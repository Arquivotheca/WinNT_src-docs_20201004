<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: filelock.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>filelock.c</h1><a href="../../d5/d3/filelock_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1989  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    FileLock.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    The file lock package provides a set of routines that allow the</span>
00012 <span class="comment">    caller to handle byte range file lock requests.  A variable of</span>
00013 <span class="comment">    type FILE_LOCK is needed for every file with byte range locking.</span>
00014 <span class="comment">    The package provides routines to set and clear locks, and to</span>
00015 <span class="comment">    test for read or write access to a file with byte range locks.</span>
00016 <span class="comment"></span>
00017 <span class="comment">    The main idea of the package is to have the file system initialize</span>
00018 <span class="comment">    a FILE_LOCK variable for every data file as its opened, and then</span>
00019 <span class="comment">    to simply call a file lock processing routine to handle all IRP's</span>
00020 <span class="comment">    with a major function code of LOCK_CONTROL.  The package is responsible</span>
00021 <span class="comment">    for keeping track of locks and for completing the LOCK_CONTROL IRPS.</span>
00022 <span class="comment">    When processing a read or write request the file system can then call</span>
00023 <span class="comment">    two query routines to check for access.</span>
00024 <span class="comment"></span>
00025 <span class="comment">    Most of the code for processing IRPS and checking for access use</span>
00026 <span class="comment">    paged pool and can encounter a page fault, therefore the check routines</span>
00027 <span class="comment">    cannot be called at DPC level.  To help servers that do call the file</span>
00028 <span class="comment">    system to do read/write operations at DPC level there is a additional</span>
00029 <span class="comment">    routine that simply checks for the existence of a lock on a file and</span>
00030 <span class="comment">    can be run at DPC level.</span>
00031 <span class="comment"></span>
00032 <span class="comment">    Concurrent access to the FILE_LOCK variable must be controlled by the</span>
00033 <span class="comment">    caller.</span>
00034 <span class="comment"></span>
00035 <span class="comment">    The functions provided in this package are as follows:</span>
00036 <span class="comment"></span>
00037 <span class="comment">      o  FsRtlInitializeFileLock - Initialize a new FILE_LOCK structure.</span>
00038 <span class="comment"></span>
00039 <span class="comment">      o  FsRtlUninitializeFileLock - Uninitialize an existing FILE_LOCK</span>
00040 <span class="comment">         structure.</span>
00041 <span class="comment"></span>
00042 <span class="comment">      o  FsRtlProcessFileLock - Process an IRP whose major function code</span>
00043 <span class="comment">         is LOCK_CONTROL.</span>
00044 <span class="comment"></span>
00045 <span class="comment">      o  FsRtlCheckLockForReadAccess - Check for read access to a range</span>
00046 <span class="comment">         of bytes in a file given an IRP.</span>
00047 <span class="comment"></span>
00048 <span class="comment">      o  FsRtlCheckLockForWriteAccess - Check for write access to a range</span>
00049 <span class="comment">         of bytes in a file given an IRP.</span>
00050 <span class="comment"></span>
00051 <span class="comment">      o  FsRtlAreThereCurrentFileLocks - Check if there are any locks</span>
00052 <span class="comment">         currently assigned to a file.</span>
00053 <span class="comment"></span>
00054 <span class="comment">      o  FsRtlGetNextFileLock - This procedure enumerates the current locks</span>
00055 <span class="comment">         of a file lock variable.</span>
00056 <span class="comment"></span>
00057 <span class="comment">      o  FsRtlFastCheckLockForRead - Check for read access to a range of</span>
00058 <span class="comment">         bytes in a file given separate parameters.</span>
00059 <span class="comment"></span>
00060 <span class="comment">      o  FsRtlFastCheckLockForWrite - Check for write access to a range of</span>
00061 <span class="comment">         bytes in a file given separate parameters.</span>
00062 <span class="comment"></span>
00063 <span class="comment">      o  FsRtlFastLock - A fast non-Irp based way to get a lock</span>
00064 <span class="comment"></span>
00065 <span class="comment">      o  FsRtlFastUnlockSingle - A fast non-Irp based way to release a single</span>
00066 <span class="comment">         lock</span>
00067 <span class="comment"></span>
00068 <span class="comment">      o  FsRtlFastUnlockAll - A fast non-Irp based way to release all locks</span>
00069 <span class="comment">         held by a file object.</span>
00070 <span class="comment"></span>
00071 <span class="comment">      o  FsRtlFastUnlockAllByKey - A fast non-Irp based way to release all</span>
00072 <span class="comment">         locks held by a file object that match a key.</span>
00073 <span class="comment"></span>
00074 <span class="comment"></span>
00075 <span class="comment">Authors:</span>
00076 <span class="comment"></span>
00077 <span class="comment">    Gary Kimura     [GaryKi]    24-Apr-1990</span>
00078 <span class="comment">    Dan Lovinger    [DanLo]     22-Sep-1995</span>
00079 <span class="comment"></span>
00080 <span class="comment">Revision History:</span>
00081 <span class="comment"></span>
00082 <span class="comment">--*/</span>
00083 
00084 <span class="preprocessor">#include "FsRtlP.h"</span>
00085 
00086 <span class="comment">//</span>
00087 <span class="comment">//  Local constants</span>
00088 <span class="comment">//</span>
00089 
00090 <span class="comment">//</span>
00091 <span class="comment">//  Local debug trace level</span>
00092 <span class="comment">//</span>
00093 
<a name="l00094"></a><a class="code" href="../../d5/d3/filelock_8c.html#a0">00094</a> <span class="preprocessor">#define Dbg                 (0x20000000)</span>
00095 <span class="preprocessor"></span>
00096 <span class="comment">//</span>
00097 <span class="comment">//  YA definition of INLINE</span>
00098 <span class="comment">//</span>
00099 
00100 <span class="preprocessor">#ifndef INLINE</span>
<a name="l00101"></a><a class="code" href="../../d5/d3/filelock_8c.html#a1">00101</a> <span class="preprocessor"></span><span class="preprocessor">#define INLINE __inline</span>
00102 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00103 <span class="preprocessor"></span>
<a name="l00104"></a><a class="code" href="../../d5/d3/filelock_8c.html#a2">00104</a> <span class="preprocessor">#define TAG_EXCLUSIVE_LOCK  'xeLF'</span>
<a name="l00105"></a><a class="code" href="../../d5/d3/filelock_8c.html#a3">00105</a> <span class="preprocessor"></span><span class="preprocessor">#define TAG_FILE_LOCK       'lfLF'</span>
<a name="l00106"></a><a class="code" href="../../d5/d3/filelock_8c.html#a4">00106</a> <span class="preprocessor"></span><span class="preprocessor">#define TAG_LOCK_INFO       'ilLF'</span>
<a name="l00107"></a><a class="code" href="../../d5/d3/filelock_8c.html#a5">00107</a> <span class="preprocessor"></span><span class="preprocessor">#define TAG_LOCKTREE_NODE   'nlLF'</span>
<a name="l00108"></a><a class="code" href="../../d5/d3/filelock_8c.html#a6">00108</a> <span class="preprocessor"></span><span class="preprocessor">#define TAG_SHARED_LOCK     'hsLF'</span>
<a name="l00109"></a><a class="code" href="../../d5/d3/filelock_8c.html#a7">00109</a> <span class="preprocessor"></span><span class="preprocessor">#define TAG_WAITING_LOCK    'lwLF'</span>
00110 <span class="preprocessor"></span>
00111 <span class="comment">//</span>
00112 <span class="comment">//  Globals</span>
00113 <span class="comment">//</span>
00114 
00115 <span class="comment">//</span>
00116 <span class="comment">//  This mutex synchronizes threads competing to initialize file lock structures.</span>
00117 <span class="comment">//</span>
00118 
<a name="l00119"></a><a class="code" href="../../d5/d3/filelock_8c.html#a12">00119</a> <a class="code" href="../../d6/d9/struct__FAST__MUTEX.html">FAST_MUTEX</a> <a class="code" href="../../d5/d3/filelock_8c.html#a12">FsRtlCreateLockInfo</a>;
00120 
00121 <span class="comment">//</span>
00122 <span class="comment">//  Lookaside lists</span>
00123 <span class="comment">//</span>
00124 <span class="comment">//  Here is a good place to note why this is still nonpaged.  We need to be able</span>
00125 <span class="comment">//  to cancel lock IRPs at DPC, and the ripple effects of this (esp. granting waiting</span>
00126 <span class="comment">//  locks and synchronizing the waiting list) implies some unfortunate realities.</span>
00127 <span class="comment">//</span>
00128 <span class="comment">//  This should be reinvestigated post NT 5.0.</span>
00129 <span class="comment">//</span>
00130 
<a name="l00131"></a><a class="code" href="../../d5/d3/filelock_8c.html#a13">00131</a> <a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html">NPAGED_LOOKASIDE_LIST</a> <a class="code" href="../../d5/d3/filelock_8c.html#a13">FsRtlSharedLockLookasideList</a>;
<a name="l00132"></a><a class="code" href="../../d5/d3/filelock_8c.html#a14">00132</a> <a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html">NPAGED_LOOKASIDE_LIST</a> <a class="code" href="../../d5/d3/filelock_8c.html#a14">FsRtlExclusiveLockLookasideList</a>;
<a name="l00133"></a><a class="code" href="../../d5/d3/filelock_8c.html#a15">00133</a> <a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html">NPAGED_LOOKASIDE_LIST</a> <a class="code" href="../../d5/d3/filelock_8c.html#a15">FsRtlWaitingLockLookasideList</a>;
<a name="l00134"></a><a class="code" href="../../d5/d3/filelock_8c.html#a16">00134</a> <a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html">NPAGED_LOOKASIDE_LIST</a> <a class="code" href="../../d5/d3/filelock_8c.html#a16">FsRtlLockTreeNodeLookasideList</a>;
<a name="l00135"></a><a class="code" href="../../d5/d3/filelock_8c.html#a17">00135</a> <a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html">NPAGED_LOOKASIDE_LIST</a> <a class="code" href="../../d5/d3/filelock_8c.html#a17">FsRtlLockInfoLookasideList</a>;
00136 
<a name="l00137"></a><a class="code" href="../../d5/d3/filelock_8c.html#a18">00137</a> <a class="code" href="../../d1/d8/struct__PAGED__LOOKASIDE__LIST.html">PAGED_LOOKASIDE_LIST</a> <a class="code" href="../../d5/d3/filelock_8c.html#a18">FsRtlFileLockLookasideList</a>;
00138 
00139 
00140 <span class="comment">//</span>
00141 <span class="comment">//  Local structures</span>
00142 <span class="comment">//</span>
00143 
00144 <span class="comment">/*++</span>
00145 <span class="comment"></span>
00146 <span class="comment">    Some of the decisions made regarding the internal datastructres may not be clear,</span>
00147 <span class="comment">    so I should discuss the evolution of this design.</span>
00148 <span class="comment"></span>
00149 <span class="comment">    The original file lock implementation was a single linked list, extended in the MP</span>
00150 <span class="comment">    case to a set of linked lists which each held locks in page-aligned segments of the</span>
00151 <span class="comment">    file. If locks spilled over these page-aligned segments the code fell back to the</span>
00152 <span class="comment">    UP single linked list. There are clearly peformance implications with substantial</span>
00153 <span class="comment">    usage of file locks, since these are mandatory locks.</span>
00154 <span class="comment"></span>
00155 <span class="comment">    This implementation goes for O(lgn) search performance by using splay trees. In order to</span>
00156 <span class="comment">    apply simple trees to this problem no node of the tree can overlap, so since shared</span>
00157 <span class="comment">    locks can in fact overlap something must be done. The solution used here is to have</span>
00158 <span class="comment">    a meta-structure contain all locks which do overlap and have the tree operations</span>
00159 <span class="comment">    split and merge these nodes of (potentially) multiple locks. This is the LOCKTREE_NODE.</span>
00160 <span class="comment">    It should be noted that the worst case add/delete lock times are still linear.</span>
00161 <span class="comment"></span>
00162 <span class="comment">    Exclusive locks pose a problem because of an asymmetry in the semantics of applying</span>
00163 <span class="comment">    locks to a file. If a process applies a shared lock to a section of a file, no application</span>
00164 <span class="comment">    of an exclusive lock to bytes in that section can succeed. However, if a process</span>
00165 <span class="comment">    applies an exclusive lock, that same process can get a shared lock as well. This</span>
00166 <span class="comment">    behavior conflicts with the mergeable node since by applying locks in a given order</span>
00167 <span class="comment">    we can get a node to have many shared locks and "rogue" exclusive locks which are</span>
00168 <span class="comment">    hidden except to a linear search, which is what we're designing out. So exclusive locks</span>
00169 <span class="comment">    must be seperated from the shared locks. This is the reason we have two lock trees.</span>
00170 <span class="comment"></span>
00171 <span class="comment">    Since we have two lock trees, the average case search is now O(lgm + lgn) for m exlcusive</span>
00172 <span class="comment">    and n shared. Also, since no exclusive locks can ever overlap each other it is now</span>
00173 <span class="comment">    unreasonable to have them use LOCKTREE_NODES - this would impose a memory penalty on code</span>
00174 <span class="comment">    which was weighted toward exclusive locks. This means that the exclusive locks should</span>
00175 <span class="comment">    be wired into the splay tree directly. So we need an RTL_SPLAY_LINKS, but this is 64 bits</span>
00176 <span class="comment">    bigger than the SINGLE_LIST_ENTRY which shared locks need (to be threaded off of a</span>
00177 <span class="comment">    LOCKTREE_NODE), which dictates seperate shared and exclusive lock structures to avoid</span>
00178 <span class="comment">    penalizing code which was weighted toward shared locks by having that wasted 64 bits per</span>
00179 <span class="comment">    lock. Hence EX_LOCK and SH_LOCK (they actually occupy different pool block sizes).</span>
00180 <span class="comment"></span>
00181 <span class="comment">    Zero length locks are a bizzare creation, and there is some errata relating to them. It</span>
00182 <span class="comment">    used to be the case that zero length locks would be granted without exception. This is</span>
00183 <span class="comment">    flat out bogus, and has been changed (NT 4.0). They are now subject to failure if they</span>
00184 <span class="comment">    occupy a point interior to a lock of a type that can cause an access failure. A particular</span>
00185 <span class="comment">    case that was previously allowed was a zero length exclusive lock interior to another</span>
00186 <span class="comment">    exclusive lock.</span>
00187 <span class="comment"></span>
00188 <span class="comment">    Zero length locks cannot conflict with zero length locks. This is the subject of some</span>
00189 <span class="comment">    special code throughout the module. Note especially that zero length exclusive locks can</span>
00190 <span class="comment">    "overlap". Zero length locks also cannot conflict at the starting byte and ending byte of a</span>
00191 <span class="comment">    range - they are points on the line.</span>
00192 <span class="comment"></span>
00193 <span class="comment">--*/</span>
00194 
<a name="l00195"></a><a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html">00195</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html">_LOCKTREE_NODE</a> {
00196 
00197     <span class="comment">//</span>
00198     <span class="comment">//  List of locks under this node</span>
00199     <span class="comment">//</span>
00200 
00201     SINGLE_LIST_ENTRY <a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o0">Locks</a>;
00202 
00203     <span class="comment">//</span>
00204     <span class="comment">//  Flag whether this node is holey as a result of a failed allocation</span>
00205     <span class="comment">//  during a node split.  During deletion of shared locks, we may</span>
00206     <span class="comment">//  discover that the locks in the node no longer have total overlap</span>
00207     <span class="comment">//  but cannot allocate resources to create the new nodes in the tree.</span>
00208     <span class="comment">//</span>
00209     <span class="comment">//  Any insert into the region occupied by a holey node will finish by</span>
00210     <span class="comment">//  trying to split a holey node up.  Any split or access check in a</span>
00211     <span class="comment">//  holey node must completely traverse the locks at the node.</span>
00212     <span class="comment">//</span>
00213 
00214     BOOLEAN <a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o1">HoleyNode</a>;
00215 
00216     <span class="comment">//</span>
00217     <span class="comment">//  Maximum byte offset affected by locks in this node.</span>
00218     <span class="comment">//  Note: minimum offset is the starting offset of the</span>
00219     <span class="comment">//  first lock at this node.</span>
00220     <span class="comment">//</span>
00221 
00222     ULONGLONG <a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o2">Extent</a>;
00223 
00224     <span class="comment">//</span>
00225     <span class="comment">//  Splay tree links to parent, lock groups strictly less than</span>
00226     <span class="comment">//  and lock groups strictly greater than locks in this node.</span>
00227     <span class="comment">//</span>
00228 
00229     RTL_SPLAY_LINKS <a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o3">Links</a>;
00230 
00231     <span class="comment">//</span>
00232     <span class="comment">//  Last lock in the list (useful for node collapse under insert)</span>
00233     <span class="comment">//</span>
00234 
00235     SINGLE_LIST_ENTRY <a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o4">Tail</a>;
00236 
00237 } <a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html">LOCKTREE_NODE</a>, *<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html">PLOCKTREE_NODE</a>;
00238 
00239 <span class="comment">//</span>
00240 <span class="comment">//  Define the threading wrappers for lock information</span>
00241 <span class="comment">//</span>
00242 
00243 <span class="comment">//</span>
00244 <span class="comment">//  Each shared lock record corresponds to a current granted lock and is</span>
00245 <span class="comment">//  maintained in a queue off of a LOCKTREE_NODE's Locks list.  The list</span>
00246 <span class="comment">//  of current locks is ordered according to the starting byte of the lock.</span>
00247 <span class="comment">//</span>
00248 
<a name="l00249"></a><a class="code" href="../../d8/d2/struct__SH__LOCK.html">00249</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d8/d2/struct__SH__LOCK.html">_SH_LOCK</a> {
00250 
00251     <span class="comment">//</span>
00252     <span class="comment">//  The link structures for the list of shared locks.</span>
00253     <span class="comment">//</span>
00254 
00255     SINGLE_LIST_ENTRY   <a class="code" href="../../d8/d2/struct__SH__LOCK.html#o0">Link</a>;
00256 
00257     <span class="comment">//</span>
00258     <span class="comment">//  The actual locked range</span>
00259     <span class="comment">//</span>
00260 
00261     <a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html">FILE_LOCK_INFO</a> <a class="code" href="../../d8/d2/struct__SH__LOCK.html#o1">LockInfo</a>;
00262 
00263 } <a class="code" href="../../d8/d2/struct__SH__LOCK.html">SH_LOCK</a>, *<a class="code" href="../../d8/d2/struct__SH__LOCK.html">PSH_LOCK</a>;
00264 
00265 <span class="comment">//</span>
00266 <span class="comment">//  Each exclusive lock record corresponds to a current granted lock and is</span>
00267 <span class="comment">//  threaded into the exclusive lock tree.</span>
00268 <span class="comment">//</span>
00269 
<a name="l00270"></a><a class="code" href="../../d7/d7/struct__EX__LOCK.html">00270</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d7/d7/struct__EX__LOCK.html">_EX_LOCK</a> {
00271 
00272     <span class="comment">//</span>
00273     <span class="comment">//  The link structures for the list of current locks.</span>
00274     <span class="comment">//</span>
00275 
00276     RTL_SPLAY_LINKS     <a class="code" href="../../d7/d7/struct__EX__LOCK.html#o0">Links</a>;
00277 
00278     <span class="comment">//</span>
00279     <span class="comment">//  The actual locked range</span>
00280     <span class="comment">//</span>
00281 
00282     <a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html">FILE_LOCK_INFO</a> <a class="code" href="../../d7/d7/struct__EX__LOCK.html#o1">LockInfo</a>;
00283 
00284 } <a class="code" href="../../d7/d7/struct__EX__LOCK.html">EX_LOCK</a>, *<a class="code" href="../../d7/d7/struct__EX__LOCK.html">PEX_LOCK</a>;
00285 
00286 <span class="comment">//</span>
00287 <span class="comment">//  Each Waiting lock record corresponds to a IRP that is waiting for a</span>
00288 <span class="comment">//  lock to be granted and is maintained in a queue off of the FILE_LOCK's</span>
00289 <span class="comment">//  WaitingLockQueue list.</span>
00290 <span class="comment">//</span>
00291 
<a name="l00292"></a><a class="code" href="../../d1/d8/struct__WAITING__LOCK.html">00292</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d1/d8/struct__WAITING__LOCK.html">_WAITING_LOCK</a> {
00293 
00294     <span class="comment">//</span>
00295     <span class="comment">//  The link structures for the list of waiting locks</span>
00296     <span class="comment">//</span>
00297 
00298     SINGLE_LIST_ENTRY   <a class="code" href="../../d1/d8/struct__WAITING__LOCK.html#o0">Link</a>;
00299 
00300     <span class="comment">//</span>
00301     <span class="comment">//  The context field to use when completing the irp via the alternate</span>
00302     <span class="comment">//  routine</span>
00303     <span class="comment">//</span>
00304 
00305     PVOID <a class="code" href="../../d1/d8/struct__WAITING__LOCK.html#o1">Context</a>;
00306 
00307     <span class="comment">//</span>
00308     <span class="comment">//  A pointer to the IRP that is waiting for a lock</span>
00309     <span class="comment">//</span>
00310 
00311     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>;
00312 
00313 } <a class="code" href="../../d1/d8/struct__WAITING__LOCK.html">WAITING_LOCK</a>, *<a class="code" href="../../d1/d8/struct__WAITING__LOCK.html">PWAITING_LOCK</a>;
00314 
00315 
00316 <span class="comment">//</span>
00317 <span class="comment">//  Each lock or waiting onto some lock queue.</span>
00318 <span class="comment">//</span>
00319 
<a name="l00320"></a><a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html">00320</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html">_LOCK_QUEUE</a> {
00321 
00322     <span class="comment">//</span>
00323     <span class="comment">// Sync to guard queue access.</span>
00324     <span class="comment">//</span>
00325 
00326     KSPIN_LOCK  <a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o0">QueueSpinLock</a>;
00327 
00328     <span class="comment">//</span>
00329     <span class="comment">//  The items contain locktrees of the current granted</span>
00330     <span class="comment">//  locks and a list of the waiting locks</span>
00331     <span class="comment">//</span>
00332 
00333     PRTL_SPLAY_LINKS <a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o1">SharedLockTree</a>;
00334     PRTL_SPLAY_LINKS <a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o2">ExclusiveLockTree</a>;
00335     SINGLE_LIST_ENTRY <a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o3">WaitingLocks</a>;
00336     SINGLE_LIST_ENTRY <a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o4">WaitingLocksTail</a>;
00337 
00338 } <a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html">LOCK_QUEUE</a>, *<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html">PLOCK_QUEUE</a>;
00339 
00340 
00341 <span class="comment">//</span>
00342 <span class="comment">//  Any file_lock which has had a lock applied gets a non-paged pool</span>
00343 <span class="comment">//  structure which tracks the current locks applied to the file</span>
00344 <span class="comment">//</span>
00345 
<a name="l00346"></a><a class="code" href="../../d6/d2/struct__LOCK__INFO.html">00346</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d6/d2/struct__LOCK__INFO.html">_LOCK_INFO</a> {
00347 
00348     <span class="comment">//</span>
00349     <span class="comment">//  LowestLockOffset retains the offset of the lowest existing</span>
00350     <span class="comment">//  lock.  This facilitates a quick check to see if a read or</span>
00351     <span class="comment">//  write can proceed without locking the lock database.  This is</span>
00352     <span class="comment">//  helpful for applications that use mirrored locks -- all locks</span>
00353     <span class="comment">//  are higher than file data.</span>
00354     <span class="comment">//</span>
00355     <span class="comment">//  If the lowest lock has an offset &gt; 0xffffffff, LowestLockOffset</span>
00356     <span class="comment">//  is set to 0xffffffff.</span>
00357     <span class="comment">//</span>
00358 
00359     ULONG <a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o0">LowestLockOffset</a>;
00360 
00361     <span class="comment">//</span>
00362     <span class="comment">//  The optional procedure to call to complete a request</span>
00363     <span class="comment">//</span>
00364 
00365     <a class="code" href="../../d1/d8/fsrtl_8h.html#a65">PCOMPLETE_LOCK_IRP_ROUTINE</a> <a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o1">CompleteLockIrpRoutine</a>;
00366 
00367     <span class="comment">//</span>
00368     <span class="comment">//  The optional procedure to call when unlocking a byte range</span>
00369     <span class="comment">//</span>
00370 
00371     <a class="code" href="../../d1/d8/fsrtl_8h.html#a66">PUNLOCK_ROUTINE</a> <a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o2">UnlockRoutine</a>;
00372 
00373     <span class="comment">//</span>
00374     <span class="comment">// The locked ranges</span>
00375     <span class="comment">//</span>
00376 
00377     <a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html">LOCK_QUEUE</a>  <a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>;
00378 
00379 } <a class="code" href="../../d6/d2/struct__LOCK__INFO.html">LOCK_INFO</a>, *<a class="code" href="../../d6/d2/struct__LOCK__INFO.html">PLOCK_INFO</a>;
00380 
00381 <span class="comment">//</span>
00382 <span class="comment">//  Local Macros</span>
00383 <span class="comment">//</span>
00384 
00385 <span class="comment">//</span>
00386 <span class="comment">//  The following macros sort out the allocation of internal structures.</span>
00387 <span class="comment">//</span>
00388 
00389 <a class="code" href="../../d5/d3/filelock_8c.html#a1">INLINE</a>
00390 <a class="code" href="../../d5/d3/filelock_8c.html#a22">PSH_LOCK</a>
<a name="l00391"></a><a class="code" href="../../d5/d3/filelock_8c.html#a31">00391</a> <a class="code" href="../../d5/d3/filelock_8c.html#a31">FsRtlAllocateSharedLock</a> (
00392     VOID
00393     )
00394 {
00395     <span class="keywordflow">return</span> (<a class="code" href="../../d5/d3/filelock_8c.html#a22">PSH_LOCK</a>) <a class="code" href="../../d5/d8/ex_8h.html#a248">ExAllocateFromNPagedLookasideList</a>( &amp;<a class="code" href="../../d5/d3/filelock_8c.html#a13">FsRtlSharedLockLookasideList</a> );
00396 }
00397 
00398 <a class="code" href="../../d5/d3/filelock_8c.html#a1">INLINE</a>
00399 <a class="code" href="../../d5/d3/filelock_8c.html#a24">PEX_LOCK</a>
<a name="l00400"></a><a class="code" href="../../d5/d3/filelock_8c.html#a32">00400</a> <a class="code" href="../../d5/d3/filelock_8c.html#a32">FsRtlAllocateExclusiveLock</a> (
00401     VOID
00402     )
00403 {
00404     <span class="keywordflow">return</span> (<a class="code" href="../../d5/d3/filelock_8c.html#a24">PEX_LOCK</a>) <a class="code" href="../../d5/d8/ex_8h.html#a248">ExAllocateFromNPagedLookasideList</a>( &amp;<a class="code" href="../../d5/d3/filelock_8c.html#a14">FsRtlExclusiveLockLookasideList</a> );
00405 }
00406 
00407 <a class="code" href="../../d5/d3/filelock_8c.html#a1">INLINE</a>
00408 <a class="code" href="../../d5/d3/filelock_8c.html#a26">PWAITING_LOCK</a>
<a name="l00409"></a><a class="code" href="../../d5/d3/filelock_8c.html#a33">00409</a> <a class="code" href="../../d5/d3/filelock_8c.html#a33">FsRtlAllocateWaitingLock</a> (
00410     VOID
00411     )
00412 {
00413     <span class="keywordflow">return</span> (<a class="code" href="../../d5/d3/filelock_8c.html#a26">PWAITING_LOCK</a>) <a class="code" href="../../d5/d8/ex_8h.html#a248">ExAllocateFromNPagedLookasideList</a>( &amp;<a class="code" href="../../d5/d3/filelock_8c.html#a15">FsRtlWaitingLockLookasideList</a> );
00414 }
00415 
00416 <a class="code" href="../../d5/d3/filelock_8c.html#a1">INLINE</a>
00417 <a class="code" href="../../d5/d3/filelock_8c.html#a20">PLOCKTREE_NODE</a>
<a name="l00418"></a><a class="code" href="../../d5/d3/filelock_8c.html#a34">00418</a> <a class="code" href="../../d5/d3/filelock_8c.html#a34">FsRtlAllocateLockTreeNode</a> (
00419     VOID
00420     )
00421 {
00422     <span class="keywordflow">return</span> (<a class="code" href="../../d5/d3/filelock_8c.html#a20">PLOCKTREE_NODE</a>) <a class="code" href="../../d5/d8/ex_8h.html#a248">ExAllocateFromNPagedLookasideList</a>( &amp;<a class="code" href="../../d5/d3/filelock_8c.html#a16">FsRtlLockTreeNodeLookasideList</a> );
00423 }
00424 
00425 <a class="code" href="../../d5/d3/filelock_8c.html#a1">INLINE</a>
00426 <a class="code" href="../../d5/d3/filelock_8c.html#a30">PLOCK_INFO</a>
<a name="l00427"></a><a class="code" href="../../d5/d3/filelock_8c.html#a35">00427</a> <a class="code" href="../../d5/d3/filelock_8c.html#a35">FsRtlAllocateLockInfo</a> (
00428     VOID
00429     )
00430 {
00431     <span class="keywordflow">return</span> (<a class="code" href="../../d5/d3/filelock_8c.html#a30">PLOCK_INFO</a>) <a class="code" href="../../d5/d8/ex_8h.html#a248">ExAllocateFromNPagedLookasideList</a>( &amp;<a class="code" href="../../d5/d3/filelock_8c.html#a17">FsRtlLockInfoLookasideList</a> );
00432 }
00433 
00434 
00435 <a class="code" href="../../d5/d3/filelock_8c.html#a1">INLINE</a>
00436 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00437"></a><a class="code" href="../../d5/d3/filelock_8c.html#a36">00437</a> <a class="code" href="../../d5/d3/filelock_8c.html#a36">FsRtlFreeSharedLock</a> (
00438     IN PSH_LOCK C
00439     )
00440 {
00441     <a class="code" href="../../d5/d8/ex_8h.html#a249">ExFreeToNPagedLookasideList</a>( &amp;<a class="code" href="../../d5/d3/filelock_8c.html#a13">FsRtlSharedLockLookasideList</a>, (PVOID)C );
00442 }
00443 
00444 <a class="code" href="../../d5/d3/filelock_8c.html#a1">INLINE</a>
00445 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00446"></a><a class="code" href="../../d5/d3/filelock_8c.html#a37">00446</a> <a class="code" href="../../d5/d3/filelock_8c.html#a37">FsRtlFreeExclusiveLock</a> (
00447     IN PEX_LOCK C
00448     )
00449 {
00450     <a class="code" href="../../d5/d8/ex_8h.html#a249">ExFreeToNPagedLookasideList</a>( &amp;<a class="code" href="../../d5/d3/filelock_8c.html#a14">FsRtlExclusiveLockLookasideList</a>, (PVOID)C );
00451 }
00452 
00453 <a class="code" href="../../d5/d3/filelock_8c.html#a1">INLINE</a>
00454 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00455"></a><a class="code" href="../../d5/d3/filelock_8c.html#a38">00455</a> <a class="code" href="../../d5/d3/filelock_8c.html#a38">FsRtlFreeWaitingLock</a> (
00456     IN PWAITING_LOCK C
00457     )
00458 {
00459     <a class="code" href="../../d5/d8/ex_8h.html#a249">ExFreeToNPagedLookasideList</a>( &amp;<a class="code" href="../../d5/d3/filelock_8c.html#a15">FsRtlWaitingLockLookasideList</a>, (PVOID)C );
00460 }
00461 
00462 <a class="code" href="../../d5/d3/filelock_8c.html#a1">INLINE</a>
00463 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00464"></a><a class="code" href="../../d5/d3/filelock_8c.html#a39">00464</a> <a class="code" href="../../d5/d3/filelock_8c.html#a39">FsRtlFreeLockTreeNode</a> (
00465     IN PLOCKTREE_NODE C
00466     )
00467 {
00468     <a class="code" href="../../d5/d8/ex_8h.html#a249">ExFreeToNPagedLookasideList</a>( &amp;<a class="code" href="../../d5/d3/filelock_8c.html#a16">FsRtlLockTreeNodeLookasideList</a>, (PVOID)C );
00469 }
00470 
00471 <a class="code" href="../../d5/d3/filelock_8c.html#a1">INLINE</a>
00472 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00473"></a><a class="code" href="../../d5/d3/filelock_8c.html#a40">00473</a> <a class="code" href="../../d5/d3/filelock_8c.html#a40">FsRtlFreeLockInfo</a> (
00474     IN PLOCK_INFO C
00475     )
00476 {
00477     <a class="code" href="../../d5/d8/ex_8h.html#a249">ExFreeToNPagedLookasideList</a>( &amp;<a class="code" href="../../d5/d3/filelock_8c.html#a17">FsRtlLockInfoLookasideList</a>, (PVOID)C );
00478 }
00479 
00480 
<a name="l00481"></a><a class="code" href="../../d5/d3/filelock_8c.html#a8">00481</a> <span class="preprocessor">#define FsRtlAcquireLockQueue(a,b)                  \</span>
00482 <span class="preprocessor">        ExAcquireSpinLock(&amp;(a)-&gt;QueueSpinLock, b);</span>
00483 <span class="preprocessor"></span>
<a name="l00484"></a><a class="code" href="../../d5/d3/filelock_8c.html#a9">00484</a> <span class="preprocessor">#define FsRtlReacquireLockQueue(a,b,c)              \</span>
00485 <span class="preprocessor">        ExAcquireSpinLock(&amp;(b)-&gt;QueueSpinLock, c);</span>
00486 <span class="preprocessor"></span>
<a name="l00487"></a><a class="code" href="../../d5/d3/filelock_8c.html#a10">00487</a> <span class="preprocessor">#define FsRtlReleaseLockQueue(a,b)                  \</span>
00488 <span class="preprocessor">        ExReleaseSpinLock(&amp;(a)-&gt;QueueSpinLock, b);</span>
00489 <span class="preprocessor"></span>
00490 
00491 <span class="comment">//</span>
00492 <span class="comment">//  Generic way to complete a lock IRP.  We like to treat this as an overloaded</span>
00493 <span class="comment">//  function so it can be used with LOCK_INFO and FILE_LOCK structures, as</span>
00494 <span class="comment">//  appropriate using paged/nonpaged pool to discover the completion routine.</span>
00495 <span class="comment">//</span>
00496 
<a name="l00497"></a><a class="code" href="../../d5/d3/filelock_8c.html#a11">00497</a> <span class="preprocessor">#define FsRtlCompleteLockIrp( A, B, C, D, E, F )                \</span>
00498 <span class="preprocessor">        FsRtlCompleteLockIrpReal( (A)-&gt;CompleteLockIrpRoutine,  \</span>
00499 <span class="preprocessor">                                  B,                            \</span>
00500 <span class="preprocessor">                                  C,                            \</span>
00501 <span class="preprocessor">                                  D,                            \</span>
00502 <span class="preprocessor">                                  E,                            \</span>
00503 <span class="preprocessor">                                  F )</span>
00504 <span class="preprocessor"></span>
00505 <a class="code" href="../../d5/d3/filelock_8c.html#a1">INLINE</a>
00506 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00507"></a><a class="code" href="../../d5/d3/filelock_8c.html#a41">00507</a> <a class="code" href="../../d5/d3/filelock_8c.html#a41">FsRtlCompleteLockIrpReal</a> (
00508     IN <a class="code" href="../../d1/d8/fsrtl_8h.html#a65">PCOMPLETE_LOCK_IRP_ROUTINE</a> CompleteLockIrpRoutine,
00509     IN PVOID Context,
00510     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
00511     IN NTSTATUS Status,
00512     IN PNTSTATUS NewStatus,
00513     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject
00514     )
00515 {
00516     <span class="comment">//</span>
00517     <span class="comment">//  This fools the compiler into generating the Status only once</span>
00518     <span class="comment">//  if it is calculated from an expression.</span>
00519     <span class="comment">//</span>
00520 
00521     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> LocalStatus = <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00522 
00523     <span class="keywordflow">if</span> (CompleteLockIrpRoutine != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00524 
00525         <span class="keywordflow">if</span> (FileObject != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00526 
00527             FileObject-&gt;LastLock = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00528         }
00529 
00530         <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status = LocalStatus;
00531         *NewStatus = CompleteLockIrpRoutine( Context, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
00532 
00533     } <span class="keywordflow">else</span> {
00534 
00535         <a class="code" href="../../d1/d8/fsrtl_8h.html#a47">FsRtlCompleteRequest</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, LocalStatus );
00536         *NewStatus = LocalStatus;
00537     }
00538 }
00539 
00540 <span class="comment">//</span>
00541 <span class="comment">//  Define USERTEST to get a version which compiles into a usermode test rig</span>
00542 <span class="comment">//</span>
00543 
00544 <span class="preprocessor">#ifdef USERTEST</span>
00545 <span class="preprocessor"></span><span class="preprocessor">#include &lt;stdio.h&gt;</span>
00546 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00547 <span class="preprocessor">#undef FsRtlAllocateSharedLock</span>
00548 <span class="preprocessor"></span><span class="preprocessor">#undef FsRtlAllocateExclusiveLock</span>
00549 <span class="preprocessor"></span><span class="preprocessor">#undef FsRtlAllocateLockTreeNode</span>
00550 <span class="preprocessor"></span><span class="preprocessor">#undef FsRtlAllocateWaitingLock</span>
00551 <span class="preprocessor"></span><span class="preprocessor">#undef FsRtlFreeSharedLock</span>
00552 <span class="preprocessor"></span><span class="preprocessor">#undef FsRtlFreeExclusiveLock</span>
00553 <span class="preprocessor"></span><span class="preprocessor">#undef FsRtlFreeLockTreeNode</span>
00554 <span class="preprocessor"></span><span class="preprocessor">#undef FsRtlFreeWaitingLock</span>
00555 <span class="preprocessor"></span><span class="preprocessor">#undef FsRtlAcquireLockQueue</span>
00556 <span class="preprocessor"></span><span class="preprocessor">#undef FsRtlReacquireLockQueue</span>
00557 <span class="preprocessor"></span><span class="preprocessor">#undef FsRtlReleaseLockQueue</span>
00558 <span class="preprocessor"></span><span class="preprocessor">#undef FsRtlCompleteLockIrp</span>
00559 <span class="preprocessor"></span><span class="preprocessor">#undef IoCompleteRequest</span>
00560 <span class="preprocessor"></span>
00561 <span class="preprocessor">#define FsRtlAllocateSharedLock( C )        (PSH_LOCK)malloc(sizeof(SH_LOCK))</span>
00562 <span class="preprocessor"></span><span class="preprocessor">#define FsRtlAllocateExclusiveLock( C )     (PEX_LOCK)malloc(sizeof(EX_LOCK))</span>
00563 <span class="preprocessor"></span><span class="preprocessor">#define FsRtlAllocateLockTreeNode( C )      (PLOCKTREE_NODE)malloc(sizeof(LOCKTREE_NODE))</span>
00564 <span class="preprocessor"></span><span class="preprocessor">#define FsRtlAllocateWaitingLock( C )       (PWAITING_LOCK)malloc(sizeof(WAITING_LOCK))</span>
00565 <span class="preprocessor"></span><span class="preprocessor">#define FsRtlAllocateLockInfo( C )          (PLOCK_INFO)malloc(sizeof(LOCK_INFO))</span>
00566 <span class="preprocessor"></span><span class="preprocessor">#define FsRtlFreeSharedLock( C )            free(C)</span>
00567 <span class="preprocessor"></span><span class="preprocessor">#define FsRtlFreeExclusiveLock( C )         free(C)</span>
00568 <span class="preprocessor"></span><span class="preprocessor">#define FsRtlFreeLockTreeNode( C )          free(C)</span>
00569 <span class="preprocessor"></span><span class="preprocessor">#define FsRtlFreeWaitingLock( C )           free(C)</span>
00570 <span class="preprocessor"></span><span class="preprocessor">#define FsRtlFreeLockInfo( C )              free(C)</span>
00571 <span class="preprocessor"></span><span class="preprocessor">#define FsRtlAcquireLockQueue(a,b)          (*(b) = '\0')</span>
00572 <span class="preprocessor"></span><span class="preprocessor">#define FsRtlReacquireLockQueue(a,b,c)      (*(c) = '\0')</span>
00573 <span class="preprocessor"></span><span class="preprocessor">#define FsRtlReleaseLockQueue(a,b)</span>
00574 <span class="preprocessor"></span><span class="preprocessor">#define FsRtlCompleteLockIrp(_FileLock, _Context, _Irp, _Status, _NewStatus, _FileObject)   \</span>
00575 <span class="preprocessor">    {                                                                                       \</span>
00576 <span class="preprocessor">        DbgBreakPoint();                                                                    \</span>
00577 <span class="preprocessor">        *_NewStatus = STATUS_SUCCESS;                                                       \</span>
00578 <span class="preprocessor">    }</span>
00579 <span class="preprocessor"></span>
00580 <span class="preprocessor">#define ExReleaseFastMutex(M)</span>
00581 <span class="preprocessor"></span><span class="preprocessor">#define ExAcquireFastMutex(M)</span>
00582 <span class="preprocessor"></span><span class="preprocessor">#define KeInitializeSpinLock(L)</span>
00583 <span class="preprocessor"></span><span class="preprocessor">#define KfRaiseIrql(L)                      ('\0')</span>
00584 <span class="preprocessor"></span><span class="preprocessor">#define KfLowerIrql(I)</span>
00585 <span class="preprocessor"></span><span class="preprocessor">#define IoAcquireCancelSpinLock(I)</span>
00586 <span class="preprocessor"></span><span class="preprocessor">#define IoReleaseCancelSpinLock(I)</span>
00587 <span class="preprocessor"></span><span class="preprocessor">#define IoCompleteRequest(I, S)</span>
00588 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00589 <span class="preprocessor"></span>
00590 <span class="comment">//</span>
00591 <span class="comment">//  The following routines are private to this module</span>
00592 <span class="comment">//</span>
00593 
00594 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00595 <a class="code" href="../../d5/d3/filelock_8c.html#a72">FsRtlSplitLocks</a> (
00596     IN PLOCKTREE_NODE ParentNode,
00597     IN PSINGLE_LIST_ENTRY *pStartLink,
00598     IN PLARGE_INTEGER LastShadowedByte,
00599     IN PLARGE_INTEGER GlueOffset
00600     );
00601 
00602 PRTL_SPLAY_LINKS
00603 <a class="code" href="../../d5/d3/filelock_8c.html#a43">FsRtlFindFirstOverlappingSharedNode</a> (
00604     IN PRTL_SPLAY_LINKS        Tree,
00605     IN PLARGE_INTEGER          StartingByte,
00606     IN PLARGE_INTEGER          EndingByte,
00607     IN OUT PRTL_SPLAY_LINKS    *LastEdgeNode,
00608     IN OUT PBOOLEAN            GreaterThan
00609     );
00610 
00611 PRTL_SPLAY_LINKS
00612 <a class="code" href="../../d5/d3/filelock_8c.html#a44">FsRtlFindFirstOverlappingExclusiveNode</a> (
00613     IN PRTL_SPLAY_LINKS        Tree,
00614     IN PLARGE_INTEGER          StartingByte,
00615     IN PLARGE_INTEGER          EndingByte,
00616     IN OUT PRTL_SPLAY_LINKS    *LastEdgeNode,
00617     IN OUT PBOOLEAN            GreaterThan
00618     );
00619 
00620 <a class="code" href="../../d5/d3/filelock_8c.html#a22">PSH_LOCK</a>
00621 <a class="code" href="../../d5/d3/filelock_8c.html#a45">FsRtlFindFirstOverlapInNode</a> (
00622     IN PLOCKTREE_NODE Node,
00623     IN PLARGE_INTEGER StartingByte,
00624     IN PLARGE_INTEGER EndingByte
00625     );
00626 
00627 BOOLEAN
00628 <a class="code" href="../../d5/d3/filelock_8c.html#a46">FsRtlPrivateInsertLock</a> (
00629     IN PLOCK_INFO LockInfo,
00630     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00631     IN <a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html">PFILE_LOCK_INFO</a> FileLockInfo
00632     );
00633 
00634 BOOLEAN
00635 <a class="code" href="../../d5/d3/filelock_8c.html#a47">FsRtlPrivateInsertSharedLock</a> (
00636     IN PLOCK_QUEUE LockQueue,
00637     IN PSH_LOCK NewLock
00638     );
00639 
00640 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00641 <a class="code" href="../../d5/d3/filelock_8c.html#a48">FsRtlPrivateInsertExclusiveLock</a> (
00642     IN PLOCK_QUEUE LockQueue,
00643     IN PEX_LOCK NewLock
00644     );
00645 
00646 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00647 <a class="code" href="../../d5/d3/filelock_8c.html#a49">FsRtlPrivateCheckWaitingLocks</a> (
00648     IN PLOCK_INFO   LockInfo,
00649     IN PLOCK_QUEUE  LockQueue,
00650     IN KIRQL        OldIrql
00651     );
00652 
00653 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00654 <a class="code" href="../../d5/d3/filelock_8c.html#a50">FsRtlPrivateCancelFileLockIrp</a> (
00655     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
00656     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
00657     );
00658 
00659 BOOLEAN
00660 <a class="code" href="../../d5/d3/filelock_8c.html#a51">FsRtlPrivateCheckForExclusiveLockAccess</a> (
00661     IN PLOCK_QUEUE LockInfo,
00662     IN <a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html">PFILE_LOCK_INFO</a> FileLockInfo
00663     );
00664 
00665 BOOLEAN
00666 <a class="code" href="../../d5/d3/filelock_8c.html#a52">FsRtlPrivateCheckForSharedLockAccess</a> (
00667     IN PLOCK_QUEUE LockInfo,
00668     IN <a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html">PFILE_LOCK_INFO</a> FileLockInfo
00669     );
00670 
00671 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00672 <a class="code" href="../../d5/d3/filelock_8c.html#a53">FsRtlPrivateFastUnlockAll</a> (
00673     IN <a class="code" href="../../d7/d1/struct__FILE__LOCK.html">PFILE_LOCK</a> FileLock,
00674     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00675     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> ProcessId,
00676     IN ULONG Key,
00677     IN BOOLEAN MatchKey,
00678     IN PVOID Context OPTIONAL
00679     );
00680 
00681 BOOLEAN
00682 <a class="code" href="../../d5/d3/filelock_8c.html#a54">FsRtlPrivateInitializeFileLock</a> (
00683     IN <a class="code" href="../../d7/d1/struct__FILE__LOCK.html">PFILE_LOCK</a>   FileLock,
00684     IN BOOLEAN ViaFastCall
00685     );
00686 
00687 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00688 <a class="code" href="../../d5/d3/filelock_8c.html#a55">FsRtlPrivateRemoveLock</a> (
00689     IN PLOCK_INFO LockInfo,
00690     IN <a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html">PFILE_LOCK_INFO</a>,
00691     IN BOOLEAN CheckForWaiters
00692     );
00693 
00694 BOOLEAN
00695 <a class="code" href="../../d5/d3/filelock_8c.html#a56">FsRtlCheckNoSharedConflict</a> (
00696    IN PLOCK_QUEUE LockQueue,
00697    IN PLARGE_INTEGER Starting,
00698    IN PLARGE_INTEGER Ending
00699    );
00700 
00701 BOOLEAN
00702 <a class="code" href="../../d5/d3/filelock_8c.html#a57">FsRtlCheckNoExclusiveConflict</a> (
00703     IN PLOCK_QUEUE LockQueue,
00704     IN PLARGE_INTEGER Starting,
00705     IN PLARGE_INTEGER Ending,
00706     IN ULONG Key,
00707     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00708     IN PVOID ProcessId
00709     );
00710 
00711 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00712 <a class="code" href="../../d5/d3/filelock_8c.html#a58">FsRtlPrivateResetLowestLockOffset</a> (
00713     PLOCK_INFO LockInfo
00714     );
00715 
00716 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00717 <a class="code" href="../../d5/d3/filelock_8c.html#a59">FsRtlFastUnlockSingleShared</a> (
00718     IN PLOCK_INFO LockInfo,
00719     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00720     IN LARGE_INTEGER UNALIGNED *FileOffset,
00721     IN PLARGE_INTEGER Length,
00722     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> ProcessId,
00723     IN ULONG Key,
00724     IN PVOID Context OPTIONAL,
00725     IN BOOLEAN IgnoreUnlockRoutine,
00726     IN BOOLEAN CheckForWaiters
00727     );
00728 
00729 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00730 <a class="code" href="../../d5/d3/filelock_8c.html#a60">FsRtlFastUnlockSingleExclusive</a> (
00731     IN PLOCK_INFO LockInfo,
00732     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00733     IN LARGE_INTEGER UNALIGNED *FileOffset,
00734     IN PLARGE_INTEGER Length,
00735     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> ProcessId,
00736     IN ULONG Key,
00737     IN PVOID Context OPTIONAL,
00738     IN BOOLEAN IgnoreUnlockRoutine,
00739     IN BOOLEAN CheckForWaiters
00740     );
00741 
00742 
00743 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00744"></a><a class="code" href="../../d3/d8/fsrtlp_8h.html#a25">00744</a> <a class="code" href="../../d3/d8/fsrtlp_8h.html#a25">FsRtlInitializeFileLocks</a> (
00745     VOID
00746     )
00747 <span class="comment">/*++</span>
00748 <span class="comment"></span>
00749 <span class="comment">Routine Description:</span>
00750 <span class="comment"></span>
00751 <span class="comment">    Initializes the global portion of the filelock package.</span>
00752 <span class="comment"></span>
00753 <span class="comment">Arguments:</span>
00754 <span class="comment"></span>
00755 <span class="comment">    None</span>
00756 <span class="comment"></span>
00757 <span class="comment">Return Value:</span>
00758 <span class="comment"></span>
00759 <span class="comment">    None.</span>
00760 <span class="comment"></span>
00761 <span class="comment">--*/</span>
00762 {
00763 <span class="preprocessor">#ifndef USERTEST</span>
00764 <span class="preprocessor"></span>
00765     <span class="comment">//</span>
00766     <span class="comment">//  Build the lookaside lists for our internal structures.</span>
00767     <span class="comment">//</span>
00768 
00769     <a class="code" href="../../d5/d8/ex_8h.html#a246">ExInitializeNPagedLookasideList</a>( &amp;<a class="code" href="../../d5/d3/filelock_8c.html#a13">FsRtlSharedLockLookasideList</a>,
00770                                      <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00771                                      <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00772                                      0,
00773                                      <span class="keyword">sizeof</span>(<a class="code" href="../../d8/d2/struct__SH__LOCK.html">SH_LOCK</a>),
00774                                      <a class="code" href="../../d5/d3/filelock_8c.html#a6">TAG_SHARED_LOCK</a>,
00775                                      16 );
00776 
00777     <a class="code" href="../../d5/d8/ex_8h.html#a246">ExInitializeNPagedLookasideList</a>( &amp;<a class="code" href="../../d5/d3/filelock_8c.html#a14">FsRtlExclusiveLockLookasideList</a>,
00778                                      <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00779                                      <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00780                                      0,
00781                                      <span class="keyword">sizeof</span>(<a class="code" href="../../d7/d7/struct__EX__LOCK.html">EX_LOCK</a>),
00782                                      <a class="code" href="../../d5/d3/filelock_8c.html#a2">TAG_EXCLUSIVE_LOCK</a>,
00783                                      16 );
00784 
00785     <a class="code" href="../../d5/d8/ex_8h.html#a246">ExInitializeNPagedLookasideList</a>( &amp;<a class="code" href="../../d5/d3/filelock_8c.html#a15">FsRtlWaitingLockLookasideList</a>,
00786                                      <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00787                                      <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00788                                      0,
00789                                      <span class="keyword">sizeof</span>(<a class="code" href="../../d1/d8/struct__WAITING__LOCK.html">WAITING_LOCK</a>),
00790                                      <a class="code" href="../../d5/d3/filelock_8c.html#a7">TAG_WAITING_LOCK</a>,
00791                                      16 );
00792 
00793     <a class="code" href="../../d5/d8/ex_8h.html#a246">ExInitializeNPagedLookasideList</a>( &amp;<a class="code" href="../../d5/d3/filelock_8c.html#a16">FsRtlLockTreeNodeLookasideList</a>,
00794                                      <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00795                                      <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00796                                      0,
00797                                      <span class="keyword">sizeof</span>(<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html">LOCKTREE_NODE</a>),
00798                                      <a class="code" href="../../d5/d3/filelock_8c.html#a5">TAG_LOCKTREE_NODE</a>,
00799                                      16 );
00800 
00801     <a class="code" href="../../d5/d8/ex_8h.html#a246">ExInitializeNPagedLookasideList</a>( &amp;<a class="code" href="../../d5/d3/filelock_8c.html#a17">FsRtlLockInfoLookasideList</a>,
00802                                      <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00803                                      <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00804                                      0,
00805                                      <span class="keyword">sizeof</span>(<a class="code" href="../../d6/d2/struct__LOCK__INFO.html">LOCK_INFO</a>),
00806                                      <a class="code" href="../../d5/d3/filelock_8c.html#a4">TAG_LOCK_INFO</a>,
00807                                      8 );
00808 
00809     <a class="code" href="../../d5/d8/ex_8h.html#a250">ExInitializePagedLookasideList</a>( &amp;<a class="code" href="../../d5/d3/filelock_8c.html#a18">FsRtlFileLockLookasideList</a>,
00810                                     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00811                                     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00812                                     0,
00813                                     <span class="keyword">sizeof</span>(<a class="code" href="../../d7/d1/struct__FILE__LOCK.html">FILE_LOCK</a>),
00814                                     <a class="code" href="../../d5/d3/filelock_8c.html#a3">TAG_FILE_LOCK</a>,
00815                                     8 );
00816 
00817     <span class="comment">//</span>
00818     <span class="comment">//  Initialize the LockInfo creation mutex</span>
00819     <span class="comment">//</span>
00820 
00821     <a class="code" href="../../d5/d8/ex_8h.html#a8">ExInitializeFastMutex</a>(&amp;<a class="code" href="../../d5/d3/filelock_8c.html#a12">FsRtlCreateLockInfo</a>);
00822 
00823 
00824 <span class="preprocessor">#endif</span>
00825 <span class="preprocessor"></span>}
00826 
00827 
00828 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00829"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a114">00829</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a114">FsRtlInitializeFileLock</a> (
00830     IN <a class="code" href="../../d7/d1/struct__FILE__LOCK.html">PFILE_LOCK</a> FileLock,
00831     IN PCOMPLETE_LOCK_IRP_ROUTINE CompleteLockIrpRoutine OPTIONAL,
00832     IN <a class="code" href="../../d1/d8/fsrtl_8h.html#a66">PUNLOCK_ROUTINE</a> UnlockRoutine OPTIONAL
00833     )
00834 
00835 <span class="comment">/*++</span>
00836 <span class="comment"></span>
00837 <span class="comment">Routine Description:</span>
00838 <span class="comment"></span>
00839 <span class="comment">    This routine initializes a new FILE_LOCK structure.  The caller must</span>
00840 <span class="comment">    supply the memory for the structure.  This call must precede all other</span>
00841 <span class="comment">    calls that utilize the FILE_LOCK variable.</span>
00842 <span class="comment"></span>
00843 <span class="comment">Arguments:</span>
00844 <span class="comment"></span>
00845 <span class="comment">    FileLock - Supplies a pointer to the FILE_LOCK structure to</span>
00846 <span class="comment">        initialize.</span>
00847 <span class="comment"></span>
00848 <span class="comment">    CompleteLockIrpRoutine - Optionally supplies an alternate routine to</span>
00849 <span class="comment">        call for completing IRPs.  FsRtlProcessFileLock by default will</span>
00850 <span class="comment">        call IoCompleteRequest to finish up an IRP; however if the caller</span>
00851 <span class="comment">        want to process the completion itself then it needs to specify</span>
00852 <span class="comment">        a completion routine here.  This routine will then be called in</span>
00853 <span class="comment">        place of IoCompleteRequest.</span>
00854 <span class="comment"></span>
00855 <span class="comment">    UnlockRoutine - Optionally supplies a routine to call when removing</span>
00856 <span class="comment">        a lock.</span>
00857 <span class="comment"></span>
00858 <span class="comment">Return Value:</span>
00859 <span class="comment"></span>
00860 <span class="comment">    None.</span>
00861 <span class="comment"></span>
00862 <span class="comment">--*/</span>
00863 
00864 {
00865     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlInitializeFileLock, FileLock = %08lx\n"</span>, FileLock);
00866 
00867     <span class="comment">//</span>
00868     <span class="comment">// Clear non-paged pool pointer</span>
00869     <span class="comment">//</span>
00870 
00871     FileLock-&gt;LockInformation = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00872     FileLock-&gt;CompleteLockIrpRoutine = CompleteLockIrpRoutine;
00873     FileLock-&gt;UnlockRoutine = UnlockRoutine;
00874 
00875     FileLock-&gt;FastIoIsQuestionable = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00876 
00877     <span class="comment">//</span>
00878     <span class="comment">//  and return to our caller</span>
00879     <span class="comment">//</span>
00880 
00881     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlInitializeFileLock -&gt; VOID\n"</span>, 0 );
00882 
00883     <span class="keywordflow">return</span>;
00884 }
00885 
00886 
00887 BOOLEAN
<a name="l00888"></a><a class="code" href="../../d5/d3/filelock_8c.html#a54">00888</a> <a class="code" href="../../d5/d3/filelock_8c.html#a54">FsRtlPrivateInitializeFileLock</a> (
00889     IN <a class="code" href="../../d7/d1/struct__FILE__LOCK.html">PFILE_LOCK</a>   FileLock,
00890     IN BOOLEAN ViaFastCall
00891     )
00892 <span class="comment">/*++</span>
00893 <span class="comment"></span>
00894 <span class="comment">Routine Description:</span>
00895 <span class="comment"></span>
00896 <span class="comment">    This routine initializes a new LOCK_INFO structure in non-paged</span>
00897 <span class="comment">    pool for the FILE_LOCK.  This routines only occurs once for a given</span>
00898 <span class="comment">    FILE_LOCK and it only occurs if any locks are applied to that file.</span>
00899 <span class="comment"></span>
00900 <span class="comment">Arguments:</span>
00901 <span class="comment"></span>
00902 <span class="comment">    FileLock - Supplies a pointer to the FILE_LOCK structure to</span>
00903 <span class="comment">        initialize.</span>
00904 <span class="comment"></span>
00905 <span class="comment">    ViaFastCall - Indicates if we are being invoked via a fast call or</span>
00906 <span class="comment">        via the slow irp based method.</span>
00907 <span class="comment"></span>
00908 <span class="comment">Return Value:</span>
00909 <span class="comment"></span>
00910 <span class="comment">    TRUE - If LockInfo structure was allocated and initialized</span>
00911 <span class="comment"></span>
00912 <span class="comment">--*/</span>
00913 {
00914     <a class="code" href="../../d5/d3/filelock_8c.html#a30">PLOCK_INFO</a>  LockInfo;
00915     BOOLEAN     Results = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00916 
00917     ExAcquireFastMutex( &amp;<a class="code" href="../../d5/d3/filelock_8c.html#a12">FsRtlCreateLockInfo</a> );
00918 
00919     <span class="keywordflow">try</span> {
00920 
00921         <span class="keywordflow">if</span> (FileLock-&gt;LockInformation != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00922 
00923             <span class="comment">//</span>
00924             <span class="comment">// Structure is already allocated, just return</span>
00925             <span class="comment">//</span>
00926 
00927             <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>( Results = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00928         }
00929 
00930         <span class="comment">//</span>
00931         <span class="comment">//  Allocate pool for lock structures.  If we fail then we will either return false or</span>
00932         <span class="comment">//  raise based on if we know the caller has an try-except to handle a raise.</span>
00933         <span class="comment">//</span>
00934 
00935         LockInfo = <a class="code" href="../../d5/d3/filelock_8c.html#a35">FsRtlAllocateLockInfo</a>();
00936 
00937         <span class="keywordflow">if</span> (LockInfo == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00938 
00939             <span class="keywordflow">if</span> (ViaFastCall) {
00940 
00941                 <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>( Results = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00942 
00943             } <span class="keywordflow">else</span> {
00944 
00945                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INSUFFICIENT_RESOURCES );
00946             }
00947         }
00948 
00949         <span class="comment">//</span>
00950         <span class="comment">//  Allocate and initialize the waiting lock queue</span>
00951         <span class="comment">//  spinlock, and initialize the queues</span>
00952         <span class="comment">//</span>
00953 
00954         LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o0">LowestLockOffset</a> = 0xffffffff;
00955 
00956         <a class="code" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock</a>( &amp;LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>.<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o0">QueueSpinLock</a> );
00957         LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>.<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o1">SharedLockTree</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00958         LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>.<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o2">ExclusiveLockTree</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00959         LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>.<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o3">WaitingLocks</a>.Next = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00960         LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>.<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o4">WaitingLocksTail</a>.Next = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00961 
00962         <span class="comment">//</span>
00963         <span class="comment">// Copy Irp &amp; Unlock routines from pagable FileLock structure</span>
00964         <span class="comment">// to non-pagable LockInfo structure</span>
00965         <span class="comment">//</span>
00966 
00967         LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o1">CompleteLockIrpRoutine</a> = FileLock-&gt;CompleteLockIrpRoutine;
00968         LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o2">UnlockRoutine</a> = FileLock-&gt;UnlockRoutine;
00969 
00970         <span class="comment">//</span>
00971         <span class="comment">// Clear continuation info for enum routine</span>
00972         <span class="comment">//</span>
00973 
00974         FileLock-&gt;LastReturnedLockInfo.FileObject = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00975         FileLock-&gt;LastReturnedLock = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00976 
00977         <span class="comment">//</span>
00978         <span class="comment">// Link LockInfo into FileLock</span>
00979         <span class="comment">//</span>
00980 
00981         FileLock-&gt;LockInformation = (PVOID) LockInfo;
00982         Results = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00983 
00984     try_exit: NOTHING;
00985     } finally {
00986 
00987         ExReleaseFastMutex( &amp;<a class="code" href="../../d5/d3/filelock_8c.html#a12">FsRtlCreateLockInfo</a> );
00988     }
00989 
00990     <span class="keywordflow">return</span> Results;
00991 }
00992 
00993 
00994 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00995"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a115">00995</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a115">FsRtlUninitializeFileLock</a> (
00996     IN <a class="code" href="../../d7/d1/struct__FILE__LOCK.html">PFILE_LOCK</a> FileLock
00997     )
00998 
00999 <span class="comment">/*++</span>
01000 <span class="comment"></span>
01001 <span class="comment">Routine Description:</span>
01002 <span class="comment"></span>
01003 <span class="comment">    This routine uninitializes a FILE_LOCK structure.  After calling this</span>
01004 <span class="comment">    routine the File lock must be reinitialized before being used again.</span>
01005 <span class="comment"></span>
01006 <span class="comment">    This routine will free all files locks and completes any outstanding</span>
01007 <span class="comment">    lock requests as a result of cleaning itself up.</span>
01008 <span class="comment"></span>
01009 <span class="comment">Arguments:</span>
01010 <span class="comment"></span>
01011 <span class="comment">    FileLock - Supplies a pointer to the FILE_LOCK struture being</span>
01012 <span class="comment">        decommissioned.</span>
01013 <span class="comment"></span>
01014 <span class="comment">Return Value:</span>
01015 <span class="comment"></span>
01016 <span class="comment">    None.</span>
01017 <span class="comment"></span>
01018 <span class="comment">--*/</span>
01019 
01020 {
01021     <a class="code" href="../../d5/d3/filelock_8c.html#a30">PLOCK_INFO</a>          LockInfo;
01022     <a class="code" href="../../d5/d3/filelock_8c.html#a22">PSH_LOCK</a>            ShLock;
01023     <a class="code" href="../../d5/d3/filelock_8c.html#a24">PEX_LOCK</a>            ExLock;
01024     PSINGLE_LIST_ENTRY  Link;
01025     <a class="code" href="../../d5/d3/filelock_8c.html#a26">PWAITING_LOCK</a>       WaitingLock;
01026     <a class="code" href="../../d5/d3/filelock_8c.html#a20">PLOCKTREE_NODE</a>      LockTreeNode;
01027     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>                <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>;
01028     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>            NewStatus;
01029     KIRQL               OldIrql;
01030     PKPRCB              Prcb;
01031 
01032     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlUninitializeFileLock, FileLock = %08lx\n"</span>, FileLock);
01033 
01034     <span class="keywordflow">if</span> ((LockInfo = (<a class="code" href="../../d5/d3/filelock_8c.html#a30">PLOCK_INFO</a>) FileLock-&gt;LockInformation) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01035         <span class="keywordflow">return</span> ;
01036     }
01037 
01038     <span class="comment">//</span>
01039     <span class="comment">//  Lock the queue</span>
01040     <span class="comment">//</span>
01041 
01042     <a class="code" href="../../d5/d3/filelock_8c.html#a8">FsRtlAcquireLockQueue</a>(&amp;LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>, &amp;OldIrql);
01043 
01044     <span class="comment">//</span>
01045     <span class="comment">//  Free lock trees</span>
01046     <span class="comment">//</span>
01047 
01048     <span class="keywordflow">while</span> (LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>.<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o1">SharedLockTree</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01049 
01050         LockTreeNode = CONTAINING_RECORD(LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>.<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o1">SharedLockTree</a>, <a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html">LOCKTREE_NODE</a>, Links);
01051 
01052         <span class="comment">//</span>
01053         <span class="comment">//  Remove all locks associated with the root node</span>
01054         <span class="comment">//</span>
01055 
01056         <span class="keywordflow">while</span> (LockTreeNode-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o0">Locks</a>.Next != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01057             Link = PopEntryList (&amp;LockTreeNode-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o0">Locks</a>);
01058             ShLock = CONTAINING_RECORD( Link, <a class="code" href="../../d8/d2/struct__SH__LOCK.html">SH_LOCK</a>, Link );
01059 
01060             <a class="code" href="../../d5/d3/filelock_8c.html#a36">FsRtlFreeSharedLock</a>(ShLock);
01061         }
01062 
01063         <span class="comment">//</span>
01064         <span class="comment">//  Slice off the root node of the tree</span>
01065         <span class="comment">//</span>
01066 
01067         <a class="code" href="../../d3/d4/splay_8c.html#a5">RtlDeleteNoSplay</a>(&amp;LockTreeNode-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o3">Links</a>, &amp;LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>.<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o1">SharedLockTree</a>);
01068 
01069         <a class="code" href="../../d5/d3/filelock_8c.html#a39">FsRtlFreeLockTreeNode</a>(LockTreeNode);
01070     }
01071 
01072     <span class="keywordflow">while</span> (LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>.<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o2">ExclusiveLockTree</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01073 
01074         ExLock = CONTAINING_RECORD(LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>.<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o2">ExclusiveLockTree</a>, <a class="code" href="../../d7/d7/struct__EX__LOCK.html">EX_LOCK</a>, Links);
01075 
01076         <a class="code" href="../../d3/d4/splay_8c.html#a5">RtlDeleteNoSplay</a>(&amp;ExLock-&gt;<a class="code" href="../../d7/d7/struct__EX__LOCK.html#o0">Links</a>, &amp;LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>.<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o2">ExclusiveLockTree</a>);
01077 
01078         <a class="code" href="../../d5/d3/filelock_8c.html#a37">FsRtlFreeExclusiveLock</a>(ExLock);
01079     }
01080 
01081     <span class="comment">//</span>
01082     <span class="comment">//  Free WaitingLockQueue</span>
01083     <span class="comment">//</span>
01084 
01085     <span class="keywordflow">while</span> (LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>.<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o3">WaitingLocks</a>.Next != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01086 
01087         Link = PopEntryList( &amp;LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>.<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o3">WaitingLocks</a> );
01088         WaitingLock = CONTAINING_RECORD( Link, <a class="code" href="../../d1/d8/struct__WAITING__LOCK.html">WAITING_LOCK</a>, Link );
01089 
01090         <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> = WaitingLock-&gt;<a class="code" href="../../d1/d8/struct__WAITING__LOCK.html#o2">Irp</a>;
01091 
01092         <span class="comment">//</span>
01093         <span class="comment">//  To complete an irp in the waiting queue we need to</span>
01094         <span class="comment">//  void the cancel routine (protected by a spinlock) before</span>
01095         <span class="comment">//  we can complete the irp</span>
01096         <span class="comment">//</span>
01097 
01098         <a class="code" href="../../d5/d3/filelock_8c.html#a10">FsRtlReleaseLockQueue</a> (&amp;LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>, OldIrql);
01099 
01100         <a class="code" href="../../d4/d6/iosubs_8c.html#a9">IoAcquireCancelSpinLock</a>( &amp;<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o15">CancelIrql</a> );
01101         <a class="code" href="../../d0/d5/io_8h.html#a236">IoSetCancelRoutine</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01102         <a class="code" href="../../d4/d6/iosubs_8c.html#a101">IoReleaseCancelSpinLock</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o15">CancelIrql</a> );
01103 
01104         <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information = 0;
01105 
01106         <a class="code" href="../../d5/d3/filelock_8c.html#a11">FsRtlCompleteLockIrp</a>(
01107              LockInfo,
01108              WaitingLock-&gt;<a class="code" href="../../d1/d8/struct__WAITING__LOCK.html#o1">Context</a>,
01109              <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>,
01110              STATUS_RANGE_NOT_LOCKED,
01111              &amp;NewStatus,
01112              <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01113 
01114         <a class="code" href="../../d5/d3/filelock_8c.html#a8">FsRtlAcquireLockQueue</a>(&amp;LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>, &amp;OldIrql);
01115         <a class="code" href="../../d5/d3/filelock_8c.html#a38">FsRtlFreeWaitingLock</a>( WaitingLock );
01116     }
01117 
01118     <span class="comment">//</span>
01119     <span class="comment">// Free pool used to track the lock info on this file</span>
01120     <span class="comment">//</span>
01121 
01122     <a class="code" href="../../d5/d3/filelock_8c.html#a10">FsRtlReleaseLockQueue</a>( &amp;LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>, OldIrql );
01123     <a class="code" href="../../d5/d3/filelock_8c.html#a40">FsRtlFreeLockInfo</a>( LockInfo );
01124 
01125     <span class="comment">//</span>
01126     <span class="comment">// Unlink LockInfo from FileLock</span>
01127     <span class="comment">//</span>
01128 
01129     FileLock-&gt;LockInformation = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01130 
01131     <span class="comment">//</span>
01132     <span class="comment">//  And return to our caller</span>
01133     <span class="comment">//</span>
01134 
01135     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlUninitializeFileLock -&gt; VOID\n"</span>, 0 );
01136     <span class="keywordflow">return</span>;
01137 }
01138 
01139 
01140 <a class="code" href="../../d7/d1/struct__FILE__LOCK.html">PFILE_LOCK</a>
<a name="l01141"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a112">01141</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a112">FsRtlAllocateFileLock</a> (
01142     IN PCOMPLETE_LOCK_IRP_ROUTINE CompleteLockIrpRoutine OPTIONAL,
01143     IN PUNLOCK_ROUTINE UnlockRoutine OPTIONAL
01144 
01145     )
01146 {
01147     <a class="code" href="../../d7/d1/struct__FILE__LOCK.html">PFILE_LOCK</a> FileLock;
01148 
01149     FileLock = <a class="code" href="../../d5/d8/ex_8h.html#a252">ExAllocateFromPagedLookasideList</a>( &amp;<a class="code" href="../../d5/d3/filelock_8c.html#a18">FsRtlFileLockLookasideList</a> );
01150 
01151     <span class="keywordflow">if</span> (FileLock != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01152 
01153         <a class="code" href="../../d1/d8/fsrtl_8h.html#a114">FsRtlInitializeFileLock</a>( FileLock,
01154                                  CompleteLockIrpRoutine,
01155                                  UnlockRoutine );
01156     }
01157 
01158     <span class="keywordflow">return</span> FileLock;
01159 }
01160 
01161 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01162"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a113">01162</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a113">FsRtlFreeFileLock</a> (
01163     IN <a class="code" href="../../d7/d1/struct__FILE__LOCK.html">PFILE_LOCK</a> FileLock
01164     )
01165 {
01166     <a class="code" href="../../d1/d8/fsrtl_8h.html#a115">FsRtlUninitializeFileLock</a>( FileLock );
01167 
01168     <a class="code" href="../../d5/d8/ex_8h.html#a253">ExFreeToPagedLookasideList</a>( &amp;<a class="code" href="../../d5/d3/filelock_8c.html#a18">FsRtlFileLockLookasideList</a>, FileLock );
01169 }
01170 
01171 
01172 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01173"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a116">01173</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a116">FsRtlProcessFileLock</a> (
01174     IN <a class="code" href="../../d7/d1/struct__FILE__LOCK.html">PFILE_LOCK</a> FileLock,
01175     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
01176     IN PVOID Context OPTIONAL
01177     )
01178 
01179 <span class="comment">/*++</span>
01180 <span class="comment"></span>
01181 <span class="comment">Routine Description:</span>
01182 <span class="comment"></span>
01183 <span class="comment">    This routine processes a file lock IRP it does either a lock request,</span>
01184 <span class="comment">    or an unlock request.  It also completes the IRP.  Once called the user</span>
01185 <span class="comment">    (i.e., File System) has relinquished control of the input IRP.</span>
01186 <span class="comment"></span>
01187 <span class="comment">    If pool is not available to store the information this routine will raise a</span>
01188 <span class="comment">    status value indicating insufficient resources.</span>
01189 <span class="comment"></span>
01190 <span class="comment">Arguments:</span>
01191 <span class="comment"></span>
01192 <span class="comment">    FileLock - Supplies the File lock being modified/queried.</span>
01193 <span class="comment"></span>
01194 <span class="comment">    Irp - Supplies the Irp being processed.</span>
01195 <span class="comment"></span>
01196 <span class="comment">    Context - Optionally supplies a context to use when calling the user</span>
01197 <span class="comment">        alternate IRP completion routine.</span>
01198 <span class="comment"></span>
01199 <span class="comment">Return Value:</span>
01200 <span class="comment"></span>
01201 <span class="comment">    NTSTATUS - The return status for the operation.</span>
01202 <span class="comment"></span>
01203 <span class="comment">--*/</span>
01204 
01205 {
01206     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> IrpSp;
01207 
01208     IO_STATUS_BLOCK Iosb;
01209     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>        <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01210     LARGE_INTEGER   ByteOffset;
01211 
01212     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlProcessFileLock, FileLock = %08lx\n"</span>, FileLock);
01213 
01214     Iosb.Information = 0;
01215 
01216     <span class="comment">//</span>
01217     <span class="comment">//  Get a pointer to the current Irp stack location and assert that</span>
01218     <span class="comment">//  the major function code is for a lock operation</span>
01219     <span class="comment">//</span>
01220 
01221     IrpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
01222 
01223     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> == <a class="code" href="../../d0/d5/io_8h.html#a30">IRP_MJ_LOCK_CONTROL</a> );
01224 
01225     <span class="comment">//</span>
01226     <span class="comment">//  Now process the different minor lock operations</span>
01227     <span class="comment">//</span>
01228 
01229     <span class="keywordflow">switch</span> (IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o1">MinorFunction</a>) {
01230 
01231     <span class="keywordflow">case</span> <a class="code" href="../../d0/d5/io_8h.html#a52">IRP_MN_LOCK</a>:
01232 
01233         ByteOffset = IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.LockControl.ByteOffset;
01234 
01235         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d8/fsrtl_8h.html#a125">FsRtlPrivateLock</a>( FileLock,
01236                                  IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a>,
01237                                  &amp;ByteOffset,
01238                                  IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.LockControl.Length,
01239                                  <a class="code" href="../../d0/d5/io_8h.html#a512">IoGetRequestorProcess</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>),
01240                                  IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.LockControl.Key,
01241                                  <a class="code" href="../../d5/d5/cc_8h.html#a59">BooleanFlagOn</a>(IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o2">Flags</a>, <a class="code" href="../../d0/d5/io_8h.html#a206">SL_FAIL_IMMEDIATELY</a>),
01242                                  <a class="code" href="../../d5/d5/cc_8h.html#a59">BooleanFlagOn</a>(IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o2">Flags</a>, <a class="code" href="../../d0/d5/io_8h.html#a207">SL_EXCLUSIVE_LOCK</a>),
01243                                  &amp;Iosb,
01244                                  <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>,
01245                                  Context,
01246                                  <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01247 
01248         <span class="keywordflow">break</span>;
01249 
01250     <span class="keywordflow">case</span> <a class="code" href="../../d0/d5/io_8h.html#a53">IRP_MN_UNLOCK_SINGLE</a>:
01251 
01252         ByteOffset = IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.LockControl.ByteOffset;
01253 
01254         Iosb.Status = <a class="code" href="../../d1/d8/fsrtl_8h.html#a122">FsRtlFastUnlockSingle</a>( FileLock,
01255                                              IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a>,
01256                                              &amp;ByteOffset,
01257                                              IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.LockControl.Length,
01258                                              <a class="code" href="../../d0/d5/io_8h.html#a512">IoGetRequestorProcess</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>),
01259                                              IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.LockControl.Key,
01260                                              Context,
01261                                              <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01262 
01263         <a class="code" href="../../d5/d3/filelock_8c.html#a11">FsRtlCompleteLockIrp</a>( FileLock, Context, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, Iosb.Status, &amp;<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01264         <span class="keywordflow">break</span>;
01265 
01266     <span class="keywordflow">case</span> <a class="code" href="../../d0/d5/io_8h.html#a54">IRP_MN_UNLOCK_ALL</a>:
01267 
01268         Iosb.Status = <a class="code" href="../../d1/d8/fsrtl_8h.html#a123">FsRtlFastUnlockAll</a>( FileLock,
01269                                           IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a>,
01270                                           <a class="code" href="../../d0/d5/io_8h.html#a512">IoGetRequestorProcess</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>),
01271                                           Context );
01272 
01273         <a class="code" href="../../d5/d3/filelock_8c.html#a11">FsRtlCompleteLockIrp</a>( FileLock, Context, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, Iosb.Status, &amp;<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01274         <span class="keywordflow">break</span>;
01275 
01276     <span class="keywordflow">case</span> <a class="code" href="../../d0/d5/io_8h.html#a55">IRP_MN_UNLOCK_ALL_BY_KEY</a>:
01277 
01278         Iosb.Status = <a class="code" href="../../d1/d8/fsrtl_8h.html#a124">FsRtlFastUnlockAllByKey</a>( FileLock,
01279                                                IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a>,
01280                                                <a class="code" href="../../d0/d5/io_8h.html#a512">IoGetRequestorProcess</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>),
01281                                                IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.LockControl.Key,
01282                                                Context );
01283 
01284         <a class="code" href="../../d5/d3/filelock_8c.html#a11">FsRtlCompleteLockIrp</a>( FileLock, Context, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, Iosb.Status, &amp;<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01285         <span class="keywordflow">break</span>;
01286 
01287     <span class="keywordflow">default</span>:
01288 
01289         <span class="comment">//</span>
01290         <span class="comment">//  For all other minor function codes we say they're invalid and</span>
01291         <span class="comment">//  complete the request.  Note that the IRP has not been marked</span>
01292         <span class="comment">//  pending so this error will be returned directly to the caller.</span>
01293         <span class="comment">//</span>
01294 
01295         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(0, 1, <span class="stringliteral">"Invalid LockFile Minor Function Code %08lx\n"</span>, IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o1">MinorFunction</a>);
01296 
01297 
01298         <a class="code" href="../../d1/d8/fsrtl_8h.html#a47">FsRtlCompleteRequest</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, STATUS_INVALID_DEVICE_REQUEST );
01299 
01300         Iosb.Status = STATUS_INVALID_DEVICE_REQUEST;
01301         <span class="keywordflow">break</span>;
01302     }
01303 
01304     <span class="comment">//</span>
01305     <span class="comment">//  And return to our caller</span>
01306     <span class="comment">//</span>
01307 
01308     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlProcessFileLock -&gt; %08lx\n"</span>, Iosb.Status);
01309 
01310     <span class="keywordflow">return</span> Iosb.Status;
01311 }
01312 
01313 
01314 BOOLEAN
<a name="l01315"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a117">01315</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a117">FsRtlCheckLockForReadAccess</a> (
01316     IN <a class="code" href="../../d7/d1/struct__FILE__LOCK.html">PFILE_LOCK</a> FileLock,
01317     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
01318     )
01319 
01320 <span class="comment">/*++</span>
01321 <span class="comment"></span>
01322 <span class="comment">Routine Description:</span>
01323 <span class="comment"></span>
01324 <span class="comment">    This routine checks to see if the caller has read access to the</span>
01325 <span class="comment">    range indicated in the IRP due to file locks.  This call does not</span>
01326 <span class="comment">    complete the Irp it only uses it to get the lock information and read</span>
01327 <span class="comment">    information.  The IRP must be for a read operation.</span>
01328 <span class="comment"></span>
01329 <span class="comment">Arguments:</span>
01330 <span class="comment"></span>
01331 <span class="comment">    FileLock - Supplies the File Lock to check.</span>
01332 <span class="comment"></span>
01333 <span class="comment">    Irp - Supplies the Irp being processed.</span>
01334 <span class="comment"></span>
01335 <span class="comment">Return Value:</span>
01336 <span class="comment"></span>
01337 <span class="comment">    BOOLEAN - TRUE if the indicated user/request has read access to the</span>
01338 <span class="comment">        entire specified byte range, and FALSE otherwise</span>
01339 <span class="comment"></span>
01340 <span class="comment">--*/</span>
01341 
01342 {
01343     BOOLEAN Result;
01344 
01345     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> IrpSp;
01346 
01347     <a class="code" href="../../d5/d3/filelock_8c.html#a30">PLOCK_INFO</a>     LockInfo;
01348     LARGE_INTEGER  StartingByte;
01349     LARGE_INTEGER  Length;
01350     ULONG          <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>;
01351     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>   FileObject;
01352     PVOID          ProcessId;
01353     LARGE_INTEGER  BeyondLastByte;
01354 
01355     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlCheckLockForReadAccess, FileLock = %08lx\n"</span>, FileLock);
01356 
01357     <span class="keywordflow">if</span> ((LockInfo = (<a class="code" href="../../d5/d3/filelock_8c.html#a30">PLOCK_INFO</a>) FileLock-&gt;LockInformation) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01358         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlCheckLockForReadAccess (No current lock info) -&gt; TRUE\n"</span>, 0);
01359         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01360     }
01361 
01362     <span class="comment">//</span>
01363     <span class="comment">//  Do a really fast test to see if there are any exclusive locks to start with</span>
01364     <span class="comment">//</span>
01365 
01366     <span class="keywordflow">if</span> (LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>.<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o2">ExclusiveLockTree</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01367         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlCheckLockForReadAccess (No current locks) -&gt; TRUE\n"</span>, 0);
01368         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01369     }
01370 
01371     <span class="comment">//</span>
01372     <span class="comment">//  Get the read offset and compare it to the lowest existing lock.</span>
01373     <span class="comment">//</span>
01374 
01375     IrpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
01376 
01377     StartingByte  = IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Read.ByteOffset;
01378     (ULONGLONG)Length.QuadPart = (ULONGLONG)IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Read.Length;
01379 
01380     (ULONGLONG)BeyondLastByte.QuadPart = (ULONGLONG)StartingByte.QuadPart + Length.LowPart;
01381     <span class="keywordflow">if</span> ( (ULONGLONG)BeyondLastByte.QuadPart &lt;= (ULONGLONG)LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o0">LowestLockOffset</a> ) {
01382         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlCheckLockForReadAccess (Below lowest lock) -&gt; TRUE\n"</span>, 0);
01383         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01384     }
01385 
01386     <span class="comment">//</span>
01387     <span class="comment">//  Get remaining parameters.</span>
01388     <span class="comment">//</span>
01389 
01390     <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>           = IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Read.Key;
01391     FileObject    = IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a>;
01392     ProcessId     = <a class="code" href="../../d4/d6/iosubs_8c.html#a78">IoGetRequestorProcess</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
01393 
01394     <span class="comment">//</span>
01395     <span class="comment">//  Call our private work routine to do the real check</span>
01396     <span class="comment">//</span>
01397 
01398     Result = <a class="code" href="../../d1/d8/fsrtl_8h.html#a119">FsRtlFastCheckLockForRead</a>( FileLock,
01399                                         &amp;StartingByte,
01400                                         &amp;Length,
01401                                         <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>,
01402                                         FileObject,
01403                                         ProcessId );
01404 
01405     <span class="comment">//</span>
01406     <span class="comment">//  And return to our caller</span>
01407     <span class="comment">//</span>
01408 
01409     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlCheckLockForReadAccess -&gt; %08lx\n"</span>, Result);
01410 
01411     <span class="keywordflow">return</span> Result;
01412 }
01413 
01414 
01415 BOOLEAN
<a name="l01416"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a118">01416</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a118">FsRtlCheckLockForWriteAccess</a> (
01417     IN <a class="code" href="../../d7/d1/struct__FILE__LOCK.html">PFILE_LOCK</a> FileLock,
01418     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
01419     )
01420 
01421 <span class="comment">/*++</span>
01422 <span class="comment"></span>
01423 <span class="comment">Routine Description:</span>
01424 <span class="comment"></span>
01425 <span class="comment">    This routine checks to see if the caller has write access to the</span>
01426 <span class="comment">    indicated range due to file locks.  This call does not complete the</span>
01427 <span class="comment">    Irp it only uses it to get the lock information and write information.</span>
01428 <span class="comment">    The IRP must be for a write operation.</span>
01429 <span class="comment"></span>
01430 <span class="comment">Arguments:</span>
01431 <span class="comment"></span>
01432 <span class="comment">    FileLock - Supplies the File Lock to check.</span>
01433 <span class="comment"></span>
01434 <span class="comment">    Irp - Supplies the Irp being processed.</span>
01435 <span class="comment"></span>
01436 <span class="comment">Return Value:</span>
01437 <span class="comment"></span>
01438 <span class="comment">    BOOLEAN - TRUE if the indicated user/request has write access to the</span>
01439 <span class="comment">        entire specified byte range, and FALSE otherwise</span>
01440 <span class="comment"></span>
01441 <span class="comment">--*/</span>
01442 
01443 {
01444     BOOLEAN Result;
01445 
01446     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> IrpSp;
01447 
01448     <a class="code" href="../../d5/d3/filelock_8c.html#a30">PLOCK_INFO</a>      LockInfo;
01449     LARGE_INTEGER   StartingByte;
01450     LARGE_INTEGER   Length;
01451     ULONG           <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>;
01452     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>    FileObject;
01453     PVOID           ProcessId;
01454     LARGE_INTEGER   BeyondLastByte;
01455 
01456     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlCheckLockForWriteAccess, FileLock = %08lx\n"</span>, FileLock);
01457 
01458     <span class="keywordflow">if</span> ((LockInfo = (<a class="code" href="../../d5/d3/filelock_8c.html#a30">PLOCK_INFO</a>) FileLock-&gt;LockInformation) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01459         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlCheckLockForWriteAccess (No current lock info) -&gt; TRUE\n"</span>, 0);
01460         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01461     }
01462 
01463     <span class="comment">//</span>
01464     <span class="comment">//  Do a really fast test to see if there are any locks to start with</span>
01465     <span class="comment">//</span>
01466 
01467     <span class="keywordflow">if</span> (LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>.<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o2">ExclusiveLockTree</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> &amp;&amp; LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>.<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o1">SharedLockTree</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01468         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlCheckLockForWriteAccess (No current locks) -&gt; TRUE\n"</span>, 0);
01469         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01470     }
01471 
01472     <span class="comment">//</span>
01473     <span class="comment">//  Get the write offset and compare it to the lowest existing lock.</span>
01474     <span class="comment">//</span>
01475 
01476     IrpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
01477 
01478     StartingByte  = IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Write.ByteOffset;
01479     (ULONGLONG)Length.QuadPart = (ULONGLONG)IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Write.Length;
01480 
01481     (ULONGLONG)BeyondLastByte.QuadPart = (ULONGLONG)StartingByte.QuadPart + Length.LowPart;
01482     <span class="keywordflow">if</span> ( (ULONGLONG)BeyondLastByte.QuadPart &lt;= (ULONGLONG)LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o0">LowestLockOffset</a> ) {
01483         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlCheckLockForWriteAccess (Below lowest lock) -&gt; TRUE\n"</span>, 0);
01484         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01485     }
01486 
01487     <span class="comment">//</span>
01488     <span class="comment">//  Get remaining parameters.</span>
01489     <span class="comment">//</span>
01490 
01491     <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>           = IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Write.Key;
01492     FileObject    = IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a>;
01493     ProcessId     = <a class="code" href="../../d4/d6/iosubs_8c.html#a78">IoGetRequestorProcess</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
01494 
01495     <span class="comment">//</span>
01496     <span class="comment">//  Call our private work routine to do the real work</span>
01497     <span class="comment">//</span>
01498 
01499     Result = <a class="code" href="../../d1/d8/fsrtl_8h.html#a120">FsRtlFastCheckLockForWrite</a>( FileLock,
01500                                          &amp;StartingByte,
01501                                          &amp;Length,
01502                                          <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>,
01503                                          FileObject,
01504                                          ProcessId );
01505 
01506     <span class="comment">//</span>
01507     <span class="comment">//  And return to our caller</span>
01508     <span class="comment">//</span>
01509 
01510     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlCheckLockForWriteAccess -&gt; %08lx\n"</span>, Result);
01511 
01512     <span class="keywordflow">return</span> Result;
01513 }
01514 
01515 
01516 PRTL_SPLAY_LINKS
<a name="l01517"></a><a class="code" href="../../d5/d3/filelock_8c.html#a43">01517</a> <a class="code" href="../../d5/d3/filelock_8c.html#a43">FsRtlFindFirstOverlappingSharedNode</a> (
01518     IN PRTL_SPLAY_LINKS         Tree,
01519     IN PLARGE_INTEGER           StartingByte,
01520     IN PLARGE_INTEGER           EndingByte,
01521     IN OUT PRTL_SPLAY_LINKS     *LastEdgeNode,
01522     IN OUT PBOOLEAN             GreaterThan
01523     )
01524 <span class="comment">/*++</span>
01525 <span class="comment"></span>
01526 <span class="comment">Routine Description:</span>
01527 <span class="comment"></span>
01528 <span class="comment">    This routine returns the first node in the shared lock tree which</span>
01529 <span class="comment">    overlaps with the range given. No nodes given by RtlRealPredecessor()</span>
01530 <span class="comment">    on the result overlap the range.</span>
01531 <span class="comment"></span>
01532 <span class="comment">Arguments:</span>
01533 <span class="comment"></span>
01534 <span class="comment">    Tree - supplies the splay links of the root node of the shared tree</span>
01535 <span class="comment">        to search</span>
01536 <span class="comment"></span>
01537 <span class="comment">    StartingByte - supplies the first byte offset of the range to check</span>
01538 <span class="comment"></span>
01539 <span class="comment">    EndingByte - supplies the last byte offset of the range to check</span>
01540 <span class="comment"></span>
01541 <span class="comment">    LastEdgeNode - optional, will be set to the last node searched in the</span>
01542 <span class="comment">        not including returned node (presumeably where a new node will</span>
01543 <span class="comment">        be inserted if return is NULL).</span>
01544 <span class="comment"></span>
01545 <span class="comment">    GreaterThan - optional, set according to whether LastEdgeNode is covering</span>
01546 <span class="comment">        a range greater than the queried range. !GreaterThan == LessThan, since</span>
01547 <span class="comment">        we would have returned this node in the "Equals" (overlap) case.</span>
01548 <span class="comment"></span>
01549 <span class="comment">Return Value:</span>
01550 <span class="comment"></span>
01551 <span class="comment">    The splay links of the node, if such a node exists, NULL otherwise</span>
01552 <span class="comment"></span>
01553 <span class="comment">--*/</span>
01554 {
01555     <a class="code" href="../../d5/d3/filelock_8c.html#a20">PLOCKTREE_NODE</a>        Node, LastOverlapNode;
01556     PRTL_SPLAY_LINKS      SplayLinks;
01557     <a class="code" href="../../d5/d3/filelock_8c.html#a22">PSH_LOCK</a>              <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>;
01558 
01559     <span class="keywordflow">if</span> (LastEdgeNode) *LastEdgeNode = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01560     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d8/fsrtl_8h.html#a189a91">GreaterThan</a>) *<a class="code" href="../../d1/d8/fsrtl_8h.html#a189a91">GreaterThan</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01561 
01562     LastOverlapNode = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01563     SplayLinks = Tree;
01564 
01565     <span class="keywordflow">while</span> (SplayLinks) {
01566 
01567         Node = CONTAINING_RECORD( SplayLinks, <a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html">LOCKTREE_NODE</a>, Links );
01568 
01569         <span class="comment">//</span>
01570         <span class="comment">//  Pull up the first lock on the chain at this node to check</span>
01571         <span class="comment">//  the starting byte offset of locks at this node</span>
01572         <span class="comment">//</span>
01573 
01574         <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a> = CONTAINING_RECORD( Node-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o0">Locks</a>.Next, <a class="code" href="../../d8/d2/struct__SH__LOCK.html">SH_LOCK</a>, Link );
01575 
01576         <span class="comment">//</span>
01577         <span class="comment">//  We may have to go right in the tree if this lock covers a range before the start of this</span>
01578         <span class="comment">//  range we are looking for overlap on or this lock is [0, 0).  This is important since a lock</span>
01579         <span class="comment">//  on [0, 0) will look like the extent is from [0, ~0], which is the only case where the zero</span>
01580         <span class="comment">//  length lock relation of End &lt; Start does not hold.</span>
01581         <span class="comment">//</span>
01582 
01583         <span class="keywordflow">if</span> (Node-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o2">Extent</a> &lt; (ULONGLONG)StartingByte-&gt;QuadPart ||
01584             (<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.StartingByte.QuadPart == 0 &amp;&amp; <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.Length.QuadPart == 0)) {
01585 
01586             <span class="keywordflow">if</span> ((ULONGLONG)<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.EndingByte.QuadPart == (ULONGLONG)EndingByte-&gt;QuadPart &amp;&amp;
01587                 (ULONGLONG)<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.StartingByte.QuadPart == (ULONGLONG)StartingByte-&gt;QuadPart) {
01588 
01589                 <span class="comment">//</span>
01590                 <span class="comment">//  The extent of the node is less than the starting position of the</span>
01591                 <span class="comment">//  range we are checking and the first lock on this node is equal to</span>
01592                 <span class="comment">//  the range, which implies that the range and the lock are zero</span>
01593                 <span class="comment">//  length.</span>
01594                 <span class="comment">//</span>
01595                 <span class="comment">//  This is a zero length lock node and we are searching for zero</span>
01596                 <span class="comment">//  length overlap. This makes multiple zero length shared locks</span>
01597                 <span class="comment">//  occupy the same node, which is a win, but makes application of</span>
01598                 <span class="comment">//  zero length exclusive locks check the length of the overlapping</span>
01599                 <span class="comment">//  lock to see if they really conflict.</span>
01600                 <span class="comment">//</span>
01601 
01602                 <span class="keywordflow">break</span>;
01603             }
01604 
01605             <span class="comment">//</span>
01606             <span class="comment">//  All locks at this node are strictly less than this</span>
01607             <span class="comment">//  byterange, so go right in the tree.</span>
01608             <span class="comment">//</span>
01609 
01610             <span class="keywordflow">if</span> (LastEdgeNode) *LastEdgeNode = SplayLinks;
01611             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d8/fsrtl_8h.html#a189a91">GreaterThan</a>) *<a class="code" href="../../d1/d8/fsrtl_8h.html#a189a91">GreaterThan</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01612 
01613             SplayLinks = RtlRightChild(SplayLinks);
01614             <span class="keywordflow">continue</span>;
01615         }
01616 
01617         <span class="keywordflow">if</span> ((ULONGLONG)<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.StartingByte.QuadPart &lt;= (ULONGLONG)EndingByte-&gt;QuadPart) {
01618 
01619             <span class="comment">//</span>
01620             <span class="comment">//  We have an overlap, but we need to see if the byterange starts</span>
01621             <span class="comment">//  before this node so that there is the guarantee that we start</span>
01622             <span class="comment">//  the search at the correct point. There may be still be predecessor</span>
01623             <span class="comment">//  nodes covering the byterange.</span>
01624             <span class="comment">//</span>
01625 
01626             <span class="keywordflow">if</span> ((ULONGLONG)<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.StartingByte.QuadPart &lt;= (ULONGLONG)StartingByte-&gt;QuadPart) {
01627 
01628                 <span class="comment">//</span>
01629                 <span class="comment">//  This node begins at a byte offset prior to the byterange we</span>
01630                 <span class="comment">//  are checking, so it must be the correct starting position.</span>
01631                 <span class="comment">//</span>
01632 
01633                 <span class="keywordflow">break</span>;
01634             }
01635 
01636             <span class="comment">//</span>
01637             <span class="comment">//  Drop a marker at this node so that we can come back if it turns out</span>
01638             <span class="comment">//  that the left subtree does not cover the range of bytes before this</span>
01639             <span class="comment">//  node in the byterange.</span>
01640             <span class="comment">//</span>
01641 
01642             LastOverlapNode = Node;
01643         }
01644 
01645         <span class="comment">//</span>
01646         <span class="comment">//  It must now be the case that all locks at this node are strictly greater</span>
01647         <span class="comment">//  than the byterange, or we have the candidate overlap case above,</span>
01648         <span class="comment">//  so go left in the tree.</span>
01649         <span class="comment">//</span>
01650 
01651         <span class="keywordflow">if</span> (LastEdgeNode) *LastEdgeNode = SplayLinks;
01652         <span class="keywordflow">if</span> (<a class="code" href="../../d1/d8/fsrtl_8h.html#a189a91">GreaterThan</a>) *<a class="code" href="../../d1/d8/fsrtl_8h.html#a189a91">GreaterThan</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01653 
01654         SplayLinks = RtlLeftChild(SplayLinks);
01655     }
01656 
01657     <span class="keywordflow">if</span> (SplayLinks == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01658 
01659         <span class="comment">//</span>
01660         <span class="comment">//  We hit the edge of the tree. If the LastOverlapNode is set, it means that</span>
01661         <span class="comment">//  we had kept searching left in the tree for a node that covered the starting</span>
01662         <span class="comment">//  byte of the byterange, but didn't find it. If it isn't set, we'll do the</span>
01663         <span class="comment">//  right thing anyway since Node &lt;- NULL.</span>
01664         <span class="comment">//</span>
01665 
01666         Node = LastOverlapNode;
01667     }
01668 
01669     <span class="keywordflow">if</span> (Node == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01670 
01671         <span class="comment">//</span>
01672         <span class="comment">// No overlapping node existed</span>
01673         <span class="comment">//</span>
01674 
01675         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01676     }
01677 
01678     <span class="comment">//</span>
01679     <span class="comment">// Return the splay links of the first overlapping node</span>
01680     <span class="comment">//</span>
01681 
01682     <span class="keywordflow">return</span> &amp;Node-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o3">Links</a>;
01683 }
01684 
01685 
01686 PRTL_SPLAY_LINKS
<a name="l01687"></a><a class="code" href="../../d5/d3/filelock_8c.html#a44">01687</a> <a class="code" href="../../d5/d3/filelock_8c.html#a44">FsRtlFindFirstOverlappingExclusiveNode</a> (
01688     IN PRTL_SPLAY_LINKS        Tree,
01689     IN PLARGE_INTEGER          StartingByte,
01690     IN PLARGE_INTEGER          EndingByte,
01691     IN OUT PRTL_SPLAY_LINKS    *LastEdgeNode,
01692     IN OUT PBOOLEAN            GreaterThan
01693     )
01694 <span class="comment">/*++</span>
01695 <span class="comment"></span>
01696 <span class="comment">Routine Description:</span>
01697 <span class="comment"></span>
01698 <span class="comment">    This routine returns the first node in the exclusive lock tree which</span>
01699 <span class="comment">    overlaps with the range given. No nodes given by RtlRealPredecessor()</span>
01700 <span class="comment">    on the result overlap the range.</span>
01701 <span class="comment"></span>
01702 <span class="comment">Arguments:</span>
01703 <span class="comment"></span>
01704 <span class="comment">    Tree - supplies the splay links of the root node of the exclusive tree</span>
01705 <span class="comment">        to search</span>
01706 <span class="comment"></span>
01707 <span class="comment">    StartingByte - supplies the first byte offset of the range to check</span>
01708 <span class="comment"></span>
01709 <span class="comment">    EndingByte - supplies the last byte offset of the range to check</span>
01710 <span class="comment"></span>
01711 <span class="comment">    LastEdgeNode - optional, will be set to the last node searched</span>
01712 <span class="comment">        not including returned node (presumeably where a new node will</span>
01713 <span class="comment">        be inserted if return is NULL).</span>
01714 <span class="comment"></span>
01715 <span class="comment">    GreaterThan - optional, set according to whether LastEdgeNode is covering</span>
01716 <span class="comment">        a range greater than the queried range. !GreaterThan == LessThan, since</span>
01717 <span class="comment">        we would have returned this node in the "Equals" (overlap) case.</span>
01718 <span class="comment"></span>
01719 <span class="comment">Return Value:</span>
01720 <span class="comment"></span>
01721 <span class="comment">    The splay links of the node, if such a node exists, NULL otherwise</span>
01722 <span class="comment"></span>
01723 <span class="comment">--*/</span>
01724 {
01725     PRTL_SPLAY_LINKS    SplayLinks;
01726     <a class="code" href="../../d5/d3/filelock_8c.html#a24">PEX_LOCK</a>            <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>, LastOverlapNode;
01727 
01728     <span class="keywordflow">if</span> (LastEdgeNode) *LastEdgeNode = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01729     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d8/fsrtl_8h.html#a189a91">GreaterThan</a>) *<a class="code" href="../../d1/d8/fsrtl_8h.html#a189a91">GreaterThan</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01730 
01731     LastOverlapNode = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01732     SplayLinks = Tree;
01733 
01734     <span class="keywordflow">while</span> (SplayLinks) {
01735 
01736         <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a> = CONTAINING_RECORD( SplayLinks, <a class="code" href="../../d7/d7/struct__EX__LOCK.html">EX_LOCK</a>, Links );
01737 
01738         <span class="comment">//</span>
01739         <span class="comment">//  We may have to go right in the tree if this lock covers a range before the start of this</span>
01740         <span class="comment">//  range we are looking for overlap on or this lock is [0, 0).  This is important since a lock</span>
01741         <span class="comment">//  on [0, 0) will look like the extent is from [0, ~0], which is the only case where the zero</span>
01742         <span class="comment">//  length lock relation of End &lt; Start does not hold.</span>
01743         <span class="comment">//</span>
01744 
01745         <span class="keywordflow">if</span> ((ULONGLONG)<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.EndingByte.QuadPart &lt; (ULONGLONG)StartingByte-&gt;QuadPart ||
01746             (<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.StartingByte.QuadPart == 0 &amp;&amp; <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.Length.QuadPart == 0)) {
01747 
01748             <span class="keywordflow">if</span> ((ULONGLONG)<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.EndingByte.QuadPart == (ULONGLONG)EndingByte-&gt;QuadPart &amp;&amp;
01749                 (ULONGLONG)<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.StartingByte.QuadPart == (ULONGLONG)StartingByte-&gt;QuadPart) {
01750 
01751                 <span class="comment">//</span>
01752                 <span class="comment">//  The extent of the lock is less than the starting position of the</span>
01753                 <span class="comment">//  range we are checking and the lock is equal to the range, which</span>
01754                 <span class="comment">//  implies that the range and the lock are zero length.</span>
01755                 <span class="comment">//</span>
01756                 <span class="comment">//  This is a zero length lock node and we are searching for zero</span>
01757                 <span class="comment">//  length overlap. Since the exclusive tree is one lock per node,</span>
01758                 <span class="comment">//  we are in the potential middle of a run of zero length locks in</span>
01759                 <span class="comment">//  the tree. Go left to find the first zero length lock.</span>
01760                 <span class="comment">//</span>
01761                 <span class="comment">//  This is actually the same logic we'd use for equivalent locks,</span>
01762                 <span class="comment">//  but the only time that can happen in this tree is for zero length</span>
01763                 <span class="comment">//  locks.</span>
01764                 <span class="comment">//</span>
01765 
01766                 LastOverlapNode = <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>;
01767 
01768                 <span class="keywordflow">if</span> (LastEdgeNode) *LastEdgeNode = SplayLinks;
01769                 <span class="keywordflow">if</span> (<a class="code" href="../../d1/d8/fsrtl_8h.html#a189a91">GreaterThan</a>) *<a class="code" href="../../d1/d8/fsrtl_8h.html#a189a91">GreaterThan</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01770 
01771                 SplayLinks = RtlLeftChild(SplayLinks);
01772                 <span class="keywordflow">continue</span>;
01773             }
01774 
01775             <span class="comment">//</span>
01776             <span class="comment">//  This lock is strictly less than this byterange, so go</span>
01777             <span class="comment">//  right in the tree.</span>
01778             <span class="comment">//</span>
01779 
01780             <span class="keywordflow">if</span> (LastEdgeNode) *LastEdgeNode = SplayLinks;
01781             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d8/fsrtl_8h.html#a189a91">GreaterThan</a>) *<a class="code" href="../../d1/d8/fsrtl_8h.html#a189a91">GreaterThan</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01782 
01783             SplayLinks = RtlRightChild(SplayLinks);
01784             <span class="keywordflow">continue</span>;
01785         }
01786 
01787         <span class="keywordflow">if</span> ((ULONGLONG)<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.StartingByte.QuadPart &lt;= (ULONGLONG)EndingByte-&gt;QuadPart) {
01788 
01789             <span class="comment">//</span>
01790             <span class="comment">//  We have an overlap, but we need to see if the byterange starts</span>
01791             <span class="comment">//  before this node so that there is the guarantee that we start</span>
01792             <span class="comment">//  the search at the correct point. There may be still be predecessor</span>
01793             <span class="comment">//  nodes covering the byterange.</span>
01794             <span class="comment">//</span>
01795 
01796             <span class="keywordflow">if</span> ((ULONGLONG)<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.StartingByte.QuadPart &lt;= (ULONGLONG)StartingByte-&gt;QuadPart) {
01797 
01798                 <span class="comment">//</span>
01799                 <span class="comment">//  This node begins at a byte offset prior to the byterange we</span>
01800                 <span class="comment">//  are checking, so it must be the correct starting position.</span>
01801                 <span class="comment">//</span>
01802 
01803                 <span class="keywordflow">break</span>;
01804             }
01805 
01806             <span class="comment">//</span>
01807             <span class="comment">//  Drop a marker at this node so that we can come back if it turns out</span>
01808             <span class="comment">//  that the left subtree does not cover the range of bytes before this</span>
01809             <span class="comment">//  node in the byterange.</span>
01810             <span class="comment">//</span>
01811 
01812             LastOverlapNode = <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>;
01813         }
01814 
01815         <span class="comment">//</span>
01816         <span class="comment">//  It must now be the case this lock is strictly greater than the byterange,</span>
01817         <span class="comment">//  or we have the candidate overlap case above, so go left in the tree.</span>
01818         <span class="comment">//</span>
01819 
01820         <span class="keywordflow">if</span> (LastEdgeNode) *LastEdgeNode = SplayLinks;
01821         <span class="keywordflow">if</span> (<a class="code" href="../../d1/d8/fsrtl_8h.html#a189a91">GreaterThan</a>) *<a class="code" href="../../d1/d8/fsrtl_8h.html#a189a91">GreaterThan</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01822 
01823         SplayLinks = RtlLeftChild(SplayLinks);
01824     }
01825 
01826     <span class="keywordflow">if</span> (SplayLinks == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01827 
01828         <span class="comment">//</span>
01829         <span class="comment">//  We hit the edge of the tree. If the LastOverlapNode is set, it means that</span>
01830         <span class="comment">//  we had kept searching left in the tree for a node that covered the starting</span>
01831         <span class="comment">//  byte of the byterange, but didn't find it. If it isn't set, we'll do the</span>
01832         <span class="comment">//  right thing anyway since Node &lt;- NULL.</span>
01833         <span class="comment">//</span>
01834 
01835         <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a> = LastOverlapNode;
01836     }
01837 
01838     <span class="keywordflow">if</span> (<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01839 
01840         <span class="comment">//</span>
01841         <span class="comment">// No overlapping lock existed</span>
01842         <span class="comment">//</span>
01843 
01844         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01845     }
01846 
01847     <span class="comment">//</span>
01848     <span class="comment">// Return the splay links of the first overlapping lock</span>
01849     <span class="comment">//</span>
01850 
01851     <span class="keywordflow">return</span> &amp;<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;Links;
01852 }
01853 
01854 
01855 <a class="code" href="../../d5/d3/filelock_8c.html#a22">PSH_LOCK</a>
<a name="l01856"></a><a class="code" href="../../d5/d3/filelock_8c.html#a45">01856</a> <a class="code" href="../../d5/d3/filelock_8c.html#a45">FsRtlFindFirstOverlapInNode</a> (
01857     IN PLOCKTREE_NODE Node,
01858     IN PLARGE_INTEGER StartingByte,
01859     IN PLARGE_INTEGER EndingByte
01860     )
01861 
01862 <span class="comment">/*++</span>
01863 <span class="comment"></span>
01864 <span class="comment">Routine Description:</span>
01865 <span class="comment"></span>
01866 <span class="comment">    This routine examines a shared lock node, usually a node which is known to be composed</span>
01867 <span class="comment">    of several non-overlapping lock segments (holey), for true overlap with the indicated</span>
01868 <span class="comment">    range.  This is not handled in the normal overlap check (..FindFirstOverlappingSharedLock)</span>
01869 <span class="comment">    since the needs for holey checks are rather different than the full node check.</span>
01870 <span class="comment"></span>
01871 <span class="comment">Arguments:</span>
01872 <span class="comment"></span>
01873 <span class="comment">    Node - the lock tree node to be examined for overlap</span>
01874 <span class="comment"></span>
01875 <span class="comment">    StartingByte - supplies the first byte offset of the range to check</span>
01876 <span class="comment"></span>
01877 <span class="comment">    EndingByte - supplies the last byte offset of the range to check</span>
01878 <span class="comment"></span>
01879 <span class="comment">Return Value:</span>
01880 <span class="comment"></span>
01881 <span class="comment">    PSH_LOCK - the first lock which overlaps with the specified range.</span>
01882 <span class="comment"></span>
01883 <span class="comment">--*/</span>
01884 {
01885     <a class="code" href="../../d5/d3/filelock_8c.html#a22">PSH_LOCK</a> <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>;
01886     PSINGLE_LIST_ENTRY Link;
01887 
01888     <span class="keywordflow">for</span> (Link = Node-&gt;Locks.Next;
01889          Link;
01890          Link = Link-&gt;Next) {
01891 
01892         <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a> = CONTAINING_RECORD( Link, <a class="code" href="../../d8/d2/struct__SH__LOCK.html">SH_LOCK</a>, Link );
01893 
01894         <span class="comment">//</span>
01895         <span class="comment">//  Logic is the same as above checkers.  If the ending byte of the lock is less than the</span>
01896         <span class="comment">//  starting byte of the range, OR we have the weird [0, 0) case, then the lock is almost</span>
01897         <span class="comment">//  certainly less than the range.</span>
01898         <span class="comment">//</span>
01899 
01900         <span class="keywordflow">if</span> ((ULONGLONG)<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.EndingByte.QuadPart &lt; (ULONGLONG)StartingByte-&gt;QuadPart ||
01901             (<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.StartingByte.QuadPart == 0 &amp;&amp; <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.Length.QuadPart == 0)) {
01902 
01903             <span class="comment">//</span>
01904             <span class="comment">//  ... except if the lock and range are equivalent, in which case we have discovered</span>
01905             <span class="comment">//  zero lock/range overlap.</span>
01906             <span class="comment">//</span>
01907 
01908             <span class="keywordflow">if</span> ((ULONGLONG)<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.EndingByte.QuadPart == (ULONGLONG)EndingByte-&gt;QuadPart &amp;&amp;
01909                 (ULONGLONG)<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.StartingByte.QuadPart == (ULONGLONG)StartingByte-&gt;QuadPart) {
01910 
01911                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>;
01912             }
01913 
01914             <span class="comment">//</span>
01915             <span class="comment">//  Look forward in the node.</span>
01916             <span class="comment">//</span>
01917 
01918             <span class="keywordflow">continue</span>;
01919         }
01920 
01921         <span class="comment">//</span>
01922         <span class="comment">//  No overlap at all if the lock begins at a higher byte than the last of the range.</span>
01923         <span class="comment">//  We already covered zero length locks (where this is true, and overlap could still</span>
01924         <span class="comment">//  occur).</span>
01925         <span class="comment">//</span>
01926 
01927         <span class="keywordflow">if</span> ((ULONGLONG)<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.StartingByte.QuadPart &gt; (ULONGLONG)EndingByte-&gt;QuadPart) {
01928 
01929             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01930         }
01931 
01932         <span class="comment">//</span>
01933         <span class="comment">//  Regular overlap has occured.  Return this lock.</span>
01934         <span class="comment">//</span>
01935 
01936         <span class="keywordflow">return</span> <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>;
01937     }
01938 
01939     <span class="comment">//</span>
01940     <span class="comment">//  If we invoke this check and wander off the end of the node without determining what is</span>
01941     <span class="comment">//  going on, something is terribly wrong.</span>
01942     <span class="comment">//</span>
01943 
01944     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01945 
01946     <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01947 }
01948 
01949 
01950 <a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html">PFILE_LOCK_INFO</a>
<a name="l01951"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a121">01951</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a121">FsRtlGetNextFileLock</a> (
01952     IN <a class="code" href="../../d7/d1/struct__FILE__LOCK.html">PFILE_LOCK</a> FileLock,
01953     IN BOOLEAN Restart
01954     )
01955 
01956 <span class="comment">/*++</span>
01957 <span class="comment"></span>
01958 <span class="comment">Routine Description:</span>
01959 <span class="comment"></span>
01960 <span class="comment">    This routine enumerates the individual file locks denoted by the input file lock</span>
01961 <span class="comment">    variable. It returns a pointer to the file lock information stored for each lock.</span>
01962 <span class="comment">    The caller is responsible for synchronizing call to this procedure and for not</span>
01963 <span class="comment">    altering any of the data returned by this procedure. If the caller does not</span>
01964 <span class="comment">    synchronize the enumeration will not be reliably complete.</span>
01965 <span class="comment"></span>
01966 <span class="comment">    The way a programmer will use this procedure to enumerate all of the locks</span>
01967 <span class="comment">    is as follows:</span>
01968 <span class="comment"></span>
01969 <span class="comment">    for (p = FsRtlGetNextFileLock( FileLock, TRUE );</span>
01970 <span class="comment">         p != NULL;</span>
01971 <span class="comment">         p = FsRtlGetNextFileLock( FileLock, FALSE )) {</span>
01972 <span class="comment"></span>
01973 <span class="comment">            // Process the lock information referenced by p</span>
01974 <span class="comment">    }</span>
01975 <span class="comment"></span>
01976 <span class="comment">    Order is *not* guaranteed.</span>
01977 <span class="comment"></span>
01978 <span class="comment">Arguments:</span>
01979 <span class="comment"></span>
01980 <span class="comment">    FileLock - Supplies the File Lock to enumerate.  The current</span>
01981 <span class="comment">        enumeration state is stored in the file lock variable so if multiple</span>
01982 <span class="comment">        threads are enumerating the lock at the same time the results will</span>
01983 <span class="comment">        be unpredictable.</span>
01984 <span class="comment"></span>
01985 <span class="comment">    Restart - Indicates if the enumeration is to start at the beginning of the</span>
01986 <span class="comment">        file lock tree or if we are continuing from a previous call.</span>
01987 <span class="comment"></span>
01988 <span class="comment">Return Value:</span>
01989 <span class="comment"></span>
01990 <span class="comment">    PFILE_LOCK_INFO - Either it returns a pointer to the next file lock</span>
01991 <span class="comment">        record for the input file lock or it returns NULL if there</span>
01992 <span class="comment">        are not more locks.</span>
01993 <span class="comment"></span>
01994 <span class="comment">--*/</span>
01995 
01996 {
01997     <a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html">FILE_LOCK_INFO</a>      FileLockInfo;
01998     PVOID               ContinuationPointer;
01999     <a class="code" href="../../d5/d3/filelock_8c.html#a30">PLOCK_INFO</a>          LockInfo;
02000     <a class="code" href="../../d5/d3/filelock_8c.html#a20">PLOCKTREE_NODE</a>      Node;
02001     PSINGLE_LIST_ENTRY  Link;
02002     PRTL_SPLAY_LINKS    SplayLinks, LastSplayLinks;
02003     <a class="code" href="../../d5/d3/filelock_8c.html#a22">PSH_LOCK</a>            ShLock;
02004     <a class="code" href="../../d5/d3/filelock_8c.html#a24">PEX_LOCK</a>            ExLock;
02005     BOOLEAN             FoundReturnable, <a class="code" href="../../d1/d8/fsrtl_8h.html#a189a91">GreaterThan</a>;
02006     KIRQL               OldIrql;
02007 
02008     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlGetNextFileLock, FileLock = %08lx\n"</span>, FileLock);
02009 
02010     <span class="keywordflow">if</span> ((LockInfo = (<a class="code" href="../../d5/d3/filelock_8c.html#a30">PLOCK_INFO</a>) FileLock-&gt;LockInformation) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02011         <span class="comment">//</span>
02012         <span class="comment">//  No lock information on this FileLock</span>
02013         <span class="comment">//</span>
02014 
02015         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02016     }
02017 
02018     FoundReturnable = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02019 
02020     <span class="comment">//</span>
02021     <span class="comment">//  Before getting the spinlock, copy pagable info onto stack</span>
02022     <span class="comment">//</span>
02023 
02024     FileLockInfo = FileLock-&gt;LastReturnedLockInfo;
02025     ContinuationPointer = FileLock-&gt;LastReturnedLock;
02026 
02027     <a class="code" href="../../d5/d3/filelock_8c.html#a8">FsRtlAcquireLockQueue</a> (&amp;LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>, &amp;OldIrql);
02028 
02029     <span class="keywordflow">if</span> (!Restart) {
02030         <span class="comment">//</span>
02031         <span class="comment">//  Given the last returned lock, find its current successor in the tree.</span>
02032         <span class="comment">//  Previous implementations would reset the enumeration if the last returned</span>
02033         <span class="comment">//  lock had been removed from the tree but I think we can be better in that</span>
02034         <span class="comment">//  case since every other structure modifying event (add new locks, delete</span>
02035         <span class="comment">//  other locks) would *not* have caused the reset. Possible minor performance</span>
02036         <span class="comment">//  enhancement.</span>
02037         <span class="comment">//</span>
02038 
02039         <span class="comment">//</span>
02040         <span class="comment">//  Find the node which could contain the last returned lock. We enumerate the</span>
02041         <span class="comment">//  exclusive lock tree, then the shared lock tree. Find the one we're enumerating.</span>
02042         <span class="comment">//</span>
02043 
02044         <span class="keywordflow">if</span> (FileLockInfo.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o2">ExclusiveLock</a>) {
02045 
02046             <span class="comment">//</span>
02047             <span class="comment">//  Continue enumeration in the exclusive lock tree</span>
02048             <span class="comment">//</span>
02049 
02050             ExLock = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02051 
02052             SplayLinks = <a class="code" href="../../d5/d3/filelock_8c.html#a44">FsRtlFindFirstOverlappingExclusiveNode</a>( LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>.<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o2">ExclusiveLockTree</a>,
02053                                                                  &amp;FileLockInfo.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o0">StartingByte</a>,
02054                                                                  &amp;FileLockInfo.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o6">EndingByte</a>,
02055                                                                  &amp;LastSplayLinks,
02056                                                                  &amp;<a class="code" href="../../d1/d8/fsrtl_8h.html#a189a91">GreaterThan</a> );
02057 
02058             <span class="keywordflow">if</span> (SplayLinks == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02059 
02060                 <span class="comment">//</span>
02061                 <span class="comment">//  No overlapping nodes were found, try to find successor</span>
02062                 <span class="comment">//</span>
02063 
02064                 <span class="keywordflow">if</span> (<a class="code" href="../../d1/d8/fsrtl_8h.html#a189a91">GreaterThan</a>) {
02065 
02066                     <span class="comment">//</span>
02067                     <span class="comment">//  Last node looked at was greater than the lock so it is</span>
02068                     <span class="comment">//  the place to pick up the enumeration</span>
02069                     <span class="comment">//</span>
02070 
02071                     SplayLinks = LastSplayLinks;
02072 
02073                 } <span class="keywordflow">else</span> {
02074 
02075                     <span class="comment">//</span>
02076                     <span class="comment">// Last node looked at was less than the lock so grab its successor</span>
02077                     <span class="comment">//</span>
02078 
02079                     <span class="keywordflow">if</span> (LastSplayLinks) {
02080 
02081                         SplayLinks = <a class="code" href="../../d3/d4/splay_8c.html#a8">RtlRealSuccessor</a>(LastSplayLinks);
02082                     }
02083                 }
02084 
02085             } <span class="keywordflow">else</span> {
02086 
02087                 <span class="comment">//</span>
02088                 <span class="comment">//  Found an overlapping lock, see if it is the last returned</span>
02089                 <span class="comment">//</span>
02090 
02091                 <span class="keywordflow">for</span> (;
02092                     SplayLinks;
02093                     SplayLinks = <a class="code" href="../../d3/d4/splay_8c.html#a8">RtlRealSuccessor</a>(SplayLinks)) {
02094 
02095                     ExLock = CONTAINING_RECORD( SplayLinks, <a class="code" href="../../d7/d7/struct__EX__LOCK.html">EX_LOCK</a>, Links );
02096 
02097                     <span class="keywordflow">if</span> (ContinuationPointer == ExLock &amp;&amp;
02098                         (ULONGLONG)FileLockInfo.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o0">StartingByte</a>.QuadPart == (ULONGLONG)ExLock-&gt;<a class="code" href="../../d7/d7/struct__EX__LOCK.html#o1">LockInfo</a>.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o0">StartingByte</a>.QuadPart &amp;&amp;
02099                         (ULONGLONG)FileLockInfo.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o1">Length</a>.QuadPart == (ULONGLONG)ExLock-&gt;<a class="code" href="../../d7/d7/struct__EX__LOCK.html#o1">LockInfo</a>.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o1">Length</a>.QuadPart &amp;&amp;
02100                         FileLockInfo.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o3">Key</a> == ExLock-&gt;<a class="code" href="../../d7/d7/struct__EX__LOCK.html#o1">LockInfo</a>.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o3">Key</a> &amp;&amp;
02101                         FileLockInfo.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o4">FileObject</a> == ExLock-&gt;<a class="code" href="../../d7/d7/struct__EX__LOCK.html#o1">LockInfo</a>.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o4">FileObject</a> &amp;&amp;
02102                         FileLockInfo.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o5">ProcessId</a> == ExLock-&gt;<a class="code" href="../../d7/d7/struct__EX__LOCK.html#o1">LockInfo</a>.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o5">ProcessId</a>) {
02103 
02104                         <span class="comment">//</span>
02105                         <span class="comment">//  Found last returned, dig up its successor</span>
02106                         <span class="comment">//</span>
02107 
02108                         SplayLinks = <a class="code" href="../../d3/d4/splay_8c.html#a8">RtlRealSuccessor</a>(SplayLinks);
02109 
02110                         <span class="comment">//</span>
02111                         <span class="comment">//  Got the node cold, so we're done</span>
02112                         <span class="comment">//</span>
02113 
02114                         <span class="keywordflow">break</span>;
02115                     }
02116 
02117                     <span class="comment">//</span>
02118                     <span class="comment">//  This lock overlapped and was not the last returned. In fact, since this lock would</span>
02119                     <span class="comment">//  have conflicted with the last returned we know it could not have been returned</span>
02120                     <span class="comment">//  before, so this should be returned to the caller.</span>
02121                     <span class="comment">//</span>
02122                     <span class="comment">//  However, if it is a zero length lock we are looking for and a zero length lock we hit,</span>
02123                     <span class="comment">//  we are at the beginning of a run we need to inspect. If we cannot find the last lock</span>
02124                     <span class="comment">//  we returned, resume the enumeration at the beginning of the run.</span>
02125                     <span class="comment">//</span>
02126 
02127                     <span class="keywordflow">if</span> (ExLock-&gt;<a class="code" href="../../d7/d7/struct__EX__LOCK.html#o1">LockInfo</a>.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o1">Length</a>.QuadPart != 0 || FileLockInfo.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o1">Length</a>.QuadPart != 0) {
02128 
02129                         <span class="keywordflow">break</span>;
02130                     }
02131 
02132                     <span class="comment">//</span>
02133                     <span class="comment">//  Keep wandering down the run</span>
02134                     <span class="comment">//</span>
02135                 }
02136             }
02137 
02138             <span class="comment">//</span>
02139             <span class="comment">//  Were we able to find a lock to return?</span>
02140             <span class="comment">//</span>
02141 
02142             <span class="keywordflow">if</span> (SplayLinks == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02143 
02144                 <span class="comment">//</span>
02145                 <span class="comment">//  There aren't any more exclusive locks, fall over to the shared tree</span>
02146                 <span class="comment">//</span>
02147 
02148                 SplayLinks = LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>.<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o1">SharedLockTree</a>;
02149 
02150                 <span class="keywordflow">if</span> (SplayLinks) {
02151 
02152                     <span class="keywordflow">while</span> (RtlLeftChild(SplayLinks)) {
02153 
02154                         SplayLinks = RtlLeftChild(SplayLinks);
02155                     }
02156 
02157                     Node = CONTAINING_RECORD(SplayLinks, <a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html">LOCKTREE_NODE</a>, Links);
02158                     ShLock = CONTAINING_RECORD(Node-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o0">Locks</a>.Next, <a class="code" href="../../d8/d2/struct__SH__LOCK.html">SH_LOCK</a>, Link);
02159 
02160                     FileLockInfo = ShLock-&gt;<a class="code" href="../../d8/d2/struct__SH__LOCK.html#o1">LockInfo</a>;
02161                     ContinuationPointer = ShLock;
02162                     FoundReturnable = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02163                 }
02164 
02165             } <span class="keywordflow">else</span> {
02166 
02167                 <span class="comment">//</span>
02168                 <span class="comment">//  This is the lock to return</span>
02169                 <span class="comment">//</span>
02170 
02171                 ExLock = CONTAINING_RECORD( SplayLinks, <a class="code" href="../../d7/d7/struct__EX__LOCK.html">EX_LOCK</a>, Links );
02172 
02173                 FileLockInfo = ExLock-&gt;<a class="code" href="../../d7/d7/struct__EX__LOCK.html#o1">LockInfo</a>;
02174                 ContinuationPointer = ExLock;
02175                 FoundReturnable = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02176             }
02177 
02178         } <span class="keywordflow">else</span> {
02179 
02180             <span class="comment">//</span>
02181             <span class="comment">//  Continue enumeration in the shared lock tree</span>
02182             <span class="comment">//</span>
02183 
02184             Node = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02185 
02186             SplayLinks = <a class="code" href="../../d5/d3/filelock_8c.html#a43">FsRtlFindFirstOverlappingSharedNode</a>( LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>.<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o1">SharedLockTree</a>,
02187                                                               &amp;FileLockInfo.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o0">StartingByte</a>,
02188                                                               &amp;FileLockInfo.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o6">EndingByte</a>,
02189                                                               &amp;LastSplayLinks,
02190                                                               &amp;<a class="code" href="../../d1/d8/fsrtl_8h.html#a189a91">GreaterThan</a> );
02191 
02192             <span class="keywordflow">if</span> (SplayLinks == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02193 
02194                 <span class="comment">//</span>
02195                 <span class="comment">//  No overlapping nodes were found</span>
02196                 <span class="comment">//</span>
02197 
02198                 <span class="keywordflow">if</span> (<a class="code" href="../../d1/d8/fsrtl_8h.html#a189a91">GreaterThan</a>) {
02199 
02200                     <span class="comment">//</span>
02201                     <span class="comment">//  Last node looked at was greater than the lock so it is</span>
02202                     <span class="comment">//  the place to pick up the enumeration</span>
02203                     <span class="comment">//</span>
02204 
02205                     <span class="keywordflow">if</span> (LastSplayLinks) {
02206 
02207                         SplayLinks = LastSplayLinks;
02208                         Node = CONTAINING_RECORD( LastSplayLinks, <a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html">LOCKTREE_NODE</a>, Links );
02209                     }
02210 
02211                 } <span class="keywordflow">else</span> {
02212 
02213                     <span class="comment">//</span>
02214                     <span class="comment">// Last node looked at was less than the lock so grab its successor</span>
02215                     <span class="comment">//</span>
02216 
02217                     <span class="keywordflow">if</span> (LastSplayLinks) {
02218 
02219                         SplayLinks = <a class="code" href="../../d3/d4/splay_8c.html#a8">RtlRealSuccessor</a>(LastSplayLinks);
02220 
02221                         <span class="keywordflow">if</span> (SplayLinks) {
02222 
02223                             Node = CONTAINING_RECORD( SplayLinks, <a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html">LOCKTREE_NODE</a>, Links );
02224                         }
02225                     }
02226                 }
02227 
02228             } <span class="keywordflow">else</span> {
02229 
02230                 <span class="comment">//</span>
02231                 <span class="comment">//  Grab the node we found</span>
02232                 <span class="comment">//</span>
02233 
02234                 Node = CONTAINING_RECORD( SplayLinks, <a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html">LOCKTREE_NODE</a>, Links );
02235             }
02236 
02237             <span class="comment">//</span>
02238             <span class="comment">//  If we have a node to look at, it may still not contain the the last returned lock</span>
02239             <span class="comment">//  if this isn't synchronized.</span>
02240             <span class="comment">//</span>
02241 
02242             <span class="keywordflow">if</span> (Node != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02243 
02244                 <span class="comment">//</span>
02245                 <span class="comment">//    Walk down the locks at this node looking for the last returned lock</span>
02246                 <span class="comment">//</span>
02247 
02248                 <span class="keywordflow">for</span> (Link = Node-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o0">Locks</a>.Next;
02249                      Link;
02250                      Link = Link-&gt;Next) {
02251 
02252                     <span class="comment">//</span>
02253                     <span class="comment">//  Get a pointer to the current lock record</span>
02254                     <span class="comment">//</span>
02255 
02256                     ShLock = CONTAINING_RECORD( Link, <a class="code" href="../../d8/d2/struct__SH__LOCK.html">SH_LOCK</a>, Link );
02257 
02258                     <span class="comment">//</span>
02259                     <span class="comment">// See if it's a match</span>
02260                     <span class="comment">//</span>
02261 
02262                     <span class="keywordflow">if</span> (ContinuationPointer == ShLock &amp;&amp;
02263                         (ULONGLONG)FileLockInfo.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o0">StartingByte</a>.QuadPart == (ULONGLONG)ShLock-&gt;<a class="code" href="../../d8/d2/struct__SH__LOCK.html#o1">LockInfo</a>.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o0">StartingByte</a>.QuadPart &amp;&amp;
02264                         (ULONGLONG)FileLockInfo.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o1">Length</a>.QuadPart == (ULONGLONG)ShLock-&gt;<a class="code" href="../../d8/d2/struct__SH__LOCK.html#o1">LockInfo</a>.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o1">Length</a>.QuadPart &amp;&amp;
02265                         FileLockInfo.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o3">Key</a> == ShLock-&gt;<a class="code" href="../../d8/d2/struct__SH__LOCK.html#o1">LockInfo</a>.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o3">Key</a> &amp;&amp;
02266                         FileLockInfo.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o4">FileObject</a> == ShLock-&gt;<a class="code" href="../../d8/d2/struct__SH__LOCK.html#o1">LockInfo</a>.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o4">FileObject</a> &amp;&amp;
02267                         FileLockInfo.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o5">ProcessId</a> == ShLock-&gt;<a class="code" href="../../d8/d2/struct__SH__LOCK.html#o1">LockInfo</a>.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o5">ProcessId</a>) {
02268 
02269                         Link = Link-&gt;Next;
02270                         <span class="keywordflow">break</span>;
02271                     }
02272 
02273                     <span class="comment">//</span>
02274                     <span class="comment">// See if we passed by its slot</span>
02275                     <span class="comment">//</span>
02276 
02277                     <span class="keywordflow">if</span> ((ULONGLONG)FileLockInfo.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o0">StartingByte</a>.QuadPart &lt; (ULONGLONG)ShLock-&gt;<a class="code" href="../../d8/d2/struct__SH__LOCK.html#o1">LockInfo</a>.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o0">StartingByte</a>.QuadPart) {
02278 
02279                         <span class="keywordflow">break</span>;
02280                     }
02281                 }
02282 
02283                 <span class="keywordflow">if</span> (Link == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02284 
02285                     <span class="comment">//</span>
02286                     <span class="comment">//  This node doesn't contain the successor, so move</span>
02287                     <span class="comment">//  up to the successor node in the tree and return the</span>
02288                     <span class="comment">//  first lock. If we're actually at the end of the tree</span>
02289                     <span class="comment">//  we just fall off the end correctly.</span>
02290                     <span class="comment">//</span>
02291 
02292                     SplayLinks = <a class="code" href="../../d3/d4/splay_8c.html#a8">RtlRealSuccessor</a>(SplayLinks);
02293 
02294                     <span class="keywordflow">if</span> (SplayLinks) {
02295 
02296                         Node = CONTAINING_RECORD( SplayLinks, <a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html">LOCKTREE_NODE</a>, Links );
02297 
02298                         Link = Node-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o0">Locks</a>.Next;
02299                     }
02300                 }
02301 
02302                 <span class="keywordflow">if</span> (Link) {
02303 
02304                     <span class="comment">//</span>
02305                     <span class="comment">//  Found a Lock to return, copy it to the stack</span>
02306                     <span class="comment">//</span>
02307 
02308                     ShLock = CONTAINING_RECORD( Link, <a class="code" href="../../d8/d2/struct__SH__LOCK.html">SH_LOCK</a>, Link );
02309 
02310                     FileLockInfo = ShLock-&gt;<a class="code" href="../../d8/d2/struct__SH__LOCK.html#o1">LockInfo</a>;
02311                     ContinuationPointer = ShLock;
02312                     FoundReturnable = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02313                 }
02314 
02315             }
02316         }
02317 
02318     } <span class="keywordflow">else</span> {
02319 
02320         <span class="comment">//</span>
02321         <span class="comment">//  Restarting the enumeration. Find leftmost node in the exclusive tree and hand back</span>
02322         <span class="comment">//  the first lock, falling over to the shared if no exlcusive locks are applied</span>
02323         <span class="comment">//</span>
02324 
02325         <span class="keywordflow">if</span> (LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>.<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o2">ExclusiveLockTree</a>) {
02326 
02327             SplayLinks = LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>.<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o2">ExclusiveLockTree</a>;
02328 
02329             <span class="keywordflow">while</span> (RtlLeftChild(SplayLinks) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02330 
02331                 SplayLinks = RtlLeftChild(SplayLinks);
02332             }
02333 
02334             ExLock = CONTAINING_RECORD( SplayLinks, <a class="code" href="../../d7/d7/struct__EX__LOCK.html">EX_LOCK</a>, Links );
02335 
02336             FileLockInfo = ExLock-&gt;<a class="code" href="../../d7/d7/struct__EX__LOCK.html#o1">LockInfo</a>;
02337             ContinuationPointer = ExLock;
02338             FoundReturnable = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02339 
02340         } <span class="keywordflow">else</span> {
02341 
02342             <span class="keywordflow">if</span> (LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>.<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o1">SharedLockTree</a>) {
02343 
02344                 SplayLinks = LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>.<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o1">SharedLockTree</a>;
02345 
02346                 <span class="keywordflow">while</span> (RtlLeftChild(SplayLinks) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02347 
02348                     SplayLinks = RtlLeftChild(SplayLinks);
02349                 }
02350 
02351                 Node = CONTAINING_RECORD( SplayLinks, <a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html">LOCKTREE_NODE</a>, Links );
02352                 ShLock = CONTAINING_RECORD( Node-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o0">Locks</a>.Next, <a class="code" href="../../d8/d2/struct__SH__LOCK.html">SH_LOCK</a>, Link );
02353 
02354                 FileLockInfo = ShLock-&gt;<a class="code" href="../../d8/d2/struct__SH__LOCK.html#o1">LockInfo</a>;
02355                 ContinuationPointer = ShLock;
02356                 FoundReturnable = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02357             }
02358         }
02359     }
02360 
02361     <span class="comment">//</span>
02362     <span class="comment">//  Release all the lock queues</span>
02363     <span class="comment">//</span>
02364 
02365     <a class="code" href="../../d5/d3/filelock_8c.html#a10">FsRtlReleaseLockQueue</a> (&amp;LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>, OldIrql);
02366 
02367     <span class="keywordflow">if</span> (!FoundReturnable) {
02368 
02369         <span class="comment">//</span>
02370         <span class="comment">//  No returnable lock was found, end of list</span>
02371         <span class="comment">//</span>
02372 
02373         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02374     }
02375 
02376     <span class="comment">//</span>
02377     <span class="comment">// Update current enum location information</span>
02378     <span class="comment">//</span>
02379 
02380     FileLock-&gt;LastReturnedLockInfo = FileLockInfo;
02381     FileLock-&gt;LastReturnedLock = ContinuationPointer;
02382 
02383     <span class="comment">//</span>
02384     <span class="comment">// Return lock record to caller</span>
02385     <span class="comment">//</span>
02386 
02387     <span class="keywordflow">return</span> &amp;FileLock-&gt;LastReturnedLockInfo;
02388 }
02389 
02390 
02391 BOOLEAN
<a name="l02392"></a><a class="code" href="../../d5/d3/filelock_8c.html#a56">02392</a> <a class="code" href="../../d5/d3/filelock_8c.html#a56">FsRtlCheckNoSharedConflict</a> (
02393    IN PLOCK_QUEUE LockQueue,
02394    IN PLARGE_INTEGER Starting,
02395    IN PLARGE_INTEGER Ending
02396    )
02397 <span class="comment">/*++</span>
02398 <span class="comment"></span>
02399 <span class="comment">Routine Description:</span>
02400 <span class="comment"></span>
02401 <span class="comment">    This routine checks to see if there is overlap in the shared locks with</span>
02402 <span class="comment">    the given range. It is intended for use in the write access check path</span>
02403 <span class="comment">    so that a rebalance will occur.</span>
02404 <span class="comment"></span>
02405 <span class="comment">Arguments:</span>
02406 <span class="comment"></span>
02407 <span class="comment">    FileLock - Supplies the File Lock to check</span>
02408 <span class="comment"></span>
02409 <span class="comment">    StartingByte - Supplies the first byte (zero based) to check</span>
02410 <span class="comment"></span>
02411 <span class="comment">    Length - Supplies the length, in bytes, to check</span>
02412 <span class="comment"></span>
02413 <span class="comment">    Key - Supplies the key to use in the check</span>
02414 <span class="comment"></span>
02415 <span class="comment">    FileObject - Supplies the file object to use in the check</span>
02416 <span class="comment"></span>
02417 <span class="comment">    ProcessId - Supplies the Process Id to use in the check</span>
02418 <span class="comment"></span>
02419 <span class="comment">Return Value:</span>
02420 <span class="comment"></span>
02421 <span class="comment">    BOOLEAN - TRUE if the indicated user/request doesn't conflict in</span>
02422 <span class="comment">        entire specified byte range, and FALSE otherwise</span>
02423 <span class="comment"></span>
02424 <span class="comment">--*/</span>
02425 {
02426     PRTL_SPLAY_LINKS SplayLinks, BeginLinks;
02427     <a class="code" href="../../d5/d3/filelock_8c.html#a20">PLOCKTREE_NODE</a> Node;
02428 
02429     SplayLinks = <a class="code" href="../../d5/d3/filelock_8c.html#a43">FsRtlFindFirstOverlappingSharedNode</a>( LockQueue-&gt;SharedLockTree,
02430                                                       Starting,
02431                                                       Ending,
02432                                                       &amp;BeginLinks,
02433                                                       <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
02434 
02435     <span class="keywordflow">if</span> (BeginLinks) {
02436 
02437         LockQueue-&gt;SharedLockTree = <a class="code" href="../../d3/d4/splay_8c.html#a3">RtlSplay</a>(BeginLinks);
02438     }
02439 
02440     <span class="comment">//</span>
02441     <span class="comment">//  If this node is holey, we'll have to walk the whole thing.</span>
02442     <span class="comment">//</span>
02443 
02444     <span class="keywordflow">if</span> (SplayLinks) {
02445 
02446         Node = CONTAINING_RECORD( SplayLinks, <a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html">LOCKTREE_NODE</a>, Links );
02447 
02448         <span class="keywordflow">if</span> (Node-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o1">HoleyNode</a>) {
02449 
02450             <span class="keywordflow">return</span> (BOOLEAN)(<a class="code" href="../../d5/d3/filelock_8c.html#a45">FsRtlFindFirstOverlapInNode</a>( Node, Starting, Ending ) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
02451         }
02452 
02453         <span class="comment">//</span>
02454         <span class="comment">//  Overlapping non-holey node, so we do have shared lock conflict.</span>
02455         <span class="comment">//</span>
02456 
02457         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02458     }
02459 
02460     <span class="comment">//</span>
02461     <span class="comment">//  No node overlaps.</span>
02462     <span class="comment">//</span>
02463 
02464     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02465 }
02466 
02467 
02468 BOOLEAN
<a name="l02469"></a><a class="code" href="../../d5/d3/filelock_8c.html#a57">02469</a> <a class="code" href="../../d5/d3/filelock_8c.html#a57">FsRtlCheckNoExclusiveConflict</a> (
02470     IN PLOCK_QUEUE LockQueue,
02471     IN PLARGE_INTEGER Starting,
02472     IN PLARGE_INTEGER Ending,
02473     IN ULONG Key,
02474     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
02475     IN PVOID ProcessId
02476     )
02477 <span class="comment">/*++</span>
02478 <span class="comment"></span>
02479 <span class="comment">Routine Description:</span>
02480 <span class="comment"></span>
02481 <span class="comment">    This routine checks to see if there is conflict in the exclusive locks with</span>
02482 <span class="comment">    a given range and identifying tuple of key, fileobject and process. This is</span>
02483 <span class="comment">    for part of the read access path.</span>
02484 <span class="comment"></span>
02485 <span class="comment">Arguments:</span>
02486 <span class="comment"></span>
02487 <span class="comment">    FileLock - Supplies the File Lock to check</span>
02488 <span class="comment"></span>
02489 <span class="comment">    StartingByte - Supplies the first byte (zero based) to check</span>
02490 <span class="comment"></span>
02491 <span class="comment">    Length - Supplies the length, in bytes, to check</span>
02492 <span class="comment"></span>
02493 <span class="comment">    Key - Supplies the key to use in the check</span>
02494 <span class="comment"></span>
02495 <span class="comment">    FileObject - Supplies the file object to use in the check</span>
02496 <span class="comment"></span>
02497 <span class="comment">    ProcessId - Supplies the Process Id to use in the check</span>
02498 <span class="comment"></span>
02499 <span class="comment">Return Value:</span>
02500 <span class="comment"></span>
02501 <span class="comment">    BOOLEAN - TRUE if the indicated user/request doesn't conflict in</span>
02502 <span class="comment">        entire specified byte range, and FALSE otherwise</span>
02503 <span class="comment"></span>
02504 <span class="comment">--*/</span>
02505 {
02506     PRTL_SPLAY_LINKS SplayLinks, BeginLinks;
02507     <a class="code" href="../../d5/d3/filelock_8c.html#a24">PEX_LOCK</a> <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>;
02508     BOOLEAN <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02509 
02510     <span class="comment">//</span>
02511     <span class="comment">//  Find the node to begin the search at and go</span>
02512     <span class="comment">//</span>
02513 
02514     <span class="keywordflow">for</span> (SplayLinks = <a class="code" href="../../d5/d3/filelock_8c.html#a44">FsRtlFindFirstOverlappingExclusiveNode</a>( LockQueue-&gt;ExclusiveLockTree,
02515                                                               Starting,
02516                                                               Ending,
02517                                                               &amp;BeginLinks,
02518                                                               <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
02519          SplayLinks;
02520          SplayLinks = <a class="code" href="../../d3/d4/splay_8c.html#a8">RtlRealSuccessor</a>(SplayLinks)) {
02521 
02522         <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a> = CONTAINING_RECORD( SplayLinks, <a class="code" href="../../d7/d7/struct__EX__LOCK.html">EX_LOCK</a>, Links );
02523 
02524         <span class="comment">//</span>
02525         <span class="comment">//  If the current lock is greater than the end of the range we're</span>
02526         <span class="comment">//  looking for then the the user doesn't conflict</span>
02527         <span class="comment">//</span>
02528         <span class="comment">//  if (Ending &lt; Lock-&gt;StartingByte) ...</span>
02529         <span class="comment">//</span>
02530 
02531         <span class="keywordflow">if</span> ((ULONGLONG)Ending-&gt;QuadPart &lt; (ULONGLONG)<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.StartingByte.QuadPart) {
02532 
02533             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlCheckForExclusiveConflict, Ending &lt; Lock-&gt;StartingByte\n"</span>, 0);
02534 
02535             <span class="keywordflow">break</span>;
02536         }
02537 
02538         <span class="comment">//</span>
02539         <span class="comment">//  Check for any overlap with the request. The test for</span>
02540         <span class="comment">//  overlap is that starting byte is less than or equal to the locks</span>
02541         <span class="comment">//  ending byte, and the ending byte is greater than or equal to the</span>
02542         <span class="comment">//  locks starting byte.  We already tested for this latter case in</span>
02543         <span class="comment">//  the preceding statement.</span>
02544         <span class="comment">//</span>
02545         <span class="comment">//  if (Starting &lt;= Lock-&gt;StartingByte + Lock-&gt;Length - 1) ...</span>
02546         <span class="comment">//</span>
02547 
02548         <span class="keywordflow">if</span> ((ULONGLONG)Starting-&gt;QuadPart &lt;= (ULONGLONG)<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.EndingByte.QuadPart) {
02549 
02550             <span class="comment">//</span>
02551             <span class="comment">//  This request overlaps the lock. We cannot grant the request</span>
02552             <span class="comment">//  if the file object, process id, and key do not match. Otherwise</span>
02553             <span class="comment">//  we'll continue looping looking at locks</span>
02554             <span class="comment">//</span>
02555 
02556             <span class="keywordflow">if</span> ((<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.FileObject != FileObject) ||
02557                 (<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.ProcessId != ProcessId) ||
02558                 (<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.Key != <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>)) {
02559 
02560                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlCheckForExclusiveConflict, Range locked already\n"</span>, 0);
02561 
02562                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02563                 <span class="keywordflow">break</span>;
02564             }
02565         }
02566     }
02567 
02568     <span class="keywordflow">if</span> (BeginLinks) {
02569 
02570         LockQueue-&gt;ExclusiveLockTree = <a class="code" href="../../d3/d4/splay_8c.html#a3">RtlSplay</a>(BeginLinks);
02571     }
02572 
02573     <span class="comment">//</span>
02574     <span class="comment">//  We searched the entire range without a conflict so we'll note no conflict</span>
02575     <span class="comment">//</span>
02576 
02577     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02578 }
02579 
02580 
02581 BOOLEAN
<a name="l02582"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a119">02582</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a119">FsRtlFastCheckLockForRead</a> (
02583     IN <a class="code" href="../../d7/d1/struct__FILE__LOCK.html">PFILE_LOCK</a> FileLock,
02584     IN PLARGE_INTEGER StartingByte,
02585     IN PLARGE_INTEGER Length,
02586     IN ULONG Key,
02587     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
02588     IN PVOID ProcessId
02589     )
02590 
02591 <span class="comment">/*++</span>
02592 <span class="comment"></span>
02593 <span class="comment">Routine Description:</span>
02594 <span class="comment"></span>
02595 <span class="comment">    This routine checks to see if the caller has read access to the</span>
02596 <span class="comment">    indicated range due to file locks.</span>
02597 <span class="comment"></span>
02598 <span class="comment">Arguments:</span>
02599 <span class="comment"></span>
02600 <span class="comment">    FileLock - Supplies the File Lock to check</span>
02601 <span class="comment"></span>
02602 <span class="comment">    StartingByte - Supplies the first byte (zero based) to check</span>
02603 <span class="comment"></span>
02604 <span class="comment">    Length - Supplies the length, in bytes, to check</span>
02605 <span class="comment"></span>
02606 <span class="comment">    Key - Supplies the to use in the check</span>
02607 <span class="comment"></span>
02608 <span class="comment">    FileObject - Supplies the file object to use in the check</span>
02609 <span class="comment"></span>
02610 <span class="comment">    ProcessId - Supplies the Process Id to use in the check</span>
02611 <span class="comment"></span>
02612 <span class="comment">Return Value:</span>
02613 <span class="comment"></span>
02614 <span class="comment">    BOOLEAN - TRUE if the indicated user/request has read access to the</span>
02615 <span class="comment">        entire specified byte range, and FALSE otherwise</span>
02616 <span class="comment"></span>
02617 <span class="comment">--*/</span>
02618 
02619 {
02620     LARGE_INTEGER Starting;
02621     LARGE_INTEGER Ending;
02622 
02623     <a class="code" href="../../d5/d3/filelock_8c.html#a30">PLOCK_INFO</a>            LockInfo;
02624     <a class="code" href="../../d5/d3/filelock_8c.html#a28">PLOCK_QUEUE</a>           LockQueue;
02625     KIRQL                 OldIrql;
02626     <a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html">PFILE_LOCK_INFO</a>       LastLock;
02627     BOOLEAN               <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02628 
02629     <span class="keywordflow">if</span> ((LockInfo = (<a class="code" href="../../d5/d3/filelock_8c.html#a30">PLOCK_INFO</a>) FileLock-&gt;LockInformation) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02630 
02631         <span class="comment">//</span>
02632         <span class="comment">// No lock information on this FileLock</span>
02633         <span class="comment">//</span>
02634 
02635         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlFastCheckLockForRead, No lock info\n"</span>, 0);
02636         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02637     }
02638 
02639     <span class="comment">//</span>
02640     <span class="comment">// If there isn't an exclusive lock then we can immediately grant access</span>
02641     <span class="comment">//</span>
02642 
02643     <span class="keywordflow">if</span> (LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>.<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o2">ExclusiveLockTree</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02644         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlFastCheckLockForRead, No exlocks present\n"</span>, 0);
02645         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02646     }
02647 
02648     <span class="comment">//</span>
02649     <span class="comment">// If length is zero then automatically give grant access</span>
02650     <span class="comment">//</span>
02651 
02652     <span class="keywordflow">if</span> ((ULONGLONG)Length-&gt;QuadPart == 0) {
02653 
02654         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlFastCheckLockForRead, Length == 0\n"</span>, 0);
02655         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02656     }
02657 
02658     <span class="comment">//</span>
02659     <span class="comment">//  Get our starting and ending byte position</span>
02660     <span class="comment">//</span>
02661 
02662     Starting = *StartingByte;
02663     (ULONGLONG)Ending.QuadPart = (ULONGLONG)Starting.QuadPart + (ULONGLONG)Length-&gt;QuadPart - 1;
02664 
02665     <span class="comment">//</span>
02666     <span class="comment">// Now check lock queue</span>
02667     <span class="comment">//</span>
02668 
02669     LockQueue = &amp;LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>;
02670 
02671     <span class="comment">//</span>
02672     <span class="comment">//  Grab the waiting lock queue spinlock to exclude anyone from messing</span>
02673     <span class="comment">//  with the queue while we're using it</span>
02674     <span class="comment">//</span>
02675 
02676     <a class="code" href="../../d5/d3/filelock_8c.html#a9">FsRtlReacquireLockQueue</a>(LockInfo, LockQueue, &amp;OldIrql);
02677 
02678     <span class="comment">//</span>
02679     <span class="comment">//  If the range ends below the lowest existing lock, this read is OK.</span>
02680     <span class="comment">//</span>
02681 
02682     <span class="keywordflow">if</span> ( ((ULONGLONG)Ending.QuadPart &lt; (ULONGLONG)LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o0">LowestLockOffset</a>) ) {
02683         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlFastCheckLockForRead (below lowest lock)\n"</span>, 0);
02684 
02685         <a class="code" href="../../d5/d3/filelock_8c.html#a10">FsRtlReleaseLockQueue</a>(LockQueue, OldIrql);
02686         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02687     }
02688 
02689     <span class="comment">//</span>
02690     <span class="comment">//  If the caller just locked this range, he can read it.</span>
02691     <span class="comment">//</span>
02692 
02693     LastLock = (<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html">PFILE_LOCK_INFO</a>)FileObject-&gt;LastLock;
02694     <span class="keywordflow">if</span> ((LastLock != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
02695         ((ULONGLONG)Starting.QuadPart &gt;= (ULONGLONG)LastLock-&gt;<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o0">StartingByte</a>.QuadPart) &amp;&amp;
02696         ((ULONGLONG)Ending.QuadPart &lt;= (ULONGLONG)LastLock-&gt;<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o6">EndingByte</a>.QuadPart) &amp;&amp;
02697         (LastLock-&gt;<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o3">Key</a> == <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>) &amp;&amp;
02698         (LastLock-&gt;<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o5">ProcessId</a> == ProcessId)) {
02699 
02700         <a class="code" href="../../d5/d3/filelock_8c.html#a10">FsRtlReleaseLockQueue</a>(LockQueue, OldIrql);
02701         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02702     }
02703 
02704     <span class="comment">//</span>
02705     <span class="comment">//  Check the exclusive locks for a conflict. It is impossible to have</span>
02706     <span class="comment">//  a read conflict with any shared lock.</span>
02707     <span class="comment">//</span>
02708 
02709     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d5/d3/filelock_8c.html#a57">FsRtlCheckNoExclusiveConflict</a>(LockQueue, &amp;Starting, &amp;Ending, <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>, FileObject, ProcessId);
02710 
02711     <a class="code" href="../../d5/d3/filelock_8c.html#a10">FsRtlReleaseLockQueue</a>(LockQueue, OldIrql);
02712 
02713     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02714 }
02715 
02716 
02717 BOOLEAN
<a name="l02718"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a120">02718</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a120">FsRtlFastCheckLockForWrite</a> (
02719     IN <a class="code" href="../../d7/d1/struct__FILE__LOCK.html">PFILE_LOCK</a> FileLock,
02720     IN PLARGE_INTEGER StartingByte,
02721     IN PLARGE_INTEGER Length,
02722     IN ULONG Key,
02723     IN PVOID FileObject,
02724     IN PVOID ProcessId
02725     )
02726 
02727 <span class="comment">/*++</span>
02728 <span class="comment"></span>
02729 <span class="comment">Routine Description:</span>
02730 <span class="comment"></span>
02731 <span class="comment">    This routine checks to see if the caller has write access to the</span>
02732 <span class="comment">    indicated range due to file locks</span>
02733 <span class="comment"></span>
02734 <span class="comment">Arguments:</span>
02735 <span class="comment"></span>
02736 <span class="comment">    FileLock - Supplies the File Lock to check</span>
02737 <span class="comment"></span>
02738 <span class="comment">    StartingByte - Supplies the first byte (zero based) to check</span>
02739 <span class="comment"></span>
02740 <span class="comment">    Length - Supplies the length, in bytes, to check</span>
02741 <span class="comment"></span>
02742 <span class="comment">    Key - Supplies the to use in the check</span>
02743 <span class="comment"></span>
02744 <span class="comment">    FileObject - Supplies the file object to use in the check</span>
02745 <span class="comment"></span>
02746 <span class="comment">    ProcessId - Supplies the Process Id to use in the check</span>
02747 <span class="comment"></span>
02748 <span class="comment">Return Value:</span>
02749 <span class="comment"></span>
02750 <span class="comment">    BOOLEAN - TRUE if the indicated user/request has write access to the</span>
02751 <span class="comment">        entire specified byte range, and FALSE otherwise</span>
02752 <span class="comment"></span>
02753 <span class="comment">--*/</span>
02754 
02755 {
02756     LARGE_INTEGER Starting;
02757     LARGE_INTEGER Ending;
02758 
02759     <a class="code" href="../../d5/d3/filelock_8c.html#a30">PLOCK_INFO</a>              LockInfo;
02760     <a class="code" href="../../d5/d3/filelock_8c.html#a28">PLOCK_QUEUE</a>             LockQueue;
02761     KIRQL                   OldIrql;
02762     <a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html">PFILE_LOCK_INFO</a>         LastLock;
02763     BOOLEAN                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02764 
02765     <span class="keywordflow">if</span> ((LockInfo = (<a class="code" href="../../d5/d3/filelock_8c.html#a30">PLOCK_INFO</a>) FileLock-&gt;LockInformation) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02766 
02767         <span class="comment">//</span>
02768         <span class="comment">// No lock information on this FileLock</span>
02769         <span class="comment">//</span>
02770 
02771         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlFastCheckLockForRead, No lock info\n"</span>, 0);
02772         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02773     }
02774 
02775     <span class="comment">//</span>
02776     <span class="comment">//  If there isn't a lock then we can immediately grant access</span>
02777     <span class="comment">//</span>
02778 
02779     <span class="keywordflow">if</span> (LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>.<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o1">SharedLockTree</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> &amp;&amp; LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>.<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o2">ExclusiveLockTree</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02780 
02781         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlFastCheckLockForWrite, No locks present\n"</span>, 0);
02782         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02783     }
02784 
02785     <span class="comment">//</span>
02786     <span class="comment">//  If length is zero then automatically grant access</span>
02787     <span class="comment">//</span>
02788 
02789     <span class="keywordflow">if</span> ((ULONGLONG)Length-&gt;QuadPart == 0) {
02790 
02791         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlFastCheckLockForWrite, Length == 0\n"</span>, 0);
02792         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02793     }
02794 
02795     <span class="comment">//</span>
02796     <span class="comment">//  Get our starting and ending byte position</span>
02797     <span class="comment">//</span>
02798 
02799     Starting = *StartingByte;
02800     (ULONGLONG)Ending.QuadPart = (ULONGLONG)Starting.QuadPart + (ULONGLONG)Length-&gt;QuadPart - 1;
02801 
02802     <span class="comment">//</span>
02803     <span class="comment">//  Now check lock queue</span>
02804     <span class="comment">//</span>
02805 
02806     LockQueue = &amp;LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>;
02807 
02808     <span class="comment">//</span>
02809     <span class="comment">//  Grab the waiting lock queue spinlock to exclude anyone from messing</span>
02810     <span class="comment">//  with the queue while we're using it</span>
02811     <span class="comment">//</span>
02812 
02813     <a class="code" href="../../d5/d3/filelock_8c.html#a9">FsRtlReacquireLockQueue</a>(LockInfo, LockQueue, &amp;OldIrql);
02814 
02815     <span class="comment">//</span>
02816     <span class="comment">//  If the range ends below the lowest existing lock, this write is OK.</span>
02817     <span class="comment">//</span>
02818 
02819     <span class="keywordflow">if</span> ( ((ULONGLONG)Ending.QuadPart &lt; (ULONGLONG)LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o0">LowestLockOffset</a>) ) {
02820 
02821         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlFastCheckLockForWrite (below lowest lock)\n"</span>, 0);
02822 
02823         <a class="code" href="../../d5/d3/filelock_8c.html#a10">FsRtlReleaseLockQueue</a>(LockQueue, OldIrql);
02824         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02825     }
02826 
02827     <span class="comment">//</span>
02828     <span class="comment">//  If the caller just locked this range exclusively, he can write it.</span>
02829     <span class="comment">//</span>
02830 
02831     LastLock = (<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html">PFILE_LOCK_INFO</a>)((<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>)FileObject)-&gt;LastLock;
02832     <span class="keywordflow">if</span> ((LastLock != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
02833         ((ULONGLONG)Starting.QuadPart &gt;= (ULONGLONG)LastLock-&gt;<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o0">StartingByte</a>.QuadPart) &amp;&amp;
02834         ((ULONGLONG)Ending.QuadPart &lt;= (ULONGLONG)LastLock-&gt;<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o6">EndingByte</a>.QuadPart) &amp;&amp;
02835         (LastLock-&gt;<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o3">Key</a> == <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>) &amp;&amp;
02836         (LastLock-&gt;<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o5">ProcessId</a> == ProcessId) &amp;&amp;
02837         LastLock-&gt;<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o2">ExclusiveLock</a>) {
02838 
02839         <a class="code" href="../../d5/d3/filelock_8c.html#a10">FsRtlReleaseLockQueue</a>(LockQueue, OldIrql);
02840         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02841     }
02842 
02843     <span class="comment">//</span>
02844     <span class="comment">//  Check the shared locks for overlap. Any overlap in the shared locks is fatal.</span>
02845     <span class="comment">//</span>
02846 
02847     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d5/d3/filelock_8c.html#a56">FsRtlCheckNoSharedConflict</a>(LockQueue, &amp;Starting, &amp;Ending);
02848 
02849     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
02850 
02851         <span class="comment">//</span>
02852         <span class="comment">//  No overlap in the shared locks, so check the exclusive locks for overlap.</span>
02853         <span class="comment">//</span>
02854 
02855         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d5/d3/filelock_8c.html#a57">FsRtlCheckNoExclusiveConflict</a>(LockQueue, &amp;Starting, &amp;Ending, <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>, FileObject, ProcessId);
02856     }
02857 
02858     <a class="code" href="../../d5/d3/filelock_8c.html#a10">FsRtlReleaseLockQueue</a>(LockQueue, OldIrql);
02859 
02860     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02861 }
02862 
02863 
02864 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02865"></a><a class="code" href="../../d5/d3/filelock_8c.html#a72">02865</a> <a class="code" href="../../d5/d3/filelock_8c.html#a72">FsRtlSplitLocks</a> (
02866     IN PLOCKTREE_NODE ParentNode,
02867     IN PSINGLE_LIST_ENTRY *pStartLink OPTIONAL,
02868     IN PLARGE_INTEGER LastShadowedByte OPTIONAL,
02869     IN PLARGE_INTEGER GlueOffset OPTIONAL
02870     )
02871 <span class="comment">/*++</span>
02872 <span class="comment"></span>
02873 <span class="comment">Routine Description:</span>
02874 <span class="comment"></span>
02875 <span class="comment">    This routine examines and possibly splits off shared locks associated</span>
02876 <span class="comment">    with a node into new nodes of the lock tree. Called from routines that</span>
02877 <span class="comment">    have just deleted locks.</span>
02878 <span class="comment"></span>
02879 <span class="comment">    The arguments that supply the initial conditions for the operation are</span>
02880 <span class="comment">    optional if the node is known to be holey.</span>
02881 <span class="comment"></span>
02882 <span class="comment">Arguments:</span>
02883 <span class="comment"></span>
02884 <span class="comment">    ParentNode- Supplies the node the locks are coming from</span>
02885 <span class="comment"></span>
02886 <span class="comment">    pStartLink - Supplies the pointer to the link address of the start of the</span>
02887 <span class="comment">        range of locks in the ParentNode's locklist that need to be checked</span>
02888 <span class="comment"></span>
02889 <span class="comment">    LastShadowedByte - Supplies the last byte offset that needs to be checked</span>
02890 <span class="comment"></span>
02891 <span class="comment">    GlueOffset - Supplies the maximum offset affected by locks prior to this</span>
02892 <span class="comment">        point in the list</span>
02893 <span class="comment"></span>
02894 <span class="comment">Return Value:</span>
02895 <span class="comment"></span>
02896 <span class="comment">    BOOLEAN - True if the split was successful, False otherwise.  The node will</span>
02897 <span class="comment">        be marked as Holey if the split could not occur.</span>
02898 <span class="comment"></span>
02899 <span class="comment">--*/</span>
02900 {
02901     <a class="code" href="../../d5/d3/filelock_8c.html#a22">PSH_LOCK</a>                <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>;
02902     <a class="code" href="../../d5/d3/filelock_8c.html#a20">PLOCKTREE_NODE</a>          NewNode;
02903     PSINGLE_LIST_ENTRY      Link, *pLink, *NextpLink;
02904     LARGE_INTEGER           MaxOffset, StartOffset, HaltOffset;
02905 
02906     BOOLEAN                 ExtentValid;
02907     BOOLEAN                 FailedHoleySplit = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02908 
02909     <span class="comment">//</span>
02910     <span class="comment">//  There are two cases: the node is holey or not.  If the node is holey, at some</span>
02911     <span class="comment">//  point we failed to get resources to complete a split, so despite our caller's</span>
02912     <span class="comment">//  good intentions we need to go over the entire node.</span>
02913     <span class="comment">//</span>
02914 
02915     <span class="keywordflow">if</span> (ParentNode-&gt;HoleyNode) {
02916 
02917         <span class="comment">//</span>
02918         <span class="comment">//  Just move the starting link back to the front.  The maximum offset and</span>
02919         <span class="comment">//  starting offset of the node will be initialized in the loop.  We also turn</span>
02920         <span class="comment">//  off the holey flag, which will be turned on again as appropriate.</span>
02921         <span class="comment">//</span>
02922 
02923         pStartLink = &amp;ParentNode-&gt;Locks.Next;
02924         ParentNode-&gt;HoleyNode = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02925 
02926         HaltOffset.QuadPart = ParentNode-&gt;Extent;
02927 
02928     } <span class="keywordflow">else</span> {
02929 
02930         HaltOffset = *LastShadowedByte;
02931         MaxOffset = *GlueOffset;
02932         StartOffset.QuadPart = 0;
02933 
02934         <span class="keywordflow">if</span> (!ParentNode-&gt;Locks.Next ||
02935             (ULONGLONG)HaltOffset.QuadPart &lt;= (ULONGLONG)MaxOffset.QuadPart) {
02936 
02937             <span class="comment">//</span>
02938             <span class="comment">//  The parent node is not there, doesn't have links associated, or the</span>
02939             <span class="comment">//  last possible byte that is affected by the operation our caller made</span>
02940             <span class="comment">//  is interior to the max extent of all locks still in this node - in</span>
02941             <span class="comment">//  which case there is nothing that needs to be done.</span>
02942             <span class="comment">//</span>
02943 
02944             <span class="keywordflow">return</span>;
02945         }
02946     }
02947 
02948     <span class="comment">//</span>
02949     <span class="comment">//  If the extent of the node is past the last byte affected by whatever</span>
02950     <span class="comment">//  operations were done to this node, we can avoid the linear scan of</span>
02951     <span class="comment">//  the list past that last affected byte since we already know the</span>
02952     <span class="comment">//  extent of the entire list! If it is not (note that it would have to</span>
02953     <span class="comment">//  be equal - by defintion) then we need to recalculate the extents of</span>
02954     <span class="comment">//  all nodes we touch in this operation.</span>
02955     <span class="comment">//</span>
02956 
02957     ExtentValid = (ParentNode-&gt;Extent &gt; (ULONGLONG)HaltOffset.QuadPart);
02958 
02959     <span class="keywordflow">for</span> (pLink = pStartLink;
02960          (Link = *pLink) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02961          pLink = NextpLink) {
02962 
02963         NextpLink = &amp;Link-&gt;Next;
02964 
02965         <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a> = CONTAINING_RECORD( Link, <a class="code" href="../../d8/d2/struct__SH__LOCK.html">SH_LOCK</a>, Link );
02966 
02967         <span class="keywordflow">if</span> (ParentNode-&gt;Locks.Next == *pLink) {
02968 
02969             <span class="comment">//</span>
02970             <span class="comment">//  We're at the first lock in the node, and we know that we're going to leave</span>
02971             <span class="comment">//  at least one lock here. Skip over that lock. We also know that the max</span>
02972             <span class="comment">//  offset must be that locks's ending byte - make sure it is. Note that this</span>
02973             <span class="comment">//  code is *exactly* the same as the update MaxOffset code at the bottom of</span>
02974             <span class="comment">//  the loop.</span>
02975             <span class="comment">//</span>
02976 
02977             MaxOffset.QuadPart = <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.EndingByte.QuadPart;
02978 
02979             <span class="comment">//</span>
02980             <span class="comment">//  Set the starting offset of the node.  This is only an issue for zero length</span>
02981             <span class="comment">//  locks, so that we can figure out what is going on if we split a node and wind</span>
02982             <span class="comment">//  up with some number of "overlapped" zero length locks at the front of the new</span>
02983             <span class="comment">//  node.  We must be able to notice this case, and not think that each needs to</span>
02984             <span class="comment">//  be in a seperate node.</span>
02985             <span class="comment">//</span>
02986 
02987             StartOffset.QuadPart = <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.StartingByte.QuadPart;
02988 
02989             <span class="comment">//</span>
02990             <span class="comment">//  If extents are invalid we also need to set it in case this turns out to</span>
02991             <span class="comment">//  be the only lock at this node.</span>
02992             <span class="comment">//</span>
02993 
02994             <span class="keywordflow">if</span> (!ExtentValid) {
02995 
02996                 ParentNode-&gt;Extent = (ULONGLONG)MaxOffset.QuadPart;
02997             }
02998 
02999             <span class="keywordflow">continue</span>;
03000         }
03001 
03002         <span class="comment">//</span>
03003         <span class="comment">//  If the lock begins at a byte offset greater than the maximum offset seen to this</span>
03004         <span class="comment">//  point, AND this is not a zero length node starting at the beginning of this node,</span>
03005         <span class="comment">//  break the node.  The second half of the test keeps co-incident zero length locks</span>
03006         <span class="comment">//  in the same node. (zero length lock ---&gt; starting = ending + 1).</span>
03007         <span class="comment">//</span>
03008 
03009         <span class="keywordflow">if</span> ((ULONGLONG)<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.StartingByte.QuadPart &gt; (ULONGLONG)MaxOffset.QuadPart &amp;&amp;
03010             !(<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.Length.QuadPart == 0 &amp;&amp;
03011               <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.StartingByte.QuadPart == StartOffset.QuadPart)) {
03012 
03013             <span class="comment">//</span>
03014             <span class="comment">//  Break the node up here</span>
03015             <span class="comment">//</span>
03016 
03017             NewNode = <a class="code" href="../../d5/d3/filelock_8c.html#a34">FsRtlAllocateLockTreeNode</a>();
03018 
03019             <span class="keywordflow">if</span> (NewNode == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03020 
03021                 <span class="comment">//</span>
03022                 <span class="comment">//  If we are out of resources, this node is now holey - we know that the locks at</span>
03023                 <span class="comment">//  this node do not completely cover the indicated range.  Keep splitting for two</span>
03024                 <span class="comment">//  reasons: more resources may become avaliable, and we must keep updating the</span>
03025                 <span class="comment">//  node's extent if it is known to be invalid.</span>
03026                 <span class="comment">//</span>
03027 
03028                 <span class="comment">//</span>
03029                 <span class="comment">//  Now if this node was already holey it is not possible to state that, if we</span>
03030                 <span class="comment">//  manage to split if further as we keep walking, that the resulting "left" node</span>
03031                 <span class="comment">//  is not holey.  See below.</span>
03032                 <span class="comment">//</span>
03033 
03034                 <span class="keywordflow">if</span> (ParentNode-&gt;HoleyNode) {
03035 
03036                     FailedHoleySplit = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03037                 }
03038 
03039                 ParentNode-&gt;HoleyNode = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03040 
03041             } <span class="keywordflow">else</span> {
03042 
03043                 <span class="comment">//</span>
03044                 <span class="comment">//  Initialize the node.</span>
03045                 <span class="comment">//</span>
03046 
03047                 RtlInitializeSplayLinks(&amp;NewNode-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o3">Links</a>);
03048                 NewNode-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o1">HoleyNode</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03049 
03050                 <span class="comment">//</span>
03051                 <span class="comment">//  Find the spot in the tree to take the new node(s). If the current node has</span>
03052                 <span class="comment">//  a free right child, we use it, else find the successor node and use its</span>
03053                 <span class="comment">//  left child. One of these cases must be avaliable since we know there are</span>
03054                 <span class="comment">//  no nodes between this node and its successor.</span>
03055                 <span class="comment">//</span>
03056 
03057                 <span class="keywordflow">if</span> (RtlRightChild(&amp;ParentNode-&gt;Links) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03058 
03059                     RtlInsertAsRightChild(&amp;ParentNode-&gt;Links, &amp;NewNode-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o3">Links</a>);
03060 
03061                 } <span class="keywordflow">else</span> {
03062 
03063                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(RtlLeftChild(<a class="code" href="../../d3/d4/splay_8c.html#a8">RtlRealSuccessor</a>(&amp;ParentNode-&gt;Links)) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
03064                     RtlInsertAsLeftChild(<a class="code" href="../../d3/d4/splay_8c.html#a8">RtlRealSuccessor</a>(&amp;ParentNode-&gt;Links), &amp;NewNode-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o3">Links</a>);
03065                 }
03066 
03067                 <span class="comment">//</span>
03068                 <span class="comment">//  Move the remaining locks over to the new node and fix up extents</span>
03069                 <span class="comment">//</span>
03070 
03071                 NewNode-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o0">Locks</a>.Next = *pLink;
03072                 *pLink = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03073 
03074                 NewNode-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o4">Tail</a>.Next = ParentNode-&gt;Tail.Next;
03075                 ParentNode-&gt;Tail.Next = CONTAINING_RECORD( pLink, SINGLE_LIST_ENTRY, Next );
03076 
03077                 <span class="comment">//</span>
03078                 <span class="comment">//  This will cause us to fall into the first-lock clause above on the next pass</span>
03079                 <span class="comment">//</span>
03080 
03081                 NextpLink = &amp;NewNode-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o0">Locks</a>.Next;
03082 
03083                 <span class="comment">//</span>
03084                 <span class="comment">// The new node's extent is now copied from the parent. The old node's extent must be</span>
03085                 <span class="comment">// the maximum offset we have seen to this point.</span>
03086                 <span class="comment">//</span>
03087                 <span class="comment">// Note that if ExtentValid is true, that must mean that the lock ending at that extent</span>
03088                 <span class="comment">// is in the new node since if it was in the old node we wouldn't have been able to split.</span>
03089                 <span class="comment">//</span>
03090 
03091                 NewNode-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o2">Extent</a> = ParentNode-&gt;Extent;
03092                 ParentNode-&gt;Extent = (ULONGLONG)MaxOffset.QuadPart;
03093 
03094                 <span class="comment">//</span>
03095                 <span class="comment">//  The parent node can no longer be holey if we have not failed a split in this node.</span>
03096                 <span class="comment">//</span>
03097 
03098                 <span class="keywordflow">if</span> (!FailedHoleySplit) {
03099 
03100                     ParentNode-&gt;HoleyNode = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03101 
03102                 } <span class="keywordflow">else</span> {
03103 
03104                     <span class="comment">//</span>
03105                     <span class="comment">//  So reset the failure flag for the new node.</span>
03106                     <span class="comment">//</span>
03107 
03108                     FailedHoleySplit = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03109                 }
03110 
03111                 <span class="comment">//</span>
03112                 <span class="comment">//  Move over to the new node.</span>
03113                 <span class="comment">//</span>
03114 
03115                 ParentNode = NewNode;
03116 
03117                 <span class="keywordflow">continue</span>;
03118             }
03119         }
03120 
03121         <span class="keywordflow">if</span> (ExtentValid &amp;&amp;
03122             (ULONGLONG)<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.StartingByte.QuadPart &gt; (ULONGLONG)HaltOffset.QuadPart) {
03123 
03124             <span class="comment">//</span>
03125             <span class="comment">//  Our extents are good and this lock is past the shadow, so we can stop</span>
03126             <span class="comment">//</span>
03127 
03128             <span class="keywordflow">return</span>;
03129         }
03130 
03131         <span class="keywordflow">if</span> ((ULONGLONG)MaxOffset.QuadPart &lt; (ULONGLONG)<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.EndingByte.QuadPart) {
03132 
03133             <span class="comment">//</span>
03134             <span class="comment">//  Update maximum offset</span>
03135             <span class="comment">//</span>
03136 
03137             MaxOffset.QuadPart = <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.EndingByte.QuadPart;
03138 
03139             <span class="keywordflow">if</span> (!ExtentValid) {
03140 
03141                 <span class="comment">//</span>
03142                 <span class="comment">//  Extents are not good so we must update the extent</span>
03143                 <span class="comment">//</span>
03144 
03145                 ParentNode-&gt;Extent = (ULONGLONG)MaxOffset.QuadPart;
03146             }
03147         }
03148     }
03149 
03150     <span class="comment">//</span>
03151     <span class="comment">//  Reached the end of the list, so update the extent (case of all subsequent locks</span>
03152     <span class="comment">//  having been interior to GlueOffset)</span>
03153     <span class="comment">//</span>
03154 
03155     ParentNode-&gt;Extent = (ULONGLONG)MaxOffset.QuadPart;
03156 
03157     <span class="keywordflow">return</span>;
03158 }
03159 
03160 
03161 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l03162"></a><a class="code" href="../../d5/d3/filelock_8c.html#a55">03162</a> <a class="code" href="../../d5/d3/filelock_8c.html#a55">FsRtlPrivateRemoveLock</a> (
03163     IN PLOCK_INFO LockInfo,
03164     IN <a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html">PFILE_LOCK_INFO</a> FileLockInfo,
03165     IN BOOLEAN CheckForWaiters
03166     )
03167 
03168 <span class="comment">/*++</span>
03169 <span class="comment"></span>
03170 <span class="comment">Routine Description:</span>
03171 <span class="comment"></span>
03172 <span class="comment">    General purpose cleanup routine.  Finds the given lock structure</span>
03173 <span class="comment">    and removes it from the file lock list. Differs from UnlockSingle</span>
03174 <span class="comment">    only in that it disables the UnlockRoutine of the FileLock and</span>
03175 <span class="comment">    optionalizes walking the waiting locks list.</span>
03176 <span class="comment"></span>
03177 <span class="comment">Arguments:</span>
03178 <span class="comment"></span>
03179 <span class="comment">    FileLock - Supplies the file's lock structure supposedly containing a stale lock</span>
03180 <span class="comment"></span>
03181 <span class="comment">    FileLockInfo - Supplies file lock data being freed</span>
03182 <span class="comment"></span>
03183 <span class="comment">    CheckForWaiters - If true check for possible waiting locks, caused</span>
03184 <span class="comment">        by freeing the locked range</span>
03185 <span class="comment"></span>
03186 <span class="comment">Return Value:</span>
03187 <span class="comment"></span>
03188 <span class="comment">    None.</span>
03189 <span class="comment"></span>
03190 <span class="comment">--*/</span>
03191 
03192 {
03193     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
03194 
03195     <span class="keywordflow">if</span> (FileLockInfo-&gt;ExclusiveLock) {
03196 
03197         <span class="comment">//</span>
03198         <span class="comment">//  We must find it in the exclusive lock tree</span>
03199         <span class="comment">//</span>
03200 
03201         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d5/d3/filelock_8c.html#a60">FsRtlFastUnlockSingleExclusive</a>( LockInfo,
03202 
03203                                                  FileLockInfo-&gt;FileObject,
03204                                                  &amp;FileLockInfo-&gt;StartingByte,
03205                                                  &amp;FileLockInfo-&gt;Length,
03206                                                  FileLockInfo-&gt;ProcessId,
03207                                                  FileLockInfo-&gt;Key,
03208 
03209                                                  <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
03210                                                  <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
03211                                                  CheckForWaiters );
03212 
03213         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_SUCCESS);
03214 
03215     } <span class="keywordflow">else</span> {
03216 
03217         <span class="comment">//</span>
03218         <span class="comment">//  We must find it in the shared lock tree</span>
03219         <span class="comment">//</span>
03220 
03221         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d5/d3/filelock_8c.html#a59">FsRtlFastUnlockSingleShared</a>( LockInfo,
03222 
03223                                               FileLockInfo-&gt;FileObject,
03224                                               &amp;FileLockInfo-&gt;StartingByte,
03225                                               &amp;FileLockInfo-&gt;Length,
03226                                               FileLockInfo-&gt;ProcessId,
03227                                               FileLockInfo-&gt;Key,
03228 
03229                                               <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
03230                                               <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
03231                                               CheckForWaiters );
03232 
03233         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_SUCCESS);
03234     }
03235 
03236     <span class="keywordflow">return</span>;
03237 }
03238 
03239 
03240 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l03241"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a122">03241</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a122">FsRtlFastUnlockSingle</a> (
03242     IN <a class="code" href="../../d7/d1/struct__FILE__LOCK.html">PFILE_LOCK</a> FileLock,
03243     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
03244     IN LARGE_INTEGER UNALIGNED *FileOffset,
03245     IN PLARGE_INTEGER Length,
03246     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> ProcessId,
03247     IN ULONG Key,
03248     IN PVOID Context OPTIONAL,
03249     IN BOOLEAN AlreadySynchronized
03250     )
03251 
03252 <span class="comment">/*++</span>
03253 <span class="comment"></span>
03254 <span class="comment">Routine Description:</span>
03255 <span class="comment"></span>
03256 <span class="comment">    This routine performs an Unlock Single operation on the current locks</span>
03257 <span class="comment">    associated with the specified file lock.  Only the lock with a matching</span>
03258 <span class="comment">    file object, process id, key, and range is freed.</span>
03259 <span class="comment"></span>
03260 <span class="comment">Arguments:</span>
03261 <span class="comment"></span>
03262 <span class="comment">    FileLock - Supplies the file lock being freed.</span>
03263 <span class="comment"></span>
03264 <span class="comment">    FileObject - Supplies the file object holding the locks</span>
03265 <span class="comment"></span>
03266 <span class="comment">    FileOffset - Supplies the offset to be unlocked</span>
03267 <span class="comment"></span>
03268 <span class="comment">    Length - Supplies the length in bytes to be unlocked</span>
03269 <span class="comment"></span>
03270 <span class="comment">    ProcessId - Supplies the process Id to use in this operation</span>
03271 <span class="comment"></span>
03272 <span class="comment">    Key - Supplies the key to use in this operation</span>
03273 <span class="comment"></span>
03274 <span class="comment">    Context - Optionally supplies context to use when completing Irps</span>
03275 <span class="comment"></span>
03276 <span class="comment">    AlreadySynchronized - Indicates that the caller has already synchronized</span>
03277 <span class="comment">        access to the file lock so the fields in the file lock and</span>
03278 <span class="comment">        be updated without further locking, but not the queues.</span>
03279 <span class="comment"></span>
03280 <span class="comment">Return Value:</span>
03281 <span class="comment"></span>
03282 <span class="comment">    NTSTATUS - The completion status for this operation</span>
03283 <span class="comment"></span>
03284 <span class="comment">--*/</span>
03285 
03286 {
03287     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
03288 
03289     <span class="comment">//</span>
03290     <span class="comment">//  XXX AlreadySynchronized is obsolete. It was apparently added for the dead</span>
03291     <span class="comment">//  XXX SoloLock code.</span>
03292     <span class="comment">//</span>
03293 
03294     <span class="keywordflow">if</span> (FileLock-&gt;LockInformation == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03295 
03296         <span class="comment">//</span>
03297         <span class="comment">//  Fast exit - no locks are applied</span>
03298         <span class="comment">//</span>
03299 
03300         <span class="keywordflow">return</span> STATUS_RANGE_NOT_LOCKED;
03301     }
03302 
03303     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d5/d3/filelock_8c.html#a60">FsRtlFastUnlockSingleExclusive</a>( FileLock-&gt;LockInformation,
03304                                              FileObject,
03305                                              FileOffset,
03306                                              Length,
03307                                              ProcessId,
03308                                              <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>,
03309                                              Context,
03310                                              <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
03311                                              <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
03312 
03313     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_SUCCESS) {
03314 
03315         <span class="comment">//</span>
03316         <span class="comment">//  Found and unlocked in the exclusive tree, so we're done</span>
03317         <span class="comment">//</span>
03318 
03319         <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
03320     }
03321 
03322     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d5/d3/filelock_8c.html#a59">FsRtlFastUnlockSingleShared</a>( FileLock-&gt;LockInformation,
03323                                           FileObject,
03324                                           FileOffset,
03325                                           Length,
03326                                           ProcessId,
03327                                           <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>,
03328                                           Context,
03329                                           <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
03330                                           <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
03331 
03332     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
03333 }
03334 
03335 
03336 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l03337"></a><a class="code" href="../../d5/d3/filelock_8c.html#a59">03337</a> <a class="code" href="../../d5/d3/filelock_8c.html#a59">FsRtlFastUnlockSingleShared</a> (
03338     IN PLOCK_INFO LockInfo,
03339     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
03340     IN LARGE_INTEGER UNALIGNED *FileOffset,
03341     IN PLARGE_INTEGER Length,
03342     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> ProcessId,
03343     IN ULONG Key,
03344     IN PVOID Context OPTIONAL,
03345     IN BOOLEAN IgnoreUnlockRoutine,
03346     IN BOOLEAN CheckForWaiters
03347     )
03348 
03349 <span class="comment">/*++</span>
03350 <span class="comment"></span>
03351 <span class="comment">Routine Description:</span>
03352 <span class="comment"></span>
03353 <span class="comment">    This routine performs an Unlock Single operation on the current locks</span>
03354 <span class="comment">    associated with the specified file lock.  Only the lock with a matching</span>
03355 <span class="comment">    file object, process id, key, and range is freed.</span>
03356 <span class="comment"></span>
03357 <span class="comment">Arguments:</span>
03358 <span class="comment"></span>
03359 <span class="comment">    LockInfo - Supplies the lock data being operated on</span>
03360 <span class="comment"></span>
03361 <span class="comment">    FileObject - Supplies the file object holding the locks</span>
03362 <span class="comment"></span>
03363 <span class="comment">    FileOffset - Supplies the offset to be unlocked</span>
03364 <span class="comment"></span>
03365 <span class="comment">    Length - Supplies the length in bytes to be unlocked</span>
03366 <span class="comment"></span>
03367 <span class="comment">    ProcessId - Supplies the process Id to use in this operation</span>
03368 <span class="comment"></span>
03369 <span class="comment">    Key - Supplies the key to use in this operation</span>
03370 <span class="comment"></span>
03371 <span class="comment">    Context - Optionally supplies context to use when completing Irps</span>
03372 <span class="comment"></span>
03373 <span class="comment">    IgnoreUnlockRoutine - inidicates that the filelock's unlock routine</span>
03374 <span class="comment">        should not be called on lock removal (for removal of aborted</span>
03375 <span class="comment">        locks)</span>
03376 <span class="comment"></span>
03377 <span class="comment">    CheckForWaiters - If true check for possible waiting locks, caused</span>
03378 <span class="comment">        by freeing the locked range</span>
03379 <span class="comment"></span>
03380 <span class="comment">Return Value:</span>
03381 <span class="comment"></span>
03382 <span class="comment">    NTSTATUS - The completion status for this operation</span>
03383 <span class="comment"></span>
03384 <span class="comment">--*/</span>
03385 
03386 {
03387     PSINGLE_LIST_ENTRY      *pLink, Link;
03388     KIRQL                   OldIrql;
03389 
03390     <a class="code" href="../../d5/d3/filelock_8c.html#a28">PLOCK_QUEUE</a>             LockQueue;
03391     PRTL_SPLAY_LINKS        SplayLinks;
03392     LARGE_INTEGER           EndingOffset, MaxOffset;
03393     <a class="code" href="../../d5/d3/filelock_8c.html#a20">PLOCKTREE_NODE</a>          Node;
03394     LARGE_INTEGER           AlignedFileOffset;
03395 
03396     <span class="comment">//</span>
03397     <span class="comment">//  General case - search the outstanding lock queue for this lock</span>
03398     <span class="comment">//</span>
03399 
03400     AlignedFileOffset = *FileOffset;
03401 
03402     LockQueue = &amp;LockInfo-&gt;LockQueue;
03403 
03404     <a class="code" href="../../d5/d3/filelock_8c.html#a8">FsRtlAcquireLockQueue</a>(LockQueue, &amp;OldIrql);
03405 
03406     <span class="comment">//</span>
03407     <span class="comment">//  Check for the no locks currently held</span>
03408     <span class="comment">//</span>
03409 
03410     <span class="keywordflow">if</span> (LockQueue-&gt;<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o1">SharedLockTree</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03411 
03412         <a class="code" href="../../d5/d3/filelock_8c.html#a10">FsRtlReleaseLockQueue</a>( LockQueue, OldIrql );
03413 
03414         <span class="keywordflow">return</span> STATUS_RANGE_NOT_LOCKED;
03415     }
03416 
03417     <span class="comment">//</span>
03418     <span class="comment">//  Find the overlapping node, if it exists, to search. Note that</span>
03419     <span class="comment">//  we don't have to go through more than one node in the tree</span>
03420     <span class="comment">//  since we are assuming this is an existing lock.</span>
03421     <span class="comment">//</span>
03422 
03423     EndingOffset.QuadPart = (ULONGLONG)AlignedFileOffset.QuadPart + (ULONGLONG)Length-&gt;QuadPart - 1;
03424 
03425     SplayLinks = <a class="code" href="../../d5/d3/filelock_8c.html#a43">FsRtlFindFirstOverlappingSharedNode</a>( LockQueue-&gt;<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o1">SharedLockTree</a>,
03426                                                       &amp;AlignedFileOffset,
03427                                                       &amp;EndingOffset,
03428                                                       <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
03429                                                       <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
03430 
03431     <span class="keywordflow">if</span> (SplayLinks == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03432 
03433         <span class="comment">//</span>
03434         <span class="comment">//  No node in the tree overlaps this range, so we're done</span>
03435         <span class="comment">//</span>
03436 
03437         <a class="code" href="../../d5/d3/filelock_8c.html#a10">FsRtlReleaseLockQueue</a>(LockQueue, OldIrql);
03438 
03439         <span class="keywordflow">return</span> STATUS_RANGE_NOT_LOCKED;
03440     }
03441 
03442     Node = CONTAINING_RECORD( SplayLinks, <a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html">LOCKTREE_NODE</a>, Links );
03443     MaxOffset.QuadPart = 0;
03444 
03445     <span class="keywordflow">for</span> (pLink = &amp;Node-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o0">Locks</a>.Next;
03446          (Link = *pLink) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03447          pLink = &amp;Link-&gt;Next) {
03448 
03449         <a class="code" href="../../d5/d3/filelock_8c.html#a22">PSH_LOCK</a> <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>;
03450 
03451         <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a> = CONTAINING_RECORD( Link, <a class="code" href="../../d8/d2/struct__SH__LOCK.html">SH_LOCK</a>, Link );
03452 
03453         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"Sh Top of Loop, Lock = %08lx\n"</span>, <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a> );
03454 
03455         <span class="keywordflow">if</span> ((<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.FileObject == FileObject) &amp;&amp;
03456             (<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.ProcessId == ProcessId) &amp;&amp;
03457             (<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.Key == <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>) &amp;&amp;
03458             ((ULONGLONG)<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.StartingByte.QuadPart == (ULONGLONG)AlignedFileOffset.QuadPart) &amp;&amp;
03459             ((ULONGLONG)<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.Length.QuadPart == (ULONGLONG)Length-&gt;QuadPart)) {
03460 
03461             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"Sh Found one to unlock\n"</span>, 0);
03462 
03463             <span class="comment">//</span>
03464             <span class="comment">//  We have an exact match so now is the time to delete this</span>
03465             <span class="comment">//  lock.  Remove the lock from the list, then call the</span>
03466             <span class="comment">//  optional unlock routine, then delete the lock.</span>
03467             <span class="comment">//</span>
03468 
03469             <span class="keywordflow">if</span> (FileObject-&gt;LastLock == &amp;<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo) {
03470 
03471                 FileObject-&gt;LastLock = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03472             }
03473 
03474             <span class="keywordflow">if</span> (*pLink == Node-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o4">Tail</a>.Next) {
03475 
03476                 <span class="comment">//</span>
03477                 <span class="comment">//  Deleting the tail node of the list. Safe even if deleting the</span>
03478                 <span class="comment">//  first node since this implies we're also deleting the last node</span>
03479                 <span class="comment">//  in the node which means we'll delete the node ...</span>
03480                 <span class="comment">//</span>
03481 
03482                 Node-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o4">Tail</a>.Next = CONTAINING_RECORD( pLink, SINGLE_LIST_ENTRY, Next );
03483             }
03484 
03485             <span class="comment">//</span>
03486             <span class="comment">//  Snip the deleted lock</span>
03487             <span class="comment">//</span>
03488 
03489             *pLink = Link-&gt;Next;
03490 
03491             <span class="keywordflow">if</span> (pLink == &amp;Node-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o0">Locks</a>.Next) {
03492 
03493                 <span class="comment">//</span>
03494                 <span class="comment">//  Deleted first lock in node</span>
03495                 <span class="comment">//</span>
03496 
03497                 <span class="keywordflow">if</span> (Node-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o0">Locks</a>.Next == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03498 
03499                     <span class="comment">//</span>
03500                     <span class="comment">// Just deleted last lock on this node, so free it</span>
03501                     <span class="comment">//</span>
03502 
03503                     LockQueue-&gt;<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o1">SharedLockTree</a> = <a class="code" href="../../d3/d4/splay_8c.html#a4">RtlDelete</a>(SplayLinks);
03504 
03505                     <a class="code" href="../../d5/d3/filelock_8c.html#a39">FsRtlFreeLockTreeNode</a>(Node);
03506 
03507                     Node = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03508                 }
03509 
03510                 <span class="keywordflow">if</span> (LockInfo-&gt;LowestLockOffset != 0xffffffff &amp;&amp;
03511                     LockInfo-&gt;LowestLockOffset == <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.StartingByte.LowPart) {
03512 
03513                     <span class="comment">//</span>
03514                     <span class="comment">//  This was the lowest lock in the trees, reset the lowest lock offset</span>
03515                     <span class="comment">//</span>
03516 
03517                     <a class="code" href="../../d5/d3/filelock_8c.html#a58">FsRtlPrivateResetLowestLockOffset</a>(LockInfo);
03518                 }
03519             }
03520 
03521             <span class="comment">//</span>
03522             <span class="comment">//  Now the fun begins. It may be the case that the lock just snipped from</span>
03523             <span class="comment">//  the chain was gluing locks at this node together, so we need to</span>
03524             <span class="comment">//  inspect the chain.</span>
03525             <span class="comment">//</span>
03526 
03527             <span class="keywordflow">if</span> (Node) {
03528 
03529                 <a class="code" href="../../d5/d3/filelock_8c.html#a72">FsRtlSplitLocks</a>(Node, pLink, &amp;<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.EndingByte, &amp;MaxOffset);
03530             }
03531 
03532             <span class="keywordflow">if</span> (!IgnoreUnlockRoutine &amp;&amp; LockInfo-&gt;UnlockRoutine != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03533 
03534                 <a class="code" href="../../d5/d3/filelock_8c.html#a10">FsRtlReleaseLockQueue</a>( LockQueue, OldIrql );
03535 
03536                 LockInfo-&gt;UnlockRoutine( Context, &amp;<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo );
03537 
03538                 <a class="code" href="../../d5/d3/filelock_8c.html#a9">FsRtlReacquireLockQueue</a>( LockInfo, LockQueue, &amp;OldIrql );
03539 
03540             }
03541 
03542             <a class="code" href="../../d5/d3/filelock_8c.html#a36">FsRtlFreeSharedLock</a>( <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a> );
03543 
03544             <span class="comment">//</span>
03545             <span class="comment">//  See if there are additional waiting locks that we can</span>
03546             <span class="comment">//  now release.</span>
03547             <span class="comment">//</span>
03548 
03549             <span class="keywordflow">if</span> (CheckForWaiters &amp;&amp; LockQueue-&gt;<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o3">WaitingLocks</a>.Next) {
03550 
03551                 <a class="code" href="../../d5/d3/filelock_8c.html#a49">FsRtlPrivateCheckWaitingLocks</a>( LockInfo, LockQueue, OldIrql );
03552             }
03553 
03554             <a class="code" href="../../d5/d3/filelock_8c.html#a10">FsRtlReleaseLockQueue</a>( LockQueue, OldIrql );
03555 
03556             <span class="keywordflow">return</span> STATUS_SUCCESS;
03557         }
03558 
03559         <span class="keywordflow">if</span> ((ULONGLONG)<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.StartingByte.QuadPart &gt; (ULONGLONG)AlignedFileOffset.QuadPart) {
03560 
03561             <span class="comment">//</span>
03562             <span class="comment">//  The current lock begins at a byte offset greater than the range we are seeking</span>
03563             <span class="comment">//  to unlock. This range must therefore not be locked.</span>
03564             <span class="comment">//</span>
03565 
03566             <span class="keywordflow">break</span>;
03567         }
03568 
03569         <span class="keywordflow">if</span> ((ULONGLONG)MaxOffset.QuadPart &lt; (ULONGLONG)<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.EndingByte.QuadPart) {
03570 
03571             <span class="comment">//</span>
03572             <span class="comment">// Maintain the maximum offset affected by locks up to this point.</span>
03573             <span class="comment">//</span>
03574 
03575             MaxOffset.QuadPart = <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.EndingByte.QuadPart;
03576         }
03577     }
03578 
03579     <span class="comment">//</span>
03580     <span class="comment">//  Lock was not found, return to our caller</span>
03581     <span class="comment">//</span>
03582 
03583     <a class="code" href="../../d5/d3/filelock_8c.html#a10">FsRtlReleaseLockQueue</a>(LockQueue, OldIrql);
03584     <span class="keywordflow">return</span> STATUS_RANGE_NOT_LOCKED;
03585 }
03586 
03587 
03588 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l03589"></a><a class="code" href="../../d5/d3/filelock_8c.html#a60">03589</a> <a class="code" href="../../d5/d3/filelock_8c.html#a60">FsRtlFastUnlockSingleExclusive</a> (
03590     IN PLOCK_INFO LockInfo,
03591     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
03592     IN LARGE_INTEGER UNALIGNED *FileOffset,
03593     IN PLARGE_INTEGER Length,
03594     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> ProcessId,
03595     IN ULONG Key,
03596     IN PVOID Context OPTIONAL,
03597     IN BOOLEAN IgnoreUnlockRoutine,
03598     IN BOOLEAN CheckForWaiters
03599     )
03600 
03601 <span class="comment">/*++</span>
03602 <span class="comment"></span>
03603 <span class="comment">Routine Description:</span>
03604 <span class="comment"></span>
03605 <span class="comment">    This routine performs an Unlock Single operation on the exclusive locks</span>
03606 <span class="comment">    associated with the specified lock data.  Only the lock with a matching</span>
03607 <span class="comment">    file object, process id, key, and range is freed.</span>
03608 <span class="comment"></span>
03609 <span class="comment">Arguments:</span>
03610 <span class="comment"></span>
03611 <span class="comment">    LockInfo - Supplies the lock data being operated on</span>
03612 <span class="comment"></span>
03613 <span class="comment">    FileObject - Supplies the file object holding the locks</span>
03614 <span class="comment"></span>
03615 <span class="comment">    FileOffset - Supplies the offset to be unlocked</span>
03616 <span class="comment"></span>
03617 <span class="comment">    Length - Supplies the length in bytes to be unlocked</span>
03618 <span class="comment"></span>
03619 <span class="comment">    ProcessId - Supplies the process Id to use in this operation</span>
03620 <span class="comment"></span>
03621 <span class="comment">    Key - Supplies the key to use in this operation</span>
03622 <span class="comment"></span>
03623 <span class="comment">    Context - Optionally supplies context to use when completing Irps</span>
03624 <span class="comment"></span>
03625 <span class="comment">    IgnoreUnlockRoutine - inidicates that the filelock's unlock routine</span>
03626 <span class="comment">        should not be called on lock removal (for removal of aborted</span>
03627 <span class="comment">        locks)</span>
03628 <span class="comment"></span>
03629 <span class="comment">    CheckForWaiters - If true check for possible waiting locks, caused</span>
03630 <span class="comment">        by freeing the locked range</span>
03631 <span class="comment"></span>
03632 <span class="comment">Return Value:</span>
03633 <span class="comment"></span>
03634 <span class="comment">    NTSTATUS - The completion status for this operation</span>
03635 <span class="comment"></span>
03636 <span class="comment">--*/</span>
03637 
03638 {
03639     KIRQL                   OldIrql;
03640     <a class="code" href="../../d5/d3/filelock_8c.html#a28">PLOCK_QUEUE</a>             LockQueue;
03641     PRTL_SPLAY_LINKS        SplayLinks;
03642     LARGE_INTEGER           EndingOffset;
03643     <a class="code" href="../../d5/d3/filelock_8c.html#a24">PEX_LOCK</a>                <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>;
03644     LARGE_INTEGER           AlignedFileOffset;
03645 
03646     <span class="comment">//</span>
03647     <span class="comment">//  General case - search the outstanding lock queue for this lock</span>
03648     <span class="comment">//</span>
03649 
03650     AlignedFileOffset = *FileOffset;
03651 
03652     LockQueue = &amp;LockInfo-&gt;LockQueue;
03653 
03654     <a class="code" href="../../d5/d3/filelock_8c.html#a8">FsRtlAcquireLockQueue</a>(LockQueue, &amp;OldIrql);
03655 
03656     <span class="comment">//</span>
03657     <span class="comment">//  Check for the no locks currently held</span>
03658     <span class="comment">//</span>
03659 
03660     <span class="keywordflow">if</span> (LockQueue-&gt;<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o2">ExclusiveLockTree</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03661 
03662         <a class="code" href="../../d5/d3/filelock_8c.html#a10">FsRtlReleaseLockQueue</a>( LockQueue, OldIrql );
03663 
03664         <span class="keywordflow">return</span> STATUS_RANGE_NOT_LOCKED;
03665     }
03666 
03667     <span class="comment">//</span>
03668     <span class="comment">//  Find the overlapping lock, if it exists. Note that this is usually</span>
03669     <span class="comment">//  the only lock we need to check since we are assuming this is an</span>
03670     <span class="comment">//  existing lock. However, if the lock is a zero length lock we will</span>
03671     <span class="comment">//  have a run of locks to check.</span>
03672     <span class="comment">//</span>
03673 
03674     EndingOffset.QuadPart = (ULONGLONG)AlignedFileOffset.QuadPart + (ULONGLONG)Length-&gt;QuadPart - 1;
03675 
03676     <span class="keywordflow">for</span> (SplayLinks = <a class="code" href="../../d5/d3/filelock_8c.html#a44">FsRtlFindFirstOverlappingExclusiveNode</a>( LockQueue-&gt;<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o2">ExclusiveLockTree</a>,
03677                                                               &amp;AlignedFileOffset,
03678                                                               &amp;EndingOffset,
03679                                                               <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
03680                                                               <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
03681          SplayLinks;
03682          SplayLinks = <a class="code" href="../../d3/d4/splay_8c.html#a8">RtlRealSuccessor</a>(SplayLinks)) {
03683 
03684         <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a> = CONTAINING_RECORD( SplayLinks, <a class="code" href="../../d7/d7/struct__EX__LOCK.html">EX_LOCK</a>, Links );
03685 
03686         <span class="keywordflow">if</span> ((<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.FileObject == FileObject) &amp;&amp;
03687             (<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.ProcessId == ProcessId) &amp;&amp;
03688             (<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.Key == <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>) &amp;&amp;
03689             ((ULONGLONG)<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.StartingByte.QuadPart == (ULONGLONG)AlignedFileOffset.QuadPart) &amp;&amp;
03690             ((ULONGLONG)<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.Length.QuadPart == (ULONGLONG)Length-&gt;QuadPart)) {
03691 
03692             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"Ex Found one to unlock\n"</span>, 0);
03693 
03694             <span class="comment">//</span>
03695             <span class="comment">//  We have an exact match so now is the time to delete this</span>
03696             <span class="comment">//  lock.  Remove the lock from the list, then call the</span>
03697             <span class="comment">//  optional unlock routine, then delete the lock.</span>
03698             <span class="comment">//</span>
03699 
03700             <span class="keywordflow">if</span> (FileObject-&gt;LastLock == &amp;<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo) {
03701 
03702                 FileObject-&gt;LastLock = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03703             }
03704 
03705             <span class="comment">//</span>
03706             <span class="comment">//  Snip the deleted lock</span>
03707             <span class="comment">//</span>
03708 
03709             LockQueue-&gt;<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o2">ExclusiveLockTree</a> = <a class="code" href="../../d3/d4/splay_8c.html#a4">RtlDelete</a>(&amp;<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;Links);
03710 
03711             <span class="keywordflow">if</span> (LockInfo-&gt;LowestLockOffset != 0xffffffff &amp;&amp;
03712                 LockInfo-&gt;LowestLockOffset == <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.StartingByte.LowPart) {
03713 
03714                 <span class="comment">//</span>
03715                 <span class="comment">//  This was the lowest lock in the tree, so reset the lowest lock</span>
03716                 <span class="comment">//  offset</span>
03717                 <span class="comment">//</span>
03718 
03719                 <a class="code" href="../../d5/d3/filelock_8c.html#a58">FsRtlPrivateResetLowestLockOffset</a>(LockInfo);
03720             }
03721 
03722             <span class="keywordflow">if</span> (!IgnoreUnlockRoutine &amp;&amp; LockInfo-&gt;UnlockRoutine != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03723 
03724                 <a class="code" href="../../d5/d3/filelock_8c.html#a10">FsRtlReleaseLockQueue</a>( LockQueue, OldIrql );
03725 
03726                 LockInfo-&gt;UnlockRoutine( Context, &amp;<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo );
03727 
03728                 <a class="code" href="../../d5/d3/filelock_8c.html#a9">FsRtlReacquireLockQueue</a>( LockInfo, LockQueue, &amp;OldIrql );
03729 
03730             }
03731 
03732             <a class="code" href="../../d5/d3/filelock_8c.html#a37">FsRtlFreeExclusiveLock</a>( <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a> );
03733 
03734             <span class="comment">//</span>
03735             <span class="comment">//  See if there are additional waiting locks that we can</span>
03736             <span class="comment">//  now release.</span>
03737             <span class="comment">//</span>
03738 
03739             <span class="keywordflow">if</span> (CheckForWaiters &amp;&amp; LockQueue-&gt;<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o3">WaitingLocks</a>.Next) {
03740 
03741                 <a class="code" href="../../d5/d3/filelock_8c.html#a49">FsRtlPrivateCheckWaitingLocks</a>( LockInfo, LockQueue, OldIrql );
03742             }
03743 
03744             <a class="code" href="../../d5/d3/filelock_8c.html#a10">FsRtlReleaseLockQueue</a>( LockQueue, OldIrql );
03745 
03746             <span class="keywordflow">return</span> STATUS_SUCCESS;
03747         }
03748 
03749         <span class="keywordflow">if</span> ((ULONGLONG)<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.StartingByte.QuadPart &gt; (ULONGLONG)AlignedFileOffset.QuadPart) {
03750 
03751             <span class="comment">//</span>
03752             <span class="comment">//  The current lock begins at a byte offset greater than the range we are seeking</span>
03753             <span class="comment">//  to unlock. This range must therefore not be locked.</span>
03754             <span class="comment">//</span>
03755 
03756             <span class="keywordflow">break</span>;
03757         }
03758     }
03759 
03760     <span class="comment">//</span>
03761     <span class="comment">//  Lock was not found, return to our caller</span>
03762     <span class="comment">//</span>
03763 
03764     <a class="code" href="../../d5/d3/filelock_8c.html#a10">FsRtlReleaseLockQueue</a>(LockQueue, OldIrql);
03765     <span class="keywordflow">return</span> STATUS_RANGE_NOT_LOCKED;
03766 }
03767 
03768 
03769 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l03770"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a123">03770</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a123">FsRtlFastUnlockAll</a> (
03771     IN <a class="code" href="../../d7/d1/struct__FILE__LOCK.html">PFILE_LOCK</a> FileLock,
03772     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
03773     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> ProcessId,
03774     IN PVOID Context OPTIONAL
03775     )
03776 
03777 <span class="comment">/*++</span>
03778 <span class="comment"></span>
03779 <span class="comment">Routine Description:</span>
03780 <span class="comment"></span>
03781 <span class="comment">    This routine performs an Unlock all operation on the current locks</span>
03782 <span class="comment">    associated with the specified file lock.  Only those locks with</span>
03783 <span class="comment">    a matching file object and process id are freed.</span>
03784 <span class="comment"></span>
03785 <span class="comment">Arguments:</span>
03786 <span class="comment"></span>
03787 <span class="comment">    FileLock - Supplies the file lock being freed.</span>
03788 <span class="comment"></span>
03789 <span class="comment">    FileObject - Supplies the file object associated with the file lock</span>
03790 <span class="comment"></span>
03791 <span class="comment">    ProcessId - Supplies the Process Id assoicated with the locks to be</span>
03792 <span class="comment">        freed</span>
03793 <span class="comment"></span>
03794 <span class="comment">    Context - Supplies an optional context to use when completing waiting</span>
03795 <span class="comment">        lock irps.</span>
03796 <span class="comment"></span>
03797 <span class="comment">Return Value:</span>
03798 <span class="comment"></span>
03799 <span class="comment">    None</span>
03800 <span class="comment"></span>
03801 <span class="comment">--*/</span>
03802 
03803 {
03804     <span class="keywordflow">return</span> <a class="code" href="../../d5/d3/filelock_8c.html#a53">FsRtlPrivateFastUnlockAll</a>(
03805                 FileLock,
03806                 FileObject,
03807                 ProcessId,
03808                 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,           <span class="comment">// No Key</span>
03809                 Context );
03810 }
03811 
03812 
03813 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l03814"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a124">03814</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a124">FsRtlFastUnlockAllByKey</a> (
03815     IN <a class="code" href="../../d7/d1/struct__FILE__LOCK.html">PFILE_LOCK</a> FileLock,
03816     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
03817     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> ProcessId,
03818     IN ULONG Key,
03819     IN PVOID Context OPTIONAL
03820     )
03821 
03822 <span class="comment">/*++</span>
03823 <span class="comment"></span>
03824 <span class="comment">Routine Description:</span>
03825 <span class="comment"></span>
03826 <span class="comment">    This routine performs an Unlock All by Key operation on the current locks</span>
03827 <span class="comment">    associated with the specified file lock.  Only those locks with</span>
03828 <span class="comment">    a matching file object, process id, and key are freed.  The input Irp</span>
03829 <span class="comment">    is completed by this procedure</span>
03830 <span class="comment"></span>
03831 <span class="comment">Arguments:</span>
03832 <span class="comment"></span>
03833 <span class="comment">    FileLock - Supplies the file lock being freed.</span>
03834 <span class="comment"></span>
03835 <span class="comment">    FileObject - Supplies the file object associated with the file lock</span>
03836 <span class="comment"></span>
03837 <span class="comment">    ProcessId - Supplies the Process Id assoicated with the locks to be</span>
03838 <span class="comment">        freed</span>
03839 <span class="comment"></span>
03840 <span class="comment">    Key - Supplies the Key to use in this operation</span>
03841 <span class="comment"></span>
03842 <span class="comment">    Context - Supplies an optional context to use when completing waiting</span>
03843 <span class="comment">        lock irps.</span>
03844 <span class="comment"></span>
03845 <span class="comment">Return Value:</span>
03846 <span class="comment"></span>
03847 <span class="comment">    NTSTATUS - The return status for the operation.</span>
03848 <span class="comment"></span>
03849 <span class="comment">--*/</span>
03850 
03851 {
03852     <span class="keywordflow">return</span> <a class="code" href="../../d5/d3/filelock_8c.html#a53">FsRtlPrivateFastUnlockAll</a>(
03853                 FileLock,
03854                 FileObject,
03855                 ProcessId,
03856                 <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
03857                 Context );
03858 
03859 }
03860 
03861 
03862 <span class="comment">//</span>
03863 <span class="comment">//  Local Support Routine</span>
03864 <span class="comment">//</span>
03865 
03866 BOOLEAN
<a name="l03867"></a><a class="code" href="../../d1/d8/fsrtl_8h.html#a125">03867</a> <a class="code" href="../../d1/d8/fsrtl_8h.html#a125">FsRtlPrivateLock</a> (
03868     IN <a class="code" href="../../d7/d1/struct__FILE__LOCK.html">PFILE_LOCK</a> FileLock,
03869     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
03870     IN PLARGE_INTEGER FileOffset,
03871     IN PLARGE_INTEGER Length,
03872     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> ProcessId,
03873     IN ULONG Key,
03874     IN BOOLEAN FailImmediately,
03875     IN BOOLEAN ExclusiveLock,
03876     OUT PIO_STATUS_BLOCK Iosb,
03877     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp OPTIONAL,
03878     IN PVOID Context,
03879     IN BOOLEAN AlreadySynchronized
03880     )
03881 
03882 <span class="comment">/*++</span>
03883 <span class="comment"></span>
03884 <span class="comment">Routine Description:</span>
03885 <span class="comment"></span>
03886 <span class="comment">    This routine preforms a lock operation request.  This handles both the fast</span>
03887 <span class="comment">    get lock and the Irp based get lock.  If the Irp is supplied then</span>
03888 <span class="comment">    this routine will either complete the Irp or enqueue it as a waiting</span>
03889 <span class="comment">    lock request.</span>
03890 <span class="comment"></span>
03891 <span class="comment">Arguments:</span>
03892 <span class="comment"></span>
03893 <span class="comment">    FileLock - Supplies the File Lock to work against</span>
03894 <span class="comment"></span>
03895 <span class="comment">    FileObject - Supplies the file object used in this operation</span>
03896 <span class="comment"></span>
03897 <span class="comment">    FileOffset - Supplies the file offset used in this operation</span>
03898 <span class="comment"></span>
03899 <span class="comment">    Length - Supplies the length used in this operation</span>
03900 <span class="comment"></span>
03901 <span class="comment">    ProcessId - Supplies the process ID used in this operation</span>
03902 <span class="comment"></span>
03903 <span class="comment">    Key - Supplies the key used in this operation</span>
03904 <span class="comment"></span>
03905 <span class="comment">    FailImmediately - Indicates if the request should fail immediately</span>
03906 <span class="comment">        if the lock cannot be granted.</span>
03907 <span class="comment"></span>
03908 <span class="comment">    ExclusiveLock - Indicates if this is a request for an exclusive or</span>
03909 <span class="comment">        shared lock</span>
03910 <span class="comment"></span>
03911 <span class="comment">    Iosb - Receives the Status if this operation is successful</span>
03912 <span class="comment"></span>
03913 <span class="comment">    Context - Supplies the context with which to complete Irp with</span>
03914 <span class="comment"></span>
03915 <span class="comment">    AlreadySynchronized - Indicates that the caller has already synchronized</span>
03916 <span class="comment">        access to the file lock so the fields in the file lock and</span>
03917 <span class="comment">        be updated without further locking, but not the queues.</span>
03918 <span class="comment"></span>
03919 <span class="comment">Return Value:</span>
03920 <span class="comment"></span>
03921 <span class="comment">    BOOLEAN - TRUE if this operation completed and FALSE otherwise.</span>
03922 <span class="comment"></span>
03923 <span class="comment">--*/</span>
03924 
03925 {
03926     BOOLEAN Results;
03927     BOOLEAN AccessGranted;
03928     BOOLEAN ViaFastCall;
03929     BOOLEAN ReleaseQueue = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03930 
03931     <a class="code" href="../../d5/d3/filelock_8c.html#a30">PLOCK_INFO</a>  LockInfo;
03932     <a class="code" href="../../d5/d3/filelock_8c.html#a28">PLOCK_QUEUE</a> LockQueue;
03933     KIRQL       OldIrql;
03934     <a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html">FILE_LOCK_INFO</a> FileLockInfo;
03935 
03936     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlPrivateLock, FileLock = %08lx\n"</span>, FileLock);
03937 
03938     <span class="comment">//</span>
03939     <span class="comment">//  If the irp is null then this is being called via the fast call method.</span>
03940     <span class="comment">//</span>
03941 
03942     ViaFastCall = (BOOLEAN) !ARGUMENT_PRESENT( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
03943 
03944     <span class="keywordflow">if</span> ((LockInfo = (<a class="code" href="../../d5/d3/filelock_8c.html#a30">PLOCK_INFO</a>) FileLock-&gt;LockInformation) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03945         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+2, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlPrivateLock, New LockInfo required\n"</span>, 0);
03946 
03947         <span class="comment">//</span>
03948         <span class="comment">// No lock information on this FileLock, create the structure.</span>
03949         <span class="comment">//</span>
03950         <span class="comment">//</span>
03951 
03952         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d3/filelock_8c.html#a54">FsRtlPrivateInitializeFileLock</a> (FileLock, ViaFastCall)) {
03953 
03954             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03955         }
03956 
03957         <span class="comment">//</span>
03958         <span class="comment">// Set flag so file locks will be checked on the fast io</span>
03959         <span class="comment">// code paths</span>
03960         <span class="comment">//</span>
03961 
03962         FileLock-&gt;FastIoIsQuestionable = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03963 
03964         <span class="comment">//</span>
03965         <span class="comment">// Pickup allocated lockinfo structure</span>
03966         <span class="comment">//</span>
03967 
03968         LockInfo = (<a class="code" href="../../d5/d3/filelock_8c.html#a30">PLOCK_INFO</a>) FileLock-&gt;LockInformation;
03969     }
03970 
03971     <span class="comment">//</span>
03972     <span class="comment">// Assume success and build LockData structure prior to acquiring</span>
03973     <span class="comment">// the lock queue spinlock.  (mp perf enhancement)</span>
03974     <span class="comment">//</span>
03975 
03976     FileLockInfo.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o0">StartingByte</a> = *FileOffset;
03977     FileLockInfo.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o1">Length</a> = *Length;
03978     (ULONGLONG)FileLockInfo.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o6">EndingByte</a>.QuadPart =
03979             (ULONGLONG)FileLockInfo.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o0">StartingByte</a>.QuadPart + (ULONGLONG)FileLockInfo.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o1">Length</a>.QuadPart - 1;
03980 
03981     FileLockInfo.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o3">Key</a> = <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>;
03982     FileLockInfo.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o4">FileObject</a> = FileObject;
03983     FileLockInfo.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o5">ProcessId</a> = ProcessId;
03984     FileLockInfo.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o2">ExclusiveLock</a> = ExclusiveLock;
03985 
03986     LockQueue = &amp;LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>;
03987 
03988     <span class="comment">//</span>
03989     <span class="comment">//  Now we need to actually run through our current lock queue.</span>
03990     <span class="comment">//</span>
03991 
03992     <a class="code" href="../../d5/d3/filelock_8c.html#a8">FsRtlAcquireLockQueue</a>(LockQueue, &amp;OldIrql);
03993     ReleaseQueue = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03994 
03995     <span class="keywordflow">try</span> {
03996 
03997         <span class="comment">//</span>
03998         <span class="comment">//  Case on whether we're trying to take out an exclusive lock or</span>
03999         <span class="comment">//  a shared lock.  And in both cases try to get appropriate access.</span>
04000         <span class="comment">//</span>
04001 
04002         <span class="keywordflow">if</span> (ExclusiveLock) {
04003 
04004             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"Check for write access\n"</span>, 0);
04005 
04006             AccessGranted = <a class="code" href="../../d5/d3/filelock_8c.html#a51">FsRtlPrivateCheckForExclusiveLockAccess</a>(
04007                                 LockQueue,
04008                                 &amp;FileLockInfo );
04009 
04010         } <span class="keywordflow">else</span> {
04011 
04012             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"Check for read access\n"</span>, 0);
04013 
04014             AccessGranted = <a class="code" href="../../d5/d3/filelock_8c.html#a52">FsRtlPrivateCheckForSharedLockAccess</a>(
04015                                 LockQueue,
04016                                 &amp;FileLockInfo );
04017         }
04018 
04019         <span class="comment">//</span>
04020         <span class="comment">//  Now AccessGranted tells us whether we can really get the access</span>
04021         <span class="comment">//  for the range we want</span>
04022         <span class="comment">//</span>
04023 
04024         <span class="keywordflow">if</span> (!AccessGranted) {
04025 
04026             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"We do not have access\n"</span>, 0);
04027 
04028             <span class="comment">//</span>
04029             <span class="comment">//  We cannot read/write to the range, so we cannot take out</span>
04030             <span class="comment">//  the lock.  Now if the user wanted to fail immediately then</span>
04031             <span class="comment">//  we'll complete the Irp, otherwise we'll enqueue this Irp</span>
04032             <span class="comment">//  to the waiting lock queue</span>
04033             <span class="comment">//</span>
04034 
04035             <span class="keywordflow">if</span> (FailImmediately) {
04036 
04037                 <span class="comment">//</span>
04038                 <span class="comment">//  Set our status and return, the finally clause will</span>
04039                 <span class="comment">//  complete the request</span>
04040                 <span class="comment">//</span>
04041 
04042                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"And we fail immediately\n"</span>, 0);
04043 
04044                 Iosb-&gt;Status = STATUS_LOCK_NOT_GRANTED;
04045                 <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>( Results = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
04046 
04047             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ARGUMENT_PRESENT(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>)) {
04048 
04049                 <a class="code" href="../../d5/d3/filelock_8c.html#a26">PWAITING_LOCK</a> WaitingLock;
04050 
04051                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"And we enqueue the Irp for later\n"</span>, 0);
04052 
04053                 <span class="comment">//</span>
04054                 <span class="comment">//  Allocate a new waiting record, set it to point to the</span>
04055                 <span class="comment">//  waiting Irp, and insert it in the tail of the waiting</span>
04056                 <span class="comment">//  locks queue</span>
04057                 <span class="comment">//</span>
04058 
04059                 WaitingLock = <a class="code" href="../../d5/d3/filelock_8c.html#a33">FsRtlAllocateWaitingLock</a>();
04060 
04061                 <span class="comment">//</span>
04062                 <span class="comment">//  Simply raise out if we can't allocate.</span>
04063                 <span class="comment">//</span>
04064 
04065                 <span class="keywordflow">if</span> (WaitingLock == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04066 
04067                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INSUFFICIENT_RESOURCES );
04068                 }
04069 
04070                 WaitingLock-&gt;<a class="code" href="../../d1/d8/struct__WAITING__LOCK.html#o2">Irp</a> = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>;
04071                 WaitingLock-&gt;<a class="code" href="../../d1/d8/struct__WAITING__LOCK.html#o1">Context</a> = Context;
04072                 <a class="code" href="../../d0/d5/io_8h.html#a234">IoMarkIrpPending</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
04073 
04074                 <span class="comment">//</span>
04075                 <span class="comment">// Add WaitingLock WaitingLockQueue</span>
04076                 <span class="comment">//</span>
04077 
04078                 WaitingLock-&gt;<a class="code" href="../../d1/d8/struct__WAITING__LOCK.html#o0">Link</a>.Next = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04079                 <span class="keywordflow">if</span> (LockQueue-&gt;<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o3">WaitingLocks</a>.Next == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04080 
04081                     <span class="comment">//</span>
04082                     <span class="comment">// Create new list</span>
04083                     <span class="comment">//</span>
04084 
04085                     LockQueue-&gt;<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o3">WaitingLocks</a>.Next = &amp;WaitingLock-&gt;<a class="code" href="../../d1/d8/struct__WAITING__LOCK.html#o0">Link</a>;
04086                     LockQueue-&gt;<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o4">WaitingLocksTail</a>.Next = &amp;WaitingLock-&gt;<a class="code" href="../../d1/d8/struct__WAITING__LOCK.html#o0">Link</a>;
04087 
04088                 } <span class="keywordflow">else</span> {
04089 
04090                     <span class="comment">//</span>
04091                     <span class="comment">// Add waiter to tail of list</span>
04092                     <span class="comment">//</span>
04093 
04094                     LockQueue-&gt;<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o4">WaitingLocksTail</a>.Next-&gt;Next = &amp;WaitingLock-&gt;<a class="code" href="../../d1/d8/struct__WAITING__LOCK.html#o0">Link</a>;
04095                     LockQueue-&gt;<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o4">WaitingLocksTail</a>.Next = &amp;WaitingLock-&gt;<a class="code" href="../../d1/d8/struct__WAITING__LOCK.html#o0">Link</a>;
04096                 }
04097 
04098 
04099                 <span class="comment">//</span>
04100                 <span class="comment">//  Setup IRP in case it's canceled - then set the</span>
04101                 <span class="comment">//  IRP's cancel routine</span>
04102                 <span class="comment">//</span>
04103 
04104                 <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information = (ULONG_PTR)LockInfo;
04105                 <a class="code" href="../../d0/d5/io_8h.html#a236">IoSetCancelRoutine</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, <a class="code" href="../../d5/d3/filelock_8c.html#a50">FsRtlPrivateCancelFileLockIrp</a> );
04106 
04107                 <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o14">Cancel</a>) {
04108 
04109                     <span class="comment">//</span>
04110                     <span class="comment">// Pull the cancel routine off of the IRP - if it is not</span>
04111                     <span class="comment">// NULL, this means we won the race with IoCancelIrp and</span>
04112                     <span class="comment">// will be responsible for cancelling the IRP synchronously.</span>
04113                     <span class="comment">// If NULL, we lost and our cancel routine is already being</span>
04114                     <span class="comment">// called for us.</span>
04115                     <span class="comment">//</span>
04116                     <span class="comment">// This must be done while holding the lock queue down since</span>
04117                     <span class="comment">// this is how we synchronize with the cancel.</span>
04118                     <span class="comment">//</span>
04119 
04120                     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d5/io_8h.html#a236">IoSetCancelRoutine</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> )) {
04121 
04122                         <span class="comment">//</span>
04123                         <span class="comment">// Irp's cancel routine was not called, do it ourselves.</span>
04124                         <span class="comment">// Indicate to the cancel routine that he does not need</span>
04125                         <span class="comment">// to release the cancel spinlock by passing a NULL DO.</span>
04126                         <span class="comment">//</span>
04127                         <span class="comment">// The queue will be dropped in order to complete the Irp.</span>
04128                         <span class="comment">// We communicate the previous IRQL through the Irp itself.</span>
04129                         <span class="comment">//</span>
04130 
04131                         <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o15">CancelIrql</a> = OldIrql;
04132                         <a class="code" href="../../d5/d3/filelock_8c.html#a50">FsRtlPrivateCancelFileLockIrp</a>( <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
04133                         ReleaseQueue = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04134                     }
04135                 }
04136 
04137                 Iosb-&gt;Status = STATUS_PENDING;
04138                 <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>( Results = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
04139 
04140             } <span class="keywordflow">else</span> {
04141 
04142                 <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>( Results = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
04143             }
04144         }
04145 
04146         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"We have access\n"</span>, 0);
04147 
04148         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d3/filelock_8c.html#a46">FsRtlPrivateInsertLock</a>( LockInfo, FileObject, &amp;FileLockInfo )) {
04149 
04150             <span class="comment">//</span>
04151             <span class="comment">//  Resource exhaustion will cause us to fail here.  Via the fast call, indicate</span>
04152             <span class="comment">//  that it may be worthwhile to go around again via the Irp based path.  If we</span>
04153             <span class="comment">//  are already there, simply raise out.</span>
04154             <span class="comment">//</span>
04155 
04156             <span class="keywordflow">if</span> (ViaFastCall) {
04157 
04158                 <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>( Results = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
04159 
04160             } <span class="keywordflow">else</span> {
04161 
04162                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INSUFFICIENT_RESOURCES );
04163             }
04164 
04165         } <span class="keywordflow">else</span> {
04166 
04167             Iosb-&gt;Status = STATUS_SUCCESS;
04168         }
04169 
04170         <span class="comment">//</span>
04171         <span class="comment">//  At long last, we're done.</span>
04172         <span class="comment">//</span>
04173 
04174         Results = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04175 
04176     try_exit: NOTHING;
04177     } finally {
04178 
04179         <span class="keywordflow">if</span> (ReleaseQueue) {
04180             
04181             <a class="code" href="../../d5/d3/filelock_8c.html#a10">FsRtlReleaseLockQueue</a>(LockQueue, OldIrql);
04182         }
04183 
04184         <span class="comment">//</span>
04185         <span class="comment">//  Complete the request provided we were given one and it is not a pending status</span>
04186         <span class="comment">//</span>
04187 
04188         <span class="keywordflow">if</span> (!AbnormalTermination() &amp;&amp; ARGUMENT_PRESENT(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>) &amp;&amp; (Iosb-&gt;Status != STATUS_PENDING)) {
04189 
04190             <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> NewStatus;
04191 
04192             <span class="comment">//</span>
04193             <span class="comment">//  We must reference the fileobject for the case that the IRP completion</span>
04194             <span class="comment">//  fails and we need to lift the lock.  Although the only reason we have</span>
04195             <span class="comment">//  to touch the fileobject in the remove case is to unset the LastLock field,</span>
04196             <span class="comment">//  we have no way of knowing if we will race with a reference count drop</span>
04197             <span class="comment">//  and lose.</span>
04198             <span class="comment">//</span>
04199 
04200             <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a>( FileObject );
04201 
04202             <span class="comment">//</span>
04203             <span class="comment">//  Complete the request, if the don't get back success then</span>
04204             <span class="comment">//  we need to possibly remove the lock that we just</span>
04205             <span class="comment">//  inserted.</span>
04206             <span class="comment">//</span>
04207 
04208             <a class="code" href="../../d5/d3/filelock_8c.html#a11">FsRtlCompleteLockIrp</a>(
04209                 LockInfo,
04210                 Context,
04211                 <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>,
04212                 Iosb-&gt;Status,
04213                 &amp;NewStatus,
04214                 FileObject );
04215 
04216             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(NewStatus) &amp;&amp; <a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Iosb-&gt;Status) ) {
04217 
04218                 <span class="comment">//</span>
04219                 <span class="comment">// Irp failed, remove the lock which was added</span>
04220                 <span class="comment">//</span>
04221 
04222                 <a class="code" href="../../d5/d3/filelock_8c.html#a55">FsRtlPrivateRemoveLock</a> (
04223                     LockInfo,
04224                     &amp;FileLockInfo,
04225                     <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
04226             }
04227 
04228             <span class="comment">//</span>
04229             <span class="comment">//  Lift our private reference to the fileobject. This may induce deletion.</span>
04230             <span class="comment">//</span>
04231 
04232             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( FileObject );
04233 
04234             Iosb-&gt;Status = NewStatus;
04235         }
04236 
04237         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlPrivateLock -&gt; %08lx\n"</span>, Results);
04238     }
04239 
04240     <span class="comment">//</span>
04241     <span class="comment">//  and return to our caller</span>
04242     <span class="comment">//</span>
04243 
04244     <span class="keywordflow">return</span> Results;
04245 }
04246 
04247 
04248 <span class="comment">//</span>
04249 <span class="comment">//  Internal Support Routine</span>
04250 <span class="comment">//</span>
04251 
04252 BOOLEAN
<a name="l04253"></a><a class="code" href="../../d5/d3/filelock_8c.html#a46">04253</a> <a class="code" href="../../d5/d3/filelock_8c.html#a46">FsRtlPrivateInsertLock</a> (
04254     IN PLOCK_INFO LockInfo,
04255     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
04256     IN <a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html">PFILE_LOCK_INFO</a> FileLockInfo
04257     )
04258 
04259 <span class="comment">/*++</span>
04260 <span class="comment"></span>
04261 <span class="comment">Routine Description:</span>
04262 <span class="comment"></span>
04263 <span class="comment">    This routine fills in a new lock record of the appropriate type and inserts</span>
04264 <span class="comment">    it into the lock information.</span>
04265 <span class="comment"></span>
04266 <span class="comment">Arguments:</span>
04267 <span class="comment"></span>
04268 <span class="comment">    LockInfo - Supplies the lock being modified</span>
04269 <span class="comment"></span>
04270 <span class="comment">    FileObject - The associated file object to update hints in</span>
04271 <span class="comment"></span>
04272 <span class="comment">    FileLockInfo - Supplies the new lock data to add to the lock queue</span>
04273 <span class="comment"></span>
04274 <span class="comment">Return Value:</span>
04275 <span class="comment"></span>
04276 <span class="comment">    BOOLEAN - True if the insert was successful, False if no resources were avaliable</span>
04277 <span class="comment">        to complete the operation.</span>
04278 <span class="comment"></span>
04279 <span class="comment">--*/</span>
04280 
04281 {
04282     <span class="comment">//</span>
04283     <span class="comment">//  Now add the lock to the appropriate tree.</span>
04284     <span class="comment">//</span>
04285 
04286     <span class="keywordflow">if</span> (FileLockInfo-&gt;ExclusiveLock) {
04287 
04288         <a class="code" href="../../d5/d3/filelock_8c.html#a24">PEX_LOCK</a> ExLock;
04289 
04290         ExLock = <a class="code" href="../../d5/d3/filelock_8c.html#a32">FsRtlAllocateExclusiveLock</a>();
04291 
04292         <span class="keywordflow">if</span> (ExLock == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04293 
04294             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04295         }
04296 
04297         ExLock-&gt;<a class="code" href="../../d7/d7/struct__EX__LOCK.html#o1">LockInfo</a> = *FileLockInfo;
04298 
04299         <a class="code" href="../../d5/d3/filelock_8c.html#a48">FsRtlPrivateInsertExclusiveLock</a>( &amp;LockInfo-&gt;LockQueue, ExLock );
04300 
04301         FileObject-&gt;LastLock = &amp;ExLock-&gt;<a class="code" href="../../d7/d7/struct__EX__LOCK.html#o1">LockInfo</a>;
04302 
04303     } <span class="keywordflow">else</span> {
04304 
04305         <a class="code" href="../../d5/d3/filelock_8c.html#a22">PSH_LOCK</a> ShLock;
04306 
04307         ShLock = <a class="code" href="../../d5/d3/filelock_8c.html#a31">FsRtlAllocateSharedLock</a>();
04308 
04309         <span class="keywordflow">if</span> (ShLock == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04310 
04311             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04312         }
04313 
04314         ShLock-&gt;<a class="code" href="../../d8/d2/struct__SH__LOCK.html#o1">LockInfo</a> = *FileLockInfo;
04315 
04316         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d3/filelock_8c.html#a47">FsRtlPrivateInsertSharedLock</a>( &amp;LockInfo-&gt;LockQueue, ShLock )) {
04317 
04318             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04319         }
04320 
04321         FileObject-&gt;LastLock = &amp;ShLock-&gt;<a class="code" href="../../d8/d2/struct__SH__LOCK.html#o1">LockInfo</a>;
04322     }
04323 
04324     <span class="comment">//</span>
04325     <span class="comment">//  Fix up the lowest lock offset if need be</span>
04326     <span class="comment">//</span>
04327 
04328     <span class="keywordflow">if</span> ((ULONGLONG)FileLockInfo-&gt;StartingByte.QuadPart &lt; (ULONGLONG)LockInfo-&gt;LowestLockOffset) {
04329 
04330         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( FileLockInfo-&gt;StartingByte.HighPart == 0 );
04331         LockInfo-&gt;LowestLockOffset = FileLockInfo-&gt;StartingByte.LowPart;
04332     }
04333 
04334     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04335 }
04336 
04337 
04338 <span class="comment">//</span>
04339 <span class="comment">//  Internal Support Routine</span>
04340 <span class="comment">//</span>
04341 
04342 BOOLEAN
<a name="l04343"></a><a class="code" href="../../d5/d3/filelock_8c.html#a47">04343</a> <a class="code" href="../../d5/d3/filelock_8c.html#a47">FsRtlPrivateInsertSharedLock</a> (
04344     IN PLOCK_QUEUE LockQueue,
04345     IN PSH_LOCK NewLock
04346     )
04347 
04348 <span class="comment">/*++</span>
04349 <span class="comment"></span>
04350 <span class="comment">Routine Description:</span>
04351 <span class="comment"></span>
04352 <span class="comment">    This routine adds a new shared lock record to the File lock's current</span>
04353 <span class="comment">    lock queue. Locks are inserted into nodes ordered by their starting byte.</span>
04354 <span class="comment"></span>
04355 <span class="comment">Arguments:</span>
04356 <span class="comment"></span>
04357 <span class="comment">    LockQueue - Supplies the lock queue being modified</span>
04358 <span class="comment"></span>
04359 <span class="comment">    NewLock - Supplies the new shared lock to add to the lock queue</span>
04360 <span class="comment"></span>
04361 <span class="comment">Return Value:</span>
04362 <span class="comment"></span>
04363 <span class="comment">    BOOLEAN - True if the insert was successful, False if no resources were avaliable</span>
04364 <span class="comment">        to complete the operation.</span>
04365 <span class="comment"></span>
04366 <span class="comment">--*/</span>
04367 {
04368     PSINGLE_LIST_ENTRY pLink, Link;
04369     PRTL_SPLAY_LINKS OverlappedSplayLinks, ParentSplayLinks;
04370     <a class="code" href="../../d5/d3/filelock_8c.html#a20">PLOCKTREE_NODE</a> Node, NextNode;
04371     <a class="code" href="../../d5/d3/filelock_8c.html#a22">PSH_LOCK</a> NextLock;
04372     BOOLEAN <a class="code" href="../../d1/d8/fsrtl_8h.html#a189a91">GreaterThan</a>;
04373 
04374     OverlappedSplayLinks = <a class="code" href="../../d5/d3/filelock_8c.html#a43">FsRtlFindFirstOverlappingSharedNode</a>( LockQueue-&gt;SharedLockTree,
04375                                                                 &amp;NewLock-&gt;LockInfo.StartingByte,
04376                                                                 &amp;NewLock-&gt;LockInfo.EndingByte,
04377                                                                 &amp;ParentSplayLinks,
04378                                                                 &amp;<a class="code" href="../../d1/d8/fsrtl_8h.html#a189a91">GreaterThan</a> );
04379 
04380     <span class="keywordflow">if</span> (OverlappedSplayLinks == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04381 
04382         <span class="comment">//</span>
04383         <span class="comment">//  Simple insert case, build a new node</span>
04384         <span class="comment">//</span>
04385 
04386         NextNode = <a class="code" href="../../d5/d3/filelock_8c.html#a34">FsRtlAllocateLockTreeNode</a>();
04387 
04388         <span class="comment">//</span>
04389         <span class="comment">//  If no resources are avaliable, simply fail now.</span>
04390         <span class="comment">//</span>
04391 
04392         <span class="keywordflow">if</span> (NextNode == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04393 
04394             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04395         }
04396 
04397         RtlInitializeSplayLinks(&amp;NextNode-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o3">Links</a>);
04398         NextNode-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o1">HoleyNode</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04399 
04400         NextNode-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o0">Locks</a>.Next = NextNode-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o4">Tail</a>.Next = &amp;NewLock-&gt;Link;
04401         NextNode-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o2">Extent</a> = (ULONGLONG)NewLock-&gt;LockInfo.EndingByte.QuadPart;
04402         NewLock-&gt;Link.Next = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04403 
04404         <span class="keywordflow">if</span> (ParentSplayLinks) {
04405 
04406             <span class="comment">//</span>
04407             <span class="comment">//  We have a real parent node in the tree</span>
04408             <span class="comment">//</span>
04409 
04410             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d8/fsrtl_8h.html#a189a91">GreaterThan</a>) {
04411 
04412                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(RtlLeftChild(ParentSplayLinks) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
04413                 RtlInsertAsLeftChild(ParentSplayLinks, &amp;NextNode-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o3">Links</a>);
04414 
04415             } <span class="keywordflow">else</span> {
04416 
04417                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(RtlRightChild(ParentSplayLinks) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
04418                 RtlInsertAsRightChild(ParentSplayLinks, &amp;NextNode-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o3">Links</a>);
04419             }
04420 
04421             <span class="comment">//</span>
04422             <span class="comment">//  Splay all new nodes in the tree</span>
04423             <span class="comment">//</span>
04424 
04425             LockQueue-&gt;SharedLockTree = <a class="code" href="../../d3/d4/splay_8c.html#a3">RtlSplay</a>(&amp;NextNode-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o3">Links</a>);
04426 
04427         } <span class="keywordflow">else</span> {
04428 
04429             <span class="comment">//</span>
04430             <span class="comment">//  First node in the tree</span>
04431             <span class="comment">//</span>
04432 
04433             LockQueue-&gt;SharedLockTree = &amp;NextNode-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o3">Links</a>;
04434         }
04435 
04436         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04437     }
04438 
04439     <span class="comment">//</span>
04440     <span class="comment">//  Now we examine the node to see if it is holey as a result of a resource-failed split.</span>
04441     <span class="comment">//  If it is, we must complete the split before adding the new lock.</span>
04442     <span class="comment">//</span>
04443 
04444     Node = CONTAINING_RECORD( OverlappedSplayLinks, <a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html">LOCKTREE_NODE</a>, Links );
04445 
04446     <span class="comment">//</span>
04447     <span class="comment">//  Search down the overlapped node finding the position for the new lock</span>
04448     <span class="comment">//</span>
04449 
04450     <span class="keywordflow">for</span> (pLink = &amp;Node-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o0">Locks</a>;
04451          (Link = pLink-&gt;Next) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04452          pLink = Link) {
04453 
04454         <a class="code" href="../../d5/d3/filelock_8c.html#a22">PSH_LOCK</a> <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>;
04455 
04456         <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a> = CONTAINING_RECORD( Link, <a class="code" href="../../d8/d2/struct__SH__LOCK.html">SH_LOCK</a>, Link );
04457 
04458         <span class="comment">//</span>
04459         <span class="comment">//  We sort locks on this list first by starting byte, then by whether the length is zero or not.</span>
04460         <span class="comment">//  This is important so that zero length locks appear prior to non-zero length locks, so that</span>
04461         <span class="comment">//  they are split out of nodes into the tree in the correct order.</span>
04462         <span class="comment">//</span>
04463         <span class="comment">//  if (NewLock-&gt;StartingByte &lt;= Lock-&gt;StartingByte) ...</span>
04464         <span class="comment">//</span>
04465 
04466         <span class="keywordflow">if</span> (((ULONGLONG)NewLock-&gt;LockInfo.StartingByte.QuadPart &lt; (ULONGLONG)<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.StartingByte.QuadPart) ||
04467 
04468             ((ULONGLONG)NewLock-&gt;LockInfo.StartingByte.QuadPart == (ULONGLONG)<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.StartingByte.QuadPart &amp;&amp;
04469              (NewLock-&gt;LockInfo.Length.QuadPart == 0 || <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.Length.QuadPart != 0))) {
04470 
04471             <span class="keywordflow">break</span>;
04472         }
04473     }
04474 
04475     <span class="comment">//</span>
04476     <span class="comment">//  At this point pLink points to the record that comes right after</span>
04477     <span class="comment">//  the new lock that we're inserting so we can simply push the</span>
04478     <span class="comment">//  newlock into the entrylist</span>
04479     <span class="comment">//</span>
04480 
04481     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"InsertSharedLock, Insert Before = %08lx\n"</span>, Link);
04482 
04483     <span class="keywordflow">if</span> (pLink-&gt;Next == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04484 
04485         <span class="comment">//</span>
04486         <span class="comment">//    Adding onto the tail of the list</span>
04487         <span class="comment">//</span>
04488 
04489         Node-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o4">Tail</a>.Next = &amp;NewLock-&gt;Link;
04490     }
04491 
04492     NewLock-&gt;Link.Next = pLink-&gt;Next;
04493     pLink-&gt;Next = &amp;NewLock-&gt;Link;
04494 
04495     <span class="comment">//</span>
04496     <span class="comment">//  And splay the node we inserted into</span>
04497     <span class="comment">//</span>
04498 
04499     LockQueue-&gt;SharedLockTree = <a class="code" href="../../d3/d4/splay_8c.html#a3">RtlSplay</a>(OverlappedSplayLinks);
04500 
04501     <span class="keywordflow">if</span> ((ULONGLONG)NewLock-&gt;LockInfo.EndingByte.QuadPart &gt; Node-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o2">Extent</a>) {
04502 
04503         <span class="comment">//</span>
04504         <span class="comment">//  The new lock extends the range of this node, so fix up the extent</span>
04505         <span class="comment">//</span>
04506 
04507         Node-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o2">Extent</a> = NewLock-&gt;LockInfo.EndingByte.QuadPart;
04508 
04509         <span class="comment">//</span>
04510         <span class="comment">//  Walk across the remainder of the tree integrating newly overlapping</span>
04511         <span class="comment">//  nodes into the node we just inserted the new lock into.  Note that</span>
04512         <span class="comment">//  this isn't so much a walk as a repeated examination of our successor's</span>
04513         <span class="comment">//  until one does not overlap (or we hit the end).</span>
04514         <span class="comment">//</span>
04515 
04516         ParentSplayLinks = OverlappedSplayLinks;
04517 
04518         <span class="keywordflow">for</span> (OverlappedSplayLinks = <a class="code" href="../../d3/d4/splay_8c.html#a8">RtlRealSuccessor</a>(ParentSplayLinks);
04519              OverlappedSplayLinks;
04520              OverlappedSplayLinks = <a class="code" href="../../d3/d4/splay_8c.html#a8">RtlRealSuccessor</a>(ParentSplayLinks)) {
04521 
04522             NextNode = CONTAINING_RECORD( OverlappedSplayLinks, <a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html">LOCKTREE_NODE</a>, Links );
04523             NextLock = CONTAINING_RECORD( NextNode-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o0">Locks</a>.Next, <a class="code" href="../../d8/d2/struct__SH__LOCK.html">SH_LOCK</a>, Link );
04524 
04525             <span class="keywordflow">if</span> ((ULONGLONG)NextLock-&gt;<a class="code" href="../../d8/d2/struct__SH__LOCK.html#o1">LockInfo</a>.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o0">StartingByte</a>.QuadPart &gt; Node-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o2">Extent</a>) {
04526 
04527                 <span class="comment">//</span>
04528                 <span class="comment">//  This node is not overlapped, so stop</span>
04529                 <span class="comment">//</span>
04530 
04531                 <span class="keywordflow">break</span>;
04532             }
04533 
04534             <span class="comment">//</span>
04535             <span class="comment">//  If we are intergrating a holey node into a non-holey node, try to split</span>
04536             <span class="comment">//  the node first.  It will be better to get this done with a smaller node</span>
04537             <span class="comment">//  than a big, fully integrated one.  Note that we are guaranteed that the</span>
04538             <span class="comment">//  node will remain a candidate for integration since the first lock on the</span>
04539             <span class="comment">//  node will still be there, and overlaps.</span>
04540             <span class="comment">//</span>
04541 
04542             <span class="keywordflow">if</span> (!Node-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o1">HoleyNode</a> &amp;&amp; NextNode-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o1">HoleyNode</a>) {
04543 
04544                 <a class="code" href="../../d5/d3/filelock_8c.html#a72">FsRtlSplitLocks</a>( NextNode, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
04545             }
04546 
04547             <span class="comment">//</span>
04548             <span class="comment">//  Integrate the locks in this node into our list</span>
04549             <span class="comment">//</span>
04550 
04551             Node-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o4">Tail</a>.Next-&gt;Next = NextNode-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o0">Locks</a>.Next;
04552             Node-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o4">Tail</a>.Next = NextNode-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o4">Tail</a>.Next;
04553 
04554             <span class="keywordflow">if</span> (NextNode-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o2">Extent</a> &gt; Node-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o2">Extent</a>) {
04555 
04556                 <span class="comment">//</span>
04557                 <span class="comment">//  If the node we just swallowed was (still!) holey, we perhaps made this</span>
04558                 <span class="comment">//  node holey too.  The resolution of this is left to the lock split we will</span>
04559                 <span class="comment">//  perform after integration is complete.</span>
04560                 <span class="comment">//</span>
04561                 <span class="comment">//  Note that if the extent of the node we are swallowing is interior</span>
04562                 <span class="comment">//  to the current node, we just covered whatever holes it contained.</span>
04563                 <span class="comment">//</span>
04564 
04565                 <span class="keywordflow">if</span> (NextNode-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o1">HoleyNode</a>) {
04566 
04567                     Node-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o1">HoleyNode</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04568                 }
04569 
04570                 Node-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o2">Extent</a> = NextNode-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o2">Extent</a>;
04571             }
04572 
04573             <span class="comment">//</span>
04574             <span class="comment">//  Free the now empty node.</span>
04575             <span class="comment">//</span>
04576 
04577             <a class="code" href="../../d3/d4/splay_8c.html#a5">RtlDeleteNoSplay</a>( OverlappedSplayLinks, &amp;LockQueue-&gt;SharedLockTree );
04578             <a class="code" href="../../d5/d3/filelock_8c.html#a39">FsRtlFreeLockTreeNode</a>( NextNode );
04579         }
04580     }
04581 
04582     <span class="comment">//</span>
04583     <span class="comment">//  Now, perhaps this node is still holey.  For grins lets try one more time to split</span>
04584     <span class="comment">//  this thing apart.</span>
04585     <span class="comment">//</span>
04586 
04587     <span class="keywordflow">if</span> (Node-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o1">HoleyNode</a>) {
04588 
04589         <a class="code" href="../../d5/d3/filelock_8c.html#a72">FsRtlSplitLocks</a>( Node, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
04590     }
04591 
04592     <span class="comment">//</span>
04593     <span class="comment">//  And return to our caller</span>
04594     <span class="comment">//</span>
04595 
04596     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04597 }
04598 
04599 
04600 <span class="comment">//</span>
04601 <span class="comment">//  Internal Support Routine</span>
04602 <span class="comment">//</span>
04603 
04604 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l04605"></a><a class="code" href="../../d5/d3/filelock_8c.html#a48">04605</a> <a class="code" href="../../d5/d3/filelock_8c.html#a48">FsRtlPrivateInsertExclusiveLock</a> (
04606     IN PLOCK_QUEUE LockQueue,
04607     IN PEX_LOCK NewLock
04608     )
04609 
04610 <span class="comment">/*++</span>
04611 <span class="comment"></span>
04612 <span class="comment">Routine Description:</span>
04613 <span class="comment"></span>
04614 <span class="comment">    This routine adds a new exclusive lock record to the File lock's current</span>
04615 <span class="comment">    lock queue.</span>
04616 <span class="comment"></span>
04617 <span class="comment">Arguments:</span>
04618 <span class="comment"></span>
04619 <span class="comment">    LockQueue - Supplies the lock queue being modified</span>
04620 <span class="comment"></span>
04621 <span class="comment">    NewLock - Supplies the new exclusive lock to add to the lock queue</span>
04622 <span class="comment"></span>
04623 <span class="comment">Return Value:</span>
04624 <span class="comment"></span>
04625 <span class="comment">    None.</span>
04626 <span class="comment"></span>
04627 <span class="comment">--*/</span>
04628 
04629 {
04630     PRTL_SPLAY_LINKS OverlappedSplayLinks, ParentSplayLinks;
04631     BOOLEAN <a class="code" href="../../d1/d8/fsrtl_8h.html#a189a91">GreaterThan</a>;
04632 
04633     OverlappedSplayLinks = <a class="code" href="../../d5/d3/filelock_8c.html#a44">FsRtlFindFirstOverlappingExclusiveNode</a>( LockQueue-&gt;ExclusiveLockTree,
04634                                                                    &amp;NewLock-&gt;LockInfo.StartingByte,
04635                                                                    &amp;NewLock-&gt;LockInfo.EndingByte,
04636                                                                    &amp;ParentSplayLinks,
04637                                                                    &amp;<a class="code" href="../../d1/d8/fsrtl_8h.html#a189a91">GreaterThan</a> );
04638 
04639     <span class="comment">//</span>
04640     <span class="comment">//  This is the exclusive tree. Nothing can overlap (caller is supposed to insure this) unless</span>
04641     <span class="comment">//  the lock is a zero length lock, in which case we just insert it - still.</span>
04642     <span class="comment">//</span>
04643 
04644     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(!OverlappedSplayLinks || NewLock-&gt;LockInfo.Length.QuadPart == 0);
04645 
04646     <span class="comment">//</span>
04647     <span class="comment">//  Simple insert ...</span>
04648     <span class="comment">//</span>
04649 
04650     RtlInitializeSplayLinks(&amp;NewLock-&gt;Links);
04651 
04652     <span class="keywordflow">if</span> (OverlappedSplayLinks) {
04653 
04654         <span class="comment">//</span>
04655         <span class="comment">//  With zero length locks we have OverlappedSplayLinks at the starting point</span>
04656         <span class="comment">//  of a run of zero length locks, so we have to e flexible about where the new</span>
04657         <span class="comment">//  node is inserted.</span>
04658         <span class="comment">//</span>
04659 
04660         <span class="keywordflow">if</span> (RtlRightChild(OverlappedSplayLinks)) {
04661 
04662             <span class="comment">//</span>
04663             <span class="comment">//  Right slot taken. We can use the left slot or go to the sucessor's left slot</span>
04664             <span class="comment">//</span>
04665 
04666             <span class="keywordflow">if</span> (RtlLeftChild(OverlappedSplayLinks)) {
04667 
04668                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(RtlLeftChild(<a class="code" href="../../d3/d4/splay_8c.html#a8">RtlRealSuccessor</a>(OverlappedSplayLinks)) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
04669                 RtlInsertAsLeftChild(<a class="code" href="../../d3/d4/splay_8c.html#a8">RtlRealSuccessor</a>(OverlappedSplayLinks), &amp;NewLock-&gt;Links);
04670 
04671             } <span class="keywordflow">else</span> {
04672 
04673                 RtlInsertAsLeftChild(OverlappedSplayLinks, &amp;NewLock-&gt;Links);
04674             }
04675 
04676 
04677         } <span class="keywordflow">else</span> {
04678 
04679             RtlInsertAsRightChild(OverlappedSplayLinks, &amp;NewLock-&gt;Links);
04680         }
04681 
04682     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ParentSplayLinks) {
04683 
04684         <span class="comment">//</span>
04685         <span class="comment">//  We have a real parent node in the tree, and must be at a leaf since</span>
04686         <span class="comment">//  there was no overlap</span>
04687         <span class="comment">//</span>
04688 
04689         <span class="keywordflow">if</span> (<a class="code" href="../../d1/d8/fsrtl_8h.html#a189a91">GreaterThan</a>) {
04690 
04691             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(RtlLeftChild(ParentSplayLinks) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
04692             RtlInsertAsLeftChild(ParentSplayLinks, &amp;NewLock-&gt;Links);
04693 
04694         } <span class="keywordflow">else</span> {
04695 
04696             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(RtlRightChild(ParentSplayLinks) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
04697             RtlInsertAsRightChild(ParentSplayLinks, &amp;NewLock-&gt;Links);
04698         }
04699 
04700     } <span class="keywordflow">else</span> {
04701 
04702         <span class="comment">//</span>
04703         <span class="comment">//  First node in the tree</span>
04704         <span class="comment">//</span>
04705 
04706         LockQueue-&gt;ExclusiveLockTree = &amp;NewLock-&gt;Links;
04707     }
04708 
04709     <span class="comment">//</span>
04710     <span class="comment">//  And return to our caller</span>
04711     <span class="comment">//</span>
04712 
04713     <span class="keywordflow">return</span>;
04714 }
04715 
04716 
04717 <span class="comment">//</span>
04718 <span class="comment">//  Internal Support Routine</span>
04719 <span class="comment">//</span>
04720 
04721 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l04722"></a><a class="code" href="../../d5/d3/filelock_8c.html#a49">04722</a> <a class="code" href="../../d5/d3/filelock_8c.html#a49">FsRtlPrivateCheckWaitingLocks</a> (
04723     IN PLOCK_INFO   LockInfo,
04724     IN PLOCK_QUEUE  LockQueue,
04725     IN KIRQL        OldIrql
04726     )
04727 
04728 <span class="comment">/*++</span>
04729 <span class="comment"></span>
04730 <span class="comment">Routine Description:</span>
04731 <span class="comment"></span>
04732 <span class="comment">    This routine checks to see if any of the current waiting locks are now</span>
04733 <span class="comment">    be satisfied, and if so it completes their IRPs.</span>
04734 <span class="comment"></span>
04735 <span class="comment">Arguments:</span>
04736 <span class="comment"></span>
04737 <span class="comment">    LockInfo - LockInfo which LockQueue is member of</span>
04738 <span class="comment"></span>
04739 <span class="comment">    LockQueue - Supplies queue which needs to be checked</span>
04740 <span class="comment"></span>
04741 <span class="comment">    OldIrql - Irql to restore when LockQueue is released</span>
04742 <span class="comment"></span>
04743 <span class="comment">Return Value:</span>
04744 <span class="comment"></span>
04745 <span class="comment">    None.</span>
04746 <span class="comment"></span>
04747 <span class="comment">--*/</span>
04748 
04749 {
04750     PSINGLE_LIST_ENTRY *pLink, Link;
04751     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> NewStatus;
04752     BOOLEAN Result;
04753 
04754     pLink = &amp;LockQueue-&gt;WaitingLocks.Next;
04755     <span class="keywordflow">while</span> ((Link = *pLink) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04756 
04757         <a class="code" href="../../d5/d3/filelock_8c.html#a26">PWAITING_LOCK</a> WaitingLock;
04758 
04759         <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>;
04760         <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> IrpSp;
04761 
04762         BOOLEAN AccessGranted;
04763 
04764         <a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html">FILE_LOCK_INFO</a> FileLockInfo;
04765 
04766         <span class="comment">//</span>
04767         <span class="comment">//  Get a pointer to the waiting lock record</span>
04768         <span class="comment">//</span>
04769 
04770         WaitingLock = CONTAINING_RECORD( Link, <a class="code" href="../../d1/d8/struct__WAITING__LOCK.html">WAITING_LOCK</a>, Link );
04771 
04772         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlCheckWaitingLocks, Loop top, WaitingLock = %08lx\n"</span>, WaitingLock);
04773 
04774         <span class="comment">//</span>
04775         <span class="comment">//  Get a local copy of the necessary fields we'll need to use</span>
04776         <span class="comment">//</span>
04777 
04778         <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> = WaitingLock-&gt;<a class="code" href="../../d1/d8/struct__WAITING__LOCK.html#o2">Irp</a>;
04779         IrpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
04780 
04781         FileLockInfo.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o0">StartingByte</a>  = IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.LockControl.ByteOffset;
04782         FileLockInfo.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o1">Length</a>        = *IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.LockControl.Length;
04783         (ULONGLONG)FileLockInfo.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o6">EndingByte</a>.QuadPart =
04784             (ULONGLONG)FileLockInfo.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o0">StartingByte</a>.QuadPart + (ULONGLONG)FileLockInfo.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o1">Length</a>.QuadPart - 1;
04785 
04786         FileLockInfo.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o4">FileObject</a>    = IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a>;
04787         FileLockInfo.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o5">ProcessId</a>     = <a class="code" href="../../d4/d6/iosubs_8c.html#a78">IoGetRequestorProcess</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
04788         FileLockInfo.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o3">Key</a>           = IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.LockControl.Key;
04789         FileLockInfo.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o2">ExclusiveLock</a> = <a class="code" href="../../d5/d5/cc_8h.html#a59">BooleanFlagOn</a>(IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o2">Flags</a>, <a class="code" href="../../d0/d5/io_8h.html#a207">SL_EXCLUSIVE_LOCK</a>);
04790 
04791         <span class="comment">//</span>
04792         <span class="comment">//  Now case on whether we're trying to take out an exclusive lock or</span>
04793         <span class="comment">//  a shared lock.  And in both cases try to get the appropriate access</span>
04794         <span class="comment">//  For the exclusive case we send in a NULL file object and process</span>
04795         <span class="comment">//  id, this will ensure that the lookup does not give us write</span>
04796         <span class="comment">//  access through an exclusive lock.</span>
04797         <span class="comment">//</span>
04798 
04799         <span class="keywordflow">if</span> (FileLockInfo.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o2">ExclusiveLock</a>) {
04800 
04801             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlCheckWaitingLocks do we have write access?\n"</span>, 0);
04802 
04803             AccessGranted = <a class="code" href="../../d5/d3/filelock_8c.html#a51">FsRtlPrivateCheckForExclusiveLockAccess</a>(
04804                                 LockQueue,
04805                                 &amp;FileLockInfo );
04806         } <span class="keywordflow">else</span> {
04807 
04808             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlCheckWaitingLocks do we have read access?\n"</span>, 0);
04809 
04810             AccessGranted = <a class="code" href="../../d5/d3/filelock_8c.html#a52">FsRtlPrivateCheckForSharedLockAccess</a>(
04811                                 LockQueue,
04812                                 &amp;FileLockInfo );
04813 
04814         }
04815 
04816         <span class="comment">//</span>
04817         <span class="comment">//  Now AccessGranted tells us whether we can really get the access for</span>
04818         <span class="comment">//  the range we want.</span>
04819         <span class="comment">//</span>
04820         <span class="comment">//  No matter what happens, this Irp must be completed now - even if we</span>
04821         <span class="comment">//  are resource starved.  User mode deadlock could be induced since there</span>
04822         <span class="comment">//  may no longer be a pending unlock to cause a rescan of the waiting</span>
04823         <span class="comment">//  list.</span>
04824         <span class="comment">//</span>
04825 
04826         <span class="keywordflow">if</span> (AccessGranted) {
04827 
04828             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlCheckWaitingLocks now has access\n"</span>, 0);
04829 
04830             <span class="comment">//</span>
04831             <span class="comment">//  Clear the cancel routine</span>
04832             <span class="comment">//</span>
04833 
04834             <a class="code" href="../../d0/d5/io_8h.html#a236">IoSetCancelRoutine</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
04835 
04836             Result = <a class="code" href="../../d5/d3/filelock_8c.html#a46">FsRtlPrivateInsertLock</a>( LockInfo, IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a>, &amp;FileLockInfo );
04837 
04838             <span class="comment">//</span>
04839             <span class="comment">//  Now we need to remove this granted waiter and complete</span>
04840             <span class="comment">//  it's irp.</span>
04841             <span class="comment">//</span>
04842 
04843             *pLink = Link-&gt;Next;
04844             <span class="keywordflow">if</span> (Link == LockQueue-&gt;WaitingLocksTail.Next) {
04845                 LockQueue-&gt;WaitingLocksTail.Next = (PSINGLE_LIST_ENTRY) pLink;
04846             }
04847 
04848             <span class="comment">//</span>
04849             <span class="comment">// Release LockQueue and complete this waiter</span>
04850             <span class="comment">//</span>
04851 
04852             <a class="code" href="../../d5/d3/filelock_8c.html#a10">FsRtlReleaseLockQueue</a>(LockQueue, OldIrql);
04853 
04854             <span class="comment">//</span>
04855             <span class="comment">//  Reference the fileobject over the completion attempt so we can have a</span>
04856             <span class="comment">//  chance to cleanup safely if we fail</span>
04857             <span class="comment">//</span>
04858 
04859             <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a>( FileLockInfo.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o4">FileObject</a> );
04860 
04861             <span class="comment">//</span>
04862             <span class="comment">//  Now we can complete the IRP, if we don't get back success</span>
04863             <span class="comment">//  from the completion routine then we remove the lock we just</span>
04864             <span class="comment">//  inserted.</span>
04865             <span class="comment">//</span>
04866 
04867             <a class="code" href="../../d5/d3/filelock_8c.html#a11">FsRtlCompleteLockIrp</a>( LockInfo,
04868                                   WaitingLock-&gt;<a class="code" href="../../d1/d8/struct__WAITING__LOCK.html#o1">Context</a>,
04869                                   <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>,
04870                                   (Result? STATUS_SUCCESS : STATUS_INSUFFICIENT_RESOURCES),
04871                                   &amp;NewStatus,
04872                                   FileLockInfo.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o4">FileObject</a> );
04873 
04874             <span class="keywordflow">if</span> (Result &amp;&amp; !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(NewStatus)) {
04875 
04876                 <span class="comment">//</span>
04877                 <span class="comment">// Irp was not sucessfull, remove lock if it was added.</span>
04878                 <span class="comment">//</span>
04879 
04880                 <a class="code" href="../../d5/d3/filelock_8c.html#a55">FsRtlPrivateRemoveLock</a> (
04881                     LockInfo,
04882                     &amp;FileLockInfo,
04883                     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
04884             }
04885 
04886             <span class="comment">//</span>
04887             <span class="comment">//  Drop our private reference to the fileobject</span>
04888             <span class="comment">//</span>
04889 
04890             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( FileLockInfo.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o4">FileObject</a> );
04891 
04892             <span class="comment">//</span>
04893             <span class="comment">// Re-acquire queue lock</span>
04894             <span class="comment">//</span>
04895 
04896             <a class="code" href="../../d5/d3/filelock_8c.html#a9">FsRtlReacquireLockQueue</a>(LockInfo, LockQueue, &amp;OldIrql);
04897 
04898             <span class="comment">//</span>
04899             <span class="comment">// Start scan over from begining</span>
04900             <span class="comment">//</span>
04901 
04902             pLink = &amp;LockQueue-&gt;WaitingLocks.Next;
04903 
04904 
04905             <span class="comment">//</span>
04906             <span class="comment">//  Free up pool</span>
04907             <span class="comment">//</span>
04908 
04909             <a class="code" href="../../d5/d3/filelock_8c.html#a38">FsRtlFreeWaitingLock</a>( WaitingLock );
04910 
04911 
04912         } <span class="keywordflow">else</span> {
04913 
04914             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlCheckWaitingLocks still no access\n"</span>, 0);
04915 
04916             <span class="comment">//</span>
04917             <span class="comment">// Move to next lock</span>
04918             <span class="comment">//</span>
04919 
04920             pLink = &amp;Link-&gt;Next;
04921         }
04922 
04923     }
04924 
04925     <span class="comment">//</span>
04926     <span class="comment">//  And return to our caller</span>
04927     <span class="comment">//</span>
04928 
04929     <span class="keywordflow">return</span>;
04930 }
04931 
04932 
04933 BOOLEAN
<a name="l04934"></a><a class="code" href="../../d5/d3/filelock_8c.html#a51">04934</a> <a class="code" href="../../d5/d3/filelock_8c.html#a51">FsRtlPrivateCheckForExclusiveLockAccess</a> (
04935     IN PLOCK_QUEUE LockQueue,
04936     IN <a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html">PFILE_LOCK_INFO</a> FileLockInfo
04937     )
04938 <span class="comment">/*++</span>
04939 <span class="comment"></span>
04940 <span class="comment">Routine Description:</span>
04941 <span class="comment"></span>
04942 <span class="comment">    This routine checks to see if the caller can get an exclusive lock on</span>
04943 <span class="comment">    the indicated range due to file locks in the passed in lock queue.</span>
04944 <span class="comment"></span>
04945 <span class="comment">    Assumes Lock queue is held by caller</span>
04946 <span class="comment"></span>
04947 <span class="comment">Arguments:</span>
04948 <span class="comment"></span>
04949 <span class="comment">    LockQueue - Queue which needs to be checked for collision</span>
04950 <span class="comment"></span>
04951 <span class="comment">    FileLockInfo - Lock which is being checked</span>
04952 <span class="comment"></span>
04953 <span class="comment"></span>
04954 <span class="comment">Return Value:</span>
04955 <span class="comment"></span>
04956 <span class="comment">    BOOLEAN - TRUE if the indicated user can place the exclusive lock over the</span>
04957 <span class="comment">        entire specified byte range, and FALSE otherwise</span>
04958 <span class="comment"></span>
04959 <span class="comment">--*/</span>
04960 
04961 {
04962     PRTL_SPLAY_LINKS SplayLinks, LastSplayLinks = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04963     <a class="code" href="../../d5/d3/filelock_8c.html#a20">PLOCKTREE_NODE</a> Node;
04964     <a class="code" href="../../d5/d3/filelock_8c.html#a22">PSH_LOCK</a> ShLock;
04965     <a class="code" href="../../d5/d3/filelock_8c.html#a24">PEX_LOCK</a> ExLock;
04966 
04967     <span class="keywordflow">if</span> (LockQueue-&gt;SharedLockTree &amp;&amp;
04968         (SplayLinks = <a class="code" href="../../d5/d3/filelock_8c.html#a43">FsRtlFindFirstOverlappingSharedNode</a>( LockQueue-&gt;SharedLockTree,
04969                                                            &amp;FileLockInfo-&gt;StartingByte,
04970                                                            &amp;FileLockInfo-&gt;EndingByte,
04971                                                            &amp;LastSplayLinks, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>))) {
04972 
04973         Node = CONTAINING_RECORD(SplayLinks, <a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html">LOCKTREE_NODE</a>, Links);
04974 
04975         <span class="comment">//</span>
04976         <span class="comment">//  If this node is holey, we'll have to walk the whole thing.</span>
04977         <span class="comment">//</span>
04978 
04979         <span class="keywordflow">if</span> (Node-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o1">HoleyNode</a>) {
04980 
04981             ShLock = <a class="code" href="../../d5/d3/filelock_8c.html#a45">FsRtlFindFirstOverlapInNode</a>( Node,
04982                                                   &amp;FileLockInfo-&gt;StartingByte,
04983                                                   &amp;FileLockInfo-&gt;EndingByte );
04984 
04985         } <span class="keywordflow">else</span> {
04986 
04987             ShLock = CONTAINING_RECORD(Node-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o0">Locks</a>.Next, <a class="code" href="../../d8/d2/struct__SH__LOCK.html">SH_LOCK</a>, Link);
04988         }
04989 
04990         <span class="comment">//</span>
04991         <span class="comment">//  Look for overlap that we care about.  Perhaps no overlap existed in the holey case.</span>
04992         <span class="comment">//</span>
04993 
04994         <span class="keywordflow">if</span> (ShLock &amp;&amp;
04995             (FileLockInfo-&gt;Length.QuadPart || ShLock-&gt;<a class="code" href="../../d8/d2/struct__SH__LOCK.html#o1">LockInfo</a>.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o1">Length</a>.QuadPart)) {
04996 
04997             <span class="comment">//</span>
04998             <span class="comment">//  If we are checking a nonzero extent and overlapped, it is fatal. If we</span>
04999             <span class="comment">//  are checking a zero extent and overlapped a nonzero extent, it is fatal.</span>
05000             <span class="comment">//</span>
05001 
05002             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
05003         }
05004     }
05005 
05006     <span class="keywordflow">if</span> (LastSplayLinks) {
05007 
05008         LockQueue-&gt;SharedLockTree = <a class="code" href="../../d3/d4/splay_8c.html#a3">RtlSplay</a>(LastSplayLinks);
05009         LastSplayLinks = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05010     }
05011 
05012     <span class="keywordflow">if</span> (LockQueue-&gt;ExclusiveLockTree &amp;&amp;
05013         (SplayLinks = <a class="code" href="../../d5/d3/filelock_8c.html#a44">FsRtlFindFirstOverlappingExclusiveNode</a>( LockQueue-&gt;ExclusiveLockTree,
05014                                                               &amp;FileLockInfo-&gt;StartingByte,
05015                                                               &amp;FileLockInfo-&gt;EndingByte,
05016                                                               &amp;LastSplayLinks, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>))) {
05017 
05018         ExLock = CONTAINING_RECORD(SplayLinks, <a class="code" href="../../d7/d7/struct__EX__LOCK.html">EX_LOCK</a>, Links);
05019 
05020         <span class="keywordflow">if</span> (FileLockInfo-&gt;Length.QuadPart || ExLock-&gt;<a class="code" href="../../d7/d7/struct__EX__LOCK.html#o1">LockInfo</a>.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o1">Length</a>.QuadPart) {
05021 
05022             <span class="comment">//</span>
05023             <span class="comment">//  If we are checking a nonzero extent and overlapped, it is fatal. If we</span>
05024             <span class="comment">//  are checking a zero extent and overlapped a nonzero extent, it is fatal.</span>
05025             <span class="comment">//</span>
05026 
05027             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
05028         }
05029     }
05030 
05031     <span class="keywordflow">if</span> (LastSplayLinks) {
05032 
05033         LockQueue-&gt;ExclusiveLockTree = <a class="code" href="../../d3/d4/splay_8c.html#a3">RtlSplay</a>(LastSplayLinks);
05034     }
05035 
05036     <span class="comment">//</span>
05037     <span class="comment">//  We searched the entire range without a conflict so we can grant</span>
05038     <span class="comment">//  the exclusive lock</span>
05039     <span class="comment">//</span>
05040 
05041     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
05042 }
05043 
05044 
05045 BOOLEAN
<a name="l05046"></a><a class="code" href="../../d5/d3/filelock_8c.html#a52">05046</a> <a class="code" href="../../d5/d3/filelock_8c.html#a52">FsRtlPrivateCheckForSharedLockAccess</a> (
05047     IN PLOCK_QUEUE LockQueue,
05048     IN <a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html">PFILE_LOCK_INFO</a> FileLockInfo
05049     )
05050 <span class="comment">/*++</span>
05051 <span class="comment"></span>
05052 <span class="comment">Routine Description:</span>
05053 <span class="comment"></span>
05054 <span class="comment">    This routine checks to see if the caller can get a shared lock on</span>
05055 <span class="comment">    the indicated range due to file locks in the passed in lock queue.</span>
05056 <span class="comment"></span>
05057 <span class="comment">    Assumes Lock queue is held by caller</span>
05058 <span class="comment"></span>
05059 <span class="comment">Arguments:</span>
05060 <span class="comment"></span>
05061 <span class="comment">    LockQueue - Queue which needs to be checked for collision</span>
05062 <span class="comment"></span>
05063 <span class="comment">    FileLockInfo - Lock which is being checked</span>
05064 <span class="comment"></span>
05065 <span class="comment">Arguments:</span>
05066 <span class="comment"></span>
05067 <span class="comment">Return Value:</span>
05068 <span class="comment"></span>
05069 <span class="comment">    BOOLEAN - TRUE if the indicated user can place the shared lock over</span>
05070 <span class="comment">        entire specified byte range, and FALSE otherwise</span>
05071 <span class="comment"></span>
05072 <span class="comment">--*/</span>
05073 
05074 {
05075     <a class="code" href="../../d5/d3/filelock_8c.html#a24">PEX_LOCK</a> <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>;
05076     PRTL_SPLAY_LINKS SplayLinks, LastSplayLinks;
05077     BOOLEAN <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
05078 
05079     <span class="comment">//</span>
05080     <span class="comment">// If there are no exclusive locks, this is quick ...</span>
05081     <span class="comment">//</span>
05082 
05083     <span class="keywordflow">if</span> (LockQueue-&gt;ExclusiveLockTree == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05084 
05085         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
05086     }
05087 
05088     <span class="comment">//</span>
05089     <span class="comment">//  No lock in the shared lock tree can prevent access, so just search the exclusive</span>
05090     <span class="comment">//  tree for conflict.</span>
05091     <span class="comment">//</span>
05092 
05093     <span class="keywordflow">for</span> (SplayLinks = <a class="code" href="../../d5/d3/filelock_8c.html#a44">FsRtlFindFirstOverlappingExclusiveNode</a>( LockQueue-&gt;ExclusiveLockTree,
05094                                                               &amp;FileLockInfo-&gt;StartingByte,
05095                                                               &amp;FileLockInfo-&gt;EndingByte,
05096                                                               &amp;LastSplayLinks, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
05097          SplayLinks;
05098          SplayLinks = <a class="code" href="../../d3/d4/splay_8c.html#a8">RtlRealSuccessor</a>(SplayLinks)) {
05099 
05100         <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a> = CONTAINING_RECORD( SplayLinks, <a class="code" href="../../d7/d7/struct__EX__LOCK.html">EX_LOCK</a>, Links );
05101 
05102         <span class="keywordflow">if</span> ((ULONGLONG)<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.StartingByte.QuadPart &gt; (ULONGLONG)FileLockInfo-&gt;EndingByte.QuadPart) {
05103 
05104             <span class="comment">//</span>
05105             <span class="comment">//  This node is covering a range greater than the range we care about,</span>
05106             <span class="comment">//  so we're done</span>
05107             <span class="comment">//</span>
05108 
05109             <span class="keywordflow">break</span>;
05110         }
05111 
05112         <span class="comment">//</span>
05113         <span class="comment">//  We may not be able to grant the request if the fileobject, processid,</span>
05114         <span class="comment">//  and key do not match.</span>
05115         <span class="comment">//</span>
05116 
05117         <span class="keywordflow">if</span> ((<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.FileObject != FileLockInfo-&gt;FileObject) ||
05118              (<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.ProcessId != FileLockInfo-&gt;ProcessId) ||
05119              (<a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.Key != FileLockInfo-&gt;Key)) {
05120 
05121             <span class="comment">//</span>
05122             <span class="comment">//  We have a mismatch between caller and owner. It is ok not to conflict</span>
05123             <span class="comment">//  if the caller and owner will have/have zero length locks (zero length</span>
05124             <span class="comment">//  locks cannot conflict).</span>
05125             <span class="comment">//</span>
05126 
05127             <span class="keywordflow">if</span> (FileLockInfo-&gt;Length.QuadPart || <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>-&gt;LockInfo.Length.QuadPart) {
05128 
05129                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
05130                 <span class="keywordflow">break</span>;
05131             }
05132         }
05133     }
05134 
05135     <span class="keywordflow">if</span> (LastSplayLinks) {
05136 
05137         LockQueue-&gt;ExclusiveLockTree = <a class="code" href="../../d3/d4/splay_8c.html#a3">RtlSplay</a>(LastSplayLinks);
05138     }
05139 
05140     <span class="comment">//</span>
05141     <span class="comment">//  We searched the entire range without a conflict so we can grant</span>
05142     <span class="comment">//  the shared lock</span>
05143     <span class="comment">//</span>
05144 
05145     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
05146 }
05147 
05148 
05149 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l05150"></a><a class="code" href="../../d5/d3/filelock_8c.html#a58">05150</a> <a class="code" href="../../d5/d3/filelock_8c.html#a58">FsRtlPrivateResetLowestLockOffset</a> (
05151     PLOCK_INFO LockInfo
05152     )
05153 
05154 <span class="comment">/*++</span>
05155 <span class="comment"></span>
05156 <span class="comment">Routine Description:</span>
05157 <span class="comment"></span>
05158 <span class="comment">    This routine resets the lowest lock offset hint in a LOCK_INFO to</span>
05159 <span class="comment">    the lowest lock offset currently held by a lock inside of the LOCK_INFO.</span>
05160 <span class="comment"></span>
05161 <span class="comment">Arguments:</span>
05162 <span class="comment"></span>
05163 <span class="comment">    LockInfo - the lock data to operate on</span>
05164 <span class="comment"></span>
05165 <span class="comment">Return Value:</span>
05166 <span class="comment"></span>
05167 <span class="comment">    None</span>
05168 <span class="comment"></span>
05169 <span class="comment">--*/</span>
05170 
05171 {
05172     <a class="code" href="../../d5/d3/filelock_8c.html#a24">PEX_LOCK</a> ExLock = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05173     <a class="code" href="../../d5/d3/filelock_8c.html#a22">PSH_LOCK</a> ShLock = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05174     <a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html">PFILE_LOCK_INFO</a> LowestLockInfo = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05175     PRTL_SPLAY_LINKS SplayLinks;
05176     <a class="code" href="../../d5/d3/filelock_8c.html#a20">PLOCKTREE_NODE</a> Node;
05177 
05178     <span class="comment">//</span>
05179     <span class="comment">//  Fix up the lowest lock offset if we have non-empty trees and there was</span>
05180     <span class="comment">//  a lock in the low 32 bit region</span>
05181     <span class="comment">//</span>
05182 
05183     <span class="keywordflow">if</span> (LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o0">LowestLockOffset</a> != 0xffffffff &amp;&amp;
05184         (LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>.<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o1">SharedLockTree</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ||
05185          LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>.<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o2">ExclusiveLockTree</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
05186 
05187         <span class="comment">//</span>
05188         <span class="comment">//  Grab the lowest nodes in the trees</span>
05189         <span class="comment">//</span>
05190 
05191         <span class="keywordflow">if</span> (LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>.<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o1">SharedLockTree</a>) {
05192 
05193             SplayLinks = LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>.<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o1">SharedLockTree</a>;
05194 
05195             <span class="keywordflow">while</span> (RtlLeftChild(SplayLinks) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05196 
05197                 SplayLinks = RtlLeftChild(SplayLinks);
05198             }
05199 
05200             Node = CONTAINING_RECORD( SplayLinks, <a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html">LOCKTREE_NODE</a>, Links );
05201             ShLock = CONTAINING_RECORD( Node-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o0">Locks</a>.Next, <a class="code" href="../../d8/d2/struct__SH__LOCK.html">SH_LOCK</a>, Link );
05202         }
05203 
05204         <span class="keywordflow">if</span> (LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>.<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o2">ExclusiveLockTree</a>) {
05205 
05206             SplayLinks = LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>.<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o2">ExclusiveLockTree</a>;
05207 
05208             <span class="keywordflow">while</span> (RtlLeftChild(SplayLinks) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05209 
05210                 SplayLinks = RtlLeftChild(SplayLinks);
05211             }
05212 
05213             ExLock = CONTAINING_RECORD( SplayLinks, <a class="code" href="../../d7/d7/struct__EX__LOCK.html">EX_LOCK</a>, Links );
05214         }
05215 
05216         <span class="comment">//</span>
05217         <span class="comment">//  Figure out which of the lowest locks is actually lowest. We know that one of the lock</span>
05218         <span class="comment">//  trees at least has a lock, so if we have don't have exclusive locks then we do know</span>
05219         <span class="comment">//  we have shared locks ...</span>
05220         <span class="comment">//</span>
05221 
05222         <span class="keywordflow">if</span> (ExLock &amp;&amp;
05223             (!ShLock ||
05224              (ULONGLONG)ExLock-&gt;<a class="code" href="../../d7/d7/struct__EX__LOCK.html#o1">LockInfo</a>.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o0">StartingByte</a>.QuadPart &lt; (ULONGLONG)ShLock-&gt;<a class="code" href="../../d8/d2/struct__SH__LOCK.html#o1">LockInfo</a>.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o0">StartingByte</a>.QuadPart)) {
05225 
05226             LowestLockInfo = &amp;ExLock-&gt;<a class="code" href="../../d7/d7/struct__EX__LOCK.html#o1">LockInfo</a>;
05227 
05228         } <span class="keywordflow">else</span> {
05229 
05230             LowestLockInfo = &amp;ShLock-&gt;<a class="code" href="../../d8/d2/struct__SH__LOCK.html#o1">LockInfo</a>;
05231         }
05232 
05233         <span class="keywordflow">if</span> (LowestLockInfo-&gt;<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o0">StartingByte</a>.HighPart == 0) {
05234 
05235             LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o0">LowestLockOffset</a> = LowestLockInfo-&gt;<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o0">StartingByte</a>.LowPart;
05236 
05237         } <span class="keywordflow">else</span> {
05238 
05239             LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o0">LowestLockOffset</a> = 0xffffffff;
05240         }
05241 
05242     } <span class="keywordflow">else</span> {
05243 
05244         <span class="comment">//</span>
05245         <span class="comment">//  If there are no locks, set the lock offset high</span>
05246         <span class="comment">//</span>
05247 
05248         LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o0">LowestLockOffset</a> = 0xffffffff;
05249     }
05250 }
05251 
05252 
05253 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l05254"></a><a class="code" href="../../d5/d3/filelock_8c.html#a53">05254</a> <a class="code" href="../../d5/d3/filelock_8c.html#a53">FsRtlPrivateFastUnlockAll</a> (
05255     IN <a class="code" href="../../d7/d1/struct__FILE__LOCK.html">PFILE_LOCK</a> FileLock,
05256     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
05257     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> ProcessId,
05258     IN ULONG Key,
05259     IN BOOLEAN MatchKey,
05260     IN PVOID Context OPTIONAL
05261     )
05262 
05263 <span class="comment">/*++</span>
05264 <span class="comment"></span>
05265 <span class="comment">Routine Description:</span>
05266 <span class="comment"></span>
05267 <span class="comment">    This routine performs an Unlock all operation on the current locks</span>
05268 <span class="comment">    associated with the specified file lock.  Only those locks with</span>
05269 <span class="comment">    a matching file object and process id are freed.  Additionally,</span>
05270 <span class="comment">    it is possible to free only those locks which also match a given</span>
05271 <span class="comment">    key.</span>
05272 <span class="comment"></span>
05273 <span class="comment">Arguments:</span>
05274 <span class="comment"></span>
05275 <span class="comment">    FileLock - Supplies the file lock being freed.</span>
05276 <span class="comment"></span>
05277 <span class="comment">    FileObject - Supplies the file object associated with the file lock</span>
05278 <span class="comment"></span>
05279 <span class="comment">    ProcessId - Supplies the Process Id assoicated with the locks to be</span>
05280 <span class="comment">        freed</span>
05281 <span class="comment"></span>
05282 <span class="comment">    Key - Supplies the Key to use in this operation</span>
05283 <span class="comment"></span>
05284 <span class="comment">    MatchKey - Whether or not the Key must also match for lock to be freed.</span>
05285 <span class="comment"></span>
05286 <span class="comment">    Context - Supplies an optional context to use when completing waiting</span>
05287 <span class="comment">        lock irps.</span>
05288 <span class="comment"></span>
05289 <span class="comment">Return Value:</span>
05290 <span class="comment"></span>
05291 <span class="comment">    None</span>
05292 <span class="comment"></span>
05293 <span class="comment">--*/</span>
05294 
05295 {
05296     <a class="code" href="../../d5/d3/filelock_8c.html#a30">PLOCK_INFO</a>              LockInfo;
05297     <a class="code" href="../../d5/d3/filelock_8c.html#a28">PLOCK_QUEUE</a>             LockQueue;
05298     PSINGLE_LIST_ENTRY      *pLink, *SavepLink, Link;
05299     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>                NewStatus;
05300     KIRQL                   OldIrql;
05301     LARGE_INTEGER           MaxOffset, SaveEndingByte;
05302     BOOLEAN                 UnlockRoutine;
05303     <a class="code" href="../../d5/d3/filelock_8c.html#a22">PSH_LOCK</a>                ShLock;
05304     <a class="code" href="../../d5/d3/filelock_8c.html#a24">PEX_LOCK</a>                ExLock;
05305     PRTL_SPLAY_LINKS        SplayLinks, SuccessorLinks;
05306     <a class="code" href="../../d5/d3/filelock_8c.html#a20">PLOCKTREE_NODE</a>          Node;
05307 
05308 
05309     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlPrivateFastUnlockAll, FileLock = %08lx\n"</span>, FileLock);
05310 
05311     <span class="keywordflow">if</span> ((LockInfo = FileLock-&gt;LockInformation) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05312 
05313         <span class="comment">//</span>
05314         <span class="comment">// No lock information on this FileLock</span>
05315         <span class="comment">//</span>
05316 
05317         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlPrivateFastUnlockAll, No LockInfo\n"</span>, FileLock);
05318         <span class="keywordflow">return</span> STATUS_RANGE_NOT_LOCKED;
05319     }
05320 
05321     FileObject-&gt;LastLock = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05322 
05323     LockQueue = &amp;LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>;
05324 
05325     <span class="comment">//</span>
05326     <span class="comment">//  Grab the waiting lock queue spinlock to exclude anyone from messing</span>
05327     <span class="comment">//  with the queue while we're using it</span>
05328     <span class="comment">//</span>
05329 
05330     <a class="code" href="../../d5/d3/filelock_8c.html#a9">FsRtlReacquireLockQueue</a>(LockInfo, LockQueue, &amp;OldIrql);
05331 
05332     <span class="keywordflow">if</span> (LockQueue-&gt;<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o1">SharedLockTree</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> &amp;&amp; LockQueue-&gt;<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o2">ExclusiveLockTree</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05333 
05334         <span class="comment">//</span>
05335         <span class="comment">// No locks on this FileLock</span>
05336         <span class="comment">//</span>
05337 
05338         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlPrivateFastUnlockAll, No LockTrees\n"</span>, FileLock);
05339         <a class="code" href="../../d5/d3/filelock_8c.html#a10">FsRtlReleaseLockQueue</a>(LockQueue, OldIrql);
05340 
05341         <span class="keywordflow">return</span> STATUS_RANGE_NOT_LOCKED;
05342     }
05343 
05344     <span class="comment">//</span>
05345     <span class="comment">//  Remove all matching locks in the shared lock tree</span>
05346     <span class="comment">//</span>
05347 
05348     <span class="keywordflow">if</span> (LockQueue-&gt;<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o1">SharedLockTree</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05349 
05350         <span class="comment">//</span>
05351         <span class="comment">//  Grab the lowest node in the tree</span>
05352         <span class="comment">//</span>
05353 
05354         SplayLinks = LockQueue-&gt;<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o1">SharedLockTree</a>;
05355 
05356         <span class="keywordflow">while</span> (RtlLeftChild(SplayLinks) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05357 
05358             SplayLinks = RtlLeftChild(SplayLinks);
05359         }
05360 
05361         <span class="comment">//</span>
05362         <span class="comment">//  Walk all nodes in the tree</span>
05363         <span class="comment">//</span>
05364 
05365         UnlockRoutine = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
05366 
05367         <span class="keywordflow">for</span> (;
05368              SplayLinks;
05369              SplayLinks = SuccessorLinks) {
05370 
05371             Node = CONTAINING_RECORD(SplayLinks, <a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html">LOCKTREE_NODE</a>, Links );
05372 
05373             <span class="comment">//</span>
05374             <span class="comment">//  Save the next node because we may split this node apart in the process</span>
05375             <span class="comment">//  of deleting locks. It would be a waste of time to traverse those split</span>
05376             <span class="comment">//  nodes. The only case in which we will not have traversed the entire list</span>
05377             <span class="comment">//  before doing the split will be if there is an unlock routine attached</span>
05378             <span class="comment">//  to this FileLock in which case we will be restarting the entire scan</span>
05379             <span class="comment">//  anyway.</span>
05380             <span class="comment">//</span>
05381 
05382             SuccessorLinks = <a class="code" href="../../d3/d4/splay_8c.html#a8">RtlRealSuccessor</a>(SplayLinks);
05383 
05384             <span class="comment">//</span>
05385             <span class="comment">//  Search down the current lock queue looking for a match on</span>
05386             <span class="comment">//  the file object and process id</span>
05387             <span class="comment">//</span>
05388 
05389             SavepLink = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05390             SaveEndingByte.QuadPart = 0;
05391 
05392             pLink = &amp;Node-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o0">Locks</a>.Next;
05393             <span class="keywordflow">while</span> ((Link = *pLink) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05394 
05395                 ShLock = CONTAINING_RECORD( Link, <a class="code" href="../../d8/d2/struct__SH__LOCK.html">SH_LOCK</a>, Link );
05396 
05397                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"Top of ShLock Loop, Lock = %08lx\n"</span>, ShLock );
05398 
05399                 <span class="keywordflow">if</span> ((ShLock-&gt;<a class="code" href="../../d8/d2/struct__SH__LOCK.html#o1">LockInfo</a>.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o4">FileObject</a> == FileObject) &amp;&amp;
05400                     (ShLock-&gt;<a class="code" href="../../d8/d2/struct__SH__LOCK.html#o1">LockInfo</a>.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o5">ProcessId</a> == ProcessId) &amp;&amp;
05401                     (!MatchKey || ShLock-&gt;<a class="code" href="../../d8/d2/struct__SH__LOCK.html#o1">LockInfo</a>.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o3">Key</a> == <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>)) {
05402 
05403                     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"Found one to unlock\n"</span>, 0);
05404 
05405                     <span class="comment">//</span>
05406                     <span class="comment">//  We have a match so now is the time to delete this lock.</span>
05407                     <span class="comment">//  Save the neccesary information to do the split node check.</span>
05408                     <span class="comment">//  Remove the lock from the list, then call the</span>
05409                     <span class="comment">//  optional unlock routine, then delete the lock.</span>
05410                     <span class="comment">//</span>
05411 
05412                     <span class="keywordflow">if</span> (SavepLink == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05413 
05414                         <span class="comment">//</span>
05415                         <span class="comment">//  Need to remember where the first lock was deleted</span>
05416                         <span class="comment">//</span>
05417 
05418                         SavepLink = pLink;
05419                     }
05420 
05421                     <span class="keywordflow">if</span> ((ULONGLONG)ShLock-&gt;<a class="code" href="../../d8/d2/struct__SH__LOCK.html#o1">LockInfo</a>.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o6">EndingByte</a>.QuadPart &gt; (ULONGLONG)SaveEndingByte.QuadPart) {
05422 
05423                         <span class="comment">//</span>
05424                         <span class="comment">//  Need to remember where the last offset affected by deleted locks is</span>
05425                         <span class="comment">//</span>
05426 
05427                         SaveEndingByte.QuadPart = ShLock-&gt;<a class="code" href="../../d8/d2/struct__SH__LOCK.html#o1">LockInfo</a>.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o6">EndingByte</a>.QuadPart;
05428                     }
05429 
05430                     <span class="keywordflow">if</span> (*pLink == Node-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o4">Tail</a>.Next) {
05431 
05432                         <span class="comment">//</span>
05433                         <span class="comment">//  Deleting the tail node of the list. Safe even if deleting the</span>
05434                         <span class="comment">//  first node since this implies we're also deleting the last node</span>
05435                         <span class="comment">//  in the node which means we'll delete the node ...</span>
05436                         <span class="comment">//</span>
05437 
05438                         Node-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o4">Tail</a>.Next = CONTAINING_RECORD( pLink, SINGLE_LIST_ENTRY, Next );
05439                     }
05440 
05441                     *pLink = Link-&gt;Next;
05442 
05443                     <span class="keywordflow">if</span> (LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o2">UnlockRoutine</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05444 
05445                         <span class="comment">//</span>
05446                         <span class="comment">//  Signal a lock that needs to have a special unlock routine</span>
05447                         <span class="comment">//  called on it. This is complex to deal with since we'll have</span>
05448                         <span class="comment">//  to release the queue, call it, and reacquire - meaning we</span>
05449                         <span class="comment">//  also have to restart. But we still need to reorder the node</span>
05450                         <span class="comment">//  first ...</span>
05451                         <span class="comment">//</span>
05452 
05453                         UnlockRoutine = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
05454 
05455                         <span class="keywordflow">break</span>;
05456                     }
05457 
05458                     <a class="code" href="../../d5/d3/filelock_8c.html#a36">FsRtlFreeSharedLock</a>( ShLock );
05459 
05460                 } <span class="keywordflow">else</span> {
05461 
05462                     <span class="comment">//</span>
05463                     <span class="comment">// Move to next lock</span>
05464                     <span class="comment">//</span>
05465 
05466                     pLink = &amp;Link-&gt;Next;
05467                 }
05468 
05469                 <span class="keywordflow">if</span> (SavepLink == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> &amp;&amp; (ULONGLONG)ShLock-&gt;<a class="code" href="../../d8/d2/struct__SH__LOCK.html#o1">LockInfo</a>.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o6">EndingByte</a>.QuadPart &gt; (ULONGLONG)MaxOffset.QuadPart) {
05470 
05471                     <span class="comment">//</span>
05472                     <span class="comment">//  Save the max offset until we have deleted our first node</span>
05473                     <span class="comment">//</span>
05474 
05475                     MaxOffset.QuadPart = ShLock-&gt;<a class="code" href="../../d8/d2/struct__SH__LOCK.html#o1">LockInfo</a>.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o6">EndingByte</a>.QuadPart;
05476                 }
05477             }
05478 
05479             <span class="keywordflow">if</span> (SavepLink) {
05480 
05481                 <span class="comment">//</span>
05482                 <span class="comment">//  Locks were actually deleted here, so we have to check the state of the node</span>
05483                 <span class="comment">//</span>
05484 
05485                 <span class="keywordflow">if</span> (Node-&gt;<a class="code" href="../../d2/d3/struct__LOCKTREE__NODE.html#o0">Locks</a>.Next == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05486 
05487                     <span class="comment">//</span>
05488                     <span class="comment">//  We have just deleted everything at this node</span>
05489                     <span class="comment">//</span>
05490 
05491                     LockQueue-&gt;<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o1">SharedLockTree</a> = <a class="code" href="../../d3/d4/splay_8c.html#a4">RtlDelete</a>(SplayLinks);
05492 
05493                     <a class="code" href="../../d5/d3/filelock_8c.html#a39">FsRtlFreeLockTreeNode</a>(Node);
05494 
05495                 } <span class="keywordflow">else</span> {
05496 
05497                     <span class="comment">//</span>
05498                     <span class="comment">//  Now that we have deleted all matching locks in this node, we do the</span>
05499                     <span class="comment">//  check on the node to split out any now non-overlapping locks. Conceptually,</span>
05500                     <span class="comment">//  we have deleted just one big lock that starts at the starting byte of the</span>
05501                     <span class="comment">//  first deleted lock and extends to the last byte of the last deleted lock.</span>
05502                     <span class="comment">//</span>
05503 
05504                     <a class="code" href="../../d5/d3/filelock_8c.html#a72">FsRtlSplitLocks</a>(Node, SavepLink, &amp;SaveEndingByte, &amp;MaxOffset);
05505                 }
05506             }
05507 
05508             <span class="keywordflow">if</span> (UnlockRoutine) {
05509 
05510                 <span class="comment">//</span>
05511                 <span class="comment">//  We dropped out of the node scan because we had a lock that needs extra</span>
05512                 <span class="comment">//  processing during unlock. Do it.</span>
05513                 <span class="comment">//</span>
05514 
05515                 <a class="code" href="../../d5/d3/filelock_8c.html#a10">FsRtlReleaseLockQueue</a>(LockQueue, OldIrql);
05516 
05517                 LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o2">UnlockRoutine</a>(Context, &amp;ShLock-&gt;<a class="code" href="../../d8/d2/struct__SH__LOCK.html#o1">LockInfo</a>);
05518 
05519                 <a class="code" href="../../d5/d3/filelock_8c.html#a9">FsRtlReacquireLockQueue</a>(LockInfo, LockQueue, &amp;OldIrql);
05520 
05521                 <a class="code" href="../../d5/d3/filelock_8c.html#a36">FsRtlFreeSharedLock</a>(ShLock);
05522 
05523                 UnlockRoutine = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
05524 
05525                 <span class="comment">//</span>
05526                 <span class="comment">//  We have to restart the scan, because the list may have changed while</span>
05527                 <span class="comment">//  we were in the unlock routine. Careful, because the tree may be empty.</span>
05528                 <span class="comment">//</span>
05529 
05530                 <span class="keywordflow">if</span> (SuccessorLinks = LockQueue-&gt;<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o1">SharedLockTree</a>) {
05531 
05532                     <span class="keywordflow">while</span> (RtlLeftChild(SuccessorLinks) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05533 
05534                         SuccessorLinks = RtlLeftChild(SuccessorLinks);
05535                     }
05536                 }
05537             }
05538         }
05539     }
05540 
05541     <span class="comment">//</span>
05542     <span class="comment">//  Remove all matching locks in the exclusive lock tree</span>
05543     <span class="comment">//</span>
05544 
05545     <span class="keywordflow">if</span> (LockQueue-&gt;<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o2">ExclusiveLockTree</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05546 
05547         SplayLinks = LockQueue-&gt;<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o2">ExclusiveLockTree</a>;
05548 
05549         <span class="keywordflow">while</span> (RtlLeftChild(SplayLinks) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05550 
05551             SplayLinks = RtlLeftChild(SplayLinks);
05552         }
05553 
05554         <span class="comment">//</span>
05555         <span class="comment">//  Walk all nodes in the tree</span>
05556         <span class="comment">//</span>
05557 
05558         UnlockRoutine = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
05559 
05560         <span class="keywordflow">for</span> (; SplayLinks;
05561                SplayLinks = SuccessorLinks ) {
05562 
05563             SuccessorLinks = <a class="code" href="../../d3/d4/splay_8c.html#a8">RtlRealSuccessor</a>(SplayLinks);
05564 
05565             ExLock = CONTAINING_RECORD( SplayLinks, <a class="code" href="../../d7/d7/struct__EX__LOCK.html">EX_LOCK</a>, Links );
05566 
05567             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"Top of ExLock Loop, Lock = %08lx\n"</span>, ExLock );
05568 
05569             <span class="keywordflow">if</span> ((ExLock-&gt;<a class="code" href="../../d7/d7/struct__EX__LOCK.html#o1">LockInfo</a>.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o4">FileObject</a> == FileObject) &amp;&amp;
05570                 (ExLock-&gt;<a class="code" href="../../d7/d7/struct__EX__LOCK.html#o1">LockInfo</a>.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o5">ProcessId</a> == ProcessId) &amp;&amp;
05571                 (!MatchKey || ExLock-&gt;<a class="code" href="../../d7/d7/struct__EX__LOCK.html#o1">LockInfo</a>.<a class="code" href="../../d8/d1/struct__FILE__LOCK__INFO.html#o3">Key</a> == <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>)) {
05572 
05573                 LockQueue-&gt;<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o2">ExclusiveLockTree</a> = <a class="code" href="../../d3/d4/splay_8c.html#a4">RtlDelete</a>(&amp;ExLock-&gt;<a class="code" href="../../d7/d7/struct__EX__LOCK.html#o0">Links</a>);
05574 
05575                 <span class="keywordflow">if</span> (LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o2">UnlockRoutine</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05576 
05577                     <span class="comment">//</span>
05578                     <span class="comment">//  We're dropping out of the node scan because we have a lock</span>
05579                     <span class="comment">//  that needs extra processing during unlock. Do it.</span>
05580                     <span class="comment">//</span>
05581 
05582                     <a class="code" href="../../d5/d3/filelock_8c.html#a10">FsRtlReleaseLockQueue</a>(LockQueue, OldIrql);
05583 
05584                     LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o2">UnlockRoutine</a>(Context, &amp;ExLock-&gt;<a class="code" href="../../d7/d7/struct__EX__LOCK.html#o1">LockInfo</a>);
05585 
05586                     <a class="code" href="../../d5/d3/filelock_8c.html#a9">FsRtlReacquireLockQueue</a>(LockInfo, LockQueue, &amp;OldIrql);
05587 
05588                     <span class="comment">//</span>
05589                     <span class="comment">//  We have to restart the scan, because the list may have changed while</span>
05590                     <span class="comment">//  we were in the unlock routine. Careful, because the tree may be empty.</span>
05591                     <span class="comment">//</span>
05592 
05593                     <span class="keywordflow">if</span> (SuccessorLinks = LockQueue-&gt;<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o2">ExclusiveLockTree</a>) {
05594 
05595                         <span class="keywordflow">while</span> (RtlLeftChild(SuccessorLinks) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05596 
05597                             SuccessorLinks = RtlLeftChild(SuccessorLinks);
05598                         }
05599                     }
05600                 }
05601 
05602                 <a class="code" href="../../d5/d3/filelock_8c.html#a37">FsRtlFreeExclusiveLock</a>(ExLock);
05603             }
05604         }
05605     }
05606 
05607     <span class="comment">//</span>
05608     <span class="comment">//  Search down the waiting lock queue looking for a match on the</span>
05609     <span class="comment">//  file object and process id.</span>
05610     <span class="comment">//</span>
05611 
05612     pLink = &amp;LockQueue-&gt;<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o3">WaitingLocks</a>.Next;
05613     <span class="keywordflow">while</span> ((Link = *pLink) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05614 
05615         <a class="code" href="../../d5/d3/filelock_8c.html#a26">PWAITING_LOCK</a> WaitingLock;
05616         <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> WaitingIrp;
05617         <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> WaitingIrpSp;
05618 
05619         WaitingLock = CONTAINING_RECORD( Link, <a class="code" href="../../d1/d8/struct__WAITING__LOCK.html">WAITING_LOCK</a>, Link );
05620 
05621         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"Top of Waiting Loop, WaitingLock = %08lx\n"</span>, WaitingLock);
05622 
05623         <span class="comment">//</span>
05624         <span class="comment">//  Get a copy of the necessary fields we'll need to use</span>
05625         <span class="comment">//</span>
05626 
05627         WaitingIrp = WaitingLock-&gt;<a class="code" href="../../d1/d8/struct__WAITING__LOCK.html#o2">Irp</a>;
05628         WaitingIrpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( WaitingIrp );
05629 
05630         <span class="keywordflow">if</span> ((FileObject == WaitingIrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a>) &amp;&amp;
05631             (ProcessId == <a class="code" href="../../d4/d6/iosubs_8c.html#a78">IoGetRequestorProcess</a>( WaitingIrp )) &amp;&amp;
05632             (!MatchKey || <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a> == WaitingIrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.LockControl.Key)) {
05633 
05634             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"Found a waiting lock to abort\n"</span>, 0);
05635 
05636             <span class="comment">//</span>
05637             <span class="comment">//  We now void the cancel routine in the irp</span>
05638             <span class="comment">//</span>
05639 
05640             <a class="code" href="../../d0/d5/io_8h.html#a236">IoSetCancelRoutine</a>( WaitingIrp, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
05641             WaitingIrp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information = 0;
05642 
05643             <span class="comment">//</span>
05644             <span class="comment">//  We have a match so now is the time to delete this waiter</span>
05645             <span class="comment">//  But we must not mess up our link iteration variable.  We</span>
05646             <span class="comment">//  do this by simply starting the iteration over again,</span>
05647             <span class="comment">//  after we delete ourselves.  We also will deallocate the</span>
05648             <span class="comment">//  lock after we delete it.</span>
05649             <span class="comment">//</span>
05650 
05651             *pLink = Link-&gt;Next;
05652             <span class="keywordflow">if</span> (Link == LockQueue-&gt;<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o4">WaitingLocksTail</a>.Next) {
05653                 LockQueue-&gt;<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o4">WaitingLocksTail</a>.Next = (PSINGLE_LIST_ENTRY) pLink;
05654             }
05655 
05656             <a class="code" href="../../d5/d3/filelock_8c.html#a10">FsRtlReleaseLockQueue</a>(LockQueue, OldIrql);
05657 
05658             <span class="comment">//</span>
05659             <span class="comment">//  And complete this lock request Irp</span>
05660             <span class="comment">//</span>
05661 
05662             <a class="code" href="../../d5/d3/filelock_8c.html#a11">FsRtlCompleteLockIrp</a>( LockInfo,
05663                                     WaitingLock-&gt;<a class="code" href="../../d1/d8/struct__WAITING__LOCK.html#o1">Context</a>,
05664                                     WaitingIrp,
05665                                     STATUS_SUCCESS,
05666                                     &amp;NewStatus,
05667                                     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
05668 
05669             <span class="comment">//</span>
05670             <span class="comment">// Reaqcuire lock queue spinlock and start over</span>
05671             <span class="comment">//</span>
05672 
05673             <a class="code" href="../../d5/d3/filelock_8c.html#a9">FsRtlReacquireLockQueue</a>(LockInfo, LockQueue, &amp;OldIrql);
05674 
05675             <span class="comment">//</span>
05676             <span class="comment">// Start over</span>
05677             <span class="comment">//</span>
05678 
05679             pLink = &amp;LockQueue-&gt;<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o3">WaitingLocks</a>.Next;
05680 
05681             <span class="comment">//</span>
05682             <span class="comment">// Put memory onto free list</span>
05683             <span class="comment">//</span>
05684 
05685             <a class="code" href="../../d5/d3/filelock_8c.html#a38">FsRtlFreeWaitingLock</a>( WaitingLock );
05686             <span class="keywordflow">continue</span>;
05687         }
05688 
05689         <span class="comment">//</span>
05690         <span class="comment">// Move to next lock</span>
05691         <span class="comment">//</span>
05692 
05693         pLink = &amp;Link-&gt;Next;
05694     }
05695 
05696     <span class="comment">//</span>
05697     <span class="comment">//  At this point we've gone through unlocking everything. So</span>
05698     <span class="comment">//  now try and release any waiting locks.</span>
05699     <span class="comment">//</span>
05700 
05701     <a class="code" href="../../d5/d3/filelock_8c.html#a49">FsRtlPrivateCheckWaitingLocks</a>( LockInfo, LockQueue, OldIrql );
05702 
05703     <span class="comment">//</span>
05704     <span class="comment">//  We deleted a (possible) bunch of locks, go repair the lowest lock offset</span>
05705     <span class="comment">//</span>
05706 
05707     <a class="code" href="../../d5/d3/filelock_8c.html#a58">FsRtlPrivateResetLowestLockOffset</a>( LockInfo );
05708 
05709     <a class="code" href="../../d5/d3/filelock_8c.html#a10">FsRtlReleaseLockQueue</a>( LockQueue, OldIrql );
05710 
05711     <span class="comment">//</span>
05712     <span class="comment">//  and return to our caller</span>
05713     <span class="comment">//</span>
05714 
05715     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlFastUnlockAll -&gt; VOID\n"</span>, 0);
05716     <span class="keywordflow">return</span> STATUS_SUCCESS;
05717 }
05718 
05719 
05720 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l05721"></a><a class="code" href="../../d5/d3/filelock_8c.html#a50">05721</a> <a class="code" href="../../d5/d3/filelock_8c.html#a50">FsRtlPrivateCancelFileLockIrp</a> (
05722     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
05723     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
05724     )
05725 
05726 <span class="comment">/*++</span>
05727 <span class="comment"></span>
05728 <span class="comment">Routine Description:</span>
05729 <span class="comment"></span>
05730 <span class="comment">    This routine implements the cancel function for an irp saved in a</span>
05731 <span class="comment">    waiting lock queue</span>
05732 <span class="comment"></span>
05733 <span class="comment">Arguments:</span>
05734 <span class="comment"></span>
05735 <span class="comment">    DeviceObject - Ignored</span>
05736 <span class="comment"></span>
05737 <span class="comment">    Irp - Supplies the Irp being cancelled.  A pointer to the FileLock</span>
05738 <span class="comment">        structure for the lock is stored in the information field of the</span>
05739 <span class="comment">        irp's iosb.</span>
05740 <span class="comment"></span>
05741 <span class="comment">Return Value:</span>
05742 <span class="comment"></span>
05743 <span class="comment">    none.</span>
05744 <span class="comment"></span>
05745 <span class="comment">--*/</span>
05746 
05747 {
05748     PSINGLE_LIST_ENTRY *pLink, Link;
05749     <a class="code" href="../../d5/d3/filelock_8c.html#a30">PLOCK_INFO</a>  LockInfo;
05750     <a class="code" href="../../d5/d3/filelock_8c.html#a28">PLOCK_QUEUE</a> LockQueue;
05751     KIRQL       OldIrql;
05752     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>    NewStatus;
05753 
05754 
05755     UNREFERENCED_PARAMETER( DeviceObject );
05756 
05757     <span class="comment">//</span>
05758     <span class="comment">//  The information field is used to store a pointer to the file lock</span>
05759     <span class="comment">//  containing the irp</span>
05760     <span class="comment">//</span>
05761 
05762     LockInfo = (<a class="code" href="../../d5/d3/filelock_8c.html#a30">PLOCK_INFO</a>) (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information);
05763 
05764     <span class="comment">//</span>
05765     <span class="comment">// Iterate through the lock queue.</span>
05766     <span class="comment">//</span>
05767 
05768     LockQueue = &amp;LockInfo-&gt;<a class="code" href="../../d6/d2/struct__LOCK__INFO.html#o3">LockQueue</a>;
05769 
05770     <span class="comment">//</span>
05771     <span class="comment">// Release the cancel spinlock and lock the waiting queue if this</span>
05772     <span class="comment">// is initiated by Io. We already have the lock queue if this is</span>
05773     <span class="comment">// the race fixup.</span>
05774     <span class="comment">//</span>
05775     <span class="comment">// If this is from ourselves, we have the cancel Irql in the Irp.</span>
05776     <span class="comment">//</span>
05777 
05778     <span class="keywordflow">if</span> (DeviceObject) {
05779         
05780         <a class="code" href="../../d4/d6/iosubs_8c.html#a101">IoReleaseCancelSpinLock</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o15">CancelIrql</a> );
05781         <a class="code" href="../../d5/d3/filelock_8c.html#a9">FsRtlReacquireLockQueue</a>(LockInfo, LockQueue, &amp;OldIrql);
05782     
05783     } <span class="keywordflow">else</span> {
05784 
05785         OldIrql = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o15">CancelIrql</a>;
05786     }
05787 
05788     <span class="comment">//</span>
05789     <span class="comment">// Iterate through all of the waiting locks looking for a canceled one.</span>
05790     
05791     pLink = &amp;LockQueue-&gt;<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o3">WaitingLocks</a>.Next;
05792     <span class="keywordflow">while</span> ((Link = *pLink) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05793 
05794         <a class="code" href="../../d5/d3/filelock_8c.html#a26">PWAITING_LOCK</a> WaitingLock;
05795 
05796         <span class="comment">//</span>
05797         <span class="comment">//  Get a pointer to the waiting lock record</span>
05798         <span class="comment">//</span>
05799 
05800         WaitingLock = CONTAINING_RECORD( Link, <a class="code" href="../../d1/d8/struct__WAITING__LOCK.html">WAITING_LOCK</a>, Link );
05801 
05802         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"FsRtlPrivateCancelFileLockIrp, Loop top, WaitingLock = %08lx\n"</span>, WaitingLock);
05803 
05804         <span class="keywordflow">if</span>( WaitingLock-&gt;<a class="code" href="../../d1/d8/struct__WAITING__LOCK.html#o2">Irp</a> != <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> ) {
05805 
05806             pLink = &amp;Link-&gt;Next;
05807             <span class="keywordflow">continue</span>;
05808         }
05809 
05810         <span class="comment">//</span>
05811         <span class="comment">//  We've found it -- remove it from the list</span>
05812         <span class="comment">//</span>
05813 
05814         *pLink = Link-&gt;Next;
05815         <span class="keywordflow">if</span> (Link == LockQueue-&gt;<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o4">WaitingLocksTail</a>.Next) {
05816 
05817             LockQueue-&gt;<a class="code" href="../../d8/d2/struct__LOCK__QUEUE.html#o4">WaitingLocksTail</a>.Next = (PSINGLE_LIST_ENTRY) pLink;
05818         }
05819 
05820         <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information = 0;
05821 
05822         <span class="comment">//</span>
05823         <span class="comment">// Release LockQueue and complete this waiter</span>
05824         <span class="comment">//</span>
05825 
05826         <a class="code" href="../../d5/d3/filelock_8c.html#a10">FsRtlReleaseLockQueue</a>(LockQueue, OldIrql);
05827 
05828         <span class="comment">//</span>
05829         <span class="comment">// Complete this waiter</span>
05830         <span class="comment">//</span>
05831 
05832         <a class="code" href="../../d5/d3/filelock_8c.html#a11">FsRtlCompleteLockIrp</a>( LockInfo,
05833                               WaitingLock-&gt;<a class="code" href="../../d1/d8/struct__WAITING__LOCK.html#o1">Context</a>,
05834                               <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>,
05835                               STATUS_CANCELLED,
05836                               &amp;NewStatus,
05837                               <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
05838 
05839         <span class="comment">//</span>
05840         <span class="comment">//  Free up pool</span>
05841         <span class="comment">//</span>
05842 
05843         <a class="code" href="../../d5/d3/filelock_8c.html#a38">FsRtlFreeWaitingLock</a>( WaitingLock );
05844 
05845         <span class="comment">//</span>
05846         <span class="comment">// Our job is done!</span>
05847         <span class="comment">//</span>
05848 
05849         <span class="keywordflow">return</span>;
05850     }
05851 
05852     <span class="comment">//</span>
05853     <span class="comment">// Release lock queue</span>
05854     <span class="comment">//</span>
05855 
05856     <a class="code" href="../../d5/d3/filelock_8c.html#a10">FsRtlReleaseLockQueue</a>(LockQueue, OldIrql);
05857 
05858     <span class="keywordflow">return</span>;
05859 }
05860 
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:00 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
