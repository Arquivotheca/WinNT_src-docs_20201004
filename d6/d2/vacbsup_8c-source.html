<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: vacbsup.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>vacbsup.c</h1><a href="../../d5/d3/vacbsup_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1990  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    vacbsup.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module implements the support routines for the Virtual Address</span>
00012 <span class="comment">    Control Block support for the Cache Manager.  These routines are used</span>
00013 <span class="comment">    to manage a large number of relatively small address windows to map</span>
00014 <span class="comment">    file data for all forms of cache access.</span>
00015 <span class="comment"></span>
00016 <span class="comment">Author:</span>
00017 <span class="comment"></span>
00018 <span class="comment">    Tom Miller      [TomM]      8-Feb-1992</span>
00019 <span class="comment"></span>
00020 <span class="comment">Revision History:</span>
00021 <span class="comment"></span>
00022 <span class="comment">--*/</span>
00023 
00024 <span class="preprocessor">#include "<a class="code" href="../../d5/d5/cc_8h.html">cc.h</a>"</span>
00025 
00026 <span class="comment">//</span>
00027 <span class="comment">//  Define our debug constant</span>
00028 <span class="comment">//</span>
00029 
<a name="l00030"></a><a class="code" href="../../d5/d3/vacbsup_8c.html#a0">00030</a> <span class="preprocessor">#define me 0x000000040</span>
00031 <span class="preprocessor"></span>
00032 <span class="comment">//</span>
00033 <span class="comment">//  Internal Support Routines.</span>
00034 <span class="comment">//</span>
00035 
00036 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00037 <a class="code" href="../../d5/d3/vacbsup_8c.html#a6">CcUnmapVacb</a> (
00038     IN <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> Vacb,
00039     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap,
00040     IN BOOLEAN UnmapBehind
00041     );
00042 
00043 <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a>
00044 <a class="code" href="../../d5/d3/vacbsup_8c.html#a7">CcGetVacbMiss</a> (
00045     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap,
00046     IN LARGE_INTEGER FileOffset,
00047     IN OUT PKIRQL OldIrql
00048     );
00049 
00050 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00051 <a class="code" href="../../d5/d3/vacbsup_8c.html#a8">CcCalculateVacbLevelLockCount</a> (
00052     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap,
00053     IN <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *VacbArray,
00054     IN ULONG Level
00055     );
00056 
00057 <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a>
00058 <a class="code" href="../../d5/d3/vacbsup_8c.html#a9">CcGetVacbLargeOffset</a> (
00059     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap,
00060     IN LONGLONG FileOffset
00061     );
00062 
00063 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00064 <a class="code" href="../../d5/d3/vacbsup_8c.html#a10">CcSetVacbLargeOffset</a> (
00065     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap,
00066     IN LONGLONG FileOffset,
00067     IN <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> Vacb
00068     );
00069 
00070 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00071 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(INIT, CcInitializeVacbs)</span>
00072 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00073 <span class="preprocessor"></span>
00074 <span class="comment">//</span>
00075 <span class="comment">//  Define a few macros for manipulating the Vacb array.</span>
00076 <span class="comment">//</span>
00077 
<a name="l00078"></a><a class="code" href="../../d5/d3/vacbsup_8c.html#a1">00078</a> <span class="preprocessor">#define GetVacb(SCM,OFF) (                                                                \</span>
00079 <span class="preprocessor">    ((SCM)-&gt;SectionSize.QuadPart &gt; VACB_SIZE_OF_FIRST_LEVEL) ?                            \</span>
00080 <span class="preprocessor">    CcGetVacbLargeOffset((SCM),(OFF).QuadPart) :                                          \</span>
00081 <span class="preprocessor">    (SCM)-&gt;Vacbs[(OFF).LowPart &gt;&gt; VACB_OFFSET_SHIFT]                                      \</span>
00082 <span class="preprocessor">)</span>
00083 <span class="preprocessor"></span>
00084 _inline
00085 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00086"></a><a class="code" href="../../d5/d3/vacbsup_8c.html#a11">00086</a> <a class="code" href="../../d5/d3/vacbsup_8c.html#a11">SetVacb</a> (
00087     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap,
00088     IN LARGE_INTEGER Offset,
00089     IN <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> Vacb
00090     )
00091 {
00092     <span class="keywordflow">if</span> (SharedCacheMap-&gt;SectionSize.QuadPart &gt; <a class="code" href="../../d5/d5/cc_8h.html#a41">VACB_SIZE_OF_FIRST_LEVEL</a>) {
00093         <a class="code" href="../../d5/d3/vacbsup_8c.html#a10">CcSetVacbLargeOffset</a>(SharedCacheMap, <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.QuadPart, Vacb);
00094 <span class="preprocessor">#ifdef VACB_DBG</span>
00095 <span class="preprocessor"></span>        <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Vacb &gt;= <a class="code" href="../../d5/d5/cc_8h.html#a67">VACB_SPECIAL_FIRST_VALID</a> || <a class="code" href="../../d5/d3/vacbsup_8c.html#a9">CcGetVacbLargeOffset</a>(SharedCacheMap, <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.QuadPart) == Vacb);
00096 <span class="preprocessor">#endif // VACB_DBG</span>
00097 <span class="preprocessor"></span>    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Vacb &lt; <a class="code" href="../../d5/d5/cc_8h.html#a67">VACB_SPECIAL_FIRST_VALID</a>) {
00098         SharedCacheMap-&gt;Vacbs[<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.LowPart &gt;&gt; <a class="code" href="../../d4/d2/cache_8h.html#a1">VACB_OFFSET_SHIFT</a>] = Vacb;
00099     }
00100 <span class="preprocessor">#ifdef VACB_DBG</span>
00101 <span class="preprocessor"></span>    <span class="comment">//</span>
00102     <span class="comment">//  Note, we need a new field if we turn this check on again - ReservedForAlignment</span>
00103     <span class="comment">//  has been stolen for other purposes.</span>
00104     <span class="comment">//</span>
00105 
00106     <span class="keywordflow">if</span> (Vacb &lt; <a class="code" href="../../d5/d5/cc_8h.html#a67">VACB_SPECIAL_FIRST_VALID</a>) {
00107         <span class="keywordflow">if</span> (Vacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00108             SharedCacheMap-&gt;ReservedForAlignment++;
00109         } <span class="keywordflow">else</span> {
00110             SharedCacheMap-&gt;ReservedForAlignment--;
00111         }
00112     }
00113     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((SharedCacheMap-&gt;SectionSize.QuadPart &lt;= <a class="code" href="../../d5/d5/cc_8h.html#a41">VACB_SIZE_OF_FIRST_LEVEL</a>) ||
00114            (SharedCacheMap-&gt;ReservedForAlignment == 0) ||
00115            <a class="code" href="../../d5/d5/cc_8h.html#a209">IsVacbLevelReferenced</a>( SharedCacheMap, SharedCacheMap-&gt;Vacbs, 1 ));
00116 <span class="preprocessor">#endif // VACB_DBG</span>
00117 <span class="preprocessor"></span>}
00118 
00119 <span class="comment">//</span>
00120 <span class="comment">//  Define the macro for referencing the multilevel Vacb array.</span>
00121 <span class="comment">//</span>
00122 
00123 _inline
00124 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00125"></a><a class="code" href="../../d5/d3/vacbsup_8c.html#a12">00125</a> <a class="code" href="../../d5/d3/vacbsup_8c.html#a12">ReferenceVacbLevel</a> (
00126     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap,
00127     IN <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *VacbArray,
00128     IN ULONG Level,
00129     IN LONG Amount,
00130     IN BOOLEAN Special
00131     )
00132 {
00133     <a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html">PVACB_LEVEL_REFERENCE</a> VacbReference = <a class="code" href="../../d5/d5/cc_8h.html#a208">VacbLevelReference</a>( SharedCacheMap, VacbArray, Level );
00134 
00135     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( Amount &gt; 0 ||
00136             (!Special &amp;&amp; VacbReference-&gt;<a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html#o0">Reference</a> &gt;= (0 - Amount)) ||
00137             ( Special &amp;&amp; VacbReference-&gt;<a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html#o1">SpecialReference</a> &gt;= (0 - Amount)));
00138 
00139     <span class="keywordflow">if</span> (Special) {
00140         VacbReference-&gt;<a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html#o1">SpecialReference</a> += Amount;
00141     } <span class="keywordflow">else</span> {
00142         VacbReference-&gt;<a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html#o0">Reference</a> += Amount;
00143     }
00144 
00145 <span class="preprocessor">#ifdef VACB_DBG</span>
00146 <span class="preprocessor"></span>    <span class="comment">//</span>
00147     <span class="comment">//  For debugging purposes, we can assert that the regular reference count</span>
00148     <span class="comment">//  corresponds to the population of the level.</span>
00149     <span class="comment">//</span>
00150 
00151     {
00152         LONG Current = VacbReference-&gt;<a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html#o0">Reference</a>;
00153         <a class="code" href="../../d5/d3/vacbsup_8c.html#a8">CcCalculateVacbLevelLockCount</a>( SharedCacheMap, VacbArray, Level );
00154         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( Current == VacbReference-&gt;<a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html#o0">Reference</a> );
00155     }
00156 <span class="preprocessor">#endif // VACB_DBG</span>
00157 <span class="preprocessor"></span>}
00158 
00159 <span class="comment">//</span>
00160 <span class="comment">//  Define the macros for moving the VACBs on the LRU list</span>
00161 <span class="comment">//</span>
00162 
<a name="l00163"></a><a class="code" href="../../d5/d3/vacbsup_8c.html#a2">00163</a> <span class="preprocessor">#define CcMoveVacbToReuseHead(V)        RemoveEntryList( &amp;(V)-&gt;LruList );                 \</span>
00164 <span class="preprocessor">                                        InsertHeadList( &amp;CcVacbLru, &amp;(V)-&gt;LruList );</span>
00165 <span class="preprocessor"></span>
<a name="l00166"></a><a class="code" href="../../d5/d3/vacbsup_8c.html#a3">00166</a> <span class="preprocessor">#define CcMoveVacbToReuseTail(V)        RemoveEntryList( &amp;(V)-&gt;LruList );                 \</span>
00167 <span class="preprocessor">                                        InsertTailList( &amp;CcVacbLru, &amp;(V)-&gt;LruList );</span>
00168 <span class="preprocessor"></span>
00169 <span class="comment">//</span>
00170 <span class="comment">//  If the HighPart is nonzero, then we will go to a multi-level structure anyway, which is</span>
00171 <span class="comment">//  most easily triggered by returning MAXULONG.</span>
00172 <span class="comment">//</span>
00173 
<a name="l00174"></a><a class="code" href="../../d5/d3/vacbsup_8c.html#a4">00174</a> <span class="preprocessor">#define SizeOfVacbArray(LSZ) (                                                            \</span>
00175 <span class="preprocessor">    ((LSZ).HighPart != 0) ? MAXULONG :                                                    \</span>
00176 <span class="preprocessor">    ((LSZ).LowPart &gt; (PREALLOCATED_VACBS * VACB_MAPPING_GRANULARITY) ?                    \</span>
00177 <span class="preprocessor">     (((LSZ).LowPart &gt;&gt; VACB_OFFSET_SHIFT) * sizeof(PVACB)) :                             \</span>
00178 <span class="preprocessor">     (PREALLOCATED_VACBS * sizeof(PVACB)))                                                \</span>
00179 <span class="preprocessor">)</span>
00180 <span class="preprocessor"></span>
<a name="l00181"></a><a class="code" href="../../d5/d3/vacbsup_8c.html#a5">00181</a> <span class="preprocessor">#define CheckedDec(N) {  \</span>
00182 <span class="preprocessor">    ASSERT((N) != 0);    \</span>
00183 <span class="preprocessor">    (N) -= 1;            \</span>
00184 <span class="preprocessor">}</span>
00185 <span class="preprocessor"></span>
00186 
00187 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00188"></a><a class="code" href="../../d5/d3/vacbsup_8c.html#a13">00188</a> <a class="code" href="../../d5/d5/cc_8h.html#a192">CcInitializeVacbs</a>(
00189 )
00190 
00191 <span class="comment">/*++</span>
00192 <span class="comment"></span>
00193 <span class="comment">Routine Description:</span>
00194 <span class="comment"></span>
00195 <span class="comment">    This routine must be called during Cache Manager initialization to</span>
00196 <span class="comment">    initialize the Virtual Address Control Block structures.</span>
00197 <span class="comment"></span>
00198 <span class="comment">Arguments:</span>
00199 <span class="comment"></span>
00200 <span class="comment">    None.</span>
00201 <span class="comment"></span>
00202 <span class="comment">Return Value:</span>
00203 <span class="comment"></span>
00204 <span class="comment">    None.</span>
00205 <span class="comment"></span>
00206 <span class="comment">--*/</span>
00207 
00208 {
00209     ULONG VacbBytes;
00210     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> NextVacb;
00211 
00212     <a class="code" href="../../d5/d2/cachedat_8c.html#a19">CcNumberVacbs</a> = (<a class="code" href="../../d2/d1/mm_8h.html#a137">MmSizeOfSystemCacheInPages</a> &gt;&gt; (<a class="code" href="../../d4/d2/cache_8h.html#a1">VACB_OFFSET_SHIFT</a> - <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>)) - 2;
00213     VacbBytes = <a class="code" href="../../d5/d2/cachedat_8c.html#a19">CcNumberVacbs</a> * <span class="keyword">sizeof</span>(<a class="code" href="../../d2/d5/struct__VACB.html">VACB</a>);
00214 
00215     <a class="code" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock</a>( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a18">CcVacbSpinLock</a> );
00216     <a class="code" href="../../d5/d2/cachedat_8c.html#a20">CcVacbs</a> = (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a>)<a class="code" href="../../d1/d8/fsrtl_8h.html#a37">FsRtlAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, VacbBytes, 'aVcC' );
00217     <a class="code" href="../../d5/d2/cachedat_8c.html#a21">CcBeyondVacbs</a> = (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a>)((PCHAR)<a class="code" href="../../d5/d2/cachedat_8c.html#a20">CcVacbs</a> + VacbBytes);
00218     RtlZeroMemory( <a class="code" href="../../d5/d2/cachedat_8c.html#a20">CcVacbs</a>, VacbBytes );
00219 
00220     InitializeListHead( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a22">CcVacbLru</a> );
00221 
00222     <span class="keywordflow">for</span> (NextVacb = <a class="code" href="../../d5/d2/cachedat_8c.html#a20">CcVacbs</a>; NextVacb &lt; <a class="code" href="../../d5/d2/cachedat_8c.html#a21">CcBeyondVacbs</a>; NextVacb++) {
00223 
00224         InsertTailList( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a22">CcVacbLru</a>, &amp;NextVacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o5">LruList</a> );
00225     }
00226 }
00227 
00228 
00229 PVOID
<a name="l00230"></a><a class="code" href="../../d5/d3/vacbsup_8c.html#a14">00230</a> <a class="code" href="../../d5/d3/vacbsup_8c.html#a14">CcGetVirtualAddressIfMapped</a> (
00231     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap,
00232     IN LONGLONG FileOffset,
00233     OUT <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *Vacb,
00234     OUT PULONG ReceivedLength
00235     )
00236 
00237 <span class="comment">/*++</span>
00238 <span class="comment"></span>
00239 <span class="comment">Routine Description:</span>
00240 <span class="comment"></span>
00241 <span class="comment">    This routine returns a virtual address for the specified FileOffset,</span>
00242 <span class="comment">    iff it is mapped.  Otherwise, it informs the caller that the specified</span>
00243 <span class="comment">    virtual address was not mapped.  In the latter case, it still returns</span>
00244 <span class="comment">    a ReceivedLength, which may be used to advance to the next view boundary.</span>
00245 <span class="comment"></span>
00246 <span class="comment">Arguments:</span>
00247 <span class="comment"></span>
00248 <span class="comment">    SharedCacheMap - Supplies a pointer to the Shared Cache Map for the file.</span>
00249 <span class="comment"></span>
00250 <span class="comment">    FileOffset - Supplies the desired FileOffset within the file.</span>
00251 <span class="comment"></span>
00252 <span class="comment">    Vach - Returns a Vacb pointer which must be supplied later to free</span>
00253 <span class="comment">           this virtual address, or NULL if not mapped.</span>
00254 <span class="comment"></span>
00255 <span class="comment">    ReceivedLength - Returns the number of bytes to the next view boundary,</span>
00256 <span class="comment">                     whether the desired file offset is mapped or not.</span>
00257 <span class="comment"></span>
00258 <span class="comment">Return Value:</span>
00259 <span class="comment"></span>
00260 <span class="comment">    The virtual address at which the desired data is mapped, or NULL if it</span>
00261 <span class="comment">    is not mapped.</span>
00262 <span class="comment"></span>
00263 <span class="comment">--*/</span>
00264 
00265 {
00266     KIRQL OldIrql;
00267     ULONG VacbOffset = (ULONG)FileOffset &amp; (<a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - 1);
00268     PVOID Value = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00269 
00270     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(KeGetCurrentIrql() &lt; <a class="code" href="../../d6/d7/halmips_8h.html#a53">DISPATCH_LEVEL</a>);
00271 
00272     <span class="comment">//</span>
00273     <span class="comment">//  Generate ReceivedLength return right away.</span>
00274     <span class="comment">//</span>
00275 
00276     *ReceivedLength = <a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - VacbOffset;
00277 
00278     <span class="comment">//</span>
00279     <span class="comment">//  Acquire the Vacb lock to see if the desired offset is already mapped.</span>
00280     <span class="comment">//</span>
00281 
00282     <a class="code" href="../../d5/d5/cc_8h.html#a4">CcAcquireVacbLock</a>( &amp;OldIrql );
00283 
00284     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( FileOffset &lt;= SharedCacheMap-&gt;SectionSize.QuadPart );
00285 
00286     <span class="keywordflow">if</span> ((*Vacb = <a class="code" href="../../d5/d3/vacbsup_8c.html#a1">GetVacb</a>( SharedCacheMap, *(PLARGE_INTEGER)&amp;FileOffset )) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00287 
00288         <span class="keywordflow">if</span> ((*Vacb)-&gt;Overlay.ActiveCount == 0) {
00289             SharedCacheMap-&gt;VacbActiveCount += 1;
00290         }
00291 
00292         (*Vacb)-&gt;Overlay.ActiveCount += 1;
00293 
00294         <span class="comment">//</span>
00295         <span class="comment">//  Move this range away from the front to avoid wasting cycles</span>
00296         <span class="comment">//  looking at it for reuse.</span>
00297         <span class="comment">//</span>
00298 
00299         <a class="code" href="../../d5/d3/vacbsup_8c.html#a3">CcMoveVacbToReuseTail</a>( *Vacb );
00300 
00301         Value = (PVOID)((PCHAR)(*Vacb)-&gt;BaseAddress + VacbOffset);
00302     }
00303 
00304     <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( OldIrql );
00305     <span class="keywordflow">return</span> Value;
00306 }
00307 
00308 
00309 PVOID
<a name="l00310"></a><a class="code" href="../../d5/d3/vacbsup_8c.html#a15">00310</a> <a class="code" href="../../d5/d3/vacbsup_8c.html#a15">CcGetVirtualAddress</a> (
00311     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap,
00312     IN LARGE_INTEGER FileOffset,
00313     OUT <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *Vacb,
00314     IN OUT PULONG ReceivedLength
00315     )
00316 
00317 <span class="comment">/*++</span>
00318 <span class="comment"></span>
00319 <span class="comment">Routine Description:</span>
00320 <span class="comment"></span>
00321 <span class="comment">    This is the main routine for Vacb management.  It may be called to acquire</span>
00322 <span class="comment">    a virtual address for a given file offset.  If the desired file offset is</span>
00323 <span class="comment">    already mapped, this routine does very little work before returning with</span>
00324 <span class="comment">    the desired virtual address and Vacb pointer (which must be supplied to</span>
00325 <span class="comment">    free the mapping).</span>
00326 <span class="comment"></span>
00327 <span class="comment">    If the desired virtual address is not currently mapped, then this routine</span>
00328 <span class="comment">    claims a Vacb from the tail of the Vacb LRU to reuse its mapping.  This Vacb</span>
00329 <span class="comment">    is then unmapped if necessary (normally not required), and mapped to the</span>
00330 <span class="comment">    desired address.</span>
00331 <span class="comment"></span>
00332 <span class="comment">Arguments:</span>
00333 <span class="comment"></span>
00334 <span class="comment">    SharedCacheMap - Supplies a pointer to the Shared Cache Map for the file.</span>
00335 <span class="comment"></span>
00336 <span class="comment">    FileOffset - Supplies the desired FileOffset within the file.</span>
00337 <span class="comment"></span>
00338 <span class="comment">    Vacb - Returns a Vacb pointer which must be supplied later to free</span>
00339 <span class="comment">           this virtual address.</span>
00340 <span class="comment"></span>
00341 <span class="comment">    ReceivedLength - Returns the number of bytes which are contiguously</span>
00342 <span class="comment">                     mapped starting at the virtual address returned.</span>
00343 <span class="comment"></span>
00344 <span class="comment">Return Value:</span>
00345 <span class="comment"></span>
00346 <span class="comment">    The virtual address at which the desired data is mapped.</span>
00347 <span class="comment"></span>
00348 <span class="comment">--*/</span>
00349 
00350 {
00351     KIRQL OldIrql;
00352     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> TempVacb;
00353     ULONG VacbOffset = FileOffset.LowPart &amp; (<a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - 1);
00354 
00355     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(KeGetCurrentIrql() &lt; <a class="code" href="../../d6/d7/halmips_8h.html#a53">DISPATCH_LEVEL</a>);
00356 
00357     <span class="comment">//</span>
00358     <span class="comment">//  Acquire the Vacb lock to see if the desired offset is already mapped.</span>
00359     <span class="comment">//</span>
00360 
00361     <a class="code" href="../../d5/d5/cc_8h.html#a4">CcAcquireVacbLock</a>( &amp;OldIrql );
00362 
00363     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( FileOffset.QuadPart &lt;= SharedCacheMap-&gt;SectionSize.QuadPart );
00364 
00365     <span class="keywordflow">if</span> ((TempVacb = <a class="code" href="../../d5/d3/vacbsup_8c.html#a1">GetVacb</a>( SharedCacheMap, FileOffset )) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00366 
00367         TempVacb = <a class="code" href="../../d5/d3/vacbsup_8c.html#a7">CcGetVacbMiss</a>( SharedCacheMap, FileOffset, &amp;OldIrql );
00368 
00369     } <span class="keywordflow">else</span> {
00370 
00371         <span class="keywordflow">if</span> (TempVacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o4">Overlay</a>.ActiveCount == 0) {
00372             SharedCacheMap-&gt;VacbActiveCount += 1;
00373         }
00374 
00375         TempVacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o4">Overlay</a>.ActiveCount += 1;
00376     }
00377 
00378     <span class="comment">//</span>
00379     <span class="comment">//  Move this range away from the front to avoid wasting cycles</span>
00380     <span class="comment">//  looking at it for reuse.</span>
00381     <span class="comment">//</span>
00382 
00383     <a class="code" href="../../d5/d3/vacbsup_8c.html#a3">CcMoveVacbToReuseTail</a>( TempVacb );
00384 
00385     <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( OldIrql );
00386 
00387     <span class="comment">//</span>
00388     <span class="comment">//  Now form all outputs.</span>
00389     <span class="comment">//</span>
00390 
00391     *Vacb = TempVacb;
00392     *ReceivedLength = <a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - VacbOffset;
00393 
00394     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(KeGetCurrentIrql() &lt; <a class="code" href="../../d6/d7/halmips_8h.html#a53">DISPATCH_LEVEL</a>);
00395 
00396     <span class="keywordflow">return</span> (PVOID)((PCHAR)TempVacb-&gt;BaseAddress + VacbOffset);
00397 }
00398 
00399 
00400 <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a>
<a name="l00401"></a><a class="code" href="../../d5/d3/vacbsup_8c.html#a7">00401</a> <a class="code" href="../../d5/d3/vacbsup_8c.html#a7">CcGetVacbMiss</a> (
00402     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap,
00403     IN LARGE_INTEGER FileOffset,
00404     IN OUT PKIRQL OldIrql
00405     )
00406 
00407 <span class="comment">/*++</span>
00408 <span class="comment"></span>
00409 <span class="comment">Routine Description:</span>
00410 <span class="comment"></span>
00411 <span class="comment">    This is the main routine for Vacb management.  It may be called to acquire</span>
00412 <span class="comment">    a virtual address for a given file offset.  If the desired file offset is</span>
00413 <span class="comment">    already mapped, this routine does very little work before returning with</span>
00414 <span class="comment">    the desired virtual address and Vacb pointer (which must be supplied to</span>
00415 <span class="comment">    free the mapping).</span>
00416 <span class="comment"></span>
00417 <span class="comment">    If the desired virtual address is not currently mapped, then this routine</span>
00418 <span class="comment">    claims a Vacb from the tail of the Vacb LRU to reuse its mapping.  This Vacb</span>
00419 <span class="comment">    is then unmapped if necessary (normally not required), and mapped to the</span>
00420 <span class="comment">    desired address.</span>
00421 <span class="comment"></span>
00422 <span class="comment">Arguments:</span>
00423 <span class="comment"></span>
00424 <span class="comment">    SharedCacheMap - Supplies a pointer to the Shared Cache Map for the file.</span>
00425 <span class="comment"></span>
00426 <span class="comment">    FileOffset - Supplies the desired FileOffset within the file.</span>
00427 <span class="comment"></span>
00428 <span class="comment">    OldIrql - Pointer to the OldIrql variable in the caller</span>
00429 <span class="comment"></span>
00430 <span class="comment">Return Value:</span>
00431 <span class="comment"></span>
00432 <span class="comment">    The Vacb.</span>
00433 <span class="comment"></span>
00434 <span class="comment">--*/</span>
00435 
00436 {
00437     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> OldSharedCacheMap;
00438     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> Vacb, TempVacb;
00439     LARGE_INTEGER MappedLength;
00440     LARGE_INTEGER NormalOffset;
00441     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00442     ULONG ActivePage;
00443     ULONG PageIsDirty;
00444     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> ActiveVacb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00445     ULONG VacbOffset = FileOffset.LowPart &amp; (<a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - 1);
00446 
00447     NormalOffset = FileOffset;
00448     NormalOffset.LowPart -= VacbOffset;
00449 
00450     <span class="comment">//</span>
00451     <span class="comment">//  For files that are not open for random access, we assume sequential</span>
00452     <span class="comment">//  access and periodically unmap unused views behind us as we go, to</span>
00453     <span class="comment">//  keep from hogging memory.</span>
00454     <span class="comment">//</span>
00455     <span class="comment">//  We used to only do this for pure FO_SEQUENTIAL_ONLY access.  The</span>
00456     <span class="comment">//  sequential flags still has an effect (to put the pages at the front</span>
00457     <span class="comment">//  of the standby lists) but we intend for the majority of the file</span>
00458     <span class="comment">//  cache to live on the standby and are willing to take transition</span>
00459     <span class="comment">//  faults to bring it back.  Granted, this exacerbates the problem that</span>
00460     <span class="comment">//  it is hard to figure out how big the filecache really is since even</span>
00461     <span class="comment">//  less of it is going to be mapped at any given time.  It may also</span>
00462     <span class="comment">//  promote the synchronization bottlenecks in view mapping (MmPfnLock)</span>
00463     <span class="comment">//  to the forefront when significant view thrashing occurs.</span>
00464     <span class="comment">//</span>
00465     <span class="comment">//  This isn't as bad as it seems.  When we see access take a view miss,</span>
00466     <span class="comment">//  it is really likely that it is a result of sequential access.  As long</span>
00467     <span class="comment">//  as the pages go onto the back of the standby, they'll live for a while.</span>
00468     <span class="comment">//  The problem we're dealing with here is that the cache can be filled at</span>
00469     <span class="comment">//  high speed, but the working set manager can't possibly trim it as fast,</span>
00470     <span class="comment">//  intelligently, while we have a pretty good guess where the candidate</span>
00471     <span class="comment">//  pages should come from.  We can't let the filecache size make large</span>
00472     <span class="comment">//  excursions, or we'll kick out a lot of valuable pages in the process.</span>
00473     <span class="comment">//</span>
00474 
00475     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;Flags, <a class="code" href="../../d5/d5/cc_8h.html#a81">RANDOM_ACCESS_SEEN</a>) &amp;&amp;
00476         ((NormalOffset.LowPart &amp; (<a class="code" href="../../d5/d5/cc_8h.html#a31">SEQUENTIAL_MAP_LIMIT</a> - 1)) == 0) &amp;&amp;
00477         (NormalOffset.QuadPart &gt;= (<a class="code" href="../../d5/d5/cc_8h.html#a31">SEQUENTIAL_MAP_LIMIT</a> * 2))) {
00478 
00479         <span class="comment">//</span>
00480         <span class="comment">//  Use MappedLength as a scratch variable to form the offset</span>
00481         <span class="comment">//  to start unmapping.  We are not synchronized with these past</span>
00482         <span class="comment">//  views, so it is possible that CcUnmapVacbArray will kick out</span>
00483         <span class="comment">//  early when it sees an active view.  That is why we go back</span>
00484         <span class="comment">//  twice the distance, and effectively try to unmap everything</span>
00485         <span class="comment">//  twice.  The second time should normally do it.  If the file</span>
00486         <span class="comment">//  is truly sequential only, then the only collision expected</span>
00487         <span class="comment">//  might be the previous view if we are being called from readahead,</span>
00488         <span class="comment">//  or there is a small chance that we can collide with the</span>
00489         <span class="comment">//  Lazy Writer during the small window where he briefly maps</span>
00490         <span class="comment">//  the file to push out the dirty bits.</span>
00491         <span class="comment">//</span>
00492 
00493         <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( *OldIrql );
00494         MappedLength.QuadPart = NormalOffset.QuadPart - (<a class="code" href="../../d5/d5/cc_8h.html#a31">SEQUENTIAL_MAP_LIMIT</a> * 2);
00495         <a class="code" href="../../d5/d3/vacbsup_8c.html#a22">CcUnmapVacbArray</a>( SharedCacheMap, &amp;MappedLength, (<a class="code" href="../../d5/d5/cc_8h.html#a31">SEQUENTIAL_MAP_LIMIT</a> * 2), <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00496         <a class="code" href="../../d5/d5/cc_8h.html#a4">CcAcquireVacbLock</a>( OldIrql );
00497     }
00498 
00499     <span class="comment">//</span>
00500     <span class="comment">//  Scan from the front of the lru for the next victim Vacb</span>
00501     <span class="comment">//</span>
00502 
00503     Vacb = CONTAINING_RECORD( <a class="code" href="../../d5/d2/cachedat_8c.html#a22">CcVacbLru</a>.Flink, <a class="code" href="../../d2/d5/struct__VACB.html">VACB</a>, LruList );
00504 
00505     <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00506 
00507         <span class="comment">//</span>
00508         <span class="comment">//  If this guy is not active, break out and use him.  Also, if</span>
00509         <span class="comment">//  it is an Active Vacb, nuke it now, because the reader may be idle and we</span>
00510         <span class="comment">//  want to clean up.</span>
00511         <span class="comment">//</span>
00512 
00513         OldSharedCacheMap = Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o1">SharedCacheMap</a>;
00514         <span class="keywordflow">if</span> ((Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o4">Overlay</a>.ActiveCount == 0) ||
00515             ((ActiveVacb == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
00516              (OldSharedCacheMap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
00517              (OldSharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o11">ActiveVacb</a> == Vacb))) {
00518 
00519             <span class="comment">//</span>
00520             <span class="comment">//  The normal case is that the Vacb is no longer mapped</span>
00521             <span class="comment">//  and we can just get out and use it, however, here we</span>
00522             <span class="comment">//  handle the case where it is mapped.</span>
00523             <span class="comment">//</span>
00524 
00525             <span class="keywordflow">if</span> (Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o0">BaseAddress</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00526 
00527 
00528                 <span class="comment">//</span>
00529                 <span class="comment">//  If this Vacb is active, it must be the ActiveVacb.</span>
00530                 <span class="comment">//</span>
00531 
00532                 <span class="keywordflow">if</span> (Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o4">Overlay</a>.ActiveCount != 0) {
00533 
00534                     <span class="comment">//</span>
00535                     <span class="comment">//  Get the active Vacb.</span>
00536                     <span class="comment">//</span>
00537 
00538                     <a class="code" href="../../d5/d5/cc_8h.html#a83">GetActiveVacbAtDpcLevel</a>( Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o1">SharedCacheMap</a>, ActiveVacb, ActivePage, PageIsDirty );
00539 
00540                 <span class="comment">//</span>
00541                 <span class="comment">//  Otherwise we will break out and use this Vacb.  If it</span>
00542                 <span class="comment">//  is still mapped we can now safely increment the open</span>
00543                 <span class="comment">//  count.</span>
00544                 <span class="comment">//</span>
00545 
00546                 } <span class="keywordflow">else</span> {
00547 
00548                     <span class="comment">//</span>
00549                     <span class="comment">//  Note that if the SharedCacheMap is currently</span>
00550                     <span class="comment">//  being deleted, we need to skip over</span>
00551                     <span class="comment">//  it, otherwise we will become the second</span>
00552                     <span class="comment">//  deleter.  CcDeleteSharedCacheMap clears the</span>
00553                     <span class="comment">//  pointer in the SectionObjectPointer.</span>
00554                     <span class="comment">//</span>
00555 
00556                     <a class="code" href="../../d5/d5/cc_8h.html#a2">CcAcquireMasterLockAtDpcLevel</a>();
00557                     <span class="keywordflow">if</span> (Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o1">SharedCacheMap</a>-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o10">FileObject</a>-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o6">SectionObjectPointer</a>-&gt;<a class="code" href="../../d7/d0/struct__SECTION__OBJECT__POINTERS.html#o1">SharedCacheMap</a> ==
00558                         Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o1">SharedCacheMap</a>) {
00559 
00560                         <a class="code" href="../../d5/d5/cc_8h.html#a68">CcIncrementOpenCount</a>( Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o1">SharedCacheMap</a>, 'mvGS' );
00561                         <a class="code" href="../../d5/d5/cc_8h.html#a3">CcReleaseMasterLockFromDpcLevel</a>();
00562                         <span class="keywordflow">break</span>;
00563                     }
00564                     <a class="code" href="../../d5/d5/cc_8h.html#a3">CcReleaseMasterLockFromDpcLevel</a>();
00565                 }
00566             } <span class="keywordflow">else</span> {
00567                 <span class="keywordflow">break</span>;
00568             }
00569         }
00570 
00571         <span class="comment">//</span>
00572         <span class="comment">//  Advance to the next guy if we haven't scanned</span>
00573         <span class="comment">//  the entire list.</span>
00574         <span class="comment">//</span>
00575 
00576         <span class="keywordflow">if</span> (Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o5">LruList</a>.Flink != &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a22">CcVacbLru</a>) {
00577 
00578             Vacb = CONTAINING_RECORD( Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o5">LruList</a>.Flink, <a class="code" href="../../d2/d5/struct__VACB.html">VACB</a>, LruList );
00579 
00580         } <span class="keywordflow">else</span> {
00581 
00582             <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( *OldIrql );
00583 
00584             <span class="comment">//</span>
00585             <span class="comment">//  If we found an active vacb, then free it and go back and</span>
00586             <span class="comment">//  try again.  Else it's time to bail.</span>
00587             <span class="comment">//</span>
00588 
00589             <span class="keywordflow">if</span> (ActiveVacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00590                 <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( ActiveVacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o1">SharedCacheMap</a>, ActiveVacb, ActivePage, PageIsDirty );
00591                 ActiveVacb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00592 
00593                 <span class="comment">//</span>
00594                 <span class="comment">//  Reacquire spinlocks to loop back and position ourselves at the head</span>
00595                 <span class="comment">//  of the LRU for the next pass.</span>
00596                 <span class="comment">//</span>
00597 
00598                 <a class="code" href="../../d5/d5/cc_8h.html#a4">CcAcquireVacbLock</a>( OldIrql );
00599 
00600                 Vacb = CONTAINING_RECORD( <a class="code" href="../../d5/d2/cachedat_8c.html#a22">CcVacbLru</a>.Flink, <a class="code" href="../../d2/d5/struct__VACB.html">VACB</a>, LruList );
00601 
00602             } <span class="keywordflow">else</span> {
00603                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INSUFFICIENT_RESOURCES );
00604             }
00605         }
00606     }
00607 
00608     <span class="comment">//</span>
00609     <span class="comment">//  Unlink it from the other SharedCacheMap, so the other</span>
00610     <span class="comment">//  guy will not try to use it when we free the spin lock.</span>
00611     <span class="comment">//</span>
00612 
00613     <span class="keywordflow">if</span> (Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o1">SharedCacheMap</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00614 
00615         OldSharedCacheMap = Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o1">SharedCacheMap</a>;
00616         <a class="code" href="../../d5/d3/vacbsup_8c.html#a11">SetVacb</a>( OldSharedCacheMap, Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o4">Overlay</a>.FileOffset, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00617         Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o1">SharedCacheMap</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00618     }
00619 
00620     <span class="comment">//</span>
00621     <span class="comment">//  Mark it in use so no one else will muck with it after</span>
00622     <span class="comment">//  we release the spin lock.</span>
00623     <span class="comment">//</span>
00624 
00625     Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o4">Overlay</a>.ActiveCount = 1;
00626     SharedCacheMap-&gt;VacbActiveCount += 1;
00627 
00628     <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( *OldIrql );
00629 
00630     <span class="comment">//</span>
00631     <span class="comment">//  If the Vacb is already mapped, then unmap it.</span>
00632     <span class="comment">//</span>
00633 
00634     <span class="keywordflow">if</span> (Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o0">BaseAddress</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00635 
00636         <span class="comment">//</span>
00637         <span class="comment">//  Check to see if we need to drain the zone.</span>
00638         <span class="comment">//</span>
00639 
00640         <a class="code" href="../../d5/d5/cc_8h.html#a205">CcDrainVacbLevelZone</a>();
00641 
00642         <a class="code" href="../../d5/d3/vacbsup_8c.html#a6">CcUnmapVacb</a>( Vacb, OldSharedCacheMap, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00643 
00644         <span class="comment">//</span>
00645         <span class="comment">//  Now we can decrement the open count as we normally</span>
00646         <span class="comment">//  do, possibly deleting the guy.</span>
00647         <span class="comment">//</span>
00648 
00649         <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( OldIrql );
00650 
00651         <span class="comment">//</span>
00652         <span class="comment">//  Now release our open count.</span>
00653         <span class="comment">//</span>
00654 
00655         <a class="code" href="../../d5/d5/cc_8h.html#a69">CcDecrementOpenCount</a>( OldSharedCacheMap, 'mvGF' );
00656 
00657         <span class="keywordflow">if</span> ((OldSharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o2">OpenCount</a> == 0) &amp;&amp;
00658             !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(OldSharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a74">WRITE_QUEUED</a>) &amp;&amp;
00659             (OldSharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> == 0)) {
00660 
00661             <span class="comment">//</span>
00662             <span class="comment">//  Move to the dirty list.</span>
00663             <span class="comment">//</span>
00664 
00665             RemoveEntryList( &amp;OldSharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
00666             InsertTailList( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a2">CcDirtySharedCacheMapList</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a>,
00667                             &amp;OldSharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
00668 
00669             <span class="comment">//</span>
00670             <span class="comment">//  Make sure the Lazy Writer will wake up, because we</span>
00671             <span class="comment">//  want him to delete this SharedCacheMap.</span>
00672             <span class="comment">//</span>
00673 
00674             <a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o6">OtherWork</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00675             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o5">ScanActive</a>) {
00676                 <a class="code" href="../../d5/d5/cc_8h.html#a185">CcScheduleLazyWriteScan</a>();
00677             }
00678         }
00679 
00680         <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( *OldIrql );
00681     }
00682 
00683     <span class="comment">//</span>
00684     <span class="comment">//  Use try-finally to return this guy to the list if we get an</span>
00685     <span class="comment">//  exception.</span>
00686     <span class="comment">//</span>
00687 
00688     <span class="keywordflow">try</span> {
00689 
00690         <span class="comment">//</span>
00691         <span class="comment">//  Assume we are mapping to the end of the section, but</span>
00692         <span class="comment">//  reduce to our normal mapping granularity if the section</span>
00693         <span class="comment">//  is too large.</span>
00694         <span class="comment">//</span>
00695 
00696         MappedLength.QuadPart = SharedCacheMap-&gt;SectionSize.QuadPart - NormalOffset.QuadPart;
00697 
00698         <span class="keywordflow">if</span> ((MappedLength.HighPart != 0) ||
00699             (MappedLength.LowPart &gt; <a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a>)) {
00700 
00701             MappedLength.LowPart = <a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a>;
00702         }
00703 
00704         <span class="comment">//</span>
00705         <span class="comment">//  Now map this one in the system cache.</span>
00706         <span class="comment">//</span>
00707 
00708         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"MmMapViewInSystemCache:\n"</span>, 0 );
00709         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"    Section = %08lx\n"</span>, SharedCacheMap-&gt;Section );
00710         <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>(0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"    Offset = %08lx, %08lx\n"</span>,
00711                                 NormalOffset.LowPart,
00712                                 NormalOffset.HighPart );
00713         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"    ViewSize = %08lx\n"</span>, MappedLength.LowPart );
00714 
00715         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> =
00716           <a class="code" href="../../d1/d5/mapcache_8c.html#a9">MmMapViewInSystemCache</a>( SharedCacheMap-&gt;Section,
00717                                   &amp;Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o0">BaseAddress</a>,
00718                                   &amp;NormalOffset,
00719                                   &amp;MappedLength.LowPart );
00720 
00721         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"    &lt;BaseAddress = %08lx\n"</span>, Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o0">BaseAddress</a> );
00722         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"    &lt;ViewSize = %08lx\n"</span>, MappedLength.LowPart );
00723 
00724         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
00725 
00726             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, 0, <span class="stringliteral">"Error from Map, Status = %08lx\n"</span>, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
00727 
00728             <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( <a class="code" href="../../d1/d8/fsrtl_8h.html#a136">FsRtlNormalizeNtstatus</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>,
00729                                                    STATUS_UNEXPECTED_MM_MAP_ERROR ));
00730         }
00731 
00732     } finally {
00733 
00734         <span class="comment">//</span>
00735         <span class="comment">//  Take this opportunity to free the active vacb.</span>
00736         <span class="comment">//</span>
00737 
00738         <span class="keywordflow">if</span> (ActiveVacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00739 
00740             <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( ActiveVacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o1">SharedCacheMap</a>, ActiveVacb, ActivePage, PageIsDirty );
00741         }
00742 
00743         <span class="comment">//</span>
00744         <span class="comment">//  On abnormal termination, get this guy back in the list.</span>
00745         <span class="comment">//</span>
00746 
00747         <span class="keywordflow">if</span> (AbnormalTermination()) {
00748 
00749             <a class="code" href="../../d5/d5/cc_8h.html#a4">CcAcquireVacbLock</a>( OldIrql );
00750 
00751             <span class="comment">//</span>
00752             <span class="comment">//  This is like the unlucky case below.  Just back out the stuff</span>
00753             <span class="comment">//  we did and put the guy at the tail of the list.  Basically</span>
00754             <span class="comment">//  only the Map should fail, and we clear BaseAddress accordingly.</span>
00755             <span class="comment">//</span>
00756 
00757             Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o0">BaseAddress</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00758 
00759             <a class="code" href="../../d5/d3/vacbsup_8c.html#a5">CheckedDec</a>(Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o4">Overlay</a>.ActiveCount);
00760             <a class="code" href="../../d5/d3/vacbsup_8c.html#a5">CheckedDec</a>(SharedCacheMap-&gt;VacbActiveCount);
00761 
00762             <span class="comment">//</span>
00763             <span class="comment">//  If there is someone waiting for this count to go to zero,</span>
00764             <span class="comment">//  wake them here.</span>
00765             <span class="comment">//</span>
00766 
00767             <span class="keywordflow">if</span> (SharedCacheMap-&gt;WaitOnActiveCount != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00768                 <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>( SharedCacheMap-&gt;WaitOnActiveCount, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00769             }
00770 
00771             <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( *OldIrql );
00772         }
00773     }
00774 
00775     <span class="comment">//</span>
00776     <span class="comment">//  Make sure the zone contains the worst case number of entries.</span>
00777     <span class="comment">//</span>
00778 
00779     <span class="keywordflow">if</span> (SharedCacheMap-&gt;SectionSize.QuadPart &gt; <a class="code" href="../../d5/d5/cc_8h.html#a41">VACB_SIZE_OF_FIRST_LEVEL</a>) {
00780 
00781         <span class="comment">//</span>
00782         <span class="comment">//  Raise if we cannot preallocate enough buffers.</span>
00783         <span class="comment">//</span>
00784 
00785         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d3/vacbsup_8c.html#a23">CcPrefillVacbLevelZone</a>( <a class="code" href="../../d5/d2/cachedat_8c.html#a23">CcMaxVacbLevelsSeen</a> - 1,
00786                                      OldIrql,
00787                                      <a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;Flags, <a class="code" href="../../d5/d5/cc_8h.html#a78">MODIFIED_WRITE_DISABLED</a>) )) {
00788 
00789             <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INSUFFICIENT_RESOURCES );
00790         }
00791 
00792     } <span class="keywordflow">else</span> {
00793 
00794         <a class="code" href="../../d5/d5/cc_8h.html#a4">CcAcquireVacbLock</a>( OldIrql );
00795     }
00796 
00797     <span class="comment">//</span>
00798     <span class="comment">//  Finish filling in the Vacb, and store its address in the array in</span>
00799     <span class="comment">//  the Shared Cache Map.  (We have to rewrite the ActiveCount</span>
00800     <span class="comment">//  since it is overlaid.)  To do this we must reacquire the</span>
00801     <span class="comment">//  spin lock one more time.  Note we have to check for the unusual</span>
00802     <span class="comment">//  case that someone beat us to mapping this view, since we had to</span>
00803     <span class="comment">//  drop the spin lock.</span>
00804     <span class="comment">//</span>
00805 
00806     <span class="keywordflow">if</span> ((TempVacb = <a class="code" href="../../d5/d3/vacbsup_8c.html#a1">GetVacb</a>( SharedCacheMap, NormalOffset )) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00807 
00808         Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o1">SharedCacheMap</a> = SharedCacheMap;
00809         Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o4">Overlay</a>.FileOffset = NormalOffset;
00810         Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o4">Overlay</a>.ActiveCount = 1;
00811 
00812         <a class="code" href="../../d5/d3/vacbsup_8c.html#a11">SetVacb</a>( SharedCacheMap, NormalOffset, Vacb );
00813 
00814     <span class="comment">//</span>
00815     <span class="comment">//  This is the unlucky case where we collided with someone else</span>
00816     <span class="comment">//  trying to map the same view.  He can get in because we dropped</span>
00817     <span class="comment">//  the spin lock above.  Rather than allocating events and making</span>
00818     <span class="comment">//  someone wait, considering this case is fairly unlikely, we just</span>
00819     <span class="comment">//  dump this one at the head of the LRU and use the one from the</span>
00820     <span class="comment">//  guy who beat us.</span>
00821     <span class="comment">//</span>
00822 
00823     } <span class="keywordflow">else</span> {
00824 
00825         <span class="comment">//</span>
00826         <span class="comment">//  Now we have to increment all of the counts for the one that</span>
00827         <span class="comment">//  was already there, then ditch the one we had.</span>
00828         <span class="comment">//</span>
00829 
00830         <span class="keywordflow">if</span> (TempVacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o4">Overlay</a>.ActiveCount == 0) {
00831             SharedCacheMap-&gt;VacbActiveCount += 1;
00832         }
00833 
00834         TempVacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o4">Overlay</a>.ActiveCount += 1;
00835 
00836         <span class="comment">//</span>
00837         <span class="comment">//  Now unmap the one we mapped and proceed with the other Vacb.</span>
00838         <span class="comment">//  On this path we have to release the spinlock to do the unmap,</span>
00839         <span class="comment">//  and then reacquire the spinlock before cleaning up.</span>
00840         <span class="comment">//</span>
00841 
00842         <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( *OldIrql );
00843 
00844         <a class="code" href="../../d5/d3/vacbsup_8c.html#a6">CcUnmapVacb</a>( Vacb, SharedCacheMap, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00845 
00846         <a class="code" href="../../d5/d5/cc_8h.html#a4">CcAcquireVacbLock</a>( OldIrql );
00847         <a class="code" href="../../d5/d3/vacbsup_8c.html#a5">CheckedDec</a>(Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o4">Overlay</a>.ActiveCount);
00848         <a class="code" href="../../d5/d3/vacbsup_8c.html#a5">CheckedDec</a>(SharedCacheMap-&gt;VacbActiveCount);
00849         Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o1">SharedCacheMap</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00850 
00851         <a class="code" href="../../d5/d3/vacbsup_8c.html#a2">CcMoveVacbToReuseHead</a>( Vacb );
00852 
00853         Vacb = TempVacb;
00854     }
00855 
00856     <span class="keywordflow">return</span> Vacb;
00857 }
00858 
00859 
00860 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00861 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l00862"></a><a class="code" href="../../d5/d3/vacbsup_8c.html#a16">00862</a> <a class="code" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a> (
00863     IN <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> Vacb
00864     )
00865 
00866 <span class="comment">/*++</span>
00867 <span class="comment"></span>
00868 <span class="comment">Routine Description:</span>
00869 <span class="comment"></span>
00870 <span class="comment">    This routine must be called once for each call to CcGetVirtualAddress</span>
00871 <span class="comment">    to free that virtual address.</span>
00872 <span class="comment"></span>
00873 <span class="comment">Arguments:</span>
00874 <span class="comment"></span>
00875 <span class="comment">    Vacb - Supplies the Vacb which was returned from CcGetVirtualAddress.</span>
00876 <span class="comment"></span>
00877 <span class="comment">Return Value:</span>
00878 <span class="comment"></span>
00879 <span class="comment">    None.</span>
00880 <span class="comment"></span>
00881 <span class="comment">--*/</span>
00882 
00883 {
00884     KIRQL OldIrql;
00885     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap = Vacb-&gt;SharedCacheMap;
00886 
00887     <a class="code" href="../../d5/d5/cc_8h.html#a4">CcAcquireVacbLock</a>( &amp;OldIrql );
00888 
00889     <a class="code" href="../../d5/d3/vacbsup_8c.html#a5">CheckedDec</a>(Vacb-&gt;Overlay.ActiveCount);
00890 
00891     <span class="comment">//</span>
00892     <span class="comment">//  If the count goes to zero, then we want to decrement the global</span>
00893     <span class="comment">//  Active count.</span>
00894     <span class="comment">//</span>
00895 
00896     <span class="keywordflow">if</span> (Vacb-&gt;Overlay.ActiveCount == 0) {
00897 
00898         <span class="comment">//</span>
00899         <span class="comment">//  If the SharedCacheMap address is not NULL, then this one is</span>
00900         <span class="comment">//  in use by a shared cache map, and we have to decrement his</span>
00901         <span class="comment">//  count and see if anyone is waiting.</span>
00902         <span class="comment">//</span>
00903 
00904         <span class="keywordflow">if</span> (SharedCacheMap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00905 
00906             <a class="code" href="../../d5/d3/vacbsup_8c.html#a5">CheckedDec</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o16">VacbActiveCount</a>);
00907 
00908             <span class="comment">//</span>
00909             <span class="comment">//  If there is someone waiting for this count to go to zero,</span>
00910             <span class="comment">//  wake them here.</span>
00911             <span class="comment">//</span>
00912 
00913             <span class="keywordflow">if</span> (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o24">WaitOnActiveCount</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00914                 <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o24">WaitOnActiveCount</a>, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00915             }
00916 
00917             <span class="comment">//</span>
00918             <span class="comment">//  Go to the back of the LRU to save this range for a bit</span>
00919             <span class="comment">//</span>
00920 
00921             <a class="code" href="../../d5/d3/vacbsup_8c.html#a3">CcMoveVacbToReuseTail</a>( Vacb );
00922 
00923         } <span class="keywordflow">else</span> {
00924 
00925             <span class="comment">//</span>
00926             <span class="comment">//  This range is no longer referenced, so make it avaliable</span>
00927             <span class="comment">//</span>
00928 
00929             <a class="code" href="../../d5/d3/vacbsup_8c.html#a2">CcMoveVacbToReuseHead</a>( Vacb );
00930         }
00931 
00932     } <span class="keywordflow">else</span> {
00933 
00934         <span class="comment">//</span>
00935         <span class="comment">//  This range is still in use, so move it away from the front</span>
00936         <span class="comment">//  so that it doesn't consume cycles being checked.</span>
00937         <span class="comment">//</span>
00938 
00939         <a class="code" href="../../d5/d3/vacbsup_8c.html#a3">CcMoveVacbToReuseTail</a>( Vacb );
00940     }
00941 
00942     <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( OldIrql );
00943 }
00944 
00945 
00946 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00947"></a><a class="code" href="../../d5/d3/vacbsup_8c.html#a17">00947</a> <a class="code" href="../../d5/d3/vacbsup_8c.html#a17">CcReferenceFileOffset</a> (
00948     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap,
00949     IN LARGE_INTEGER FileOffset
00950     )
00951 
00952 <span class="comment">/*++</span>
00953 <span class="comment"></span>
00954 <span class="comment">Routine Description:</span>
00955 <span class="comment"></span>
00956 <span class="comment">    This is a special form of reference that insures that the multi-level</span>
00957 <span class="comment">    Vacb structures are expanded to cover a given file offset.</span>
00958 <span class="comment"></span>
00959 <span class="comment">Arguments:</span>
00960 <span class="comment"></span>
00961 <span class="comment">    SharedCacheMap - Supplies a pointer to the Shared Cache Map for the file.</span>
00962 <span class="comment"></span>
00963 <span class="comment">    FileOffset - Supplies the desired FileOffset within the file.</span>
00964 <span class="comment"></span>
00965 <span class="comment">Return Value:</span>
00966 <span class="comment"></span>
00967 <span class="comment">    None</span>
00968 <span class="comment"></span>
00969 <span class="comment">--*/</span>
00970 
00971 {
00972     KIRQL OldIrql;
00973 
00974     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(KeGetCurrentIrql() &lt; <a class="code" href="../../d6/d7/halmips_8h.html#a53">DISPATCH_LEVEL</a>);
00975 
00976     <span class="comment">//</span>
00977     <span class="comment">//  This operation only has meaning if the Vacbs are in the multilevel form.</span>
00978     <span class="comment">//</span>
00979 
00980     <span class="keywordflow">if</span> (SharedCacheMap-&gt;SectionSize.QuadPart &gt; <a class="code" href="../../d5/d5/cc_8h.html#a41">VACB_SIZE_OF_FIRST_LEVEL</a>) {
00981 
00982         <span class="comment">//</span>
00983         <span class="comment">//  Prefill the level zone so that we can expand the tree if required.</span>
00984         <span class="comment">//</span>
00985 
00986         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d3/vacbsup_8c.html#a23">CcPrefillVacbLevelZone</a>( <a class="code" href="../../d5/d2/cachedat_8c.html#a23">CcMaxVacbLevelsSeen</a> - 1,
00987                                      &amp;OldIrql,
00988                                      <a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;Flags, <a class="code" href="../../d5/d5/cc_8h.html#a78">MODIFIED_WRITE_DISABLED</a>) )) {
00989 
00990             <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INSUFFICIENT_RESOURCES );
00991         }
00992 
00993         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( FileOffset.QuadPart &lt;= SharedCacheMap-&gt;SectionSize.QuadPart );
00994 
00995         <a class="code" href="../../d5/d3/vacbsup_8c.html#a11">SetVacb</a>( SharedCacheMap, FileOffset, <a class="code" href="../../d5/d5/cc_8h.html#a65">VACB_SPECIAL_REFERENCE</a> );
00996 
00997         <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( OldIrql );
00998     }
00999 
01000     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(KeGetCurrentIrql() &lt; <a class="code" href="../../d6/d7/halmips_8h.html#a53">DISPATCH_LEVEL</a>);
01001 
01002     <span class="keywordflow">return</span>;
01003 }
01004 
01005 
01006 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01007"></a><a class="code" href="../../d5/d3/vacbsup_8c.html#a18">01007</a> <a class="code" href="../../d5/d3/vacbsup_8c.html#a18">CcDereferenceFileOffset</a> (
01008     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap,
01009     IN LARGE_INTEGER FileOffset
01010     )
01011 
01012 <span class="comment">/*++</span>
01013 <span class="comment"></span>
01014 <span class="comment">Routine Description:</span>
01015 <span class="comment"></span>
01016 <span class="comment">    This routine must be called once for each call to CcReferenceFileOffset</span>
01017 <span class="comment">    to remove the reference.</span>
01018 <span class="comment"></span>
01019 <span class="comment">Arguments:</span>
01020 <span class="comment"></span>
01021 <span class="comment">    SharedCacheMap - Supplies a pointer to the Shared Cache Map for the file.</span>
01022 <span class="comment"></span>
01023 <span class="comment">    FileOffset - Supplies the desired FileOffset within the file.</span>
01024 <span class="comment"></span>
01025 <span class="comment">Return Value:</span>
01026 <span class="comment"></span>
01027 <span class="comment">    None</span>
01028 <span class="comment"></span>
01029 <span class="comment">--*/</span>
01030 
01031 {
01032     KIRQL OldIrql;
01033 
01034     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(KeGetCurrentIrql() &lt; <a class="code" href="../../d6/d7/halmips_8h.html#a53">DISPATCH_LEVEL</a>);
01035 
01036     <span class="comment">//</span>
01037     <span class="comment">//  This operation only has meaning if the Vacbs are in the multilevel form.</span>
01038     <span class="comment">//</span>
01039 
01040     <span class="keywordflow">if</span> (SharedCacheMap-&gt;SectionSize.QuadPart &gt; <a class="code" href="../../d5/d5/cc_8h.html#a41">VACB_SIZE_OF_FIRST_LEVEL</a>) {
01041 
01042         <span class="comment">//</span>
01043         <span class="comment">//  Acquire the Vacb lock to synchronize the dereference.</span>
01044         <span class="comment">//</span>
01045 
01046         <a class="code" href="../../d5/d5/cc_8h.html#a4">CcAcquireVacbLock</a>( &amp;OldIrql );
01047 
01048         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( FileOffset.QuadPart &lt;= SharedCacheMap-&gt;SectionSize.QuadPart );
01049 
01050         <a class="code" href="../../d5/d3/vacbsup_8c.html#a11">SetVacb</a>( SharedCacheMap, FileOffset, <a class="code" href="../../d5/d5/cc_8h.html#a66">VACB_SPECIAL_DEREFERENCE</a> );
01051 
01052         <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( OldIrql );
01053     }
01054 
01055     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(KeGetCurrentIrql() &lt; <a class="code" href="../../d6/d7/halmips_8h.html#a53">DISPATCH_LEVEL</a>);
01056 
01057     <span class="keywordflow">return</span>;
01058 }
01059 
01060 
01061 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01062"></a><a class="code" href="../../d5/d3/vacbsup_8c.html#a19">01062</a> <a class="code" href="../../d5/d3/vacbsup_8c.html#a19">CcWaitOnActiveCount</a> (
01063     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap
01064     )
01065 
01066 <span class="comment">/*++</span>
01067 <span class="comment"></span>
01068 <span class="comment">Routine Description:</span>
01069 <span class="comment"></span>
01070 <span class="comment">    This routine may be called to wait for outstanding mappings for</span>
01071 <span class="comment">    a given SharedCacheMap to go inactive.  It is intended to be called</span>
01072 <span class="comment">    from CcUninitializeCacheMap, which is called by the file systems</span>
01073 <span class="comment">    during cleanup processing.  In that case this routine only has to</span>
01074 <span class="comment">    wait if the user closed a handle without waiting for all I/Os on the</span>
01075 <span class="comment">    handle to complete.</span>
01076 <span class="comment"></span>
01077 <span class="comment">    This routine returns each time the active count is decremented.  The</span>
01078 <span class="comment">    caller must recheck his wait conditions on return, either waiting for</span>
01079 <span class="comment">    the ActiveCount to go to 0, or for specific views to go inactive</span>
01080 <span class="comment">    (CcPurgeCacheSection case).</span>
01081 <span class="comment"></span>
01082 <span class="comment">Arguments:</span>
01083 <span class="comment"></span>
01084 <span class="comment">    SharedCacheMap - Supplies the Shared Cache Map on whose VacbActiveCount</span>
01085 <span class="comment">                     we wish to wait.</span>
01086 <span class="comment"></span>
01087 <span class="comment">Return Value:</span>
01088 <span class="comment"></span>
01089 <span class="comment">    None.</span>
01090 <span class="comment"></span>
01091 <span class="comment">--*/</span>
01092 
01093 {
01094     KIRQL OldIrql;
01095     <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>;
01096 
01097     <span class="comment">//</span>
01098     <span class="comment">//  In the unusual case that we get a cleanup while I/O is still going</span>
01099     <span class="comment">//  on, we can wait here.  The caller must test the count for nonzero</span>
01100     <span class="comment">//  before calling this routine.</span>
01101     <span class="comment">//</span>
01102     <span class="comment">//  Since we are being called from cleanup, we cannot afford to</span>
01103     <span class="comment">//  fail here.</span>
01104     <span class="comment">//</span>
01105 
01106     <a class="code" href="../../d5/d5/cc_8h.html#a4">CcAcquireVacbLock</a>( &amp;OldIrql );
01107 
01108     <span class="comment">//</span>
01109     <span class="comment">//  It is possible that the count went to zero before we acquired the</span>
01110     <span class="comment">//  spinlock, so we must handle two cases here.</span>
01111     <span class="comment">//</span>
01112 
01113     <span class="keywordflow">if</span> (SharedCacheMap-&gt;VacbActiveCount != 0) {
01114 
01115         <span class="keywordflow">if</span> ((<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a> = SharedCacheMap-&gt;WaitOnActiveCount) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01116 
01117             <span class="comment">//</span>
01118             <span class="comment">//  If the local event is not being used then we take it.</span>
01119             <span class="comment">//</span>
01120 
01121             <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a> = InterlockedExchangePointer( &amp;SharedCacheMap-&gt;LocalEvent, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01122 
01123             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01124 
01125                 <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a> = (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>)<a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a175">NonPagedPoolMustSucceed</a>,
01126                                                         <span class="keyword">sizeof</span>(<a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a>),
01127                                                         'vEcC' );
01128             }
01129         }
01130 
01131         <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>,
01132                            NotificationEvent,
01133                            <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01134 
01135         SharedCacheMap-&gt;WaitOnActiveCount = <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>;
01136 
01137         <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( OldIrql );
01138 
01139         <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>,
01140                                <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
01141                                <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
01142                                <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01143                                (PLARGE_INTEGER)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
01144     } <span class="keywordflow">else</span> {
01145 
01146         <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( OldIrql );
01147     }
01148 }
01149 
01150 
01151 <span class="comment">//</span>
01152 <span class="comment">//  Internal Support Routine.</span>
01153 <span class="comment">//</span>
01154 
01155 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01156"></a><a class="code" href="../../d5/d3/vacbsup_8c.html#a6">01156</a> <a class="code" href="../../d5/d3/vacbsup_8c.html#a6">CcUnmapVacb</a> (
01157     IN <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> Vacb,
01158     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap,
01159     IN BOOLEAN UnmapBehind
01160     )
01161 
01162 <span class="comment">/*++</span>
01163 <span class="comment"></span>
01164 <span class="comment">Routine Description:</span>
01165 <span class="comment"></span>
01166 <span class="comment">    This routine may be called to unmap a previously mapped Vacb, and</span>
01167 <span class="comment">    clear its BaseAddress field.</span>
01168 <span class="comment"></span>
01169 <span class="comment">Arguments:</span>
01170 <span class="comment"></span>
01171 <span class="comment">    Vacb - Supplies the Vacb which was returned from CcGetVirtualAddress.</span>
01172 <span class="comment"></span>
01173 <span class="comment">    UnmapBehind - If this is a result of our unmap behind logic (the</span>
01174 <span class="comment">        only case in which we pay attention to sequential hints)</span>
01175 <span class="comment"></span>
01176 <span class="comment">Return Value:</span>
01177 <span class="comment"></span>
01178 <span class="comment">    None.</span>
01179 <span class="comment"></span>
01180 <span class="comment">--*/</span>
01181 
01182 {
01183     <span class="comment">//</span>
01184     <span class="comment">//  Make sure it is mapped.</span>
01185     <span class="comment">//</span>
01186 
01187     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(SharedCacheMap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
01188     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Vacb-&gt;BaseAddress != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
01189 
01190     <span class="comment">//</span>
01191     <span class="comment">//  Call MM to unmap it.</span>
01192     <span class="comment">//</span>
01193 
01194     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"MmUnmapViewInSystemCache:\n"</span>, 0 );
01195     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"    BaseAddress = %08lx\n"</span>, Vacb-&gt;BaseAddress );
01196 
01197     <a class="code" href="../../d1/d5/mapcache_8c.html#a11">MmUnmapViewInSystemCache</a>( Vacb-&gt;BaseAddress,
01198                               SharedCacheMap-&gt;Section,
01199                               UnmapBehind &amp;&amp;
01200                               <a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;Flags, <a class="code" href="../../d5/d5/cc_8h.html#a75">ONLY_SEQUENTIAL_ONLY_SEEN</a>) );
01201 
01202     Vacb-&gt;BaseAddress = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01203 }
01204 
01205 
01206 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01207 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l01208"></a><a class="code" href="../../d5/d3/vacbsup_8c.html#a20">01208</a> <a class="code" href="../../d5/d3/vacbsup_8c.html#a20">CcCreateVacbArray</a> (
01209     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap,
01210     IN LARGE_INTEGER NewSectionSize
01211     )
01212 
01213 <span class="comment">/*++</span>
01214 <span class="comment"></span>
01215 <span class="comment">Routine Description:</span>
01216 <span class="comment"></span>
01217 <span class="comment">    This routine must be called when a SharedCacheMap is created to create</span>
01218 <span class="comment">    and initialize the initial Vacb array.</span>
01219 <span class="comment"></span>
01220 <span class="comment">Arguments:</span>
01221 <span class="comment"></span>
01222 <span class="comment">    SharedCacheMap - Supplies the shared cache map for which the array is</span>
01223 <span class="comment">                     to be created.</span>
01224 <span class="comment"></span>
01225 <span class="comment">    NewSectionSize - Supplies the current size of the section which must be</span>
01226 <span class="comment">                     covered by the Vacb array.</span>
01227 <span class="comment"></span>
01228 <span class="comment">Return Value:</span>
01229 <span class="comment"></span>
01230 <span class="comment">    None.</span>
01231 <span class="comment"></span>
01232 <span class="comment">--*/</span>
01233 
01234 {
01235     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *NewAddresses;
01236     ULONG NewSize, SizeToAllocate;
01237     PLIST_ENTRY BcbListHead;
01238     BOOLEAN CreateBcbListHeads = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, CreateReference = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01239 
01240     NewSize = SizeToAllocate = <a class="code" href="../../d5/d3/vacbsup_8c.html#a4">SizeOfVacbArray</a>(NewSectionSize);
01241 
01242     <span class="comment">//</span>
01243     <span class="comment">//  The following limit is greater than the MM limit</span>
01244     <span class="comment">//  (i.e., MM actually only supports even smaller sections).</span>
01245     <span class="comment">//  We have to reject the sign bit, and testing the high byte</span>
01246     <span class="comment">//  for nonzero will surely only catch errors.</span>
01247     <span class="comment">//</span>
01248 
01249     <span class="keywordflow">if</span> (NewSectionSize.HighPart &amp; ~(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) {
01250         <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>(STATUS_SECTION_TOO_BIG);
01251     }
01252 
01253     <span class="comment">//</span>
01254     <span class="comment">//  See if we can use the array inside the shared cache map.</span>
01255     <span class="comment">//</span>
01256 
01257     <span class="keywordflow">if</span> (NewSize == (<a class="code" href="../../d5/d5/cc_8h.html#a64">PREALLOCATED_VACBS</a> * <span class="keyword">sizeof</span>(<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a>))) {
01258 
01259         NewAddresses = &amp;SharedCacheMap-&gt;InitialVacbs[0];
01260 
01261     <span class="comment">//</span>
01262     <span class="comment">//  Else allocate the array.</span>
01263     <span class="comment">//</span>
01264 
01265     } <span class="keywordflow">else</span> {
01266 
01267         <span class="comment">//</span>
01268         <span class="comment">//  For large metadata streams, double the size to allocate</span>
01269         <span class="comment">//  an array of Bcb listheads.  Each two Vacb pointers also</span>
01270         <span class="comment">//  gets its own Bcb listhead, thus requiring double the size.</span>
01271         <span class="comment">//</span>
01272 
01273         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d5/d5/cc_8h.html#a47">SIZE_PER_BCB_LIST</a> == (<a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> * 2));
01274 
01275         <span class="comment">//</span>
01276         <span class="comment">//  If this stream is larger than the size for multi-level Vacbs,</span>
01277         <span class="comment">//  then fix the size to allocate the root.</span>
01278         <span class="comment">//</span>
01279 
01280         <span class="keywordflow">if</span> (NewSize &gt; <a class="code" href="../../d5/d5/cc_8h.html#a39">VACB_LEVEL_BLOCK_SIZE</a>) {
01281 
01282             ULONG Level = 0;
01283             ULONG Shift = <a class="code" href="../../d4/d2/cache_8h.html#a1">VACB_OFFSET_SHIFT</a> + <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
01284 
01285             NewSize = SizeToAllocate = <a class="code" href="../../d5/d5/cc_8h.html#a39">VACB_LEVEL_BLOCK_SIZE</a>;
01286             SizeToAllocate += <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html">VACB_LEVEL_REFERENCE</a>);
01287             CreateReference = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01288 
01289             <span class="comment">//</span>
01290             <span class="comment">//  Loop to calculate how many levels we have and how much we have to</span>
01291             <span class="comment">//  shift to index into the first level.</span>
01292             <span class="comment">//</span>
01293 
01294             <span class="keywordflow">do</span> {
01295 
01296                 Level += 1;
01297                 Shift += <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
01298 
01299             } <span class="keywordflow">while</span> ((NewSectionSize.QuadPart &gt; ((LONGLONG)1 &lt;&lt; Shift)) != 0);
01300 
01301             <span class="comment">//</span>
01302             <span class="comment">//  Remember the maximum level ever seen (which is actually Level + 1).</span>
01303             <span class="comment">//</span>
01304 
01305             <span class="keywordflow">if</span> (Level &gt;= <a class="code" href="../../d5/d2/cachedat_8c.html#a23">CcMaxVacbLevelsSeen</a>) {
01306                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Level &lt;= <a class="code" href="../../d5/d5/cc_8h.html#a42">VACB_NUMBER_OF_LEVELS</a>);
01307                 <a class="code" href="../../d5/d2/cachedat_8c.html#a23">CcMaxVacbLevelsSeen</a> = Level + 1;
01308             }
01309 
01310         } <span class="keywordflow">else</span> {
01311 
01312             <span class="comment">//</span>
01313             <span class="comment">//  Does this stream get a Bcb Listhead array?</span>
01314             <span class="comment">//</span>
01315 
01316             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;Flags, <a class="code" href="../../d5/d5/cc_8h.html#a78">MODIFIED_WRITE_DISABLED</a>) &amp;&amp;
01317                 (NewSectionSize.QuadPart &gt; <a class="code" href="../../d5/d5/cc_8h.html#a46">BEGIN_BCB_LIST_ARRAY</a>)) {
01318 
01319                 SizeToAllocate *= 2;
01320                 CreateBcbListHeads = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01321             }
01322 
01323             <span class="comment">//</span>
01324             <span class="comment">//  Handle the boundary case by giving the proto-level a</span>
01325             <span class="comment">//  reference count.  This will allow us to simply push it</span>
01326             <span class="comment">//  in the expansion case.  In practice, due to pool granularity</span>
01327             <span class="comment">//  this will not change the amount of space allocated</span>
01328             <span class="comment">//</span>
01329 
01330             <span class="keywordflow">if</span> (NewSize == <a class="code" href="../../d5/d5/cc_8h.html#a39">VACB_LEVEL_BLOCK_SIZE</a>) {
01331 
01332                 SizeToAllocate += <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html">VACB_LEVEL_REFERENCE</a>);
01333                 CreateReference = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01334             }
01335         }
01336 
01337         NewAddresses = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, SizeToAllocate, 'pVcC' );
01338         <span class="keywordflow">if</span> (NewAddresses == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01339             SharedCacheMap-&gt;Status = STATUS_INSUFFICIENT_RESOURCES;
01340             <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INSUFFICIENT_RESOURCES );
01341         }
01342     }
01343 
01344     <span class="comment">//</span>
01345     <span class="comment">//  Zero out the Vacb array and the trailing reference counts.</span>
01346     <span class="comment">//</span>
01347 
01348     RtlZeroMemory( (PCHAR)NewAddresses, NewSize );
01349 
01350     <span class="keywordflow">if</span> (CreateReference) {
01351 
01352         SizeToAllocate -= <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html">VACB_LEVEL_REFERENCE</a>);
01353         RtlZeroMemory( (PCHAR)NewAddresses + SizeToAllocate, <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html">VACB_LEVEL_REFERENCE</a>) );
01354     }
01355 
01356     <span class="comment">//</span>
01357     <span class="comment">//  Loop to insert the Bcb listheads (if any) in the *descending* order</span>
01358     <span class="comment">//  Bcb list.</span>
01359     <span class="comment">//</span>
01360 
01361     <span class="keywordflow">if</span> (CreateBcbListHeads) {
01362 
01363         <span class="keywordflow">for</span> (BcbListHead = (PLIST_ENTRY)((PCHAR)NewAddresses + NewSize);
01364              BcbListHead &lt; (PLIST_ENTRY)((PCHAR)NewAddresses + SizeToAllocate);
01365              BcbListHead++) {
01366 
01367             InsertHeadList( &amp;SharedCacheMap-&gt;BcbList, BcbListHead );
01368         }
01369     }
01370 
01371     SharedCacheMap-&gt;Vacbs = NewAddresses;
01372     SharedCacheMap-&gt;SectionSize = NewSectionSize;
01373 }
01374 
01375 
01376 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01377"></a><a class="code" href="../../d5/d3/vacbsup_8c.html#a21">01377</a> <a class="code" href="../../d5/d3/vacbsup_8c.html#a21">CcExtendVacbArray</a> (
01378     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap,
01379     IN LARGE_INTEGER NewSectionSize
01380     )
01381 
01382 <span class="comment">/*++</span>
01383 <span class="comment"></span>
01384 <span class="comment">Routine Description:</span>
01385 <span class="comment"></span>
01386 <span class="comment">    This routine must be called any time the section for a shared cache</span>
01387 <span class="comment">    map is extended, in order to extend the Vacb array (if necessary).</span>
01388 <span class="comment"></span>
01389 <span class="comment">Arguments:</span>
01390 <span class="comment"></span>
01391 <span class="comment">    SharedCacheMap - Supplies the shared cache map for which the array is</span>
01392 <span class="comment">                     to be created.</span>
01393 <span class="comment"></span>
01394 <span class="comment">    NewSectionSize - Supplies the new size of the section which must be</span>
01395 <span class="comment">                     covered by the Vacb array.</span>
01396 <span class="comment"></span>
01397 <span class="comment">Return Value:</span>
01398 <span class="comment"></span>
01399 <span class="comment">    None.</span>
01400 <span class="comment"></span>
01401 <span class="comment">--*/</span>
01402 
01403 {
01404     KIRQL OldIrql;
01405     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *OldAddresses;
01406     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *NewAddresses;
01407     ULONG OldSize;
01408     ULONG NewSize, SizeToAllocate;
01409     LARGE_INTEGER NextLevelSize;
01410     BOOLEAN GrowingBcbListHeads = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, CreateReference = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01411 
01412     <span class="comment">//</span>
01413     <span class="comment">//  The following limit is greater than the MM limit</span>
01414     <span class="comment">//  (i.e., MM actually only supports even smaller sections).</span>
01415     <span class="comment">//  We have to reject the sign bit, and testing the high byte</span>
01416     <span class="comment">//  for nonzero will surely only catch errors.</span>
01417     <span class="comment">//</span>
01418 
01419     <span class="keywordflow">if</span> (NewSectionSize.HighPart &amp; ~(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) {
01420         <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>(STATUS_SECTION_TOO_BIG);
01421     }
01422 
01423     <span class="comment">//</span>
01424     <span class="comment">//  See if we will be growing the Bcb ListHeads, so we can take out the</span>
01425     <span class="comment">//  master lock if so.</span>
01426     <span class="comment">//</span>
01427 
01428     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;Flags, <a class="code" href="../../d5/d5/cc_8h.html#a78">MODIFIED_WRITE_DISABLED</a>) &amp;&amp;
01429         (NewSectionSize.QuadPart &gt; <a class="code" href="../../d5/d5/cc_8h.html#a46">BEGIN_BCB_LIST_ARRAY</a>)) {
01430 
01431         GrowingBcbListHeads = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01432     }
01433 
01434     <span class="comment">//</span>
01435     <span class="comment">//  Is there any work to do?</span>
01436     <span class="comment">//</span>
01437 
01438     <span class="keywordflow">if</span> (NewSectionSize.QuadPart &gt; SharedCacheMap-&gt;SectionSize.QuadPart) {
01439 
01440         <span class="comment">//</span>
01441         <span class="comment">//  Handle the growth of the first level here.</span>
01442         <span class="comment">//</span>
01443 
01444         <span class="keywordflow">if</span> (SharedCacheMap-&gt;SectionSize.QuadPart &lt; <a class="code" href="../../d5/d5/cc_8h.html#a41">VACB_SIZE_OF_FIRST_LEVEL</a>) {
01445 
01446             NextLevelSize = NewSectionSize;
01447 
01448             <span class="comment">//</span>
01449             <span class="comment">//  Limit the growth of this level</span>
01450             <span class="comment">//</span>
01451 
01452             <span class="keywordflow">if</span> (NextLevelSize.QuadPart &gt;= <a class="code" href="../../d5/d5/cc_8h.html#a41">VACB_SIZE_OF_FIRST_LEVEL</a>) {
01453                 NextLevelSize.QuadPart = <a class="code" href="../../d5/d5/cc_8h.html#a41">VACB_SIZE_OF_FIRST_LEVEL</a>;
01454                 CreateReference = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01455             }
01456 
01457             <span class="comment">//</span>
01458             <span class="comment">//  N.B.: SizeOfVacbArray only calculates the size of the VACB</span>
01459             <span class="comment">//  pointer block.  We must adjust for Bcb listheads and the</span>
01460             <span class="comment">//  multilevel reference count.</span>
01461             <span class="comment">//</span>
01462 
01463             NewSize = SizeToAllocate = <a class="code" href="../../d5/d3/vacbsup_8c.html#a4">SizeOfVacbArray</a>(NextLevelSize);
01464             OldSize = <a class="code" href="../../d5/d3/vacbsup_8c.html#a4">SizeOfVacbArray</a>(SharedCacheMap-&gt;SectionSize);
01465 
01466             <span class="comment">//</span>
01467             <span class="comment">//  Only do something if the size is growing.</span>
01468             <span class="comment">//</span>
01469 
01470             <span class="keywordflow">if</span> (NewSize &gt; OldSize) {
01471 
01472                 <span class="comment">//</span>
01473                 <span class="comment">//  Does this stream get a Bcb Listhead array?</span>
01474                 <span class="comment">//</span>
01475 
01476                 <span class="keywordflow">if</span> (GrowingBcbListHeads) {
01477                     SizeToAllocate *= 2;
01478                 }
01479 
01480                 <span class="comment">//</span>
01481                 <span class="comment">//  Do we need space for the reference count?</span>
01482                 <span class="comment">//</span>
01483 
01484                 <span class="keywordflow">if</span> (CreateReference) {
01485                     SizeToAllocate += <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html">VACB_LEVEL_REFERENCE</a>);
01486                 }
01487 
01488                 NewAddresses = <a class="code" href="../../d1/d8/fsrtl_8h.html#a37">FsRtlAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, SizeToAllocate, 'pVcC' );
01489 
01490                 <span class="comment">//</span>
01491                 <span class="comment">//  See if we will be growing the Bcb ListHeads, so we can take out the</span>
01492                 <span class="comment">//  master lock if so.</span>
01493                 <span class="comment">//</span>
01494 
01495                 <span class="keywordflow">if</span> (GrowingBcbListHeads) {
01496 
01497                     ExAcquireSpinLock( &amp;SharedCacheMap-&gt;BcbSpinLock, &amp;OldIrql );
01498                     <a class="code" href="../../d5/d5/cc_8h.html#a6">CcAcquireVacbLockAtDpcLevel</a>();
01499 
01500                 } <span class="keywordflow">else</span> {
01501 
01502                     <span class="comment">//</span>
01503                     <span class="comment">//  Acquire the spin lock to serialize with anyone who might like</span>
01504                     <span class="comment">//  to "steal" one of the mappings we are going to move.</span>
01505                     <span class="comment">//</span>
01506 
01507                     <a class="code" href="../../d5/d5/cc_8h.html#a4">CcAcquireVacbLock</a>( &amp;OldIrql );
01508                 }
01509 
01510                 OldAddresses = SharedCacheMap-&gt;Vacbs;
01511                 <span class="keywordflow">if</span> (OldAddresses != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01512                     RtlCopyMemory( NewAddresses, OldAddresses, OldSize );
01513                 } <span class="keywordflow">else</span> {
01514                     OldSize = 0;
01515                 }
01516 
01517                 RtlZeroMemory( (PCHAR)NewAddresses + OldSize, NewSize - OldSize );
01518 
01519                 <span class="keywordflow">if</span> (CreateReference) {
01520 
01521                     SizeToAllocate -= <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html">VACB_LEVEL_REFERENCE</a>);
01522                     RtlZeroMemory( (PCHAR)NewAddresses + SizeToAllocate, <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html">VACB_LEVEL_REFERENCE</a>) );
01523                 }
01524 
01525                 <span class="comment">//</span>
01526                 <span class="comment">//  See if we have to initialize Bcb Listheads.</span>
01527                 <span class="comment">//</span>
01528 
01529                 <span class="keywordflow">if</span> (GrowingBcbListHeads) {
01530 
01531                     LARGE_INTEGER <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
01532                     PLIST_ENTRY BcbListHeadNew, TempEntry;
01533 
01534                     <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.QuadPart = 0;
01535                     BcbListHeadNew = (PLIST_ENTRY)((PCHAR)NewAddresses + NewSize );
01536 
01537                     <span class="comment">//</span>
01538                     <span class="comment">//  Handle case where the old array had Bcb Listheads.</span>
01539                     <span class="comment">//</span>
01540 
01541                     <span class="keywordflow">if</span> ((SharedCacheMap-&gt;SectionSize.QuadPart &gt; <a class="code" href="../../d5/d5/cc_8h.html#a46">BEGIN_BCB_LIST_ARRAY</a>) &amp;&amp;
01542                         (OldAddresses != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
01543 
01544                         PLIST_ENTRY BcbListHeadOld;
01545 
01546                         BcbListHeadOld = (PLIST_ENTRY)((PCHAR)OldAddresses + OldSize);
01547 
01548                         <span class="comment">//</span>
01549                         <span class="comment">//  Loop to remove each old listhead and insert the new one</span>
01550                         <span class="comment">//  in its place.</span>
01551                         <span class="comment">//</span>
01552 
01553                         <span class="keywordflow">do</span> {
01554                             TempEntry = BcbListHeadOld-&gt;Flink;
01555                             RemoveEntryList( BcbListHeadOld );
01556                             InsertTailList( TempEntry, BcbListHeadNew );
01557                             <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.QuadPart += <a class="code" href="../../d5/d5/cc_8h.html#a47">SIZE_PER_BCB_LIST</a>;
01558                             BcbListHeadOld += 1;
01559                             BcbListHeadNew += 1;
01560                         } <span class="keywordflow">while</span> (<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.QuadPart &lt; SharedCacheMap-&gt;SectionSize.QuadPart);
01561 
01562                     <span class="comment">//</span>
01563                     <span class="comment">//  Otherwise, handle the case where we are adding Bcb</span>
01564                     <span class="comment">//  Listheads.</span>
01565                     <span class="comment">//</span>
01566 
01567                     } <span class="keywordflow">else</span> {
01568 
01569                         TempEntry = SharedCacheMap-&gt;BcbList.Blink;
01570 
01571                         <span class="comment">//</span>
01572                         <span class="comment">//  Loop through any/all Bcbs to insert the new listheads.</span>
01573                         <span class="comment">//</span>
01574 
01575                         <span class="keywordflow">while</span> (TempEntry != &amp;SharedCacheMap-&gt;BcbList) {
01576 
01577                             <span class="comment">//</span>
01578                             <span class="comment">//  Sit on this Bcb until we have inserted all listheads</span>
01579                             <span class="comment">//  that go before it.</span>
01580                             <span class="comment">//</span>
01581 
01582                             <span class="keywordflow">while</span> (<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.QuadPart &lt;= ((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)CONTAINING_RECORD(TempEntry, <a class="code" href="../../d4/d3/struct__BCB.html">BCB</a>, BcbLinks))-&gt;FileOffset.QuadPart) {
01583 
01584                                 InsertHeadList(TempEntry, BcbListHeadNew);
01585                                 <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.QuadPart += <a class="code" href="../../d5/d5/cc_8h.html#a47">SIZE_PER_BCB_LIST</a>;
01586                                 BcbListHeadNew += 1;
01587                             }
01588                             TempEntry = TempEntry-&gt;Blink;
01589                         }
01590                     }
01591 
01592                     <span class="comment">//</span>
01593                     <span class="comment">//  Now insert the rest of the new listhead entries that were</span>
01594                     <span class="comment">//  not finished in either loop above.</span>
01595                     <span class="comment">//</span>
01596 
01597                     <span class="keywordflow">while</span> (<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.QuadPart &lt; NextLevelSize.QuadPart) {
01598 
01599                         InsertHeadList(&amp;SharedCacheMap-&gt;BcbList, BcbListHeadNew);
01600                         <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.QuadPart += <a class="code" href="../../d5/d5/cc_8h.html#a47">SIZE_PER_BCB_LIST</a>;
01601                         BcbListHeadNew += 1;
01602                     }
01603                 }
01604 
01605                 <span class="comment">//</span>
01606                 <span class="comment">//  These two fields must be changed while still holding the spinlock.</span>
01607                 <span class="comment">//</span>
01608 
01609                 SharedCacheMap-&gt;Vacbs = NewAddresses;
01610                 SharedCacheMap-&gt;SectionSize = NextLevelSize;
01611 
01612                 <span class="comment">//</span>
01613                 <span class="comment">//  Now we can free the spinlocks ahead of freeing pool.</span>
01614                 <span class="comment">//</span>
01615 
01616                 <span class="keywordflow">if</span> (GrowingBcbListHeads) {
01617                     <a class="code" href="../../d5/d5/cc_8h.html#a7">CcReleaseVacbLockFromDpcLevel</a>();
01618                     ExReleaseSpinLock( &amp;SharedCacheMap-&gt;BcbSpinLock, OldIrql );
01619                 } <span class="keywordflow">else</span> {
01620                     <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( OldIrql );
01621                 }
01622 
01623                 <span class="keywordflow">if</span> ((OldAddresses != &amp;SharedCacheMap-&gt;InitialVacbs[0]) &amp;&amp;
01624                     (OldAddresses != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
01625                     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( OldAddresses );
01626                 }
01627             }
01628 
01629             <span class="comment">//</span>
01630             <span class="comment">//  Make sure SectionSize gets updated.  It is ok to fall through here</span>
01631             <span class="comment">//  without a spinlock, so long as either Vacbs was not changed, or it</span>
01632             <span class="comment">//  was changed together with SectionSize under the spinlock(s) above.</span>
01633             <span class="comment">//</span>
01634 
01635             SharedCacheMap-&gt;SectionSize = NextLevelSize;
01636         }
01637 
01638         <span class="comment">//</span>
01639         <span class="comment">//  Handle extends up to and within multi-level Vacb arrays here.  This is fairly simple.</span>
01640         <span class="comment">//  If no additional Vacb levels are required, then there is no work to do, otherwise</span>
01641         <span class="comment">//  we just have to push the root one or more levels linked through the first pointer</span>
01642         <span class="comment">//  in the new root(s).</span>
01643         <span class="comment">//</span>
01644 
01645         <span class="keywordflow">if</span> (NewSectionSize.QuadPart &gt; SharedCacheMap-&gt;SectionSize.QuadPart) {
01646 
01647             <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *NextVacbArray;
01648             ULONG NewLevel;
01649             ULONG Level = 1;
01650             ULONG Shift = <a class="code" href="../../d4/d2/cache_8h.html#a1">VACB_OFFSET_SHIFT</a> + <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
01651 
01652             <span class="comment">//</span>
01653             <span class="comment">//  Loop to calculate how many levels we currently have.</span>
01654             <span class="comment">//</span>
01655 
01656             <span class="keywordflow">while</span> (SharedCacheMap-&gt;SectionSize.QuadPart &gt; ((LONGLONG)1 &lt;&lt; Shift)) {
01657 
01658                 Level += 1;
01659                 Shift += <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
01660             }
01661 
01662             NewLevel = Level;
01663 
01664             <span class="comment">//</span>
01665             <span class="comment">//  Loop to calculate how many levels we need.</span>
01666             <span class="comment">//</span>
01667 
01668             <span class="keywordflow">while</span> (((NewSectionSize.QuadPart - 1) &gt;&gt; Shift) != 0) {
01669 
01670                 NewLevel += 1;
01671                 Shift += <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
01672             }
01673 
01674             <span class="comment">//</span>
01675             <span class="comment">//  Now see if we have any work to do.</span>
01676             <span class="comment">//</span>
01677 
01678             <span class="keywordflow">if</span> (NewLevel &gt; Level) {
01679 
01680                 <span class="comment">//</span>
01681                 <span class="comment">//  Remember the maximum level ever seen (which is actually NewLevel + 1).</span>
01682                 <span class="comment">//</span>
01683 
01684                 <span class="keywordflow">if</span> (NewLevel &gt;= <a class="code" href="../../d5/d2/cachedat_8c.html#a23">CcMaxVacbLevelsSeen</a>) {
01685                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(NewLevel &lt;= <a class="code" href="../../d5/d5/cc_8h.html#a42">VACB_NUMBER_OF_LEVELS</a>);
01686                     <a class="code" href="../../d5/d2/cachedat_8c.html#a23">CcMaxVacbLevelsSeen</a> = NewLevel + 1;
01687                 }
01688 
01689                 <span class="comment">//</span>
01690                 <span class="comment">//  Raise if we cannot preallocate enough buffers.</span>
01691                 <span class="comment">//</span>
01692 
01693                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d3/vacbsup_8c.html#a23">CcPrefillVacbLevelZone</a>( NewLevel - Level, &amp;OldIrql, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> )) {
01694 
01695                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INSUFFICIENT_RESOURCES );
01696                 }
01697 
01698                 <span class="comment">//</span>
01699                 <span class="comment">//  Now if the current Level of the file is 1, we have not been maintaining</span>
01700                 <span class="comment">//  a reference count, so we have to calculate it before pushing.  In the</span>
01701                 <span class="comment">//  boundary case we have made sure that the reference space is avaliable.</span>
01702                 <span class="comment">//</span>
01703 
01704                 <span class="keywordflow">if</span> (Level == 1) {
01705 
01706                     <span class="comment">//</span>
01707                     <span class="comment">//  We know this is always a leaf-like level right now.</span>
01708                     <span class="comment">//</span>
01709 
01710                     <a class="code" href="../../d5/d3/vacbsup_8c.html#a8">CcCalculateVacbLevelLockCount</a>( SharedCacheMap, SharedCacheMap-&gt;Vacbs, 0 );
01711                 }
01712 
01713                 <span class="comment">//</span>
01714                 <span class="comment">//  Finally, if there are any active pointers in the first level, then we</span>
01715                 <span class="comment">//  have to create new levels by adding a new root enough times to create</span>
01716                 <span class="comment">//  additional levels.  On the other hand, if the pointer count in the top</span>
01717                 <span class="comment">//  level is zero, then we must not do any pushes, because we never allow</span>
01718                 <span class="comment">//  empty leaves!</span>
01719                 <span class="comment">//</span>
01720 
01721                 <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a209">IsVacbLevelReferenced</a>( SharedCacheMap, SharedCacheMap-&gt;Vacbs, Level - 1 )) {
01722 
01723                     <span class="keywordflow">while</span> (NewLevel &gt; Level++) {
01724 
01725                         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d5/d2/cachedat_8c.html#a24">CcVacbLevelEntries</a> != 0);
01726                         NextVacbArray = <a class="code" href="../../d5/d5/cc_8h.html#a206">CcAllocateVacbLevel</a>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
01727 
01728                         NextVacbArray[0] = (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a>)SharedCacheMap-&gt;Vacbs;
01729                         <a class="code" href="../../d5/d3/vacbsup_8c.html#a12">ReferenceVacbLevel</a>( SharedCacheMap, NextVacbArray, Level, 1, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01730 
01731                         SharedCacheMap-&gt;Vacbs = NextVacbArray;
01732                     }
01733 
01734                 } <span class="keywordflow">else</span> {
01735 
01736                     <span class="comment">//</span>
01737                     <span class="comment">//  We are now possesed of the additional problem that this level has no</span>
01738                     <span class="comment">//  references but may have Bcb listheads due to the boundary case where</span>
01739                     <span class="comment">//  we have expanded up to the multilevel Vacbs above.  This level can't</span>
01740                     <span class="comment">//  remain at the root and needs to be destroyed.  What we need to do is</span>
01741                     <span class="comment">//  replace it with one of our prefilled (non Bcb) levels and unlink the</span>
01742                     <span class="comment">//  Bcb listheads in the old one.</span>
01743                     <span class="comment">//</span>
01744 
01745                     <span class="keywordflow">if</span> (Level == 1 &amp;&amp; <a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;Flags, <a class="code" href="../../d5/d5/cc_8h.html#a78">MODIFIED_WRITE_DISABLED</a>)) {
01746 
01747                         PLIST_ENTRY PredecessorListHead, SuccessorListHead;
01748 
01749                         NextVacbArray = SharedCacheMap-&gt;Vacbs;
01750                         SharedCacheMap-&gt;Vacbs = <a class="code" href="../../d5/d5/cc_8h.html#a206">CcAllocateVacbLevel</a>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
01751 
01752                         PredecessorListHead = ((PLIST_ENTRY)((PCHAR)NextVacbArray + <a class="code" href="../../d5/d5/cc_8h.html#a39">VACB_LEVEL_BLOCK_SIZE</a>))-&gt;Flink;
01753                         SuccessorListHead = ((PLIST_ENTRY)((PCHAR)NextVacbArray + (<a class="code" href="../../d5/d5/cc_8h.html#a39">VACB_LEVEL_BLOCK_SIZE</a> * 2) - <span class="keyword">sizeof</span>(LIST_ENTRY)))-&gt;Blink;
01754                         PredecessorListHead-&gt;Blink = SuccessorListHead;
01755                         SuccessorListHead-&gt;Flink = PredecessorListHead;
01756 
01757                         <a class="code" href="../../d5/d5/cc_8h.html#a207">CcDeallocateVacbLevel</a>( NextVacbArray, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
01758                     }
01759                 }
01760 
01761                 <span class="comment">//</span>
01762                 <span class="comment">//  These two fields (Vacbs and SectionSize) must be changed while still</span>
01763                 <span class="comment">//  holding the spinlock.</span>
01764                 <span class="comment">//</span>
01765 
01766                 SharedCacheMap-&gt;SectionSize = NewSectionSize;
01767                 <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( OldIrql );
01768             }
01769 
01770             <span class="comment">//</span>
01771             <span class="comment">//  Make sure SectionSize gets updated.  It is ok to fall through here</span>
01772             <span class="comment">//  without a spinlock, so long as either Vacbs was not changed, or it</span>
01773             <span class="comment">//  was changed together with SectionSize under the spinlock(s) above.</span>
01774             <span class="comment">//</span>
01775 
01776             SharedCacheMap-&gt;SectionSize = NewSectionSize;
01777         }
01778     }
01779 }
01780 
01781 
01782 BOOLEAN
01783 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l01784"></a><a class="code" href="../../d5/d3/vacbsup_8c.html#a22">01784</a> <a class="code" href="../../d5/d3/vacbsup_8c.html#a22">CcUnmapVacbArray</a> (
01785     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap,
01786     IN PLARGE_INTEGER FileOffset OPTIONAL,
01787     IN ULONG Length,
01788     IN BOOLEAN UnmapBehind
01789     )
01790 
01791 <span class="comment">/*++</span>
01792 <span class="comment"></span>
01793 <span class="comment">Routine Description:</span>
01794 <span class="comment"></span>
01795 <span class="comment">    This routine must be called to do any unmapping and associated</span>
01796 <span class="comment">    cleanup for a shared cache map, just before it is deleted.</span>
01797 <span class="comment"></span>
01798 <span class="comment">Arguments:</span>
01799 <span class="comment"></span>
01800 <span class="comment">    SharedCacheMap - Supplies a pointer to the shared cache map</span>
01801 <span class="comment">                     which is about to be deleted.</span>
01802 <span class="comment"></span>
01803 <span class="comment">    FileOffset - If supplied, only unmap the specified offset and length</span>
01804 <span class="comment"></span>
01805 <span class="comment">    Length - Completes range to unmap if FileOffset specified.  If FileOffset</span>
01806 <span class="comment">             is specified, Length of 0 means unmap to the end of the section.</span>
01807 <span class="comment"></span>
01808 <span class="comment">    UnmapBehind - If this is a result of our unmap behind logic</span>
01809 <span class="comment"></span>
01810 <span class="comment">Return Value:</span>
01811 <span class="comment"></span>
01812 <span class="comment">    FALSE -- if an the unmap was not done due to an active vacb</span>
01813 <span class="comment">    TRUE -- if the unmap was done</span>
01814 <span class="comment"></span>
01815 <span class="comment">--*/</span>
01816 
01817 {
01818     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> Vacb;
01819     KIRQL OldIrql;
01820     LARGE_INTEGER StartingFileOffset = {0,0};
01821     LARGE_INTEGER EndingFileOffset = SharedCacheMap-&gt;SectionSize;
01822 
01823     <span class="comment">//</span>
01824     <span class="comment">//  We could be just cleaning up for error recovery.</span>
01825     <span class="comment">//</span>
01826 
01827     <span class="keywordflow">if</span> (SharedCacheMap-&gt;Vacbs == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01828         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01829     }
01830 
01831     <span class="comment">//</span>
01832     <span class="comment">//  See if a range was specified. Align it to the VACB boundaries so it</span>
01833     <span class="comment">//  works in the loop below  </span>
01834     <span class="comment">//</span>
01835 
01836     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(FileOffset)) {
01837         StartingFileOffset.QuadPart = ((FileOffset-&gt;QuadPart) &amp; (~((LONGLONG)<a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - 1)));
01838         <span class="keywordflow">if</span> (Length != 0) {
01839 
01840             EndingFileOffset.QuadPart = FileOffset-&gt;QuadPart + Length;
01841                 
01842         }
01843     }
01844 
01845     <span class="comment">//</span>
01846     <span class="comment">//  Acquire the spin lock to</span>
01847     <span class="comment">//</span>
01848 
01849     <a class="code" href="../../d5/d5/cc_8h.html#a4">CcAcquireVacbLock</a>( &amp;OldIrql );
01850 
01851     <span class="keywordflow">while</span> (StartingFileOffset.QuadPart &lt; EndingFileOffset.QuadPart) {
01852 
01853         <span class="comment">//</span>
01854         <span class="comment">//  Note that the caller with an explicit range may be off the</span>
01855         <span class="comment">//  end of the section (example CcPurgeCacheSection for cache</span>
01856         <span class="comment">//  coherency).  That is the reason for the first part of the</span>
01857         <span class="comment">//  test below.</span>
01858         <span class="comment">//</span>
01859         <span class="comment">//  Check the next cell once without the spin lock, it probably will</span>
01860         <span class="comment">//  not change, but we will handle it if it does not.</span>
01861         <span class="comment">//</span>
01862 
01863         <span class="keywordflow">if</span> ((StartingFileOffset.QuadPart &lt; SharedCacheMap-&gt;SectionSize.QuadPart) &amp;&amp;
01864             ((Vacb = <a class="code" href="../../d5/d3/vacbsup_8c.html#a1">GetVacb</a>( SharedCacheMap, StartingFileOffset )) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
01865 
01866             <span class="comment">//</span>
01867             <span class="comment">//  Return here if we are unlucky and see an active</span>
01868             <span class="comment">//  Vacb.  It could be Purge calling, and the Lazy Writer</span>
01869             <span class="comment">//  may have done a CcGetVirtualAddressIfMapped!</span>
01870             <span class="comment">//</span>
01871 
01872             <span class="keywordflow">if</span> (Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o4">Overlay</a>.ActiveCount != 0) {
01873 
01874                 <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( OldIrql );
01875                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01876             }
01877 
01878             <span class="comment">//</span>
01879             <span class="comment">//  Unlink it from the other SharedCacheMap, so the other</span>
01880             <span class="comment">//  guy will not try to use it when we free the spin lock.</span>
01881             <span class="comment">//</span>
01882 
01883             <a class="code" href="../../d5/d3/vacbsup_8c.html#a11">SetVacb</a>( SharedCacheMap, StartingFileOffset, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01884             Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o1">SharedCacheMap</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01885 
01886             <span class="comment">//</span>
01887             <span class="comment">//  Increment the open count so that no one else will</span>
01888             <span class="comment">//  try to unmap or reuse until we are done.</span>
01889             <span class="comment">//</span>
01890 
01891             Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o4">Overlay</a>.ActiveCount += 1;
01892 
01893             <span class="comment">//</span>
01894             <span class="comment">//  Release the spin lock.</span>
01895             <span class="comment">//</span>
01896 
01897             <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( OldIrql );
01898 
01899             <span class="comment">//</span>
01900             <span class="comment">//  Unmap and free it if we really got it above.</span>
01901             <span class="comment">//</span>
01902 
01903             <a class="code" href="../../d5/d3/vacbsup_8c.html#a6">CcUnmapVacb</a>( Vacb, SharedCacheMap, UnmapBehind );
01904 
01905             <span class="comment">//</span>
01906             <span class="comment">//  Reacquire the spin lock so that we can decrment the count.</span>
01907             <span class="comment">//</span>
01908 
01909             <a class="code" href="../../d5/d5/cc_8h.html#a4">CcAcquireVacbLock</a>( &amp;OldIrql );
01910             Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o4">Overlay</a>.ActiveCount -= 1;
01911 
01912             <span class="comment">//</span>
01913             <span class="comment">//  Place this VACB at the head of the LRU</span>
01914             <span class="comment">//</span>
01915 
01916             <a class="code" href="../../d5/d3/vacbsup_8c.html#a2">CcMoveVacbToReuseHead</a>( Vacb );
01917         }
01918 
01919         StartingFileOffset.QuadPart = StartingFileOffset.QuadPart + <a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a>;
01920     }
01921 
01922     <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( OldIrql );
01923 
01924     <a class="code" href="../../d5/d5/cc_8h.html#a205">CcDrainVacbLevelZone</a>();
01925 
01926     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01927 }
01928 
01929 
01930 ULONG
<a name="l01931"></a><a class="code" href="../../d5/d3/vacbsup_8c.html#a23">01931</a> <a class="code" href="../../d5/d3/vacbsup_8c.html#a23">CcPrefillVacbLevelZone</a> (
01932     IN ULONG NumberNeeded,
01933     OUT PKIRQL OldIrql,
01934     IN ULONG NeedBcbListHeads
01935     )
01936 
01937 <span class="comment">/*++</span>
01938 <span class="comment"></span>
01939 <span class="comment">Routine Description:</span>
01940 <span class="comment"></span>
01941 <span class="comment">    This routine may be called to prefill the VacbLevelZone with the number of</span>
01942 <span class="comment">    entries required, and return with CcVacbSpinLock acquired.  This approach is</span>
01943 <span class="comment">    taken so that the pool allocations and RtlZeroMemory calls can occur without</span>
01944 <span class="comment">    holding any spinlock, yet the caller may proceed to peform a single indivisible</span>
01945 <span class="comment">    operation without error handling, since there is a guaranteed minimum number of</span>
01946 <span class="comment">    entries in the zone.</span>
01947 <span class="comment"></span>
01948 <span class="comment">Arguments:</span>
01949 <span class="comment"></span>
01950 <span class="comment">    NumberNeeded - Number of VacbLevel entries needed, not counting the possible</span>
01951 <span class="comment">                   one with Bcb listheads.</span>
01952 <span class="comment"></span>
01953 <span class="comment">    OldIrql = supplies a pointer to where OldIrql should be returned upon acquiring</span>
01954 <span class="comment">              the spinlock.</span>
01955 <span class="comment"></span>
01956 <span class="comment">    NeedBcbListHeads - Supplies true if a level is also needed which contains listheads.</span>
01957 <span class="comment"></span>
01958 <span class="comment">Return Value:</span>
01959 <span class="comment"></span>
01960 <span class="comment">    FALSE if the buffers could not be preallocated, TRUE otherwise.</span>
01961 <span class="comment"></span>
01962 <span class="comment">Environment:</span>
01963 <span class="comment"></span>
01964 <span class="comment">    No spinlocks should be held upon entry.</span>
01965 <span class="comment"></span>
01966 <span class="comment">--*/</span>
01967 
01968 {
01969     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *NextVacbArray;
01970 
01971     <a class="code" href="../../d5/d5/cc_8h.html#a4">CcAcquireVacbLock</a>( OldIrql );
01972 
01973     <span class="comment">//</span>
01974     <span class="comment">//  Loop until there is enough entries, else raise...</span>
01975     <span class="comment">//</span>
01976 
01977     <span class="keywordflow">while</span> ((NumberNeeded &gt; <a class="code" href="../../d5/d2/cachedat_8c.html#a24">CcVacbLevelEntries</a>) ||
01978            (NeedBcbListHeads &amp;&amp; (<a class="code" href="../../d5/d2/cachedat_8c.html#a27">CcVacbLevelWithBcbsFreeList</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>))) {
01979 
01980 
01981         <span class="comment">//</span>
01982         <span class="comment">//  Else release the spinlock so we can do the allocate/zero.</span>
01983         <span class="comment">//</span>
01984 
01985         <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( *OldIrql );
01986 
01987         <span class="comment">//</span>
01988         <span class="comment">//  First handle the case where we need a VacbListHead with Bcb Listheads.</span>
01989         <span class="comment">//  The pointer test is unsafe but see below.</span>
01990         <span class="comment">//</span>
01991 
01992         <span class="keywordflow">if</span> (NeedBcbListHeads &amp;&amp; (<a class="code" href="../../d5/d2/cachedat_8c.html#a27">CcVacbLevelWithBcbsFreeList</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
01993 
01994             <span class="comment">//</span>
01995             <span class="comment">//  Allocate and initialize the Vacb block for this level, and store its pointer</span>
01996             <span class="comment">//  back into our parent.  We do not zero the listhead area.</span>
01997             <span class="comment">//</span>
01998 
01999             NextVacbArray =
02000             (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *)<a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, (<a class="code" href="../../d5/d5/cc_8h.html#a39">VACB_LEVEL_BLOCK_SIZE</a> * 2) + <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html">VACB_LEVEL_REFERENCE</a>), 'lVcC' );
02001 
02002             <span class="keywordflow">if</span> (NextVacbArray == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02003                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02004             }
02005 
02006             RtlZeroMemory( (PCHAR)NextVacbArray, <a class="code" href="../../d5/d5/cc_8h.html#a39">VACB_LEVEL_BLOCK_SIZE</a> );
02007             RtlZeroMemory( (PCHAR)NextVacbArray + (<a class="code" href="../../d5/d5/cc_8h.html#a39">VACB_LEVEL_BLOCK_SIZE</a> * 2), <span class="keyword">sizeof</span>(<a class="code" href="../../d5/d5/cc_8h.html#a95">VACB_LEVEL_REFERENCE</a>) );
02008 
02009             <a class="code" href="../../d5/d5/cc_8h.html#a4">CcAcquireVacbLock</a>( OldIrql );
02010 
02011             NextVacbArray[0] = (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a>)<a class="code" href="../../d5/d2/cachedat_8c.html#a27">CcVacbLevelWithBcbsFreeList</a>;
02012             <a class="code" href="../../d5/d2/cachedat_8c.html#a27">CcVacbLevelWithBcbsFreeList</a> = NextVacbArray;
02013             <a class="code" href="../../d5/d2/cachedat_8c.html#a26">CcVacbLevelWithBcbsEntries</a> += 1;
02014 
02015         } <span class="keywordflow">else</span> {
02016 
02017             <span class="comment">//</span>
02018             <span class="comment">//  Allocate and initialize the Vacb block for this level, and store its pointer</span>
02019             <span class="comment">//  back into our parent.</span>
02020             <span class="comment">//</span>
02021 
02022             NextVacbArray =
02023             (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *)<a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, <a class="code" href="../../d5/d5/cc_8h.html#a39">VACB_LEVEL_BLOCK_SIZE</a> + <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html">VACB_LEVEL_REFERENCE</a>), 'lVcC' );
02024 
02025             <span class="keywordflow">if</span> (NextVacbArray == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02026                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02027             }
02028 
02029             RtlZeroMemory( (PCHAR)NextVacbArray, <a class="code" href="../../d5/d5/cc_8h.html#a39">VACB_LEVEL_BLOCK_SIZE</a> + <span class="keyword">sizeof</span>(<a class="code" href="../../d5/d5/cc_8h.html#a95">VACB_LEVEL_REFERENCE</a>) );
02030 
02031             <a class="code" href="../../d5/d5/cc_8h.html#a4">CcAcquireVacbLock</a>( OldIrql );
02032 
02033             NextVacbArray[0] = (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a>)<a class="code" href="../../d5/d2/cachedat_8c.html#a25">CcVacbLevelFreeList</a>;
02034             <a class="code" href="../../d5/d2/cachedat_8c.html#a25">CcVacbLevelFreeList</a> = NextVacbArray;
02035             <a class="code" href="../../d5/d2/cachedat_8c.html#a24">CcVacbLevelEntries</a> += 1;
02036         }
02037     }
02038 
02039     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02040 }
02041 
02042 
02043 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02044"></a><a class="code" href="../../d5/d3/vacbsup_8c.html#a24">02044</a> <a class="code" href="../../d5/d5/cc_8h.html#a205">CcDrainVacbLevelZone</a> (
02045     )
02046 
02047 <span class="comment">/*++</span>
02048 <span class="comment"></span>
02049 <span class="comment">Routine Description:</span>
02050 <span class="comment"></span>
02051 <span class="comment">    This routine should be called any time some entries have been deallocated to</span>
02052 <span class="comment">    the VacbLevel zone, and we want to insure the zone is returned to a normal level.</span>
02053 <span class="comment"></span>
02054 <span class="comment">Arguments:</span>
02055 <span class="comment"></span>
02056 <span class="comment">Return Value:</span>
02057 <span class="comment"></span>
02058 <span class="comment">    None.</span>
02059 <span class="comment"></span>
02060 <span class="comment">Environment:</span>
02061 <span class="comment"></span>
02062 <span class="comment">    No spinlocks should be held upon entry.</span>
02063 <span class="comment"></span>
02064 <span class="comment">--*/</span>
02065 
02066 {
02067     KIRQL OldIrql;
02068     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *NextVacbArray;
02069 
02070     <span class="comment">//</span>
02071     <span class="comment">//  This is an unsafe loop to see if it looks like there is stuff to</span>
02072     <span class="comment">//  clean up.</span>
02073     <span class="comment">//</span>
02074 
02075     <span class="keywordflow">while</span> ((<a class="code" href="../../d5/d2/cachedat_8c.html#a24">CcVacbLevelEntries</a> &gt; (<a class="code" href="../../d5/d2/cachedat_8c.html#a23">CcMaxVacbLevelsSeen</a> * 4)) ||
02076            (<a class="code" href="../../d5/d2/cachedat_8c.html#a26">CcVacbLevelWithBcbsEntries</a> &gt; 2)) {
02077 
02078         <span class="comment">//</span>
02079         <span class="comment">//  Now go in and try to pick up one entry to free under a FastLock.</span>
02080         <span class="comment">//</span>
02081 
02082         NextVacbArray = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02083         <a class="code" href="../../d5/d5/cc_8h.html#a4">CcAcquireVacbLock</a>( &amp;OldIrql );
02084         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d2/cachedat_8c.html#a24">CcVacbLevelEntries</a> &gt; (<a class="code" href="../../d5/d2/cachedat_8c.html#a23">CcMaxVacbLevelsSeen</a> * 4)) {
02085             NextVacbArray = <a class="code" href="../../d5/d2/cachedat_8c.html#a25">CcVacbLevelFreeList</a>;
02086             <a class="code" href="../../d5/d2/cachedat_8c.html#a25">CcVacbLevelFreeList</a> = (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *)NextVacbArray[0];
02087             <a class="code" href="../../d5/d2/cachedat_8c.html#a24">CcVacbLevelEntries</a> -= 1;
02088         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d5/d2/cachedat_8c.html#a26">CcVacbLevelWithBcbsEntries</a> &gt; 2) {
02089             NextVacbArray = <a class="code" href="../../d5/d2/cachedat_8c.html#a27">CcVacbLevelWithBcbsFreeList</a>;
02090             <a class="code" href="../../d5/d2/cachedat_8c.html#a27">CcVacbLevelWithBcbsFreeList</a> = (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *)NextVacbArray[0];
02091             <a class="code" href="../../d5/d2/cachedat_8c.html#a26">CcVacbLevelWithBcbsEntries</a> -= 1;
02092         }
02093         <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( OldIrql );
02094 
02095         <span class="comment">//</span>
02096         <span class="comment">//  Since the loop is unsafe, we may not have gotten anything.</span>
02097         <span class="comment">//</span>
02098 
02099         <span class="keywordflow">if</span> (NextVacbArray != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02100             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(NextVacbArray);
02101         }
02102     }
02103 }
02104 
02105 
02106 PLIST_ENTRY
<a name="l02107"></a><a class="code" href="../../d5/d3/vacbsup_8c.html#a25">02107</a> <a class="code" href="../../d5/d3/vacbsup_8c.html#a25">CcGetBcbListHeadLargeOffset</a> (
02108     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap,
02109     IN LONGLONG FileOffset,
02110     IN BOOLEAN FailToSuccessor
02111     )
02112 
02113 <span class="comment">/*++</span>
02114 <span class="comment"></span>
02115 <span class="comment">Routine Description:</span>
02116 <span class="comment"></span>
02117 <span class="comment">    This routine may be called to return the Bcb listhead for the specified FileOffset.</span>
02118 <span class="comment">    It should only be called if the SectionSize is greater than VACB_SIZE_OF_FIRST_LEVEL.</span>
02119 <span class="comment"></span>
02120 <span class="comment">Arguments:</span>
02121 <span class="comment"></span>
02122 <span class="comment">    SharedCacheMap - Supplies the pointer to the SharedCacheMap for which the listhead</span>
02123 <span class="comment">                     is desired.</span>
02124 <span class="comment"></span>
02125 <span class="comment">    FileOffset - Supplies the fileOffset corresponding to the desired listhead.</span>
02126 <span class="comment"></span>
02127 <span class="comment">    FailToSuccessor - Instructs whether not finding the exact listhead should cause us to</span>
02128 <span class="comment">        return the predecessor or successor Bcb listhead.</span>
02129 <span class="comment"></span>
02130 <span class="comment">Return Value:</span>
02131 <span class="comment"></span>
02132 <span class="comment">    Returns the desired Listhead pointer.  If the desired listhead does not actually exist</span>
02133 <span class="comment">    yet, then it returns the appropriate listhead.</span>
02134 <span class="comment"></span>
02135 <span class="comment">Environment:</span>
02136 <span class="comment"></span>
02137 <span class="comment">    The BcbSpinlock should be held on entry.</span>
02138 <span class="comment"></span>
02139 <span class="comment">--*/</span>
02140 
02141 {
02142     ULONG Level, Shift;
02143     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *VacbArray, *NextVacbArray;
02144     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
02145     ULONG SavedIndexes[<a class="code" href="../../d5/d5/cc_8h.html#a42">VACB_NUMBER_OF_LEVELS</a>];
02146     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *SavedVacbArrays[<a class="code" href="../../d5/d5/cc_8h.html#a42">VACB_NUMBER_OF_LEVELS</a>];
02147     ULONG SavedLevels = 0;
02148 
02149     <span class="comment">//</span>
02150     <span class="comment">//  Initialize variables controlling our descent into the hierarchy.</span>
02151     <span class="comment">//</span>
02152 
02153     Level = 0;
02154     Shift = <a class="code" href="../../d4/d2/cache_8h.html#a1">VACB_OFFSET_SHIFT</a> + <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
02155     VacbArray = SharedCacheMap-&gt;Vacbs;
02156 
02157     <span class="comment">//</span>
02158     <span class="comment">//  Caller must have verified that we have a hierarchy, otherwise this routine</span>
02159     <span class="comment">//  would fail.</span>
02160     <span class="comment">//</span>
02161 
02162     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(SharedCacheMap-&gt;SectionSize.QuadPart &gt; <a class="code" href="../../d5/d5/cc_8h.html#a41">VACB_SIZE_OF_FIRST_LEVEL</a>);
02163 
02164     <span class="comment">//</span>
02165     <span class="comment">//  Loop to calculate how many levels we have and how much we have to</span>
02166     <span class="comment">//  shift to index into the first level.</span>
02167     <span class="comment">//</span>
02168 
02169     <span class="keywordflow">do</span> {
02170 
02171         Level += 1;
02172         Shift += <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
02173 
02174     } <span class="keywordflow">while</span> (SharedCacheMap-&gt;SectionSize.QuadPart &gt; ((LONGLONG)1 &lt;&lt; Shift));
02175 
02176     <span class="comment">//</span>
02177     <span class="comment">//  Our caller could be asking for an offset off the end of section size, so if he</span>
02178     <span class="comment">//  is actually off the size of the level, then return the main listhead.</span>
02179     <span class="comment">//</span>
02180 
02181     <span class="keywordflow">if</span> (FileOffset &gt;= ((LONGLONG)1 &lt;&lt; Shift)) {
02182         <span class="keywordflow">return</span> &amp;SharedCacheMap-&gt;BcbList;
02183     }
02184 
02185     <span class="comment">//</span>
02186     <span class="comment">//  Now descend the tree to the bottom level to get the caller's Bcb ListHead.</span>
02187     <span class="comment">//</span>
02188 
02189     Shift -= <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
02190     <span class="keywordflow">do</span> {
02191 
02192         <span class="comment">//</span>
02193         <span class="comment">//  Decrement back to the level that describes the size we are within.</span>
02194         <span class="comment">//</span>
02195 
02196         Level -= 1;
02197 
02198         <span class="comment">//</span>
02199         <span class="comment">//  Calculate the index into the Vacb block for this level.</span>
02200         <span class="comment">//</span>
02201 
02202         <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = (ULONG)(FileOffset &gt;&gt; Shift);
02203         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt;= <a class="code" href="../../d5/d5/cc_8h.html#a40">VACB_LAST_INDEX_FOR_LEVEL</a>);
02204 
02205         <span class="comment">//</span>
02206         <span class="comment">//  Get block address for next level.</span>
02207         <span class="comment">//</span>
02208 
02209         NextVacbArray = (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *)VacbArray[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>];
02210 
02211         <span class="comment">//</span>
02212         <span class="comment">//  If it is NULL then we have to go find the highest Bcb or listhead which</span>
02213         <span class="comment">//  comes before the guy we are looking for, i.e., its predecessor.</span>
02214         <span class="comment">//</span>
02215 
02216         <span class="keywordflow">if</span> (NextVacbArray == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02217 
02218             <span class="comment">//</span>
02219             <span class="comment">//  Back up to look for the highest guy earlier in this tree, i.e., the</span>
02220             <span class="comment">//  predecessor listhead.</span>
02221             <span class="comment">//</span>
02222 
02223             <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
02224 
02225                 <span class="comment">//</span>
02226                 <span class="comment">//  Scan, if we can, in the current array for a non-null index.</span>
02227                 <span class="comment">//</span>
02228 
02229                 <span class="keywordflow">if</span> (FailToSuccessor) {
02230 
02231                     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> != <a class="code" href="../../d5/d5/cc_8h.html#a40">VACB_LAST_INDEX_FOR_LEVEL</a>) {
02232 
02233                         <span class="keywordflow">while</span> ((<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> != <a class="code" href="../../d5/d5/cc_8h.html#a40">VACB_LAST_INDEX_FOR_LEVEL</a>) &amp;&amp; (VacbArray[++<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>] == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
02234                             <span class="keywordflow">continue</span>;
02235                         }
02236 
02237                         <span class="comment">//</span>
02238                         <span class="comment">//  If we found a non-null index, get out and try to return the</span>
02239                         <span class="comment">//  listhead.</span>
02240                         <span class="comment">//</span>
02241 
02242                         <span class="keywordflow">if</span> ((NextVacbArray = (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *)VacbArray[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>]) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02243                             <span class="keywordflow">break</span>;
02244                         }
02245                     }
02246 
02247                 } <span class="keywordflow">else</span> {
02248 
02249                     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> != 0) {
02250 
02251                         <span class="keywordflow">while</span> ((<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> != 0) &amp;&amp; (VacbArray[--<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>] == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
02252                             <span class="keywordflow">continue</span>;
02253                         }
02254 
02255                         <span class="comment">//</span>
02256                         <span class="comment">//  If we found a non-null index, get out and try to return the</span>
02257                         <span class="comment">//  listhead.</span>
02258                         <span class="comment">//</span>
02259 
02260                         <span class="keywordflow">if</span> ((NextVacbArray = (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *)VacbArray[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>]) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02261                             <span class="keywordflow">break</span>;
02262                         }
02263                     }
02264                 }
02265 
02266                 <span class="comment">//</span>
02267                 <span class="comment">//  If there are no saved levels yet, then there is no predecessor or</span>
02268                 <span class="comment">//  successor - it is the main listhead.</span>
02269                 <span class="comment">//</span>
02270 
02271                 <span class="keywordflow">if</span> (SavedLevels == 0) {
02272                     <span class="keywordflow">return</span> &amp;SharedCacheMap-&gt;BcbList;
02273                 }
02274 
02275                 <span class="comment">//</span>
02276                 <span class="comment">//  Otherwise, we can pop up a level in the tree and start scanning</span>
02277                 <span class="comment">//  from that guy for a path to the right listhead.</span>
02278                 <span class="comment">//</span>
02279 
02280                 Level += 1;
02281                 <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = SavedIndexes[--SavedLevels];
02282                 VacbArray = SavedVacbArrays[SavedLevels];
02283             }
02284 
02285             <span class="comment">//</span>
02286             <span class="comment">//  We have backed up in the hierarchy, so now we are just looking for the</span>
02287             <span class="comment">//  highest/lowest guy in the level we want, i.e., the level-linking listhead.</span>
02288             <span class="comment">//  So smash FileOffset accordingly (we mask the high bits out anyway).</span>
02289             <span class="comment">//</span>
02290 
02291             <span class="keywordflow">if</span> (FailToSuccessor) {
02292                 FileOffset = 0;
02293             } <span class="keywordflow">else</span> {
02294                 FileOffset = MAXLONGLONG;
02295             }
02296         }
02297 
02298         <span class="comment">//</span>
02299         <span class="comment">//  We save Index and VacbArray at each level, for the case that we</span>
02300         <span class="comment">//  have to walk back up the tree to find a predecessor.</span>
02301         <span class="comment">//</span>
02302 
02303         SavedIndexes[SavedLevels] = <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
02304         SavedVacbArrays[SavedLevels] = VacbArray;
02305         SavedLevels += 1;
02306 
02307         <span class="comment">//</span>
02308         <span class="comment">//  Now make this one our current pointer, and mask away the extraneous high-order</span>
02309         <span class="comment">//  FileOffset bits for this level.</span>
02310         <span class="comment">//</span>
02311 
02312         VacbArray = NextVacbArray;
02313         FileOffset &amp;= ((LONGLONG)1 &lt;&lt; Shift) - 1;
02314         Shift -= <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
02315 
02316     <span class="comment">//</span>
02317     <span class="comment">//  Loop until we hit the bottom level.</span>
02318     <span class="comment">//</span>
02319 
02320     } <span class="keywordflow">while</span> (Level != 0);
02321 
02322     <span class="comment">//</span>
02323     <span class="comment">//  Now calculate the index for the bottom level and return the appropriate listhead.</span>
02324     <span class="comment">//  (The normal Vacb index indexes to a pointer to a Vacb for a .25MB view, so dropping</span>
02325     <span class="comment">//  the low bit gets you to the even-indexed Vacb pointer which is one block size below</span>
02326     <span class="comment">//  the two-pointer listhead for the Bcbs for that .5MB range...)</span>
02327     <span class="comment">//</span>
02328 
02329     <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = (ULONG)(FileOffset &gt;&gt; Shift);
02330     <span class="keywordflow">return</span> (PLIST_ENTRY)((PCHAR)&amp;VacbArray[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &amp; ~1] + <a class="code" href="../../d5/d5/cc_8h.html#a39">VACB_LEVEL_BLOCK_SIZE</a>);
02331 }
02332 
02333 
02334 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02335"></a><a class="code" href="../../d5/d3/vacbsup_8c.html#a26">02335</a> <a class="code" href="../../d5/d3/vacbsup_8c.html#a26">CcAdjustVacbLevelLockCount</a> (
02336     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap,
02337     IN LONGLONG FileOffset,
02338     IN LONG Adjustment
02339     )
02340 
02341 <span class="comment">/*++</span>
02342 <span class="comment"></span>
02343 <span class="comment">Routine Description:</span>
02344 <span class="comment"></span>
02345 <span class="comment">    This routine may be called to adjust the lock count of the bottom Vacb level when</span>
02346 <span class="comment">    Bcbs are inserted or deleted.  If the count goes to zero, the level will be</span>
02347 <span class="comment">    eliminated.  The bottom level must exist, or we crash!</span>
02348 <span class="comment"></span>
02349 <span class="comment">Arguments:</span>
02350 <span class="comment"></span>
02351 <span class="comment">    SharedCacheMap - Supplies the pointer to the SharedCacheMap for which the Vacb</span>
02352 <span class="comment">                     is desired.</span>
02353 <span class="comment"></span>
02354 <span class="comment">    FileOffset - Supplies the fileOffset corresponding to the desired Vacb.</span>
02355 <span class="comment"></span>
02356 <span class="comment">    Adjustment - Generally -1 or +1.</span>
02357 <span class="comment"></span>
02358 <span class="comment">Return Value:</span>
02359 <span class="comment"></span>
02360 <span class="comment">    None.</span>
02361 <span class="comment"></span>
02362 <span class="comment">Environment:</span>
02363 <span class="comment"></span>
02364 <span class="comment">    CcVacbSpinLock should be held on entry.</span>
02365 <span class="comment"></span>
02366 <span class="comment">--*/</span>
02367 
02368 {
02369     ULONG Level, Shift;
02370     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *VacbArray;
02371     LONGLONG OriginalFileOffset = FileOffset;
02372 
02373     <span class="comment">//</span>
02374     <span class="comment">//  Initialize variables controlling our descent into the hierarchy.</span>
02375     <span class="comment">//</span>
02376 
02377     Level = 0;
02378     Shift = <a class="code" href="../../d4/d2/cache_8h.html#a1">VACB_OFFSET_SHIFT</a> + <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
02379 
02380     VacbArray = SharedCacheMap-&gt;Vacbs;
02381 
02382     <span class="comment">//</span>
02383     <span class="comment">//  Caller must have verified that we have a hierarchy, otherwise this routine</span>
02384     <span class="comment">//  would fail.</span>
02385     <span class="comment">//</span>
02386 
02387     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(SharedCacheMap-&gt;SectionSize.QuadPart &gt; <a class="code" href="../../d5/d5/cc_8h.html#a41">VACB_SIZE_OF_FIRST_LEVEL</a>);
02388 
02389     <span class="comment">//</span>
02390     <span class="comment">//  Loop to calculate how many levels we have and how much we have to</span>
02391     <span class="comment">//  shift to index into the first level.</span>
02392     <span class="comment">//</span>
02393 
02394     <span class="keywordflow">do</span> {
02395 
02396         Level += 1;
02397         Shift += <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
02398 
02399     } <span class="keywordflow">while</span> (SharedCacheMap-&gt;SectionSize.QuadPart &gt; ((LONGLONG)1 &lt;&lt; Shift));
02400 
02401     <span class="comment">//</span>
02402     <span class="comment">//  Now descend the tree to the bottom level to get the caller's Vacb.</span>
02403     <span class="comment">//</span>
02404 
02405     Shift -= <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
02406     <span class="keywordflow">do</span> {
02407 
02408         VacbArray = (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *)VacbArray[(ULONG)(FileOffset &gt;&gt; Shift)];
02409 
02410         Level -= 1;
02411 
02412         FileOffset &amp;= ((LONGLONG)1 &lt;&lt; Shift) - 1;
02413 
02414         Shift -= <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
02415 
02416     } <span class="keywordflow">while</span> (Level != 0);
02417 
02418     <span class="comment">//</span>
02419     <span class="comment">//  Now we have reached the final level, do the adjustment.</span>
02420     <span class="comment">//</span>
02421 
02422     <a class="code" href="../../d5/d3/vacbsup_8c.html#a12">ReferenceVacbLevel</a>( SharedCacheMap, VacbArray, Level, Adjustment, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
02423 
02424     <span class="comment">//</span>
02425     <span class="comment">//  Now, if we decremented the count to 0, then force the collapse to happen by</span>
02426     <span class="comment">//  upping count and resetting to NULL.  Then smash OriginalFileOffset to be</span>
02427     <span class="comment">//  the first entry so we do not recalculate!</span>
02428     <span class="comment">//</span>
02429 
02430     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a209">IsVacbLevelReferenced</a>( SharedCacheMap, VacbArray, Level )) {
02431         <a class="code" href="../../d5/d3/vacbsup_8c.html#a12">ReferenceVacbLevel</a>( SharedCacheMap, VacbArray, Level, 1, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
02432         OriginalFileOffset &amp;= ~(<a class="code" href="../../d5/d5/cc_8h.html#a41">VACB_SIZE_OF_FIRST_LEVEL</a> - 1);
02433         <a class="code" href="../../d5/d3/vacbsup_8c.html#a10">CcSetVacbLargeOffset</a>( SharedCacheMap, OriginalFileOffset, <a class="code" href="../../d5/d5/cc_8h.html#a66">VACB_SPECIAL_DEREFERENCE</a> );
02434     }
02435 }
02436 
02437 
02438 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02439"></a><a class="code" href="../../d5/d3/vacbsup_8c.html#a8">02439</a> <a class="code" href="../../d5/d3/vacbsup_8c.html#a8">CcCalculateVacbLevelLockCount</a> (
02440     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap,
02441     IN <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *VacbArray,
02442     IN ULONG Level
02443     )
02444 
02445 <span class="comment">/*++</span>
02446 <span class="comment"></span>
02447 <span class="comment">Routine Description:</span>
02448 <span class="comment"></span>
02449 <span class="comment">    This routine may be called to calculate or recalculate the lock count on a</span>
02450 <span class="comment">    given Vacb level array.  It is called, for example, when we are extending a</span>
02451 <span class="comment">    section up to the point where we activate multilevel logic and want to start</span>
02452 <span class="comment">    keeping the count.</span>
02453 <span class="comment"></span>
02454 <span class="comment">Arguments:</span>
02455 <span class="comment"></span>
02456 <span class="comment">    SharedCacheMap - Supplies the pointer to the SharedCacheMap for which the Vacb</span>
02457 <span class="comment">                     is desired.</span>
02458 <span class="comment"></span>
02459 <span class="comment">    VacbArray - The Vacb Level array to recalculate</span>
02460 <span class="comment"></span>
02461 <span class="comment">    Level - Supplies 0 for the bottom level, nonzero otherwise.</span>
02462 <span class="comment"></span>
02463 <span class="comment">Return Value:</span>
02464 <span class="comment"></span>
02465 <span class="comment">    None.</span>
02466 <span class="comment"></span>
02467 <span class="comment">Environment:</span>
02468 <span class="comment"></span>
02469 <span class="comment">    CcVacbSpinLock should be held on entry.</span>
02470 <span class="comment"></span>
02471 <span class="comment">--*/</span>
02472 
02473 {
02474     <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> Bcb;
02475     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
02476     LONG <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> = 0;
02477     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *VacbTemp = VacbArray;
02478     <a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html">PVACB_LEVEL_REFERENCE</a> VacbReference;
02479 
02480     <span class="comment">//</span>
02481     <span class="comment">//  First loop through to count how many Vacb pointers are in use.</span>
02482     <span class="comment">//</span>
02483 
02484     <span class="keywordflow">for</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt;= <a class="code" href="../../d5/d5/cc_8h.html#a40">VACB_LAST_INDEX_FOR_LEVEL</a>; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>++) {
02485         <span class="keywordflow">if</span> (*(VacbTemp++) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02486             <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> += 1;
02487         }
02488     }
02489 
02490     <span class="comment">//</span>
02491     <span class="comment">//  If this is a metadata stream, we also have to count the Bcbs in the</span>
02492     <span class="comment">//  corresponding listheads.</span>
02493     <span class="comment">//</span>
02494 
02495     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;Flags, <a class="code" href="../../d5/d5/cc_8h.html#a78">MODIFIED_WRITE_DISABLED</a>) &amp;&amp; (Level == 0)) {
02496 
02497         <span class="comment">//</span>
02498         <span class="comment">//  Pick up the Blink of the first listhead, casting it to a Bcb.</span>
02499         <span class="comment">//</span>
02500 
02501         Bcb = (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)CONTAINING_RECORD(((PLIST_ENTRY)VacbTemp)-&gt;Blink, <a class="code" href="../../d4/d3/struct__BCB.html">BCB</a>, BcbLinks);
02502         <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0;
02503 
02504         <span class="comment">//</span>
02505         <span class="comment">//  Now loop through the list.  For each Bcb we see, increment the count,</span>
02506         <span class="comment">//  and for each listhead, increment Index.  We are done when we hit the</span>
02507         <span class="comment">//  last listhead, which is actually the next listhead past the ones in this</span>
02508         <span class="comment">//  block.</span>
02509         <span class="comment">//</span>
02510 
02511         <span class="keywordflow">do</span> {
02512 
02513             <span class="keywordflow">if</span> (Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o0">NodeTypeCode</a> == <a class="code" href="../../d5/d5/cc_8h.html#a14">CACHE_NTC_BCB</a>) {
02514                 <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> += 1;
02515             } <span class="keywordflow">else</span> {
02516                 <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> += 1;
02517             }
02518 
02519             Bcb = (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)CONTAINING_RECORD(Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o4">BcbLinks</a>.Blink, <a class="code" href="../../d4/d3/struct__BCB.html">BCB</a>, BcbLinks);
02520 
02521         } <span class="keywordflow">while</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt;= (<a class="code" href="../../d5/d5/cc_8h.html#a40">VACB_LAST_INDEX_FOR_LEVEL</a> / 2));
02522     }
02523 
02524     <span class="comment">//</span>
02525     <span class="comment">//  Store the count and get out... (by hand, don't touch the special count)</span>
02526     <span class="comment">//</span>
02527 
02528     VacbReference = <a class="code" href="../../d5/d5/cc_8h.html#a208">VacbLevelReference</a>( SharedCacheMap, VacbArray, Level );
02529     VacbReference-&gt;<a class="code" href="../../d4/d5/struct__VACB__LEVEL__REFERENCE.html#o0">Reference</a> = <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>;
02530 }
02531 
02532 
02533 <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a>
<a name="l02534"></a><a class="code" href="../../d5/d3/vacbsup_8c.html#a9">02534</a> <a class="code" href="../../d5/d3/vacbsup_8c.html#a9">CcGetVacbLargeOffset</a> (
02535     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap,
02536     IN LONGLONG FileOffset
02537     )
02538 
02539 <span class="comment">/*++</span>
02540 <span class="comment"></span>
02541 <span class="comment">Routine Description:</span>
02542 <span class="comment"></span>
02543 <span class="comment">    This routine may be called to return the Vacb for the specified FileOffset.</span>
02544 <span class="comment">    It should only be called if the SectionSize is greater than VACB_SIZE_OF_FIRST_LEVEL.</span>
02545 <span class="comment"></span>
02546 <span class="comment">Arguments:</span>
02547 <span class="comment"></span>
02548 <span class="comment">    SharedCacheMap - Supplies the pointer to the SharedCacheMap for which the Vacb</span>
02549 <span class="comment">                     is desired.</span>
02550 <span class="comment"></span>
02551 <span class="comment">    FileOffset - Supplies the fileOffset corresponding to the desired Vacb.</span>
02552 <span class="comment"></span>
02553 <span class="comment">Return Value:</span>
02554 <span class="comment"></span>
02555 <span class="comment">    Returns the desired Vacb pointer or NULL if there is none.</span>
02556 <span class="comment"></span>
02557 <span class="comment">Environment:</span>
02558 <span class="comment"></span>
02559 <span class="comment">    CcVacbSpinLock should be held on entry.</span>
02560 <span class="comment"></span>
02561 <span class="comment">--*/</span>
02562 
02563 {
02564     ULONG Level, Shift;
02565     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *VacbArray;
02566     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> Vacb;
02567 
02568     <span class="comment">//</span>
02569     <span class="comment">//  Initialize variables controlling our descent into the hierarchy.</span>
02570     <span class="comment">//</span>
02571 
02572     Level = 0;
02573     Shift = <a class="code" href="../../d4/d2/cache_8h.html#a1">VACB_OFFSET_SHIFT</a> + <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
02574     VacbArray = SharedCacheMap-&gt;Vacbs;
02575 
02576     <span class="comment">//</span>
02577     <span class="comment">//  Caller must have verified that we have a hierarchy, otherwise this routine</span>
02578     <span class="comment">//  would fail.</span>
02579     <span class="comment">//</span>
02580 
02581     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(SharedCacheMap-&gt;SectionSize.QuadPart &gt; <a class="code" href="../../d5/d5/cc_8h.html#a41">VACB_SIZE_OF_FIRST_LEVEL</a>);
02582 
02583     <span class="comment">//</span>
02584     <span class="comment">//  Loop to calculate how many levels we have and how much we have to</span>
02585     <span class="comment">//  shift to index into the first level.</span>
02586     <span class="comment">//</span>
02587 
02588     <span class="keywordflow">do</span> {
02589 
02590         Level += 1;
02591         Shift += <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
02592 
02593     } <span class="keywordflow">while</span> (SharedCacheMap-&gt;SectionSize.QuadPart &gt; ((LONGLONG)1 &lt;&lt; Shift));
02594 
02595     <span class="comment">//</span>
02596     <span class="comment">//  Now descend the tree to the bottom level to get the caller's Vacb.</span>
02597     <span class="comment">//</span>
02598 
02599     Shift -= <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
02600     <span class="keywordflow">while</span> (((Vacb = (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a>)VacbArray[FileOffset &gt;&gt; Shift]) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp; (Level != 0)) {
02601 
02602         Level -= 1;
02603 
02604         VacbArray = (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *)Vacb;
02605         FileOffset &amp;= ((LONGLONG)1 &lt;&lt; Shift) - 1;
02606 
02607         Shift -= <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
02608     }
02609 
02610     <span class="comment">//</span>
02611     <span class="comment">//  If the Vacb we exited with is not NULL, we want to make sure it looks OK.</span>
02612     <span class="comment">//</span>
02613 
02614     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Vacb == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> || ((Vacb &gt;= <a class="code" href="../../d5/d2/cachedat_8c.html#a20">CcVacbs</a>) &amp;&amp; (Vacb &lt; <a class="code" href="../../d5/d2/cachedat_8c.html#a21">CcBeyondVacbs</a>)));
02615 
02616     <span class="keywordflow">return</span> Vacb;
02617 }
02618 
02619 
02620 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02621"></a><a class="code" href="../../d5/d3/vacbsup_8c.html#a10">02621</a> <a class="code" href="../../d5/d3/vacbsup_8c.html#a10">CcSetVacbLargeOffset</a> (
02622     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap,
02623     IN LONGLONG FileOffset,
02624     IN <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> Vacb
02625     )
02626 
02627 <span class="comment">/*++</span>
02628 <span class="comment"></span>
02629 <span class="comment">Routine Description:</span>
02630 <span class="comment"></span>
02631 <span class="comment">    This routine may be called to set the specified Vacb pointer for the specified FileOffset.</span>
02632 <span class="comment">    It should only be called if the SectionSize is greater than VACB_SIZE_OF_FIRST_LEVEL.</span>
02633 <span class="comment"></span>
02634 <span class="comment">    For non-null Vacb, intermediate Vacb levels will be added as necessary, and if the lowest</span>
02635 <span class="comment">    level has Bcb listheads, these will also be added.  For this case the caller must acquire</span>
02636 <span class="comment">    the spinlock by calling CcPrefillVacbLevelZone specifying the worst-case number of levels</span>
02637 <span class="comment">    required.</span>
02638 <span class="comment"></span>
02639 <span class="comment">    For a null Vacb pointer, the tree is pruned of all Vacb levels that go empty.  If the lowest</span>
02640 <span class="comment">    level has Bcb listheads, then they are removed.  The caller should subsequently call</span>
02641 <span class="comment">    CcDrainVacbLevelZone once the spinlock is release to actually free some of this zone to the</span>
02642 <span class="comment">    pool.</span>
02643 <span class="comment"></span>
02644 <span class="comment">Arguments:</span>
02645 <span class="comment"></span>
02646 <span class="comment">    SharedCacheMap - Supplies the pointer to the SharedCacheMap for which the Vacb</span>
02647 <span class="comment">                     is desired.</span>
02648 <span class="comment"></span>
02649 <span class="comment">    FileOffset - Supplies the fileOffset corresponding to the desired Vacb.</span>
02650 <span class="comment"></span>
02651 <span class="comment">Return Value:</span>
02652 <span class="comment"></span>
02653 <span class="comment">    Returns the desired Vacb pointer or NULL if there is none.</span>
02654 <span class="comment"></span>
02655 <span class="comment">Environment:</span>
02656 <span class="comment"></span>
02657 <span class="comment">    CcVacbSpinLock should be held on entry.</span>
02658 <span class="comment"></span>
02659 <span class="comment">--*/</span>
02660 
02661 {
02662     ULONG Level, Shift;
02663     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *VacbArray, *NextVacbArray;
02664     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
02665     ULONG SavedIndexes[<a class="code" href="../../d5/d5/cc_8h.html#a42">VACB_NUMBER_OF_LEVELS</a>];
02666     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *SavedVacbArrays[<a class="code" href="../../d5/d5/cc_8h.html#a42">VACB_NUMBER_OF_LEVELS</a>];
02667     PLIST_ENTRY PredecessorListHead, SuccessorListHead, CurrentListHead;
02668     BOOLEAN AllocatingBcbListHeads, Special = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02669     LONGLONG OriginalFileOffset = FileOffset;
02670     ULONG SavedLevels = 0;
02671 
02672     <span class="comment">//</span>
02673     <span class="comment">//  Initialize variables controlling our descent into the hierarchy.</span>
02674     <span class="comment">//</span>
02675 
02676     Level = 0;
02677     Shift = <a class="code" href="../../d4/d2/cache_8h.html#a1">VACB_OFFSET_SHIFT</a> + <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
02678     VacbArray = SharedCacheMap-&gt;Vacbs;
02679 
02680     <span class="comment">//</span>
02681     <span class="comment">//  Caller must have verified that we have a hierarchy, otherwise this routine</span>
02682     <span class="comment">//  would fail.</span>
02683     <span class="comment">//</span>
02684 
02685     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(SharedCacheMap-&gt;SectionSize.QuadPart &gt; <a class="code" href="../../d5/d5/cc_8h.html#a41">VACB_SIZE_OF_FIRST_LEVEL</a>);
02686 
02687     <span class="comment">//</span>
02688     <span class="comment">//  Loop to calculate how many levels we have and how much we have to</span>
02689     <span class="comment">//  shift to index into the first level.</span>
02690     <span class="comment">//</span>
02691 
02692     <span class="keywordflow">do</span> {
02693 
02694         Level += 1;
02695         Shift += <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
02696 
02697     } <span class="keywordflow">while</span> (SharedCacheMap-&gt;SectionSize.QuadPart &gt; ((LONGLONG)1 &lt;&lt; Shift));
02698 
02699     <span class="comment">//</span>
02700     <span class="comment">//  Now descend the tree to the bottom level to set the caller's Vacb.</span>
02701     <span class="comment">//</span>
02702 
02703     Shift -= <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
02704     <span class="keywordflow">do</span> {
02705 
02706         <span class="comment">//</span>
02707         <span class="comment">//  Decrement back to the level that describes the size we are within.</span>
02708         <span class="comment">//</span>
02709 
02710         Level -= 1;
02711 
02712         <span class="comment">//</span>
02713         <span class="comment">//  Calculate the index into the Vacb block for this level.</span>
02714         <span class="comment">//</span>
02715 
02716         <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = (ULONG)(FileOffset &gt;&gt; Shift);
02717         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt;= <a class="code" href="../../d5/d5/cc_8h.html#a40">VACB_LAST_INDEX_FOR_LEVEL</a>);
02718 
02719         <span class="comment">//</span>
02720         <span class="comment">//  We save Index and VacbArray at each level, for the case that we</span>
02721         <span class="comment">//  are collapsing and deallocating blocks below.</span>
02722         <span class="comment">//</span>
02723 
02724         SavedIndexes[SavedLevels] = <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
02725         SavedVacbArrays[SavedLevels] = VacbArray;
02726         SavedLevels += 1;
02727 
02728         <span class="comment">//</span>
02729         <span class="comment">//  Get block address for next level.</span>
02730         <span class="comment">//</span>
02731 
02732         NextVacbArray = (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *)VacbArray[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>];
02733 
02734         <span class="comment">//</span>
02735         <span class="comment">//  If it is NULL then we have to allocate the next level to fill it in.</span>
02736         <span class="comment">//</span>
02737 
02738         <span class="keywordflow">if</span> (NextVacbArray == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02739 
02740             <span class="comment">//</span>
02741             <span class="comment">//  We better not be thinking we're dereferencing a level if the level</span>
02742             <span class="comment">//  doesn't currently exist.</span>
02743             <span class="comment">//</span>
02744 
02745             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( Vacb != <a class="code" href="../../d5/d5/cc_8h.html#a66">VACB_SPECIAL_DEREFERENCE</a> );
02746 
02747             AllocatingBcbListHeads = <a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;Flags, <a class="code" href="../../d5/d5/cc_8h.html#a78">MODIFIED_WRITE_DISABLED</a>) &amp;&amp; (Level == 0);
02748 
02749             <span class="comment">//</span>
02750             <span class="comment">//  This is only valid if we are setting a nonzero pointer!</span>
02751             <span class="comment">//</span>
02752 
02753             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Vacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
02754 
02755             NextVacbArray = <a class="code" href="../../d5/d5/cc_8h.html#a206">CcAllocateVacbLevel</a>(AllocatingBcbListHeads);
02756 
02757             <span class="comment">//</span>
02758             <span class="comment">//  If we allocated Bcb Listheads, we must link them in.</span>
02759             <span class="comment">//</span>
02760 
02761             <span class="keywordflow">if</span> (AllocatingBcbListHeads) {
02762 
02763                 ULONG i;
02764 
02765                 <span class="comment">//</span>
02766                 <span class="comment">//  Find our predecessor.</span>
02767                 <span class="comment">//</span>
02768 
02769                 PredecessorListHead = <a class="code" href="../../d5/d3/vacbsup_8c.html#a25">CcGetBcbListHeadLargeOffset</a>( SharedCacheMap, OriginalFileOffset, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
02770 
02771                 <span class="comment">//</span>
02772                 <span class="comment">//  If he is followed by any Bcbs, they "belong" to him, and we have to</span>
02773                 <span class="comment">//  skip over them.</span>
02774                 <span class="comment">//</span>
02775 
02776                 <span class="keywordflow">while</span> (((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)CONTAINING_RECORD(PredecessorListHead-&gt;Blink, <a class="code" href="../../d4/d3/struct__BCB.html">BCB</a>, BcbLinks))-&gt;NodeTypeCode ==
02777                        <a class="code" href="../../d5/d5/cc_8h.html#a14">CACHE_NTC_BCB</a>) {
02778                     PredecessorListHead = (PLIST_ENTRY)PredecessorListHead-&gt;Blink;
02779                 }
02780 
02781                 <span class="comment">//</span>
02782                 <span class="comment">//  Point to the first newly allocated listhead.</span>
02783                 <span class="comment">//</span>
02784 
02785                 CurrentListHead = (PLIST_ENTRY)((PCHAR)NextVacbArray + <a class="code" href="../../d5/d5/cc_8h.html#a39">VACB_LEVEL_BLOCK_SIZE</a>);
02786 
02787                 <span class="comment">//</span>
02788                 <span class="comment">//  Link first new listhead to predecessor.</span>
02789                 <span class="comment">//</span>
02790 
02791                 SuccessorListHead = PredecessorListHead-&gt;Blink;
02792                 PredecessorListHead-&gt;Blink = CurrentListHead;
02793                 CurrentListHead-&gt;Flink = PredecessorListHead;
02794 
02795                 <span class="comment">//</span>
02796                 <span class="comment">//  Now loop to link all of the new listheads together.</span>
02797                 <span class="comment">//</span>
02798 
02799                 <span class="keywordflow">for</span> (i = 0; i &lt; ((<a class="code" href="../../d5/d5/cc_8h.html#a39">VACB_LEVEL_BLOCK_SIZE</a> / <span class="keyword">sizeof</span>(LIST_ENTRY) - 1)); i++) {
02800 
02801                     CurrentListHead-&gt;Blink = CurrentListHead + 1;
02802                     CurrentListHead += 1;
02803                     CurrentListHead-&gt;Flink = CurrentListHead - 1;
02804                 }
02805 
02806                 <span class="comment">//</span>
02807                 <span class="comment">//  Finally link the last new listhead to the successor.</span>
02808                 <span class="comment">//</span>
02809 
02810                 CurrentListHead-&gt;Blink = SuccessorListHead;
02811                 SuccessorListHead-&gt;Flink = CurrentListHead;
02812             }
02813 
02814             VacbArray[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>] = (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a>)NextVacbArray;
02815 
02816             <span class="comment">//</span>
02817             <span class="comment">//  Increment the reference count.  Note that Level right now properly indicates</span>
02818             <span class="comment">//  what level NextVacbArray is at, not VacbArray.</span>
02819             <span class="comment">//</span>
02820 
02821             <a class="code" href="../../d5/d3/vacbsup_8c.html#a12">ReferenceVacbLevel</a>( SharedCacheMap, VacbArray, Level + 1, 1, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
02822         }
02823 
02824         <span class="comment">//</span>
02825         <span class="comment">//  Now make this one our current pointer, and mask away the extraneous high-order</span>
02826         <span class="comment">//  FileOffset bits for this level and reduce the shift count.</span>
02827         <span class="comment">//</span>
02828 
02829         VacbArray = NextVacbArray;
02830         FileOffset &amp;= ((LONGLONG)1 &lt;&lt; Shift) - 1;
02831         Shift -= <a class="code" href="../../d5/d5/cc_8h.html#a38">VACB_LEVEL_SHIFT</a>;
02832 
02833     <span class="comment">//</span>
02834     <span class="comment">//  Loop until we hit the bottom level.</span>
02835     <span class="comment">//</span>
02836 
02837     } <span class="keywordflow">while</span> (Level != 0);
02838 
02839     <span class="keywordflow">if</span> (Vacb &lt; <a class="code" href="../../d5/d5/cc_8h.html#a67">VACB_SPECIAL_FIRST_VALID</a>) {
02840 
02841         <span class="comment">//</span>
02842         <span class="comment">//  Now calculate the index for the bottom level and store the caller's Vacb pointer.</span>
02843         <span class="comment">//</span>
02844 
02845         <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = (ULONG)(FileOffset &gt;&gt; Shift);
02846         VacbArray[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>] = Vacb;
02847 
02848     <span class="comment">//</span>
02849     <span class="comment">//  Handle the special actions.</span>
02850     <span class="comment">//</span>
02851 
02852     } <span class="keywordflow">else</span> {
02853 
02854         Special = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02855 
02856         <span class="comment">//</span>
02857         <span class="comment">//  Induce the dereference.</span>
02858         <span class="comment">//</span>
02859 
02860         <span class="keywordflow">if</span> (Vacb == <a class="code" href="../../d5/d5/cc_8h.html#a66">VACB_SPECIAL_DEREFERENCE</a>) {
02861 
02862             Vacb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02863         }
02864     }
02865 
02866     <span class="comment">//</span>
02867     <span class="comment">//  If he is storing a nonzero pointer, just reference the level.</span>
02868     <span class="comment">//</span>
02869 
02870     <span class="keywordflow">if</span> (Vacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02871 
02872         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( !(Special &amp;&amp; Level != 0) );
02873 
02874         <a class="code" href="../../d5/d3/vacbsup_8c.html#a12">ReferenceVacbLevel</a>( SharedCacheMap, VacbArray, Level, 1, Special );
02875 
02876     <span class="comment">//</span>
02877     <span class="comment">//  Otherwise we are storing a NULL pointer, and we have to see if we can collapse</span>
02878     <span class="comment">//  the tree by deallocating empty blocks of pointers.</span>
02879     <span class="comment">//</span>
02880 
02881     } <span class="keywordflow">else</span> {
02882 
02883         <span class="comment">//</span>
02884         <span class="comment">//  Loop until doing all possible collapse except for the top level.</span>
02885         <span class="comment">//</span>
02886 
02887         <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
02888 
02889             <a class="code" href="../../d5/d3/vacbsup_8c.html#a12">ReferenceVacbLevel</a>( SharedCacheMap, VacbArray, Level, -1, Special );
02890 
02891             <span class="comment">//</span>
02892             <span class="comment">//  If this was a special dereference, then recognize that this was</span>
02893             <span class="comment">//  the only one.  The rest, as we tear up the tree, are regular</span>
02894             <span class="comment">//  (calculable) references.</span>
02895             <span class="comment">//</span>
02896 
02897             Special = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02898 
02899             <span class="comment">//</span>
02900             <span class="comment">//  Now, if we have an empty block (other than the top one), then we should free the</span>
02901             <span class="comment">//  block and keep looping.</span>
02902             <span class="comment">//</span>
02903 
02904             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a209">IsVacbLevelReferenced</a>( SharedCacheMap, VacbArray, Level ) &amp;&amp; (SavedLevels != 0)) {
02905 
02906                 SavedLevels -= 1;
02907 
02908                 <span class="comment">//</span>
02909                 <span class="comment">//  First see if we have Bcb Listheads to delete and if so, we have to unlink</span>
02910                 <span class="comment">//  the whole block first.</span>
02911                 <span class="comment">//</span>
02912 
02913                 AllocatingBcbListHeads = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02914                 <span class="keywordflow">if</span> ((Level++ == 0) &amp;&amp; <a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;Flags, <a class="code" href="../../d5/d5/cc_8h.html#a78">MODIFIED_WRITE_DISABLED</a>)) {
02915 
02916                     AllocatingBcbListHeads = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02917                     PredecessorListHead = ((PLIST_ENTRY)((PCHAR)VacbArray + <a class="code" href="../../d5/d5/cc_8h.html#a39">VACB_LEVEL_BLOCK_SIZE</a>))-&gt;Flink;
02918                     SuccessorListHead = ((PLIST_ENTRY)((PCHAR)VacbArray + (<a class="code" href="../../d5/d5/cc_8h.html#a39">VACB_LEVEL_BLOCK_SIZE</a> * 2) - <span class="keyword">sizeof</span>(LIST_ENTRY)))-&gt;Blink;
02919                     PredecessorListHead-&gt;Blink = SuccessorListHead;
02920                     SuccessorListHead-&gt;Flink = PredecessorListHead;
02921                 }
02922 
02923                 <span class="comment">//</span>
02924                 <span class="comment">//  Free the unused block and then pick up the saved parent pointer array and</span>
02925                 <span class="comment">//  index and erase the pointer to this block.</span>
02926                 <span class="comment">//</span>
02927 
02928                 <a class="code" href="../../d5/d5/cc_8h.html#a207">CcDeallocateVacbLevel</a>( VacbArray, AllocatingBcbListHeads );
02929                 <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = SavedIndexes[SavedLevels];
02930                 VacbArray = SavedVacbArrays[SavedLevels];
02931                 VacbArray[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>] = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02932 
02933             <span class="comment">//</span>
02934             <span class="comment">//  No more collapsing if we hit a block that still has pointers, or we hit the root.</span>
02935             <span class="comment">//</span>
02936 
02937             } <span class="keywordflow">else</span> {
02938                 <span class="keywordflow">break</span>;
02939             }
02940         }
02941     }
02942 }
02943 
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:42:20 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
