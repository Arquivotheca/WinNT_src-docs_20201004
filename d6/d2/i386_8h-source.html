<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: i386.h Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>i386.h</h1><a href="../../d5/d3/i386_8h.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++ BUILD Version: 0014    // Increment this if a change has global effects</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1989  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    i386.h</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module contains the i386 hardware specific header file.</span>
00012 <span class="comment"></span>
00013 <span class="comment">Author:</span>
00014 <span class="comment"></span>
00015 <span class="comment">    David N. Cutler (davec) 2-Aug-1989</span>
00016 <span class="comment"></span>
00017 <span class="comment">Revision History:</span>
00018 <span class="comment"></span>
00019 <span class="comment">    25-Jan-1990    shielint</span>
00020 <span class="comment"></span>
00021 <span class="comment">                   Added definitions for 8259 ports and commands and</span>
00022 <span class="comment">                   macros for 8259 irq# and system irql conversion.</span>
00023 <span class="comment"></span>
00024 <span class="comment">--*/</span>
00025 
00026 <span class="preprocessor">#ifndef _i386_</span>
00027 <span class="preprocessor"></span><span class="preprocessor">#define _i386_</span>
00028 <span class="preprocessor"></span>
00029 
00030 <span class="comment">// begin_ntddk begin_wdm begin_nthal begin_ntndis</span>
00031 
00032 <span class="preprocessor">#if defined(_X86_)</span>
00033 <span class="preprocessor"></span>
00034 <span class="comment">//</span>
00035 <span class="comment">// Types to use to contain PFNs and their counts.</span>
00036 <span class="comment">//</span>
00037 
00038 <span class="keyword">typedef</span> ULONG PFN_COUNT;
00039 
00040 <span class="keyword">typedef</span> LONG SPFN_NUMBER, *PSPFN_NUMBER;
00041 <span class="keyword">typedef</span> ULONG PFN_NUMBER, *PPFN_NUMBER;
00042 
00043 <span class="comment">//</span>
00044 <span class="comment">// Define maximum size of flush multiple TB request.</span>
00045 <span class="comment">//</span>
00046 
00047 <span class="preprocessor">#define FLUSH_MULTIPLE_MAXIMUM 16</span>
00048 <span class="preprocessor"></span>
00049 <span class="comment">//</span>
00050 <span class="comment">// Indicate that the i386 compiler supports the pragma textout construct.</span>
00051 <span class="comment">//</span>
00052 
00053 <span class="preprocessor">#define ALLOC_PRAGMA 1</span>
00054 <span class="preprocessor"></span><span class="comment">//</span>
00055 <span class="comment">// Indicate that the i386 compiler supports the DATA_SEG("INIT") and</span>
00056 <span class="comment">// DATA_SEG("PAGE") pragmas</span>
00057 <span class="comment">//</span>
00058 
00059 <span class="preprocessor">#define ALLOC_DATA_PRAGMA 1</span>
00060 <span class="preprocessor"></span>
00061 <span class="comment">// end_ntddk end_nthal end_ntndis end_wdm</span>
00062 
00063 
00064 <span class="comment">//  NOTE -  KiPcr is only useful for PCR references where we know we</span>
00065 <span class="comment">//          won't get context switched between the call to it and the</span>
00066 <span class="comment">//          variable reference, OR, were we don't care, (ie TEB pointer)</span>
00067 
00068 <span class="comment">//  BUGBUG bryanwi 11 june 90 - we must not macro out things we export</span>
00069 <span class="comment">//      Things like KeFlushIcache and KeFlushDcache cannot be macroed</span>
00070 <span class="comment">//      out because external code (like drivers) will want to import</span>
00071 <span class="comment">//      them by name.  Therefore, the defines below that turn them into</span>
00072 <span class="comment">//      nothing are inappropriate.  But this isn't going to hurt us right</span>
00073 <span class="comment">//      now.</span>
00074 
00075 <span class="comment">//  BUGBUG kenr - remove this PIC stuff from i386.h!</span>
00076 
00077 
00078 <span class="comment">//</span>
00079 <span class="comment">// Interrupt controller register addresses.</span>
00080 <span class="comment">//</span>
00081 
00082 <span class="preprocessor">#define PIC1_PORT0 0x20         // master PIC</span>
00083 <span class="preprocessor"></span><span class="preprocessor">#define PIC1_PORT1 0x21</span>
00084 <span class="preprocessor"></span><span class="preprocessor">#define PIC2_PORT0 0x0A0        // slave PIC</span>
00085 <span class="preprocessor"></span><span class="preprocessor">#define PIC2_PORT1 0x0A1</span>
00086 <span class="preprocessor"></span>
00087 <span class="comment">//</span>
00088 <span class="comment">// Commands for Interrupt Controller</span>
00089 <span class="comment">//</span>
00090 
00091 <span class="preprocessor">#define PIC1_EOI_MASK 0x60</span>
00092 <span class="preprocessor"></span><span class="preprocessor">#define PIC2_EOI      0x62</span>
00093 <span class="preprocessor"></span><span class="preprocessor">#define OCW2_NON_SPECIFIC_EOI 0x20</span>
00094 <span class="preprocessor"></span><span class="preprocessor">#define OCW3_READ_ISR 0xb</span>
00095 <span class="preprocessor"></span><span class="preprocessor">#define OCW3_READ_IRR 0xa</span>
00096 <span class="preprocessor"></span>
00097 
00098 <span class="comment">//</span>
00099 <span class="comment">// Length on interrupt object dispatch code in longwords.</span>
00100 <span class="comment">// BUGBUG shielint Reserve 9*4 space for ABIOS stack mapping.  If NO</span>
00101 <span class="comment">//        ABIOS support the size of DISPATCH_LENGTH should be 74.</span>
00102 <span class="comment">//</span>
00103 
00104 <span class="comment">// begin_nthal</span>
00105 
00106 <span class="preprocessor">#define NORMAL_DISPATCH_LENGTH 106                  // ntddk wdm</span>
00107 <span class="preprocessor"></span><span class="preprocessor">#define DISPATCH_LENGTH NORMAL_DISPATCH_LENGTH      // ntddk wdm</span>
00108 <span class="preprocessor"></span>
00109 
00110 <span class="comment">//</span>
00111 <span class="comment">// Define constants to access the bits in CR0.</span>
00112 <span class="comment">//</span>
00113 
00114 <span class="preprocessor">#define CR0_PG  0x80000000          // paging</span>
00115 <span class="preprocessor"></span><span class="preprocessor">#define CR0_ET  0x00000010          // extension type (80387)</span>
00116 <span class="preprocessor"></span><span class="preprocessor">#define CR0_TS  0x00000008          // task switched</span>
00117 <span class="preprocessor"></span><span class="preprocessor">#define CR0_EM  0x00000004          // emulate math coprocessor</span>
00118 <span class="preprocessor"></span><span class="preprocessor">#define CR0_MP  0x00000002          // math present</span>
00119 <span class="preprocessor"></span><span class="preprocessor">#define CR0_PE  0x00000001          // protection enable</span>
00120 <span class="preprocessor"></span>
00121 <span class="comment">//</span>
00122 <span class="comment">// More CR0 bits; these only apply to the 80486.</span>
00123 <span class="comment">//</span>
00124 
00125 <span class="preprocessor">#define CR0_CD  0x40000000          // cache disable</span>
00126 <span class="preprocessor"></span><span class="preprocessor">#define CR0_NW  0x20000000          // not write-through</span>
00127 <span class="preprocessor"></span><span class="preprocessor">#define CR0_AM  0x00040000          // alignment mask</span>
00128 <span class="preprocessor"></span><span class="preprocessor">#define CR0_WP  0x00010000          // write protect</span>
00129 <span class="preprocessor"></span><span class="preprocessor">#define CR0_NE  0x00000020          // numeric error</span>
00130 <span class="preprocessor"></span>
00131 <span class="comment">//</span>
00132 <span class="comment">// CR4 bits;  These only apply to Pentium</span>
00133 <span class="comment">//</span>
00134 <span class="preprocessor">#define CR4_VME 0x00000001          // V86 mode extensions</span>
00135 <span class="preprocessor"></span><span class="preprocessor">#define CR4_PVI 0x00000002          // Protected mode virtual interrupts</span>
00136 <span class="preprocessor"></span><span class="preprocessor">#define CR4_TSD 0x00000004          // Time stamp disable</span>
00137 <span class="preprocessor"></span><span class="preprocessor">#define CR4_DE  0x00000008          // Debugging Extensions</span>
00138 <span class="preprocessor"></span><span class="preprocessor">#define CR4_PSE 0x00000010          // Page size extensions</span>
00139 <span class="preprocessor"></span><span class="preprocessor">#define CR4_PAE 0x00000020          // Physical address extensions</span>
00140 <span class="preprocessor"></span><span class="preprocessor">#define CR4_MCE 0x00000040          // Machine check enable</span>
00141 <span class="preprocessor"></span><span class="preprocessor">#define CR4_PGE 0x00000080          // Page global enable</span>
00142 <span class="preprocessor"></span><span class="preprocessor">#define CR4_FXSR 0x00000200         // FXSR used by OS</span>
00143 <span class="preprocessor"></span><span class="preprocessor">#define CR4_XMMEXCPT 0x00000400     // XMMI used by OS</span>
00144 <span class="preprocessor"></span>
00145 <span class="comment">// begin_ntddk begin_wdm</span>
00146 <span class="comment">//</span>
00147 <span class="comment">// STATUS register for each MCA bank.</span>
00148 <span class="comment">//</span>
00149 
00150 <span class="keyword">typedef</span> <span class="keyword">union </span>_MCI_STATS {
00151     <span class="keyword">struct </span>{
00152         <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>  McaCod;
00153         <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>  MsCod;
00154         ULONG   OtherInfo : 25;
00155         ULONG   Damage : 1;
00156         ULONG   AddressValid : 1;
00157         ULONG   MiscValid : 1;
00158         ULONG   Enabled : 1;
00159         ULONG   UnCorrected : 1;
00160         ULONG   OverFlow : 1;
00161         ULONG   Valid : 1;
00162     } MciStats;
00163 
00164     ULONGLONG QuadPart;
00165 
00166 } MCI_STATS, *PMCI_STATS;
00167 
00168 <span class="comment">// end_ntddk end_wdm</span>
00169 <span class="comment">// end_nthal</span>
00170 
00171 <span class="comment">//</span>
00172 <span class="comment">// Define constants to access ThNpxState</span>
00173 <span class="comment">//</span>
00174 
00175 <span class="preprocessor">#define NPX_STATE_NOT_LOADED    (CR0_TS | CR0_MP)</span>
00176 <span class="preprocessor"></span><span class="preprocessor">#define NPX_STATE_LOADED        0</span>
00177 <span class="preprocessor"></span>
00178 <span class="comment">//</span>
00179 <span class="comment">// External references to the labels defined in int.asm</span>
00180 <span class="comment">//</span>
00181 
00182 <span class="keyword">extern</span> ULONG KiInterruptTemplate[NORMAL_DISPATCH_LENGTH];
00183 <span class="keyword">extern</span> PULONG KiInterruptTemplateObject;
00184 <span class="keyword">extern</span> PULONG KiInterruptTemplateDispatch;
00185 <span class="keyword">extern</span> PULONG KiInterruptTemplate2ndDispatch;
00186 
00187 <span class="comment">// begin_ntddk begin_wdm begin_nthal</span>
00188 <span class="comment">//</span>
00189 <span class="comment">// Interrupt Request Level definitions</span>
00190 <span class="comment">//</span>
00191 
00192 <span class="preprocessor">#define PASSIVE_LEVEL 0             // Passive release level</span>
00193 <span class="preprocessor"></span><span class="preprocessor">#define LOW_LEVEL 0                 // Lowest interrupt level</span>
00194 <span class="preprocessor"></span><span class="preprocessor">#define APC_LEVEL 1                 // APC interrupt level</span>
00195 <span class="preprocessor"></span><span class="preprocessor">#define DISPATCH_LEVEL 2            // Dispatcher level</span>
00196 <span class="preprocessor"></span>
00197 <span class="preprocessor">#define PROFILE_LEVEL 27            // timer used for profiling.</span>
00198 <span class="preprocessor"></span><span class="preprocessor">#define CLOCK1_LEVEL 28             // Interval clock 1 level - Not used on x86</span>
00199 <span class="preprocessor"></span><span class="preprocessor">#define CLOCK2_LEVEL 28             // Interval clock 2 level</span>
00200 <span class="preprocessor"></span><span class="preprocessor">#define IPI_LEVEL 29                // Interprocessor interrupt level</span>
00201 <span class="preprocessor"></span><span class="preprocessor">#define POWER_LEVEL 30              // Power failure level</span>
00202 <span class="preprocessor"></span><span class="preprocessor">#define HIGH_LEVEL 31               // Highest interrupt level</span>
00203 <span class="preprocessor"></span><span class="preprocessor">#define SYNCH_LEVEL (IPI_LEVEL-1)   // synchronization level</span>
00204 <span class="preprocessor"></span><span class="comment">// end_ntddk end_wdm</span>
00205 
00206 <span class="preprocessor">#define KiSynchIrql SYNCH_LEVEL     // enable portable code</span>
00207 <span class="preprocessor"></span>
00208 <span class="comment">//</span>
00209 <span class="comment">// Machine type definitions</span>
00210 <span class="comment">// BUGBUG shielint This is temporary definitions.</span>
00211 <span class="comment">//</span>
00212 
00213 <span class="preprocessor">#define MACHINE_TYPE_ISA 0</span>
00214 <span class="preprocessor"></span><span class="preprocessor">#define MACHINE_TYPE_EISA 1</span>
00215 <span class="preprocessor"></span><span class="preprocessor">#define MACHINE_TYPE_MCA 2</span>
00216 <span class="preprocessor"></span>
00217 <span class="comment">// end_nthal</span>
00218 <span class="comment">//</span>
00219 <span class="comment">//  The previous values and the following are or'ed in KeI386MachineType.</span>
00220 <span class="comment">//  The latter section can be removed once PC/AT style computers become</span>
00221 <span class="comment">//  dominant in Japan. (DavidGoe)</span>
00222 <span class="comment">//</span>
00223 
00224 <span class="preprocessor">#define MACHINE_TYPE_PC_AT_COMPATIBLE      0x00000000</span>
00225 <span class="preprocessor"></span><span class="preprocessor">#define MACHINE_TYPE_PC_9800_COMPATIBLE    0x00000100</span>
00226 <span class="preprocessor"></span><span class="preprocessor">#define MACHINE_TYPE_FMR_COMPATIBLE        0x00000200</span>
00227 <span class="preprocessor"></span>
00228 <span class="keyword">extern</span> ULONG <a class="code" href="../../d7/d3/i386init_8c.html#a1">KeI386MachineType</a>;
00229 
00230 <span class="comment">// begin_nthal</span>
00231 <span class="comment">//</span>
00232 <span class="comment">// Define constants used in selector tests.</span>
00233 <span class="comment">//</span>
00234 <span class="comment">//  RPL_MASK is the real value for extracting RPL values.  IT IS THE WRONG</span>
00235 <span class="comment">//  CONSTANT TO USE FOR MODE TESTING.</span>
00236 <span class="comment">//</span>
00237 <span class="comment">//  MODE_MASK is the value for deciding the current mode.</span>
00238 <span class="comment">//  WARNING:    MODE_MASK assumes that all code runs at either ring-0</span>
00239 <span class="comment">//              or ring-3.  Ring-1 or Ring-2 support will require changing</span>
00240 <span class="comment">//              this value and all of the code that refers to it.</span>
00241 
00242 <span class="preprocessor">#define MODE_MASK    1</span>
00243 <span class="preprocessor"></span><span class="preprocessor">#define RPL_MASK     3</span>
00244 <span class="preprocessor"></span>
00245 <span class="comment">//</span>
00246 <span class="comment">// SEGMENT_MASK is used to throw away trash part of segment.  Part always</span>
00247 <span class="comment">// pushes or pops 32 bits to/from stack, but if it's a segment value,</span>
00248 <span class="comment">// high order 16 bits are trash.</span>
00249 <span class="comment">//</span>
00250 
00251 <span class="preprocessor">#define SEGMENT_MASK    0xffff</span>
00252 <span class="preprocessor"></span>
00253 <span class="comment">//</span>
00254 <span class="comment">// Startup count value for KeStallExecution.  This value is used</span>
00255 <span class="comment">// until KiInitializeStallExecution can compute the real one.</span>
00256 <span class="comment">// Pick a value long enough for very fast processors.</span>
00257 <span class="comment">//</span>
00258 
00259 <span class="preprocessor">#define INITIAL_STALL_COUNT 100</span>
00260 <span class="preprocessor"></span>
00261 <span class="comment">// end_nthal</span>
00262 
00263 <span class="comment">//</span>
00264 <span class="comment">// begin_nthal</span>
00265 <span class="comment">//</span>
00266 <span class="comment">// Macro to extract the high word of a long offset</span>
00267 <span class="comment">//</span>
00268 
00269 <span class="preprocessor">#define HIGHWORD(l) \</span>
00270 <span class="preprocessor">    ((USHORT)(((ULONG)(l)&gt;&gt;16) &amp; 0xffff))</span>
00271 <span class="preprocessor"></span>
00272 <span class="comment">//</span>
00273 <span class="comment">// Macro to extract the low word of a long offset</span>
00274 <span class="comment">//</span>
00275 
00276 <span class="preprocessor">#define LOWWORD(l) \</span>
00277 <span class="preprocessor">    ((USHORT)((ULONG)l &amp; 0x0000ffff))</span>
00278 <span class="preprocessor"></span>
00279 <span class="comment">//</span>
00280 <span class="comment">// Macro to combine two USHORT offsets into a long offset</span>
00281 <span class="comment">//</span>
00282 
00283 <span class="preprocessor">#if !defined(MAKEULONG)</span>
00284 <span class="preprocessor"></span>
00285 <span class="preprocessor">#define MAKEULONG(x, y) \</span>
00286 <span class="preprocessor">    (((((ULONG)(x))&lt;&lt;16) &amp; 0xffff0000) | \</span>
00287 <span class="preprocessor">    ((ULONG)(y) &amp; 0xffff))</span>
00288 <span class="preprocessor"></span>
00289 <span class="preprocessor">#endif</span>
00290 <span class="preprocessor"></span>
00291 <span class="comment">// end_nthal</span>
00292 
00293 <span class="comment">//</span>
00294 <span class="comment">// Request a software interrupt.</span>
00295 <span class="comment">//</span>
00296 
00297 <span class="preprocessor">#define KiRequestSoftwareInterrupt(RequestIrql) \</span>
00298 <span class="preprocessor">    HalRequestSoftwareInterrupt( RequestIrql )</span>
00299 <span class="preprocessor"></span>
00300 <span class="comment">// begin_ntddk begin_wdm begin_nthal begin_ntndis</span>
00301 
00302 <span class="comment">//</span>
00303 <span class="comment">// I/O space read and write macros.</span>
00304 <span class="comment">//</span>
00305 <span class="comment">//  These have to be actual functions on the 386, because we need</span>
00306 <span class="comment">//  to use assembler, but cannot return a value if we inline it.</span>
00307 <span class="comment">//</span>
00308 <span class="comment">//  The READ/WRITE_REGISTER_* calls manipulate I/O registers in MEMORY space.</span>
00309 <span class="comment">//  (Use x86 move instructions, with LOCK prefix to force correct behavior</span>
00310 <span class="comment">//   w.r.t. caches and write buffers.)</span>
00311 <span class="comment">//</span>
00312 <span class="comment">//  The READ/WRITE_PORT_* calls manipulate I/O registers in PORT space.</span>
00313 <span class="comment">//  (Use x86 in/out instructions.)</span>
00314 <span class="comment">//</span>
00315 
00316 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
00317 UCHAR
00318 READ_REGISTER_UCHAR(
00319     PUCHAR  Register
00320     );
00321 
00322 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
00323 <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>
00324 READ_REGISTER_USHORT(
00325     PUSHORT Register
00326     );
00327 
00328 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
00329 ULONG
00330 READ_REGISTER_ULONG(
00331     PULONG  Register
00332     );
00333 
00334 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
00335 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00336 READ_REGISTER_BUFFER_UCHAR(
00337     PUCHAR  Register,
00338     PUCHAR  Buffer,
00339     ULONG   Count
00340     );
00341 
00342 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
00343 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00344 READ_REGISTER_BUFFER_USHORT(
00345     PUSHORT Register,
00346     PUSHORT Buffer,
00347     ULONG   Count
00348     );
00349 
00350 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
00351 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00352 READ_REGISTER_BUFFER_ULONG(
00353     PULONG  Register,
00354     PULONG  Buffer,
00355     ULONG   Count
00356     );
00357 
00358 
00359 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
00360 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00361 WRITE_REGISTER_UCHAR(
00362     PUCHAR  Register,
00363     UCHAR   Value
00364     );
00365 
00366 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
00367 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00368 WRITE_REGISTER_USHORT(
00369     PUSHORT Register,
00370     USHORT  Value
00371     );
00372 
00373 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
00374 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00375 WRITE_REGISTER_ULONG(
00376     PULONG  Register,
00377     ULONG   Value
00378     );
00379 
00380 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
00381 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00382 WRITE_REGISTER_BUFFER_UCHAR(
00383     PUCHAR  Register,
00384     PUCHAR  Buffer,
00385     ULONG   Count
00386     );
00387 
00388 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
00389 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00390 WRITE_REGISTER_BUFFER_USHORT(
00391     PUSHORT Register,
00392     PUSHORT Buffer,
00393     ULONG   Count
00394     );
00395 
00396 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
00397 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00398 WRITE_REGISTER_BUFFER_ULONG(
00399     PULONG  Register,
00400     PULONG  Buffer,
00401     ULONG   Count
00402     );
00403 
00404 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
00405 UCHAR
00406 READ_PORT_UCHAR(
00407     PUCHAR  Port
00408     );
00409 
00410 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
00411 <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>
00412 READ_PORT_USHORT(
00413     PUSHORT Port
00414     );
00415 
00416 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
00417 ULONG
00418 READ_PORT_ULONG(
00419     PULONG  Port
00420     );
00421 
00422 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
00423 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00424 READ_PORT_BUFFER_UCHAR(
00425     PUCHAR  Port,
00426     PUCHAR  Buffer,
00427     ULONG   Count
00428     );
00429 
00430 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
00431 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00432 READ_PORT_BUFFER_USHORT(
00433     PUSHORT Port,
00434     PUSHORT Buffer,
00435     ULONG   Count
00436     );
00437 
00438 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
00439 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00440 READ_PORT_BUFFER_ULONG(
00441     PULONG  Port,
00442     PULONG  Buffer,
00443     ULONG   Count
00444     );
00445 
00446 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
00447 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00448 WRITE_PORT_UCHAR(
00449     PUCHAR  Port,
00450     UCHAR   Value
00451     );
00452 
00453 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
00454 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00455 WRITE_PORT_USHORT(
00456     PUSHORT Port,
00457     USHORT  Value
00458     );
00459 
00460 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
00461 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00462 WRITE_PORT_ULONG(
00463     PULONG  Port,
00464     ULONG   Value
00465     );
00466 
00467 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
00468 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00469 WRITE_PORT_BUFFER_UCHAR(
00470     PUCHAR  Port,
00471     PUCHAR  Buffer,
00472     ULONG   Count
00473     );
00474 
00475 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
00476 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00477 WRITE_PORT_BUFFER_USHORT(
00478     PUSHORT Port,
00479     PUSHORT Buffer,
00480     ULONG   Count
00481     );
00482 
00483 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
00484 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00485 WRITE_PORT_BUFFER_ULONG(
00486     PULONG  Port,
00487     PULONG  Buffer,
00488     ULONG   Count
00489     );
00490 
00491 <span class="comment">// end_ntndis</span>
00492 <span class="comment">//</span>
00493 <span class="comment">// Get data cache fill size.</span>
00494 <span class="comment">//</span>
00495 
00496 <span class="preprocessor">#define KeGetDcacheFillSize() 1L</span>
00497 <span class="preprocessor"></span>
00498 <span class="comment">// end_ntddk end_wdm end_nthal</span>
00499 
00500 <span class="comment">//</span>
00501 <span class="comment">// Fill TB entry.</span>
00502 <span class="comment">//</span>
00503 
00504 <span class="preprocessor">#define KeFillEntryTb(Pte, Virtual, Invalid)    \</span>
00505 <span class="preprocessor">    if (Invalid != FALSE) {                     \</span>
00506 <span class="preprocessor">        Ke386InvalidateTb (Virtual);            \</span>
00507 <span class="preprocessor">    }</span>
00508 <span class="preprocessor"></span>
00509 <span class="preprocessor">#if !defined(MIDL_PASS) &amp;&amp; defined(_M_IX86) &amp;&amp; !defined(_CROSS_PLATFORM_)</span>
00510 <span class="preprocessor"></span>
00511 __inline
00512 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00513 Ke386InvalidateTb (
00514     IN PVOID Virtual
00515     )
00516 {
00517     __asm {
00518         mov eax, <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a2">Virtual</a>
00519         invlpg [eax]
00520     }
00521 }
00522 
00523 <span class="preprocessor">#endif</span>
00524 <span class="preprocessor"></span>
00525 <span class="comment">//</span>
00526 <span class="comment">// Data cache, instruction cache, I/O buffer, and write buffer flush routine</span>
00527 <span class="comment">// prototypes.</span>
00528 <span class="comment">//</span>
00529 
00530 <span class="comment">//  386 and 486 have transparent caches, so these are noops.</span>
00531 
00532 <span class="preprocessor">#define KeSweepDcache(AllProcessors)</span>
00533 <span class="preprocessor"></span><span class="preprocessor">#define KeSweepCurrentDcache()</span>
00534 <span class="preprocessor"></span>
00535 <span class="preprocessor">#define KeSweepIcache(AllProcessors)</span>
00536 <span class="preprocessor"></span><span class="preprocessor">#define KeSweepCurrentIcache()</span>
00537 <span class="preprocessor"></span>
00538 <span class="preprocessor">#define KeSweepIcacheRange(AllProcessors, BaseAddress, Length)</span>
00539 <span class="preprocessor"></span>
00540 <span class="comment">// begin_ntddk begin_wdm begin_nthal begin_ntndis</span>
00541 
00542 <span class="preprocessor">#define KeFlushIoBuffers(Mdl, ReadOperation, DmaOperation)</span>
00543 <span class="preprocessor"></span>
00544 <span class="comment">// end_ntddk end_wdm end_ntndis</span>
00545 
00546 <span class="preprocessor">#define KeYieldProcessor()    __asm { rep nop }</span>
00547 <span class="preprocessor"></span>
00548 <span class="comment">// end_nthal</span>
00549 
00550 <span class="comment">//</span>
00551 <span class="comment">// Define executive macros for acquiring and releasing executive spinlocks.</span>
00552 <span class="comment">// These macros can ONLY be used by executive components and NOT by drivers.</span>
00553 <span class="comment">// Drivers MUST use the kernel interfaces since they must be MP enabled on</span>
00554 <span class="comment">// all systems.</span>
00555 <span class="comment">//</span>
00556 <span class="comment">// KeRaiseIrql is one instruction longer than KeAcquireSpinLock on x86 UP.</span>
00557 <span class="comment">// KeLowerIrql and KeReleaseSpinLock are the same.</span>
00558 <span class="comment">//</span>
00559 
00560 <span class="preprocessor">#if defined(NT_UP) &amp;&amp; !DBG &amp;&amp; !defined(_NTDDK_) &amp;&amp; !defined(_NTIFS_)</span>
00561 <span class="preprocessor"></span>
00562 <span class="preprocessor">#if !defined(_NTDRIVER_)</span>
00563 <span class="preprocessor"></span><span class="preprocessor">#define ExAcquireSpinLock(Lock, OldIrql) (*OldIrql) = KeRaiseIrqlToDpcLevel();</span>
00564 <span class="preprocessor"></span><span class="preprocessor">#define ExReleaseSpinLock(Lock, OldIrql) KeLowerIrql((OldIrql))</span>
00565 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00566 <span class="preprocessor"></span><span class="preprocessor">#define ExAcquireSpinLock(Lock, OldIrql) KeAcquireSpinLock((Lock), (OldIrql))</span>
00567 <span class="preprocessor"></span><span class="preprocessor">#define ExReleaseSpinLock(Lock, OldIrql) KeReleaseSpinLock((Lock), (OldIrql))</span>
00568 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00569 <span class="preprocessor"></span><span class="preprocessor">#define ExAcquireSpinLockAtDpcLevel(Lock)</span>
00570 <span class="preprocessor"></span><span class="preprocessor">#define ExReleaseSpinLockFromDpcLevel(Lock)</span>
00571 <span class="preprocessor"></span>
00572 <span class="preprocessor">#else</span>
00573 <span class="preprocessor"></span>
00574 <span class="comment">//  begin_wdm begin_ntddk</span>
00575 
00576 <span class="preprocessor">#define ExAcquireSpinLock(Lock, OldIrql) KeAcquireSpinLock((Lock), (OldIrql))</span>
00577 <span class="preprocessor"></span><span class="preprocessor">#define ExReleaseSpinLock(Lock, OldIrql) KeReleaseSpinLock((Lock), (OldIrql))</span>
00578 <span class="preprocessor"></span><span class="preprocessor">#define ExAcquireSpinLockAtDpcLevel(Lock) KeAcquireSpinLockAtDpcLevel(Lock)</span>
00579 <span class="preprocessor"></span><span class="preprocessor">#define ExReleaseSpinLockFromDpcLevel(Lock) KeReleaseSpinLockFromDpcLevel(Lock)</span>
00580 <span class="preprocessor"></span>
00581 <span class="comment">// end_wdm end_ntddk</span>
00582 
00583 <span class="preprocessor">#endif</span>
00584 <span class="preprocessor"></span>
00585 <span class="comment">//</span>
00586 <span class="comment">// The acquire and release fast lock macros disable and enable interrupts</span>
00587 <span class="comment">// on UP nondebug systems. On MP or debug systems, the spinlock routines</span>
00588 <span class="comment">// are used.</span>
00589 <span class="comment">//</span>
00590 <span class="comment">// N.B. Extreme caution should be observed when using these routines.</span>
00591 <span class="comment">//</span>
00592 
00593 <span class="preprocessor">#if defined(_M_IX86) &amp;&amp; !defined(USER_MODE_CODE)</span>
00594 <span class="preprocessor"></span>
00595 <span class="preprocessor">#pragma warning(disable:4164)</span>
00596 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic(_disable)</span>
00597 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic(_enable)</span>
00598 <span class="preprocessor"></span><span class="preprocessor">#pragma warning(default:4164)</span>
00599 <span class="preprocessor"></span>
00600 <span class="preprocessor">#endif</span>
00601 <span class="preprocessor"></span>
00602 <span class="preprocessor">#if defined(NT_UP) &amp;&amp; !DBG &amp;&amp; !defined(USER_MODE_CODE)</span>
00603 <span class="preprocessor"></span><span class="preprocessor">#define ExAcquireFastLock(Lock, OldIrql) _disable()</span>
00604 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00605 <span class="preprocessor"></span><span class="preprocessor">#define ExAcquireFastLock(Lock, OldIrql) \</span>
00606 <span class="preprocessor">    ExAcquireSpinLock(Lock, OldIrql)</span>
00607 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00608 <span class="preprocessor"></span>
00609 <span class="preprocessor">#if defined(NT_UP) &amp;&amp; !DBG &amp;&amp; !defined(USER_MODE_CODE)</span>
00610 <span class="preprocessor"></span><span class="preprocessor">#define ExReleaseFastLock(Lock, OldIrql) _enable()</span>
00611 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00612 <span class="preprocessor"></span><span class="preprocessor">#define ExReleaseFastLock(Lock, OldIrql) \</span>
00613 <span class="preprocessor">    ExReleaseSpinLock(Lock, OldIrql)</span>
00614 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00615 <span class="preprocessor"></span>
00616 <span class="comment">//</span>
00617 <span class="comment">// The following function prototypes must be in this module so that the</span>
00618 <span class="comment">// above macros can call them directly.</span>
00619 <span class="comment">//</span>
00620 <span class="comment">// begin_nthal</span>
00621 
00622 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00623 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
00624 KiAcquireSpinLock (
00625     IN PKSPIN_LOCK SpinLock
00626     );
00627 
00628 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00629 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
00630 KiReleaseSpinLock (
00631     IN PKSPIN_LOCK SpinLock
00632     );
00633 
00634 <span class="comment">// end_nthal</span>
00635 
00636 <span class="comment">//</span>
00637 <span class="comment">// KeTestSpinLock may be used to spin at low IRQL until the lock is</span>
00638 <span class="comment">// available.  The IRQL must then be raised and the lock acquired with</span>
00639 <span class="comment">// KeTryToAcquireSpinLock.  If that fails, lower the IRQL and start again.</span>
00640 <span class="comment">//</span>
00641 
00642 <span class="preprocessor">#if defined(NT_UP)</span>
00643 <span class="preprocessor"></span>
00644 <span class="preprocessor">#define KeTestSpinLock(SpinLock) (TRUE)</span>
00645 <span class="preprocessor"></span>
00646 <span class="preprocessor">#else</span>
00647 <span class="preprocessor"></span>
00648 BOOLEAN
00649 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
00650 KeTestSpinLock (
00651     IN PKSPIN_LOCK SpinLock
00652     );
00653 
00654 <span class="preprocessor">#endif</span>
00655 <span class="preprocessor"></span>
00656 <span class="comment">//</span>
00657 <span class="comment">// Define query system time macro.</span>
00658 <span class="comment">//</span>
00659 
00660 <span class="preprocessor">#define KiQuerySystemTime(CurrentTime) \</span>
00661 <span class="preprocessor">    while (TRUE) {                                                                  \</span>
00662 <span class="preprocessor">        (CurrentTime)-&gt;HighPart = SharedUserData-&gt;SystemTime.High1Time;             \</span>
00663 <span class="preprocessor">        (CurrentTime)-&gt;LowPart = SharedUserData-&gt;SystemTime.LowPart;                \</span>
00664 <span class="preprocessor">        if ((CurrentTime)-&gt;HighPart == SharedUserData-&gt;SystemTime.High2Time) break; \</span>
00665 <span class="preprocessor">        _asm { rep nop }                                                            \</span>
00666 <span class="preprocessor">    }</span>
00667 <span class="preprocessor"></span><span class="comment">//</span>
00668 <span class="comment">// Define query tick count macro.</span>
00669 <span class="comment">//</span>
00670 
00671 <span class="preprocessor">#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_)</span>
00672 <span class="preprocessor"></span>
00673 <span class="comment">//  begin_wdm begin_ntddk</span>
00674 
00675 <span class="preprocessor">#define KeQueryTickCount(CurrentCount ) { \</span>
00676 <span class="preprocessor">    volatile PKSYSTEM_TIME _TickCount = *((PKSYSTEM_TIME *)(&amp;KeTickCount)); \</span>
00677 <span class="preprocessor">    while (TRUE) {                                                          \</span>
00678 <span class="preprocessor">        (CurrentCount)-&gt;HighPart = _TickCount-&gt;High1Time;                   \</span>
00679 <span class="preprocessor">        (CurrentCount)-&gt;LowPart = _TickCount-&gt;LowPart;                      \</span>
00680 <span class="preprocessor">        if ((CurrentCount)-&gt;HighPart == _TickCount-&gt;High2Time) break;       \</span>
00681 <span class="preprocessor">        _asm { rep nop }                                                    \</span>
00682 <span class="preprocessor">    }                                                                       \</span>
00683 <span class="preprocessor">}</span>
00684 <span class="preprocessor"></span>
00685 <span class="comment">//  end_wdm end_ntddk</span>
00686 
00687 <span class="preprocessor">#else</span>
00688 <span class="preprocessor"></span>
00689 <span class="comment">// begin_nthal</span>
00690 <span class="preprocessor">#define KiQueryTickCount(CurrentCount) \</span>
00691 <span class="preprocessor">    while (TRUE) {                                                      \</span>
00692 <span class="preprocessor">        (CurrentCount)-&gt;HighPart = KeTickCount.High1Time;               \</span>
00693 <span class="preprocessor">        (CurrentCount)-&gt;LowPart = KeTickCount.LowPart;                  \</span>
00694 <span class="preprocessor">        if ((CurrentCount)-&gt;HighPart == KeTickCount.High2Time) break;   \</span>
00695 <span class="preprocessor">        _asm { rep nop }                                                \</span>
00696 <span class="preprocessor">    }</span>
00697 <span class="preprocessor"></span>
00698 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00699 <a class="code" href="../../d7/d0/ke_2miscc_8c.html#a4">KeQueryTickCount</a> (
00700     OUT PLARGE_INTEGER CurrentCount
00701     );
00702 
00703 <span class="comment">// end_nthal</span>
00704 <span class="preprocessor">#endif</span>
00705 <span class="preprocessor"></span>
00706 <span class="preprocessor">#define KiQueryLowTickCount() KeTickCount.LowPart</span>
00707 <span class="preprocessor"></span>
00708 <span class="comment">//</span>
00709 <span class="comment">// Define query interrupt time macro.</span>
00710 <span class="comment">//</span>
00711 
00712 <span class="preprocessor">#define KiQueryInterruptTime(CurrentTime) \</span>
00713 <span class="preprocessor">    while (TRUE) {                                                                      \</span>
00714 <span class="preprocessor">        (CurrentTime)-&gt;HighPart = SharedUserData-&gt;InterruptTime.High1Time;              \</span>
00715 <span class="preprocessor">        (CurrentTime)-&gt;LowPart = SharedUserData-&gt;InterruptTime.LowPart;                 \</span>
00716 <span class="preprocessor">        if ((CurrentTime)-&gt;HighPart == SharedUserData-&gt;InterruptTime.High2Time) break;  \</span>
00717 <span class="preprocessor">        _asm { rep nop }                                                                \</span>
00718 <span class="preprocessor">    }</span>
00719 <span class="preprocessor"></span>
00720 
00721 <span class="comment">// begin_nthal</span>
00722 <span class="comment">//</span>
00723 <span class="comment">// 386 hardware structures</span>
00724 <span class="comment">//</span>
00725 
00726 <span class="comment">//</span>
00727 <span class="comment">// A Page Table Entry on an Intel 386/486 has the following definition.</span>
00728 <span class="comment">//</span>
00729 <span class="comment">// **** NOTE A PRIVATE COPY OF THIS EXISTS IN THE MM\I386 DIRECTORY! ****</span>
00730 <span class="comment">// ****  ANY CHANGES NEED TO BE MADE TO BOTH HEADER FILES.           ****</span>
00731 <span class="comment">//</span>
00732 
00733 
00734 <span class="keyword">typedef</span> <span class="keyword">struct </span>_HARDWARE_PTE_X86 {
00735     ULONG Valid : 1;
00736     ULONG Write : 1;
00737     ULONG <a class="code" href="../../d6/d0/ctaccess_8c.html#a53">Owner</a> : 1;
00738     ULONG WriteThrough : 1;
00739     ULONG CacheDisable : 1;
00740     ULONG Accessed : 1;
00741     ULONG Dirty : 1;
00742     ULONG LargePage : 1;
00743     ULONG Global : 1;
00744     ULONG CopyOnWrite : 1; <span class="comment">// software field</span>
00745     ULONG Prototype : 1;   <span class="comment">// software field</span>
00746     ULONG reserved : 1;  <span class="comment">// software field</span>
00747     ULONG PageFrameNumber : 20;
00748 } HARDWARE_PTE_X86, *PHARDWARE_PTE_X86;
00749 
00750 <span class="keyword">typedef</span> <span class="keyword">struct </span>_HARDWARE_PTE_X86PAE {
00751     <span class="keyword">union </span>{
00752         <span class="keyword">struct </span>{
00753             ULONGLONG Valid : 1;
00754             ULONGLONG Write : 1;
00755             ULONGLONG <a class="code" href="../../d6/d0/ctaccess_8c.html#a53">Owner</a> : 1;
00756             ULONGLONG WriteThrough : 1;
00757             ULONGLONG CacheDisable : 1;
00758             ULONGLONG Accessed : 1;
00759             ULONGLONG Dirty : 1;
00760             ULONGLONG LargePage : 1;
00761             ULONGLONG Global : 1;
00762             ULONGLONG CopyOnWrite : 1; <span class="comment">// software field</span>
00763             ULONGLONG Prototype : 1;   <span class="comment">// software field</span>
00764             ULONGLONG reserved0 : 1;  <span class="comment">// software field</span>
00765             ULONGLONG PageFrameNumber : 24;
00766             ULONGLONG reserved1 : 28;  <span class="comment">// software field</span>
00767         };
00768         <span class="keyword">struct </span>{
00769             ULONG LowPart;
00770             ULONG HighPart;
00771         };
00772     };
00773 } HARDWARE_PTE_X86PAE, *PHARDWARE_PTE_X86PAE;
00774 
00775 <span class="preprocessor">#if !defined (_X86PAE_)</span>
00776 <span class="preprocessor"></span><span class="keyword">typedef</span> HARDWARE_PTE_X86 HARDWARE_PTE;
00777 <span class="keyword">typedef</span> PHARDWARE_PTE_X86 PHARDWARE_PTE;
00778 <span class="preprocessor">#else</span>
00779 <span class="preprocessor"></span><span class="keyword">typedef</span> HARDWARE_PTE_X86PAE HARDWARE_PTE;
00780 <span class="keyword">typedef</span> PHARDWARE_PTE_X86PAE PHARDWARE_PTE;
00781 <span class="preprocessor">#endif</span>
00782 <span class="preprocessor"></span>
00783 <span class="comment">//</span>
00784 <span class="comment">// GDT Entry</span>
00785 <span class="comment">//</span>
00786 
00787 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KGDTENTRY {
00788     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>  LimitLow;
00789     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>  BaseLow;
00790     <span class="keyword">union </span>{
00791         <span class="keyword">struct </span>{
00792             UCHAR   BaseMid;
00793             UCHAR   Flags1;     <span class="comment">// Declare as bytes to avoid alignment</span>
00794             UCHAR   Flags2;     <span class="comment">// Problems.</span>
00795             UCHAR   BaseHi;
00796         } Bytes;
00797         <span class="keyword">struct </span>{
00798             ULONG   BaseMid : 8;
00799             ULONG   Type : 5;
00800             ULONG   Dpl : 2;
00801             ULONG   Pres : 1;
00802             ULONG   LimitHi : 4;
00803             ULONG   Sys : 1;
00804             ULONG   Reserved_0 : 1;
00805             ULONG   Default_Big : 1;
00806             ULONG   Granularity : 1;
00807             ULONG   BaseHi : 8;
00808         } Bits;
00809     } HighWord;
00810 } KGDTENTRY, *PKGDTENTRY;
00811 
00812 <span class="preprocessor">#define TYPE_CODE   0x10  // 11010 = Code, Readable, NOT Conforming, Accessed</span>
00813 <span class="preprocessor"></span><span class="preprocessor">#define TYPE_DATA   0x12  // 10010 = Data, ReadWrite, NOT Expanddown, Accessed</span>
00814 <span class="preprocessor"></span><span class="preprocessor">#define TYPE_TSS    0x01  // 01001 = NonBusy TSS</span>
00815 <span class="preprocessor"></span><span class="preprocessor">#define TYPE_LDT    0x02  // 00010 = LDT</span>
00816 <span class="preprocessor"></span>
00817 <span class="preprocessor">#define DPL_USER    3</span>
00818 <span class="preprocessor"></span><span class="preprocessor">#define DPL_SYSTEM  0</span>
00819 <span class="preprocessor"></span>
00820 <span class="preprocessor">#define GRAN_BYTE   0</span>
00821 <span class="preprocessor"></span><span class="preprocessor">#define GRAN_PAGE   1</span>
00822 <span class="preprocessor"></span>
00823 <span class="preprocessor">#define SELECTOR_TABLE_INDEX 0x04</span>
00824 <span class="preprocessor"></span>
00825 <span class="comment">//</span>
00826 <span class="comment">// Entry of Interrupt Descriptor Table (IDTENTRY)</span>
00827 <span class="comment">//</span>
00828 
00829 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KIDTENTRY {
00830    <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
00831    <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> Selector;
00832    <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> Access;
00833    <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> ExtendedOffset;
00834 } KIDTENTRY;
00835 
00836 <span class="keyword">typedef</span> KIDTENTRY *PKIDTENTRY;
00837 
00838 
00839 <span class="comment">//</span>
00840 <span class="comment">// TSS (Task switch segment) NT only uses to control stack switches.</span>
00841 <span class="comment">//</span>
00842 <span class="comment">//  The only fields we actually care about are Esp0, Ss0, the IoMapBase</span>
00843 <span class="comment">//  and the IoAccessMaps themselves.</span>
00844 <span class="comment">//</span>
00845 <span class="comment">//</span>
00846 <span class="comment">//  N.B.    Size of TSS must be &lt;= 0xDFFF</span>
00847 <span class="comment">//</span>
00848 
00849 <span class="comment">//</span>
00850 <span class="comment">// The interrupt direction bitmap is used on Pentium to allow</span>
00851 <span class="comment">// the processor to emulate V86 mode software interrupts for us.</span>
00852 <span class="comment">// There is one for each IOPM.  It is located by subtracting</span>
00853 <span class="comment">// 32 from the IOPM base in the Tss.</span>
00854 <span class="comment">//</span>
00855 <span class="preprocessor">#define INT_DIRECTION_MAP_SIZE   32</span>
00856 <span class="preprocessor"></span><span class="keyword">typedef</span> UCHAR   KINT_DIRECTION_MAP[INT_DIRECTION_MAP_SIZE];
00857 
00858 <span class="preprocessor">#define IOPM_COUNT      1           // Number of i/o access maps that</span>
00859 <span class="preprocessor"></span>                                    <span class="comment">// exist (in addition to</span>
00860                                     <span class="comment">// IO_ACCESS_MAP_NONE)</span>
00861 
00862 <span class="preprocessor">#define IO_ACCESS_MAP_NONE 0</span>
00863 <span class="preprocessor"></span>
00864 <span class="preprocessor">#define IOPM_SIZE           8192    // Size of map callers can set.</span>
00865 <span class="preprocessor"></span>
00866 <span class="preprocessor">#define PIOPM_SIZE          8196    // Size of structure we must allocate</span>
00867 <span class="preprocessor"></span>                                    <span class="comment">// to hold it.</span>
00868 
00869 <span class="keyword">typedef</span> UCHAR   KIO_ACCESS_MAP[IOPM_SIZE];
00870 
00871 <span class="keyword">typedef</span> KIO_ACCESS_MAP *PKIO_ACCESS_MAP;
00872 
00873 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KiIoAccessMap {
00874     KINT_DIRECTION_MAP DirectionMap;
00875     UCHAR IoMap[PIOPM_SIZE];
00876 } KIIO_ACCESS_MAP;
00877 
00878 
00879 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KTSS {
00880 
00881     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>  Backlink;
00882     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>  Reserved0;
00883 
00884     ULONG   Esp0;
00885     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>  Ss0;
00886     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>  <a class="code" href="../../d1/d9/arc_8h.html#a313a149">Reserved1</a>;
00887 
00888     ULONG   NotUsed1[4];
00889 
00890     ULONG   CR3;
00891 
00892     ULONG   Eip;
00893 
00894     ULONG   NotUsed2[9];
00895 
00896     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>  Es;
00897     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>  <a class="code" href="../../d1/d9/arc_8h.html#a313a160">Reserved2</a>;
00898 
00899     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>  Cs;
00900     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>  Reserved3;
00901 
00902     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>  Ss;
00903     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>  Reserved4;
00904 
00905     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>  Ds;
00906     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>  Reserved5;
00907 
00908     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>  Fs;
00909     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>  Reserved6;
00910 
00911     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>  Gs;
00912     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>  Reserved7;
00913 
00914     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>  LDT;
00915     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>  Reserved8;
00916 
00917     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>  Flags;
00918 
00919     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>  IoMapBase;
00920 
00921     KIIO_ACCESS_MAP IoMaps[IOPM_COUNT];
00922 
00923     <span class="comment">//</span>
00924     <span class="comment">// This is the Software interrupt direction bitmap associated with</span>
00925     <span class="comment">// IO_ACCESS_MAP_NONE</span>
00926     <span class="comment">//</span>
00927     KINT_DIRECTION_MAP IntDirectionMap;
00928 } KTSS, *PKTSS;
00929 
00930 
00931 <span class="preprocessor">#define KiComputeIopmOffset(MapNumber)          \</span>
00932 <span class="preprocessor">    (MapNumber == IO_ACCESS_MAP_NONE) ?         \</span>
00933 <span class="preprocessor">        (USHORT)(sizeof(KTSS)) :                    \</span>
00934 <span class="preprocessor">        (USHORT)(FIELD_OFFSET(KTSS, IoMaps[MapNumber-1].IoMap))</span>
00935 <span class="preprocessor"></span>
00936 <span class="comment">// begin_windbgkd</span>
00937 
00938 <span class="preprocessor">#ifdef _X86_</span>
00939 <span class="preprocessor"></span><span class="comment">//</span>
00940 <span class="comment">// Special Registers for i386</span>
00941 <span class="comment">//</span>
00942 
00943 <span class="keyword">typedef</span> <span class="keyword">struct </span>_DESCRIPTOR {
00944     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>  Pad;
00945     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>  Limit;
00946     ULONG   Base;
00947 } KDESCRIPTOR, *PKDESCRIPTOR;
00948 
00949 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KSPECIAL_REGISTERS {
00950     ULONG Cr0;
00951     ULONG Cr2;
00952     ULONG Cr3;
00953     ULONG Cr4;
00954     ULONG KernelDr0;
00955     ULONG KernelDr1;
00956     ULONG KernelDr2;
00957     ULONG KernelDr3;
00958     ULONG KernelDr6;
00959     ULONG KernelDr7;
00960     KDESCRIPTOR Gdtr;
00961     KDESCRIPTOR Idtr;
00962     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> Tr;
00963     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> Ldtr;
00964     ULONG Reserved[6];
00965 } KSPECIAL_REGISTERS, *PKSPECIAL_REGISTERS;
00966 
00967 <span class="comment">//</span>
00968 <span class="comment">// Processor State frame: Before a processor freezes itself, it</span>
00969 <span class="comment">// dumps the processor state to the processor state frame for</span>
00970 <span class="comment">// debugger to examine.</span>
00971 <span class="comment">//</span>
00972 
00973 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KPROCESSOR_STATE {
00974     <span class="keyword">struct </span>_CONTEXT ContextFrame;
00975     <span class="keyword">struct </span>_KSPECIAL_REGISTERS SpecialRegisters;
00976 } KPROCESSOR_STATE, *PKPROCESSOR_STATE;
00977 <span class="preprocessor">#endif // _X86_</span>
00978 <span class="preprocessor"></span><span class="comment">// end_windbgkd</span>
00979 
00980 <span class="comment">//</span>
00981 <span class="comment">// Processor Control Block (PRCB)</span>
00982 <span class="comment">//</span>
00983 
00984 <span class="preprocessor">#define PRCB_MAJOR_VERSION 1</span>
00985 <span class="preprocessor"></span><span class="preprocessor">#define PRCB_MINOR_VERSION 1</span>
00986 <span class="preprocessor"></span><span class="preprocessor">#define PRCB_BUILD_DEBUG        0x0001</span>
00987 <span class="preprocessor"></span><span class="preprocessor">#define PRCB_BUILD_UNIPROCESSOR 0x0002</span>
00988 <span class="preprocessor"></span>
00989 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KPRCB {
00990 
00991 <span class="comment">//</span>
00992 <span class="comment">// Start of the architecturally defined section of the PRCB. This section</span>
00993 <span class="comment">// may be directly addressed by vendor/platform specific HAL code and will</span>
00994 <span class="comment">// not change from version to version of NT.</span>
00995 <span class="comment">//</span>
00996     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> MinorVersion;
00997     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> MajorVersion;
00998 
00999     <span class="keyword">struct </span><a class="code" href="../../d1/d8/struct__KTHREAD.html">_KTHREAD</a> *CurrentThread;
01000     <span class="keyword">struct </span><a class="code" href="../../d1/d8/struct__KTHREAD.html">_KTHREAD</a> *NextThread;
01001     <span class="keyword">struct </span><a class="code" href="../../d1/d8/struct__KTHREAD.html">_KTHREAD</a> *IdleThread;
01002 
01003     CCHAR  Number;
01004     CCHAR  Reserved;
01005     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> BuildType;
01006     KAFFINITY <a class="code" href="../../d0/d0/ki_8h.html#a7">SetMember</a>;
01007 
01008     CCHAR   CpuType;
01009     CCHAR   CpuID;
01010     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>  CpuStep;
01011 
01012     <span class="keyword">struct </span>_KPROCESSOR_STATE ProcessorState;
01013 
01014     ULONG   KernelReserved[16];         <span class="comment">// For use by the kernel</span>
01015     ULONG   HalReserved[16];            <span class="comment">// For use by Hal</span>
01016 
01017 <span class="comment">//</span>
01018 <span class="comment">// Per processor lock queue entries.</span>
01019 <span class="comment">//</span>
01020 
01021     <a class="code" href="../../d0/d8/struct__KSPIN__LOCK__QUEUE.html">KSPIN_LOCK_QUEUE</a> LockQueue[16];
01022 
01023 <span class="comment">// End of the architecturally defined section of the PRCB.</span>
01024 <span class="comment">// end_nthal</span>
01025 
01026     <span class="keyword">struct </span><a class="code" href="../../d1/d8/struct__KTHREAD.html">_KTHREAD</a> *NpxThread;
01027 
01028     ULONG   InterruptCount;             <span class="comment">// per processor counts</span>
01029     ULONG   KernelTime;
01030     ULONG   UserTime;
01031     ULONG   DpcTime;
01032     ULONG   InterruptTime;
01033     ULONG   ApcBypassCount;
01034     ULONG   DpcBypassCount;
01035     ULONG   AdjustDpcThreshold;
01036     ULONG   DebugDpcTime;               <span class="comment">// per dpc tick count</span>
01037     ULONG   <a class="code" href="../../d4/d9/ke_8h.html#a407a219">Spare2</a>[4];
01038 
01039     ULONG   ThreadStartCount[2];        <span class="comment">// perf data</span>
01040 
01041 
01042 <span class="comment">//  MP tuning..</span>
01043 
01044 <span class="comment">//</span>
01045 <span class="comment">//  Per-processor data for various hot code which resides in the</span>
01046 <span class="comment">//  kernel image.  We give each processor it's own copy of the data</span>
01047 <span class="comment">//  to lessen the caching impact of sharing the data between multiple</span>
01048 <span class="comment">//  processors.</span>
01049 <span class="comment">//</span>
01050 
01051 <span class="comment">//</span>
01052 <span class="comment">//  Spares (formerly fsrtl filelock free lists)</span>
01053 <span class="comment">//</span>
01054 
01055     PVOID SpareHotData[2];
01056 
01057 <span class="comment">//</span>
01058 <span class="comment">//  Cache manager performance counters.</span>
01059 <span class="comment">//</span>
01060 
01061     ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a44">CcFastReadNoWait</a>;
01062     ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a45">CcFastReadWait</a>;
01063     ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a47">CcFastReadNotPossible</a>;
01064     ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a61">CcCopyReadNoWait</a>;
01065     ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a62">CcCopyReadWait</a>;
01066     ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a63">CcCopyReadNoWaitMiss</a>;
01067 
01068 <span class="comment">//</span>
01069 <span class="comment">//  Kernel performance counters.</span>
01070 <span class="comment">//</span>
01071 
01072     ULONG KeAlignmentFixupCount;
01073     ULONG KeContextSwitches;
01074     ULONG <a class="code" href="../../d5/d9/kernldat_8c.html#a13">KeDcacheFlushCount</a>;
01075     ULONG KeExceptionDispatchCount;
01076     ULONG KeFirstLevelTbFills;
01077     ULONG KeFloatingEmulationCount;
01078     ULONG <a class="code" href="../../d5/d9/kernldat_8c.html#a14">KeIcacheFlushCount</a>;
01079     ULONG KeSecondLevelTbFills;
01080     ULONG KeSystemCalls;
01081 
01082 <span class="comment">//</span>
01083 <span class="comment">//  Reserved for future counters.</span>
01084 <span class="comment">//</span>
01085 
01086     ULONG ReservedCounter[8];
01087 
01088 <span class="comment">//</span>
01089 <span class="comment">// I/O system per processor single entry lookaside lists.</span>
01090 <span class="comment">//</span>
01091 
01092     PVOID SmallIrpFreeEntry;
01093     PVOID LargeIrpFreeEntry;
01094     PVOID MdlFreeEntry;
01095 
01096 <span class="comment">//</span>
01097 <span class="comment">// Object manager per processor single entry lookaside lists.</span>
01098 <span class="comment">//</span>
01099 
01100     PVOID CreateInfoFreeEntry;
01101     PVOID NameBufferFreeEntry;
01102 
01103 <span class="comment">//</span>
01104 <span class="comment">// Cache manager per processor single entry lookaside lists.</span>
01105 <span class="comment">//</span>
01106 
01107     PVOID SharedCacheMapEntry;
01108 
01109 <span class="comment">//</span>
01110 <span class="comment">// Cache pad.</span>
01111 <span class="comment">//</span>
01112 
01113     ULONG CachePad0[2];
01114 
01115 <span class="comment">//</span>
01116 <span class="comment">// Nonpaged per processor lookaside lists.</span>
01117 <span class="comment">//</span>
01118 
01119     <a class="code" href="../../d5/d9/struct__PP__LOOKASIDE__LIST.html">PP_LOOKASIDE_LIST</a> PPLookasideList[16];
01120 
01121 <span class="comment">//</span>
01122 <span class="comment">// Nonpaged per processor small pool lookaside lists.</span>
01123 <span class="comment">//</span>
01124 
01125     <a class="code" href="../../d5/d9/struct__PP__LOOKASIDE__LIST.html">PP_LOOKASIDE_LIST</a> PPNPagedLookasideList[<a class="code" href="../../d0/d9/ntosdef_8h.html#a2">POOL_SMALL_LISTS</a>];
01126 
01127 <span class="comment">//</span>
01128 <span class="comment">// Paged per processor small pool lookaside lists.</span>
01129 <span class="comment">//</span>
01130 
01131     <a class="code" href="../../d5/d9/struct__PP__LOOKASIDE__LIST.html">PP_LOOKASIDE_LIST</a> PPPagedLookasideList[<a class="code" href="../../d0/d9/ntosdef_8h.html#a2">POOL_SMALL_LISTS</a>];
01132 
01133 <span class="comment">//</span>
01134 <span class="comment">// Reserved Pad.</span>
01135 <span class="comment">//</span>
01136 
01137     UCHAR ReservedPad[16 * 8];
01138 
01139 <span class="comment">//</span>
01140 <span class="comment">// MP interprocessor request packet and summary.</span>
01141 <span class="comment">//</span>
01142 <span class="comment">// N.B. This is carefully aligned to be on a cache line boundary.</span>
01143 <span class="comment">//</span>
01144 
01145     <span class="keyword">volatile</span> PVOID CurrentPacket[3];
01146     <span class="keyword">volatile</span> KAFFINITY TargetSet;
01147     <span class="keyword">volatile</span> <a class="code" href="../../d0/d9/ntosdef_8h.html#a55">PKIPI_WORKER</a> WorkerRoutine;
01148     <span class="keyword">volatile</span> ULONG IpiFrozen;
01149     ULONG CachePad1[2];
01150 
01151 <span class="comment">//</span>
01152 <span class="comment">// MP interprocessor request summary and packet address.</span>
01153 <span class="comment">//</span>
01154 
01155     <span class="keyword">volatile</span> ULONG RequestSummary;
01156     <span class="keyword">volatile</span> <span class="keyword">struct </span>_KPRCB *SignalDone;
01157     <span class="keyword">volatile</span> ULONG ReverseStall;
01158     PVOID IpiFrame;
01159     ULONG CachePad2[4];
01160 
01161 <span class="comment">//</span>
01162 <span class="comment">// DPC interrupt requested.</span>
01163 <span class="comment">//</span>
01164 
01165     ULONG DpcInterruptRequested;
01166 
01167 <span class="comment">//</span>
01168 <span class="comment">// Per processor chained interrupt list.</span>
01169 <span class="comment">// (This is not here for any performance reason, it seemed reasonable</span>
01170 <span class="comment">// to use a cache pad dword for something useful).</span>
01171 <span class="comment">//</span>
01172 
01173     PVOID ChainedInterruptList;
01174     ULONG CachePad3[2];
01175 
01176 <span class="comment">//</span>
01177 <span class="comment">// DPC batching parameters.</span>
01178 <span class="comment">//</span>
01179 
01180     ULONG MaximumDpcQueueDepth;
01181     ULONG MinimumDpcRate;
01182     ULONG CachePad4[2];
01183 
01184 <span class="comment">//</span>
01185 <span class="comment">// DPC list head, spinlock, and count.</span>
01186 <span class="comment">//</span>
01187 
01188     LIST_ENTRY DpcListHead;
01189     ULONG DpcQueueDepth;
01190     ULONG DpcRoutineActive;
01191     ULONG DpcCount;
01192     ULONG DpcLastCount;
01193     ULONG DpcRequestRate;
01194     PVOID DpcStack;
01195 
01196     ULONG KernelReserved2[10];
01197     KSPIN_LOCK DpcLock;
01198 
01199 <span class="comment">//</span>
01200 <span class="comment">// Debug &amp; processor information</span>
01201 <span class="comment">//</span>
01202 
01203     BOOLEAN SkipTick;
01204     UCHAR VendorString[13];
01205     ULONG MHz;
01206     ULONG FeatureBits;
01207     LARGE_INTEGER UpdateSignature;
01208 
01209 <span class="comment">//</span>
01210 <span class="comment">// QuantumEnd indicator</span>
01211 <span class="comment">//</span>
01212 
01213     ULONG QuantumEnd;
01214 
01215 <span class="comment">//</span>
01216 <span class="comment">// Processors power state</span>
01217 <span class="comment">//</span>
01218 
01219     PROCESSOR_POWER_STATE PowerState;
01220 
01221 <span class="comment">//</span>
01222 <span class="comment">// Npx save area</span>
01223 <span class="comment">//</span>
01224     FX_SAVE_AREA    NpxSaveArea;
01225 
01226 <span class="comment">// begin_nthal</span>
01227 } KPRCB, *PKPRCB, *RESTRICTED_POINTER PRKPRCB;
01228 
01229 <span class="comment">// begin_ntddk</span>
01230 
01231 <span class="comment">//</span>
01232 <span class="comment">// Processor Control Region Structure Definition</span>
01233 <span class="comment">//</span>
01234 
01235 <span class="preprocessor">#define PCR_MINOR_VERSION 1</span>
01236 <span class="preprocessor"></span><span class="preprocessor">#define PCR_MAJOR_VERSION 1</span>
01237 <span class="preprocessor"></span>
01238 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KPCR {
01239 
01240 <span class="comment">//</span>
01241 <span class="comment">// Start of the architecturally defined section of the PCR. This section</span>
01242 <span class="comment">// may be directly addressed by vendor/platform specific HAL code and will</span>
01243 <span class="comment">// not change from version to version of NT.</span>
01244 <span class="comment">//</span>
01245 
01246     NT_TIB  NtTib;
01247     <span class="keyword">struct </span>_KPCR *SelfPcr;              <span class="comment">// flat address of this PCR</span>
01248     <span class="keyword">struct </span>_KPRCB *Prcb;                <span class="comment">// pointer to Prcb</span>
01249     KIRQL   Irql;
01250     ULONG   IRR;
01251     ULONG   IrrActive;
01252     ULONG   IDR;
01253     ULONG   <a class="code" href="../../d1/d9/arc_8h.html#a313a160">Reserved2</a>;
01254 
01255     <span class="keyword">struct </span>_KIDTENTRY *<a class="code" href="../../d6/d9/kernlini_8c.html#a27">IDT</a>;
01256     <span class="keyword">struct </span>_KGDTENTRY *GDT;
01257     <span class="keyword">struct </span>_KTSS      *TSS;
01258     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>  MajorVersion;
01259     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>  MinorVersion;
01260     KAFFINITY <a class="code" href="../../d0/d0/ki_8h.html#a7">SetMember</a>;
01261     ULONG   StallScaleFactor;
01262     UCHAR   DebugActive;
01263     UCHAR   Number;
01264 
01265 <span class="comment">// end_ntddk</span>
01266 
01267     UCHAR   VdmAlert;
01268     UCHAR   Reserved[1];                <span class="comment">// dword align</span>
01269     ULONG   KernelReserved[15];         <span class="comment">// For use by the kernel</span>
01270     ULONG   SecondLevelCacheSize;
01271     ULONG   HalReserved[16];            <span class="comment">// For use by Hal</span>
01272 
01273 <span class="comment">// End of the architecturally defined section of the PCR.</span>
01274 <span class="comment">// end_nthal</span>
01275 
01276     ULONG   InterruptMode;
01277     UCHAR   Spare1;
01278     ULONG   KernelReserved2[17];
01279     <span class="keyword">struct </span>_KPRCB PrcbData;
01280 
01281 <span class="comment">// begin_nthal begin_ntddk</span>
01282 } KPCR;
01283 <span class="keyword">typedef</span> KPCR *PKPCR;
01284 
01285 <span class="comment">// end_nthal end_ntddk</span>
01286 
01287 
01288 <span class="comment">//</span>
01289 <span class="comment">// Sanitize segCS and eFlags based on a processor mode.</span>
01290 <span class="comment">//</span>
01291 <span class="comment">// If kernel mode,</span>
01292 <span class="comment">//      force CPL == 0</span>
01293 <span class="comment">//</span>
01294 <span class="comment">// If user mode,</span>
01295 <span class="comment">//      force CPL == 3</span>
01296 <span class="comment">//</span>
01297 
01298 <span class="preprocessor">#define SANITIZE_SEG(segCS, mode) (\</span>
01299 <span class="preprocessor">    ((mode) == KernelMode ? \</span>
01300 <span class="preprocessor">        ((0x00000000L) | ((segCS) &amp; 0xfffc)) : \</span>
01301 <span class="preprocessor">        ((0x00000003L) | ((segCS) &amp; 0xffff))))</span>
01302 <span class="preprocessor"></span>
01303 <span class="comment">//</span>
01304 <span class="comment">// If kernel mode, then</span>
01305 <span class="comment">//      let caller specify Carry, Parity, AuxCarry, Zero, Sign, Trap,</span>
01306 <span class="comment">//      Direction, Overflow, Interrupt, AlignCheck.</span>
01307 <span class="comment">//</span>
01308 <span class="comment">// If user mode, then</span>
01309 <span class="comment">//      let caller specify Carry, Parity, AuxCarry, Zero, Sign, Trap,</span>
01310 <span class="comment">//      Direction, Overflow, AlignCheck.</span>
01311 <span class="comment">//      force Interrupts on.</span>
01312 <span class="comment">//</span>
01313 
01314 <span class="preprocessor">#define EFLAGS_DF_MASK        0x00000400L</span>
01315 <span class="preprocessor"></span><span class="preprocessor">#define EFLAGS_INTERRUPT_MASK 0x00000200L</span>
01316 <span class="preprocessor"></span><span class="preprocessor">#define EFLAGS_V86_MASK       0x00020000L</span>
01317 <span class="preprocessor"></span><span class="preprocessor">#define EFLAGS_ALIGN_CHECK    0x00040000L</span>
01318 <span class="preprocessor"></span><span class="preprocessor">#define EFLAGS_IOPL_MASK      0x00003000L</span>
01319 <span class="preprocessor"></span><span class="preprocessor">#define EFLAGS_VIF            0x00080000L</span>
01320 <span class="preprocessor"></span><span class="preprocessor">#define EFLAGS_VIP            0x00100000L</span>
01321 <span class="preprocessor"></span><span class="preprocessor">#define EFLAGS_USER_SANITIZE  0x003e0dd7L</span>
01322 <span class="preprocessor"></span>
01323 <span class="preprocessor">#define SANITIZE_FLAGS(eFlags, mode) (\</span>
01324 <span class="preprocessor">    ((mode) == KernelMode ? \</span>
01325 <span class="preprocessor">        ((0x00000000L) | ((eFlags) &amp; 0x003e0fd7)) : \</span>
01326 <span class="preprocessor">        ((((eFlags) &amp; EFLAGS_V86_MASK) &amp;&amp; KeI386VdmIoplAllowed) ? \</span>
01327 <span class="preprocessor">        (((eFlags) &amp; KeI386EFlagsAndMaskV86) | KeI386EFlagsOrMaskV86) : \</span>
01328 <span class="preprocessor">        ((EFLAGS_INTERRUPT_MASK) | ((eFlags) &amp; EFLAGS_USER_SANITIZE)))))</span>
01329 <span class="preprocessor"></span>
01330 <span class="comment">//</span>
01331 <span class="comment">// Masks for Dr7 and sanitize macros for various Dr registers.</span>
01332 <span class="comment">//</span>
01333 
01334 <span class="preprocessor">#define DR6_LEGAL   0x0000e00f</span>
01335 <span class="preprocessor"></span>
01336 <span class="preprocessor">#define DR7_LEGAL   0xffff0155  // R/W, LEN for Dr0-Dr4,</span>
01337 <span class="preprocessor"></span>                                <span class="comment">// Local enable for Dr0-Dr4,</span>
01338                                 <span class="comment">// Le for "perfect" trapping</span>
01339 
01340 <span class="preprocessor">#define DR7_ACTIVE  0x00000055  // If any of these bits are set, a Dr is active</span>
01341 <span class="preprocessor"></span>
01342 <span class="preprocessor">#define SANITIZE_DR6(Dr6, mode) ((Dr6 &amp; DR6_LEGAL));</span>
01343 <span class="preprocessor"></span>
01344 <span class="preprocessor">#define SANITIZE_DR7(Dr7, mode) ((Dr7 &amp; DR7_LEGAL));</span>
01345 <span class="preprocessor"></span>
01346 <span class="preprocessor">#define SANITIZE_DRADDR(DrReg, mode) (          \</span>
01347 <span class="preprocessor">    (mode) == KernelMode ?                      \</span>
01348 <span class="preprocessor">        (DrReg) :                               \</span>
01349 <span class="preprocessor">        (((PVOID)DrReg &lt;= MM_HIGHEST_USER_ADDRESS) ?   \</span>
01350 <span class="preprocessor">            (DrReg) :                           \</span>
01351 <span class="preprocessor">            (0)                                 \</span>
01352 <span class="preprocessor">        )                                       \</span>
01353 <span class="preprocessor">    )</span>
01354 <span class="preprocessor"></span>
01355 <span class="comment">//</span>
01356 <span class="comment">// Define macro to clear reserved bits from MXCSR so that we don't</span>
01357 <span class="comment">// GP fault when doing an FRSTOR</span>
01358 <span class="comment">//</span>
01359 <span class="preprocessor">#define SANITIZE_MXCSR(_mxcsr_) ((_mxcsr_) &amp; 0xFFBF)</span>
01360 <span class="preprocessor"></span>
01361 <span class="comment">//</span>
01362 <span class="comment">// Nonvolatile context pointers</span>
01363 <span class="comment">//</span>
01364 <span class="comment">// BUGBUG bryanwi 21 feb 90 - This is bogus.  The 386 doesn't have</span>
01365 <span class="comment">//                            enough nonvolatile context to make this</span>
01366 <span class="comment">//                            structure worthwhile.  Can't declare a</span>
01367 <span class="comment">//                            field to be void, so declare a Junk structure</span>
01368 <span class="comment">//                            instead.</span>
01369 
01370 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KNONVOLATILE_CONTEXT_POINTERS {
01371     ULONG   Junk;
01372 } KNONVOLATILE_CONTEXT_POINTERS,  *PKNONVOLATILE_CONTEXT_POINTERS;
01373 
01374 <span class="comment">// begin_nthal</span>
01375 <span class="comment">//</span>
01376 <span class="comment">// Trap frame</span>
01377 <span class="comment">//</span>
01378 <span class="comment">//  NOTE - We deal only with 32bit registers, so the assembler equivalents</span>
01379 <span class="comment">//         are always the extended forms.</span>
01380 <span class="comment">//</span>
01381 <span class="comment">//  NOTE - Unless you want to run like slow molasses everywhere in the</span>
01382 <span class="comment">//         the system, this structure must be of DWORD length, DWORD</span>
01383 <span class="comment">//         aligned, and its elements must all be DWORD aligned.</span>
01384 <span class="comment">//</span>
01385 <span class="comment">//  NOTE WELL   -</span>
01386 <span class="comment">//</span>
01387 <span class="comment">//      The i386 does not build stack frames in a consistent format, the</span>
01388 <span class="comment">//      frames vary depending on whether or not a privilege transition</span>
01389 <span class="comment">//      was involved.</span>
01390 <span class="comment">//</span>
01391 <span class="comment">//      In order to make NtContinue work for both user mode and kernel</span>
01392 <span class="comment">//      mode callers, we must force a canonical stack.</span>
01393 <span class="comment">//</span>
01394 <span class="comment">//      If we're called from kernel mode, this structure is 8 bytes longer</span>
01395 <span class="comment">//      than the actual frame!</span>
01396 <span class="comment">//</span>
01397 <span class="comment">//  WARNING:</span>
01398 <span class="comment">//</span>
01399 <span class="comment">//      KTRAP_FRAME_LENGTH needs to be 16byte integral (at present.)</span>
01400 <span class="comment">//</span>
01401 
01402 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KTRAP_FRAME {
01403 
01404 
01405 <span class="comment">//</span>
01406 <span class="comment">//  Following 4 values are only used and defined for DBG systems,</span>
01407 <span class="comment">//  but are always allocated to make switching from DBG to non-DBG</span>
01408 <span class="comment">//  and back quicker.  They are not DEVL because they have a non-0</span>
01409 <span class="comment">//  performance impact.</span>
01410 <span class="comment">//</span>
01411 
01412     ULONG   DbgEbp;         <span class="comment">// Copy of User EBP set up so KB will work.</span>
01413     ULONG   DbgEip;         <span class="comment">// EIP of caller to system call, again, for KB.</span>
01414     ULONG   DbgArgMark;     <span class="comment">// Marker to show no args here.</span>
01415     ULONG   DbgArgPointer;  <span class="comment">// Pointer to the actual args</span>
01416 
01417 <span class="comment">//</span>
01418 <span class="comment">//  Temporary values used when frames are edited.</span>
01419 <span class="comment">//</span>
01420 <span class="comment">//</span>
01421 <span class="comment">//  NOTE:   Any code that want's ESP must materialize it, since it</span>
01422 <span class="comment">//          is not stored in the frame for kernel mode callers.</span>
01423 <span class="comment">//</span>
01424 <span class="comment">//          And code that sets ESP in a KERNEL mode frame, must put</span>
01425 <span class="comment">//          the new value in TempEsp, make sure that TempSegCs holds</span>
01426 <span class="comment">//          the real SegCs value, and put a special marker value into SegCs.</span>
01427 <span class="comment">//</span>
01428 
01429     ULONG   TempSegCs;
01430     ULONG   TempEsp;
01431 
01432 <span class="comment">//</span>
01433 <span class="comment">//  Debug registers.</span>
01434 <span class="comment">//</span>
01435 
01436     ULONG   Dr0;
01437     ULONG   Dr1;
01438     ULONG   Dr2;
01439     ULONG   Dr3;
01440     ULONG   Dr6;
01441     ULONG   Dr7;
01442 
01443 <span class="comment">//</span>
01444 <span class="comment">//  Segment registers</span>
01445 <span class="comment">//</span>
01446 
01447     ULONG   SegGs;
01448     ULONG   SegEs;
01449     ULONG   SegDs;
01450 
01451 <span class="comment">//</span>
01452 <span class="comment">//  Volatile registers</span>
01453 <span class="comment">//</span>
01454 
01455     ULONG   Edx;
01456     ULONG   Ecx;
01457     ULONG   Eax;
01458 
01459 <span class="comment">//</span>
01460 <span class="comment">//  Nesting state, not part of context record</span>
01461 <span class="comment">//</span>
01462 
01463     ULONG   PreviousPreviousMode;
01464 
01465     PEXCEPTION_REGISTRATION_RECORD ExceptionList;
01466                                             <span class="comment">// Trash if caller was user mode.</span>
01467                                             <span class="comment">// Saved exception list if caller</span>
01468                                             <span class="comment">// was kernel mode or we're in</span>
01469                                             <span class="comment">// an interrupt.</span>
01470 
01471 <span class="comment">//</span>
01472 <span class="comment">//  FS is TIB/PCR pointer, is here to make save sequence easy</span>
01473 <span class="comment">//</span>
01474 
01475     ULONG   SegFs;
01476 
01477 <span class="comment">//</span>
01478 <span class="comment">//  Non-volatile registers</span>
01479 <span class="comment">//</span>
01480 
01481     ULONG   Edi;
01482     ULONG   Esi;
01483     ULONG   Ebx;
01484     ULONG   Ebp;
01485 
01486 <span class="comment">//</span>
01487 <span class="comment">//  Control registers</span>
01488 <span class="comment">//</span>
01489 
01490     ULONG   ErrCode;
01491     ULONG   Eip;
01492     ULONG   SegCs;
01493     ULONG   EFlags;
01494 
01495     ULONG   HardwareEsp;    <span class="comment">// WARNING - segSS:esp are only here for stacks</span>
01496     ULONG   HardwareSegSs;  <span class="comment">// that involve a ring transition.</span>
01497 
01498     ULONG   V86Es;          <span class="comment">// these will be present for all transitions from</span>
01499     ULONG   V86Ds;          <span class="comment">// V86 mode</span>
01500     ULONG   V86Fs;
01501     ULONG   V86Gs;
01502 } KTRAP_FRAME;
01503 
01504 
01505 <span class="keyword">typedef</span> KTRAP_FRAME *PKTRAP_FRAME;
01506 <span class="keyword">typedef</span> KTRAP_FRAME *PKEXCEPTION_FRAME;
01507 
01508 <span class="preprocessor">#define KTRAP_FRAME_LENGTH  (sizeof(KTRAP_FRAME))</span>
01509 <span class="preprocessor"></span><span class="preprocessor">#define KTRAP_FRAME_ALIGN   (sizeof(ULONG))</span>
01510 <span class="preprocessor"></span><span class="preprocessor">#define KTRAP_FRAME_ROUND   (KTRAP_FRAME_ALIGN-1)</span>
01511 <span class="preprocessor"></span>
01512 <span class="comment">//</span>
01513 <span class="comment">//  Bits forced to 0 in SegCs if Esp has been edited.</span>
01514 <span class="comment">//</span>
01515 
01516 <span class="preprocessor">#define FRAME_EDITED        0xfff8</span>
01517 <span class="preprocessor"></span>
01518 <span class="comment">// end_nthal</span>
01519 
01520 <span class="comment">//</span>
01521 <span class="comment">// The frame saved by KiCallUserMode is defined here to allow</span>
01522 <span class="comment">// the kernel debugger to trace the entire kernel stack</span>
01523 <span class="comment">// when usermode callouts are pending.</span>
01524 <span class="comment">//</span>
01525 
01526 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KCALLOUT_FRAME {
01527     ULONG   InStk;          <span class="comment">// saved initial stack address</span>
01528     ULONG   TrFr;           <span class="comment">// saved callback trap frame</span>
01529     ULONG   CbStk;          <span class="comment">// saved callback stack address</span>
01530     ULONG   Edi;            <span class="comment">// saved nonvolatile registers</span>
01531     ULONG   Esi;            <span class="comment">//</span>
01532     ULONG   Ebx;            <span class="comment">//</span>
01533     ULONG   Ebp;            <span class="comment">//</span>
01534     ULONG   Ret;            <span class="comment">// saved return address</span>
01535     ULONG   OutBf;          <span class="comment">// address to store output buffer</span>
01536     ULONG   OutLn;          <span class="comment">// address to store output length</span>
01537 } KCALLOUT_FRAME;
01538 
01539 <span class="keyword">typedef</span> KCALLOUT_FRAME *PKCALLOUT_FRAME;
01540 
01541 
01542 <span class="comment">//</span>
01543 <span class="comment">// BUGBUG shielint  The second level vectors have not been defined.</span>
01544 <span class="comment">//</span>
01545 
01546 <span class="comment">// #define MAXIMUM_VECTOR 0x20   // Maximum Interrupt Vector</span>
01547 
01548 
01549 <span class="comment">//</span>
01550 <span class="comment">//  Switch Frame</span>
01551 <span class="comment">//</span>
01552 <span class="comment">//  386 doesn't have an "exception frame", and doesn't normally make</span>
01553 <span class="comment">//  any use of nonvolatile context register structures.</span>
01554 <span class="comment">//</span>
01555 <span class="comment">//  However, swapcontext in ctxswap.c and KeInitializeThread in</span>
01556 <span class="comment">//  thredini.c need to share common stack structure used at thread</span>
01557 <span class="comment">//  startup and switch time.</span>
01558 <span class="comment">//</span>
01559 <span class="comment">//  This is that structure.</span>
01560 <span class="comment">//</span>
01561 
01562 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KSWITCHFRAME {
01563     ULONG   ExceptionList;
01564     ULONG   Eflags;
01565     ULONG   RetAddr;
01566 } KSWITCHFRAME, *PKSWITCHFRAME;
01567 
01568 
01569 <span class="comment">//</span>
01570 <span class="comment">// Various 387 defines</span>
01571 <span class="comment">//</span>
01572 
01573 <span class="preprocessor">#define I386_80387_NP_VECTOR    0x07    // trap 7 when hardware not present</span>
01574 <span class="preprocessor"></span>
01575 <span class="comment">// begin_ntddk begin_wdm</span>
01576 <span class="comment">//</span>
01577 <span class="comment">// The non-volatile 387 state</span>
01578 <span class="comment">//</span>
01579 
01580 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KFLOATING_SAVE {
01581     ULONG   ControlWord;
01582     ULONG   StatusWord;
01583     ULONG   ErrorOffset;
01584     ULONG   ErrorSelector;
01585     ULONG   DataOffset;                 <span class="comment">// Not used in wdm</span>
01586     ULONG   DataSelector;
01587     ULONG   Cr0NpxState;
01588     ULONG   Spare1;                     <span class="comment">// Not used in wdm</span>
01589 } KFLOATING_SAVE, *PKFLOATING_SAVE;
01590 
01591 <span class="comment">// end_ntddk end_wdm</span>
01592 
01593 <span class="comment">//</span>
01594 <span class="comment">// i386 Profile values</span>
01595 <span class="comment">//</span>
01596 
01597 <span class="preprocessor">#define DEFAULT_PROFILE_INTERVAL   39063</span>
01598 <span class="preprocessor"></span>
01599 <span class="comment">//</span>
01600 <span class="comment">// The minimum acceptable profiling interval is set to 1221 which is the</span>
01601 <span class="comment">// fast RTC clock rate we can get.  If this</span>
01602 <span class="comment">// value is too small, the system will run very slowly.</span>
01603 <span class="comment">//</span>
01604 
01605 <span class="preprocessor">#define MINIMUM_PROFILE_INTERVAL   1221</span>
01606 <span class="preprocessor"></span>
01607 
01608 <span class="comment">// begin_ntddk begin_wdm begin_nthal begin_ntndis</span>
01609 <span class="comment">//</span>
01610 <span class="comment">// i386 Specific portions of mm component</span>
01611 <span class="comment">//</span>
01612 
01613 <span class="comment">//</span>
01614 <span class="comment">// Define the page size for the Intel 386 as 4096 (0x1000).</span>
01615 <span class="comment">//</span>
01616 
01617 <span class="preprocessor">#define PAGE_SIZE 0x1000</span>
01618 <span class="preprocessor"></span>
01619 <span class="comment">//</span>
01620 <span class="comment">// Define the number of trailing zeroes in a page aligned virtual address.</span>
01621 <span class="comment">// This is used as the shift count when shifting virtual addresses to</span>
01622 <span class="comment">// virtual page numbers.</span>
01623 <span class="comment">//</span>
01624 
01625 <span class="preprocessor">#define PAGE_SHIFT 12L</span>
01626 <span class="preprocessor"></span>
01627 <span class="comment">// end_ntndis end_wdm</span>
01628 <span class="comment">//</span>
01629 <span class="comment">// Define the number of bits to shift to right justify the Page Directory Index</span>
01630 <span class="comment">// field of a PTE.</span>
01631 <span class="comment">//</span>
01632 
01633 <span class="preprocessor">#define PDI_SHIFT_X86    22</span>
01634 <span class="preprocessor"></span><span class="preprocessor">#define PDI_SHIFT_X86PAE 21</span>
01635 <span class="preprocessor"></span>
01636 <span class="preprocessor">#if !defined (_X86PAE_)</span>
01637 <span class="preprocessor"></span><span class="preprocessor">#define PDI_SHIFT PDI_SHIFT_X86</span>
01638 <span class="preprocessor"></span><span class="preprocessor">#else</span>
01639 <span class="preprocessor"></span><span class="preprocessor">#define PDI_SHIFT PDI_SHIFT_X86PAE</span>
01640 <span class="preprocessor"></span><span class="preprocessor">#define PPI_SHIFT 30</span>
01641 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
01642 <span class="preprocessor"></span>
01643 <span class="comment">//</span>
01644 <span class="comment">// Define the number of bits to shift to right justify the Page Table Index</span>
01645 <span class="comment">// field of a PTE.</span>
01646 <span class="comment">//</span>
01647 
01648 <span class="preprocessor">#define PTI_SHIFT 12</span>
01649 <span class="preprocessor"></span>
01650 <span class="comment">//</span>
01651 <span class="comment">// Define the highest user address and user probe address.</span>
01652 <span class="comment">//</span>
01653 
01654 <span class="comment">// end_ntddk end_nthal</span>
01655 
01656 <span class="preprocessor">#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_)</span>
01657 <span class="preprocessor"></span>
01658 <span class="comment">// begin_ntddk begin_nthal</span>
01659 
01660 <span class="keyword">extern</span> PVOID *<a class="code" href="../../d0/d9/miglobal_8c.html#a0">MmHighestUserAddress</a>;
01661 <span class="keyword">extern</span> PVOID *<a class="code" href="../../d0/d9/miglobal_8c.html#a1">MmSystemRangeStart</a>;
01662 <span class="keyword">extern</span> ULONG *<a class="code" href="../../d0/d9/miglobal_8c.html#a2">MmUserProbeAddress</a>;
01663 
01664 <span class="preprocessor">#define MM_HIGHEST_USER_ADDRESS *MmHighestUserAddress</span>
01665 <span class="preprocessor"></span><span class="preprocessor">#define MM_SYSTEM_RANGE_START *MmSystemRangeStart</span>
01666 <span class="preprocessor"></span><span class="preprocessor">#define MM_USER_PROBE_ADDRESS *MmUserProbeAddress</span>
01667 <span class="preprocessor"></span>
01668 <span class="comment">// end_ntddk end_nthal</span>
01669 
01670 <span class="preprocessor">#else</span>
01671 <span class="preprocessor"></span>
01672 <span class="keyword">extern</span> PVOID <a class="code" href="../../d0/d9/miglobal_8c.html#a0">MmHighestUserAddress</a>;
01673 <span class="keyword">extern</span> PVOID <a class="code" href="../../d0/d9/miglobal_8c.html#a1">MmSystemRangeStart</a>;
01674 <span class="keyword">extern</span> ULONG <a class="code" href="../../d0/d9/miglobal_8c.html#a2">MmUserProbeAddress</a>;
01675 
01676 <span class="preprocessor">#define MM_HIGHEST_USER_ADDRESS MmHighestUserAddress</span>
01677 <span class="preprocessor"></span><span class="preprocessor">#define MM_SYSTEM_RANGE_START MmSystemRangeStart</span>
01678 <span class="preprocessor"></span><span class="preprocessor">#define MM_USER_PROBE_ADDRESS MmUserProbeAddress</span>
01679 <span class="preprocessor"></span>
01680 <span class="preprocessor">#endif</span>
01681 <span class="preprocessor"></span>
01682 <span class="comment">// begin_ntddk begin_nthal</span>
01683 <span class="comment">//</span>
01684 <span class="comment">// The lowest user address reserves the low 64k.</span>
01685 <span class="comment">//</span>
01686 
01687 <span class="preprocessor">#define MM_LOWEST_USER_ADDRESS (PVOID)0x10000</span>
01688 <span class="preprocessor"></span>
01689 <span class="comment">//</span>
01690 <span class="comment">// The lowest address for system space.</span>
01691 <span class="comment">//</span>
01692 
01693 <span class="preprocessor">#if !defined (_X86PAE_)</span>
01694 <span class="preprocessor"></span><span class="preprocessor">#define MM_LOWEST_SYSTEM_ADDRESS (PVOID)0xC0800000</span>
01695 <span class="preprocessor"></span><span class="preprocessor">#else</span>
01696 <span class="preprocessor"></span><span class="preprocessor">#define MM_LOWEST_SYSTEM_ADDRESS (PVOID)0xC0C00000</span>
01697 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
01698 <span class="preprocessor"></span>
01699 <span class="comment">// begin_wdm</span>
01700 
01701 <span class="preprocessor">#define MmGetProcedureAddress(Address) (Address)</span>
01702 <span class="preprocessor"></span><span class="preprocessor">#define MmLockPagableCodeSection(Address) MmLockPagableDataSection(Address)</span>
01703 <span class="preprocessor"></span>
01704 <span class="comment">// end_ntddk end_wdm</span>
01705 
01706 <span class="comment">//</span>
01707 <span class="comment">// Define the number of bits to shift to right justify the Page Directory Index</span>
01708 <span class="comment">// field of a PTE.</span>
01709 <span class="comment">//</span>
01710 
01711 <span class="preprocessor">#define PDI_SHIFT_X86    22</span>
01712 <span class="preprocessor"></span><span class="preprocessor">#define PDI_SHIFT_X86PAE 21</span>
01713 <span class="preprocessor"></span>
01714 <span class="preprocessor">#if !defined (_X86PAE_)</span>
01715 <span class="preprocessor"></span><span class="preprocessor">#define PDI_SHIFT PDI_SHIFT_X86</span>
01716 <span class="preprocessor"></span><span class="preprocessor">#else</span>
01717 <span class="preprocessor"></span><span class="preprocessor">#define PDI_SHIFT PDI_SHIFT_X86PAE</span>
01718 <span class="preprocessor"></span><span class="preprocessor">#define PPI_SHIFT 30</span>
01719 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
01720 <span class="preprocessor"></span>
01721 <span class="comment">//</span>
01722 <span class="comment">// Define the number of bits to shift to right justify the Page Table Index</span>
01723 <span class="comment">// field of a PTE.</span>
01724 <span class="comment">//</span>
01725 
01726 <span class="preprocessor">#define PTI_SHIFT 12</span>
01727 <span class="preprocessor"></span>
01728 <span class="comment">//</span>
01729 <span class="comment">// Define page directory and page base addresses.</span>
01730 <span class="comment">//</span>
01731 
01732 <span class="preprocessor">#define PDE_BASE_X86    0xc0300000</span>
01733 <span class="preprocessor"></span><span class="preprocessor">#define PDE_BASE_X86PAE 0xc0600000</span>
01734 <span class="preprocessor"></span>
01735 <span class="preprocessor">#if !defined (_X86PAE_)</span>
01736 <span class="preprocessor"></span><span class="preprocessor">#define PDE_BASE PDE_BASE_X86</span>
01737 <span class="preprocessor"></span><span class="preprocessor">#else</span>
01738 <span class="preprocessor"></span><span class="preprocessor">#define PDE_BASE PDE_BASE_X86PAE</span>
01739 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
01740 <span class="preprocessor"></span><span class="preprocessor">#define PTE_BASE 0xc0000000</span>
01741 <span class="preprocessor"></span>
01742 <span class="comment">// end_nthal</span>
01743 
01744 <span class="comment">//</span>
01745 <span class="comment">// Define virtual base and alternate virtual base of kernel.</span>
01746 <span class="comment">//</span>
01747 
01748 <span class="preprocessor">#define KSEG0_BASE 0x80000000</span>
01749 <span class="preprocessor"></span><span class="preprocessor">#define ALTERNATE_BASE (0xe1000000 - 64 * 1024 * 1024)</span>
01750 <span class="preprocessor"></span>
01751 <span class="comment">//</span>
01752 <span class="comment">// Define macro to initialize directory table base.</span>
01753 <span class="comment">//</span>
01754 
01755 <span class="preprocessor">#define INITIALIZE_DIRECTORY_TABLE_BASE(dirbase,pfn) \</span>
01756 <span class="preprocessor">     *((PULONG)(dirbase)) = ((pfn) &lt;&lt; PAGE_SHIFT)</span>
01757 <span class="preprocessor"></span>
01758 
01759 <span class="comment">// begin_nthal</span>
01760 <span class="comment">//</span>
01761 <span class="comment">// Location of primary PCR (used only for UP kernel &amp; hal code)</span>
01762 <span class="comment">//</span>
01763 
01764 <span class="comment">// addressed from 0xffdf0000 - 0xffdfffff are reserved for the system</span>
01765 <span class="comment">// (ie, not for use by the hal)</span>
01766 
01767 <span class="preprocessor">#define KI_BEGIN_KERNEL_RESERVED    0xffdf0000</span>
01768 <span class="preprocessor"></span><span class="preprocessor">#define KIP0PCRADDRESS              0xffdff000</span>
01769 <span class="preprocessor"></span>
01770 <span class="comment">// begin_ntddk</span>
01771 
01772 <span class="preprocessor">#define KI_USER_SHARED_DATA         0xffdf0000</span>
01773 <span class="preprocessor"></span><span class="preprocessor">#define SharedUserData  ((KUSER_SHARED_DATA * const) KI_USER_SHARED_DATA)</span>
01774 <span class="preprocessor"></span>
01775 <span class="comment">//</span>
01776 <span class="comment">// Result type definition for i386.  (Machine specific enumerate type</span>
01777 <span class="comment">// which is return type for portable exinterlockedincrement/decrement</span>
01778 <span class="comment">// procedures.)  In general, you should use the enumerated type defined</span>
01779 <span class="comment">// in ex.h instead of directly referencing these constants.</span>
01780 <span class="comment">//</span>
01781 
01782 <span class="comment">// Flags loaded into AH by LAHF instruction</span>
01783 
01784 <span class="preprocessor">#define EFLAG_SIGN      0x8000</span>
01785 <span class="preprocessor"></span><span class="preprocessor">#define EFLAG_ZERO      0x4000</span>
01786 <span class="preprocessor"></span><span class="preprocessor">#define EFLAG_SELECT    (EFLAG_SIGN | EFLAG_ZERO)</span>
01787 <span class="preprocessor"></span>
01788 <span class="preprocessor">#define RESULT_NEGATIVE ((EFLAG_SIGN &amp; ~EFLAG_ZERO) &amp; EFLAG_SELECT)</span>
01789 <span class="preprocessor"></span><span class="preprocessor">#define RESULT_ZERO     ((~EFLAG_SIGN &amp; EFLAG_ZERO) &amp; EFLAG_SELECT)</span>
01790 <span class="preprocessor"></span><span class="preprocessor">#define RESULT_POSITIVE ((~EFLAG_SIGN &amp; ~EFLAG_ZERO) &amp; EFLAG_SELECT)</span>
01791 <span class="preprocessor"></span>
01792 <span class="comment">//</span>
01793 <span class="comment">// Convert various portable ExInterlock APIs into their architectural</span>
01794 <span class="comment">// equivalents.</span>
01795 <span class="comment">//</span>
01796 
01797 <span class="preprocessor">#define ExInterlockedIncrementLong(Addend,Lock) \</span>
01798 <span class="preprocessor">        Exfi386InterlockedIncrementLong(Addend)</span>
01799 <span class="preprocessor"></span>
01800 <span class="preprocessor">#define ExInterlockedDecrementLong(Addend,Lock) \</span>
01801 <span class="preprocessor">        Exfi386InterlockedDecrementLong(Addend)</span>
01802 <span class="preprocessor"></span>
01803 <span class="preprocessor">#define ExInterlockedExchangeUlong(Target,Value,Lock) \</span>
01804 <span class="preprocessor">        Exfi386InterlockedExchangeUlong(Target,Value)</span>
01805 <span class="preprocessor"></span>
01806 <span class="comment">//  begin_wdm</span>
01807 
01808 <span class="preprocessor">#define ExInterlockedAddUlong           ExfInterlockedAddUlong</span>
01809 <span class="preprocessor"></span><span class="preprocessor">#define ExInterlockedInsertHeadList     ExfInterlockedInsertHeadList</span>
01810 <span class="preprocessor"></span><span class="preprocessor">#define ExInterlockedInsertTailList     ExfInterlockedInsertTailList</span>
01811 <span class="preprocessor"></span><span class="preprocessor">#define ExInterlockedRemoveHeadList     ExfInterlockedRemoveHeadList</span>
01812 <span class="preprocessor"></span><span class="preprocessor">#define ExInterlockedPopEntryList       ExfInterlockedPopEntryList</span>
01813 <span class="preprocessor"></span><span class="preprocessor">#define ExInterlockedPushEntryList      ExfInterlockedPushEntryList</span>
01814 <span class="preprocessor"></span>
01815 <span class="comment">//  end_wdm</span>
01816 
01817 <span class="comment">//</span>
01818 <span class="comment">// Prototypes for architectural specific versions of Exi386 Api</span>
01819 <span class="comment">//</span>
01820 
01821 <span class="comment">//</span>
01822 <span class="comment">// Interlocked result type is portable, but its values are machine specific.</span>
01823 <span class="comment">// Constants for value are in i386.h, mips.h, etc.</span>
01824 <span class="comment">//</span>
01825 
01826 <span class="keyword">typedef</span> <span class="keyword">enum</span> _INTERLOCKED_RESULT {
01827     ResultNegative = RESULT_NEGATIVE,
01828     ResultZero     = RESULT_ZERO,
01829     ResultPositive = RESULT_POSITIVE
01830 } INTERLOCKED_RESULT;
01831 
01832 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01833 INTERLOCKED_RESULT
01834 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
01835 Exfi386InterlockedIncrementLong (
01836     IN PLONG Addend
01837     );
01838 
01839 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01840 INTERLOCKED_RESULT
01841 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
01842 Exfi386InterlockedDecrementLong (
01843     IN PLONG Addend
01844     );
01845 
01846 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01847 LARGE_INTEGER
01848 ExInterlockedExchangeAddLargeInteger (
01849     IN PLARGE_INTEGER Addend,
01850     IN LARGE_INTEGER Increment,
01851     IN PKSPIN_LOCK Lock
01852     );
01853 
01854 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01855 ULONG
01856 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
01857 Exfi386InterlockedExchangeUlong (
01858     IN PULONG Target,
01859     IN ULONG Value
01860     );
01861 
01862 <span class="comment">//</span>
01863 <span class="comment">// Intrinsic interlocked functions</span>
01864 <span class="comment">//</span>
01865 
01866 <span class="preprocessor">#if (defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(NO_INTERLOCKED_INTRINSICS)) &amp;&amp; !defined(_WINBASE_)</span>
01867 <span class="preprocessor"></span>
01868 <span class="comment">//  begin_wdm</span>
01869 
01870 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01871 LONG
01872 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
01873 InterlockedIncrement(
01874     IN PLONG Addend
01875     );
01876 
01877 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01878 LONG
01879 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
01880 InterlockedDecrement(
01881     IN PLONG Addend
01882     );
01883 
01884 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01885 LONG
01886 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
01887 InterlockedExchange(
01888     IN OUT PLONG Target,
01889     IN LONG Value
01890     );
01891 
01892 <span class="preprocessor">#define InterlockedExchangePointer(Target, Value) \</span>
01893 <span class="preprocessor">   (PVOID)InterlockedExchange((PLONG)(Target), (LONG)(Value))</span>
01894 <span class="preprocessor"></span>
01895 LONG
01896 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
01897 InterlockedExchangeAdd(
01898     IN OUT PLONG Addend,
01899     IN LONG Increment
01900     );
01901 
01902 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01903 LONG
01904 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
01905 InterlockedCompareExchange(
01906     IN OUT PLONG Destination,
01907     IN LONG ExChange,
01908     IN LONG Comperand
01909     );
01910 
01911 <span class="preprocessor">#define InterlockedCompareExchangePointer(Destination, ExChange, Comperand) \</span>
01912 <span class="preprocessor">    (PVOID)InterlockedCompareExchange((PLONG)Destination, (LONG)ExChange, (LONG)Comperand)</span>
01913 <span class="preprocessor"></span>
01914 <span class="comment">//  end_wdm</span>
01915 
01916 <span class="preprocessor">#endif</span>
01917 <span class="preprocessor"></span>
01918 <span class="comment">// end_ntddk end_nthal</span>
01919 
01920 <span class="comment">//</span>
01921 <span class="comment">// UP/MP versions of interlocked intrinsics for use within ntoskrnl.exe.</span>
01922 <span class="comment">//</span>
01923 <span class="comment">// N.B. FASTCALL does NOT work with inline functions.</span>
01924 <span class="comment">//</span>
01925 
01926 <span class="preprocessor">#if !defined(_NTDDK_) &amp;&amp; !defined(_NTIFS_) &amp;&amp; !defined(_NTHAL_) &amp;&amp; !defined(_WINBASE_)</span>
01927 <span class="preprocessor"></span><span class="preprocessor">#if defined(_M_IX86) &amp;&amp; !defined(_CROSS_PLATFORM_)</span>
01928 <span class="preprocessor"></span>
01929 <span class="preprocessor">#pragma warning(disable:4035)               // wdm re-enable below</span>
01930 <span class="preprocessor"></span>
01931 <span class="preprocessor">#if !defined(MIDL_PASS) // wdm</span>
01932 <span class="preprocessor"></span>
01933 <span class="preprocessor">#if !defined(NO_INTERLOCKED_INTRINSICS)</span>
01934 <span class="preprocessor"></span><span class="preprocessor">#if defined(NT_UP)</span>
01935 <span class="preprocessor"></span>
01936 __inline
01937 LONG
01938 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
01939 InterlockedIncrement(
01940     IN PLONG Addend
01941     )
01942 {
01943     __asm {
01944         mov     eax, 1
01945         mov     ecx, Addend
01946         xadd    [ecx], eax
01947         inc     eax
01948     }
01949 }
01950 
01951 __inline
01952 LONG
01953 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
01954 InterlockedDecrement(
01955     IN PLONG Addend
01956     )
01957 {
01958     __asm {
01959         mov     eax, -1
01960         mov     ecx, Addend
01961         xadd    [ecx], eax
01962         dec     eax
01963     }
01964 }
01965 
01966 __inline
01967 LONG
01968 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
01969 InterlockedExchange(
01970     IN OUT PLONG Target,
01971     IN LONG Value
01972     )
01973 {
01974     __asm {
01975         mov     edx, Value
01976         mov     ecx, Target
01977         mov     eax, [ecx]
01978 ie:     cmpxchg [ecx], edx
01979         jnz     <span class="keywordtype">short</span> ie
01980     }
01981 }
01982 
01983 <span class="preprocessor">#define InterlockedExchangePointer(Target, Value) \</span>
01984 <span class="preprocessor">   (PVOID)InterlockedExchange((PLONG)Target, (LONG)Value)</span>
01985 <span class="preprocessor"></span>
01986 __inline
01987 LONG
01988 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
01989 InterlockedExchangeAdd(
01990     IN OUT PLONG Addend,
01991     IN LONG Increment
01992     )
01993 {
01994     __asm {
01995         mov     eax, <a class="code" href="../../d6/d4/rtl_2random_8c.html#a1">Increment</a>
01996         mov     ecx, Addend
01997         xadd    [ecx], eax
01998     }
01999 }
02000 
02001 __inline
02002 LONG
02003 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
02004 InterlockedCompareExchange(
02005     IN OUT PLONG Destination,
02006     IN LONG Exchange,
02007     IN LONG Comperand
02008     )
02009 {
02010     __asm {
02011         mov     eax, Comperand
02012         mov     ecx, Destination
02013         mov     edx, Exchange
02014         cmpxchg [ecx], edx
02015     }
02016 }
02017 
02018 <span class="preprocessor">#define InterlockedCompareExchangePointer(Destination, ExChange, Comperand) \</span>
02019 <span class="preprocessor">    (PVOID)InterlockedCompareExchange((PLONG)Destination, (LONG)ExChange, (LONG)Comperand)</span>
02020 <span class="preprocessor"></span>
02021 <span class="preprocessor">#else</span>
02022 <span class="preprocessor"></span>
02023 __inline
02024 LONG
02025 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
02026 InterlockedIncrement(
02027     IN PLONG Addend
02028     )
02029 {
02030     __asm {
02031         mov     eax, 1
02032         mov     ecx, Addend
02033    lock xadd    [ecx], eax
02034         inc     eax
02035     }
02036 }
02037 
02038 __inline
02039 LONG
02040 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
02041 InterlockedDecrement(
02042     IN PLONG Addend
02043     )
02044 {
02045     __asm {
02046         mov     eax, -1
02047         mov     ecx, Addend
02048    lock xadd    [ecx], eax
02049         dec     eax
02050     }
02051 }
02052 
02053 __inline
02054 LONG
02055 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
02056 InterlockedExchange(
02057     IN OUT PLONG Target,
02058     IN LONG Value
02059     )
02060 {
02061     __asm {
02062         mov     eax, Value
02063         mov     ecx, Target
02064         xchg    [ecx], eax
02065     }
02066 }
02067 
02068 <span class="preprocessor">#define InterlockedExchangePointer(Target, Value) \</span>
02069 <span class="preprocessor">   (PVOID)InterlockedExchange((PLONG)Target, (LONG)Value)</span>
02070 <span class="preprocessor"></span>
02071 <span class="comment">// begin_wdm</span>
02072 
02073 __inline
02074 LONG
02075 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
02076 InterlockedExchangeAdd(
02077     IN OUT PLONG Addend,
02078     IN LONG Increment
02079     )
02080 {
02081     __asm {
02082         mov     eax, <a class="code" href="../../d6/d4/rtl_2random_8c.html#a1">Increment</a>
02083         mov     ecx, Addend
02084    lock xadd    [ecx], eax
02085     }
02086 }
02087 
02088 
02089 <span class="comment">// end_wdm</span>
02090 
02091 __inline
02092 LONG
02093 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
02094 InterlockedCompareExchange(
02095     IN OUT PLONG Destination,
02096     IN LONG Exchange,
02097     IN LONG Comperand
02098     )
02099 {
02100     __asm {
02101         mov     eax, Comperand
02102         mov     ecx, Destination
02103         mov     edx, Exchange
02104    lock cmpxchg [ecx], edx
02105     }
02106 }
02107 
02108 <span class="preprocessor">#define InterlockedCompareExchangePointer(Destination, ExChange, Comperand) \</span>
02109 <span class="preprocessor">    (PVOID)InterlockedCompareExchange((PLONG)Destination, (LONG)ExChange, (LONG)Comperand)</span>
02110 <span class="preprocessor"></span>
02111 <span class="preprocessor">#endif      // wdm</span>
02112 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
02113 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
02114 <span class="preprocessor"></span>
02115 <span class="preprocessor">#pragma warning(default:4035)   // wdm</span>
02116 <span class="preprocessor"></span>
02117 <span class="preprocessor">#endif</span>
02118 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
02119 <span class="preprocessor"></span>
02120 <span class="comment">//</span>
02121 <span class="comment">// Structure for Ldt information in x86 processes</span>
02122 <span class="comment">//</span>
02123 
02124 <span class="keyword">typedef</span> <span class="keyword">struct </span>_LDTINFORMATION {
02125     ULONG <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
02126     ULONG AllocatedSize;
02127     PLDT_ENTRY Ldt;
02128 } LDTINFORMATION, *PLDTINFORMATION;
02129 
02130 <span class="comment">//</span>
02131 <span class="comment">// SetProcessInformation Structure for ProcessSetIoHandlers info class</span>
02132 <span class="comment">//</span>
02133 
02134 <span class="keyword">typedef</span> <span class="keyword">struct </span>_PROCESS_IO_PORT_HANDLER_INFORMATION {
02135     BOOLEAN Install;            <span class="comment">// true if handlers to be installed</span>
02136     ULONG NumEntries;
02137     ULONG Context;
02138     <a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html">PEMULATOR_ACCESS_ENTRY</a> EmulatorAccessEntries;
02139 } PROCESS_IO_PORT_HANDLER_INFORMATION, *PPROCESS_IO_PORT_HANDLER_INFORMATION;
02140 
02141 
02142 <span class="comment">//</span>
02143 <span class="comment">//    Vdm Objects and Io handling structure</span>
02144 <span class="comment">//</span>
02145 
02146 <span class="keyword">typedef</span> <span class="keyword">struct </span>_VDM_IO_HANDLER_FUNCTIONS {
02147     <a class="code" href="../../d4/d3/v86emul_8h.html#a10">PDRIVER_IO_PORT_ULONG</a>  UlongIo;
02148     <a class="code" href="../../d4/d3/v86emul_8h.html#a11">PDRIVER_IO_PORT_ULONG_STRING</a> UlongStringIo;
02149     <a class="code" href="../../d4/d3/v86emul_8h.html#a8">PDRIVER_IO_PORT_USHORT</a> UshortIo[2];
02150     <a class="code" href="../../d4/d3/v86emul_8h.html#a9">PDRIVER_IO_PORT_USHORT_STRING</a> UshortStringIo[2];
02151     <a class="code" href="../../d4/d3/v86emul_8h.html#a6">PDRIVER_IO_PORT_UCHAR</a> UcharIo[4];
02152     <a class="code" href="../../d4/d3/v86emul_8h.html#a7">PDRIVER_IO_PORT_UCHAR_STRING</a> UcharStringIo[4];
02153 } VDM_IO_HANDLER_FUNCTIONS, *PVDM_IO_HANDLER_FUNCTIONS;
02154 
02155 <span class="keyword">typedef</span> <span class="keyword">struct </span>_VDM_IO_HANDLER {
02156     <span class="keyword">struct </span>_VDM_IO_HANDLER *Next;
02157     ULONG PortNumber;
02158     VDM_IO_HANDLER_FUNCTIONS IoFunctions[2];
02159 } VDM_IO_HANDLER, *PVDM_IO_HANDLER;
02160 
02161 
02162 
02163 <span class="comment">// begin_nthal begin_ntddk begin_wdm</span>
02164 
02165 <span class="preprocessor">#if !defined(MIDL_PASS) &amp;&amp; defined(_M_IX86)</span>
02166 <span class="preprocessor"></span>
02167 <span class="comment">//</span>
02168 <span class="comment">// i386 function definitions</span>
02169 <span class="comment">//</span>
02170 
02171 <span class="preprocessor">#pragma warning(disable:4035)               // re-enable below</span>
02172 <span class="preprocessor"></span>
02173 <span class="comment">// end_ntddk end_wdm</span>
02174 
02175 <span class="preprocessor">#if NT_UP</span>
02176 <span class="preprocessor"></span><span class="preprocessor">    #define _PCR   ds:[KIP0PCRADDRESS]</span>
02177 <span class="preprocessor"></span><span class="preprocessor">#else</span>
02178 <span class="preprocessor"></span><span class="preprocessor">    #define _PCR   fs:[0]                   // ntddk</span>
02179 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
02180 <span class="preprocessor"></span>
02181 <span class="comment">//</span>
02182 <span class="comment">// Get address of current processor block.</span>
02183 <span class="comment">//</span>
02184 <span class="comment">// WARNING: This inline macro can only be used by the kernel or hal</span>
02185 <span class="comment">//</span>
02186 <span class="preprocessor">#define KiPcr() KeGetPcr()</span>
02187 <span class="preprocessor"></span>__inline PKPCR <a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a1">KeGetPcr</a>(VOID)
02188 {
02189 <span class="preprocessor">#if NT_UP</span>
02190 <span class="preprocessor"></span>    __asm {  mov eax, KIP0PCRADDRESS }
02191 <span class="preprocessor">#else</span>
02192 <span class="preprocessor"></span>    __asm {  mov eax, _PCR KPCR.SelfPcr  }
02193 <span class="preprocessor">#endif</span>
02194 <span class="preprocessor"></span>}
02195 
02196 <span class="comment">//</span>
02197 <span class="comment">// Get address of current processor block.</span>
02198 <span class="comment">//</span>
02199 <span class="comment">// WARNING: This inline macro can only be used by the kernel or hal</span>
02200 <span class="comment">//</span>
02201 __inline PKPRCB <a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a2">KeGetCurrentPrcb</a> (VOID)
02202 {
02203     __asm {  mov eax, _PCR KPCR.Prcb     }
02204 }
02205 
02206 <span class="comment">// begin_ntddk begin_wdm</span>
02207 
02208 <span class="comment">//</span>
02209 <span class="comment">// Get current IRQL.</span>
02210 <span class="comment">//</span>
02211 <span class="comment">// On x86 this function resides in the HAL</span>
02212 <span class="comment">//</span>
02213 
02214 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
02215 KIRQL
02216 KeGetCurrentIrql();
02217 
02218 <span class="comment">// end_wdm</span>
02219 <span class="comment">//</span>
02220 <span class="comment">// Get the current processor number</span>
02221 <span class="comment">//</span>
02222 
02223 __inline ULONG KeGetCurrentProcessorNumber(VOID)
02224 {
02225     __asm {  movzx eax, _PCR KPCR.Number  }
02226 }
02227 
02228 <span class="comment">// end_nthal end_ntddk</span>
02229 <span class="comment">//</span>
02230 <span class="comment">// Get address of current kernel thread object.</span>
02231 <span class="comment">//</span>
02232 <span class="comment">// WARNING: This inline macro can not be used for device drivers or HALs</span>
02233 <span class="comment">// they must call the kernel function KeGetCurrentThread.</span>
02234 <span class="comment">// WARNING: This inline macro is always MP enabled because filesystems</span>
02235 <span class="comment">// utilize it</span>
02236 <span class="comment">//</span>
02237 __inline <span class="keyword">struct </span><a class="code" href="../../d1/d8/struct__KTHREAD.html">_KTHREAD</a> *<a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a> (VOID)
02238 {
02239     __asm {  mov eax, fs:[0] KPCR.PrcbData.CurrentThread }
02240 }
02241 
02242 <span class="comment">//</span>
02243 <span class="comment">// If processor executing DPC?</span>
02244 <span class="comment">// WARNING: This inline macro is always MP enabled because filesystems</span>
02245 <span class="comment">// utilize it</span>
02246 <span class="comment">//</span>
02247 __inline ULONG KeIsExecutingDpc(VOID)
02248 {
02249     __asm {  mov eax, fs:[0] KPCR.PrcbData.DpcRoutineActive }
02250 }
02251 
02252 <span class="comment">// begin_nthal begin_ntddk begin_wdm</span>
02253 
02254 <span class="preprocessor">#endif // !defined(MIDL_PASS) &amp;&amp; defined(_M_IX86)</span>
02255 <span class="preprocessor"></span>
02256 <span class="comment">// end_nthal end_ntddk end_wdm</span>
02257 
02258 <span class="comment">//</span>
02259 <span class="comment">// Get previous processor mode.</span>
02260 <span class="comment">//</span>
02261 <span class="comment">// WARNING: This inline macro can not be used for device drivers or HALs</span>
02262 <span class="comment">//</span>
02263 <span class="comment">// KPROCESSOR_MODE</span>
02264 <span class="comment">// KeGetPreviousMode();</span>
02265 <span class="preprocessor">#define KeGetPreviousMode()     (KeGetCurrentThread()-&gt;PreviousMode)</span>
02266 <span class="preprocessor"></span>
02267 <span class="comment">// begin_nthal</span>
02268 <span class="comment">//</span>
02269 <span class="comment">// Macro to set address of a trap/interrupt handler to IDT</span>
02270 <span class="comment">//</span>
02271 <span class="preprocessor">#define KiSetHandlerAddressToIDT(Vector, HandlerAddress) \</span>
02272 <span class="preprocessor">    KeGetPcr()-&gt;IDT[Vector].ExtendedOffset = HIGHWORD(HandlerAddress); \</span>
02273 <span class="preprocessor">    KeGetPcr()-&gt;IDT[Vector].Offset = LOWWORD(HandlerAddress);</span>
02274 <span class="preprocessor"></span>
02275 <span class="comment">//</span>
02276 <span class="comment">// Macro to return address of a trap/interrupt handler in IDT</span>
02277 <span class="comment">//</span>
02278 <span class="preprocessor">#define KiReturnHandlerAddressFromIDT(Vector) \</span>
02279 <span class="preprocessor">   MAKEULONG(KiPcr()-&gt;IDT[Vector].ExtendedOffset, KiPcr()-&gt;IDT[Vector].Offset)</span>
02280 <span class="preprocessor"></span>
02281 <span class="preprocessor">#pragma warning(default:4035)</span>
02282 <span class="preprocessor"></span><span class="comment">// end_nthal</span>
02283 
02284 <span class="comment">//++</span>
02285 <span class="comment">//</span>
02286 <span class="comment">// BOOLEAN</span>
02287 <span class="comment">// KiIsThreadNumericStateSaved(</span>
02288 <span class="comment">//     IN PKTHREAD Address</span>
02289 <span class="comment">//     )</span>
02290 <span class="comment">//</span>
02291 <span class="comment">//--</span>
02292 <span class="preprocessor">#define KiIsThreadNumericStateSaved(a) \</span>
02293 <span class="preprocessor">    (a-&gt;NpxState != NPX_STATE_LOADED)</span>
02294 <span class="preprocessor"></span>
02295 <span class="comment">//++</span>
02296 <span class="comment">//</span>
02297 <span class="comment">// VOID</span>
02298 <span class="comment">// KiRundownThread(</span>
02299 <span class="comment">//     IN PKTHREAD Address</span>
02300 <span class="comment">//     )</span>
02301 <span class="comment">//</span>
02302 <span class="comment">//--</span>
02303 
02304 <span class="preprocessor">#if defined(NT_UP)</span>
02305 <span class="preprocessor"></span>
02306 <span class="comment">//</span>
02307 <span class="comment">// On UP x86 systems, FP state is lazy saved and loaded.  If this</span>
02308 <span class="comment">// thread owns the current FP context, clear the ownership field</span>
02309 <span class="comment">// so we will not try to save to this thread after it has been</span>
02310 <span class="comment">// terminated.</span>
02311 <span class="comment">//</span>
02312 
02313 <span class="preprocessor">#define KiRundownThread(a)                          \</span>
02314 <span class="preprocessor">    if (KeGetCurrentPrcb()-&gt;NpxThread == (a))   {   \</span>
02315 <span class="preprocessor">        KeGetCurrentPrcb()-&gt;NpxThread = NULL;       \</span>
02316 <span class="preprocessor">    }</span>
02317 <span class="preprocessor"></span>
02318 <span class="preprocessor">#else</span>
02319 <span class="preprocessor"></span>
02320 <span class="preprocessor">#define KiRundownThread(a)</span>
02321 <span class="preprocessor"></span>
02322 <span class="preprocessor">#endif</span>
02323 <span class="preprocessor"></span>
02324 <span class="comment">//</span>
02325 <span class="comment">// functions specific to 386 structure</span>
02326 <span class="comment">//</span>
02327 
02328 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
02329 KiSetIRR (
02330     IN ULONG SWInterruptMask
02331     );
02332 
02333 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
02334 <a class="code" href="../../d7/d3/i386init_8c.html#a13">KiInitializeGDT</a> (
02335     IN OUT PKGDTENTRY Gdt,
02336     IN USHORT GdtLimit,
02337     IN PKPCR Pcr,
02338     IN USHORT PcrLimit,
02339     IN PKTSS Tss,
02340     IN USHORT TssLimit,
02341     IN USHORT TebLimit
02342     );
02343 
02344 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
02345 <a class="code" href="../../d7/d3/i386init_8c.html#a14">KiInitializeGdtEntry</a> (
02346     OUT PKGDTENTRY GdtEntry,
02347     IN ULONG Base,
02348     IN ULONG Limit,
02349     IN USHORT Type,
02350     IN USHORT Dpl,
02351     IN USHORT Granularity
02352     );
02353 
02354 <span class="comment">//</span>
02355 <span class="comment">// Procedures to support frame manipulation</span>
02356 <span class="comment">//</span>
02357 
02358 ULONG
02359 <a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a13">KiEspFromTrapFrame</a>(
02360     IN PKTRAP_FRAME TrapFrame
02361     );
02362 
02363 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
02364 <a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a14">KiEspToTrapFrame</a>(
02365     IN PKTRAP_FRAME TrapFrame,
02366     IN ULONG Esp
02367     );
02368 
02369 ULONG
02370 <a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a15">KiSegSsFromTrapFrame</a>(
02371     IN PKTRAP_FRAME TrapFrame
02372     );
02373 
02374 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
02375 <a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a16">KiSegSsToTrapFrame</a>(
02376     IN PKTRAP_FRAME TrapFrame,
02377     IN ULONG SegSs
02378     );
02379 
02380 <span class="comment">//</span>
02381 <span class="comment">// Define prototypes for i386 specific clock and profile interrupt routines.</span>
02382 <span class="comment">//</span>
02383 
02384 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
02385 KiUpdateRunTime (
02386     VOID
02387     );
02388 
02389 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
02390 KiUpdateSystemTime (
02391     VOID
02392     );
02393 
02394 <span class="comment">// begin_ntddk begin_wdm</span>
02395 
02396 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
02397 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
02398 NTAPI
02399 <a class="code" href="../../d2/d0/ke_2i386_2misc_8c.html#a13">KeSaveFloatingPointState</a> (
02400     OUT PKFLOATING_SAVE     FloatSave
02401     );
02402 
02403 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
02404 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
02405 NTAPI
02406 <a class="code" href="../../d2/d0/ke_2i386_2misc_8c.html#a14">KeRestoreFloatingPointState</a> (
02407     IN PKFLOATING_SAVE      FloatSave
02408     );
02409 
02410 <span class="comment">// end_ntddk end_wdm</span>
02411 <span class="comment">// begin_nthal</span>
02412 
02413 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
02414 <a class="code" href="../../d1/d9/clock_8c.html#a5">KeProfileInterrupt</a> (
02415     IN KIRQL OldIrql,
02416     IN KTRAP_FRAME TrapFrame
02417     );
02418 
02419 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
02420 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
02421 <a class="code" href="../../d1/d9/clock_8c.html#a6">KeProfileInterruptWithSource</a> (
02422     IN <span class="keyword">struct</span> _KTRAP_FRAME *TrapFrame,
02423     IN KPROFILE_SOURCE ProfileSource
02424     );
02425 
02426 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
02427 KeUpdateRuntime (
02428     IN KIRQL OldIrql,
02429     IN KTRAP_FRAME TrapFrame
02430     );
02431 
02432 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
02433 <a class="code" href="../../d1/d9/clock_8c.html#a2">KeUpdateSystemTime</a> (
02434     IN KIRQL OldIrql,
02435     IN KTRAP_FRAME TrapFrame
02436     );
02437 
02438 <span class="comment">// begin_ntddk begin_wdm begin_ntndis</span>
02439 
02440 <span class="preprocessor">#endif // defined(_X86_)</span>
02441 <span class="preprocessor"></span>
02442 <span class="comment">// end_nthal end_ntddk end_wdm end_ntndis</span>
02443 
02444 <span class="comment">// begin_nthal begin_ntddk</span>
02445 
02446 <span class="comment">// Use the following for kernel mode runtime checks of X86 system architecture</span>
02447 
02448 <span class="preprocessor">#ifdef _X86_</span>
02449 <span class="preprocessor"></span>
02450 <span class="preprocessor">#ifdef IsNEC_98</span>
02451 <span class="preprocessor"></span><span class="preprocessor">#undef IsNEC_98</span>
02452 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
02453 <span class="preprocessor"></span>
02454 <span class="preprocessor">#ifdef IsNotNEC_98</span>
02455 <span class="preprocessor"></span><span class="preprocessor">#undef IsNotNEC_98</span>
02456 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
02457 <span class="preprocessor"></span>
02458 <span class="preprocessor">#ifdef SetNEC_98</span>
02459 <span class="preprocessor"></span><span class="preprocessor">#undef SetNEC_98</span>
02460 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
02461 <span class="preprocessor"></span>
02462 <span class="preprocessor">#ifdef SetNotNEC_98</span>
02463 <span class="preprocessor"></span><span class="preprocessor">#undef SetNotNEC_98</span>
02464 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
02465 <span class="preprocessor"></span>
02466 <span class="preprocessor">#define IsNEC_98     (SharedUserData-&gt;AlternativeArchitecture == NEC98x86)</span>
02467 <span class="preprocessor"></span><span class="preprocessor">#define IsNotNEC_98  (SharedUserData-&gt;AlternativeArchitecture != NEC98x86)</span>
02468 <span class="preprocessor"></span><span class="preprocessor">#define SetNEC_98    SharedUserData-&gt;AlternativeArchitecture = NEC98x86</span>
02469 <span class="preprocessor"></span><span class="preprocessor">#define SetNotNEC_98 SharedUserData-&gt;AlternativeArchitecture = StandardDesign</span>
02470 <span class="preprocessor"></span>
02471 <span class="preprocessor">#endif</span>
02472 <span class="preprocessor"></span>
02473 <span class="comment">// end_nthal end_ntddk</span>
02474 
02475 <span class="comment">//</span>
02476 <span class="comment">// i386 arch. specific kernel functions.</span>
02477 <span class="comment">//</span>
02478 
02479 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
02480 <a class="code" href="../../d4/d3/i386_2ldtsup_8c.html#a4">Ke386SetLdtProcess</a> (
02481     <span class="keyword">struct</span> <a class="code" href="../../d5/d7/struct__KPROCESS.html">_KPROCESS</a>  *Process,
02482     PLDT_ENTRY  Ldt,
02483     ULONG       Limit
02484     );
02485 
02486 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
02487 <a class="code" href="../../d4/d3/i386_2ldtsup_8c.html#a5">Ke386SetDescriptorProcess</a> (
02488     <span class="keyword">struct</span> <a class="code" href="../../d5/d7/struct__KPROCESS.html">_KPROCESS</a>  *Process,
02489     ULONG       Offset,
02490     LDT_ENTRY   LdtEntry
02491     );
02492 
02493 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
02494 <a class="code" href="../../d9/d8/i386_2gdtsup_8c.html#a0">Ke386GetGdtEntryThread</a> (
02495     <span class="keyword">struct</span> <a class="code" href="../../d1/d8/struct__KTHREAD.html">_KTHREAD</a> *Thread,
02496     ULONG Offset,
02497     PKGDTENTRY Descriptor
02498     );
02499 
02500 BOOLEAN
02501 <a class="code" href="../../d1/d6/i386_2iopm_8c.html#a4">Ke386SetIoAccessMap</a> (
02502     ULONG               MapNumber,
02503     PKIO_ACCESS_MAP     IoAccessMap
02504     );
02505 
02506 BOOLEAN
02507 <a class="code" href="../../d1/d6/i386_2iopm_8c.html#a5">Ke386QueryIoAccessMap</a> (
02508     ULONG              MapNumber,
02509     PKIO_ACCESS_MAP    IoAccessMap
02510     );
02511 
02512 BOOLEAN
02513 <a class="code" href="../../d1/d6/i386_2iopm_8c.html#a6">Ke386IoSetAccessProcess</a> (
02514     <span class="keyword">struct</span> <a class="code" href="../../d5/d7/struct__KPROCESS.html">_KPROCESS</a>    *Process,
02515     ULONG       MapNumber
02516     );
02517 
02518 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
02519 <a class="code" href="../../d1/d6/i386_2iopm_8c.html#a7">Ke386SetIOPL</a>(
02520     <span class="keyword">struct</span> <a class="code" href="../../d5/d7/struct__KPROCESS.html">_KPROCESS</a>    *Process
02521     );
02522 
02523 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
02524 <a class="code" href="../../d3/d1/biosc_8c.html#a10">Ke386CallBios</a> (
02525     IN ULONG BiosCommand,
02526     IN OUT PCONTEXT BiosArguments
02527     );
02528 
02529 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
02530 <a class="code" href="../../d5/d3/i386_8h.html#a34">KiEditIopmDpc</a> (
02531     IN <span class="keyword">struct</span> <a class="code" href="../../d1/d6/struct__KDPC.html">_KDPC</a> *Dpc,
02532     IN PVOID DeferredContext,
02533     IN PVOID SystemArgument1,
02534     IN PVOID SystemArgument2
02535     );
02536 
02537 BOOLEAN
02538 <a class="code" href="../../d8/d4/vdmint21_8c.html#a6">Ki386GetSelectorParameters</a>(
02539     IN USHORT Selector,
02540     OUT PULONG Flags,
02541     OUT PULONG Base,
02542     OUT PULONG Limit
02543     );
02544 
02545 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
02546 <a class="code" href="../../d8/d4/vdmint21_8c.html#a8">Ke386SetVdmInterruptHandler</a> (
02547     IN <span class="keyword">struct</span> <a class="code" href="../../d5/d7/struct__KPROCESS.html">_KPROCESS</a> *Process,
02548     IN ULONG Interrupt,
02549     IN USHORT Selector,
02550     IN ULONG  Offset,
02551     IN BOOLEAN Gate32
02552     );
02553 
02554 <span class="comment">//</span>
02555 <span class="comment">// i386 ABIOS specific routines.</span>
02556 <span class="comment">//</span>
02557 
02558 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
02559 <a class="code" href="../../d3/d3/abiosc_8c.html#a11">KeI386GetLid</a>(
02560     IN USHORT DeviceId,
02561     IN USHORT RelativeLid,
02562     IN BOOLEAN SharedLid,
02563     IN <span class="keyword">struct</span> <a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html">_DRIVER_OBJECT</a> *DeviceObject,
02564     OUT PUSHORT LogicalId
02565     );
02566 
02567 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
02568 <a class="code" href="../../d3/d3/abiosc_8c.html#a12">KeI386ReleaseLid</a>(
02569     IN USHORT LogicalId,
02570     IN <span class="keyword">struct</span> <a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html">_DRIVER_OBJECT</a> *DeviceObject
02571     );
02572 
02573 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
02574 <a class="code" href="../../d3/d3/abiosc_8c.html#a13">KeI386AbiosCall</a>(
02575     IN USHORT LogicalId,
02576     IN <span class="keyword">struct</span> <a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html">_DRIVER_OBJECT</a> *DriverObject,
02577     IN PUCHAR RequestBlock,
02578     IN USHORT EntryPoint
02579     );
02580 
02581 <span class="comment">//</span>
02582 <span class="comment">// i386 misc routines</span>
02583 <span class="comment">//</span>
02584 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
02585 <a class="code" href="../../d3/d3/abiosc_8c.html#a14">KeI386AllocateGdtSelectors</a>(
02586     OUT PUSHORT SelectorArray,
02587     IN USHORT NumberOfSelectors
02588     );
02589 
02590 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
02591 <a class="code" href="../../d5/d3/i386_8h.html#a41">KeI386Call16BitFunction</a> (
02592     IN OUT PCONTEXT Regs
02593     );
02594 
02595 <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>
02596 <a class="code" href="../../d5/d3/i386_8h.html#a42">KeI386Call16BitCStyleFunction</a> (
02597     IN ULONG EntryOffset,
02598     IN ULONG EntrySelector,
02599     IN PUCHAR Parameters,
02600     IN ULONG Size
02601     );
02602 
02603 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
02604 <a class="code" href="../../d3/d3/abiosc_8c.html#a16">KeI386FlatToGdtSelector</a>(
02605     IN ULONG SelectorBase,
02606     IN USHORT Length,
02607     IN USHORT Selector
02608     );
02609 
02610 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
02611 <a class="code" href="../../d3/d3/abiosc_8c.html#a15">KeI386ReleaseGdtSelectors</a>(
02612     OUT PUSHORT SelectorArray,
02613     IN USHORT NumberOfSelectors
02614     );
02615 
02616 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
02617 <a class="code" href="../../d9/d8/i386_2gdtsup_8c.html#a1">KeI386SetGdtSelector</a> (
02618     ULONG       Selector,
02619     PKGDTENTRY  GdtValue
02620     );
02621 
02622 
02623 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
02624 <a class="code" href="../../d6/d9/kernlini_8c.html#a60">KeOptimizeProcessorControlState</a> (
02625     VOID
02626     );
02627 
02628 <span class="comment">//</span>
02629 <span class="comment">// i386 Vdm specific functions</span>
02630 <span class="comment">//</span>
02631 BOOLEAN
02632 <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a20">Ke386VdmInsertQueueApc</a> (
02633     IN <a class="code" href="../../d1/d5/struct__KAPC.html">PKAPC</a>             Apc,
02634     IN <span class="keyword">struct</span> <a class="code" href="../../d1/d8/struct__KTHREAD.html">_KTHREAD</a>  *Thread,
02635     IN KPROCESSOR_MODE   ApcMode,
02636     IN PKKERNEL_ROUTINE  KernelRoutine,
02637     IN PKRUNDOWN_ROUTINE RundownRoutine OPTIONAL,
02638     IN PKNORMAL_ROUTINE  NormalRoutine  OPTIONAL,
02639     IN PVOID             NormalContext   OPTIONAL,
02640     IN KPRIORITY         Increment
02641     );
02642 
02643 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
02644 <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a21">Ke386VdmClearApcObject</a> (
02645     IN <a class="code" href="../../d1/d5/struct__KAPC.html">PKAPC</a> Apc
02646     );
02647 
02648 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
02649 <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a17">KeI386VdmInitialize</a> (
02650     VOID
02651     );
02652 
02653 <span class="comment">//</span>
02654 <span class="comment">// x86 functions for special instructions</span>
02655 <span class="comment">//</span>
02656 
02657 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
02658 <a class="code" href="../../d5/d3/i386_8h.html#a50">CPUID</a> (
02659     ULONG   InEax,
02660     PULONG  OutEax,
02661     PULONG  OutEbx,
02662     PULONG  OutEcx,
02663     PULONG  OutEdx
02664     );
02665 
02666 LONGLONG
02667 <a class="code" href="../../d5/d3/i386_8h.html#a51">RDTSC</a> (
02668     VOID
02669     );
02670 
02671 ULONGLONG
02672 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
02673 <a class="code" href="../../d5/d3/i386_8h.html#a52">RDMSR</a> (
02674     IN ULONG MsrRegister
02675     );
02676 
02677 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
02678 <a class="code" href="../../d5/d3/i386_8h.html#a53">WRMSR</a> (
02679     IN ULONG MsrRegister,
02680     IN ULONGLONG MsrValue
02681     );
02682 
02683 <span class="comment">//</span>
02684 <span class="comment">// i386 Vdm specific data</span>
02685 <span class="comment">//</span>
<a name="l02686"></a><a class="code" href="../../d5/d3/i386_8h.html#a17">02686</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d5/d3/i386_8h.html#a17">KeI386EFlagsAndMaskV86</a>;
<a name="l02687"></a><a class="code" href="../../d5/d3/i386_8h.html#a18">02687</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d5/d3/i386_8h.html#a18">KeI386EFlagsOrMaskV86</a>;
<a name="l02688"></a><a class="code" href="../../d5/d3/i386_8h.html#a19">02688</a> <span class="keyword">extern</span> BOOLEAN <a class="code" href="../../d5/d3/i386_8h.html#a19">KeI386VdmIoplAllowed</a>;
<a name="l02689"></a><a class="code" href="../../d5/d3/i386_8h.html#a20">02689</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d5/d3/i386_8h.html#a20">KeI386VirtualIntExtensions</a>;
02690 
02691 
<a name="l02692"></a><a class="code" href="../../d5/d3/i386_8h.html#a21">02692</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d5/d3/i386_8h.html#a21">KeI386CpuType</a>;
<a name="l02693"></a><a class="code" href="../../d5/d3/i386_8h.html#a22">02693</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d5/d3/i386_8h.html#a22">KeI386CpuStep</a>;
<a name="l02694"></a><a class="code" href="../../d5/d3/i386_8h.html#a23">02694</a> <span class="keyword">extern</span> BOOLEAN <a class="code" href="../../d5/d3/i386_8h.html#a23">KeI386NpxPresent</a>;
<a name="l02695"></a><a class="code" href="../../d5/d3/i386_8h.html#a24">02695</a> <span class="keyword">extern</span> BOOLEAN <a class="code" href="../../d5/d3/i386_8h.html#a24">KeI386FxsrPresent</a>;
02696 
02697 
02698 <span class="comment">//</span>
02699 <span class="comment">// i386 Feature bit definitions</span>
02700 <span class="comment">//</span>
02701 
<a name="l02702"></a><a class="code" href="../../d5/d3/i386_8h.html#a0">02702</a> <span class="preprocessor">#define KF_V86_VIS          0x00000001</span>
<a name="l02703"></a><a class="code" href="../../d5/d3/i386_8h.html#a1">02703</a> <span class="preprocessor"></span><span class="preprocessor">#define KF_RDTSC            0x00000002</span>
<a name="l02704"></a><a class="code" href="../../d5/d3/i386_8h.html#a2">02704</a> <span class="preprocessor"></span><span class="preprocessor">#define KF_CR4              0x00000004</span>
<a name="l02705"></a><a class="code" href="../../d5/d3/i386_8h.html#a3">02705</a> <span class="preprocessor"></span><span class="preprocessor">#define KF_CMOV             0x00000008</span>
<a name="l02706"></a><a class="code" href="../../d5/d3/i386_8h.html#a4">02706</a> <span class="preprocessor"></span><span class="preprocessor">#define KF_GLOBAL_PAGE      0x00000010</span>
<a name="l02707"></a><a class="code" href="../../d5/d3/i386_8h.html#a5">02707</a> <span class="preprocessor"></span><span class="preprocessor">#define KF_LARGE_PAGE       0x00000020</span>
<a name="l02708"></a><a class="code" href="../../d5/d3/i386_8h.html#a6">02708</a> <span class="preprocessor"></span><span class="preprocessor">#define KF_MTRR             0x00000040</span>
<a name="l02709"></a><a class="code" href="../../d5/d3/i386_8h.html#a7">02709</a> <span class="preprocessor"></span><span class="preprocessor">#define KF_CMPXCHG8B        0x00000080</span>
<a name="l02710"></a><a class="code" href="../../d5/d3/i386_8h.html#a8">02710</a> <span class="preprocessor"></span><span class="preprocessor">#define KF_MMX              0x00000100</span>
<a name="l02711"></a><a class="code" href="../../d5/d3/i386_8h.html#a9">02711</a> <span class="preprocessor"></span><span class="preprocessor">#define KF_WORKING_PTE      0x00000200</span>
<a name="l02712"></a><a class="code" href="../../d5/d3/i386_8h.html#a10">02712</a> <span class="preprocessor"></span><span class="preprocessor">#define KF_PAT              0x00000400</span>
<a name="l02713"></a><a class="code" href="../../d5/d3/i386_8h.html#a11">02713</a> <span class="preprocessor"></span><span class="preprocessor">#define KF_FXSR             0x00000800</span>
<a name="l02714"></a><a class="code" href="../../d5/d3/i386_8h.html#a12">02714</a> <span class="preprocessor"></span><span class="preprocessor">#define KF_FAST_SYSCALL     0x00001000</span>
<a name="l02715"></a><a class="code" href="../../d5/d3/i386_8h.html#a13">02715</a> <span class="preprocessor"></span><span class="preprocessor">#define KF_XMMI             0x00002000</span>
<a name="l02716"></a><a class="code" href="../../d5/d3/i386_8h.html#a14">02716</a> <span class="preprocessor"></span><span class="preprocessor">#define KF_3DNOW            0x00004000</span>
<a name="l02717"></a><a class="code" href="../../d5/d3/i386_8h.html#a15">02717</a> <span class="preprocessor"></span><span class="preprocessor">#define KF_AMDK6MTRR        0x00008000</span>
02718 <span class="preprocessor"></span>
02719 <span class="comment">//</span>
02720 <span class="comment">// Define macro to test if x86 feature is present.</span>
02721 <span class="comment">//</span>
02722 
<a name="l02723"></a><a class="code" href="../../d5/d3/i386_8h.html#a25">02723</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d5/d3/i386_8h.html#a25">KiBootFeatureBits</a>;
02724 
<a name="l02725"></a><a class="code" href="../../d5/d3/i386_8h.html#a16">02725</a> <span class="preprocessor">#define Isx86FeaturePresent(_f_) ((KiBootFeatureBits &amp; (_f_)) != 0)</span>
02726 <span class="preprocessor"></span>
02727 <span class="preprocessor">#endif // _i386_</span>
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:18 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
