<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: acceschk.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>acceschk.c</h1><a href="../../d5/d3/acceschk_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1989  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">   acceschk.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module contains the access check routines for memory management.</span>
00012 <span class="comment"></span>
00013 <span class="comment">Author:</span>
00014 <span class="comment"></span>
00015 <span class="comment">    Lou Perazzoli (loup) 10-Apr-1989</span>
00016 <span class="comment"></span>
00017 <span class="comment">Revision History:</span>
00018 <span class="comment"></span>
00019 <span class="comment">--*/</span>
00020 
00021 <span class="preprocessor">#include "<a class="code" href="../../d4/d8/mi_8h.html">mi.h</a>"</span>
00022 
00023 <span class="preprocessor">#if defined(_WIN64)</span>
00024 <span class="preprocessor"></span><span class="preprocessor">#include "wow64t.h"</span>
00025 <span class="preprocessor">#endif</span>
00026 <span class="preprocessor"></span>
00027 <span class="comment">//</span>
00028 <span class="comment">// MmReadWrite yields 0 if no-access, 10 if read-only, 11 if read-write.</span>
00029 <span class="comment">// It is indexed by a page protection.  The value of this array is added</span>
00030 <span class="comment">// to the !WriteOperation value.  If the value is 10 or less an access</span>
00031 <span class="comment">// violation is issued (read-only - write_operation) = 9,</span>
00032 <span class="comment">// (read_only - read_operation) = 10, etc.</span>
00033 <span class="comment">//</span>
00034 
<a name="l00035"></a><a class="code" href="../../d5/d3/acceschk_8c.html#a0">00035</a> CCHAR <a class="code" href="../../d5/d3/acceschk_8c.html#a0">MmReadWrite</a>[32] = {1, 10, 10, 10, 11, 11, 11, 11,
00036                          1, 10, 10, 10, 11, 11, 11, 11,
00037                          1, 10, 10, 10, 11, 11, 11, 11,
00038                          1, 10, 10, 10, 11, 11, 11, 11 };
00039 
00040 
00041 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00042"></a><a class="code" href="../../d4/d8/mi_8h.html#a833">00042</a> <a class="code" href="../../d4/d8/mi_8h.html#a833">MiAccessCheck</a> (
00043     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte,
00044     IN BOOLEAN WriteOperation,
00045     IN <a class="code" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> PreviousMode,
00046     IN ULONG Protection,
00047     IN BOOLEAN CallerHoldsPfnLock
00048     )
00049 
00050 <span class="comment">/*++</span>
00051 <span class="comment"></span>
00052 <span class="comment">Routine Description:</span>
00053 <span class="comment"></span>
00054 <span class="comment"></span>
00055 <span class="comment"></span>
00056 <span class="comment">Arguments:</span>
00057 <span class="comment"></span>
00058 <span class="comment">    PointerPte - Supplies the pointer to the PTE which caused the</span>
00059 <span class="comment">                 page fault.</span>
00060 <span class="comment"></span>
00061 <span class="comment">    WriteOperation - Supplies 1 if the operation is a write, 0 if</span>
00062 <span class="comment">                     the operation is a read.</span>
00063 <span class="comment"></span>
00064 <span class="comment">    PreviousMode - Supplies the previous mode, one of UserMode or KernelMode.</span>
00065 <span class="comment"></span>
00066 <span class="comment">    Protection - Supplies the protection mask to check.</span>
00067 <span class="comment"></span>
00068 <span class="comment">    CallerHoldsPfnLock - Supplies TRUE if the PFN lock is held, FALSE otherwise.</span>
00069 <span class="comment"></span>
00070 <span class="comment">Return Value:</span>
00071 <span class="comment"></span>
00072 <span class="comment">    Returns TRUE if access to the page is allowed, FALSE otherwise.</span>
00073 <span class="comment"></span>
00074 <span class="comment">Environment:</span>
00075 <span class="comment"></span>
00076 <span class="comment">    Kernel mode, APCs disabled.</span>
00077 <span class="comment"></span>
00078 <span class="comment">--*/</span>
00079 
00080 {
00081     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> PteContents;
00082     KIRQL OldIrql;
00083     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
00084 
00085     <span class="comment">//</span>
00086     <span class="comment">// Check to see if the owner bit allows access to the previous mode.</span>
00087     <span class="comment">// Access is not allowed if the owner is kernel and the previous</span>
00088     <span class="comment">// mode is user.  Access is also disallowed if the write operation</span>
00089     <span class="comment">// is true and the write field in the PTE is false.</span>
00090     <span class="comment">//</span>
00091 
00092     <span class="comment">//</span>
00093     <span class="comment">// If both an access violation and a guard page violation could</span>
00094     <span class="comment">// occur for the page, the access violation must be returned.</span>
00095     <span class="comment">//</span>
00096 
00097     <span class="keywordflow">if</span> (PreviousMode == <a class="code" href="../../d0/d9/ntosdef_8h.html#a76a70">UserMode</a>) {
00098         <span class="keywordflow">if</span> (PointerPte &gt; <a class="code" href="../../d4/d8/mi_8h.html#a755">MiHighestUserPte</a>) {
00099             <span class="keywordflow">return</span> STATUS_ACCESS_VIOLATION;
00100         }
00101     }
00102 
00103     PteContents = *PointerPte;
00104 
00105     <span class="keywordflow">if</span> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1) {
00106 
00107         <span class="comment">//</span>
00108         <span class="comment">// Valid pages cannot be guard page violations.</span>
00109         <span class="comment">//</span>
00110 
00111         <span class="keywordflow">if</span> (WriteOperation) {
00112             <span class="keywordflow">if</span> ((PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Write == 1) ||
00113                 (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.CopyOnWrite == 1)) {
00114                 <span class="keywordflow">return</span> STATUS_SUCCESS;
00115             } <span class="keywordflow">else</span> {
00116                 <span class="keywordflow">return</span> STATUS_ACCESS_VIOLATION;
00117             }
00118         } <span class="keywordflow">else</span> {
00119             <span class="keywordflow">return</span> STATUS_SUCCESS;
00120         }
00121 
00122     } <span class="keywordflow">else</span> {
00123 
00124         <span class="keywordflow">if</span> ((<a class="code" href="../../d5/d3/acceschk_8c.html#a0">MmReadWrite</a>[Protection] - (CCHAR)WriteOperation) &lt; 10) {
00125             <span class="keywordflow">return</span> STATUS_ACCESS_VIOLATION;
00126         } <span class="keywordflow">else</span> {
00127 
00128             <span class="comment">//</span>
00129             <span class="comment">// Check for a guard page fault.</span>
00130             <span class="comment">//</span>
00131 
00132             <span class="keywordflow">if</span> (Protection &amp; <a class="code" href="../../d4/d8/mi_8h.html#a44">MM_GUARD_PAGE</a>) {
00133 
00134                 <span class="comment">//</span>
00135                 <span class="comment">// If this thread is attached to a different process,</span>
00136                 <span class="comment">// return an access violation rather than a guard</span>
00137                 <span class="comment">// page exception.  The prevents problems with unwanted</span>
00138                 <span class="comment">// stack expansion and unexpected guard page behavior</span>
00139                 <span class="comment">// from debuggers.</span>
00140 
00141                 <span class="keywordflow">if</span> (<a class="code" href="../../d4/d9/ke_8h.html#a25">KeIsAttachedProcess</a>()) {
00142                     <span class="keywordflow">return</span> STATUS_ACCESS_VIOLATION;
00143                 }
00144 
00145                 <span class="comment">//</span>
00146                 <span class="comment">// Check to see if this is a transition PTE, if so,</span>
00147                 <span class="comment">// the PFN database original contents field needs to be</span>
00148                 <span class="comment">// updated.</span>
00149                 <span class="comment">//</span>
00150 
00151                 <span class="keywordflow">if</span> ((PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Transition == 1) &amp;&amp;
00152                     (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Prototype == 0)) {
00153 
00154                     <span class="comment">//</span>
00155                     <span class="comment">// Acquire the PFN mutex and check to see if the</span>
00156                     <span class="comment">// PTE is still in the transition state, and, if so</span>
00157                     <span class="comment">// update the original PTE in the pfn database.</span>
00158                     <span class="comment">//</span>
00159 
00160                     <span class="keywordflow">if</span> (CallerHoldsPfnLock == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00161                         <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
00162                     }
00163                     PteContents = *(<span class="keyword">volatile</span> <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> *)PointerPte;
00164                     <span class="keywordflow">if</span> ((PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Transition == 1) &amp;&amp;
00165                         (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Prototype == 0)) {
00166 
00167                         <span class="comment">//</span>
00168                         <span class="comment">// Still in transition, update the PFN database.</span>
00169                         <span class="comment">//</span>
00170 
00171                         Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (
00172                                     PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Trans.PageFrameNumber);
00173 
00174                         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PrototypePte == 0);
00175                         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Protection =
00176                                                   Protection &amp; ~<a class="code" href="../../d4/d8/mi_8h.html#a44">MM_GUARD_PAGE</a>;
00177                     }
00178                     <span class="keywordflow">if</span> (CallerHoldsPfnLock == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00179                         <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
00180                     }
00181                 }
00182 
00183                 PointerPte-&gt;u.Soft.Protection = Protection &amp; ~<a class="code" href="../../d4/d8/mi_8h.html#a44">MM_GUARD_PAGE</a>;
00184 
00185                 <span class="keywordflow">return</span> STATUS_GUARD_PAGE_VIOLATION;
00186             }
00187             <span class="keywordflow">return</span> STATUS_SUCCESS;
00188         }
00189     }
00190 }
00191 
00192 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00193 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l00194"></a><a class="code" href="../../d4/d8/mi_8h.html#a834">00194</a> <a class="code" href="../../d4/d8/mi_8h.html#a834">MiCheckForUserStackOverflow</a> (
00195     IN PVOID FaultingAddress
00196     )
00197 
00198 <span class="comment">/*++</span>
00199 <span class="comment"></span>
00200 <span class="comment">Routine Description:</span>
00201 <span class="comment"></span>
00202 <span class="comment">    This routine checks to see if the faulting address is within</span>
00203 <span class="comment">    the stack limits and if so tries to create another guard</span>
00204 <span class="comment">    page on the stack.  A stack over flow is returned if the</span>
00205 <span class="comment">    creation of a new guard page fails or if the stack is in</span>
00206 <span class="comment">    the following form:</span>
00207 <span class="comment"></span>
00208 <span class="comment"></span>
00209 <span class="comment">    stack   +----------------+</span>
00210 <span class="comment">    growth  |                |  StackBase</span>
00211 <span class="comment">      |     +----------------+</span>
00212 <span class="comment">      v     |                |</span>
00213 <span class="comment">            |   allocated    |</span>
00214 <span class="comment">            |                |</span>
00215 <span class="comment">            |    ...         |</span>
00216 <span class="comment">            |                |</span>
00217 <span class="comment">            +----------------+</span>
00218 <span class="comment">            | old guard page | &lt;- faulting address is in this page.</span>
00219 <span class="comment">            +----------------+</span>
00220 <span class="comment">            |                |</span>
00221 <span class="comment">            +----------------+</span>
00222 <span class="comment">            |                | last page of stack (always no access)</span>
00223 <span class="comment">            +----------------+</span>
00224 <span class="comment"></span>
00225 <span class="comment">    In this case, the page before the last page is committed, but</span>
00226 <span class="comment">    not as a guard page and a STACK_OVERFLOW condition is returned.</span>
00227 <span class="comment"></span>
00228 <span class="comment">Arguments:</span>
00229 <span class="comment"></span>
00230 <span class="comment">    FaultingAddress - Supplies the virtual address of the page which</span>
00231 <span class="comment">                      was a guard page.</span>
00232 <span class="comment"></span>
00233 <span class="comment">Return Value:</span>
00234 <span class="comment"></span>
00235 <span class="comment">    None.</span>
00236 <span class="comment"></span>
00237 <span class="comment">Environment:</span>
00238 <span class="comment"></span>
00239 <span class="comment">    Kernel mode. No mutexes held.</span>
00240 <span class="comment"></span>
00241 <span class="comment">--*/</span>
00242 
00243 {
00244     PTEB Teb;
00245     ULONG_PTR NextPage;
00246     SIZE_T RegionSize;
00247     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
00248     KIRQL OldIrql;
00249     <a class="code" href="../../d7/d2/struct__MMLOCK__CONFLICT.html">PMMLOCK_CONFLICT</a> Next;
00250     PVOID DeallocationStack;
00251     PVOID *StackLimit;
00252 
00253 <span class="preprocessor">#if defined(WX86) || defined(_AXP64_)</span>
00254 <span class="preprocessor"></span>    PWX86TIB  Wx86Tib;
00255 <span class="preprocessor">#endif</span>
00256 <span class="preprocessor"></span><span class="preprocessor">#if defined(_WIN64)</span>
00257 <span class="preprocessor"></span>    PTEB32 Teb32;
00258 <span class="preprocessor">#endif</span>
00259 <span class="preprocessor"></span>
00260     <span class="comment">//</span>
00261     <span class="comment">// Make sure we are not recursing with the address space or</span>
00262     <span class="comment">// working set lock held.</span>
00263     <span class="comment">//</span>
00264 
00265     <span class="keywordflow">if</span> (!IsListEmpty (&amp;<a class="code" href="../../d4/d8/mi_8h.html#a433">MmLockConflictList</a>)) {
00266         ExAcquireSpinLock (&amp;<a class="code" href="../../d4/d8/mi_8h.html#a690">MmChargeCommitmentLock</a>, &amp;OldIrql);
00267         Next = (<a class="code" href="../../d7/d2/struct__MMLOCK__CONFLICT.html">PMMLOCK_CONFLICT</a>)<a class="code" href="../../d4/d8/mi_8h.html#a433">MmLockConflictList</a>.Flink;
00268 
00269         <span class="keywordflow">while</span> ((PVOID)Next != &amp;<a class="code" href="../../d4/d8/mi_8h.html#a433">MmLockConflictList</a>) {
00270 
00271             <span class="keywordflow">if</span> (Next-&gt;<a class="code" href="../../d7/d2/struct__MMLOCK__CONFLICT.html#o1">Thread</a> == <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>()) {
00272                 ExReleaseSpinLock (&amp;<a class="code" href="../../d4/d8/mi_8h.html#a690">MmChargeCommitmentLock</a>, OldIrql);
00273                 <span class="keywordflow">return</span> STATUS_GUARD_PAGE_VIOLATION;
00274             }
00275             Next = (<a class="code" href="../../d7/d2/struct__MMLOCK__CONFLICT.html">PMMLOCK_CONFLICT</a>)Next-&gt;<a class="code" href="../../d7/d2/struct__MMLOCK__CONFLICT.html#o0">List</a>.Flink;
00276         }
00277         ExReleaseSpinLock (&amp;<a class="code" href="../../d4/d8/mi_8h.html#a690">MmChargeCommitmentLock</a>, OldIrql);
00278     }
00279 
00280     <span class="comment">//</span>
00281     <span class="comment">// Create an exception handler as the TEB is within the user's</span>
00282     <span class="comment">// address space.</span>
00283     <span class="comment">//</span>
00284 
00285     <span class="keywordflow">try</span> {
00286 
00287         Teb = NtCurrentTeb();
00288 
00289 <span class="preprocessor">#if defined(_IA64_)</span>
00290 <span class="preprocessor"></span>
00291       <span class="keywordflow">if</span> ((Teb-&gt;NtTib.StackBase &lt;= FaultingAddress) &amp;&amp;
00292           (Teb-&gt;DeallocationBStore &gt; FaultingAddress)) {
00293 
00294         <span class="comment">//</span>
00295         <span class="comment">// check to see if the faulting address is within</span>
00296         <span class="comment">// the bstore limits and if so tries to create another guard</span>
00297         <span class="comment">// page on the bstore.</span>
00298         <span class="comment">//</span>
00299         <span class="comment">//</span>
00300         <span class="comment">//          +----------------+</span>
00301         <span class="comment">//          |                | last page of stack (always no access)</span>
00302         <span class="comment">//          +----------------+</span>
00303         <span class="comment">//          |                |</span>
00304         <span class="comment">//          |                |</span>
00305         <span class="comment">//          |                |</span>
00306         <span class="comment">//          +----------------+</span>
00307         <span class="comment">//          | old guard page | &lt;- faulting address is in this page.               |</span>
00308         <span class="comment">//          +----------------+</span>
00309         <span class="comment">//  bstore  |                |</span>
00310         <span class="comment">//  growth  |    ......      |</span>
00311         <span class="comment">//          |                |</span>
00312         <span class="comment">//    ^     |   allocated    |</span>
00313         <span class="comment">//    |     |                |  StackBase</span>
00314         <span class="comment">//          +----------------+</span>
00315         <span class="comment">//</span>
00316         <span class="comment">//</span>
00317 
00318         NextPage = (ULONG_PTR)<a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a>(FaultingAddress) + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
00319 
00320         RegionSize = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
00321 
00322         <span class="keywordflow">if</span> ((NextPage + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>) &gt;= (ULONG_PTR)<a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a>(Teb-&gt;DeallocationBStore)) {
00323 
00324             <span class="comment">//</span>
00325             <span class="comment">// There is no more room for expansion, attempt to</span>
00326             <span class="comment">// commit the page before the last page of the</span>
00327             <span class="comment">// stack.</span>
00328             <span class="comment">//</span>
00329 
00330             NextPage = (ULONG_PTR)<a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a>(Teb-&gt;DeallocationBStore) - <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
00331 
00332             status = ZwAllocateVirtualMemory (NtCurrentProcess(),
00333                                               (PVOID *)&amp;NextPage,
00334                                               0,
00335                                               &amp;RegionSize,
00336                                               MEM_COMMIT,
00337                                               PAGE_READWRITE);
00338             <span class="keywordflow">if</span> ( <a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status) ) {
00339                 Teb-&gt;BStoreLimit = (PVOID)( (PUCHAR)NextPage);
00340             }
00341 
00342             <span class="keywordflow">return</span> STATUS_STACK_OVERFLOW;
00343         }
00344 
00345         Teb-&gt;BStoreLimit = (PVOID)((PUCHAR)(NextPage));
00346 
00347       } <span class="keywordflow">else</span> {
00348 
00349 <span class="preprocessor">#endif</span>
00350 <span class="preprocessor"></span>
00351         DeallocationStack = Teb-&gt;DeallocationStack;
00352         StackLimit = &amp;Teb-&gt;NtTib.StackLimit;
00353 
00354         <span class="comment">//</span>
00355         <span class="comment">// The stack base and the stack limit are both within the stack.</span>
00356         <span class="comment">//</span>
00357 
00358         <span class="keywordflow">if</span> ((Teb-&gt;NtTib.StackBase &lt;= FaultingAddress) ||
00359             (DeallocationStack &gt; FaultingAddress)) {
00360 
00361 <span class="preprocessor">#if defined(WX86)</span>
00362 <span class="preprocessor"></span>            <span class="comment">//</span>
00363             <span class="comment">// Also check the Wx86 i386 stack on risc.</span>
00364             <span class="comment">//</span>
00365             Wx86Tib = Teb-&gt;Vdm;
00366             <span class="keywordflow">if</span> (Wx86Tib) {
00367                 <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>(Wx86Tib, <span class="keyword">sizeof</span>(WX86TIB), <span class="keyword">sizeof</span>(ULONG));
00368                 <span class="keywordflow">if</span> (Wx86Tib-&gt;Size == <span class="keyword">sizeof</span>(WX86TIB) &amp;&amp;
00369                     Wx86Tib-&gt;StackBase &gt; FaultingAddress &amp;&amp;
00370                     Wx86Tib-&gt;DeallocationStack &lt;= FaultingAddress) {
00371 
00372                     DeallocationStack = Wx86Tib-&gt;DeallocationStack;
00373                     StackLimit = &amp;Wx86Tib-&gt;StackLimit;
00374                 } <span class="keywordflow">else</span> {
00375                     <span class="comment">//</span>
00376                     <span class="comment">// Not within the stack.</span>
00377                     <span class="comment">//</span>
00378 
00379                     <span class="keywordflow">return</span> STATUS_GUARD_PAGE_VIOLATION;
00380                 }
00381             } <span class="keywordflow">else</span>
00382 <span class="preprocessor">#endif</span>
00383 <span class="preprocessor"></span><span class="preprocessor">#if defined(_WIN64)</span>
00384 <span class="preprocessor"></span>            <span class="comment">//</span>
00385             <span class="comment">// Also check for the 32-bit native stack on NT64</span>
00386             <span class="comment">//</span>
00387             <span class="keywordflow">if</span> ((Teb32 = (PTEB32)Teb-&gt;NtTib.ExceptionList) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00388                 <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>(Teb32, <span class="keyword">sizeof</span>(TEB32), <span class="keyword">sizeof</span>(ULONG));
00389                 <span class="keywordflow">if</span> ((ULONG_PTR)Teb32-&gt;NtTib.StackBase &gt; (ULONG_PTR)FaultingAddress &amp;&amp;
00390                     (ULONG_PTR)Teb32-&gt;DeallocationStack &lt;= (ULONG_PTR)FaultingAddress) {
00391                     DeallocationStack = (PVOID)ULongToPtr(Teb32-&gt;DeallocationStack);
00392 
00393                     StackLimit = (PVOID *)&amp;Teb32-&gt;NtTib.StackLimit;
00394                 } <span class="keywordflow">else</span>
00395 <span class="preprocessor">#if defined(_AXP64_)</span>
00396 <span class="preprocessor"></span>                <span class="comment">//</span>
00397                 <span class="comment">// Also check the Wx86 i386 stack on risc.</span>
00398                 <span class="comment">//</span>
00399                 <span class="keywordflow">if</span> (Wx86Tib = (PWX86TIB)ULongToPtr(Teb32-&gt;Vdm)) {
00400                     <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>(Wx86Tib, <span class="keyword">sizeof</span>(WX86TIB), <span class="keyword">sizeof</span>(ULONG));
00401                     <span class="keywordflow">if</span> (Wx86Tib-&gt;Size == <span class="keyword">sizeof</span>(WX86TIB) &amp;&amp;
00402                         (ULONG_PTR)Wx86Tib-&gt;StackBase &gt; (ULONG_PTR)FaultingAddress &amp;&amp;
00403                         (ULONG_PTR)Wx86Tib-&gt;DeallocationStack &lt;= (ULONG_PTR)FaultingAddress) {
00404 
00405                         DeallocationStack = Wx86Tib-&gt;DeallocationStack;
00406                         StackLimit = (PVOID *)(&amp;Wx86Tib-&gt;StackLimit);
00407                     } <span class="keywordflow">else</span> {
00408                         <span class="comment">//</span>
00409                         <span class="comment">// Not within the stack.</span>
00410                         <span class="comment">//</span>
00411 
00412                         <span class="keywordflow">return</span> STATUS_GUARD_PAGE_VIOLATION;
00413                     }
00414                 } <span class="keywordflow">else</span>
00415 <span class="preprocessor">#endif</span>
00416 <span class="preprocessor"></span>                {
00417                     <span class="comment">//</span>
00418                     <span class="comment">// Not within the stack.</span>
00419                     <span class="comment">//</span>
00420 
00421                     <span class="keywordflow">return</span> STATUS_GUARD_PAGE_VIOLATION;
00422                 }
00423             } <span class="keywordflow">else</span>
00424 <span class="preprocessor">#endif</span>
00425 <span class="preprocessor"></span>              {
00426                 <span class="comment">//</span>
00427                 <span class="comment">// Not within the stack.</span>
00428                 <span class="comment">//</span>
00429 
00430                 <span class="keywordflow">return</span> STATUS_GUARD_PAGE_VIOLATION;
00431             }
00432         }
00433 
00434         <span class="comment">//</span>
00435         <span class="comment">// This address is within the current stack, check to see</span>
00436         <span class="comment">// if there is ample room for another guard page and</span>
00437         <span class="comment">// if so attempt to commit a new guard page.</span>
00438         <span class="comment">//</span>
00439 
00440         NextPage = ((ULONG_PTR)<a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a>(FaultingAddress) - <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
00441 
00442         RegionSize = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
00443 
00444         <span class="keywordflow">if</span> ((NextPage - <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>) &lt;= (ULONG_PTR)<a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a>(DeallocationStack)) {
00445 
00446             <span class="comment">//</span>
00447             <span class="comment">// There is no more room for expansion, attempt to</span>
00448             <span class="comment">// commit the page before the last page of the</span>
00449             <span class="comment">// stack.</span>
00450             <span class="comment">//</span>
00451 
00452             NextPage = (ULONG_PTR)<a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a>(DeallocationStack) + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
00453 
00454             status = ZwAllocateVirtualMemory (NtCurrentProcess(),
00455                                               (PVOID *)&amp;NextPage,
00456                                               0,
00457                                               &amp;RegionSize,
00458                                               MEM_COMMIT,
00459                                               PAGE_READWRITE);
00460             <span class="keywordflow">if</span> ( <a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status) ) {
00461 
00462 <span class="preprocessor">#if defined(_WIN64)</span>
00463 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (Teb32) {
00464                     <span class="comment">// update the 32-bit stacklimit</span>
00465                     *(ULONG *)StackLimit = PtrToUlong((PUCHAR)NextPage);
00466                 } <span class="keywordflow">else</span> {
00467                     *StackLimit = (PVOID)( (PUCHAR)NextPage);
00468                 }
00469 <span class="preprocessor">#else</span>
00470 <span class="preprocessor"></span>                *StackLimit = (PVOID)( (PUCHAR)NextPage);
00471 <span class="preprocessor">#endif</span>
00472 <span class="preprocessor"></span>
00473             }
00474 
00475             <span class="keywordflow">return</span> STATUS_STACK_OVERFLOW;
00476         }
00477 <span class="preprocessor">#if defined(_WIN64)</span>
00478 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (Teb32) {
00479             <span class="comment">// Update the 32-bit stacklimit</span>
00480             *(ULONG *)StackLimit = PtrToUlong((PUCHAR)(NextPage + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>));
00481         } <span class="keywordflow">else</span> {
00482             *StackLimit = (PVOID)((PUCHAR)(NextPage + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>));
00483         }
00484 <span class="preprocessor">#else</span>
00485 <span class="preprocessor"></span>        *StackLimit = (PVOID)((PUCHAR)(NextPage + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>));
00486 <span class="preprocessor">#endif</span>
00487 <span class="preprocessor"></span>
00488 <span class="preprocessor">#if defined(_IA64_)</span>
00489 <span class="preprocessor"></span>      }
00490 <span class="preprocessor">#endif // _IA64_</span>
00491 <span class="preprocessor"></span>
00492 retry:
00493         status = ZwAllocateVirtualMemory (NtCurrentProcess(),
00494                                           (PVOID *)&amp;NextPage,
00495                                           0,
00496                                           &amp;RegionSize,
00497                                           MEM_COMMIT,
00498                                           PAGE_READWRITE | PAGE_GUARD);
00499 
00500 
00501         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status) || (status == STATUS_ALREADY_COMMITTED)) {
00502 
00503             <span class="comment">//</span>
00504             <span class="comment">// The guard page is now committed or stack space is</span>
00505             <span class="comment">// already present, return success.</span>
00506             <span class="comment">//</span>
00507 
00508             <span class="keywordflow">return</span> STATUS_PAGE_FAULT_GUARD_PAGE;
00509         }
00510 
00511         <span class="keywordflow">if</span> (<a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>() == <a class="code" href="../../d6/d8/ex_2harderr_8c.html#a4">ExpDefaultErrorPortProcess</a>) {
00512 
00513             <span class="comment">//</span>
00514             <span class="comment">// Don't let CSRSS process get any stack overflows due to</span>
00515             <span class="comment">// commitment.  Increase the commitment by a page and</span>
00516             <span class="comment">// try again.</span>
00517             <span class="comment">//</span>
00518 
00519             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (status == STATUS_COMMITMENT_LIMIT);
00520 
00521             ExAcquireSpinLock (&amp;<a class="code" href="../../d4/d8/mi_8h.html#a690">MmChargeCommitmentLock</a>, &amp;OldIrql);
00522             <a class="code" href="../../d6/d8/sysinfo_8c.html#a4">MmTotalCommitLimit</a> += 1;
00523             <a class="code" href="../../d8/d5/kddata_8c.html#a35">MmExtendedCommit</a> += 1;
00524             ExReleaseSpinLock (&amp;<a class="code" href="../../d4/d8/mi_8h.html#a690">MmChargeCommitmentLock</a>, OldIrql);
00525             <span class="keywordflow">goto</span> retry;
00526         }
00527 
00528         <span class="keywordflow">return</span> STATUS_STACK_OVERFLOW;
00529 
00530     } except (<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00531 
00532         <span class="comment">//</span>
00533         <span class="comment">// An exception has occurred during the referencing of the</span>
00534         <span class="comment">// TEB or TIB, just return a guard page violation and</span>
00535         <span class="comment">// don't deal with the stack overflow.</span>
00536         <span class="comment">//</span>
00537 
00538         <span class="keywordflow">return</span> STATUS_GUARD_PAGE_VIOLATION;
00539     }
00540 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:39:12 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
