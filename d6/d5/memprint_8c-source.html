<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: memprint.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>memprint.c</h1><a href="../../d5/d6/memprint_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1989  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    memprint.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module contains the routines to implement in-memory DbgPrint.</span>
00012 <span class="comment">    DbgPrint text is stored in a large circular buffer, and optionally</span>
00013 <span class="comment">    written to a file and/or the debug console.  Output to file is</span>
00014 <span class="comment">    buffered to allow high performance by the file system.</span>
00015 <span class="comment"></span>
00016 <span class="comment">Author:</span>
00017 <span class="comment"></span>
00018 <span class="comment">    David Treadwell (davidtr) 05-Oct-1990</span>
00019 <span class="comment"></span>
00020 <span class="comment">Revision History:</span>
00021 <span class="comment"></span>
00022 <span class="comment">--*/</span>
00023 
00024 <span class="preprocessor">#include "<a class="code" href="../../d4/d0/exp_8h.html">exp.h</a>"</span>
00025 <span class="preprocessor">#pragma hdrstop</span>
00026 <span class="preprocessor"></span>
00027 <span class="preprocessor">#include &lt;stdarg.h&gt;</span>
00028 <span class="preprocessor">#include &lt;string.h&gt;</span>
00029 <span class="preprocessor">#include &lt;<a class="code" href="../../d6/d6/memprint_8h.html">memprint.h</a>&gt;</span>
00030 <span class="preprocessor">#undef DbgPrint</span>
00031 <span class="preprocessor"></span>
00032 <span class="comment">//</span>
00033 <span class="comment">// Forward declarations.</span>
00034 <span class="comment">//</span>
00035 
00036 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00037 <a class="code" href="../../d5/d6/memprint_8c.html#a16">MemPrintWriteCompleteApc</a> (
00038     IN PVOID ApcContext,
00039     IN PIO_STATUS_BLOCK IoStatusBlock,
00040     IN ULONG Reserved
00041     );
00042 
00043 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00044 <a class="code" href="../../d5/d6/memprint_8c.html#a17">MemPrintWriteThread</a> (
00045     IN PVOID Dummy
00046     );
00047 
00048 
00049 <span class="comment">//</span>
00050 <span class="comment">// The maximum message size is the largest message that can be written</span>
00051 <span class="comment">// by a single call to MemPrint.</span>
00052 
<a name="l00053"></a><a class="code" href="../../d5/d6/memprint_8c.html#a0">00053</a> <span class="preprocessor">#define MEM_PRINT_MAX_MESSAGE_SIZE 256</span>
00054 <span class="preprocessor"></span>
00055 <span class="comment">//</span>
00056 <span class="comment">// These macros aid in determining the size of a subbuffer and the</span>
00057 <span class="comment">// subbuffer corresponding to an index into the circular buffer.</span>
00058 <span class="comment">//</span>
00059 
<a name="l00060"></a><a class="code" href="../../d5/d6/memprint_8c.html#a1">00060</a> <span class="preprocessor">#define MEM_PRINT_SUBBUFFER_SIZE (MemPrintBufferSize / MemPrintSubbufferCount)</span>
00061 <span class="preprocessor"></span>
<a name="l00062"></a><a class="code" href="../../d5/d6/memprint_8c.html#a2">00062</a> <span class="preprocessor">#define GET_MEM_PRINT_SUBBUFFER(i) ((CSHORT)( (i) / MEM_PRINT_SUBBUFFER_SIZE ))</span>
00063 <span class="preprocessor"></span>
00064 <span class="comment">//</span>
00065 <span class="comment">// The definition of the header put before each message if the</span>
00066 <span class="comment">// MEM_PRINT_FLAG_HEADER bit of MemPrintFlags is turned on.</span>
00067 <span class="comment">//</span>
00068 
<a name="l00069"></a><a class="code" href="../../d0/d8/struct__MEM__PRINT__MESSAGE__HEADER.html">00069</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d0/d8/struct__MEM__PRINT__MESSAGE__HEADER.html">_MEM_PRINT_MESSAGE_HEADER</a> {
<a name="l00070"></a><a class="code" href="../../d0/d8/struct__MEM__PRINT__MESSAGE__HEADER.html#o0">00070</a>     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
<a name="l00071"></a><a class="code" href="../../d0/d8/struct__MEM__PRINT__MESSAGE__HEADER.html#o1">00071</a>     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> <a class="code" href="../../d0/d8/struct__MEM__PRINT__MESSAGE__HEADER.html#o1">Type</a>;
00072 } <a class="code" href="../../d0/d8/struct__MEM__PRINT__MESSAGE__HEADER.html">MEM_PRINT_MESSAGE_HEADER</a>, *<a class="code" href="../../d0/d8/struct__MEM__PRINT__MESSAGE__HEADER.html">PMEM_PRINT_MESSAGE_HEADER</a>;
00073 
00074 <span class="comment">//</span>
00075 <span class="comment">// Global data.  It is all protected by MemPrintSpinLock.</span>
00076 <span class="comment">//</span>
00077 
<a name="l00078"></a><a class="code" href="../../d5/d6/memprint_8c.html#a5">00078</a> CLONG <a class="code" href="../../d5/d6/memprint_8c.html#a5">MemPrintBufferSize</a> = <a class="code" href="../../d6/d6/memprint_8h.html#a3">MEM_PRINT_DEF_BUFFER_SIZE</a>;
<a name="l00079"></a><a class="code" href="../../d5/d6/memprint_8c.html#a6">00079</a> CLONG <a class="code" href="../../d5/d6/memprint_8c.html#a6">MemPrintSubbufferCount</a> = <a class="code" href="../../d6/d6/memprint_8h.html#a4">MEM_PRINT_DEF_SUBBUFFER_COUNT</a>;
<a name="l00080"></a><a class="code" href="../../d5/d6/memprint_8c.html#a7">00080</a> PCHAR <a class="code" href="../../d5/d6/memprint_8c.html#a7">MemPrintBuffer</a>;
00081 
<a name="l00082"></a><a class="code" href="../../d5/d6/memprint_8c.html#a8">00082</a> ULONG <a class="code" href="../../d5/d6/memprint_8c.html#a8">MemPrintFlags</a> = <a class="code" href="../../d6/d6/memprint_8h.html#a0">MEM_PRINT_FLAG_CONSOLE</a>;
00083 
<a name="l00084"></a><a class="code" href="../../d5/d6/memprint_8c.html#a9">00084</a> KSPIN_LOCK <a class="code" href="../../d5/d6/memprint_8c.html#a9">MemPrintSpinLock</a>;
00085 
<a name="l00086"></a><a class="code" href="../../d5/d6/memprint_8c.html#a10">00086</a> <a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a> <a class="code" href="../../d5/d6/memprint_8c.html#a10">MemPrintTempBuffer</a>[<a class="code" href="../../d5/d6/memprint_8c.html#a0">MEM_PRINT_MAX_MESSAGE_SIZE</a>];
00087 
<a name="l00088"></a><a class="code" href="../../d5/d6/memprint_8c.html#a11">00088</a> BOOLEAN <a class="code" href="../../d5/d6/memprint_8c.html#a11">MemPrintInitialized</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00089 
00090 <span class="comment">//</span>
00091 <span class="comment">// MemPrintIndex stores the current index into the circular buffer.</span>
00092 <span class="comment">//</span>
00093 
<a name="l00094"></a><a class="code" href="../../d5/d6/memprint_8c.html#a12">00094</a> CLONG <a class="code" href="../../d5/d6/memprint_8c.html#a12">MemPrintIndex</a> = 0;
00095 
00096 <span class="comment">//</span>
00097 <span class="comment">// MemPrintCurrentSubbuffer stores the index of the subbuffer currently</span>
00098 <span class="comment">// being used to hold data.  It has a range between 0 and</span>
00099 <span class="comment">// MemPrintSubbufferCount-1.</span>
00100 <span class="comment">//</span>
00101 
<a name="l00102"></a><a class="code" href="../../d5/d6/memprint_8c.html#a13">00102</a> CLONG <a class="code" href="../../d5/d6/memprint_8c.html#a13">MemPrintCurrentSubbuffer</a> = 0;
00103 
00104 <span class="comment">//</span>
00105 <span class="comment">// The MemPrintSubbufferWriting array is used to indicate when a</span>
00106 <span class="comment">// subbuffer is being written to disk.  While this occurs, new data</span>
00107 <span class="comment">// cannot be written to the subbuffer.</span>
00108 <span class="comment">//</span>
00109 
<a name="l00110"></a><a class="code" href="../../d5/d6/memprint_8c.html#a14">00110</a> BOOLEAN <a class="code" href="../../d5/d6/memprint_8c.html#a14">MemPrintSubbufferWriting</a>[<a class="code" href="../../d6/d6/memprint_8h.html#a5">MEM_PRINT_MAX_SUBBUFFER_COUNT</a>];
00111 
00112 <span class="comment">//</span>
00113 <span class="comment">// The MemPrintSubbufferFullEvent array is used to communicate between</span>
00114 <span class="comment">// threads calling MemPrintMemory and the thread that writes the log</span>
00115 <span class="comment">// file.  When a subbuffer is full and ready to be written to disk,</span>
00116 <span class="comment">// the corresponding event in this array is signaled, which causes</span>
00117 <span class="comment">// the write thread to wake up and perform the write.</span>
00118 <span class="comment">//</span>
00119 
<a name="l00120"></a><a class="code" href="../../d5/d6/memprint_8c.html#a15">00120</a> <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> <a class="code" href="../../d5/d6/memprint_8c.html#a15">MemPrintSubbufferFullEvent</a>[<a class="code" href="../../d6/d6/memprint_8h.html#a5">MEM_PRINT_MAX_SUBBUFFER_COUNT</a>];
00121 
00122 
00123 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00124"></a><a class="code" href="../../d6/d6/memprint_8h.html#a9">00124</a> <a class="code" href="../../d6/d6/memprint_8h.html#a9">MemPrintInitialize</a> (
00125     VOID
00126     )
00127 
00128 <span class="comment">/*++</span>
00129 <span class="comment"></span>
00130 <span class="comment">Routine Description:</span>
00131 <span class="comment"></span>
00132 <span class="comment">    This is the initialization routine for the in-memory DbgPrint routine.</span>
00133 <span class="comment">    It should be called before the first call to MemPrint to set up the</span>
00134 <span class="comment">    various structures used and to start the log file write thread.</span>
00135 <span class="comment"></span>
00136 <span class="comment">Arguments:</span>
00137 <span class="comment"></span>
00138 <span class="comment">    None.</span>
00139 <span class="comment"></span>
00140 <span class="comment">Return Value:</span>
00141 <span class="comment"></span>
00142 <span class="comment">    None.</span>
00143 <span class="comment"></span>
00144 <span class="comment">--*/</span>
00145 
00146 {
00147     CLONG i;
00148     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
00149     HANDLE threadHandle;
00150 
00151     <span class="keywordflow">if</span> ( <a class="code" href="../../d5/d6/memprint_8c.html#a11">MemPrintInitialized</a> ) {
00152         <span class="keywordflow">return</span>;
00153     }
00154 
00155     <span class="comment">//</span>
00156     <span class="comment">// Allocate memory for the circular buffer that will receive</span>
00157     <span class="comment">// the text and data.  If we can't do it, try again with a buffer</span>
00158     <span class="comment">// half as large.  If that fails, quit trying.</span>
00159     <span class="comment">//</span>
00160 
00161     <a class="code" href="../../d5/d6/memprint_8c.html#a7">MemPrintBuffer</a> = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, <a class="code" href="../../d5/d6/memprint_8c.html#a5">MemPrintBufferSize</a>, 'rPeM' );
00162 
00163     <span class="keywordflow">if</span> ( <a class="code" href="../../d5/d6/memprint_8c.html#a7">MemPrintBuffer</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
00164 
00165         <a class="code" href="../../d5/d6/memprint_8c.html#a5">MemPrintBufferSize</a> /= 2;
00166         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( <span class="stringliteral">"Unable to allocate DbgPrint buffer--trying size = %ld\n"</span>,
00167                       <a class="code" href="../../d5/d6/memprint_8c.html#a5">MemPrintBufferSize</a> );
00168         <a class="code" href="../../d5/d6/memprint_8c.html#a7">MemPrintBuffer</a> = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, <a class="code" href="../../d5/d6/memprint_8c.html#a5">MemPrintBufferSize</a>, 'rPeM' );
00169 
00170         <span class="keywordflow">if</span> ( <a class="code" href="../../d5/d6/memprint_8c.html#a7">MemPrintBuffer</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
00171             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( <span class="stringliteral">"Couldn't allocate DbgPrint buffer.\n"</span> );
00172             <span class="keywordflow">return</span>;
00173         } <span class="keywordflow">else</span> {
00174             <span class="comment">//DbgPrint( "MemPrint buffer from %lx to %lx\n",</span>
00175             <span class="comment">//            MemPrintBuffer, MemPrintBuffer + MemPrintBufferSize );</span>
00176         }
00177 
00178     } <span class="keywordflow">else</span> {
00179         <span class="comment">//DbgPrint( "MemPrint buffer from %lx to %lx\n",</span>
00180         <span class="comment">//              MemPrintBuffer, MemPrintBuffer + MemPrintBufferSize );</span>
00181     }
00182 
00183     <span class="comment">//</span>
00184     <span class="comment">// Allocate the spin lock that protects access to the various</span>
00185     <span class="comment">// pointers and the circular buffer.  This ensures integrity of the</span>
00186     <span class="comment">// buffer.</span>
00187     <span class="comment">//</span>
00188 
00189     <a class="code" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock</a>( &amp;<a class="code" href="../../d5/d6/memprint_8c.html#a9">MemPrintSpinLock</a> );
00190 
00191     <span class="comment">//</span>
00192     <span class="comment">// Make sure that the subbuffer count is in range.  (We assume that</span>
00193     <span class="comment">// the number is a power of 2.)</span>
00194     <span class="comment">//</span>
00195 
00196     <span class="keywordflow">if</span> ( <a class="code" href="../../d5/d6/memprint_8c.html#a6">MemPrintSubbufferCount</a> &lt; 2 ) {
00197         <a class="code" href="../../d5/d6/memprint_8c.html#a6">MemPrintSubbufferCount</a> = 2;
00198     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <a class="code" href="../../d5/d6/memprint_8c.html#a6">MemPrintSubbufferCount</a> &gt; <a class="code" href="../../d6/d6/memprint_8h.html#a5">MEM_PRINT_MAX_SUBBUFFER_COUNT</a> ) {
00199         <a class="code" href="../../d5/d6/memprint_8c.html#a6">MemPrintSubbufferCount</a> = <a class="code" href="../../d6/d6/memprint_8h.html#a5">MEM_PRINT_MAX_SUBBUFFER_COUNT</a>;
00200     }
00201 
00202     <span class="comment">//</span>
00203     <span class="comment">// Initialize the array of BOOLEANs that determines which subbuffers</span>
00204     <span class="comment">// are being written to disk and therefore cannot be used to store</span>
00205     <span class="comment">// new DbgPrint data.</span>
00206     <span class="comment">//</span>
00207     <span class="comment">// Initialize the array of events that indicates that a subbuffer is</span>
00208     <span class="comment">// ready to be written to disk.</span>
00209     <span class="comment">//</span>
00210 
00211     <span class="keywordflow">for</span> ( i = 0; i &lt; <a class="code" href="../../d5/d6/memprint_8c.html#a6">MemPrintSubbufferCount</a>; i++ ) {
00212         <a class="code" href="../../d5/d6/memprint_8c.html#a14">MemPrintSubbufferWriting</a>[i] = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00213         <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>(
00214             &amp;<a class="code" href="../../d5/d6/memprint_8c.html#a15">MemPrintSubbufferFullEvent</a>[i],
00215             SynchronizationEvent,
00216             <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>
00217             );
00218     }
00219 
00220     <span class="comment">//</span>
00221     <span class="comment">// Start the thread that writes subbuffers from the large circular</span>
00222     <span class="comment">// buffer to disk.</span>
00223     <span class="comment">//</span>
00224 
00225     status = <a class="code" href="../../d2/d8/ps_2create_8c.html#a11">PsCreateSystemThread</a>(
00226                 &amp;threadHandle,
00227                 PROCESS_ALL_ACCESS,
00228                 <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00229                 NtCurrentProcess(),
00230                 <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00231                 <a class="code" href="../../d5/d6/memprint_8c.html#a17">MemPrintWriteThread</a>,
00232                 <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
00233                 );
00234 
00235     <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status) ) {
00236         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( <span class="stringliteral">"MemPrintInitialize: PsCreateSystemThread failed: %X\n"</span>,
00237                       status );
00238         <span class="keywordflow">return</span>;
00239     }
00240 
00241     <a class="code" href="../../d5/d6/memprint_8c.html#a11">MemPrintInitialized</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00242     ZwClose( threadHandle );
00243 
00244     <span class="keywordflow">return</span>;
00245 
00246 } <span class="comment">// MemPrintInitialize</span>
00247 
00248 
00249 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00250"></a><a class="code" href="../../d6/d6/memprint_8h.html#a10">00250</a> <a class="code" href="../../d6/d6/memprint_8h.html#a10">MemPrint</a> (
00251     CHAR *Format, ...
00252     )
00253 
00254 <span class="comment">/*++</span>
00255 <span class="comment"></span>
00256 <span class="comment">Routine Description:</span>
00257 <span class="comment"></span>
00258 <span class="comment">    This routine is called in place of DbgPrint to process in-memory</span>
00259 <span class="comment">    printing.</span>
00260 <span class="comment"></span>
00261 <span class="comment">Arguments:</span>
00262 <span class="comment"></span>
00263 <span class="comment">    Format - A format string in the style of DbgPrint.</span>
00264 <span class="comment"></span>
00265 <span class="comment">           - formatting arguments.</span>
00266 <span class="comment"></span>
00267 <span class="comment">Return Value:</span>
00268 <span class="comment"></span>
00269 <span class="comment">    None.</span>
00270 <span class="comment"></span>
00271 <span class="comment">--*/</span>
00272 
00273 {
00274     va_list arglist;
00275     KIRQL oldIrql;
00276     CLONG nextSubbuffer;
00277     <a class="code" href="../../d5/d6/memprint_8c.html#a4">PMEM_PRINT_MESSAGE_HEADER</a> messageHeader;
00278     <a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a> tempBuffer[<a class="code" href="../../d5/d6/memprint_8c.html#a0">MEM_PRINT_MAX_MESSAGE_SIZE</a>];
00279 
00280     va_start(arglist, Format);
00281     _vsnprintf( tempBuffer, <span class="keyword">sizeof</span>( tempBuffer ), Format, arglist );
00282     va_end(arglist);
00283 
00284     <span class="comment">//</span>
00285     <span class="comment">// If memory DbgPrint has not been initialized, simply print to the</span>
00286     <span class="comment">// console.</span>
00287     <span class="comment">//</span>
00288 
00289     <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/memprint_8c.html#a11">MemPrintInitialized</a> ) {
00290 
00291         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( <span class="stringliteral">"%s"</span>, tempBuffer );
00292         <span class="keywordflow">return</span>;
00293     }
00294 
00295     <span class="comment">//</span>
00296     <span class="comment">// Acquire the spin lock that synchronizes access to the pointers</span>
00297     <span class="comment">// and circular buffer.</span>
00298     <span class="comment">//</span>
00299 
00300     <a class="code" href="../../d4/d9/ke_8h.html#a37">KeAcquireSpinLock</a>( &amp;<a class="code" href="../../d5/d6/memprint_8c.html#a9">MemPrintSpinLock</a>, &amp;oldIrql );
00301 
00302     <span class="comment">//</span>
00303     <span class="comment">// Make sure that the request will fit.  xx_sprintf will just dump</span>
00304     <span class="comment">// all it gets, so assume the message is maximum size, and, if the</span>
00305     <span class="comment">// request would go into the next subbuffer and it is writing, fail</span>
00306     <span class="comment">// the request.</span>
00307     <span class="comment">//</span>
00308 
00309     nextSubbuffer =
00310         <a class="code" href="../../d5/d6/memprint_8c.html#a2">GET_MEM_PRINT_SUBBUFFER</a>( <a class="code" href="../../d5/d6/memprint_8c.html#a12">MemPrintIndex</a> + <a class="code" href="../../d5/d6/memprint_8c.html#a0">MEM_PRINT_MAX_MESSAGE_SIZE</a> );
00311 
00312     <span class="keywordflow">if</span> (  nextSubbuffer != <a class="code" href="../../d5/d6/memprint_8c.html#a13">MemPrintCurrentSubbuffer</a> ) {
00313 
00314         <span class="comment">//</span>
00315         <span class="comment">// The request will go to a new subbuffer.  Check if we should</span>
00316         <span class="comment">// wrap around to the first subbuffer (i.e. start of circular</span>
00317         <span class="comment">// buffer).</span>
00318         <span class="comment">//</span>
00319 
00320         <span class="keywordflow">if</span> ( nextSubbuffer == <a class="code" href="../../d5/d6/memprint_8c.html#a6">MemPrintSubbufferCount</a> ) {
00321             nextSubbuffer = 0;
00322         }
00323 
00324         <span class="comment">//</span>
00325         <span class="comment">// Is that subbuffer available for use?</span>
00326         <span class="comment">//</span>
00327 
00328         <span class="keywordflow">if</span> ( <a class="code" href="../../d5/d6/memprint_8c.html#a14">MemPrintSubbufferWriting</a>[nextSubbuffer] ) {
00329 
00330             <span class="comment">//</span>
00331             <span class="comment">// It is in use.  Print to the console.  Oh well.</span>
00332             <span class="comment">//</span>
00333 
00334             <a class="code" href="../../d9/d5/verifier_8c.html#a119">KeReleaseSpinLock</a>( &amp;<a class="code" href="../../d5/d6/memprint_8c.html#a9">MemPrintSpinLock</a>, oldIrql );
00335 
00336             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( <span class="stringliteral">"%s"</span>, tempBuffer );
00337 
00338             <span class="keywordflow">return</span>;
00339         }
00340 
00341         <span class="comment">//</span>
00342         <span class="comment">// If we went to subbuffer 0 and it is available to receive</span>
00343         <span class="comment">// data, set up the "end of last subbuffer" conditions and reset</span>
00344         <span class="comment">// the index into the circular buffer.  By setting a special</span>
00345         <span class="comment">// type value in the message header that precedes the garbage at</span>
00346         <span class="comment">// the end of the last subbuffer, an interpreter program can</span>
00347         <span class="comment">// know to skip over the garbage by using the size in the</span>
00348         <span class="comment">// header.  This is done instead of writing only good data so</span>
00349         <span class="comment">// that we can write just full sectors to disk, thereby</span>
00350         <span class="comment">// enhancing write performance.</span>
00351         <span class="comment">//</span>
00352 
00353         <span class="keywordflow">if</span> ( nextSubbuffer == 0 ) {
00354 
00355             <span class="comment">//</span>
00356             <span class="comment">// Set up the message header.  This always gets done at the</span>
00357             <span class="comment">// end of the circular buffer, regardless of the flags bit.</span>
00358             <span class="comment">//</span>
00359 
00360             messageHeader =
00361                 (<a class="code" href="../../d5/d6/memprint_8c.html#a4">PMEM_PRINT_MESSAGE_HEADER</a>)&amp;<a class="code" href="../../d5/d6/memprint_8c.html#a7">MemPrintBuffer</a>[<a class="code" href="../../d5/d6/memprint_8c.html#a12">MemPrintIndex</a>];
00362             RtlStoreUshort(
00363                 &amp;messageHeader-&gt;<a class="code" href="../../d0/d8/struct__MEM__PRINT__MESSAGE__HEADER.html#o0">Size</a>,
00364                 (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(<a class="code" href="../../d5/d6/memprint_8c.html#a5">MemPrintBufferSize</a> - <a class="code" href="../../d5/d6/memprint_8c.html#a12">MemPrintIndex</a> - 1)
00365                 );
00366             RtlStoreUshort(
00367                 &amp;messageHeader-&gt;<a class="code" href="../../d0/d8/struct__MEM__PRINT__MESSAGE__HEADER.html#o1">Type</a>,
00368                 (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)0xffff
00369                 );
00370 
00371             <span class="comment">//</span>
00372             <span class="comment">// Zero out the rest of the subbuffer.</span>
00373             <span class="comment">//</span>
00374 
00375             <span class="keywordflow">for</span> ( <a class="code" href="../../d5/d6/memprint_8c.html#a12">MemPrintIndex</a> += <span class="keyword">sizeof</span>(<a class="code" href="../../d0/d8/struct__MEM__PRINT__MESSAGE__HEADER.html">MEM_PRINT_MESSAGE_HEADER</a>);
00376                   <a class="code" href="../../d5/d6/memprint_8c.html#a12">MemPrintIndex</a> &lt; <a class="code" href="../../d5/d6/memprint_8c.html#a5">MemPrintBufferSize</a>;
00377                   <a class="code" href="../../d5/d6/memprint_8c.html#a12">MemPrintIndex</a>++ ) {
00378 
00379                 <a class="code" href="../../d5/d6/memprint_8c.html#a7">MemPrintBuffer</a>[<a class="code" href="../../d5/d6/memprint_8c.html#a12">MemPrintIndex</a>] = 0;
00380             }
00381 
00382             <span class="comment">//</span>
00383             <span class="comment">// Reset the index to start at the beginning of the circular</span>
00384             <span class="comment">// buffer.</span>
00385             <span class="comment">//</span>
00386 
00387             <a class="code" href="../../d5/d6/memprint_8c.html#a12">MemPrintIndex</a> = 0;
00388         }
00389     }
00390 
00391     <span class="comment">//</span>
00392     <span class="comment">// Store a pointer to the location that will contain the message</span>
00393     <span class="comment">// header.</span>
00394     <span class="comment">//</span>
00395 
00396     messageHeader = (<a class="code" href="../../d5/d6/memprint_8c.html#a4">PMEM_PRINT_MESSAGE_HEADER</a>)&amp;<a class="code" href="../../d5/d6/memprint_8c.html#a7">MemPrintBuffer</a>[<a class="code" href="../../d5/d6/memprint_8c.html#a12">MemPrintIndex</a>];
00397 
00398     <span class="keywordflow">if</span> ( <a class="code" href="../../d5/d6/memprint_8c.html#a8">MemPrintFlags</a> &amp; <a class="code" href="../../d6/d6/memprint_8h.html#a2">MEM_PRINT_FLAG_HEADER</a> ) {
00399         <a class="code" href="../../d5/d6/memprint_8c.html#a12">MemPrintIndex</a> += <span class="keyword">sizeof</span>(<a class="code" href="../../d0/d8/struct__MEM__PRINT__MESSAGE__HEADER.html">MEM_PRINT_MESSAGE_HEADER</a>);
00400     }
00401 
00402     <span class="comment">//</span>
00403     <span class="comment">// Dump the formatted string to the subbuffer.  xx_sprintf is a special</span>
00404     <span class="comment">// version of sprintf that takes a variable argument list.</span>
00405     <span class="comment">//</span>
00406 
00407     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d5/d6/memprint_8c.html#a12">MemPrintIndex</a> + <a class="code" href="../../d5/d6/memprint_8c.html#a0">MEM_PRINT_MAX_MESSAGE_SIZE</a> -
00408                 <span class="keyword">sizeof</span>(<a class="code" href="../../d0/d8/struct__MEM__PRINT__MESSAGE__HEADER.html">MEM_PRINT_MESSAGE_HEADER</a>) &lt;= <a class="code" href="../../d5/d6/memprint_8c.html#a5">MemPrintBufferSize</a> );
00409 
00410 
00411     RtlMoveMemory( &amp;<a class="code" href="../../d5/d6/memprint_8c.html#a7">MemPrintBuffer</a>[<a class="code" href="../../d5/d6/memprint_8c.html#a12">MemPrintIndex</a>], tempBuffer, <a class="code" href="../../d2/d7/regtest_8c.html#a2">strlen</a>(tempBuffer)+1 );
00412 
00413     <a class="code" href="../../d5/d6/memprint_8c.html#a12">MemPrintIndex</a> += <a class="code" href="../../d2/d7/regtest_8c.html#a2">strlen</a>(tempBuffer);
00414 
00415     <span class="comment">//</span>
00416     <span class="comment">// Write the total message size to the message header.</span>
00417     <span class="comment">//</span>
00418 
00419     <span class="keywordflow">if</span> ( <a class="code" href="../../d5/d6/memprint_8c.html#a8">MemPrintFlags</a> &amp; <a class="code" href="../../d6/d6/memprint_8h.html#a2">MEM_PRINT_FLAG_HEADER</a> ) {
00420         messageHeader-&gt;<a class="code" href="../../d0/d8/struct__MEM__PRINT__MESSAGE__HEADER.html#o0">Size</a> =
00421             (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)( &amp;<a class="code" href="../../d5/d6/memprint_8c.html#a7">MemPrintBuffer</a>[<a class="code" href="../../d5/d6/memprint_8c.html#a12">MemPrintIndex</a>] - (PCHAR)messageHeader );
00422         messageHeader-&gt;<a class="code" href="../../d0/d8/struct__MEM__PRINT__MESSAGE__HEADER.html#o1">Type</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)0xdead;
00423         messageHeader++;
00424     }
00425 
00426     <span class="comment">//</span>
00427     <span class="comment">// If it was too large, there's a potential problem with writing off</span>
00428     <span class="comment">// the end of the circular buffer.  Print the offending message to</span>
00429     <span class="comment">// the console and breakpoint.</span>
00430     <span class="comment">//</span>
00431 
00432     <span class="keywordflow">if</span> ( &amp;<a class="code" href="../../d5/d6/memprint_8c.html#a7">MemPrintBuffer</a>[<a class="code" href="../../d5/d6/memprint_8c.html#a12">MemPrintIndex</a>] - (PCHAR)messageHeader &gt;
00433                                                 <a class="code" href="../../d5/d6/memprint_8c.html#a0">MEM_PRINT_MAX_MESSAGE_SIZE</a> ) {
00434         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( <span class="stringliteral">"Message too long!! :\n"</span> );
00435         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( <span class="stringliteral">"%s"</span>, messageHeader );
00436         DbgBreakPoint( );
00437     }
00438 
00439     <span class="comment">//</span>
00440     <span class="comment">// Print to the console if the appropriate flag is on.</span>
00441     <span class="comment">//</span>
00442 
00443     <span class="keywordflow">if</span> ( <a class="code" href="../../d5/d6/memprint_8c.html#a8">MemPrintFlags</a> &amp; <a class="code" href="../../d6/d6/memprint_8h.html#a0">MEM_PRINT_FLAG_CONSOLE</a> ) {
00444         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( <span class="stringliteral">"%s"</span>, messageHeader );
00445     }
00446 
00447     <span class="comment">//</span>
00448     <span class="comment">// Calculate whether we have stepped into a new subbuffer.</span>
00449     <span class="comment">//</span>
00450 
00451     nextSubbuffer = <a class="code" href="../../d5/d6/memprint_8c.html#a2">GET_MEM_PRINT_SUBBUFFER</a>( <a class="code" href="../../d5/d6/memprint_8c.html#a12">MemPrintIndex</a> );
00452 
00453     <span class="keywordflow">if</span> ( nextSubbuffer != <a class="code" href="../../d5/d6/memprint_8c.html#a13">MemPrintCurrentSubbuffer</a> ) {
00454 
00455         <span class="comment">//DbgPrint( "Subbuffer %ld complete.\n", MemPrintCurrentSubbuffer );</span>
00456 
00457         <span class="comment">//</span>
00458         <span class="comment">// We did step into a new subbuffer, so set the boolean to</span>
00459         <span class="comment">// indicate that the old subbuffer is writing to disk, thereby</span>
00460         <span class="comment">// preventing it from being overwritten until the write is</span>
00461         <span class="comment">// complete.</span>
00462         <span class="comment">//</span>
00463 
00464         <a class="code" href="../../d5/d6/memprint_8c.html#a14">MemPrintSubbufferWriting</a>[<a class="code" href="../../d5/d6/memprint_8c.html#a13">MemPrintCurrentSubbuffer</a>] = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00465 
00466         <span class="comment">//</span>
00467         <span class="comment">// Set the event that will wake up the thread writing subbuffers</span>
00468         <span class="comment">// to disk.</span>
00469         <span class="comment">//</span>
00470 
00471         <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>(
00472             &amp;<a class="code" href="../../d5/d6/memprint_8c.html#a15">MemPrintSubbufferFullEvent</a>[<a class="code" href="../../d5/d6/memprint_8c.html#a13">MemPrintCurrentSubbuffer</a>],
00473             2,
00474             <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>
00475             );
00476 
00477         <span class="comment">//</span>
00478         <span class="comment">// Update the current subbuffer.</span>
00479         <span class="comment">//</span>
00480 
00481         <a class="code" href="../../d5/d6/memprint_8c.html#a13">MemPrintCurrentSubbuffer</a> = nextSubbuffer;
00482     }
00483 
00484     <a class="code" href="../../d9/d5/verifier_8c.html#a119">KeReleaseSpinLock</a>( &amp;<a class="code" href="../../d5/d6/memprint_8c.html#a9">MemPrintSpinLock</a>, oldIrql );
00485 
00486     <span class="keywordflow">return</span>;
00487 
00488 } <span class="comment">// MemPrint</span>
00489 
00490 
00491 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00492"></a><a class="code" href="../../d6/d6/memprint_8h.html#a11">00492</a> <a class="code" href="../../d6/d6/memprint_8h.html#a11">MemPrintFlush</a> (
00493     VOID
00494     )
00495 
00496 <span class="comment">/*++</span>
00497 <span class="comment"></span>
00498 <span class="comment">Routine Description:</span>
00499 <span class="comment"></span>
00500 <span class="comment">    This routine causes the current subbuffer to be written to disk,</span>
00501 <span class="comment">    regardless of how full it is.  The unwritten part of the subbuffer</span>
00502 <span class="comment">    is zeroed before writing.</span>
00503 <span class="comment"></span>
00504 <span class="comment">Arguments:</span>
00505 <span class="comment"></span>
00506 <span class="comment">    None.</span>
00507 <span class="comment"></span>
00508 <span class="comment">Return Value:</span>
00509 <span class="comment"></span>
00510 <span class="comment">    None.</span>
00511 <span class="comment"></span>
00512 <span class="comment">--*/</span>
00513 
00514 {
00515     KIRQL oldIrql;
00516     <a class="code" href="../../d5/d6/memprint_8c.html#a4">PMEM_PRINT_MESSAGE_HEADER</a> messageHeader;
00517     CLONG nextSubbufferIndex;
00518     LARGE_INTEGER delayInterval;
00519 
00520     <span class="comment">//</span>
00521     <span class="comment">// Acquire the spin lock that protects memory DbgPrint variables.</span>
00522     <span class="comment">//</span>
00523 
00524     <a class="code" href="../../d4/d9/ke_8h.html#a37">KeAcquireSpinLock</a>( &amp;<a class="code" href="../../d5/d6/memprint_8c.html#a9">MemPrintSpinLock</a>, &amp;oldIrql );
00525 
00526     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( <span class="stringliteral">"Flushing subbuffer %ld\n"</span>, <a class="code" href="../../d5/d6/memprint_8c.html#a13">MemPrintCurrentSubbuffer</a> );
00527 
00528     <span class="comment">//</span>
00529     <span class="comment">// Set up the header that indicates that unused space follows.</span>
00530     <span class="comment">//</span>
00531 
00532     messageHeader =
00533         (<a class="code" href="../../d5/d6/memprint_8c.html#a4">PMEM_PRINT_MESSAGE_HEADER</a>)&amp;<a class="code" href="../../d5/d6/memprint_8c.html#a7">MemPrintBuffer</a>[<a class="code" href="../../d5/d6/memprint_8c.html#a12">MemPrintIndex</a>];
00534     messageHeader-&gt;<a class="code" href="../../d0/d8/struct__MEM__PRINT__MESSAGE__HEADER.html#o0">Size</a> =
00535         (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(<a class="code" href="../../d5/d6/memprint_8c.html#a5">MemPrintBufferSize</a> - <a class="code" href="../../d5/d6/memprint_8c.html#a12">MemPrintIndex</a> - 1);
00536     messageHeader-&gt;<a class="code" href="../../d0/d8/struct__MEM__PRINT__MESSAGE__HEADER.html#o1">Type</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)0xffff;
00537 
00538     <span class="comment">//</span>
00539     <span class="comment">// Determine where the next subbuffer starts.</span>
00540     <span class="comment">//</span>
00541 
00542     nextSubbufferIndex =
00543         (<a class="code" href="../../d5/d6/memprint_8c.html#a13">MemPrintCurrentSubbuffer</a> + 1) * <a class="code" href="../../d5/d6/memprint_8c.html#a1">MEM_PRINT_SUBBUFFER_SIZE</a>;
00544 
00545     <span class="comment">//</span>
00546     <span class="comment">// Zero out the rest of the subbuffer.</span>
00547     <span class="comment">//</span>
00548 
00549     <span class="keywordflow">for</span> ( <a class="code" href="../../d5/d6/memprint_8c.html#a12">MemPrintIndex</a> += <span class="keyword">sizeof</span>(<a class="code" href="../../d0/d8/struct__MEM__PRINT__MESSAGE__HEADER.html">MEM_PRINT_MESSAGE_HEADER</a>);
00550           <a class="code" href="../../d5/d6/memprint_8c.html#a12">MemPrintIndex</a> &lt; nextSubbufferIndex;
00551           <a class="code" href="../../d5/d6/memprint_8c.html#a12">MemPrintIndex</a>++ ) {
00552 
00553         <a class="code" href="../../d5/d6/memprint_8c.html#a7">MemPrintBuffer</a>[<a class="code" href="../../d5/d6/memprint_8c.html#a12">MemPrintIndex</a>] = 0;
00554     }
00555 
00556     <span class="comment">//</span>
00557     <span class="comment">// Indicate that the subbuffer should be written to disk.</span>
00558     <span class="comment">//</span>
00559 
00560     <a class="code" href="../../d5/d6/memprint_8c.html#a14">MemPrintSubbufferWriting</a>[<a class="code" href="../../d5/d6/memprint_8c.html#a13">MemPrintCurrentSubbuffer</a>] = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00561 
00562     <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>(
00563         &amp;<a class="code" href="../../d5/d6/memprint_8c.html#a15">MemPrintSubbufferFullEvent</a>[<a class="code" href="../../d5/d6/memprint_8c.html#a13">MemPrintCurrentSubbuffer</a>],
00564         8,
00565         <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>
00566         );
00567 
00568     <span class="comment">//</span>
00569     <span class="comment">// Increment the current subbuffer so that it corresponds with the</span>
00570     <span class="comment">// buffer index.</span>
00571     <span class="comment">//</span>
00572 
00573     <a class="code" href="../../d5/d6/memprint_8c.html#a13">MemPrintCurrentSubbuffer</a>++;
00574 
00575     <a class="code" href="../../d9/d5/verifier_8c.html#a119">KeReleaseSpinLock</a>( &amp;<a class="code" href="../../d5/d6/memprint_8c.html#a9">MemPrintSpinLock</a>, oldIrql );
00576 
00577     <span class="comment">//</span>
00578     <span class="comment">// Delay so that the memory print write thread wakes up and performs</span>
00579     <span class="comment">// the write to disk.</span>
00580     <span class="comment">//</span>
00581     <span class="comment">// !!! This is obviously not a perfect solution--the write thread</span>
00582     <span class="comment">//     may never wake up, so this could complete before the flush</span>
00583     <span class="comment">//     is really done.</span>
00584     <span class="comment">//</span>
00585 
00586     delayInterval.QuadPart = -10*10*1000*1000;
00587 
00588     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( <span class="stringliteral">"Delaying...\n"</span> );
00589     <a class="code" href="../../d1/d7/wait_8c.html#a2">KeDelayExecutionThread</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, &amp;delayInterval );
00590     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( <span class="stringliteral">"Woke up.\n"</span> );
00591 
00592     <span class="keywordflow">return</span>;
00593 
00594 } <span class="comment">// MemPrintFlush</span>
00595 
00596 
00597 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00598"></a><a class="code" href="../../d5/d6/memprint_8c.html#a17">00598</a> <a class="code" href="../../d5/d6/memprint_8c.html#a17">MemPrintWriteThread</a> (
00599     IN PVOID Dummy
00600     )
00601 
00602 <span class="comment">/*++</span>
00603 <span class="comment"></span>
00604 <span class="comment">Routine Description:</span>
00605 <span class="comment"></span>
00606 <span class="comment">    The log file write thread executes this routine.  It sets up the</span>
00607 <span class="comment">    log file for writing, then waits for subbuffers to fill, writing</span>
00608 <span class="comment">    them to disk when they do.  When the log file fills, new space</span>
00609 <span class="comment">    for it is allocated on disk to prevent the file system from</span>
00610 <span class="comment">    having to do it.</span>
00611 <span class="comment"></span>
00612 <span class="comment">Arguments:</span>
00613 <span class="comment"></span>
00614 <span class="comment">    Dummy - Ignored.</span>
00615 <span class="comment"></span>
00616 <span class="comment">Return Value:</span>
00617 <span class="comment"></span>
00618 <span class="comment">    None.</span>
00619 <span class="comment"></span>
00620 <span class="comment">--*/</span>
00621 
00622 {
00623     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
00624     IO_STATUS_BLOCK ioStatusBlock[<a class="code" href="../../d6/d6/memprint_8h.html#a5">MEM_PRINT_MAX_SUBBUFFER_COUNT</a>];
00625     IO_STATUS_BLOCK localIoStatusBlock;
00626     CLONG i;
00627     KPRIORITY threadPriorityLevel;
00628 
00629     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> waitStatus;
00630     PVOID waitObjects[64];
00631     <a class="code" href="../../d4/d8/struct__KWAIT__BLOCK.html">KWAIT_BLOCK</a> waitBlockArray[<a class="code" href="../../d6/d6/memprint_8h.html#a5">MEM_PRINT_MAX_SUBBUFFER_COUNT</a>];
00632 
00633     OBJECT_ATTRIBUTES objectAttributes;
00634     PCHAR fileName = <a class="code" href="../../d6/d6/memprint_8h.html#a6">MEM_PRINT_LOG_FILE_NAME</a>;
00635     ANSI_STRING fileNameString;
00636     HANDLE fileHandle;
00637 
00638     LARGE_INTEGER fileAllocation;
00639     LARGE_INTEGER fileAllocationIncrement;
00640     LARGE_INTEGER totalBytesWritten;
00641     LARGE_INTEGER writeSize;
00642 
00643     LARGE_INTEGER delayInterval;
00644     ULONG attempts = 0;
00645 
00646     UNICODE_STRING UnicodeFileName;
00647 
00648     Dummy;
00649 
00650     <span class="comment">//</span>
00651     <span class="comment">// Initialize the string containing the file name and the object</span>
00652     <span class="comment">// attributes structure that will describe the log file to open.</span>
00653     <span class="comment">//</span>
00654 
00655     <a class="code" href="../../d2/d7/string_8c.html#a6">RtlInitAnsiString</a>( &amp;fileNameString, fileName );
00656     status = <a class="code" href="../../d6/d6/nls_8c.html#a21">RtlAnsiStringToUnicodeString</a>(&amp;UnicodeFileName,&amp;fileNameString,<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
00657     <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status) ) {
00658         <a class="code" href="../../d8/d0/psdelete_8c.html#a6">NtTerminateThread</a>( NtCurrentThread(), status );
00659     }
00660 
00661     InitializeObjectAttributes(
00662         &amp;objectAttributes,
00663         &amp;UnicodeFileName,
00664         OBJ_CASE_INSENSITIVE,
00665         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00666         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
00667         );
00668 
00669     <span class="comment">//</span>
00670     <span class="comment">// Set the allocation size of the log file to be three times the</span>
00671     <span class="comment">// size of the circular buffer.  When it fills up, we'll extend</span>
00672     <span class="comment">// it.</span>
00673     <span class="comment">//</span>
00674 
00675     fileAllocationIncrement.LowPart = <a class="code" href="../../d5/d6/memprint_8c.html#a5">MemPrintBufferSize</a> * 8;
00676     fileAllocationIncrement.HighPart = 0;
00677     fileAllocation = fileAllocationIncrement;
00678 
00679     <span class="comment">//</span>
00680     <span class="comment">// Open the log file.</span>
00681     <span class="comment">//</span>
00682     <span class="comment">// !!! The loop here is to help avoid a system initialization</span>
00683     <span class="comment">//     timing problem, and should be removed when the problem is</span>
00684     <span class="comment">//     fixed.</span>
00685     <span class="comment">//</span>
00686 
00687     <span class="keywordflow">while</span> ( <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> ) {
00688 
00689         status = <a class="code" href="../../d1/d8/io_2create_8c.html#a0">NtCreateFile</a>(
00690                      &amp;fileHandle,
00691                      FILE_WRITE_DATA,
00692                      &amp;objectAttributes,
00693                      &amp;localIoStatusBlock,
00694                      &amp;fileAllocation,
00695                      FILE_ATTRIBUTE_NORMAL,
00696                      FILE_SHARE_READ,
00697                      FILE_OVERWRITE_IF,
00698                      FILE_SEQUENTIAL_ONLY,
00699                      <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00700                      0<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>
00701                      );
00702 
00703         <span class="keywordflow">if</span> ( (status != STATUS_OBJECT_PATH_NOT_FOUND) || (++attempts &gt;= 3) ) {
00704             <a class="code" href="../../d6/d6/nls_8c.html#a34">RtlFreeUnicodeString</a>(&amp;UnicodeFileName);
00705             <span class="keywordflow">break</span>;
00706         }
00707 
00708         delayInterval.QuadPart = -5*10*1000*1000;    <span class="comment">// five second delay</span>
00709         <a class="code" href="../../d1/d7/wait_8c.html#a2">KeDelayExecutionThread</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, &amp;delayInterval );
00710 
00711     }
00712 
00713     <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status) ) {
00714         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( <span class="stringliteral">"NtCreateFile for log file failed: %X\n"</span>, status );
00715         <a class="code" href="../../d8/d0/psdelete_8c.html#a6">NtTerminateThread</a>( NtCurrentThread(), status );
00716     }
00717 
00718     <span class="comment">//</span>
00719     <span class="comment">// Initialize the total bytes written and write size variables.</span>
00720     <span class="comment">//</span>
00721 
00722     totalBytesWritten.LowPart = 0;
00723     totalBytesWritten.HighPart = 0;
00724     writeSize.LowPart = <a class="code" href="../../d5/d6/memprint_8c.html#a1">MEM_PRINT_SUBBUFFER_SIZE</a>;
00725     writeSize.HighPart = 0;
00726 
00727     <span class="comment">//</span>
00728     <span class="comment">// Set up the wait objects array for a call to KeWaitForMultipleObjects.</span>
00729     <span class="comment">//</span>
00730 
00731     <span class="keywordflow">for</span> ( i = 0; i &lt; <a class="code" href="../../d5/d6/memprint_8c.html#a6">MemPrintSubbufferCount</a>; i++ ) {
00732         waitObjects[i] = &amp;<a class="code" href="../../d5/d6/memprint_8c.html#a15">MemPrintSubbufferFullEvent</a>[i];
00733     }
00734 
00735     <span class="comment">//</span>
00736     <span class="comment">// Set the priority of the write thread.</span>
00737     <span class="comment">//</span>
00738 
00739     threadPriorityLevel = LOW_REALTIME_PRIORITY + 1;
00740 
00741     status = <a class="code" href="../../d9/d1/psquery_8c.html#a21">NtSetInformationThread</a>(
00742                 NtCurrentThread(),
00743                 ThreadPriority,
00744                 &amp;threadPriorityLevel,
00745                 <span class="keyword">sizeof</span>(threadPriorityLevel)
00746                 );
00747 
00748     <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status) ) {
00749         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( <span class="stringliteral">"Unable to set error log thread priority: %X\n"</span>, status );
00750     }
00751 
00752     <span class="comment">//</span>
00753     <span class="comment">// Loop waiting for one of the subbuffer full events to be signaled.</span>
00754     <span class="comment">// When one is signaled, wake up and write the subbuffer to the log</span>
00755     <span class="comment">// file.</span>
00756     <span class="comment">//</span>
00757 
00758     <span class="keywordflow">while</span> ( <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> ) {
00759 
00760         waitStatus = <a class="code" href="../../d1/d7/wait_8c.html#a3">KeWaitForMultipleObjects</a>(
00761                          (CCHAR)<a class="code" href="../../d5/d6/memprint_8c.html#a6">MemPrintSubbufferCount</a>,
00762                          waitObjects,
00763                          WaitAny,
00764                          <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
00765                          <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
00766                          <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00767                          <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00768                          waitBlockArray
00769                          );
00770 
00771         <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(waitStatus) ) {
00772             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( <span class="stringliteral">"KeWaitForMultipleObjects failed: %X\n"</span>, waitStatus );
00773             <a class="code" href="../../d8/d0/psdelete_8c.html#a6">NtTerminateThread</a>( NtCurrentThread(), waitStatus );
00774         } <span class="comment">//else {</span>
00775             <span class="comment">//DbgPrint( "Writing subbuffer %ld...\n", waitStatus );</span>
00776         <span class="comment">//}</span>
00777 
00778         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( (CCHAR)waitStatus &lt; (CCHAR)<a class="code" href="../../d5/d6/memprint_8c.html#a6">MemPrintSubbufferCount</a> );
00779 
00780         <span class="comment">//</span>
00781         <span class="comment">// Check the DbgPrint flags to see if we really want to write</span>
00782         <span class="comment">// this.</span>
00783         <span class="comment">//</span>
00784 
00785         <span class="keywordflow">if</span> ( (<a class="code" href="../../d5/d6/memprint_8c.html#a8">MemPrintFlags</a> &amp; <a class="code" href="../../d6/d6/memprint_8h.html#a1">MEM_PRINT_FLAG_FILE</a>) == 0 ) {
00786 
00787             KIRQL oldIrql;
00788 
00789             <a class="code" href="../../d4/d9/ke_8h.html#a37">KeAcquireSpinLock</a>( &amp;<a class="code" href="../../d5/d6/memprint_8c.html#a9">MemPrintSpinLock</a>, &amp;oldIrql );
00790             <a class="code" href="../../d5/d6/memprint_8c.html#a14">MemPrintSubbufferWriting</a>[ waitStatus ] = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00791             <a class="code" href="../../d9/d5/verifier_8c.html#a119">KeReleaseSpinLock</a>( &amp;<a class="code" href="../../d5/d6/memprint_8c.html#a9">MemPrintSpinLock</a>, oldIrql );
00792 
00793             <span class="keywordflow">continue</span>;
00794         }
00795 
00796         <span class="comment">//</span>
00797         <span class="comment">// Start the write operation.  The APC routine will handle</span>
00798         <span class="comment">// checking the return status from the write and resetting</span>
00799         <span class="comment">// the MemPrintSubbufferWriting boolean.</span>
00800         <span class="comment">//</span>
00801 
00802         status = <a class="code" href="../../d0/d0/io_2write_8c.html#a0">NtWriteFile</a>(
00803                      fileHandle,
00804                      <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00805                      <a class="code" href="../../d5/d6/memprint_8c.html#a16">MemPrintWriteCompleteApc</a>,
00806                      (PVOID)waitStatus,
00807                      &amp;ioStatusBlock[waitStatus],
00808                      &amp;<a class="code" href="../../d5/d6/memprint_8c.html#a7">MemPrintBuffer</a>[waitStatus * <a class="code" href="../../d5/d6/memprint_8c.html#a1">MEM_PRINT_SUBBUFFER_SIZE</a>],
00809                      <a class="code" href="../../d5/d6/memprint_8c.html#a1">MEM_PRINT_SUBBUFFER_SIZE</a>,
00810                      &amp;totalBytesWritten,
00811                      <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
00812                      );
00813 
00814         <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status) ) {
00815             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( <span class="stringliteral">"NtWriteFile for log file failed: %X\n"</span>, status );
00816         }
00817 
00818         <span class="comment">//</span>
00819         <span class="comment">// Update the count of bytes written to the log file.</span>
00820         <span class="comment">//</span>
00821 
00822         totalBytesWritten.QuadPart = totalBytesWritten.QuadPart + writeSize.QuadPart;
00823 
00824         <span class="comment">//</span>
00825         <span class="comment">// Extend the file if we have reached the end of what we have</span>
00826         <span class="comment">// thus far allocated for the file.  This increases performance</span>
00827         <span class="comment">// by extending the file here rather than in the file system,</span>
00828         <span class="comment">// which would have to extend it each time a write past end of</span>
00829         <span class="comment">// file comes in.</span>
00830         <span class="comment">//</span>
00831 
00832         <span class="keywordflow">if</span> ( totalBytesWritten.QuadPart &gt;= fileAllocation.QuadPart ) {
00833 
00834             fileAllocation.QuadPart =
00835                         fileAllocation.QuadPart + fileAllocationIncrement.QuadPart;
00836 
00837             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( <span class="stringliteral">"Enlarging log file to %ld bytes.\n"</span>,
00838                           fileAllocation.LowPart );
00839 
00840             status = <a class="code" href="../../d9/d2/qsinfo_8c.html#a4">NtSetInformationFile</a>(
00841                          fileHandle,
00842                          &amp;localIoStatusBlock,
00843                          &amp;fileAllocation,
00844                          <span class="keyword">sizeof</span>(fileAllocation),
00845                          FileAllocationInformation
00846                          );
00847 
00848             <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status) ) {
00849                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( <span class="stringliteral">"Attempt to extend log file failed: %X\n"</span>, status );
00850                 fileAllocation.QuadPart =
00851                         fileAllocation.QuadPart - fileAllocationIncrement.QuadPart;
00852             }
00853         }
00854     }
00855 
00856     <span class="keywordflow">return</span>;
00857 
00858 } <span class="comment">// MemPrintWriteThread</span>
00859 
00860 
00861 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00862"></a><a class="code" href="../../d5/d6/memprint_8c.html#a16">00862</a> <a class="code" href="../../d5/d6/memprint_8c.html#a16">MemPrintWriteCompleteApc</a> (
00863     IN PVOID ApcContext,
00864     IN PIO_STATUS_BLOCK IoStatusBlock,
00865     IN ULONG Reserved
00866     )
00867 
00868 <span class="comment">/*++</span>
00869 <span class="comment"></span>
00870 <span class="comment">Routine Description:</span>
00871 <span class="comment"></span>
00872 <span class="comment">    This APC routine is called when subbuffer writes to disk complete.</span>
00873 <span class="comment">    It checks for success, printing a message if the write failed.</span>
00874 <span class="comment">    It also sets the appropriate MemPrintSubbufferWriting location to</span>
00875 <span class="comment">    FALSE so that the subbuffer can be reused.</span>
00876 <span class="comment"></span>
00877 <span class="comment">Arguments:</span>
00878 <span class="comment"></span>
00879 <span class="comment">    ApcContext - contains the index of the subbuffer just written.</span>
00880 <span class="comment"></span>
00881 <span class="comment">    IoStatusBlock - the status block for the operation.</span>
00882 <span class="comment"></span>
00883 <span class="comment">    Reserved - not used; reserved for future use.</span>
00884 <span class="comment"></span>
00885 <span class="comment">Return Value:</span>
00886 <span class="comment"></span>
00887 <span class="comment">    None.</span>
00888 <span class="comment"></span>
00889 <span class="comment">--*/</span>
00890 
00891 {
00892     KIRQL oldIrql;
00893 
00894     <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(IoStatusBlock-&gt;Status) ) {
00895         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( <span class="stringliteral">"NtWriteFile for subbuffer %ld failed: %X\n"</span>,
00896                       ApcContext, IoStatusBlock-&gt;Status );
00897         <span class="keywordflow">return</span>;
00898     }
00899 
00900     <span class="comment">//DbgPrint( "Write complete for subbuffer %ld.\n", ApcContext );</span>
00901     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( <span class="stringliteral">"."</span> );
00902 
00903     <span class="comment">//</span>
00904     <span class="comment">// Acquire the spin lock that protects memory print global variables</span>
00905     <span class="comment">// and set the subbuffer writing boolean to FALSE so that other</span>
00906     <span class="comment">// threads can write to the subbuffer if necessary.</span>
00907     <span class="comment">//</span>
00908 
00909     <a class="code" href="../../d4/d9/ke_8h.html#a37">KeAcquireSpinLock</a>( &amp;<a class="code" href="../../d5/d6/memprint_8c.html#a9">MemPrintSpinLock</a>, &amp;oldIrql );
00910     <a class="code" href="../../d5/d6/memprint_8c.html#a14">MemPrintSubbufferWriting</a>[ (ULONG_PTR)ApcContext ] = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00911     <a class="code" href="../../d9/d5/verifier_8c.html#a119">KeReleaseSpinLock</a>( &amp;<a class="code" href="../../d5/d6/memprint_8c.html#a9">MemPrintSpinLock</a>, oldIrql );
00912 
00913     <span class="keywordflow">return</span>;
00914 
00915     Reserved;
00916 
00917 } <span class="comment">// MemPrintWriteCompleteApc</span>
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:44 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
