<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: iosup.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>iosup.c</h1><a href="../../d5/d6/iosup_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1989  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">   iosup.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module contains routines which provide support for the I/O system.</span>
00012 <span class="comment"></span>
00013 <span class="comment">Author:</span>
00014 <span class="comment"></span>
00015 <span class="comment">    Lou Perazzoli (loup) 25-Apr-1989</span>
00016 <span class="comment">    Landy Wang (landyw) 02-June-1997</span>
00017 <span class="comment"></span>
00018 <span class="comment">Revision History:</span>
00019 <span class="comment"></span>
00020 <span class="comment">--*/</span>
00021 
00022 <span class="preprocessor">#include "<a class="code" href="../../d4/d8/mi_8h.html">mi.h</a>"</span>
00023 
00024 <span class="preprocessor">#undef MmIsRecursiveIoFault</span>
00025 <span class="preprocessor"></span>
<a name="l00026"></a><a class="code" href="../../d5/d6/iosup_8c.html#a2">00026</a> PFN_NUMBER <a class="code" href="../../d5/d6/iosup_8c.html#a2">MmSystemLockPagesCount</a>;
00027 
<a name="l00028"></a><a class="code" href="../../d5/d6/iosup_8c.html#a3">00028</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d6/d8/sysinfo_8c.html#a14">MmTotalSystemDriverPages</a>;
00029 
00030 BOOLEAN
00031 <a class="code" href="../../d2/d1/mm_8h.html#a16">MmIsRecursiveIoFault</a>(
00032     VOID
00033     );
00034 
00035 PVOID
00036 <a class="code" href="../../d5/d6/iosup_8c.html#a28">MiAllocateContiguousMemory</a> (
00037     IN SIZE_T NumberOfBytes,
00038     IN PFN_NUMBER LowestAcceptablePfn,
00039     IN PFN_NUMBER HighestAcceptablePfn,
00040     IN PFN_NUMBER BoundaryPfn,
00041     PVOID CallingAddress
00042     );
00043 
00044 PVOID
00045 <a class="code" href="../../d5/d6/iosup_8c.html#a29">MiMapLockedPagesInUserSpace</a> (
00046      IN <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MemoryDescriptorList,
00047      IN PVOID StartingVa,
00048      IN MEMORY_CACHING_TYPE CacheType,
00049      IN PVOID BaseVa
00050      );
00051 
00052 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00053 <a class="code" href="../../d5/d6/iosup_8c.html#a30">MiUnmapLockedPagesInUserSpace</a> (
00054      IN PVOID BaseAddress,
00055      IN <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MemoryDescriptorList
00056      );
00057 
00058 LOGICAL
00059 <a class="code" href="../../d0/d9/sysptes_8c.html#a29">MiGetSystemPteAvailability</a> (
00060     IN ULONG NumberOfPtes,
00061     IN <a class="code" href="../../d2/d1/mm_8h.html#a154">MM_PAGE_PRIORITY</a> Priority
00062     );
00063 
00064 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00065 <a class="code" href="../../d5/d6/iosup_8c.html#a32">MiAddMdlTracker</a> (
00066     IN <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MemoryDescriptorList,
00067     IN PVOID CallingAddress,
00068     IN PVOID CallersCaller,
00069     IN PFN_NUMBER NumberOfPagesToLock,
00070     IN ULONG Who
00071     );
00072 
<a name="l00073"></a><a class="code" href="../../d7/d1/struct__PTE__TRACKER.html">00073</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d7/d1/struct__PTE__TRACKER.html">_PTE_TRACKER</a> {
<a name="l00074"></a><a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o0">00074</a>     LIST_ENTRY <a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o0">ListEntry</a>;
<a name="l00075"></a><a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o1">00075</a>     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> <a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o1">Mdl</a>;
<a name="l00076"></a><a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o2">00076</a>     PFN_NUMBER <a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o2">Count</a>;
<a name="l00077"></a><a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o3">00077</a>     PVOID <a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o3">SystemVa</a>;
<a name="l00078"></a><a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o4">00078</a>     PVOID <a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o4">StartVa</a>;
<a name="l00079"></a><a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o5">00079</a>     ULONG <a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o5">Offset</a>;
<a name="l00080"></a><a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o6">00080</a>     ULONG <a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o6">Length</a>;
<a name="l00081"></a><a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o7">00081</a>     ULONG_PTR <a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o7">Page</a>;
<a name="l00082"></a><a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o8">00082</a>     PVOID <a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o8">CallingAddress</a>;
<a name="l00083"></a><a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o9">00083</a>     PVOID <a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o9">CallersCaller</a>;
<a name="l00084"></a><a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o10">00084</a>     PVOID <a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o10">PteAddress</a>;
00085 } <a class="code" href="../../d7/d1/struct__PTE__TRACKER.html">PTE_TRACKER</a>, *<a class="code" href="../../d7/d1/struct__PTE__TRACKER.html">PPTE_TRACKER</a>;
00086 
<a name="l00087"></a><a class="code" href="../../d9/d7/struct__SYSPTES__HEADER.html">00087</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d9/d7/struct__SYSPTES__HEADER.html">_SYSPTES_HEADER</a> {
<a name="l00088"></a><a class="code" href="../../d9/d7/struct__SYSPTES__HEADER.html#o0">00088</a>     LIST_ENTRY <a class="code" href="../../d9/d7/struct__SYSPTES__HEADER.html#o0">ListHead</a>;
<a name="l00089"></a><a class="code" href="../../d9/d7/struct__SYSPTES__HEADER.html#o1">00089</a>     PFN_NUMBER <a class="code" href="../../d9/d7/struct__SYSPTES__HEADER.html#o1">Count</a>;
00090 } <a class="code" href="../../d9/d7/struct__SYSPTES__HEADER.html">SYSPTES_HEADER</a>, *<a class="code" href="../../d9/d7/struct__SYSPTES__HEADER.html">PSYSPTES_HEADER</a>;
00091 
<a name="l00092"></a><a class="code" href="../../d5/d6/iosup_8c.html#a8">00092</a> LOGICAL <a class="code" href="../../d8/d0/cmdat3_8c.html#a37">MmTrackPtes</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
<a name="l00093"></a><a class="code" href="../../d5/d6/iosup_8c.html#a9">00093</a> BOOLEAN <a class="code" href="../../d5/d6/iosup_8c.html#a9">MiTrackPtesAborted</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
<a name="l00094"></a><a class="code" href="../../d5/d6/iosup_8c.html#a10">00094</a> <a class="code" href="../../d9/d7/struct__SYSPTES__HEADER.html">SYSPTES_HEADER</a> <a class="code" href="../../d5/d6/iosup_8c.html#a10">MiPteHeader</a>;
<a name="l00095"></a><a class="code" href="../../d5/d6/iosup_8c.html#a11">00095</a> LIST_ENTRY <a class="code" href="../../d5/d6/iosup_8c.html#a11">MiDeadPteTrackerListHead</a>;
<a name="l00096"></a><a class="code" href="../../d5/d6/iosup_8c.html#a12">00096</a> KSPIN_LOCK <a class="code" href="../../d5/d6/iosup_8c.html#a12">MiPteTrackerLock</a>;
00097 
<a name="l00098"></a><a class="code" href="../../d5/d6/iosup_8c.html#a13">00098</a> <a class="code" href="../../d5/d2/struct__LOCK__HEADER.html">LOCK_HEADER</a> <a class="code" href="../../d5/d6/iosup_8c.html#a13">MmLockedPagesHead</a>;
<a name="l00099"></a><a class="code" href="../../d5/d6/iosup_8c.html#a14">00099</a> BOOLEAN <a class="code" href="../../d5/d6/iosup_8c.html#a14">MiTrackingAborted</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00100 
00101 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00102 <a class="code" href="../../d5/d6/iosup_8c.html#a33">MiInsertPteTracker</a> (
00103      IN PVOID PoolBlock,
00104      IN <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MemoryDescriptorList,
00105      IN PFN_NUMBER NumberOfPtes,
00106      IN PVOID MyCaller,
00107      IN PVOID MyCallersCaller
00108      );
00109 
00110 PVOID
00111 <a class="code" href="../../d5/d6/iosup_8c.html#a34">MiRemovePteTracker</a> (
00112      IN <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MemoryDescriptorList,
00113      IN PVOID PteAddress,
00114      IN PFN_NUMBER NumberOfPtes
00115      );
00116 
00117 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00118 <a class="code" href="../../d5/d6/iosup_8c.html#a35">MiReleaseDeadPteTrackers</a> (
00119     VOID
00120     );
00121 
00122 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00123 <a class="code" href="../../d5/d6/iosup_8c.html#a36">MiInsertDeadPteTrackingBlock</a> (
00124     IN PVOID PoolBlock
00125     );
00126 
00127 
00128 
00129 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00130 <a class="code" href="../../d5/d6/iosup_8c.html#a37">MiProtectFreeNonPagedPool</a> (
00131     IN PVOID VirtualAddress,
00132     IN ULONG SizeInPages
00133     );
00134 
00135 LOGICAL
00136 <a class="code" href="../../d5/d6/iosup_8c.html#a38">MiUnProtectFreeNonPagedPool</a> (
00137     IN PVOID VirtualAddress,
00138     IN ULONG SizeInPages
00139     );
00140 
<a name="l00141"></a><a class="code" href="../../d5/d6/iosup_8c.html#a15">00141</a> <span class="keyword">extern</span> LOGICAL <a class="code" href="../../d5/d6/iosup_8c.html#a15">MiNoLowMemory</a>;
00142 
00143 PVOID
00144 <a class="code" href="../../d4/d5/procsup_8c.html#a27">MiAllocateLowMemory</a> (
00145     IN SIZE_T NumberOfBytes,
00146     IN PFN_NUMBER LowestAcceptablePfn,
00147     IN PFN_NUMBER HighestAcceptablePfn,
00148     IN PFN_NUMBER BoundaryPfn,
00149     IN PVOID CallingAddress,
00150     IN ULONG Tag
00151     );
00152 
00153 LOGICAL
00154 <a class="code" href="../../d4/d5/procsup_8c.html#a28">MiFreeLowMemory</a> (
00155     IN PVOID BaseAddress,
00156     IN ULONG Tag
00157     );
00158 
00159 <span class="preprocessor">#if DBG</span>
00160 <span class="preprocessor"></span>ULONG MiPrintLockedPages;
00161 
00162 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00163 MiVerifyLockedPageCharges (
00164     VOID
00165     );
00166 <span class="preprocessor">#endif</span>
00167 <span class="preprocessor"></span>
00168 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00169 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(INIT, MmAllocateIndependentPages)</span>
00170 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(INIT, MmSetPageProtection)</span>
00171 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(INIT, MiInitializeIoTrackers)</span>
00172 <span class="preprocessor"></span>
00173 <span class="preprocessor">#pragma alloc_text(PAGE, MmLockPagableDataSection)</span>
00174 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, MiLookupDataTableEntry)</span>
00175 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, MiMapLockedPagesInUserSpace)</span>
00176 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, MmSetBankedSection)</span>
00177 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, MmProbeAndLockProcessPages)</span>
00178 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, MmProbeAndLockSelectedPages)</span>
00179 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, MmMapVideoDisplay)</span>
00180 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, MmUnmapVideoDisplay)</span>
00181 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, MmGetSectionRange)</span>
00182 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, MiMapSinglePage)</span>
00183 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, MiUnmapSinglePage)</span>
00184 <span class="preprocessor"></span>
00185 <span class="preprocessor">#pragma alloc_text(PAGELK, MiUnmapLockedPagesInUserSpace)</span>
00186 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGELK, MmAllocateNonCachedMemory)</span>
00187 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGELK, MmFreeNonCachedMemory)</span>
00188 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGELK, MmAllocatePagesForMdl)</span>
00189 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGELK, MmFreePagesFromMdl)</span>
00190 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGELK, MmLockPagedPool)</span>
00191 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGELK, MmUnlockPagedPool)</span>
00192 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGELK, MmGatherMemoryForHibernate)</span>
00193 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGELK, MmReturnMemoryForHibernate)</span>
00194 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGELK, MmReleaseDumpAddresses)</span>
00195 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGELK, MmEnablePAT)</span>
00196 <span class="preprocessor"></span>
00197 <span class="preprocessor">#pragma alloc_text(PAGEVRFY, MmIsSystemAddressLocked)</span>
00198 <span class="preprocessor"></span>
00199 <span class="preprocessor">#pragma alloc_text(PAGEHYDRA, MmDispatchWin32Callout)</span>
00200 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00201 <span class="preprocessor"></span>
<a name="l00202"></a><a class="code" href="../../d5/d6/iosup_8c.html#a16">00202</a> <span class="keyword">extern</span> <a class="code" href="../../d4/d8/struct__POOL__DESCRIPTOR.html">POOL_DESCRIPTOR</a> <a class="code" href="../../d2/d2/ex_2pool_8c.html#a52">NonPagedPoolDescriptor</a>;
00203 
<a name="l00204"></a><a class="code" href="../../d5/d6/iosup_8c.html#a17">00204</a> PFN_NUMBER <a class="code" href="../../d5/d6/iosup_8c.html#a17">MmMdlPagesAllocated</a>;
00205 
<a name="l00206"></a><a class="code" href="../../d5/d6/iosup_8c.html#a18">00206</a> <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> <a class="code" href="../../d5/d6/iosup_8c.html#a18">MmCollidedLockEvent</a>;
<a name="l00207"></a><a class="code" href="../../d5/d6/iosup_8c.html#a19">00207</a> ULONG <a class="code" href="../../d5/d6/iosup_8c.html#a19">MmCollidedLockWait</a>;
00208 
<a name="l00209"></a><a class="code" href="../../d5/d6/iosup_8c.html#a20">00209</a> SIZE_T <a class="code" href="../../d5/d6/iosup_8c.html#a20">MmLockedCode</a>;
00210 
<a name="l00211"></a><a class="code" href="../../d5/d6/iosup_8c.html#a21">00211</a> BOOLEAN <a class="code" href="../../d6/d8/mi386_8h.html#a204">MiWriteCombiningPtes</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00212 
00213 <span class="preprocessor">#ifdef LARGE_PAGES</span>
00214 <span class="preprocessor"></span>ULONG MmLargeVideoMapped;
00215 <span class="preprocessor">#endif</span>
00216 <span class="preprocessor"></span>
00217 <span class="preprocessor">#if DBG</span>
00218 <span class="preprocessor"></span>ULONG MiPrintAwe;
00219 <span class="preprocessor">#endif</span>
00220 <span class="preprocessor"></span>
<a name="l00221"></a><a class="code" href="../../d5/d6/iosup_8c.html#a0">00221</a> <span class="preprocessor">#define MI_PROBE_RAISE_SIZE 10</span>
00222 <span class="preprocessor"></span>
<a name="l00223"></a><a class="code" href="../../d5/d6/iosup_8c.html#a22">00223</a> ULONG <a class="code" href="../../d5/d6/iosup_8c.html#a22">MiProbeRaises</a>[<a class="code" href="../../d5/d6/iosup_8c.html#a0">MI_PROBE_RAISE_SIZE</a>];
00224 
<a name="l00225"></a><a class="code" href="../../d5/d6/iosup_8c.html#a1">00225</a> <span class="preprocessor">#define MI_INSTRUMENT_PROBE_RAISES(i)       \</span>
00226 <span class="preprocessor">        ASSERT (i &lt; MI_PROBE_RAISE_SIZE);   \</span>
00227 <span class="preprocessor">        MiProbeRaises[i] += 1;</span>
00228 <span class="preprocessor"></span>
00229 <span class="comment">//</span>
00230 <span class="comment">//  Note: this should be &gt; 2041 to account for the cache manager's</span>
00231 <span class="comment">//  aggressive zeroing logic.</span>
00232 <span class="comment">//</span>
00233 
<a name="l00234"></a><a class="code" href="../../d5/d6/iosup_8c.html#a23">00234</a> ULONG <a class="code" href="../../d5/d6/iosup_8c.html#a23">MmReferenceCountCheck</a> = 2500;
00235 
00236 
00237 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00238"></a><a class="code" href="../../d5/d6/iosup_8c.html#a41">00238</a> <a class="code" href="../../d5/d6/iosup_8c.html#a41">MmProbeAndLockPages</a> (
00239      IN OUT <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MemoryDescriptorList,
00240      IN KPROCESSOR_MODE AccessMode,
00241      IN LOCK_OPERATION Operation
00242      )
00243 
00244 <span class="comment">/*++</span>
00245 <span class="comment"></span>
00246 <span class="comment">Routine Description:</span>
00247 <span class="comment"></span>
00248 <span class="comment">    This routine probes the specified pages, makes the pages resident and</span>
00249 <span class="comment">    locks the physical pages mapped by the virtual pages in memory.  The</span>
00250 <span class="comment">    Memory descriptor list is updated to describe the physical pages.</span>
00251 <span class="comment"></span>
00252 <span class="comment">Arguments:</span>
00253 <span class="comment"></span>
00254 <span class="comment">    MemoryDescriptorList - Supplies a pointer to a Memory Descriptor List</span>
00255 <span class="comment">                            (MDL). The supplied MDL must supply a virtual</span>
00256 <span class="comment">                            address, byte offset and length field.  The</span>
00257 <span class="comment">                            physical page portion of the MDL is updated when</span>
00258 <span class="comment">                            the pages are locked in memory.</span>
00259 <span class="comment"></span>
00260 <span class="comment">    AccessMode - Supplies the access mode in which to probe the arguments.</span>
00261 <span class="comment">                 One of KernelMode or UserMode.</span>
00262 <span class="comment"></span>
00263 <span class="comment">    Operation - Supplies the operation type.  One of IoReadAccess, IoWriteAccess</span>
00264 <span class="comment">                or IoModifyAccess.</span>
00265 <span class="comment"></span>
00266 <span class="comment">Return Value:</span>
00267 <span class="comment"></span>
00268 <span class="comment">    None - exceptions are raised.</span>
00269 <span class="comment"></span>
00270 <span class="comment">Environment:</span>
00271 <span class="comment"></span>
00272 <span class="comment">    Kernel mode.  APC_LEVEL and below for pagable addresses,</span>
00273 <span class="comment">                  DISPATCH_LEVEL and below for non-pagable addresses.</span>
00274 <span class="comment"></span>
00275 <span class="comment">--*/</span>
00276 
00277 {
00278     PPFN_NUMBER Page;
00279     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> PteContents;
00280     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
00281     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPde;
00282     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPpe;
00283     PVOID Va;
00284     PVOID EndVa;
00285     PVOID AlignedVa;
00286     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
00287     PFN_NUMBER PageFrameIndex;
00288     <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> CurrentProcess;
00289     KIRQL OldIrql;
00290     PFN_NUMBER NumberOfPagesToLock;
00291     PFN_NUMBER NumberOfPagesSpanned;
00292     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
00293     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> ProbeStatus;
00294     <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a> Thread;
00295     ULONG SavedState;
00296     LOGICAL AddressIsPhysical;
00297     PLIST_ENTRY NextEntry;
00298     <a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html">PMI_PHYSICAL_VIEW</a> PhysicalView;
00299     PCHAR StartVa;
00300     PVOID CallingAddress;
00301     PVOID CallersCaller;
00302 
00303 <span class="preprocessor">#if !defined (_X86_)</span>
00304 <span class="preprocessor"></span>    CallingAddress = (PVOID)_ReturnAddress();
00305     CallersCaller = (PVOID)0;
00306 <span class="preprocessor">#endif</span>
00307 <span class="preprocessor"></span>
00308 <span class="preprocessor">#if DBG</span>
00309 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (MiPrintLockedPages != 0) {
00310         MiVerifyLockedPageCharges ();
00311     }
00312 <span class="preprocessor">#endif</span>
00313 <span class="preprocessor"></span>
00314     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (MemoryDescriptorList-&gt;ByteCount != 0);
00315     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (((ULONG)MemoryDescriptorList-&gt;ByteOffset &amp; ~(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) == 0);
00316 
00317     Page = (PPFN_NUMBER)(MemoryDescriptorList + 1);
00318 
00319     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (((ULONG_PTR)MemoryDescriptorList-&gt;StartVa &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) == 0);
00320     AlignedVa = (PVOID)MemoryDescriptorList-&gt;StartVa;
00321 
00322     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((MemoryDescriptorList-&gt;MdlFlags &amp; (
00323                     <a class="code" href="../../d0/d9/ntosdef_8h.html#a13">MDL_PAGES_LOCKED</a> |
00324                     <a class="code" href="../../d0/d9/ntosdef_8h.html#a12">MDL_MAPPED_TO_SYSTEM_VA</a> |
00325                     <a class="code" href="../../d0/d9/ntosdef_8h.html#a14">MDL_SOURCE_IS_NONPAGED_POOL</a> |
00326                     <a class="code" href="../../d0/d9/ntosdef_8h.html#a16">MDL_PARTIAL</a> |
00327                     <a class="code" href="../../d0/d9/ntosdef_8h.html#a23">MDL_IO_SPACE</a>)) == 0);
00328 
00329     Va = (PCHAR)AlignedVa + MemoryDescriptorList-&gt;ByteOffset;
00330     StartVa = Va;
00331 
00332     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (Va);
00333 
00334     <span class="comment">//</span>
00335     <span class="comment">// Endva is one byte past the end of the buffer, if ACCESS_MODE is not</span>
00336     <span class="comment">// kernel, make sure the EndVa is in user space AND the byte count</span>
00337     <span class="comment">// does not cause it to wrap.</span>
00338     <span class="comment">//</span>
00339 
00340     EndVa = (PVOID)((PCHAR)Va + MemoryDescriptorList-&gt;ByteCount);
00341 
00342     <span class="keywordflow">if</span> ((AccessMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) &amp;&amp;
00343         ((EndVa &gt; (PVOID)MM_USER_PROBE_ADDRESS) || (Va &gt;= EndVa))) {
00344         *Page = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a>;
00345         <a class="code" href="../../d5/d6/iosup_8c.html#a1">MI_INSTRUMENT_PROBE_RAISES</a>(0);
00346         <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a> (STATUS_ACCESS_VIOLATION);
00347         <span class="keywordflow">return</span>;
00348     }
00349 
00350     <span class="comment">//</span>
00351     <span class="comment">// There is an optimization which could be performed here.  If</span>
00352     <span class="comment">// the operation is for WriteAccess and the complete page is</span>
00353     <span class="comment">// being modified, we can remove the current page, if it is not</span>
00354     <span class="comment">// resident, and substitute a demand zero page.</span>
00355     <span class="comment">// Note, that after analysis by marking the thread and then</span>
00356     <span class="comment">// noting if a page read was done, this rarely occurs.</span>
00357     <span class="comment">//</span>
00358 
00359     MemoryDescriptorList-&gt;Process = (<a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a>)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00360 
00361     Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a> ();
00362 
00363     <span class="keywordflow">if</span> (!<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a>(Va)) {
00364 
00365         AddressIsPhysical = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00366         ProbeStatus = STATUS_SUCCESS;
00367 
00368         NumberOfPagesToLock = <a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a> (Va,
00369                                        MemoryDescriptorList-&gt;ByteCount);
00370 
00371         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (NumberOfPagesToLock != 0);
00372 
00373         NumberOfPagesSpanned = NumberOfPagesToLock;
00374 
00375         PointerPpe = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a150">MiGetPpeAddress</a> (Va);
00376         PointerPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a151">MiGetPdeAddress</a> (Va);
00377 
00378         <a class="code" href="../../d2/d1/mm_8h.html#a19">MmSavePageFaultReadAhead</a> (Thread, &amp;SavedState);
00379         <a class="code" href="../../d2/d1/mm_8h.html#a20">MmSetPageFaultReadAhead</a> (Thread, (ULONG)(NumberOfPagesToLock - 1));
00380 
00381         <span class="keywordflow">try</span> {
00382 
00383             <span class="keywordflow">do</span> {
00384 
00385                 *Page = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a>;
00386 
00387                 <span class="comment">//</span>
00388                 <span class="comment">// Make sure the page is resident.</span>
00389                 <span class="comment">//</span>
00390 
00391                 *(<span class="keyword">volatile</span> <a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a> *)Va;
00392 
00393                 <span class="keywordflow">if</span> ((Operation != <a class="code" href="../../d2/d1/mm_8h.html#a344a168">IoReadAccess</a>) &amp;&amp;
00394                     (Va &lt;= MM_HIGHEST_USER_ADDRESS)) {
00395 
00396                     <span class="comment">//</span>
00397                     <span class="comment">// Probe for write access as well.</span>
00398                     <span class="comment">//</span>
00399 
00400                     <a class="code" href="../../d5/d8/ex_8h.html#a29">ProbeForWriteChar</a> ((PCHAR)Va);
00401                 }
00402 
00403                 NumberOfPagesToLock -= 1;
00404 
00405                 <a class="code" href="../../d2/d1/mm_8h.html#a20">MmSetPageFaultReadAhead</a> (Thread, (ULONG)(NumberOfPagesToLock - 1));
00406                 Va = (PVOID)(((ULONG_PTR)(PCHAR)Va + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>) &amp; ~(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1));
00407                 Page += 1;
00408             } <span class="keywordflow">while</span> (Va &lt; EndVa);
00409 
00410             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (NumberOfPagesToLock == 0);
00411 
00412         } except (<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00413             ProbeStatus = GetExceptionCode();
00414         }
00415 
00416         <span class="comment">//</span>
00417         <span class="comment">// We may still fault again below but it's generally rare.</span>
00418         <span class="comment">// Restore this thread's normal fault behavior now.</span>
00419         <span class="comment">//</span>
00420 
00421         <a class="code" href="../../d2/d1/mm_8h.html#a21">MmResetPageFaultReadAhead</a> (Thread, SavedState);
00422 
00423         <span class="keywordflow">if</span> (ProbeStatus != STATUS_SUCCESS) {
00424             <a class="code" href="../../d5/d6/iosup_8c.html#a1">MI_INSTRUMENT_PROBE_RAISES</a>(1);
00425             <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a> (ProbeStatus);
00426             <span class="keywordflow">return</span>;
00427         }
00428     }
00429     <span class="keywordflow">else</span> {
00430         AddressIsPhysical = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00431         *Page = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a>;
00432     }
00433 
00434     Va = AlignedVa;
00435     Page = (PPFN_NUMBER)(MemoryDescriptorList + 1);
00436 
00437     <span class="comment">//</span>
00438     <span class="comment">// Indicate that this is a write operation.</span>
00439     <span class="comment">//</span>
00440 
00441     <span class="keywordflow">if</span> (Operation != <a class="code" href="../../d2/d1/mm_8h.html#a344a168">IoReadAccess</a>) {
00442         MemoryDescriptorList-&gt;MdlFlags |= <a class="code" href="../../d0/d9/ntosdef_8h.html#a19">MDL_WRITE_OPERATION</a>;
00443     } <span class="keywordflow">else</span> {
00444         MemoryDescriptorList-&gt;MdlFlags &amp;= ~(<a class="code" href="../../d0/d9/ntosdef_8h.html#a19">MDL_WRITE_OPERATION</a>);
00445     }
00446 
00447     <span class="comment">//</span>
00448     <span class="comment">// Acquire the PFN database lock.</span>
00449     <span class="comment">//</span>
00450 
00451     <a class="code" href="../../d4/d8/mi_8h.html#a130">LOCK_PFN2</a> (OldIrql);
00452 
00453     <span class="keywordflow">if</span> (Va &lt;= MM_HIGHEST_USER_ADDRESS) {
00454 
00455         <span class="comment">//</span>
00456         <span class="comment">// These are addresses with user space, check to see if the</span>
00457         <span class="comment">// working set size will allow these pages to be locked.</span>
00458         <span class="comment">//</span>
00459 
00460         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (NumberOfPagesSpanned != 0);
00461 
00462         CurrentProcess = <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a> ();
00463 
00464         <span class="comment">//</span>
00465         <span class="comment">// Check for a transfer to/from a physical VAD - no reference counts</span>
00466         <span class="comment">// may be modified for these pages.</span>
00467         <span class="comment">//</span>
00468 
00469         NextEntry = CurrentProcess-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o61">PhysicalVadList</a>.Flink;
00470         <span class="keywordflow">while</span> (NextEntry != &amp;CurrentProcess-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o61">PhysicalVadList</a>) {
00471 
00472             PhysicalView = CONTAINING_RECORD(NextEntry,
00473                                              <a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html">MI_PHYSICAL_VIEW</a>,
00474                                              ListEntry);
00475 
00476             <span class="keywordflow">if</span> ((PhysicalView-&gt;<a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html#o1">Vad</a>-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.VadFlags.UserPhysicalPages == 0) &amp;&amp;
00477                 (PhysicalView-&gt;<a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html#o1">Vad</a>-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.VadFlags.PhysicalMapping == 0)) {
00478                 NextEntry = NextEntry-&gt;Flink;
00479                 <span class="keywordflow">continue</span>;
00480             }
00481 
00482             <span class="keywordflow">if</span> (StartVa &lt; PhysicalView-&gt;<a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html#o2">StartVa</a>) {
00483 
00484                 <span class="keywordflow">if</span> ((PCHAR)EndVa - 1 &gt;= PhysicalView-&gt;<a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html#o2">StartVa</a>) {
00485 
00486                     <span class="comment">//</span>
00487                     <span class="comment">// The range encompasses a physical VAD.  This is not</span>
00488                     <span class="comment">// allowed.</span>
00489                     <span class="comment">//</span>
00490 
00491                     <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
00492                     <a class="code" href="../../d5/d6/iosup_8c.html#a1">MI_INSTRUMENT_PROBE_RAISES</a>(2);
00493                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a> (STATUS_ACCESS_VIOLATION);
00494                     <span class="keywordflow">return</span>;
00495                 }
00496 
00497                 NextEntry = NextEntry-&gt;Flink;
00498                 <span class="keywordflow">continue</span>;
00499             }
00500 
00501             <span class="keywordflow">if</span> (StartVa &lt;= PhysicalView-&gt;<a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html#o3">EndVa</a>) {
00502 
00503                 <span class="comment">//</span>
00504                 <span class="comment">// Ensure that the entire range lies within the VAD.</span>
00505                 <span class="comment">//</span>
00506 
00507                 <span class="keywordflow">if</span> ((PCHAR)EndVa - 1 &gt; PhysicalView-&gt;<a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html#o3">EndVa</a>) {
00508 
00509                     <span class="comment">//</span>
00510                     <span class="comment">// The range goes past the end of the VAD - not allowed.</span>
00511                     <span class="comment">//</span>
00512 
00513                     <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
00514                     <a class="code" href="../../d5/d6/iosup_8c.html#a1">MI_INSTRUMENT_PROBE_RAISES</a>(3);
00515                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a> (STATUS_ACCESS_VIOLATION);
00516                     <span class="keywordflow">return</span>;
00517                 }
00518 
00519                 <span class="keywordflow">if</span> (PhysicalView-&gt;<a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html#o1">Vad</a>-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.VadFlags.UserPhysicalPages == 1) {
00520 
00521                     <span class="comment">//</span>
00522                     <span class="comment">// All the PTEs must still be checked and reference</span>
00523                     <span class="comment">// counts bumped on the pages.  Just don't charge</span>
00524                     <span class="comment">// against the working set.</span>
00525                     <span class="comment">//</span>
00526 
00527                     NextEntry = NextEntry-&gt;Flink;
00528                     <span class="keywordflow">continue</span>;
00529                 }
00530 
00531                 <span class="comment">//</span>
00532                 <span class="comment">// The range lies within a physical VAD.</span>
00533                 <span class="comment">//</span>
00534 
00535                 <span class="keywordflow">if</span> (Operation != <a class="code" href="../../d2/d1/mm_8h.html#a344a168">IoReadAccess</a>) {
00536 
00537                     <span class="comment">//</span>
00538                     <span class="comment">// Ensure the VAD is writable.  Changing individual PTE</span>
00539                     <span class="comment">// protections in a physical VAD is not allowed.</span>
00540                     <span class="comment">//</span>
00541 
00542                     <span class="keywordflow">if</span> ((PhysicalView-&gt;<a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html#o1">Vad</a>-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.VadFlags.Protection &amp; <a class="code" href="../../d4/d8/mi_8h.html#a39">MM_READWRITE</a>) == 0) {
00543                         <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
00544                         <a class="code" href="../../d5/d6/iosup_8c.html#a1">MI_INSTRUMENT_PROBE_RAISES</a>(4);
00545                         <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a> (STATUS_ACCESS_VIOLATION);
00546                         <span class="keywordflow">return</span>;
00547                     }
00548                 }
00549 
00550                 <span class="comment">//</span>
00551                 <span class="comment">// Don't charge page locking for this transfer as it is all</span>
00552                 <span class="comment">// physical, just initialize the MDL.  Note the pages do not</span>
00553                 <span class="comment">// have to be physically contiguous, so the frames must be</span>
00554                 <span class="comment">// extracted from the PTEs.</span>
00555                 <span class="comment">//</span>
00556 
00557                 MemoryDescriptorList-&gt;MdlFlags |= (<a class="code" href="../../d0/d9/ntosdef_8h.html#a22">MDL_PHYSICAL_VIEW</a> | <a class="code" href="../../d0/d9/ntosdef_8h.html#a13">MDL_PAGES_LOCKED</a>);
00558                 MemoryDescriptorList-&gt;Process = CurrentProcess;
00559 
00560                 <span class="keywordflow">do</span> {
00561                     PageFrameIndex = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a> (PointerPte);
00562                     *Page = PageFrameIndex;
00563                     Page += 1;
00564                     PointerPte += 1;
00565                     Va = (PVOID)((PCHAR)Va + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
00566                 } <span class="keywordflow">while</span> (Va &lt; EndVa);
00567 
00568                 <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
00569                 <span class="keywordflow">return</span>;
00570             }
00571             NextEntry = NextEntry-&gt;Flink;
00572         }
00573 
00574         CurrentProcess-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o42">NumberOfLockedPages</a> += NumberOfPagesSpanned;
00575 
00576         MemoryDescriptorList-&gt;Process = CurrentProcess;
00577     }
00578 
00579     MemoryDescriptorList-&gt;MdlFlags |= <a class="code" href="../../d0/d9/ntosdef_8h.html#a13">MDL_PAGES_LOCKED</a>;
00580 
00581     <span class="keywordflow">do</span> {
00582 
00583         <span class="keywordflow">if</span> (AddressIsPhysical == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00584 
00585             <span class="comment">//</span>
00586             <span class="comment">// On certain architectures, virtual addresses</span>
00587             <span class="comment">// may be physical and hence have no corresponding PTE.</span>
00588             <span class="comment">//</span>
00589 
00590             PageFrameIndex = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a179">MI_CONVERT_PHYSICAL_TO_PFN</a> (Va);
00591 
00592         } <span class="keywordflow">else</span> {
00593 
00594 <span class="preprocessor">#if defined (_WIN64)</span>
00595 <span class="preprocessor"></span>            <span class="keywordflow">while</span> ((PointerPpe-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 0) ||
00596                    (PointerPde-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 0) ||
00597                    (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 0))
00598 <span class="preprocessor">#else</span>
00599 <span class="preprocessor"></span>            <span class="keywordflow">while</span> ((PointerPde-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 0) ||
00600                    (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 0))
00601 <span class="preprocessor">#endif</span>
00602 <span class="preprocessor"></span>            {
00603 
00604                 <span class="comment">//</span>
00605                 <span class="comment">// PDE is not resident, release PFN lock touch the page and make</span>
00606                 <span class="comment">// it appear.</span>
00607                 <span class="comment">//</span>
00608 
00609                 <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
00610 
00611                 <a class="code" href="../../d2/d1/mm_8h.html#a20">MmSetPageFaultReadAhead</a> (Thread, 0);
00612 
00613                 status = <a class="code" href="../../d4/d1/mmfault_8c.html#a2">MmAccessFault</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, Va, <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>, (PVOID)0);
00614 
00615                 <a class="code" href="../../d2/d1/mm_8h.html#a21">MmResetPageFaultReadAhead</a> (Thread, SavedState);
00616 
00617                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
00618 
00619                     <span class="comment">//</span>
00620                     <span class="comment">// An exception occurred.  Unlock the pages locked</span>
00621                     <span class="comment">// so far.</span>
00622                     <span class="comment">//</span>
00623 
00624 <a class="code" href="../../d8/d0/rtbatcr_8c.html#a1">failure</a>:
00625                     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a33">MmTrackLockedPages</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00626 
00627                         <span class="comment">//</span>
00628                         <span class="comment">// Adjust the MDL length so that MmUnlockPages only</span>
00629                         <span class="comment">// processes the part that was completed.</span>
00630                         <span class="comment">//</span>
00631 
00632                         ULONG PagesLocked;
00633             
00634                         PagesLocked = <a class="code" href="../../d2/d1/mm_8h.html#a8">ADDRESS_AND_SIZE_TO_SPAN_PAGES</a>(StartVa,
00635                                               MemoryDescriptorList-&gt;ByteCount);
00636 
00637 <span class="preprocessor">#if defined (_X86_)</span>
00638 <span class="preprocessor"></span>                        <a class="code" href="../../d5/d2/ppc_2getcalr_8c.html#a0">RtlGetCallersAddress</a>(&amp;CallingAddress, &amp;CallersCaller);
00639 <span class="preprocessor">#endif</span>
00640 <span class="preprocessor"></span>                        <a class="code" href="../../d5/d6/iosup_8c.html#a32">MiAddMdlTracker</a> (MemoryDescriptorList,
00641                                          CallingAddress,
00642                                          CallersCaller,
00643                                          PagesLocked,
00644                                          0);
00645                     }
00646 
00647                     <a class="code" href="../../d5/d6/iosup_8c.html#a45">MmUnlockPages</a> (MemoryDescriptorList);
00648 
00649                     <span class="comment">//</span>
00650                     <span class="comment">// Raise an exception of access violation to the caller.</span>
00651                     <span class="comment">//</span>
00652 
00653                     <a class="code" href="../../d5/d6/iosup_8c.html#a1">MI_INSTRUMENT_PROBE_RAISES</a>(7);
00654                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a> (status);
00655                     <span class="keywordflow">return</span>;
00656                 }
00657 
00658                 <a class="code" href="../../d4/d8/mi_8h.html#a130">LOCK_PFN2</a> (OldIrql);
00659             }
00660 
00661             PteContents = *PointerPte;
00662             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1);
00663 
00664             <span class="keywordflow">if</span> (Va &lt;= MM_HIGHEST_USER_ADDRESS) {
00665                 <span class="keywordflow">if</span> (Operation != <a class="code" href="../../d2/d1/mm_8h.html#a344a168">IoReadAccess</a>) {
00666 
00667                     <span class="keywordflow">if</span> ((PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long &amp; <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a77">MM_PTE_WRITE_MASK</a>) == 0) {
00668 
00669                         <span class="comment">//</span>
00670                         <span class="comment">// The caller has made the page protection more</span>
00671                         <span class="comment">// restrictive, this should never be done once the</span>
00672                         <span class="comment">// request has been issued !  Rather than wading</span>
00673                         <span class="comment">// through the PFN database entry to see if it</span>
00674                         <span class="comment">// could possibly work out, give the caller an</span>
00675                         <span class="comment">// access violation.</span>
00676                         <span class="comment">//</span>
00677 
00678 <span class="preprocessor">#if DBG</span>
00679 <span class="preprocessor"></span>                        <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a> (<span class="stringliteral">"MmProbeAndLockPages: PTE %p %p changed\n"</span>,
00680                             PointerPte,
00681                             PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long);
00682                         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00683 <span class="preprocessor">#endif</span>
00684 <span class="preprocessor"></span>
00685                         <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
00686                         status = STATUS_ACCESS_VIOLATION;
00687                         <span class="keywordflow">goto</span> <a class="code" href="../../d8/d0/rtbatcr_8c.html#a1">failure</a>;
00688                     }
00689                 }
00690             }
00691 
00692             PageFrameIndex = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a> (&amp;PteContents);
00693         }
00694 
00695         <span class="keywordflow">if</span> (PageFrameIndex &gt; <a class="code" href="../../d6/d8/sysinfo_8c.html#a7">MmHighestPhysicalPage</a>) {
00696 
00697             <span class="comment">//</span>
00698             <span class="comment">// This is an I/O space address don't allow operations</span>
00699             <span class="comment">// on addresses not in the PFN database.</span>
00700             <span class="comment">//</span>
00701 
00702             MemoryDescriptorList-&gt;MdlFlags |= <a class="code" href="../../d0/d9/ntosdef_8h.html#a23">MDL_IO_SPACE</a>;
00703 
00704         } <span class="keywordflow">else</span> {
00705             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((MemoryDescriptorList-&gt;MdlFlags &amp; <a class="code" href="../../d0/d9/ntosdef_8h.html#a23">MDL_IO_SPACE</a>) == 0);
00706 
00707             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PageFrameIndex);
00708 
00709 <span class="preprocessor">#if PFN_CONSISTENCY</span>
00710 <span class="preprocessor"></span>            <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageTablePage == 0);
00711 <span class="preprocessor">#endif</span>
00712 <span class="preprocessor"></span>
00713             <span class="comment">//</span>
00714             <span class="comment">// Check to make sure this page is not locked down an unusually</span>
00715             <span class="comment">// high number of times.</span>
00716             <span class="comment">//</span>
00717 
00718             <span class="keywordflow">if</span> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount &gt;= <a class="code" href="../../d5/d6/iosup_8c.html#a23">MmReferenceCountCheck</a>) {
00719                 <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
00720                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00721                 status = STATUS_WORKING_SET_QUOTA;
00722                 <span class="keywordflow">goto</span> <a class="code" href="../../d8/d0/rtbatcr_8c.html#a1">failure</a>;
00723             }
00724 
00725             <span class="comment">//</span>
00726             <span class="comment">// Check to make sure the systemwide locked pages count is fluid.</span>
00727             <span class="comment">//</span>
00728 
00729             <span class="keywordflow">if</span> (<a class="code" href="../../d4/d8/mi_8h.html#a323">MI_NONPAGABLE_MEMORY_AVAILABLE</a>() &lt;= 0) {
00730 
00731                 <span class="comment">//</span>
00732                 <span class="comment">// If this page is for paged pool or privileged code/data,</span>
00733                 <span class="comment">// then force it in.</span>
00734                 <span class="comment">//</span>
00735 
00736                 <span class="keywordflow">if</span> ((Va &gt; MM_HIGHEST_USER_ADDRESS) &amp;&amp;
00737                     (!<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a196">MI_IS_SYSTEM_CACHE_ADDRESS</a>(Va))) {
00738                     <a class="code" href="../../d5/d6/iosup_8c.html#a1">MI_INSTRUMENT_PROBE_RAISES</a>(8);
00739                     <span class="keywordflow">goto</span> ok;
00740                 }
00741 
00742                 <a class="code" href="../../d5/d6/iosup_8c.html#a1">MI_INSTRUMENT_PROBE_RAISES</a>(5);
00743                 <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
00744                 status = STATUS_WORKING_SET_QUOTA;
00745                 <span class="keywordflow">goto</span> <a class="code" href="../../d8/d0/rtbatcr_8c.html#a1">failure</a>;
00746             }
00747 
00748             <span class="comment">//</span>
00749             <span class="comment">// Check to make sure any administrator-desired limit is obeyed.</span>
00750             <span class="comment">//</span>
00751 
00752             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/iosup_8c.html#a2">MmSystemLockPagesCount</a> + 1 &gt;= <a class="code" href="../../d4/d8/mi_8h.html#a635">MmLockPagesLimit</a>) {
00753 
00754                 <span class="comment">//</span>
00755                 <span class="comment">// If this page is for paged pool or privileged code/data,</span>
00756                 <span class="comment">// then force it in.</span>
00757                 <span class="comment">//</span>
00758 
00759                 <span class="keywordflow">if</span> ((Va &gt; MM_HIGHEST_USER_ADDRESS) &amp;&amp;
00760                     (!<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a196">MI_IS_SYSTEM_CACHE_ADDRESS</a>(Va))) {
00761                     <a class="code" href="../../d5/d6/iosup_8c.html#a1">MI_INSTRUMENT_PROBE_RAISES</a>(9);
00762                     <span class="keywordflow">goto</span> ok;
00763                 }
00764 
00765                 <a class="code" href="../../d5/d6/iosup_8c.html#a1">MI_INSTRUMENT_PROBE_RAISES</a>(6);
00766                 <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
00767                 status = STATUS_WORKING_SET_QUOTA;
00768                 <span class="keywordflow">goto</span> <a class="code" href="../../d8/d0/rtbatcr_8c.html#a1">failure</a>;
00769             }
00770 
00771 ok:
00772             <a class="code" href="../../d4/d8/mi_8h.html#a186">MI_ADD_LOCKED_PAGE_CHARGE</a>(Pfn1, 0);
00773 
00774             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount += 1;
00775         }
00776 
00777         *Page = PageFrameIndex;
00778 
00779         Page += 1;
00780         PointerPte += 1;
00781         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a167">MiIsPteOnPdeBoundary</a>(PointerPte)) {
00782             PointerPde += 1;
00783             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a166">MiIsPteOnPpeBoundary</a>(PointerPte)) {
00784                 PointerPpe += 1;
00785             }
00786         }
00787 
00788         Va = (PVOID)((PCHAR)Va + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
00789     } <span class="keywordflow">while</span> (Va &lt; EndVa);
00790 
00791     <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
00792 
00793     <span class="keywordflow">if</span> ((<a class="code" href="../../d8/d0/cmdat3_8c.html#a33">MmTrackLockedPages</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) &amp;&amp; (AlignedVa &lt;= MM_HIGHEST_USER_ADDRESS)) {
00794 
00795         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (NumberOfPagesSpanned != 0);
00796 
00797 <span class="preprocessor">#if defined (_X86_)</span>
00798 <span class="preprocessor"></span>        <a class="code" href="../../d5/d2/ppc_2getcalr_8c.html#a0">RtlGetCallersAddress</a>(&amp;CallingAddress, &amp;CallersCaller);
00799 <span class="preprocessor">#endif</span>
00800 <span class="preprocessor"></span>
00801         <a class="code" href="../../d5/d6/iosup_8c.html#a32">MiAddMdlTracker</a> (MemoryDescriptorList,
00802                          CallingAddress,
00803                          CallersCaller,
00804                          NumberOfPagesSpanned,
00805                          1);
00806     }
00807 
00808     <span class="keywordflow">return</span>;
00809 }
00810 
00811 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
00812 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00813"></a><a class="code" href="../../d5/d6/iosup_8c.html#a42">00813</a> <a class="code" href="../../d5/d6/iosup_8c.html#a42">MmProbeAndLockProcessPages</a> (
00814     IN OUT <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MemoryDescriptorList,
00815     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process,
00816     IN KPROCESSOR_MODE AccessMode,
00817     IN LOCK_OPERATION Operation
00818     )
00819 
00820 <span class="comment">/*++</span>
00821 <span class="comment"></span>
00822 <span class="comment">Routine Description:</span>
00823 <span class="comment"></span>
00824 <span class="comment">    This routine probes and locks the address range specified by</span>
00825 <span class="comment">    the MemoryDescriptorList in the specified Process for the AccessMode</span>
00826 <span class="comment">    and Operation.</span>
00827 <span class="comment"></span>
00828 <span class="comment">Arguments:</span>
00829 <span class="comment"></span>
00830 <span class="comment">    MemoryDescriptorList - Supplies a pre-initialized MDL that describes the</span>
00831 <span class="comment">                           address range to be probed and locked.</span>
00832 <span class="comment"></span>
00833 <span class="comment">    Process - Specifies the address of the process whose address range is</span>
00834 <span class="comment">              to be locked.</span>
00835 <span class="comment"></span>
00836 <span class="comment">    AccessMode - The mode for which the probe should check access to the range.</span>
00837 <span class="comment"></span>
00838 <span class="comment">    Operation - Supplies the type of access which for which to check the range.</span>
00839 <span class="comment"></span>
00840 <span class="comment">Return Value:</span>
00841 <span class="comment"></span>
00842 <span class="comment">    None.</span>
00843 <span class="comment"></span>
00844 <span class="comment">--*/</span>
00845 
00846 {
00847     LOGICAL Attached;
00848     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00849 
00850     Attached = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00851     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
00852 
00853     <span class="keywordflow">if</span> (Process != <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a> ()) {
00854         <a class="code" href="../../d3/d5/procobj_8c.html#a4">KeAttachProcess</a> (&amp;Process-&gt;Pcb);
00855         Attached = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00856     }
00857 
00858     <span class="keywordflow">try</span> {
00859 
00860         <a class="code" href="../../d5/d6/iosup_8c.html#a41">MmProbeAndLockPages</a> (MemoryDescriptorList,
00861                              AccessMode,
00862                              Operation);
00863 
00864     } except (<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00865         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = GetExceptionCode();
00866     }
00867 
00868     <span class="keywordflow">if</span> (Attached) {
00869         <a class="code" href="../../d3/d5/procobj_8c.html#a7">KeDetachProcess</a>();
00870     }
00871 
00872     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> != STATUS_SUCCESS) {
00873         <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>);
00874     }
00875     <span class="keywordflow">return</span>;
00876 }
00877 
00878 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00879"></a><a class="code" href="../../d5/d6/iosup_8c.html#a32">00879</a> <a class="code" href="../../d5/d6/iosup_8c.html#a32">MiAddMdlTracker</a> (
00880     IN <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MemoryDescriptorList,
00881     IN PVOID CallingAddress,
00882     IN PVOID CallersCaller,
00883     IN PFN_NUMBER NumberOfPagesToLock,
00884     IN ULONG Who
00885     )
00886 
00887 <span class="comment">/*++</span>
00888 <span class="comment"></span>
00889 <span class="comment">Routine Description:</span>
00890 <span class="comment"></span>
00891 <span class="comment">    This routine adds an MDL to the specified process' chain.</span>
00892 <span class="comment"></span>
00893 <span class="comment">Arguments:</span>
00894 <span class="comment"></span>
00895 <span class="comment">    MemoryDescriptorList - Supplies a pointer to a Memory Descriptor List</span>
00896 <span class="comment">                           (MDL). The MDL must supply the length. The</span>
00897 <span class="comment">                           physical page portion of the MDL is updated when</span>
00898 <span class="comment">                           the pages are locked in memory.</span>
00899 <span class="comment"></span>
00900 <span class="comment">    CallingAddress - Supplies the address of the caller of our caller.</span>
00901 <span class="comment"></span>
00902 <span class="comment">    CallersCaller - Supplies the address of the caller of CallingAddress.</span>
00903 <span class="comment"></span>
00904 <span class="comment">    NumberOfPagesToLock - Specifies the number of pages to lock.</span>
00905 <span class="comment"></span>
00906 <span class="comment">    Who - Specifies which routine is adding the entry.</span>
00907 <span class="comment"></span>
00908 <span class="comment">Return Value:</span>
00909 <span class="comment"></span>
00910 <span class="comment">    None - exceptions are raised.</span>
00911 <span class="comment"></span>
00912 <span class="comment">Environment:</span>
00913 <span class="comment"></span>
00914 <span class="comment">    Kernel mode.  APC_LEVEL and below.</span>
00915 <span class="comment"></span>
00916 <span class="comment">--*/</span>
00917 
00918 {
00919     KIRQL OldIrql;
00920     <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process;
00921     <a class="code" href="../../d5/d2/struct__LOCK__HEADER.html">PLOCK_HEADER</a> LockedPagesHeader;
00922     <a class="code" href="../../d0/d3/struct__LOCK__TRACKER.html">PLOCK_TRACKER</a> Tracker;
00923     <a class="code" href="../../d0/d3/struct__LOCK__TRACKER.html">PLOCK_TRACKER</a> P;
00924     PLIST_ENTRY NextEntry;
00925 
00926     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a33">MmTrackLockedPages</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
00927 
00928     Process = MemoryDescriptorList-&gt;Process;
00929 
00930     <span class="keywordflow">if</span> (Process == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00931         <span class="keywordflow">return</span>;
00932     }
00933 
00934     LockedPagesHeader = Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o76">LockedPagesList</a>;
00935 
00936     <span class="keywordflow">if</span> (LockedPagesHeader == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00937         <span class="keywordflow">return</span>;
00938     }
00939 
00940     <span class="comment">//</span>
00941     <span class="comment">// It's ok to check unsynchronized for aborted tracking as the worst case</span>
00942     <span class="comment">// is just that one more entry gets added which will be freed later anyway.</span>
00943     <span class="comment">// The main purpose behind aborted tracking is that frees and exits don't</span>
00944     <span class="comment">// mistakenly bugcheck when an entry cannot be found.</span>
00945     <span class="comment">//</span>
00946 
00947     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/iosup_8c.html#a14">MiTrackingAborted</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00948         <span class="keywordflow">return</span>;
00949     }
00950 
00951     Tracker = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a> (<a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
00952                                      <span class="keyword">sizeof</span> (<a class="code" href="../../d0/d3/struct__LOCK__TRACKER.html">LOCK_TRACKER</a>),
00953                                      'kLmM');
00954 
00955     <span class="keywordflow">if</span> (Tracker == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00956 
00957         <span class="comment">//</span>
00958         <span class="comment">// It's ok to set this without synchronization as the worst case</span>
00959         <span class="comment">// is just that a few more entries gets added which will be freed</span>
00960         <span class="comment">// later anyway.  The main purpose behind aborted tracking is that</span>
00961         <span class="comment">// frees and exits don't mistakenly bugcheck when an entry cannot</span>
00962         <span class="comment">// be found.</span>
00963         <span class="comment">//</span>
00964     
00965         <a class="code" href="../../d5/d6/iosup_8c.html#a14">MiTrackingAborted</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00966 
00967         <span class="keywordflow">return</span>;
00968     }
00969 
00970     Tracker-&gt;<a class="code" href="../../d0/d3/struct__LOCK__TRACKER.html#o1">Mdl</a> = MemoryDescriptorList;
00971     Tracker-&gt;<a class="code" href="../../d0/d3/struct__LOCK__TRACKER.html#o3">Count</a> = NumberOfPagesToLock;
00972     Tracker-&gt;<a class="code" href="../../d0/d3/struct__LOCK__TRACKER.html#o2">StartVa</a> = MemoryDescriptorList-&gt;StartVa;
00973     Tracker-&gt;<a class="code" href="../../d0/d3/struct__LOCK__TRACKER.html#o4">Offset</a> = MemoryDescriptorList-&gt;ByteOffset;
00974     Tracker-&gt;<a class="code" href="../../d0/d3/struct__LOCK__TRACKER.html#o5">Length</a> = MemoryDescriptorList-&gt;ByteCount;
00975     Tracker-&gt;<a class="code" href="../../d0/d3/struct__LOCK__TRACKER.html#o6">Page</a> = *(PPFN_NUMBER)(MemoryDescriptorList + 1);
00976 
00977     Tracker-&gt;<a class="code" href="../../d0/d3/struct__LOCK__TRACKER.html#o7">CallingAddress</a> = CallingAddress;
00978     Tracker-&gt;<a class="code" href="../../d0/d3/struct__LOCK__TRACKER.html#o8">CallersCaller</a> = CallersCaller;
00979 
00980     Tracker-&gt;<a class="code" href="../../d0/d3/struct__LOCK__TRACKER.html#o10">Who</a> = Who;
00981     Tracker-&gt;<a class="code" href="../../d0/d3/struct__LOCK__TRACKER.html#o11">Process</a> = Process;
00982 
00983     <a class="code" href="../../d4/d8/mi_8h.html#a130">LOCK_PFN2</a> (OldIrql);
00984 
00985     <span class="comment">//</span>
00986     <span class="comment">// Update the list for this process.  First make sure it's not already</span>
00987     <span class="comment">// inserted.</span>
00988     <span class="comment">//</span>
00989 
00990     NextEntry = LockedPagesHeader-&gt;<a class="code" href="../../d5/d2/struct__LOCK__HEADER.html#o0">ListHead</a>.Flink;
00991     <span class="keywordflow">while</span> (NextEntry != &amp;LockedPagesHeader-&gt;<a class="code" href="../../d5/d2/struct__LOCK__HEADER.html#o0">ListHead</a>) {
00992 
00993         P = CONTAINING_RECORD (NextEntry,
00994                                <a class="code" href="../../d4/d8/mi_8h.html#a524">LOCK_TRACKER</a>,
00995                                ListEntry);
00996 
00997         <span class="keywordflow">if</span> (P-&gt;<a class="code" href="../../d0/d3/struct__LOCK__TRACKER.html#o1">Mdl</a> == MemoryDescriptorList) {
00998             <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a> (LOCKED_PAGES_TRACKER_CORRUPTION,
00999                           0x1,
01000                           (ULONG_PTR)P,
01001                           (ULONG_PTR)MemoryDescriptorList,
01002                           (ULONG_PTR)<a class="code" href="../../d5/d6/iosup_8c.html#a13">MmLockedPagesHead</a>.<a class="code" href="../../d5/d2/struct__LOCK__HEADER.html#o1">Count</a>);
01003         }
01004         NextEntry = NextEntry-&gt;Flink;
01005     }
01006 
01007     InsertHeadList (&amp;LockedPagesHeader-&gt;<a class="code" href="../../d5/d2/struct__LOCK__HEADER.html#o0">ListHead</a>, &amp;Tracker-&gt;<a class="code" href="../../d0/d3/struct__LOCK__TRACKER.html#o0">ListEntry</a>);
01008     LockedPagesHeader-&gt;<a class="code" href="../../d5/d2/struct__LOCK__HEADER.html#o1">Count</a> += NumberOfPagesToLock;
01009 
01010     <span class="comment">//</span>
01011     <span class="comment">// Update the systemwide global list.  First make sure it's not</span>
01012     <span class="comment">// already inserted.</span>
01013     <span class="comment">//</span>
01014 
01015     NextEntry = <a class="code" href="../../d5/d6/iosup_8c.html#a13">MmLockedPagesHead</a>.<a class="code" href="../../d5/d2/struct__LOCK__HEADER.html#o0">ListHead</a>.Flink;
01016     <span class="keywordflow">while</span> (NextEntry != &amp;<a class="code" href="../../d5/d6/iosup_8c.html#a13">MmLockedPagesHead</a>.<a class="code" href="../../d5/d2/struct__LOCK__HEADER.html#o0">ListHead</a>) {
01017 
01018         P = CONTAINING_RECORD(NextEntry,
01019                               <a class="code" href="../../d4/d8/mi_8h.html#a524">LOCK_TRACKER</a>,
01020                               GlobalListEntry);
01021 
01022         <span class="keywordflow">if</span> (P-&gt;<a class="code" href="../../d0/d3/struct__LOCK__TRACKER.html#o1">Mdl</a> == MemoryDescriptorList) {
01023             <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a> (LOCKED_PAGES_TRACKER_CORRUPTION,
01024                           0x2,
01025                           (ULONG_PTR)P,
01026                           (ULONG_PTR)MemoryDescriptorList,
01027                           (ULONG_PTR)<a class="code" href="../../d5/d6/iosup_8c.html#a13">MmLockedPagesHead</a>.<a class="code" href="../../d5/d2/struct__LOCK__HEADER.html#o1">Count</a>);
01028         }
01029 
01030         NextEntry = NextEntry-&gt;Flink;
01031     }
01032 
01033     InsertHeadList (&amp;<a class="code" href="../../d5/d6/iosup_8c.html#a13">MmLockedPagesHead</a>.<a class="code" href="../../d5/d2/struct__LOCK__HEADER.html#o0">ListHead</a>,
01034                     &amp;Tracker-&gt;<a class="code" href="../../d0/d3/struct__LOCK__TRACKER.html#o9">GlobalListEntry</a>);
01035     <a class="code" href="../../d5/d6/iosup_8c.html#a13">MmLockedPagesHead</a>.<a class="code" href="../../d5/d2/struct__LOCK__HEADER.html#o1">Count</a> += NumberOfPagesToLock;
01036 
01037     <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
01038 }
01039 
01040 LOGICAL
<a name="l01041"></a><a class="code" href="../../d5/d6/iosup_8c.html#a43">01041</a> <a class="code" href="../../d5/d6/iosup_8c.html#a43">MiFreeMdlTracker</a> (
01042     IN OUT <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MemoryDescriptorList,
01043     IN PFN_NUMBER NumberOfPages
01044     )
01045 
01046 <span class="comment">/*++</span>
01047 <span class="comment"></span>
01048 <span class="comment">Routine Description:</span>
01049 <span class="comment"></span>
01050 <span class="comment">    This deletes an MDL from the specified process' chain.  Used specifically</span>
01051 <span class="comment">    by MmProbeAndLockSelectedPages () because it builds an MDL in its local</span>
01052 <span class="comment">    stack and then copies the requested pages into the real MDL.  this lets</span>
01053 <span class="comment">    us track these pages.</span>
01054 <span class="comment"></span>
01055 <span class="comment">Arguments:</span>
01056 <span class="comment"></span>
01057 <span class="comment">    MemoryDescriptorList - Supplies a pointer to a Memory Descriptor List</span>
01058 <span class="comment">                           (MDL). The MDL must supply the length.</span>
01059 <span class="comment"></span>
01060 <span class="comment">    NumberOfPages - Supplies the number of pages to be freed.</span>
01061 <span class="comment"></span>
01062 <span class="comment">Return Value:</span>
01063 <span class="comment"></span>
01064 <span class="comment">    TRUE.</span>
01065 <span class="comment"></span>
01066 <span class="comment">Environment:</span>
01067 <span class="comment"></span>
01068 <span class="comment">    Kernel mode.  APC_LEVEL and below.</span>
01069 <span class="comment"></span>
01070 <span class="comment">--*/</span>
01071 {
01072     KIRQL OldIrql;
01073     <a class="code" href="../../d0/d3/struct__LOCK__TRACKER.html">PLOCK_TRACKER</a> Tracker;
01074     PLIST_ENTRY NextEntry;
01075     <a class="code" href="../../d5/d2/struct__LOCK__HEADER.html">PLOCK_HEADER</a> LockedPagesHeader;
01076     PPFN_NUMBER Page;
01077     <a class="code" href="../../d0/d3/struct__LOCK__TRACKER.html">PLOCK_TRACKER</a> Found;
01078     PVOID PoolToFree;
01079 
01080     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (MemoryDescriptorList-&gt;Process != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
01081 
01082     LockedPagesHeader = (<a class="code" href="../../d5/d2/struct__LOCK__HEADER.html">PLOCK_HEADER</a>)MemoryDescriptorList-&gt;Process-&gt;LockedPagesList;
01083 
01084     <span class="keywordflow">if</span> (LockedPagesHeader == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01085         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01086     }
01087 
01088     Found = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01089     Page = (PPFN_NUMBER) (MemoryDescriptorList + 1);
01090 
01091     <a class="code" href="../../d4/d8/mi_8h.html#a130">LOCK_PFN2</a> (OldIrql);
01092 
01093     NextEntry = LockedPagesHeader-&gt;<a class="code" href="../../d5/d2/struct__LOCK__HEADER.html#o0">ListHead</a>.Flink;
01094     <span class="keywordflow">while</span> (NextEntry != &amp;LockedPagesHeader-&gt;<a class="code" href="../../d5/d2/struct__LOCK__HEADER.html#o0">ListHead</a>) {
01095 
01096         Tracker = CONTAINING_RECORD (NextEntry,
01097                                      <a class="code" href="../../d0/d3/struct__LOCK__TRACKER.html">LOCK_TRACKER</a>,
01098                                      ListEntry);
01099 
01100         <span class="keywordflow">if</span> (MemoryDescriptorList == Tracker-&gt;<a class="code" href="../../d0/d3/struct__LOCK__TRACKER.html#o1">Mdl</a>) {
01101 
01102             <span class="keywordflow">if</span> (Found != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01103                 <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a> (LOCKED_PAGES_TRACKER_CORRUPTION,
01104                               0x3,
01105                               (ULONG_PTR)Found,
01106                               (ULONG_PTR)Tracker,
01107                               (ULONG_PTR)MemoryDescriptorList);
01108             }
01109 
01110             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Tracker-&gt;<a class="code" href="../../d0/d3/struct__LOCK__TRACKER.html#o6">Page</a> == *Page);
01111             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (NumberOfPages == Tracker-&gt;<a class="code" href="../../d0/d3/struct__LOCK__TRACKER.html#o3">Count</a>);
01112             Tracker-&gt;<a class="code" href="../../d0/d3/struct__LOCK__TRACKER.html#o3">Count</a> = (PFN_NUMBER)-1;
01113             RemoveEntryList (NextEntry);
01114             LockedPagesHeader-&gt;<a class="code" href="../../d5/d2/struct__LOCK__HEADER.html#o1">Count</a> -= NumberOfPages;
01115 
01116             RemoveEntryList (&amp;Tracker-&gt;<a class="code" href="../../d0/d3/struct__LOCK__TRACKER.html#o9">GlobalListEntry</a>);
01117             <a class="code" href="../../d5/d6/iosup_8c.html#a13">MmLockedPagesHead</a>.<a class="code" href="../../d5/d2/struct__LOCK__HEADER.html#o1">Count</a> -= NumberOfPages;
01118 
01119             Found = Tracker;
01120             PoolToFree = (PVOID)NextEntry;
01121         }
01122         NextEntry = Tracker-&gt;<a class="code" href="../../d0/d3/struct__LOCK__TRACKER.html#o0">ListEntry</a>.Flink;
01123     }
01124 
01125     <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
01126 
01127     <span class="keywordflow">if</span> (Found == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01128 
01129         <span class="comment">//</span>
01130         <span class="comment">// A driver is trying to unlock pages that aren't locked.</span>
01131         <span class="comment">//</span>
01132 
01133         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/iosup_8c.html#a14">MiTrackingAborted</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01134             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01135         }
01136 
01137         <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a> (PROCESS_HAS_LOCKED_PAGES,
01138                       1,
01139                       (ULONG_PTR)MemoryDescriptorList,
01140                       MemoryDescriptorList-&gt;Process-&gt;NumberOfLockedPages,
01141                       (ULONG_PTR)MemoryDescriptorList-&gt;Process-&gt;LockedPagesList);
01142     }
01143 
01144     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (PoolToFree);
01145 
01146     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01147 }
01148 
01149 
01150 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01151 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01152"></a><a class="code" href="../../d5/d6/iosup_8c.html#a44">01152</a> <a class="code" href="../../d5/d6/iosup_8c.html#a44">MmProbeAndLockSelectedPages</a> (
01153     IN OUT <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MemoryDescriptorList,
01154     IN PFILE_SEGMENT_ELEMENT SegmentArray,
01155     IN KPROCESSOR_MODE AccessMode,
01156     IN LOCK_OPERATION Operation
01157     )
01158 
01159 <span class="comment">/*++</span>
01160 <span class="comment"></span>
01161 <span class="comment">Routine Description:</span>
01162 <span class="comment"></span>
01163 <span class="comment">    This routine probes the specified pages, makes the pages resident and</span>
01164 <span class="comment">    locks the physical pages mapped by the virtual pages in memory.  The</span>
01165 <span class="comment">    Memory descriptor list is updated to describe the physical pages.</span>
01166 <span class="comment"></span>
01167 <span class="comment">Arguments:</span>
01168 <span class="comment"></span>
01169 <span class="comment">    MemoryDescriptorList - Supplies a pointer to a Memory Descriptor List</span>
01170 <span class="comment">                           (MDL). The MDL must supply the length. The</span>
01171 <span class="comment">                           physical page portion of the MDL is updated when</span>
01172 <span class="comment">                           the pages are locked in memory.</span>
01173 <span class="comment"></span>
01174 <span class="comment">    SegmentArray - Supplies a pointer to a list of buffer segments to be</span>
01175 <span class="comment">                   probed and locked.</span>
01176 <span class="comment"></span>
01177 <span class="comment">    AccessMode - Supplies the access mode in which to probe the arguments.</span>
01178 <span class="comment">                 One of KernelMode or UserMode.</span>
01179 <span class="comment"></span>
01180 <span class="comment">    Operation - Supplies the operation type.  One of IoReadAccess, IoWriteAccess</span>
01181 <span class="comment">                or IoModifyAccess.</span>
01182 <span class="comment"></span>
01183 <span class="comment">Return Value:</span>
01184 <span class="comment"></span>
01185 <span class="comment">    None - exceptions are raised.</span>
01186 <span class="comment"></span>
01187 <span class="comment">Environment:</span>
01188 <span class="comment"></span>
01189 <span class="comment">    Kernel mode.  APC_LEVEL and below.</span>
01190 <span class="comment"></span>
01191 <span class="comment">--*/</span>
01192 
01193 {
01194     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> TempMdl;
01195     PFN_NUMBER MdlHack[(<span class="keyword">sizeof</span>(<a class="code" href="../../d6/d7/struct__MDL.html">MDL</a>)/<span class="keyword">sizeof</span>(PFN_NUMBER)) + 1];
01196     PPFN_NUMBER Page;
01197     PFILE_SEGMENT_ELEMENT LastSegment;
01198     PVOID CallingAddress;
01199     PVOID CallersCaller;
01200     ULONG NumberOfPagesToLock;
01201 
01202     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01203 
01204 <span class="preprocessor">#if !defined (_X86_)</span>
01205 <span class="preprocessor"></span>    CallingAddress = (PVOID)_ReturnAddress();
01206     CallersCaller = (PVOID)0;
01207 <span class="preprocessor">#endif</span>
01208 <span class="preprocessor"></span>
01209     NumberOfPagesToLock = 0;
01210 
01211     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (MemoryDescriptorList-&gt;ByteCount != 0);
01212     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (((ULONG_PTR)MemoryDescriptorList-&gt;ByteOffset &amp; ~(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) == 0);
01213 
01214     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((MemoryDescriptorList-&gt;MdlFlags &amp; (
01215                     <a class="code" href="../../d0/d9/ntosdef_8h.html#a13">MDL_PAGES_LOCKED</a> |
01216                     <a class="code" href="../../d0/d9/ntosdef_8h.html#a12">MDL_MAPPED_TO_SYSTEM_VA</a> |
01217                     <a class="code" href="../../d0/d9/ntosdef_8h.html#a14">MDL_SOURCE_IS_NONPAGED_POOL</a> |
01218                     <a class="code" href="../../d0/d9/ntosdef_8h.html#a16">MDL_PARTIAL</a> |
01219                     <a class="code" href="../../d0/d9/ntosdef_8h.html#a23">MDL_IO_SPACE</a>)) == 0);
01220 
01221     <span class="comment">//</span>
01222     <span class="comment">// Initialize TempMdl.</span>
01223     <span class="comment">//</span>
01224 
01225     TempMdl = (<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>) &amp;MdlHack;
01226 
01227     <a class="code" href="../../d2/d1/mm_8h.html#a24">MmInitializeMdl</a>( TempMdl, SegmentArray-&gt;Buffer, <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> );
01228 
01229     Page = (PPFN_NUMBER) (MemoryDescriptorList + 1);
01230 
01231     <span class="comment">//</span>
01232     <span class="comment">// Calculate the end of the segment list.</span>
01233     <span class="comment">//</span>
01234 
01235     LastSegment = SegmentArray +
01236                   <a class="code" href="../../d2/d1/mm_8h.html#a5">BYTES_TO_PAGES</a>(MemoryDescriptorList-&gt;ByteCount);
01237 
01238     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(SegmentArray &lt; LastSegment);
01239 
01240     <span class="comment">//</span>
01241     <span class="comment">// Build a small Mdl for each segment and call probe and lock pages.</span>
01242     <span class="comment">// Then copy the PFNs to the real mdl.  The first page is processed</span>
01243     <span class="comment">// outside of the try/finally to ensure that the flags and process</span>
01244     <span class="comment">// field are correctly set in case MmUnlockPages needs to be called.</span>
01245     <span class="comment">//</span>
01246 
01247     <span class="comment">//</span>
01248     <span class="comment">// Even systems without 64 bit pointers are required to zero the</span>
01249     <span class="comment">// upper 32 bits of the segment address so use alignment rather</span>
01250     <span class="comment">// than the buffer pointer.</span>
01251     <span class="comment">//</span>
01252 
01253     SegmentArray += 1;
01254     <a class="code" href="../../d5/d6/iosup_8c.html#a41">MmProbeAndLockPages</a>( TempMdl, AccessMode, Operation );
01255 
01256     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a33">MmTrackLockedPages</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01257 
01258         <span class="comment">//</span>
01259         <span class="comment">// Since we move the page from the temp MDL to the real one below</span>
01260         <span class="comment">// and never free the temp one, fixup our accounting now.</span>
01261         <span class="comment">//</span>
01262 
01263         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/iosup_8c.html#a43">MiFreeMdlTracker</a> (TempMdl, 1) == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01264             NumberOfPagesToLock += 1;
01265         }
01266     }
01267 
01268     *Page++ = *((PPFN_NUMBER) (TempMdl + 1));
01269 
01270     <span class="comment">//</span>
01271     <span class="comment">// Copy the flags and process fields.</span>
01272     <span class="comment">//</span>
01273 
01274     MemoryDescriptorList-&gt;MdlFlags |= TempMdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o2">MdlFlags</a>;
01275     MemoryDescriptorList-&gt;Process = TempMdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o3">Process</a>;
01276 
01277     <span class="keywordflow">try</span> {
01278 
01279         <span class="keywordflow">while</span> (SegmentArray &lt; LastSegment) {
01280 
01281             <span class="comment">//</span>
01282             <span class="comment">// Even systems without 64 bit pointers are required to zero the</span>
01283             <span class="comment">// upper 32 bits of the segment address so use alignment rather</span>
01284             <span class="comment">// than the buffer pointer.</span>
01285             <span class="comment">//</span>
01286 
01287             TempMdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o5">StartVa</a> = (PVOID)(ULONG_PTR)SegmentArray-&gt;Buffer;
01288             TempMdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o2">MdlFlags</a> = 0;
01289 
01290             SegmentArray += 1;
01291             <a class="code" href="../../d5/d6/iosup_8c.html#a41">MmProbeAndLockPages</a>( TempMdl, AccessMode, Operation );
01292 
01293 
01294             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a33">MmTrackLockedPages</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01295 
01296                 <span class="comment">//</span>
01297                 <span class="comment">// Since we move the page from the temp MDL to the real one</span>
01298                 <span class="comment">// below and never free the temp one, fixup our accounting now.</span>
01299                 <span class="comment">//</span>
01300 
01301                 <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/iosup_8c.html#a43">MiFreeMdlTracker</a> (TempMdl, 1) == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01302                     NumberOfPagesToLock += 1;
01303                 }
01304             }
01305 
01306             *Page++ = *((PPFN_NUMBER) (TempMdl + 1));
01307         }
01308     } finally {
01309 
01310         <span class="keywordflow">if</span> (abnormal_termination()) {
01311 
01312             <span class="comment">//</span>
01313             <span class="comment">// Adjust the MDL length so that MmUnlockPages only processes</span>
01314             <span class="comment">// the part that was completed.</span>
01315             <span class="comment">//</span>
01316 
01317             MemoryDescriptorList-&gt;ByteCount =
01318                 (ULONG) (Page - (PPFN_NUMBER) (MemoryDescriptorList + 1)) &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
01319 
01320             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a33">MmTrackLockedPages</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01321 <span class="preprocessor">#if defined (_X86_)</span>
01322 <span class="preprocessor"></span>                <a class="code" href="../../d5/d2/ppc_2getcalr_8c.html#a0">RtlGetCallersAddress</a>(&amp;CallingAddress, &amp;CallersCaller);
01323 <span class="preprocessor">#endif</span>
01324 <span class="preprocessor"></span>                <a class="code" href="../../d5/d6/iosup_8c.html#a32">MiAddMdlTracker</a> (MemoryDescriptorList,
01325                                  CallingAddress,
01326                                  CallersCaller,
01327                                  NumberOfPagesToLock,
01328                                  2);
01329             }
01330 
01331             <a class="code" href="../../d5/d6/iosup_8c.html#a45">MmUnlockPages</a>( MemoryDescriptorList );
01332         }
01333         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a33">MmTrackLockedPages</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01334 <span class="preprocessor">#if defined (_X86_)</span>
01335 <span class="preprocessor"></span>            <a class="code" href="../../d5/d2/ppc_2getcalr_8c.html#a0">RtlGetCallersAddress</a>(&amp;CallingAddress, &amp;CallersCaller);
01336 <span class="preprocessor">#endif</span>
01337 <span class="preprocessor"></span>            <a class="code" href="../../d5/d6/iosup_8c.html#a32">MiAddMdlTracker</a> (MemoryDescriptorList,
01338                              CallingAddress,
01339                              CallersCaller,
01340                              NumberOfPagesToLock,
01341                              3);
01342         }
01343     }
01344 }
01345 
01346 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01347"></a><a class="code" href="../../d5/d6/iosup_8c.html#a45">01347</a> <a class="code" href="../../d5/d6/iosup_8c.html#a45">MmUnlockPages</a> (
01348      IN OUT <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MemoryDescriptorList
01349      )
01350 
01351 <span class="comment">/*++</span>
01352 <span class="comment"></span>
01353 <span class="comment">Routine Description:</span>
01354 <span class="comment"></span>
01355 <span class="comment">    This routine unlocks physical pages which are described by a Memory</span>
01356 <span class="comment">    Descriptor List.</span>
01357 <span class="comment"></span>
01358 <span class="comment">Arguments:</span>
01359 <span class="comment"></span>
01360 <span class="comment">    MemoryDescriptorList - Supplies a pointer to a memory descriptor list</span>
01361 <span class="comment">                            (MDL). The supplied MDL must have been supplied</span>
01362 <span class="comment">                            to MmLockPages to lock the pages down.  As the</span>
01363 <span class="comment">                            pages are unlocked, the MDL is updated.</span>
01364 <span class="comment"></span>
01365 <span class="comment">Return Value:</span>
01366 <span class="comment"></span>
01367 <span class="comment">    None.</span>
01368 <span class="comment"></span>
01369 <span class="comment">Environment:</span>
01370 <span class="comment"></span>
01371 <span class="comment">    Kernel mode, IRQL of DISPATCH_LEVEL or below.</span>
01372 <span class="comment"></span>
01373 <span class="comment">--*/</span>
01374 
01375 {
01376     PFN_NUMBER NumberOfPages;
01377     PPFN_NUMBER Page;
01378     PVOID StartingVa;
01379     KIRQL OldIrql;
01380     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
01381     LOGICAL <a class="code" href="../../d6/d0/usercli_8h.html#a42">Unlock</a>;
01382 
01383     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((MemoryDescriptorList-&gt;MdlFlags &amp; <a class="code" href="../../d0/d9/ntosdef_8h.html#a13">MDL_PAGES_LOCKED</a>) != 0);
01384     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((MemoryDescriptorList-&gt;MdlFlags &amp; <a class="code" href="../../d0/d9/ntosdef_8h.html#a14">MDL_SOURCE_IS_NONPAGED_POOL</a>) == 0);
01385     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((MemoryDescriptorList-&gt;MdlFlags &amp; <a class="code" href="../../d0/d9/ntosdef_8h.html#a16">MDL_PARTIAL</a>) == 0);
01386     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (MemoryDescriptorList-&gt;ByteCount != 0);
01387 
01388     <span class="keywordflow">if</span> (MemoryDescriptorList-&gt;MdlFlags &amp; <a class="code" href="../../d0/d9/ntosdef_8h.html#a12">MDL_MAPPED_TO_SYSTEM_VA</a>) {
01389 
01390         <span class="comment">//</span>
01391         <span class="comment">// This MDL has been mapped into system space, unmap now.</span>
01392         <span class="comment">//</span>
01393 
01394         <a class="code" href="../../d5/d6/iosup_8c.html#a56">MmUnmapLockedPages</a> (MemoryDescriptorList-&gt;MappedSystemVa,
01395                             MemoryDescriptorList);
01396     }
01397 
01398     Page = (PPFN_NUMBER)(MemoryDescriptorList + 1);
01399     <a class="code" href="../../d6/d0/usercli_8h.html#a42">Unlock</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01400     StartingVa = (PVOID)((PCHAR)MemoryDescriptorList-&gt;StartVa +
01401                     MemoryDescriptorList-&gt;ByteOffset);
01402 
01403     NumberOfPages = <a class="code" href="../../d2/d1/mm_8h.html#a8">ADDRESS_AND_SIZE_TO_SPAN_PAGES</a>(StartingVa,
01404                                               MemoryDescriptorList-&gt;ByteCount);
01405 
01406     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a33">MmTrackLockedPages</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01407         <span class="keywordflow">if</span> ((MemoryDescriptorList-&gt;Process != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
01408             (<a class="code" href="../../d6/d0/usercli_8h.html#a42">Unlock</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) &amp;&amp;
01409             ((MemoryDescriptorList-&gt;MdlFlags &amp; <a class="code" href="../../d0/d9/ntosdef_8h.html#a22">MDL_PHYSICAL_VIEW</a>) == 0)) {
01410                 <a class="code" href="../../d5/d6/iosup_8c.html#a43">MiFreeMdlTracker</a> (MemoryDescriptorList, NumberOfPages);
01411         }
01412     }
01413 
01414     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (NumberOfPages != 0);
01415 
01416     <a class="code" href="../../d4/d8/mi_8h.html#a130">LOCK_PFN2</a> (OldIrql);
01417 
01418     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/iosup_8c.html#a13">MmLockedPagesHead</a>.<a class="code" href="../../d5/d2/struct__LOCK__HEADER.html#o0">ListHead</a>.Flink != 0) {
01419 
01420         <a class="code" href="../../d0/d3/struct__LOCK__TRACKER.html">PLOCK_TRACKER</a> P;
01421         PLIST_ENTRY NextEntry;
01422 
01423         NextEntry = <a class="code" href="../../d5/d6/iosup_8c.html#a13">MmLockedPagesHead</a>.<a class="code" href="../../d5/d2/struct__LOCK__HEADER.html#o0">ListHead</a>.Flink;
01424         <span class="keywordflow">while</span> (NextEntry != &amp;<a class="code" href="../../d5/d6/iosup_8c.html#a13">MmLockedPagesHead</a>.<a class="code" href="../../d5/d2/struct__LOCK__HEADER.html#o0">ListHead</a>) {
01425 
01426             P = CONTAINING_RECORD(NextEntry,
01427                                   <a class="code" href="../../d0/d3/struct__LOCK__TRACKER.html">LOCK_TRACKER</a>,
01428                                   GlobalListEntry);
01429 
01430             <span class="keywordflow">if</span> (P-&gt;<a class="code" href="../../d0/d3/struct__LOCK__TRACKER.html#o1">Mdl</a> == MemoryDescriptorList) {
01431                 <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a> (LOCKED_PAGES_TRACKER_CORRUPTION,
01432                               0x4,
01433                               (ULONG_PTR)P,
01434                               (ULONG_PTR)MemoryDescriptorList,
01435                               0);
01436             }
01437 
01438             NextEntry = NextEntry-&gt;Flink;
01439         }
01440     }
01441 
01442     <span class="keywordflow">if</span> ((MemoryDescriptorList-&gt;Process != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
01443         (<a class="code" href="../../d6/d0/usercli_8h.html#a42">Unlock</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) &amp;&amp;
01444         ((MemoryDescriptorList-&gt;MdlFlags &amp; <a class="code" href="../../d0/d9/ntosdef_8h.html#a22">MDL_PHYSICAL_VIEW</a>) == 0)) {
01445 
01446         MemoryDescriptorList-&gt;Process-&gt;NumberOfLockedPages -= NumberOfPages;
01447         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((SPFN_NUMBER)MemoryDescriptorList-&gt;Process-&gt;NumberOfLockedPages &gt;= 0);
01448     }
01449 
01450     <span class="keywordflow">if</span> ((MemoryDescriptorList-&gt;MdlFlags &amp; (<a class="code" href="../../d0/d9/ntosdef_8h.html#a23">MDL_IO_SPACE</a> | <a class="code" href="../../d0/d9/ntosdef_8h.html#a22">MDL_PHYSICAL_VIEW</a>)) == 0) {
01451 
01452         <span class="comment">//</span>
01453         <span class="comment">// Only unlock if not I/O or physical space.</span>
01454         <span class="comment">//</span>
01455 
01456         <span class="keywordflow">do</span> {
01457 
01458             <span class="keywordflow">if</span> (*Page == <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a>) {
01459 
01460                 <span class="comment">//</span>
01461                 <span class="comment">// There are no more locked pages.</span>
01462                 <span class="comment">//</span>
01463 
01464                 <span class="keywordflow">break</span>;
01465             }
01466             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (*Page &lt;= <a class="code" href="../../d6/d8/sysinfo_8c.html#a7">MmHighestPhysicalPage</a>);
01467 
01468             <span class="comment">//</span>
01469             <span class="comment">// If this was a write operation set the modified bit in the</span>
01470             <span class="comment">// PFN database.</span>
01471             <span class="comment">//</span>
01472 
01473             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (*Page);
01474             <span class="keywordflow">if</span> (MemoryDescriptorList-&gt;MdlFlags &amp; <a class="code" href="../../d0/d9/ntosdef_8h.html#a19">MDL_WRITE_OPERATION</a>) {
01475                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.Modified = 1;
01476                 <span class="keywordflow">if</span> ((Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Prototype == 0) &amp;&amp;
01477                              (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.WriteInProgress == 0)) {
01478                     <a class="code" href="../../d4/d8/mi_8h.html#a889">MiReleasePageFileSpace</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>);
01479                     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.PageFileHigh = 0;
01480                 }
01481             }
01482 
01483             <a class="code" href="../../d4/d8/mi_8h.html#a189">MI_REMOVE_LOCKED_PAGE_CHARGE</a>(Pfn1, 1);
01484 
01485             <a class="code" href="../../d6/d5/pfndec_8c.html#a2">MiDecrementReferenceCount</a> (*Page);
01486 
01487             *Page = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a>;
01488             Page += 1;
01489             NumberOfPages -= 1;
01490         } <span class="keywordflow">while</span> (NumberOfPages != 0);
01491     }
01492 
01493     MemoryDescriptorList-&gt;MdlFlags &amp;= ~<a class="code" href="../../d0/d9/ntosdef_8h.html#a13">MDL_PAGES_LOCKED</a>;
01494     <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
01495 
01496     <span class="keywordflow">return</span>;
01497 }
01498 
01499 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01500"></a><a class="code" href="../../d5/d6/iosup_8c.html#a46">01500</a> <a class="code" href="../../d5/d6/iosup_8c.html#a46">MmBuildMdlForNonPagedPool</a> (
01501     IN OUT <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MemoryDescriptorList
01502     )
01503 
01504 <span class="comment">/*++</span>
01505 <span class="comment"></span>
01506 <span class="comment">Routine Description:</span>
01507 <span class="comment"></span>
01508 <span class="comment">    This routine fills in the "pages" portion of the MDL using the PFN</span>
01509 <span class="comment">    numbers corresponding the buffers which resides in non-paged pool.</span>
01510 <span class="comment"></span>
01511 <span class="comment">    Unlike MmProbeAndLockPages, there is no corresponding unlock as no</span>
01512 <span class="comment">    reference counts are incremented as the buffers being in nonpaged</span>
01513 <span class="comment">    pool are always resident.</span>
01514 <span class="comment"></span>
01515 <span class="comment">Arguments:</span>
01516 <span class="comment"></span>
01517 <span class="comment">    MemoryDescriptorList - Supplies a pointer to a Memory Descriptor List</span>
01518 <span class="comment">                            (MDL). The supplied MDL must supply a virtual</span>
01519 <span class="comment">                            address, byte offset and length field.  The</span>
01520 <span class="comment">                            physical page portion of the MDL is updated when</span>
01521 <span class="comment">                            the pages are locked in memory.  The virtual</span>
01522 <span class="comment">                            address must be within the non-paged portion</span>
01523 <span class="comment">                            of the system space.</span>
01524 <span class="comment"></span>
01525 <span class="comment">Return Value:</span>
01526 <span class="comment"></span>
01527 <span class="comment">    None.</span>
01528 <span class="comment"></span>
01529 <span class="comment">Environment:</span>
01530 <span class="comment"></span>
01531 <span class="comment">    Kernel mode, IRQL of DISPATCH_LEVEL or below.</span>
01532 <span class="comment"></span>
01533 <span class="comment">--*/</span>
01534 
01535 {
01536     PPFN_NUMBER Page;
01537     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
01538     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> LastPte;
01539     PVOID EndVa;
01540     PFN_NUMBER PageFrameIndex;
01541 
01542     Page = (PPFN_NUMBER)(MemoryDescriptorList + 1);
01543 
01544     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (MemoryDescriptorList-&gt;ByteCount != 0);
01545     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((MemoryDescriptorList-&gt;MdlFlags &amp; (
01546                     <a class="code" href="../../d0/d9/ntosdef_8h.html#a13">MDL_PAGES_LOCKED</a> |
01547                     <a class="code" href="../../d0/d9/ntosdef_8h.html#a12">MDL_MAPPED_TO_SYSTEM_VA</a> |
01548                     <a class="code" href="../../d0/d9/ntosdef_8h.html#a14">MDL_SOURCE_IS_NONPAGED_POOL</a> |
01549                     <a class="code" href="../../d0/d9/ntosdef_8h.html#a16">MDL_PARTIAL</a>)) == 0);
01550 
01551     MemoryDescriptorList-&gt;Process = (<a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a>)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01552 
01553     <span class="comment">//</span>
01554     <span class="comment">// Endva is last byte of the buffer.</span>
01555     <span class="comment">//</span>
01556 
01557     MemoryDescriptorList-&gt;MdlFlags |= <a class="code" href="../../d0/d9/ntosdef_8h.html#a14">MDL_SOURCE_IS_NONPAGED_POOL</a>;
01558 
01559     MemoryDescriptorList-&gt;MappedSystemVa =
01560             (PVOID)((PCHAR)MemoryDescriptorList-&gt;StartVa +
01561                                            MemoryDescriptorList-&gt;ByteOffset);
01562 
01563     EndVa = (PVOID)(((PCHAR)MemoryDescriptorList-&gt;MappedSystemVa +
01564                             MemoryDescriptorList-&gt;ByteCount - 1));
01565 
01566     LastPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (EndVa);
01567 
01568     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d2/d1/mm_8h.html#a303">MmIsNonPagedSystemAddressValid</a> (MemoryDescriptorList-&gt;StartVa));
01569 
01570     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (MemoryDescriptorList-&gt;StartVa);
01571 
01572     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a>(EndVa)) {
01573         PageFrameIndex = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a179">MI_CONVERT_PHYSICAL_TO_PFN</a> (
01574                                 MemoryDescriptorList-&gt;StartVa);
01575 
01576         <span class="keywordflow">do</span> {
01577             *Page = PageFrameIndex;
01578             Page += 1;
01579             PageFrameIndex += 1;
01580             PointerPte += 1;
01581         } <span class="keywordflow">while</span> (PointerPte &lt;= LastPte);
01582     } <span class="keywordflow">else</span> {
01583         <span class="keywordflow">do</span> {
01584             PageFrameIndex = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a> (PointerPte);
01585             *Page = PageFrameIndex;
01586             Page += 1;
01587             PointerPte += 1;
01588         } <span class="keywordflow">while</span> (PointerPte &lt;= LastPte);
01589     }
01590 
01591     <span class="keywordflow">return</span>;
01592 }
01593 
01594 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01595"></a><a class="code" href="../../d4/d8/mi_8h.html#a817">01595</a> <a class="code" href="../../d4/d8/mi_8h.html#a817">MiInitializeIoTrackers</a> (
01596     VOID
01597     )
01598 {
01599     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a37">MmTrackPtes</a> != 0) {
01600         InitializeListHead (&amp;<a class="code" href="../../d5/d6/iosup_8c.html#a11">MiDeadPteTrackerListHead</a>);
01601         <a class="code" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock</a> (&amp;<a class="code" href="../../d5/d6/iosup_8c.html#a12">MiPteTrackerLock</a>);
01602         InitializeListHead (&amp;<a class="code" href="../../d5/d6/iosup_8c.html#a10">MiPteHeader</a>.<a class="code" href="../../d9/d7/struct__SYSPTES__HEADER.html#o0">ListHead</a>);
01603     }
01604 
01605     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a33">MmTrackLockedPages</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01606         InitializeListHead (&amp;<a class="code" href="../../d5/d6/iosup_8c.html#a13">MmLockedPagesHead</a>.<a class="code" href="../../d5/d2/struct__LOCK__HEADER.html#o0">ListHead</a>);
01607     }
01608 }
01609 
01610 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01611"></a><a class="code" href="../../d5/d6/iosup_8c.html#a33">01611</a> <a class="code" href="../../d5/d6/iosup_8c.html#a33">MiInsertPteTracker</a> (
01612      IN PVOID PoolBlock,
01613      IN <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MemoryDescriptorList,
01614      IN PFN_NUMBER NumberOfPtes,
01615      IN PVOID MyCaller,
01616      IN PVOID MyCallersCaller
01617      )
01618 <span class="comment">/*++</span>
01619 <span class="comment"></span>
01620 <span class="comment">Routine Description:</span>
01621 <span class="comment"></span>
01622 <span class="comment">    This function inserts a PTE tracking block as the caller has just</span>
01623 <span class="comment">    consumed system PTEs.</span>
01624 <span class="comment"></span>
01625 <span class="comment">Arguments:</span>
01626 <span class="comment"></span>
01627 <span class="comment">    PoolBlock - Supplies a tracker pool block.  This is supplied by the caller</span>
01628 <span class="comment">                since the MmSystemSpaceLock is held on entry hence pool</span>
01629 <span class="comment">                allocations may not be done here.</span>
01630 <span class="comment"></span>
01631 <span class="comment">    MemoryDescriptorList - Supplies a valid Memory Descriptor List.</span>
01632 <span class="comment"></span>
01633 <span class="comment">    NumberOfPtes - Supplies the number of system PTEs allocated.</span>
01634 <span class="comment"></span>
01635 <span class="comment">    MyCaller - Supplies the return address of the caller who consumed the</span>
01636 <span class="comment">               system PTEs to map this MDL.</span>
01637 <span class="comment"></span>
01638 <span class="comment">    MyCallersCaller - Supplies the return address of the caller of the caller</span>
01639 <span class="comment">                      who consumed the system PTEs to map this MDL.</span>
01640 <span class="comment"></span>
01641 <span class="comment">Return Value:</span>
01642 <span class="comment"></span>
01643 <span class="comment">    None.</span>
01644 <span class="comment"></span>
01645 <span class="comment">Environment:</span>
01646 <span class="comment"></span>
01647 <span class="comment">    Kernel mode, protected by MmSystemSpaceLock at DISPATCH_LEVEL.</span>
01648 <span class="comment"></span>
01649 <span class="comment">--*/</span>
01650 
01651 {
01652     <a class="code" href="../../d5/d6/iosup_8c.html#a5">PPTE_TRACKER</a> Tracker;
01653 
01654     Tracker = (<a class="code" href="../../d5/d6/iosup_8c.html#a5">PPTE_TRACKER</a>)PoolBlock;
01655 
01656     Tracker-&gt;<a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o1">Mdl</a> = MemoryDescriptorList;
01657     Tracker-&gt;<a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o3">SystemVa</a> = MemoryDescriptorList-&gt;MappedSystemVa;
01658     Tracker-&gt;<a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o2">Count</a> = NumberOfPtes;
01659 
01660     Tracker-&gt;<a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o4">StartVa</a> = MemoryDescriptorList-&gt;StartVa;
01661     Tracker-&gt;<a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o5">Offset</a> = MemoryDescriptorList-&gt;ByteOffset;
01662     Tracker-&gt;<a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o6">Length</a> = MemoryDescriptorList-&gt;ByteCount;
01663     Tracker-&gt;<a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o7">Page</a> = *(PPFN_NUMBER)(MemoryDescriptorList + 1);
01664 
01665     Tracker-&gt;<a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o8">CallingAddress</a> = MyCaller;
01666     Tracker-&gt;<a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o9">CallersCaller</a> = MyCallersCaller;
01667     Tracker-&gt;<a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o10">PteAddress</a> = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (Tracker-&gt;<a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o3">SystemVa</a>);
01668 
01669     <a class="code" href="../../d5/d6/iosup_8c.html#a10">MiPteHeader</a>.<a class="code" href="../../d9/d7/struct__SYSPTES__HEADER.html#o1">Count</a> += NumberOfPtes;
01670 
01671     InsertHeadList (&amp;<a class="code" href="../../d5/d6/iosup_8c.html#a10">MiPteHeader</a>.<a class="code" href="../../d9/d7/struct__SYSPTES__HEADER.html#o0">ListHead</a>, &amp;Tracker-&gt;<a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o0">ListEntry</a>);
01672 }
01673 
01674 PVOID
<a name="l01675"></a><a class="code" href="../../d5/d6/iosup_8c.html#a34">01675</a> <a class="code" href="../../d5/d6/iosup_8c.html#a34">MiRemovePteTracker</a> (
01676      IN <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MemoryDescriptorList OPTIONAL,
01677      IN PVOID PteAddress,
01678      IN PFN_NUMBER NumberOfPtes
01679      )
01680 
01681 <span class="comment">/*++</span>
01682 <span class="comment"></span>
01683 <span class="comment">Routine Description:</span>
01684 <span class="comment"></span>
01685 <span class="comment">    This function removes a PTE tracking block from the lists as the PTEs</span>
01686 <span class="comment">    are being freed.</span>
01687 <span class="comment"></span>
01688 <span class="comment">Arguments:</span>
01689 <span class="comment"></span>
01690 <span class="comment">    MemoryDescriptorList - Supplies a valid Memory Descriptor List.</span>
01691 <span class="comment"></span>
01692 <span class="comment">    PteAddress - Supplies the address the system PTEs were mapped to.</span>
01693 <span class="comment"></span>
01694 <span class="comment">    NumberOfPtes - Supplies the number of system PTEs allocated.</span>
01695 <span class="comment"></span>
01696 <span class="comment">Return Value:</span>
01697 <span class="comment"></span>
01698 <span class="comment">    The pool block that held the tracking info that must be freed by our</span>
01699 <span class="comment">    caller _AFTER_ our caller releases MmSystemSpaceLock (to prevent deadlock).</span>
01700 <span class="comment"></span>
01701 <span class="comment">Environment:</span>
01702 <span class="comment"></span>
01703 <span class="comment">    Kernel mode, protected by MmSystemSpaceLock at DISPATCH_LEVEL.</span>
01704 <span class="comment"></span>
01705 <span class="comment">--*/</span>
01706 
01707 {
01708     <a class="code" href="../../d5/d6/iosup_8c.html#a5">PPTE_TRACKER</a> Tracker;
01709     PFN_NUMBER Page;
01710     PVOID BaseAddress;
01711     PLIST_ENTRY LastFound;
01712     PLIST_ENTRY NextEntry;
01713 
01714     BaseAddress = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PteAddress);
01715 
01716     <span class="keywordflow">if</span> (ARGUMENT_PRESENT (MemoryDescriptorList)) {
01717         Page = *(PPFN_NUMBER)(MemoryDescriptorList + 1);
01718     }
01719 
01720     LastFound = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01721     NextEntry = <a class="code" href="../../d5/d6/iosup_8c.html#a10">MiPteHeader</a>.<a class="code" href="../../d9/d7/struct__SYSPTES__HEADER.html#o0">ListHead</a>.Flink;
01722     <span class="keywordflow">while</span> (NextEntry != &amp;<a class="code" href="../../d5/d6/iosup_8c.html#a10">MiPteHeader</a>.<a class="code" href="../../d9/d7/struct__SYSPTES__HEADER.html#o0">ListHead</a>) {
01723 
01724         Tracker = (<a class="code" href="../../d5/d6/iosup_8c.html#a5">PPTE_TRACKER</a>) CONTAINING_RECORD (NextEntry,
01725                                                     <a class="code" href="../../d7/d1/struct__PTE__TRACKER.html">PTE_TRACKER</a>,
01726                                                     ListEntry.Flink);
01727 
01728         <span class="keywordflow">if</span> (PteAddress == Tracker-&gt;<a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o10">PteAddress</a>) {
01729 
01730             <span class="keywordflow">if</span> (LastFound != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01731 
01732                 <span class="comment">//</span>
01733                 <span class="comment">// Duplicate map entry.</span>
01734                 <span class="comment">//</span>
01735 
01736                 <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a> (SYSTEM_PTE_MISUSE,
01737                               0x1,
01738                               (ULONG_PTR)Tracker,
01739                               (ULONG_PTR)MemoryDescriptorList,
01740                               (ULONG_PTR)LastFound);
01741             }
01742 
01743             <span class="keywordflow">if</span> (Tracker-&gt;<a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o2">Count</a> != NumberOfPtes) {
01744 
01745                 <span class="comment">//</span>
01746                 <span class="comment">// Not unmapping the same of number of PTEs that were mapped.</span>
01747                 <span class="comment">//</span>
01748 
01749                 <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a> (SYSTEM_PTE_MISUSE,
01750                               0x2,
01751                               (ULONG_PTR)Tracker,
01752                               Tracker-&gt;<a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o2">Count</a>,
01753                               NumberOfPtes);
01754             }
01755 
01756             <span class="keywordflow">if</span> (ARGUMENT_PRESENT (MemoryDescriptorList)) {
01757 
01758                 <span class="keywordflow">if</span> (Tracker-&gt;<a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o3">SystemVa</a> != MemoryDescriptorList-&gt;MappedSystemVa) {
01759 
01760                     <span class="comment">//</span>
01761                     <span class="comment">// Not unmapping the same address that was mapped.</span>
01762                     <span class="comment">//</span>
01763 
01764                     <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a> (SYSTEM_PTE_MISUSE,
01765                                   0x3,
01766                                   (ULONG_PTR)Tracker,
01767                                   (ULONG_PTR)Tracker-&gt;<a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o3">SystemVa</a>,
01768                                   (ULONG_PTR)MemoryDescriptorList-&gt;MappedSystemVa);
01769                 }
01770 
01771                 <span class="keywordflow">if</span> (Tracker-&gt;<a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o7">Page</a> != Page) {
01772 
01773                     <span class="comment">//</span>
01774                     <span class="comment">// The first page in the MDL has changed since it was mapped.</span>
01775                     <span class="comment">//</span>
01776 
01777                     <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a> (SYSTEM_PTE_MISUSE,
01778                                   0x4,
01779                                   (ULONG_PTR)Tracker,
01780                                   (ULONG_PTR)Tracker-&gt;<a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o7">Page</a>,
01781                                   (ULONG_PTR)Page);
01782                 }
01783 
01784                 <span class="keywordflow">if</span> (Tracker-&gt;<a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o4">StartVa</a> != MemoryDescriptorList-&gt;StartVa) {
01785 
01786                     <span class="comment">//</span>
01787                     <span class="comment">// Map and unmap don't match up.</span>
01788                     <span class="comment">//</span>
01789 
01790                     <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a> (SYSTEM_PTE_MISUSE,
01791                                   0x5,
01792                                   (ULONG_PTR)Tracker,
01793                                   (ULONG_PTR)Tracker-&gt;<a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o4">StartVa</a>,
01794                                   (ULONG_PTR)MemoryDescriptorList-&gt;StartVa);
01795                 }
01796             }
01797 
01798             RemoveEntryList (NextEntry);
01799             LastFound = NextEntry;
01800         }
01801         NextEntry = Tracker-&gt;<a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o0">ListEntry</a>.Flink;
01802     }
01803 
01804     <span class="keywordflow">if</span> ((LastFound == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp; (<a class="code" href="../../d5/d6/iosup_8c.html#a9">MiTrackPtesAborted</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
01805 
01806         <span class="comment">//</span>
01807         <span class="comment">// Can't unmap something that was never (or isn't currently) mapped.</span>
01808         <span class="comment">//</span>
01809 
01810         <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a> (SYSTEM_PTE_MISUSE,
01811                       0x6,
01812                       (ULONG_PTR)MemoryDescriptorList,
01813                       (ULONG_PTR)BaseAddress,
01814                       (ULONG_PTR)NumberOfPtes);
01815     }
01816 
01817     <a class="code" href="../../d5/d6/iosup_8c.html#a10">MiPteHeader</a>.<a class="code" href="../../d9/d7/struct__SYSPTES__HEADER.html#o1">Count</a> -= NumberOfPtes;
01818 
01819     <span class="keywordflow">return</span> (PVOID)LastFound;
01820 }
01821 
01822 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01823"></a><a class="code" href="../../d5/d6/iosup_8c.html#a36">01823</a> <a class="code" href="../../d5/d6/iosup_8c.html#a36">MiInsertDeadPteTrackingBlock</a> (
01824     IN PVOID PoolBlock
01825     )
01826 
01827 <span class="comment">/*++</span>
01828 <span class="comment"></span>
01829 <span class="comment">Routine Description:</span>
01830 <span class="comment"></span>
01831 <span class="comment">    This routine inserts a tracking block into the dead PTE list for later</span>
01832 <span class="comment">    release.  Locks (including the PFN lock) may be held on entry, thus the</span>
01833 <span class="comment">    block cannot be directly freed to pool at this time.</span>
01834 <span class="comment"></span>
01835 <span class="comment">Arguments:</span>
01836 <span class="comment"></span>
01837 <span class="comment">    PoolBlock - Supplies the base pool address to free.</span>
01838 <span class="comment"></span>
01839 <span class="comment">Return Value:</span>
01840 <span class="comment"></span>
01841 <span class="comment">    None.</span>
01842 <span class="comment"></span>
01843 <span class="comment">Environment:</span>
01844 <span class="comment"></span>
01845 <span class="comment">    Kernel mode.  DISPATCH_LEVEL or below, locks may be held.</span>
01846 <span class="comment"></span>
01847 <span class="comment">--*/</span>
01848 {
01849     KIRQL OldIrql;
01850 
01851     ExAcquireSpinLock (&amp;<a class="code" href="../../d5/d6/iosup_8c.html#a12">MiPteTrackerLock</a>, &amp;OldIrql);
01852 
01853     InsertTailList (&amp;<a class="code" href="../../d5/d6/iosup_8c.html#a11">MiDeadPteTrackerListHead</a>, (PLIST_ENTRY)PoolBlock);
01854 
01855     ExReleaseSpinLock (&amp;<a class="code" href="../../d5/d6/iosup_8c.html#a12">MiPteTrackerLock</a>, OldIrql);
01856 }
01857 
01858 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01859"></a><a class="code" href="../../d5/d6/iosup_8c.html#a35">01859</a> <a class="code" href="../../d5/d6/iosup_8c.html#a35">MiReleaseDeadPteTrackers</a> (
01860     VOID
01861     )
01862 <span class="comment">/*++</span>
01863 <span class="comment"></span>
01864 <span class="comment">Routine Description:</span>
01865 <span class="comment"></span>
01866 <span class="comment">    This routine removes tracking blocks from the dead PTE list and frees</span>
01867 <span class="comment">    them to pool.</span>
01868 <span class="comment"></span>
01869 <span class="comment">Arguments:</span>
01870 <span class="comment"></span>
01871 <span class="comment">    None.</span>
01872 <span class="comment"></span>
01873 <span class="comment">Return Value:</span>
01874 <span class="comment"></span>
01875 <span class="comment">    None.</span>
01876 <span class="comment"></span>
01877 <span class="comment">Environment:</span>
01878 <span class="comment"></span>
01879 <span class="comment">    Kernel mode.  No locks held.</span>
01880 <span class="comment"></span>
01881 <span class="comment">--*/</span>
01882 {
01883     KIRQL OldIrql;
01884     PVOID PoolBlock;
01885 
01886     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (KeGetCurrentIrql() &lt;= <a class="code" href="../../d6/d7/halmips_8h.html#a53">DISPATCH_LEVEL</a>);
01887 
01888     ExAcquireSpinLock (&amp;<a class="code" href="../../d5/d6/iosup_8c.html#a12">MiPteTrackerLock</a>, &amp;OldIrql);
01889 
01890     <span class="keywordflow">while</span> (IsListEmpty(&amp;<a class="code" href="../../d5/d6/iosup_8c.html#a11">MiDeadPteTrackerListHead</a>) == 0) {
01891         PoolBlock = (PVOID)RemoveHeadList(&amp;<a class="code" href="../../d5/d6/iosup_8c.html#a11">MiDeadPteTrackerListHead</a>);
01892         ExReleaseSpinLock (&amp;<a class="code" href="../../d5/d6/iosup_8c.html#a12">MiPteTrackerLock</a>, OldIrql);
01893         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (PoolBlock);
01894         ExAcquireSpinLock (&amp;<a class="code" href="../../d5/d6/iosup_8c.html#a12">MiPteTrackerLock</a>, &amp;OldIrql);
01895     }
01896 
01897     ExReleaseSpinLock (&amp;<a class="code" href="../../d5/d6/iosup_8c.html#a12">MiPteTrackerLock</a>, OldIrql);
01898 }
01899 
01900 PVOID
<a name="l01901"></a><a class="code" href="../../d0/d9/sysptes_8c.html#a24">01901</a> <a class="code" href="../../d0/d9/sysptes_8c.html#a24">MiGetHighestPteConsumer</a> (
01902     OUT PULONG_PTR NumberOfPtes
01903     )
01904 
01905 <span class="comment">/*++</span>
01906 <span class="comment"></span>
01907 <span class="comment">Routine Description:</span>
01908 <span class="comment"></span>
01909 <span class="comment">    This function examines the PTE tracking blocks and returns the biggest</span>
01910 <span class="comment">    consumer.</span>
01911 <span class="comment"></span>
01912 <span class="comment">Arguments:</span>
01913 <span class="comment"></span>
01914 <span class="comment">    None.</span>
01915 <span class="comment"></span>
01916 <span class="comment">Return Value:</span>
01917 <span class="comment"></span>
01918 <span class="comment">    The loaded module entry of the biggest consumer.</span>
01919 <span class="comment"></span>
01920 <span class="comment">Environment:</span>
01921 <span class="comment"></span>
01922 <span class="comment">    Kernel mode, called during bugcheck only.  Many locks may be held.</span>
01923 <span class="comment"></span>
01924 <span class="comment">--*/</span>
01925 
01926 {
01927     <a class="code" href="../../d5/d6/iosup_8c.html#a5">PPTE_TRACKER</a> Tracker;
01928     PVOID BaseAddress;
01929     PFN_NUMBER NumberOfPages;
01930     PLIST_ENTRY NextEntry;
01931     PLIST_ENTRY NextEntry2;
01932     PLDR_DATA_TABLE_ENTRY DataTableEntry;
01933     ULONG_PTR Highest;
01934     ULONG_PTR PagesByThisModule;
01935     PLDR_DATA_TABLE_ENTRY HighDataTableEntry;
01936 
01937     *NumberOfPtes = 0;
01938 
01939     <span class="comment">//</span>
01940     <span class="comment">// No locks are acquired as this is only called during a bugcheck.</span>
01941     <span class="comment">//</span>
01942 
01943     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a37">MmTrackPtes</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01944         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01945     }
01946 
01947     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/iosup_8c.html#a9">MiTrackPtesAborted</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01948         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01949     }
01950 
01951     <span class="keywordflow">if</span> (IsListEmpty(&amp;<a class="code" href="../../d5/d6/iosup_8c.html#a10">MiPteHeader</a>.<a class="code" href="../../d9/d7/struct__SYSPTES__HEADER.html#o0">ListHead</a>)) {
01952         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01953     }
01954 
01955     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d9/ps_8h.html#a56">PsLoadedModuleList</a>.Flink == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01956         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01957     }
01958 
01959     Highest = 0;
01960     HighDataTableEntry = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01961 
01962     NextEntry = <a class="code" href="../../d1/d9/ps_8h.html#a56">PsLoadedModuleList</a>.Flink;
01963     <span class="keywordflow">while</span> (NextEntry != &amp;<a class="code" href="../../d1/d9/ps_8h.html#a56">PsLoadedModuleList</a>) {
01964 
01965         DataTableEntry = CONTAINING_RECORD(NextEntry,
01966                                            LDR_DATA_TABLE_ENTRY,
01967                                            InLoadOrderLinks);
01968 
01969         PagesByThisModule = 0;
01970 
01971         <span class="comment">//</span>
01972         <span class="comment">// Walk the PTE mapping list and update each driver's counts.</span>
01973         <span class="comment">//</span>
01974     
01975         NextEntry2 = <a class="code" href="../../d5/d6/iosup_8c.html#a10">MiPteHeader</a>.<a class="code" href="../../d9/d7/struct__SYSPTES__HEADER.html#o0">ListHead</a>.Flink;
01976         <span class="keywordflow">while</span> (NextEntry2 != &amp;<a class="code" href="../../d5/d6/iosup_8c.html#a10">MiPteHeader</a>.<a class="code" href="../../d9/d7/struct__SYSPTES__HEADER.html#o0">ListHead</a>) {
01977     
01978             Tracker = (<a class="code" href="../../d5/d6/iosup_8c.html#a5">PPTE_TRACKER</a>) CONTAINING_RECORD (NextEntry2,
01979                                                         <a class="code" href="../../d7/d1/struct__PTE__TRACKER.html">PTE_TRACKER</a>,
01980                                                         ListEntry.Flink);
01981     
01982             BaseAddress = Tracker-&gt;<a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o8">CallingAddress</a>;
01983             NumberOfPages = Tracker-&gt;<a class="code" href="../../d7/d1/struct__PTE__TRACKER.html#o2">Count</a>;
01984     
01985             <span class="keywordflow">if</span> ((BaseAddress &gt;= DataTableEntry-&gt;DllBase) &amp;&amp;
01986                 (BaseAddress &lt; (PVOID)((ULONG_PTR)(DataTableEntry-&gt;DllBase) + DataTableEntry-&gt;SizeOfImage))) {
01987 
01988                 PagesByThisModule += NumberOfPages;
01989             }
01990         
01991             NextEntry2 = NextEntry2-&gt;Flink;
01992     
01993         }
01994     
01995         <span class="keywordflow">if</span> (PagesByThisModule &gt; Highest) {
01996             Highest = PagesByThisModule;
01997             HighDataTableEntry = DataTableEntry;
01998         }
01999 
02000         NextEntry = NextEntry-&gt;Flink;
02001     }
02002 
02003     *NumberOfPtes = Highest;
02004 
02005     <span class="keywordflow">return</span> (PVOID)HighDataTableEntry;
02006 }
02007 
02008 PVOID
<a name="l02009"></a><a class="code" href="../../d5/d6/iosup_8c.html#a49">02009</a> <a class="code" href="../../d5/d6/iosup_8c.html#a49">MmMapLockedPages</a> (
02010      IN <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MemoryDescriptorList,
02011      IN KPROCESSOR_MODE AccessMode
02012      )
02013 
02014 <span class="comment">/*++</span>
02015 <span class="comment"></span>
02016 <span class="comment">Routine Description:</span>
02017 <span class="comment"></span>
02018 <span class="comment">    This function maps physical pages described by a memory descriptor</span>
02019 <span class="comment">    list into the system virtual address space or the user portion of</span>
02020 <span class="comment">    the virtual address space.</span>
02021 <span class="comment"></span>
02022 <span class="comment">Arguments:</span>
02023 <span class="comment"></span>
02024 <span class="comment">    MemoryDescriptorList - Supplies a valid Memory Descriptor List which has</span>
02025 <span class="comment">                            been updated by MmProbeAndLockPages.</span>
02026 <span class="comment"></span>
02027 <span class="comment"></span>
02028 <span class="comment">    AccessMode - Supplies an indicator of where to map the pages;</span>
02029 <span class="comment">                 KernelMode indicates that the pages should be mapped in the</span>
02030 <span class="comment">                 system part of the address space, UserMode indicates the</span>
02031 <span class="comment">                 pages should be mapped in the user part of the address space.</span>
02032 <span class="comment"></span>
02033 <span class="comment">Return Value:</span>
02034 <span class="comment"></span>
02035 <span class="comment">    Returns the base address where the pages are mapped.  The base address</span>
02036 <span class="comment">    has the same offset as the virtual address in the MDL.</span>
02037 <span class="comment"></span>
02038 <span class="comment">    This routine will raise an exception if the processor mode is USER_MODE</span>
02039 <span class="comment">    and quota limits or VM limits are exceeded.</span>
02040 <span class="comment"></span>
02041 <span class="comment">Environment:</span>
02042 <span class="comment"></span>
02043 <span class="comment">    Kernel mode.  DISPATCH_LEVEL or below if access mode is KernelMode,</span>
02044 <span class="comment">                  APC_LEVEL or below if access mode is UserMode.</span>
02045 <span class="comment"></span>
02046 <span class="comment">--*/</span>
02047 
02048 {
02049     <span class="keywordflow">return</span> <a class="code" href="../../d5/d6/iosup_8c.html#a50">MmMapLockedPagesSpecifyCache</a> (MemoryDescriptorList,
02050                                          AccessMode,
02051                                          <a class="code" href="../../d4/d9/ke_8h.html#a413a249">MmCached</a>,
02052                                          <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
02053                                          <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
02054                                          <a class="code" href="../../d2/d1/mm_8h.html#a347a183">HighPagePriority</a>);
02055 }
02056 
02057 PVOID
<a name="l02058"></a><a class="code" href="../../d5/d6/iosup_8c.html#a50">02058</a> <a class="code" href="../../d5/d6/iosup_8c.html#a50">MmMapLockedPagesSpecifyCache</a> (
02059      IN <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MemoryDescriptorList,
02060      IN KPROCESSOR_MODE AccessMode,
02061      IN MEMORY_CACHING_TYPE CacheType,
02062      IN PVOID RequestedAddress,
02063      IN ULONG BugCheckOnFailure,
02064      IN MM_PAGE_PRIORITY Priority
02065      )
02066 
02067 <span class="comment">/*++</span>
02068 <span class="comment"></span>
02069 <span class="comment">Routine Description:</span>
02070 <span class="comment"></span>
02071 <span class="comment">    This function maps physical pages described by a memory descriptor</span>
02072 <span class="comment">    list into the system virtual address space or the user portion of</span>
02073 <span class="comment">    the virtual address space.</span>
02074 <span class="comment"></span>
02075 <span class="comment">Arguments:</span>
02076 <span class="comment"></span>
02077 <span class="comment">    MemoryDescriptorList - Supplies a valid Memory Descriptor List which has</span>
02078 <span class="comment">                           been updated by MmProbeAndLockPages.</span>
02079 <span class="comment"></span>
02080 <span class="comment">    AccessMode - Supplies an indicator of where to map the pages;</span>
02081 <span class="comment">                 KernelMode indicates that the pages should be mapped in the</span>
02082 <span class="comment">                 system part of the address space, UserMode indicates the</span>
02083 <span class="comment">                 pages should be mapped in the user part of the address space.</span>
02084 <span class="comment"></span>
02085 <span class="comment">    CacheType - Supplies the type of cache mapping to use for the MDL.</span>
02086 <span class="comment">                MmCached indicates "normal" kernel or user mappings.</span>
02087 <span class="comment"></span>
02088 <span class="comment">    RequestedAddress - Supplies the base user address of the view. This is only</span>
02089 <span class="comment">                       used if the AccessMode is UserMode.  If the initial</span>
02090 <span class="comment">                       value of this argument is not null, then the view will</span>
02091 <span class="comment">                       be allocated starting at the specified virtual</span>
02092 <span class="comment">                       address rounded down to the next 64kb address</span>
02093 <span class="comment">                       boundary. If the initial value of this argument is</span>
02094 <span class="comment">                       null, then the operating system will determine</span>
02095 <span class="comment">                       where to allocate the view.</span>
02096 <span class="comment"></span>
02097 <span class="comment">    BugCheckOnFailure - Supplies whether to bugcheck if the mapping cannot be</span>
02098 <span class="comment">                        obtained.  This flag is only checked if the MDL's</span>
02099 <span class="comment">                        MDL_MAPPING_CAN_FAIL is zero, which implies that the</span>
02100 <span class="comment">                        default MDL behavior is to bugcheck.  This flag then</span>
02101 <span class="comment">                        provides an additional avenue to avoid the bugcheck.</span>
02102 <span class="comment">                        Done this way in order to provide WDM compatibility.</span>
02103 <span class="comment"></span>
02104 <span class="comment">    Priority - Supplies an indication as to how important it is that this</span>
02105 <span class="comment">               request succeed under low available PTE conditions.</span>
02106 <span class="comment"></span>
02107 <span class="comment">Return Value:</span>
02108 <span class="comment"></span>
02109 <span class="comment">    Returns the base address where the pages are mapped.  The base address</span>
02110 <span class="comment">    has the same offset as the virtual address in the MDL.</span>
02111 <span class="comment"></span>
02112 <span class="comment">    This routine will raise an exception if the processor mode is USER_MODE</span>
02113 <span class="comment">    and quota limits or VM limits are exceeded.</span>
02114 <span class="comment"></span>
02115 <span class="comment">Environment:</span>
02116 <span class="comment"></span>
02117 <span class="comment">    Kernel mode.  DISPATCH_LEVEL or below if access mode is KernelMode,</span>
02118 <span class="comment">                  APC_LEVEL or below if access mode is UserMode.</span>
02119 <span class="comment"></span>
02120 <span class="comment">--*/</span>
02121 
02122 {
02123     PFN_NUMBER NumberOfPages;
02124     PFN_NUMBER SavedPageCount;
02125     PPFN_NUMBER Page;
02126     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
02127     PVOID BaseVa;
02128     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> TempPte;
02129     PVOID StartingVa;
02130     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn2;
02131     KIRQL OldIrql;
02132     PFN_NUMBER NumberOfPtes;
02133     PVOID CallingAddress;
02134     PVOID CallersCaller;
02135     PVOID Tracker;
02136 
02137 <span class="preprocessor">#if !defined (_X86_)</span>
02138 <span class="preprocessor"></span>    CallingAddress = (PVOID)_ReturnAddress();
02139     CallersCaller = (PVOID)0;
02140 <span class="preprocessor">#endif</span>
02141 <span class="preprocessor"></span>
02142     StartingVa = (PVOID)((PCHAR)MemoryDescriptorList-&gt;StartVa +
02143                     MemoryDescriptorList-&gt;ByteOffset);
02144 
02145     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (MemoryDescriptorList-&gt;ByteCount != 0);
02146 
02147     <span class="keywordflow">if</span> (AccessMode == <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
02148 
02149         Page = (PPFN_NUMBER)(MemoryDescriptorList + 1);
02150         NumberOfPages = <a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a> (StartingVa,
02151                                                MemoryDescriptorList-&gt;ByteCount);
02152         SavedPageCount = NumberOfPages;
02153 
02154         <span class="comment">//</span>
02155         <span class="comment">// Map the pages into the system part of the address space as</span>
02156         <span class="comment">// kernel read/write.</span>
02157         <span class="comment">//</span>
02158 
02159         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((MemoryDescriptorList-&gt;MdlFlags &amp; (
02160                         <a class="code" href="../../d0/d9/ntosdef_8h.html#a12">MDL_MAPPED_TO_SYSTEM_VA</a> |
02161                         <a class="code" href="../../d0/d9/ntosdef_8h.html#a14">MDL_SOURCE_IS_NONPAGED_POOL</a> |
02162                         <a class="code" href="../../d0/d9/ntosdef_8h.html#a17">MDL_PARTIAL_HAS_BEEN_MAPPED</a>)) == 0);
02163         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((MemoryDescriptorList-&gt;MdlFlags &amp; (
02164                         <a class="code" href="../../d0/d9/ntosdef_8h.html#a13">MDL_PAGES_LOCKED</a> |
02165                         <a class="code" href="../../d0/d9/ntosdef_8h.html#a16">MDL_PARTIAL</a>)) != 0);
02166 
02167         <span class="comment">//</span>
02168         <span class="comment">// Map this with KSEG0 if possible.</span>
02169         <span class="comment">//</span>
02170 
02171 <span class="preprocessor">#if defined(_ALPHA_)</span>
02172 <span class="preprocessor"></span><span class="preprocessor">#define KSEG0_MAXPAGE ((PFN_NUMBER)((KSEG2_BASE - KSEG0_BASE) &gt;&gt; PAGE_SHIFT))</span>
02173 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
02174 <span class="preprocessor"></span>
02175 <span class="preprocessor">#if defined(_X86_) || defined(_IA64_)</span>
02176 <span class="preprocessor"></span><span class="preprocessor">#define KSEG0_MAXPAGE MmKseg2Frame</span>
02177 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
02178 <span class="preprocessor"></span>
02179 <span class="preprocessor">#if defined(_IA64_)</span>
02180 <span class="preprocessor"></span><span class="preprocessor">#define MM_KSEG0_BASE KSEG0_BASE</span>
02181 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
02182 <span class="preprocessor"></span>
02183         <span class="keywordflow">if</span> ((NumberOfPages == 1) &amp;&amp; (CacheType == <a class="code" href="../../d4/d9/ke_8h.html#a413a249">MmCached</a>) &amp;&amp;
02184             (*Page &lt; KSEG0_MAXPAGE)) {
02185             BaseVa = (PVOID)(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a3">MM_KSEG0_BASE</a> + (*Page &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>) +
02186                             MemoryDescriptorList-&gt;ByteOffset);
02187             MemoryDescriptorList-&gt;MappedSystemVa = BaseVa;
02188             MemoryDescriptorList-&gt;MdlFlags |= <a class="code" href="../../d0/d9/ntosdef_8h.html#a12">MDL_MAPPED_TO_SYSTEM_VA</a>;
02189 
02190             <span class="keywordflow">goto</span> Update;
02191         }
02192 
02193         <span class="comment">//</span>
02194         <span class="comment">// Make sure there are enough PTEs of the requested size.</span>
02195         <span class="comment">//</span>
02196 
02197         <span class="keywordflow">if</span> ((Priority != <a class="code" href="../../d2/d1/mm_8h.html#a347a183">HighPagePriority</a>) &amp;&amp;
02198             (<a class="code" href="../../d0/d9/sysptes_8c.html#a29">MiGetSystemPteAvailability</a> ((ULONG)NumberOfPages, Priority) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
02199                 <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02200         }
02201 
02202         PointerPte = <a class="code" href="../../d0/d9/sysptes_8c.html#a25">MiReserveSystemPtes</a> (
02203                                     (ULONG)NumberOfPages,
02204                                     <a class="code" href="../../d4/d8/mi_8h.html#a1003a769">SystemPteSpace</a>,
02205                                     <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a58">MM_COLOR_ALIGNMENT</a>,
02206                                     (PtrToUlong(StartingVa) &amp;
02207                                                        <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a59">MM_COLOR_MASK_VIRTUAL</a>),
02208                         MemoryDescriptorList-&gt;MdlFlags &amp; <a class="code" href="../../d0/d9/ntosdef_8h.html#a25">MDL_MAPPING_CAN_FAIL</a> ? 0 : BugCheckOnFailure);
02209 
02210         <span class="keywordflow">if</span> (PointerPte == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02211 
02212             <span class="comment">//</span>
02213             <span class="comment">// Not enough system PTES are available.</span>
02214             <span class="comment">//</span>
02215 
02216             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02217         }
02218         BaseVa = (PVOID)((PCHAR)<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPte) +
02219                                 MemoryDescriptorList-&gt;ByteOffset);
02220 
02221         NumberOfPtes = NumberOfPages;
02222 
02223         TempPte = <a class="code" href="../../d4/d2/datalpha_8c.html#a2">ValidKernelPte</a>;
02224 
02225         <span class="keywordflow">switch</span> (CacheType) {
02226 
02227             <span class="keywordflow">case</span> <a class="code" href="../../d4/d9/ke_8h.html#a413a248">MmNonCached</a>:
02228                 <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a118">MI_DISABLE_CACHING</a> (TempPte);
02229                 <span class="keywordflow">break</span>;
02230 
02231             <span class="keywordflow">case</span> <a class="code" href="../../d4/d9/ke_8h.html#a413a249">MmCached</a>:
02232                 <span class="keywordflow">break</span>;
02233 
02234             <span class="keywordflow">case</span> <a class="code" href="../../d4/d9/ke_8h.html#a413a250">MmWriteCombined</a>:
02235                 <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a111">MI_SET_PTE_WRITE_COMBINE</a> (TempPte);
02236                 <span class="keywordflow">break</span>;
02237 
02238             <span class="keywordflow">case</span> <a class="code" href="../../d4/d9/ke_8h.html#a413a251">MmHardwareCoherentCached</a>:
02239                 <span class="keywordflow">break</span>;
02240 
02241 <span class="preprocessor">#if 0</span>
02242 <span class="preprocessor"></span>            <span class="keywordflow">case</span> <a class="code" href="../../d4/d9/ke_8h.html#a413a252">MmNonCachedUnordered</a>:
02243                 <span class="keywordflow">break</span>;
02244 <span class="preprocessor">#endif</span>
02245 <span class="preprocessor"></span>
02246             <span class="keywordflow">default</span>:
02247                 <span class="keywordflow">break</span>;
02248         }
02249 
02250 <span class="preprocessor">#if defined(_IA64_)</span>
02251 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (CacheType != <a class="code" href="../../d4/d9/ke_8h.html#a413a249">MmCached</a>) {
02252             <a class="code" href="../../d0/d6/ppc_2flushtb_8c.html#a0">KeFlushEntireTb</a>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
02253         }
02254 <span class="preprocessor">#endif</span>
02255 <span class="preprocessor"></span>
02256 <span class="preprocessor">#if DBG</span>
02257 <span class="preprocessor"></span>        <a class="code" href="../../d4/d8/mi_8h.html#a130">LOCK_PFN2</a> (OldIrql);
02258 <span class="preprocessor">#endif //DBG</span>
02259 <span class="preprocessor"></span>
02260         <span class="keywordflow">do</span> {
02261 
02262             <span class="keywordflow">if</span> (*Page == <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a>) {
02263                 <span class="keywordflow">break</span>;
02264             }
02265             TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber = *Page;
02266             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 0);
02267 
02268 <span class="preprocessor">#if DBG</span>
02269 <span class="preprocessor"></span>            <span class="keywordflow">if</span> ((MemoryDescriptorList-&gt;MdlFlags &amp; (<a class="code" href="../../d0/d9/ntosdef_8h.html#a23">MDL_IO_SPACE</a> | <a class="code" href="../../d0/d9/ntosdef_8h.html#a22">MDL_PHYSICAL_VIEW</a>)) == 0) {
02270                 Pfn2 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (*Page);
02271                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn2-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount != 0);
02272                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((((ULONG_PTR)PointerPte &gt;&gt; <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a52">PTE_SHIFT</a>) &amp; <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a57">MM_COLOR_MASK</a>) ==
02273                      (((ULONG)Pfn2-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageColor)));
02274             }
02275 <span class="preprocessor">#endif //DBG</span>
02276 <span class="preprocessor"></span>
02277             <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a186">MI_WRITE_VALID_PTE</a> (PointerPte, TempPte);
02278             Page += 1;
02279             PointerPte += 1;
02280             NumberOfPages -= 1;
02281         } <span class="keywordflow">while</span> (NumberOfPages != 0);
02282 
02283 <span class="preprocessor">#if DBG</span>
02284 <span class="preprocessor"></span>        <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
02285 <span class="preprocessor">#endif //DBG</span>
02286 <span class="preprocessor"></span>
02287 <span class="preprocessor">#if defined(i386)</span>
02288 <span class="preprocessor"></span>        <span class="comment">//</span>
02289         <span class="comment">// If write combined was specified then flush all caches and TBs.</span>
02290         <span class="comment">//</span>
02291 
02292         <span class="keywordflow">if</span> (CacheType == <a class="code" href="../../d4/d9/ke_8h.html#a413a250">MmWriteCombined</a> &amp;&amp; <a class="code" href="../../d6/d8/mi386_8h.html#a204">MiWriteCombiningPtes</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
02293             <a class="code" href="../../d0/d6/ppc_2flushtb_8c.html#a0">KeFlushEntireTb</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
02294             <a class="code" href="../../d0/d5/i386_2flush_8c.html#a2">KeInvalidateAllCaches</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
02295         }
02296 <span class="preprocessor">#endif</span>
02297 <span class="preprocessor"></span>
02298 <span class="preprocessor">#if defined(_IA64_)</span>
02299 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (CacheType != <a class="code" href="../../d4/d9/ke_8h.html#a413a249">MmCached</a>) {
02300             <a class="code" href="../../d2/d9/miia64_8h.html#a318">MiSweepCacheMachineDependent</a>(BaseVa, SavedPageCount * <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>, CacheType);
02301         }
02302 <span class="preprocessor">#endif</span>
02303 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a37">MmTrackPtes</a> != 0) {
02304 
02305             <span class="comment">//</span>
02306             <span class="comment">// First free any zombie blocks as no locks are being held.</span>
02307             <span class="comment">//</span>
02308 
02309             <a class="code" href="../../d5/d6/iosup_8c.html#a35">MiReleaseDeadPteTrackers</a> ();
02310 
02311             Tracker = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a> (<a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
02312                                              <span class="keyword">sizeof</span> (<a class="code" href="../../d7/d1/struct__PTE__TRACKER.html">PTE_TRACKER</a>),
02313                                              'ySmM');
02314             <span class="keywordflow">if</span> (Tracker == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02315                 <a class="code" href="../../d5/d6/iosup_8c.html#a9">MiTrackPtesAborted</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02316             }
02317         }
02318 
02319         <a class="code" href="../../d4/d8/mi_8h.html#a117">MiLockSystemSpace</a>(OldIrql);
02320         <span class="keywordflow">if</span> (MemoryDescriptorList-&gt;MdlFlags &amp; <a class="code" href="../../d0/d9/ntosdef_8h.html#a12">MDL_MAPPED_TO_SYSTEM_VA</a>) {
02321 
02322             <span class="comment">//</span>
02323             <span class="comment">// Another thread must have already mapped this.</span>
02324             <span class="comment">// Clean up the system PTES and release them.</span>
02325             <span class="comment">//</span>
02326 
02327             <a class="code" href="../../d4/d8/mi_8h.html#a118">MiUnlockSystemSpace</a>(OldIrql);
02328 
02329             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a37">MmTrackPtes</a> != 0) {
02330                 <span class="keywordflow">if</span> (Tracker != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02331                     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(Tracker);
02332                 }
02333             }
02334 
02335 <span class="preprocessor">#if DBG</span>
02336 <span class="preprocessor"></span>            <span class="keywordflow">if</span> ((MemoryDescriptorList-&gt;MdlFlags &amp; (<a class="code" href="../../d0/d9/ntosdef_8h.html#a23">MDL_IO_SPACE</a> | <a class="code" href="../../d0/d9/ntosdef_8h.html#a22">MDL_PHYSICAL_VIEW</a>)) == 0) {
02337                 <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn3;
02338                 PFN_NUMBER j;
02339                 PPFN_NUMBER Page1;
02340     
02341                 Page1 = (PPFN_NUMBER)(MemoryDescriptorList + 1);
02342                 <span class="keywordflow">for</span> (j = 0; j &lt; SavedPageCount ;j += 1) {
02343                     <span class="keywordflow">if</span> (*Page == <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a>) {
02344                         <span class="keywordflow">break</span>;
02345                     }
02346                     Pfn3 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (*Page1);
02347                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn3-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount != 0);
02348                     Page1 += 1;
02349                 }
02350             }
02351 <span class="preprocessor">#endif //DBG</span>
02352 <span class="preprocessor"></span>            PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (BaseVa);
02353 
02354             <a class="code" href="../../d0/d9/sysptes_8c.html#a26">MiReleaseSystemPtes</a> (PointerPte,
02355                                  (ULONG)SavedPageCount,
02356                                  <a class="code" href="../../d4/d8/mi_8h.html#a1003a769">SystemPteSpace</a>);
02357 
02358             <span class="keywordflow">return</span> MemoryDescriptorList-&gt;MappedSystemVa;
02359         }
02360 
02361         MemoryDescriptorList-&gt;MappedSystemVa = BaseVa;
02362         *(<span class="keyword">volatile</span> ULONG *)&amp;<a class="code" href="../../d5/d6/iosup_8c.html#a2">MmSystemLockPagesCount</a>;  <span class="comment">//need to force order.</span>
02363         MemoryDescriptorList-&gt;MdlFlags |= <a class="code" href="../../d0/d9/ntosdef_8h.html#a12">MDL_MAPPED_TO_SYSTEM_VA</a>;
02364 
02365         <span class="keywordflow">if</span> ((<a class="code" href="../../d8/d0/cmdat3_8c.html#a37">MmTrackPtes</a> != 0) &amp;&amp; (Tracker != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
02366 <span class="preprocessor">#if defined (_X86_)</span>
02367 <span class="preprocessor"></span>            <a class="code" href="../../d5/d2/ppc_2getcalr_8c.html#a0">RtlGetCallersAddress</a>(&amp;CallingAddress, &amp;CallersCaller);
02368 <span class="preprocessor">#endif</span>
02369 <span class="preprocessor"></span>            <a class="code" href="../../d5/d6/iosup_8c.html#a33">MiInsertPteTracker</a> (Tracker,
02370                                 MemoryDescriptorList,
02371                                 NumberOfPtes,
02372                                 CallingAddress,
02373                                 CallersCaller);
02374         }
02375 
02376         <a class="code" href="../../d4/d8/mi_8h.html#a118">MiUnlockSystemSpace</a>(OldIrql);
02377 
02378 Update:
02379         <span class="keywordflow">if</span> ((MemoryDescriptorList-&gt;MdlFlags &amp; <a class="code" href="../../d0/d9/ntosdef_8h.html#a16">MDL_PARTIAL</a>) != 0) {
02380             MemoryDescriptorList-&gt;MdlFlags |= <a class="code" href="../../d0/d9/ntosdef_8h.html#a17">MDL_PARTIAL_HAS_BEEN_MAPPED</a>;
02381         }
02382 
02383         <span class="keywordflow">return</span> BaseVa;
02384 
02385     } <span class="keywordflow">else</span> {
02386 
02387         <span class="keywordflow">return</span> <a class="code" href="../../d5/d6/iosup_8c.html#a29">MiMapLockedPagesInUserSpace</a> (MemoryDescriptorList,
02388                                             StartingVa,
02389                                             CacheType,
02390                                             RequestedAddress);
02391     }
02392 }
02393 
02394 PVOID
<a name="l02395"></a><a class="code" href="../../d4/d8/mi_8h.html#a818">02395</a> <a class="code" href="../../d4/d8/mi_8h.html#a818">MiMapSinglePage</a> (
02396      IN PVOID VirtualAddress OPTIONAL,
02397      IN PFN_NUMBER PageFrameIndex,
02398      IN MEMORY_CACHING_TYPE CacheType,
02399      IN MM_PAGE_PRIORITY Priority
02400      )
02401 
02402 <span class="comment">/*++</span>
02403 <span class="comment"></span>
02404 <span class="comment">Routine Description:</span>
02405 <span class="comment"></span>
02406 <span class="comment">    This function (re)maps a single system PTE to the specified physical page.</span>
02407 <span class="comment"></span>
02408 <span class="comment">Arguments:</span>
02409 <span class="comment"></span>
02410 <span class="comment">    VirtualAddress - Supplies the virtual address to map the page frame at.</span>
02411 <span class="comment">                     NULL indicates a system PTE is needed.  Non-NULL supplies</span>
02412 <span class="comment">                     the virtual address returned by an earlier</span>
02413 <span class="comment">                     MiMapSinglePage call.</span>
02414 <span class="comment"></span>
02415 <span class="comment">    PageFrameIndex - Supplies the page frame index to map.</span>
02416 <span class="comment"></span>
02417 <span class="comment">    CacheType - Supplies the type of cache mapping to use for the MDL.</span>
02418 <span class="comment">                MmCached indicates "normal" kernel or user mappings.</span>
02419 <span class="comment"></span>
02420 <span class="comment">    Priority - Supplies an indication as to how important it is that this</span>
02421 <span class="comment">               request succeed under low available PTE conditions.</span>
02422 <span class="comment"></span>
02423 <span class="comment">Return Value:</span>
02424 <span class="comment"></span>
02425 <span class="comment">    Returns the base address where the page is mapped, or NULL if it the</span>
02426 <span class="comment">    mapping failed.</span>
02427 <span class="comment"></span>
02428 <span class="comment">Environment:</span>
02429 <span class="comment"></span>
02430 <span class="comment">    Kernel mode.  APC_LEVEL or below.</span>
02431 <span class="comment"></span>
02432 <span class="comment">--*/</span>
02433 
02434 {
02435     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
02436     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> TempPte;
02437 
02438     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a> ();
02439 
02440     <span class="keywordflow">if</span> (VirtualAddress == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02441 
02442         <span class="comment">//</span>
02443         <span class="comment">// Make sure there are enough PTEs of the requested size.</span>
02444         <span class="comment">//</span>
02445     
02446         <span class="keywordflow">if</span> ((Priority != <a class="code" href="../../d2/d1/mm_8h.html#a347a183">HighPagePriority</a>) &amp;&amp;
02447             (<a class="code" href="../../d0/d9/sysptes_8c.html#a29">MiGetSystemPteAvailability</a> (1, Priority) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
02448                 <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02449         }
02450 
02451         PointerPte = <a class="code" href="../../d0/d9/sysptes_8c.html#a25">MiReserveSystemPtes</a> (1,
02452                                           <a class="code" href="../../d4/d8/mi_8h.html#a1003a769">SystemPteSpace</a>,
02453                                           <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a58">MM_COLOR_ALIGNMENT</a>,
02454                                           0,
02455                                           0);
02456 
02457         <span class="keywordflow">if</span> (PointerPte == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02458     
02459             <span class="comment">//</span>
02460             <span class="comment">// Not enough system PTES are available.</span>
02461             <span class="comment">//</span>
02462     
02463             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02464         }
02465 
02466         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 0);
02467         VirtualAddress = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPte);
02468     }
02469     <span class="keywordflow">else</span> {
02470         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a> (VirtualAddress) == 0);
02471         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (VirtualAddress &gt;= MM_SYSTEM_RANGE_START);
02472 
02473         PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (VirtualAddress);
02474         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1);
02475 
02476         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a187">MI_WRITE_INVALID_PTE</a> (PointerPte, <a class="code" href="../../d4/d2/datalpha_8c.html#a0">ZeroPte</a>);
02477 
02478         <a class="code" href="../../d0/d6/ppc_2flushtb_8c.html#a2">KeFlushSingleTb</a> (VirtualAddress,
02479                          <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
02480                          <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
02481                          (PHARDWARE_PTE)PointerPte,
02482                          <a class="code" href="../../d4/d2/datalpha_8c.html#a0">ZeroPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Flush);
02483     }
02484 
02485     TempPte = <a class="code" href="../../d4/d2/datalpha_8c.html#a2">ValidKernelPte</a>;
02486 
02487     <span class="keywordflow">switch</span> (CacheType) {
02488 
02489         <span class="keywordflow">case</span> <a class="code" href="../../d4/d9/ke_8h.html#a413a248">MmNonCached</a>:
02490             <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a118">MI_DISABLE_CACHING</a> (TempPte);
02491             <span class="keywordflow">break</span>;
02492 
02493         <span class="keywordflow">case</span> <a class="code" href="../../d4/d9/ke_8h.html#a413a249">MmCached</a>:
02494             <span class="keywordflow">break</span>;
02495 
02496         <span class="keywordflow">case</span> <a class="code" href="../../d4/d9/ke_8h.html#a413a250">MmWriteCombined</a>:
02497             <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a111">MI_SET_PTE_WRITE_COMBINE</a> (TempPte);
02498             <span class="keywordflow">break</span>;
02499 
02500         <span class="keywordflow">case</span> <a class="code" href="../../d4/d9/ke_8h.html#a413a251">MmHardwareCoherentCached</a>:
02501             <span class="keywordflow">break</span>;
02502 
02503 <span class="preprocessor">#if 0</span>
02504 <span class="preprocessor"></span>        <span class="keywordflow">case</span> <a class="code" href="../../d4/d9/ke_8h.html#a413a252">MmNonCachedUnordered</a>:
02505             <span class="keywordflow">break</span>;
02506 <span class="preprocessor">#endif</span>
02507 <span class="preprocessor"></span>
02508         <span class="keywordflow">default</span>:
02509             <span class="keywordflow">break</span>;
02510     }
02511 
02512 <span class="preprocessor">#if defined(_IA64_)</span>
02513 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (CacheType != <a class="code" href="../../d4/d9/ke_8h.html#a413a249">MmCached</a>) {
02514         <a class="code" href="../../d0/d6/ppc_2flushtb_8c.html#a0">KeFlushEntireTb</a>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
02515     }
02516 <span class="preprocessor">#endif</span>
02517 <span class="preprocessor"></span>
02518     TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber = PageFrameIndex;
02519 
02520     <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a186">MI_WRITE_VALID_PTE</a> (PointerPte, TempPte);
02521 
02522 <span class="preprocessor">#if defined(i386)</span>
02523 <span class="preprocessor"></span>    <span class="comment">//</span>
02524     <span class="comment">// If write combined was specified then flush all caches and TBs.</span>
02525     <span class="comment">//</span>
02526 
02527     <span class="keywordflow">if</span> (CacheType == <a class="code" href="../../d4/d9/ke_8h.html#a413a250">MmWriteCombined</a> &amp;&amp; <a class="code" href="../../d6/d8/mi386_8h.html#a204">MiWriteCombiningPtes</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
02528         <a class="code" href="../../d0/d6/ppc_2flushtb_8c.html#a0">KeFlushEntireTb</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
02529         <a class="code" href="../../d0/d5/i386_2flush_8c.html#a2">KeInvalidateAllCaches</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
02530     }
02531 <span class="preprocessor">#endif</span>
02532 <span class="preprocessor"></span>
02533 <span class="preprocessor">#if defined(_IA64_)</span>
02534 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (CacheType != <a class="code" href="../../d4/d9/ke_8h.html#a413a249">MmCached</a>) {
02535         <a class="code" href="../../d2/d9/miia64_8h.html#a318">MiSweepCacheMachineDependent</a>(VirtualAddress, <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>, CacheType);
02536     }
02537 <span class="preprocessor">#endif</span>
02538 <span class="preprocessor"></span>
02539     <span class="keywordflow">return</span> VirtualAddress;
02540 }
02541 
02542 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02543"></a><a class="code" href="../../d4/d8/mi_8h.html#a819">02543</a> <a class="code" href="../../d4/d8/mi_8h.html#a819">MiUnmapSinglePage</a> (
02544      IN PVOID VirtualAddress
02545      )
02546 
02547 <span class="comment">/*++</span>
02548 <span class="comment"></span>
02549 <span class="comment">Routine Description:</span>
02550 <span class="comment"></span>
02551 <span class="comment">    This routine unmaps a single locked pages which was previously mapped via</span>
02552 <span class="comment">    an MiMapSinglePage call.</span>
02553 <span class="comment"></span>
02554 <span class="comment">Arguments:</span>
02555 <span class="comment"></span>
02556 <span class="comment">    VirtualAddress - Supplies the virtual address used to map the page.</span>
02557 <span class="comment"></span>
02558 <span class="comment">Return Value:</span>
02559 <span class="comment"></span>
02560 <span class="comment">    None.</span>
02561 <span class="comment"></span>
02562 <span class="comment">Environment:</span>
02563 <span class="comment"></span>
02564 <span class="comment">    Kernel mode.  APC_LEVEL or below, base address is within system space.</span>
02565 <span class="comment"></span>
02566 <span class="comment">--*/</span>
02567 
02568 {
02569     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
02570 
02571     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a> ();
02572 
02573     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a> (VirtualAddress) == 0);
02574     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (VirtualAddress &gt;= MM_SYSTEM_RANGE_START);
02575 
02576     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (VirtualAddress);
02577 
02578     <a class="code" href="../../d0/d9/sysptes_8c.html#a26">MiReleaseSystemPtes</a> (PointerPte, 1, <a class="code" href="../../d4/d8/mi_8h.html#a1003a769">SystemPteSpace</a>);
02579     <span class="keywordflow">return</span>;
02580 }
02581 
02582 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02583"></a><a class="code" href="../../d5/d6/iosup_8c.html#a53">02583</a> <a class="code" href="../../d5/d6/iosup_8c.html#a53">MiPhysicalViewInserter</a> (
02584     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process,
02585     IN <a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html">PMI_PHYSICAL_VIEW</a> PhysicalView
02586     )
02587 
02588 <span class="comment">/*++</span>
02589 <span class="comment"></span>
02590 <span class="comment">Routine Description:</span>
02591 <span class="comment"></span>
02592 <span class="comment">    This function is a nonpaged wrapper which acquires the PFN lock to insert</span>
02593 <span class="comment">    a physical VAD into the process chain.</span>
02594 <span class="comment"></span>
02595 <span class="comment">Arguments:</span>
02596 <span class="comment"></span>
02597 <span class="comment">    Process - Supplies the process to add the physical VAD to.</span>
02598 <span class="comment"></span>
02599 <span class="comment">    PhysicalView - Supplies the physical view data to link in.</span>
02600 <span class="comment"></span>
02601 <span class="comment">Return Value:</span>
02602 <span class="comment"></span>
02603 <span class="comment">    None.</span>
02604 <span class="comment"></span>
02605 <span class="comment">Environment:</span>
02606 <span class="comment"></span>
02607 <span class="comment">    Kernel mode.  APC_LEVEL, working set and address space mutexes held.</span>
02608 <span class="comment"></span>
02609 <span class="comment">--*/</span>
02610 {
02611     KIRQL OldIrql;
02612     KIRQL OldIrql2;
02613 
02614     <a class="code" href="../../d4/d8/mi_8h.html#a133">LOCK_AWE</a> (Process, OldIrql);
02615 
02616     <a class="code" href="../../d4/d8/mi_8h.html#a130">LOCK_PFN2</a> (OldIrql2);
02617 
02618     InsertHeadList (&amp;Process-&gt;PhysicalVadList, &amp;PhysicalView-&gt;ListEntry);
02619 
02620     <span class="keywordflow">if</span> (PhysicalView-&gt;Vad-&gt;u.VadFlags.WriteWatch == 1) {
02621         <a class="code" href="../../d4/d8/mi_8h.html#a495">MiActiveWriteWatch</a> += 1;
02622     }
02623 
02624     <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql2);
02625 
02626     <a class="code" href="../../d4/d8/mi_8h.html#a134">UNLOCK_AWE</a> (Process, OldIrql);
02627 
02628     <span class="keywordflow">if</span> (PhysicalView-&gt;Vad-&gt;u.VadFlags.WriteWatch == 1) {
02629 
02630         <span class="comment">//</span>
02631         <span class="comment">// Mark this process as forever containing write-watch</span>
02632         <span class="comment">// address space(s).</span>
02633 
02634         <span class="keywordflow">if</span> (Process-&gt;Vm.u.Flags.WriteWatch == 0) {
02635             <a class="code" href="../../d4/d8/mi_8h.html#a773">MiMarkProcessAsWriteWatch</a> (Process);
02636         }
02637     }
02638 }
02639 
02640 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02641"></a><a class="code" href="../../d4/d8/mi_8h.html#a893">02641</a> <a class="code" href="../../d4/d8/mi_8h.html#a893">MiPhysicalViewRemover</a> (
02642     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process,
02643     IN <a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a> Vad
02644     )
02645 
02646 <span class="comment">/*++</span>
02647 <span class="comment"></span>
02648 <span class="comment">Routine Description:</span>
02649 <span class="comment"></span>
02650 <span class="comment">    This function is a nonpaged wrapper which acquires the PFN lock to remove</span>
02651 <span class="comment">    a physical VAD from the process chain.</span>
02652 <span class="comment"></span>
02653 <span class="comment">Arguments:</span>
02654 <span class="comment"></span>
02655 <span class="comment">    Process - Supplies the process to remove the physical VAD from.</span>
02656 <span class="comment"></span>
02657 <span class="comment">    Vad - Supplies the Vad to remove.</span>
02658 <span class="comment"></span>
02659 <span class="comment">Return Value:</span>
02660 <span class="comment"></span>
02661 <span class="comment">    None.</span>
02662 <span class="comment"></span>
02663 <span class="comment">Environment:</span>
02664 <span class="comment"></span>
02665 <span class="comment">    Kernel mode, APC_LEVEL, working set and address space mutexes held.</span>
02666 <span class="comment"></span>
02667 <span class="comment">--*/</span>
02668 {
02669     KIRQL OldIrql;
02670     KIRQL OldIrql2;
02671     PRTL_BITMAP <a class="code" href="../../d2/d1/structBitMap.html">BitMap</a>;
02672     PLIST_ENTRY NextEntry;
02673     <a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html">PMI_PHYSICAL_VIEW</a> PhysicalView;
02674     ULONG BitMapSize;
02675 
02676     <a class="code" href="../../d8/d9/tbitmap_8c.html#a2">BitMap</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02677 
02678     <a class="code" href="../../d4/d8/mi_8h.html#a133">LOCK_AWE</a> (Process, OldIrql);
02679 
02680     <a class="code" href="../../d4/d8/mi_8h.html#a130">LOCK_PFN2</a> (OldIrql2);
02681 
02682     NextEntry = Process-&gt;PhysicalVadList.Flink;
02683     <span class="keywordflow">while</span> (NextEntry != &amp;Process-&gt;PhysicalVadList) {
02684 
02685         PhysicalView = CONTAINING_RECORD(NextEntry,
02686                                          <a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html">MI_PHYSICAL_VIEW</a>,
02687                                          ListEntry);
02688 
02689         <span class="keywordflow">if</span> (PhysicalView-&gt;<a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html#o1">Vad</a> == Vad) {
02690             RemoveEntryList (NextEntry);
02691 
02692             <span class="keywordflow">if</span> (Vad-&gt;u.VadFlags.WriteWatch == 1) {
02693                 <a class="code" href="../../d4/d8/mi_8h.html#a495">MiActiveWriteWatch</a> -= 1;
02694                 <a class="code" href="../../d8/d9/tbitmap_8c.html#a2">BitMap</a> = PhysicalView-&gt;<a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html#o4">BitMap</a>;
02695                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d8/d9/tbitmap_8c.html#a2">BitMap</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
02696             }
02697 
02698             <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql2);
02699             <a class="code" href="../../d4/d8/mi_8h.html#a134">UNLOCK_AWE</a> (Process, OldIrql);
02700             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (PhysicalView);
02701 
02702             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d9/tbitmap_8c.html#a2">BitMap</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02703                 BitMapSize = <span class="keyword">sizeof</span>(RTL_BITMAP) + (ULONG)(((<a class="code" href="../../d8/d9/tbitmap_8c.html#a2">BitMap</a>-&gt;SizeOfBitMap + 31) / 32) * 4);
02704                 <a class="code" href="../../d0/d2/psquota_8c.html#a3">PsReturnPoolQuota</a> (Process, <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, BitMapSize);
02705                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (<a class="code" href="../../d8/d9/tbitmap_8c.html#a2">BitMap</a>);
02706             }
02707 
02708             <span class="keywordflow">return</span>;
02709         }
02710 
02711         NextEntry = NextEntry-&gt;Flink;
02712     }
02713 
02714     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
02715 
02716     <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql2);
02717     <a class="code" href="../../d4/d8/mi_8h.html#a134">UNLOCK_AWE</a> (Process, OldIrql);
02718 }
02719 
02720 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02721"></a><a class="code" href="../../d4/d8/mi_8h.html#a894">02721</a> <a class="code" href="../../d4/d8/mi_8h.html#a894">MiPhysicalViewAdjuster</a> (
02722     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process,
02723     IN <a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a> OldVad,
02724     IN <a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a> NewVad
02725     )
02726 
02727 <span class="comment">/*++</span>
02728 <span class="comment"></span>
02729 <span class="comment">Routine Description:</span>
02730 <span class="comment"></span>
02731 <span class="comment">    This function is a nonpaged wrapper which acquires the PFN lock to repoint</span>
02732 <span class="comment">    a physical VAD in the process chain.</span>
02733 <span class="comment"></span>
02734 <span class="comment">Arguments:</span>
02735 <span class="comment"></span>
02736 <span class="comment">    Process - Supplies the process in which to adjust the physical VAD.</span>
02737 <span class="comment"></span>
02738 <span class="comment">    Vad - Supplies the old Vad to replace.</span>
02739 <span class="comment"></span>
02740 <span class="comment">    NewVad - Supplies the newVad to substitute.</span>
02741 <span class="comment"></span>
02742 <span class="comment">Return Value:</span>
02743 <span class="comment"></span>
02744 <span class="comment">    None.</span>
02745 <span class="comment"></span>
02746 <span class="comment">Environment:</span>
02747 <span class="comment"></span>
02748 <span class="comment">    Kernel mode, called with APCs disabled, working set mutex held.</span>
02749 <span class="comment"></span>
02750 <span class="comment">--*/</span>
02751 {
02752     KIRQL OldIrql;
02753     KIRQL OldIrql2;
02754     PLIST_ENTRY NextEntry;
02755     <a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html">PMI_PHYSICAL_VIEW</a> PhysicalView;
02756 
02757     <a class="code" href="../../d4/d8/mi_8h.html#a133">LOCK_AWE</a> (Process, OldIrql);
02758 
02759     <a class="code" href="../../d4/d8/mi_8h.html#a130">LOCK_PFN2</a> (OldIrql2);
02760 
02761     NextEntry = Process-&gt;PhysicalVadList.Flink;
02762     <span class="keywordflow">while</span> (NextEntry != &amp;Process-&gt;PhysicalVadList) {
02763 
02764         PhysicalView = CONTAINING_RECORD(NextEntry,
02765                                          <a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html">MI_PHYSICAL_VIEW</a>,
02766                                          ListEntry);
02767 
02768         <span class="keywordflow">if</span> (PhysicalView-&gt;<a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html#o1">Vad</a> == OldVad) {
02769             PhysicalView-&gt;<a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html#o1">Vad</a> = NewVad;
02770             <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql2);
02771             <a class="code" href="../../d4/d8/mi_8h.html#a134">UNLOCK_AWE</a> (Process, OldIrql);
02772             <span class="keywordflow">return</span>;
02773         }
02774 
02775         NextEntry = NextEntry-&gt;Flink;
02776     }
02777 
02778     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
02779 
02780     <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql2);
02781     <a class="code" href="../../d4/d8/mi_8h.html#a134">UNLOCK_AWE</a> (Process, OldIrql);
02782 }
02783 
02784 PVOID
<a name="l02785"></a><a class="code" href="../../d5/d6/iosup_8c.html#a29">02785</a> <a class="code" href="../../d5/d6/iosup_8c.html#a29">MiMapLockedPagesInUserSpace</a> (
02786      IN <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MemoryDescriptorList,
02787      IN PVOID StartingVa,
02788      IN MEMORY_CACHING_TYPE CacheType,
02789      IN PVOID BaseVa
02790      )
02791 
02792 <span class="comment">/*++</span>
02793 <span class="comment"></span>
02794 <span class="comment">Routine Description:</span>
02795 <span class="comment"></span>
02796 <span class="comment">    This function maps physical pages described by a memory descriptor</span>
02797 <span class="comment">    list into the user portion of the virtual address space.</span>
02798 <span class="comment"></span>
02799 <span class="comment">Arguments:</span>
02800 <span class="comment"></span>
02801 <span class="comment">    MemoryDescriptorList - Supplies a valid Memory Descriptor List which has</span>
02802 <span class="comment">                           been updated by MmProbeAndLockPages.</span>
02803 <span class="comment"></span>
02804 <span class="comment"></span>
02805 <span class="comment">    StartingVa - Supplies the starting address.</span>
02806 <span class="comment"></span>
02807 <span class="comment">    CacheType - Supplies the type of cache mapping to use for the MDL.</span>
02808 <span class="comment">                MmCached indicates "normal" user mappings.</span>
02809 <span class="comment"></span>
02810 <span class="comment">    BaseVa - Supplies the base address of the view. If the initial</span>
02811 <span class="comment">             value of this argument is not null, then the view will</span>
02812 <span class="comment">             be allocated starting at the specified virtual</span>
02813 <span class="comment">             address rounded down to the next 64kb address</span>
02814 <span class="comment">             boundary. If the initial value of this argument is</span>
02815 <span class="comment">             null, then the operating system will determine</span>
02816 <span class="comment">             where to allocate the view.</span>
02817 <span class="comment"></span>
02818 <span class="comment">Return Value:</span>
02819 <span class="comment"></span>
02820 <span class="comment">    Returns the base address where the pages are mapped.  The base address</span>
02821 <span class="comment">    has the same offset as the virtual address in the MDL.</span>
02822 <span class="comment"></span>
02823 <span class="comment">    This routine will raise an exception if the processor mode is USER_MODE</span>
02824 <span class="comment">    and quota limits or VM limits are exceeded.</span>
02825 <span class="comment"></span>
02826 <span class="comment">Environment:</span>
02827 <span class="comment"></span>
02828 <span class="comment">    Kernel mode.  APC_LEVEL or below.</span>
02829 <span class="comment"></span>
02830 <span class="comment">--*/</span>
02831 
02832 {
02833     PFN_NUMBER NumberOfPages;
02834     PPFN_NUMBER Page;
02835     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
02836     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPde;
02837     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPpe;
02838     PCHAR Va;
02839     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> TempPte;
02840     PVOID EndingAddress;
02841     <a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a> Vad;
02842     <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process;
02843     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn2;
02844     PVOID UsedPageTableHandle;
02845     <a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html">PMI_PHYSICAL_VIEW</a> PhysicalView;
02846 <span class="preprocessor">#if defined (_WIN64)</span>
02847 <span class="preprocessor"></span>    PVOID UsedPageDirectoryHandle;
02848 <span class="preprocessor">#endif</span>
02849 <span class="preprocessor"></span>
02850     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a> ();
02851     Page = (PPFN_NUMBER)(MemoryDescriptorList + 1);
02852     NumberOfPages = <a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a> (StartingVa,
02853                                            MemoryDescriptorList-&gt;ByteCount);
02854 
02855     <span class="keywordflow">if</span> (MemoryDescriptorList-&gt;MdlFlags &amp; <a class="code" href="../../d0/d9/ntosdef_8h.html#a23">MDL_IO_SPACE</a>) {
02856         <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a> (STATUS_INVALID_ADDRESS);
02857         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02858     }
02859 
02860     <span class="comment">//</span>
02861     <span class="comment">// Map the pages into the user part of the address as user</span>
02862     <span class="comment">// read/write no-delete.</span>
02863     <span class="comment">//</span>
02864 
02865     TempPte = <a class="code" href="../../d4/d2/datalpha_8c.html#a4">ValidUserPte</a>;
02866 
02867     <span class="keywordflow">switch</span> (CacheType) {
02868 
02869         <span class="keywordflow">case</span> <a class="code" href="../../d4/d9/ke_8h.html#a413a248">MmNonCached</a>:
02870             <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a118">MI_DISABLE_CACHING</a> (TempPte);
02871             <span class="keywordflow">break</span>;
02872 
02873         <span class="keywordflow">case</span> <a class="code" href="../../d4/d9/ke_8h.html#a413a249">MmCached</a>:
02874             <span class="keywordflow">break</span>;
02875 
02876         <span class="keywordflow">case</span> <a class="code" href="../../d4/d9/ke_8h.html#a413a250">MmWriteCombined</a>:
02877             <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a111">MI_SET_PTE_WRITE_COMBINE</a> (TempPte);
02878             <span class="keywordflow">break</span>;
02879 
02880         <span class="keywordflow">case</span> <a class="code" href="../../d4/d9/ke_8h.html#a413a251">MmHardwareCoherentCached</a>:
02881             <span class="keywordflow">break</span>;
02882 
02883 <span class="preprocessor">#if 0</span>
02884 <span class="preprocessor"></span>        <span class="keywordflow">case</span> <a class="code" href="../../d4/d9/ke_8h.html#a413a252">MmNonCachedUnordered</a>:
02885             <span class="keywordflow">break</span>;
02886 <span class="preprocessor">#endif</span>
02887 <span class="preprocessor"></span>
02888         <span class="keywordflow">default</span>:
02889             <span class="keywordflow">break</span>;
02890     }
02891 
02892     Process = <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a> ();
02893 
02894     <span class="comment">//</span>
02895     <span class="comment">// Make sure the specified starting and ending addresses are</span>
02896     <span class="comment">// within the user part of the virtual address space.</span>
02897     <span class="comment">//</span>
02898 
02899     <span class="keywordflow">if</span> (BaseVa != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02900 
02901         <span class="keywordflow">if</span> ((ULONG_PTR)BaseVa &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) {
02902 
02903             <span class="comment">//</span>
02904             <span class="comment">// Invalid base address.</span>
02905             <span class="comment">//</span>
02906 
02907             <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a> (STATUS_INVALID_ADDRESS);
02908             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02909         }
02910 
02911         EndingAddress = (PVOID)((PCHAR)BaseVa + ((ULONG_PTR)NumberOfPages * <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>) - 1);
02912 
02913         <span class="keywordflow">if</span> (EndingAddress &lt;= BaseVa) {
02914 
02915             <span class="comment">//</span>
02916             <span class="comment">// Invalid region size.</span>
02917             <span class="comment">//</span>
02918 
02919             <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a> (STATUS_INVALID_ADDRESS);
02920             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02921         }
02922 
02923         <span class="keywordflow">if</span> (EndingAddress &gt; <a class="code" href="../../d4/d8/mi_8h.html#a19">MM_HIGHEST_VAD_ADDRESS</a>) {
02924 
02925             <span class="comment">//</span>
02926             <span class="comment">// Invalid region size.</span>
02927             <span class="comment">//</span>
02928 
02929             <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a> (STATUS_INVALID_ADDRESS);
02930             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02931         }
02932 
02933         <a class="code" href="../../d4/d8/mi_8h.html#a161">LOCK_WS_AND_ADDRESS_SPACE</a> (Process);
02934 
02935         <span class="comment">//</span>
02936         <span class="comment">// Make sure the address space was not deleted, if so, return an error.</span>
02937         <span class="comment">//</span>
02938 
02939         <span class="keywordflow">if</span> (Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o27">AddressSpaceDeleted</a> != 0) {
02940             <a class="code" href="../../d4/d8/mi_8h.html#a162">UNLOCK_WS_AND_ADDRESS_SPACE</a> (Process);
02941             <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a> (STATUS_PROCESS_IS_TERMINATING);
02942             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02943         }
02944 
02945         Vad = <a class="code" href="../../d4/d8/mi_8h.html#a98">MiCheckForConflictingVad</a> (BaseVa, EndingAddress);
02946 
02947         <span class="comment">//</span>
02948         <span class="comment">// Make sure the address space is not already in use.</span>
02949         <span class="comment">//</span>
02950 
02951         <span class="keywordflow">if</span> (Vad != (<a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a>)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02952             <a class="code" href="../../d4/d8/mi_8h.html#a162">UNLOCK_WS_AND_ADDRESS_SPACE</a> (Process);
02953             <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a> (STATUS_CONFLICTING_ADDRESSES);
02954             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02955         }
02956     }
02957     <span class="keywordflow">else</span> {
02958 
02959         <span class="comment">//</span>
02960         <span class="comment">// Get the working set mutex and address creation mutex.</span>
02961         <span class="comment">//</span>
02962 
02963         <a class="code" href="../../d4/d8/mi_8h.html#a161">LOCK_WS_AND_ADDRESS_SPACE</a> (Process);
02964 
02965         <span class="comment">//</span>
02966         <span class="comment">// Make sure the address space was not deleted, if so, return an error.</span>
02967         <span class="comment">//</span>
02968 
02969         <span class="keywordflow">if</span> (Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o27">AddressSpaceDeleted</a> != 0) {
02970             <a class="code" href="../../d4/d8/mi_8h.html#a162">UNLOCK_WS_AND_ADDRESS_SPACE</a> (Process);
02971             <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a> (STATUS_PROCESS_IS_TERMINATING);
02972             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02973         }
02974 
02975         <span class="keywordflow">try</span> {
02976 
02977             BaseVa = <a class="code" href="../../d6/d3/vadtree_8c.html#a3">MiFindEmptyAddressRange</a> ( (ULONG_PTR)NumberOfPages * <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>,
02978                                                 <a class="code" href="../../d4/d8/mi_8h.html#a18">X64K</a>,
02979                                                 0 );
02980 
02981             EndingAddress = (PVOID)((PCHAR)BaseVa + ((ULONG_PTR)NumberOfPages * <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>) - 1);
02982 
02983         } except (<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
02984             BaseVa = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02985             <span class="keywordflow">goto</span> Done;
02986         }
02987     }
02988 
02989     PhysicalView = (<a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html">PMI_PHYSICAL_VIEW</a>)<a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a> (<a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
02990                                                              <span class="keyword">sizeof</span>(<a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html">MI_PHYSICAL_VIEW</a>),
02991                                                              <a class="code" href="../../d4/d8/mi_8h.html#a231">MI_PHYSICAL_VIEW_KEY</a>);
02992     <span class="keywordflow">if</span> (PhysicalView == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02993         BaseVa = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02994         <span class="keywordflow">goto</span> Done;
02995     }
02996 
02997     Vad = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a> (<a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, <span class="keyword">sizeof</span>(<a class="code" href="../../d6/d6/struct__MMVAD.html">MMVAD</a>), ' daV');
02998 
02999     <span class="keywordflow">if</span> (Vad == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03000         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (PhysicalView);
03001         BaseVa = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03002         <span class="keywordflow">goto</span> Done;
03003     }
03004 
03005     PhysicalView-&gt;<a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html#o1">Vad</a> = Vad;
03006     PhysicalView-&gt;<a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html#o2">StartVa</a> = BaseVa;
03007     PhysicalView-&gt;<a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html#o3">EndVa</a> = EndingAddress;
03008 
03009     Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o0">StartingVpn</a> = <a class="code" href="../../d4/d8/mi_8h.html#a107">MI_VA_TO_VPN</a> (BaseVa);
03010     Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o1">EndingVpn</a> = <a class="code" href="../../d4/d8/mi_8h.html#a107">MI_VA_TO_VPN</a> (EndingAddress);
03011     Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o8">ControlArea</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03012     Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o9">FirstPrototypePte</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03013     Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.LongFlags = 0;
03014     Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.VadFlags.Protection = <a class="code" href="../../d4/d8/mi_8h.html#a39">MM_READWRITE</a>;
03015     Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.VadFlags.PhysicalMapping = 1;
03016     Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.VadFlags.PrivateMemory = 1;
03017     Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o19">u4</a>.Banked = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03018 
03019     <span class="keywordflow">try</span> {
03020 
03021         <a class="code" href="../../d6/d3/vadtree_8c.html#a0">MiInsertVad</a> (Vad);
03022 
03023     } except (<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
03024         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (PhysicalView);
03025         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (Vad);
03026         BaseVa = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03027         <span class="keywordflow">goto</span> Done;
03028     }
03029 
03030     <a class="code" href="../../d5/d6/iosup_8c.html#a53">MiPhysicalViewInserter</a> (Process, PhysicalView);
03031 
03032 <span class="preprocessor">#if defined(_IA64_)</span>
03033 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (CacheType != <a class="code" href="../../d4/d9/ke_8h.html#a413a249">MmCached</a>) {
03034         <a class="code" href="../../d0/d6/ppc_2flushtb_8c.html#a0">KeFlushEntireTb</a>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
03035     }
03036 <span class="preprocessor">#endif</span>
03037 <span class="preprocessor"></span>
03038     <span class="comment">//</span>
03039     <span class="comment">// Create a page table and fill in the mappings for the Vad.</span>
03040     <span class="comment">//</span>
03041 
03042     Va = BaseVa;
03043     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (BaseVa);
03044 
03045     <span class="keywordflow">do</span> {
03046 
03047         <span class="keywordflow">if</span> (*Page == <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a>) {
03048             <span class="keywordflow">break</span>;
03049         }
03050 
03051         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (*Page &lt;= <a class="code" href="../../d6/d8/sysinfo_8c.html#a7">MmHighestPhysicalPage</a>);
03052 
03053         PointerPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (PointerPte);
03054         PointerPpe = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a151">MiGetPdeAddress</a> (PointerPte);
03055 
03056 <span class="preprocessor">#if defined (_WIN64)</span>
03057 <span class="preprocessor"></span>        <a class="code" href="../../d4/d8/mi_8h.html#a245">MiMakePpeExistAndMakeValid</a> (PointerPpe, Process, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
03058         <span class="keywordflow">if</span> (PointerPde-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long == 0) {
03059             UsedPageDirectoryHandle = <a class="code" href="../../d4/d8/mi_8h.html#a180">MI_GET_USED_PTES_HANDLE</a> (PointerPte);
03060             <a class="code" href="../../d4/d8/mi_8h.html#a182">MI_INCREMENT_USED_PTES_BY_HANDLE</a> (UsedPageDirectoryHandle);
03061         }
03062 <span class="preprocessor">#endif</span>
03063 <span class="preprocessor"></span>
03064         <a class="code" href="../../d0/d2/mmsup_8c.html#a7">MiMakePdeExistAndMakeValid</a>(PointerPde, Process, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
03065 
03066         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 0);
03067         TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber = *Page;
03068         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a186">MI_WRITE_VALID_PTE</a> (PointerPte, TempPte);
03069 
03070         <span class="comment">//</span>
03071         <span class="comment">// A PTE just went from not present, not transition to</span>
03072         <span class="comment">// present.  The share count and valid count must be</span>
03073         <span class="comment">// updated in the page table page which contains this</span>
03074         <span class="comment">// PTE.</span>
03075         <span class="comment">//</span>
03076 
03077         Pfn2 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(PointerPde-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
03078         Pfn2-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount += 1;
03079 
03080         <span class="comment">//</span>
03081         <span class="comment">// Another zeroed PTE has become non-zero.</span>
03082         <span class="comment">//</span>
03083 
03084         UsedPageTableHandle = <a class="code" href="../../d4/d8/mi_8h.html#a180">MI_GET_USED_PTES_HANDLE</a> (Va);
03085 
03086         <a class="code" href="../../d4/d8/mi_8h.html#a182">MI_INCREMENT_USED_PTES_BY_HANDLE</a> (UsedPageTableHandle);
03087 
03088         Page += 1;
03089         PointerPte += 1;
03090         NumberOfPages -= 1;
03091         Va += <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
03092     } <span class="keywordflow">while</span> (NumberOfPages != 0);
03093 
03094 <span class="preprocessor">#if defined(_IA64_)</span>
03095 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (CacheType != <a class="code" href="../../d4/d9/ke_8h.html#a413a249">MmCached</a>) {
03096         <a class="code" href="../../d2/d9/miia64_8h.html#a318">MiSweepCacheMachineDependent</a> (BaseVa, MemoryDescriptorList-&gt;ByteCount, CacheType);
03097     }
03098 <span class="preprocessor">#endif</span>
03099 <span class="preprocessor"></span>
03100 Done:
03101     <a class="code" href="../../d4/d8/mi_8h.html#a162">UNLOCK_WS_AND_ADDRESS_SPACE</a> (Process);
03102     <span class="keywordflow">if</span> (BaseVa == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03103         <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a> (STATUS_INSUFFICIENT_RESOURCES);
03104         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03105     }
03106 
03107 <span class="preprocessor">#if defined(i386)</span>
03108 <span class="preprocessor"></span>    <span class="comment">//</span>
03109     <span class="comment">// If write combined was specified then flush all caches and TBs.</span>
03110     <span class="comment">//</span>
03111 
03112     <span class="keywordflow">if</span> (CacheType == <a class="code" href="../../d4/d9/ke_8h.html#a413a250">MmWriteCombined</a> &amp;&amp; <a class="code" href="../../d6/d8/mi386_8h.html#a204">MiWriteCombiningPtes</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
03113         <a class="code" href="../../d0/d6/ppc_2flushtb_8c.html#a0">KeFlushEntireTb</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
03114         <a class="code" href="../../d0/d5/i386_2flush_8c.html#a2">KeInvalidateAllCaches</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
03115     }
03116 <span class="preprocessor">#endif</span>
03117 <span class="preprocessor"></span>
03118     BaseVa = (PVOID)((PCHAR)BaseVa + MemoryDescriptorList-&gt;ByteOffset);
03119 
03120     <span class="keywordflow">return</span> BaseVa;
03121 }
03122 
03123 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l03124"></a><a class="code" href="../../d5/d6/iosup_8c.html#a56">03124</a> <a class="code" href="../../d5/d6/iosup_8c.html#a56">MmUnmapLockedPages</a> (
03125      IN PVOID BaseAddress,
03126      IN <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MemoryDescriptorList
03127      )
03128 
03129 <span class="comment">/*++</span>
03130 <span class="comment"></span>
03131 <span class="comment">Routine Description:</span>
03132 <span class="comment"></span>
03133 <span class="comment">    This routine unmaps locked pages which were previously mapped via</span>
03134 <span class="comment">    a MmMapLockedPages call.</span>
03135 <span class="comment"></span>
03136 <span class="comment">Arguments:</span>
03137 <span class="comment"></span>
03138 <span class="comment">    BaseAddress - Supplies the base address where the pages were previously</span>
03139 <span class="comment">                  mapped.</span>
03140 <span class="comment"></span>
03141 <span class="comment">    MemoryDescriptorList - Supplies a valid Memory Descriptor List which has</span>
03142 <span class="comment">                            been updated by MmProbeAndLockPages.</span>
03143 <span class="comment"></span>
03144 <span class="comment">Return Value:</span>
03145 <span class="comment"></span>
03146 <span class="comment">    None.</span>
03147 <span class="comment"></span>
03148 <span class="comment">Environment:</span>
03149 <span class="comment"></span>
03150 <span class="comment">    Kernel mode.  DISPATCH_LEVEL or below if base address is within</span>
03151 <span class="comment">    system space; APC_LEVEL or below if base address is user space.</span>
03152 <span class="comment"></span>
03153 <span class="comment">--*/</span>
03154 
03155 {
03156     PFN_NUMBER NumberOfPages;
03157     PFN_NUMBER i;
03158     PPFN_NUMBER Page;
03159     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
03160     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerBase;
03161     PVOID StartingVa;
03162     KIRQL OldIrql;
03163     PVOID PoolBlock;
03164 
03165     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (MemoryDescriptorList-&gt;ByteCount != 0);
03166     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((MemoryDescriptorList-&gt;MdlFlags &amp; <a class="code" href="../../d0/d9/ntosdef_8h.html#a20">MDL_PARENT_MAPPED_SYSTEM_VA</a>) == 0);
03167 
03168     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a> (BaseAddress)) {
03169 
03170         <span class="comment">//</span>
03171         <span class="comment">// MDL is not mapped into virtual space, just clear the fields</span>
03172         <span class="comment">// and return.</span>
03173         <span class="comment">//</span>
03174 
03175         MemoryDescriptorList-&gt;MdlFlags &amp;= ~(<a class="code" href="../../d0/d9/ntosdef_8h.html#a12">MDL_MAPPED_TO_SYSTEM_VA</a> |
03176                                             <a class="code" href="../../d0/d9/ntosdef_8h.html#a17">MDL_PARTIAL_HAS_BEEN_MAPPED</a>);
03177         <span class="keywordflow">return</span>;
03178     }
03179 
03180     <span class="keywordflow">if</span> (BaseAddress &gt; MM_HIGHEST_USER_ADDRESS) {
03181 
03182         StartingVa = (PVOID)((PCHAR)MemoryDescriptorList-&gt;StartVa +
03183                         MemoryDescriptorList-&gt;ByteOffset);
03184 
03185         NumberOfPages = <a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a> (StartingVa,
03186                                                MemoryDescriptorList-&gt;ByteCount);
03187 
03188         PointerBase = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (BaseAddress);
03189 
03190 
03191         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((MemoryDescriptorList-&gt;MdlFlags &amp; <a class="code" href="../../d0/d9/ntosdef_8h.html#a12">MDL_MAPPED_TO_SYSTEM_VA</a>) != 0);
03192 
03193 
03194 <span class="preprocessor">#if DBG</span>
03195 <span class="preprocessor"></span>        PointerPte = PointerBase;
03196         i = NumberOfPages;
03197         Page = (PPFN_NUMBER)(MemoryDescriptorList + 1);
03198         <span class="keywordflow">if</span> ((MemoryDescriptorList-&gt;MdlFlags &amp; <a class="code" href="../../d0/d9/ntosdef_8h.html#a21">MDL_LOCK_HELD</a>) == 0) {
03199             <a class="code" href="../../d4/d8/mi_8h.html#a130">LOCK_PFN2</a> (OldIrql);
03200         }
03201 
03202         <span class="keywordflow">while</span> (i != 0) {
03203             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1);
03204             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (*Page == <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a> (PointerPte));
03205             <span class="keywordflow">if</span> ((MemoryDescriptorList-&gt;MdlFlags &amp; (<a class="code" href="../../d0/d9/ntosdef_8h.html#a23">MDL_IO_SPACE</a> | <a class="code" href="../../d0/d9/ntosdef_8h.html#a22">MDL_PHYSICAL_VIEW</a>)) == 0) {
03206                 <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn3;
03207                 Pfn3 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (*Page);
03208                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn3-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount != 0);
03209             }
03210 
03211             Page += 1;
03212             PointerPte += 1;
03213             i -= 1;
03214         }
03215 
03216         <span class="keywordflow">if</span> ((MemoryDescriptorList-&gt;MdlFlags &amp; <a class="code" href="../../d0/d9/ntosdef_8h.html#a21">MDL_LOCK_HELD</a>) == 0) {
03217             <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
03218         }
03219 <span class="preprocessor">#endif //DBG</span>
03220 <span class="preprocessor"></span>
03221         MemoryDescriptorList-&gt;MdlFlags &amp;= ~(<a class="code" href="../../d0/d9/ntosdef_8h.html#a12">MDL_MAPPED_TO_SYSTEM_VA</a> |
03222                                             <a class="code" href="../../d0/d9/ntosdef_8h.html#a17">MDL_PARTIAL_HAS_BEEN_MAPPED</a>);
03223 
03224         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a37">MmTrackPtes</a> != 0) {
03225             <a class="code" href="../../d4/d8/mi_8h.html#a117">MiLockSystemSpace</a>(OldIrql);
03226             PoolBlock = <a class="code" href="../../d5/d6/iosup_8c.html#a34">MiRemovePteTracker</a> (MemoryDescriptorList,
03227                                             PointerBase,
03228                                             NumberOfPages);
03229             <a class="code" href="../../d4/d8/mi_8h.html#a118">MiUnlockSystemSpace</a>(OldIrql);
03230 
03231             <span class="comment">//</span>
03232             <span class="comment">// Can't free the pool block here because we may be getting called</span>
03233             <span class="comment">// from the fault path in MiWaitForInPageComplete holding the PFN</span>
03234             <span class="comment">// lock.  Queue the block for later release.</span>
03235             <span class="comment">//</span>
03236 
03237             <span class="keywordflow">if</span> (PoolBlock) {
03238                 <a class="code" href="../../d5/d6/iosup_8c.html#a36">MiInsertDeadPteTrackingBlock</a> (PoolBlock);
03239             }
03240         }
03241 
03242         <a class="code" href="../../d0/d9/sysptes_8c.html#a26">MiReleaseSystemPtes</a> (PointerBase, (ULONG)NumberOfPages, <a class="code" href="../../d4/d8/mi_8h.html#a1003a769">SystemPteSpace</a>);
03243         <span class="keywordflow">return</span>;
03244 
03245     } <span class="keywordflow">else</span> {
03246 
03247         <a class="code" href="../../d5/d6/iosup_8c.html#a30">MiUnmapLockedPagesInUserSpace</a> (BaseAddress,
03248                                        MemoryDescriptorList);
03249     }
03250 }
03251 
03252 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l03253"></a><a class="code" href="../../d5/d6/iosup_8c.html#a30">03253</a> <a class="code" href="../../d5/d6/iosup_8c.html#a30">MiUnmapLockedPagesInUserSpace</a> (
03254      IN PVOID BaseAddress,
03255      IN <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MemoryDescriptorList
03256      )
03257 
03258 <span class="comment">/*++</span>
03259 <span class="comment"></span>
03260 <span class="comment">Routine Description:</span>
03261 <span class="comment"></span>
03262 <span class="comment">    This routine unmaps locked pages which were previously mapped via</span>
03263 <span class="comment">    a MmMapLockedPages function.</span>
03264 <span class="comment"></span>
03265 <span class="comment">Arguments:</span>
03266 <span class="comment"></span>
03267 <span class="comment">    BaseAddress - Supplies the base address where the pages were previously</span>
03268 <span class="comment">                  mapped.</span>
03269 <span class="comment"></span>
03270 <span class="comment">    MemoryDescriptorList - Supplies a valid Memory Descriptor List which has</span>
03271 <span class="comment">                           been updated by MmProbeAndLockPages.</span>
03272 <span class="comment"></span>
03273 <span class="comment">Return Value:</span>
03274 <span class="comment"></span>
03275 <span class="comment">    None.</span>
03276 <span class="comment"></span>
03277 <span class="comment">Environment:</span>
03278 <span class="comment"></span>
03279 <span class="comment">    Kernel mode.  DISPATCH_LEVEL or below if base address is within system space;</span>
03280 <span class="comment">                APC_LEVEL or below if base address is user space.</span>
03281 <span class="comment"></span>
03282 <span class="comment">--*/</span>
03283 
03284 {
03285     PFN_NUMBER NumberOfPages;
03286     PPFN_NUMBER Page;
03287     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
03288     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerBase;
03289     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPde;
03290     PVOID StartingVa;
03291     KIRQL OldIrql;
03292     <a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a> Vad;
03293     PVOID TempVa;
03294     <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process;
03295     PVOID UsedPageTableHandle;
03296 <span class="preprocessor">#if defined (_WIN64)</span>
03297 <span class="preprocessor"></span>    PVOID UsedPageDirectoryHandle;
03298 <span class="preprocessor">#endif</span>
03299 <span class="preprocessor"></span>
03300     <a class="code" href="../../d5/d6/iosup_8c.html#a76">MmLockPagableSectionByHandle</a> (<a class="code" href="../../d5/d8/ex_8h.html#a166">ExPageLockHandle</a>);
03301 
03302     StartingVa = (PVOID)((PCHAR)MemoryDescriptorList-&gt;StartVa +
03303                     MemoryDescriptorList-&gt;ByteOffset);
03304 
03305     Page = (PPFN_NUMBER)(MemoryDescriptorList + 1);
03306     NumberOfPages = <a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a> (StartingVa,
03307                                            MemoryDescriptorList-&gt;ByteCount);
03308 
03309     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (BaseAddress);
03310     PointerBase = PointerPte;
03311 
03312     <span class="comment">//</span>
03313     <span class="comment">// This was mapped into the user portion of the address space and</span>
03314     <span class="comment">// the corresponding virtual address descriptor must be deleted.</span>
03315     <span class="comment">//</span>
03316 
03317     <span class="comment">//</span>
03318     <span class="comment">// Get the working set mutex and address creation mutex.</span>
03319     <span class="comment">//</span>
03320 
03321     Process = <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a> ();
03322 
03323     <a class="code" href="../../d4/d8/mi_8h.html#a161">LOCK_WS_AND_ADDRESS_SPACE</a> (Process);
03324 
03325     Vad = <a class="code" href="../../d6/d3/vadtree_8c.html#a2">MiLocateAddress</a> (BaseAddress);
03326     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Vad != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
03327 
03328     <a class="code" href="../../d4/d8/mi_8h.html#a893">MiPhysicalViewRemover</a> (Process, Vad);
03329 
03330     <a class="code" href="../../d6/d3/vadtree_8c.html#a1">MiRemoveVad</a> (Vad);
03331 
03332     <span class="comment">//</span>
03333     <span class="comment">// Get the PFN mutex so we can safely decrement share and valid</span>
03334     <span class="comment">// counts on page table pages.</span>
03335     <span class="comment">//</span>
03336 
03337     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
03338 
03339     <span class="keywordflow">do</span> {
03340 
03341         <span class="keywordflow">if</span> (*Page == <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a>) {
03342             <span class="keywordflow">break</span>;
03343         }
03344 
03345         <a class="code" href="../../d4/d8/mi_8h.html#a1">ASSERT64</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a151">MiGetPdeAddress</a>(PointerPte)-&gt;u.Hard.Valid == 1);
03346         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(PointerPte)-&gt;u.Hard.Valid == 1);
03347         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;u.Hard.Valid == 1);
03348 
03349         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d0/d6/ppc_2flushtb_8c.html#a2">KeFlushSingleTb</a> (BaseAddress,
03350                                <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
03351                                <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
03352                                (PHARDWARE_PTE)PointerPte,
03353                                <a class="code" href="../../d4/d2/datalpha_8c.html#a0">ZeroPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Flush);
03354 
03355         PointerPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(PointerPte);
03356         <a class="code" href="../../d4/d8/mi_8h.html#a242">MiDecrementShareAndValidCount</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a> (PointerPde));
03357 
03358         <span class="comment">//</span>
03359         <span class="comment">// Another PTE has become zero.</span>
03360         <span class="comment">//</span>
03361 
03362         UsedPageTableHandle = <a class="code" href="../../d4/d8/mi_8h.html#a180">MI_GET_USED_PTES_HANDLE</a> (BaseAddress);
03363 
03364         <a class="code" href="../../d4/d8/mi_8h.html#a183">MI_DECREMENT_USED_PTES_BY_HANDLE</a> (UsedPageTableHandle);
03365 
03366         <span class="comment">//</span>
03367         <span class="comment">// If all the entries have been eliminated from the previous</span>
03368         <span class="comment">// page table page, delete the page table page itself.  Likewise</span>
03369         <span class="comment">// with the page directory page.</span>
03370         <span class="comment">//</span>
03371 
03372         <span class="keywordflow">if</span> (<a class="code" href="../../d4/d8/mi_8h.html#a181">MI_GET_USED_PTES_FROM_HANDLE</a> (UsedPageTableHandle) == 0) {
03373 
03374             TempVa = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPde);
03375             <a class="code" href="../../d4/d8/mi_8h.html#a886">MiDeletePte</a> (PointerPde,
03376                          TempVa,
03377                          <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
03378                          Process,
03379                          (<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
03380                          <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
03381 
03382 <span class="preprocessor">#if defined (_WIN64)</span>
03383 <span class="preprocessor"></span>            UsedPageDirectoryHandle = <a class="code" href="../../d4/d8/mi_8h.html#a180">MI_GET_USED_PTES_HANDLE</a> (PointerPte);
03384 
03385             <a class="code" href="../../d4/d8/mi_8h.html#a183">MI_DECREMENT_USED_PTES_BY_HANDLE</a> (UsedPageDirectoryHandle);
03386 
03387             <span class="keywordflow">if</span> (<a class="code" href="../../d4/d8/mi_8h.html#a181">MI_GET_USED_PTES_FROM_HANDLE</a> (UsedPageDirectoryHandle) == 0) {
03388 
03389                 TempVa = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a>(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(PointerPde));
03390                 <a class="code" href="../../d4/d8/mi_8h.html#a886">MiDeletePte</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(PointerPde),
03391                              TempVa,
03392                              <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
03393                              Process,
03394                              <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
03395                              <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
03396             }
03397 <span class="preprocessor">#endif</span>
03398 <span class="preprocessor"></span>        }
03399 
03400         Page += 1;
03401         PointerPte += 1;
03402         NumberOfPages -= 1;
03403         BaseAddress = (PVOID)((PCHAR)BaseAddress + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
03404     } <span class="keywordflow">while</span> (NumberOfPages != 0);
03405 
03406     <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
03407     <a class="code" href="../../d4/d8/mi_8h.html#a162">UNLOCK_WS_AND_ADDRESS_SPACE</a> (Process);
03408     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (Vad);
03409     <a class="code" href="../../d5/d6/iosup_8c.html#a81">MmUnlockPagableImageSection</a>(<a class="code" href="../../d5/d8/ex_8h.html#a166">ExPageLockHandle</a>);
03410     <span class="keywordflow">return</span>;
03411 }
03412 
03413 
03414 PVOID
<a name="l03415"></a><a class="code" href="../../d5/d6/iosup_8c.html#a57">03415</a> <a class="code" href="../../d5/d6/iosup_8c.html#a57">MmMapIoSpace</a> (
03416      IN PHYSICAL_ADDRESS PhysicalAddress,
03417      IN SIZE_T NumberOfBytes,
03418      IN MEMORY_CACHING_TYPE CacheType
03419      )
03420 
03421 <span class="comment">/*++</span>
03422 <span class="comment"></span>
03423 <span class="comment">Routine Description:</span>
03424 <span class="comment"></span>
03425 <span class="comment">    This function maps the specified physical address into the non-pagable</span>
03426 <span class="comment">    portion of the system address space.</span>
03427 <span class="comment"></span>
03428 <span class="comment">Arguments:</span>
03429 <span class="comment"></span>
03430 <span class="comment">    PhysicalAddress - Supplies the starting physical address to map.</span>
03431 <span class="comment"></span>
03432 <span class="comment">    NumberOfBytes - Supplies the number of bytes to map.</span>
03433 <span class="comment"></span>
03434 <span class="comment">    CacheType - Supplies MmNonCached if the physical address is to be mapped</span>
03435 <span class="comment">                as non-cached, MmCached if the address should be cached, and</span>
03436 <span class="comment">                MmWriteCombined if the address should be cached and</span>
03437 <span class="comment">                write-combined as a frame buffer which is to be used only by</span>
03438 <span class="comment">                the video port driver.  All other callers should use</span>
03439 <span class="comment">                MmUSWCCached.  MmUSWCCached is available only if the PAT</span>
03440 <span class="comment">                feature is present and available.</span>
03441 <span class="comment"></span>
03442 <span class="comment">                For I/O device registers, this is usually specified</span>
03443 <span class="comment">                as MmNonCached.</span>
03444 <span class="comment"></span>
03445 <span class="comment">Return Value:</span>
03446 <span class="comment"></span>
03447 <span class="comment">    Returns the virtual address which maps the specified physical addresses.</span>
03448 <span class="comment">    The value NULL is returned if sufficient virtual address space for</span>
03449 <span class="comment">    the mapping could not be found.</span>
03450 <span class="comment"></span>
03451 <span class="comment">Environment:</span>
03452 <span class="comment"></span>
03453 <span class="comment">    Kernel mode, Should be IRQL of APC_LEVEL or below, but unfortunately</span>
03454 <span class="comment">    callers are coming in at DISPATCH_LEVEL and it's too late to change the</span>
03455 <span class="comment">    rules now.  This means you can never make this routine pagable.</span>
03456 <span class="comment"></span>
03457 <span class="comment">--*/</span>
03458 
03459 {
03460     PFN_NUMBER NumberOfPages;
03461     PFN_NUMBER PageFrameIndex;
03462     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
03463     PVOID BaseVa;
03464     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> TempPte;
03465     KIRQL OldIrql;
03466     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> TempMdl;
03467     PFN_NUMBER MdlHack[(<span class="keyword">sizeof</span>(<a class="code" href="../../d6/d7/struct__MDL.html">MDL</a>)/<span class="keyword">sizeof</span>(PFN_NUMBER)) + 1];
03468     PPFN_NUMBER Page;
03469     <a class="code" href="../../d0/d3/struct__LOCK__TRACKER.html">PLOCK_TRACKER</a> Tracker;
03470     PVOID CallingAddress;
03471     PVOID CallersCaller;
03472 <span class="preprocessor">#ifdef i386</span>
03473 <span class="preprocessor"></span>    <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
03474 <span class="preprocessor">#endif</span>
03475 <span class="preprocessor"></span>
03476 <span class="preprocessor">#if !defined (_X86_)</span>
03477 <span class="preprocessor"></span>    CallingAddress = (PVOID)_ReturnAddress();
03478     CallersCaller = (PVOID)0;
03479 <span class="preprocessor">#endif</span>
03480 <span class="preprocessor"></span>
03481     <span class="comment">//</span>
03482     <span class="comment">// For compatibility for when CacheType used to be passed as a BOOLEAN</span>
03483     <span class="comment">// mask off the upper bits (TRUE == MmCached, FALSE == MmNonCached).</span>
03484     <span class="comment">//</span>
03485 
03486     CacheType &amp;= 0xFF;
03487 
03488     <span class="keywordflow">if</span> (CacheType &gt;= <a class="code" href="../../d4/d9/ke_8h.html#a413a254">MmMaximumCacheType</a>) {
03489         <span class="keywordflow">return</span> (<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
03490     }
03491 
03492 <span class="preprocessor">#if defined (i386) &amp;&amp; !defined (_X86PAE_)</span>
03493 <span class="preprocessor"></span>    <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PhysicalAddress.HighPart == 0);
03494 <span class="preprocessor">#endif</span>
03495 <span class="preprocessor"></span>
03496     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (NumberOfBytes != 0);
03497     NumberOfPages = <a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a> (PhysicalAddress.LowPart,
03498                                            NumberOfBytes);
03499 
03500     PointerPte = <a class="code" href="../../d0/d9/sysptes_8c.html#a25">MiReserveSystemPtes</a>((ULONG)NumberOfPages,
03501                                      <a class="code" href="../../d4/d8/mi_8h.html#a1003a769">SystemPteSpace</a>,
03502                                      <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a58">MM_COLOR_ALIGNMENT</a>,
03503                                      (PhysicalAddress.LowPart &amp;
03504                                                        <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a59">MM_COLOR_MASK_VIRTUAL</a>),
03505                                      <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
03506     <span class="keywordflow">if</span> (PointerPte == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03507         <span class="keywordflow">return</span>(<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
03508     }
03509 
03510     BaseVa = (PVOID)<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPte);
03511     BaseVa = (PVOID)((PCHAR)BaseVa + <a class="code" href="../../d2/d1/mm_8h.html#a6">BYTE_OFFSET</a>(PhysicalAddress.LowPart));
03512 
03513     TempPte = <a class="code" href="../../d4/d2/datalpha_8c.html#a2">ValidKernelPte</a>;
03514 
03515 <span class="preprocessor">#ifdef i386</span>
03516 <span class="preprocessor"></span>    <span class="comment">//</span>
03517     <span class="comment">// Set the physical range to proper caching type.  If the PAT feature</span>
03518     <span class="comment">// is supported, then set the caching type in the PTE, otherwise modify</span>
03519     <span class="comment">// the MTRRs if applicable.  If the cache type is MmUSWCCached and the</span>
03520     <span class="comment">// PAT is not supported then fail the call.</span>
03521     <span class="comment">//</span>
03522 
03523     <span class="keywordflow">if</span> (<a class="code" href="../../d4/d9/ke_8h.html#a137">KeFeatureBits</a> &amp; <a class="code" href="../../d5/d3/i386_8h.html#a10">KF_PAT</a>) {
03524         <span class="keywordflow">if</span> ((CacheType == <a class="code" href="../../d4/d9/ke_8h.html#a413a250">MmWriteCombined</a>) || (CacheType == <a class="code" href="../../d4/d9/ke_8h.html#a413a253">MmUSWCCached</a>)) {
03525             <span class="keywordflow">if</span> (<a class="code" href="../../d6/d8/mi386_8h.html#a204">MiWriteCombiningPtes</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
03526                 <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a111">MI_SET_PTE_WRITE_COMBINE</a>(TempPte);
03527                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
03528             } <span class="keywordflow">else</span> {
03529                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_UNSUCCESSFUL;
03530             }
03531         } <span class="keywordflow">else</span> {
03532 
03533             <span class="comment">//</span>
03534             <span class="comment">// For Non-MmFrameBufferCaching type use existing mm macros.</span>
03535             <span class="comment">//</span>
03536 
03537             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
03538         }
03539     } <span class="keywordflow">else</span> {
03540 
03541         <span class="comment">// Set the MTRRs if possible.</span>
03542 
03543         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d8/d4/mtrr_8c.html#a32">KeSetPhysicalCacheTypeRange</a>(
03544                     PhysicalAddress,
03545                     NumberOfBytes,
03546                     CacheType
03547                     );
03548     }
03549 
03550     <span class="comment">//</span>
03551     <span class="comment">// If range could not be set, determine what to do</span>
03552     <span class="comment">//</span>
03553 
03554     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
03555 
03556         <span class="keywordflow">if</span> ((<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_NOT_SUPPORTED) &amp;&amp;
03557             ((CacheType == <a class="code" href="../../d4/d9/ke_8h.html#a413a248">MmNonCached</a>) || (CacheType == <a class="code" href="../../d4/d9/ke_8h.html#a413a249">MmCached</a>))) {
03558 
03559             <span class="comment">//</span>
03560             <span class="comment">// The range may not have been set into the proper cache</span>
03561             <span class="comment">// type.  If the range is either MmNonCached or MmCached just</span>
03562             <span class="comment">// continue as the PTE will be marked properly.</span>
03563             <span class="comment">//</span>
03564 
03565             NOTHING;
03566 
03567         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_UNSUCCESSFUL  &amp;&amp;  CacheType == <a class="code" href="../../d4/d9/ke_8h.html#a413a249">MmCached</a>) {
03568 
03569             <span class="comment">//</span>
03570             <span class="comment">// If setting a range to Cached was unsuccessful things are not</span>
03571             <span class="comment">// optimal, but not fatal.  The range can be returned to the</span>
03572             <span class="comment">// caller and it will have whatever caching type it has - possibly</span>
03573             <span class="comment">// something below fully cached.</span>
03574             <span class="comment">//</span>
03575 
03576             NOTHING;
03577 
03578         } <span class="keywordflow">else</span> {
03579 
03580             <span class="comment">//</span>
03581             <span class="comment">// If there's still a problem, fail the request.</span>
03582             <span class="comment">//</span>
03583 
03584             <a class="code" href="../../d0/d9/sysptes_8c.html#a26">MiReleaseSystemPtes</a>(PointerPte, NumberOfPages, <a class="code" href="../../d4/d8/mi_8h.html#a1003a769">SystemPteSpace</a>);
03585 
03586             <span class="keywordflow">return</span>(<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
03587          }
03588     }
03589 <span class="preprocessor">#endif</span>
03590 <span class="preprocessor"></span>
03591     <span class="keywordflow">if</span> (CacheType == <a class="code" href="../../d4/d9/ke_8h.html#a413a248">MmNonCached</a>) {
03592         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a118">MI_DISABLE_CACHING</a> (TempPte);
03593     }
03594 
03595 <span class="preprocessor">#if defined(_IA64_)</span>
03596 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (CacheType != <a class="code" href="../../d4/d9/ke_8h.html#a413a249">MmCached</a>) { 
03597         <a class="code" href="../../d0/d6/ppc_2flushtb_8c.html#a0">KeFlushEntireTb</a>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
03598     }
03599 <span class="preprocessor">#endif</span>
03600 <span class="preprocessor"></span>
03601     PageFrameIndex = (PFN_NUMBER)(PhysicalAddress.QuadPart &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
03602 
03603     <span class="keywordflow">do</span> {
03604         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 0);
03605         TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber = PageFrameIndex;
03606         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a186">MI_WRITE_VALID_PTE</a> (PointerPte, TempPte);
03607         PointerPte += 1;
03608         PageFrameIndex += 1;
03609         NumberOfPages -= 1;
03610     } <span class="keywordflow">while</span> (NumberOfPages != 0);
03611 
03612 <span class="preprocessor">#if defined(i386)</span>
03613 <span class="preprocessor"></span>    <span class="comment">//</span>
03614     <span class="comment">// WriteCombined is a non self-snooping memory type.  This memory type</span>
03615     <span class="comment">// requires a writeback invalidation of all the caches on all processors</span>
03616     <span class="comment">// and each accompanying TB flush if the PAT is supported.</span>
03617     <span class="comment">//</span>
03618 
03619     <span class="keywordflow">if</span> ((<a class="code" href="../../d4/d9/ke_8h.html#a137">KeFeatureBits</a> &amp; <a class="code" href="../../d5/d3/i386_8h.html#a10">KF_PAT</a>) &amp;&amp; ((CacheType == <a class="code" href="../../d4/d9/ke_8h.html#a413a250">MmWriteCombined</a>)
03620         || (CacheType == <a class="code" href="../../d4/d9/ke_8h.html#a413a253">MmUSWCCached</a>)) &amp;&amp; (<a class="code" href="../../d6/d8/mi386_8h.html#a204">MiWriteCombiningPtes</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>)) {
03621             <a class="code" href="../../d0/d6/ppc_2flushtb_8c.html#a0">KeFlushEntireTb</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
03622             <a class="code" href="../../d0/d5/i386_2flush_8c.html#a2">KeInvalidateAllCaches</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
03623     }
03624 <span class="preprocessor">#endif</span>
03625 <span class="preprocessor"></span>
03626 <span class="preprocessor">#if defined(_IA64_)</span>
03627 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (CacheType != <a class="code" href="../../d4/d9/ke_8h.html#a413a249">MmCached</a>) {
03628         <a class="code" href="../../d2/d9/miia64_8h.html#a318">MiSweepCacheMachineDependent</a>(BaseVa, NumberOfBytes, CacheType);
03629     }
03630 <span class="preprocessor">#endif</span>
03631 <span class="preprocessor"></span>
03632     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a37">MmTrackPtes</a> != 0) {
03633 
03634         <span class="comment">//</span>
03635         <span class="comment">// First free any zombie blocks as no locks are being held.</span>
03636         <span class="comment">//</span>
03637 
03638         <a class="code" href="../../d5/d6/iosup_8c.html#a35">MiReleaseDeadPteTrackers</a> ();
03639 
03640         Tracker = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a> (<a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
03641                                          <span class="keyword">sizeof</span> (<a class="code" href="../../d7/d1/struct__PTE__TRACKER.html">PTE_TRACKER</a>),
03642                                          'ySmM');
03643 
03644         <span class="keywordflow">if</span> (Tracker != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03645 <span class="preprocessor">#if defined (_X86_)</span>
03646 <span class="preprocessor"></span>            <a class="code" href="../../d5/d2/ppc_2getcalr_8c.html#a0">RtlGetCallersAddress</a>(&amp;CallingAddress, &amp;CallersCaller);
03647 <span class="preprocessor">#endif</span>
03648 <span class="preprocessor"></span>
03649             TempMdl = (<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>) &amp;MdlHack;
03650             TempMdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o4">MappedSystemVa</a> = BaseVa;
03651             TempMdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o5">StartVa</a> = (PVOID)(ULONG_PTR)PhysicalAddress.QuadPart;
03652             TempMdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o7">ByteOffset</a> = <a class="code" href="../../d2/d1/mm_8h.html#a6">BYTE_OFFSET</a>(PhysicalAddress.LowPart);
03653             TempMdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o6">ByteCount</a> = (ULONG)NumberOfBytes;
03654     
03655             Page = (PPFN_NUMBER) (TempMdl + 1);
03656             Page = (PPFN_NUMBER)-1;
03657     
03658             <a class="code" href="../../d4/d8/mi_8h.html#a117">MiLockSystemSpace</a>(OldIrql);
03659     
03660             <a class="code" href="../../d5/d6/iosup_8c.html#a33">MiInsertPteTracker</a> (Tracker,
03661                                 TempMdl,
03662                                 <a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a> (PhysicalAddress.LowPart,
03663                                                NumberOfBytes),
03664                                 CallingAddress,
03665                                 CallersCaller);
03666     
03667             <a class="code" href="../../d4/d8/mi_8h.html#a118">MiUnlockSystemSpace</a>(OldIrql);
03668         }
03669         <span class="keywordflow">else</span> {
03670             <a class="code" href="../../d5/d6/iosup_8c.html#a9">MiTrackPtesAborted</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03671         }
03672     }
03673     
03674     <span class="keywordflow">return</span> BaseVa;
03675 }
03676 
03677 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l03678"></a><a class="code" href="../../d5/d6/iosup_8c.html#a58">03678</a> <a class="code" href="../../d5/d6/iosup_8c.html#a58">MmUnmapIoSpace</a> (
03679      IN PVOID BaseAddress,
03680      IN SIZE_T NumberOfBytes
03681      )
03682 
03683 <span class="comment">/*++</span>
03684 <span class="comment"></span>
03685 <span class="comment">Routine Description:</span>
03686 <span class="comment"></span>
03687 <span class="comment">    This function unmaps a range of physical address which were previously</span>
03688 <span class="comment">    mapped via an MmMapIoSpace function call.</span>
03689 <span class="comment"></span>
03690 <span class="comment">Arguments:</span>
03691 <span class="comment"></span>
03692 <span class="comment">    BaseAddress - Supplies the base virtual address where the physical</span>
03693 <span class="comment">                  address was previously mapped.</span>
03694 <span class="comment"></span>
03695 <span class="comment">    NumberOfBytes - Supplies the number of bytes which were mapped.</span>
03696 <span class="comment"></span>
03697 <span class="comment">Return Value:</span>
03698 <span class="comment"></span>
03699 <span class="comment">    None.</span>
03700 <span class="comment"></span>
03701 <span class="comment">Environment:</span>
03702 <span class="comment"></span>
03703 <span class="comment">    Kernel mode, Should be IRQL of APC_LEVEL or below, but unfortunately</span>
03704 <span class="comment">    callers are coming in at DISPATCH_LEVEL and it's too late to change the</span>
03705 <span class="comment">    rules now.  This means you can never make this routine pagable.</span>
03706 <span class="comment"></span>
03707 <span class="comment">--*/</span>
03708 
03709 {
03710     PFN_NUMBER NumberOfPages;
03711     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> FirstPte;
03712     KIRQL OldIrql;
03713     PVOID PoolBlock;
03714 
03715     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
03716     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (NumberOfBytes != 0);
03717     NumberOfPages = <a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a> (BaseAddress, NumberOfBytes);
03718     FirstPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (BaseAddress);
03719     <a class="code" href="../../d0/d9/sysptes_8c.html#a26">MiReleaseSystemPtes</a>(FirstPte, (ULONG)NumberOfPages, <a class="code" href="../../d4/d8/mi_8h.html#a1003a769">SystemPteSpace</a>);
03720 
03721     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a37">MmTrackPtes</a> != 0) {
03722         <a class="code" href="../../d4/d8/mi_8h.html#a117">MiLockSystemSpace</a>(OldIrql);
03723 
03724         PoolBlock = <a class="code" href="../../d5/d6/iosup_8c.html#a34">MiRemovePteTracker</a> (<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
03725                                         FirstPte,
03726                                         NumberOfPages);
03727         <a class="code" href="../../d4/d8/mi_8h.html#a118">MiUnlockSystemSpace</a>(OldIrql);
03728 
03729         <span class="comment">//</span>
03730         <span class="comment">// Can't free the pool block here because we may be getting called</span>
03731         <span class="comment">// from the fault path in MiWaitForInPageComplete holding the PFN</span>
03732         <span class="comment">// lock.  Queue the block for later release.</span>
03733         <span class="comment">//</span>
03734 
03735         <span class="keywordflow">if</span> (PoolBlock) {
03736             <a class="code" href="../../d5/d6/iosup_8c.html#a36">MiInsertDeadPteTrackingBlock</a> (PoolBlock);
03737         }
03738     }
03739 
03740     <span class="keywordflow">return</span>;
03741 }
03742 
03743 PVOID
<a name="l03744"></a><a class="code" href="../../d5/d6/iosup_8c.html#a59">03744</a> <a class="code" href="../../d5/d6/iosup_8c.html#a59">MmAllocateContiguousMemorySpecifyCache</a> (
03745     IN SIZE_T NumberOfBytes,
03746     IN PHYSICAL_ADDRESS LowestAcceptableAddress,
03747     IN PHYSICAL_ADDRESS HighestAcceptableAddress,
03748     IN PHYSICAL_ADDRESS BoundaryAddressMultiple OPTIONAL,
03749     IN MEMORY_CACHING_TYPE CacheType
03750     )
03751 
03752 <span class="comment">/*++</span>
03753 <span class="comment"></span>
03754 <span class="comment">Routine Description:</span>
03755 <span class="comment"></span>
03756 <span class="comment">    This function allocates a range of physically contiguous non-cached,</span>
03757 <span class="comment">    non-paged memory.  This is accomplished by using MmAllocateContiguousMemory</span>
03758 <span class="comment">    which uses nonpaged pool virtual addresses to map the found memory chunk.</span>
03759 <span class="comment"></span>
03760 <span class="comment">    Then this function establishes another map to the same physical addresses,</span>
03761 <span class="comment">    but this alternate map is initialized as non-cached.  All references by</span>
03762 <span class="comment">    our caller will be done through this alternate map.</span>
03763 <span class="comment"></span>
03764 <span class="comment">    This routine is designed to be used by a driver's initialization</span>
03765 <span class="comment">    routine to allocate a contiguous block of noncached physical memory for</span>
03766 <span class="comment">    things like the AGP GART.</span>
03767 <span class="comment"></span>
03768 <span class="comment">Arguments:</span>
03769 <span class="comment"></span>
03770 <span class="comment">    NumberOfBytes - Supplies the number of bytes to allocate.</span>
03771 <span class="comment"></span>
03772 <span class="comment">    LowestAcceptableAddress - Supplies the lowest physical address</span>
03773 <span class="comment">                              which is valid for the allocation.  For</span>
03774 <span class="comment">                              example, if the device can only reference</span>
03775 <span class="comment">                              physical memory in the 8M to 16MB range, this</span>
03776 <span class="comment">                              value would be set to 0x800000 (8Mb).</span>
03777 <span class="comment"></span>
03778 <span class="comment">    HighestAcceptableAddress - Supplies the highest physical address</span>
03779 <span class="comment">                               which is valid for the allocation.  For</span>
03780 <span class="comment">                               example, if the device can only reference</span>
03781 <span class="comment">                               physical memory below 16MB, this</span>
03782 <span class="comment">                               value would be set to 0xFFFFFF (16Mb - 1).</span>
03783 <span class="comment"></span>
03784 <span class="comment">    BoundaryAddressMultiple - Supplies the physical address multiple this</span>
03785 <span class="comment">                              allocation must not cross.</span>
03786 <span class="comment"></span>
03787 <span class="comment">Return Value:</span>
03788 <span class="comment"></span>
03789 <span class="comment">    NULL - a contiguous range could not be found to satisfy the request.</span>
03790 <span class="comment"></span>
03791 <span class="comment">    NON-NULL - Returns a pointer (virtual address in the nonpaged portion</span>
03792 <span class="comment">               of the system) to the allocated physically contiguous</span>
03793 <span class="comment">               memory.</span>
03794 <span class="comment"></span>
03795 <span class="comment">Environment:</span>
03796 <span class="comment"></span>
03797 <span class="comment">    Kernel mode, IRQL of DISPATCH_LEVEL or below.</span>
03798 <span class="comment"></span>
03799 <span class="comment">--*/</span>
03800 
03801 {
03802     PVOID BaseAddress;
03803     PVOID NewVa;
03804     PFN_NUMBER LowestPfn;
03805     PFN_NUMBER HighestPfn;
03806     PFN_NUMBER BoundaryPfn;
03807     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
03808     PHYSICAL_ADDRESS PhysicalAddress;
03809     PVOID CallingAddress;
03810 
03811 <span class="preprocessor">#if defined (_X86_)</span>
03812 <span class="preprocessor"></span>    PVOID CallersCaller;
03813 
03814     <a class="code" href="../../d5/d2/ppc_2getcalr_8c.html#a0">RtlGetCallersAddress</a>(&amp;CallingAddress, &amp;CallersCaller);
03815 <span class="preprocessor">#else</span>
03816 <span class="preprocessor"></span>    CallingAddress = (PVOID)_ReturnAddress();
03817 <span class="preprocessor">#endif</span>
03818 <span class="preprocessor"></span>
03819     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (NumberOfBytes != 0);
03820 
03821     LowestPfn = (PFN_NUMBER)(LowestAcceptableAddress.QuadPart &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
03822     <span class="keywordflow">if</span> (<a class="code" href="../../d2/d1/mm_8h.html#a6">BYTE_OFFSET</a>(LowestAcceptableAddress.LowPart)) {
03823         LowestPfn += 1;
03824     }
03825 
03826     <span class="keywordflow">if</span> (<a class="code" href="../../d2/d1/mm_8h.html#a6">BYTE_OFFSET</a>(BoundaryAddressMultiple.LowPart)) {
03827         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03828     }
03829 
03830     BoundaryPfn = (PFN_NUMBER)(BoundaryAddressMultiple.QuadPart &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
03831 
03832     HighestPfn = (PFN_NUMBER)(HighestAcceptableAddress.QuadPart &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
03833 
03834     BaseAddress = <a class="code" href="../../d5/d6/iosup_8c.html#a28">MiAllocateContiguousMemory</a>(NumberOfBytes,
03835                                              LowestPfn,
03836                                              HighestPfn,
03837                                              BoundaryPfn,
03838                                              CallingAddress);
03839 
03840     <span class="keywordflow">if</span> (BaseAddress) {
03841 
03842         <span class="keywordflow">if</span> (CacheType != <a class="code" href="../../d4/d9/ke_8h.html#a413a249">MmCached</a>) {
03843 
03844             <span class="comment">//</span>
03845             <span class="comment">// We have an address range but it's cached.  Create an uncached</span>
03846             <span class="comment">// alternate mapping now.  Stash the original virtual address at the</span>
03847             <span class="comment">// end of the mapped range so we can unmap the nonpaged pool VAs and</span>
03848             <span class="comment">// the actual pages when the caller frees the memory.</span>
03849             <span class="comment">//</span>
03850 
03851             PhysicalAddress = <a class="code" href="../../d5/d6/iosup_8c.html#a68">MmGetPhysicalAddress</a> (BaseAddress);
03852 
03853             NewVa = <a class="code" href="../../d5/d6/iosup_8c.html#a57">MmMapIoSpace</a> (PhysicalAddress,
03854                                   NumberOfBytes + (2 * <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>),
03855                                   CacheType);
03856 
03857             <span class="keywordflow">if</span> (NewVa) {
03858 
03859                 PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(NewVa);
03860 
03861                 PointerPte += ((NumberOfBytes + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1) &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
03862                 PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long = (ULONG_PTR)BaseAddress;
03863 
03864                 PointerPte += 1;
03865                 PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long = NumberOfBytes;
03866 
03867                 <a class="code" href="../../d3/d5/ppc_2flush_8c.html#a6">KeSweepDcache</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
03868                 BaseAddress = NewVa;
03869             }
03870             <span class="keywordflow">else</span> {
03871                 <a class="code" href="../../d5/d6/iosup_8c.html#a66">MmFreeContiguousMemory</a> (BaseAddress);
03872                 BaseAddress = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03873             }
03874         }
03875     }
03876 
03877     <span class="keywordflow">return</span> BaseAddress;
03878 }
03879 
03880 PVOID
<a name="l03881"></a><a class="code" href="../../d5/d6/iosup_8c.html#a60">03881</a> <a class="code" href="../../d5/d6/iosup_8c.html#a60">MmAllocateContiguousMemory</a> (
03882     IN SIZE_T NumberOfBytes,
03883     IN PHYSICAL_ADDRESS HighestAcceptableAddress
03884     )
03885 
03886 <span class="comment">/*++</span>
03887 <span class="comment"></span>
03888 <span class="comment">Routine Description:</span>
03889 <span class="comment"></span>
03890 <span class="comment">    This function allocates a range of physically contiguous non-paged pool.</span>
03891 <span class="comment"></span>
03892 <span class="comment">    This routine is designed to be used by a driver's initialization</span>
03893 <span class="comment">    routine to allocate a contiguous block of physical memory for</span>
03894 <span class="comment">    issuing DMA requests from.</span>
03895 <span class="comment"></span>
03896 <span class="comment">Arguments:</span>
03897 <span class="comment"></span>
03898 <span class="comment">    NumberOfBytes - Supplies the number of bytes to allocate.</span>
03899 <span class="comment"></span>
03900 <span class="comment">    HighestAcceptableAddress - Supplies the highest physical address</span>
03901 <span class="comment">                               which is valid for the allocation.  For</span>
03902 <span class="comment">                               example, if the device can only reference</span>
03903 <span class="comment">                               physical memory in the lower 16MB this</span>
03904 <span class="comment">                               value would be set to 0xFFFFFF (16Mb - 1).</span>
03905 <span class="comment"></span>
03906 <span class="comment">Return Value:</span>
03907 <span class="comment"></span>
03908 <span class="comment">    NULL - a contiguous range could not be found to satisfy the request.</span>
03909 <span class="comment"></span>
03910 <span class="comment">    NON-NULL - Returns a pointer (virtual address in the nonpaged portion</span>
03911 <span class="comment">               of the system) to the allocated physically contiguous</span>
03912 <span class="comment">               memory.</span>
03913 <span class="comment"></span>
03914 <span class="comment">Environment:</span>
03915 <span class="comment"></span>
03916 <span class="comment">    Kernel mode, IRQL of DISPATCH_LEVEL or below.</span>
03917 <span class="comment"></span>
03918 <span class="comment">--*/</span>
03919 
03920 {
03921     PFN_NUMBER HighestPfn;
03922     PVOID CallingAddress;
03923 
03924 <span class="preprocessor">#if defined (_X86_)</span>
03925 <span class="preprocessor"></span>    PVOID CallersCaller;
03926 
03927     <a class="code" href="../../d5/d2/ppc_2getcalr_8c.html#a0">RtlGetCallersAddress</a>(&amp;CallingAddress, &amp;CallersCaller);
03928 <span class="preprocessor">#else</span>
03929 <span class="preprocessor"></span>    CallingAddress = (PVOID)_ReturnAddress();
03930 <span class="preprocessor">#endif</span>
03931 <span class="preprocessor"></span>
03932     HighestPfn = (PFN_NUMBER)(HighestAcceptableAddress.QuadPart &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
03933 
03934     <span class="keywordflow">return</span> <a class="code" href="../../d5/d6/iosup_8c.html#a28">MiAllocateContiguousMemory</a>(NumberOfBytes,
03935                                       0,
03936                                       HighestPfn,
03937                                       0,
03938                                       CallingAddress);
03939 }
03940 
03941 PVOID
<a name="l03942"></a><a class="code" href="../../d5/d6/iosup_8c.html#a61">03942</a> <a class="code" href="../../d5/d6/iosup_8c.html#a61">MmAllocateIndependentPages</a>(
03943     IN SIZE_T NumberOfBytes
03944     )
03945 
03946 <span class="comment">/*++</span>
03947 <span class="comment"></span>
03948 <span class="comment">Routine Description:</span>
03949 <span class="comment"></span>
03950 <span class="comment">    This function allocates a range of virtually contiguous nonpaged pages that</span>
03951 <span class="comment">    can have independent page protections applied to each page.</span>
03952 <span class="comment"></span>
03953 <span class="comment">Arguments:</span>
03954 <span class="comment"></span>
03955 <span class="comment">    NumberOfBytes - Supplies the number of bytes to allocate.</span>
03956 <span class="comment"></span>
03957 <span class="comment">Return Value:</span>
03958 <span class="comment"></span>
03959 <span class="comment">    The virtual address of the memory or NULL if none could be allocated.</span>
03960 <span class="comment"></span>
03961 <span class="comment">Environment:</span>
03962 <span class="comment"></span>
03963 <span class="comment">    Kernel mode, IRQL of APC_LEVEL or below.</span>
03964 <span class="comment"></span>
03965 <span class="comment">--*/</span>
03966 
03967 {
03968     PFN_NUMBER NumberOfPages;
03969     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
03970     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> TempPte;
03971     PFN_NUMBER PageFrameIndex;
03972     PVOID BaseAddress;
03973     KIRQL OldIrql;
03974 
03975     NumberOfPages = <a class="code" href="../../d2/d1/mm_8h.html#a5">BYTES_TO_PAGES</a> (NumberOfBytes);
03976 
03977     PointerPte = <a class="code" href="../../d0/d9/sysptes_8c.html#a25">MiReserveSystemPtes</a> ((ULONG)NumberOfPages,
03978                                       <a class="code" href="../../d4/d8/mi_8h.html#a1003a769">SystemPteSpace</a>,
03979                                       0,
03980                                       0,
03981                                       <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
03982     <span class="keywordflow">if</span> (PointerPte == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03983         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03984     }
03985 
03986     BaseAddress = (PVOID)<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPte);
03987 
03988     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
03989 
03990     <span class="keywordflow">if</span> ((SPFN_NUMBER)NumberOfPages &gt; <a class="code" href="../../d4/d8/mi_8h.html#a323">MI_NONPAGABLE_MEMORY_AVAILABLE</a>()) {
03991         <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
03992         <a class="code" href="../../d0/d9/sysptes_8c.html#a26">MiReleaseSystemPtes</a> (PointerPte, (ULONG)NumberOfPages, <a class="code" href="../../d4/d8/mi_8h.html#a1003a769">SystemPteSpace</a>);
03993         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03994     }
03995 
03996     <a class="code" href="../../d8/d5/kddata_8c.html#a42">MmResidentAvailablePages</a> -= NumberOfPages;
03997     <a class="code" href="../../d4/d8/mi_8h.html#a322">MM_BUMP_COUNTER</a>(28, NumberOfPages);
03998 
03999     <span class="keywordflow">do</span> {
04000         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 0);
04001         <a class="code" href="../../d7/d5/pfnlist_8c.html#a13">MiEnsureAvailablePageOrWait</a> (<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
04002         PageFrameIndex = <a class="code" href="../../d7/d5/pfnlist_8c.html#a15">MiRemoveAnyPage</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a124">MI_GET_PAGE_COLOR_FROM_PTE</a> (PointerPte));
04003 
04004         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a105">MI_MAKE_VALID_PTE</a> (TempPte,
04005                            PageFrameIndex,
04006                            <a class="code" href="../../d4/d8/mi_8h.html#a39">MM_READWRITE</a>,
04007                            PointerPte);
04008 
04009         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a112">MI_SET_PTE_DIRTY</a> (TempPte);
04010         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a186">MI_WRITE_VALID_PTE</a> (PointerPte, TempPte);
04011         <a class="code" href="../../d8/d2/pagfault_8c.html#a22">MiInitializePfn</a> (PageFrameIndex, PointerPte, 1);
04012 
04013         PointerPte += 1;
04014         NumberOfPages -= 1;
04015     } <span class="keywordflow">while</span> (NumberOfPages != 0);
04016 
04017     <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
04018 
04019     <a class="code" href="../../d6/d1/mmquota_8c.html#a18">MiChargeCommitmentCantExpand</a> (NumberOfPages, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
04020 
04021     <a class="code" href="../../d4/d8/mi_8h.html#a254">MM_TRACK_COMMIT</a> (<a class="code" href="../../d4/d8/mi_8h.html#a265">MM_DBG_COMMIT_INDEPENDENT_PAGES</a>, NumberOfPages);
04022 
04023     <span class="keywordflow">return</span> BaseAddress;
04024 }
04025 
04026 BOOLEAN
<a name="l04027"></a><a class="code" href="../../d5/d6/iosup_8c.html#a62">04027</a> <a class="code" href="../../d5/d6/iosup_8c.html#a62">MmSetPageProtection</a>(
04028     IN PVOID VirtualAddress,
04029     IN SIZE_T NumberOfBytes,
04030     IN ULONG NewProtect
04031     )
04032 
04033 <span class="comment">/*++</span>
04034 <span class="comment"></span>
04035 <span class="comment">Routine Description:</span>
04036 <span class="comment"></span>
04037 <span class="comment">    This function sets the specified virtual address range to the desired</span>
04038 <span class="comment">    protection.  This assumes that the virtual addresses are backed by PTEs</span>
04039 <span class="comment">    which can be set (ie: not in kseg0 or large pages).</span>
04040 <span class="comment"></span>
04041 <span class="comment">Arguments:</span>
04042 <span class="comment"></span>
04043 <span class="comment">    VirtualAddress - Supplies the start address to protect.</span>
04044 <span class="comment"></span>
04045 <span class="comment">    NumberOfBytes - Supplies the number of bytes to set.</span>
04046 <span class="comment"></span>
04047 <span class="comment">    NewProtect - Supplies the protection to set the pages to (PAGE_XX).</span>
04048 <span class="comment"></span>
04049 <span class="comment">Return Value:</span>
04050 <span class="comment"></span>
04051 <span class="comment">    TRUE if the protection was applied, FALSE if not.</span>
04052 <span class="comment"></span>
04053 <span class="comment">Environment:</span>
04054 <span class="comment"></span>
04055 <span class="comment">    Kernel mode, IRQL of APC_LEVEL or below.</span>
04056 <span class="comment"></span>
04057 <span class="comment">--*/</span>
04058 
04059 {
04060     PFN_NUMBER i;
04061     PFN_NUMBER NumberOfPages;
04062     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
04063     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> TempPte;
04064     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> NewPteContents;
04065     KIRQL OldIrql;
04066     ULONG ProtectionMask;
04067 
04068     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a>(VirtualAddress)) {
04069         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04070     }
04071 
04072     <span class="keywordflow">try</span> {
04073         ProtectionMask = <a class="code" href="../../d0/d2/mmsup_8c.html#a5">MiMakeProtectionMask</a> (NewProtect);
04074     } except (<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
04075         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04076     }
04077 
04078     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (VirtualAddress);
04079     NumberOfPages = <a class="code" href="../../d2/d1/mm_8h.html#a5">BYTES_TO_PAGES</a> (NumberOfBytes);
04080 
04081     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
04082 
04083     <span class="keywordflow">for</span> (i = 0; i &lt; NumberOfPages; i += 1) {
04084         TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long = PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long;
04085 
04086         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a105">MI_MAKE_VALID_PTE</a> (NewPteContents,
04087                            TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber,
04088                            ProtectionMask,
04089                            PointerPte);
04090 
04091         <a class="code" href="../../d0/d6/ppc_2flushtb_8c.html#a2">KeFlushSingleTb</a> ((PVOID)((PUCHAR)VirtualAddress + (i &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>)),
04092                          <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
04093                          <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
04094                          (PHARDWARE_PTE)PointerPte,
04095                          NewPteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Flush);
04096 
04097         PointerPte += 1;
04098     }
04099 
04100     <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
04101 
04102     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04103 }
04104 
04105 
04106 PVOID
<a name="l04107"></a><a class="code" href="../../d5/d6/iosup_8c.html#a28">04107</a> <a class="code" href="../../d5/d6/iosup_8c.html#a28">MiAllocateContiguousMemory</a> (
04108     IN SIZE_T NumberOfBytes,
04109     IN PFN_NUMBER LowestAcceptablePfn,
04110     IN PFN_NUMBER HighestAcceptablePfn,
04111     IN PFN_NUMBER BoundaryPfn,
04112     PVOID CallingAddress
04113     )
04114 
04115 <span class="comment">/*++</span>
04116 <span class="comment"></span>
04117 <span class="comment">Routine Description:</span>
04118 <span class="comment"></span>
04119 <span class="comment">    This function allocates a range of physically contiguous non-paged</span>
04120 <span class="comment">    pool.  It relies on the fact that non-paged pool is built at</span>
04121 <span class="comment">    system initialization time from a contiguous range of physical</span>
04122 <span class="comment">    memory.  It allocates the specified size of non-paged pool and</span>
04123 <span class="comment">    then checks to ensure it is contiguous as pool expansion does</span>
04124 <span class="comment">    not maintain the contiguous nature of non-paged pool.</span>
04125 <span class="comment"></span>
04126 <span class="comment">    This routine is designed to be used by a driver's initialization</span>
04127 <span class="comment">    routine to allocate a contiguous block of physical memory for</span>
04128 <span class="comment">    issuing DMA requests from.</span>
04129 <span class="comment"></span>
04130 <span class="comment">Arguments:</span>
04131 <span class="comment"></span>
04132 <span class="comment">    NumberOfBytes - Supplies the number of bytes to allocate.</span>
04133 <span class="comment"></span>
04134 <span class="comment">    LowestAcceptablePfn - Supplies the lowest page frame number</span>
04135 <span class="comment">                          which is valid for the allocation.</span>
04136 <span class="comment"></span>
04137 <span class="comment">    HighestAcceptablePfn - Supplies the highest page frame number</span>
04138 <span class="comment">                           which is valid for the allocation.</span>
04139 <span class="comment"></span>
04140 <span class="comment">    BoundaryPfn - Supplies the page frame number multiple the allocation must</span>
04141 <span class="comment">                  not cross.  0 indicates it can cross any boundary.</span>
04142 <span class="comment"></span>
04143 <span class="comment">    CallingAddress - Supplies the calling address of the allocator.</span>
04144 <span class="comment"></span>
04145 <span class="comment">Return Value:</span>
04146 <span class="comment"></span>
04147 <span class="comment">    NULL - a contiguous range could not be found to satisfy the request.</span>
04148 <span class="comment"></span>
04149 <span class="comment">    NON-NULL - Returns a pointer (virtual address in the nonpaged portion</span>
04150 <span class="comment">               of the system) to the allocated physically contiguous</span>
04151 <span class="comment">               memory.</span>
04152 <span class="comment"></span>
04153 <span class="comment">Environment:</span>
04154 <span class="comment"></span>
04155 <span class="comment">    Kernel mode, IRQL of DISPATCH_LEVEL or below.</span>
04156 <span class="comment"></span>
04157 <span class="comment">--*/</span>
04158 
04159 {
04160     PVOID BaseAddress;
04161     PFN_NUMBER SizeInPages;
04162     PFN_NUMBER LowestPfn;
04163     PFN_NUMBER HighestPfn;
04164     PFN_NUMBER i;
04165 
04166     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (NumberOfBytes != 0);
04167 
04168 <span class="preprocessor">#if defined (_X86PAE_)</span>
04169 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/iosup_8c.html#a15">MiNoLowMemory</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
04170         <span class="keywordflow">if</span> (HighestAcceptablePfn &lt;= 0xFFFFF) {
04171             <span class="keywordflow">return</span> <a class="code" href="../../d4/d5/procsup_8c.html#a27">MiAllocateLowMemory</a> (NumberOfBytes,
04172                                         LowestAcceptablePfn,
04173                                         HighestAcceptablePfn,
04174                                         BoundaryPfn,
04175                                         CallingAddress,
04176                                         'tnoC');
04177         }
04178         LowestPfn = 0x100000;
04179     }
04180 <span class="preprocessor">#endif</span>
04181 <span class="preprocessor"></span>
04182     BaseAddress = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a> (<a class="code" href="../../d5/d8/ex_8h.html#a329a177">NonPagedPoolCacheAligned</a>,
04183                                          NumberOfBytes,
04184                                          'mCmM');
04185 
04186     <span class="comment">//</span>
04187     <span class="comment">// N.B. This setting of SizeInPages to exactly the request size means the</span>
04188     <span class="comment">// non-NULL return value from MiCheckForContiguousMemory is guaranteed to</span>
04189     <span class="comment">// be the BaseAddress.  If this size is ever changed, then the non-NULL</span>
04190     <span class="comment">// return value must be checked and split/returned accordingly.</span>
04191     <span class="comment">//</span>
04192 
04193     SizeInPages = <a class="code" href="../../d2/d1/mm_8h.html#a5">BYTES_TO_PAGES</a> (NumberOfBytes);
04194 
04195     LowestPfn = LowestAcceptablePfn;
04196     HighestPfn = HighestAcceptablePfn;
04197 
04198     <span class="keywordflow">if</span> (BaseAddress != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04199         <span class="keywordflow">if</span> (<a class="code" href="../../d4/d8/mi_8h.html#a795">MiCheckForContiguousMemory</a>( BaseAddress,
04200                                         SizeInPages,
04201                                         SizeInPages,
04202                                         LowestPfn,
04203                                         HighestPfn,
04204                                         BoundaryPfn)) {
04205 
04206             <span class="keywordflow">return</span> BaseAddress;
04207         }
04208 
04209         <span class="comment">//</span>
04210         <span class="comment">// The allocation from pool does not meet the contiguous</span>
04211         <span class="comment">// requirements. Free the page and see if any of the free</span>
04212         <span class="comment">// pool pages meet the requirement.</span>
04213         <span class="comment">//</span>
04214 
04215         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (BaseAddress);
04216 
04217     } <span class="keywordflow">else</span> {
04218 
04219         <span class="comment">//</span>
04220         <span class="comment">// No pool was available, return NULL.</span>
04221         <span class="comment">//</span>
04222 
04223         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04224     }
04225 
04226     <span class="keywordflow">if</span> (KeGetCurrentIrql() &gt; <a class="code" href="../../d6/d7/halmips_8h.html#a52">APC_LEVEL</a>) {
04227         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04228     }
04229 
04230     BaseAddress = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04231 
04232     i = 3;
04233 
04234     InterlockedIncrement (&amp;<a class="code" href="../../d4/d8/mi_8h.html#a598">MiDelayPageFaults</a>);
04235 
04236     <span class="keywordflow">for</span> (; ; ) {
04237         BaseAddress = <a class="code" href="../../d4/d8/mi_8h.html#a794">MiFindContiguousMemory</a> (LowestPfn,
04238                                               HighestPfn,
04239                                               BoundaryPfn,
04240                                               SizeInPages,
04241                                               CallingAddress);
04242 
04243         <span class="keywordflow">if</span> ((BaseAddress != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) || (i == 0)) {
04244             <span class="keywordflow">break</span>;
04245         }
04246 
04247         <span class="comment">//</span>
04248         <span class="comment">// Attempt to move pages to the standby list.</span>
04249         <span class="comment">//</span>
04250 
04251         <a class="code" href="../../d5/d0/wsmanage_8c.html#a47">MiEmptyAllWorkingSets</a> ();
04252         <a class="code" href="../../d6/d3/modwrite_8c.html#a57">MiFlushAllPages</a>();
04253 
04254         <a class="code" href="../../d1/d7/wait_8c.html#a2">KeDelayExecutionThread</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
04255                                 <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
04256                                 (PLARGE_INTEGER)&amp;<a class="code" href="../../d4/d8/mi_8h.html#a421">MmHalfSecond</a>);
04257 
04258         i -= 1;
04259     }
04260     InterlockedDecrement (&amp;<a class="code" href="../../d4/d8/mi_8h.html#a598">MiDelayPageFaults</a>);
04261     <span class="keywordflow">return</span> BaseAddress;
04262 }
04263 
<a name="l04264"></a><a class="code" href="../../d5/d6/iosup_8c.html#a24">04264</a> PFN_NUMBER <a class="code" href="../../d5/d6/iosup_8c.html#a24">MiLastCallLowPage</a>;
<a name="l04265"></a><a class="code" href="../../d5/d6/iosup_8c.html#a25">04265</a> PFN_NUMBER <a class="code" href="../../d5/d6/iosup_8c.html#a25">MiLastCallHighPage</a>;
<a name="l04266"></a><a class="code" href="../../d5/d6/iosup_8c.html#a26">04266</a> ULONG <a class="code" href="../../d5/d6/iosup_8c.html#a26">MiLastCallColor</a>;
04267 
04268 
04269 <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>
<a name="l04270"></a><a class="code" href="../../d5/d6/iosup_8c.html#a63">04270</a> <a class="code" href="../../d5/d6/iosup_8c.html#a63">MmAllocatePagesForMdl</a> (
04271     IN PHYSICAL_ADDRESS LowAddress,
04272     IN PHYSICAL_ADDRESS HighAddress,
04273     IN PHYSICAL_ADDRESS SkipBytes,
04274     IN SIZE_T TotalBytes
04275     )
04276 
04277 <span class="comment">/*++</span>
04278 <span class="comment"></span>
04279 <span class="comment">Routine Description:</span>
04280 <span class="comment"></span>
04281 <span class="comment">    This routine searches the PFN database for free, zeroed or standby pages</span>
04282 <span class="comment">    to satisfy the request.  This does not map the pages - it just allocates</span>
04283 <span class="comment">    them and puts them into an MDL.  It is expected that our caller will</span>
04284 <span class="comment">    map the MDL as needed.</span>
04285 <span class="comment"></span>
04286 <span class="comment">    NOTE: this routine may return an MDL mapping a smaller number of bytes</span>
04287 <span class="comment">    than the amount requested.  It is the caller's responsibility to check the</span>
04288 <span class="comment">    MDL upon return for the size actually allocated.</span>
04289 <span class="comment"></span>
04290 <span class="comment">    These pages comprise physical non-paged memory and are zero-filled.</span>
04291 <span class="comment"></span>
04292 <span class="comment">    This routine is designed to be used by an AGP driver to obtain physical</span>
04293 <span class="comment">    memory in a specified range since hardware may provide substantial</span>
04294 <span class="comment">    performance wins depending on where the backing memory is allocated.</span>
04295 <span class="comment"></span>
04296 <span class="comment">Arguments:</span>
04297 <span class="comment"></span>
04298 <span class="comment">    LowAddress - Supplies the low physical address of the first range that</span>
04299 <span class="comment">                 the allocated pages can come from.</span>
04300 <span class="comment"></span>
04301 <span class="comment">    HighAddress - Supplies the high physical address of the first range that</span>
04302 <span class="comment">                  the allocated pages can come from.</span>
04303 <span class="comment"></span>
04304 <span class="comment">    SkipBytes - Number of bytes to skip (from the Low Address) to get to the</span>
04305 <span class="comment">                next physical address range that allocated pages can come from.</span>
04306 <span class="comment"></span>
04307 <span class="comment">    TotalBytes - Supplies the number of bytes to allocate.</span>
04308 <span class="comment"></span>
04309 <span class="comment">Return Value:</span>
04310 <span class="comment"></span>
04311 <span class="comment">    MDL - An MDL mapping a range of pages in the specified range.</span>
04312 <span class="comment">          This may map less memory than the caller requested if the full amount</span>
04313 <span class="comment">          is not currently available.</span>
04314 <span class="comment"></span>
04315 <span class="comment">    NULL - No pages in the specified range OR not enough virtually contiguous</span>
04316 <span class="comment">           nonpaged pool for the MDL is available at this time.</span>
04317 <span class="comment"></span>
04318 <span class="comment">Environment:</span>
04319 <span class="comment"></span>
04320 <span class="comment">    Kernel mode, IRQL of APC_LEVEL or below.</span>
04321 <span class="comment"></span>
04322 <span class="comment">--*/</span>
04323 
04324 {
04325     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MemoryDescriptorList;
04326     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MemoryDescriptorList2;
04327     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
04328     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> PfnNextColored;
04329     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> PfnNextFlink;
04330     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> PfnLastColored;
04331     KIRQL OldIrql;
04332     PFN_NUMBER start;
04333     PFN_NUMBER count;
04334     PFN_NUMBER Page;
04335     PFN_NUMBER LastPage;
04336     PFN_NUMBER found;
04337     PFN_NUMBER BasePage;
04338     PFN_NUMBER LowPage;
04339     PFN_NUMBER HighPage;
04340     PFN_NUMBER SizeInPages;
04341     PFN_NUMBER MdlPageSpan;
04342     PFN_NUMBER SkipPages;
04343     PFN_NUMBER MaxPages;
04344     PPFN_NUMBER MdlPage;
04345     PPFN_NUMBER LastMdlPage;
04346     ULONG Color;
04347     <a class="code" href="../../d4/d1/struct__MMCOLOR__TABLES.html">PMMCOLOR_TABLES</a> ColorHead;
04348     <a class="code" href="../../d2/d1/mm_8h.html#a147">MMLISTS</a> MemoryList;
04349     PPFN_NUMBER FirstMdlPageToZero;
04350     PFN_NUMBER LowPage1;
04351     PFN_NUMBER HighPage1;
04352     LOGICAL PagePlacementOk;
04353     PFN_NUMBER PageNextColored;
04354     PFN_NUMBER PageNextFlink;
04355     PFN_NUMBER PageLastColored;
04356     <a class="code" href="../../d0/d4/struct__MMPFNLIST.html">PMMPFNLIST</a> ListHead;
04357     PPFN_NUMBER ColorAnchorsHead;
04358     PPFN_NUMBER ColorAnchor;
04359     ULONG FullAnchorCount;
04360 <span class="preprocessor">#if DBG</span>
04361 <span class="preprocessor"></span>    ULONG FinishedCount;
04362 <span class="preprocessor">#endif</span>
04363 <span class="preprocessor"></span>
04364     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (KeGetCurrentIrql() &lt;= <a class="code" href="../../d6/d7/halmips_8h.html#a52">APC_LEVEL</a>);
04365 
04366     <span class="comment">//</span>
04367     <span class="comment">// The skip increment must be a page-size multiple.</span>
04368     <span class="comment">//</span>
04369 
04370     <span class="keywordflow">if</span> (<a class="code" href="../../d2/d1/mm_8h.html#a6">BYTE_OFFSET</a>(SkipBytes.LowPart)) {
04371         <span class="keywordflow">return</span> (<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>)0;
04372     }
04373 
04374     <a class="code" href="../../d5/d6/iosup_8c.html#a76">MmLockPagableSectionByHandle</a> (<a class="code" href="../../d5/d8/ex_8h.html#a166">ExPageLockHandle</a>);
04375 
04376     LowPage = (PFN_NUMBER)(LowAddress.QuadPart &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
04377     HighPage = (PFN_NUMBER)(HighAddress.QuadPart &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
04378 
04379     <span class="comment">//</span>
04380     <span class="comment">// Maximum allocation size is constrained by the MDL ByteCount field.</span>
04381     <span class="comment">//</span>
04382 
04383     <span class="keywordflow">if</span> (TotalBytes &gt; (SIZE_T)((ULONG)(MAXULONG - <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>))) {
04384         TotalBytes = (SIZE_T)((ULONG)(MAXULONG - <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>));
04385     }
04386 
04387     SizeInPages = (PFN_NUMBER)<a class="code" href="../../d2/d1/mm_8h.html#a8">ADDRESS_AND_SIZE_TO_SPAN_PAGES</a>(0, TotalBytes);
04388 
04389     SkipPages = (PFN_NUMBER)(SkipBytes.QuadPart &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
04390 
04391     BasePage = LowPage;
04392 
04393     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
04394 
04395     MaxPages = <a class="code" href="../../d4/d8/mi_8h.html#a323">MI_NONPAGABLE_MEMORY_AVAILABLE</a>() - 1024;
04396 
04397     <span class="keywordflow">if</span> ((SPFN_NUMBER)MaxPages &lt;= 0) {
04398         SizeInPages = 0;
04399     }
04400     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (SizeInPages &gt; MaxPages) {
04401         SizeInPages = MaxPages;
04402     }
04403 
04404     <span class="keywordflow">if</span> (SizeInPages == 0) {
04405         <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
04406         <a class="code" href="../../d5/d6/iosup_8c.html#a81">MmUnlockPagableImageSection</a> (<a class="code" href="../../d5/d8/ex_8h.html#a166">ExPageLockHandle</a>);
04407         <span class="keywordflow">return</span> (<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>)0;
04408     }
04409 
04410     <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
04411 
04412 <span class="preprocessor">#if DBG</span>
04413 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (SizeInPages &lt; (PFN_NUMBER)<a class="code" href="../../d2/d1/mm_8h.html#a8">ADDRESS_AND_SIZE_TO_SPAN_PAGES</a>(0, TotalBytes)) {
04414         <span class="keywordflow">if</span> (MiPrintAwe != 0) {
04415             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"MmAllocatePagesForMdl1: unable to get %p pages, trying for %p instead\n"</span>,
04416                 <a class="code" href="../../d2/d1/mm_8h.html#a8">ADDRESS_AND_SIZE_TO_SPAN_PAGES</a>(0, TotalBytes),
04417                 SizeInPages);
04418         }
04419     }
04420 <span class="preprocessor">#endif</span>
04421 <span class="preprocessor"></span>
04422     <span class="comment">//</span>
04423     <span class="comment">// Allocate an MDL to return the pages in.</span>
04424     <span class="comment">//</span>
04425 
04426     <span class="keywordflow">do</span> {
04427         MemoryDescriptorList = <a class="code" href="../../d5/d6/iosup_8c.html#a73">MmCreateMdl</a> ((<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>)0,
04428                                             (PVOID)0,
04429                                             SizeInPages &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
04430     
04431         <span class="keywordflow">if</span> (MemoryDescriptorList != (<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>)0) {
04432             <span class="keywordflow">break</span>;
04433         }
04434         SizeInPages -= (SizeInPages &gt;&gt; 4);
04435     } <span class="keywordflow">while</span> (SizeInPages != 0);
04436 
04437     <span class="keywordflow">if</span> (MemoryDescriptorList == (<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>)0) {
04438         <a class="code" href="../../d5/d6/iosup_8c.html#a81">MmUnlockPagableImageSection</a> (<a class="code" href="../../d5/d8/ex_8h.html#a166">ExPageLockHandle</a>);
04439         <span class="keywordflow">return</span> (<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>)0;
04440     }
04441 
04442     <span class="comment">//</span>
04443     <span class="comment">// Allocate a list of colored anchors.</span>
04444     <span class="comment">//</span>
04445 
04446     ColorAnchorsHead = (PPFN_NUMBER) <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a> (<a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
04447                                                             <a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a> * <span class="keyword">sizeof</span> (PFN_NUMBER),
04448                                                             'ldmM');
04449 
04450     <span class="keywordflow">if</span> (ColorAnchorsHead == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04451         <a class="code" href="../../d5/d6/iosup_8c.html#a81">MmUnlockPagableImageSection</a> (<a class="code" href="../../d5/d8/ex_8h.html#a166">ExPageLockHandle</a>);
04452         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (MemoryDescriptorList);
04453         <span class="keywordflow">return</span> (<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>)0;
04454     }
04455 
04456     MdlPageSpan = SizeInPages;
04457 
04458     <span class="comment">//</span>
04459     <span class="comment">// Recalculate as the PFN lock was dropped.</span>
04460     <span class="comment">//</span>
04461 
04462     start = 0;
04463     found = 0;
04464 
04465     MdlPage = (PPFN_NUMBER)(MemoryDescriptorList + 1);
04466 
04467     ExAcquireFastMutex (&amp;<a class="code" href="../../d9/d3/dynmem_8c.html#a1">MmDynamicMemoryMutex</a>);
04468 
04469     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
04470 
04471     MaxPages = <a class="code" href="../../d4/d8/mi_8h.html#a323">MI_NONPAGABLE_MEMORY_AVAILABLE</a>() - 1024;
04472 
04473     <span class="keywordflow">if</span> ((SPFN_NUMBER)MaxPages &lt;= 0) {
04474         SizeInPages = 0;
04475     }
04476     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (SizeInPages &gt; MaxPages) {
04477         SizeInPages = MaxPages;
04478     }
04479 
04480     <span class="keywordflow">if</span> (SizeInPages == 0) {
04481         <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
04482         ExReleaseFastMutex (&amp;<a class="code" href="../../d9/d3/dynmem_8c.html#a1">MmDynamicMemoryMutex</a>);
04483         <a class="code" href="../../d5/d6/iosup_8c.html#a81">MmUnlockPagableImageSection</a> (<a class="code" href="../../d5/d8/ex_8h.html#a166">ExPageLockHandle</a>);
04484         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (MemoryDescriptorList);
04485         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (ColorAnchorsHead);
04486         <span class="keywordflow">return</span> (<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>)0;
04487     }
04488 
04489     <span class="comment">//</span>
04490     <span class="comment">// Ensure there is enough commit prior to allocating the pages as this</span>
04491     <span class="comment">// is not a nonpaged pool allocation but rather a dynamic MDL allocation.</span>
04492     <span class="comment">//</span>
04493 
04494     <span class="keywordflow">if</span> (<a class="code" href="../../d6/d1/mmquota_8c.html#a18">MiChargeCommitmentCantExpand</a> (SizeInPages, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
04495         <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
04496         ExReleaseFastMutex (&amp;<a class="code" href="../../d9/d3/dynmem_8c.html#a1">MmDynamicMemoryMutex</a>);
04497         <a class="code" href="../../d5/d6/iosup_8c.html#a81">MmUnlockPagableImageSection</a> (<a class="code" href="../../d5/d8/ex_8h.html#a166">ExPageLockHandle</a>);
04498         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (MemoryDescriptorList);
04499         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (ColorAnchorsHead);
04500         <span class="keywordflow">return</span> (<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>)0;
04501     }
04502 
04503     <a class="code" href="../../d4/d8/mi_8h.html#a254">MM_TRACK_COMMIT</a> (<a class="code" href="../../d4/d8/mi_8h.html#a267">MM_DBG_COMMIT_MDL_PAGES</a>, SizeInPages);
04504 
04505     <span class="keywordflow">if</span> ((<a class="code" href="../../d5/d6/iosup_8c.html#a24">MiLastCallLowPage</a> != LowPage) || (<a class="code" href="../../d5/d6/iosup_8c.html#a25">MiLastCallHighPage</a> != HighPage)) {
04506         <a class="code" href="../../d5/d6/iosup_8c.html#a26">MiLastCallColor</a> = 0;
04507     }
04508 
04509     <a class="code" href="../../d5/d6/iosup_8c.html#a24">MiLastCallLowPage</a> = LowPage;
04510     <a class="code" href="../../d5/d6/iosup_8c.html#a25">MiLastCallHighPage</a> = HighPage;
04511 
04512     FirstMdlPageToZero = MdlPage;
04513 
04514     <span class="keywordflow">do</span> {
04515         <span class="comment">//</span>
04516         <span class="comment">// Grab all zeroed (and then free) pages first directly from the</span>
04517         <span class="comment">// colored lists to avoid multiple walks down these singly linked lists.</span>
04518         <span class="comment">// Then snatch transition pages as needed.  In addition to optimizing</span>
04519         <span class="comment">// the speed of the removals this also avoids cannibalizing the page</span>
04520         <span class="comment">// cache unless it's absolutely needed.</span>
04521         <span class="comment">//</span>
04522 
04523         <span class="keywordflow">for</span> (MemoryList = <a class="code" href="../../d2/d1/mm_8h.html#a345a171">ZeroedPageList</a>; MemoryList &lt;= <a class="code" href="../../d2/d1/mm_8h.html#a345a172">FreePageList</a>; MemoryList += 1) {
04524 
04525             ListHead = <a class="code" href="../../d4/d8/mi_8h.html#a606">MmPageLocationList</a>[MemoryList];
04526 
04527             FullAnchorCount = 0;
04528 
04529             <span class="keywordflow">for</span> (Color = 0; Color &lt; <a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a>; Color += 1) {
04530                 ColorAnchorsHead[Color] = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a>;
04531             }
04532 
04533             Color = <a class="code" href="../../d5/d6/iosup_8c.html#a26">MiLastCallColor</a>;
04534             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Color &lt; <a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a>);
04535 
04536             <span class="keywordflow">do</span> {
04537 
04538                 ColorHead = &amp;<a class="code" href="../../d4/d2/datalpha_8c.html#a20">MmFreePagesByColor</a>[MemoryList][Color];
04539                 ColorAnchor = &amp;ColorAnchorsHead[Color];
04540     
04541                 Color += 1;
04542                 <span class="keywordflow">if</span> (Color &gt;= <a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a>) {
04543                     Color = 0;
04544                 }
04545 
04546                 <span class="keywordflow">if</span> (*ColorAnchor == (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a> - 1)) {
04547 
04548                     <span class="comment">//</span>
04549                     <span class="comment">// This colored list has already been completely searched.</span>
04550                     <span class="comment">//</span>
04551 
04552                     <span class="keywordflow">continue</span>;
04553                 }
04554 
04555                 <span class="keywordflow">if</span> (ColorHead-&gt;<a class="code" href="../../d4/d1/struct__MMCOLOR__TABLES.html#o0">Flink</a> == <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a>) {
04556 
04557                     <span class="comment">//</span>
04558                     <span class="comment">// This colored list is empty.</span>
04559                     <span class="comment">//</span>
04560 
04561                     FullAnchorCount += 1;
04562                     *ColorAnchor = (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a> - 1);
04563                     <span class="keywordflow">continue</span>;
04564                 }
04565 
04566                 <span class="keywordflow">while</span> (ColorHead-&gt;<a class="code" href="../../d4/d1/struct__MMCOLOR__TABLES.html#o0">Flink</a> != <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a>) {
04567     
04568                     Page = ColorHead-&gt;<a class="code" href="../../d4/d1/struct__MMCOLOR__TABLES.html#o0">Flink</a>;
04569         
04570                     Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(Page);
04571 
04572                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((<a class="code" href="../../d2/d1/mm_8h.html#a147">MMLISTS</a>)Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageLocation == MemoryList);
04573     
04574                     <span class="comment">//</span>
04575                     <span class="comment">// See if the page is within the caller's page constraints.</span>
04576                     <span class="comment">//</span>
04577 
04578                     PagePlacementOk = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04579 
04580                     LowPage1 = LowPage;
04581                     HighPage1 = HighPage;
04582 
04583                     <span class="keywordflow">do</span> {
04584                         <span class="keywordflow">if</span> ((Page &gt;= LowPage1) &amp;&amp; (Page &lt;= HighPage1)) {
04585                             PagePlacementOk = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04586                             <span class="keywordflow">break</span>;
04587                         }
04588 
04589                         <span class="keywordflow">if</span> (SkipPages == 0) {
04590                             <span class="keywordflow">break</span>;
04591                         }
04592 
04593                         LowPage1 += SkipPages;
04594                         HighPage1 += SkipPages;
04595 
04596                         <span class="keywordflow">if</span> (LowPage1 &gt; <a class="code" href="../../d6/d8/sysinfo_8c.html#a7">MmHighestPhysicalPage</a>) {
04597                             <span class="keywordflow">break</span>;
04598                         }
04599                         <span class="keywordflow">if</span> (HighPage1 &gt; <a class="code" href="../../d6/d8/sysinfo_8c.html#a7">MmHighestPhysicalPage</a>) {
04600                             HighPage1 = <a class="code" href="../../d6/d8/sysinfo_8c.html#a7">MmHighestPhysicalPage</a>;
04601                         }
04602                     } <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
04603                 
04604                     <span class="comment">// </span>
04605                     <span class="comment">// The Flink and Blink must be nonzero here for the page</span>
04606                     <span class="comment">// to be on the listhead.  Only code that scans the</span>
04607                     <span class="comment">// MmPhysicalMemoryBlock has to check for the zero case.</span>
04608                     <span class="comment">//</span>
04609 
04610                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.Flink != 0);
04611                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.Blink != 0);
04612 
04613                     <span class="keywordflow">if</span> (PagePlacementOk == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
04614 
04615                         <span class="comment">//</span>
04616                         <span class="comment">// Put page on end of list and if first time, save pfn.</span>
04617                         <span class="comment">//</span>
04618     
04619                         <span class="keywordflow">if</span> (*ColorAnchor == <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a>) {
04620                             *ColorAnchor = Page;
04621                         }
04622                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Page == *ColorAnchor) {
04623 
04624                             <span class="comment">//</span>
04625                             <span class="comment">// No more pages available in this colored chain.</span>
04626                             <span class="comment">//</span>
04627 
04628                             FullAnchorCount += 1;
04629                             *ColorAnchor = (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a> - 1);
04630                             <span class="keywordflow">break</span>;
04631                         }
04632 
04633                         <span class="comment">//</span>
04634                         <span class="comment">// If the colored chain has more than one entry then</span>
04635                         <span class="comment">// put this page on the end.</span>
04636                         <span class="comment">//</span>
04637 
04638                         PageNextColored = (PFN_NUMBER)Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long;
04639 
04640                         <span class="keywordflow">if</span> (PageNextColored == <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a>) {
04641 
04642                             <span class="comment">//</span>
04643                             <span class="comment">// No more pages available in this colored chain.</span>
04644                             <span class="comment">//</span>
04645 
04646                             FullAnchorCount += 1;
04647                             *ColorAnchor = (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a> - 1);
04648                             <span class="keywordflow">break</span>;
04649                         }
04650 
04651                         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.Flink != 0);
04652                         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.Flink != <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a>);
04653                         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o17">PteFrame</a> != <a class="code" href="../../d4/d8/mi_8h.html#a170">MI_MAGIC_AWE_PTEFRAME</a>);
04654 
04655                         PfnNextColored = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(PageNextColored);
04656                         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((<a class="code" href="../../d2/d1/mm_8h.html#a147">MMLISTS</a>)PfnNextColored-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageLocation == MemoryList);
04657                         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PfnNextColored-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o17">PteFrame</a> != <a class="code" href="../../d4/d8/mi_8h.html#a170">MI_MAGIC_AWE_PTEFRAME</a>);
04658 
04659                         <span class="comment">//</span>
04660                         <span class="comment">// Adjust the free page list so Page</span>
04661                         <span class="comment">// follows PageNextFlink.</span>
04662                         <span class="comment">//</span>
04663 
04664                         PageNextFlink = Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.Flink;
04665                         PfnNextFlink = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(PageNextFlink);
04666 
04667                         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((<a class="code" href="../../d2/d1/mm_8h.html#a147">MMLISTS</a>)PfnNextFlink-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageLocation == MemoryList);
04668                         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PfnNextFlink-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o17">PteFrame</a> != <a class="code" href="../../d4/d8/mi_8h.html#a170">MI_MAGIC_AWE_PTEFRAME</a>);
04669 
04670                         PfnLastColored = ColorHead-&gt;<a class="code" href="../../d4/d1/struct__MMCOLOR__TABLES.html#o1">Blink</a>;
04671                         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PfnLastColored != (<a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a>)<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a>);
04672                         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PfnLastColored-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long == <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a>);
04673                         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PfnLastColored-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o17">PteFrame</a> != <a class="code" href="../../d4/d8/mi_8h.html#a170">MI_MAGIC_AWE_PTEFRAME</a>);
04674                         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PfnLastColored-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.Blink != <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a>);
04675 
04676                         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((<a class="code" href="../../d2/d1/mm_8h.html#a147">MMLISTS</a>)PfnLastColored-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageLocation == MemoryList);
04677                         PageLastColored = PfnLastColored - <a class="code" href="../../d2/d3/dumpctl_8c.html#a15">MmPfnDatabase</a>;
04678 
04679                         <span class="keywordflow">if</span> (ListHead-&gt;<a class="code" href="../../d0/d4/struct__MMPFNLIST.html#o2">Flink</a> == Page) {
04680 
04681                             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.Blink == <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a>);
04682                             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (ListHead-&gt;<a class="code" href="../../d0/d4/struct__MMPFNLIST.html#o3">Blink</a> != Page);
04683 
04684                             ListHead-&gt;<a class="code" href="../../d0/d4/struct__MMPFNLIST.html#o2">Flink</a> = PageNextFlink;
04685 
04686                             PfnNextFlink-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.Blink = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a>;
04687                         }
04688                         <span class="keywordflow">else</span> {
04689 
04690                             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.Blink != <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a>);
04691                             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((<a class="code" href="../../d2/d1/mm_8h.html#a147">MMLISTS</a>)(<a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>((<a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.Blink)-&gt;u1.Flink)))-&gt;PteFrame != <a class="code" href="../../d4/d8/mi_8h.html#a170">MI_MAGIC_AWE_PTEFRAME</a>);
04692                             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((<a class="code" href="../../d2/d1/mm_8h.html#a147">MMLISTS</a>)(<a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>((<a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.Blink)-&gt;u1.Flink)))-&gt;u3.e1.PageLocation == MemoryList);
04693 
04694                             <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.Blink)-&gt;u1.Flink = PageNextFlink;
04695                             PfnNextFlink-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.Blink = Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.Blink;
04696                         }
04697 
04698 <span class="preprocessor">#if DBG</span>
04699 <span class="preprocessor"></span>                        <span class="keywordflow">if</span> (PfnLastColored-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.Flink == <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a>) {
04700                             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (ListHead-&gt;<a class="code" href="../../d0/d4/struct__MMPFNLIST.html#o3">Blink</a> == PageLastColored);
04701                         }
04702 <span class="preprocessor">#endif</span>
04703 <span class="preprocessor"></span>
04704                         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.Flink = PfnLastColored-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.Flink;
04705                         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.Blink = PageLastColored;
04706 
04707                         <span class="keywordflow">if</span> (ListHead-&gt;<a class="code" href="../../d0/d4/struct__MMPFNLIST.html#o3">Blink</a> == PageLastColored) {
04708                             ListHead-&gt;<a class="code" href="../../d0/d4/struct__MMPFNLIST.html#o3">Blink</a> = Page;
04709                         }
04710 
04711                         <span class="comment">//</span>
04712                         <span class="comment">// Adjust the colored chains.</span>
04713                         <span class="comment">//</span>
04714 
04715                         <span class="keywordflow">if</span> (PfnLastColored-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.Flink != <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a>) {
04716                             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(PfnLastColored-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.Flink)-&gt;PteFrame != <a class="code" href="../../d4/d8/mi_8h.html#a170">MI_MAGIC_AWE_PTEFRAME</a>);
04717                             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((<a class="code" href="../../d2/d1/mm_8h.html#a147">MMLISTS</a>)(<a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(PfnLastColored-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.Flink)-&gt;u3.e1.PageLocation) == MemoryList);
04718                             <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(PfnLastColored-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.Flink)-&gt;u2.Blink = Page;
04719                         }
04720 
04721                         PfnLastColored-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.Flink = Page;
04722 
04723                         ColorHead-&gt;<a class="code" href="../../d4/d1/struct__MMCOLOR__TABLES.html#o0">Flink</a> = PageNextColored;
04724                         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a>;
04725 
04726                         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PfnLastColored-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long == <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a>);
04727                         PfnLastColored-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long = Page;
04728                         ColorHead-&gt;<a class="code" href="../../d4/d1/struct__MMCOLOR__TABLES.html#o1">Blink</a> = Pfn1;
04729 
04730                         <span class="keywordflow">continue</span>;
04731                     }
04732     
04733                     found += 1;
04734                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.ReadInProgress == 0);
04735                     <a class="code" href="../../d7/d5/pfnlist_8c.html#a12">MiUnlinkFreeOrZeroedPage</a> (Page);
04736                     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageColor = 0;
04737     
04738                     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount = 1;
04739                     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount = 1;
04740                     <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a120">MI_SET_PFN_DELETED</a>(Pfn1);
04741                     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a95">MM_DEMAND_ZERO_WRITE_PTE</a>;
04742 <span class="preprocessor">#if DBG</span>
04743 <span class="preprocessor"></span>                    Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o17">PteFrame</a> = <a class="code" href="../../d4/d8/mi_8h.html#a170">MI_MAGIC_AWE_PTEFRAME</a>;
04744 <span class="preprocessor">#endif</span>
04745 <span class="preprocessor"></span>                    Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageLocation = <a class="code" href="../../d2/d1/mm_8h.html#a345a177">ActiveAndValid</a>;
04746     
04747                     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.StartOfAllocation = 1;
04748                     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.EndOfAllocation = 1;
04749                     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.VerifierAllocation = 0;
04750                     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.LargeSessionAllocation = 0;
04751     
04752                     *MdlPage = Page;
04753                     MdlPage += 1;
04754     
04755                     <span class="keywordflow">if</span> (found == SizeInPages) {
04756     
04757                         <span class="comment">//</span>
04758                         <span class="comment">// All the pages requested are available.</span>
04759                         <span class="comment">//</span>
04760 
04761                         <span class="keywordflow">if</span> (MemoryList == <a class="code" href="../../d2/d1/mm_8h.html#a345a171">ZeroedPageList</a>) {
04762                             FirstMdlPageToZero = MdlPage;
04763                             <a class="code" href="../../d5/d6/iosup_8c.html#a26">MiLastCallColor</a> = Color;
04764                         }
04765     
04766 <span class="preprocessor">#if DBG</span>
04767 <span class="preprocessor"></span>                        FinishedCount = 0;
04768                         <span class="keywordflow">for</span> (Color = 0; Color &lt; <a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a>; Color += 1) {
04769                             <span class="keywordflow">if</span> (ColorAnchorsHead[Color] == (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a> - 1)) {
04770                                 FinishedCount += 1;
04771                             }
04772                         }
04773                         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (FinishedCount == FullAnchorCount);
04774 <span class="preprocessor">#endif</span>
04775 <span class="preprocessor"></span>
04776                         <span class="keywordflow">goto</span> pass2_done;
04777                     }
04778     
04779                     <span class="comment">//</span>
04780                     <span class="comment">// March on to the next colored chain so the overall</span>
04781                     <span class="comment">// allocation round-robins the page colors.</span>
04782                     <span class="comment">//</span>
04783 
04784                     <span class="keywordflow">break</span>;
04785                 }
04786 
04787             } <span class="keywordflow">while</span> (FullAnchorCount != <a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a>);
04788 
04789 <span class="preprocessor">#if DBG</span>
04790 <span class="preprocessor"></span>            FinishedCount = 0;
04791             <span class="keywordflow">for</span> (Color = 0; Color &lt; <a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a>; Color += 1) {
04792                 <span class="keywordflow">if</span> (ColorAnchorsHead[Color] == (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a> - 1)) {
04793                     FinishedCount += 1;
04794                 }
04795             }
04796             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (FinishedCount == FullAnchorCount);
04797 <span class="preprocessor">#endif</span>
04798 <span class="preprocessor"></span>
04799             <span class="keywordflow">if</span> (MemoryList == <a class="code" href="../../d2/d1/mm_8h.html#a345a171">ZeroedPageList</a>) {
04800                 FirstMdlPageToZero = MdlPage;
04801             }
04802 
04803             <a class="code" href="../../d5/d6/iosup_8c.html#a26">MiLastCallColor</a> = 0;
04804         }
04805 
04806         start = 0;
04807 
04808         <span class="keywordflow">do</span> {
04809 
04810             count = <a class="code" href="../../d2/d1/mm_8h.html#a131">MmPhysicalMemoryBlock</a>-&gt;<a class="code" href="../../d3/d5/struct__PHYSICAL__MEMORY__DESCRIPTOR.html#o2">Run</a>[start].<a class="code" href="../../d5/d5/struct__PHYSICAL__MEMORY__RUN.html#o1">PageCount</a>;
04811             Page = <a class="code" href="../../d2/d1/mm_8h.html#a131">MmPhysicalMemoryBlock</a>-&gt;<a class="code" href="../../d3/d5/struct__PHYSICAL__MEMORY__DESCRIPTOR.html#o2">Run</a>[start].<a class="code" href="../../d5/d5/struct__PHYSICAL__MEMORY__RUN.html#o0">BasePage</a>;
04812 
04813             <span class="keywordflow">if</span> (count != 0) {
04814 
04815                 <span class="comment">//</span>
04816                 <span class="comment">// Close the gaps, then examine the range for a fit.</span>
04817                 <span class="comment">//</span>
04818 
04819                 LastPage = Page + count;
04820 
04821                 <span class="keywordflow">if</span> (LastPage - 1 &gt; HighPage) {
04822                     LastPage = HighPage + 1;
04823                 }
04824             
04825                 <span class="keywordflow">if</span> (Page &lt; LowPage) {
04826                     Page = LowPage;
04827                 }
04828 
04829                 <span class="keywordflow">if</span> ((Page &lt; LastPage) &amp;&amp;
04830                     (Page &gt;= <a class="code" href="../../d2/d1/mm_8h.html#a131">MmPhysicalMemoryBlock</a>-&gt;<a class="code" href="../../d3/d5/struct__PHYSICAL__MEMORY__DESCRIPTOR.html#o2">Run</a>[start].<a class="code" href="../../d5/d5/struct__PHYSICAL__MEMORY__RUN.html#o0">BasePage</a>) &amp;&amp;
04831                     (LastPage &lt;= <a class="code" href="../../d2/d1/mm_8h.html#a131">MmPhysicalMemoryBlock</a>-&gt;<a class="code" href="../../d3/d5/struct__PHYSICAL__MEMORY__DESCRIPTOR.html#o2">Run</a>[start].<a class="code" href="../../d5/d5/struct__PHYSICAL__MEMORY__RUN.html#o0">BasePage</a> +
04832                         <a class="code" href="../../d2/d1/mm_8h.html#a131">MmPhysicalMemoryBlock</a>-&gt;<a class="code" href="../../d3/d5/struct__PHYSICAL__MEMORY__DESCRIPTOR.html#o2">Run</a>[start].<a class="code" href="../../d5/d5/struct__PHYSICAL__MEMORY__RUN.html#o1">PageCount</a>)) {
04833 
04834                     Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (Page);
04835                     <span class="keywordflow">do</span> {
04836     
04837                         <span class="keywordflow">if</span> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageLocation == <a class="code" href="../../d2/d1/mm_8h.html#a345a173">StandbyPageList</a>) {
04838     
04839                             <span class="keywordflow">if</span> ((Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.Flink != 0) &amp;&amp;
04840                                 (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.Blink != 0) &amp;&amp;
04841                                 (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount == 0)) {
04842     
04843                                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.ReadInProgress == 0);
04844 
04845                                 found += 1;
04846     
04847                                 <span class="comment">//</span>
04848                                 <span class="comment">// This page is in the desired range - grab it.</span>
04849                                 <span class="comment">//</span>
04850     
04851                                 <a class="code" href="../../d7/d5/pfnlist_8c.html#a11">MiUnlinkPageFromList</a> (Pfn1);
04852                                 <a class="code" href="../../d0/d2/mmsup_8c.html#a15">MiRestoreTransitionPte</a> (Page);
04853     
04854                                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageColor = 0;
04855     
04856                                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount = 1;
04857                                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount = 1;
04858                                 <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a120">MI_SET_PFN_DELETED</a>(Pfn1);
04859                                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a95">MM_DEMAND_ZERO_WRITE_PTE</a>;
04860 <span class="preprocessor">#if DBG</span>
04861 <span class="preprocessor"></span>                                Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o17">PteFrame</a> = <a class="code" href="../../d4/d8/mi_8h.html#a170">MI_MAGIC_AWE_PTEFRAME</a>;
04862 <span class="preprocessor">#endif</span>
04863 <span class="preprocessor"></span>                                Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageLocation = <a class="code" href="../../d2/d1/mm_8h.html#a345a177">ActiveAndValid</a>;
04864     
04865                                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.StartOfAllocation = 1;
04866                                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.EndOfAllocation = 1;
04867                                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.VerifierAllocation = 0;
04868                                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.LargeSessionAllocation = 0;
04869     
04870                                 *MdlPage = Page;
04871                                 MdlPage += 1;
04872     
04873                                 <span class="keywordflow">if</span> (found == SizeInPages) {
04874 
04875                                     <span class="comment">//</span>
04876                                     <span class="comment">// All the pages requested are available.</span>
04877                                     <span class="comment">//</span>
04878     
04879                                     <span class="keywordflow">goto</span> pass2_done;
04880                                 }
04881                             }
04882                         }
04883                         Page += 1;
04884                         Pfn1 += 1;
04885     
04886                     } <span class="keywordflow">while</span> (Page &lt; LastPage);
04887                 }
04888             }
04889             start += 1;
04890         } <span class="keywordflow">while</span> (start != <a class="code" href="../../d2/d1/mm_8h.html#a131">MmPhysicalMemoryBlock</a>-&gt;<a class="code" href="../../d3/d5/struct__PHYSICAL__MEMORY__DESCRIPTOR.html#o0">NumberOfRuns</a>);
04891 
04892         <span class="keywordflow">if</span> (SkipPages == 0) {
04893             <span class="keywordflow">break</span>;
04894         }
04895         LowPage += SkipPages;
04896         HighPage += SkipPages;
04897         <span class="keywordflow">if</span> (LowPage &gt; <a class="code" href="../../d6/d8/sysinfo_8c.html#a7">MmHighestPhysicalPage</a>) {
04898             <span class="keywordflow">break</span>;
04899         }
04900         <span class="keywordflow">if</span> (HighPage &gt; <a class="code" href="../../d6/d8/sysinfo_8c.html#a7">MmHighestPhysicalPage</a>) {
04901             HighPage = <a class="code" href="../../d6/d8/sysinfo_8c.html#a7">MmHighestPhysicalPage</a>;
04902         }
04903     } <span class="keywordflow">while</span> (1);
04904 
04905 pass2_done:
04906 
04907     <a class="code" href="../../d5/d6/iosup_8c.html#a17">MmMdlPagesAllocated</a> += found;
04908 
04909     <a class="code" href="../../d8/d5/kddata_8c.html#a42">MmResidentAvailablePages</a> -= found;
04910     <a class="code" href="../../d4/d8/mi_8h.html#a322">MM_BUMP_COUNTER</a>(34, found);
04911 
04912     <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
04913 
04914     ExReleaseFastMutex (&amp;<a class="code" href="../../d9/d3/dynmem_8c.html#a1">MmDynamicMemoryMutex</a>);
04915     <a class="code" href="../../d5/d6/iosup_8c.html#a81">MmUnlockPagableImageSection</a> (<a class="code" href="../../d5/d8/ex_8h.html#a166">ExPageLockHandle</a>);
04916 
04917     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (ColorAnchorsHead);
04918 
04919     <span class="keywordflow">if</span> (found != SizeInPages) {
04920         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (found &lt; SizeInPages);
04921         <a class="code" href="../../d6/d1/mmquota_8c.html#a19">MiReturnCommitment</a> (SizeInPages - found);
04922         <a class="code" href="../../d4/d8/mi_8h.html#a254">MM_TRACK_COMMIT</a> (<a class="code" href="../../d4/d8/mi_8h.html#a267">MM_DBG_COMMIT_MDL_PAGES</a>, 0 - (SizeInPages - found));
04923     }
04924 
04925     <span class="keywordflow">if</span> (found == 0) {
04926         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (MemoryDescriptorList);
04927         <span class="keywordflow">return</span> (<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>)0;
04928     }
04929 
04930     MemoryDescriptorList-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o6">ByteCount</a> = (ULONG)(found &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
04931 
04932     <span class="keywordflow">if</span> (found != SizeInPages) {
04933         *MdlPage = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a>;
04934     }
04935 
04936     <span class="comment">//</span>
04937     <span class="comment">// If the number of pages allocated was substantially less than the</span>
04938     <span class="comment">// initial request amount, attempt to allocate a smaller MDL to save</span>
04939     <span class="comment">// pool.</span>
04940     <span class="comment">//</span>
04941 
04942     <span class="keywordflow">if</span> ((MdlPageSpan - found) &gt; ((4 * <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>) / <span class="keyword">sizeof</span> (PFN_NUMBER))) {
04943         MemoryDescriptorList2 = <a class="code" href="../../d5/d6/iosup_8c.html#a73">MmCreateMdl</a> ((<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>)0,
04944                                              (PVOID)0,
04945                                              found &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
04946     
04947         <span class="keywordflow">if</span> (MemoryDescriptorList2 != (<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>)0) {
04948             RtlMoveMemory ((PVOID)(MemoryDescriptorList2 + 1),
04949                            (PVOID)(MemoryDescriptorList + 1),
04950                            found * <span class="keyword">sizeof</span> (PFN_NUMBER));
04951             FirstMdlPageToZero = (PPFN_NUMBER)(MemoryDescriptorList2 + 1) +
04952                                  (FirstMdlPageToZero -
04953                                     (PPFN_NUMBER)(MemoryDescriptorList + 1));
04954             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (MemoryDescriptorList);
04955             MemoryDescriptorList = MemoryDescriptorList2;
04956         }
04957     }
04958 
04959     MdlPage = (PPFN_NUMBER)(MemoryDescriptorList + 1);
04960     LastMdlPage = MdlPage + found;
04961 
04962 <span class="preprocessor">#if DBG</span>
04963 <span class="preprocessor"></span>    <span class="comment">//</span>
04964     <span class="comment">// Ensure all pages are within the caller's page constraints.</span>
04965     <span class="comment">//</span>
04966 
04967     LowPage = (PFN_NUMBER)(LowAddress.QuadPart &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
04968     HighPage = (PFN_NUMBER)(HighAddress.QuadPart &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
04969 
04970     <span class="keywordflow">while</span> (MdlPage &lt; FirstMdlPageToZero) {
04971         Page = *MdlPage;
04972         PagePlacementOk = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04973         LowPage1 = LowPage;
04974         HighPage1 = HighPage;
04975 
04976         <span class="keywordflow">do</span> {
04977             <span class="keywordflow">if</span> ((Page &gt;= LowPage1) &amp;&amp; (Page &lt;= HighPage1)) {
04978                 PagePlacementOk = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04979                 <span class="keywordflow">break</span>;
04980             }
04981 
04982             <span class="keywordflow">if</span> (SkipPages == 0) {
04983                 <span class="keywordflow">break</span>;
04984             }
04985 
04986             LowPage1 += SkipPages;
04987             HighPage1 += SkipPages;
04988 
04989             <span class="keywordflow">if</span> (LowPage1 &gt; <a class="code" href="../../d6/d8/sysinfo_8c.html#a7">MmHighestPhysicalPage</a>) {
04990                 <span class="keywordflow">break</span>;
04991             }
04992             <span class="keywordflow">if</span> (HighPage1 &gt; <a class="code" href="../../d6/d8/sysinfo_8c.html#a7">MmHighestPhysicalPage</a>) {
04993                 HighPage1 = <a class="code" href="../../d6/d8/sysinfo_8c.html#a7">MmHighestPhysicalPage</a>;
04994             }
04995         } <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
04996 
04997         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PagePlacementOk == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
04998         Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(*MdlPage);
04999         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o17">PteFrame</a> == <a class="code" href="../../d4/d8/mi_8h.html#a170">MI_MAGIC_AWE_PTEFRAME</a>);
05000         MdlPage += 1;
05001     }
05002 <span class="preprocessor">#endif</span>
05003 <span class="preprocessor"></span>
05004     <span class="keywordflow">while</span> (FirstMdlPageToZero &lt; LastMdlPage) {
05005 
05006 <span class="preprocessor">#if DBG</span>
05007 <span class="preprocessor"></span>        <span class="comment">//</span>
05008         <span class="comment">// Ensure all pages are within the caller's page constraints.</span>
05009         <span class="comment">//</span>
05010 
05011         Page = *FirstMdlPageToZero;
05012 
05013         PagePlacementOk = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
05014         LowPage1 = LowPage;
05015         HighPage1 = HighPage;
05016 
05017         <span class="keywordflow">do</span> {
05018             <span class="keywordflow">if</span> ((Page &gt;= LowPage1) &amp;&amp; (Page &lt;= HighPage1)) {
05019                 PagePlacementOk = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
05020                 <span class="keywordflow">break</span>;
05021             }
05022 
05023             <span class="keywordflow">if</span> (SkipPages == 0) {
05024                 <span class="keywordflow">break</span>;
05025             }
05026 
05027             LowPage1 += SkipPages;
05028             HighPage1 += SkipPages;
05029 
05030             <span class="keywordflow">if</span> (LowPage1 &gt; <a class="code" href="../../d6/d8/sysinfo_8c.html#a7">MmHighestPhysicalPage</a>) {
05031                 <span class="keywordflow">break</span>;
05032             }
05033             <span class="keywordflow">if</span> (HighPage1 &gt; <a class="code" href="../../d6/d8/sysinfo_8c.html#a7">MmHighestPhysicalPage</a>) {
05034                 HighPage1 = <a class="code" href="../../d6/d8/sysinfo_8c.html#a7">MmHighestPhysicalPage</a>;
05035             }
05036         } <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
05037 
05038         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PagePlacementOk == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
05039         Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(*FirstMdlPageToZero);
05040         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o17">PteFrame</a> == <a class="code" href="../../d4/d8/mi_8h.html#a170">MI_MAGIC_AWE_PTEFRAME</a>);
05041 <span class="preprocessor">#endif</span>
05042 <span class="preprocessor"></span>        <a class="code" href="../../d0/d2/mmsup_8c.html#a14">MiZeroPhysicalPage</a> (*FirstMdlPageToZero, 0);
05043         FirstMdlPageToZero += 1;
05044     }
05045 
05046     <span class="keywordflow">return</span> MemoryDescriptorList;
05047 }
05048 
05049 
05050 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l05051"></a><a class="code" href="../../d5/d6/iosup_8c.html#a64">05051</a> <a class="code" href="../../d5/d6/iosup_8c.html#a64">MmFreePagesFromMdl</a> (
05052     IN <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MemoryDescriptorList
05053     )
05054 
05055 <span class="comment">/*++</span>
05056 <span class="comment"></span>
05057 <span class="comment">Routine Description:</span>
05058 <span class="comment"></span>
05059 <span class="comment">    This routine walks the argument MDL freeing each physical page back to</span>
05060 <span class="comment">    the PFN database.  This is designed to free pages acquired via</span>
05061 <span class="comment">    MmAllocatePagesForMdl only.</span>
05062 <span class="comment"></span>
05063 <span class="comment">Arguments:</span>
05064 <span class="comment"></span>
05065 <span class="comment">    MemoryDescriptorList - Supplies an MDL which contains the pages to be freed.</span>
05066 <span class="comment"></span>
05067 <span class="comment">Return Value:</span>
05068 <span class="comment"></span>
05069 <span class="comment">    None.</span>
05070 <span class="comment"></span>
05071 <span class="comment">Environment:</span>
05072 <span class="comment"></span>
05073 <span class="comment">    Kernel mode, IRQL of APC_LEVEL or below.</span>
05074 <span class="comment"></span>
05075 <span class="comment">--*/</span>
05076 {
05077     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
05078     KIRQL OldIrql;
05079     PVOID StartingAddress;
05080     PVOID AlignedVa;
05081     PPFN_NUMBER Page;
05082     PFN_NUMBER NumberOfPages;
05083     PFN_NUMBER PagesFreed;
05084 
05085     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (KeGetCurrentIrql() &lt;= <a class="code" href="../../d6/d7/halmips_8h.html#a52">APC_LEVEL</a>);
05086 
05087     PagesFreed = 0;
05088 
05089     <a class="code" href="../../d5/d6/iosup_8c.html#a76">MmLockPagableSectionByHandle</a> (<a class="code" href="../../d5/d8/ex_8h.html#a166">ExPageLockHandle</a>);
05090 
05091     Page = (PPFN_NUMBER)(MemoryDescriptorList + 1);
05092 
05093     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((MemoryDescriptorList-&gt;MdlFlags &amp; (<a class="code" href="../../d0/d9/ntosdef_8h.html#a23">MDL_IO_SPACE</a> | <a class="code" href="../../d0/d9/ntosdef_8h.html#a22">MDL_PHYSICAL_VIEW</a>)) == 0);
05094 
05095     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (((ULONG_PTR)MemoryDescriptorList-&gt;StartVa &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) == 0);
05096     AlignedVa = (PVOID)MemoryDescriptorList-&gt;StartVa;
05097 
05098     StartingAddress = (PVOID)((PCHAR)AlignedVa +
05099                     MemoryDescriptorList-&gt;ByteOffset);
05100 
05101     NumberOfPages = <a class="code" href="../../d2/d1/mm_8h.html#a8">ADDRESS_AND_SIZE_TO_SPAN_PAGES</a>(StartingAddress,
05102                                               MemoryDescriptorList-&gt;ByteCount);
05103 
05104     <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a173">MI_MAKING_MULTIPLE_PTES_INVALID</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
05105 
05106     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
05107 
05108     <span class="keywordflow">do</span> {
05109 
05110         <span class="keywordflow">if</span> (*Page == <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a>) {
05111 
05112             <span class="comment">//</span>
05113             <span class="comment">// There are no more locked pages.</span>
05114             <span class="comment">//</span>
05115 
05116             <span class="keywordflow">break</span>;
05117         }
05118 
05119         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (*Page &lt;= <a class="code" href="../../d6/d8/sysinfo_8c.html#a7">MmHighestPhysicalPage</a>);
05120 
05121         Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (*Page);
05122         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount == 1);
05123         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a121">MI_IS_PFN_DELETED</a> (Pfn1) == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
05124         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d4/d8/mi_8h.html#a171">MI_PFN_IS_AWE</a> (Pfn1) == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
05125         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;PteFrame == <a class="code" href="../../d4/d8/mi_8h.html#a170">MI_MAGIC_AWE_PTEFRAME</a>);
05126 
05127         Pfn1-&gt;u3.e1.StartOfAllocation = 0;
05128         Pfn1-&gt;u3.e1.EndOfAllocation = 0;
05129         Pfn1-&gt;u2.ShareCount = 0;
05130 <span class="preprocessor">#if DBG</span>
05131 <span class="preprocessor"></span>        Pfn1-&gt;PteFrame -= 1;
05132         Pfn1-&gt;u3.e1.PageLocation = <a class="code" href="../../d2/d1/mm_8h.html#a345a173">StandbyPageList</a>;
05133 <span class="preprocessor">#endif</span>
05134 <span class="preprocessor"></span>
05135         <a class="code" href="../../d6/d5/pfndec_8c.html#a2">MiDecrementReferenceCount</a> (*Page);
05136 
05137         PagesFreed += 1;
05138 
05139         StartingAddress = (PVOID)((PCHAR)StartingAddress + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
05140 
05141         *Page++ = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a>;
05142         NumberOfPages -= 1;
05143 
05144     } <span class="keywordflow">while</span> (NumberOfPages != 0);
05145 
05146     <a class="code" href="../../d5/d6/iosup_8c.html#a17">MmMdlPagesAllocated</a> -= PagesFreed;
05147 
05148     <a class="code" href="../../d8/d5/kddata_8c.html#a42">MmResidentAvailablePages</a> += PagesFreed;
05149     <a class="code" href="../../d4/d8/mi_8h.html#a322">MM_BUMP_COUNTER</a>(35, PagesFreed);
05150 
05151     <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
05152 
05153     <a class="code" href="../../d5/d6/iosup_8c.html#a81">MmUnlockPagableImageSection</a> (<a class="code" href="../../d5/d8/ex_8h.html#a166">ExPageLockHandle</a>);
05154 
05155     <a class="code" href="../../d6/d1/mmquota_8c.html#a19">MiReturnCommitment</a> (PagesFreed);
05156     <a class="code" href="../../d4/d8/mi_8h.html#a254">MM_TRACK_COMMIT</a> (<a class="code" href="../../d4/d8/mi_8h.html#a298">MM_DBG_COMMIT_RETURN_MDL_PAGES</a>, PagesFreed);
05157 }
05158 
05159 
05160 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l05161"></a><a class="code" href="../../d5/d6/iosup_8c.html#a65">05161</a> <a class="code" href="../../d5/d6/iosup_8c.html#a65">MmMapUserAddressesToPage</a> (
05162     IN PVOID BaseAddress,
05163     IN SIZE_T NumberOfBytes,
05164     IN PVOID PageAddress
05165     )
05166 
05167 <span class="comment">/*++</span>
05168 <span class="comment"></span>
05169 <span class="comment">Routine Description:</span>
05170 <span class="comment"></span>
05171 <span class="comment">    This function maps a range of addresses in a physical memory VAD to the</span>
05172 <span class="comment">    specified page address.  This is typically used by a driver to nicely</span>
05173 <span class="comment">    remove an application's access to things like video memory when the</span>
05174 <span class="comment">    application is not responding to requests to relinquish it.</span>
05175 <span class="comment"></span>
05176 <span class="comment">    Note the entire range must be currently mapped (ie, all the PTEs must</span>
05177 <span class="comment">    be valid) by the caller.</span>
05178 <span class="comment"></span>
05179 <span class="comment">Arguments:</span>
05180 <span class="comment"></span>
05181 <span class="comment">    BaseAddress - Supplies the base virtual address where the physical</span>
05182 <span class="comment">                  address is mapped.</span>
05183 <span class="comment"></span>
05184 <span class="comment">    NumberOfBytes - Supplies the number of bytes to remap to the new address.</span>
05185 <span class="comment"></span>
05186 <span class="comment">    PageAddress - Supplies the virtual address of the page this is remapped to.</span>
05187 <span class="comment">                  This must be nonpaged memory.</span>
05188 <span class="comment"></span>
05189 <span class="comment">Return Value:</span>
05190 <span class="comment"></span>
05191 <span class="comment">    Various NTSTATUS codes.</span>
05192 <span class="comment"></span>
05193 <span class="comment">Environment:</span>
05194 <span class="comment"></span>
05195 <span class="comment">    Kernel mode, IRQL of APC_LEVEL or below.</span>
05196 <span class="comment"></span>
05197 <span class="comment">--*/</span>
05198 
05199 {
05200     <a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a> Vad;
05201     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
05202     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> PteContents;
05203     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> LastPte;
05204     <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process;
05205     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
05206     PVOID EndingAddress;
05207     PFN_NUMBER PageFrameNumber;
05208     SIZE_T NumberOfPtes;
05209     PHYSICAL_ADDRESS PhysicalAddress;
05210     KIRQL OldIrql;
05211 
05212     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
05213 
05214     <span class="keywordflow">if</span> (BaseAddress &gt; MM_HIGHEST_USER_ADDRESS) {
05215         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER_1;
05216     }
05217 
05218     <span class="keywordflow">if</span> ((ULONG_PTR)BaseAddress + NumberOfBytes &gt; (ULONG64)MM_HIGHEST_USER_ADDRESS) {
05219         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER_2;
05220     }
05221 
05222     Process = <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>();
05223 
05224     EndingAddress = (PVOID)((PCHAR)BaseAddress + NumberOfBytes - 1);
05225 
05226     <a class="code" href="../../d4/d8/mi_8h.html#a161">LOCK_WS_AND_ADDRESS_SPACE</a> (Process);
05227 
05228     <span class="comment">//</span>
05229     <span class="comment">// Make sure the address space was not deleted.</span>
05230     <span class="comment">//</span>
05231 
05232     <span class="keywordflow">if</span> (Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o27">AddressSpaceDeleted</a> != 0) {
05233         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_PROCESS_IS_TERMINATING;
05234         <span class="keywordflow">goto</span> ErrorReturn;
05235     }
05236 
05237     Vad = (<a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a>)<a class="code" href="../../d6/d3/vadtree_8c.html#a2">MiLocateAddress</a> (BaseAddress);
05238 
05239     <span class="keywordflow">if</span> (Vad == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05240 
05241         <span class="comment">//</span>
05242         <span class="comment">// No virtual address descriptor located.</span>
05243         <span class="comment">//</span>
05244 
05245         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_MEMORY_NOT_ALLOCATED;
05246         <span class="keywordflow">goto</span> ErrorReturn;
05247     }
05248 
05249     <span class="keywordflow">if</span> (NumberOfBytes == 0) {
05250 
05251         <span class="comment">//</span>
05252         <span class="comment">// If the region size is specified as 0, the base address</span>
05253         <span class="comment">// must be the starting address for the region.  The entire VAD</span>
05254         <span class="comment">// will then be repointed.</span>
05255         <span class="comment">//</span>
05256 
05257         <span class="keywordflow">if</span> (<a class="code" href="../../d4/d8/mi_8h.html#a107">MI_VA_TO_VPN</a> (BaseAddress) != Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o0">StartingVpn</a>) {
05258             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_FREE_VM_NOT_AT_BASE;
05259             <span class="keywordflow">goto</span> ErrorReturn;
05260         }
05261 
05262         BaseAddress = <a class="code" href="../../d4/d8/mi_8h.html#a108">MI_VPN_TO_VA</a> (Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o0">StartingVpn</a>);
05263         EndingAddress = <a class="code" href="../../d4/d8/mi_8h.html#a109">MI_VPN_TO_VA_ENDING</a> (Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o1">EndingVpn</a>);
05264         NumberOfBytes = (PCHAR)EndingAddress - (PCHAR)BaseAddress + 1;
05265     }
05266 
05267     <span class="comment">//</span>
05268     <span class="comment">// Found the associated virtual address descriptor.</span>
05269     <span class="comment">//</span>
05270 
05271     <span class="keywordflow">if</span> (Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o1">EndingVpn</a> &lt; <a class="code" href="../../d4/d8/mi_8h.html#a107">MI_VA_TO_VPN</a> (EndingAddress)) {
05272 
05273         <span class="comment">//</span>
05274         <span class="comment">// The entire range to remap is not contained within a single</span>
05275         <span class="comment">// virtual address descriptor.  Return an error.</span>
05276         <span class="comment">//</span>
05277 
05278         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_PARAMETER_2;
05279         <span class="keywordflow">goto</span> ErrorReturn;
05280     }
05281 
05282     <span class="keywordflow">if</span> (Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.VadFlags.PhysicalMapping == 0) {
05283 
05284         <span class="comment">//</span>
05285         <span class="comment">// The virtual address descriptor is not a physical mapping.</span>
05286         <span class="comment">//</span>
05287 
05288         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_ADDRESS;
05289         <span class="keywordflow">goto</span> ErrorReturn;
05290     }
05291 
05292     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (BaseAddress);
05293     LastPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (EndingAddress);
05294     NumberOfPtes = LastPte - PointerPte + 1;
05295 
05296     PhysicalAddress = <a class="code" href="../../d5/d6/iosup_8c.html#a68">MmGetPhysicalAddress</a> (PageAddress);
05297     PageFrameNumber = (PFN_NUMBER)(PhysicalAddress.QuadPart &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
05298 
05299     PteContents = *PointerPte;
05300     PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber = PageFrameNumber;
05301 
05302 <span class="preprocessor">#if DBG</span>
05303 <span class="preprocessor"></span>
05304     <span class="comment">//</span>
05305     <span class="comment">// All the PTEs must be valid or the filling will corrupt the</span>
05306     <span class="comment">// UsedPageTableCounts.</span>
05307     <span class="comment">//</span>
05308 
05309     <span class="keywordflow">do</span> {
05310         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;u.Hard.Valid == 1);
05311         PointerPte += 1;
05312     } <span class="keywordflow">while</span> (PointerPte &lt; LastPte);
05313     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (BaseAddress);
05314 <span class="preprocessor">#endif</span>
05315 <span class="preprocessor"></span>
05316     <span class="comment">//</span>
05317     <span class="comment">// Fill the PTEs and flush at the end - no race here because it doesn't</span>
05318     <span class="comment">// matter whether the user app sees the old or the new data until we</span>
05319     <span class="comment">// return (writes going to either page is acceptable prior to return</span>
05320     <span class="comment">// from this function).  There is no race with I/O and ProbeAndLockPages</span>
05321     <span class="comment">// because the PFN lock is acquired here.</span>
05322     <span class="comment">//</span>
05323 
05324     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
05325 
05326 <span class="preprocessor">#if !defined (_X86PAE_)</span>
05327 <span class="preprocessor"></span>    <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a189">MiFillMemoryPte</a> (PointerPte,
05328                      NumberOfPtes * <span class="keyword">sizeof</span> (<a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a>),
05329                      PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long);
05330 <span class="preprocessor">#else</span>
05331 <span class="preprocessor"></span>
05332     <span class="comment">//</span>
05333     <span class="comment">// Note that the PAE architecture must very carefully fill these PTEs.</span>
05334     <span class="comment">//</span>
05335 
05336     <span class="keywordflow">do</span> {
05337         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;u.Hard.Valid == 1);
05338         PointerPte += 1;
05339         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)KeInterlockedSwapPte ((PHARDWARE_PTE)PointerPte,
05340                                     (PHARDWARE_PTE)&amp;PteContents);
05341     } <span class="keywordflow">while</span> (PointerPte &lt; LastPte);
05342     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (BaseAddress);
05343 
05344 <span class="preprocessor">#endif</span>
05345 <span class="preprocessor"></span>
05346     <span class="keywordflow">if</span> (NumberOfPtes == 1) {
05347 
05348         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d0/d6/ppc_2flushtb_8c.html#a2">KeFlushSingleTb</a> (BaseAddress,
05349                                <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
05350                                <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
05351                                (PHARDWARE_PTE)PointerPte,
05352                                PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Flush);
05353     }
05354     <span class="keywordflow">else</span> {
05355         <a class="code" href="../../d0/d6/ppc_2flushtb_8c.html#a0">KeFlushEntireTb</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
05356     }
05357 
05358     <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
05359 
05360     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
05361 
05362 ErrorReturn:
05363 
05364     <a class="code" href="../../d4/d8/mi_8h.html#a162">UNLOCK_WS_AND_ADDRESS_SPACE</a> (Process);
05365 
05366     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
05367 }
05368 
05369 
05370 
05371 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l05372"></a><a class="code" href="../../d5/d6/iosup_8c.html#a66">05372</a> <a class="code" href="../../d5/d6/iosup_8c.html#a66">MmFreeContiguousMemory</a> (
05373     IN PVOID BaseAddress
05374     )
05375 
05376 <span class="comment">/*++</span>
05377 <span class="comment"></span>
05378 <span class="comment">Routine Description:</span>
05379 <span class="comment"></span>
05380 <span class="comment">    This function deallocates a range of physically contiguous non-paged</span>
05381 <span class="comment">    pool which was allocated with the MmAllocateContiguousMemory function.</span>
05382 <span class="comment"></span>
05383 <span class="comment">Arguments:</span>
05384 <span class="comment"></span>
05385 <span class="comment">    BaseAddress - Supplies the base virtual address where the physical</span>
05386 <span class="comment">                  address was previously mapped.</span>
05387 <span class="comment"></span>
05388 <span class="comment">Return Value:</span>
05389 <span class="comment"></span>
05390 <span class="comment">    None.</span>
05391 <span class="comment"></span>
05392 <span class="comment">Environment:</span>
05393 <span class="comment"></span>
05394 <span class="comment">    Kernel mode, IRQL of APC_LEVEL or below.</span>
05395 <span class="comment"></span>
05396 <span class="comment">--*/</span>
05397 
05398 {
05399     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
05400 
05401 <span class="preprocessor">#if defined (_X86PAE_)</span>
05402 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/iosup_8c.html#a15">MiNoLowMemory</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
05403         <span class="keywordflow">if</span> (<a class="code" href="../../d4/d5/procsup_8c.html#a28">MiFreeLowMemory</a> (BaseAddress, 'tnoC') == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
05404             <span class="keywordflow">return</span>;
05405         }
05406     }
05407 <span class="preprocessor">#endif</span>
05408 <span class="preprocessor"></span>
05409     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (BaseAddress);
05410 }
05411 
05412 
05413 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l05414"></a><a class="code" href="../../d5/d6/iosup_8c.html#a67">05414</a> <a class="code" href="../../d5/d6/iosup_8c.html#a67">MmFreeContiguousMemorySpecifyCache</a> (
05415     IN PVOID BaseAddress,
05416     IN SIZE_T NumberOfBytes,
05417     IN MEMORY_CACHING_TYPE CacheType
05418     )
05419 
05420 <span class="comment">/*++</span>
05421 <span class="comment"></span>
05422 <span class="comment">Routine Description:</span>
05423 <span class="comment"></span>
05424 <span class="comment">    This function deallocates a range of noncached memory in</span>
05425 <span class="comment">    the non-paged portion of the system address space.</span>
05426 <span class="comment"></span>
05427 <span class="comment">Arguments:</span>
05428 <span class="comment"></span>
05429 <span class="comment">    BaseAddress - Supplies the base virtual address where the noncached</span>
05430 <span class="comment"></span>
05431 <span class="comment">    NumberOfBytes - Supplies the number of bytes allocated to the request.</span>
05432 <span class="comment">                    This must be the same number that was obtained with</span>
05433 <span class="comment">                    the MmAllocateContiguousMemorySpecifyCache call.</span>
05434 <span class="comment"></span>
05435 <span class="comment">    CacheType - Supplies the cachetype used when the caller made the</span>
05436 <span class="comment">                MmAllocateContiguousMemorySpecifyCache call.</span>
05437 <span class="comment"></span>
05438 <span class="comment">Return Value:</span>
05439 <span class="comment"></span>
05440 <span class="comment">    None.</span>
05441 <span class="comment"></span>
05442 <span class="comment">Environment:</span>
05443 <span class="comment"></span>
05444 <span class="comment">    Kernel mode, IRQL of APC_LEVEL or below.</span>
05445 <span class="comment"></span>
05446 <span class="comment">--*/</span>
05447 
05448 {
05449     PVOID PoolAddress;
05450     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
05451 
05452     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
05453 
05454     <span class="keywordflow">if</span> (CacheType != <a class="code" href="../../d4/d9/ke_8h.html#a413a249">MmCached</a>) {
05455 
05456         <span class="comment">//</span>
05457         <span class="comment">// The caller was using an alternate mapping - free these PTEs too.</span>
05458         <span class="comment">//</span>
05459 
05460         PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(BaseAddress);
05461 
05462         PointerPte += ((NumberOfBytes + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1) &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
05463         PoolAddress = (PVOID)(ULONG_PTR)PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long;
05464 
05465         PointerPte += 1;
05466         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (NumberOfBytes == PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long);
05467 
05468         NumberOfBytes += (2 * <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
05469         <a class="code" href="../../d5/d6/iosup_8c.html#a58">MmUnmapIoSpace</a> (BaseAddress, NumberOfBytes);
05470         BaseAddress = PoolAddress;
05471     }
05472     <span class="keywordflow">else</span> {
05473         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (BaseAddress &lt; <a class="code" href="../../d8/d5/kddata_8c.html#a22">MmNonPagedSystemStart</a> ||
05474                 BaseAddress &gt;= (PVOID)((PCHAR)<a class="code" href="../../d8/d5/kddata_8c.html#a22">MmNonPagedSystemStart</a> + (<a class="code" href="../../d8/d0/cmdat3_8c.html#a23">MmNumberOfSystemPtes</a> &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>)));
05475     }
05476 
05477 <span class="preprocessor">#if defined (_X86PAE_)</span>
05478 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/iosup_8c.html#a15">MiNoLowMemory</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
05479         <span class="keywordflow">if</span> (<a class="code" href="../../d4/d5/procsup_8c.html#a28">MiFreeLowMemory</a> (BaseAddress, 'tnoC') == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
05480             <span class="keywordflow">return</span>;
05481         }
05482     }
05483 <span class="preprocessor">#endif</span>
05484 <span class="preprocessor"></span>
05485     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (BaseAddress);
05486 }
05487 
05488 
05489 PHYSICAL_ADDRESS
<a name="l05490"></a><a class="code" href="../../d5/d6/iosup_8c.html#a68">05490</a> <a class="code" href="../../d5/d6/iosup_8c.html#a68">MmGetPhysicalAddress</a> (
05491      IN PVOID BaseAddress
05492      )
05493 
05494 <span class="comment">/*++</span>
05495 <span class="comment"></span>
05496 <span class="comment">Routine Description:</span>
05497 <span class="comment"></span>
05498 <span class="comment">    This function returns the corresponding physical address for a</span>
05499 <span class="comment">    valid virtual address.</span>
05500 <span class="comment"></span>
05501 <span class="comment">Arguments:</span>
05502 <span class="comment"></span>
05503 <span class="comment">    BaseAddress - Supplies the virtual address for which to return the</span>
05504 <span class="comment">                  physical address.</span>
05505 <span class="comment"></span>
05506 <span class="comment">Return Value:</span>
05507 <span class="comment"></span>
05508 <span class="comment">    Returns the corresponding physical address.</span>
05509 <span class="comment"></span>
05510 <span class="comment">Environment:</span>
05511 <span class="comment"></span>
05512 <span class="comment">    Kernel mode.  Any IRQL level.</span>
05513 <span class="comment"></span>
05514 <span class="comment">--*/</span>
05515 
05516 {
05517     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
05518     PHYSICAL_ADDRESS PhysicalAddress;
05519 
05520     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a>(BaseAddress)) {
05521         PhysicalAddress.QuadPart = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a179">MI_CONVERT_PHYSICAL_TO_PFN</a> (BaseAddress);
05522     } <span class="keywordflow">else</span> {
05523 
05524         PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(BaseAddress);
05525 
05526         <span class="keywordflow">if</span> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 0) {
05527             KdPrint((<span class="stringliteral">"MM:MmGetPhysicalAddressFailed base address was %lx"</span>,
05528                       BaseAddress));
05529             <a class="code" href="../../d4/d8/mi_8h.html#a166">ZERO_LARGE</a> (PhysicalAddress);
05530             <span class="keywordflow">return</span> PhysicalAddress;
05531         }
05532         PhysicalAddress.QuadPart = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a> (PointerPte);
05533     }
05534 
05535     PhysicalAddress.QuadPart = PhysicalAddress.QuadPart &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
05536     PhysicalAddress.LowPart += <a class="code" href="../../d2/d1/mm_8h.html#a6">BYTE_OFFSET</a>(BaseAddress);
05537 
05538     <span class="keywordflow">return</span> PhysicalAddress;
05539 }
05540 
05541 PVOID
<a name="l05542"></a><a class="code" href="../../d5/d6/iosup_8c.html#a69">05542</a> <a class="code" href="../../d5/d6/iosup_8c.html#a69">MmGetVirtualForPhysical</a> (
05543     IN PHYSICAL_ADDRESS PhysicalAddress
05544      )
05545 
05546 <span class="comment">/*++</span>
05547 <span class="comment"></span>
05548 <span class="comment">Routine Description:</span>
05549 <span class="comment"></span>
05550 <span class="comment">    This function returns the corresponding virtual address for a physical</span>
05551 <span class="comment">    address whose primary virtual address is in system space.</span>
05552 <span class="comment"></span>
05553 <span class="comment">Arguments:</span>
05554 <span class="comment"></span>
05555 <span class="comment">    PhysicalAddress - Supplies the physical address for which to return the</span>
05556 <span class="comment">                  virtual address.</span>
05557 <span class="comment"></span>
05558 <span class="comment">Return Value:</span>
05559 <span class="comment"></span>
05560 <span class="comment">    Returns the corresponding virtual address.</span>
05561 <span class="comment"></span>
05562 <span class="comment">Environment:</span>
05563 <span class="comment"></span>
05564 <span class="comment">    Kernel mode.  Any IRQL level.</span>
05565 <span class="comment"></span>
05566 <span class="comment">--*/</span>
05567 
05568 {
05569     PFN_NUMBER PageFrameIndex;
05570     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn;
05571 
05572     PageFrameIndex = (PFN_NUMBER)(PhysicalAddress.QuadPart &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
05573 
05574     Pfn = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PageFrameIndex);
05575 
05576     <span class="keywordflow">return</span> (PVOID)((PCHAR)<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (Pfn-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a>) +
05577                     <a class="code" href="../../d2/d1/mm_8h.html#a6">BYTE_OFFSET</a> (PhysicalAddress.LowPart));
05578 }
05579 
05580 PVOID
<a name="l05581"></a><a class="code" href="../../d5/d6/iosup_8c.html#a70">05581</a> <a class="code" href="../../d5/d6/iosup_8c.html#a70">MmAllocateNonCachedMemory</a> (
05582     IN SIZE_T NumberOfBytes
05583     )
05584 
05585 <span class="comment">/*++</span>
05586 <span class="comment"></span>
05587 <span class="comment">Routine Description:</span>
05588 <span class="comment"></span>
05589 <span class="comment">    This function allocates a range of noncached memory in</span>
05590 <span class="comment">    the non-paged portion of the system address space.</span>
05591 <span class="comment"></span>
05592 <span class="comment">    This routine is designed to be used by a driver's initialization</span>
05593 <span class="comment">    routine to allocate a noncached block of virtual memory for</span>
05594 <span class="comment">    various device specific buffers.</span>
05595 <span class="comment"></span>
05596 <span class="comment">Arguments:</span>
05597 <span class="comment"></span>
05598 <span class="comment">    NumberOfBytes - Supplies the number of bytes to allocate.</span>
05599 <span class="comment"></span>
05600 <span class="comment">Return Value:</span>
05601 <span class="comment"></span>
05602 <span class="comment">    NON-NULL - Returns a pointer (virtual address in the nonpaged portion</span>
05603 <span class="comment">               of the system) to the allocated physically contiguous</span>
05604 <span class="comment">               memory.</span>
05605 <span class="comment"></span>
05606 <span class="comment">    NULL - The specified request could not be satisfied.</span>
05607 <span class="comment"></span>
05608 <span class="comment">Environment:</span>
05609 <span class="comment"></span>
05610 <span class="comment">    Kernel mode, IRQL of APC_LEVEL or below.</span>
05611 <span class="comment"></span>
05612 <span class="comment">--*/</span>
05613 
05614 {
05615     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
05616     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> TempPte;
05617     PFN_NUMBER NumberOfPages;
05618     PFN_NUMBER PageFrameIndex;
05619     PVOID BaseAddress;
05620     KIRQL OldIrql;
05621 
05622     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (NumberOfBytes != 0);
05623 
05624     NumberOfPages = <a class="code" href="../../d2/d1/mm_8h.html#a5">BYTES_TO_PAGES</a>(NumberOfBytes);
05625 
05626     <span class="comment">//</span>
05627     <span class="comment">// Obtain enough virtual space to map the pages.</span>
05628     <span class="comment">//</span>
05629 
05630     PointerPte = <a class="code" href="../../d0/d9/sysptes_8c.html#a25">MiReserveSystemPtes</a> ((ULONG)NumberOfPages,
05631                                       <a class="code" href="../../d4/d8/mi_8h.html#a1003a769">SystemPteSpace</a>,
05632                                       0,
05633                                       0,
05634                                       <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
05635 
05636     <span class="keywordflow">if</span> (PointerPte == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05637         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05638     }
05639 
05640     <span class="comment">//</span>
05641     <span class="comment">// Obtain backing commitment for the pages.</span>
05642     <span class="comment">//</span>
05643 
05644     <span class="keywordflow">if</span> (<a class="code" href="../../d6/d1/mmquota_8c.html#a18">MiChargeCommitmentCantExpand</a> (NumberOfPages, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
05645         <a class="code" href="../../d0/d9/sysptes_8c.html#a26">MiReleaseSystemPtes</a> (PointerPte, (ULONG)NumberOfPages, <a class="code" href="../../d4/d8/mi_8h.html#a1003a769">SystemPteSpace</a>);
05646         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05647     }
05648 
05649     <a class="code" href="../../d4/d8/mi_8h.html#a254">MM_TRACK_COMMIT</a> (<a class="code" href="../../d4/d8/mi_8h.html#a268">MM_DBG_COMMIT_NONCACHED_PAGES</a>, NumberOfPages);
05650 
05651     <a class="code" href="../../d5/d6/iosup_8c.html#a76">MmLockPagableSectionByHandle</a> (<a class="code" href="../../d5/d8/ex_8h.html#a166">ExPageLockHandle</a>);
05652 
05653     <span class="comment">//</span>
05654     <span class="comment">// Acquire the PFN mutex to synchronize access to the PFN database.</span>
05655     <span class="comment">//</span>
05656 
05657     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
05658 
05659     <span class="comment">//</span>
05660     <span class="comment">// Obtain enough pages to contain the allocation.</span>
05661     <span class="comment">// Check to make sure the physical pages are available.</span>
05662     <span class="comment">//</span>
05663 
05664     <span class="keywordflow">if</span> ((SPFN_NUMBER)NumberOfPages &gt; <a class="code" href="../../d4/d8/mi_8h.html#a323">MI_NONPAGABLE_MEMORY_AVAILABLE</a>()) {
05665         <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
05666         <a class="code" href="../../d5/d6/iosup_8c.html#a81">MmUnlockPagableImageSection</a> (<a class="code" href="../../d5/d8/ex_8h.html#a166">ExPageLockHandle</a>);
05667         <a class="code" href="../../d0/d9/sysptes_8c.html#a26">MiReleaseSystemPtes</a> (PointerPte, (ULONG)NumberOfPages, <a class="code" href="../../d4/d8/mi_8h.html#a1003a769">SystemPteSpace</a>);
05668         <a class="code" href="../../d6/d1/mmquota_8c.html#a19">MiReturnCommitment</a> (NumberOfPages);
05669         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05670     }
05671 
05672 <span class="preprocessor">#if defined(_IA64_)</span>
05673 <span class="preprocessor"></span>    <a class="code" href="../../d0/d6/ppc_2flushtb_8c.html#a0">KeFlushEntireTb</a>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
05674 <span class="preprocessor">#endif</span>
05675 <span class="preprocessor"></span>
05676     <a class="code" href="../../d8/d5/kddata_8c.html#a42">MmResidentAvailablePages</a> -= NumberOfPages;
05677     <a class="code" href="../../d4/d8/mi_8h.html#a322">MM_BUMP_COUNTER</a>(4, NumberOfPages);
05678 
05679     BaseAddress = (PVOID)<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPte);
05680 
05681     <span class="keywordflow">do</span> {
05682         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 0);
05683         <a class="code" href="../../d7/d5/pfnlist_8c.html#a13">MiEnsureAvailablePageOrWait</a> (<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
05684         PageFrameIndex = <a class="code" href="../../d7/d5/pfnlist_8c.html#a15">MiRemoveAnyPage</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a124">MI_GET_PAGE_COLOR_FROM_PTE</a> (PointerPte));
05685 
05686         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a105">MI_MAKE_VALID_PTE</a> (TempPte,
05687                            PageFrameIndex,
05688                            <a class="code" href="../../d4/d8/mi_8h.html#a39">MM_READWRITE</a>,
05689                            PointerPte);
05690 
05691         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a112">MI_SET_PTE_DIRTY</a> (TempPte);
05692         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a118">MI_DISABLE_CACHING</a> (TempPte);
05693         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a186">MI_WRITE_VALID_PTE</a> (PointerPte, TempPte);
05694         <a class="code" href="../../d8/d2/pagfault_8c.html#a22">MiInitializePfn</a> (PageFrameIndex, PointerPte, 1);
05695 
05696         PointerPte += 1;
05697         NumberOfPages -= 1;
05698     } <span class="keywordflow">while</span> (NumberOfPages != 0);
05699 
05700     <span class="comment">//</span>
05701     <span class="comment">// Flush any data for this page out of the dcaches.</span>
05702     <span class="comment">//</span>
05703 
05704 <span class="preprocessor">#if !defined(_IA64_)</span>
05705 <span class="preprocessor"></span>    <span class="comment">//</span>
05706     <span class="comment">// Flush any data for this page out of the dcaches.</span>
05707     <span class="comment">//</span>
05708 
05709     <a class="code" href="../../d3/d5/ppc_2flush_8c.html#a6">KeSweepDcache</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
05710 <span class="preprocessor">#else</span>
05711 <span class="preprocessor"></span>    <a class="code" href="../../d2/d9/miia64_8h.html#a318">MiSweepCacheMachineDependent</a>(BaseAddress, NumberOfBytes, <a class="code" href="../../d4/d9/ke_8h.html#a413a248">MmNonCached</a>);
05712 <span class="preprocessor">#endif</span>
05713 <span class="preprocessor"></span>
05714     <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
05715     <a class="code" href="../../d5/d6/iosup_8c.html#a81">MmUnlockPagableImageSection</a> (<a class="code" href="../../d5/d8/ex_8h.html#a166">ExPageLockHandle</a>);
05716 
05717     <span class="keywordflow">return</span> BaseAddress;
05718 }
05719 
05720 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l05721"></a><a class="code" href="../../d5/d6/iosup_8c.html#a71">05721</a> <a class="code" href="../../d5/d6/iosup_8c.html#a71">MmFreeNonCachedMemory</a> (
05722     IN PVOID BaseAddress,
05723     IN SIZE_T NumberOfBytes
05724     )
05725 
05726 <span class="comment">/*++</span>
05727 <span class="comment"></span>
05728 <span class="comment">Routine Description:</span>
05729 <span class="comment"></span>
05730 <span class="comment">    This function deallocates a range of noncached memory in</span>
05731 <span class="comment">    the non-paged portion of the system address space.</span>
05732 <span class="comment"></span>
05733 <span class="comment">Arguments:</span>
05734 <span class="comment"></span>
05735 <span class="comment">    BaseAddress - Supplies the base virtual address where the noncached</span>
05736 <span class="comment">                  memory resides.</span>
05737 <span class="comment"></span>
05738 <span class="comment">    NumberOfBytes - Supplies the number of bytes allocated to the request.</span>
05739 <span class="comment">                    This must be the same number that was obtained with</span>
05740 <span class="comment">                    the MmAllocateNonCachedMemory call.</span>
05741 <span class="comment"></span>
05742 <span class="comment">Return Value:</span>
05743 <span class="comment"></span>
05744 <span class="comment">    None.</span>
05745 <span class="comment"></span>
05746 <span class="comment">Environment:</span>
05747 <span class="comment"></span>
05748 <span class="comment">    Kernel mode, IRQL of APC_LEVEL or below.</span>
05749 <span class="comment"></span>
05750 <span class="comment">--*/</span>
05751 
05752 {
05753 
05754     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
05755     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
05756     PFN_NUMBER NumberOfPages;
05757     PFN_NUMBER i;
05758     PFN_NUMBER PageFrameIndex;
05759     KIRQL OldIrql;
05760 
05761     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (NumberOfBytes != 0);
05762     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a> (BaseAddress) == BaseAddress);
05763 
05764     <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a173">MI_MAKING_MULTIPLE_PTES_INVALID</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
05765 
05766     NumberOfPages = <a class="code" href="../../d2/d1/mm_8h.html#a5">BYTES_TO_PAGES</a>(NumberOfBytes);
05767 
05768     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (BaseAddress);
05769 
05770     i = NumberOfPages;
05771 
05772     <a class="code" href="../../d5/d6/iosup_8c.html#a76">MmLockPagableSectionByHandle</a> (<a class="code" href="../../d5/d8/ex_8h.html#a166">ExPageLockHandle</a>);
05773 
05774     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
05775 
05776     <span class="keywordflow">do</span> {
05777 
05778         PageFrameIndex = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a> (PointerPte);
05779 
05780         <span class="comment">//</span>
05781         <span class="comment">// Mark the page for deletion when the reference count goes to zero.</span>
05782         <span class="comment">//</span>
05783 
05784         Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PageFrameIndex);
05785         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount == 1);
05786         <a class="code" href="../../d4/d8/mi_8h.html#a242">MiDecrementShareAndValidCount</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o17">PteFrame</a>);
05787         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a120">MI_SET_PFN_DELETED</a> (Pfn1);
05788         <a class="code" href="../../d4/d8/mi_8h.html#a241">MiDecrementShareCountOnly</a> (PageFrameIndex);
05789         PointerPte += 1;
05790         i -= 1;
05791     } <span class="keywordflow">while</span> (i != 0);
05792 
05793     PointerPte -= NumberOfPages;
05794 
05795     <span class="comment">//</span>
05796     <span class="comment">// Update the count of available resident pages.</span>
05797     <span class="comment">//</span>
05798 
05799     <a class="code" href="../../d8/d5/kddata_8c.html#a42">MmResidentAvailablePages</a> += NumberOfPages;
05800     <a class="code" href="../../d4/d8/mi_8h.html#a322">MM_BUMP_COUNTER</a>(5, NumberOfPages);
05801 
05802     <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
05803 
05804     <a class="code" href="../../d5/d6/iosup_8c.html#a81">MmUnlockPagableImageSection</a> (<a class="code" href="../../d5/d8/ex_8h.html#a166">ExPageLockHandle</a>);
05805 
05806     <a class="code" href="../../d0/d9/sysptes_8c.html#a26">MiReleaseSystemPtes</a> (PointerPte, (ULONG)NumberOfPages, <a class="code" href="../../d4/d8/mi_8h.html#a1003a769">SystemPteSpace</a>);
05807 
05808     <a class="code" href="../../d6/d1/mmquota_8c.html#a19">MiReturnCommitment</a> (NumberOfPages);
05809     <a class="code" href="../../d4/d8/mi_8h.html#a254">MM_TRACK_COMMIT</a> (<a class="code" href="../../d4/d8/mi_8h.html#a299">MM_DBG_COMMIT_RETURN_NONCACHED_PAGES</a>, NumberOfPages);
05810 
05811     <span class="keywordflow">return</span>;
05812 }
05813 
05814 SIZE_T
<a name="l05815"></a><a class="code" href="../../d5/d6/iosup_8c.html#a72">05815</a> <a class="code" href="../../d5/d6/iosup_8c.html#a72">MmSizeOfMdl</a> (
05816     IN PVOID Base,
05817     IN SIZE_T Length
05818     )
05819 
05820 <span class="comment">/*++</span>
05821 <span class="comment"></span>
05822 <span class="comment">Routine Description:</span>
05823 <span class="comment"></span>
05824 <span class="comment">    This function returns the number of bytes required for an MDL for a</span>
05825 <span class="comment">    given buffer and size.</span>
05826 <span class="comment"></span>
05827 <span class="comment">Arguments:</span>
05828 <span class="comment"></span>
05829 <span class="comment">    Base - Supplies the base virtual address for the buffer.</span>
05830 <span class="comment"></span>
05831 <span class="comment">    Length - Supplies the size of the buffer in bytes.</span>
05832 <span class="comment"></span>
05833 <span class="comment">Return Value:</span>
05834 <span class="comment"></span>
05835 <span class="comment">    Returns the number of bytes required to contain the MDL.</span>
05836 <span class="comment"></span>
05837 <span class="comment">Environment:</span>
05838 <span class="comment"></span>
05839 <span class="comment">    Kernel mode.  Any IRQL level.</span>
05840 <span class="comment"></span>
05841 <span class="comment">--*/</span>
05842 
05843 {
05844     <span class="keywordflow">return</span>( <span class="keyword">sizeof</span>( <a class="code" href="../../d6/d7/struct__MDL.html">MDL</a> ) +
05845                 (<a class="code" href="../../d2/d1/mm_8h.html#a8">ADDRESS_AND_SIZE_TO_SPAN_PAGES</a>( Base, Length ) *
05846                  <span class="keyword">sizeof</span>( PFN_NUMBER ))
05847           );
05848 }
05849 
05850 
05851 <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>
<a name="l05852"></a><a class="code" href="../../d5/d6/iosup_8c.html#a73">05852</a> <a class="code" href="../../d5/d6/iosup_8c.html#a73">MmCreateMdl</a> (
05853     IN <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MemoryDescriptorList OPTIONAL,
05854     IN PVOID Base,
05855     IN SIZE_T Length
05856     )
05857 
05858 <span class="comment">/*++</span>
05859 <span class="comment"></span>
05860 <span class="comment">Routine Description:</span>
05861 <span class="comment"></span>
05862 <span class="comment">    This function optionally allocates and initializes an MDL.</span>
05863 <span class="comment"></span>
05864 <span class="comment">Arguments:</span>
05865 <span class="comment"></span>
05866 <span class="comment">    MemoryDescriptorList - Optionally supplies the address of the MDL</span>
05867 <span class="comment">                           to initialize.  If this address is supplied as NULL</span>
05868 <span class="comment">                           an MDL is allocated from non-paged pool and</span>
05869 <span class="comment">                           initialized.</span>
05870 <span class="comment"></span>
05871 <span class="comment">    Base - Supplies the base virtual address for the buffer.</span>
05872 <span class="comment"></span>
05873 <span class="comment">    Length - Supplies the size of the buffer in bytes.</span>
05874 <span class="comment"></span>
05875 <span class="comment">Return Value:</span>
05876 <span class="comment"></span>
05877 <span class="comment">    Returns the address of the initialized MDL.</span>
05878 <span class="comment"></span>
05879 <span class="comment">Environment:</span>
05880 <span class="comment"></span>
05881 <span class="comment">    Kernel mode, IRQL of DISPATCH_LEVEL or below.</span>
05882 <span class="comment"></span>
05883 <span class="comment">--*/</span>
05884 
05885 {
05886     SIZE_T MdlSize;
05887 
05888     MdlSize = <a class="code" href="../../d5/d6/iosup_8c.html#a72">MmSizeOfMdl</a>( Base, Length );
05889 
05890     <span class="keywordflow">if</span> (!ARGUMENT_PRESENT( MemoryDescriptorList )) {
05891 
05892         <span class="comment">//</span>
05893         <span class="comment">// The pool manager doesn't like being called with large requests</span>
05894         <span class="comment">// marked MustSucceed, so try the normal nonpaged if the</span>
05895         <span class="comment">// request is large.</span>
05896         <span class="comment">//</span>
05897 
05898         <span class="keywordflow">if</span> (MdlSize &gt; <a class="code" href="../../d5/d2/poolhack_8c.html#a7">POOL_BUDDY_MAX</a>) {
05899             MemoryDescriptorList = (<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>)<a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a> (
05900                                                      <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
05901                                                      MdlSize,
05902                                                      'ldmM');
05903             <span class="keywordflow">if</span> (MemoryDescriptorList == (<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>)0) {
05904                 <span class="keywordflow">return</span> (<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>)0;
05905             }
05906         }
05907         <span class="keywordflow">else</span> {
05908             MemoryDescriptorList = (<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>)<a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a> (
05909                                                      <a class="code" href="../../d5/d8/ex_8h.html#a329a175">NonPagedPoolMustSucceed</a>,
05910                                                      MdlSize,
05911                                                      'ldmM');
05912         }
05913     }
05914 
05915     <a class="code" href="../../d2/d1/mm_8h.html#a24">MmInitializeMdl</a> (MemoryDescriptorList, Base, Length);
05916     <span class="keywordflow">return</span> MemoryDescriptorList;
05917 }
05918 
05919 BOOLEAN
<a name="l05920"></a><a class="code" href="../../d5/d6/iosup_8c.html#a74">05920</a> <a class="code" href="../../d5/d6/iosup_8c.html#a74">MmSetAddressRangeModified</a> (
05921     IN PVOID Address,
05922     IN SIZE_T Length
05923     )
05924 
05925 <span class="comment">/*++</span>
05926 <span class="comment"></span>
05927 <span class="comment">Routine Description:</span>
05928 <span class="comment"></span>
05929 <span class="comment">    This routine sets the modified bit in the PFN database for the</span>
05930 <span class="comment">    pages that correspond to the specified address range.</span>
05931 <span class="comment"></span>
05932 <span class="comment">    Note that the dirty bit in the PTE is cleared by this operation.</span>
05933 <span class="comment"></span>
05934 <span class="comment">Arguments:</span>
05935 <span class="comment"></span>
05936 <span class="comment">    Address - Supplies the address of the start of the range.  This</span>
05937 <span class="comment">              range must reside within the system cache.</span>
05938 <span class="comment"></span>
05939 <span class="comment">    Length - Supplies the length of the range.</span>
05940 <span class="comment"></span>
05941 <span class="comment">Return Value:</span>
05942 <span class="comment"></span>
05943 <span class="comment">    TRUE if at least one PTE was dirty in the range, FALSE otherwise.</span>
05944 <span class="comment"></span>
05945 <span class="comment">Environment:</span>
05946 <span class="comment"></span>
05947 <span class="comment">    Kernel mode.  APC_LEVEL and below for pagable addresses,</span>
05948 <span class="comment">                  DISPATCH_LEVEL and below for non-pagable addresses.</span>
05949 <span class="comment"></span>
05950 <span class="comment">--*/</span>
05951 
05952 {
05953     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
05954     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> LastPte;
05955     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
05956     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> FlushPte;
05957     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> PteContents;
05958     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> FlushContents;
05959     KIRQL OldIrql;
05960     PVOID VaFlushList[<a class="code" href="../../d4/d8/mi_8h.html#a34">MM_MAXIMUM_FLUSH_COUNT</a>];
05961     ULONG <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>;
05962     BOOLEAN Result;
05963 
05964     <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> = 0;
05965     Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
05966 
05967     <span class="comment">//</span>
05968     <span class="comment">// Loop on the copy on write case until the page is only</span>
05969     <span class="comment">// writable.</span>
05970     <span class="comment">//</span>
05971 
05972     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (Address);
05973     LastPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> ((PVOID)((PCHAR)Address + Length - 1));
05974 
05975     <a class="code" href="../../d4/d8/mi_8h.html#a130">LOCK_PFN2</a> (OldIrql);
05976 
05977     <span class="keywordflow">do</span> {
05978 
05979         PteContents = *PointerPte;
05980 
05981         <span class="keywordflow">if</span> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1) {
05982 
05983             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
05984             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.Modified = 1;
05985 
05986             <span class="keywordflow">if</span> ((Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Prototype == 0) &amp;&amp;
05987                          (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.WriteInProgress == 0)) {
05988                 <a class="code" href="../../d4/d8/mi_8h.html#a889">MiReleasePageFileSpace</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>);
05989                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.PageFileHigh = 0;
05990             }
05991 
05992 <span class="preprocessor">#ifdef NT_UP</span>
05993 <span class="preprocessor"></span>            <span class="comment">//</span>
05994             <span class="comment">// On uniprocessor systems no need to flush if this processor</span>
05995             <span class="comment">// doesn't think the PTE is dirty.</span>
05996             <span class="comment">//</span>
05997 
05998             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a114">MI_IS_PTE_DIRTY</a> (PteContents)) {
05999                 Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
06000 <span class="preprocessor">#else  //NT_UP</span>
06001 <span class="preprocessor"></span>                Result |= (BOOLEAN)(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a114">MI_IS_PTE_DIRTY</a> (PteContents));
06002 <span class="preprocessor">#endif //NT_UP</span>
06003 <span class="preprocessor"></span>                <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a113">MI_SET_PTE_CLEAN</a> (PteContents);
06004                 <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a188">MI_WRITE_VALID_PTE_NEW_PROTECTION</a> (PointerPte, PteContents);
06005                 FlushContents = PteContents;
06006                 FlushPte = PointerPte;
06007 
06008                 <span class="comment">//</span>
06009                 <span class="comment">// Clear the write bit in the PTE so new writes can be tracked.</span>
06010                 <span class="comment">//</span>
06011 
06012                 <span class="keywordflow">if</span> (<a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> != <a class="code" href="../../d4/d8/mi_8h.html#a34">MM_MAXIMUM_FLUSH_COUNT</a>) {
06013                     VaFlushList[<a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>] = Address;
06014                     <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> += 1;
06015                 }
06016 <span class="preprocessor">#ifdef NT_UP</span>
06017 <span class="preprocessor"></span>            }
06018 <span class="preprocessor">#endif //NT_UP</span>
06019 <span class="preprocessor"></span>        }
06020         PointerPte += 1;
06021         Address = (PVOID)((PCHAR)Address + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
06022     } <span class="keywordflow">while</span> (PointerPte &lt;= LastPte);
06023 
06024     <span class="keywordflow">if</span> (<a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> != 0) {
06025         <span class="keywordflow">if</span> (<a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> == 1) {
06026 
06027             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d0/d6/ppc_2flushtb_8c.html#a2">KeFlushSingleTb</a> (VaFlushList[0],
06028                                    <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
06029                                    <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
06030                                    (PHARDWARE_PTE)FlushPte,
06031                                    FlushContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Flush);
06032 
06033         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> != <a class="code" href="../../d4/d8/mi_8h.html#a34">MM_MAXIMUM_FLUSH_COUNT</a>) {
06034 
06035             <a class="code" href="../../d0/d6/ppc_2flushtb_8c.html#a1">KeFlushMultipleTb</a> (<a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>,
06036                                &amp;VaFlushList[0],
06037                                <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
06038                                <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
06039                                <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
06040                                *(PHARDWARE_PTE)&amp;<a class="code" href="../../d4/d2/datalpha_8c.html#a0">ZeroPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Flush);
06041 
06042         } <span class="keywordflow">else</span> {
06043             <a class="code" href="../../d0/d6/ppc_2flushtb_8c.html#a0">KeFlushEntireTb</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
06044         }
06045     }
06046     <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
06047     <span class="keywordflow">return</span> Result;
06048 }
06049 
06050 
06051 PVOID
<a name="l06052"></a><a class="code" href="../../d4/d8/mi_8h.html#a795">06052</a> <a class="code" href="../../d4/d8/mi_8h.html#a795">MiCheckForContiguousMemory</a> (
06053     IN PVOID BaseAddress,
06054     IN PFN_NUMBER BaseAddressPages,
06055     IN PFN_NUMBER SizeInPages,
06056     IN PFN_NUMBER LowestPfn,
06057     IN PFN_NUMBER HighestPfn,
06058     IN PFN_NUMBER BoundaryPfn
06059     )
06060 
06061 <span class="comment">/*++</span>
06062 <span class="comment"></span>
06063 <span class="comment">Routine Description:</span>
06064 <span class="comment"></span>
06065 <span class="comment">    This routine checks to see if the physical memory mapped</span>
06066 <span class="comment">    by the specified BaseAddress for the specified size is</span>
06067 <span class="comment">    contiguous and that the first page is greater than or equal to</span>
06068 <span class="comment">    the specified LowestPfn and that the last page of the physical memory is</span>
06069 <span class="comment">    less than or equal to the specified HighestPfn.</span>
06070 <span class="comment"></span>
06071 <span class="comment">Arguments:</span>
06072 <span class="comment"></span>
06073 <span class="comment">    BaseAddress - Supplies the base address to start checking at.</span>
06074 <span class="comment"></span>
06075 <span class="comment">    BaseAddressPages - Supplies the number of pages to scan from the</span>
06076 <span class="comment">                       BaseAddress.</span>
06077 <span class="comment"></span>
06078 <span class="comment">    SizeInPages - Supplies the number of pages in the range.</span>
06079 <span class="comment"></span>
06080 <span class="comment">    LowestPfn - Supplies lowest PFN acceptable as a physical page.</span>
06081 <span class="comment"></span>
06082 <span class="comment">    HighestPfn - Supplies the highest PFN acceptable as a physical page.</span>
06083 <span class="comment"></span>
06084 <span class="comment">    BoundaryPfn - Supplies the PFN multiple the allocation must</span>
06085 <span class="comment">                  not cross.  0 indicates it can cross any boundary.</span>
06086 <span class="comment"></span>
06087 <span class="comment">Return Value:</span>
06088 <span class="comment"></span>
06089 <span class="comment">    Returns the usable virtual address within the argument range that the</span>
06090 <span class="comment">    caller should return to his caller.  NULL if there is no usable address.</span>
06091 <span class="comment"></span>
06092 <span class="comment">Environment:</span>
06093 <span class="comment"></span>
06094 <span class="comment">    Kernel mode, memory management internal.</span>
06095 <span class="comment"></span>
06096 <span class="comment">--*/</span>
06097 
06098 {
06099     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
06100     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> LastPte;
06101     PFN_NUMBER PreviousPage;
06102     PFN_NUMBER Page;
06103     PFN_NUMBER HighestStartPage;
06104     PFN_NUMBER LastPage;
06105     PFN_NUMBER OriginalPage;
06106     PFN_NUMBER OriginalLastPage;
06107     PVOID BoundaryAllocation;
06108     PFN_NUMBER BoundaryMask;
06109     ULONG PageCount;
06110     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> PteContents;
06111 
06112     BoundaryMask = ~(BoundaryPfn - 1);
06113 
06114     <span class="keywordflow">if</span> (LowestPfn &gt; HighestPfn) {
06115         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
06116     }
06117 
06118     <span class="keywordflow">if</span> (LowestPfn + SizeInPages &lt;= LowestPfn) {
06119         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
06120     }
06121 
06122     <span class="keywordflow">if</span> (LowestPfn + SizeInPages &gt; HighestPfn + 1) {
06123         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
06124     }
06125 
06126     <span class="keywordflow">if</span> (BaseAddressPages &lt; SizeInPages) {
06127         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
06128     }
06129 
06130     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a> (BaseAddress)) {
06131 
06132         OriginalPage = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a179">MI_CONVERT_PHYSICAL_TO_PFN</a>(BaseAddress);
06133         OriginalLastPage = OriginalPage + BaseAddressPages;
06134 
06135         Page = OriginalPage;
06136         LastPage = OriginalLastPage;
06137 
06138         <span class="comment">//</span>
06139         <span class="comment">// Close the gaps, then examine the range for a fit.</span>
06140         <span class="comment">//</span>
06141 
06142         <span class="keywordflow">if</span> (Page &lt; LowestPfn) {
06143             Page = LowestPfn;
06144         }
06145 
06146         <span class="keywordflow">if</span> (LastPage &gt; HighestPfn + 1) {
06147             LastPage = HighestPfn + 1;
06148         }
06149 
06150         HighestStartPage = LastPage - SizeInPages;
06151 
06152         <span class="keywordflow">if</span> (Page &gt; HighestStartPage) {
06153             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
06154         }
06155 
06156         <span class="keywordflow">if</span> (BoundaryPfn != 0) {
06157             <span class="keywordflow">do</span> {
06158                 <span class="keywordflow">if</span> (((Page ^ (Page + SizeInPages - 1)) &amp; BoundaryMask) == 0) {
06159 
06160                     <span class="comment">//</span>
06161                     <span class="comment">// This portion of the range meets the alignment</span>
06162                     <span class="comment">// requirements.</span>
06163                     <span class="comment">//</span>
06164 
06165                     <span class="keywordflow">break</span>;
06166                 }
06167                 Page |= (BoundaryPfn - 1);
06168                 Page += 1;
06169             } <span class="keywordflow">while</span> (Page &lt;= HighestStartPage);
06170 
06171             <span class="keywordflow">if</span> (Page &gt; HighestStartPage) {
06172                 <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
06173             }
06174             BoundaryAllocation = (PVOID)((PCHAR)BaseAddress + ((Page - OriginalPage) &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>));
06175 
06176             <span class="comment">//</span>
06177             <span class="comment">// The request can be satisfied.  Since specific alignment was</span>
06178             <span class="comment">// requested, return the fit now without getting fancy.</span>
06179             <span class="comment">//</span>
06180 
06181             <span class="keywordflow">return</span> BoundaryAllocation;
06182         }
06183 
06184         <span class="comment">//</span>
06185         <span class="comment">// If possible return a chunk on the end to reduce fragmentation.</span>
06186         <span class="comment">//</span>
06187     
06188         <span class="keywordflow">if</span> (LastPage == OriginalLastPage) {
06189             <span class="keywordflow">return</span> (PVOID)((PCHAR)BaseAddress + ((BaseAddressPages - SizeInPages) &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>));
06190         }
06191     
06192         <span class="comment">//</span>
06193         <span class="comment">// The end chunk did not satisfy the requirements.  The next best option</span>
06194         <span class="comment">// is to return a chunk from the beginning.  Since that's where the search</span>
06195         <span class="comment">// began, just return the current chunk.</span>
06196         <span class="comment">//</span>
06197 
06198         <span class="keywordflow">return</span> (PVOID)((PCHAR)BaseAddress + ((Page - OriginalPage) &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>));
06199     }
06200 
06201     <span class="comment">//</span>
06202     <span class="comment">// Check the virtual addresses for physical contiguity.</span>
06203     <span class="comment">//</span>
06204 
06205     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (BaseAddress);
06206     LastPte = PointerPte + BaseAddressPages;
06207 
06208     HighestStartPage = HighestPfn + 1 - SizeInPages;
06209     PageCount = 0;
06210 
06211     <span class="keywordflow">while</span> (PointerPte &lt; LastPte) {
06212 
06213         PteContents = *PointerPte;
06214         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1);
06215         Page = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a> (&amp;PteContents);
06216 
06217         <span class="comment">//</span>
06218         <span class="comment">// Before starting a new run, ensure that it</span>
06219         <span class="comment">// can satisfy the location &amp; boundary requirements (if any).</span>
06220         <span class="comment">//</span>
06221 
06222         <span class="keywordflow">if</span> (PageCount == 0) {
06223 
06224             <span class="keywordflow">if</span> ((Page &gt;= LowestPfn) &amp;&amp; (Page &lt;= HighestStartPage)) {
06225 
06226                 <span class="keywordflow">if</span> (BoundaryPfn == 0) {
06227                     PageCount += 1;
06228                 }
06229                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (((Page ^ (Page + SizeInPages - 1)) &amp; BoundaryMask) == 0) {
06230                     <span class="comment">//</span>
06231                     <span class="comment">// This run's physical address meets the alignment</span>
06232                     <span class="comment">// requirement.</span>
06233                     <span class="comment">//</span>
06234 
06235                     PageCount += 1;
06236                 }
06237             }
06238 
06239             <span class="keywordflow">if</span> (PageCount == SizeInPages) {
06240 
06241                 <span class="comment">//</span>
06242                 <span class="comment">// Success - found a single page satifying the requirements.</span>
06243                 <span class="comment">//</span>
06244 
06245                 BaseAddress = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPte);
06246                 <span class="keywordflow">return</span> BaseAddress;
06247             }
06248 
06249             PreviousPage = Page;
06250             PointerPte += 1;
06251             <span class="keywordflow">continue</span>;
06252         }
06253 
06254         <span class="keywordflow">if</span> (Page != PreviousPage + 1) {
06255 
06256             <span class="comment">//</span>
06257             <span class="comment">// This page is not physically contiguous.  Start over.</span>
06258             <span class="comment">//</span>
06259 
06260             PageCount = 0;
06261             <span class="keywordflow">continue</span>;
06262         }
06263 
06264         PageCount += 1;
06265 
06266         <span class="keywordflow">if</span> (PageCount == SizeInPages) {
06267 
06268             <span class="comment">//</span>
06269             <span class="comment">// Success - found a page range satifying the requirements.</span>
06270             <span class="comment">//</span>
06271 
06272             BaseAddress = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPte - PageCount + 1);
06273             <span class="keywordflow">return</span> BaseAddress;
06274         }
06275 
06276         PointerPte += 1;
06277     }
06278 
06279     <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
06280 }
06281 
06282 
06283 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l06284"></a><a class="code" href="../../d5/d6/iosup_8c.html#a76">06284</a> <a class="code" href="../../d5/d6/iosup_8c.html#a76">MmLockPagableSectionByHandle</a> (
06285     IN PVOID ImageSectionHandle
06286     )
06287 
06288 
06289 <span class="comment">/*++</span>
06290 <span class="comment"></span>
06291 <span class="comment">Routine Description:</span>
06292 <span class="comment"></span>
06293 <span class="comment">    This routine checks to see if the specified pages are resident in</span>
06294 <span class="comment">    the process's working set and if so the reference count for the</span>
06295 <span class="comment">    page is incremented.  The allows the virtual address to be accessed</span>
06296 <span class="comment">    without getting a hard page fault (have to go to the disk... except</span>
06297 <span class="comment">    for extremely rare case when the page table page is removed from the</span>
06298 <span class="comment">    working set and migrates to the disk.</span>
06299 <span class="comment"></span>
06300 <span class="comment">    If the virtual address is that of the system wide global "cache" the</span>
06301 <span class="comment">    virtual address of the "locked" pages is always guaranteed to</span>
06302 <span class="comment">    be valid.</span>
06303 <span class="comment"></span>
06304 <span class="comment">    NOTE: This routine is not to be used for general locking of user</span>
06305 <span class="comment">    addresses - use MmProbeAndLockPages.  This routine is intended for</span>
06306 <span class="comment">    well behaved system code like the file system caches which allocates</span>
06307 <span class="comment">    virtual addresses for mapping files AND guarantees that the mapping</span>
06308 <span class="comment">    will not be modified (deleted or changed) while the pages are locked.</span>
06309 <span class="comment"></span>
06310 <span class="comment">Arguments:</span>
06311 <span class="comment"></span>
06312 <span class="comment">    ImageSectionHandle - Supplies the value returned by a previous call</span>
06313 <span class="comment">        to MmLockPagableDataSection.  This is a pointer to the Section</span>
06314 <span class="comment">        header for the image.</span>
06315 <span class="comment"></span>
06316 <span class="comment">Return Value:</span>
06317 <span class="comment"></span>
06318 <span class="comment">    None.</span>
06319 <span class="comment"></span>
06320 <span class="comment">Environment:</span>
06321 <span class="comment"></span>
06322 <span class="comment">    Kernel mode, IRQL of DISPATCH_LEVEL or below.</span>
06323 <span class="comment"></span>
06324 <span class="comment">--*/</span>
06325 
06326 {
06327     PIMAGE_SECTION_HEADER NtSection;
06328     PVOID BaseAddress;
06329     ULONG SizeToLock;
06330     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
06331     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> LastPte;
06332     KIRQL OldIrql;
06333     KIRQL OldIrqlWs;
06334     ULONG Collision;
06335 
06336     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a>(ImageSectionHandle)) {
06337 
06338         <span class="comment">//</span>
06339         <span class="comment">// No need to lock physical addresses.</span>
06340         <span class="comment">//</span>
06341 
06342         <span class="keywordflow">return</span>;
06343     }
06344 
06345     NtSection = (PIMAGE_SECTION_HEADER)ImageSectionHandle;
06346 
06347     BaseAddress = <a class="code" href="../../d4/d8/mi_8h.html#a217">SECTION_BASE_ADDRESS</a>(NtSection);
06348 
06349     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (!<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a196">MI_IS_SYSTEM_CACHE_ADDRESS</a>(BaseAddress));
06350 
06351     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (BaseAddress &gt;= <a class="code" href="../../d0/d9/miglobal_8c.html#a1">MmSystemRangeStart</a>);
06352 
06353     SizeToLock = NtSection-&gt;SizeOfRawData;
06354     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(BaseAddress);
06355     LastPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>((PCHAR)BaseAddress + SizeToLock - 1);
06356 
06357     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (SizeToLock != 0);
06358 
06359     <span class="comment">//</span>
06360     <span class="comment">// The address must be within the system space.</span>
06361     <span class="comment">//</span>
06362 
06363 RetryLock:
06364 
06365     <a class="code" href="../../d4/d8/mi_8h.html#a144">LOCK_SYSTEM_WS</a> (OldIrqlWs);
06366     <a class="code" href="../../d4/d8/mi_8h.html#a130">LOCK_PFN2</a> (OldIrql);
06367 
06368     <a class="code" href="../../d0/d2/mmsup_8c.html#a10">MiMakeSystemAddressValidPfnSystemWs</a> (&amp;NtSection-&gt;NumberOfLinenumbers);
06369 
06370     <span class="comment">//</span>
06371     <span class="comment">// The NumberOfLinenumbers field is used to store the</span>
06372     <span class="comment">// lock count.</span>
06373     <span class="comment">//</span>
06374     <span class="comment">//  Value of 0 means unlocked,</span>
06375     <span class="comment">//  Value of 1 means lock in progress by another thread.</span>
06376     <span class="comment">//  Value of 2 or more means locked.</span>
06377     <span class="comment">//</span>
06378     <span class="comment">//  If the value is 1, this thread must block until the other thread's</span>
06379     <span class="comment">//  lock operation is complete.</span>
06380     <span class="comment">//</span>
06381 
06382     NtSection-&gt;NumberOfLinenumbers += 1;
06383 
06384     <span class="keywordflow">if</span> (NtSection-&gt;NumberOfLinenumbers &gt;= 3) {
06385 
06386         <span class="comment">//</span>
06387         <span class="comment">// Already locked, increment counter and return.</span>
06388         <span class="comment">//</span>
06389 
06390         <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
06391         <a class="code" href="../../d4/d8/mi_8h.html#a145">UNLOCK_SYSTEM_WS</a> (OldIrqlWs);
06392         <span class="keywordflow">return</span>;
06393     }
06394 
06395     <span class="keywordflow">if</span> (NtSection-&gt;NumberOfLinenumbers == 2) {
06396 
06397         <span class="comment">//</span>
06398         <span class="comment">// A lock is in progress.</span>
06399         <span class="comment">// Reset back to 1 and wait.</span>
06400         <span class="comment">//</span>
06401 
06402         NtSection-&gt;NumberOfLinenumbers = 1;
06403         <a class="code" href="../../d5/d6/iosup_8c.html#a19">MmCollidedLockWait</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
06404 
06405         <a class="code" href="../../d4/d9/ke_8h.html#a28">KeEnterCriticalRegion</a>();
06406 
06407         <span class="comment">//</span>
06408         <span class="comment">// The unlock IRQLs are deliberately reversed as the lock and mutex</span>
06409         <span class="comment">// are being released in reverse order.</span>
06410         <span class="comment">//</span>
06411 
06412         <a class="code" href="../../d4/d8/mi_8h.html#a146">UNLOCK_SYSTEM_WS_NO_IRQL</a> ();
06413         <a class="code" href="../../d4/d8/mi_8h.html#a132">UNLOCK_PFN_AND_THEN_WAIT</a> (OldIrqlWs);
06414 
06415         <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>(&amp;<a class="code" href="../../d5/d6/iosup_8c.html#a18">MmCollidedLockEvent</a>,
06416                               <a class="code" href="../../d4/d9/ke_8h.html#a407a216">WrVirtualMemory</a>,
06417                               <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
06418                               <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
06419                               (PLARGE_INTEGER)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
06420         <a class="code" href="../../d4/d9/ke_8h.html#a29">KeLeaveCriticalRegion</a>();
06421         <span class="keywordflow">goto</span> RetryLock;
06422     }
06423 
06424     <span class="comment">//</span>
06425     <span class="comment">// Value was 0 when the lock was obtained.  It is now 1 indicating</span>
06426     <span class="comment">// a lock is in progress.</span>
06427     <span class="comment">//</span>
06428 
06429     <a class="code" href="../../d4/d8/mi_8h.html#a873">MiLockCode</a> (PointerPte, LastPte, <a class="code" href="../../d4/d8/mi_8h.html#a29">MM_LOCK_BY_REFCOUNT</a>);
06430 
06431     <span class="comment">//</span>
06432     <span class="comment">// Set lock count to 2 (it was 1 when this started) and check</span>
06433     <span class="comment">// to see if any other threads tried to lock while this was happening.</span>
06434     <span class="comment">//</span>
06435 
06436     <a class="code" href="../../d0/d2/mmsup_8c.html#a10">MiMakeSystemAddressValidPfnSystemWs</a> (&amp;NtSection-&gt;NumberOfLinenumbers);
06437     NtSection-&gt;NumberOfLinenumbers += 1;
06438 
06439     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (NtSection-&gt;NumberOfLinenumbers == 2);
06440 
06441     Collision = <a class="code" href="../../d5/d6/iosup_8c.html#a19">MmCollidedLockWait</a>;
06442     <a class="code" href="../../d5/d6/iosup_8c.html#a19">MmCollidedLockWait</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
06443 
06444     <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
06445     <a class="code" href="../../d4/d8/mi_8h.html#a145">UNLOCK_SYSTEM_WS</a> (OldIrqlWs);
06446 
06447     <span class="keywordflow">if</span> (Collision) {
06448 
06449         <span class="comment">//</span>
06450         <span class="comment">// Wake up all waiters.</span>
06451         <span class="comment">//</span>
06452 
06453         <a class="code" href="../../d2/d8/eventobj_8c.html#a5">KePulseEvent</a> (&amp;<a class="code" href="../../d5/d6/iosup_8c.html#a18">MmCollidedLockEvent</a>, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
06454     }
06455 
06456     <span class="keywordflow">return</span>;
06457 }
06458 
06459 
06460 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l06461"></a><a class="code" href="../../d4/d8/mi_8h.html#a873">06461</a> <a class="code" href="../../d4/d8/mi_8h.html#a873">MiLockCode</a> (
06462     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> FirstPte,
06463     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> LastPte,
06464     IN ULONG LockType
06465     )
06466 
06467 <span class="comment">/*++</span>
06468 <span class="comment"></span>
06469 <span class="comment">Routine Description:</span>
06470 <span class="comment"></span>
06471 <span class="comment">    This routine checks to see if the specified pages are resident in</span>
06472 <span class="comment">    the process's working set and if so the reference count for the</span>
06473 <span class="comment">    page is incremented.  This allows the virtual address to be accessed</span>
06474 <span class="comment">    without getting a hard page fault (have to go to the disk...) except</span>
06475 <span class="comment">    for the extremely rare case when the page table page is removed from the</span>
06476 <span class="comment">    working set and migrates to the disk.</span>
06477 <span class="comment"></span>
06478 <span class="comment">    If the virtual address is that of the system wide global "cache", the</span>
06479 <span class="comment">    virtual address of the "locked" pages is always guaranteed to</span>
06480 <span class="comment">    be valid.</span>
06481 <span class="comment"></span>
06482 <span class="comment">    NOTE: This routine is not to be used for general locking of user</span>
06483 <span class="comment">    addresses - use MmProbeAndLockPages.  This routine is intended for</span>
06484 <span class="comment">    well behaved system code like the file system caches which allocates</span>
06485 <span class="comment">    virtual addresses for mapping files AND guarantees that the mapping</span>
06486 <span class="comment">    will not be modified (deleted or changed) while the pages are locked.</span>
06487 <span class="comment"></span>
06488 <span class="comment">Arguments:</span>
06489 <span class="comment"></span>
06490 <span class="comment">    FirstPte - Supplies the base address to begin locking.</span>
06491 <span class="comment"></span>
06492 <span class="comment">    LastPte - The last PTE to lock.</span>
06493 <span class="comment"></span>
06494 <span class="comment">    LockType - Supplies either MM_LOCK_BY_REFCOUNT or MM_LOCK_NONPAGE.</span>
06495 <span class="comment">               LOCK_BY_REFCOUNT increments the reference count to keep</span>
06496 <span class="comment">               the page in memory, LOCK_NONPAGE removes the page from</span>
06497 <span class="comment">               the working set so it's locked just like nonpaged pool.</span>
06498 <span class="comment"></span>
06499 <span class="comment">Return Value:</span>
06500 <span class="comment"></span>
06501 <span class="comment">    None.</span>
06502 <span class="comment"></span>
06503 <span class="comment">Environment:</span>
06504 <span class="comment"></span>
06505 <span class="comment">    Kernel mode, System working set mutex and PFN LOCK held.</span>
06506 <span class="comment"></span>
06507 <span class="comment">--*/</span>
06508 
06509 {
06510     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
06511     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
06512     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> TempPte;
06513     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> PteContents;
06514     <a class="code" href="../../d4/d8/mi_8h.html#a435">WSLE_NUMBER</a> WorkingSetIndex;
06515     <a class="code" href="../../d4/d8/mi_8h.html#a435">WSLE_NUMBER</a> SwapEntry;
06516     PFN_NUMBER PageFrameIndex;
06517     KIRQL OldIrql;
06518     LOGICAL SessionSpace;
06519     <a class="code" href="../../d0/d8/struct__MMWSL.html">PMMWSL</a> WorkingSetList;
06520     <a class="code" href="../../d3/d6/struct__MMSUPPORT.html">PMMSUPPORT</a> Vm;
06521 <span class="preprocessor">#if PFN_CONSISTENCY</span>
06522 <span class="preprocessor"></span>    KIRQL PfnIrql;
06523 <span class="preprocessor">#endif</span>
06524 <span class="preprocessor"></span>
06525     <a class="code" href="../../d4/d8/mi_8h.html#a136">MM_PFN_LOCK_ASSERT</a>();
06526 
06527     SessionSpace = <a class="code" href="../../d4/d8/mi_8h.html#a352">MI_IS_SESSION_IMAGE_ADDRESS</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a>(FirstPte));
06528 
06529     <span class="keywordflow">if</span> (SessionSpace == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
06530         Vm = &amp;<a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o30">Vm</a>;
06531         WorkingSetList = <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o30">Vm</a>.<a class="code" href="../../d3/d6/struct__MMSUPPORT.html#o7">VmWorkingSetList</a>;
06532     }
06533 
06534     <span class="comment">//</span>
06535     <span class="comment">// Session space is never locked by refcount.</span>
06536     <span class="comment">//</span>
06537 
06538     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((SessionSpace == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) || (LockType != <a class="code" href="../../d4/d8/mi_8h.html#a29">MM_LOCK_BY_REFCOUNT</a>));
06539 
06540     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (!<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a>(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a>(FirstPte)));
06541     PointerPte = FirstPte;
06542 
06543     <a class="code" href="../../d5/d6/iosup_8c.html#a20">MmLockedCode</a> += 1 + LastPte - FirstPte;
06544 
06545     <span class="keywordflow">do</span> {
06546 
06547         PteContents = *PointerPte;
06548         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long != <a class="code" href="../../d4/d2/datalpha_8c.html#a1">ZeroKernelPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long);
06549         <span class="keywordflow">if</span> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 0) {
06550 
06551             <span class="keywordflow">if</span> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Prototype == 1) {
06552 
06553                 <span class="comment">//</span>
06554                 <span class="comment">// Page is not in memory and it is a prototype.</span>
06555                 <span class="comment">//</span>
06556 
06557                 <a class="code" href="../../d0/d2/mmsup_8c.html#a10">MiMakeSystemAddressValidPfnSystemWs</a> (
06558                         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a>(PointerPte));
06559 
06560                 <span class="keywordflow">continue</span>;
06561             }
06562             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Transition == 1) {
06563 
06564                 PageFrameIndex = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a183">MI_GET_PAGE_FRAME_FROM_TRANSITION_PTE</a> (&amp;PteContents);
06565 
06566                 Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PageFrameIndex);
06567                 <span class="keywordflow">if</span> ((Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.ReadInProgress) ||
06568                     (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.InPageError)) {
06569 
06570                     <span class="comment">//</span>
06571                     <span class="comment">// Page read is ongoing, force a collided fault.</span>
06572                     <span class="comment">//</span>
06573 
06574                     <a class="code" href="../../d0/d2/mmsup_8c.html#a10">MiMakeSystemAddressValidPfnSystemWs</a> (
06575                             <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a>(PointerPte));
06576 
06577                     <span class="keywordflow">continue</span>;
06578                 }
06579 
06580                 <span class="comment">//</span>
06581                 <span class="comment">// Paged pool is trimmed without regard to sharecounts.</span>
06582                 <span class="comment">// This means a paged pool PTE can be in transition while</span>
06583                 <span class="comment">// the page is still marked active.</span>
06584                 <span class="comment">//</span>
06585 
06586                 <span class="keywordflow">if</span> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageLocation == <a class="code" href="../../d2/d1/mm_8h.html#a345a177">ActiveAndValid</a>) {
06587 
06588                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (((Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> &gt;= <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(<a class="code" href="../../d8/d5/kddata_8c.html#a25">MmPagedPoolStart</a>)) &amp;&amp;
06589                             (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> &lt;= <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(<a class="code" href="../../d8/d5/kddata_8c.html#a26">MmPagedPoolEnd</a>))) ||
06590                             ((Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> &gt;= <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(<a class="code" href="../../d2/d1/mm_8h.html#a160">MmSpecialPoolStart</a>)) &amp;&amp;
06591                             (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> &lt;= <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(<a class="code" href="../../d2/d1/mm_8h.html#a161">MmSpecialPoolEnd</a>))));
06592 
06593                     <span class="comment">//</span>
06594                     <span class="comment">// Don't increment the valid PTE count for the</span>
06595                     <span class="comment">// paged pool page.</span>
06596                     <span class="comment">//</span>
06597 
06598                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount != 0);
06599                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount != 0);
06600                     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount += 1;
06601                 }
06602                 <span class="keywordflow">else</span> {
06603 
06604                     <a class="code" href="../../d7/d5/pfnlist_8c.html#a11">MiUnlinkPageFromList</a> (Pfn1);
06605 
06606                     <span class="comment">//</span>
06607                     <span class="comment">// Set the reference count and share counts to 1.  Note the</span>
06608                     <span class="comment">// reference count may be 1 already if a modified page</span>
06609                     <span class="comment">// write is underway.  The systemwide locked page charges</span>
06610                     <span class="comment">// are correct in either case and nothing needs to be done</span>
06611                     <span class="comment">// just yet.</span>
06612                     <span class="comment">//</span>
06613 
06614                     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount += 1;
06615                     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount = 1;
06616                 }
06617 
06618                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageLocation = <a class="code" href="../../d2/d1/mm_8h.html#a345a177">ActiveAndValid</a>;
06619 
06620                 <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a105">MI_MAKE_VALID_PTE</a> (TempPte,
06621                                    PageFrameIndex,
06622                                    Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Protection,
06623                                    PointerPte);
06624 
06625                 <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a186">MI_WRITE_VALID_PTE</a> (PointerPte, TempPte);
06626 
06627                 <span class="comment">//</span>
06628                 <span class="comment">// Increment the reference count one for putting it the</span>
06629                 <span class="comment">// working set list and one for locking it for I/O.</span>
06630                 <span class="comment">//</span>
06631 
06632                 <span class="keywordflow">if</span> (LockType == <a class="code" href="../../d4/d8/mi_8h.html#a29">MM_LOCK_BY_REFCOUNT</a>) {
06633 
06634                     <span class="comment">//</span>
06635                     <span class="comment">// Lock the page in the working set by upping the</span>
06636                     <span class="comment">// reference count.</span>
06637                     <span class="comment">//</span>
06638 
06639                     <a class="code" href="../../d4/d8/mi_8h.html#a186">MI_ADD_LOCKED_PAGE_CHARGE</a> (Pfn1, 34);
06640                     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount += 1;
06641                     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.Event = (PVOID)<a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
06642 
06643                     <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a52">APC_LEVEL</a>);
06644                     WorkingSetIndex = <a class="code" href="../../d4/d0/wslist_8c.html#a21">MiLocateAndReserveWsle</a> (&amp;<a class="code" href="../../d6/d8/sysinfo_8c.html#a21">MmSystemCacheWs</a>);
06645 
06646                     <a class="code" href="../../d4/d0/wslist_8c.html#a25">MiUpdateWsle</a> (&amp;WorkingSetIndex,
06647                                   <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPte),
06648                                   <a class="code" href="../../d4/d8/mi_8h.html#a657">MmSystemCacheWorkingSetList</a>,
06649                                   Pfn1);
06650 
06651                     <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a109">MI_SET_PTE_IN_WORKING_SET</a> (PointerPte, WorkingSetIndex);
06652 
06653                     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
06654 
06655                 } <span class="keywordflow">else</span> {
06656 
06657                     <span class="comment">//</span>
06658                     <span class="comment">// The wsindex field must be zero because the</span>
06659                     <span class="comment">// page is not in the system (or session) working set.</span>
06660                     <span class="comment">//</span>
06661 
06662                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.WsIndex == 0);
06663 
06664                     <span class="comment">//</span>
06665                     <span class="comment">// Adjust available pages as this page is now not in any</span>
06666                     <span class="comment">// working set, just like a non-paged pool page.  On entry</span>
06667                     <span class="comment">// this page was in transition so it was part of the</span>
06668                     <span class="comment">// available pages by definition.</span>
06669                     <span class="comment">//</span>
06670     
06671                     <a class="code" href="../../d8/d5/kddata_8c.html#a42">MmResidentAvailablePages</a> -= 1;
06672                     <span class="keywordflow">if</span> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PrototypePte == 0) {
06673                         <a class="code" href="../../d6/d8/sysinfo_8c.html#a14">MmTotalSystemDriverPages</a> -= 1;
06674                     }
06675                     <a class="code" href="../../d4/d8/mi_8h.html#a322">MM_BUMP_COUNTER</a>(29, 1);
06676                 }
06677             } <span class="keywordflow">else</span> {
06678 
06679                 <span class="comment">//</span>
06680                 <span class="comment">// Page is not in memory.</span>
06681                 <span class="comment">//</span>
06682 
06683                 <a class="code" href="../../d0/d2/mmsup_8c.html#a10">MiMakeSystemAddressValidPfnSystemWs</a> (
06684                         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a>(PointerPte));
06685 
06686                 <span class="keywordflow">continue</span>;
06687             }
06688 
06689         }
06690         <span class="keywordflow">else</span> {
06691 
06692             <span class="comment">//</span>
06693             <span class="comment">// This address is already in the system (or session) working set.</span>
06694             <span class="comment">//</span>
06695 
06696             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
06697 
06698             <span class="comment">//</span>
06699             <span class="comment">// Up the reference count so the page cannot be released.</span>
06700             <span class="comment">//</span>
06701 
06702             <a class="code" href="../../d4/d8/mi_8h.html#a186">MI_ADD_LOCKED_PAGE_CHARGE</a> (Pfn1, 36);
06703             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount += 1;
06704 
06705             <span class="keywordflow">if</span> (LockType != <a class="code" href="../../d4/d8/mi_8h.html#a29">MM_LOCK_BY_REFCOUNT</a>) {
06706 
06707                 <span class="comment">//</span>
06708                 <span class="comment">// If the page is in the system working set, remove it.</span>
06709                 <span class="comment">// The system working set lock MUST be owned to check to</span>
06710                 <span class="comment">// see if this page is in the working set or not.  This</span>
06711                 <span class="comment">// is because the pager may have just released the PFN lock,</span>
06712                 <span class="comment">// acquired the system lock and is now trying to add the</span>
06713                 <span class="comment">// page to the system working set.</span>
06714                 <span class="comment">//</span>
06715                 <span class="comment">// If the page is in the SESSION working set, it cannot be</span>
06716                 <span class="comment">// removed as all these pages are carefully accounted for.</span>
06717                 <span class="comment">// Instead move it to the locked portion of the working set</span>
06718                 <span class="comment">// if it is not there already.</span>
06719                 <span class="comment">//</span>
06720 
06721                 <span class="keywordflow">if</span> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.WsIndex != 0) {
06722 
06723                     <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a52">APC_LEVEL</a>);
06724 
06725                     <span class="keywordflow">if</span> (SessionSpace == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
06726 
06727                         WorkingSetIndex = <a class="code" href="../../d7/d0/wstree_8c.html#a7">MiLocateWsle</a> (
06728                                     <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a>(PointerPte),
06729                                     WorkingSetList,
06730                                     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.WsIndex);
06731 
06732                         <span class="keywordflow">if</span> (WorkingSetIndex &gt;= WorkingSetList-&gt;<a class="code" href="../../d0/d8/struct__MMWSL.html#o2">FirstDynamic</a>) {
06733                 
06734                             SwapEntry = WorkingSetList-&gt;<a class="code" href="../../d0/d8/struct__MMWSL.html#o2">FirstDynamic</a>;
06735                 
06736                             <span class="keywordflow">if</span> (WorkingSetIndex != WorkingSetList-&gt;<a class="code" href="../../d0/d8/struct__MMWSL.html#o2">FirstDynamic</a>) {
06737                 
06738                                 <span class="comment">//</span>
06739                                 <span class="comment">// Swap this entry with the one at first</span>
06740                                 <span class="comment">// dynamic.  Note that the working set index</span>
06741                                 <span class="comment">// in the PTE is updated here as well.</span>
06742                                 <span class="comment">//</span>
06743                 
06744                                 <a class="code" href="../../d7/d0/wstree_8c.html#a9">MiSwapWslEntries</a> (WorkingSetIndex,
06745                                                   SwapEntry,
06746                                                   Vm);
06747                             }
06748                 
06749                             WorkingSetList-&gt;<a class="code" href="../../d0/d8/struct__MMWSL.html#o2">FirstDynamic</a> += 1;
06750                         }
06751                         <span class="keywordflow">else</span> {
06752                             SwapEntry = WorkingSetIndex;
06753                         }
06754 
06755                         <span class="comment">//</span>
06756                         <span class="comment">// Indicate that the page is locked.</span>
06757                         <span class="comment">//</span>
06758             
06759                         <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o31">Wsle</a>[SwapEntry].<a class="code" href="../../d1/d8/struct__MMWSLE.html#o3">u1</a>.e1.LockedInWs = 1;
06760                     }
06761                     <span class="keywordflow">else</span> {
06762                         <a class="code" href="../../d7/d0/wstree_8c.html#a8">MiRemoveWsle</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.WsIndex, <a class="code" href="../../d4/d8/mi_8h.html#a657">MmSystemCacheWorkingSetList</a>);
06763                         <a class="code" href="../../d4/d0/wslist_8c.html#a24">MiReleaseWsle</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.WsIndex, &amp;<a class="code" href="../../d6/d8/sysinfo_8c.html#a21">MmSystemCacheWs</a>);
06764 
06765                         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a109">MI_SET_PTE_IN_WORKING_SET</a> (PointerPte, 0);
06766                     }
06767 
06768                     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
06769 
06770                     <a class="code" href="../../d4/d8/mi_8h.html#a190">MI_ZERO_WSINDEX</a> (Pfn1);
06771 
06772                     <span class="comment">//</span>
06773                     <span class="comment">// Adjust available pages as this page is now not in any</span>
06774                     <span class="comment">// working set, just like a non-paged pool page.</span>
06775                     <span class="comment">//</span>
06776     
06777                     <a class="code" href="../../d8/d5/kddata_8c.html#a42">MmResidentAvailablePages</a> -= 1;
06778                     <a class="code" href="../../d4/d8/mi_8h.html#a322">MM_BUMP_COUNTER</a>(29, 1);
06779                     <span class="keywordflow">if</span> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PrototypePte == 0) {
06780                         <a class="code" href="../../d6/d8/sysinfo_8c.html#a14">MmTotalSystemDriverPages</a> -= 1;
06781                     }
06782                 }
06783                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount &gt; 1);
06784                 <a class="code" href="../../d4/d8/mi_8h.html#a189">MI_REMOVE_LOCKED_PAGE_CHARGE</a> (Pfn1, 37);
06785                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount -= 1;
06786             }
06787         }
06788 
06789         PointerPte += 1;
06790     } <span class="keywordflow">while</span> (PointerPte &lt;= LastPte);
06791 
06792     <span class="keywordflow">return</span>;
06793 }
06794 
06795 
06796 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l06797"></a><a class="code" href="../../d5/d6/iosup_8c.html#a78">06797</a> <a class="code" href="../../d5/d6/iosup_8c.html#a78">MmGetSectionRange</a>(
06798     IN PVOID AddressWithinSection,
06799     OUT PVOID *StartingSectionAddress,
06800     OUT PULONG SizeofSection
06801     )
06802 {
06803     PLDR_DATA_TABLE_ENTRY DataTableEntry;
06804     ULONG i;
06805     PIMAGE_NT_HEADERS NtHeaders;
06806     PIMAGE_SECTION_HEADER NtSection;
06807     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
06808     ULONG_PTR Rva;
06809 
06810     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
06811 
06812     <span class="comment">//</span>
06813     <span class="comment">// Search the loaded module list for the data table entry that describes</span>
06814     <span class="comment">// the DLL that was just unloaded. It is possible that an entry is not in</span>
06815     <span class="comment">// the list if a failure occurred at a point in loading the DLL just before</span>
06816     <span class="comment">// the data table entry was generated.</span>
06817     <span class="comment">//</span>
06818 
06819     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_NOT_FOUND;
06820 
06821     <a class="code" href="../../d4/d9/ke_8h.html#a28">KeEnterCriticalRegion</a>();
06822     <a class="code" href="../../d5/d8/ex_8h.html#a69">ExAcquireResourceShared</a> (&amp;<a class="code" href="../../d1/d9/ps_8h.html#a57">PsLoadedModuleResource</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
06823 
06824     DataTableEntry = <a class="code" href="../../d4/d8/mi_8h.html#a874">MiLookupDataTableEntry</a> (AddressWithinSection, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
06825     <span class="keywordflow">if</span> (DataTableEntry) {
06826 
06827         Rva = (ULONG_PTR)((PUCHAR)AddressWithinSection - (ULONG_PTR)DataTableEntry-&gt;DllBase);
06828 
06829         NtHeaders = (PIMAGE_NT_HEADERS)<a class="code" href="../../d8/d9/imagedir_8c.html#a0">RtlImageNtHeader</a>(DataTableEntry-&gt;DllBase);
06830 
06831         NtSection = (PIMAGE_SECTION_HEADER)((PCHAR)NtHeaders +
06832                             <span class="keyword">sizeof</span>(ULONG) +
06833                             <span class="keyword">sizeof</span>(IMAGE_FILE_HEADER) +
06834                             NtHeaders-&gt;FileHeader.SizeOfOptionalHeader
06835                             );
06836 
06837         <span class="keywordflow">for</span> (i = 0; i &lt; NtHeaders-&gt;FileHeader.NumberOfSections; i += 1) {
06838 
06839             <span class="keywordflow">if</span> ( Rva &gt;= NtSection-&gt;VirtualAddress &amp;&amp;
06840                  Rva &lt; NtSection-&gt;VirtualAddress + NtSection-&gt;SizeOfRawData ) {
06841 
06842                 <span class="comment">//</span>
06843                 <span class="comment">// Found it</span>
06844                 <span class="comment">//</span>
06845 
06846                 *StartingSectionAddress = (PVOID)
06847                     ((PCHAR) DataTableEntry-&gt;DllBase + NtSection-&gt;VirtualAddress);
06848                 *SizeofSection = NtSection-&gt;SizeOfRawData;
06849                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
06850                 <span class="keywordflow">break</span>;
06851             }
06852 
06853             NtSection += 1;
06854         }
06855     }
06856 
06857     <a class="code" href="../../d5/d8/ex_8h.html#a66">ExReleaseResource</a> (&amp;<a class="code" href="../../d1/d9/ps_8h.html#a57">PsLoadedModuleResource</a>);
06858     <a class="code" href="../../d4/d9/ke_8h.html#a29">KeLeaveCriticalRegion</a>();
06859     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
06860 }
06861 
06862 
06863 PVOID
<a name="l06864"></a><a class="code" href="../../d5/d6/iosup_8c.html#a79">06864</a> <a class="code" href="../../d5/d6/iosup_8c.html#a79">MmLockPagableDataSection</a>(
06865     IN PVOID AddressWithinSection
06866     )
06867 
06868 <span class="comment">/*++</span>
06869 <span class="comment"></span>
06870 <span class="comment">Routine Description:</span>
06871 <span class="comment"></span>
06872 <span class="comment">    This functions locks the entire section that contains the specified</span>
06873 <span class="comment">    section in memory.  This allows pagable code to be brought into</span>
06874 <span class="comment">    memory and to be used as if the code was not really pagable.  This</span>
06875 <span class="comment">    should not be done with a high degree of frequency.</span>
06876 <span class="comment"></span>
06877 <span class="comment">Arguments:</span>
06878 <span class="comment"></span>
06879 <span class="comment">    AddressWithinSection - Supplies the address of a function</span>
06880 <span class="comment">        contained within a section that should be brought in and locked</span>
06881 <span class="comment">        in memory.</span>
06882 <span class="comment"></span>
06883 <span class="comment">Return Value:</span>
06884 <span class="comment"></span>
06885 <span class="comment">    This function returns a value to be used in a subsequent call to</span>
06886 <span class="comment">    MmUnlockPagableImageSection.</span>
06887 <span class="comment"></span>
06888 <span class="comment">--*/</span>
06889 
06890 {
06891     PLDR_DATA_TABLE_ENTRY DataTableEntry;
06892     ULONG i;
06893     PIMAGE_NT_HEADERS NtHeaders;
06894     PIMAGE_SECTION_HEADER NtSection;
06895     PIMAGE_SECTION_HEADER FoundSection;
06896     ULONG_PTR Rva;
06897 
06898     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
06899 
06900     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a>(AddressWithinSection)) {
06901 
06902         <span class="comment">//</span>
06903         <span class="comment">// Physical address, just return that as the handle.</span>
06904         <span class="comment">//</span>
06905 
06906         <span class="keywordflow">return</span> AddressWithinSection;
06907     }
06908 
06909     <span class="comment">//</span>
06910     <span class="comment">// Search the loaded module list for the data table entry that describes</span>
06911     <span class="comment">// the DLL that was just unloaded. It is possible that an entry is not in</span>
06912     <span class="comment">// the list if a failure occurred at a point in loading the DLL just before</span>
06913     <span class="comment">// the data table entry was generated.</span>
06914     <span class="comment">//</span>
06915 
06916     FoundSection = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
06917 
06918     <a class="code" href="../../d4/d9/ke_8h.html#a28">KeEnterCriticalRegion</a>();
06919     <a class="code" href="../../d5/d8/ex_8h.html#a69">ExAcquireResourceShared</a> (&amp;<a class="code" href="../../d1/d9/ps_8h.html#a57">PsLoadedModuleResource</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
06920 
06921     DataTableEntry = <a class="code" href="../../d4/d8/mi_8h.html#a874">MiLookupDataTableEntry</a> (AddressWithinSection, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
06922 
06923     Rva = (ULONG_PTR)((PUCHAR)AddressWithinSection - (ULONG_PTR)DataTableEntry-&gt;DllBase);
06924 
06925     NtHeaders = (PIMAGE_NT_HEADERS)<a class="code" href="../../d8/d9/imagedir_8c.html#a0">RtlImageNtHeader</a>(DataTableEntry-&gt;DllBase);
06926 
06927     NtSection = (PIMAGE_SECTION_HEADER)((ULONG_PTR)NtHeaders +
06928                         <span class="keyword">sizeof</span>(ULONG) +
06929                         <span class="keyword">sizeof</span>(IMAGE_FILE_HEADER) +
06930                         NtHeaders-&gt;FileHeader.SizeOfOptionalHeader
06931                         );
06932 
06933     <span class="keywordflow">for</span> (i = 0; i &lt; NtHeaders-&gt;FileHeader.NumberOfSections; i += 1) {
06934 
06935         <span class="keywordflow">if</span> ( Rva &gt;= NtSection-&gt;VirtualAddress &amp;&amp;
06936              Rva &lt; NtSection-&gt;VirtualAddress + NtSection-&gt;SizeOfRawData ) {
06937             FoundSection = NtSection;
06938 
06939             <span class="keywordflow">if</span> (<a class="code" href="../../d4/d8/mi_8h.html#a217">SECTION_BASE_ADDRESS</a>(NtSection) != ((PUCHAR)DataTableEntry-&gt;DllBase +
06940                             NtSection-&gt;VirtualAddress)) {
06941 
06942                 <span class="comment">//</span>
06943                 <span class="comment">// Overwrite the PointerToRelocations field (and on Win64, the</span>
06944                 <span class="comment">// PointerToLinenumbers field also) so that it contains</span>
06945                 <span class="comment">// the Va of this section and NumberOfLinenumbers so it contains</span>
06946                 <span class="comment">// the Lock Count for the section.</span>
06947                 <span class="comment">//</span>
06948 
06949                 <a class="code" href="../../d4/d8/mi_8h.html#a217">SECTION_BASE_ADDRESS</a>(NtSection) = ((PUCHAR)DataTableEntry-&gt;DllBase +
06950                                         NtSection-&gt;VirtualAddress);
06951                 NtSection-&gt;NumberOfLinenumbers = 0;
06952             }
06953 
06954             <span class="comment">//</span>
06955             <span class="comment">// Now lock in the code</span>
06956             <span class="comment">//</span>
06957 
06958 <span class="preprocessor">#if DBG</span>
06959 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (MmDebug &amp; <a class="code" href="../../d4/d8/mi_8h.html#a78">MM_DBG_LOCK_CODE</a>) {
06960                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"MM Lock %wZ %8s %p -&gt; %p : %p %3ld.\n"</span>,
06961                         &amp;DataTableEntry-&gt;BaseDllName,
06962                         NtSection-&gt;Name,
06963                         AddressWithinSection,
06964                         NtSection,
06965                         <a class="code" href="../../d4/d8/mi_8h.html#a217">SECTION_BASE_ADDRESS</a>(NtSection),
06966                         NtSection-&gt;NumberOfLinenumbers);
06967             }
06968 <span class="preprocessor">#endif //DBG</span>
06969 <span class="preprocessor"></span>
06970             <a class="code" href="../../d5/d6/iosup_8c.html#a76">MmLockPagableSectionByHandle</a> ((PVOID)NtSection);
06971 
06972             <span class="keywordflow">break</span>;
06973         }
06974         NtSection += 1;
06975     }
06976 
06977     <a class="code" href="../../d5/d8/ex_8h.html#a66">ExReleaseResource</a> (&amp;<a class="code" href="../../d1/d9/ps_8h.html#a57">PsLoadedModuleResource</a>);
06978     <a class="code" href="../../d4/d9/ke_8h.html#a29">KeLeaveCriticalRegion</a>();
06979     <span class="keywordflow">if</span> (!FoundSection) {
06980         <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a> (MEMORY_MANAGEMENT,
06981                       0x1234,
06982                       (ULONG_PTR)AddressWithinSection,
06983                       0,
06984                       0);
06985     }
06986     <span class="keywordflow">return</span> (PVOID)FoundSection;
06987 }
06988 
06989 
06990 PLDR_DATA_TABLE_ENTRY
<a name="l06991"></a><a class="code" href="../../d4/d8/mi_8h.html#a874">06991</a> <a class="code" href="../../d4/d8/mi_8h.html#a874">MiLookupDataTableEntry</a> (
06992     IN PVOID AddressWithinSection,
06993     IN ULONG ResourceHeld
06994     )
06995 
06996 <span class="comment">/*++</span>
06997 <span class="comment"></span>
06998 <span class="comment">Routine Description:</span>
06999 <span class="comment"></span>
07000 <span class="comment">    This functions locates the data table entry that maps the specified address.</span>
07001 <span class="comment"></span>
07002 <span class="comment">Arguments:</span>
07003 <span class="comment"></span>
07004 <span class="comment">    AddressWithinSection - Supplies the address of a function contained</span>
07005 <span class="comment">                           within the desired module.</span>
07006 <span class="comment"></span>
07007 <span class="comment">    ResourceHeld - Supplies TRUE if the loaded module resource is already held,</span>
07008 <span class="comment">                   FALSE if not.</span>
07009 <span class="comment"></span>
07010 <span class="comment">Return Value:</span>
07011 <span class="comment"></span>
07012 <span class="comment">    The address of the loaded module list data table entry that maps the</span>
07013 <span class="comment">    argument address.</span>
07014 <span class="comment"></span>
07015 <span class="comment">--*/</span>
07016 
07017 {
07018     PLDR_DATA_TABLE_ENTRY DataTableEntry;
07019     PLDR_DATA_TABLE_ENTRY FoundEntry = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
07020     PLIST_ENTRY NextEntry;
07021 
07022     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
07023 
07024     <span class="comment">//</span>
07025     <span class="comment">// Search the loaded module list for the data table entry that describes</span>
07026     <span class="comment">// the DLL that was just unloaded. It is possible that an entry is not in</span>
07027     <span class="comment">// the list if a failure occurred at a point in loading the DLL just before</span>
07028     <span class="comment">// the data table entry was generated.</span>
07029     <span class="comment">//</span>
07030 
07031     <span class="keywordflow">if</span> (!ResourceHeld) {
07032         <a class="code" href="../../d4/d9/ke_8h.html#a28">KeEnterCriticalRegion</a>();
07033         <a class="code" href="../../d5/d8/ex_8h.html#a69">ExAcquireResourceShared</a> (&amp;<a class="code" href="../../d1/d9/ps_8h.html#a57">PsLoadedModuleResource</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
07034     }
07035 
07036     NextEntry = <a class="code" href="../../d1/d9/ps_8h.html#a56">PsLoadedModuleList</a>.Flink;
07037     <span class="keywordflow">do</span> {
07038 
07039         DataTableEntry = CONTAINING_RECORD(NextEntry,
07040                                            LDR_DATA_TABLE_ENTRY,
07041                                            InLoadOrderLinks);
07042 
07043         <span class="comment">//</span>
07044         <span class="comment">// Locate the loaded module that contains this address.</span>
07045         <span class="comment">//</span>
07046 
07047         <span class="keywordflow">if</span> ( AddressWithinSection &gt;= DataTableEntry-&gt;DllBase &amp;&amp;
07048              AddressWithinSection &lt; (PVOID)((PUCHAR)DataTableEntry-&gt;DllBase+DataTableEntry-&gt;SizeOfImage) ) {
07049 
07050             FoundEntry = DataTableEntry;
07051             <span class="keywordflow">break</span>;
07052         }
07053 
07054         NextEntry = NextEntry-&gt;Flink;
07055     } <span class="keywordflow">while</span> (NextEntry != &amp;<a class="code" href="../../d1/d9/ps_8h.html#a56">PsLoadedModuleList</a>);
07056 
07057     <span class="keywordflow">if</span> (!ResourceHeld) {
07058         <a class="code" href="../../d5/d8/ex_8h.html#a66">ExReleaseResource</a> (&amp;<a class="code" href="../../d1/d9/ps_8h.html#a57">PsLoadedModuleResource</a>);
07059         <a class="code" href="../../d4/d9/ke_8h.html#a29">KeLeaveCriticalRegion</a>();
07060     }
07061     <span class="keywordflow">return</span> FoundEntry;
07062 }
07063 
07064 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l07065"></a><a class="code" href="../../d5/d6/iosup_8c.html#a81">07065</a> <a class="code" href="../../d5/d6/iosup_8c.html#a81">MmUnlockPagableImageSection</a>(
07066     IN PVOID ImageSectionHandle
07067     )
07068 
07069 <span class="comment">/*++</span>
07070 <span class="comment"></span>
07071 <span class="comment">Routine Description:</span>
07072 <span class="comment"></span>
07073 <span class="comment">    This function unlocks from memory, the pages locked by a preceding call to</span>
07074 <span class="comment">    MmLockPagableDataSection.</span>
07075 <span class="comment"></span>
07076 <span class="comment">Arguments:</span>
07077 <span class="comment"></span>
07078 <span class="comment">    ImageSectionHandle - Supplies the value returned by a previous call</span>
07079 <span class="comment">        to MmLockPagableDataSection.</span>
07080 <span class="comment"></span>
07081 <span class="comment">Return Value:</span>
07082 <span class="comment"></span>
07083 <span class="comment">    None.</span>
07084 <span class="comment"></span>
07085 <span class="comment">--*/</span>
07086 
07087 {
07088     PIMAGE_SECTION_HEADER NtSection;
07089     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
07090     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> LastPte;
07091     PFN_NUMBER PageFrameIndex;
07092     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
07093     KIRQL OldIrql;
07094     PVOID BaseAddress;
07095     ULONG SizeToUnlock;
07096     ULONG Collision;
07097 
07098     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a>(ImageSectionHandle)) {
07099 
07100         <span class="comment">//</span>
07101         <span class="comment">// No need to lock physical addresses.</span>
07102         <span class="comment">//</span>
07103 
07104         <span class="keywordflow">return</span>;
07105     }
07106 
07107     NtSection = (PIMAGE_SECTION_HEADER)ImageSectionHandle;
07108 
07109     BaseAddress = <a class="code" href="../../d4/d8/mi_8h.html#a217">SECTION_BASE_ADDRESS</a>(NtSection);
07110     SizeToUnlock = NtSection-&gt;SizeOfRawData;
07111 
07112     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(BaseAddress);
07113     LastPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>((PCHAR)BaseAddress + SizeToUnlock - 1);
07114 
07115     <span class="comment">//</span>
07116     <span class="comment">// Address must be within the system cache.</span>
07117     <span class="comment">//</span>
07118 
07119     <a class="code" href="../../d4/d8/mi_8h.html#a130">LOCK_PFN2</a> (OldIrql);
07120 
07121     <span class="comment">//</span>
07122     <span class="comment">// The NumberOfLinenumbers field is used to store the</span>
07123     <span class="comment">// lock count.</span>
07124     <span class="comment">//</span>
07125 
07126     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (NtSection-&gt;NumberOfLinenumbers &gt;= 2);
07127     NtSection-&gt;NumberOfLinenumbers -= 1;
07128 
07129     <span class="keywordflow">if</span> (NtSection-&gt;NumberOfLinenumbers != 1) {
07130         <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
07131         <span class="keywordflow">return</span>;
07132     }
07133 
07134     <span class="keywordflow">do</span> {
07135         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1);
07136 
07137         PageFrameIndex = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a> (PointerPte);
07138         Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PageFrameIndex);
07139 
07140         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount &gt; 1);
07141 
07142         <a class="code" href="../../d4/d8/mi_8h.html#a189">MI_REMOVE_LOCKED_PAGE_CHARGE</a> (Pfn1, 37);
07143 
07144         <a class="code" href="../../d6/d5/pfndec_8c.html#a2">MiDecrementReferenceCount</a> (PageFrameIndex);
07145 
07146         PointerPte += 1;
07147 
07148     } <span class="keywordflow">while</span> (PointerPte &lt;= LastPte);
07149 
07150     NtSection-&gt;NumberOfLinenumbers -= 1;
07151     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (NtSection-&gt;NumberOfLinenumbers == 0);
07152     Collision = <a class="code" href="../../d5/d6/iosup_8c.html#a19">MmCollidedLockWait</a>;
07153     <a class="code" href="../../d5/d6/iosup_8c.html#a19">MmCollidedLockWait</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
07154     <a class="code" href="../../d5/d6/iosup_8c.html#a20">MmLockedCode</a> -= SizeToUnlock;
07155 
07156     <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
07157 
07158     <span class="keywordflow">if</span> (Collision) {
07159         <a class="code" href="../../d2/d8/eventobj_8c.html#a5">KePulseEvent</a> (&amp;<a class="code" href="../../d5/d6/iosup_8c.html#a18">MmCollidedLockEvent</a>, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
07160     }
07161 
07162     <span class="keywordflow">return</span>;
07163 }
07164 
07165 
07166 BOOLEAN
<a name="l07167"></a><a class="code" href="../../d5/d6/iosup_8c.html#a27">07167</a> <a class="code" href="../../d2/d1/mm_8h.html#a16">MmIsRecursiveIoFault</a>(
07168     VOID
07169     )
07170 
07171 <span class="comment">/*++</span>
07172 <span class="comment"></span>
07173 <span class="comment">Routine Description:</span>
07174 <span class="comment"></span>
07175 <span class="comment">    This function examines the thread's page fault clustering information</span>
07176 <span class="comment">    and determines if the current page fault is occurring during an I/O</span>
07177 <span class="comment">    operation.</span>
07178 <span class="comment"></span>
07179 <span class="comment">Arguments:</span>
07180 <span class="comment"></span>
07181 <span class="comment">    None.</span>
07182 <span class="comment"></span>
07183 <span class="comment">Return Value:</span>
07184 <span class="comment"></span>
07185 <span class="comment">    Returns TRUE if the fault is occurring during an I/O operation,</span>
07186 <span class="comment">    FALSE otherwise.</span>
07187 <span class="comment"></span>
07188 <span class="comment">--*/</span>
07189 
07190 {
07191     <span class="keywordflow">return</span> (BOOLEAN)(<a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>()-&gt;DisablePageFaultClustering |
07192                      <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>()-&gt;ForwardClusterOnly);
07193 }
07194 
07195 
07196 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l07197"></a><a class="code" href="../../d5/d6/iosup_8c.html#a82">07197</a> <a class="code" href="../../d5/d6/iosup_8c.html#a82">MmMapMemoryDumpMdl</a>(
07198     IN OUT <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MemoryDumpMdl
07199     )
07200 
07201 <span class="comment">/*++</span>
07202 <span class="comment"></span>
07203 <span class="comment">Routine Description:</span>
07204 <span class="comment"></span>
07205 <span class="comment">    For use by crash dump routine ONLY.  Maps an MDL into a fixed</span>
07206 <span class="comment">    portion of the address space.  Only 1 MDL can be mapped at a</span>
07207 <span class="comment">    time.</span>
07208 <span class="comment"></span>
07209 <span class="comment">Arguments:</span>
07210 <span class="comment"></span>
07211 <span class="comment">    MemoryDumpMdl - Supplies the MDL to map.</span>
07212 <span class="comment"></span>
07213 <span class="comment">Return Value:</span>
07214 <span class="comment"></span>
07215 <span class="comment">    None, fields in MDL updated.</span>
07216 <span class="comment"></span>
07217 <span class="comment">--*/</span>
07218 
07219 {
07220     PFN_NUMBER NumberOfPages;
07221     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
07222     PCHAR BaseVa;
07223     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> TempPte;
07224     PPFN_NUMBER Page;
07225 
07226     NumberOfPages = <a class="code" href="../../d2/d1/mm_8h.html#a5">BYTES_TO_PAGES</a> (MemoryDumpMdl-&gt;ByteCount + MemoryDumpMdl-&gt;ByteOffset);
07227 
07228     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (NumberOfPages &lt;= 16);
07229 
07230     PointerPte = <a class="code" href="../../d4/d2/datalpha_8c.html#a19">MmCrashDumpPte</a>;
07231     BaseVa = (PCHAR)<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a>(PointerPte);
07232     MemoryDumpMdl-&gt;MappedSystemVa = (PCHAR)BaseVa + MemoryDumpMdl-&gt;ByteOffset;
07233     TempPte = <a class="code" href="../../d4/d2/datalpha_8c.html#a2">ValidKernelPte</a>;
07234     Page = (PPFN_NUMBER)(MemoryDumpMdl + 1);
07235 
07236     <span class="comment">//</span>
07237     <span class="comment">// If the pages don't span the entire dump virtual address range,</span>
07238     <span class="comment">// build a barrier.  Otherwise use the default barrier provided at the</span>
07239     <span class="comment">// end of the dump virtual address range.</span>
07240     <span class="comment">//</span>
07241 
07242     <span class="keywordflow">if</span> (NumberOfPages &lt; 16) {
07243         <a class="code" href="../../d0/d0/ki_8h.html#a114">KiFlushSingleTb</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, BaseVa + (NumberOfPages &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>));
07244         (PointerPte + NumberOfPages)-&gt;u.Long = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a96">MM_KERNEL_DEMAND_ZERO_PTE</a>;
07245     }
07246 
07247     <span class="keywordflow">do</span> {
07248 
07249         <a class="code" href="../../d0/d0/ki_8h.html#a114">KiFlushSingleTb</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, BaseVa);
07250 
07251         TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber = *Page;
07252 
07253         <span class="comment">//</span>
07254         <span class="comment">// Note this PTE may be valid or invalid prior to the overwriting here.</span>
07255         <span class="comment">//</span>
07256 
07257         *PointerPte = TempPte;
07258 
07259         Page += 1;
07260         PointerPte += 1;
07261         BaseVa += <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
07262         NumberOfPages -= 1;
07263     } <span class="keywordflow">while</span> (NumberOfPages != 0);
07264 
07265     <span class="keywordflow">return</span>;
07266 }
07267 
07268 
07269 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l07270"></a><a class="code" href="../../d5/d6/iosup_8c.html#a83">07270</a> <a class="code" href="../../d5/d6/iosup_8c.html#a83">MmReleaseDumpAddresses</a> (
07271     IN PFN_NUMBER Pages
07272     )
07273 
07274 <span class="comment">/*++</span>
07275 <span class="comment"></span>
07276 <span class="comment">Routine Description:</span>
07277 <span class="comment"></span>
07278 <span class="comment">    For use by hibernate routine ONLY.  Puts zeros back into the</span>
07279 <span class="comment">    used dump PTEs.</span>
07280 <span class="comment"></span>
07281 <span class="comment">Arguments:</span>
07282 <span class="comment"></span>
07283 <span class="comment">    None</span>
07284 <span class="comment"></span>
07285 <span class="comment">Return Value:</span>
07286 <span class="comment"></span>
07287 <span class="comment">    None</span>
07288 <span class="comment"></span>
07289 <span class="comment">--*/</span>
07290 
07291 {
07292     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
07293     PCHAR BaseVa;
07294 
07295     PointerPte = <a class="code" href="../../d4/d2/datalpha_8c.html#a19">MmCrashDumpPte</a>;
07296     BaseVa = (PCHAR)<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a>(PointerPte);
07297 
07298     <span class="keywordflow">while</span> (Pages) {
07299 
07300         <a class="code" href="../../d0/d0/ki_8h.html#a114">KiFlushSingleTb</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, BaseVa);
07301 
07302         PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a93">MM_ZERO_PTE</a>;
07303         PointerPte += 1;
07304         BaseVa += <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
07305         Pages -= 1;
07306     }
07307 }
07308 
07309 
07310 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l07311"></a><a class="code" href="../../d5/d6/iosup_8c.html#a84">07311</a> <a class="code" href="../../d5/d6/iosup_8c.html#a84">MmSetBankedSection</a> (
07312     IN HANDLE ProcessHandle,
07313     IN PVOID VirtualAddress,
07314     IN ULONG BankLength,
07315     IN BOOLEAN ReadWriteBank,
07316     IN <a class="code" href="../../d2/d1/mm_8h.html#a162">PBANKED_SECTION_ROUTINE</a> BankRoutine,
07317     IN PVOID Context
07318     )
07319 
07320 <span class="comment">/*++</span>
07321 <span class="comment"></span>
07322 <span class="comment">Routine Description:</span>
07323 <span class="comment"></span>
07324 <span class="comment">    This function declares a mapped video buffer as a banked</span>
07325 <span class="comment">    section.  This allows banked video devices (i.e., even</span>
07326 <span class="comment">    though the video controller has a megabyte or so of memory,</span>
07327 <span class="comment">    only a small bank (like 64k) can be mapped at any one time.</span>
07328 <span class="comment"></span>
07329 <span class="comment">    In order to overcome this problem, the pager handles faults</span>
07330 <span class="comment">    to this memory, unmaps the current bank, calls off to the</span>
07331 <span class="comment">    video driver and then maps in the new bank.</span>
07332 <span class="comment"></span>
07333 <span class="comment">    This function creates the necessary structures to allow the</span>
07334 <span class="comment">    video driver to be called from the pager.</span>
07335 <span class="comment"></span>
07336 <span class="comment"> ********************* NOTE NOTE NOTE *************************</span>
07337 <span class="comment">    At this time only read/write banks are supported!</span>
07338 <span class="comment"></span>
07339 <span class="comment">Arguments:</span>
07340 <span class="comment"></span>
07341 <span class="comment">    ProcessHandle - Supplies a handle to the process in which to</span>
07342 <span class="comment">                    support the banked video function.</span>
07343 <span class="comment"></span>
07344 <span class="comment">    VirtualAddress - Supplies the virtual address where the video</span>
07345 <span class="comment">                     buffer is mapped in the specified process.</span>
07346 <span class="comment"></span>
07347 <span class="comment">    BankLength - Supplies the size of the bank.</span>
07348 <span class="comment"></span>
07349 <span class="comment">    ReadWriteBank - Supplies TRUE if the bank is read and write.</span>
07350 <span class="comment"></span>
07351 <span class="comment">    BankRoutine - Supplies a pointer to the routine that should be</span>
07352 <span class="comment">                  called by the pager.</span>
07353 <span class="comment"></span>
07354 <span class="comment">    Context - Supplies a context to be passed by the pager to the</span>
07355 <span class="comment">              BankRoutine.</span>
07356 <span class="comment"></span>
07357 <span class="comment">Return Value:</span>
07358 <span class="comment"></span>
07359 <span class="comment">    Returns the status of the function.</span>
07360 <span class="comment"></span>
07361 <span class="comment">Environment:</span>
07362 <span class="comment"></span>
07363 <span class="comment">    Kernel mode, APC_LEVEL or below.</span>
07364 <span class="comment"></span>
07365 <span class="comment">--*/</span>
07366 
07367 {
07368     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
07369     <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process;
07370     <a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a> Vad;
07371     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
07372     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> LastPte;
07373     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> TempPte;
07374     ULONG_PTR size;
07375     LONG count;
07376     ULONG NumberOfPtes;
07377     <a class="code" href="../../d0/d1/struct__MMBANKED__SECTION.html">PMMBANKED_SECTION</a> Bank;
07378 
07379     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a> ();
07380 
07381     UNREFERENCED_PARAMETER (ReadWriteBank);
07382 
07383     <span class="comment">//</span>
07384     <span class="comment">// Reference the specified process handle for VM_OPERATION access.</span>
07385     <span class="comment">//</span>
07386 
07387     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a> ( ProcessHandle,
07388                                          PROCESS_VM_OPERATION,
07389                                          <a class="code" href="../../d9/d8/ntos_8h.html#a2">PsProcessType</a>,
07390                                          <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
07391                                          (PVOID *)&amp;Process,
07392                                          <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
07393 
07394     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
07395         <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
07396     }
07397 
07398     <a class="code" href="../../d3/d5/procobj_8c.html#a4">KeAttachProcess</a> (&amp;Process-&gt;Pcb);
07399 
07400     <span class="comment">//</span>
07401     <span class="comment">// Get the address creation mutex to block multiple threads from</span>
07402     <span class="comment">// creating or deleting address space at the same time and</span>
07403     <span class="comment">// get the working set mutex so virtual address descriptors can</span>
07404     <span class="comment">// be inserted and walked.  Block APCs so an APC which takes a page</span>
07405     <span class="comment">// fault does not corrupt various structures.</span>
07406     <span class="comment">//</span>
07407 
07408     <a class="code" href="../../d4/d8/mi_8h.html#a161">LOCK_WS_AND_ADDRESS_SPACE</a> (Process);
07409 
07410     <span class="comment">//</span>
07411     <span class="comment">// Make sure the address space was not deleted, if so, return an error.</span>
07412     <span class="comment">//</span>
07413 
07414     <span class="keywordflow">if</span> (Process-&gt;AddressSpaceDeleted != 0) {
07415         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_PROCESS_IS_TERMINATING;
07416         <span class="keywordflow">goto</span> ErrorReturn;
07417     }
07418 
07419     Vad = <a class="code" href="../../d6/d3/vadtree_8c.html#a2">MiLocateAddress</a> (VirtualAddress);
07420 
07421     <span class="keywordflow">if</span> ((Vad == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) ||
07422         (Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o0">StartingVpn</a> != <a class="code" href="../../d4/d8/mi_8h.html#a107">MI_VA_TO_VPN</a> (VirtualAddress)) ||
07423         (Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.VadFlags.PhysicalMapping == 0)) {
07424         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_NOT_MAPPED_DATA;
07425         <span class="keywordflow">goto</span> ErrorReturn;
07426     }
07427 
07428     size = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> + ((Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o1">EndingVpn</a> - Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o0">StartingVpn</a>) &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
07429     <span class="keywordflow">if</span> ((size % BankLength) != 0) {
07430         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_VIEW_SIZE;
07431         <span class="keywordflow">goto</span> ErrorReturn;
07432     }
07433 
07434     count = -1;
07435     NumberOfPtes = BankLength;
07436 
07437     <span class="keywordflow">do</span> {
07438         NumberOfPtes = NumberOfPtes &gt;&gt; 1;
07439         count += 1;
07440     } <span class="keywordflow">while</span> (NumberOfPtes != 0);
07441 
07442     <span class="comment">//</span>
07443     <span class="comment">// Turn VAD into Banked VAD</span>
07444     <span class="comment">//</span>
07445 
07446     NumberOfPtes = BankLength &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
07447 
07448     Bank = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a> (<a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
07449                                     <span class="keyword">sizeof</span> (<a class="code" href="../../d0/d1/struct__MMBANKED__SECTION.html">MMBANKED_SECTION</a>) +
07450                                        (NumberOfPtes - 1) * <span class="keyword">sizeof</span>(<a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a>),
07451                                     '  mM');
07452     <span class="keywordflow">if</span> (Bank == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
07453         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INSUFFICIENT_RESOURCES;
07454         <span class="keywordflow">goto</span> ErrorReturn;
07455     }
07456 
07457     Bank-&gt;<a class="code" href="../../d0/d1/struct__MMBANKED__SECTION.html#o3">BankShift</a> = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a52">PTE_SHIFT</a> + count - <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
07458 
07459     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(<a class="code" href="../../d4/d8/mi_8h.html#a108">MI_VPN_TO_VA</a> (Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o0">StartingVpn</a>));
07460     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1);
07461 
07462     Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o19">u4</a>.Banked = Bank;
07463     Bank-&gt;<a class="code" href="../../d0/d1/struct__MMBANKED__SECTION.html#o0">BasePhysicalPage</a> = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a> (PointerPte);
07464     Bank-&gt;<a class="code" href="../../d0/d1/struct__MMBANKED__SECTION.html#o1">BasedPte</a> = PointerPte;
07465     Bank-&gt;<a class="code" href="../../d0/d1/struct__MMBANKED__SECTION.html#o2">BankSize</a> = BankLength;
07466     Bank-&gt;<a class="code" href="../../d0/d1/struct__MMBANKED__SECTION.html#o4">BankedRoutine</a> = BankRoutine;
07467     Bank-&gt;<a class="code" href="../../d0/d1/struct__MMBANKED__SECTION.html#o5">Context</a> = Context;
07468     Bank-&gt;<a class="code" href="../../d0/d1/struct__MMBANKED__SECTION.html#o6">CurrentMappedPte</a> = PointerPte;
07469 
07470     <span class="comment">//</span>
07471     <span class="comment">// Build the template PTEs structure.</span>
07472     <span class="comment">//</span>
07473 
07474     count = 0;
07475     TempPte = <a class="code" href="../../d4/d2/datalpha_8c.html#a0">ZeroPte</a>;
07476 
07477     <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a105">MI_MAKE_VALID_PTE</a> (TempPte,
07478                        Bank-&gt;<a class="code" href="../../d0/d1/struct__MMBANKED__SECTION.html#o0">BasePhysicalPage</a>,
07479                        <a class="code" href="../../d4/d8/mi_8h.html#a39">MM_READWRITE</a>,
07480                        PointerPte);
07481 
07482     <span class="keywordflow">if</span> (TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Write) {
07483         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a112">MI_SET_PTE_DIRTY</a> (TempPte);
07484     }
07485 
07486     <span class="keywordflow">do</span> {
07487         Bank-&gt;<a class="code" href="../../d0/d1/struct__MMBANKED__SECTION.html#o7">BankTemplate</a>[count] = TempPte;
07488         TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber += 1;
07489         count += 1;
07490     } <span class="keywordflow">while</span> ((ULONG)count &lt; NumberOfPtes );
07491 
07492     LastPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (<a class="code" href="../../d4/d8/mi_8h.html#a108">MI_VPN_TO_VA</a> (Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o1">EndingVpn</a>));
07493 
07494     <span class="comment">//</span>
07495     <span class="comment">// Set all PTEs within this range to zero.  Any faults within</span>
07496     <span class="comment">// this range will call the banked routine before making the</span>
07497     <span class="comment">// page valid.</span>
07498     <span class="comment">//</span>
07499 
07500     RtlFillMemory (PointerPte,
07501                    (size &gt;&gt; (<a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a> - <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a52">PTE_SHIFT</a>)),
07502                    (UCHAR)<a class="code" href="../../d4/d2/datalpha_8c.html#a0">ZeroPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long);
07503 
07504     <a class="code" href="../../d0/d6/ppc_2flushtb_8c.html#a0">KeFlushEntireTb</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
07505 
07506     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
07507 ErrorReturn:
07508 
07509     <a class="code" href="../../d4/d8/mi_8h.html#a162">UNLOCK_WS_AND_ADDRESS_SPACE</a> (Process);
07510     <a class="code" href="../../d3/d5/procobj_8c.html#a7">KeDetachProcess</a>();
07511     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a> (Process);
07512     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
07513 }
07514 
07515 PVOID
<a name="l07516"></a><a class="code" href="../../d5/d6/iosup_8c.html#a85">07516</a> <a class="code" href="../../d5/d6/iosup_8c.html#a85">MmMapVideoDisplay</a> (
07517      IN PHYSICAL_ADDRESS PhysicalAddress,
07518      IN SIZE_T NumberOfBytes,
07519      IN MEMORY_CACHING_TYPE CacheType
07520      )
07521 
07522 <span class="comment">/*++</span>
07523 <span class="comment"></span>
07524 <span class="comment">Routine Description:</span>
07525 <span class="comment"></span>
07526 <span class="comment">    This function maps the specified physical address into the non-pagable</span>
07527 <span class="comment">    portion of the system address space.</span>
07528 <span class="comment"></span>
07529 <span class="comment">Arguments:</span>
07530 <span class="comment"></span>
07531 <span class="comment">    PhysicalAddress - Supplies the starting physical address to map.</span>
07532 <span class="comment"></span>
07533 <span class="comment">    NumberOfBytes - Supplies the number of bytes to map.</span>
07534 <span class="comment"></span>
07535 <span class="comment">    CacheType - Supplies MmNonCached if the physical address is to be mapped</span>
07536 <span class="comment">                as non-cached, MmCached if the address should be cached, and</span>
07537 <span class="comment">                MmWriteCombined if the address should be cached and</span>
07538 <span class="comment">                write-combined as a frame buffer. For I/O device registers,</span>
07539 <span class="comment">                this is usually specified as MmNonCached.</span>
07540 <span class="comment"></span>
07541 <span class="comment">Return Value:</span>
07542 <span class="comment"></span>
07543 <span class="comment">    Returns the virtual address which maps the specified physical addresses.</span>
07544 <span class="comment">    The value NULL is returned if sufficient virtual address space for</span>
07545 <span class="comment">    the mapping could not be found.</span>
07546 <span class="comment"></span>
07547 <span class="comment">Environment:</span>
07548 <span class="comment"></span>
07549 <span class="comment">    Kernel mode, IRQL of APC_LEVEL or below.</span>
07550 <span class="comment"></span>
07551 <span class="comment">--*/</span>
07552 
07553 {
07554     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
07555     PVOID BaseVa;
07556 <span class="preprocessor">#ifdef LARGE_PAGES</span>
07557 <span class="preprocessor"></span>    <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> TempPte;
07558     PFN_NUMBER PageFrameIndex;
07559     PFN_NUMBER NumberOfPages;
07560     ULONG size;
07561     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> protoPte;
07562     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> largePte;
07563     ULONG pageSize;
07564     <a class="code" href="../../d1/d7/struct__SUBSECTION.html">PSUBSECTION</a> Subsection;
07565     ULONG Alignment;
07566     ULONG EmPageSize;
07567 <span class="preprocessor">#endif LARGE_PAGES</span>
07568 <span class="preprocessor"></span>    ULONG LargePages;
07569 
07570     LargePages = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
07571     PointerPte = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
07572 
07573 <span class="preprocessor">#if defined (i386) &amp;&amp; !defined (_X86PAE_)</span>
07574 <span class="preprocessor"></span>    <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PhysicalAddress.HighPart == 0);
07575 <span class="preprocessor">#endif</span>
07576 <span class="preprocessor"></span>
07577     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
07578 
07579     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (NumberOfBytes != 0);
07580 
07581 <span class="preprocessor">#ifdef LARGE_PAGES</span>
07582 <span class="preprocessor"></span>    NumberOfPages = <a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a> (PhysicalAddress.LowPart,
07583                                            NumberOfBytes);
07584 
07585     TempPte = <a class="code" href="../../d4/d2/datalpha_8c.html#a2">ValidKernelPte</a>;
07586     <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a118">MI_DISABLE_CACHING</a> (TempPte);
07587     PageFrameIndex = (PFN_NUMBER)(PhysicalAddress.QuadPart &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
07588     TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber = PageFrameIndex;
07589 
07590     <span class="keywordflow">if</span> ((NumberOfBytes &gt; <a class="code" href="../../d4/d8/mi_8h.html#a18">X64K</a>) &amp;&amp; (!MmLargeVideoMapped)) {
07591         size = (NumberOfBytes - 1) &gt;&gt; (<a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a> + 1);
07592         pageSize = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
07593 
07594         <span class="keywordflow">while</span> (size != 0) {
07595             size = size &gt;&gt; 2;
07596             pageSize = pageSize &lt;&lt; 2;
07597         }
07598 
07599         Alignment = pageSize &lt;&lt; 1;
07600         <span class="keywordflow">if</span> (Alignment &lt; <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a50">MM_VA_MAPPED_BY_PDE</a>) {
07601             Alignment = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a50">MM_VA_MAPPED_BY_PDE</a>;
07602         }
07603 
07604 <span class="preprocessor">#if defined(_IA64_)</span>
07605 <span class="preprocessor"></span>
07606         <span class="comment">//</span>
07607         <span class="comment">// Convert pageSize to the EM specific page-size field format</span>
07608         <span class="comment">//</span>
07609 
07610         EmPageSize = 0;
07611         size = pageSize - 1 ;
07612 
07613         <span class="keywordflow">while</span> (size) {
07614             size = size &gt;&gt; 1;
07615             EmPageSize += 1;
07616         }
07617 
07618         <span class="keywordflow">if</span> (NumberOfBytes &gt; pageSize) {
07619 
07620             <span class="keywordflow">if</span> (<a class="code" href="../../d3/d2/dataia64_8c.html#a27">MmPageSizeInfo</a> &amp; (pageSize &lt;&lt; 1)) {
07621 
07622                 <span class="comment">//</span>
07623                 <span class="comment">// if larger page size is supported in the implementation</span>
07624                 <span class="comment">//</span>
07625 
07626                 pageSize = pageSize &lt;&lt; 1;
07627                 EmPageSize += 1;
07628 
07629             }
07630             <span class="keywordflow">else</span> {
07631 
07632                 EmPageSize = EmPageSize | pageSize;
07633 
07634             }
07635         }
07636 
07637         pageSize = EmPageSize;
07638 <span class="preprocessor">#endif</span>
07639 <span class="preprocessor"></span>
07640         NumberOfPages = Alignment &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
07641 
07642         PointerPte = <a class="code" href="../../d0/d9/sysptes_8c.html#a25">MiReserveSystemPtes</a>(NumberOfPages,
07643                                          <a class="code" href="../../d4/d8/mi_8h.html#a1003a769">SystemPteSpace</a>,
07644                                          Alignment,
07645                                          0,
07646                                          <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
07647 
07648         <span class="keywordflow">if</span> (PointerPte == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
07649             <span class="keywordflow">goto</span> MapWithSmallPages;
07650         }
07651 
07652         protoPte = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a> (<a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>,
07653                                            <span class="keyword">sizeof</span> (<a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a>),
07654                                            'bSmM');
07655 
07656         <span class="keywordflow">if</span> (protoPte == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
07657             <a class="code" href="../../d0/d9/sysptes_8c.html#a26">MiReleaseSystemPtes</a>(PointerPte, NumberOfPages, <a class="code" href="../../d4/d8/mi_8h.html#a1003a769">SystemPteSpace</a>);
07658             <span class="keywordflow">goto</span> MapWithSmallPages;
07659         }
07660 
07661         Subsection = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a> (<a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
07662                                      <span class="keyword">sizeof</span>(<a class="code" href="../../d1/d7/struct__SUBSECTION.html">SUBSECTION</a>) + (4 * <span class="keyword">sizeof</span>(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a213">MMPTE</a>)),
07663                                      'bSmM');
07664 
07665         <span class="keywordflow">if</span> (Subsection == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
07666             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (protoPte);
07667             <a class="code" href="../../d0/d9/sysptes_8c.html#a26">MiReleaseSystemPtes</a>(PointerPte, NumberOfPages, <a class="code" href="../../d4/d8/mi_8h.html#a1003a769">SystemPteSpace</a>);
07668             <span class="keywordflow">goto</span> MapWithSmallPages;
07669         }
07670 
07671         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a189">MiFillMemoryPte</a> (PointerPte,
07672                          Alignment &gt;&gt; (<a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a> - <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a52">PTE_SHIFT</a>),
07673                          <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a94">MM_ZERO_KERNEL_PTE</a>);
07674 
07675         <span class="comment">//</span>
07676         <span class="comment">// Build large page descriptor and fill in all the PTEs.</span>
07677         <span class="comment">//</span>
07678 
07679         Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o4">StartingSector</a> = pageSize;
07680         Subsection-&gt;EndingSector = (ULONG)NumberOfPages;
07681         Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o3">u</a>.LongFlags = 0;
07682         Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o3">u</a>.SubsectionFlags.LargePages = 1;
07683         Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o3">u</a>.SubsectionFlags.Protection = <a class="code" href="../../d4/d8/mi_8h.html#a39">MM_READWRITE</a> | <a class="code" href="../../d4/d8/mi_8h.html#a43">MM_NOCACHE</a>;
07684         Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o8">PtesInSubsection</a> = Alignment;
07685         Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o6">SubsectionBase</a> = PointerPte;
07686 
07687         largePte = (<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)(Subsection + 1);
07688 
07689         <span class="comment">//</span>
07690         <span class="comment">// Build the first 2 PTEs as entries for the TLB to</span>
07691         <span class="comment">// map the specified physical address.</span>
07692         <span class="comment">//</span>
07693 
07694         *largePte = TempPte;
07695         largePte += 1;
07696 
07697         <span class="keywordflow">if</span> (NumberOfBytes &gt; pageSize) {
07698             *largePte = TempPte;
07699             largePte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber += (pageSize &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
07700         } <span class="keywordflow">else</span> {
07701             *largePte = <a class="code" href="../../d4/d2/datalpha_8c.html#a1">ZeroKernelPte</a>;
07702         }
07703 
07704         <span class="comment">//</span>
07705         <span class="comment">// Build the first prototype PTE as a paging file format PTE</span>
07706         <span class="comment">// referring to the subsection.</span>
07707         <span class="comment">//</span>
07708 
07709         protoPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a149">MiGetSubsectionAddressForPte</a>(Subsection);
07710         protoPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Prototype = 1;
07711         protoPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Protection = <a class="code" href="../../d4/d8/mi_8h.html#a39">MM_READWRITE</a> | <a class="code" href="../../d4/d8/mi_8h.html#a43">MM_NOCACHE</a>;
07712 
07713         <span class="comment">//</span>
07714         <span class="comment">// Set the PTE up for all the user's PTE entries, proto pte</span>
07715         <span class="comment">// format pointing to the 3rd prototype PTE.</span>
07716         <span class="comment">//</span>
07717 
07718         TempPte.u.Long = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a145">MiProtoAddressForPte</a> (protoPte);
07719         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a116">MI_SET_GLOBAL_STATE</a> (TempPte, 1);
07720         LargePages = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
07721         MmLargeVideoMapped = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
07722     }
07723 
07724     <span class="keywordflow">if</span> (PointerPte != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
07725         BaseVa = (PVOID)<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPte);
07726         BaseVa = (PVOID)((PCHAR)BaseVa + <a class="code" href="../../d2/d1/mm_8h.html#a6">BYTE_OFFSET</a>(PhysicalAddress.LowPart));
07727 
07728         <span class="keywordflow">do</span> {
07729             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 0);
07730             <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a186">MI_WRITE_VALID_PTE</a> (PointerPte, TempPte);
07731             PointerPte += 1;
07732             NumberOfPages -= 1;
07733         } <span class="keywordflow">while</span> (NumberOfPages != 0);
07734     } <span class="keywordflow">else</span> {
07735 
07736 MapWithSmallPages:
07737 
07738 <span class="preprocessor">#endif //LARGE_PAGES</span>
07739 <span class="preprocessor"></span>
07740         BaseVa = <a class="code" href="../../d5/d6/iosup_8c.html#a57">MmMapIoSpace</a> (PhysicalAddress,
07741                                NumberOfBytes,
07742                                CacheType);
07743 <span class="preprocessor">#ifdef LARGE_PAGES</span>
07744 <span class="preprocessor"></span>    }
07745 <span class="preprocessor">#endif //LARGE_PAGES</span>
07746 <span class="preprocessor"></span>
07747     <span class="keywordflow">return</span> BaseVa;
07748 }
07749 
07750 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l07751"></a><a class="code" href="../../d5/d6/iosup_8c.html#a86">07751</a> <a class="code" href="../../d5/d6/iosup_8c.html#a86">MmUnmapVideoDisplay</a> (
07752      IN PVOID BaseAddress,
07753      IN SIZE_T NumberOfBytes
07754      )
07755 
07756 <span class="comment">/*++</span>
07757 <span class="comment"></span>
07758 <span class="comment">Routine Description:</span>
07759 <span class="comment"></span>
07760 <span class="comment">    This function unmaps a range of physical address which were previously</span>
07761 <span class="comment">    mapped via an MmMapVideoDisplay function call.</span>
07762 <span class="comment"></span>
07763 <span class="comment">Arguments:</span>
07764 <span class="comment"></span>
07765 <span class="comment">    BaseAddress - Supplies the base virtual address where the physical</span>
07766 <span class="comment">                  address was previously mapped.</span>
07767 <span class="comment"></span>
07768 <span class="comment">    NumberOfBytes - Supplies the number of bytes which were mapped.</span>
07769 <span class="comment"></span>
07770 <span class="comment">Return Value:</span>
07771 <span class="comment"></span>
07772 <span class="comment">    None.</span>
07773 <span class="comment"></span>
07774 <span class="comment">Environment:</span>
07775 <span class="comment"></span>
07776 <span class="comment">    Kernel mode, IRQL of APC_LEVEL or below.</span>
07777 <span class="comment"></span>
07778 <span class="comment">--*/</span>
07779 
07780 {
07781 
07782 <span class="preprocessor">#ifdef LARGE_PAGES</span>
07783 <span class="preprocessor"></span>    PFN_NUMBER NumberOfPages;
07784     ULONG i;
07785     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> FirstPte;
07786     KIRQL OldIrql;
07787     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> LargePte;
07788     <a class="code" href="../../d1/d7/struct__SUBSECTION.html">PSUBSECTION</a> Subsection;
07789 
07790     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
07791 
07792     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (NumberOfBytes != 0);
07793     NumberOfPages = <a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a> (BaseAddress, NumberOfBytes);
07794     FirstPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (BaseAddress);
07795 
07796     <span class="keywordflow">if</span> ((NumberOfBytes &gt; <a class="code" href="../../d4/d8/mi_8h.html#a18">X64K</a>) &amp;&amp; (FirstPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 0)) {
07797 
07798         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (MmLargeVideoMapped);
07799         LargePte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a144">MiPteToProto</a> (FirstPte);
07800         Subsection = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a148">MiGetSubsectionAddress</a> (LargePte);
07801         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o6">SubsectionBase</a> == FirstPte);
07802 
07803         NumberOfPages = Subsection-&gt;EndingSector;
07804         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (Subsection);
07805         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (LargePte);
07806         MmLargeVideoMapped = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
07807         KeFillFixedEntryTb ((PHARDWARE_PTE)FirstPte, (PVOID)<a class="code" href="../../d6/d7/halmips_8h.html#a443">KSEG0_BASE</a>, LARGE_ENTRY);
07808     }
07809     <a class="code" href="../../d0/d9/sysptes_8c.html#a26">MiReleaseSystemPtes</a>(FirstPte, NumberOfPages, <a class="code" href="../../d4/d8/mi_8h.html#a1003a769">SystemPteSpace</a>);
07810     <span class="keywordflow">return</span>;
07811 
07812 <span class="preprocessor">#else // LARGE_PAGES</span>
07813 <span class="preprocessor"></span>
07814     <a class="code" href="../../d5/d6/iosup_8c.html#a58">MmUnmapIoSpace</a> (BaseAddress, NumberOfBytes);
07815     <span class="keywordflow">return</span>;
07816 <span class="preprocessor">#endif //LARGE_PAGES</span>
07817 <span class="preprocessor"></span>}
07818 
07819 
07820 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l07821"></a><a class="code" href="../../d5/d6/iosup_8c.html#a87">07821</a> <a class="code" href="../../d5/d6/iosup_8c.html#a87">MmLockPagedPool</a> (
07822     IN PVOID Address,
07823     IN SIZE_T SizeInBytes
07824     )
07825 
07826 <span class="comment">/*++</span>
07827 <span class="comment"></span>
07828 <span class="comment">Routine Description:</span>
07829 <span class="comment"></span>
07830 <span class="comment">    Locks the specified address (which MUST reside in paged pool) into</span>
07831 <span class="comment">    memory until MmUnlockPagedPool is called.</span>
07832 <span class="comment"></span>
07833 <span class="comment">Arguments:</span>
07834 <span class="comment"></span>
07835 <span class="comment">    Address - Supplies the address in paged pool to lock.</span>
07836 <span class="comment"></span>
07837 <span class="comment">    SizeInBytes - Supplies the size in bytes to lock.</span>
07838 <span class="comment"></span>
07839 <span class="comment">Return Value:</span>
07840 <span class="comment"></span>
07841 <span class="comment">    None.</span>
07842 <span class="comment"></span>
07843 <span class="comment">Environment:</span>
07844 <span class="comment"></span>
07845 <span class="comment">    Kernel mode, IRQL of APC_LEVEL or below.</span>
07846 <span class="comment"></span>
07847 <span class="comment">--*/</span>
07848 
07849 {
07850     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
07851     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> LastPte;
07852     KIRQL OldIrql;
07853     KIRQL OldIrqlWs;
07854 
07855     <a class="code" href="../../d5/d6/iosup_8c.html#a76">MmLockPagableSectionByHandle</a>(<a class="code" href="../../d5/d8/ex_8h.html#a166">ExPageLockHandle</a>);
07856     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (Address);
07857     LastPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> ((PVOID)((PCHAR)Address + (SizeInBytes - 1)));
07858     <a class="code" href="../../d4/d8/mi_8h.html#a144">LOCK_SYSTEM_WS</a> (OldIrqlWs);
07859     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
07860     <a class="code" href="../../d4/d8/mi_8h.html#a873">MiLockCode</a> (PointerPte, LastPte, <a class="code" href="../../d4/d8/mi_8h.html#a29">MM_LOCK_BY_REFCOUNT</a>);
07861     <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
07862     <a class="code" href="../../d4/d8/mi_8h.html#a145">UNLOCK_SYSTEM_WS</a> (OldIrqlWs);
07863     <a class="code" href="../../d5/d6/iosup_8c.html#a81">MmUnlockPagableImageSection</a>(<a class="code" href="../../d5/d8/ex_8h.html#a166">ExPageLockHandle</a>);
07864     <span class="keywordflow">return</span>;
07865 }
07866 
07867 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
07868 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l07869"></a><a class="code" href="../../d5/d6/iosup_8c.html#a88">07869</a> <a class="code" href="../../d5/d6/iosup_8c.html#a88">MmUnlockPagedPool</a> (
07870     IN PVOID Address,
07871     IN SIZE_T SizeInBytes
07872     )
07873 
07874 <span class="comment">/*++</span>
07875 <span class="comment"></span>
07876 <span class="comment">Routine Description:</span>
07877 <span class="comment"></span>
07878 <span class="comment">    Unlocks paged pool that was locked with MmLockPagedPool.</span>
07879 <span class="comment"></span>
07880 <span class="comment">Arguments:</span>
07881 <span class="comment"></span>
07882 <span class="comment">    Address - Supplies the address in paged pool to unlock.</span>
07883 <span class="comment"></span>
07884 <span class="comment">    Size - Supplies the size to unlock.</span>
07885 <span class="comment"></span>
07886 <span class="comment">Return Value:</span>
07887 <span class="comment"></span>
07888 <span class="comment">    None.</span>
07889 <span class="comment"></span>
07890 <span class="comment">Environment:</span>
07891 <span class="comment"></span>
07892 <span class="comment">    Kernel mode, IRQL of APC_LEVEL or below.</span>
07893 <span class="comment"></span>
07894 <span class="comment">--*/</span>
07895 
07896 {
07897     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
07898     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> LastPte;
07899     KIRQL OldIrql;
07900     PFN_NUMBER PageFrameIndex;
07901     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
07902 
07903     <a class="code" href="../../d5/d6/iosup_8c.html#a76">MmLockPagableSectionByHandle</a>(<a class="code" href="../../d5/d8/ex_8h.html#a166">ExPageLockHandle</a>);
07904     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (Address);
07905     LastPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> ((PVOID)((PCHAR)Address + (SizeInBytes - 1)));
07906     <a class="code" href="../../d4/d8/mi_8h.html#a130">LOCK_PFN2</a> (OldIrql);
07907 
07908     <span class="keywordflow">do</span> {
07909         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1);
07910 
07911         PageFrameIndex = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a> (PointerPte);
07912         Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PageFrameIndex);
07913 
07914         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount &gt; 1);
07915 
07916         <a class="code" href="../../d4/d8/mi_8h.html#a189">MI_REMOVE_LOCKED_PAGE_CHARGE</a> (Pfn1, 35);
07917 
07918         <a class="code" href="../../d6/d5/pfndec_8c.html#a2">MiDecrementReferenceCount</a> (PageFrameIndex);
07919 
07920         PointerPte += 1;
07921     } <span class="keywordflow">while</span> (PointerPte &lt;= LastPte);
07922 
07923     <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
07924     <a class="code" href="../../d5/d6/iosup_8c.html#a81">MmUnlockPagableImageSection</a>(<a class="code" href="../../d5/d8/ex_8h.html#a166">ExPageLockHandle</a>);
07925     <span class="keywordflow">return</span>;
07926 }
07927 
07928 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
07929 ULONG
<a name="l07930"></a><a class="code" href="../../d5/d6/iosup_8c.html#a89">07930</a> <a class="code" href="../../d5/d6/iosup_8c.html#a89">MmGatherMemoryForHibernate</a> (
07931     IN <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> Mdl,
07932     IN BOOLEAN Wait
07933     )
07934 
07935 <span class="comment">/*++</span>
07936 <span class="comment"></span>
07937 <span class="comment">Routine Description:</span>
07938 <span class="comment"></span>
07939 <span class="comment">    Finds enough memory to fill in the pages of the MDL for power management</span>
07940 <span class="comment">    hibernate function.</span>
07941 <span class="comment"></span>
07942 <span class="comment">Arguments:</span>
07943 <span class="comment"></span>
07944 <span class="comment">    Mdl - Supplies an MDL, the start VA field should be NULL.  The length</span>
07945 <span class="comment">          field indicates how many pages to obtain.</span>
07946 <span class="comment"></span>
07947 <span class="comment">    Wait - FALSE to fail immediately if the pages aren't available.</span>
07948 <span class="comment"></span>
07949 <span class="comment">Return Value:</span>
07950 <span class="comment"></span>
07951 <span class="comment">    TRUE if the MDL could be filled in, FALSE otherwise.</span>
07952 <span class="comment"></span>
07953 <span class="comment">Environment:</span>
07954 <span class="comment"></span>
07955 <span class="comment">    Kernel mode, IRQL of APC_LEVEL or below.</span>
07956 <span class="comment"></span>
07957 <span class="comment">--*/</span>
07958 
07959 {
07960     KIRQL OldIrql;
07961     PFN_NUMBER PagesNeeded;
07962     PPFN_NUMBER Pages;
07963     PFN_NUMBER i;
07964     PFN_NUMBER PageFrameIndex;
07965     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
07966     ULONG status;
07967 
07968     status = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
07969 
07970     PagesNeeded = Mdl-&gt;ByteCount &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
07971     Pages = (PPFN_NUMBER)(Mdl + 1);
07972 
07973     i = Wait ? 100 : 1;
07974 
07975     InterlockedIncrement (&amp;<a class="code" href="../../d4/d8/mi_8h.html#a598">MiDelayPageFaults</a>);
07976 
07977     <span class="keywordflow">do</span> {
07978 
07979         <a class="code" href="../../d4/d8/mi_8h.html#a130">LOCK_PFN2</a> (OldIrql);
07980         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a94">MmAvailablePages</a> &gt; PagesNeeded) {
07981 
07982             <span class="comment">//</span>
07983             <span class="comment">// Fill in the MDL.</span>
07984             <span class="comment">//</span>
07985 
07986             <span class="keywordflow">do</span> {
07987                 PageFrameIndex = <a class="code" href="../../d7/d5/pfnlist_8c.html#a15">MiRemoveAnyPage</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a124">MI_GET_PAGE_COLOR_FROM_PTE</a> (<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>));
07988                 Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PageFrameIndex);
07989                 <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a120">MI_SET_PFN_DELETED</a> (Pfn1);
07990                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount += 1;
07991                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a95">MM_DEMAND_ZERO_WRITE_PTE</a>;
07992                 *Pages = PageFrameIndex;
07993                 Pages += 1;
07994                 PagesNeeded -= 1;
07995             } <span class="keywordflow">while</span> (PagesNeeded);
07996             <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
07997             Mdl-&gt;MdlFlags |= <a class="code" href="../../d0/d9/ntosdef_8h.html#a13">MDL_PAGES_LOCKED</a>;
07998             status = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
07999             <span class="keywordflow">break</span>;
08000         }
08001 
08002         <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
08003 
08004         <span class="comment">//</span>
08005         <span class="comment">// If we're being called at DISPATCH_LEVEL we cannot move pages to</span>
08006         <span class="comment">// the standby list because mutexes must be acquired to do so.</span>
08007         <span class="comment">//</span>
08008 
08009         <span class="keywordflow">if</span> (OldIrql &gt; <a class="code" href="../../d6/d7/halmips_8h.html#a52">APC_LEVEL</a>) {
08010             <span class="keywordflow">break</span>;
08011         }
08012 
08013         <span class="keywordflow">if</span> (!i) {
08014             <span class="keywordflow">break</span>;
08015         }
08016 
08017         <span class="comment">//</span>
08018         <span class="comment">// Attempt to move pages to the standby list.</span>
08019         <span class="comment">//</span>
08020 
08021         <a class="code" href="../../d5/d0/wsmanage_8c.html#a47">MiEmptyAllWorkingSets</a> ();
08022         <a class="code" href="../../d6/d3/modwrite_8c.html#a57">MiFlushAllPages</a>();
08023 
08024         <a class="code" href="../../d1/d7/wait_8c.html#a2">KeDelayExecutionThread</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
08025                                 <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
08026                                 (PLARGE_INTEGER)&amp;<a class="code" href="../../d4/d8/mi_8h.html#a422">Mm30Milliseconds</a>);
08027         i -= 1;
08028 
08029     } <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
08030 
08031     InterlockedDecrement (&amp;<a class="code" href="../../d4/d8/mi_8h.html#a598">MiDelayPageFaults</a>);
08032 
08033     <span class="keywordflow">return</span> status;
08034 }
08035 
08036 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
08037 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l08038"></a><a class="code" href="../../d5/d6/iosup_8c.html#a90">08038</a> <a class="code" href="../../d5/d6/iosup_8c.html#a90">MmReturnMemoryForHibernate</a> (
08039     IN <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> Mdl
08040     )
08041 
08042 <span class="comment">/*++</span>
08043 <span class="comment"></span>
08044 <span class="comment">Routine Description:</span>
08045 <span class="comment"></span>
08046 <span class="comment">    Returns memory from MmGatherMemoryForHibername.</span>
08047 <span class="comment"></span>
08048 <span class="comment">Arguments:</span>
08049 <span class="comment"></span>
08050 <span class="comment">    Mdl - Supplies an MDL, the start VA field should be NULL.  The length</span>
08051 <span class="comment">          field indicates how many pages to obtain.</span>
08052 <span class="comment"></span>
08053 <span class="comment">Return Value:</span>
08054 <span class="comment"></span>
08055 <span class="comment">    None.</span>
08056 <span class="comment"></span>
08057 <span class="comment">Environment:</span>
08058 <span class="comment"></span>
08059 <span class="comment">    Kernel mode, IRQL of APC_LEVEL or below.</span>
08060 <span class="comment"></span>
08061 <span class="comment">--*/</span>
08062 
08063 {
08064     KIRQL OldIrql;
08065     PFN_NUMBER PagesNeeded;
08066     PPFN_NUMBER Pages;
08067 
08068     PagesNeeded = (Mdl-&gt;ByteCount &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
08069     Pages = (PPFN_NUMBER)(Mdl + 1);
08070 
08071     <a class="code" href="../../d4/d8/mi_8h.html#a130">LOCK_PFN2</a> (OldIrql);
08072     <span class="keywordflow">do</span> {
08073         <a class="code" href="../../d6/d5/pfndec_8c.html#a2">MiDecrementReferenceCount</a> (*Pages);
08074         Pages += 1;
08075         PagesNeeded -= 1;
08076     } <span class="keywordflow">while</span> (PagesNeeded);
08077     <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
08078     <span class="keywordflow">return</span>;
08079 }
08080 
08081 
08082 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l08083"></a><a class="code" href="../../d5/d6/iosup_8c.html#a91">08083</a> <a class="code" href="../../d5/d6/iosup_8c.html#a91">MmSetKernelDumpRange</a>(
08084     IN OUT PVOID pDumpContext
08085     )
08086 
08087 <span class="comment">/*++</span>
08088 <span class="comment"></span>
08089 <span class="comment">Routine Description:</span>
08090 <span class="comment"></span>
08091 <span class="comment">    For use by crash dump routine ONLY.</span>
08092 <span class="comment"></span>
08093 <span class="comment">    Specifies the range of memory (mostly kernel) to include in the dump.</span>
08094 <span class="comment"></span>
08095 <span class="comment">Arguments:</span>
08096 <span class="comment"></span>
08097 <span class="comment">    pDumpContext - Opaque dump context</span>
08098 <span class="comment"></span>
08099 <span class="comment">Return Value:</span>
08100 <span class="comment"></span>
08101 <span class="comment">    None.</span>
08102 <span class="comment"></span>
08103 <span class="comment">Environment:</span>
08104 <span class="comment"></span>
08105 <span class="comment">    Kernel mode, post-bugcheck.</span>
08106 <span class="comment"></span>
08107 <span class="comment">--*/</span>
08108 
08109 {
08110     PLIST_ENTRY NextEntry;
08111     PLDR_DATA_TABLE_ENTRY DataTableEntry;
08112     PCHAR Kseg0Addr;
08113     PCHAR Kseg2Addr;
08114     PFN_NUMBER Pages;
08115     PCHAR Va;
08116     PCHAR HighVa;
08117     LOGICAL IsPhysicalAddress;
08118     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
08119 <span class="preprocessor">#if defined(_X86_)</span>
08120 <span class="preprocessor"></span>    PHYSICAL_ADDRESS DirBase;
08121     PKDESCRIPTOR Descriptor;
08122     PKPROCESSOR_STATE ProcessorState;
08123 <span class="preprocessor">#endif</span>
08124 <span class="preprocessor"></span>
08125     <span class="comment">//</span>
08126     <span class="comment">// Initialize memory boundary values.</span>
08127     <span class="comment">//</span>
08128 
08129     Kseg0Addr = (PCHAR)<a class="code" href="../../d0/d9/miglobal_8c.html#a1">MmSystemRangeStart</a>;
08130     Kseg2Addr = Kseg0Addr + <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a8">MM_PAGES_IN_KSEG0</a> * <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
08131 
08132     <span class="comment">//</span>
08133     <span class="comment">// If unbiased, copy only valid portions of KSEG0.</span>
08134     <span class="comment">//</span>
08135 
08136     <span class="keywordflow">if</span> (!<a class="code" href="../../d2/d1/mm_8h.html#a126">MmVirtualBias</a>) {
08137 
08138         <span class="comment">//</span>
08139         <span class="comment">// Include loaded modules in KSEG0.</span>
08140         <span class="comment">//</span>
08141 
08142         NextEntry = <a class="code" href="../../d1/d9/ps_8h.html#a56">PsLoadedModuleList</a>.Flink;
08143 
08144         <span class="keywordflow">while</span> (NextEntry != &amp;<a class="code" href="../../d1/d9/ps_8h.html#a56">PsLoadedModuleList</a>) {
08145 
08146             DataTableEntry = CONTAINING_RECORD (NextEntry,
08147                                                 LDR_DATA_TABLE_ENTRY,
08148                                                 InLoadOrderLinks);
08149             Va = DataTableEntry-&gt;DllBase;
08150 
08151             <span class="keywordflow">if</span> (Va &gt;= Kseg0Addr &amp;&amp; Va &lt; Kseg2Addr) {
08152 
08153                 Pages = <a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a>(Va, DataTableEntry-&gt;SizeOfImage);
08154 
08155                 <a class="code" href="../../d2/d3/dumpctl_8c.html#a48">IoSetDumpRange</a> (pDumpContext,
08156                                 Va,
08157                                 (ULONG)Pages,
08158                                 (BOOLEAN) <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a> (Va));
08159             }
08160             NextEntry = NextEntry-&gt;Flink;
08161         }
08162     }
08163 
08164     <span class="comment">//</span>
08165     <span class="comment">// Add the processor block array. That is, the array of pointers to</span>
08166     <span class="comment">// KPRCB objects. This is necessary if we are going to support the</span>
08167     <span class="comment">// !prcb extension.</span>
08168     <span class="comment">//</span>
08169 
08170     Va = (PCHAR) <a class="code" href="../../d4/d9/ke_8h.html#a139">KiProcessorBlock</a>;
08171 
08172     Pages = <a class="code" href="../../d2/d1/mm_8h.html#a8">ADDRESS_AND_SIZE_TO_SPAN_PAGES</a> (
08173                             Va,
08174                             <span class="keyword">sizeof</span> (PKPRCB) * <a class="code" href="../../d4/d9/ke_8h.html#a133">KeNumberProcessors</a>);
08175 
08176 
08177     <a class="code" href="../../d2/d3/dumpctl_8c.html#a48">IoSetDumpRange</a> (pDumpContext,
08178                     Va,
08179                     (ULONG)Pages,
08180                     (BOOLEAN) <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a> (Va));
08181 
08182     <span class="comment">//</span>
08183     <span class="comment">// Add the contents of the processor blocks.</span>
08184     <span class="comment">//</span>
08185     
08186     <span class="keywordflow">for</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0; (CCHAR)<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; <a class="code" href="../../d4/d9/ke_8h.html#a133">KeNumberProcessors</a>; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> += 1) {
08187 
08188         Va = (PCHAR) <a class="code" href="../../d4/d9/ke_8h.html#a139">KiProcessorBlock</a>[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>];
08189 
08190         Pages = <a class="code" href="../../d2/d1/mm_8h.html#a8">ADDRESS_AND_SIZE_TO_SPAN_PAGES</a> (Va,
08191                                                 <span class="keyword">sizeof</span> (KPRCB));
08192 
08193         <a class="code" href="../../d2/d3/dumpctl_8c.html#a48">IoSetDumpRange</a> (pDumpContext,
08194                         Va,
08195                         (ULONG)Pages,
08196                         (BOOLEAN) <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a> (Va));
08197 
08198 
08199 <span class="preprocessor">#if defined (_X86_)</span>
08200 <span class="preprocessor"></span>
08201         <span class="comment">//</span>
08202         <span class="comment">// Add the global descriptor table.</span>
08203         <span class="comment">//</span>
08204         
08205         ProcessorState = &amp;<a class="code" href="../../d4/d9/ke_8h.html#a139">KiProcessorBlock</a>[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>]-&gt;ProcessorState;
08206 
08207         Descriptor = &amp;ProcessorState-&gt;SpecialRegisters.Gdtr;
08208 
08209         Va = (PCHAR) Descriptor-&gt;Base;
08210 
08211         <span class="keywordflow">if</span> (Va != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
08212 
08213             Pages = <a class="code" href="../../d2/d1/mm_8h.html#a8">ADDRESS_AND_SIZE_TO_SPAN_PAGES</a> (Va, Descriptor-&gt;Limit);
08214 
08215             <a class="code" href="../../d2/d3/dumpctl_8c.html#a48">IoSetDumpRange</a> (pDumpContext,
08216                             Va,
08217                             (ULONG)Pages,
08218                             (BOOLEAN) <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a> (Va));
08219         }
08220 
08221         <span class="comment">//</span>
08222         <span class="comment">// Add the intrrupt descriptor table.</span>
08223         <span class="comment">//</span>
08224         
08225         Descriptor = &amp;ProcessorState-&gt;SpecialRegisters.Idtr;
08226 
08227         Va = (PCHAR) Descriptor-&gt;Base;
08228 
08229         <span class="keywordflow">if</span> (Va != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
08230 
08231             Pages = <a class="code" href="../../d2/d1/mm_8h.html#a8">ADDRESS_AND_SIZE_TO_SPAN_PAGES</a> (Va, Descriptor-&gt;Limit);
08232 
08233             <a class="code" href="../../d2/d3/dumpctl_8c.html#a48">IoSetDumpRange</a> (pDumpContext,
08234                             Va,
08235                             (ULONG)Pages,
08236                             (BOOLEAN) <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a> (Va));
08237         }
08238     }
08239 
08240     <span class="comment">//</span>
08241     <span class="comment">// Add the current page directory table page - don't use the directory</span>
08242     <span class="comment">// table base for the crashing process as we have switched cr3 on</span>
08243     <span class="comment">// stack overflow crashes, etc.</span>
08244     <span class="comment">//</span>
08245 
08246     _asm {
08247         mov     eax, cr3
08248         mov     DirBase.LowPart, eax
08249     }
08250 
08251     <span class="comment">//</span>
08252     <span class="comment">// cr3 is always located below 4gb physical.</span>
08253     <span class="comment">//</span>
08254 
08255     DirBase.HighPart = 0;
08256 
08257     Va = <a class="code" href="../../d5/d6/iosup_8c.html#a69">MmGetVirtualForPhysical</a> (DirBase);
08258 
08259     <a class="code" href="../../d2/d3/dumpctl_8c.html#a48">IoSetDumpRange</a> (pDumpContext,
08260                     Va,
08261                     1,
08262                     (BOOLEAN) <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a> (Va));
08263 <span class="preprocessor">#endif</span>
08264 <span class="preprocessor"></span>
08265     <span class="comment">//</span>
08266     <span class="comment">// Check to see if nonpaged pool starts before Kseg2 and if so add it.</span>
08267     <span class="comment">//</span>
08268 
08269     <span class="keywordflow">if</span> (((PCHAR)<a class="code" href="../../d8/d5/kddata_8c.html#a23">MmNonPagedPoolStart</a> &gt;= Kseg0Addr) &amp;&amp;
08270          ((PCHAR)<a class="code" href="../../d8/d5/kddata_8c.html#a23">MmNonPagedPoolStart</a> &lt;= Kseg2Addr)) {
08271 
08272         Va = <a class="code" href="../../d8/d5/kddata_8c.html#a23">MmNonPagedPoolStart</a>;
08273 
08274         Pages = (ULONG) <a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a>(Va, <a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a>);
08275 
08276         <a class="code" href="../../d2/d3/dumpctl_8c.html#a48">IoSetDumpRange</a> (pDumpContext,
08277                         Va,
08278                         (ULONG)Pages,
08279                         (BOOLEAN) <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a> (Va));
08280     }
08281 
08282     <span class="comment">//</span>
08283     <span class="comment">// Include all valid kernel memory above KSEG2 (or KSEG0 if biased).</span>
08284     <span class="comment">//</span>
08285 
08286     <span class="keywordflow">if</span> (!<a class="code" href="../../d2/d1/mm_8h.html#a126">MmVirtualBias</a>) {
08287         Va = Kseg2Addr;
08288     }
08289     <span class="keywordflow">else</span> {
08290         Va = Kseg0Addr;
08291     }
08292 
08293     <span class="keywordflow">do</span> {
08294 
08295         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d2/pagfault_8c.html#a26">MmIsAddressValid</a>(Va)) {
08296 
08297             <a class="code" href="../../d2/d3/dumpctl_8c.html#a48">IoSetDumpRange</a>(pDumpContext,
08298                            Va,
08299                            1,
08300                            <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
08301         }
08302 
08303         Va += <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
08304 
08305     } <span class="keywordflow">while</span> ((LONG_PTR)Va &lt; (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a25">MM_SYSTEM_SPACE_END</a> &amp; ~(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)));
08306 
08307     <span class="comment">//</span>
08308     <span class="comment">// Include the PFN database if it was not already done above.</span>
08309     <span class="comment">//</span>
08310 
08311     <span class="keywordflow">if</span> ((PCHAR)<a class="code" href="../../d2/d3/dumpctl_8c.html#a15">MmPfnDatabase</a> &lt; Kseg2Addr) {
08312 
08313         IsPhysicalAddress = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a>(<a class="code" href="../../d2/d3/dumpctl_8c.html#a15">MmPfnDatabase</a>);
08314 
08315         <a class="code" href="../../d2/d3/dumpctl_8c.html#a48">IoSetDumpRange</a> (pDumpContext,
08316                         <a class="code" href="../../d2/d3/dumpctl_8c.html#a15">MmPfnDatabase</a>,
08317                         <a class="code" href="../../d2/d1/mm_8h.html#a8">ADDRESS_AND_SIZE_TO_SPAN_PAGES</a> (<a class="code" href="../../d2/d3/dumpctl_8c.html#a15">MmPfnDatabase</a>,
08318                           (<a class="code" href="../../d2/d3/dumpctl_8c.html#a16">MmHighestPossiblePhysicalPage</a> + 1) * <span class="keyword">sizeof</span> (<a class="code" href="../../d4/d3/struct__MMPFN.html">MMPFN</a>)),
08319                         (BOOLEAN) IsPhysicalAddress);
08320 
08321         <span class="keywordflow">if</span> (IsPhysicalAddress == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
08322 
08323             <span class="comment">//</span>
08324             <span class="comment">// The PFN database may be sparse.  Exclude any nonexistent</span>
08325             <span class="comment">// ranges now.</span>
08326             <span class="comment">//</span>
08327 
08328             Va = (PCHAR)<a class="code" href="../../d2/d3/dumpctl_8c.html#a15">MmPfnDatabase</a>;
08329             HighVa = Va + (<a class="code" href="../../d2/d3/dumpctl_8c.html#a16">MmHighestPossiblePhysicalPage</a> + 1) * <span class="keyword">sizeof</span> (<a class="code" href="../../d4/d8/mi_8h.html#a438">MMPFN</a>);
08330 
08331             <span class="keywordflow">do</span> {
08332                 <span class="keywordflow">if</span> (!<a class="code" href="../../d8/d2/pagfault_8c.html#a26">MmIsAddressValid</a>(Va)) {
08333     
08334                     <a class="code" href="../../d2/d3/dumpctl_8c.html#a49">IoFreeDumpRange</a> (pDumpContext,
08335                                      Va,
08336                                      1,
08337                                      <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
08338                 }
08339 
08340                 Va += <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
08341 
08342             } <span class="keywordflow">while</span> (Va &lt; HighVa);
08343         }
08344     }
08345 
08346     <span class="comment">//</span>
08347     <span class="comment">// Exclude all free non-paged pool.</span>
08348     <span class="comment">//</span>
08349 
08350     <span class="keywordflow">for</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; <a class="code" href="../../d4/d8/mi_8h.html#a324">MI_MAX_FREE_LIST_HEADS</a>; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> += 1) {
08351 
08352         NextEntry = <a class="code" href="../../d1/d6/allocpag_8c.html#a8">MmNonPagedPoolFreeListHead</a>[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].Flink;
08353 
08354         <span class="keywordflow">while</span> (NextEntry != &amp;<a class="code" href="../../d1/d6/allocpag_8c.html#a8">MmNonPagedPoolFreeListHead</a>[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>]) {
08355 
08356             <a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html">PMMFREE_POOL_ENTRY</a> FreePageInfo;
08357 
08358             <span class="comment">//</span>
08359             <span class="comment">// The list is not empty, remove free ones</span>
08360             <span class="comment">//</span>
08361 
08362             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a36">MmProtectFreedNonPagedPool</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
08363                 <a class="code" href="../../d5/d6/iosup_8c.html#a38">MiUnProtectFreeNonPagedPool</a> ((PVOID)NextEntry, 0);
08364             }
08365 
08366             FreePageInfo = CONTAINING_RECORD(NextEntry,
08367                                              <a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html">MMFREE_POOL_ENTRY</a>,
08368                                              <a class="code" href="../../d1/d0/cmchek_8c.html#a12">List</a>);
08369 
08370             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o2">Signature</a> == <a class="code" href="../../d4/d8/mi_8h.html#a11">MM_FREE_POOL_SIGNATURE</a>);
08371 
08372             <span class="keywordflow">if</span> (FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o1">Size</a>) {
08373 
08374                 Va = (PCHAR)FreePageInfo;
08375 
08376                 Pages = <a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a>(FreePageInfo, FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o1">Size</a>);
08377 
08378                 <a class="code" href="../../d2/d3/dumpctl_8c.html#a49">IoFreeDumpRange</a>(pDumpContext,
08379                                 Va,
08380                                 (ULONG)Pages,
08381                                 (BOOLEAN) <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a> (Va));
08382 
08383             }
08384 
08385             NextEntry = FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o0">List</a>.Flink;
08386 
08387             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a36">MmProtectFreedNonPagedPool</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
08388                 <a class="code" href="../../d5/d6/iosup_8c.html#a37">MiProtectFreeNonPagedPool</a> ((PVOID)FreePageInfo,
08389                                            (ULONG)FreePageInfo-&gt;<a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html#o1">Size</a>);
08390             }
08391         }
08392     }
08393 
08394     <span class="comment">//</span>
08395     <span class="comment">// Exclude all valid system cache addresses.</span>
08396     <span class="comment">//</span>
08397 
08398     <span class="keywordflow">for</span> (Va = (PCHAR)<a class="code" href="../../d8/d5/kddata_8c.html#a11">MmSystemCacheStart</a>; Va &lt; (PCHAR)<a class="code" href="../../d8/d5/kddata_8c.html#a12">MmSystemCacheEnd</a>; Va += <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>) {
08399 
08400         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d2/pagfault_8c.html#a26">MmIsAddressValid</a>(Va)) {
08401 
08402             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a>(Va) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
08403 
08404             <a class="code" href="../../d2/d3/dumpctl_8c.html#a49">IoFreeDumpRange</a> (pDumpContext,
08405                              Va,
08406                              1,
08407                              <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
08408         }
08409     }
08410 
08411 <span class="preprocessor">#if defined(_X86_)</span>
08412 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (<a class="code" href="../../d2/d2/data386_8c.html#a30">MiSystemCacheEndExtra</a> != <a class="code" href="../../d8/d5/kddata_8c.html#a12">MmSystemCacheEnd</a>) {
08413         <span class="keywordflow">for</span> (Va = (PCHAR)<a class="code" href="../../d2/d2/data386_8c.html#a29">MiSystemCacheStartExtra</a>; Va &lt; (PCHAR)<a class="code" href="../../d2/d2/data386_8c.html#a30">MiSystemCacheEndExtra</a>; Va += <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>) {
08414 
08415             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d2/pagfault_8c.html#a26">MmIsAddressValid</a>(Va)) {
08416 
08417                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a>(Va) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
08418 
08419                 <a class="code" href="../../d2/d3/dumpctl_8c.html#a49">IoFreeDumpRange</a>(pDumpContext,
08420                                 Va,
08421                                 1,
08422                                 <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
08423             }
08424         }
08425     }
08426 <span class="preprocessor">#endif</span>
08427 <span class="preprocessor"></span>}
08428 
08429 
08430 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
08431 <a class="code" href="../../d2/d1/mm_8h.html#a189">MmEnablePAT</a> (
08432      VOID
08433      )
08434 
08435 <span class="comment">/*++</span>
08436 <span class="comment"></span>
08437 <span class="comment">Routine Description:</span>
08438 <span class="comment"></span>
08439 <span class="comment">    This routine enables the page attribute capability for individual PTE</span>
08440 <span class="comment">    mappings.</span>
08441 <span class="comment"></span>
08442 <span class="comment">Arguments:</span>
08443 <span class="comment"></span>
08444 <span class="comment">    None.</span>
08445 <span class="comment"></span>
08446 <span class="comment">Return Value:</span>
08447 <span class="comment"></span>
08448 <span class="comment">    None.</span>
08449 <span class="comment"></span>
08450 <span class="comment">Environment:</span>
08451 <span class="comment"></span>
08452 <span class="comment">    Kernel mode.</span>
08453 <span class="comment"></span>
08454 <span class="comment">--*/</span>
08455 {
08456     <a class="code" href="../../d6/d8/mi386_8h.html#a204">MiWriteCombiningPtes</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
08457 }
08458 
08459 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
08460 <a class="code" href="../../d2/d1/mm_8h.html#a197">MmDispatchWin32Callout</a>(
08461     IN <a class="code" href="../../d2/d1/mm_8h.html#a146">PKWIN32_CALLOUT</a> CallbackRoutine,
08462     IN PKWIN32_CALLOUT WorkerCallback OPTIONAL,
08463     IN PVOID Parameter,
08464     IN PULONG SessionId OPTIONAL
08465     )
08466 
08467 <span class="comment">/*++</span>
08468 <span class="comment"></span>
08469 <span class="comment">Routine Description:</span>
08470 <span class="comment"></span>
08471 <span class="comment">    This routine dispatches callbacks to the WIN32K.SYS module.</span>
08472 <span class="comment"></span>
08473 <span class="comment">Arguments:</span>
08474 <span class="comment"></span>
08475 <span class="comment">    CallbackRoutine - Supplies the function in WIN32K.SYS to callback.</span>
08476 <span class="comment"></span>
08477 <span class="comment">    WorkerCallback - If present indicates the routine to be called to do</span>
08478 <span class="comment">                     additional processing if required. This routine MUST</span>
08479 <span class="comment">                     then call the callback.  The CallbackRoutine will NOT be</span>
08480 <span class="comment">                     called, but only used to check for existence in session</span>
08481 <span class="comment">                     space.</span>
08482 <span class="comment"></span>
08483 <span class="comment">    Parameter - Supplies the parameter to pass to the called function.</span>
08484 <span class="comment"></span>
08485 <span class="comment">    SessionId - Supplies an optional pointer to the session ID in</span>
08486 <span class="comment">                which to dispatch the callback.  NULL indicates all sessions.</span>
08487 <span class="comment"></span>
08488 <span class="comment">Return Value:</span>
08489 <span class="comment"></span>
08490 <span class="comment">    NTSTATUS code.</span>
08491 <span class="comment"></span>
08492 <span class="comment">Environment:</span>
08493 <span class="comment"></span>
08494 <span class="comment">    Kernel mode, system process context.</span>
08495 <span class="comment"></span>
08496 <span class="comment">--*/</span>
08497 
08498 {
08499     ULONG i;
08500     KIRQL OldIrql;
08501     PLIST_ENTRY NextEntry;
08502     <a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html">PMM_SESSION_SPACE</a> Session;
08503     <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> *Processes;
08504     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
08505     ULONG SessionCount;
08506     BOOLEAN Signal;
08507     <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> SingleProcess;
08508     PLIST_ENTRY NextProcessEntry;
08509     <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process;
08510 
08511     <span class="keywordflow">if</span> (WorkerCallback == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
08512         WorkerCallback = CallbackRoutine;
08513     }
08514 
08515     <span class="keywordflow">if</span> (<a class="code" href="../../d4/d8/mi_8h.html#a581">MiHydra</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
08516         <span class="keywordflow">return</span> (*WorkerCallback)(Parameter);
08517     }
08518 
08519     <span class="keywordflow">if</span> (<a class="code" href="../../d4/d8/mi_8h.html#a354">MI_IS_SESSION_ADDRESS</a>((ULONG_PTR)*CallbackRoutine) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
08520         <span class="keywordflow">return</span> (*WorkerCallback)(Parameter);
08521     }
08522 
08523     <span class="comment">//</span>
08524     <span class="comment">// If the call is from a user mode process, we are in</span>
08525     <span class="comment">// a session space.  In this case the power event is</span>
08526     <span class="comment">// only of interest to the current session.</span>
08527     <span class="comment">//</span>
08528 
08529     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>()-&gt;Vm.u.Flags.ProcessInSession == 1) {
08530         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d8/d2/pagfault_8c.html#a26">MmIsAddressValid</a>(MmSessionSpace) == TRUE);
08531         <span class="keywordflow">return</span> (*WorkerCallback)(Parameter);
08532     }
08533 
08534     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(SessionId)) {
08535 
08536         <span class="comment">//</span>
08537         <span class="comment">// If the SessionId is passed in as an argument, just attach to that</span>
08538         <span class="comment">// session and deliver the callback.</span>
08539         <span class="comment">//</span>
08540 
08541         SessionCount = 1;
08542 
08543         Processes = &amp;SingleProcess;
08544 
08545         <a class="code" href="../../d4/d8/mi_8h.html#a139">LOCK_EXPANSION</a> (OldIrql);
08546     }
08547     <span class="keywordflow">else</span> {
08548 
08549         <span class="comment">//</span>
08550         <span class="comment">// We must call all the WIN32 sessions on a Hydra system.  Each is in</span>
08551         <span class="comment">// a separate address space and is pagable.  Build a list of one</span>
08552         <span class="comment">// process in each session and attach to each in order to deliver</span>
08553         <span class="comment">// the callback.</span>
08554         <span class="comment">//</span>
08555 
08556 ReAllocate:
08557 
08558         SessionCount = <a class="code" href="../../d4/d8/mi_8h.html#a754">MiSessionCount</a> + 10;
08559 
08560         Processes = (<a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> *) <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(
08561                                   NonPagedPool,
08562                                   SessionCount * <span class="keyword">sizeof</span>(<a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a>),
08563                                   '23WD'
08564                                   );
08565 
08566         <span class="keywordflow">if</span> (Processes == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
08567             <span class="keywordflow">return</span> STATUS_NO_MEMORY;
08568         }
08569 
08570         <a class="code" href="../../d4/d8/mi_8h.html#a139">LOCK_EXPANSION</a> (OldIrql);
08571 
08572         <span class="keywordflow">if</span> (SessionCount &lt; <a class="code" href="../../d4/d8/mi_8h.html#a754">MiSessionCount</a>) {
08573             <a class="code" href="../../d4/d8/mi_8h.html#a140">UNLOCK_EXPANSION</a> (OldIrql);
08574             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (Processes);
08575             <span class="keywordflow">goto</span> ReAllocate;
08576         }
08577     }
08578 
08579     SessionCount = 0;
08580 
08581     NextEntry = <a class="code" href="../../d4/d8/mi_8h.html#a761">MiSessionWsList</a>.Flink;
08582 
08583     <span class="keywordflow">while</span> (NextEntry != &amp;<a class="code" href="../../d4/d8/mi_8h.html#a761">MiSessionWsList</a>) {
08584 
08585         Session = CONTAINING_RECORD(NextEntry, <a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html">MM_SESSION_SPACE</a>, WsListEntry);
08586 
08587         NextProcessEntry = Session-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o8">ProcessList</a>.Flink;
08588 
08589         <span class="keywordflow">if</span> ((Session-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o3">u</a>.Flags.DeletePending == 0) &amp;&amp;
08590             (NextProcessEntry != &amp;Session-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o8">ProcessList</a>)) {
08591 
08592             <span class="keywordflow">if</span> (ARGUMENT_PRESENT(SessionId) &amp;&amp; Session-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o4">SessionId</a> != *SessionId)
08593             {
08594                 <span class="comment">//</span>
08595                 <span class="comment">// Not the one we're looking for.</span>
08596                 <span class="comment">//</span>
08597 
08598                 NextEntry = NextEntry-&gt;Flink;
08599                 <span class="keywordflow">continue</span>;
08600             }
08601 
08602             Process = CONTAINING_RECORD (NextProcessEntry,
08603                                          <a class="code" href="../../d0/d4/struct__EPROCESS.html">EPROCESS</a>,
08604                                          SessionProcessLinks);
08605 
08606             <span class="keywordflow">if</span> (Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o16">Vm</a>.<a class="code" href="../../d3/d6/struct__MMSUPPORT.html#o15">u</a>.Flags.SessionLeader == 1) {
08607 
08608                 <span class="comment">//</span>
08609                 <span class="comment">// If session manager is still the first process (ie: smss</span>
08610                 <span class="comment">// hasn't detached yet), then don't bother delivering to this</span>
08611                 <span class="comment">// session this early in its lifetime.</span>
08612                 <span class="comment">//</span>
08613 
08614                 NextEntry = NextEntry-&gt;Flink;
08615                 <span class="keywordflow">continue</span>;
08616             }
08617 
08618             <span class="comment">//</span>
08619             <span class="comment">// Attach to the oldest process in the session (presumably csrss)</span>
08620             <span class="comment">// in hopes that it will exit the session last so we don't have</span>
08621             <span class="comment">// to retry.</span>
08622             <span class="comment">//</span>
08623 
08624             Processes[SessionCount] = CONTAINING_RECORD (NextProcessEntry,
08625                                                          <a class="code" href="../../d0/d4/struct__EPROCESS.html">EPROCESS</a>,
08626                                                          SessionProcessLinks);
08627 
08628             <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a> (Processes[SessionCount]);
08629             SessionCount += 1;
08630             Session-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o27">AttachCount</a> += 1;
08631 
08632             <span class="keywordflow">if</span> (ARGUMENT_PRESENT(SessionId) &amp;&amp; Session-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o4">SessionId</a> != *SessionId)
08633             {
08634                 <span class="keywordflow">break</span>;
08635             }
08636         }
08637         NextEntry = NextEntry-&gt;Flink;
08638     }
08639 
08640     <a class="code" href="../../d4/d8/mi_8h.html#a140">UNLOCK_EXPANSION</a> (OldIrql);
08641 
08642     <span class="comment">//</span>
08643     <span class="comment">// Now callback the referenced process objects.</span>
08644     <span class="comment">//</span>
08645 
08646     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_NOT_FOUND;
08647 
08648     <span class="keywordflow">for</span> (i = 0; i &lt; SessionCount; i += 1) {
08649 
08650         <a class="code" href="../../d3/d5/procobj_8c.html#a4">KeAttachProcess</a> (&amp;Processes[i]-&gt;Pcb);
08651 
08652         <span class="keywordflow">if</span> (Processes[i]-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o60">SessionId</a> == 0) {
08653 
08654             <span class="comment">//</span>
08655             <span class="comment">// Return status for the console session.</span>
08656             <span class="comment">//</span>
08657 
08658             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = (*WorkerCallback)(Parameter);
08659         }
08660         <span class="keywordflow">else</span> {
08661 
08662             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)(*WorkerCallback)(Parameter);
08663         }
08664 
08665         Signal = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
08666 
08667         <a class="code" href="../../d4/d8/mi_8h.html#a139">LOCK_EXPANSION</a> (OldIrql);
08668 
08669         <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o27">AttachCount</a> -= 1;
08670 
08671         <span class="keywordflow">if</span> (<a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o3">u</a>.Flags.DeletePending == 1 &amp;&amp; <a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o27">AttachCount</a> == 0) {
08672             Signal = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
08673         }
08674 
08675         <a class="code" href="../../d4/d8/mi_8h.html#a140">UNLOCK_EXPANSION</a> (OldIrql);
08676 
08677         <span class="keywordflow">if</span> (Signal == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
08678             <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a> (&amp;<a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o28">AttachEvent</a>, 0, FALSE);
08679         }
08680 
08681         <a class="code" href="../../d3/d5/procobj_8c.html#a7">KeDetachProcess</a>();
08682 
08683         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a> (Processes[i]);
08684     }
08685 
08686     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(SessionId) == 0) {
08687         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (Processes);
08688     }
08689 
08690     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
08691 }
08692 
08693 LOGICAL
08694 <a class="code" href="../../d2/d1/mm_8h.html#a207">MmIsSystemAddressLocked</a>(
08695     IN PVOID VirtualAddress
08696     )
08697 
08698 <span class="comment">/*++</span>
08699 <span class="comment"></span>
08700 <span class="comment">Routine Description:</span>
08701 <span class="comment"></span>
08702 <span class="comment">    This routine determines whether the specified system address is currently</span>
08703 <span class="comment">    locked.</span>
08704 <span class="comment"></span>
08705 <span class="comment">    This routine should only be called for debugging purposes, as it is not</span>
08706 <span class="comment">    guaranteed upon return to the caller that the address is still locked.</span>
08707 <span class="comment">    (The address could easily have been trimmed prior to return).</span>
08708 <span class="comment"></span>
08709 <span class="comment">Arguments:</span>
08710 <span class="comment"></span>
08711 <span class="comment">    VirtualAddress - Supplies the virtual address to check.</span>
08712 <span class="comment"></span>
08713 <span class="comment">Return Value:</span>
08714 <span class="comment"></span>
08715 <span class="comment">    TRUE if the address is locked.  FALSE if not.</span>
08716 <span class="comment"></span>
08717 <span class="comment">Environment:</span>
08718 <span class="comment"></span>
08719 <span class="comment">    DISPATCH LEVEL or below.  No memory management locks may be held.</span>
08720 <span class="comment"></span>
08721 <span class="comment">--*/</span>
08722 {
08723     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
08724     KIRQL OldIrql;
08725     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
08726     PFN_NUMBER PageFrameIndex;
08727 
08728     <span class="keywordflow">if</span> (<a class="code" href="../../d2/d1/mm_8h.html#a10">IS_SYSTEM_ADDRESS</a> (VirtualAddress) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
08729         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
08730     }
08731 
08732     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a> (VirtualAddress)) {
08733         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
08734     }
08735 
08736     <span class="comment">//</span>
08737     <span class="comment">// Hyperspace and page maps are not treated as locked down.</span>
08738     <span class="comment">//</span>
08739 
08740     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a194">MI_IS_PROCESS_SPACE_ADDRESS</a> (VirtualAddress) == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
08741         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
08742     }
08743 
08744 <span class="preprocessor">#if defined (_IA64_)</span>
08745 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (<a class="code" href="../../d2/d9/miia64_8h.html#a214">MI_IS_KERNEL_PTE_ADDRESS</a> (VirtualAddress) == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
08746         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
08747     }
08748 <span class="preprocessor">#endif</span>
08749 <span class="preprocessor"></span>
08750     <a class="code" href="../../d4/d8/mi_8h.html#a130">LOCK_PFN2</a> (OldIrql);
08751 
08752     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d2/pagfault_8c.html#a26">MmIsAddressValid</a> (VirtualAddress) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
08753         <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
08754         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
08755     }
08756 
08757     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (VirtualAddress);
08758 
08759     PageFrameIndex = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a> (PointerPte);
08760 
08761     <span class="comment">//</span>
08762     <span class="comment">// Note that the mapped page may not be in the PFN database.  Treat</span>
08763     <span class="comment">// this as locked.  There is no way to detect if the PFN database is</span>
08764     <span class="comment">// sparse without walking the loader blocks.  Don't bother doing this</span>
08765     <span class="comment">// as few machines are still sparse today.</span>
08766     <span class="comment">//</span>
08767 
08768     <span class="keywordflow">if</span> (PageFrameIndex &gt; <a class="code" href="../../d6/d8/sysinfo_8c.html#a7">MmHighestPhysicalPage</a>) {
08769         <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
08770         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
08771     }
08772 
08773     Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PageFrameIndex);
08774 
08775     <span class="comment">//</span>
08776     <span class="comment">// Check for the page being locked by reference.</span>
08777     <span class="comment">//</span>
08778 
08779     <span class="keywordflow">if</span> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount &gt; 1) {
08780         <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
08781         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
08782     }
08783 
08784     <span class="keywordflow">if</span> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount &gt; Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount) {
08785         <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
08786         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
08787     }
08788 
08789     <span class="comment">//</span>
08790     <span class="comment">// Check whether the page is locked into the working set.</span>
08791     <span class="comment">//</span>
08792 
08793     <span class="keywordflow">if</span> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.Event == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
08794         <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
08795         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
08796     }
08797 
08798     <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
08799 
08800     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
08801 }
08802 
08803 <span class="preprocessor">#if DBG</span>
08804 <span class="preprocessor"></span>
08805 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
08806 MiVerifyLockedPageCharges (
08807     VOID
08808     )
08809 {
08810     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
08811     KIRQL OldIrql;
08812     PFN_NUMBER start;
08813     PFN_NUMBER count;
08814     PFN_NUMBER Page;
08815     PFN_NUMBER LockCharged;
08816 
08817     <span class="keywordflow">if</span> (MiPrintLockedPages == 0) {
08818         <span class="keywordflow">return</span>;
08819     }
08820 
08821     <span class="keywordflow">if</span> (KeGetCurrentIrql() &gt; <a class="code" href="../../d6/d7/halmips_8h.html#a52">APC_LEVEL</a>) {
08822         <span class="keywordflow">return</span>;
08823     }
08824 
08825     start = 0;
08826     LockCharged = 0;
08827 
08828     ExAcquireFastMutex (&amp;MmDynamicMemoryMutex);
08829 
08830     <a class="code" href="../../d4/d8/mi_8h.html#a130">LOCK_PFN2</a> (OldIrql);
08831 
08832     <span class="keywordflow">do</span> {
08833 
08834         count = <a class="code" href="../../d2/d1/mm_8h.html#a131">MmPhysicalMemoryBlock</a>-&gt;<a class="code" href="../../d3/d5/struct__PHYSICAL__MEMORY__DESCRIPTOR.html#o2">Run</a>[start].<a class="code" href="../../d5/d5/struct__PHYSICAL__MEMORY__RUN.html#o1">PageCount</a>;
08835         Page = <a class="code" href="../../d2/d1/mm_8h.html#a131">MmPhysicalMemoryBlock</a>-&gt;<a class="code" href="../../d3/d5/struct__PHYSICAL__MEMORY__DESCRIPTOR.html#o2">Run</a>[start].<a class="code" href="../../d5/d5/struct__PHYSICAL__MEMORY__RUN.html#o0">BasePage</a>;
08836 
08837         <span class="keywordflow">if</span> (count != 0) {
08838             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (Page);
08839             <span class="keywordflow">do</span> {
08840                 <span class="keywordflow">if</span> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.LockCharged == 1) {
08841                     <span class="keywordflow">if</span> (MiPrintLockedPages &amp; 0x4) {
08842                         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a> (<span class="stringliteral">"%x "</span>, Pfn1 - MmPfnDatabase);
08843                     }
08844                     LockCharged += 1;
08845                 }
08846                 count -= 1;
08847                 Pfn1 += 1;
08848             } <span class="keywordflow">while</span> (count != 0);
08849         }
08850 
08851         start += 1;
08852     } <span class="keywordflow">while</span> (start != <a class="code" href="../../d2/d1/mm_8h.html#a131">MmPhysicalMemoryBlock</a>-&gt;<a class="code" href="../../d3/d5/struct__PHYSICAL__MEMORY__DESCRIPTOR.html#o0">NumberOfRuns</a>);
08853 
08854     <span class="keywordflow">if</span> (LockCharged != <a class="code" href="../../d5/d6/iosup_8c.html#a2">MmSystemLockPagesCount</a>) {
08855         <span class="keywordflow">if</span> (MiPrintLockedPages &amp; 0x1) {
08856             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a> (<span class="stringliteral">"MM: Locked pages MISMATCH %u %u\n"</span>,
08857                 LockCharged, MmSystemLockPagesCount);
08858         }
08859     }
08860     <span class="keywordflow">else</span> {
08861         <span class="keywordflow">if</span> (MiPrintLockedPages &amp; 0x2) {
08862             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a> (<span class="stringliteral">"MM: Locked pages ok %u\n"</span>,
08863                 LockCharged);
08864         }
08865     }
08866 
08867     <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql);
08868 
08869     ExReleaseFastMutex (&amp;MmDynamicMemoryMutex);
08870 
08871     <span class="keywordflow">return</span>;
08872 }
08873 <span class="preprocessor">#endif</span>
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:31 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
