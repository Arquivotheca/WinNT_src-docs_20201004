<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: vlm.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>vlm.c</h1><a href="../../d5/d6/vlm_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1996  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">   VLM.C</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module contains the routines which implement the 64-bit Very Large</span>
00012 <span class="comment">    Memory support.</span>
00013 <span class="comment"></span>
00014 <span class="comment">Author:</span>
00015 <span class="comment"></span>
00016 <span class="comment">    Lou Perazzoli (loup) 3-Sep-1996</span>
00017 <span class="comment"></span>
00018 <span class="comment">Revision History:</span>
00019 <span class="comment"></span>
00020 <span class="comment">--*/</span>
00021 
00022 <span class="preprocessor">#include "<a class="code" href="../../d4/d8/mi_8h.html">mi.h</a>"</span>
00023 
<a name="l00024"></a><a class="code" href="../../d5/d6/vlm_8c.html#a0">00024</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d3/d6/allocvm_8c.html#a0">MMVADKEY</a>;
00025 
00026 <span class="preprocessor">#ifdef VLM_SUPPORT</span>
00027 <span class="preprocessor"></span>
00028 <span class="preprocessor">#define ROUND_TO_PAGES64(Size)  ((ULONGLONG)(Size) + (PAGE_SIZE - 1) &amp; ~((LONGLONG)PAGE_SIZE - 1))</span>
00029 <span class="preprocessor"></span>
00030 <span class="preprocessor">#define MM_VALID_PTE_SIZE (256)</span>
00031 <span class="preprocessor"></span>
00032 <span class="preprocessor">#define MM_LARGEST_VLM_RANGE \</span>
00033 <span class="preprocessor">   ((ULONGLONG)MM_HIGHEST_USER_ADDRESS64 - (ULONGLONG)MM_LOWEST_USER_ADDRESS64)</span>
00034 <span class="preprocessor"></span>
00035 <span class="preprocessor">#define DELETE_TYPE_PRIVATE 0</span>
00036 <span class="preprocessor"></span><span class="preprocessor">#define DELETE_TYPE_SHARED 1</span>
00037 <span class="preprocessor"></span>
00038 <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a>
00039 <a class="code" href="../../d5/d3/queryvm_8c.html#a2">MiCaptureSystemPte</a> (
00040     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerProtoPte,
00041     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process
00042     );
00043 
00044 LOGICAL
00045 MiCommitPages64 (
00046     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> StartPte,
00047     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> LastPte,
00048     IN ULONG ProtectionMask,
00049     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process,
00050     OUT PSIZE_T ValidPtes
00051     );
00052 
00053 ULONG
00054 MiDecommitOrDeletePages64 (
00055     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> StartingPte,
00056     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> EndingPte,
00057     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process,
00058     IN ULONG Type,
00059     IN LOGICAL FlushTb
00060     );
00061 
00062 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00063 MiFlushPteList64 (
00064     IN PMMPTE_FLUSH_LIST64 PteFlushList,
00065     IN ULONG AllProcessors,
00066     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> FillPte
00067     );
00068 
00069 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00070 MiReturnAvailablePages (
00071     IN PFN_NUMBER Amount
00072     );
00073 
00074 LOGICAL
00075 MiCheckPdeForDeletion (
00076     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPde,
00077     IN LOGICAL FlushTb
00078     );
00079 
00080 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00081 MiProcessValidPteList64 (
00082     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> *ValidPteList,
00083     IN ULONG Count,
00084     IN LOGICAL FlushTb
00085     );
00086 
00087 ULONG
00088 MiDoesPdeExist64 (
00089     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPde
00090     );
00091 
00092 LOGICAL
00093 MiMakePdeExistAndMakeValid64 (
00094     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPde,
00095     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> TargetProcess,
00096     IN LOGICAL PfnLockHeld,
00097     IN LOGICAL MakePageTablePage
00098     );
00099 
00100 HARDWARE_PTE
00101 <a class="code" href="../../d0/d9/protect_8c.html#a1">MiFlushTbAndCapture</a>(
00102     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PtePointer,
00103     IN HARDWARE_PTE TempPte,
00104     IN <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1
00105     );
00106 
00107 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00108 MiMapViewOfVlmDataSection (
00109     IN <a class="code" href="../../d8/d7/struct__CONTROL__AREA.html">PCONTROL_AREA</a> ControlArea,
00110     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process,
00111     IN PVOID64 *CapturedBase,
00112     IN PULONGLONG SectionOffset,
00113     IN PULONGLONG CapturedViewSize,
00114     IN PSECTION Section,
00115     IN ULONG ProtectionMask,
00116     IN ULONG AllocationType,
00117     IN PULONG ReleasedWsMutex
00118     );
00119 
00120 ULONG
00121 MiIsEntireRangeCommitted64 (
00122     IN PVOID64 StartingAddress,
00123     IN PVOID64 EndingAddress,
00124     IN <a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a> Vad,
00125     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process
00126     );
00127 
00128 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00129 MiMakeValidPageNoAccess64 (
00130     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointePte
00131     );
00132 
00133 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00134 MiMakeNoAccessPageValid64 (
00135     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte,
00136     IN ULONG Protect
00137     );
00138 
00139 ULONG
00140 <a class="code" href="../../d8/d8/sysload_8c.html#a41">MiSetProtectionOnTransitionPte</a> (
00141     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte,
00142     IN ULONG ProtectionMask
00143     );
00144 
00145 ULONG
00146 MiQueryAddressState64 (
00147     IN PVOID64 Va,
00148     IN <a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a> Vad,
00149     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> TargetProcess,
00150     OUT PULONG ReturnedProtect
00151     );
00152 
00153 <span class="preprocessor">#define MI_NONPAGABLE_MEMORY_AVAILABLE(_SizeInPages) \</span>
00154 <span class="preprocessor">    (MmResidentAvailablePages &gt; ((SPFN_NUMBER)_SizeInPages + (SPFN_NUMBER)MmTotalFreeSystemPtes[NonPagedPoolExpansion] + ((SPFN_NUMBER)MiSpecialPagesNonPagedMaximum - (SPFN_NUMBER)MiSpecialPagesNonPaged) + (SPFN_NUMBER)MM_VLM_FLUID_PAGES))</span>
00155 <span class="preprocessor"></span>
00156 <span class="preprocessor">#define MI_GET_USED_PDE64_HANDLE(PDE64) \</span>
00157 <span class="preprocessor">        (&amp;(((PMI_PROCESS_VLM_INFO) (((PMMPTE)PDE_BASE64)-&gt;u.Long))-&gt;UsedPageTableEntries[PDE64 - MiGetPdeAddress64 (MM_LOWEST_USER_ADDRESS64)]))</span>
00158 <span class="preprocessor"></span>
00159 ULONG MmSharedCommitVlm;            <span class="comment">// Protected by the PFN lock.</span>
00160 
00161 KSPIN_LOCK MiVlmStatisticsLock;     <span class="comment">// Protects both fields below.</span>
00162 
00163 ULONG MiVlmCommitChargeInPages;
00164 ULONG MiVlmCommitChargeInPagesPeak;
00165 
00166 
00167 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00168 <a class="code" href="../../d5/d6/vlm_8c.html#a1">NtAllocateVirtualMemory64</a> (
00169     IN HANDLE ProcessHandle,
00170     IN OUT PVOID64 *BaseAddress,
00171     IN ULONG ZeroBits,
00172     IN OUT PULONGLONG RegionSize,
00173     IN ULONG AllocationType,
00174     IN ULONG Protect
00175     )
00176 
00177 <span class="comment">/*++</span>
00178 <span class="comment"></span>
00179 <span class="comment">Routine Description:</span>
00180 <span class="comment"></span>
00181 <span class="comment">    This function creates a region of pages within the virtual address</span>
00182 <span class="comment">    space of a subject process.</span>
00183 <span class="comment"></span>
00184 <span class="comment">Arguments:</span>
00185 <span class="comment"></span>
00186 <span class="comment">    ProcessHandle - Supplies an open handle to a process object.</span>
00187 <span class="comment"></span>
00188 <span class="comment">    BaseAddress - Supplies a pointer to a variable that will receive</span>
00189 <span class="comment">         the base address of the allocated region of pages.</span>
00190 <span class="comment">         If the initial value of this argument is not null,</span>
00191 <span class="comment">         then the region will be allocated starting at the</span>
00192 <span class="comment">         specified virtual address rounded down to the next</span>
00193 <span class="comment">         host page size address boundary. If the initial</span>
00194 <span class="comment">         value of this argument is null, then the operating</span>
00195 <span class="comment">         system will determine where to allocate the</span>
00196 <span class="comment">         region.</span>
00197 <span class="comment"></span>
00198 <span class="comment">    ZeroBits - IGNORED</span>
00199 <span class="comment"></span>
00200 <span class="comment">    RegionSize - Supplies a pointer to a variable that will receive</span>
00201 <span class="comment">         the actual size in bytes of the allocated region</span>
00202 <span class="comment">         of pages. The initial value of this argument</span>
00203 <span class="comment">         specifies the size in bytes of the region and is</span>
00204 <span class="comment">         rounded up to the next host page size boundary.</span>
00205 <span class="comment"></span>
00206 <span class="comment">    AllocationType - Supplies a set of flags that describe the type</span>
00207 <span class="comment">         of allocation that is to be performed for the</span>
00208 <span class="comment">         specified region of pages. Flags are:</span>
00209 <span class="comment"></span>
00210 <span class="comment"></span>
00211 <span class="comment">         MEM_COMMIT - The specified region of pages is to</span>
00212 <span class="comment">              be committed.</span>
00213 <span class="comment"></span>
00214 <span class="comment">         MEM_RESERVE - The specified region of pages is to</span>
00215 <span class="comment">              be reserved.</span>
00216 <span class="comment"></span>
00217 <span class="comment">         MEM_TOP_DOWN - NOT ALLOWED.</span>
00218 <span class="comment"></span>
00219 <span class="comment">         MEM_RESET - IGNORED.</span>
00220 <span class="comment"></span>
00221 <span class="comment">    Protect - Supplies the protection desired for the committed</span>
00222 <span class="comment">         region of pages.</span>
00223 <span class="comment"></span>
00224 <span class="comment">        Protect Values:</span>
00225 <span class="comment"></span>
00226 <span class="comment"></span>
00227 <span class="comment">         PAGE_NOACCESS - No access to the committed region</span>
00228 <span class="comment">              of pages is allowed. An attempt to read,</span>
00229 <span class="comment">              write, or execute the committed region</span>
00230 <span class="comment">              results in an access violation (i.e. a GP</span>
00231 <span class="comment">              fault).</span>
00232 <span class="comment"></span>
00233 <span class="comment">         PAGE_EXECUTE - Not allowed</span>
00234 <span class="comment"></span>
00235 <span class="comment">         PAGE_READONLY - Read only and execute access to the</span>
00236 <span class="comment">              committed region of pages is allowed. An</span>
00237 <span class="comment">              attempt to write the committed region results</span>
00238 <span class="comment">              in an access violation.</span>
00239 <span class="comment"></span>
00240 <span class="comment">         PAGE_READWRITE - Read, write, and execute access to</span>
00241 <span class="comment">              the committed region of pages is allowed. If</span>
00242 <span class="comment">              write access to the underlying section is</span>
00243 <span class="comment">              allowed, then a single copy of the pages are</span>
00244 <span class="comment">              shared. Otherwise the pages are shared read</span>
00245 <span class="comment">              only/copy on write.</span>
00246 <span class="comment"></span>
00247 <span class="comment">         PAGE_NOCACHE - not allowed.</span>
00248 <span class="comment"></span>
00249 <span class="comment">Return Value:</span>
00250 <span class="comment"></span>
00251 <span class="comment">    Returns the status</span>
00252 <span class="comment"></span>
00253 <span class="comment">    TBS</span>
00254 <span class="comment"></span>
00255 <span class="comment"></span>
00256 <span class="comment">--*/</span>
00257 
00258 {
00259     <a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a> Vad;
00260     <a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a> FoundVad;
00261     <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process;
00262     <a class="code" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> PreviousMode;
00263     PVOID64 StartingAddress;
00264     PVOID64 EndingAddress;
00265     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00266     PVOID64 CapturedBase;
00267     ULONGLONG CapturedRegionSize;
00268     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> CommitLimitPte;
00269     ULONG ProtectionMask;
00270     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> LastPte;
00271     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPde;
00272     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> StartingPte;
00273     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
00274     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> TempPte;
00275     ULONG OldProtect;
00276     SSIZE_T QuotaCharge;
00277     SIZE_T QuotaFree;
00278     ULONG CopyOnWriteCharge;
00279     BOOLEAN PageFileChargeSucceeded;
00280     LOGICAL Attached;
00281     KIRQL OldIrql;
00282     ULONG_PTR NewPages;
00283     LOGICAL ChargedExactQuota;
00284     LOGICAL CommitSucceeded;
00285     LOGICAL LargeVad;
00286     LOGICAL GotResidentAvail;
00287     PMI_PROCESS_VLM_INFO VlmInfo;
00288     ULONG CommitCharge;
00289 
00290     Attached = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00291 
00292     <span class="keywordflow">if</span> (MI_VLM_ENABLED() == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00293         <span class="keywordflow">return</span> STATUS_NOT_IMPLEMENTED;
00294     }
00295 
00296     <span class="comment">//</span>
00297     <span class="comment">// Check the AllocationType for correctness.</span>
00298     <span class="comment">//</span>
00299 
00300     <span class="keywordflow">if</span> ((AllocationType &amp; ~(MEM_COMMIT | MEM_RESERVE |
00301                             MEM_RESET)) != 0) {
00302         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER_5;
00303     }
00304 
00305     <span class="comment">//</span>
00306     <span class="comment">// One of MEM_COMMIT, MEM_RESET or MEM_RESERVE must be set.</span>
00307     <span class="comment">//</span>
00308 
00309     <span class="keywordflow">if</span> ((AllocationType &amp; (MEM_COMMIT | MEM_RESERVE | MEM_RESET)) == 0) {
00310         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER_5;
00311     }
00312 
00313     <span class="keywordflow">if</span> ((AllocationType &amp; MEM_RESET) &amp;&amp; (AllocationType != MEM_RESET)) {
00314 
00315         <span class="comment">//</span>
00316         <span class="comment">// MEM_RESET may not be used with any other flag.</span>
00317         <span class="comment">//</span>
00318 
00319         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER_5;
00320     }
00321 
00322     <span class="comment">//</span>
00323     <span class="comment">// Check the protection field.  This could raise an exception.</span>
00324     <span class="comment">//</span>
00325 
00326     <span class="keywordflow">try</span> {
00327         ProtectionMask = <a class="code" href="../../d0/d2/mmsup_8c.html#a5">MiMakeProtectionMask</a> (Protect);
00328     } except (EXCEPTION_EXECUTE_HANDLER) {
00329         <span class="keywordflow">return</span> GetExceptionCode();
00330     }
00331 
00332     <span class="keywordflow">if</span> ((ProtectionMask == <a class="code" href="../../d4/d8/mi_8h.html#a46">MM_NOACCESS</a>) &amp;&amp;
00333         (AllocationType &amp; MEM_COMMIT)) {
00334 
00335         <span class="keywordflow">return</span> STATUS_INVALID_PAGE_PROTECTION;
00336     }
00337 
00338     PreviousMode = KeGetPreviousMode();
00339 
00340     <span class="comment">//</span>
00341     <span class="comment">// Establish an exception handler, probe the specified addresses</span>
00342     <span class="comment">// for write access and capture the initial values.</span>
00343     <span class="comment">//</span>
00344 
00345     <span class="keywordflow">try</span> {
00346 
00347         <span class="keywordflow">if</span> (PreviousMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
00348 
00349             <a class="code" href="../../d5/d8/ex_8h.html#a259">ProbeForWrite</a> (BaseAddress, <span class="keyword">sizeof</span>(PVOID64), <span class="keyword">sizeof</span>(PVOID64));
00350             <a class="code" href="../../d5/d8/ex_8h.html#a259">ProbeForWrite</a> (RegionSize, <span class="keyword">sizeof</span>(ULONGLONG), <span class="keyword">sizeof</span>(ULONGLONG));
00351         }
00352 
00353         <span class="comment">//</span>
00354         <span class="comment">// Capture the base address.</span>
00355         <span class="comment">//</span>
00356 
00357         CapturedBase = *BaseAddress;
00358 
00359         <span class="comment">//</span>
00360         <span class="comment">// Capture the region size.</span>
00361         <span class="comment">//</span>
00362 
00363         CapturedRegionSize = *RegionSize;
00364 
00365     } except (<a class="code" href="../../d5/d8/ex_8h.html#a307">ExSystemExceptionFilter</a>()) {
00366 
00367         <span class="comment">//</span>
00368         <span class="comment">// If an exception occurs during the probe or capture</span>
00369         <span class="comment">// of the initial values, then handle the exception and</span>
00370         <span class="comment">// return the exception code as the status value.</span>
00371         <span class="comment">//</span>
00372 
00373         <span class="keywordflow">return</span> GetExceptionCode();
00374     }
00375 
00376 <span class="preprocessor">#if 0</span>
00377 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (MmDebug &amp; <a class="code" href="../../d4/d8/mi_8h.html#a81">MM_DBG_SHOW_NT_CALLS</a>) {
00378         <span class="keywordflow">if</span> ( MmWatchProcess ) {
00379             ;
00380         } <span class="keywordflow">else</span> {
00381             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"allocvm process handle %lx base address %p zero bits %lx\n"</span>,
00382                 ProcessHandle, CapturedBase, ZeroBits);
00383             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"    region size %p alloc type %lx protect %lx\n"</span>,
00384                 CapturedRegionSize, AllocationType, Protect);
00385         }
00386     }
00387 <span class="preprocessor">#endif</span>
00388 <span class="preprocessor"></span>
00389     <span class="comment">//</span>
00390     <span class="comment">// Make sure the specified starting and ending addresses are</span>
00391     <span class="comment">// within the user part of the virtual address space.</span>
00392     <span class="comment">//</span>
00393 
00394     <span class="keywordflow">if</span> ((CapturedBase != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) &amp;&amp;
00395         ((CapturedBase &gt; (PVOID64)MM_HIGHEST_USER_ADDRESS64) ||
00396         (CapturedBase &lt; (PVOID64)MM_LOWEST_USER_ADDRESS64))) {
00397 
00398         <span class="comment">//</span>
00399         <span class="comment">// Invalid base address.</span>
00400         <span class="comment">//</span>
00401 
00402         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER_2;
00403     }
00404 
00405     <span class="keywordflow">if</span> (CapturedBase != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00406 
00407         <span class="keywordflow">if</span> ((ULONGLONG)CapturedBase + CapturedRegionSize &lt; (ULONGLONG)CapturedBase) {
00408 
00409             <span class="comment">//</span>
00410             <span class="comment">// the requested region wraps</span>
00411             <span class="comment">//</span>
00412 
00413             <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER_4;
00414         }
00415 
00416 
00417         <span class="keywordflow">if</span> ((ULONGLONG)CapturedBase + CapturedRegionSize &gt; (ULONGLONG)MM_HIGHEST_USER_ADDRESS64 - <a class="code" href="../../d4/d8/mi_8h.html#a18">X64K</a>) {
00418 
00419             <span class="comment">//</span>
00420             <span class="comment">// the requested region goes beyond the end of user memory - flag it</span>
00421             <span class="comment">//</span>
00422 
00423             <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER_4;
00424         }
00425     }
00426     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (CapturedRegionSize &gt; (ULONGLONG)MM_LARGEST_VLM_RANGE - <a class="code" href="../../d4/d8/mi_8h.html#a18">X64K</a>) {
00427 
00428         <span class="comment">//</span>
00429         <span class="comment">// Invalid region size;</span>
00430         <span class="comment">//</span>
00431 
00432         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER_4;
00433     }
00434 
00435     <span class="keywordflow">if</span> (CapturedRegionSize == 0) {
00436 
00437         <span class="comment">//</span>
00438         <span class="comment">// Region size cannot be 0.</span>
00439         <span class="comment">//</span>
00440 
00441         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER_4;
00442     }
00443 
00444     <span class="comment">//</span>
00445     <span class="comment">// Reference the specified process handle for VM_OPERATION access.</span>
00446     <span class="comment">//</span>
00447 
00448     <span class="keywordflow">if</span> ( ProcessHandle == NtCurrentProcess() ) {
00449         Process = <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>();
00450     } <span class="keywordflow">else</span> {
00451         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a> ( ProcessHandle,
00452                                              PROCESS_VM_OPERATION,
00453                                              PsProcessType,
00454                                              PreviousMode,
00455                                              (PVOID *)&amp;Process,
00456                                              NULL );
00457 
00458         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status)) {
00459             <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00460         }
00461     }
00462 
00463     <span class="comment">//</span>
00464     <span class="comment">// If the specified process is not the current process, attach</span>
00465     <span class="comment">// to the specified process.</span>
00466     <span class="comment">//</span>
00467 
00468     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>() != Process) {
00469         <a class="code" href="../../d3/d5/procobj_8c.html#a4">KeAttachProcess</a> (&amp;Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o0">Pcb</a>);
00470         Attached = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00471     }
00472 
00473     <span class="comment">//</span>
00474     <span class="comment">// Get the address creation mutex to block multiple threads from</span>
00475     <span class="comment">// creating or deleting address space at the same time and</span>
00476     <span class="comment">// get the working set mutex so virtual address descriptors can</span>
00477     <span class="comment">// be inserted and walked.  Block APCs so an APC which takes a page</span>
00478     <span class="comment">// fault does not corrupt various structures.</span>
00479     <span class="comment">//</span>
00480 
00481     <a class="code" href="../../d4/d8/mi_8h.html#a161">LOCK_WS_AND_ADDRESS_SPACE</a> (Process);
00482 
00483     <span class="comment">//</span>
00484     <span class="comment">// Make sure the address space was not deleted, if so, return an error.</span>
00485     <span class="comment">//</span>
00486 
00487     <span class="keywordflow">if</span> (Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o27">AddressSpaceDeleted</a> != 0) {
00488         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_PROCESS_IS_TERMINATING;
00489         <span class="keywordflow">goto</span> ErrorReturn;
00490     }
00491 
00492     <span class="comment">//</span>
00493     <span class="comment">// Don't allow POSIX apps to do VLM operations.</span>
00494     <span class="comment">//</span>
00495 
00496     <span class="keywordflow">if</span> ((Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o40">CloneRoot</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
00497          (Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o32">ForkWasSuccessful</a> != MM_NO_FORK_ALLOWED)) {
00498         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_VLM_OPERATION;
00499         <span class="keywordflow">goto</span> ErrorReturn;
00500     }
00501     Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o32">ForkWasSuccessful</a> = MM_NO_FORK_ALLOWED;
00502 
00503     <span class="keywordflow">if</span> ((CapturedBase == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) || (AllocationType &amp; MEM_RESERVE)) {
00504 
00505         <span class="comment">//</span>
00506         <span class="comment">// PAGE_WRITECOPY is not valid for private pages.</span>
00507         <span class="comment">//</span>
00508 
00509         <span class="keywordflow">if</span> ((Protect &amp; PAGE_WRITECOPY) ||
00510             (Protect &amp; PAGE_EXECUTE_WRITECOPY)) {
00511             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_PAGE_PROTECTION;
00512             <span class="keywordflow">goto</span> ErrorReturn;
00513         }
00514 
00515         <span class="comment">//</span>
00516         <span class="comment">// Reserve the address space.</span>
00517         <span class="comment">//</span>
00518 
00519         <span class="keywordflow">if</span> (CapturedBase == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00520 
00521             <span class="comment">//</span>
00522             <span class="comment">// No base address was specified.  This MUST be a reserve or</span>
00523             <span class="comment">// reserve and commit.</span>
00524             <span class="comment">//</span>
00525 
00526             CapturedRegionSize = <a class="code" href="../../d3/d5/mapview_8c.html#a1">ROUND_TO_PAGES64</a> (CapturedRegionSize);
00527 
00528             <span class="comment">//</span>
00529             <span class="comment">// Establish exception handler as MiFindEmptyAddressRange</span>
00530             <span class="comment">// will raise an exception if it fails.</span>
00531             <span class="comment">//</span>
00532 
00533             <span class="keywordflow">try</span> {
00534 
00535 
00536                 StartingAddress = MiFindEmptyAddressRangeInTree64 (
00537                                    CapturedRegionSize,
00538                                    X64K,
00539                                    (<a class="code" href="../../d9/d0/struct__MMADDRESS__NODE.html">PMMADDRESS_NODE</a>)(Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o40">CloneRoot</a>));
00540 
00541             } except (EXCEPTION_EXECUTE_HANDLER) {
00542                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = GetExceptionCode();
00543                 <span class="keywordflow">goto</span> ErrorReturn;
00544             }
00545 
00546             <span class="comment">//</span>
00547             <span class="comment">// Calculate the ending address based on the top address.</span>
00548             <span class="comment">//</span>
00549 
00550             EndingAddress = (PVOID64)(((ULONGLONG)StartingAddress +
00551                                   CapturedRegionSize - 1<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>) | (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>));
00552 
00553         } <span class="keywordflow">else</span> {
00554 
00555             <span class="comment">//</span>
00556             <span class="comment">// A non-NULL base address was specified. Check to make sure</span>
00557             <span class="comment">// the specified base address to ending address is currently</span>
00558             <span class="comment">// unused.</span>
00559             <span class="comment">//</span>
00560 
00561             EndingAddress = (PVOID64)(((ULONGLONG)CapturedBase +
00562                                   CapturedRegionSize - 1<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>) | (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>));
00563 
00564             <span class="comment">//</span>
00565             <span class="comment">// Align the starting address on a 64k boundary.</span>
00566             <span class="comment">//</span>
00567 
00568             StartingAddress = MI_64K_ALIGN64(CapturedBase);
00569 
00570             <span class="comment">//</span>
00571             <span class="comment">// See if a VAD overlaps with this starting/ending address pair.</span>
00572             <span class="comment">//</span>
00573 
00574             <span class="keywordflow">if</span> (MiCheckForConflictingVad64 (StartingAddress, EndingAddress) !=
00575                     (<a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a>)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00576 
00577                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_CONFLICTING_ADDRESSES;
00578                 <span class="keywordflow">goto</span> ErrorReturn;
00579             }
00580         }
00581 
00582         <span class="keywordflow">if</span> (AllocationType &amp; MEM_COMMIT) {
00583             StartingPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a154">MiGetPteAddress64</a> (StartingAddress);
00584             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a152">MiGetPdeAddress64</a>(StartingAddress) == MiGetPteAddress (StartingPte));
00585             LastPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a154">MiGetPteAddress64</a> (EndingAddress);
00586             QuotaCharge = 1 + LastPte - StartingPte;
00587         }
00588         <span class="keywordflow">else</span> {
00589             QuotaCharge = 0;
00590         }
00591 
00592         <span class="comment">//</span>
00593         <span class="comment">// An unoccupied address range has been found, build the virtual</span>
00594         <span class="comment">// address descriptor to describe this range.</span>
00595         <span class="comment">//</span>
00596 
00597         <span class="comment">//</span>
00598         <span class="comment">// Establish an exception handler and attempt to allocate</span>
00599         <span class="comment">// the pool and charge quota.  Note that the InsertVad routine</span>
00600         <span class="comment">// will also charge quota which could raise an exception.</span>
00601         <span class="comment">//</span>
00602 
00603         <span class="keywordflow">try</span>  {
00604 
00605             <span class="keywordflow">if</span> ((AllocationType &amp; MEM_COMMIT) &amp;&amp; (QuotaCharge + QuotaCharge / <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a103">PTE_PER_PAGE</a> + 2 &gt;= <a class="code" href="../../d4/d8/mi_8h.html#a227">MM_MAX_COMMIT</a>)) {
00606                 LargeVad = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00607                 Vad = (<a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a>)<a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a> (NonPagedPool,
00608                                                      <span class="keyword">sizeof</span>(<a class="code" href="../../d6/d6/struct__MMVAD.html">MMVAD</a>),
00609                                                      MMVADKEY);
00610             }
00611             <span class="keywordflow">else</span> {
00612                 LargeVad = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00613                 Vad = (<a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a>)<a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a> (NonPagedPool,
00614                                                      <span class="keyword">sizeof</span>(<a class="code" href="../../d3/d7/struct__MMVAD__SHORT.html">MMVAD_SHORT</a>),
00615                                                      'SdaV');
00616             }
00617 
00618             <span class="comment">//</span>
00619             <span class="comment">// Faults are not allowed here since we are already holding the WS</span>
00620             <span class="comment">// lock.  This means we must check pool allocations explicitly.</span>
00621             <span class="comment">//</span>
00622 
00623             <span class="keywordflow">if</span> (Vad == (<a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a>)0) {
00624                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a> (STATUS_INSUFFICIENT_RESOURCES);
00625             }
00626 
00627             Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o0">StartingVpn</a> = MI_VA_TO_VPN64 (StartingAddress);
00628             Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o1">EndingVpn</a> = MI_VA_TO_VPN64 (EndingAddress);
00629 
00630             Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.LongFlags = 0;
00631             <span class="keywordflow">if</span> (AllocationType &amp; MEM_COMMIT) {
00632                 Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.VadFlags.MemCommit = 1;
00633 
00634                 <span class="keywordflow">if</span> (LargeVad == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00635                     Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.VadFlags.ImageMap = 1;       <span class="comment">// Signify large commit</span>
00636                     Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.VadFlags.CommitCharge = 0;
00637                     Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o16">u3</a>.List.Flink = (PLIST_ENTRY)QuotaCharge;
00638                 }
00639                 <span class="keywordflow">else</span> {
00640                     Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.VadFlags.CommitCharge = QuotaCharge;
00641                 }
00642             }
00643 
00644             Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.VadFlags.Protection = ProtectionMask;
00645             Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.VadFlags.PrivateMemory = 1;
00646 
00647             MiInsertVad64 ((PVOID)Vad);
00648 
00649         } except (EXCEPTION_EXECUTE_HANDLER) {
00650 
00651             <span class="keywordflow">if</span> (Vad != (<a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a>)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00652 
00653                 <span class="comment">//</span>
00654                 <span class="comment">// The pool allocation succeeded, but the quota charge</span>
00655                 <span class="comment">// in InsertVad failed, deallocate the pool and return</span>
00656                 <span class="comment">// an error.</span>
00657                 <span class="comment">//</span>
00658 
00659                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (Vad);
00660                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = GetExceptionCode();
00661             } <span class="keywordflow">else</span> {
00662                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INSUFFICIENT_RESOURCES;
00663             }
00664 
00665             <span class="keywordflow">goto</span> ErrorReturn;
00666         }
00667 
00668         <span class="keywordflow">if</span> (AllocationType &amp; MEM_COMMIT) {
00669 
00670             <span class="comment">//</span>
00671             <span class="comment">// Check to ensure these pages can be committed.</span>
00672             <span class="comment">// Charge quota and commitment for the range.  Establish an</span>
00673             <span class="comment">// exception handler as this could raise an exception.</span>
00674             <span class="comment">//</span>
00675 
00676             QuotaFree = 1;
00677             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
00678 
00679             <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
00680 
00681             <span class="keywordflow">if</span> (<a class="code" href="../../d4/d8/mi_8h.html#a323">MI_NONPAGABLE_MEMORY_AVAILABLE</a> (QuotaCharge)) {
00682                 <a class="code" href="../../d8/d5/kddata_8c.html#a42">MmResidentAvailablePages</a> -= (PFN_NUMBER)QuotaCharge;
00683                 <a class="code" href="../../d4/d8/mi_8h.html#a322">MM_BUMP_COUNTER</a>(22, QuotaCharge);
00684                 QuotaFree = 0;
00685             }
00686             <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
00687             <span class="keywordflow">if</span> (QuotaFree == 1) {
00688                 MiRemoveVad64 ((<a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a>)Vad);
00689                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (Vad);
00690                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_COMMITMENT_LIMIT;
00691                 <span class="keywordflow">goto</span> ErrorReturn;
00692             }
00693 
00694             CommitSucceeded = MiCommitPages64 (StartingPte,
00695                                                LastPte,
00696                                                ProtectionMask,
00697                                                Process,
00698                                                &amp;QuotaFree);
00699 
00700             <span class="keywordflow">if</span> (CommitSucceeded == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00701 
00702                 <span class="comment">//</span>
00703                 <span class="comment">// Nothing has been committed so just adjust counts and bail.</span>
00704                 <span class="comment">//</span>
00705 
00706                 <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
00707                 <a class="code" href="../../d8/d5/kddata_8c.html#a42">MmResidentAvailablePages</a> += (PFN_NUMBER) QuotaCharge;
00708                 <a class="code" href="../../d4/d8/mi_8h.html#a322">MM_BUMP_COUNTER</a>(22, -QuotaCharge);
00709                 <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
00710                 MiRemoveVad64 ((<a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a>)Vad);
00711                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (Vad);
00712                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INSUFFICIENT_RESOURCES;
00713                 <span class="keywordflow">goto</span> ErrorReturn;
00714             }
00715 
00716             <span class="keywordflow">if</span> (QuotaFree != 0) {
00717                 <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
00718                 <a class="code" href="../../d8/d5/kddata_8c.html#a42">MmResidentAvailablePages</a> += (PFN_NUMBER) QuotaFree;
00719                 <a class="code" href="../../d4/d8/mi_8h.html#a322">MM_BUMP_COUNTER</a>(23, QuotaFree);
00720                 <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
00721             }
00722 
00723             VlmInfo = (PMI_PROCESS_VLM_INFO) (((<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a6">PDE_BASE64</a>)-&gt;u.Long);
00724             VlmInfo-&gt;CommitCharge += (QuotaCharge - QuotaFree);
00725             <span class="keywordflow">if</span> (VlmInfo-&gt;CommitCharge &gt; VlmInfo-&gt;CommitChargePeak) {
00726                 VlmInfo-&gt;CommitChargePeak = VlmInfo-&gt;CommitCharge;
00727             }
00728         }
00729         <span class="keywordflow">else</span> {
00730 
00731             <span class="comment">//</span>
00732             <span class="comment">// The top level PDE map page is allocated here (it it is not</span>
00733             <span class="comment">// already) even though this is only a reserve.  Because data like</span>
00734             <span class="comment">// the virtual size is saved in a pool allocation whose pointer is</span>
00735             <span class="comment">// in the top level PDE map page.</span>
00736             <span class="comment">//</span>
00737 
00738             CommitSucceeded = MiMakePdeExistAndMakeValid64 (
00739                                         MiGetPdeAddress64 (StartingAddress),
00740                                         Process,
00741                                         FALSE,
00742                                         FALSE);
00743 
00744             <span class="keywordflow">if</span> (CommitSucceeded == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00745                 MiRemoveVad64 ((<a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a>)Vad);
00746                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (Vad);
00747                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INSUFFICIENT_RESOURCES;
00748                 <span class="keywordflow">goto</span> ErrorReturn;
00749             }
00750             QuotaCharge = 0;
00751         }
00752 
00753         <span class="comment">//</span>
00754         <span class="comment">// Unlock the working set lock, page faults can now be taken.</span>
00755         <span class="comment">//</span>
00756 
00757         <a class="code" href="../../d4/d8/mi_8h.html#a158">UNLOCK_WS</a> (Process);
00758 
00759         <span class="comment">//</span>
00760         <span class="comment">// Update the current virtual size in the process header, the</span>
00761         <span class="comment">// address space lock protects this operation.</span>
00762         <span class="comment">//</span>
00763 
00764         CapturedRegionSize = (ULONGLONG)EndingAddress - (ULONGLONG)StartingAddress + 1;
00765 
00766         VlmInfo = (PMI_PROCESS_VLM_INFO) (((<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a6">PDE_BASE64</a>)-&gt;u.Long);
00767         VlmInfo-&gt;VirtualSize += CapturedRegionSize;
00768         <span class="keywordflow">if</span> (VlmInfo-&gt;VirtualSize &gt; VlmInfo-&gt;VirtualSizePeak) {
00769             VlmInfo-&gt;VirtualSizePeak = VlmInfo-&gt;VirtualSize;
00770         }
00771 
00772         ExAcquireFastLock (&amp;MiVlmStatisticsLock, &amp;OldIrql);
00773 
00774         <span class="keywordflow">if</span> (AllocationType &amp; MEM_COMMIT) {
00775             MiVlmCommitChargeInPages += (QuotaCharge - QuotaFree);
00776             <span class="keywordflow">if</span> (MiVlmCommitChargeInPages &gt; MiVlmCommitChargeInPagesPeak) {
00777                 MiVlmCommitChargeInPagesPeak = MiVlmCommitChargeInPages;
00778             }
00779         }
00780 
00781         ExReleaseFastLock (&amp;MiVlmStatisticsLock, OldIrql);
00782 
00783         <span class="comment">//</span>
00784         <span class="comment">// Release the address space lock, lower IRQL, detach, and dereference</span>
00785         <span class="comment">// the process object.</span>
00786         <span class="comment">//</span>
00787 
00788         <a class="code" href="../../d4/d8/mi_8h.html#a163">UNLOCK_ADDRESS_SPACE</a>(Process);
00789         <span class="keywordflow">if</span> (Attached) {
00790             <a class="code" href="../../d3/d5/procobj_8c.html#a7">KeDetachProcess</a>();
00791         }
00792 
00793         <span class="keywordflow">if</span> ( ProcessHandle != NtCurrentProcess() ) {
00794             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a> (Process);
00795         }
00796 
00797         <span class="comment">//</span>
00798         <span class="comment">// Establish an exception handler and write the size and base</span>
00799         <span class="comment">// address.</span>
00800         <span class="comment">//</span>
00801         <span class="keywordflow">try</span> {
00802 
00803             *RegionSize = CapturedRegionSize;
00804             *BaseAddress = StartingAddress;
00805 
00806         } except (EXCEPTION_EXECUTE_HANDLER) {
00807 
00808             <span class="comment">//</span>
00809             <span class="comment">// Return success at this point even if the results</span>
00810             <span class="comment">// cannot be written.</span>
00811             <span class="comment">//</span>
00812 
00813             NOTHING;
00814         }
00815 
00816 <span class="preprocessor">#if 0</span>
00817 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (MmDebug &amp; <a class="code" href="../../d4/d8/mi_8h.html#a81">MM_DBG_SHOW_NT_CALLS</a>) {
00818             <span class="keywordflow">if</span> ( MmWatchProcess ) {
00819                 <span class="keywordflow">if</span> ( MmWatchProcess == <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>() ) {
00820                     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\n+++ ALLOC Type %lx Base %p Size %p\n"</span>,
00821                         AllocationType,StartingAddress, CapturedRegionSize);
00822                     MmFooBar();
00823                 }
00824             } <span class="keywordflow">else</span> {
00825                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"return allocvm status %lx baseaddr %p size %p\n"</span>,
00826                     Status, StartingAddress, CapturedRegionSize);
00827             }
00828         }
00829 <span class="preprocessor">#endif</span>
00830 <span class="preprocessor"></span>
00831         <span class="keywordflow">return</span> STATUS_SUCCESS;
00832 
00833     } <span class="keywordflow">else</span> {
00834 
00835         <span class="comment">//</span>
00836         <span class="comment">// Commit previously reserved pages.  Note that these pages could</span>
00837         <span class="comment">// be either private or a section.</span>
00838         <span class="comment">//</span>
00839 
00840         <span class="keywordflow">if</span> (AllocationType == MEM_RESET) {
00841 
00842             <span class="comment">//</span>
00843             <span class="comment">// Don't do anything for the mem reset case as the pages are</span>
00844             <span class="comment">// all valid.</span>
00845             <span class="comment">//</span>
00846 
00847             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
00848             <span class="keywordflow">goto</span> ErrorReturn;
00849 
00850         } <span class="keywordflow">else</span> {
00851             EndingAddress = (PVOID64)(((ULONGLONG)CapturedBase +
00852                                     CapturedRegionSize - 1) | (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1));
00853             StartingAddress = (PVOID64)PAGE_ALIGN64(CapturedBase);
00854         }
00855 
00856         CapturedRegionSize = (ULONGLONG)EndingAddress - (ULONGLONG)StartingAddress + 1;
00857 
00858         FoundVad = MiCheckForConflictingVad64 (StartingAddress, EndingAddress);
00859 
00860         <span class="keywordflow">if</span> (FoundVad == (<a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a>)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00861 
00862             <span class="comment">//</span>
00863             <span class="comment">// No virtual address is reserved at the specified base address,</span>
00864             <span class="comment">// return an error.</span>
00865             <span class="comment">//</span>
00866 
00867             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_CONFLICTING_ADDRESSES;
00868             <span class="keywordflow">goto</span> ErrorReturn;
00869         }
00870 
00871         <span class="comment">//</span>
00872         <span class="comment">// Ensure that the starting and ending addresses are all within</span>
00873         <span class="comment">// the same virtual address descriptor.</span>
00874         <span class="comment">//</span>
00875 
00876         <span class="keywordflow">if</span> ((MI_VA_TO_VPN64 (StartingAddress) &lt; FoundVad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o0">StartingVpn</a>) ||
00877             (MI_VA_TO_VPN64 (EndingAddress) &gt; FoundVad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o1">EndingVpn</a>)) {
00878 
00879             <span class="comment">//</span>
00880             <span class="comment">// Not within the section virtual address descriptor,</span>
00881             <span class="comment">// return an error.</span>
00882             <span class="comment">//</span>
00883 
00884             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_CONFLICTING_ADDRESSES;
00885             <span class="keywordflow">goto</span> ErrorReturn;
00886         }
00887 
00888 
00889         <span class="keywordflow">if</span> (FoundVad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.VadFlags.PrivateMemory == 1) {
00890 
00891             <span class="comment">//</span>
00892             <span class="comment">// PAGE_WRITECOPY is not valid for private pages.</span>
00893             <span class="comment">//</span>
00894 
00895             <span class="keywordflow">if</span> ((Protect &amp; PAGE_WRITECOPY) ||
00896                 (Protect &amp; PAGE_EXECUTE_WRITECOPY)) {
00897                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_PAGE_PROTECTION;
00898                 <span class="keywordflow">goto</span> ErrorReturn;
00899             }
00900 
00901             <span class="comment">//</span>
00902             <span class="comment">// Ensure none of the pages are already committed as described</span>
00903             <span class="comment">// in the virtual address descriptor.</span>
00904             <span class="comment">//</span>
00905 <span class="preprocessor">#if 0</span>
00906 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (AllocationType &amp; <a class="code" href="../../d3/d7/freevm_8c.html#a0">MEM_CHECK_COMMIT_STATE</a>) {
00907                 <span class="keywordflow">if</span> ( !<a class="code" href="../../d4/d8/mi_8h.html#a907">MiIsEntireRangeDecommitted</a>(StartingAddress,
00908                                                  EndingAddress,
00909                                                  FoundVad,
00910                                                  Process)) {
00911 
00912                     <span class="comment">//</span>
00913                     <span class="comment">// Previously reserved pages have been committed, or</span>
00914                     <span class="comment">// an error occurred, release mutex and return status.</span>
00915                     <span class="comment">//</span>
00916 
00917                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_ALREADY_COMMITTED;
00918                     <span class="keywordflow">goto</span> ErrorReturn;
00919                 }
00920             }
00921 <span class="preprocessor">#endif //0</span>
00922 <span class="preprocessor"></span>
00923             <span class="comment">//</span>
00924             <span class="comment">// The address range has not been committed, commit it now.</span>
00925             <span class="comment">// Note, that for private pages, commitment is handled by</span>
00926             <span class="comment">// explicitly updating PTEs to contain Demand Zero entries.</span>
00927             <span class="comment">//</span>
00928 
00929             StartingPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a154">MiGetPteAddress64</a> (StartingAddress);
00930             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a152">MiGetPdeAddress64</a>(StartingAddress) == MiGetPteAddress (StartingPte));
00931             LastPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a154">MiGetPteAddress64</a> (EndingAddress);
00932 
00933             <span class="comment">//</span>
00934             <span class="comment">// Check to ensure these pages can be committed.</span>
00935             <span class="comment">//</span>
00936 
00937             QuotaCharge = 1 + LastPte - StartingPte;
00938 
00939             <span class="comment">//</span>
00940             <span class="comment">// Charge quota and commitment for the range.  Establish an</span>
00941             <span class="comment">// exception handler as this could raise an exception.</span>
00942             <span class="comment">//</span>
00943 
00944             QuotaFree = 1;
00945             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
00946 
00947             <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
00948             <span class="keywordflow">if</span> (<a class="code" href="../../d4/d8/mi_8h.html#a323">MI_NONPAGABLE_MEMORY_AVAILABLE</a> (QuotaCharge)) {
00949                 <a class="code" href="../../d8/d5/kddata_8c.html#a42">MmResidentAvailablePages</a> -= (PFN_NUMBER) QuotaCharge;
00950                 <a class="code" href="../../d4/d8/mi_8h.html#a322">MM_BUMP_COUNTER</a>(24, QuotaCharge);
00951                 QuotaFree = 0;
00952             }
00953             <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
00954             <span class="keywordflow">if</span> (QuotaFree == 1) {
00955                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_COMMITMENT_LIMIT;
00956                 <span class="keywordflow">goto</span> ErrorReturn;
00957             }
00958 
00959             <span class="keywordflow">if</span> (Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o85">CommitChargeLimit</a>) {
00960                 <span class="keywordflow">if</span> (Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o12">CommitCharge</a> + QuotaCharge &gt; Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o85">CommitChargeLimit</a>) {
00961                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_COMMITMENT_LIMIT;
00962                     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
00963                     <a class="code" href="../../d8/d5/kddata_8c.html#a42">MmResidentAvailablePages</a> += (PFN_NUMBER) QuotaCharge;
00964                     <a class="code" href="../../d4/d8/mi_8h.html#a322">MM_BUMP_COUNTER</a>(24, -QuotaCharge);
00965                     <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
00966                     <span class="keywordflow">if</span> (Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o73">Job</a>) {
00967                         <a class="code" href="../../d1/d1/psjob_8c.html#a21">PsReportProcessMemoryLimitViolation</a> ();
00968                     }
00969                     <span class="keywordflow">goto</span> ErrorReturn;
00970                 }
00971             }
00972             <span class="keywordflow">if</span> (Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o74">JobStatus</a> &amp; <a class="code" href="../../d1/d9/ps_8h.html#a13">PS_JOB_STATUS_REPORT_COMMIT_CHANGES</a>) {
00973                 <span class="keywordflow">if</span> (<a class="code" href="../../d1/d1/psjob_8c.html#a20">PsChangeJobMemoryUsage</a>(QuotaCharge) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00974                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_COMMITMENT_LIMIT;
00975                     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
00976                     <a class="code" href="../../d8/d5/kddata_8c.html#a42">MmResidentAvailablePages</a> += (PFN_NUMBER) QuotaCharge;
00977                     <a class="code" href="../../d4/d8/mi_8h.html#a322">MM_BUMP_COUNTER</a>(24, -QuotaCharge);
00978                     <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
00979                     <span class="keywordflow">goto</span> ErrorReturn;
00980                 }
00981             }
00982 
00983             <span class="keywordflow">try</span> {
00984                 <a class="code" href="../../d6/d1/mmquota_8c.html#a17">MiChargeCommitment</a> (QuotaCharge, Process);
00985             } except (EXCEPTION_EXECUTE_HANDLER) {
00986 
00987                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = GetExceptionCode();
00988                 <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
00989                 <a class="code" href="../../d8/d5/kddata_8c.html#a42">MmResidentAvailablePages</a> += (PFN_NUMBER) QuotaCharge;
00990                 <a class="code" href="../../d4/d8/mi_8h.html#a322">MM_BUMP_COUNTER</a>(24, -QuotaCharge);
00991                 <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
00992                 <span class="keywordflow">if</span> (Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o74">JobStatus</a> &amp; <a class="code" href="../../d1/d9/ps_8h.html#a13">PS_JOB_STATUS_REPORT_COMMIT_CHANGES</a>) {
00993 
00994                     <span class="comment">//</span>
00995                     <span class="comment">// Temporarily up the process commit charge as the</span>
00996                     <span class="comment">// job code will be referencing it as though everything</span>
00997                     <span class="comment">// has succeeded.</span>
00998                     <span class="comment">//</span>
00999 
01000                     Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o12">CommitCharge</a> += QuotaCharge;
01001                     <a class="code" href="../../d1/d1/psjob_8c.html#a20">PsChangeJobMemoryUsage</a> (-(SSIZE_T)QuotaCharge);
01002                     Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o12">CommitCharge</a> -= QuotaCharge;
01003                 }
01004                 <span class="keywordflow">goto</span> ErrorReturn;
01005             }
01006 
01007             <a class="code" href="../../d4/d8/mi_8h.html#a254">MM_TRACK_COMMIT</a> (MM_DBG_COMMIT_ALLOCVM1_VLM, QuotaCharge);
01008 
01009             CommitSucceeded = MiCommitPages64 (StartingPte,
01010                                                LastPte,
01011                                                ProtectionMask,
01012                                                Process,
01013                                                &amp;QuotaFree);
01014 
01015             <span class="keywordflow">if</span> (CommitSucceeded == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01016                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INSUFFICIENT_RESOURCES;
01017                 <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
01018                 <a class="code" href="../../d8/d5/kddata_8c.html#a42">MmResidentAvailablePages</a> += (PFN_NUMBER) QuotaCharge;
01019                 <a class="code" href="../../d4/d8/mi_8h.html#a322">MM_BUMP_COUNTER</a>(24, -QuotaCharge);
01020                 <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
01021                 <a class="code" href="../../d6/d1/mmquota_8c.html#a19">MiReturnCommitment</a> (QuotaCharge);
01022                 <span class="keywordflow">if</span> (Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o74">JobStatus</a> &amp; <a class="code" href="../../d1/d9/ps_8h.html#a13">PS_JOB_STATUS_REPORT_COMMIT_CHANGES</a>) {
01023 
01024                     <span class="comment">//</span>
01025                     <span class="comment">// Temporarily up the process commit charge as the</span>
01026                     <span class="comment">// job code will be referencing it as though everything</span>
01027                     <span class="comment">// has succeeded.</span>
01028                     <span class="comment">//</span>
01029 
01030                     Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o12">CommitCharge</a> += QuotaCharge;
01031                     <a class="code" href="../../d1/d1/psjob_8c.html#a20">PsChangeJobMemoryUsage</a> (-(SSIZE_T)QuotaCharge);
01032                     Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o12">CommitCharge</a> -= QuotaCharge;
01033                 }
01034                 <span class="keywordflow">goto</span> ErrorReturn;
01035             }
01036 
01037             NewPages = QuotaCharge - QuotaFree;
01038 
01039             <span class="comment">//</span>
01040             <span class="comment">// Excess charging of commit is returned below.</span>
01041             <span class="comment">//</span>
01042 
01043             <span class="keywordflow">if</span> (FoundVad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.VadFlags.ImageMap == 1) {
01044                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (FoundVad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.VadFlags.CommitCharge == 0);
01045                 CommitCharge = (ULONG)FoundVad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o16">u3</a>.List.Flink;
01046             }
01047             <span class="keywordflow">else</span> {
01048                 CommitCharge = FoundVad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.VadFlags.CommitCharge;
01049             }
01050 
01051             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (CommitCharge + NewPages &gt;= CommitCharge);
01052             CommitCharge += NewPages;
01053 
01054             <span class="keywordflow">if</span> (QuotaFree) {
01055                 <a class="code" href="../../d6/d1/mmquota_8c.html#a19">MiReturnCommitment</a> (QuotaFree);
01056                 <a class="code" href="../../d4/d8/mi_8h.html#a254">MM_TRACK_COMMIT</a> (MM_DBG_COMMIT_ALLOCVM1_VLM, -QuotaFree);
01057                 <span class="keywordflow">if</span> (Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o74">JobStatus</a> &amp; <a class="code" href="../../d1/d9/ps_8h.html#a13">PS_JOB_STATUS_REPORT_COMMIT_CHANGES</a>) {
01058 
01059                     <span class="comment">//</span>
01060                     <span class="comment">// Temporarily up the process commit charge as the</span>
01061                     <span class="comment">// job code will be referencing it as though everything</span>
01062                     <span class="comment">// has succeeded.</span>
01063                     <span class="comment">//</span>
01064 
01065                     Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o12">CommitCharge</a> += QuotaFree;
01066                     <a class="code" href="../../d1/d1/psjob_8c.html#a20">PsChangeJobMemoryUsage</a> (-(SSIZE_T)QuotaFree);
01067                     Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o12">CommitCharge</a> -= QuotaFree;
01068                 }
01069             }
01070 
01071             <span class="keywordflow">if</span> (FoundVad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.VadFlags.ImageMap == 1) {
01072                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (FoundVad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.VadFlags.CommitCharge == 0);
01073                 FoundVad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o16">u3</a>.List.Flink = (PLIST_ENTRY)CommitCharge;
01074             }
01075             <span class="keywordflow">else</span> {
01076                 FoundVad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.VadFlags.CommitCharge = CommitCharge;
01077             }
01078 
01079             Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o12">CommitCharge</a> += NewPages;
01080             <span class="keywordflow">if</span> (Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o12">CommitCharge</a> &gt; Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o86">CommitChargePeak</a>) {
01081                 Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o86">CommitChargePeak</a> = Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o12">CommitCharge</a>;
01082             }
01083 
01084             VlmInfo = (PMI_PROCESS_VLM_INFO) (((<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a6">PDE_BASE64</a>)-&gt;u.Long);
01085             VlmInfo-&gt;CommitCharge += NewPages;
01086             <span class="keywordflow">if</span> (VlmInfo-&gt;CommitCharge &gt; VlmInfo-&gt;CommitChargePeak) {
01087                 VlmInfo-&gt;CommitChargePeak = VlmInfo-&gt;CommitCharge;
01088             }
01089 
01090             ExAcquireFastLock (&amp;MiVlmStatisticsLock, &amp;OldIrql);
01091 
01092             MiVlmCommitChargeInPages += NewPages;
01093             <span class="keywordflow">if</span> (MiVlmCommitChargeInPages &gt; MiVlmCommitChargeInPagesPeak) {
01094                 MiVlmCommitChargeInPagesPeak = MiVlmCommitChargeInPages;
01095             }
01096 
01097             ExReleaseFastLock (&amp;MiVlmStatisticsLock, OldIrql);
01098 
01099         } <span class="keywordflow">else</span> {
01100 
01101             <span class="comment">//</span>
01102             <span class="comment">// The no cache option is not allowed for sections.</span>
01103             <span class="comment">//</span>
01104 
01105             <span class="keywordflow">if</span> (Protect &amp; PAGE_NOCACHE) {
01106                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_PAGE_PROTECTION;
01107                 <span class="keywordflow">goto</span> ErrorReturn;
01108             }
01109 
01110             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (FoundVad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.VadFlags.NoChange == 0);
01111 
01112             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (FoundVad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o8">ControlArea</a>-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o11">FilePointer</a> == NULL);
01113 
01114             StartingPte = <a class="code" href="../../d4/d8/mi_8h.html#a246">MiGetProtoPteAddress</a> (FoundVad,
01115                                     MI_VA_TO_VPN64 (StartingAddress));
01116             PointerPte = StartingPte;
01117             LastPte = <a class="code" href="../../d4/d8/mi_8h.html#a246">MiGetProtoPteAddress</a> (FoundVad,
01118                                     MI_VA_TO_VPN64 (EndingAddress));
01119 
01120             <a class="code" href="../../d4/d8/mi_8h.html#a158">UNLOCK_WS</a> (Process);
01121 
01122             ExAcquireFastMutex (&amp;MmSectionCommitMutex);
01123 
01124             PointerPte = StartingPte;
01125 
01126             <span class="comment">//</span>
01127             <span class="comment">// Check to ensure these pages can be committed if this</span>
01128             <span class="comment">// is a page file backed segment.  Note that page file quota</span>
01129             <span class="comment">// has already been charged for this.</span>
01130             <span class="comment">//</span>
01131 
01132             QuotaCharge = 1 + LastPte - StartingPte;
01133 
01134             <span class="comment">//</span>
01135             <span class="comment">// Charge commitment for the range.  Establish an</span>
01136             <span class="comment">// exception handler as this could raise an exception.</span>
01137             <span class="comment">//</span>
01138 
01139             QuotaFree = 0;
01140 
01141             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_VLM_OPERATION;
01142             ChargedExactQuota = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01143 
01144             <span class="keywordflow">for</span> (; ; ) {
01145                 GotResidentAvail = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01146                 <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
01147                 <span class="keywordflow">if</span> (<a class="code" href="../../d4/d8/mi_8h.html#a323">MI_NONPAGABLE_MEMORY_AVAILABLE</a> (QuotaCharge)) {
01148                     <a class="code" href="../../d8/d5/kddata_8c.html#a42">MmResidentAvailablePages</a> -= (PFN_NUMBER) QuotaCharge;
01149                     <a class="code" href="../../d4/d8/mi_8h.html#a322">MM_BUMP_COUNTER</a>(36, QuotaCharge);
01150                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
01151                     GotResidentAvail = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01152                 }
01153                 <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
01154 
01155                 <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_SUCCESS) {
01156 
01157                     <span class="keywordflow">try</span> {
01158                         <a class="code" href="../../d6/d1/mmquota_8c.html#a17">MiChargeCommitment</a> (QuotaCharge, NULL);
01159                     } except (EXCEPTION_EXECUTE_HANDLER) {
01160                         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = GetExceptionCode();
01161                     }
01162                     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_SUCCESS) {
01163                         <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
01164                         MmSharedCommitVlm += QuotaCharge;
01165                         <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
01166                         <span class="keywordflow">break</span>;
01167                     }
01168                 }
01169 
01170                 <span class="comment">//</span>
01171                 <span class="comment">// Not enough resident pages or commmit for the commitment,</span>
01172                 <span class="comment">// If we've already backed out the previously committed</span>
01173                 <span class="comment">// pages from the charge, just return an error.</span>
01174                 <span class="comment">//</span>
01175 
01176                 <span class="keywordflow">if</span> (GotResidentAvail == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01177                     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
01178                     <a class="code" href="../../d8/d5/kddata_8c.html#a42">MmResidentAvailablePages</a> += (PFN_NUMBER) QuotaCharge;
01179                     <a class="code" href="../../d4/d8/mi_8h.html#a322">MM_BUMP_COUNTER</a>(36, -QuotaCharge);
01180                     <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
01181                 }
01182 
01183                 <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> != STATUS_INVALID_VLM_OPERATION) {
01184 
01185                     <span class="comment">//</span>
01186                     <span class="comment">// We have already tried for the precise charge,</span>
01187                     <span class="comment">// return an error.</span>
01188                     <span class="comment">//</span>
01189 
01190                     ExReleaseFastMutex (&amp;MmSectionCommitMutex);
01191                     <span class="keywordflow">goto</span> ErrorReturn1;
01192                 }
01193 
01194                 <span class="comment">//</span>
01195                 <span class="comment">// Quota charge failed, calculate the exact quota</span>
01196                 <span class="comment">// taking into account pages that may already be</span>
01197                 <span class="comment">// committed and retry the operation.</span>
01198                 <span class="comment">//</span>
01199 
01200                 <span class="keywordflow">while</span> (PointerPte &lt;= LastPte) {
01201 
01202                     <span class="comment">//</span>
01203                     <span class="comment">// Check to see if the prototype PTE is committed.</span>
01204                     <span class="comment">// Note that prototype PTEs cannot be decommitted so</span>
01205                     <span class="comment">// PTE only needs to be checked for zeroes.</span>
01206                     <span class="comment">//</span>
01207                     <span class="comment">//</span>
01208 
01209                     <span class="keywordflow">if</span> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long != 0) {
01210                         QuotaFree += 1;
01211                     }
01212                     PointerPte += 1;
01213                 }
01214 
01215                 <span class="keywordflow">if</span> (QuotaFree) {
01216                     PointerPte = StartingPte;
01217                     QuotaCharge -= QuotaFree;
01218                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_COMMITMENT_LIMIT;
01219                     ChargedExactQuota = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01220                 }
01221                 <span class="keywordflow">else</span> {
01222                     ExReleaseFastMutex (&amp;MmSectionCommitMutex);
01223                     <span class="keywordflow">goto</span> ErrorReturn1;
01224                 }
01225             }
01226 
01227             <span class="comment">//</span>
01228             <span class="comment">// Commit all the pages.</span>
01229             <span class="comment">//</span>
01230 
01231             QuotaFree = 0;
01232             TempPte = FoundVad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o8">ControlArea</a>-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o0">Segment</a>-&gt;<a class="code" href="../../d1/d1/struct__SEGMENT.html#o9">SegmentPteTemplate</a>;
01233 
01234             FoundVad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o8">ControlArea</a>-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o0">Segment</a>-&gt;<a class="code" href="../../d1/d1/struct__SEGMENT.html#o8">NumberOfCommittedPages</a> +=
01235                                                         QuotaCharge;
01236 
01237             <span class="keywordflow">while</span> (PointerPte &lt;= LastPte) {
01238 
01239                 <span class="keywordflow">if</span> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long != 0) {
01240 
01241                     <span class="comment">//</span>
01242                     <span class="comment">// Page is already committed, back out commitment.</span>
01243                     <span class="comment">//</span>
01244 
01245                     QuotaFree += 1;
01246                 } <span class="keywordflow">else</span> {
01247                     *PointerPte = TempPte;
01248                 }
01249                 PointerPte += 1;
01250             }
01251 
01252             <span class="keywordflow">if</span> (ChargedExactQuota == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01253                 QuotaFree = 0;
01254             }
01255             <span class="keywordflow">else</span> {
01256                 <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
01257                 MmSharedCommitVlm -= QuotaFree;
01258                 <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
01259                 FoundVad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o8">ControlArea</a>-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o0">Segment</a>-&gt;<a class="code" href="../../d1/d1/struct__SEGMENT.html#o8">NumberOfCommittedPages</a> -=
01260                                                         QuotaFree;
01261             }
01262 
01263             ExReleaseFastMutex (&amp;MmSectionCommitMutex);
01264             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((LONG)QuotaFree &gt;= 0);
01265 
01266             <span class="comment">//</span>
01267             <span class="comment">// Change all the protections to be protected as specified.</span>
01268             <span class="comment">//</span>
01269 
01270             <a class="code" href="../../d4/d8/mi_8h.html#a154">LOCK_WS</a> (Process);
01271 
01272 <span class="preprocessor">#if 0 //fixfix charge and update protection.</span>
01273 <span class="preprocessor"></span>            <a class="code" href="../../d0/d9/protect_8c.html#a6">MiSetProtectionOnSection</a> (Process,
01274                                       FoundVad,
01275                                       StartingAddress,
01276                                       EndingAddress,
01277                                       Protect,
01278                                       &amp;OldProtect,
01279                                       TRUE);
01280 
01281 <span class="preprocessor">#endif //0</span>
01282 <span class="preprocessor"></span>        }
01283 
01284         <a class="code" href="../../d4/d8/mi_8h.html#a158">UNLOCK_WS</a> (Process);
01285 
01286         <span class="keywordflow">if</span> (QuotaFree != 0) {
01287             <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
01288             <a class="code" href="../../d8/d5/kddata_8c.html#a42">MmResidentAvailablePages</a> += (PFN_NUMBER) QuotaFree;
01289             <a class="code" href="../../d4/d8/mi_8h.html#a322">MM_BUMP_COUNTER</a>(25, QuotaFree);
01290             <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
01291         }
01292 
01293         <span class="comment">//</span>
01294         <span class="comment">// Previously reserved pages have been committed, or an error occurred,</span>
01295         <span class="comment">// release working set lock, address creation lock, detach,</span>
01296         <span class="comment">// dereference process and return status.</span>
01297         <span class="comment">//</span>
01298 
01299         <a class="code" href="../../d4/d8/mi_8h.html#a163">UNLOCK_ADDRESS_SPACE</a>(Process);
01300 
01301         <span class="keywordflow">if</span> (Attached) {
01302             <a class="code" href="../../d3/d5/procobj_8c.html#a7">KeDetachProcess</a>();
01303         }
01304         <span class="keywordflow">if</span> ( ProcessHandle != NtCurrentProcess() ) {
01305             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a> (Process);
01306         }
01307 
01308         <span class="comment">//</span>
01309         <span class="comment">// Establish an exception handler and write the size and base</span>
01310         <span class="comment">// address.</span>
01311         <span class="comment">//</span>
01312 
01313         <span class="keywordflow">try</span> {
01314 
01315             *RegionSize = CapturedRegionSize;
01316             *BaseAddress = StartingAddress;
01317 
01318         } except (EXCEPTION_EXECUTE_HANDLER) {
01319             <span class="keywordflow">return</span> GetExceptionCode();
01320         }
01321 
01322 <span class="preprocessor">#if 0</span>
01323 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (MmDebug &amp; <a class="code" href="../../d4/d8/mi_8h.html#a81">MM_DBG_SHOW_NT_CALLS</a>) {
01324             <span class="keywordflow">if</span> ( MmWatchProcess ) {
01325                 <span class="keywordflow">if</span> ( MmWatchProcess == <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>() ) {
01326                     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\n+++ ALLOC Type %lx Base %p Size %p\n"</span>,
01327                         AllocationType,StartingAddress, CapturedRegionSize);
01328                     MmFooBar();
01329                 }
01330             } <span class="keywordflow">else</span> {
01331                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"return allocvm status %lx baseaddr %p size %p\n"</span>,
01332                     Status, CapturedRegionSize, StartingAddress);
01333             }
01334         }
01335 <span class="preprocessor">#endif</span>
01336 <span class="preprocessor"></span>
01337         <span class="keywordflow">return</span> STATUS_SUCCESS;
01338     }
01339 
01340 ErrorReturn:
01341     <a class="code" href="../../d4/d8/mi_8h.html#a158">UNLOCK_WS</a> (Process);
01342 
01343 ErrorReturn1:
01344 
01345     <a class="code" href="../../d4/d8/mi_8h.html#a163">UNLOCK_ADDRESS_SPACE</a> (Process);
01346     <span class="keywordflow">if</span> (Attached) {
01347         <a class="code" href="../../d3/d5/procobj_8c.html#a7">KeDetachProcess</a>();
01348     }
01349     <span class="keywordflow">if</span> (ProcessHandle != NtCurrentProcess()) {
01350         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a> (Process);
01351     }
01352     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01353 }
01354 
01355 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01356 <a class="code" href="../../d5/d6/vlm_8c.html#a2">NtFreeVirtualMemory64</a>(
01357     IN HANDLE ProcessHandle,
01358     IN OUT PVOID64 *BaseAddress,
01359     IN OUT PULONGLONG RegionSize,
01360     IN ULONG FreeType
01361     )
01362 
01363 <span class="comment">/*++</span>
01364 <span class="comment"></span>
01365 <span class="comment">Routine Description:</span>
01366 <span class="comment"></span>
01367 <span class="comment">    This function deletes a region of pages within the virtual address</span>
01368 <span class="comment">    space of a subject process.</span>
01369 <span class="comment"></span>
01370 <span class="comment">Arguments:</span>
01371 <span class="comment"></span>
01372 <span class="comment">   ProcessHandle - An open handle to a process object.</span>
01373 <span class="comment"></span>
01374 <span class="comment">   BaseAddress - The base address of the region of pages</span>
01375 <span class="comment">                 to be freed. This value is rounded down to the</span>
01376 <span class="comment">                 next host page address boundary.</span>
01377 <span class="comment"></span>
01378 <span class="comment">   RegionSize - A pointer to a variable that will receive</span>
01379 <span class="comment">                the actual size in bytes of the freed region of</span>
01380 <span class="comment">                pages. The initial value of this argument is</span>
01381 <span class="comment">                rounded up to the next host page size boundary.</span>
01382 <span class="comment"></span>
01383 <span class="comment">   FreeType - A set of flags that describe the type of free that is to</span>
01384 <span class="comment">              be performed for the specified region of pages.</span>
01385 <span class="comment"></span>
01386 <span class="comment"></span>
01387 <span class="comment">       FreeType Flags</span>
01388 <span class="comment"></span>
01389 <span class="comment"></span>
01390 <span class="comment">        MEM_DECOMMIT - The specified region of pages is to</span>
01391 <span class="comment">                       be decommitted.</span>
01392 <span class="comment"></span>
01393 <span class="comment">        MEM_RELEASE - The specified region of pages is to</span>
01394 <span class="comment">                      be released.</span>
01395 <span class="comment"></span>
01396 <span class="comment"></span>
01397 <span class="comment">Return Value:</span>
01398 <span class="comment"></span>
01399 <span class="comment">    Returns the status</span>
01400 <span class="comment"></span>
01401 <span class="comment">    TBS</span>
01402 <span class="comment"></span>
01403 <span class="comment"></span>
01404 <span class="comment">--*/</span>
01405 
01406 {
01407     <a class="code" href="../../d3/d7/struct__MMVAD__SHORT.html">PMMVAD_SHORT</a> Vad;
01408     <a class="code" href="../../d3/d7/struct__MMVAD__SHORT.html">PMMVAD_SHORT</a> NewVad;
01409     <a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a> PreviousVad;
01410     <a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a> NextVad;
01411     <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process;
01412     <a class="code" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> PreviousMode;
01413     PVOID64 StartingAddress;
01414     PVOID64 EndingAddress;
01415     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01416     LOGICAL Attached;
01417     ULONGLONG CapturedRegionSize;
01418     PVOID64 CapturedBase;
01419     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> StartingPte;
01420     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> EndingPte;
01421     SIZE_T OldQuota;
01422     SIZE_T QuotaCharge;
01423     SIZE_T CommitReduction;
01424     ULONG OldEnd;
01425     KIRQL OldIrql;
01426     PMI_PROCESS_VLM_INFO VlmInfo;
01427 
01428     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01429 
01430     Attached = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01431 
01432     <span class="keywordflow">if</span> (MI_VLM_ENABLED() == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01433         <span class="keywordflow">return</span> STATUS_NOT_IMPLEMENTED;
01434     }
01435 
01436     <span class="comment">//</span>
01437     <span class="comment">// Check to make sure FreeType is good.</span>
01438     <span class="comment">//</span>
01439 
01440     <span class="keywordflow">if</span> ((FreeType &amp; ~(MEM_DECOMMIT | MEM_RELEASE)) != 0) {
01441         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER_4;
01442     }
01443 
01444     <span class="comment">//</span>
01445     <span class="comment">// One of MEM_DECOMMIT or MEM_RELEASE must be specified, but not both.</span>
01446     <span class="comment">//</span>
01447 
01448     <span class="keywordflow">if</span> (((FreeType &amp; (MEM_DECOMMIT | MEM_RELEASE)) == 0) ||
01449         ((FreeType &amp; (MEM_DECOMMIT | MEM_RELEASE)) ==
01450                             (MEM_DECOMMIT | MEM_RELEASE))) {
01451         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER_4;
01452     }
01453 
01454     PreviousMode = KeGetPreviousMode();
01455 
01456     <span class="comment">//</span>
01457     <span class="comment">// Establish an exception handler, probe the specified addresses</span>
01458     <span class="comment">// for write access and capture the initial values.</span>
01459     <span class="comment">//</span>
01460 
01461     <span class="keywordflow">try</span> {
01462 
01463         <span class="keywordflow">if</span> (PreviousMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
01464 
01465             <a class="code" href="../../d5/d8/ex_8h.html#a259">ProbeForWrite</a> (BaseAddress, <span class="keyword">sizeof</span>(PVOID64), <span class="keyword">sizeof</span>(PVOID64));
01466             <a class="code" href="../../d5/d8/ex_8h.html#a259">ProbeForWrite</a> (RegionSize, <span class="keyword">sizeof</span>(ULONGLONG), <span class="keyword">sizeof</span>(ULONGLONG));
01467         }
01468 
01469         <span class="comment">//</span>
01470         <span class="comment">// Capture the base address.</span>
01471         <span class="comment">//</span>
01472 
01473         CapturedBase = *BaseAddress;
01474 
01475         <span class="comment">//</span>
01476         <span class="comment">// Capture the region size.</span>
01477         <span class="comment">//</span>
01478 
01479         CapturedRegionSize = *RegionSize;
01480 
01481     } except (<a class="code" href="../../d5/d8/ex_8h.html#a307">ExSystemExceptionFilter</a>()) {
01482 
01483         <span class="comment">//</span>
01484         <span class="comment">// If an exception occurs during the probe or capture</span>
01485         <span class="comment">// of the initial values, then handle the exception and</span>
01486         <span class="comment">// return the exception code as the status value.</span>
01487         <span class="comment">//</span>
01488 
01489         <span class="keywordflow">return</span> GetExceptionCode();
01490     }
01491 
01492 <span class="preprocessor">#if 0</span>
01493 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (MmDebug &amp; <a class="code" href="../../d4/d8/mi_8h.html#a81">MM_DBG_SHOW_NT_CALLS</a>) {
01494         <span class="keywordflow">if</span> ( !MmWatchProcess ) {
01495             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"freevm processhandle %lx base %p size %p type %lx\n"</span>,
01496                     ProcessHandle, CapturedBase, CapturedRegionSize, FreeType);
01497         }
01498     }
01499 <span class="preprocessor">#endif</span>
01500 <span class="preprocessor"></span>
01501     <span class="keywordflow">if</span> ((CapturedRegionSize != 0) &amp;&amp; (FreeType &amp; MEM_RELEASE)) {
01502         <span class="keywordflow">return</span> STATUS_FREE_VM_NOT_AT_BASE;
01503     }
01504 
01505     <span class="comment">//</span>
01506     <span class="comment">// Make sure the specified starting and ending addresses are</span>
01507     <span class="comment">// within the user part of the virtual address space.</span>
01508     <span class="comment">//</span>
01509 
01510     <span class="keywordflow">if</span> (CapturedBase &gt; (PVOID64)MM_HIGHEST_USER_ADDRESS64) {
01511 
01512         <span class="comment">//</span>
01513         <span class="comment">// Invalid base address.</span>
01514         <span class="comment">//</span>
01515 
01516         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER_2;
01517     }
01518 
01519     <span class="keywordflow">if</span> ((ULONGLONG)MM_HIGHEST_USER_ADDRESS64 - (ULONGLONG)CapturedBase &lt;
01520                                                         CapturedRegionSize) {
01521 
01522         <span class="comment">//</span>
01523         <span class="comment">// Invalid region size;</span>
01524         <span class="comment">//</span>
01525 
01526         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER_3;
01527 
01528     }
01529 
01530     EndingAddress = (PVOID64)(((ULONGLONG)CapturedBase + CapturedRegionSize - 1) |
01531                         (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1));
01532 
01533     StartingAddress = (PVOID64)PAGE_ALIGN64(CapturedBase);
01534 
01535     <span class="keywordflow">if</span> ( ProcessHandle == NtCurrentProcess() ) {
01536         Process = <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>();
01537     } <span class="keywordflow">else</span> {
01538 
01539         <span class="comment">//</span>
01540         <span class="comment">// Reference the specified process handle for VM_OPERATION access.</span>
01541         <span class="comment">//</span>
01542 
01543         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a> ( ProcessHandle,
01544                                              PROCESS_VM_OPERATION,
01545                                              PsProcessType,
01546                                              PreviousMode,
01547                                              (PVOID *)&amp;Process,
01548                                              NULL );
01549         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status)) {
01550             <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01551         }
01552     }
01553 
01554     <span class="comment">//</span>
01555     <span class="comment">// If the specified process is not the current process, attach</span>
01556     <span class="comment">// to the specified process.</span>
01557     <span class="comment">//</span>
01558 
01559     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>() != Process) {
01560         <a class="code" href="../../d3/d5/procobj_8c.html#a4">KeAttachProcess</a> (&amp;Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o0">Pcb</a>);
01561         Attached = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01562     }
01563 
01564 
01565     <span class="comment">//</span>
01566     <span class="comment">// Get the address creation mutex to block multiple threads from</span>
01567     <span class="comment">// creating or deleting address space at the same time and</span>
01568     <span class="comment">// get the working set mutex so virtual address descriptors can</span>
01569     <span class="comment">// be inserted and walked.  Block APCs to prevent page faults while</span>
01570     <span class="comment">// we own the working set mutex.</span>
01571     <span class="comment">//</span>
01572 
01573     <a class="code" href="../../d4/d8/mi_8h.html#a161">LOCK_WS_AND_ADDRESS_SPACE</a> (Process);
01574 
01575     <span class="comment">//</span>
01576     <span class="comment">// Make sure the address space was not deleted.</span>
01577     <span class="comment">//</span>
01578 
01579     <span class="keywordflow">if</span> (Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o27">AddressSpaceDeleted</a> != 0) {
01580         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_PROCESS_IS_TERMINATING;
01581         <span class="keywordflow">goto</span> ErrorReturn;
01582     }
01583 
01584     <span class="keywordflow">if</span> (Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o32">ForkWasSuccessful</a> != MM_NO_FORK_ALLOWED) {
01585         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_MEMORY_NOT_ALLOCATED;
01586         <span class="keywordflow">goto</span> ErrorReturn;
01587     }
01588 
01589     Vad = (<a class="code" href="../../d3/d7/struct__MMVAD__SHORT.html">PMMVAD_SHORT</a>)MiLocateAddress64 (MI_VA_TO_VPN64 (StartingAddress));
01590 
01591     <span class="keywordflow">if</span> (Vad == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01592 
01593         <span class="comment">//</span>
01594         <span class="comment">// No Virtual Address Descriptor located for Base Address.</span>
01595         <span class="comment">//</span>
01596 
01597         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_MEMORY_NOT_ALLOCATED;
01598         <span class="keywordflow">goto</span> ErrorReturn;
01599     }
01600 
01601     <span class="comment">//</span>
01602     <span class="comment">// Found the associated Virtual Address Descriptor.</span>
01603     <span class="comment">//</span>
01604 
01605     <span class="keywordflow">if</span> (Vad-&gt;<a class="code" href="../../d3/d7/struct__MMVAD__SHORT.html#o1">EndingVpn</a> &lt; MI_VA_TO_VPN64 (EndingAddress)) {
01606 
01607         <span class="comment">//</span>
01608         <span class="comment">// The entire range to delete is not contained within a single</span>
01609         <span class="comment">// virtual address descriptor.  Return an error.</span>
01610         <span class="comment">//</span>
01611 
01612         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_UNABLE_TO_FREE_VM;
01613         <span class="keywordflow">goto</span> ErrorReturn;
01614     }
01615 
01616     <span class="comment">//</span>
01617     <span class="comment">// Check to ensure this Vad is deletable.  Delete is required</span>
01618     <span class="comment">// for both decommit and release.</span>
01619     <span class="comment">//</span>
01620 
01621     <span class="keywordflow">if</span> ((Vad-&gt;<a class="code" href="../../d3/d7/struct__MMVAD__SHORT.html#o7">u</a>.VadFlags.PrivateMemory == 0) ||
01622         (Vad-&gt;<a class="code" href="../../d3/d7/struct__MMVAD__SHORT.html#o7">u</a>.VadFlags.PhysicalMapping == 1)) {
01623         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_UNABLE_TO_DELETE_SECTION;
01624         <span class="keywordflow">goto</span> ErrorReturn;
01625     }
01626 
01627     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Vad-&gt;<a class="code" href="../../d3/d7/struct__MMVAD__SHORT.html#o7">u</a>.VadFlags.NoChange == 0);
01628 
01629     <span class="keywordflow">if</span> (FreeType &amp; MEM_RELEASE) {
01630 
01631         <span class="comment">//</span>
01632         <span class="comment">// *****************************************************************</span>
01633         <span class="comment">// MEM_RELEASE was specified.</span>
01634         <span class="comment">// *****************************************************************</span>
01635         <span class="comment">//</span>
01636 
01637         <span class="comment">//</span>
01638         <span class="comment">// The descriptor for the address range is deletable.  Remove the</span>
01639         <span class="comment">// the descriptor.</span>
01640         <span class="comment">//</span>
01641 
01642         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (CapturedRegionSize == 0);
01643 
01644         <span class="comment">//</span>
01645         <span class="comment">// If the region size is specified as 0, the base address</span>
01646         <span class="comment">// must be the starting address for the region.</span>
01647         <span class="comment">//</span>
01648 
01649         <span class="keywordflow">if</span> (MI_VA_TO_VPN64 (CapturedBase) != Vad-&gt;<a class="code" href="../../d3/d7/struct__MMVAD__SHORT.html#o0">StartingVpn</a>) {
01650             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_FREE_VM_NOT_AT_BASE;
01651             <span class="keywordflow">goto</span> ErrorReturn;
01652         }
01653 
01654         <span class="comment">//</span>
01655         <span class="comment">// This Virtual Address Descriptor has been deleted.</span>
01656         <span class="comment">//</span>
01657 
01658         StartingAddress = MI_VPN_TO_VA64 (Vad-&gt;<a class="code" href="../../d3/d7/struct__MMVAD__SHORT.html#o0">StartingVpn</a>);
01659         StartingPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a154">MiGetPteAddress64</a> (StartingAddress);
01660         EndingAddress = MI_VPN_TO_VA64 (Vad-&gt;<a class="code" href="../../d3/d7/struct__MMVAD__SHORT.html#o1">EndingVpn</a>);
01661         EndingPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a154">MiGetPteAddress64</a> (EndingAddress);
01662         CapturedRegionSize = ((EndingPte - StartingPte + 1) &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
01663         MiRemoveVad64 ((<a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a>)Vad);
01664         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (Vad);
01665 
01666         <span class="comment">//</span>
01667         <span class="comment">// Get the PFN mutex so that MiDeleteVirtualAddresses can be called.</span>
01668         <span class="comment">//</span>
01669 
01670         CommitReduction = MiDecommitOrDeletePages64 (StartingPte,
01671                                                      EndingPte,
01672                                                      Process,
01673                                                      DELETE_TYPE_PRIVATE,
01674                                                      TRUE);
01675         <a class="code" href="../../d4/d8/mi_8h.html#a158">UNLOCK_WS</a> (Process);
01676 
01677         <span class="comment">//</span>
01678         <span class="comment">// Update the virtual size in the process header.</span>
01679         <span class="comment">//</span>
01680 
01681         VlmInfo = (PMI_PROCESS_VLM_INFO) (((<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a6">PDE_BASE64</a>)-&gt;u.Long);
01682         VlmInfo-&gt;VirtualSize -= CapturedRegionSize;
01683         VlmInfo-&gt;CommitCharge -= CommitReduction;
01684 
01685         ExAcquireFastLock (&amp;MiVlmStatisticsLock, &amp;OldIrql);
01686         MiVlmCommitChargeInPages -= CommitReduction;
01687         ExReleaseFastLock (&amp;MiVlmStatisticsLock, OldIrql);
01688 
01689         <a class="code" href="../../d4/d8/mi_8h.html#a163">UNLOCK_ADDRESS_SPACE</a> (Process);
01690 
01691         <span class="keywordflow">if</span> (Attached) {
01692             <a class="code" href="../../d3/d5/procobj_8c.html#a7">KeDetachProcess</a>();
01693         }
01694 
01695         <span class="keywordflow">if</span> ( ProcessHandle != NtCurrentProcess() ) {
01696             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a> (Process);
01697         }
01698         <span class="comment">//</span>
01699         <span class="comment">// Establish an exception handler and write the size and base</span>
01700         <span class="comment">// address.</span>
01701         <span class="comment">//</span>
01702 
01703         <span class="keywordflow">try</span> {
01704 
01705             *RegionSize = CapturedRegionSize;
01706             *BaseAddress = StartingAddress;
01707 
01708         } except (EXCEPTION_EXECUTE_HANDLER) {
01709 
01710             <span class="comment">//</span>
01711             <span class="comment">// An exception occurred, don't take any action (just handle</span>
01712             <span class="comment">// the exception and return success.</span>
01713 
01714         }
01715 
01716 <span class="preprocessor">#if 0</span>
01717 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (MmDebug &amp; <a class="code" href="../../d4/d8/mi_8h.html#a81">MM_DBG_SHOW_NT_CALLS</a>) {
01718             <span class="keywordflow">if</span> ( MmWatchProcess ) {
01719                 <span class="keywordflow">if</span> ( MmWatchProcess == <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>() ) {
01720                     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\n--- FREE Type 0x%lx Base %p Size %p\n"</span>,
01721                             FreeType, StartingAddress, CapturedRegionSize);
01722                     MmFooBar();
01723                 }
01724             }
01725         }
01726 <span class="preprocessor">#endif</span>
01727 <span class="preprocessor"></span>
01728         <span class="keywordflow">return</span> STATUS_SUCCESS;
01729     }
01730 
01731     <span class="comment">//</span>
01732     <span class="comment">// **************************************************************</span>
01733     <span class="comment">//</span>
01734     <span class="comment">// MEM_DECOMMIT was specified.</span>
01735     <span class="comment">//</span>
01736     <span class="comment">// **************************************************************</span>
01737     <span class="comment">//</span>
01738 
01739     <span class="comment">//</span>
01740     <span class="comment">// Check to ensure the complete range of pages is already committed.</span>
01741     <span class="comment">//</span>
01742 
01743     <span class="keywordflow">if</span> (CapturedRegionSize == 0) {
01744 
01745         <span class="keywordflow">if</span> (MI_VA_TO_VPN64 (CapturedBase) != Vad-&gt;<a class="code" href="../../d3/d7/struct__MMVAD__SHORT.html#o0">StartingVpn</a>) {
01746             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_FREE_VM_NOT_AT_BASE;
01747             <span class="keywordflow">goto</span> ErrorReturn;
01748         }
01749         EndingAddress = MI_VPN_TO_VA_ENDING64 (Vad-&gt;<a class="code" href="../../d3/d7/struct__MMVAD__SHORT.html#o1">EndingVpn</a>);
01750     }
01751 
01752     <span class="comment">//</span>
01753     <span class="comment">// Calculate the initial quotas and commit charges for this VAD.</span>
01754     <span class="comment">//</span>
01755 
01756     StartingPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a154">MiGetPteAddress64</a> (StartingAddress);
01757     EndingPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a154">MiGetPteAddress64</a> (EndingAddress);
01758 
01759     CapturedRegionSize = 1 + (ULONGLONG)EndingAddress - (ULONGLONG)StartingAddress;
01760 
01761     CommitReduction = MiDecommitOrDeletePages64 (StartingPte,
01762                                                  EndingPte,
01763                                                  Process,
01764                                                  DELETE_TYPE_PRIVATE,
01765                                                  TRUE);
01766 
01767     VlmInfo = (PMI_PROCESS_VLM_INFO) (((<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a6">PDE_BASE64</a>)-&gt;u.Long);
01768     VlmInfo-&gt;CommitCharge -= CommitReduction;
01769 
01770     ExAcquireFastLock (&amp;MiVlmStatisticsLock, &amp;OldIrql);
01771     MiVlmCommitChargeInPages -= CommitReduction;
01772     ExReleaseFastLock (&amp;MiVlmStatisticsLock, OldIrql);
01773 
01774     <a class="code" href="../../d4/d8/mi_8h.html#a158">UNLOCK_WS</a> (Process);
01775     <a class="code" href="../../d4/d8/mi_8h.html#a163">UNLOCK_ADDRESS_SPACE</a> (Process);
01776 
01777     <span class="keywordflow">if</span> (Attached) {
01778         <a class="code" href="../../d3/d5/procobj_8c.html#a7">KeDetachProcess</a>();
01779     }
01780     <span class="keywordflow">if</span> (ProcessHandle != NtCurrentProcess()) {
01781         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a> (Process);
01782     }
01783 
01784     <span class="comment">//</span>
01785     <span class="comment">// Establish an exception handler and write the size and base</span>
01786     <span class="comment">// address.</span>
01787     <span class="comment">//</span>
01788 
01789     <span class="keywordflow">try</span> {
01790 
01791         *RegionSize = CapturedRegionSize;
01792         *BaseAddress = StartingAddress;
01793 
01794     } except (EXCEPTION_EXECUTE_HANDLER) {
01795         NOTHING;
01796     }
01797 
01798     <span class="keywordflow">return</span> STATUS_SUCCESS;
01799 
01800 ErrorReturn:
01801 
01802     <a class="code" href="../../d4/d8/mi_8h.html#a158">UNLOCK_WS</a> (Process);
01803     <a class="code" href="../../d4/d8/mi_8h.html#a163">UNLOCK_ADDRESS_SPACE</a> (Process);
01804 
01805     <span class="keywordflow">if</span> (Attached) {
01806         <a class="code" href="../../d3/d5/procobj_8c.html#a7">KeDetachProcess</a>();
01807     }
01808 
01809     <span class="keywordflow">if</span> (ProcessHandle != NtCurrentProcess()) {
01810        <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a> (Process);
01811     }
01812 
01813     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01814 }
01815 
01816 
01817 PVOID64
01818 MiFindEmptyAddressRangeInTree64 (
01819     IN ULONGLONG SizeOfRange64,
01820     IN ULONG_PTR Alignment,
01821     IN <a class="code" href="../../d9/d0/struct__MMADDRESS__NODE.html">PMMADDRESS_NODE</a> Root
01822     )
01823 
01824 <span class="comment">/*++</span>
01825 <span class="comment"></span>
01826 <span class="comment">Routine Description:</span>
01827 <span class="comment"></span>
01828 <span class="comment">    The function examines the virtual address descriptors to locate</span>
01829 <span class="comment">    an unused range of the specified size and returns the starting</span>
01830 <span class="comment">    address of the range.</span>
01831 <span class="comment"></span>
01832 <span class="comment">Arguments:</span>
01833 <span class="comment"></span>
01834 <span class="comment">    SizeOfRange - Supplies the size in bytes of the range to locate.</span>
01835 <span class="comment"></span>
01836 <span class="comment">    Alignment - Supplies the alignment for the address.  Must be</span>
01837 <span class="comment">                 a power of 2 and greater than the page_size.</span>
01838 <span class="comment"></span>
01839 <span class="comment">    Root - Supplies the root of the tree to search through.</span>
01840 <span class="comment"></span>
01841 <span class="comment"></span>
01842 <span class="comment">Return Value:</span>
01843 <span class="comment"></span>
01844 <span class="comment">    Returns the starting address of a suitable range.</span>
01845 <span class="comment"></span>
01846 <span class="comment">--*/</span>
01847 
01848 {
01849     <a class="code" href="../../d9/d0/struct__MMADDRESS__NODE.html">PMMADDRESS_NODE</a> Node;
01850     <a class="code" href="../../d9/d0/struct__MMADDRESS__NODE.html">PMMADDRESS_NODE</a> NextNode;
01851     ULONG_PTR AlignmentVpn;
01852     ULONG SizeOfRange;
01853     PVOID64 <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a>;
01854 
01855     AlignmentVpn = Alignment &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
01856 
01857     <span class="comment">//</span>
01858     <span class="comment">// Locate the Node with the lowest starting address.</span>
01859     <span class="comment">//</span>
01860 
01861     SizeOfRange = (ULONG)((SizeOfRange64 + (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
01862     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (SizeOfRange != 0);
01863 
01864     Node = Root;
01865 
01866     <span class="keywordflow">if</span> (Node == (<a class="code" href="../../d9/d0/struct__MMADDRESS__NODE.html">PMMADDRESS_NODE</a>)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01867         <span class="keywordflow">return</span> (PVOID64)MM_LOWEST_USER_ADDRESS64;
01868     }
01869     <span class="keywordflow">while</span> (Node-&gt;<a class="code" href="../../d9/d0/struct__MMADDRESS__NODE.html#o3">LeftChild</a> != (<a class="code" href="../../d9/d0/struct__MMADDRESS__NODE.html">PMMADDRESS_NODE</a>)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01870         Node = Node-&gt;<a class="code" href="../../d9/d0/struct__MMADDRESS__NODE.html#o3">LeftChild</a>;
01871     }
01872 
01873     <span class="comment">//</span>
01874     <span class="comment">// Check to see if a range exists between the lowest address VAD</span>
01875     <span class="comment">// and lowest user address.</span>
01876     <span class="comment">//</span>
01877 
01878     <span class="keywordflow">if</span> (Node-&gt;<a class="code" href="../../d9/d0/struct__MMADDRESS__NODE.html#o0">StartingVpn</a> &gt; MI_VA_TO_VPN64 (MM_LOWEST_USER_ADDRESS64)) {
01879         <span class="keywordflow">if</span> ( SizeOfRange &lt;
01880             (Node-&gt;<a class="code" href="../../d9/d0/struct__MMADDRESS__NODE.html#o0">StartingVpn</a> - MI_VA_TO_VPN64 (MM_LOWEST_USER_ADDRESS64))) {
01881 
01882             <span class="keywordflow">return</span> (PVOID64)MM_LOWEST_USER_ADDRESS64;
01883         }
01884     }
01885 
01886     <span class="keywordflow">for</span> (;;) {
01887 
01888         NextNode = <a class="code" href="../../d4/d8/mi_8h.html#a838">MiGetNextNode</a> (Node);
01889 
01890         <span class="keywordflow">if</span> (NextNode != (<a class="code" href="../../d9/d0/struct__MMADDRESS__NODE.html">PMMADDRESS_NODE</a>)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01891 
01892             <span class="keywordflow">if</span> (SizeOfRange &lt;=
01893                 ((ULONG_PTR)NextNode-&gt;<a class="code" href="../../d9/d0/struct__MMADDRESS__NODE.html#o0">StartingVpn</a> -
01894                                 <a class="code" href="../../d4/d8/mi_8h.html#a90">MI_ROUND_TO_SIZE</a>(1 + Node-&gt;<a class="code" href="../../d9/d0/struct__MMADDRESS__NODE.html#o1">EndingVpn</a>,
01895                                                  AlignmentVpn))) {
01896 
01897                 <span class="comment">//</span>
01898                 <span class="comment">// Check to ensure that the ending address aligned upwards</span>
01899                 <span class="comment">// is not greater than the starting address.</span>
01900                 <span class="comment">//</span>
01901 
01902                 <span class="keywordflow">if</span> ((ULONG_PTR)NextNode-&gt;<a class="code" href="../../d9/d0/struct__MMADDRESS__NODE.html#o0">StartingVpn</a> &gt;
01903                         <a class="code" href="../../d4/d8/mi_8h.html#a90">MI_ROUND_TO_SIZE</a>(1 + Node-&gt;<a class="code" href="../../d9/d0/struct__MMADDRESS__NODE.html#o1">EndingVpn</a>,
01904                                          AlignmentVpn)) {
01905 
01906                     <span class="keywordflow">return</span> (PVOID64)<a class="code" href="../../d4/d8/mi_8h.html#a90">MI_ROUND_TO_SIZE</a>(
01907                             (ULONGLONG)(MI_VPN_TO_VA_ENDING64(Node-&gt;<a class="code" href="../../d9/d0/struct__MMADDRESS__NODE.html#o1">EndingVpn</a>)),
01908                             (ULONGLONG)Alignment);
01909                 }
01910             }
01911 
01912         } <span class="keywordflow">else</span> {
01913 
01914             <span class="comment">//</span>
01915             <span class="comment">// No more descriptors, check to see if this fits into the remainder</span>
01916             <span class="comment">// of the address space.</span>
01917             <span class="comment">//</span>
01918 
01919             <span class="keywordflow">if</span> ((((ULONG_PTR)Node-&gt;<a class="code" href="../../d9/d0/struct__MMADDRESS__NODE.html#o1">EndingVpn</a> + <a class="code" href="../../d4/d8/mi_8h.html#a107">MI_VA_TO_VPN</a>(X64K)) &lt;
01920                     MI_VA_TO_VPN64 (MM_HIGHEST_VAD_ADDRESS64))
01921                         &amp;&amp;
01922                 (SizeOfRange64 &lt;=
01923                     ((ULONGLONG)<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a53">MM_HIGHEST_VAD_ADDRESS64</a> - <a class="code" href="../../d4/d8/mi_8h.html#a18">X64K</a> -
01924                             <a class="code" href="../../d4/d8/mi_8h.html#a90">MI_ROUND_TO_SIZE</a>(
01925                              (ULONGLONG)(MI_VPN_TO_VA64(Node-&gt;<a class="code" href="../../d9/d0/struct__MMADDRESS__NODE.html#o1">EndingVpn</a>)),
01926                              (ULONGLONG)Alignment)))) {
01927 
01928                 <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a> = MI_VPN_TO_VA_ENDING64 (Node-&gt;<a class="code" href="../../d9/d0/struct__MMADDRESS__NODE.html#o1">EndingVpn</a>);
01929                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (MI_VA_TO_VPN64 (Start) == Node-&gt;<a class="code" href="../../d9/d0/struct__MMADDRESS__NODE.html#o1">EndingVpn</a>);
01930 
01931                 <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a> = (PVOID64)<a class="code" href="../../d4/d8/mi_8h.html#a90">MI_ROUND_TO_SIZE</a>((ULONGLONG)Start,
01932                                                   (ULONGLONG)Alignment);
01933                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (MI_VA_TO_VPN64 (Start) &gt; Node-&gt;<a class="code" href="../../d9/d0/struct__MMADDRESS__NODE.html#o1">EndingVpn</a>);
01934                 <span class="keywordflow">return</span> <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a>;
01935             } <span class="keywordflow">else</span> {
01936                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a> (STATUS_NO_MEMORY);
01937             }
01938         }
01939         Node = NextNode;
01940     }
01941 }
01942 
01943 LOGICAL
01944 MiCommitPages64 (
01945     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> StartPte,
01946     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> LastPte,
01947     IN ULONG ProtectionMask,
01948     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process,
01949     OUT PSIZE_T PtesCommitted
01950     )
01951 
01952 <span class="comment">/*++</span>
01953 <span class="comment"></span>
01954 <span class="comment">Routine Description:</span>
01955 <span class="comment"></span>
01956 <span class="comment">    This function commits by making each page valid in the specified range of</span>
01957 <span class="comment">    PTEs.  It also changes the protection of any existing valid PTEs in</span>
01958 <span class="comment">    the specified range.</span>
01959 <span class="comment"></span>
01960 <span class="comment">Arguments:</span>
01961 <span class="comment"></span>
01962 <span class="comment">    StartPte - First PTE in the range.</span>
01963 <span class="comment"></span>
01964 <span class="comment">    LastPte - Last PTE in the range.</span>
01965 <span class="comment"></span>
01966 <span class="comment">    ProtectionMask - Protection mask to set in the valid PTEs.</span>
01967 <span class="comment"></span>
01968 <span class="comment">    Process - Pointer to the process object of the subject process.</span>
01969 <span class="comment"></span>
01970 <span class="comment">    PtesCommitted - Supplies a pointer to receive the number of valid PTEs</span>
01971 <span class="comment">                    encountered in the range.</span>
01972 <span class="comment"></span>
01973 <span class="comment">Return Value:</span>
01974 <span class="comment"></span>
01975 <span class="comment">    TRUE if the pages were committed, FALSE if not.</span>
01976 <span class="comment"></span>
01977 <span class="comment">Environment:</span>
01978 <span class="comment"></span>
01979 <span class="comment">    Process Working Set Lock held.</span>
01980 <span class="comment"></span>
01981 <span class="comment">--*/</span>
01982 
01983 {
01984     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
01985     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPde;
01986     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> TempPte;
01987     PFN_NUMBER PageFrameIndex;
01988     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
01989     ULONG PageColor;
01990     KIRQL OldIrql;
01991     ULONG BarrierStamp;
01992     LOGICAL TopPdeBuilt;
01993     LOGICAL PdeBuilt;
01994     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a> UsedPde64Handle;
01995 
01996     *PtesCommitted = 0;
01997     PointerPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (StartPte);
01998 
01999     <span class="comment">//</span>
02000     <span class="comment">// Fill in all the page table pages with the valid PTEs.</span>
02001     <span class="comment">//</span>
02002 
02003     TopPdeBuilt = MiMakePdeExistAndMakeValid64 (PointerPde, Process, FALSE, TRUE);
02004     <span class="keywordflow">if</span> (TopPdeBuilt == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
02005         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02006     }
02007 
02008     UsedPde64Handle = MI_GET_USED_PDE64_HANDLE (PointerPde);
02009 
02010     PointerPte = StartPte;
02011     <span class="keywordflow">while</span> (PointerPte &lt;= LastPte) {
02012 
02013         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a167">MiIsPteOnPdeBoundary</a>(PointerPte)) {
02014 
02015             <span class="comment">//</span>
02016             <span class="comment">// Pointing to the next page table page, make</span>
02017             <span class="comment">// a page table page exist and make it valid.</span>
02018             <span class="comment">//</span>
02019 
02020             PointerPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (PointerPte);
02021             UsedPde64Handle = MI_GET_USED_PDE64_HANDLE (PointerPde);
02022 
02023             <span class="comment">//</span>
02024             <span class="comment">// This call will always succeed since the top level PDE already</span>
02025             <span class="comment">// exists.</span>
02026             <span class="comment">//</span>
02027 
02028             PdeBuilt = MiMakePdeExistAndMakeValid64 (PointerPde, Process, FALSE, TRUE);
02029             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PdeBuilt == TRUE);
02030         }
02031 
02032         <span class="keywordflow">if</span> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long == 0) {
02033 
02034             PageColor = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a127">MI_PAGE_COLOR_PTE_PROCESS</a> (PointerPte,
02035                                                    &amp;Process-&gt;NextPageColor);
02036             PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Protection = ProtectionMask;
02037             <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
02038 
02039             <span class="comment">//</span>
02040             <span class="comment">// There can be no races on private PTEs (just PDEs) so even</span>
02041             <span class="comment">// if a wait state occurs, nothing needs to be rechecked.</span>
02042             <span class="comment">//</span>
02043 
02044             <a class="code" href="../../d7/d5/pfnlist_8c.html#a13">MiEnsureAvailablePageOrWait</a> (Process, NULL);
02045 
02046             PageFrameIndex = <a class="code" href="../../d7/d5/pfnlist_8c.html#a14">MiRemoveZeroPage</a> (PageColor);
02047 
02048             BarrierStamp = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(PageFrameIndex)-&gt;PteFrame;
02049 
02050             <a class="code" href="../../d8/d2/pagfault_8c.html#a22">MiInitializePfn</a> (PageFrameIndex, PointerPte, 1);
02051             <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
02052 
02053             <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a105">MI_MAKE_VALID_PTE</a> (TempPte,
02054                                PageFrameIndex,
02055                                ProtectionMask,
02056                                NULL);
02057 
02058             <span class="keywordflow">if</span> (TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Write) {
02059                 <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a112">MI_SET_PTE_DIRTY</a> (TempPte);
02060             }
02061 
02062             <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a197">MI_BARRIER_SYNCHRONIZE</a> (BarrierStamp);
02063 
02064             *PointerPte = TempPte;
02065             (*UsedPde64Handle) += 1;
02066 
02067         } <span class="keywordflow">else</span> {
02068             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1);
02069             (*PtesCommitted) += 1;
02070 
02071             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
02072 
02073             <span class="keywordflow">if</span> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Protection != ProtectionMask) {
02074 
02075                 <span class="comment">//</span>
02076                 <span class="comment">// Change protection to match specified protection.</span>
02077                 <span class="comment">//</span>
02078 
02079                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Protection = ProtectionMask;
02080                 <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a105">MI_MAKE_VALID_PTE</a> (TempPte,
02081                                    PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber,
02082                                    ProtectionMask,
02083                                    NULL);
02084                 <span class="keywordflow">if</span> (TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Write) {
02085                     <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a112">MI_SET_PTE_DIRTY</a> (TempPte);
02086                 }
02087 
02088                 <span class="comment">//</span>
02089                 <span class="comment">// Flush the TB as we have changed the protection</span>
02090                 <span class="comment">// of a valid PTE.</span>
02091                 <span class="comment">//</span>
02092 
02093                 <a class="code" href="../../d0/d9/protect_8c.html#a1">MiFlushTbAndCapture</a> (PointerPte,
02094                                      TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Flush,
02095                                      Pfn1);
02096             }
02097         }
02098         PointerPte += 1;
02099     }
02100     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02101 }
02102 
02103 LOGICAL
02104 MiMakePdeExistAndMakeValid64 (
02105     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPde,
02106     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> TargetProcess,
02107     IN LOGICAL PfnLockHeld,
02108     IN LOGICAL MakePageTablePage
02109     )
02110 
02111 <span class="comment">/*++</span>
02112 <span class="comment"></span>
02113 <span class="comment">Routine Description:</span>
02114 <span class="comment"></span>
02115 <span class="comment">    This routine examines the specified Page Directory Entry to determine</span>
02116 <span class="comment">    if the page table page mapped by the PDE exists.</span>
02117 <span class="comment"></span>
02118 <span class="comment">    If the page table page exists and is not currently in memory, the</span>
02119 <span class="comment">    working set mutex and, if held, the PFN mutex are released and the</span>
02120 <span class="comment">    page table page is faulted into the working set.  The mutexes are</span>
02121 <span class="comment">    required.</span>
02122 <span class="comment"></span>
02123 <span class="comment">    If the PDE exists, the function returns TRUE.</span>
02124 <span class="comment"></span>
02125 <span class="comment">    If the PDE does not exist, a zero filled PTE is created and it</span>
02126 <span class="comment">    too is brought into the working set.  In this case the return</span>
02127 <span class="comment">    value is FALSE.</span>
02128 <span class="comment"></span>
02129 <span class="comment">Arguments:</span>
02130 <span class="comment"></span>
02131 <span class="comment">    PointerPde - Supplies a pointer to the PDE to examine and bring</span>
02132 <span class="comment">                 into the working set.</span>
02133 <span class="comment"></span>
02134 <span class="comment">    TargetProcess - Supplies a pointer to the current process.</span>
02135 <span class="comment"></span>
02136 <span class="comment">    PfnLockHeld - Supplies the value TRUE if the PFN mutex is held, FALSE</span>
02137 <span class="comment">                  otherwise.</span>
02138 <span class="comment"></span>
02139 <span class="comment">    MakePageTablePage - Supplies the value TRUE if the PDE is to be created.</span>
02140 <span class="comment">                        FALSE if not - meaning just the top level Base is</span>
02141 <span class="comment">                        to be created.</span>
02142 <span class="comment"></span>
02143 <span class="comment">Return Value:</span>
02144 <span class="comment"></span>
02145 <span class="comment">    TRUE if the PDE exists, FALSE if the PDE was created.</span>
02146 <span class="comment"></span>
02147 <span class="comment">Environment:</span>
02148 <span class="comment"></span>
02149 <span class="comment">    Kernel mode, APCs disabled, WorkingSetLock and AddressSpace locks held.</span>
02150 <span class="comment"></span>
02151 <span class="comment">--*/</span>
02152 
02153 {
02154     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
02155     KIRQL OldIrql;
02156     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> TempPte;
02157     ULONG PageColor;
02158     PFN_NUMBER PageFrameIndex;
02159     ULONG BarrierStamp;
02160     PMI_PROCESS_VLM_INFO VlmInfo;
02161     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PdeBase;
02162 
02163     VlmInfo = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02164 
02165     <span class="comment">//</span>
02166     <span class="comment">// Make sure the Page Directory Page for this 32GB region exists.</span>
02167     <span class="comment">//</span>
02168 
02169     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (PointerPde);
02170 
02171 redo:
02172 
02173     <span class="keywordflow">if</span> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long == 0) {
02174 
02175         <span class="comment">//</span>
02176         <span class="comment">// Make a page directory page.</span>
02177         <span class="comment">//</span>
02178 
02179         <span class="keywordflow">if</span> (VlmInfo == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02180 
02181             <span class="keywordflow">if</span> (PfnLockHeld) {
02182                 <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
02183             }
02184 
02185             <a class="code" href="../../d4/d8/mi_8h.html#a158">UNLOCK_WS</a> (TargetProcess);
02186 
02187             VlmInfo = (PMI_PROCESS_VLM_INFO) <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a> (
02188                                                 NonPagedPool,
02189                                                 <span class="keyword">sizeof</span> (MI_PROCESS_VLM_INFO),
02190                                                 'lVmM');
02191 
02192             <span class="keywordflow">if</span> (VlmInfo) {
02193                 RtlZeroMemory (VlmInfo,
02194                                <span class="keyword">sizeof</span> (MI_PROCESS_VLM_INFO));
02195             }
02196 
02197             <a class="code" href="../../d4/d8/mi_8h.html#a154">LOCK_WS</a> (TargetProcess);
02198 
02199             <span class="keywordflow">if</span> (PfnLockHeld) {
02200                 <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
02201             }
02202 
02203             <span class="keywordflow">if</span> (VlmInfo == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02204                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02205             }
02206 
02207             <span class="comment">//</span>
02208             <span class="comment">// Since locks were released, everything must be rechecked.</span>
02209             <span class="comment">// Note the VAD cannot disappear as the address space lock was</span>
02210             <span class="comment">// held all the way through.</span>
02211             <span class="comment">//</span>
02212 
02213             <span class="keywordflow">goto</span> redo;
02214         }
02215 
02216         PageColor = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a127">MI_PAGE_COLOR_PTE_PROCESS</a> (PointerPte,
02217                                                &amp;TargetProcess-&gt;NextPageColor);
02218         <span class="keywordflow">if</span> (!PfnLockHeld) {
02219             <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
02220         }
02221 
02222         <span class="keywordflow">if</span> (<a class="code" href="../../d7/d5/pfnlist_8c.html#a13">MiEnsureAvailablePageOrWait</a> (TargetProcess, NULL) == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
02223 
02224             <span class="comment">//</span>
02225             <span class="comment">// A wait state occurred, everything must be rechecked.</span>
02226             <span class="comment">//</span>
02227 
02228             <span class="keywordflow">goto</span> redo;
02229         }
02230 
02231         PageFrameIndex = <a class="code" href="../../d7/d5/pfnlist_8c.html#a14">MiRemoveZeroPage</a> (PageColor);
02232         BarrierStamp = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(PageFrameIndex)-&gt;PteFrame;
02233         <a class="code" href="../../d8/d2/pagfault_8c.html#a22">MiInitializePfn</a> (PageFrameIndex, PointerPte, 1);
02234 
02235         <span class="keywordflow">if</span> (!PfnLockHeld) {
02236             <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
02237         }
02238 
02239         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a105">MI_MAKE_VALID_PTE</a> (TempPte,
02240                            PageFrameIndex,
02241                            MM_READWRITE,
02242                            NULL);
02243 
02244         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a112">MI_SET_PTE_DIRTY</a> (TempPte);
02245 
02246         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a197">MI_BARRIER_SYNCHRONIZE</a> (BarrierStamp);
02247 
02248         *PointerPte = TempPte;
02249 
02250         <span class="comment">//</span>
02251         <span class="comment">// Stash the used page table page counts pointer in the PDE_BASE64.</span>
02252         <span class="comment">//</span>
02253 
02254         PdeBase = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPte);
02255 
02256         <span class="comment">//</span>
02257         <span class="comment">// This will always be true unless VLM is expanded past 32GB.</span>
02258         <span class="comment">//</span>
02259 
02260         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PdeBase == (<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)PDE_BASE64);
02261 
02262         PdeBase-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long = (ULONG)VlmInfo;
02263     }
02264     <span class="keywordflow">else</span> {
02265         <span class="keywordflow">if</span> (VlmInfo) {
02266             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (VlmInfo);
02267         }
02268     }
02269 
02270     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1);
02271 
02272     <span class="keywordflow">if</span> (MakePageTablePage == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
02273         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02274     }
02275 
02276 redo2:
02277 
02278     <span class="keywordflow">if</span> (PointerPde-&gt;u.Hard.Valid == 1) {
02279 
02280         <span class="comment">//</span>
02281         <span class="comment">// Already valid.</span>
02282         <span class="comment">//</span>
02283 
02284         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02285     }
02286 
02287     <span class="comment">//</span>
02288     <span class="comment">// Page directory entry not valid, make it valid.</span>
02289     <span class="comment">//</span>
02290 
02291     PageColor = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a127">MI_PAGE_COLOR_PTE_PROCESS</a> (PointerPde,
02292                                            &amp;TargetProcess-&gt;NextPageColor);
02293     <span class="keywordflow">if</span> (!PfnLockHeld) {
02294         <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
02295     }
02296 
02297     <span class="keywordflow">if</span> (<a class="code" href="../../d7/d5/pfnlist_8c.html#a13">MiEnsureAvailablePageOrWait</a> (TargetProcess, NULL) == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
02298 
02299         <span class="comment">//</span>
02300         <span class="comment">// A wait state occurred, everything from the PDE down must</span>
02301         <span class="comment">// be rechecked.</span>
02302         <span class="comment">//</span>
02303 
02304         <span class="keywordflow">if</span> (!PfnLockHeld) {
02305             <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
02306         }
02307         <span class="keywordflow">goto</span> redo2;
02308     }
02309 
02310     PageFrameIndex = <a class="code" href="../../d7/d5/pfnlist_8c.html#a14">MiRemoveZeroPage</a> (PageColor);
02311     BarrierStamp = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(PageFrameIndex)-&gt;PteFrame;
02312     <a class="code" href="../../d8/d2/pagfault_8c.html#a22">MiInitializePfn</a> (PageFrameIndex, PointerPde, 1);
02313 
02314     <span class="keywordflow">if</span> (!PfnLockHeld) {
02315         <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
02316     }
02317 
02318     <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a105">MI_MAKE_VALID_PTE</a> (TempPte,
02319                        PageFrameIndex,
02320                        MM_READWRITE,
02321                        NULL);
02322 
02323     <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a112">MI_SET_PTE_DIRTY</a> (TempPte);
02324 
02325     <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a197">MI_BARRIER_SYNCHRONIZE</a> (BarrierStamp);
02326 
02327     *PointerPde = TempPte;
02328 
02329     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02330 }
02331 
02332 ULONG
02333 MiDoesPdeExist64 (
02334     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPde
02335     )
02336 
02337 <span class="comment">/*++</span>
02338 <span class="comment"></span>
02339 <span class="comment">Routine Description:</span>
02340 <span class="comment"></span>
02341 <span class="comment">    This routine examines the specified Page Directory Entry to determine</span>
02342 <span class="comment">    if the page table page mapped by the PDE exists.</span>
02343 <span class="comment"></span>
02344 <span class="comment">    If the page table page exists and is not currently in memory, the</span>
02345 <span class="comment">    working set mutex and, if held, the PFN mutex are released and the</span>
02346 <span class="comment">    page table page is faulted into the working set.  The mutexes are</span>
02347 <span class="comment">    required.</span>
02348 <span class="comment"></span>
02349 <span class="comment">    If the PDE exists, the function returns true.</span>
02350 <span class="comment"></span>
02351 <span class="comment">Arguments:</span>
02352 <span class="comment"></span>
02353 <span class="comment">    PointerPde - Supplies a pointer to the PDE to examine and potentially</span>
02354 <span class="comment">                 bring into the working set.</span>
02355 <span class="comment"></span>
02356 <span class="comment">    TargetProcess - Supplies a pointer to the current process.</span>
02357 <span class="comment"></span>
02358 <span class="comment">    PfnMutexHeld - Supplies the value TRUE if the PFN mutex is held, FALSE</span>
02359 <span class="comment">                   otherwise.</span>
02360 <span class="comment"></span>
02361 <span class="comment">Return Value:</span>
02362 <span class="comment"></span>
02363 <span class="comment">    TRUE if the PDE exists, FALSE if the PDE is zero.</span>
02364 <span class="comment"></span>
02365 <span class="comment">Environment:</span>
02366 <span class="comment"></span>
02367 <span class="comment">    Kernel mode, APCs disabled, WorkingSetLock held.</span>
02368 <span class="comment"></span>
02369 <span class="comment">--*/</span>
02370 
02371 {
02372     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
02373     PMI_PROCESS_VLM_INFO VlmInfo;
02374 
02375     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(PointerPde);
02376     <span class="keywordflow">if</span> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long == 0) {
02377 
02378         <span class="comment">//</span>
02379         <span class="comment">// This page directory entry doesn't exist, return FALSE.</span>
02380         <span class="comment">//</span>
02381 
02382         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02383     }
02384 
02385     <span class="keywordflow">if</span> (PointerPde-&gt;u.Long == 0) {
02386 
02387         <span class="comment">//</span>
02388         <span class="comment">// This page directory entry doesn't exist, return FALSE.</span>
02389         <span class="comment">//</span>
02390 
02391         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02392     }
02393 
02394     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPde-&gt;u.Hard.Valid == 1);
02395 
02396     VlmInfo = (PMI_PROCESS_VLM_INFO) (((<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a6">PDE_BASE64</a>)-&gt;u.Long);
02397     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (VlmInfo != NULL);
02398 
02399     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02400 }
02401 
02402 ULONG
02403 MiDecommitOrDeletePages64 (
02404     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> StartingPte,
02405     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> EndingPte,
02406     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process,
02407     IN ULONG Type,
02408     IN LOGICAL FlushTb
02409     )
02410 
02411 <span class="comment">/*++</span>
02412 <span class="comment"></span>
02413 <span class="comment">Routine Description:</span>
02414 <span class="comment"></span>
02415 <span class="comment">    This routine decommits the specified range of pages.</span>
02416 <span class="comment"></span>
02417 <span class="comment">Arguments:</span>
02418 <span class="comment"></span>
02419 <span class="comment">    StartingAddress - Supplies the starting address of the range.</span>
02420 <span class="comment"></span>
02421 <span class="comment">    EndingPte - Supplies the ending PTE of the range.</span>
02422 <span class="comment"></span>
02423 <span class="comment">    Process - Supplies the current process.</span>
02424 <span class="comment"></span>
02425 <span class="comment">    Type - One of: DELETE_TYPE_PRIVATE for private memory or DELETE_TYPE_SHARED</span>
02426 <span class="comment">           for shared memory.</span>
02427 <span class="comment"></span>
02428 <span class="comment">    FlushTb - Supplies TRUE if the TB needs to be flushed, FALSE if not.</span>
02429 <span class="comment"></span>
02430 <span class="comment">Return Value:</span>
02431 <span class="comment"></span>
02432 <span class="comment">    Value to reduce commitment by for the VAD.</span>
02433 <span class="comment"></span>
02434 <span class="comment">Environment:</span>
02435 <span class="comment"></span>
02436 <span class="comment">    Kernel mode, APCs disabled, WorkingSetMutex and AddressCreation mutexes</span>
02437 <span class="comment">    held.</span>
02438 <span class="comment"></span>
02439 <span class="comment">--*/</span>
02440 
02441 {
02442     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPde;
02443     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
02444     ULONG PdeOffset;
02445     PFN_NUMBER CommitReduction;
02446     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> CommitLimitPte;
02447     KIRQL OldIrql;
02448     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> ValidPteList[<a class="code" href="../../d3/d7/freevm_8c.html#a1">MM_VALID_PTE_SIZE</a>];
02449     ULONG count;
02450     ULONG WorkingSetIndex;
02451     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
02452     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn2;
02453     PVOID SwapVa;
02454     ULONG Entry;
02455     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> PteContents;
02456     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> NewPte;
02457     ULONG PfnLockHeld;
02458     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> LowestPde;
02459     PMI_PROCESS_VLM_INFO VlmInfo;
02460 
02461     count = 0;
02462     PfnLockHeld = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02463     CommitReduction = 0;
02464 
02465     <span class="comment">//</span>
02466     <span class="comment">// Decommit each page by setting the PTE to be explicitly</span>
02467     <span class="comment">// decommitted.  The PTEs cannot be deleted all at once as</span>
02468     <span class="comment">// this would set the PTEs to zero which would auto-evaluate</span>
02469     <span class="comment">// as committed if referenced by another thread when a page</span>
02470     <span class="comment">// table page is being in-paged.</span>
02471     <span class="comment">//</span>
02472 
02473     PointerPte = StartingPte;
02474     PointerPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (StartingPte);
02475 
02476     VlmInfo = (PMI_PROCESS_VLM_INFO) (((<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a6">PDE_BASE64</a>)-&gt;u.Long);
02477     LowestPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a152">MiGetPdeAddress64</a> (MM_LOWEST_USER_ADDRESS64);
02478 
02479     <span class="comment">//</span>
02480     <span class="comment">// Loop through all the PDEs which map this region and ensure that</span>
02481     <span class="comment">// they exist.  If they don't exist create them by touching a</span>
02482     <span class="comment">// PTE mapped by the PDE.</span>
02483     <span class="comment">//</span>
02484 
02485     <span class="keywordflow">if</span> (!MiDoesPdeExist64 (PointerPde)) {
02486         PointerPte = (<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)<a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a> (PointerPte);
02487         PointerPte += <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a103">PTE_PER_PAGE</a>;
02488     }
02489 
02490     <span class="keywordflow">while</span> (PointerPte &lt;= EndingPte) {
02491 
02492         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a167">MiIsPteOnPdeBoundary</a>(PointerPte)) {
02493 
02494             <span class="keywordflow">if</span> (count != 0) {
02495                 MiProcessValidPteList64 (&amp;ValidPteList[0], count, FlushTb);
02496                 count = 0;
02497             }
02498 
02499             <span class="keywordflow">if</span> (PfnLockHeld) {
02500                 <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
02501             }
02502 
02503             MiCheckPdeForDeletion (PointerPde, FlushTb);
02504             PointerPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (PointerPte);
02505 
02506             <span class="keywordflow">if</span> (!MiDoesPdeExist64 (PointerPde)) {
02507                 PointerPte += <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a103">PTE_PER_PAGE</a>;
02508                 <span class="keywordflow">continue</span>;
02509             }
02510             <span class="keywordflow">if</span> (PfnLockHeld) {
02511                 <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
02512             }
02513         }
02514 
02515         <span class="comment">//</span>
02516         <span class="comment">// The working set lock is held.  No PTEs can go from</span>
02517         <span class="comment">// invalid to valid or valid to invalid.  Transition</span>
02518         <span class="comment">// PTEs can go from transition to pagefile.</span>
02519         <span class="comment">//</span>
02520 
02521         PteContents = *PointerPte;
02522 
02523         <span class="keywordflow">if</span> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long != 0) {
02524 
02525             VlmInfo-&gt;UsedPageTableEntries[PointerPde - LowestPde] -= 1;
02526 
02527             <span class="keywordflow">if</span> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1) {
02528                 <span class="keywordflow">if</span> (Type == DELETE_TYPE_PRIVATE) {
02529                     CommitReduction += 1;
02530                 }
02531 
02532                 <span class="comment">//</span>
02533                 <span class="comment">// Pte is valid, process later when PFN lock is held.</span>
02534                 <span class="comment">//</span>
02535 
02536                 <span class="keywordflow">if</span> (count == <a class="code" href="../../d3/d7/freevm_8c.html#a1">MM_VALID_PTE_SIZE</a>) {
02537                     MiProcessValidPteList64 (&amp;ValidPteList[0], count, FlushTb);
02538                     count = 0;
02539                 }
02540                 ValidPteList[count] = PointerPte;
02541                 count += 1;
02542             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Prototype == 1) {
02543                 NOTHING;
02544 
02545             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Transition == 1) {
02546 
02547                 <span class="comment">//</span>
02548                 <span class="comment">// This is a transition PTE. (Page is private)</span>
02549                 <span class="comment">//</span>
02550                 <span class="comment">// Get the PFN mutex so that MiDeletePte can be called.</span>
02551                 <span class="comment">//</span>
02552 
02553                 <span class="keywordflow">if</span> (!PfnLockHeld) {
02554                     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
02555                     PfnLockHeld = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02556                     <span class="keywordflow">continue</span>;
02557                 }
02558                 Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Trans.PageFrameNumber);
02559 
02560                 <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a120">MI_SET_PFN_DELETED</a> (Pfn1);
02561 
02562                 <a class="code" href="../../d6/d5/pfndec_8c.html#a1">MiDecrementShareCount</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o17">PteFrame</a>);
02563 
02564                 <span class="comment">//</span>
02565                 <span class="comment">// Check the reference count for the page, if the reference</span>
02566                 <span class="comment">// count is zero, move the page to the free list, if the</span>
02567                 <span class="comment">// reference count is not zero, ignore this page.  When the</span>
02568                 <span class="comment">// reference count goes to zero, it will be placed on the</span>
02569                 <span class="comment">// free list.</span>
02570                 <span class="comment">//</span>
02571 
02572                 <span class="keywordflow">if</span> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount == 0) {
02573                     <a class="code" href="../../d7/d5/pfnlist_8c.html#a11">MiUnlinkPageFromList</a> (Pfn1);
02574                     <a class="code" href="../../d4/d8/mi_8h.html#a889">MiReleasePageFileSpace</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>);
02575                     <a class="code" href="../../d7/d5/pfnlist_8c.html#a8">MiInsertPageInList</a> (MmPageLocationList[FreePageList],
02576                                         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a183">MI_GET_PAGE_FRAME_FROM_TRANSITION_PTE</a>(&amp;PteContents));
02577                 }
02578             } <span class="keywordflow">else</span> {
02579                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.PageFileHigh == 0);
02580             }
02581         }
02582 
02583         <span class="keywordflow">if</span> (PfnLockHeld) {
02584             <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
02585             PfnLockHeld = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02586         }
02587         PointerPte += 1;
02588     }
02589     <span class="keywordflow">if</span> (count != 0) {
02590         MiProcessValidPteList64 (&amp;ValidPteList[0], count, FlushTb);
02591     }
02592 
02593     MiCheckPdeForDeletion (PointerPde, FlushTb);
02594 
02595     MiReturnAvailablePages (CommitReduction);
02596 
02597     <span class="keywordflow">return</span> CommitReduction;
02598 }
02599 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
02600 MiProcessValidPteList64 (
02601     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> *ValidPteList,
02602     IN ULONG Count,
02603     IN LOGICAL FlushTb
02604     )
02605 
02606 <span class="comment">/*++</span>
02607 <span class="comment"></span>
02608 <span class="comment">Routine Description:</span>
02609 <span class="comment"></span>
02610 <span class="comment">    This routine flushes the specified range of valid PTEs.</span>
02611 <span class="comment"></span>
02612 <span class="comment">Arguments:</span>
02613 <span class="comment"></span>
02614 <span class="comment">    ValidPteList - Supplies a pointer to an array of PTEs to flush.</span>
02615 <span class="comment"></span>
02616 <span class="comment">    Count - Supplies the count of the number of elements in the array.</span>
02617 <span class="comment"></span>
02618 <span class="comment">    FlushTb - Supplies TRUE if the TB needs to be flushed, FALSE if not.</span>
02619 <span class="comment"></span>
02620 <span class="comment">Return Value:</span>
02621 <span class="comment"></span>
02622 <span class="comment">    none.</span>
02623 <span class="comment"></span>
02624 <span class="comment">Environment:</span>
02625 <span class="comment"></span>
02626 <span class="comment">    Kernel mode, APCs disabled, WorkingSetMutex and AddressCreation mutexes</span>
02627 <span class="comment">    held.</span>
02628 <span class="comment"></span>
02629 <span class="comment">--*/</span>
02630 
02631 {
02632     ULONG i = 0;
02633     MMPTE_FLUSH_LIST64 PteFlushList;
02634     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> PteContents;
02635     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
02636     KIRQL OldIrql;
02637     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPde;
02638 
02639     PteFlushList.Count = <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>;
02640 
02641     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
02642 
02643     <span class="keywordflow">do</span> {
02644         PteContents = *ValidPteList[i];
02645         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1);
02646         Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
02647 
02648         <span class="keywordflow">if</span> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PrototypePte == 1) {
02649 
02650             <span class="comment">//</span>
02651             <span class="comment">// Capture the state of the modified bit for this</span>
02652             <span class="comment">// pte.</span>
02653             <span class="comment">//</span>
02654 
02655             <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a177">MI_CAPTURE_DIRTY_BIT_TO_PFN</a> (&amp;PteContents, Pfn1);
02656 
02657             <span class="comment">//</span>
02658             <span class="comment">// Decrement the share and valid counts of the page table</span>
02659             <span class="comment">// page which maps this PTE.</span>
02660             <span class="comment">//</span>
02661 
02662             PointerPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (ValidPteList[i]);
02663             <a class="code" href="../../d4/d8/mi_8h.html#a242">MiDecrementShareAndValidCount</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a>(PointerPde));
02664 
02665             <span class="comment">//</span>
02666             <span class="comment">// Decrement the share count for the physical page.</span>
02667             <span class="comment">//</span>
02668 
02669             <a class="code" href="../../d6/d5/pfndec_8c.html#a1">MiDecrementShareCount</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a>(&amp;PteContents));
02670 
02671         } <span class="keywordflow">else</span> {
02672 
02673             <span class="comment">//</span>
02674             <span class="comment">// Decrement the share and valid counts of the page table</span>
02675             <span class="comment">// page which maps this PTE.</span>
02676             <span class="comment">//</span>
02677 
02678             <a class="code" href="../../d4/d8/mi_8h.html#a242">MiDecrementShareAndValidCount</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o17">PteFrame</a>);
02679 
02680             <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a120">MI_SET_PFN_DELETED</a> (Pfn1);
02681 
02682             <span class="comment">//</span>
02683             <span class="comment">// Decrement the share count for the physical page.  As the page</span>
02684             <span class="comment">// is private it will be put on the free list.</span>
02685             <span class="comment">//</span>
02686 
02687             <a class="code" href="../../d4/d8/mi_8h.html#a241">MiDecrementShareCountOnly</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a>(&amp;PteContents));
02688         }
02689 
02690         <span class="keywordflow">if</span> (<a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> &lt; <a class="code" href="../../d4/d8/mi_8h.html#a34">MM_MAXIMUM_FLUSH_COUNT</a>) {
02691             PteFlushList.FlushPte[i] = ValidPteList[i];
02692             PteFlushList.FlushVpn[i] =
02693                  <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a163">MiGetVirtualPageNumberMappedByPte64</a> (ValidPteList[i]) &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
02694         }
02695         *ValidPteList[i] = <a class="code" href="../../d4/d2/datalpha_8c.html#a0">ZeroPte</a>;
02696         i += 1;
02697     } <span class="keywordflow">while</span> (i != <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>);
02698 
02699     <span class="keywordflow">if</span> (FlushTb) {
02700         MiFlushPteList64 (&amp;PteFlushList, FALSE, ZeroPte);
02701     }
02702 
02703     <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
02704     <span class="keywordflow">return</span>;
02705 }
02706 
02707 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
02708 MiReturnAvailablePages (
02709     IN PFN_NUMBER Amount
02710     )
02711 
02712 <span class="comment">/*++</span>
02713 <span class="comment"></span>
02714 <span class="comment">Routine Description:</span>
02715 <span class="comment"></span>
02716 <span class="comment">    This routine returns the specified amount to the system resident pages list.</span>
02717 <span class="comment"></span>
02718 <span class="comment">Arguments:</span>
02719 <span class="comment"></span>
02720 <span class="comment">    Amount - Supplies the amount to return.</span>
02721 <span class="comment"></span>
02722 <span class="comment">Return Value:</span>
02723 <span class="comment"></span>
02724 <span class="comment">    none.</span>
02725 <span class="comment"></span>
02726 <span class="comment">Environment:</span>
02727 <span class="comment"></span>
02728 <span class="comment">    Kernel mode, APCs disabled, WorkingSetMutex and AddressCreation mutexes</span>
02729 <span class="comment">    held.</span>
02730 <span class="comment"></span>
02731 <span class="comment">--*/</span>
02732 
02733 {
02734     KIRQL OldIrql;
02735 
02736     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
02737     <a class="code" href="../../d8/d5/kddata_8c.html#a42">MmResidentAvailablePages</a> += Amount;
02738     <a class="code" href="../../d4/d8/mi_8h.html#a322">MM_BUMP_COUNTER</a>(26, Amount);
02739     <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
02740     <span class="keywordflow">return</span>;
02741 }
02742 
02743 
02744 LOGICAL
02745 MiCheckPdeForDeletion (
02746     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPde,
02747     IN LOGICAL FlushTb
02748     )
02749 
02750 <span class="comment">/*++</span>
02751 <span class="comment"></span>
02752 <span class="comment">Routine Description:</span>
02753 <span class="comment"></span>
02754 <span class="comment">    This routine checks to see if the share count of the specified PDE is 1,</span>
02755 <span class="comment">    and if it is, the PDE is deleted.</span>
02756 <span class="comment"></span>
02757 <span class="comment">Arguments:</span>
02758 <span class="comment"></span>
02759 <span class="comment">    PointerPde - Supplies the PDE to check.</span>
02760 <span class="comment"></span>
02761 <span class="comment">    FlushTb - Supplies TRUE if the TB needs to be flushed, FALSE if not.</span>
02762 <span class="comment"></span>
02763 <span class="comment">Return Value:</span>
02764 <span class="comment"></span>
02765 <span class="comment">    TRUE if the PDE no longer exists upon return.</span>
02766 <span class="comment">    FALSE if the PDE still exists on return.</span>
02767 <span class="comment"></span>
02768 <span class="comment">Environment:</span>
02769 <span class="comment"></span>
02770 <span class="comment">    Kernel mode, APCs disabled, WorkingSetMutex and AddressCreation mutexes</span>
02771 <span class="comment">    held.</span>
02772 <span class="comment"></span>
02773 <span class="comment">--*/</span>
02774 
02775 {
02776     LOGICAL <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02777     KIRQL OldIrql;
02778     PFN_NUMBER PageFrameIndex;
02779     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
02780     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
02781     PMI_PROCESS_VLM_INFO VlmInfo;
02782     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> LowestPde;
02783 
02784     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (PointerPde);
02785     <span class="keywordflow">if</span> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 0) {
02786 
02787         <span class="comment">//</span>
02788         <span class="comment">// Page Directory does not exist.</span>
02789         <span class="comment">//</span>
02790 
02791         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02792     }
02793 
02794     <span class="keywordflow">if</span> (PointerPde-&gt;u.Hard.Valid == 0) {
02795 
02796         <span class="comment">//</span>
02797         <span class="comment">// Page directory entry does not exist.</span>
02798         <span class="comment">//</span>
02799 
02800         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02801     }
02802     PageFrameIndex = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a>(PointerPde);
02803     Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PageFrameIndex);
02804     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02805     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
02806 
02807     VlmInfo = (PMI_PROCESS_VLM_INFO) (((<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a6">PDE_BASE64</a>)-&gt;u.Long);
02808     LowestPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a152">MiGetPdeAddress64</a> (MM_LOWEST_USER_ADDRESS64);
02809 
02810     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPde);
02811 
02812     <span class="keywordflow">if</span> (VlmInfo-&gt;UsedPageTableEntries[PointerPde - LowestPde] == 0) {
02813         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount == 1);
02814         <a class="code" href="../../d4/d8/mi_8h.html#a242">MiDecrementShareAndValidCount</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o17">PteFrame</a>);
02815         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a120">MI_SET_PFN_DELETED</a> (Pfn1);
02816         <a class="code" href="../../d4/d8/mi_8h.html#a241">MiDecrementShareCountOnly</a> (PageFrameIndex);
02817         <span class="keywordflow">if</span> (FlushTb == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
02818             <a class="code" href="../../d0/d6/ppc_2flushtb_8c.html#a2">KeFlushSingleTb</a> (PointerPte,
02819                              TRUE,
02820                              FALSE,
02821                              (PHARDWARE_PTE)PointerPde,
02822                              <a class="code" href="../../d4/d2/datalpha_8c.html#a0">ZeroPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Flush);
02823         }
02824         <span class="keywordflow">else</span> {
02825              *PointerPde = <a class="code" href="../../d4/d2/datalpha_8c.html#a0">ZeroPte</a>;
02826         }
02827         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02828     }
02829 <span class="preprocessor">#if DBG</span>
02830 <span class="preprocessor"></span>    <span class="keywordflow">else</span> {
02831         ULONG i;
02832         ULONG count;
02833         PULONG p;
02834 
02835         count = 0;
02836         p = (PULONG)PointerPte;
02837 
02838         <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>; i += <span class="keyword">sizeof</span>(p)) {
02839             p += 1;
02840             count += 1;
02841         }
02842         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (count != 0);
02843     }
02844 <span class="preprocessor">#endif</span>
02845 <span class="preprocessor"></span>
02846     <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
02847     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02848 }
02849 
02850 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
02851 MiDeleteVlmAddressSpace (
02852     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process
02853     )
02854 
02855 <span class="comment">/*++</span>
02856 <span class="comment"></span>
02857 <span class="comment">Routine Description:</span>
02858 <span class="comment"></span>
02859 <span class="comment">    This routine flushes the specified range of valid PTEs.</span>
02860 <span class="comment"></span>
02861 <span class="comment">Arguments:</span>
02862 <span class="comment"></span>
02863 <span class="comment">    ValidPteList - Supplies a pointer to an array of PTEs to flush.</span>
02864 <span class="comment"></span>
02865 <span class="comment">    Count - Supplies the count of the number of elements in the array.</span>
02866 <span class="comment"></span>
02867 <span class="comment">Return Value:</span>
02868 <span class="comment"></span>
02869 <span class="comment">    none.</span>
02870 <span class="comment"></span>
02871 <span class="comment">Environment:</span>
02872 <span class="comment"></span>
02873 <span class="comment">    Kernel mode, APCs disabled, WorkingSetMutex and AddressCreation mutexes</span>
02874 <span class="comment">    held.</span>
02875 <span class="comment"></span>
02876 <span class="comment">--*/</span>
02877 
02878 {
02879     <a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a> Vad;
02880     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPde;
02881     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte1;
02882     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte2;
02883     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
02884     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> PteContents;
02885     KIRQL OldIrql;
02886     <a class="code" href="../../d8/d7/struct__CONTROL__AREA.html">PCONTROL_AREA</a> ControlArea;
02887     ULONG Type;
02888     PMI_PROCESS_VLM_INFO VlmInfo;
02889     SIZE_T CommitReduction;
02890     ULONGLONG RegionSize;
02891 
02892     Vad = (<a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a>)Process-&gt;CloneRoot;
02893 
02894     <span class="keywordflow">if</span> (Vad != (<a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a>)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02895         VlmInfo = (PMI_PROCESS_VLM_INFO) (((<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a6">PDE_BASE64</a>)-&gt;u.Long);
02896 
02897         <span class="keywordflow">do</span> {
02898 
02899             MiRemoveVad64 (Vad);
02900 
02901             Type = DELETE_TYPE_PRIVATE;
02902             <span class="keywordflow">if</span> (Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.VadFlags.PrivateMemory == 0) {
02903                 Type = DELETE_TYPE_SHARED;
02904             }
02905             CommitReduction = MiDecommitOrDeletePages64 (
02906                            MiGetPteAddress64 (MI_VPN_TO_VA64 (Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o0">StartingVpn</a>)),
02907                            <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a154">MiGetPteAddress64</a> (MI_VPN_TO_VA_ENDING64 (Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o1">EndingVpn</a>)),
02908                            Process,
02909                            Type,
02910                            FALSE);
02911 
02912 
02913             RegionSize = (((ULONGLONG)(Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o1">EndingVpn</a> - Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o0">StartingVpn</a> + 1)) &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
02914             VlmInfo-&gt;VirtualSize -= RegionSize;
02915 
02916             ExAcquireFastLock (&amp;MiVlmStatisticsLock, &amp;OldIrql);
02917             <span class="keywordflow">if</span> (Type != DELETE_TYPE_SHARED) {
02918                 MiVlmCommitChargeInPages -= CommitReduction;
02919             }
02920             ExReleaseFastLock (&amp;MiVlmStatisticsLock, OldIrql);
02921 
02922             <span class="keywordflow">if</span> (Type == DELETE_TYPE_SHARED) {
02923 
02924                 <span class="comment">//</span>
02925                 <span class="comment">// Decrement the count of the number of views for the</span>
02926                 <span class="comment">// Segment object.  This requires the PFN mutex to be held (it is already).</span>
02927                 <span class="comment">//</span>
02928 
02929                 ControlArea = Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o8">ControlArea</a>;
02930 
02931                 <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
02932                 ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o4">NumberOfMappedViews</a> -= 1;
02933                 ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o7">NumberOfUserReferences</a> -= 1;
02934 
02935                 <span class="comment">//</span>
02936                 <span class="comment">// Check to see if the control area (segment) should be deleted.</span>
02937                 <span class="comment">// This routine releases the PFN lock.</span>
02938                 <span class="comment">//</span>
02939 
02940                 <a class="code" href="../../d5/d5/sectsup_8c.html#a24">MiCheckControlArea</a> (ControlArea, Process, OldIrql);
02941             }
02942             <span class="keywordflow">else</span> {
02943                 VlmInfo-&gt;CommitCharge -= CommitReduction;
02944             }
02945 
02946             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (Vad);
02947             Vad = (<a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a>)Process-&gt;CloneRoot;
02948 
02949         } <span class="keywordflow">while</span> (Vad != (<a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a>)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
02950     }
02951 
02952     <span class="comment">//</span>
02953     <span class="comment">// Delete any page directory pages.</span>
02954     <span class="comment">//</span>
02955 
02956     PointerPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a152">MiGetPdeAddress64</a> (MM_LOWEST_USER_ADDRESS64);
02957     PointerPte1 = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (PointerPde);
02958     PointerPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a152">MiGetPdeAddress64</a> (MM_HIGHEST_USER_ADDRESS64);
02959     PointerPte2 = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (PointerPde);
02960 
02961     <span class="comment">//</span>
02962     <span class="comment">// Free the use count allocation stashed in the PDE_BASE64.</span>
02963     <span class="comment">//</span>
02964 
02965     <span class="keywordflow">if</span> (PointerPte1-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid) {
02966         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (MiGetPteAddress (PDE_BASE64) == PointerPte1);
02967         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)PDE_BASE64 != PointerPde);
02968         VlmInfo = (PMI_PROCESS_VLM_INFO) (((<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a6">PDE_BASE64</a>)-&gt;u.Long);
02969 
02970 <span class="preprocessor">#if DBG</span>
02971 <span class="preprocessor"></span>        <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (VlmInfo-&gt;CommitCharge == 0);
02972         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (VlmInfo-&gt;VirtualSize == 0);
02973 
02974         {
02975             ULONG i;
02976             <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a> UsedPageTableEntries;
02977 
02978             UsedPageTableEntries = VlmInfo-&gt;UsedPageTableEntries;
02979 
02980             <span class="keywordflow">for</span> (i = 0; i &lt; MM_USER_PAGE_TABLE_PAGES64; i += 1) {
02981                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((*UsedPageTableEntries) == 0);
02982                 UsedPageTableEntries += 1;
02983             }
02984         }
02985 <span class="preprocessor">#endif</span>
02986 <span class="preprocessor"></span>
02987         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (VlmInfo);
02988     }
02989 
02990     <span class="keywordflow">do</span> {
02991 
02992         PteContents = *PointerPte1;
02993         <span class="keywordflow">if</span> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid) {
02994 
02995             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
02996 
02997             <span class="comment">//</span>
02998             <span class="comment">// Decrement the share and valid counts of the page table</span>
02999             <span class="comment">// page which maps this PTE.</span>
03000             <span class="comment">//</span>
03001 
03002             <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
03003             <a class="code" href="../../d4/d8/mi_8h.html#a242">MiDecrementShareAndValidCount</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o17">PteFrame</a>);
03004 
03005             <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a120">MI_SET_PFN_DELETED</a> (Pfn1);
03006 
03007             <span class="comment">//</span>
03008             <span class="comment">// Decrement the share count for the physical page.  As the page</span>
03009             <span class="comment">// is private it will be put on the free list.</span>
03010             <span class="comment">//</span>
03011 
03012             <a class="code" href="../../d4/d8/mi_8h.html#a241">MiDecrementShareCountOnly</a>(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a>(&amp;PteContents));
03013             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount == 0);
03014             <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
03015         }
03016         PointerPte1 += 1;
03017 
03018     } <span class="keywordflow">while</span> (PointerPte1 &lt;= PointerPte2);
03019 
03020     <span class="keywordflow">return</span>;
03021 }
03022 
03023 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
03024 MiFlushPteList64 (
03025     IN PMMPTE_FLUSH_LIST64 PteFlushList,
03026     IN ULONG AllProcessors,
03027     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> FillPte
03028     )
03029 
03030 <span class="comment">/*++</span>
03031 <span class="comment"></span>
03032 <span class="comment">Routine Description:</span>
03033 <span class="comment"></span>
03034 <span class="comment">    This routine flushes all the PTEs in the pte flush list.</span>
03035 <span class="comment">    Is the list has overflowed, the entire TB is flushed.</span>
03036 <span class="comment"></span>
03037 <span class="comment">Arguments:</span>
03038 <span class="comment"></span>
03039 <span class="comment">    PteFlushList - Supplies an optional pointer to the list to be flushed.</span>
03040 <span class="comment"></span>
03041 <span class="comment">    AllProcessors - Supplies TRUE if the flush occurs on all processors.</span>
03042 <span class="comment"></span>
03043 <span class="comment">    FillPte - Supplies the PTE to fill with.</span>
03044 <span class="comment"></span>
03045 <span class="comment">Return Value:</span>
03046 <span class="comment"></span>
03047 <span class="comment">    None.</span>
03048 <span class="comment"></span>
03049 <span class="comment">Environment:</span>
03050 <span class="comment"></span>
03051 <span class="comment">    Kernel mode, PFN lock held.</span>
03052 <span class="comment"></span>
03053 <span class="comment">--*/</span>
03054 
03055 {
03056     ULONG count;
03057     ULONG i = 0;
03058 
03059     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (ARGUMENT_PRESENT (PteFlushList));
03060     <a class="code" href="../../d4/d8/mi_8h.html#a136">MM_PFN_LOCK_ASSERT</a> ();
03061 
03062     count = PteFlushList-&gt;Count;
03063 
03064     <span class="keywordflow">if</span> (count != 0) {
03065         <span class="keywordflow">if</span> (count != 1) {
03066             <span class="keywordflow">if</span> (count &lt; <a class="code" href="../../d4/d8/mi_8h.html#a34">MM_MAXIMUM_FLUSH_COUNT</a>) {
03067                 <a class="code" href="../../d4/d1/xxflshtb_8c.html#a7">KeFlushMultipleTb64</a> (count,
03068                                      &amp;PteFlushList-&gt;FlushVpn[0],
03069                                      TRUE,
03070                                      (BOOLEAN)AllProcessors,
03071                                      &amp;((PHARDWARE_PTE)PteFlushList-&gt;FlushPte[0]),
03072                                      FillPte.u.Flush);
03073             } <span class="keywordflow">else</span> {
03074 
03075                 <span class="comment">//</span>
03076                 <span class="comment">// Array has overflowed, flush the entire TB.</span>
03077                 <span class="comment">//</span>
03078 
03079                 <span class="keywordflow">if</span> (AllProcessors == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
03080                     <a class="code" href="../../d4/d8/mi_8h.html#a119">MiLockSystemSpaceAtDpcLevel</a>();
03081                     <a class="code" href="../../d0/d6/ppc_2flushtb_8c.html#a0">KeFlushEntireTb</a> (TRUE, TRUE);
03082                     <a class="code" href="../../d4/d8/mi_8h.html#a644">MmFlushCounter</a> = (<a class="code" href="../../d4/d8/mi_8h.html#a644">MmFlushCounter</a> + 1) &amp; <a class="code" href="../../d4/d8/mi_8h.html#a8">MM_FLUSH_COUNTER_MASK</a>;
03083                     <a class="code" href="../../d4/d8/mi_8h.html#a120">MiUnlockSystemSpaceFromDpcLevel</a>();
03084                 } <span class="keywordflow">else</span> {
03085                     <a class="code" href="../../d0/d6/ppc_2flushtb_8c.html#a0">KeFlushEntireTb</a> (TRUE, FALSE);
03086                 }
03087             }
03088         } <span class="keywordflow">else</span> {
03089             <a class="code" href="../../d4/d1/xxflshtb_8c.html#a9">KeFlushSingleTb64</a> (PteFlushList-&gt;FlushVpn[0],
03090                                TRUE,
03091                                (BOOLEAN)AllProcessors,
03092                                (PHARDWARE_PTE)PteFlushList-&gt;FlushPte[0],
03093                                FillPte.u.Flush);
03094         }
03095         PteFlushList-&gt;Count = 0;
03096     }
03097     <span class="keywordflow">return</span>;
03098 }
03099 
03100 BOOLEAN
03101 MmIsAddressValid64 (
03102     IN PVOID64 VirtualAddress
03103     )
03104 
03105 <span class="comment">/*++</span>
03106 <span class="comment"></span>
03107 <span class="comment">Routine Description:</span>
03108 <span class="comment"></span>
03109 <span class="comment">    For a given virtual address this function returns TRUE if no page fault</span>
03110 <span class="comment">    will occur for a read operation on the address, FALSE otherwise.</span>
03111 <span class="comment"></span>
03112 <span class="comment">    Note that after this routine was called, if appropriate locks are not</span>
03113 <span class="comment">    held, a non-faulting address could fault.</span>
03114 <span class="comment"></span>
03115 <span class="comment">Arguments:</span>
03116 <span class="comment"></span>
03117 <span class="comment">    VirtualAddress - Supplies the virtual address to check.</span>
03118 <span class="comment"></span>
03119 <span class="comment">Return Value:</span>
03120 <span class="comment"></span>
03121 <span class="comment">    TRUE if a no page fault would be generated reading the virtual address,</span>
03122 <span class="comment">    FALSE otherwise.</span>
03123 <span class="comment"></span>
03124 <span class="comment">Environment:</span>
03125 <span class="comment"></span>
03126 <span class="comment">    Kernel mode.</span>
03127 <span class="comment"></span>
03128 <span class="comment">--*/</span>
03129 
03130 {
03131     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
03132     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPde;
03133 
03134     PointerPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a152">MiGetPdeAddress64</a> (VirtualAddress);
03135 
03136     <span class="comment">//</span>
03137     <span class="comment">// Get Page Directory Page.</span>
03138     <span class="comment">//</span>
03139 
03140     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (PointerPde);
03141     <span class="keywordflow">if</span> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 0) {
03142         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03143     }
03144 
03145     <span class="keywordflow">if</span> (PointerPde-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 0) {
03146         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03147     }
03148 
03149     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a154">MiGetPteAddress64</a> (VirtualAddress);
03150     <span class="keywordflow">if</span> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 0) {
03151         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03152     }
03153     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03154 }
03155 
03156 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
03157 <a class="code" href="../../d5/d6/vlm_8c.html#a3">NtMapViewOfVlmSection</a> (
03158     IN HANDLE SectionHandle,
03159     IN HANDLE ProcessHandle,
03160     IN OUT PVOID64 *BaseAddress,
03161     IN OUT PULONGLONG SectionOffset OPTIONAL,
03162     IN OUT PULONGLONG ViewSize,
03163     IN ULONG AllocationType,
03164     IN ULONG Protect
03165     )
03166 
03167 <span class="comment">/*++</span>
03168 <span class="comment"></span>
03169 <span class="comment">Routine Description:</span>
03170 <span class="comment"></span>
03171 <span class="comment">    This function maps a view in the specified subject process to</span>
03172 <span class="comment">    the section object.</span>
03173 <span class="comment"></span>
03174 <span class="comment">Arguments:</span>
03175 <span class="comment"></span>
03176 <span class="comment">    SectionHandle - Supplies an open handle to a section object.</span>
03177 <span class="comment"></span>
03178 <span class="comment">    ProcessHandle - Supplies an open handle to a process object.</span>
03179 <span class="comment"></span>
03180 <span class="comment">    BaseAddress - Supplies a pointer to a variable that will receive</span>
03181 <span class="comment">                  the base address of the view. If the initial value</span>
03182 <span class="comment">                  of this argument is not null, then the view will</span>
03183 <span class="comment">                  be allocated starting at the specified virtual</span>
03184 <span class="comment">                  address rounded down to the next 64kb address</span>
03185 <span class="comment">                  boundary. If the initial value of this argument is</span>
03186 <span class="comment">                  null, then the operating system will determine</span>
03187 <span class="comment">                  where to allocate the view using the information</span>
03188 <span class="comment">                  specified by the ZeroBits argument value and the</span>
03189 <span class="comment">                  section allocation attributes (i.e. based and</span>
03190 <span class="comment">                  tiled).</span>
03191 <span class="comment"></span>
03192 <span class="comment">    SectionOffset - Supplies the offset from the beginning of the</span>
03193 <span class="comment">                    section to the view in bytes. This value is</span>
03194 <span class="comment">                    rounded down to the next host page size boundary.</span>
03195 <span class="comment"></span>
03196 <span class="comment">    ViewSize - Supplies a pointer to a variable that will receive</span>
03197 <span class="comment">               the actual size in bytes of the view. If the value</span>
03198 <span class="comment">               of this argument is zero, then a view of the</span>
03199 <span class="comment">               section will be mapped starting at the specified</span>
03200 <span class="comment">               section offset and continuing to the end of the</span>
03201 <span class="comment">               section. Otherwise the initial value of this</span>
03202 <span class="comment">               argument specifies the size of the view in bytes</span>
03203 <span class="comment">               and is rounded up to the next host page size</span>
03204 <span class="comment">               boundary.</span>
03205 <span class="comment"></span>
03206 <span class="comment">    AllocationType - Supplies the type of allocation.  Only 0 is valid.</span>
03207 <span class="comment"></span>
03208 <span class="comment">    Protect - Supplies the protection desired for the region of</span>
03209 <span class="comment">              initially committed pages.</span>
03210 <span class="comment"></span>
03211 <span class="comment">        Protect Values</span>
03212 <span class="comment"></span>
03213 <span class="comment">         PAGE_NOACCESS - No access to the committed region</span>
03214 <span class="comment">                         of pages is allowed. An attempt to read,</span>
03215 <span class="comment">                         write, or execute the committed region</span>
03216 <span class="comment">                         results in an access violation (i.e. a GP</span>
03217 <span class="comment">                         fault).</span>
03218 <span class="comment"></span>
03219 <span class="comment">         PAGE_READONLY - Read only and execute access to the</span>
03220 <span class="comment">                         committed region of pages is allowed. An</span>
03221 <span class="comment">                         attempt to write the committed region results</span>
03222 <span class="comment">                         in an access violation.</span>
03223 <span class="comment"></span>
03224 <span class="comment">         PAGE_READWRITE - Read, write, and execute access to</span>
03225 <span class="comment">                          the region of committed pages is allowed. If</span>
03226 <span class="comment">                          write access to the underlying section is</span>
03227 <span class="comment">                          allowed, then a single copy of the pages are</span>
03228 <span class="comment">                          shared. Otherwise the pages are shared read</span>
03229 <span class="comment">                          only/copy on write.</span>
03230 <span class="comment"></span>
03231 <span class="comment">Return Value:</span>
03232 <span class="comment"></span>
03233 <span class="comment">    Returns the status.</span>
03234 <span class="comment"></span>
03235 <span class="comment">--*/</span>
03236 
03237 {
03238     <a class="code" href="../../d5/d3/parseini_8c.html#a2">PSECTION</a> Section;
03239     <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process;
03240     <a class="code" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> PreviousMode;
03241     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
03242     PVOID64 CapturedBase;
03243     ULONGLONG CapturedViewSize;
03244     ULONGLONG TempViewSize;
03245     ULONGLONG CapturedOffset;
03246     ACCESS_MASK DesiredSectionAccess;
03247     ULONG ProtectMaskForAccess;
03248     <a class="code" href="../../d8/d7/struct__CONTROL__AREA.html">PCONTROL_AREA</a> ControlArea;
03249     LOGICAL Attached;
03250     ULONG ReleasedWsMutex;
03251 
03252     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
03253 
03254     Attached = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03255 
03256     <span class="keywordflow">if</span> (MI_VLM_ENABLED() == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
03257         <span class="keywordflow">return</span> STATUS_NOT_IMPLEMENTED;
03258     }
03259 
03260     <span class="comment">//</span>
03261     <span class="comment">// Check the allocation type field.</span>
03262     <span class="comment">//</span>
03263 
03264     <span class="keywordflow">if</span> (AllocationType != 0) {
03265         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER_6;
03266     }
03267 
03268     <span class="comment">//</span>
03269     <span class="comment">// Check the protection field.  This could raise an exception.</span>
03270     <span class="comment">//</span>
03271 
03272     <span class="keywordflow">try</span> {
03273         ProtectMaskForAccess = <a class="code" href="../../d0/d2/mmsup_8c.html#a5">MiMakeProtectionMask</a> (Protect) &amp; 0x7;
03274     } except (EXCEPTION_EXECUTE_HANDLER) {
03275         <span class="keywordflow">return</span> GetExceptionCode();
03276     }
03277 
03278     DesiredSectionAccess = <a class="code" href="../../d4/d8/mi_8h.html#a414">MmMakeSectionAccess</a>[ProtectMaskForAccess];
03279 
03280     PreviousMode = KeGetPreviousMode();
03281 
03282     <span class="comment">//</span>
03283     <span class="comment">// Establish an exception handler, probe the specified addresses</span>
03284     <span class="comment">// for write access and capture the initial values.</span>
03285     <span class="comment">//</span>
03286 
03287     CapturedOffset = 0;
03288     <span class="keywordflow">try</span> {
03289         <span class="keywordflow">if</span> (PreviousMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
03290             <a class="code" href="../../d5/d8/ex_8h.html#a259">ProbeForWrite</a> (BaseAddress, <span class="keyword">sizeof</span>(PVOID64), <span class="keyword">sizeof</span>(PVOID64));
03291             <a class="code" href="../../d5/d8/ex_8h.html#a259">ProbeForWrite</a> (ViewSize, <span class="keyword">sizeof</span>(ULONGLONG), <span class="keyword">sizeof</span>(ULONGLONG));
03292             <span class="keywordflow">if</span> (ARGUMENT_PRESENT (SectionOffset)) {
03293                 <span class="keywordflow">if</span> (PreviousMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
03294                     <a class="code" href="../../d5/d8/ex_8h.html#a259">ProbeForWrite</a> (SectionOffset,
03295                                    <span class="keyword">sizeof</span>(ULONGLONG),
03296                                    <span class="keyword">sizeof</span>(ULONGLONG));
03297                 }
03298             }
03299         }
03300 
03301         <span class="keywordflow">if</span> (ARGUMENT_PRESENT (SectionOffset)) {
03302             CapturedOffset = *SectionOffset;
03303         }
03304 
03305         <span class="comment">//</span>
03306         <span class="comment">// Capture the base address.</span>
03307         <span class="comment">//</span>
03308 
03309         CapturedBase = *BaseAddress;
03310 
03311         <span class="comment">//</span>
03312         <span class="comment">// Capture the region size.</span>
03313         <span class="comment">//</span>
03314 
03315         CapturedViewSize = *ViewSize;
03316 
03317     } except (<a class="code" href="../../d5/d8/ex_8h.html#a307">ExSystemExceptionFilter</a>()) {
03318 
03319         <span class="comment">//</span>
03320         <span class="comment">// If an exception occurs during the probe or capture</span>
03321         <span class="comment">// of the initial values, then handle the exception and</span>
03322         <span class="comment">// return the exception code as the status value.</span>
03323         <span class="comment">//</span>
03324 
03325         <span class="keywordflow">return</span> GetExceptionCode();
03326     }
03327 
03328     <span class="keywordflow">if</span> ((ARGUMENT_PRESENT (SectionOffset)) &amp;&amp;
03329         ((CapturedOffset &amp; (<a class="code" href="../../d4/d8/mi_8h.html#a18">X64K</a> - 1)) != 0)) {
03330         <span class="keywordflow">return</span> STATUS_MAPPED_ALIGNMENT;
03331     }
03332 
03333     <span class="keywordflow">if</span> (((ULONGLONG)CapturedBase &amp; (<a class="code" href="../../d4/d8/mi_8h.html#a18">X64K</a> - 1)) != 0) {
03334         <span class="keywordflow">return</span> STATUS_MAPPED_ALIGNMENT;
03335     }
03336 
03337     <span class="comment">//</span>
03338     <span class="comment">// Make sure the specified starting and ending addresses are</span>
03339     <span class="comment">// within the user part of the virtual address space.</span>
03340     <span class="comment">//</span>
03341 
03342     <span class="keywordflow">if</span> ((CapturedBase != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) &amp;&amp;
03343         ((CapturedBase &gt; (PVOID64)MM_HIGHEST_USER_ADDRESS64) ||
03344         (CapturedBase &lt; (PVOID64)MM_LOWEST_USER_ADDRESS64))) {
03345 
03346         <span class="comment">//</span>
03347         <span class="comment">// Invalid base address.</span>
03348         <span class="comment">//</span>
03349 
03350         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER_3;
03351     }
03352 
03353     <span class="keywordflow">if</span> (CapturedBase != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03354 
03355         <span class="keywordflow">if</span> ((ULONGLONG)CapturedBase + CapturedViewSize &lt; (ULONGLONG)CapturedBase) {
03356 
03357             <span class="comment">//</span>
03358             <span class="comment">// the requested region wraps</span>
03359             <span class="comment">//</span>
03360 
03361             <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER_5;
03362         }
03363 
03364 
03365         <span class="keywordflow">if</span> ((ULONGLONG)CapturedBase + CapturedViewSize &gt; (ULONGLONG)MM_HIGHEST_USER_ADDRESS64 - <a class="code" href="../../d4/d8/mi_8h.html#a18">X64K</a>) {
03366 
03367             <span class="comment">//</span>
03368             <span class="comment">// the requested region goes beyond the end of user memory - flag it</span>
03369             <span class="comment">//</span>
03370 
03371             <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER_5;
03372         }
03373     }
03374     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (CapturedViewSize &gt; (ULONGLONG)MM_LARGEST_VLM_RANGE - <a class="code" href="../../d4/d8/mi_8h.html#a18">X64K</a>) {
03375 
03376         <span class="comment">//</span>
03377         <span class="comment">// Invalid view size;</span>
03378         <span class="comment">//</span>
03379 
03380         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER_5;
03381     }
03382 
03383 
03384     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a> ( ProcessHandle,
03385                                          PROCESS_VM_OPERATION,
03386                                          PsProcessType,
03387                                          PreviousMode,
03388                                          (PVOID *)&amp;Process,
03389                                          NULL );
03390     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status)) {
03391         <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
03392     }
03393 
03394     <span class="comment">//</span>
03395     <span class="comment">// Reference the section object, if a view is mapped to the section</span>
03396     <span class="comment">// object, the object is not dereferenced as the virtual address</span>
03397     <span class="comment">// descriptor contains a pointer to the section object.</span>
03398     <span class="comment">//</span>
03399 
03400     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a> ( SectionHandle,
03401                                          DesiredSectionAccess,
03402                                          MmSectionObjectType,
03403                                          PreviousMode,
03404                                          (PVOID *)&amp;Section,
03405                                          NULL );
03406 
03407     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status)) {
03408         <span class="keywordflow">goto</span> ErrorReturn1;
03409     }
03410 
03411     <span class="keywordflow">if</span> (Section-&gt;Segment-&gt;ControlArea-&gt;u.Flags.Vlm == 0) {
03412 
03413         <span class="comment">//</span>
03414         <span class="comment">// This is not a VLM section.</span>
03415         <span class="comment">//</span>
03416 
03417         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_VLM_OPERATION;
03418         <span class="keywordflow">goto</span> ErrorReturn;
03419     }
03420 
03421     <span class="comment">//</span>
03422     <span class="comment">// Check to make sure the section offset is within the section.</span>
03423     <span class="comment">//</span>
03424 
03425     <span class="keywordflow">if</span> ((CapturedOffset + CapturedViewSize) &gt;
03426                                 (ULONGLONG)Section-&gt;SizeOfSection.QuadPart) {
03427         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_VIEW_SIZE;
03428         <span class="keywordflow">goto</span> ErrorReturn;
03429     }
03430 
03431     <span class="keywordflow">if</span> (CapturedViewSize == 0) {
03432 
03433         <span class="comment">//</span>
03434         <span class="comment">// Set the view size to be size of the section less the offset.</span>
03435         <span class="comment">//</span>
03436 
03437         TempViewSize = Section-&gt;SizeOfSection.QuadPart -
03438                                                 CapturedOffset;
03439 
03440         CapturedViewSize = TempViewSize;
03441 
03442         <span class="keywordflow">if</span> ((TempViewSize == 0) ||
03443             (((ULONGLONG)<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a53">MM_HIGHEST_VAD_ADDRESS64</a> - (ULONGLONG)CapturedBase) &lt;
03444                                                         CapturedViewSize)) {
03445 
03446             <span class="comment">//</span>
03447             <span class="comment">// Invalid region size;</span>
03448             <span class="comment">//</span>
03449 
03450             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_VIEW_SIZE;
03451             <span class="keywordflow">goto</span> ErrorReturn;
03452         }
03453 
03454     } <span class="keywordflow">else</span> {
03455 
03456         <span class="comment">//</span>
03457         <span class="comment">// Check to make sure the view size plus the offset is less</span>
03458         <span class="comment">// than the size of the section.</span>
03459         <span class="comment">//</span>
03460 
03461         <span class="keywordflow">if</span> ((CapturedViewSize + CapturedOffset) &gt;
03462                      (ULONGLONG)Section-&gt;SizeOfSection.QuadPart) {
03463 
03464             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_VIEW_SIZE;
03465             <span class="keywordflow">goto</span> ErrorReturn;
03466         }
03467     }
03468 
03469     ControlArea = Section-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o0">Segment</a>-&gt;<a class="code" href="../../d1/d1/struct__SEGMENT.html#o0">ControlArea</a>;
03470 
03471     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>() != Process) {
03472         <a class="code" href="../../d3/d5/procobj_8c.html#a4">KeAttachProcess</a> (&amp;Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o0">Pcb</a>);
03473         Attached = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03474     }
03475 
03476     <span class="comment">//</span>
03477     <span class="comment">// Get the address creation mutex to block multiple threads</span>
03478     <span class="comment">// creating or deleting address space at the same time.</span>
03479     <span class="comment">//</span>
03480 
03481     <a class="code" href="../../d4/d8/mi_8h.html#a160">LOCK_ADDRESS_SPACE</a> (Process);
03482 
03483     <span class="comment">//</span>
03484     <span class="comment">// Make sure the address space was not deleted, if so, return an error.</span>
03485     <span class="comment">//</span>
03486 
03487     <span class="keywordflow">if</span> (Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o27">AddressSpaceDeleted</a> != 0) {
03488         <a class="code" href="../../d4/d8/mi_8h.html#a163">UNLOCK_ADDRESS_SPACE</a> (Process);
03489         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_PROCESS_IS_TERMINATING;
03490         <span class="keywordflow">goto</span> ErrorReturn;
03491     }
03492 
03493     <span class="comment">//</span>
03494     <span class="comment">// Don't allow POSIX apps to do VLM operations.</span>
03495     <span class="comment">//</span>
03496 
03497     <span class="keywordflow">if</span> ((Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o40">CloneRoot</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
03498          (Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o32">ForkWasSuccessful</a> != MM_NO_FORK_ALLOWED)) {
03499         <a class="code" href="../../d4/d8/mi_8h.html#a163">UNLOCK_ADDRESS_SPACE</a> (Process);
03500         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_VLM_OPERATION;
03501         <span class="keywordflow">goto</span> ErrorReturn;
03502     }
03503     Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o32">ForkWasSuccessful</a> = MM_NO_FORK_ALLOWED;
03504 
03505     ReleasedWsMutex = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03506 
03507     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = MiMapViewOfVlmDataSection (ControlArea,
03508                                      Process,
03509                                      &amp;CapturedBase,
03510                                      &amp;CapturedOffset,
03511                                      &amp;CapturedViewSize,
03512                                      Section,
03513                                      ProtectMaskForAccess,
03514                                      AllocationType,
03515                                      &amp;ReleasedWsMutex);
03516 
03517     <span class="keywordflow">if</span> (!ReleasedWsMutex) {
03518         <a class="code" href="../../d4/d8/mi_8h.html#a158">UNLOCK_WS</a> (Process);
03519     }
03520     <a class="code" href="../../d4/d8/mi_8h.html#a163">UNLOCK_ADDRESS_SPACE</a> (Process);
03521 
03522     <span class="keywordflow">if</span> (Attached == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
03523         <a class="code" href="../../d3/d5/procobj_8c.html#a7">KeDetachProcess</a>();
03524         Attached = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03525     }
03526 
03527     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status) ) {
03528         <span class="keywordflow">goto</span> ErrorReturn;
03529     }
03530 
03531     <span class="comment">//</span>
03532     <span class="comment">// Establish an exception handler and write the size and base</span>
03533     <span class="comment">// address.</span>
03534     <span class="comment">//</span>
03535 
03536     <span class="keywordflow">try</span> {
03537 
03538         *ViewSize = CapturedViewSize;
03539         *BaseAddress = CapturedBase;
03540 
03541         <span class="keywordflow">if</span> (ARGUMENT_PRESENT(SectionOffset)) {
03542             *SectionOffset = CapturedOffset;
03543         }
03544 
03545     } except (EXCEPTION_EXECUTE_HANDLER) {
03546         NOTHING;
03547     }
03548 
03549 ErrorReturn:
03550     <span class="keywordflow">if</span> (Attached == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
03551         <a class="code" href="../../d3/d5/procobj_8c.html#a7">KeDetachProcess</a>();
03552         Attached = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03553     }
03554 
03555     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a> (Section);
03556 ErrorReturn1:
03557     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a> (Process);
03558     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
03559 }
03560 
03561 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
03562 MiMapViewOfVlmDataSection (
03563     IN <a class="code" href="../../d8/d7/struct__CONTROL__AREA.html">PCONTROL_AREA</a> ControlArea,
03564     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process,
03565     IN PVOID64 *CapturedBase,
03566     IN PULONGLONG SectionOffset,
03567     IN PULONGLONG CapturedViewSize,
03568     IN PSECTION Section,
03569     IN ULONG ProtectionMask,
03570     IN ULONG AllocationType,
03571     IN PULONG ReleasedWsMutex
03572     )
03573 
03574 <span class="comment">/*++</span>
03575 <span class="comment"></span>
03576 <span class="comment">Routine Description:</span>
03577 <span class="comment"></span>
03578 <span class="comment">    This routine maps the specified physical section into the</span>
03579 <span class="comment">    specified process's address space.</span>
03580 <span class="comment"></span>
03581 <span class="comment">Arguments:</span>
03582 <span class="comment"></span>
03583 <span class="comment">    See NtMapViewOfVlmSection above...</span>
03584 <span class="comment"></span>
03585 <span class="comment">    ControlArea - Supplies the control area for the section.</span>
03586 <span class="comment"></span>
03587 <span class="comment">    Process - Supplies the process pointer which is receiving the section.</span>
03588 <span class="comment"></span>
03589 <span class="comment">    ProtectionMask - Supplies the initial page protection-mask.</span>
03590 <span class="comment"></span>
03591 <span class="comment">    ReleasedWsMutex - Supplies FALSE. If the working set mutex is</span>
03592 <span class="comment">                      not held when returning this must be set to TRUE</span>
03593 <span class="comment">                      so the caller will release the mutex.</span>
03594 <span class="comment"></span>
03595 <span class="comment">Return Value:</span>
03596 <span class="comment"></span>
03597 <span class="comment">    Status of the map view operation.</span>
03598 <span class="comment"></span>
03599 <span class="comment">Environment:</span>
03600 <span class="comment"></span>
03601 <span class="comment">    Kernel Mode, working set mutex and address creation mutex held.</span>
03602 <span class="comment"></span>
03603 <span class="comment">--*/</span>
03604 
03605 {
03606     <a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a> Vad;
03607     <span class="keyword">volatile</span> PVOID64 Va;
03608     PVOID64 StartingAddress;
03609     PVOID64 EndingAddress;
03610     KIRQL OldIrql;
03611     <a class="code" href="../../d1/d7/struct__SUBSECTION.html">PSUBSECTION</a> Subsection;
03612     ULONG PteOffset;
03613     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
03614     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> LastPte;
03615     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> TempPte;
03616     ULONG QuotaCharge;
03617     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> TheFirstPrototypePte;
03618     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> Pde;
03619     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> LastPde;
03620     LOGICAL PdeBuilt;
03621     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> ReturnStatus;
03622     PMI_PROCESS_VLM_INFO VlmInfo;
03623 
03624     <span class="comment">//</span>
03625     <span class="comment">// Check to see if a purge operation is in progress and if so, wait</span>
03626     <span class="comment">// for the purge to complete.  In addition, up the count of mapped</span>
03627     <span class="comment">// views for this control area.</span>
03628     <span class="comment">//</span>
03629 
03630     <span class="keywordflow">if</span> ((Process-&gt;CloneRoot != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
03631          (Process-&gt;ForkWasSuccessful != MM_NO_FORK_ALLOWED)) {
03632         *ReleasedWsMutex = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03633         <span class="keywordflow">return</span> STATUS_INVALID_VLM_OPERATION;
03634     }
03635 
03636     QuotaCharge = 0;
03637 
03638     Process-&gt;ForkWasSuccessful = MM_NO_FORK_ALLOWED;
03639 
03640     <a class="code" href="../../d4/d8/mi_8h.html#a928">MiCheckPurgeAndUpMapCount</a> (ControlArea);
03641 
03642     <span class="comment">//</span>
03643     <span class="comment">// Calculate the first prototype PTE field in the Vad.</span>
03644     <span class="comment">//</span>
03645 
03646     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (ControlArea-&gt;u.Flags.GlobalOnlyPerSession == 0);
03647 
03648     Subsection = (<a class="code" href="../../d1/d7/struct__SUBSECTION.html">PSUBSECTION</a>)(ControlArea + 1);
03649 
03650     *SectionOffset = (ULONGLONG)MI_ALIGN_TO_SIZE64 (*SectionOffset, X64K);
03651     PteOffset = (ULONG)(*SectionOffset &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
03652 
03653     <span class="comment">//</span>
03654     <span class="comment">// Make sure the PTEs are not in the extended part of the</span>
03655     <span class="comment">// segment.</span>
03656     <span class="comment">//</span>
03657 
03658     <span class="keywordflow">while</span> (PteOffset &gt;= Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o8">PtesInSubsection</a>) {
03659         PteOffset -= Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o8">PtesInSubsection</a>;
03660         Subsection = Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o9">NextSubsection</a>;
03661         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Subsection != NULL);
03662     }
03663 
03664     TheFirstPrototypePte = &amp;Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o6">SubsectionBase</a>[PteOffset];
03665 
03666 <span class="comment">//fixfix - make copy on write invalid    CapturedCopyOnWrite = Section-&gt;u.Flags.CopyOnWrite;</span>
03667 
03668     <a class="code" href="../../d4/d8/mi_8h.html#a154">LOCK_WS</a> (Process);
03669 
03670     <span class="keywordflow">if</span> (*CapturedBase == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03671 
03672         <span class="comment">//</span>
03673         <span class="comment">// The section is not based, find an empty range.</span>
03674         <span class="comment">// This could raise an exception.</span>
03675 
03676         <span class="keywordflow">try</span> {
03677 
03678             <span class="comment">//</span>
03679             <span class="comment">// Find a starting address on a 64k boundary.</span>
03680             <span class="comment">//</span>
03681 
03682             StartingAddress = MiFindEmptyAddressRangeInTree64 (
03683                                *CapturedViewSize,
03684                                X64K,
03685                                (<a class="code" href="../../d9/d0/struct__MMADDRESS__NODE.html">PMMADDRESS_NODE</a>)(Process-&gt;CloneRoot));
03686 
03687         } except (EXCEPTION_EXECUTE_HANDLER) {
03688 
03689             <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
03690             ControlArea-&gt;NumberOfMappedViews -= 1;
03691             ControlArea-&gt;NumberOfUserReferences -= 1;
03692             <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
03693             <span class="keywordflow">return</span> GetExceptionCode();
03694         }
03695 
03696         EndingAddress = (PVOID64)(((ULONGLONG)StartingAddress +
03697                                    *CapturedViewSize - 1<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>) | (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>));
03698 
03699     } <span class="keywordflow">else</span> {
03700 
03701         StartingAddress = MI_ALIGN_TO_SIZE64 (*CapturedBase, X64K);
03702 
03703         <span class="comment">//</span>
03704         <span class="comment">// Check to make sure the specified base address to ending address</span>
03705         <span class="comment">// is currently unused.</span>
03706         <span class="comment">//</span>
03707 
03708         EndingAddress = (PVOID64)(((ULONGLONG)StartingAddress +
03709                                    *CapturedViewSize - 1<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>) | (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>));
03710 
03711         Vad = MiCheckForConflictingVad64 (StartingAddress, EndingAddress);
03712         <span class="keywordflow">if</span> (Vad != (<a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a>)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03713             <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
03714             ControlArea-&gt;NumberOfMappedViews -= 1;
03715             ControlArea-&gt;NumberOfUserReferences -= 1;
03716             <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
03717             <span class="keywordflow">return</span> STATUS_CONFLICTING_ADDRESSES;
03718         }
03719     }
03720 
03721     <span class="comment">//</span>
03722     <span class="comment">// An unoccupied address range has been found, build the virtual</span>
03723     <span class="comment">// address descriptor to describe this range.</span>
03724     <span class="comment">//</span>
03725 
03726     <span class="keywordflow">try</span>  {
03727 
03728         Vad = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a> (NonPagedPool,
03729                                      <span class="keyword">sizeof</span>(<a class="code" href="../../d6/d6/struct__MMVAD.html">MMVAD</a>),
03730                                      MMVADKEY);
03731         <span class="keywordflow">if</span> (Vad == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03732             <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a> (STATUS_INSUFFICIENT_RESOURCES);
03733         }
03734         RtlZeroMemory (Vad, <span class="keyword">sizeof</span>(<a class="code" href="../../d6/d6/struct__MMVAD.html">MMVAD</a>));
03735 
03736         Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o0">StartingVpn</a> = MI_VA_TO_VPN64 (StartingAddress);
03737         Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o1">EndingVpn</a> = MI_VA_TO_VPN64 (EndingAddress);
03738         Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o9">FirstPrototypePte</a> = TheFirstPrototypePte;
03739 
03740         <span class="comment">//</span>
03741         <span class="comment">// The protection is in the PTE template field of the VAD.</span>
03742         <span class="comment">//</span>
03743 
03744         Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o8">ControlArea</a> = ControlArea;
03745 
03746         Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o13">u2</a>.VadFlags2.Inherit = 0;
03747         Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.VadFlags.Protection = ProtectionMask;
03748         Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o13">u2</a>.VadFlags2.CopyOnWrite = 0; <span class="comment">//fixfix</span>
03749 
03750         Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o13">u2</a>.VadFlags2.FileOffset = (ULONG)(*SectionOffset &gt;&gt; 16);
03751 
03752         PteOffset += (ULONG) (Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o1">EndingVpn</a> - Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o0">StartingVpn</a>);
03753 
03754         <span class="keywordflow">if</span> (PteOffset &lt; Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o8">PtesInSubsection</a> ) {
03755             Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o10">LastContiguousPte</a> = &amp;Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o6">SubsectionBase</a>[PteOffset];
03756 
03757         } <span class="keywordflow">else</span> {
03758             Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o10">LastContiguousPte</a> = &amp;Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o6">SubsectionBase</a>[
03759                                         (Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o8">PtesInSubsection</a> - 1) +
03760                                         Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o7">UnusedPtes</a>];
03761         }
03762 
03763         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o9">FirstPrototypePte</a> &lt;= Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o10">LastContiguousPte</a>);
03764         MiInsertVad64 (Vad);
03765 
03766     } except (EXCEPTION_EXECUTE_HANDLER) {
03767 
03768         <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
03769         ControlArea-&gt;NumberOfMappedViews -= 1;
03770         ControlArea-&gt;NumberOfUserReferences -= 1;
03771         <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
03772 
03773         <span class="keywordflow">if</span> (Vad != (<a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a>)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03774 
03775             <span class="comment">//</span>
03776             <span class="comment">// The pool allocation succeeded, but the quota charge</span>
03777             <span class="comment">// in InsertVad failed, deallocate the pool and return</span>
03778             <span class="comment">// an error.</span>
03779             <span class="comment">//</span>
03780 
03781             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (Vad);
03782             <span class="keywordflow">return</span> GetExceptionCode();
03783         }
03784         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
03785     }
03786 
03787     <span class="comment">//</span>
03788     <span class="comment">// Build the top level page directory page to describe this range.</span>
03789     <span class="comment">// The individual page table pages are materialized when the process</span>
03790     <span class="comment">// faults.</span>
03791     <span class="comment">//</span>
03792 
03793     Pde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a152">MiGetPdeAddress64</a> (StartingAddress);
03794     PdeBuilt = MiMakePdeExistAndMakeValid64 (Pde, Process, FALSE, FALSE);
03795 
03796     <span class="keywordflow">if</span> (PdeBuilt == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
03797         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pde == MiGetPdeAddress64 (StartingAddress));
03798         <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
03799         ControlArea-&gt;NumberOfMappedViews -= 1;
03800         ControlArea-&gt;NumberOfUserReferences -= 1;
03801         <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
03802         MiRemoveVad64 (Vad);
03803         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (Vad);
03804         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
03805     }
03806 
03807     *ReleasedWsMutex = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03808     <a class="code" href="../../d4/d8/mi_8h.html#a158">UNLOCK_WS</a> (Process);
03809 
03810     <span class="comment">//</span>
03811     <span class="comment">// Update the current virtual size in the process header.</span>
03812     <span class="comment">//</span>
03813 
03814     *CapturedViewSize = (<span class="keywordtype">char</span> * POINTER_64)EndingAddress - (<span class="keywordtype">char</span> * POINTER_64)StartingAddress + 1<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>;
03815 
03816     VlmInfo = (PMI_PROCESS_VLM_INFO) (((<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a6">PDE_BASE64</a>)-&gt;u.Long);
03817     VlmInfo-&gt;VirtualSize += *CapturedViewSize;
03818     <span class="keywordflow">if</span> (VlmInfo-&gt;VirtualSize &gt; VlmInfo-&gt;VirtualSizePeak) {
03819         VlmInfo-&gt;VirtualSizePeak = VlmInfo-&gt;VirtualSize;
03820     }
03821 
03822     *CapturedBase = StartingAddress;
03823 
03824     <span class="keywordflow">return</span> STATUS_SUCCESS;
03825 }
03826 
03827 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
03828 <a class="code" href="../../d5/d6/vlm_8c.html#a4">NtUnmapViewOfVlmSection</a>(
03829     IN HANDLE ProcessHandle,
03830     IN OUT PVOID64 *BaseAddress
03831     )
03832 
03833 <span class="comment">/*++</span>
03834 <span class="comment"></span>
03835 <span class="comment">Routine Description:</span>
03836 <span class="comment"></span>
03837 <span class="comment">    This function unmaps a previously created view to a section.</span>
03838 <span class="comment"></span>
03839 <span class="comment">Arguments:</span>
03840 <span class="comment"></span>
03841 <span class="comment">    ProcessHandle - Supplies an open handle to a process object.</span>
03842 <span class="comment"></span>
03843 <span class="comment">    BaseAddress - Supplies the base address of the view.</span>
03844 <span class="comment"></span>
03845 <span class="comment">Return Value:</span>
03846 <span class="comment"></span>
03847 <span class="comment">    Returns the status</span>
03848 <span class="comment"></span>
03849 <span class="comment">    TBS</span>
03850 <span class="comment"></span>
03851 <span class="comment"></span>
03852 <span class="comment">--*/</span>
03853 
03854 {
03855     <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process;
03856     <a class="code" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> PreviousMode;
03857     <a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a> Vad;
03858     ULONGLONG RegionSize;
03859     PVOID64 UnMapImageBase;
03860     PVOID64 CapturedBase;
03861     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
03862     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> StartingPte;
03863     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> EndingPte;
03864     <a class="code" href="../../d8/d7/struct__CONTROL__AREA.html">PCONTROL_AREA</a> ControlArea;
03865     KIRQL OldIrql;
03866     ULONG CommitReduction;
03867     PMI_PROCESS_VLM_INFO VlmInfo;
03868 
03869     <span class="keywordflow">if</span> (MI_VLM_ENABLED() == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
03870         <span class="keywordflow">return</span> STATUS_NOT_IMPLEMENTED;
03871     }
03872 
03873     PreviousMode = KeGetPreviousMode();
03874 
03875     status = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a> ( ProcessHandle,
03876                                          PROCESS_VM_OPERATION,
03877                                          PsProcessType,
03878                                          PreviousMode,
03879                                          (PVOID *)&amp;Process,
03880                                          NULL );
03881     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
03882         <span class="keywordflow">return</span> status;
03883     }
03884 
03885     UnMapImageBase = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03886 
03887     <span class="comment">//</span>
03888     <span class="comment">// If the specified process is not the current process, attach</span>
03889     <span class="comment">// to the specified process.</span>
03890     <span class="comment">//</span>
03891 
03892     <a class="code" href="../../d3/d5/procobj_8c.html#a4">KeAttachProcess</a> (&amp;Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o0">Pcb</a>);
03893 
03894     <span class="comment">//</span>
03895     <span class="comment">// Probe and capture the specified address</span>
03896     <span class="comment">//</span>
03897 
03898     PreviousMode = KeGetPreviousMode();
03899 
03900     <span class="keywordflow">if</span> (PreviousMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
03901         <span class="keywordflow">try</span> {
03902             <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a> (BaseAddress, <span class="keyword">sizeof</span>(PVOID64), <span class="keyword">sizeof</span>(PVOID64));
03903 
03904             <span class="comment">//</span>
03905             <span class="comment">// Capture the base address.</span>
03906             <span class="comment">//</span>
03907 
03908             CapturedBase = *BaseAddress;
03909         } except (<a class="code" href="../../d5/d8/ex_8h.html#a307">ExSystemExceptionFilter</a>()) {
03910 
03911             <span class="comment">//</span>
03912             <span class="comment">// If an exception occurs during the probe or capture</span>
03913             <span class="comment">// of the initial value, then handle the exception and</span>
03914             <span class="comment">// return the exception code as the status value.</span>
03915             <span class="comment">//</span>
03916 
03917             <a class="code" href="../../d3/d5/procobj_8c.html#a7">KeDetachProcess</a>();
03918             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a> (Process);
03919             <span class="keywordflow">return</span> GetExceptionCode();
03920         }
03921     }
03922     <span class="keywordflow">else</span> {
03923         CapturedBase = *BaseAddress;
03924     }
03925 
03926     <span class="comment">//</span>
03927     <span class="comment">// Get the address creation mutex to block multiple threads from</span>
03928     <span class="comment">// creating or deleting address space at the same time and</span>
03929     <span class="comment">// get the working set mutex so virtual address descriptors can</span>
03930     <span class="comment">// be inserted and walked.  Raise IRQL to block APCs.</span>
03931     <span class="comment">//</span>
03932     <span class="comment">// Get the working set mutex, no page faults allowed for now until</span>
03933     <span class="comment">// working set mutex released.</span>
03934     <span class="comment">//</span>
03935 
03936     <a class="code" href="../../d4/d8/mi_8h.html#a161">LOCK_WS_AND_ADDRESS_SPACE</a> (Process);
03937 
03938     <span class="comment">//</span>
03939     <span class="comment">// Make sure the address space was not deleted, if so, return an error.</span>
03940     <span class="comment">//</span>
03941 
03942     <span class="keywordflow">if</span> (Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o27">AddressSpaceDeleted</a> != 0) {
03943         status = STATUS_PROCESS_IS_TERMINATING;
03944         <span class="keywordflow">goto</span> ErrorReturn;
03945     }
03946 
03947     <span class="keywordflow">if</span> (Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o32">ForkWasSuccessful</a> != MM_NO_FORK_ALLOWED) {
03948         status = STATUS_NOT_MAPPED_VIEW;
03949         <span class="keywordflow">goto</span> ErrorReturn;
03950     }
03951 
03952     <span class="comment">//</span>
03953     <span class="comment">// Find the associated Vad.</span>
03954     <span class="comment">//</span>
03955 
03956     Vad = (<a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a>)MiLocateAddress64 (MI_VA_TO_VPN64 (CapturedBase));
03957 
03958     <span class="keywordflow">if</span> ((Vad == (<a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a>)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) || (Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.VadFlags.PrivateMemory)) {
03959 
03960         <span class="comment">//</span>
03961         <span class="comment">// No Virtual Address Descriptor located for Base Address.</span>
03962         <span class="comment">//</span>
03963 
03964         status = STATUS_NOT_MAPPED_VIEW;
03965         <span class="keywordflow">goto</span> ErrorReturn;
03966     }
03967 
03968     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.VadFlags.NoChange == 0);
03969 
03970     RegionSize = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> + (((ULONGLONG)(Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o1">EndingVpn</a> - Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o0">StartingVpn</a>)) &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
03971 
03972     MiRemoveVad64 (Vad);
03973 
03974 <span class="preprocessor">#if 0</span>
03975 <span class="preprocessor"></span>    <span class="comment">//</span>
03976     <span class="comment">// Return commitment for page table pages if possible.</span>
03977     <span class="comment">//</span>
03978 
03979     <a class="code" href="../../d6/d1/mmquota_8c.html#a21">MiReturnPageTablePageCommitment</a> (MI_VPN_TO_VA (Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o0">StartingVpn</a>),
03980                                      <a class="code" href="../../d4/d8/mi_8h.html#a109">MI_VPN_TO_VA_ENDING</a> (Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o1">EndingVpn</a>),
03981                                      Process,
03982                                      PreviousVad,
03983                                      NextVad);
03984 <span class="preprocessor">#endif //0</span>
03985 <span class="preprocessor"></span>
03986     StartingPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a154">MiGetPteAddress64</a> (MI_VPN_TO_VA64 (Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o0">StartingVpn</a>));
03987     EndingPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a154">MiGetPteAddress64</a> (MI_VPN_TO_VA64 (Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o1">EndingVpn</a>));
03988 
03989     CommitReduction = MiDecommitOrDeletePages64 (StartingPte,
03990                                                  EndingPte,
03991                                                  Process,
03992                                                  DELETE_TYPE_SHARED,
03993                                                  TRUE);
03994 
03995 
03996     <span class="comment">//</span>
03997     <span class="comment">// Decrement the count of the number of views for the</span>
03998     <span class="comment">// Segment object.  This requires the PFN mutex to be held (it is already).</span>
03999     <span class="comment">//</span>
04000 
04001     ControlArea = Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o8">ControlArea</a>;
04002     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
04003     ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o4">NumberOfMappedViews</a> -= 1;
04004     ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o7">NumberOfUserReferences</a> -= 1;
04005 
04006     <span class="comment">//</span>
04007     <span class="comment">// Check to see if the control area (segment) should be deleted.</span>
04008     <span class="comment">// This routine releases the PFN lock.</span>
04009     <span class="comment">//</span>
04010 
04011     <a class="code" href="../../d5/d5/sectsup_8c.html#a24">MiCheckControlArea</a> (ControlArea, Process, OldIrql);
04012 
04013     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (Vad);
04014 
04015     <span class="comment">//</span>
04016     <span class="comment">// Update the current virtual size in the process header.</span>
04017     <span class="comment">//</span>
04018 
04019     VlmInfo = (PMI_PROCESS_VLM_INFO) (((<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a6">PDE_BASE64</a>)-&gt;u.Long);
04020     VlmInfo-&gt;VirtualSize -= RegionSize;
04021 
04022     status = STATUS_SUCCESS;
04023 
04024 ErrorReturn:
04025 
04026     <a class="code" href="../../d4/d8/mi_8h.html#a158">UNLOCK_WS</a> (Process);
04027     <a class="code" href="../../d4/d8/mi_8h.html#a163">UNLOCK_ADDRESS_SPACE</a> (Process);
04028 
04029     <a class="code" href="../../d3/d5/procobj_8c.html#a7">KeDetachProcess</a>();
04030     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a> (Process);
04031 
04032     <span class="keywordflow">return</span> status;
04033 }
04034 
04035 
04036 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
04037 <a class="code" href="../../d5/d6/vlm_8c.html#a6">NtProtectVirtualMemory64</a>(
04038     IN HANDLE ProcessHandle,
04039     IN OUT PVOID64 *BaseAddress,
04040     IN OUT PULONGLONG RegionSize,
04041     IN ULONG NewProtect,
04042     OUT PULONG OldProtect
04043     )
04044 
04045 {
04046     <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process;
04047     <a class="code" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> PreviousMode;
04048     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
04049     LOGICAL Attached;
04050     PVOID64 CapturedBase;
04051     ULONGLONG CapturedRegionSize;
04052     ULONG ProtectionMask;
04053     <a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a> FoundVad;
04054     PVOID64 StartingAddress;
04055     PVOID64 EndingAddress;
04056     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
04057     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> LastPte;
04058     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPde;
04059     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerProtoPte;
04060     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> LastProtoPte;
04061     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
04062     ULONG CapturedOldProtect;
04063     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> TempPte;
04064     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> PteContents;
04065     PVOID64 Va;
04066     ULONG DoAgain;
04067     PMI_PROCESS_VLM_INFO VlmInfo;
04068     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> LowestPde;
04069 
04070     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
04071 
04072     Attached = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04073 
04074     <span class="comment">//</span>
04075     <span class="comment">// Check the protection field.  This could raise an exception.</span>
04076     <span class="comment">//</span>
04077 
04078     <span class="keywordflow">if</span> ((NewProtect &amp; PAGE_GUARD) ||
04079         (NewProtect &amp; PAGE_NOCACHE)) {
04080         <span class="keywordflow">return</span> STATUS_INVALID_PAGE_PROTECTION;
04081     }
04082 
04083     <span class="keywordflow">try</span> {
04084         ProtectionMask = <a class="code" href="../../d0/d2/mmsup_8c.html#a5">MiMakeProtectionMask</a> (NewProtect);
04085     } except (EXCEPTION_EXECUTE_HANDLER) {
04086         <span class="keywordflow">return</span> GetExceptionCode();
04087     }
04088 
04089     PreviousMode = KeGetPreviousMode();
04090 
04091     <span class="keywordflow">if</span> (PreviousMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
04092 
04093         <span class="comment">//</span>
04094         <span class="comment">// Capture the region size and base address under an exception handler.</span>
04095         <span class="comment">//</span>
04096 
04097         <span class="keywordflow">try</span> {
04098 
04099             <a class="code" href="../../d5/d8/ex_8h.html#a259">ProbeForWrite</a> (BaseAddress, <span class="keyword">sizeof</span>(PVOID64), <span class="keyword">sizeof</span>(PVOID64));
04100             <a class="code" href="../../d5/d8/ex_8h.html#a259">ProbeForWrite</a> (RegionSize, <span class="keyword">sizeof</span>(ULONGLONG), <span class="keyword">sizeof</span>(ULONGLONG));
04101             <a class="code" href="../../d5/d8/ex_8h.html#a40">ProbeForWriteUlong</a> (OldProtect);
04102 
04103             <span class="comment">//</span>
04104             <span class="comment">// Capture the region size and base address.</span>
04105             <span class="comment">//</span>
04106 
04107             CapturedBase = *BaseAddress;
04108             CapturedRegionSize = *RegionSize;
04109 
04110         } except (EXCEPTION_EXECUTE_HANDLER) {
04111 
04112             <span class="comment">//</span>
04113             <span class="comment">// If an exception occurs during the probe or capture</span>
04114             <span class="comment">// of the initial values, then handle the exception and</span>
04115             <span class="comment">// return the exception code as the status value.</span>
04116             <span class="comment">//</span>
04117 
04118             <span class="keywordflow">return</span> GetExceptionCode();
04119         }
04120 
04121     } <span class="keywordflow">else</span> {
04122 
04123         <span class="comment">//</span>
04124         <span class="comment">// Capture the region size and base address.</span>
04125         <span class="comment">//</span>
04126 
04127         CapturedRegionSize = *RegionSize;
04128         CapturedBase = *BaseAddress;
04129     }
04130 
04131     <span class="comment">//</span>
04132     <span class="comment">// Make sure the specified starting and ending addresses are</span>
04133     <span class="comment">// within the user part of the virtual address space.</span>
04134     <span class="comment">//</span>
04135 
04136     <span class="keywordflow">if</span> (CapturedBase &gt; (PVOID64)MM_HIGHEST_USER_ADDRESS64) {
04137 
04138         <span class="comment">//</span>
04139         <span class="comment">// Invalid base address.</span>
04140         <span class="comment">//</span>
04141 
04142         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER_2;
04143     }
04144 
04145     <span class="keywordflow">if</span> ((ULONGLONG)MM_HIGHEST_USER_ADDRESS64 - (ULONGLONG)CapturedBase &lt;
04146                                                         CapturedRegionSize) {
04147 
04148         <span class="comment">//</span>
04149         <span class="comment">// Invalid region size;</span>
04150         <span class="comment">//</span>
04151 
04152         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER_3;
04153     }
04154 
04155     <span class="keywordflow">if</span> (CapturedRegionSize == 0) {
04156         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER_3;
04157     }
04158 
04159     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a> ( ProcessHandle,
04160                                          PROCESS_VM_OPERATION,
04161                                          PsProcessType,
04162                                          PreviousMode,
04163                                          (PVOID *)&amp;Process,
04164                                          NULL );
04165 
04166     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status)) {
04167         <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
04168     }
04169 
04170     <span class="comment">//</span>
04171     <span class="comment">// If the specified process is not the current process, attach</span>
04172     <span class="comment">// to the specified process.</span>
04173     <span class="comment">//</span>
04174 
04175     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>() != Process) {
04176         <a class="code" href="../../d3/d5/procobj_8c.html#a4">KeAttachProcess</a> (&amp;Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o0">Pcb</a>);
04177         Attached = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04178     }
04179 
04180 
04181     <span class="comment">//</span>
04182     <span class="comment">// Get the address creation mutex to block multiple threads from</span>
04183     <span class="comment">// creating or deleting address space at the same time.</span>
04184     <span class="comment">// Get the working set mutex so PTEs can be modified.</span>
04185     <span class="comment">// Block APCs so an APC which takes a page</span>
04186     <span class="comment">// fault does not corrupt various structures.</span>
04187     <span class="comment">//</span>
04188 
04189     <a class="code" href="../../d4/d8/mi_8h.html#a161">LOCK_WS_AND_ADDRESS_SPACE</a> (Process);
04190 
04191     <span class="comment">//</span>
04192     <span class="comment">// Make sure the address space was not deleted, if so, return an error.</span>
04193     <span class="comment">//</span>
04194 
04195     <span class="keywordflow">if</span> (Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o27">AddressSpaceDeleted</a> != 0) {
04196         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_PROCESS_IS_TERMINATING;
04197         <span class="keywordflow">goto</span> ErrorFound;
04198     }
04199 
04200     EndingAddress = (PVOID64)(((ULONGLONG)CapturedBase + CapturedRegionSize - 1) |
04201                         (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1));
04202     StartingAddress = (PVOID64)PAGE_ALIGN64(CapturedBase);
04203 
04204     FoundVad = MiCheckForConflictingVad64 (StartingAddress, EndingAddress);
04205 
04206     <span class="keywordflow">if</span> (FoundVad == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04207 
04208         <span class="comment">//</span>
04209         <span class="comment">// No virtual address is reserved at the specified base address,</span>
04210         <span class="comment">// return an error.</span>
04211         <span class="comment">//</span>
04212 
04213         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_CONFLICTING_ADDRESSES;
04214         <span class="keywordflow">goto</span> ErrorFound;
04215     }
04216 
04217     <span class="comment">//</span>
04218     <span class="comment">// Ensure that the starting and ending addresses are all within</span>
04219     <span class="comment">// the same virtual address descriptor.</span>
04220     <span class="comment">//</span>
04221 
04222     <span class="keywordflow">if</span> ((MI_VA_TO_VPN64 (StartingAddress) &lt; FoundVad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o0">StartingVpn</a>) ||
04223         (MI_VA_TO_VPN64 (EndingAddress) &gt; FoundVad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o1">EndingVpn</a>)) {
04224 
04225         <span class="comment">//</span>
04226         <span class="comment">// Not within the section virtual address descriptor,</span>
04227         <span class="comment">// return an error.</span>
04228         <span class="comment">//</span>
04229 
04230         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_CONFLICTING_ADDRESSES;
04231         <span class="keywordflow">goto</span> ErrorFound;
04232     }
04233 
04234     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (FoundVad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.VadFlags.PhysicalMapping == 0);
04235     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (FoundVad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.VadFlags.NoChange == 0);
04236 
04237     <span class="keywordflow">if</span> (FoundVad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.VadFlags.PrivateMemory == 0) {
04238 
04239 
04240         <span class="comment">//</span>
04241         <span class="comment">// For mapped sections, the NO_CACHE and the COPY_ON_WRITE attribute</span>
04242         <span class="comment">// are not allowed.</span>
04243         <span class="comment">//</span>
04244 
04245         <span class="keywordflow">if</span> ((NewProtect &amp; PAGE_NOCACHE) ||
04246             (ProtectionMask &amp; <a class="code" href="../../d4/d8/mi_8h.html#a84">MM_COPY_ON_WRITE_MASK</a>)) {
04247 
04248             <span class="comment">//</span>
04249             <span class="comment">// Not allowed.</span>
04250             <span class="comment">//</span>
04251 
04252             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_PARAMETER_4;
04253             <span class="keywordflow">goto</span> ErrorFound;
04254         }
04255 
04256         <span class="comment">//</span>
04257         <span class="comment">// If this is a file mapping, then all pages must be</span>
04258         <span class="comment">// committed as there can be no sparse file maps. Images</span>
04259         <span class="comment">// can have non-committed pages if the alignment is greater</span>
04260         <span class="comment">// than the page size.</span>
04261         <span class="comment">//</span>
04262 
04263         <span class="keywordflow">if</span> ((FoundVad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o8">ControlArea</a>-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o10">u</a>.Flags.File == 0) ||
04264             (FoundVad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o8">ControlArea</a>-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o10">u</a>.Flags.Image == 1)) {
04265 
04266             PointerProtoPte = <a class="code" href="../../d4/d8/mi_8h.html#a246">MiGetProtoPteAddress</a> (FoundVad,
04267                                         MI_VA_TO_VPN64 (StartingAddress));
04268             LastProtoPte = <a class="code" href="../../d4/d8/mi_8h.html#a246">MiGetProtoPteAddress</a> (FoundVad,
04269                                         MI_VA_TO_VPN64 (EndingAddress));
04270 
04271             <span class="comment">//</span>
04272             <span class="comment">// Release the working set mutex and acquire the section</span>
04273             <span class="comment">// commit mutex.  Check all the prototype PTEs described by</span>
04274             <span class="comment">// the virtual address range to ensure they are committed.</span>
04275             <span class="comment">//</span>
04276 
04277             <a class="code" href="../../d4/d8/mi_8h.html#a158">UNLOCK_WS</a> (Process);
04278             ExAcquireFastMutex (&amp;MmSectionCommitMutex);
04279 
04280             <span class="keywordflow">while</span> (PointerProtoPte &lt;= LastProtoPte) {
04281 
04282                 <span class="comment">//</span>
04283                 <span class="comment">// Check to see if the prototype PTE is committed, if</span>
04284                 <span class="comment">// not return an error.</span>
04285                 <span class="comment">//</span>
04286 
04287                 <span class="keywordflow">if</span> (PointerProtoPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long == 0) {
04288 
04289                     <span class="comment">//</span>
04290                     <span class="comment">// Error, this prototype PTE is not committed.</span>
04291                     <span class="comment">//</span>
04292 
04293                     ExReleaseFastMutex (&amp;MmSectionCommitMutex);
04294                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_NOT_COMMITTED;
04295                     <span class="keywordflow">goto</span> ErrorFoundNoWs;
04296                 }
04297                 PointerProtoPte += 1;
04298             }
04299 
04300             <span class="comment">//</span>
04301             <span class="comment">// The range is committed, release the section commitment</span>
04302             <span class="comment">// mutex, acquire the working set mutex and update the local PTEs.</span>
04303             <span class="comment">//</span>
04304 
04305             ExReleaseFastMutex (&amp;MmSectionCommitMutex);
04306 
04307             <span class="comment">//</span>
04308             <span class="comment">// Set the protection on the section pages.  This could</span>
04309             <span class="comment">// get a quota exceeded exception.</span>
04310             <span class="comment">//</span>
04311 
04312             <a class="code" href="../../d4/d8/mi_8h.html#a154">LOCK_WS</a> (Process);
04313         }
04314 
04315         <span class="comment">//</span>
04316         <span class="comment">// Set the protection on the pages.</span>
04317         <span class="comment">//</span>
04318 
04319         <span class="comment">//</span>
04320         <span class="comment">// The address range is committed, change the protection.</span>
04321         <span class="comment">//</span>
04322 
04323         PointerPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a152">MiGetPdeAddress64</a> (StartingAddress);
04324         PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a154">MiGetPteAddress64</a> (StartingAddress);
04325         LastPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a154">MiGetPteAddress64</a> (EndingAddress);
04326 
04327         <a class="code" href="../../d0/d2/mmsup_8c.html#a7">MiMakePdeExistAndMakeValid</a>(PointerPde, Process, FALSE);
04328 
04329         <span class="comment">//</span>
04330         <span class="comment">// Capture the protection for the first page.</span>
04331         <span class="comment">//</span>
04332 
04333         <span class="keywordflow">if</span> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long != 0) {
04334 
04335             CapturedOldProtect = PAGE_READWRITE;
04336             <span class="keywordflow">if</span> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1) {
04337                 <span class="keywordflow">if</span> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Write == 0) {
04338                     CapturedOldProtect = PAGE_READONLY;
04339                 }
04340             } <span class="keywordflow">else</span> {
04341                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.PageFileHigh == MI_PTE_LOOKUP_NEEDED);
04342                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Prototype == 1);
04343                 CapturedOldProtect =
04344                     <a class="code" href="../../d4/d8/mi_8h.html#a86">MI_CONVERT_FROM_PTE_PROTECTION</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Protection);
04345             }
04346 
04347         } <span class="keywordflow">else</span> {
04348 
04349             <span class="comment">//</span>
04350             <span class="comment">// Get the protection from the VAD.</span>
04351             <span class="comment">//</span>
04352 
04353             CapturedOldProtect =
04354                <a class="code" href="../../d4/d8/mi_8h.html#a86">MI_CONVERT_FROM_PTE_PROTECTION</a>(FoundVad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.VadFlags.Protection);
04355         }
04356 
04357         LowestPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a152">MiGetPdeAddress64</a> (MM_LOWEST_USER_ADDRESS64);
04358         VlmInfo = (PMI_PROCESS_VLM_INFO) (((<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a6">PDE_BASE64</a>)-&gt;u.Long);
04359 
04360         <span class="comment">//</span>
04361         <span class="comment">// For all the PTEs in the specified address range, set the</span>
04362         <span class="comment">// protection depending on the state of the PTE.</span>
04363         <span class="comment">//</span>
04364 
04365         <span class="keywordflow">while</span> (PointerPte &lt;= LastPte) {
04366 
04367             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a167">MiIsPteOnPdeBoundary</a>(PointerPte)) {
04368 
04369                 PointerPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (PointerPte);
04370 
04371                 <a class="code" href="../../d0/d2/mmsup_8c.html#a7">MiMakePdeExistAndMakeValid</a>(PointerPde, Process, FALSE);
04372             }
04373 
04374             PteContents = *PointerPte;
04375 
04376             <span class="keywordflow">if</span> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1) {
04377 
04378                 <span class="keywordflow">if</span> (ProtectionMask != <a class="code" href="../../d4/d8/mi_8h.html#a46">MM_NOACCESS</a>) {
04379 
04380                     <span class="comment">//</span>
04381                     <span class="comment">// Set the protection into both the PTE and the original PTE</span>
04382                     <span class="comment">// in the PFN database.</span>
04383                     <span class="comment">//</span>
04384 
04385                     Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
04386 
04387                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PrototypePte == 1);
04388 
04389                     <span class="comment">//</span>
04390                     <span class="comment">// The PTE is a private page which is valid, if the</span>
04391                     <span class="comment">// specified protection is no-access or guard page</span>
04392                     <span class="comment">// remove the PTE from the working set.</span>
04393                     <span class="comment">//</span>
04394 
04395                     <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a105">MI_MAKE_VALID_PTE</a> (TempPte,
04396                                        PointerPte-&gt;u.Hard.PageFrameNumber,
04397                                        ProtectionMask,
04398                                        NULL);
04399                     <span class="keywordflow">if</span> (TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Write) {
04400                         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a112">MI_SET_PTE_DIRTY</a> (TempPte);
04401                     }
04402 
04403                     <span class="comment">//</span>
04404                     <span class="comment">// Flush the TB as we have changed the protection</span>
04405                     <span class="comment">// of a valid PTE.</span>
04406                     <span class="comment">//</span>
04407 
04408                     <a class="code" href="../../d0/d9/protect_8c.html#a1">MiFlushTbAndCapture</a> (PointerPte,
04409                                          TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Flush,
04410                                          Pfn1);
04411                 } <span class="keywordflow">else</span> {
04412 
04413                     <span class="comment">//</span>
04414                     <span class="comment">// No access, remove page from memory.</span>
04415                     <span class="comment">//</span>
04416 
04417                     MiMakeValidPageNoAccess64 (PointerPte);
04418                 }
04419 
04420             } <span class="keywordflow">else</span> {
04421 
04422                 <span class="keywordflow">if</span> (PointerPte-&gt;u.Long == <a class="code" href="../../d4/d2/datalpha_8c.html#a0">ZeroPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long) {
04423                     *PointerPte = <a class="code" href="../../d4/d2/datalpha_8c.html#a12">PrototypePte</a>;
04424                     PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Protection = ProtectionMask;
04425 
04426                     VlmInfo-&gt;UsedPageTableEntries[PointerPde - LowestPde] += 1;
04427 
04428                 } <span class="keywordflow">else</span> {
04429                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;u.Soft.Prototype == 1);
04430                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;u.Soft.PageFileHigh == MI_PTE_LOOKUP_NEEDED);
04431                     PointerPte-&gt;u.Soft.Protection = ProtectionMask;
04432                 }
04433             }
04434             PointerPte += 1;
04435         } <span class="comment">//end while</span>
04436 
04437     } <span class="keywordflow">else</span> {
04438 
04439         <span class="comment">//</span>
04440         <span class="comment">// Not a section, private.</span>
04441         <span class="comment">// For private pages, the WRITECOPY attribute is not allowed.</span>
04442         <span class="comment">//</span>
04443 
04444         <span class="keywordflow">if</span> ((NewProtect &amp; PAGE_WRITECOPY) ||
04445             (NewProtect &amp; PAGE_EXECUTE_WRITECOPY)) {
04446 
04447             <span class="comment">//</span>
04448             <span class="comment">// Not allowed.</span>
04449             <span class="comment">//</span>
04450 
04451             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_PARAMETER_4;
04452             <span class="keywordflow">goto</span> ErrorFound;
04453         }
04454 
04455         <span class="comment">//</span>
04456         <span class="comment">// Ensure all of the pages are already committed as described</span>
04457         <span class="comment">// in the virtual address descriptor.</span>
04458         <span class="comment">//</span>
04459 
04460         <span class="keywordflow">if</span> ( !MiIsEntireRangeCommitted64 (StartingAddress,
04461                                           EndingAddress,
04462                                           FoundVad,
04463                                           Process)) {
04464 
04465             <span class="comment">//</span>
04466             <span class="comment">// Previously reserved pages have been decommitted, or an error</span>
04467             <span class="comment">// occurred, release mutex and return status.</span>
04468             <span class="comment">//</span>
04469 
04470             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_NOT_COMMITTED;
04471             <span class="keywordflow">goto</span> ErrorFound;
04472         }
04473 
04474         <span class="comment">//</span>
04475         <span class="comment">// The address range is committed, change the protection.</span>
04476         <span class="comment">//</span>
04477 
04478         PointerPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a152">MiGetPdeAddress64</a> (StartingAddress);
04479         PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a154">MiGetPteAddress64</a> (StartingAddress);
04480         LastPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a154">MiGetPteAddress64</a> (EndingAddress);
04481 
04482         <a class="code" href="../../d0/d2/mmsup_8c.html#a7">MiMakePdeExistAndMakeValid</a>(PointerPde, Process, FALSE);
04483 
04484         <span class="comment">//</span>
04485         <span class="comment">// Capture the protection for the first page.</span>
04486         <span class="comment">//</span>
04487 
04488         <span class="keywordflow">if</span> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long != 0) {
04489 
04490             CapturedOldProtect = <a class="code" href="../../d0/d9/protect_8c.html#a7">MiGetPageProtection</a> (PointerPte, Process);
04491 
04492         } <span class="keywordflow">else</span> {
04493 
04494             <span class="comment">//</span>
04495             <span class="comment">// Get the protection from the VAD.</span>
04496             <span class="comment">//</span>
04497 
04498             CapturedOldProtect =
04499                <a class="code" href="../../d4/d8/mi_8h.html#a86">MI_CONVERT_FROM_PTE_PROTECTION</a>(FoundVad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.VadFlags.Protection);
04500         }
04501 
04502         <span class="comment">//</span>
04503         <span class="comment">// For all the PTEs in the specified address range, set the</span>
04504         <span class="comment">// protection depending on the state of the PTE.</span>
04505         <span class="comment">//</span>
04506 
04507         <span class="keywordflow">while</span> (PointerPte &lt;= LastPte) {
04508 
04509             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a167">MiIsPteOnPdeBoundary</a>(PointerPte)) {
04510 
04511                 PointerPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (PointerPte);
04512 
04513                 <a class="code" href="../../d0/d2/mmsup_8c.html#a7">MiMakePdeExistAndMakeValid</a>(PointerPde, Process, FALSE);
04514             }
04515 
04516             PteContents = *PointerPte;
04517 
04518             <span class="keywordflow">if</span> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1) {
04519 
04520                 <span class="keywordflow">if</span> (ProtectionMask != <a class="code" href="../../d4/d8/mi_8h.html#a46">MM_NOACCESS</a>) {
04521 
04522                     <span class="comment">//</span>
04523                     <span class="comment">// Set the protection into both the PTE and the original PTE</span>
04524                     <span class="comment">// in the PFN database.</span>
04525                     <span class="comment">//</span>
04526 
04527                     Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
04528 
04529                     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Protection = ProtectionMask;
04530                     <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a105">MI_MAKE_VALID_PTE</a> (TempPte,
04531                                        PointerPte-&gt;u.Hard.PageFrameNumber,
04532                                        ProtectionMask,
04533                                        NULL);
04534                     <span class="keywordflow">if</span> (TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Write) {
04535                         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a112">MI_SET_PTE_DIRTY</a> (TempPte);
04536                     }
04537 
04538                     <span class="comment">//</span>
04539                     <span class="comment">// Flush the TB as we have changed the protection</span>
04540                     <span class="comment">// of a valid PTE.</span>
04541                     <span class="comment">//</span>
04542 
04543                     <a class="code" href="../../d0/d9/protect_8c.html#a1">MiFlushTbAndCapture</a> (PointerPte,
04544                                          TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Flush,
04545                                          Pfn1);
04546                 } <span class="keywordflow">else</span> {
04547 
04548                     <span class="comment">//</span>
04549                     <span class="comment">// No access, remove page from memory, make it transition.</span>
04550                     <span class="comment">//</span>
04551 
04552                     MiMakeValidPageNoAccess64 (PointerPte);
04553                 }
04554             } <span class="keywordflow">else</span> {
04555 
04556                 <span class="comment">//</span>
04557                 <span class="comment">// the page is not present.</span>
04558                 <span class="comment">//</span>
04559 
04560                 <span class="keywordflow">if</span> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Transition == 1) {
04561 
04562                     <span class="comment">//</span>
04563                     <span class="comment">// The only reason a PTE would be transition is if it has</span>
04564                     <span class="comment">// been made no access.  If the protection is not no access,</span>
04565                     <span class="comment">// make it valid with the right protection.  otherwise, it</span>
04566                     <span class="comment">// is already in the desired state, so don't do anything.</span>
04567                     <span class="comment">//</span>
04568 
04569                     <span class="keywordflow">if</span> (ProtectionMask != <a class="code" href="../../d4/d8/mi_8h.html#a46">MM_NOACCESS</a>) {
04570                         MiMakeNoAccessPageValid64 (PointerPte, ProtectionMask);
04571                     }
04572 
04573                 } <span class="keywordflow">else</span> {
04574 
04575                     <span class="comment">//</span>
04576                     <span class="comment">// Must be page file space or demand zero.</span>
04577                     <span class="comment">//</span>
04578 
04579                     PointerPte-&gt;u.Soft.Protection = ProtectionMask;
04580                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;u.Long != 0);
04581                 }
04582             }
04583             PointerPte += 1;
04584         } <span class="comment">//end while</span>
04585     }
04586 
04587     <span class="comment">//</span>
04588     <span class="comment">// Common completion code.</span>
04589     <span class="comment">//</span>
04590 
04591     CapturedRegionSize = (<span class="keywordtype">char</span> * POINTER_64)EndingAddress - (<span class="keywordtype">char</span> * POINTER_64)StartingAddress + 1<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>;
04592 
04593     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
04594 
04595 ErrorFound:
04596 
04597     <a class="code" href="../../d4/d8/mi_8h.html#a158">UNLOCK_WS</a> (Process);
04598 ErrorFoundNoWs:
04599 
04600     <a class="code" href="../../d4/d8/mi_8h.html#a163">UNLOCK_ADDRESS_SPACE</a> (Process);
04601 
04602     <span class="keywordflow">if</span> (Attached) {
04603         <a class="code" href="../../d3/d5/procobj_8c.html#a7">KeDetachProcess</a>();
04604     }
04605 
04606     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a> (Process);
04607 
04608     <span class="comment">//</span>
04609     <span class="comment">// Establish an exception handler and write the size and base</span>
04610     <span class="comment">// address.</span>
04611     <span class="comment">//</span>
04612 
04613     <span class="keywordflow">try</span> {
04614 
04615         <span class="comment">//</span>
04616         <span class="comment">// Reprobe the addresses as certain architectures (intel 386 for one)</span>
04617         <span class="comment">// do not trap kernel writes.  This is the one service which allows</span>
04618         <span class="comment">// the protection of the page to change between the initial probe</span>
04619         <span class="comment">// and the final argument update.</span>
04620         <span class="comment">//</span>
04621 
04622         <span class="keywordflow">if</span> (PreviousMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
04623 
04624             <a class="code" href="../../d5/d8/ex_8h.html#a259">ProbeForWrite</a> (BaseAddress, <span class="keyword">sizeof</span>(PVOID64), <span class="keyword">sizeof</span>(PVOID64));
04625             <a class="code" href="../../d5/d8/ex_8h.html#a259">ProbeForWrite</a> (RegionSize, <span class="keyword">sizeof</span>(ULONGLONG), <span class="keyword">sizeof</span>(ULONGLONG));
04626             <a class="code" href="../../d5/d8/ex_8h.html#a40">ProbeForWriteUlong</a> (OldProtect);
04627         }
04628 
04629         *RegionSize = CapturedRegionSize;
04630         *BaseAddress = StartingAddress;
04631         *OldProtect = CapturedOldProtect;
04632 
04633     } except (EXCEPTION_EXECUTE_HANDLER) {
04634         NOTHING;
04635     }
04636 
04637     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
04638 }
04639 
04640 ULONG
04641 MiIsEntireRangeCommitted64 (
04642     IN PVOID64 StartingAddress,
04643     IN PVOID64 EndingAddress,
04644     IN <a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a> Vad,
04645     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process
04646     )
04647 
04648 <span class="comment">/*++</span>
04649 <span class="comment"></span>
04650 <span class="comment">Routine Description:</span>
04651 <span class="comment"></span>
04652 <span class="comment">    This routine examines the range of pages from the starting address</span>
04653 <span class="comment">    up to and including the ending address and returns TRUE if every</span>
04654 <span class="comment">    page in the range is committed, FALSE otherwise.</span>
04655 <span class="comment"></span>
04656 <span class="comment">Arguments:</span>
04657 <span class="comment"></span>
04658 <span class="comment">    StartingAddress - Supplies the starting address of the range.</span>
04659 <span class="comment"></span>
04660 <span class="comment">    EndingAddress - Supplies the ending address of the range.</span>
04661 <span class="comment"></span>
04662 <span class="comment">    Vad - Supplies the virtual address descriptor which describes the range.</span>
04663 <span class="comment"></span>
04664 <span class="comment">    Process - Supplies the current process.</span>
04665 <span class="comment"></span>
04666 <span class="comment">Return Value:</span>
04667 <span class="comment"></span>
04668 <span class="comment">    TRUE if the entire range is committed.</span>
04669 <span class="comment">    FALSE if any page within the range is not committed.</span>
04670 <span class="comment"></span>
04671 <span class="comment">Environment:</span>
04672 <span class="comment"></span>
04673 <span class="comment">    Kernel mode, APCs disabled, WorkingSetMutex and AddressCreation mutexes</span>
04674 <span class="comment">    held.</span>
04675 <span class="comment"></span>
04676 <span class="comment">--*/</span>
04677 
04678 {
04679     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
04680     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> LastPte;
04681     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPde;
04682     LOGICAL FirstTime;
04683     PVOID64 Va;
04684 
04685     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
04686 
04687     FirstTime = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04688 
04689     PointerPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a152">MiGetPdeAddress64</a> (StartingAddress);
04690     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a154">MiGetPteAddress64</a> (StartingAddress);
04691     LastPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a154">MiGetPteAddress64</a> (EndingAddress);
04692 
04693     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Vad-&gt;u.VadFlags.PrivateMemory == 1);
04694 
04695     Va = StartingAddress;
04696 
04697     <span class="keywordflow">while</span> (PointerPte &lt;= LastPte) {
04698 
04699         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a167">MiIsPteOnPdeBoundary</a>(PointerPte) || FirstTime) {
04700 
04701             <span class="comment">//</span>
04702             <span class="comment">// This is a PDE boundary, check to see if the entire</span>
04703             <span class="comment">// PDE page exists.</span>
04704             <span class="comment">//</span>
04705 
04706             FirstTime = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04707             PointerPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (PointerPte);
04708 
04709             <span class="keywordflow">if</span> (PointerPde-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long == 0) {
04710 
04711                 <span class="comment">//</span>
04712                 <span class="comment">// No page directory entry for private memory means</span>
04713                 <span class="comment">// we're not committed.</span>
04714                 <span class="comment">//</span>
04715 
04716                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Vad-&gt;u.VadFlags.PrivateMemory == 1);
04717                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04718             }
04719 <span class="preprocessor">#if 0</span>
04720 <span class="preprocessor"></span>            <span class="keywordflow">while</span> (!<a class="code" href="../../d0/d2/mmsup_8c.html#a6">MiDoesPdeExistAndMakeValid</a>(PointerPde, Process, FALSE)) {
04721 
04722                 <span class="comment">//</span>
04723                 <span class="comment">// No PDE exists for the starting address, check the VAD</span>
04724                 <span class="comment">// to see if the pages are committed.</span>
04725                 <span class="comment">//</span>
04726 
04727                 PointerPde += 1;
04728 
04729                 PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPde);
04730                 Va = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPte);
04731 
04732                 <span class="keywordflow">if</span> (PointerPte &gt; LastPte) {
04733 
04734                     <span class="comment">//</span>
04735                     <span class="comment">// Make sure the entire range is committed.</span>
04736                     <span class="comment">//</span>
04737 
04738                     <span class="keywordflow">if</span> (Vad-&gt;u.VadFlags.MemCommit == 0) {
04739 
04740                         <span class="comment">//</span>
04741                         <span class="comment">// The entire range to be decommitted is not committed,</span>
04742                         <span class="comment">// return an error.</span>
04743                         <span class="comment">//</span>
04744 
04745                         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04746                     } <span class="keywordflow">else</span> {
04747                         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04748                     }
04749                 }
04750 
04751                 <span class="comment">//</span>
04752                 <span class="comment">// Make sure the range thus far is committed.</span>
04753                 <span class="comment">//</span>
04754 
04755                 <span class="keywordflow">if</span> (Vad-&gt;u.VadFlags.MemCommit == 0) {
04756 
04757                     <span class="comment">//</span>
04758                     <span class="comment">// The entire range to be decommitted is not committed,</span>
04759                     <span class="comment">// return an error.</span>
04760                     <span class="comment">//</span>
04761 
04762                     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04763                 }
04764             }
04765 <span class="preprocessor">#endif //0</span>
04766 <span class="preprocessor"></span>        }
04767 
04768         <span class="comment">//</span>
04769         <span class="comment">// The page table page exists, check each PTE for commitment.</span>
04770         <span class="comment">//</span>
04771 
04772         <span class="keywordflow">if</span> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long == 0) {
04773 
04774             <span class="comment">//</span>
04775             <span class="comment">// This page has not been committed, check the VAD.</span>
04776             <span class="comment">//</span>
04777 
04778 <span class="preprocessor">#if 0</span>
04779 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (Vad-&gt;u.VadFlags.MemCommit == 0) {
04780 <span class="preprocessor">#endif</span>
04781 <span class="preprocessor"></span>
04782                 <span class="comment">//</span>
04783                 <span class="comment">// The entire range to be decommitted is not committed,</span>
04784                 <span class="comment">// return an error.</span>
04785                 <span class="comment">//</span>
04786 
04787                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04788 <span class="preprocessor">#if 0</span>
04789 <span class="preprocessor"></span>            }
04790 <span class="preprocessor">#endif</span>
04791 <span class="preprocessor"></span>        } <span class="keywordflow">else</span> {
04792 
04793             <span class="comment">//</span>
04794             <span class="comment">// Has this page been explicitly decommitted?</span>
04795             <span class="comment">//</span>
04796 
04797             <span class="keywordflow">if</span> (<a class="code" href="../../d0/d2/mmsup_8c.html#a3">MiIsPteDecommittedPage</a> (PointerPte)) {
04798 
04799                 <span class="comment">//</span>
04800                 <span class="comment">// This page has been explicitly decommitted, return an error.</span>
04801                 <span class="comment">//</span>
04802 
04803                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04804             }
04805         }
04806         PointerPte += 1;
04807         Va = (PVOID64)((ULONGLONG)Va + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
04808     }
04809     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04810 }
04811 
04812 
04813 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
04814 MiMakeValidPageNoAccess64 (
04815     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte
04816     )
04817 {
04818     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
04819     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPde;
04820     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> PteContents;
04821     KIRQL OldIrql;
04822     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> TempPte;
04823     ULONG_PTR Vpn;
04824 
04825     Vpn = (ULONG_PTR)((ULONGLONG)<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a162">MiGetVirtualAddressMappedByPte64</a>(PointerPte) &gt;&gt;
04826                     <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
04827 
04828     TempPte = <a class="code" href="../../d4/d2/datalpha_8c.html#a12">PrototypePte</a>;
04829     TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Protection = <a class="code" href="../../d4/d8/mi_8h.html#a46">MM_NOACCESS</a>;
04830 
04831     PointerPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (PointerPte);
04832     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
04833 
04834     PteContents = *PointerPte;
04835     Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
04836 
04837     <span class="keywordflow">if</span> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PrototypePte == 1) {
04838 
04839         <span class="comment">//</span>
04840         <span class="comment">// Capture the state of the modified bit for this pte.</span>
04841         <span class="comment">//</span>
04842 
04843         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a177">MI_CAPTURE_DIRTY_BIT_TO_PFN</a> (&amp;PteContents, Pfn1);
04844 
04845         <span class="comment">//</span>
04846         <span class="comment">// Decrement the share and valid counts of the page table</span>
04847         <span class="comment">// page which maps this PTE.</span>
04848         <span class="comment">//</span>
04849 
04850         <a class="code" href="../../d4/d8/mi_8h.html#a242">MiDecrementShareAndValidCount</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a>(PointerPde));
04851 
04852         <span class="comment">//</span>
04853         <span class="comment">// Decrement the share count for the physical page.</span>
04854         <span class="comment">//</span>
04855 
04856         <a class="code" href="../../d6/d5/pfndec_8c.html#a1">MiDecrementShareCount</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a>(&amp;PteContents));
04857 
04858     } <span class="keywordflow">else</span> {
04859 
04860         <span class="comment">//</span>
04861         <span class="comment">// Make the PTE transition, but don't decrement the reference count</span>
04862         <span class="comment">// only the share count.</span>
04863         <span class="comment">//</span>
04864 
04865         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount != 0);
04866         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount += 1;
04867         <a class="code" href="../../d6/d5/pfndec_8c.html#a1">MiDecrementShareCount</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a>(&amp;PteContents));
04868         TempPte = PteContents;
04869         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a106">MI_MAKE_VALID_PTE_TRANSITION</a> (TempPte, MM_NOACCESS);
04870     }
04871 
04872     <a class="code" href="../../d4/d1/xxflshtb_8c.html#a9">KeFlushSingleTb64</a> (Vpn,
04873                      TRUE,
04874                      FALSE,
04875                      (PHARDWARE_PTE)PointerPte,
04876                      TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Flush);
04877     <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
04878     <span class="keywordflow">return</span>;
04879 }
04880 
04881 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
04882 MiMakeNoAccessPageValid64 (
04883     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte,
04884     IN ULONG Protect
04885     )
04886 
04887 {
04888     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> PteContents;
04889     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> TempPte;
04890     KIRQL OldIrql;
04891     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
04892     PFN_NUMBER PageFrameIndex;
04893 
04894     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
04895     PteContents = *PointerPte;
04896     PageFrameIndex = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a183">MI_GET_PAGE_FRAME_FROM_TRANSITION_PTE</a>(&amp;PteContents);
04897     Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PageFrameIndex);
04898     <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a105">MI_MAKE_VALID_PTE</a> (TempPte,
04899                        PageFrameIndex,
04900                        Protect,
04901                        NULL);
04902     <span class="keywordflow">if</span> (TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Write) {
04903         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a112">MI_SET_PTE_DIRTY</a> (TempPte);
04904     }
04905 
04906     <span class="comment">//</span>
04907     <span class="comment">// Note that VLM no access pages are marked as transition pages and</span>
04908     <span class="comment">// are not in any page tables.  Therefore their sharecount is zero.</span>
04909     <span class="comment">//</span>
04910     <span class="comment">// The subtlety is that the reference count on this VLM no access page</span>
04911     <span class="comment">// should never go to 0 because then the page will actually be freed</span>
04912     <span class="comment">// to the standby list - and we'd only want to do that if we were actually</span>
04913     <span class="comment">// getting rid of the page (as opposed to making it no-access).</span>
04914     <span class="comment">//</span>
04915     <span class="comment">// Thus, the ASSERT below cannot be turned on.</span>
04916     <span class="comment">//</span>
04917     <span class="comment">// ASSERT (Pfn1-&gt;u2.ShareCount == 1);</span>
04918     <span class="comment">//</span>
04919 
04920     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount != 0);
04921     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount += 1;
04922     *PointerPte = TempPte;
04923     <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
04924     <span class="keywordflow">return</span>;
04925 }
04926 
04927 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
04928 MiGetVlmInfo (
04929     IN PMEMORY_VLM_COUNTERS VlmUserInfo
04930     )
04931 
04932 <span class="comment">/*++</span>
04933 <span class="comment"></span>
04934 <span class="comment">Routine Description:</span>
04935 <span class="comment"></span>
04936 <span class="comment">    This function returns the various VLM information values.</span>
04937 <span class="comment"></span>
04938 <span class="comment">Arguments:</span>
04939 <span class="comment"></span>
04940 <span class="comment">    VlmInfo - Supplies a VLM information structure to fill in.</span>
04941 <span class="comment"></span>
04942 <span class="comment">Return Value:</span>
04943 <span class="comment"></span>
04944 <span class="comment">    Returns the status.</span>
04945 <span class="comment"></span>
04946 <span class="comment">Environment:</span>
04947 <span class="comment"></span>
04948 <span class="comment">    Kernel mode.  The caller is responsible for ensuring that VLM is enabled.</span>
04949 <span class="comment"></span>
04950 <span class="comment">--*/</span>
04951 
04952 {
04953     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
04954     <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> TargetProcess;
04955     PMI_PROCESS_VLM_INFO VlmInfo;
04956 
04957     RtlZeroMemory (VlmUserInfo, <span class="keyword">sizeof</span> (*VlmUserInfo));
04958 
04959     VlmUserInfo-&gt;SystemCommitCharge = MiVlmCommitChargeInPages;
04960     VlmUserInfo-&gt;SystemPeakCommitCharge = MiVlmCommitChargeInPagesPeak;
04961     VlmUserInfo-&gt;SystemSharedCommitCharge = MmSharedCommitVlm;
04962     VlmUserInfo-&gt;VirtualSizeAvailable =
04963         MM_HIGHEST_USER_ADDRESS64 - MM_LOWEST_USER_ADDRESS64 + 1;
04964 
04965 
04966     TargetProcess = <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>();
04967 
04968     <a class="code" href="../../d4/d8/mi_8h.html#a154">LOCK_WS</a> (TargetProcess);
04969 
04970     <span class="keywordflow">if</span> (TargetProcess-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o27">AddressSpaceDeleted</a> != 0) {
04971         <a class="code" href="../../d4/d8/mi_8h.html#a158">UNLOCK_WS</a> (TargetProcess);
04972         <span class="keywordflow">return</span> STATUS_PROCESS_IS_TERMINATING;
04973     }
04974 
04975     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (PDE_BASE64);
04976 
04977     <span class="keywordflow">if</span> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long != 0) {
04978 
04979         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1);
04980 
04981         VlmInfo = (PMI_PROCESS_VLM_INFO) (((<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a6">PDE_BASE64</a>)-&gt;u.Long);
04982 
04983         VlmUserInfo-&gt;VirtualSize = VlmInfo-&gt;VirtualSize;
04984         VlmUserInfo-&gt;PeakVirtualSize = VlmInfo-&gt;VirtualSizePeak;
04985 
04986         VlmUserInfo-&gt;VirtualSizeAvailable -= VlmInfo-&gt;VirtualSize;
04987 
04988         VlmUserInfo-&gt;CommitCharge = VlmInfo-&gt;CommitCharge;
04989         VlmUserInfo-&gt;PeakCommitCharge = VlmInfo-&gt;CommitChargePeak;
04990     }
04991 
04992     <a class="code" href="../../d4/d8/mi_8h.html#a158">UNLOCK_WS</a> (TargetProcess);
04993 
04994     <span class="keywordflow">return</span> STATUS_SUCCESS;
04995 }
04996 
04997 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
04998 <a class="code" href="../../d5/d6/vlm_8c.html#a5">NtQueryVirtualMemory64</a>(
04999     IN HANDLE ProcessHandle,
05000     IN PVOID64 *pBaseAddress,
05001     IN MEMORY_INFORMATION_CLASS MemoryInformationClass,
05002     OUT PVOID MemoryInformation,
05003     IN ULONG MemoryInformationLength,
05004     OUT PULONG ReturnLength OPTIONAL
05005     )
05006 
05007 <span class="comment">/*++</span>
05008 <span class="comment"></span>
05009 <span class="comment">Routine Description:</span>
05010 <span class="comment"></span>
05011 <span class="comment">    This function provides the capability to determine the state,</span>
05012 <span class="comment">    protection, and type of a region of pages within the virtual address</span>
05013 <span class="comment">    space of the subject process.</span>
05014 <span class="comment"></span>
05015 <span class="comment">    The state of the first page within the region is determined  and then</span>
05016 <span class="comment">    subsequent entries in the process address map are scanned from the</span>
05017 <span class="comment">    base address upward until either the entire range of pages has been</span>
05018 <span class="comment">    scanned or until a page with a nonmatching set of attributes is</span>
05019 <span class="comment">    encountered. The region attributes, the length of the region of pages</span>
05020 <span class="comment">    with matching attributes, and an appropriate status value are</span>
05021 <span class="comment">    returned.</span>
05022 <span class="comment"></span>
05023 <span class="comment">    If the entire region of pages does not have a matching set of</span>
05024 <span class="comment">    attributes, then the returned length parameter value can be used to</span>
05025 <span class="comment">    calculate the address and length of the region of pages that was not</span>
05026 <span class="comment">    scanned.</span>
05027 <span class="comment"></span>
05028 <span class="comment">Arguments:</span>
05029 <span class="comment"></span>
05030 <span class="comment"></span>
05031 <span class="comment">    ProcessHandle - An open handle to a process object.</span>
05032 <span class="comment"></span>
05033 <span class="comment">    pBaseAddress - Pointer to the base address of the region of pages to be</span>
05034 <span class="comment">        queried. This value is rounded down to the next host-page-</span>
05035 <span class="comment">        address boundary.</span>
05036 <span class="comment"></span>
05037 <span class="comment">        Note this is a 32-bit pointer to a 64-bit pointer. This is</span>
05038 <span class="comment">        necessary because all system service arguments are canonicalized</span>
05039 <span class="comment">        to 32 bits.</span>
05040 <span class="comment"></span>
05041 <span class="comment">    MemoryInformationClass - The memory information class about which</span>
05042 <span class="comment">        to retrieve information.</span>
05043 <span class="comment"></span>
05044 <span class="comment">    MemoryInformation - A pointer to a buffer that receives the</span>
05045 <span class="comment">        specified information.  The format and content of the buffer</span>
05046 <span class="comment">        depend on the specified information class.</span>
05047 <span class="comment"></span>
05048 <span class="comment"></span>
05049 <span class="comment">        MemoryBasicInformation - Data type is PMEMORY_BASIC_INFORMATION.</span>
05050 <span class="comment"></span>
05051 <span class="comment">            MEMORY_BASIC_INFORMATION Structure</span>
05052 <span class="comment"></span>
05053 <span class="comment"></span>
05054 <span class="comment">            ULONG RegionSize - The size of the region in bytes</span>
05055 <span class="comment">                beginning at the base address in which all pages have</span>
05056 <span class="comment">                identical attributes.</span>
05057 <span class="comment"></span>
05058 <span class="comment">            ULONG State - The state of the pages within the region.</span>
05059 <span class="comment"></span>
05060 <span class="comment">                State Values                        State Values</span>
05061 <span class="comment"></span>
05062 <span class="comment">                MEM_COMMIT - The state of the pages within the region</span>
05063 <span class="comment">                    is committed.</span>
05064 <span class="comment"></span>
05065 <span class="comment">                MEM_FREE - The state of the pages within the region</span>
05066 <span class="comment">                    is free.</span>
05067 <span class="comment"></span>
05068 <span class="comment">                MEM_RESERVE - The state of the pages within the</span>
05069 <span class="comment">                    region is reserved.</span>
05070 <span class="comment"></span>
05071 <span class="comment">            ULONG Protect - The protection of the pages within the</span>
05072 <span class="comment">                region.</span>
05073 <span class="comment"></span>
05074 <span class="comment"></span>
05075 <span class="comment">                Protect Values                        Protect Values</span>
05076 <span class="comment"></span>
05077 <span class="comment">                PAGE_NOACCESS - No access to the region of pages is</span>
05078 <span class="comment">                    allowed. An attempt to read, write, or execute</span>
05079 <span class="comment">                    within the region results in an access violation</span>
05080 <span class="comment">                    (i.e., a GP fault).</span>
05081 <span class="comment"></span>
05082 <span class="comment">                PAGE_EXECUTE - Execute access to the region of pages</span>
05083 <span class="comment">                    is allowed. An attempt to read or write within</span>
05084 <span class="comment">                    the region results in an access violation.</span>
05085 <span class="comment"></span>
05086 <span class="comment">                PAGE_READONLY - Read-only and execute access to the</span>
05087 <span class="comment">                    region of pages is allowed. An attempt to write</span>
05088 <span class="comment">                    within the region results in an access violation.</span>
05089 <span class="comment"></span>
05090 <span class="comment">                PAGE_READWRITE - Read, write, and execute access to</span>
05091 <span class="comment">                    the region of pages is allowed. If write access</span>
05092 <span class="comment">                    to the underlying section is allowed, then a</span>
05093 <span class="comment">                    single copy of the pages are shared. Otherwise,</span>
05094 <span class="comment">                    the pages are shared read-only/copy-on-write.</span>
05095 <span class="comment"></span>
05096 <span class="comment">                PAGE_GUARD - Read, write, and execute access to the</span>
05097 <span class="comment">                    region of pages is allowed; however, access to</span>
05098 <span class="comment">                    the region causes a "guard region entered"</span>
05099 <span class="comment">                    condition to be raised in the subject process.</span>
05100 <span class="comment"></span>
05101 <span class="comment">                PAGE_NOCACHE - Disable the placement of committed</span>
05102 <span class="comment">                    pages into the data cache.</span>
05103 <span class="comment"></span>
05104 <span class="comment">            ULONG Type - The type of pages within the region.</span>
05105 <span class="comment"></span>
05106 <span class="comment"></span>
05107 <span class="comment">                Type Values</span>
05108 <span class="comment"></span>
05109 <span class="comment">                MEM_PRIVATE - The pages within the region are</span>
05110 <span class="comment">                    private.</span>
05111 <span class="comment"></span>
05112 <span class="comment">                MEM_MAPPED - The pages within the region are mapped</span>
05113 <span class="comment">                    into the view of a section.</span>
05114 <span class="comment"></span>
05115 <span class="comment">                MEM_IMAGE - The pages within the region are mapped</span>
05116 <span class="comment">                    into the view of an image section.</span>
05117 <span class="comment"></span>
05118 <span class="comment">    MemoryInformationLength - Specifies the length in bytes  of</span>
05119 <span class="comment">        the memory information buffer.</span>
05120 <span class="comment"></span>
05121 <span class="comment">    ReturnLength - An optional pointer which, if specified,</span>
05122 <span class="comment">        receives the number of bytes placed in the process</span>
05123 <span class="comment">        information buffer.</span>
05124 <span class="comment"></span>
05125 <span class="comment"></span>
05126 <span class="comment">Return Value:</span>
05127 <span class="comment"></span>
05128 <span class="comment">    Returns the status</span>
05129 <span class="comment"></span>
05130 <span class="comment">    TBS</span>
05131 <span class="comment"></span>
05132 <span class="comment"></span>
05133 <span class="comment">Environment:</span>
05134 <span class="comment"></span>
05135 <span class="comment">    Kernel mode.</span>
05136 <span class="comment"></span>
05137 <span class="comment">--*/</span>
05138 
05139 {
05140     <a class="code" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> PreviousMode;
05141     <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> TargetProcess;
05142     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
05143     <a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a> Vad;
05144     PVOID64 Va;
05145     BOOLEAN Found = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
05146     ULONGLONG TheRegionSize;
05147     ULONG NewProtect;
05148     ULONG NewState;
05149     ULONG_PTR BaseVpn;
05150     PVOID64 BaseAddress;
05151 
05152     MEMORY_BASIC_INFORMATION_VLM Info;
05153 
05154     <span class="keywordflow">if</span> (MI_VLM_ENABLED() == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
05155         <span class="keywordflow">return</span> STATUS_NOT_IMPLEMENTED;
05156     }
05157 
05158     <span class="comment">//</span>
05159     <span class="comment">// The only supported option is MEMORY_BASIC_INFORMATION_VLM, make</span>
05160     <span class="comment">// sure the user's buffer is large enough for this.</span>
05161     <span class="comment">//</span>
05162 
05163     <span class="comment">//</span>
05164     <span class="comment">// Check argument validity.</span>
05165     <span class="comment">//</span>
05166     <span class="keywordflow">switch</span> (MemoryInformationClass) {
05167         <span class="keywordflow">case</span> MemoryBasicInformation:
05168                 <span class="keywordflow">if</span> (MemoryInformationLength &lt; <span class="keyword">sizeof</span>(MEMORY_BASIC_INFORMATION_VLM)) {
05169                     <span class="keywordflow">return</span> STATUS_INFO_LENGTH_MISMATCH;
05170                 }
05171                 <span class="keywordflow">break</span>;
05172 
05173         <span class="keywordflow">default</span>:
05174             <span class="keywordflow">return</span> STATUS_INVALID_INFO_CLASS;
05175     }
05176 
05177     PreviousMode = KeGetPreviousMode();
05178 
05179     <span class="keywordflow">if</span> (PreviousMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
05180 
05181         <span class="comment">//</span>
05182         <span class="comment">// Check arguments.</span>
05183         <span class="comment">//</span>
05184 
05185         <span class="keywordflow">try</span> {
05186             <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>(pBaseAddress, <span class="keyword">sizeof</span>(PVOID64), <span class="keyword">sizeof</span>(ULONG));
05187             BaseAddress = *pBaseAddress;
05188 
05189             <a class="code" href="../../d5/d8/ex_8h.html#a259">ProbeForWrite</a>(MemoryInformation,
05190                           MemoryInformationLength,
05191                           <span class="keyword">sizeof</span>(ULONGLONG));
05192 
05193             <span class="keywordflow">if</span> (ARGUMENT_PRESENT(ReturnLength)) {
05194                 <a class="code" href="../../d5/d8/ex_8h.html#a40">ProbeForWriteUlong</a>(ReturnLength);
05195             }
05196 
05197         } except (EXCEPTION_EXECUTE_HANDLER) {
05198 
05199             <span class="comment">//</span>
05200             <span class="comment">// If an exception occurs during the probe or capture</span>
05201             <span class="comment">// of the initial values, then handle the exception and</span>
05202             <span class="comment">// return the exception code as the status value.</span>
05203             <span class="comment">//</span>
05204 
05205             <span class="keywordflow">return</span> GetExceptionCode();
05206         }
05207     } <span class="keywordflow">else</span> {
05208         BaseAddress = *pBaseAddress;
05209     }
05210 
05211     <span class="keywordflow">if</span> (BaseAddress == (PVOID64)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05212         BaseAddress = (PVOID64)MM_LOWEST_USER_ADDRESS64;
05213     }
05214 
05215     <span class="keywordflow">if</span> ((BaseAddress &gt; (PVOID64)MM_HIGHEST_USER_ADDRESS64) ||
05216         (BaseAddress &lt; (PVOID64)MM_LOWEST_USER_ADDRESS64)) {
05217         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
05218     }
05219 
05220     <span class="keywordflow">if</span> ( ProcessHandle == NtCurrentProcess() ) {
05221         TargetProcess = <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>();
05222     } <span class="keywordflow">else</span> {
05223         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a> ( ProcessHandle,
05224                                              PROCESS_QUERY_INFORMATION,
05225                                              PsProcessType,
05226                                              PreviousMode,
05227                                              (PVOID *)&amp;TargetProcess,
05228                                              NULL );
05229 
05230         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status)) {
05231             <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
05232         }
05233     }
05234 
05235     <span class="comment">//</span>
05236     <span class="comment">// If the specified process is not the current process, attach</span>
05237     <span class="comment">// to the specified process.</span>
05238     <span class="comment">//</span>
05239 
05240     <a class="code" href="../../d3/d5/procobj_8c.html#a4">KeAttachProcess</a> (&amp;TargetProcess-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o0">Pcb</a>);
05241 
05242     <span class="comment">//</span>
05243     <span class="comment">// Get working set mutex and block APCs.</span>
05244     <span class="comment">//</span>
05245 
05246     <a class="code" href="../../d4/d8/mi_8h.html#a161">LOCK_WS_AND_ADDRESS_SPACE</a> (TargetProcess);
05247 
05248     <span class="comment">//</span>
05249     <span class="comment">// Make sure the address space was not deleted, if so, return an error.</span>
05250     <span class="comment">//</span>
05251 
05252     <span class="keywordflow">if</span> (TargetProcess-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o27">AddressSpaceDeleted</a> != 0) {
05253         <a class="code" href="../../d4/d8/mi_8h.html#a158">UNLOCK_WS</a> (TargetProcess);
05254         <a class="code" href="../../d4/d8/mi_8h.html#a163">UNLOCK_ADDRESS_SPACE</a> (TargetProcess);
05255         <a class="code" href="../../d3/d5/procobj_8c.html#a7">KeDetachProcess</a>();
05256         <span class="keywordflow">if</span> ( ProcessHandle != NtCurrentProcess() ) {
05257             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a> (TargetProcess);
05258         }
05259         <span class="keywordflow">return</span> STATUS_PROCESS_IS_TERMINATING;
05260     }
05261 
05262     <span class="keywordflow">if</span> (TargetProcess-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o32">ForkWasSuccessful</a> != MM_NO_FORK_ALLOWED) {
05263         Vad = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05264     } <span class="keywordflow">else</span> {
05265         Vad = TargetProcess-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o40">CloneRoot</a>;
05266     }
05267 
05268     <span class="comment">//</span>
05269     <span class="comment">// Locate the VAD that contains the base address or the VAD</span>
05270     <span class="comment">// which follows the base address.</span>
05271     <span class="comment">//</span>
05272 
05273     BaseVpn = MI_VA_TO_VPN64 (BaseAddress);
05274 
05275     <span class="keywordflow">for</span> (;;) {
05276 
05277         <span class="keywordflow">if</span> (Vad == (<a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a>)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05278             <span class="keywordflow">break</span>;
05279         }
05280 
05281         <span class="keywordflow">if</span> ((BaseVpn &gt;= Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o0">StartingVpn</a>) &amp;&amp;
05282             (BaseVpn &lt;= Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o1">EndingVpn</a>)) {
05283             Found = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
05284             <span class="keywordflow">break</span>;
05285         }
05286 
05287         <span class="keywordflow">if</span> (BaseVpn &lt; Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o0">StartingVpn</a>) {
05288             <span class="keywordflow">if</span> (Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o3">LeftChild</a> == (<a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a>)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05289                 <span class="keywordflow">break</span>;
05290             }
05291             Vad = Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o3">LeftChild</a>;
05292 
05293         } <span class="keywordflow">else</span> {
05294             <span class="keywordflow">if</span> (BaseVpn &lt; Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o1">EndingVpn</a>) {
05295                 <span class="keywordflow">break</span>;
05296             }
05297             <span class="keywordflow">if</span> (Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o4">RightChild</a> == (<a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a>)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05298                 <span class="keywordflow">break</span>;
05299             }
05300             Vad = Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o4">RightChild</a>;
05301         }
05302     }
05303 
05304     <span class="keywordflow">if</span> (!Found) {
05305 
05306         <span class="comment">//</span>
05307         <span class="comment">// There is no virtual address allocated at the base</span>
05308         <span class="comment">// address.  Return the size of the hole starting at</span>
05309         <span class="comment">// the base address.</span>
05310         <span class="comment">//</span>
05311 
05312         <span class="keywordflow">if</span> (Vad == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05313             TheRegionSize = MM_LARGEST_VLM_RANGE + 1;
05314         } <span class="keywordflow">else</span> {
05315             <span class="keywordflow">if</span> (Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o0">StartingVpn</a> &lt; BaseVpn) {
05316 
05317                 <span class="comment">//</span>
05318                 <span class="comment">// We are looking at the Vad which occupies the range</span>
05319                 <span class="comment">// just before the desired range.  Get the next Vad.</span>
05320                 <span class="comment">//</span>
05321 
05322                 Vad = <a class="code" href="../../d4/d8/mi_8h.html#a96">MiGetNextVad</a> (Vad);
05323                 <span class="keywordflow">if</span> (Vad == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05324                     TheRegionSize = (ULONGLONG)<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a53">MM_HIGHEST_VAD_ADDRESS64</a> -
05325                                                 (ULONGLONG)PAGE_ALIGN64(BaseAddress);
05326                 } <span class="keywordflow">else</span> {
05327                     TheRegionSize = (ULONGLONG)MI_VPN_TO_VA64 (Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o0">StartingVpn</a>) -
05328                                                 (ULONGLONG)PAGE_ALIGN64(BaseAddress);
05329                 }
05330             } <span class="keywordflow">else</span> {
05331                 TheRegionSize = (ULONGLONG)MI_VPN_TO_VA64 (Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o0">StartingVpn</a>) -
05332                                                 (ULONGLONG)PAGE_ALIGN64(BaseAddress);
05333             }
05334         }
05335 
05336         <a class="code" href="../../d4/d8/mi_8h.html#a158">UNLOCK_WS</a> (TargetProcess);
05337         <a class="code" href="../../d4/d8/mi_8h.html#a163">UNLOCK_ADDRESS_SPACE</a> (TargetProcess);
05338         <a class="code" href="../../d3/d5/procobj_8c.html#a7">KeDetachProcess</a>();
05339 
05340         <span class="keywordflow">if</span> (ProcessHandle != NtCurrentProcess()) {
05341             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a> (TargetProcess);
05342         }
05343 
05344         <span class="comment">//</span>
05345         <span class="comment">// Establish an exception handler and write the information and</span>
05346         <span class="comment">// returned length.</span>
05347         <span class="comment">//</span>
05348 
05349         <span class="keywordflow">if</span> (MemoryInformationClass == MemoryBasicInformation) {
05350             <span class="keywordflow">try</span> {
05351 
05352                 ((PMEMORY_BASIC_INFORMATION_VLM)MemoryInformation)-&gt;AllocationBase =
05353                                          (PVOID64)MM_LOWEST_USER_ADDRESS64;
05354                 ((PMEMORY_BASIC_INFORMATION_VLM)MemoryInformation)-&gt;AllocationProtect =
05355                                                                             0;
05356                 ((PMEMORY_BASIC_INFORMATION_VLM)MemoryInformation)-&gt;BaseAddressAsUlongLong =
05357                                          (ULONGLONG)PAGE_ALIGN64(BaseAddress);
05358                 ((PMEMORY_BASIC_INFORMATION_VLM)MemoryInformation)-&gt;RegionSize =
05359                                                                     TheRegionSize;
05360                 ((PMEMORY_BASIC_INFORMATION_VLM)MemoryInformation)-&gt;State = MEM_FREE;
05361                 ((PMEMORY_BASIC_INFORMATION_VLM)MemoryInformation)-&gt;Protect = PAGE_NOACCESS;
05362                 ((PMEMORY_BASIC_INFORMATION_VLM)MemoryInformation)-&gt;Type = 0;
05363 
05364                 <span class="keywordflow">if</span> (ARGUMENT_PRESENT(ReturnLength)) {
05365                     *ReturnLength = <span class="keyword">sizeof</span>(MEMORY_BASIC_INFORMATION_VLM);
05366                 }
05367 
05368             } except (EXCEPTION_EXECUTE_HANDLER) {
05369 
05370                 <span class="comment">//</span>
05371                 <span class="comment">// Just return success.</span>
05372                 <span class="comment">//</span>
05373             }
05374 
05375             <span class="keywordflow">return</span> STATUS_SUCCESS;
05376         }
05377         <span class="keywordflow">return</span> STATUS_INVALID_ADDRESS;
05378     }
05379 
05380     <span class="comment">//</span>
05381     <span class="comment">// Found a vad.</span>
05382     <span class="comment">//</span>
05383 
05384     Va = PAGE_ALIGN64(BaseAddress);
05385     Info.BaseAddress = Va;
05386 
05387     <span class="comment">//</span>
05388     <span class="comment">//</span>
05389     <span class="comment">// There is a page mapped at the base address.</span>
05390     <span class="comment">//</span>
05391 
05392     <span class="keywordflow">if</span> (Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.VadFlags.PrivateMemory) {
05393         Info.Type = MEM_PRIVATE;
05394     } <span class="keywordflow">else</span> {
05395         Info.Type = MEM_MAPPED;
05396     }
05397 
05398     Info.State = MiQueryAddressState64 (Va, Vad, TargetProcess, &amp;Info.Protect);
05399 
05400     Va = (PVOID64)((ULONGLONG)Va + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
05401 
05402     <span class="keywordflow">while</span> (MI_VA_TO_VPN64 (Va) &lt;= Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o1">EndingVpn</a>) {
05403 
05404         NewState = MiQueryAddressState64 (Va,
05405                                         Vad,
05406                                         TargetProcess,
05407                                         &amp;NewProtect);
05408 
05409         <span class="keywordflow">if</span> ((NewState != Info.State) || (NewProtect != Info.Protect)) {
05410 
05411             <span class="comment">//</span>
05412             <span class="comment">// The state for this address does not match, calculate</span>
05413             <span class="comment">// size and return.</span>
05414             <span class="comment">//</span>
05415 
05416             <span class="keywordflow">break</span>;
05417         }
05418         Va = (PVOID64)((ULONGLONG)Va + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
05419     } <span class="comment">// end while</span>
05420 
05421     Info.RegionSize = ((ULONGLONG)Va - (ULONGLONG)Info.BaseAddress);
05422     Info.AllocationBase = MI_VPN_TO_VA64 (Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o0">StartingVpn</a>);
05423     Info.AllocationProtect = <a class="code" href="../../d4/d8/mi_8h.html#a86">MI_CONVERT_FROM_PTE_PROTECTION</a> (
05424                                              Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.VadFlags.Protection);
05425 
05426     <span class="comment">//</span>
05427     <span class="comment">// A range has been found, release the mutexes, detach from the</span>
05428     <span class="comment">// target process and return the information.</span>
05429     <span class="comment">//</span>
05430 
05431     <a class="code" href="../../d4/d8/mi_8h.html#a158">UNLOCK_WS</a> (TargetProcess);
05432     <a class="code" href="../../d4/d8/mi_8h.html#a163">UNLOCK_ADDRESS_SPACE</a> (TargetProcess);
05433     <a class="code" href="../../d3/d5/procobj_8c.html#a7">KeDetachProcess</a>();
05434 
05435     <span class="keywordflow">if</span> ( ProcessHandle != NtCurrentProcess() ) {
05436         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a> (TargetProcess);
05437     }
05438 
05439 
05440     <span class="keywordflow">if</span> ( MemoryInformationClass == MemoryBasicInformation ) {
05441         <span class="keywordflow">try</span> {
05442 
05443             *(PMEMORY_BASIC_INFORMATION_VLM)MemoryInformation = Info;
05444 
05445             <span class="keywordflow">if</span> (ARGUMENT_PRESENT(ReturnLength)) {
05446                 *ReturnLength = <span class="keyword">sizeof</span>(MEMORY_BASIC_INFORMATION_VLM);
05447             }
05448 
05449         } except (EXCEPTION_EXECUTE_HANDLER) {
05450             NOTHING;
05451         }
05452         <span class="keywordflow">return</span> STATUS_SUCCESS;
05453     }
05454     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
05455 }
05456 
05457 
05458 
05459 ULONG
05460 MiQueryAddressState64 (
05461     IN PVOID64 Va,
05462     IN <a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a> Vad,
05463     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> TargetProcess,
05464     OUT PULONG ReturnedProtect
05465     )
05466 
05467 <span class="comment">/*++</span>
05468 <span class="comment"></span>
05469 <span class="comment">Routine Description:</span>
05470 <span class="comment"></span>
05471 <span class="comment"></span>
05472 <span class="comment">Arguments:</span>
05473 <span class="comment"></span>
05474 <span class="comment">Return Value:</span>
05475 <span class="comment"></span>
05476 <span class="comment">    Returns the state (MEM_COMMIT, MEM_RESERVE, MEM_PRIVATE).</span>
05477 <span class="comment"></span>
05478 <span class="comment">Environment:</span>
05479 <span class="comment"></span>
05480 <span class="comment">    Kernel mode.  Working set lock and address creation lock held.</span>
05481 <span class="comment"></span>
05482 <span class="comment">--*/</span>
05483 
05484 {
05485     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
05486     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPde;
05487     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> CapturedProtoPte;
05488     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> ProtoPte;
05489     LOGICAL PteIsZero;
05490     ULONG State;
05491     ULONG Protect;
05492     ULONG VadProtect;
05493 
05494     VadProtect = <a class="code" href="../../d4/d8/mi_8h.html#a86">MI_CONVERT_FROM_PTE_PROTECTION</a> (Vad-&gt;u.VadFlags.Protection);
05495 <span class="preprocessor">#ifdef LARGE_PAGES</span>
05496 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (Vad-&gt;u.VadFlags.LargePages) {
05497         *ReturnedProtect = VadProtect;
05498         <span class="keywordflow">return</span> MEM_COMMIT;
05499     }
05500 <span class="preprocessor">#endif //LARGE_PAGES</span>
05501 <span class="preprocessor"></span>
05502     PointerPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a152">MiGetPdeAddress64</a> (Va);
05503     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a154">MiGetPteAddress64</a> (Va);
05504 
05505     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((Vad-&gt;StartingVpn &lt;= MI_VA_TO_VPN64 (Va)) &amp;&amp;
05506             (Vad-&gt;EndingVpn &gt;= MI_VA_TO_VPN64 (Va)));
05507 
05508     PteIsZero = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
05509 
05510     <span class="comment">//</span>
05511     <span class="comment">// Note that if the PDE and PTE are not valid, then we must be</span>
05512     <span class="comment">// in a no-access guard page type VAD.</span>
05513     <span class="comment">//</span>
05514     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d2/pagfault_8c.html#a26">MmIsAddressValid</a> (PointerPde) &amp;&amp; <a class="code" href="../../d8/d2/pagfault_8c.html#a26">MmIsAddressValid</a>(PointerPte)) {
05515 
05516         <span class="comment">//</span>
05517         <span class="comment">// A PTE exists at this address, see if it is zero.</span>
05518         <span class="comment">//</span>
05519 
05520         <span class="keywordflow">if</span> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long != 0) {
05521 
05522             PteIsZero = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
05523 
05524             <span class="comment">//</span>
05525             <span class="comment">// There is a non-zero PTE at this address, use</span>
05526             <span class="comment">// it to build the information block.</span>
05527             <span class="comment">//</span>
05528 
05529             <span class="keywordflow">if</span> (<a class="code" href="../../d0/d2/mmsup_8c.html#a3">MiIsPteDecommittedPage</a> (PointerPte)) {
05530                 Protect = 0;
05531                 State = MEM_RESERVE;
05532             } <span class="keywordflow">else</span> {
05533 
05534                 State = MEM_COMMIT;
05535 
05536                 Protect = PAGE_READWRITE;
05537                 <span class="keywordflow">if</span> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1) {
05538                     <span class="keywordflow">if</span> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Write == 0) {
05539                         Protect = PAGE_READONLY;
05540                     }
05541                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Prototype) {
05542                     Protect = VadProtect;
05543 
05544                     <span class="keywordflow">if</span> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.PageFileHigh == <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a181">MI_PTE_LOOKUP_NEEDED</a>) {
05545                         Protect = <a class="code" href="../../d4/d8/mi_8h.html#a86">MI_CONVERT_FROM_PTE_PROTECTION</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Protection);
05546                     }
05547 
05548                     ProtoPte = <a class="code" href="../../d4/d8/mi_8h.html#a246">MiGetProtoPteAddress</a>(Vad,
05549                                                 MI_VA_TO_VPN64 (Va));
05550                     CapturedProtoPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long = 0;
05551                     <span class="keywordflow">if</span> (ProtoPte) {
05552                         CapturedProtoPte = <a class="code" href="../../d5/d3/queryvm_8c.html#a2">MiCaptureSystemPte</a> (ProtoPte,
05553                                                            TargetProcess);
05554                     }
05555                     <span class="keywordflow">if</span> (CapturedProtoPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long == 0) {
05556                         State = MEM_RESERVE;
05557                         Protect = 0;
05558                     }
05559 
05560                 } <span class="keywordflow">else</span> {
05561                     Protect = <a class="code" href="../../d4/d8/mi_8h.html#a86">MI_CONVERT_FROM_PTE_PROTECTION</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Protection);
05562                 }
05563             }
05564         }
05565     }
05566 
05567     <span class="keywordflow">if</span> (PteIsZero == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
05568 
05569         <span class="comment">//</span>
05570         <span class="comment">// There is no PDE at this address, the template from</span>
05571         <span class="comment">// the VAD supplies the information unless the VAD is</span>
05572         <span class="comment">// for an image file.  For image files the individual</span>
05573         <span class="comment">// protection is on the prototype PTE.</span>
05574         <span class="comment">//</span>
05575 
05576         <span class="comment">//</span>
05577         <span class="comment">// Get the default protection information.</span>
05578         <span class="comment">//</span>
05579 
05580         State = MEM_RESERVE;
05581         Protect = 0;
05582 
05583         <span class="keywordflow">if</span> ((Vad-&gt;u.VadFlags.PrivateMemory == 0) &amp;&amp;
05584             (Vad-&gt;ControlArea != (<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html">PCONTROL_AREA</a>)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
05585 
05586             <span class="comment">//</span>
05587             <span class="comment">// This VAD refers to a section.  Even though the PTE is</span>
05588             <span class="comment">// zero, the actual page may be committed in the section.</span>
05589             <span class="comment">//</span>
05590 
05591             ProtoPte = <a class="code" href="../../d4/d8/mi_8h.html#a246">MiGetProtoPteAddress</a>(Vad, MI_VA_TO_VPN64 (Va));
05592 
05593             CapturedProtoPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long = 0;
05594             <span class="keywordflow">if</span> (ProtoPte) {
05595                 CapturedProtoPte = <a class="code" href="../../d5/d3/queryvm_8c.html#a2">MiCaptureSystemPte</a> (ProtoPte,
05596                                                        TargetProcess);
05597             }
05598 
05599             <span class="keywordflow">if</span> (CapturedProtoPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long != 0) {
05600                 State = MEM_COMMIT;
05601                 Protect = VadProtect;
05602             }
05603 
05604         } <span class="keywordflow">else</span> {
05605 
05606             <span class="comment">//</span>
05607             <span class="comment">// Get the protection from the corresponding VAD.</span>
05608             <span class="comment">//</span>
05609 
05610             <span class="keywordflow">if</span> (Vad-&gt;u.VadFlags.MemCommit) {
05611                 State = MEM_COMMIT;
05612                 Protect = VadProtect;
05613             }
05614         }
05615     }
05616 
05617     *ReturnedProtect = Protect;
05618     <span class="keywordflow">return</span> State;
05619 }
05620 
05621 
05622 <span class="preprocessor">#else</span>
05623 <span class="preprocessor"></span>
05624 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l05625"></a><a class="code" href="../../d5/d6/vlm_8c.html#a1">05625</a> <a class="code" href="../../d5/d6/vlm_8c.html#a1">NtAllocateVirtualMemory64</a> (
05626     IN HANDLE ProcessHandle,
05627     IN OUT PVOID64 *BaseAddress,
05628     IN ULONG ZeroBits,
05629     IN OUT PULONGLONG RegionSize,
05630     IN ULONG AllocationType,
05631     IN ULONG Protect
05632     )
05633 {
05634     <span class="keywordflow">return</span> STATUS_NOT_IMPLEMENTED;
05635 }
05636 
05637 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l05638"></a><a class="code" href="../../d5/d6/vlm_8c.html#a2">05638</a> <a class="code" href="../../d5/d6/vlm_8c.html#a2">NtFreeVirtualMemory64</a>(
05639     IN HANDLE ProcessHandle,
05640     IN OUT PVOID64 *BaseAddress,
05641     IN OUT PULONGLONG RegionSize,
05642     IN ULONG FreeType
05643     )
05644 {
05645     <span class="keywordflow">return</span> STATUS_NOT_IMPLEMENTED;
05646 }
05647 
05648 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l05649"></a><a class="code" href="../../d5/d6/vlm_8c.html#a3">05649</a> <a class="code" href="../../d5/d6/vlm_8c.html#a3">NtMapViewOfVlmSection</a> (
05650     IN HANDLE SectionHandle,
05651     IN HANDLE ProcessHandle,
05652     IN OUT PVOID64 *BaseAddress,
05653     IN OUT PULONGLONG SectionOffset OPTIONAL,
05654     IN OUT PULONGLONG ViewSize,
05655     IN ULONG AllocationType,
05656     IN ULONG Protect
05657     )
05658 {
05659     <span class="keywordflow">return</span> STATUS_NOT_IMPLEMENTED;
05660 }
05661 
05662 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l05663"></a><a class="code" href="../../d5/d6/vlm_8c.html#a4">05663</a> <a class="code" href="../../d5/d6/vlm_8c.html#a4">NtUnmapViewOfVlmSection</a>(
05664     IN HANDLE ProcessHandle,
05665     IN OUT PVOID64 *BaseAddress
05666     )
05667 {
05668     <span class="keywordflow">return</span> STATUS_NOT_IMPLEMENTED;
05669 }
05670 
05671 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l05672"></a><a class="code" href="../../d5/d6/vlm_8c.html#a5">05672</a> <a class="code" href="../../d5/d6/vlm_8c.html#a5">NtQueryVirtualMemory64</a>(
05673     IN HANDLE ProcessHandle,
05674     IN PVOID64 *pBaseAddress,
05675     IN MEMORY_INFORMATION_CLASS MemoryInformationClass,
05676     OUT PVOID MemoryInformation,
05677     IN ULONG MemoryInformationLength,
05678     OUT PULONG ReturnLength OPTIONAL
05679     )
05680 {
05681     <span class="keywordflow">return</span> STATUS_NOT_IMPLEMENTED;
05682 }
05683 
05684 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l05685"></a><a class="code" href="../../d5/d6/vlm_8c.html#a6">05685</a> <a class="code" href="../../d5/d6/vlm_8c.html#a6">NtProtectVirtualMemory64</a>(
05686     IN HANDLE ProcessHandle,
05687     IN OUT PVOID64 *BaseAddress,
05688     IN OUT PULONGLONG RegionSize,
05689     IN ULONG NewProtect,
05690     OUT PULONG OldProtect
05691     )
05692 
05693 {
05694     <span class="keywordflow">return</span> STATUS_NOT_IMPLEMENTED;
05695 }
05696 
05697 <span class="preprocessor">#endif //VLM_SUPPORT</span>
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:42:24 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
