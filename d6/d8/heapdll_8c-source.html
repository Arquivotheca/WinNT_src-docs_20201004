<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: heapdll.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>heapdll.c</h1><a href="../../d5/d9/heapdll_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1989  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    heapdll.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module implements the user mode only portions of the heap allocator.</span>
00012 <span class="comment"></span>
00013 <span class="comment">Author:</span>
00014 <span class="comment"></span>
00015 <span class="comment">    Steve Wood (stevewo) 20-Sep-1994</span>
00016 <span class="comment"></span>
00017 <span class="comment">Revision History:</span>
00018 <span class="comment"></span>
00019 <span class="comment">--*/</span>
00020 
00021 <span class="preprocessor">#include "<a class="code" href="../../d5/d9/ntrtlp_8h.html">ntrtlp.h</a>"</span>
00022 <span class="preprocessor">#include "<a class="code" href="../../d3/d9/heap_8h.html">heap.h</a>"</span>
00023 <span class="preprocessor">#include "<a class="code" href="../../d9/d9/heappriv_8h.html">heappriv.h</a>"</span>
00024 
00025 <span class="preprocessor">#ifdef NTHEAP_ENABLED</span>
00026 <span class="preprocessor"></span><span class="preprocessor">#include "heapp.h"</span>
00027 <span class="preprocessor">#endif // NTHEAP_ENABLED</span>
00028 <span class="preprocessor"></span>
00029 
00030 <span class="comment">//</span>
00031 <span class="comment">//  This structure is used by RtlUsageHeap to keep track of heap usage</span>
00032 <span class="comment">//  between calls.  This package typecasts an extra reserved buffer passed</span>
00033 <span class="comment">//  in by the user to hold this information</span>
00034 <span class="comment">//</span>
00035 
<a name="l00036"></a><a class="code" href="../../d7/d5/struct__RTL__HEAP__USAGE__INTERNAL.html">00036</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d7/d5/struct__RTL__HEAP__USAGE__INTERNAL.html">_RTL_HEAP_USAGE_INTERNAL</a> {
<a name="l00037"></a><a class="code" href="../../d7/d5/struct__RTL__HEAP__USAGE__INTERNAL.html#o0">00037</a>     PVOID <a class="code" href="../../d7/d5/struct__RTL__HEAP__USAGE__INTERNAL.html#o0">Base</a>;
<a name="l00038"></a><a class="code" href="../../d7/d5/struct__RTL__HEAP__USAGE__INTERNAL.html#o1">00038</a>     SIZE_T <a class="code" href="../../d7/d5/struct__RTL__HEAP__USAGE__INTERNAL.html#o1">ReservedSize</a>;
<a name="l00039"></a><a class="code" href="../../d7/d5/struct__RTL__HEAP__USAGE__INTERNAL.html#o2">00039</a>     SIZE_T <a class="code" href="../../d7/d5/struct__RTL__HEAP__USAGE__INTERNAL.html#o2">CommittedSize</a>;
<a name="l00040"></a><a class="code" href="../../d7/d5/struct__RTL__HEAP__USAGE__INTERNAL.html#o3">00040</a>     PRTL_HEAP_USAGE_ENTRY <a class="code" href="../../d7/d5/struct__RTL__HEAP__USAGE__INTERNAL.html#o3">FreeList</a>;
<a name="l00041"></a><a class="code" href="../../d7/d5/struct__RTL__HEAP__USAGE__INTERNAL.html#o4">00041</a>     PRTL_HEAP_USAGE_ENTRY <a class="code" href="../../d7/d5/struct__RTL__HEAP__USAGE__INTERNAL.html#o4">LargeEntriesSentinal</a>;
<a name="l00042"></a><a class="code" href="../../d7/d5/struct__RTL__HEAP__USAGE__INTERNAL.html#o5">00042</a>     ULONG <a class="code" href="../../d7/d5/struct__RTL__HEAP__USAGE__INTERNAL.html#o5">Reserved</a>;
00043 } <a class="code" href="../../d7/d5/struct__RTL__HEAP__USAGE__INTERNAL.html">RTL_HEAP_USAGE_INTERNAL</a>, *<a class="code" href="../../d7/d5/struct__RTL__HEAP__USAGE__INTERNAL.html">PRTL_HEAP_USAGE_INTERNAL</a>;
00044 
00045 
00046 <span class="comment">//</span>
00047 <span class="comment">//  Note that the following variables are specific to each process</span>
00048 <span class="comment">//</span>
00049 <span class="comment">//</span>
00050 <span class="comment">//  This is a lock used to protect access the this processes heap list</span>
00051 <span class="comment">//</span>
00052 
<a name="l00053"></a><a class="code" href="../../d5/d9/heapdll_8c.html#a3">00053</a> <a class="code" href="../../d4/d6/struct__HEAP__LOCK.html">HEAP_LOCK</a> <a class="code" href="../../d5/d9/heapdll_8c.html#a3">RtlpProcessHeapsListLock</a>;
00054 
00055 <span class="comment">//</span>
00056 <span class="comment">//  This is a specific list of heaps initialized and used by the process</span>
00057 <span class="comment">//</span>
00058 
<a name="l00059"></a><a class="code" href="../../d5/d9/heapdll_8c.html#a0">00059</a> <span class="preprocessor">#define RTLP_STATIC_HEAP_LIST_SIZE 16</span>
00060 <span class="preprocessor"></span>
<a name="l00061"></a><a class="code" href="../../d5/d9/heapdll_8c.html#a4">00061</a> <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> <a class="code" href="../../d5/d9/heapdll_8c.html#a4">RtlpProcessHeapsListBuffer</a>[ <a class="code" href="../../d5/d9/heapdll_8c.html#a0">RTLP_STATIC_HEAP_LIST_SIZE</a> ];
00062 
00063 <span class="comment">//</span>
00064 <span class="comment">//  This variable stores a pointer to the heap used to storage global heap</span>
00065 <span class="comment">//  tags</span>
00066 <span class="comment">//</span>
00067 
<a name="l00068"></a><a class="code" href="../../d5/d9/heapdll_8c.html#a5">00068</a> <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> <a class="code" href="../../d3/d9/heap_8h.html#a64">RtlpGlobalTagHeap</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00069 
00070 <span class="comment">//</span>
00071 <span class="comment">//  This varible is used by the process as work space to build up names for</span>
00072 <span class="comment">//  pseudo tags</span>
00073 <span class="comment">//</span>
00074 
<a name="l00075"></a><a class="code" href="../../d5/d9/heapdll_8c.html#a6">00075</a> <span class="keyword">static</span> WCHAR <a class="code" href="../../d5/d9/heapdll_8c.html#a6">RtlpPseudoTagNameBuffer</a>[ 24 ];
00076 
00077 BOOLEAN
00078 <a class="code" href="../../d5/d9/heapdll_8c.html#a7">RtlpGrowBlockInPlace</a> (
00079     IN <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap,
00080     IN ULONG Flags,
00081     IN <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a> BusyBlock,
00082     IN SIZE_T Size,
00083     IN SIZE_T AllocationIndex
00084     );
00085 
00086 PVOID
00087 <a class="code" href="../../d5/d9/heapdll_8c.html#a8">RtlDebugReAllocateHeap</a> (
00088     IN PVOID HeapHandle,
00089     IN ULONG Flags,
00090     IN PVOID BaseAddress,
00091     IN SIZE_T Size
00092     );
00093 
00094 BOOLEAN
00095 <a class="code" href="../../d5/d9/heapdll_8c.html#a9">RtlDebugGetUserInfoHeap</a> (
00096     IN PVOID HeapHandle,
00097     IN ULONG Flags,
00098     IN PVOID BaseAddress,
00099     OUT PVOID *UserValue OPTIONAL,
00100     OUT PULONG UserFlags OPTIONAL
00101     );
00102 
00103 BOOLEAN
00104 <a class="code" href="../../d5/d9/heapdll_8c.html#a10">RtlDebugSetUserValueHeap</a> (
00105     IN PVOID HeapHandle,
00106     IN ULONG Flags,
00107     IN PVOID BaseAddress,
00108     IN PVOID UserValue
00109     );
00110 
00111 BOOLEAN
00112 <a class="code" href="../../d5/d9/heapdll_8c.html#a11">RtlDebugSetUserFlagsHeap</a> (
00113     IN PVOID HeapHandle,
00114     IN ULONG Flags,
00115     IN PVOID BaseAddress,
00116     IN ULONG UserFlagsReset,
00117     IN ULONG UserFlagsSet
00118     );
00119 
00120 SIZE_T
00121 <a class="code" href="../../d5/d9/heapdll_8c.html#a12">RtlDebugCompactHeap</a> (
00122     IN PVOID HeapHandle,
00123     IN ULONG Flags
00124     );
00125 
00126 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00127 <a class="code" href="../../d5/d9/heapdll_8c.html#a13">RtlDebugCreateTagHeap</a> (
00128     IN PVOID HeapHandle,
00129     IN ULONG Flags,
00130     IN PWSTR TagPrefix OPTIONAL,
00131     IN PWSTR TagNames
00132     );
00133 
00134 PWSTR
00135 <a class="code" href="../../d5/d9/heapdll_8c.html#a14">RtlDebugQueryTagHeap</a> (
00136     IN PVOID HeapHandle,
00137     IN ULONG Flags,
00138     IN USHORT TagIndex,
00139     IN BOOLEAN ResetCounters,
00140     OUT PRTL_HEAP_TAG_INFO TagInfo OPTIONAL
00141     );
00142 
00143 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00144 <a class="code" href="../../d5/d9/heapdll_8c.html#a15">RtlDebugUsageHeap</a> (
00145     IN PVOID HeapHandle,
00146     IN ULONG Flags,
00147     IN OUT PRTL_HEAP_USAGE Usage
00148     );
00149 
00150 BOOLEAN
00151 <a class="code" href="../../d5/d9/heapdll_8c.html#a16">RtlDebugWalkHeap</a> (
00152     IN PVOID HeapHandle,
00153     IN OUT PRTL_HEAP_WALK_ENTRY Entry
00154     );
00155 
00156 <a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html">PHEAP_TAG_ENTRY</a>
00157 <a class="code" href="../../d5/d9/heapdll_8c.html#a17">RtlpAllocateTags</a> (
00158     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap,
00159     ULONG NumberOfTags
00160     );
00161 
00162 PRTL_HEAP_USAGE_ENTRY
00163 <a class="code" href="../../d5/d9/heapdll_8c.html#a18">RtlpFreeHeapUsageEntry</a> (
00164     PRTL_HEAP_USAGE_INTERNAL Buffer,
00165     PRTL_HEAP_USAGE_ENTRY p
00166     );
00167 
00168 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00169 <a class="code" href="../../d5/d9/heapdll_8c.html#a19">RtlpAllocateHeapUsageEntry</a> (
00170     PRTL_HEAP_USAGE_INTERNAL Buffer,
00171     PRTL_HEAP_USAGE_ENTRY *pp
00172     );
00173 
00174 <span class="comment">//</span>
00175 <span class="comment">//  Declared in ntrtl.h</span>
00176 <span class="comment">//</span>
00177 
00178 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00179"></a><a class="code" href="../../d5/d9/heapdll_8c.html#a20">00179</a> <a class="code" href="../../d5/d9/heapdll_8c.html#a20">RtlInitializeHeapManager</a>(
00180     VOID
00181     )
00182 
00183 <span class="comment">/*++</span>
00184 <span class="comment"></span>
00185 <span class="comment">Routine Description:</span>
00186 <span class="comment"></span>
00187 <span class="comment">    This routine is used to initialize the heap manager for the current process</span>
00188 <span class="comment"></span>
00189 <span class="comment">Arguments:</span>
00190 <span class="comment"></span>
00191 <span class="comment">    None.</span>
00192 <span class="comment"></span>
00193 <span class="comment">Return Value:</span>
00194 <span class="comment"></span>
00195 <span class="comment">    None.</span>
00196 <span class="comment"></span>
00197 <span class="comment">--*/</span>
00198 
00199 {
00200     PPEB Peb = NtCurrentPeb();
00201 
00202 <span class="preprocessor">#if DBG</span>
00203 <span class="preprocessor"></span>
00204     <span class="comment">//</span>
00205     <span class="comment">//  Sanity check the sizes of the header entry structures</span>
00206     <span class="comment">//</span>
00207 
00208     <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>( <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">HEAP_ENTRY</a> ) != <span class="keyword">sizeof</span>( <a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html">HEAP_ENTRY_EXTRA</a> )) {
00209 
00210         <a class="code" href="../../d9/d9/heappriv_8h.html#a10">HeapDebugPrint</a>(( <span class="stringliteral">"Heap header and extra header sizes disagree\n"</span> ));
00211 
00212         <a class="code" href="../../d9/d9/heappriv_8h.html#a11">HeapDebugBreak</a>( <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00213     }
00214 
00215     <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>( <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">HEAP_ENTRY</a> ) != <a class="code" href="../../d3/d9/heap_8h.html#a25">CHECK_HEAP_TAIL_SIZE</a>) {
00216 
00217         <a class="code" href="../../d9/d9/heappriv_8h.html#a10">HeapDebugPrint</a>(( <span class="stringliteral">"Heap header and tail fill sizes disagree\n"</span> ));
00218 
00219         <a class="code" href="../../d9/d9/heappriv_8h.html#a11">HeapDebugBreak</a>( <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00220     }
00221 
00222     <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>( <a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">HEAP_FREE_ENTRY</a> ) != (2 * <span class="keyword">sizeof</span>( <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">HEAP_ENTRY</a> ))) {
00223 
00224         <a class="code" href="../../d9/d9/heappriv_8h.html#a10">HeapDebugPrint</a>(( <span class="stringliteral">"Heap header and free header sizes disagree\n"</span> ));
00225 
00226         <a class="code" href="../../d9/d9/heappriv_8h.html#a11">HeapDebugBreak</a>( <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00227     }
00228 
00229 <span class="preprocessor">#endif // DBG</span>
00230 <span class="preprocessor"></span>
00231     <span class="comment">//</span>
00232     <span class="comment">//  Initialize the heap specific structures in the current peb</span>
00233     <span class="comment">//</span>
00234 
00235     Peb-&gt;NumberOfHeaps = 0;
00236     Peb-&gt;MaximumNumberOfHeaps = <a class="code" href="../../d5/d9/heapdll_8c.html#a0">RTLP_STATIC_HEAP_LIST_SIZE</a>;
00237     Peb-&gt;ProcessHeaps = <a class="code" href="../../d5/d9/heapdll_8c.html#a4">RtlpProcessHeapsListBuffer</a>;
00238 
00239 <span class="preprocessor">#ifdef NTHEAP_ENABLED</span>
00240 <span class="preprocessor"></span>    {
00241         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) RtlInitializeNtHeapManager();
00242     }
00243 <span class="preprocessor">#endif // NTHEAP_ENABLED</span>
00244 <span class="preprocessor"></span>
00245     <span class="comment">//</span>
00246     <span class="comment">//  Initialize the lock and return to our caller</span>
00247     <span class="comment">//</span>
00248 
00249     <span class="keywordflow">return</span> <a class="code" href="../../d9/d9/heappriv_8h.html#a2">RtlInitializeLockRoutine</a>( &amp;<a class="code" href="../../d5/d9/heapdll_8c.html#a3">RtlpProcessHeapsListLock</a>.<a class="code" href="../../d4/d6/struct__HEAP__LOCK.html#o2">Lock</a> );
00250 }
00251 
00252 
00253 <span class="comment">//</span>
00254 <span class="comment">//  Declared in ntrtl.h</span>
00255 <span class="comment">//</span>
00256 
00257 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00258"></a><a class="code" href="../../d5/d9/heapdll_8c.html#a21">00258</a> <a class="code" href="../../d5/d9/heapdll_8c.html#a21">RtlProtectHeap</a> (
00259     IN PVOID HeapHandle,
00260     IN BOOLEAN MakeReadOnly
00261     )
00262 
00263 <span class="comment">/*++</span>
00264 <span class="comment"></span>
00265 <span class="comment">Routine Description:</span>
00266 <span class="comment"></span>
00267 <span class="comment">    This routine will change the protection on all the pages in a heap</span>
00268 <span class="comment">    to be either readonly or readwrite</span>
00269 <span class="comment"></span>
00270 <span class="comment">Arguments:</span>
00271 <span class="comment"></span>
00272 <span class="comment">    HeapHandle - Supplies a pointer to the heap being altered</span>
00273 <span class="comment"></span>
00274 <span class="comment">    MakeReadOnly - Specifies if the heap is to be made readonly or</span>
00275 <span class="comment">        readwrite</span>
00276 <span class="comment"></span>
00277 <span class="comment">Return Value:</span>
00278 <span class="comment"></span>
00279 <span class="comment">    None.</span>
00280 <span class="comment"></span>
00281 <span class="comment">--*/</span>
00282 
00283 {
00284     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap;
00285     UCHAR SegmentIndex;
00286     <a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a> Segment;
00287     MEMORY_BASIC_INFORMATION VaInfo;
00288     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00289     PVOID Address;
00290     PVOID ProtectAddress;
00291     SIZE_T <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
00292     ULONG OldProtect;
00293     ULONG NewProtect;
00294 
00295     Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
00296 
00297     <span class="comment">//</span>
00298     <span class="comment">//  For every valid segment in the heap we will zoom through all its</span>
00299     <span class="comment">//  regions and for those that are committed we'll change it protection</span>
00300     <span class="comment">//</span>
00301 
00302     <span class="keywordflow">for</span> (SegmentIndex=0; SegmentIndex&lt;<a class="code" href="../../d3/d9/heap_8h.html#a7">HEAP_MAXIMUM_SEGMENTS</a>; SegmentIndex++) {
00303 
00304         Segment = Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o22">Segments</a>[ SegmentIndex ];
00305 
00306         <span class="keywordflow">if</span> ( Segment ) {
00307 
00308             <span class="comment">//</span>
00309             <span class="comment">//  Starting from the first address for the segment and going to</span>
00310             <span class="comment">//  the last address in the segment we'll step through by regions</span>
00311             <span class="comment">//</span>
00312 
00313             Address = Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o5">BaseAddress</a>;
00314 
00315             <span class="keywordflow">while</span> ((ULONG_PTR)Address &lt; (ULONG_PTR)(Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o8">LastValidEntry</a>)) {
00316 
00317                 <span class="comment">//</span>
00318                 <span class="comment">//  Query the current region to get its state and size</span>
00319                 <span class="comment">//</span>
00320 
00321                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwQueryVirtualMemory( NtCurrentProcess(),
00322                                                Address,
00323                                                MemoryBasicInformation,
00324                                                &amp;VaInfo,
00325                                                <span class="keyword">sizeof</span>(VaInfo),
00326                                                <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00327 
00328                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
00329 
00330                     <a class="code" href="../../d9/d9/heappriv_8h.html#a10">HeapDebugPrint</a>(( <span class="stringliteral">"VirtualQuery Failed 0x%08x %x\n"</span>, Address, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ));
00331 
00332                     <span class="keywordflow">return</span>;
00333                 }
00334 
00335                 <span class="comment">//</span>
00336                 <span class="comment">//  If we found a commited block then set its protection</span>
00337                 <span class="comment">//</span>
00338 
00339                 <span class="keywordflow">if</span> (VaInfo.State == MEM_COMMIT) {
00340 
00341                     <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> = VaInfo.RegionSize;
00342 
00343                     ProtectAddress = Address;
00344 
00345                     <span class="keywordflow">if</span> (MakeReadOnly) {
00346 
00347                         NewProtect = PAGE_READONLY;
00348 
00349                     } <span class="keywordflow">else</span> {
00350 
00351                         NewProtect = PAGE_READWRITE;
00352                     }
00353 
00354                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwProtectVirtualMemory( NtCurrentProcess(),
00355                                                      &amp;ProtectAddress,
00356                                                      &amp;<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>,
00357                                                      NewProtect,
00358                                                      &amp;OldProtect );
00359 
00360                     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
00361 
00362                         <a class="code" href="../../d9/d9/heappriv_8h.html#a10">HeapDebugPrint</a>(( <span class="stringliteral">"VirtualProtect Failed 0x%08x %x\n"</span>, Address, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ));
00363 
00364                         <span class="keywordflow">return</span>;
00365                     }
00366                 }
00367 
00368                 <span class="comment">//</span>
00369                 <span class="comment">//  Now calculate the address of the next region in the segment</span>
00370                 <span class="comment">//</span>
00371 
00372                 Address = (PVOID)((PCHAR)Address + VaInfo.RegionSize);
00373             }
00374         }
00375     }
00376 
00377     <span class="comment">//</span>
00378     <span class="comment">//  And return to our caller</span>
00379     <span class="comment">//</span>
00380 
00381     <span class="keywordflow">return</span>;
00382 }
00383 
00384 
00385 <span class="comment">//</span>
00386 <span class="comment">//  Declared in nturtl.h</span>
00387 <span class="comment">//</span>
00388 
00389 BOOLEAN
<a name="l00390"></a><a class="code" href="../../d5/d9/heapdll_8c.html#a22">00390</a> <a class="code" href="../../d5/d9/heapdll_8c.html#a22">RtlLockHeap</a> (
00391     IN PVOID HeapHandle
00392     )
00393 
00394 <span class="comment">/*++</span>
00395 <span class="comment"></span>
00396 <span class="comment">Routine Description:</span>
00397 <span class="comment"></span>
00398 <span class="comment">    This routine is used by lock access to a specific heap structure</span>
00399 <span class="comment"></span>
00400 <span class="comment">Arguments:</span>
00401 <span class="comment"></span>
00402 <span class="comment">    HeapHandle - Supplies a pointer to the heap being locked</span>
00403 <span class="comment"></span>
00404 <span class="comment">Return Value:</span>
00405 <span class="comment"></span>
00406 <span class="comment">    BOOLEAN - TRUE if the heap is now locked and FALSE otherwise (i.e.,</span>
00407 <span class="comment">        the heap is ill-formed).  TRUE is returned even if the heap is</span>
00408 <span class="comment">        not lockable.</span>
00409 <span class="comment"></span>
00410 <span class="comment">--*/</span>
00411 
00412 {
00413     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
00414 
00415     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00416 
00417     <span class="comment">//</span>
00418     <span class="comment">//  Check for the heap protected by guard pages</span>
00419     <span class="comment">//</span>
00420 
00421     <a class="code" href="../../d7/d9/heappage_8h.html#a6">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>,
00422                                     <a class="code" href="../../d7/d9/heappage_8h.html#a19">RtlpDebugPageHeapLock</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> ));
00423 
00424     <span class="comment">//</span>
00425     <span class="comment">//  Validate that HeapAddress points to a HEAP structure.</span>
00426     <span class="comment">//</span>
00427 
00428     <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d9/heappriv_8h.html#a46">RtlpCheckHeapSignature</a>( Heap, <span class="stringliteral">"RtlLockHeap"</span> )) {
00429 
00430         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00431     }
00432 
00433     <span class="comment">//</span>
00434     <span class="comment">//  Lock the heap.  And disable the lookaside list by incrementing</span>
00435     <span class="comment">//  its lock count.</span>
00436     <span class="comment">//</span>
00437 
00438     <span class="keywordflow">if</span> (!(Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o2">Flags</a> &amp; HEAP_NO_SERIALIZE)) {
00439 
00440         <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
00441 
00442         Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o34">LookasideLockCount</a> += 1;
00443     }
00444 
00445     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00446 }
00447 
00448 
00449 <span class="comment">//</span>
00450 <span class="comment">//  Declared in nturtl.h</span>
00451 <span class="comment">//</span>
00452 
00453 BOOLEAN
<a name="l00454"></a><a class="code" href="../../d5/d9/heapdll_8c.html#a23">00454</a> <a class="code" href="../../d5/d9/heapdll_8c.html#a23">RtlUnlockHeap</a> (
00455     IN PVOID HeapHandle
00456     )
00457 
00458 <span class="comment">/*++</span>
00459 <span class="comment"></span>
00460 <span class="comment">Routine Description:</span>
00461 <span class="comment"></span>
00462 <span class="comment">    This routine is used to unlock access to a specific heap structure</span>
00463 <span class="comment"></span>
00464 <span class="comment">Arguments:</span>
00465 <span class="comment"></span>
00466 <span class="comment">    HeapHandle - Supplies a pointer to the heep being unlocked</span>
00467 <span class="comment"></span>
00468 <span class="comment">Return Value:</span>
00469 <span class="comment"></span>
00470 <span class="comment">    BOOLEAN - TRUE if the heap is now unlocked and FALSE otherwise (i.e.,</span>
00471 <span class="comment">        the heap is ill-formed).  TRUE is also returned if the heap was</span>
00472 <span class="comment">        never locked to begin with because it is not seralizable.</span>
00473 <span class="comment"></span>
00474 <span class="comment">--*/</span>
00475 
00476 {
00477     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
00478 
00479     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00480 
00481     <span class="comment">//</span>
00482     <span class="comment">//  Check for the heap protected by guard pages</span>
00483     <span class="comment">//</span>
00484 
00485     <a class="code" href="../../d7/d9/heappage_8h.html#a6">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>,
00486                                     <a class="code" href="../../d7/d9/heappage_8h.html#a20">RtlpDebugPageHeapUnlock</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> ));
00487 
00488     <span class="comment">//</span>
00489     <span class="comment">//  Validate that HeapAddress points to a HEAP structure.</span>
00490     <span class="comment">//</span>
00491 
00492     <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d9/heappriv_8h.html#a46">RtlpCheckHeapSignature</a>( Heap, <span class="stringliteral">"RtlUnlockHeap"</span> )) {
00493 
00494         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00495     }
00496 
00497     <span class="comment">//</span>
00498     <span class="comment">//  Unlock the heap.  And enable the lookaside logic by decrementing</span>
00499     <span class="comment">//  its lock count</span>
00500     <span class="comment">//</span>
00501 
00502     <span class="keywordflow">if</span> (!(Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o2">Flags</a> &amp; HEAP_NO_SERIALIZE)) {
00503 
00504         Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o34">LookasideLockCount</a> -= 1;
00505 
00506         <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
00507     }
00508 
00509     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00510 }
00511 
00512 
00513 <span class="comment">//</span>
00514 <span class="comment">//  Declared in nturtl.h</span>
00515 <span class="comment">//</span>
00516 
00517 PVOID
<a name="l00518"></a><a class="code" href="../../d5/d9/heapdll_8c.html#a24">00518</a> <a class="code" href="../../d5/d9/heapdll_8c.html#a24">RtlReAllocateHeap</a> (
00519     IN PVOID HeapHandle,
00520     IN ULONG Flags,
00521     IN PVOID BaseAddress,
00522     IN SIZE_T Size
00523     )
00524 
00525 <span class="comment">/*++</span>
00526 <span class="comment"></span>
00527 <span class="comment">Routine Description:</span>
00528 <span class="comment"></span>
00529 <span class="comment">    This routine will resize a user specified heap block.  The new size</span>
00530 <span class="comment">    can either be smaller or larger than the current block size.</span>
00531 <span class="comment"></span>
00532 <span class="comment">Arguments:</span>
00533 <span class="comment"></span>
00534 <span class="comment">    HeapHandle - Supplies a pointer to the heap being modified</span>
00535 <span class="comment"></span>
00536 <span class="comment">    Flags - Supplies a set of heap flags to augment those already</span>
00537 <span class="comment">        enforced by the heap</span>
00538 <span class="comment"></span>
00539 <span class="comment">    BaseAddress - Supplies the current address of a block allocated</span>
00540 <span class="comment">        from heap.  We will try and resize this block at its current</span>
00541 <span class="comment">        address, but it could possibly move if this heap structure</span>
00542 <span class="comment">        allows for relocation</span>
00543 <span class="comment"></span>
00544 <span class="comment">    Size - Supplies the size, in bytes, for the newly resized heap</span>
00545 <span class="comment">        block</span>
00546 <span class="comment"></span>
00547 <span class="comment">Return Value:</span>
00548 <span class="comment"></span>
00549 <span class="comment">    PVOID - A pointer to the resized block.  If the block had to move</span>
00550 <span class="comment">        then this address will not be equal to the input base address</span>
00551 <span class="comment"></span>
00552 <span class="comment">--*/</span>
00553 
00554 {
00555     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
00556     SIZE_T AllocationSize;
00557     <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a> BusyBlock, NewBusyBlock;
00558     <a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html">PHEAP_ENTRY_EXTRA</a> OldExtraStuff, NewExtraStuff;
00559     SIZE_T FreeSize;
00560     BOOLEAN LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00561     PVOID NewBaseAddress;
00562     <a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a> SplitBlock, SplitBlock2;
00563     SIZE_T OldSize;
00564     SIZE_T AllocationIndex;
00565     SIZE_T OldAllocationIndex;
00566     UCHAR FreeFlags;
00567     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00568     PVOID DeCommitAddress;
00569     SIZE_T DeCommitSize;
00570     EXCEPTION_RECORD ExceptionRecord;
00571 
00572     <span class="comment">//</span>
00573     <span class="comment">//  If there isn't an address to relocate the heap at then our work is done</span>
00574     <span class="comment">//</span>
00575 
00576     <span class="keywordflow">if</span> (BaseAddress == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00577 
00578         <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( STATUS_SUCCESS );
00579 
00580         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00581     }
00582 
00583 <span class="preprocessor">#ifdef NTHEAP_ENABLED</span>
00584 <span class="preprocessor"></span>    {
00585         <span class="keywordflow">if</span> (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o2">Flags</a> &amp; NTHEAP_ENABLED_FLAG) {
00586 
00587             <span class="keywordflow">return</span> RtlReAllocateNtHeap( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, Flags, BaseAddress, <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> );
00588         }
00589     }
00590 <span class="preprocessor">#endif // NTHEAP_ENABLED</span>
00591 <span class="preprocessor"></span>
00592     <span class="comment">//</span>
00593     <span class="comment">//  Augment the heap flags</span>
00594     <span class="comment">//</span>
00595 
00596     Flags |= Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o3">ForceFlags</a>;
00597 
00598     <span class="comment">//</span>
00599     <span class="comment">//  Check if we should simply call the debug version of heap to do the work</span>
00600     <span class="comment">//</span>
00601 
00602     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a8">DEBUG_HEAP</a>( Flags)) {
00603 
00604         <span class="keywordflow">return</span> <a class="code" href="../../d5/d9/heapdll_8c.html#a8">RtlDebugReAllocateHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, Flags, BaseAddress, <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> );
00605     }
00606 
00607     <span class="comment">//</span>
00608     <span class="comment">//  Make sure we didn't get a negative heap size</span>
00609     <span class="comment">//</span>
00610 
00611     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> &gt; 0x7fffffff) {
00612 
00613         <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( STATUS_NO_MEMORY );
00614 
00615         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00616     }
00617 
00618     <span class="comment">//</span>
00619     <span class="comment">//  Round the requested size up to the allocation granularity.  Note</span>
00620     <span class="comment">//  that if the request is for 0 bytes, we still allocate memory, because</span>
00621     <span class="comment">//  we add in an extra byte to protect ourselves from idiots.</span>
00622     <span class="comment">//</span>
00623 
00624     AllocationSize = ((<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> ? <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> : 1) + Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o19">AlignRound</a>) &amp; Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o20">AlignMask</a>;
00625 
00626     <span class="keywordflow">if</span> ((Flags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a31">HEAP_NEED_EXTRA_FLAGS</a>) ||
00627         (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o29">PseudoTagEntries</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) ||
00628         ((((<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)BaseAddress)-1)-&gt;Flags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a9">HEAP_ENTRY_EXTRA_PRESENT</a>)) {
00629 
00630         AllocationSize += <span class="keyword">sizeof</span>( <a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html">HEAP_ENTRY_EXTRA</a> );
00631     }
00632 
00633     <span class="keywordflow">try</span> {
00634 
00635         <span class="comment">//</span>
00636         <span class="comment">//  Lock the heap</span>
00637         <span class="comment">//</span>
00638 
00639         <span class="keywordflow">if</span> (!(Flags &amp; HEAP_NO_SERIALIZE)) {
00640 
00641             <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
00642 
00643             LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00644 
00645             <span class="comment">//</span>
00646             <span class="comment">//  Because it is now zero the following statement will set the no</span>
00647             <span class="comment">//  serialize bit</span>
00648             <span class="comment">//</span>
00649 
00650             Flags ^= HEAP_NO_SERIALIZE;
00651         }
00652 
00653         <span class="keywordflow">try</span> {
00654 
00655             <span class="comment">//</span>
00656             <span class="comment">//  Compute the heap block address for user specified block</span>
00657             <span class="comment">//</span>
00658 
00659             BusyBlock = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)BaseAddress - 1;
00660 
00661             <span class="comment">//</span>
00662             <span class="comment">//  Check if the block is not in use then it is an error</span>
00663             <span class="comment">//</span>
00664 
00665             <span class="keywordflow">if</span> (!(BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a8">HEAP_ENTRY_BUSY</a>)) {
00666 
00667                 <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( STATUS_INVALID_PARAMETER );
00668 
00669                 <span class="comment">//</span>
00670                 <span class="comment">//  Bail if not a busy block.</span>
00671                 <span class="comment">//</span>
00672 
00673                 leave;
00674 
00675             <span class="comment">//</span>
00676             <span class="comment">//  We need the current (i.e., old) size and allocation of the</span>
00677             <span class="comment">//  block.  Check if the block is a big allocation.  The size</span>
00678             <span class="comment">//  field of a big block is really the unused by count</span>
00679             <span class="comment">//</span>
00680 
00681             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a11">HEAP_ENTRY_VIRTUAL_ALLOC</a>) {
00682 
00683                 OldSize = <a class="code" href="../../d9/d9/heappriv_8h.html#a40">RtlpGetSizeOfBigBlock</a>( BusyBlock );
00684 
00685                 OldAllocationIndex = (OldSize + BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a>) &gt;&gt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>;
00686 
00687                 <span class="comment">//</span>
00688                 <span class="comment">//  We'll need to adjust the new allocation size to account</span>
00689                 <span class="comment">//  for the big block header and then round it up to a page</span>
00690                 <span class="comment">//</span>
00691 
00692                 AllocationSize += FIELD_OFFSET( <a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html">HEAP_VIRTUAL_ALLOC_ENTRY</a>, BusyBlock );
00693                 AllocationSize = <a class="code" href="../../d3/d9/heap_8h.html#a1">ROUND_UP_TO_POWER2</a>( AllocationSize, <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> );
00694 
00695             <span class="comment">//</span>
00696             <span class="comment">//  Otherwise the block is in use and is a small allocation</span>
00697             <span class="comment">//</span>
00698 
00699             } <span class="keywordflow">else</span> {
00700 
00701                 OldAllocationIndex = BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a>;
00702 
00703                 OldSize = (OldAllocationIndex &lt;&lt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>) -
00704                           BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o4">UnusedBytes</a>;
00705             }
00706 
00707             <span class="comment">//</span>
00708             <span class="comment">//  Compute the new allocation index</span>
00709             <span class="comment">//</span>
00710 
00711             AllocationIndex = AllocationSize &gt;&gt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>;
00712 
00713             <span class="comment">//</span>
00714             <span class="comment">//  At this point we have the old size and index, and the new size</span>
00715             <span class="comment">//  and index</span>
00716             <span class="comment">//</span>
00717             <span class="comment">//  See if new size less than or equal to the current size.</span>
00718             <span class="comment">//</span>
00719 
00720             <span class="keywordflow">if</span> (AllocationIndex &lt;= OldAllocationIndex) {
00721 
00722                 <span class="comment">//</span>
00723                 <span class="comment">//  If the new allocation index is only one less then the current</span>
00724                 <span class="comment">//  index then make the sizes equal</span>
00725                 <span class="comment">//</span>
00726 
00727                 <span class="keywordflow">if</span> (AllocationIndex + 1 == OldAllocationIndex) {
00728 
00729                     AllocationIndex += 1;
00730                     AllocationSize += <span class="keyword">sizeof</span>( <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">HEAP_ENTRY</a> );
00731                 }
00732 
00733                 <span class="comment">//</span>
00734                 <span class="comment">//  Calculate new residual (unused) amount</span>
00735                 <span class="comment">//</span>
00736 
00737                 <span class="keywordflow">if</span> (BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a11">HEAP_ENTRY_VIRTUAL_ALLOC</a>) {
00738 
00739                     <span class="comment">//</span>
00740                     <span class="comment">//  In a big block the size is really the unused byte count</span>
00741                     <span class="comment">//</span>
00742 
00743                     BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(AllocationSize - <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>);
00744 
00745                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a9">HEAP_ENTRY_EXTRA_PRESENT</a>) {
00746 
00747                     <span class="comment">//</span>
00748                     <span class="comment">//  The extra stuff struct goes after the data.  So compute</span>
00749                     <span class="comment">//  the old and new extra stuff location and copy the data</span>
00750                     <span class="comment">//</span>
00751 
00752                     OldExtraStuff = (<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html">PHEAP_ENTRY_EXTRA</a>)(BusyBlock + BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a> - 1);
00753 
00754                     NewExtraStuff = (<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html">PHEAP_ENTRY_EXTRA</a>)(BusyBlock + AllocationIndex - 1);
00755 
00756                     *NewExtraStuff = *OldExtraStuff;
00757 
00758                     <span class="comment">//</span>
00759                     <span class="comment">//  If we're doing heap tagging then update the tag entry</span>
00760                     <span class="comment">//</span>
00761 
00762                     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a22">IS_HEAP_TAGGING_ENABLED</a>()) {
00763 
00764                         NewExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o1">TagIndex</a> =
00765                             <a class="code" href="../../d9/d9/heappriv_8h.html#a52">RtlpUpdateTagEntry</a>( Heap,
00766                                                 NewExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o1">TagIndex</a>,
00767                                                 OldAllocationIndex,
00768                                                 AllocationIndex,
00769                                                 <a class="code" href="../../d9/d9/heappriv_8h.html#a60a31">ReAllocationAction</a> );
00770                     }
00771 
00772                     BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o4">UnusedBytes</a> = (UCHAR)(AllocationSize - <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>);
00773 
00774                 } <span class="keywordflow">else</span> {
00775 
00776                     <span class="comment">//</span>
00777                     <span class="comment">//  If we're doing heap tagging then update the tag entry</span>
00778                     <span class="comment">//</span>
00779 
00780                     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a22">IS_HEAP_TAGGING_ENABLED</a>()) {
00781 
00782                         BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o5">SmallTagIndex</a> = (UCHAR)
00783                             <a class="code" href="../../d9/d9/heappriv_8h.html#a52">RtlpUpdateTagEntry</a>( Heap,
00784                                                 BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o5">SmallTagIndex</a>,
00785                                                 BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a>,
00786                                                 AllocationIndex,
00787                                                 <a class="code" href="../../d9/d9/heappriv_8h.html#a60a31">ReAllocationAction</a> );
00788                     }
00789 
00790                     BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o4">UnusedBytes</a> = (UCHAR)(AllocationSize - <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>);
00791                 }
00792 
00793                 <span class="comment">//</span>
00794                 <span class="comment">//  Check if the block is getting bigger, then fill in the extra</span>
00795                 <span class="comment">//  space.</span>
00796                 <span class="comment">//</span>
00797                 <span class="comment">//  **** how can this happen if the allocation index is less than or</span>
00798                 <span class="comment">//  **** equal to the old allocation index</span>
00799                 <span class="comment">//</span>
00800 
00801                 <span class="keywordflow">if</span> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> &gt; OldSize) {
00802 
00803                     <span class="comment">//</span>
00804                     <span class="comment">//  See if we should zero the extra space</span>
00805                     <span class="comment">//</span>
00806 
00807                     <span class="keywordflow">if</span> (Flags &amp; HEAP_ZERO_MEMORY) {
00808 
00809                         RtlZeroMemory( (PCHAR)BaseAddress + OldSize,
00810                                        <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> - OldSize );
00811 
00812                     <span class="comment">//</span>
00813                     <span class="comment">//  Otherwise see if we should fill the extra space</span>
00814                     <span class="comment">//</span>
00815 
00816                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o2">Flags</a> &amp; HEAP_FREE_CHECKING_ENABLED) {
00817 
00818                         SIZE_T PartialBytes, ExtraSize;
00819 
00820                         PartialBytes = OldSize &amp; (<span class="keyword">sizeof</span>( ULONG ) - 1);
00821 
00822                         <span class="keywordflow">if</span> (PartialBytes) {
00823 
00824                             PartialBytes = 4 - PartialBytes;
00825                         }
00826 
00827                         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> &gt; (OldSize + PartialBytes)) {
00828 
00829                             ExtraSize = (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> - (OldSize + PartialBytes)) &amp; ~(<span class="keyword">sizeof</span>( ULONG ) - 1);
00830 
00831                             <span class="keywordflow">if</span> (ExtraSize != 0) {
00832 
00833                                 RtlFillMemoryUlong( (PCHAR)(BusyBlock + 1) + OldSize + PartialBytes,
00834                                                     ExtraSize,
00835                                                     <a class="code" href="../../d3/d9/heap_8h.html#a28">ALLOC_HEAP_FILL</a> );
00836                             }
00837                         }
00838                     }
00839                 }
00840 
00841                 <span class="keywordflow">if</span> (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o2">Flags</a> &amp; HEAP_TAIL_CHECKING_ENABLED) {
00842 
00843                     RtlFillMemory( (PCHAR)(BusyBlock + 1) + <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>,
00844                                    <a class="code" href="../../d3/d9/heap_8h.html#a25">CHECK_HEAP_TAIL_SIZE</a>,
00845                                    <a class="code" href="../../d3/d9/heap_8h.html#a26">CHECK_HEAP_TAIL_FILL</a> );
00846                 }
00847 
00848                 <span class="comment">//</span>
00849                 <span class="comment">//  If amount of change is greater than the size of a free block,</span>
00850                 <span class="comment">//  then need to free the extra space.  Otherwise, nothing else to</span>
00851                 <span class="comment">//  do.</span>
00852                 <span class="comment">//</span>
00853 
00854                 <span class="keywordflow">if</span> (AllocationIndex != OldAllocationIndex) {
00855 
00856                     FreeFlags = BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; ~<a class="code" href="../../d3/d9/heap_8h.html#a8">HEAP_ENTRY_BUSY</a>;
00857 
00858                     <span class="keywordflow">if</span> (FreeFlags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a11">HEAP_ENTRY_VIRTUAL_ALLOC</a>) {
00859 
00860                         <a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html">PHEAP_VIRTUAL_ALLOC_ENTRY</a> VirtualAllocBlock;
00861 
00862                         VirtualAllocBlock = CONTAINING_RECORD( BusyBlock, <a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html">HEAP_VIRTUAL_ALLOC_ENTRY</a>, BusyBlock );
00863 
00864                         <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a22">IS_HEAP_TAGGING_ENABLED</a>()) {
00865 
00866                             VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o1">ExtraStuff</a>.<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o1">TagIndex</a> =
00867                                 <a class="code" href="../../d9/d9/heappriv_8h.html#a52">RtlpUpdateTagEntry</a>( Heap,
00868                                                     VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o1">ExtraStuff</a>.<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o1">TagIndex</a>,
00869                                                     OldAllocationIndex,
00870                                                     AllocationIndex,
00871                                                     <a class="code" href="../../d9/d9/heappriv_8h.html#a60a32">VirtualReAllocationAction</a> );
00872                         }
00873 
00874                         DeCommitAddress = (PCHAR)VirtualAllocBlock + AllocationSize;
00875 
00876                         DeCommitSize = (OldAllocationIndex &lt;&lt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>) -
00877                                        AllocationSize;
00878 
00879                         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwFreeVirtualMemory( NtCurrentProcess(),
00880                                                       (PVOID *)&amp;DeCommitAddress,
00881                                                       &amp;DeCommitSize,
00882                                                       MEM_RELEASE );
00883 
00884                         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
00885 
00886                             <a class="code" href="../../d9/d9/heappriv_8h.html#a10">HeapDebugPrint</a>(( <span class="stringliteral">"Unable to release memory at %p for %p bytes - Status == %x\n"</span>,
00887                                              DeCommitAddress, DeCommitSize, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ));
00888 
00889                             <a class="code" href="../../d9/d9/heappriv_8h.html#a11">HeapDebugBreak</a>( <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00890 
00891                         } <span class="keywordflow">else</span> {
00892 
00893                             VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o2">CommitSize</a> -= DeCommitSize;
00894                         }
00895 
00896                     } <span class="keywordflow">else</span> {
00897 
00898                         <span class="comment">//</span>
00899                         <span class="comment">//  Otherwise, shrink size of this block to new size, and make extra</span>
00900                         <span class="comment">//  space at end free.</span>
00901                         <span class="comment">//</span>
00902 
00903                         SplitBlock = (<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)(BusyBlock + AllocationIndex);
00904 
00905                         SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a> = FreeFlags;
00906 
00907                         SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o1">PreviousSize</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)AllocationIndex;
00908 
00909                         SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o2">SegmentIndex</a> = BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o2">SegmentIndex</a>;
00910 
00911                         FreeSize = BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a> - AllocationIndex;
00912 
00913                         BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)AllocationIndex;
00914 
00915                         BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp;= ~<a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>;
00916 
00917                         <span class="comment">//</span>
00918                         <span class="comment">//  If the following block is uncommitted then we only need to</span>
00919                         <span class="comment">//  add this new entry to its free list</span>
00920                         <span class="comment">//</span>
00921 
00922                         <span class="keywordflow">if</span> (FreeFlags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>) {
00923 
00924                             <a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a> Segment;
00925 
00926                             Segment = Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o22">Segments</a>[SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o2">SegmentIndex</a>];
00927                             Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o14">LastEntryInSegment</a> = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)SplitBlock;
00928 
00929                             SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)FreeSize;
00930 
00931                             <a class="code" href="../../d9/d9/heappriv_8h.html#a14">RtlpInsertFreeBlockDirect</a>( Heap, SplitBlock, (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)FreeSize );
00932 
00933                             Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o9">TotalFreeSize</a> += FreeSize;
00934 
00935                         } <span class="keywordflow">else</span> {
00936 
00937                             <span class="comment">//</span>
00938                             <span class="comment">//  Otherwise get the next block and check if it is busy.  If it</span>
00939                             <span class="comment">//  is in use then add this new entry to its free list</span>
00940                             <span class="comment">//</span>
00941 
00942                             SplitBlock2 = (<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)((<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)SplitBlock + FreeSize);
00943 
00944                             <span class="keywordflow">if</span> (SplitBlock2-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a8">HEAP_ENTRY_BUSY</a>) {
00945 
00946                                 SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)FreeSize;
00947 
00948                                 ((<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)((<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)SplitBlock + FreeSize))-&gt;PreviousSize = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)FreeSize;
00949 
00950                                 <a class="code" href="../../d9/d9/heappriv_8h.html#a14">RtlpInsertFreeBlockDirect</a>( Heap, SplitBlock, (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)FreeSize );
00951 
00952                                 Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o9">TotalFreeSize</a> += FreeSize;
00953 
00954                             } <span class="keywordflow">else</span> {
00955 
00956                                 <span class="comment">//</span>
00957                                 <span class="comment">//  Otherwise the next block is not in use so we</span>
00958                                 <span class="comment">//  should be able to merge with it.  Remove the</span>
00959                                 <span class="comment">//  second free block and if the combined size is</span>
00960                                 <span class="comment">//  still okay then merge the two blocks and add</span>
00961                                 <span class="comment">//  the single block back in.  Otherwise call a</span>
00962                                 <span class="comment">//  routine that will actually break it apart</span>
00963                                 <span class="comment">//  before insertion.</span>
00964                                 <span class="comment">//</span>
00965 
00966                                 SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a> = SplitBlock2-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a>;
00967 
00968                                 <a class="code" href="../../d9/d9/heappriv_8h.html#a18">RtlpRemoveFreeBlock</a>( Heap, SplitBlock2 );
00969 
00970                                 Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o9">TotalFreeSize</a> -= SplitBlock2-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a>;
00971 
00972                                 FreeSize += SplitBlock2-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a>;
00973 
00974                                 <span class="keywordflow">if</span> (FreeSize &lt;= <a class="code" href="../../d3/d9/heap_8h.html#a5">HEAP_MAXIMUM_BLOCK_SIZE</a>) {
00975 
00976                                     SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)FreeSize;
00977 
00978                                     <span class="keywordflow">if</span> (!(SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>)) {
00979 
00980                                         ((<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)((<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)SplitBlock + FreeSize))-&gt;PreviousSize = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)FreeSize;
00981 
00982                                     } <span class="keywordflow">else</span> {
00983 
00984                                         <a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a> Segment;
00985 
00986                                         Segment = Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o22">Segments</a>[SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o2">SegmentIndex</a>];
00987                                         Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o14">LastEntryInSegment</a> = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)SplitBlock;
00988                                     }
00989 
00990                                     <a class="code" href="../../d9/d9/heappriv_8h.html#a14">RtlpInsertFreeBlockDirect</a>( Heap, SplitBlock, (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)FreeSize );
00991 
00992                                     Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o9">TotalFreeSize</a> += FreeSize;
00993 
00994                                 } <span class="keywordflow">else</span> {
00995 
00996                                     <a class="code" href="../../d9/d9/heappriv_8h.html#a36">RtlpInsertFreeBlock</a>( Heap, SplitBlock, FreeSize );
00997                                 }
00998                             }
00999                         }
01000                     }
01001                 }
01002 
01003             } <span class="keywordflow">else</span> {
01004 
01005                 <span class="comment">//</span>
01006                 <span class="comment">//  At this point the new size is greater than the current size</span>
01007                 <span class="comment">//</span>
01008                 <span class="comment">//  If the block is a big allocation or we're not able to grow</span>
01009                 <span class="comment">//  the block in place then we have a lot of work to do</span>
01010                 <span class="comment">//</span>
01011 
01012                 <span class="keywordflow">if</span> ((BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a11">HEAP_ENTRY_VIRTUAL_ALLOC</a>) ||
01013                     !<a class="code" href="../../d5/d9/heapdll_8c.html#a7">RtlpGrowBlockInPlace</a>( Heap, Flags, BusyBlock, <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>, AllocationIndex )) {
01014 
01015                     <span class="comment">//</span>
01016                     <span class="comment">//  We're growing the block.  Allocate a new block with the bigger</span>
01017                     <span class="comment">//  size, copy the contents of the old block to the new block and then</span>
01018                     <span class="comment">//  free the old block.  Return the address of the new block.</span>
01019                     <span class="comment">//</span>
01020 
01021                     <span class="keywordflow">if</span> (Flags &amp; HEAP_REALLOC_IN_PLACE_ONLY) {
01022 
01023 <span class="preprocessor">#if DBG</span>
01024 <span class="preprocessor"></span>                        <span class="comment">// HeapDebugPrint(( "Failing ReAlloc because cant do it inplace.\n" ));</span>
01025 <span class="preprocessor">#endif</span>
01026 <span class="preprocessor"></span>
01027                         BaseAddress = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01028 
01029                     } <span class="keywordflow">else</span> {
01030 
01031                         <span class="comment">//</span>
01032                         <span class="comment">//  Clear the tag bits from the flags</span>
01033                         <span class="comment">//</span>
01034 
01035                         Flags &amp;= ~HEAP_TAG_MASK;
01036 
01037                         <span class="comment">//</span>
01038                         <span class="comment">//  If there is an extra struct present then get the tag</span>
01039                         <span class="comment">//  index from the extra stuff and augment the flags with</span>
01040                         <span class="comment">//  the tag index.</span>
01041                         <span class="comment">//</span>
01042 
01043                         <span class="keywordflow">if</span> (BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a9">HEAP_ENTRY_EXTRA_PRESENT</a>) {
01044 
01045                             Flags &amp;= ~HEAP_SETTABLE_USER_FLAGS;
01046 
01047                             Flags |= HEAP_SETTABLE_USER_VALUE |
01048                                      ((BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a16">HEAP_ENTRY_SETTABLE_FLAGS</a>) &lt;&lt; 4);
01049 
01050                             OldExtraStuff = <a class="code" href="../../d9/d9/heappriv_8h.html#a41">RtlpGetExtraStuffPointer</a>( BusyBlock );
01051 
01052                             <span class="keywordflow">try</span> {
01053 
01054                                 <span class="keywordflow">if</span> ((OldExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o1">TagIndex</a> != 0) &amp;&amp;
01055                                     !(OldExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o1">TagIndex</a> &amp; HEAP_PSEUDO_TAG_FLAG)) {
01056 
01057                                     Flags |= OldExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o1">TagIndex</a> &lt;&lt; HEAP_TAG_SHIFT;
01058                                 }
01059 
01060                             } except (<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
01061 
01062                                 BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp;= ~<a class="code" href="../../d3/d9/heap_8h.html#a9">HEAP_ENTRY_EXTRA_PRESENT</a>;
01063                             }
01064 
01065                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o5">SmallTagIndex</a> != 0) {
01066 
01067                             <span class="comment">//</span>
01068                             <span class="comment">//  There is not an extra stuff struct, but block</span>
01069                             <span class="comment">//  does have a small tag index so now add this small</span>
01070                             <span class="comment">//  tag to the flags</span>
01071                             <span class="comment">//</span>
01072 
01073                             Flags |= BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o5">SmallTagIndex</a> &lt;&lt; HEAP_TAG_SHIFT;
01074                         }
01075 
01076                         <span class="comment">//</span>
01077                         <span class="comment">//  Allocate from the heap space for the reallocation</span>
01078                         <span class="comment">//</span>
01079 
01080                         NewBaseAddress = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>,
01081                                                           Flags &amp; ~HEAP_ZERO_MEMORY,
01082                                                           <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> );
01083 
01084                         <span class="keywordflow">if</span> (NewBaseAddress != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01085 
01086                             <span class="comment">//</span>
01087                             <span class="comment">//  We were able to get the allocation so now back up</span>
01088                             <span class="comment">//  to the heap block and if the block has an extra</span>
01089                             <span class="comment">//  stuff struct then copy over the extra stuff</span>
01090                             <span class="comment">//</span>
01091 
01092                             NewBusyBlock = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)NewBaseAddress - 1;
01093 
01094                             <span class="keywordflow">if</span> (NewBusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a9">HEAP_ENTRY_EXTRA_PRESENT</a>) {
01095 
01096                                 NewExtraStuff = <a class="code" href="../../d9/d9/heappriv_8h.html#a41">RtlpGetExtraStuffPointer</a>( NewBusyBlock );
01097 
01098                                 <span class="keywordflow">if</span> (BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a9">HEAP_ENTRY_EXTRA_PRESENT</a>) {
01099 
01100                                     OldExtraStuff = <a class="code" href="../../d9/d9/heappriv_8h.html#a41">RtlpGetExtraStuffPointer</a>( BusyBlock );
01101 
01102                                     NewExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o2">Settable</a> = OldExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o2">Settable</a>;
01103 
01104                                 } <span class="keywordflow">else</span> {
01105 
01106                                     RtlZeroMemory( NewExtraStuff, <span class="keyword">sizeof</span>( *NewExtraStuff ));
01107                                 }
01108                             }
01109 
01110                             <span class="comment">//</span>
01111                             <span class="comment">//  Copy over the user's data area to the new block</span>
01112                             <span class="comment">//</span>
01113 
01114                             RtlMoveMemory( NewBaseAddress, BaseAddress, <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> &lt; OldSize ? <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> : OldSize );
01115 
01116                             <span class="comment">//</span>
01117                             <span class="comment">//  Check if we grew the block and we should zero</span>
01118                             <span class="comment">//  the remaining part.</span>
01119                             <span class="comment">//</span>
01120                             <span class="comment">//  **** is this first test always true because we're</span>
01121                             <span class="comment">//  **** in the part that grows blocks</span>
01122                             <span class="comment">//</span>
01123 
01124                             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> &gt; OldSize &amp;&amp; (Flags &amp; HEAP_ZERO_MEMORY)) {
01125 
01126                                 RtlZeroMemory( (PCHAR)NewBaseAddress + OldSize,
01127                                                <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> - OldSize );
01128                             }
01129 
01130                             <span class="comment">//</span>
01131                             <span class="comment">//  Release the old block</span>
01132                             <span class="comment">//</span>
01133 
01134                             <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>,
01135                                          Flags,
01136                                          BaseAddress );
01137                         }
01138 
01139                         BaseAddress = NewBaseAddress;
01140                     }
01141                 }
01142             }
01143 
01144             <span class="keywordflow">if</span> ((BaseAddress == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp; (Flags &amp; HEAP_GENERATE_EXCEPTIONS)) {
01145 
01146                 <span class="comment">//</span>
01147                 <span class="comment">//  Construct an exception record.</span>
01148                 <span class="comment">//</span>
01149 
01150                 ExceptionRecord.ExceptionCode = STATUS_NO_MEMORY;
01151                 ExceptionRecord.ExceptionRecord = (PEXCEPTION_RECORD)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01152                 ExceptionRecord.NumberParameters = 1;
01153                 ExceptionRecord.ExceptionFlags = 0;
01154                 ExceptionRecord.ExceptionInformation[ 0 ] = AllocationSize;
01155 
01156                 <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a9">RtlRaiseException</a>( &amp;ExceptionRecord );
01157             }
01158 
01159         } except( GetExceptionCode() == STATUS_NO_MEMORY ? <a class="code" href="../../d6/d7/halmips_8h.html#a34">EXCEPTION_CONTINUE_SEARCH</a> :
01160                                                            <a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a> ) {
01161 
01162             <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( GetExceptionCode() );
01163             BaseAddress = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01164 
01165         }
01166 
01167     } finally {
01168 
01169         <span class="comment">//</span>
01170         <span class="comment">//  Unlock the heap</span>
01171         <span class="comment">//</span>
01172 
01173         <span class="keywordflow">if</span> (LockAcquired) {
01174 
01175             <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
01176         }
01177     }
01178 
01179     <span class="comment">//</span>
01180     <span class="comment">//  And return to our caller</span>
01181     <span class="comment">//</span>
01182 
01183     <span class="keywordflow">return</span> BaseAddress;
01184 }
01185 
01186 
01187 <span class="comment">//</span>
01188 <span class="comment">//  Declared in nturtl.h</span>
01189 <span class="comment">//</span>
01190 
01191 BOOLEAN
<a name="l01192"></a><a class="code" href="../../d5/d9/heapdll_8c.html#a25">01192</a> <a class="code" href="../../d5/d9/heapdll_8c.html#a25">RtlGetUserInfoHeap</a> (
01193     IN PVOID HeapHandle,
01194     IN ULONG Flags,
01195     IN PVOID BaseAddress,
01196     OUT PVOID *UserValue OPTIONAL,
01197     OUT PULONG UserFlags OPTIONAL
01198     )
01199 
01200 <span class="comment">/*++</span>
01201 <span class="comment"></span>
01202 <span class="comment">Routine Description:</span>
01203 <span class="comment"></span>
01204 <span class="comment">    This routine returns to the user the set of user flags</span>
01205 <span class="comment">    and user values for the specified heap entry.  The user value</span>
01206 <span class="comment">    is set via a set call and the user flags is part of the</span>
01207 <span class="comment">    user settable flags used when communicating with the heap package</span>
01208 <span class="comment">    and can also be set via a set call</span>
01209 <span class="comment"></span>
01210 <span class="comment">Arguments:</span>
01211 <span class="comment"></span>
01212 <span class="comment">    HeapHandle - Supplies a pointer to the heap being queried</span>
01213 <span class="comment"></span>
01214 <span class="comment">    Flags - Supplies a set of flags to agument those already in the heap</span>
01215 <span class="comment"></span>
01216 <span class="comment">    BaseAddress - Supplies a pointer to the users heap entry being</span>
01217 <span class="comment">        queried</span>
01218 <span class="comment"></span>
01219 <span class="comment">    UserValue - Optionally supplies a pointer to recieve the heap entry</span>
01220 <span class="comment">        value</span>
01221 <span class="comment"></span>
01222 <span class="comment">    UserFlasg - Optionally supplies a pointer to recieve the heap flags</span>
01223 <span class="comment"></span>
01224 <span class="comment">Return Value:</span>
01225 <span class="comment"></span>
01226 <span class="comment">    BOOLEAN - TRUE if the query is successful and FALSE otherwise</span>
01227 <span class="comment"></span>
01228 <span class="comment">--*/</span>
01229 
01230 {
01231     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
01232     <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a> BusyBlock;
01233     <a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html">PHEAP_ENTRY_EXTRA</a> ExtraStuff;
01234     BOOLEAN LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01235     BOOLEAN Result;
01236 
01237     <span class="comment">//</span>
01238     <span class="comment">//  Build up a set of real flags to use in this operation</span>
01239     <span class="comment">//</span>
01240 
01241     Flags |= Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o3">ForceFlags</a>;
01242 
01243     <span class="comment">//</span>
01244     <span class="comment">//  Check if we should be going the debug route</span>
01245     <span class="comment">//</span>
01246 
01247     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a8">DEBUG_HEAP</a>( Flags )) {
01248 
01249         <span class="keywordflow">return</span> <a class="code" href="../../d5/d9/heapdll_8c.html#a9">RtlDebugGetUserInfoHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, Flags, BaseAddress, UserValue, UserFlags );
01250     }
01251 
01252     Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01253 
01254     <span class="keywordflow">try</span> {
01255 
01256         <span class="keywordflow">try</span> {
01257 
01258             <span class="comment">//</span>
01259             <span class="comment">//  Lock the heap</span>
01260             <span class="comment">//</span>
01261 
01262             <span class="keywordflow">if</span> (!(Flags &amp; HEAP_NO_SERIALIZE)) {
01263 
01264                 <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
01265 
01266                 LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01267             }
01268 
01269             <span class="comment">//</span>
01270             <span class="comment">//  Backup the pointer to the heap entry</span>
01271             <span class="comment">//</span>
01272 
01273             BusyBlock = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)BaseAddress - 1;
01274 
01275             <span class="comment">//</span>
01276             <span class="comment">//  If the entry is not in use then it is an error</span>
01277             <span class="comment">//</span>
01278 
01279             <span class="keywordflow">if</span> (!(BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a8">HEAP_ENTRY_BUSY</a>)) {
01280 
01281                 <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( STATUS_INVALID_PARAMETER );
01282 
01283             } <span class="keywordflow">else</span> {
01284 
01285                 <span class="comment">//</span>
01286                 <span class="comment">//  The heap entry is in use so now check if there is</span>
01287                 <span class="comment">//  any extra information present</span>
01288                 <span class="comment">//</span>
01289 
01290                 <span class="keywordflow">if</span> (BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a9">HEAP_ENTRY_EXTRA_PRESENT</a>) {
01291 
01292                     <span class="comment">//</span>
01293                     <span class="comment">//  Get a pointer to the extra information and if the</span>
01294                     <span class="comment">//  user asked for user values then that field from the</span>
01295                     <span class="comment">//  extra stuff</span>
01296                     <span class="comment">//</span>
01297 
01298                     ExtraStuff = <a class="code" href="../../d9/d9/heappriv_8h.html#a41">RtlpGetExtraStuffPointer</a>( BusyBlock );
01299 
01300                     <span class="keywordflow">if</span> (ARGUMENT_PRESENT( UserValue )) {
01301 
01302                         *UserValue = (PVOID)ExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o2">Settable</a>;
01303                     }
01304                 }
01305 
01306                 <span class="comment">//</span>
01307                 <span class="comment">//  If the user asked for user flags then return the flags</span>
01308                 <span class="comment">//  from the heap entry that are user setable</span>
01309                 <span class="comment">//</span>
01310 
01311                 <span class="keywordflow">if</span> (ARGUMENT_PRESENT( UserFlags )) {
01312 
01313                     *UserFlags = (BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a16">HEAP_ENTRY_SETTABLE_FLAGS</a>) &lt;&lt; 4;
01314                 }
01315 
01316                 <span class="comment">//</span>
01317                 <span class="comment">//  Now that the assignments are done we can say that</span>
01318                 <span class="comment">//  we were successful</span>
01319                 <span class="comment">//</span>
01320 
01321                 Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01322             }
01323 
01324         } except( <a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a> ) {
01325 
01326             <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( GetExceptionCode() );
01327 
01328             Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01329         }
01330 
01331     } finally {
01332 
01333         <span class="comment">//</span>
01334         <span class="comment">//  Unlock the heap</span>
01335         <span class="comment">//</span>
01336 
01337         <span class="keywordflow">if</span> (LockAcquired) {
01338 
01339             <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
01340         }
01341     }
01342 
01343     <span class="comment">//</span>
01344     <span class="comment">//  And return to our caller</span>
01345     <span class="comment">//</span>
01346 
01347     <span class="keywordflow">return</span> Result;
01348 }
01349 
01350 
01351 <span class="comment">//</span>
01352 <span class="comment">//  Declared in nturtl.h</span>
01353 <span class="comment">//</span>
01354 
01355 BOOLEAN
<a name="l01356"></a><a class="code" href="../../d5/d9/heapdll_8c.html#a26">01356</a> <a class="code" href="../../d5/d9/heapdll_8c.html#a26">RtlSetUserValueHeap</a> (
01357     IN PVOID HeapHandle,
01358     IN ULONG Flags,
01359     IN PVOID BaseAddress,
01360     IN PVOID UserValue
01361     )
01362 
01363 <span class="comment">/*++</span>
01364 <span class="comment"></span>
01365 <span class="comment">Routine Description:</span>
01366 <span class="comment"></span>
01367 <span class="comment">    This routine is used to set the user settable value for a heap entry</span>
01368 <span class="comment"></span>
01369 <span class="comment">Arguments:</span>
01370 <span class="comment"></span>
01371 <span class="comment">    HeapHandle - Supplies a pointer to the heap being modified</span>
01372 <span class="comment"></span>
01373 <span class="comment">    Flags - Supplies a set of flags needed to augment those already enforced</span>
01374 <span class="comment">        by the heap</span>
01375 <span class="comment"></span>
01376 <span class="comment">    BaseAddress - Supplies a pointer to the heap entry allocation being</span>
01377 <span class="comment">        modified</span>
01378 <span class="comment"></span>
01379 <span class="comment">    UserValue - Supplies the value to store in the extra stuff space of</span>
01380 <span class="comment">        the heap entry</span>
01381 <span class="comment"></span>
01382 <span class="comment">Return Value:</span>
01383 <span class="comment"></span>
01384 <span class="comment">    BOOLEAN - TRUE if the setting worked, and FALSE otherwise.  It could be</span>
01385 <span class="comment">        FALSE if the base address is invalid, or if there is not room for</span>
01386 <span class="comment">        the extra stuff</span>
01387 <span class="comment"></span>
01388 <span class="comment">--*/</span>
01389 
01390 {
01391     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
01392     <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a> BusyBlock;
01393     <a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html">PHEAP_ENTRY_EXTRA</a> ExtraStuff;
01394     BOOLEAN LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01395     BOOLEAN Result;
01396 
01397     <span class="comment">//</span>
01398     <span class="comment">//  Augment the set of flags</span>
01399     <span class="comment">//</span>
01400 
01401     Flags |= Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o3">ForceFlags</a>;
01402 
01403     <span class="comment">//</span>
01404     <span class="comment">//  Check to see if we should be going the debug route</span>
01405     <span class="comment">//</span>
01406 
01407     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a8">DEBUG_HEAP</a>( Flags )) {
01408 
01409         <span class="keywordflow">return</span> <a class="code" href="../../d5/d9/heapdll_8c.html#a10">RtlDebugSetUserValueHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, Flags, BaseAddress, UserValue );
01410     }
01411 
01412     Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01413 
01414     <span class="keywordflow">try</span> {
01415 
01416         <span class="comment">//</span>
01417         <span class="comment">//  Lock the heap</span>
01418         <span class="comment">//</span>
01419 
01420         <span class="keywordflow">if</span> (!(Flags &amp; HEAP_NO_SERIALIZE)) {
01421 
01422             <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
01423 
01424             LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01425         }
01426 
01427         <span class="comment">//</span>
01428         <span class="comment">//  Get a pointer to the owning heap entry</span>
01429         <span class="comment">//</span>
01430 
01431         BusyBlock = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)BaseAddress - 1;
01432 
01433         <span class="comment">//</span>
01434         <span class="comment">//  If the entry is not in use then its is an error</span>
01435         <span class="comment">//</span>
01436 
01437         <span class="keywordflow">if</span> (!(BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a8">HEAP_ENTRY_BUSY</a>)) {
01438 
01439             <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( STATUS_INVALID_PARAMETER );
01440 
01441         <span class="comment">//</span>
01442         <span class="comment">//  Otherwise we only can set the value if the entry has space</span>
01443         <span class="comment">//  for the extra stuff</span>
01444         <span class="comment">//</span>
01445 
01446         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a9">HEAP_ENTRY_EXTRA_PRESENT</a>) {
01447 
01448             ExtraStuff = <a class="code" href="../../d9/d9/heappriv_8h.html#a41">RtlpGetExtraStuffPointer</a>( BusyBlock );
01449 
01450             ExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o2">Settable</a> = (ULONG_PTR)UserValue;
01451 
01452             Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01453         }
01454 
01455     } finally {
01456 
01457         <span class="comment">//</span>
01458         <span class="comment">//  Unlock the heap</span>
01459         <span class="comment">//</span>
01460 
01461         <span class="keywordflow">if</span> (LockAcquired) {
01462 
01463             <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
01464         }
01465     }
01466 
01467     <span class="comment">//</span>
01468     <span class="comment">//  And return to our caller</span>
01469     <span class="comment">//</span>
01470 
01471     <span class="keywordflow">return</span> Result;
01472 }
01473 
01474 
01475 <span class="comment">//</span>
01476 <span class="comment">//  Declared in nturtl.h</span>
01477 <span class="comment">//</span>
01478 
01479 BOOLEAN
<a name="l01480"></a><a class="code" href="../../d5/d9/heapdll_8c.html#a27">01480</a> <a class="code" href="../../d5/d9/heapdll_8c.html#a27">RtlSetUserFlagsHeap</a> (
01481     IN PVOID HeapHandle,
01482     IN ULONG Flags,
01483     IN PVOID BaseAddress,
01484     IN ULONG UserFlagsReset,
01485     IN ULONG UserFlagsSet
01486     )
01487 
01488 <span class="comment">/*++</span>
01489 <span class="comment"></span>
01490 <span class="comment">Routine Description:</span>
01491 <span class="comment"></span>
01492 <span class="comment">    HeapHandle - Supplies a pointer to the heap being modified</span>
01493 <span class="comment"></span>
01494 <span class="comment">    Flags - Supplies a set of flags needed to augment those already enforced</span>
01495 <span class="comment">        by the heap</span>
01496 <span class="comment"></span>
01497 <span class="comment">    BaseAddress - Supplies a pointer to the heap entry allocation being</span>
01498 <span class="comment">        modified</span>
01499 <span class="comment"></span>
01500 <span class="comment">    UserFlagsReset - Supplies a mask of flags that the user wants cleared</span>
01501 <span class="comment"></span>
01502 <span class="comment">    UserFlagsSet- Supplies a mask of flags that the user wants set</span>
01503 <span class="comment"></span>
01504 <span class="comment">Return Value:</span>
01505 <span class="comment"></span>
01506 <span class="comment">    BOOLEAN - TRUE if the operation is a success and FALSE otherwise</span>
01507 <span class="comment"></span>
01508 <span class="comment">--*/</span>
01509 
01510 {
01511     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
01512     <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a> BusyBlock;
01513     BOOLEAN LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01514     BOOLEAN Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01515 
01516     <span class="comment">//</span>
01517     <span class="comment">//  Augment the set of flags</span>
01518     <span class="comment">//</span>
01519 
01520     Flags |= Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o3">ForceFlags</a>;
01521 
01522     <span class="comment">//</span>
01523     <span class="comment">//  Check to see if we should be going the debug route</span>
01524     <span class="comment">//</span>
01525 
01526     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a8">DEBUG_HEAP</a>( Flags )) {
01527 
01528         <span class="keywordflow">return</span> <a class="code" href="../../d5/d9/heapdll_8c.html#a11">RtlDebugSetUserFlagsHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, Flags, BaseAddress, UserFlagsReset, UserFlagsSet );
01529     }
01530 
01531     <span class="keywordflow">try</span> {
01532 
01533         <span class="comment">//</span>
01534         <span class="comment">//  Lock the heap</span>
01535         <span class="comment">//</span>
01536 
01537         <span class="keywordflow">if</span> (!(Flags &amp; HEAP_NO_SERIALIZE)) {
01538 
01539             <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
01540 
01541             LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01542         }
01543 
01544         <span class="keywordflow">try</span> {
01545 
01546             <span class="comment">//</span>
01547             <span class="comment">//  Get a pointer to the owning heap entry</span>
01548             <span class="comment">//</span>
01549 
01550             BusyBlock = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)BaseAddress - 1;
01551 
01552             <span class="comment">//</span>
01553             <span class="comment">//  If the entry is not in use then it is an error</span>
01554             <span class="comment">//</span>
01555 
01556             <span class="keywordflow">if</span> (!(BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a8">HEAP_ENTRY_BUSY</a>)) {
01557 
01558                 <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( STATUS_INVALID_PARAMETER );
01559 
01560             } <span class="keywordflow">else</span> {
01561 
01562                 <span class="comment">//</span>
01563                 <span class="comment">//  Otherwise modify the flags in the block</span>
01564                 <span class="comment">//</span>
01565                 <span class="comment">//  **** this is terrible error prone if the user passes in</span>
01566                 <span class="comment">//  **** flags that aren't 0x200 0x400 or 0x800 only.</span>
01567                 <span class="comment">//</span>
01568 
01569                 BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp;= ~(UserFlagsReset &gt;&gt; 4);
01570                 BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> |= (UserFlagsSet &gt;&gt; 4);
01571 
01572                 Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01573             }
01574 
01575         } except( <a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a> ) {
01576 
01577             <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( GetExceptionCode() );
01578 
01579             Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01580         }
01581 
01582     } finally {
01583 
01584         <span class="comment">//</span>
01585         <span class="comment">//  Unlock the heap</span>
01586         <span class="comment">//</span>
01587 
01588         <span class="keywordflow">if</span> (LockAcquired) {
01589 
01590             <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
01591         }
01592     }
01593 
01594     <span class="keywordflow">return</span> Result;
01595 }
01596 
01597 
01598 <span class="comment">//</span>
01599 <span class="comment">//  Declared in nturtl.h</span>
01600 <span class="comment">//</span>
01601 
01602 ULONG
<a name="l01603"></a><a class="code" href="../../d5/d9/heapdll_8c.html#a28">01603</a> <a class="code" href="../../d5/d9/heapdll_8c.html#a28">RtlCreateTagHeap</a> (
01604     IN PVOID HeapHandle,
01605     IN ULONG Flags,
01606     IN PWSTR TagPrefix OPTIONAL,
01607     IN PWSTR TagNames
01608     )
01609 
01610 <span class="comment">/*++</span>
01611 <span class="comment"></span>
01612 <span class="comment">Routine Description:</span>
01613 <span class="comment"></span>
01614 <span class="comment">    This routine create a tag heap for either the specified heap or</span>
01615 <span class="comment">    for the global tag heap.</span>
01616 <span class="comment"></span>
01617 <span class="comment">Arguments:</span>
01618 <span class="comment"></span>
01619 <span class="comment">    HeapHandle - Optionally supplies a pointer to the heap that we</span>
01620 <span class="comment">        want modified.  If null then the global tag heap is used</span>
01621 <span class="comment"></span>
01622 <span class="comment">    Flags - Supplies a list of flags to augment the flags already</span>
01623 <span class="comment">        enforced by the heap</span>
01624 <span class="comment"></span>
01625 <span class="comment">    TagPrefix - Optionally supplies a null terminated wchar string</span>
01626 <span class="comment">        of a prefix to add to each tag</span>
01627 <span class="comment"></span>
01628 <span class="comment">    TagNames - Supplies a list of tag names separated by null and terminated</span>
01629 <span class="comment">        by a double null.  If the first name in the list start with</span>
01630 <span class="comment">        a "!" then it is interpreted as the heap name.  The syntax</span>
01631 <span class="comment">        for the tag name is</span>
01632 <span class="comment"></span>
01633 <span class="comment">            [!&lt;heapname&gt; nul ] {&lt;tagname&gt; nul}* nul</span>
01634 <span class="comment"></span>
01635 <span class="comment">Return Value:</span>
01636 <span class="comment"></span>
01637 <span class="comment">    ULONG - returns the index of the last tag create shifted to the high</span>
01638 <span class="comment">        order word.</span>
01639 <span class="comment"></span>
01640 <span class="comment">--*/</span>
01641 
01642 {
01643     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
01644     BOOLEAN LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01645     ULONG TagIndex;
01646     ULONG NumberOfTags, MaxTagNameLength, TagPrefixLength;
01647     PWSTR s, s1, HeapName;
01648     <a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html">PHEAP_TAG_ENTRY</a> TagEntry;
01649     ULONG Result;
01650 
01651     <span class="comment">//</span>
01652     <span class="comment">//  Check if tagging is disable and so this call is a noop</span>
01653     <span class="comment">//</span>
01654 
01655     <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d9/heappriv_8h.html#a22">IS_HEAP_TAGGING_ENABLED</a>()) {
01656 
01657         <span class="keywordflow">return</span> 0;
01658     }
01659 
01660     <span class="comment">//</span>
01661     <span class="comment">//  If the processes global tag heap has not been created yet then</span>
01662     <span class="comment">//  allocate a global tag heap</span>
01663     <span class="comment">//</span>
01664 
01665     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d9/heap_8h.html#a64">RtlpGlobalTagHeap</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01666 
01667         <a class="code" href="../../d3/d9/heap_8h.html#a64">RtlpGlobalTagHeap</a> = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>( RtlProcessHeap( ), HEAP_ZERO_MEMORY, <span class="keyword">sizeof</span>( <a class="code" href="../../d5/d5/struct__HEAP.html">HEAP</a> ));
01668 
01669         <span class="keywordflow">if</span> (<a class="code" href="../../d3/d9/heap_8h.html#a64">RtlpGlobalTagHeap</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01670 
01671             <span class="keywordflow">return</span> 0;
01672         }
01673     }
01674 
01675     <span class="keywordflow">try</span> {
01676 
01677         <span class="comment">//</span>
01678         <span class="comment">//  If the user passed in a heap then we'll use the lock from that</span>
01679         <span class="comment">//  heap to synchronize our work.  Otherwise we're unsynchronized</span>
01680         <span class="comment">//</span>
01681 
01682         <span class="keywordflow">if</span> (Heap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01683 
01684             <span class="comment">//</span>
01685             <span class="comment">//  Tagging is not part of the guard page heap package</span>
01686             <span class="comment">//</span>
01687 
01688             <a class="code" href="../../d7/d9/heappage_8h.html#a6">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0 );
01689 
01690             <span class="comment">//</span>
01691             <span class="comment">//  Check if we should be calling the debug version of the heap package</span>
01692             <span class="comment">//</span>
01693 
01694             <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a8">DEBUG_HEAP</a>( Flags )) {
01695 
01696                 Result = <a class="code" href="../../d5/d9/heapdll_8c.html#a13">RtlDebugCreateTagHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, Flags, TagPrefix, TagNames );
01697                 leave;
01698             }
01699 
01700             <span class="comment">//</span>
01701             <span class="comment">//  Augment the flags and lock the specified heap</span>
01702             <span class="comment">//</span>
01703 
01704             Flags |= Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o3">ForceFlags</a>;
01705 
01706             <span class="keywordflow">if</span> (!(Flags &amp; HEAP_NO_SERIALIZE)) {
01707 
01708                 <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
01709 
01710                 LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01711             }
01712         }
01713 
01714         <span class="comment">//</span>
01715         <span class="comment">//  We start off with zero tags</span>
01716         <span class="comment">//</span>
01717 
01718         TagIndex = 0;
01719         NumberOfTags = 0;
01720 
01721         <span class="comment">//</span>
01722         <span class="comment">//  With tag names that start with "!" we assume what follows</span>
01723         <span class="comment">//  is a heap name.</span>
01724         <span class="comment">//</span>
01725 
01726         <span class="keywordflow">if</span> (*TagNames == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'!'</span>) {
01727 
01728             HeapName = TagNames + 1;
01729 
01730             <span class="comment">//</span>
01731             <span class="comment">//  Move up to the following tag name after the heap name</span>
01732             <span class="comment">//  separated by a null</span>
01733             <span class="comment">//</span>
01734 
01735             <span class="keywordflow">while</span> (*TagNames++) { NOTHING; }
01736 
01737         } <span class="keywordflow">else</span> {
01738 
01739             HeapName = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01740         }
01741 
01742         <span class="comment">//</span>
01743         <span class="comment">//  Gobble up each tag name keeping count of how many we find</span>
01744         <span class="comment">//</span>
01745 
01746         s = TagNames;
01747 
01748         <span class="keywordflow">while</span> (*s) {
01749 
01750             <span class="keywordflow">while</span> (*s++) { NOTHING; }
01751 
01752             NumberOfTags += 1;
01753         }
01754 
01755         <span class="comment">//</span>
01756         <span class="comment">//  Now we will only continue on if we were supplied tag names</span>
01757         <span class="comment">//</span>
01758 
01759         <span class="keywordflow">if</span> (NumberOfTags &gt; 0) {
01760 
01761             <span class="comment">//</span>
01762             <span class="comment">//  Allocate heap entries for the number of tags we need and</span>
01763             <span class="comment">//  only proceed if this allocation succeeded.   The following</span>
01764             <span class="comment">//  call also makes room for the heap name as tag index 0.  Note</span>
01765             <span class="comment">//  that is heap is null then we assume we're using the global</span>
01766             <span class="comment">//  tag heap</span>
01767             <span class="comment">//</span>
01768 
01769             TagEntry = <a class="code" href="../../d5/d9/heapdll_8c.html#a17">RtlpAllocateTags</a>( Heap, NumberOfTags );
01770 
01771             <span class="keywordflow">if</span> (TagEntry != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01772 
01773                 MaxTagNameLength = (<span class="keyword">sizeof</span>( TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o5">TagName</a> ) / <span class="keyword">sizeof</span>( WCHAR )) - 1;
01774 
01775                 TagIndex = TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o3">TagIndex</a>;
01776 
01777                 <span class="comment">//</span>
01778                 <span class="comment">//  If the first tag index is zero then we'll make this tag entry</span>
01779                 <span class="comment">//  the heap name.</span>
01780                 <span class="comment">//</span>
01781 
01782                 <span class="keywordflow">if</span> (TagIndex == 0) {
01783 
01784                     <span class="keywordflow">if</span> (HeapName != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
01785 
01786                         <span class="comment">//</span>
01787                         <span class="comment">//  Copy over the heap name and pad it out with nulls up</span>
01788                         <span class="comment">//  to the end of the name buffer</span>
01789                         <span class="comment">//</span>
01790 
01791                         wcsncpy( TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o5">TagName</a>, HeapName, MaxTagNameLength );
01792                     }
01793 
01794                     <span class="comment">//</span>
01795                     <span class="comment">//  Whether we add a heap name or not we'll move on to the</span>
01796                     <span class="comment">//  next tag entry and index</span>
01797                     <span class="comment">//</span>
01798 
01799                     TagEntry += 1;
01800 
01801                     TagIndex = TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o3">TagIndex</a>;
01802 
01803                 <span class="comment">//</span>
01804                 <span class="comment">//  This isn't the first index for a specified heap, but see if</span>
01805                 <span class="comment">//  it is the first index for the global heap.  If so then put</span>
01806                 <span class="comment">//  name of the global tags into the 0 index</span>
01807                 <span class="comment">//</span>
01808 
01809                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (TagIndex == HEAP_GLOBAL_TAG) {
01810 
01811                     wcsncpy( TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o5">TagName</a>, <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"GlobalTags"</span>, MaxTagNameLength );
01812 
01813                     TagEntry += 1;
01814 
01815                     TagIndex = TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o3">TagIndex</a>;
01816                 }
01817 
01818                 <span class="comment">//</span>
01819                 <span class="comment">//  Now we've taken case of the 0 index we'll go on to the rest of</span>
01820                 <span class="comment">//  the tags.  If there is tag prefix and it is not zero length</span>
01821                 <span class="comment">//  then we'll use this tag prefix provided that is leaves us at</span>
01822                 <span class="comment">//  least 4 characters for the tag name itself.  Otherwise we'll</span>
01823                 <span class="comment">//  ignore the tag prefix (by setting the variable to null).</span>
01824                 <span class="comment">//</span>
01825 
01826                 <span class="keywordflow">if</span> ((ARGUMENT_PRESENT( TagPrefix )) &amp;&amp;
01827                     (TagPrefixLength = wcslen( TagPrefix ))) {
01828 
01829                     <span class="keywordflow">if</span> (TagPrefixLength &gt;= MaxTagNameLength-4) {
01830 
01831                         TagPrefix = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01832 
01833                     } <span class="keywordflow">else</span> {
01834 
01835                         MaxTagNameLength -= TagPrefixLength;
01836                     }
01837 
01838                 } <span class="keywordflow">else</span> {
01839 
01840                     TagPrefix = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01841                 }
01842 
01843                 <span class="comment">//</span>
01844                 <span class="comment">//  For every tag name (note that this varable has already been</span>
01845                 <span class="comment">//  advanced beyond the heap name) we'll put it in a tag entry</span>
01846                 <span class="comment">//  by copying in the prefix and then appending on the tag itself</span>
01847                 <span class="comment">//</span>
01848                 <span class="comment">//   s points to the current users supplied tag name</span>
01849                 <span class="comment">//  s1 points to the tag name buffer in the current tag entry</span>
01850                 <span class="comment">//</span>
01851 
01852                 s = TagNames;
01853 
01854                 <span class="keywordflow">while</span> (*s) {
01855 
01856                     s1 = TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o5">TagName</a>;
01857 
01858                     <span class="comment">//</span>
01859                     <span class="comment">//  Copy in the optional tag prefix and update s1</span>
01860                     <span class="comment">//</span>
01861 
01862                     <span class="keywordflow">if</span> (ARGUMENT_PRESENT( TagPrefix )) {
01863 
01864                         wcscpy( s1, TagPrefix );
01865 
01866                         s1 += TagPrefixLength;
01867                     }
01868 
01869                     <span class="comment">//</span>
01870                     <span class="comment">//  Copy over the remaining tag name padding it with nulls</span>
01871                     <span class="comment">//  up to the end of the name buffer</span>
01872                     <span class="comment">//</span>
01873 
01874                     wcsncpy( s1, s, MaxTagNameLength );
01875 
01876                     <span class="comment">//</span>
01877                     <span class="comment">//  Skip to the next tag name</span>
01878                     <span class="comment">//</span>
01879 
01880                     <span class="keywordflow">while</span> (*s++) { NOTHING; }
01881 
01882                     <span class="comment">//</span>
01883                     <span class="comment">//  Skip to the next tag entry</span>
01884                     <span class="comment">//</span>
01885 
01886                     TagEntry += 1;
01887                 }
01888             }
01889         }
01890 
01891         Result = TagIndex &lt;&lt; HEAP_TAG_SHIFT;
01892 
01893     } finally {
01894 
01895         <span class="comment">//</span>
01896         <span class="comment">//  Unlock the heap</span>
01897         <span class="comment">//</span>
01898 
01899         <span class="keywordflow">if</span> (LockAcquired) {
01900 
01901             <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
01902         }
01903     }
01904 
01905     <span class="comment">//</span>
01906     <span class="comment">//  And return to our caller.  The answer we return is the last tag index</span>
01907     <span class="comment">//  stored in the high word of a ulong result</span>
01908     <span class="comment">//</span>
01909 
01910     <span class="keywordflow">return</span> Result;
01911 }
01912 
01913 
01914 <span class="comment">//</span>
01915 <span class="comment">//  Declared in nturtl.h</span>
01916 <span class="comment">//</span>
01917 
01918 PWSTR
<a name="l01919"></a><a class="code" href="../../d5/d9/heapdll_8c.html#a29">01919</a> <a class="code" href="../../d5/d9/heapdll_8c.html#a29">RtlQueryTagHeap</a> (
01920     IN PVOID HeapHandle,
01921     IN ULONG Flags,
01922     IN USHORT TagIndex,
01923     IN BOOLEAN ResetCounters,
01924     OUT PRTL_HEAP_TAG_INFO TagInfo OPTIONAL
01925     )
01926 
01927 <span class="comment">/*++</span>
01928 <span class="comment"></span>
01929 <span class="comment">Routine Description:</span>
01930 <span class="comment"></span>
01931 <span class="comment">    This routine returns the name and optional statistics for a given</span>
01932 <span class="comment">    tag index.</span>
01933 <span class="comment"></span>
01934 <span class="comment">Arguments:</span>
01935 <span class="comment"></span>
01936 <span class="comment">        **** note that some of the code looks like it can handle the</span>
01937 <span class="comment">        **** global tag heap but other places look rather wrong</span>
01938 <span class="comment"></span>
01939 <span class="comment">    HeapHandle - Specifies the heap being queried.  If null then the</span>
01940 <span class="comment">        global tag heap is used.</span>
01941 <span class="comment"></span>
01942 <span class="comment">    Flags - Supplies a set flags to augment those enforced by the</span>
01943 <span class="comment">        heap</span>
01944 <span class="comment"></span>
01945 <span class="comment">    TagIndex - Specifies the tag index that we want to query</span>
01946 <span class="comment"></span>
01947 <span class="comment">    ResetCounter - Specifies if this routine should reset the counter</span>
01948 <span class="comment">        for the tag after the query</span>
01949 <span class="comment"></span>
01950 <span class="comment">    TagInfo - Optionally supplies storage where the output tag information</span>
01951 <span class="comment">        should be stored</span>
01952 <span class="comment"></span>
01953 <span class="comment">Return Value:</span>
01954 <span class="comment"></span>
01955 <span class="comment">    PWSTR - Returns a pointer to the tag name or NULL if the index</span>
01956 <span class="comment">        doesn't exist</span>
01957 <span class="comment"></span>
01958 <span class="comment">--*/</span>
01959 
01960 {
01961     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
01962     BOOLEAN LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01963     <a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html">PHEAP_TAG_ENTRY</a> TagEntry;
01964     PWSTR Result;
01965 
01966     <span class="comment">//</span>
01967     <span class="comment">//  Tagging is not part of the guard page heap package</span>
01968     <span class="comment">//</span>
01969 
01970     <a class="code" href="../../d7/d9/heappage_8h.html#a6">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01971 
01972     <span class="comment">//</span>
01973     <span class="comment">//  Check if tagging is disabled</span>
01974     <span class="comment">//</span>
01975 
01976     <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d9/heappriv_8h.html#a22">IS_HEAP_TAGGING_ENABLED</a>()) {
01977 
01978         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01979     }
01980 
01981     <span class="keywordflow">try</span> {
01982 
01983         <span class="comment">//</span>
01984         <span class="comment">//  Check if the caller has given us a heap to query</span>
01985         <span class="comment">//</span>
01986 
01987         <span class="keywordflow">if</span> (Heap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01988 
01989             <span class="comment">//</span>
01990             <span class="comment">//  Check if we should be using the debug version of the</span>
01991             <span class="comment">//  heap package</span>
01992             <span class="comment">//</span>
01993 
01994             <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a8">DEBUG_HEAP</a>( Flags )) {
01995 
01996                 Result = <a class="code" href="../../d5/d9/heapdll_8c.html#a14">RtlDebugQueryTagHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, Flags, TagIndex, ResetCounters, TagInfo );
01997                 leave;
01998             }
01999 
02000             <span class="comment">//</span>
02001             <span class="comment">//  Lock the heap</span>
02002             <span class="comment">//</span>
02003 
02004             Flags |= Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o3">ForceFlags</a>;
02005 
02006             <span class="keywordflow">if</span> (!(Flags &amp; HEAP_NO_SERIALIZE)) {
02007 
02008                 <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
02009 
02010                 LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02011             }
02012         }
02013 
02014         Result = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02015 
02016         <span class="comment">//</span>
02017         <span class="comment">//  **** note that the next test assumes that heap is not null</span>
02018         <span class="comment">//</span>
02019         <span class="comment">//  Check that the specified tag index is valid and that the</span>
02020         <span class="comment">//  this heap does actually have some tag entries</span>
02021         <span class="comment">//</span>
02022 
02023         <span class="keywordflow">if</span> ((TagIndex &lt; Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o14">NextAvailableTagIndex</a>) &amp;&amp;
02024             (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
02025 
02026             <span class="comment">//</span>
02027             <span class="comment">//  Stride over to the specific tag entry and if the caller gave us</span>
02028             <span class="comment">//  an output buffer then fill in the details</span>
02029             <span class="comment">//</span>
02030 
02031             TagEntry = Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a> + TagIndex;
02032 
02033             <span class="keywordflow">if</span> (ARGUMENT_PRESENT( TagInfo )) {
02034 
02035                 TagInfo-&gt;NumberOfAllocations = TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o0">Allocs</a>;
02036                 TagInfo-&gt;NumberOfFrees = TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o1">Frees</a>;
02037                 TagInfo-&gt;BytesAllocated = TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o2">Size</a> &lt;&lt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>;
02038             }
02039 
02040             <span class="comment">//</span>
02041             <span class="comment">//  Check if we should reset the counters</span>
02042             <span class="comment">//</span>
02043 
02044             <span class="keywordflow">if</span> (ResetCounters) {
02045 
02046                 TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o0">Allocs</a> = 0;
02047                 TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o1">Frees</a> = 0;
02048                 TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o2">Size</a> = 0;
02049             }
02050 
02051             <span class="comment">//</span>
02052             <span class="comment">//  Point to the tag name</span>
02053             <span class="comment">//</span>
02054 
02055             Result = &amp;TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o5">TagName</a>[ 0 ];
02056 
02057         <span class="comment">//</span>
02058         <span class="comment">//  If the tag index has the psuedo tag bit set then recalulate the</span>
02059         <span class="comment">//  tag index and if this heap has pseudo tags than that is what</span>
02060         <span class="comment">//  we'll return</span>
02061         <span class="comment">//</span>
02062 
02063         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (TagIndex &amp; HEAP_PSEUDO_TAG_FLAG) {
02064 
02065             <span class="comment">//</span>
02066             <span class="comment">//  Clear the bit</span>
02067             <span class="comment">//</span>
02068 
02069             TagIndex ^= HEAP_PSEUDO_TAG_FLAG;
02070 
02071             <span class="keywordflow">if</span> ((TagIndex &lt; <a class="code" href="../../d3/d9/heap_8h.html#a32">HEAP_NUMBER_OF_PSEUDO_TAG</a>) &amp;&amp;
02072                 (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o29">PseudoTagEntries</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
02073 
02074                 <span class="comment">//</span>
02075                 <span class="comment">//  Stride over to the specific pseudo tag entry and if the</span>
02076                 <span class="comment">//  caller gave us an output buffer then fill in the details</span>
02077                 <span class="comment">//</span>
02078 
02079                 TagEntry = (<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html">PHEAP_TAG_ENTRY</a>)(Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o29">PseudoTagEntries</a> + TagIndex);
02080 
02081                 <span class="keywordflow">if</span> (ARGUMENT_PRESENT( TagInfo )) {
02082 
02083                     TagInfo-&gt;NumberOfAllocations = TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o0">Allocs</a>;
02084                     TagInfo-&gt;NumberOfFrees = TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o1">Frees</a>;
02085                     TagInfo-&gt;BytesAllocated = TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o2">Size</a> &lt;&lt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>;
02086                 }
02087 
02088                 <span class="comment">//</span>
02089                 <span class="comment">//  Check if we should reset the counters</span>
02090                 <span class="comment">//</span>
02091 
02092                 <span class="keywordflow">if</span> (ResetCounters) {
02093 
02094                     TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o0">Allocs</a> = 0;
02095                     TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o1">Frees</a> = 0;
02096                     TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o2">Size</a> = 0;
02097                 }
02098 
02099                 <span class="comment">//</span>
02100                 <span class="comment">//  Pseudo tags do not have names</span>
02101                 <span class="comment">//</span>
02102 
02103                 Result = <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">""</span>;
02104             }
02105         }
02106 
02107     } finally {
02108 
02109         <span class="comment">//</span>
02110         <span class="comment">//  Unlock the heap</span>
02111         <span class="comment">//</span>
02112 
02113         <span class="keywordflow">if</span> (LockAcquired) {
02114 
02115             <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
02116         }
02117     }
02118 
02119     <span class="comment">//</span>
02120     <span class="comment">//  And return the tag name to our caller</span>
02121     <span class="comment">//</span>
02122 
02123     <span class="keywordflow">return</span> Result;
02124 }
02125 
02126 
02127 <span class="comment">//</span>
02128 <span class="comment">//  Declared in nturtl.h</span>
02129 <span class="comment">//</span>
02130 
02131 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l02132"></a><a class="code" href="../../d5/d9/heapdll_8c.html#a30">02132</a> <a class="code" href="../../d5/d9/heapdll_8c.html#a30">RtlExtendHeap</a> (
02133     IN PVOID HeapHandle,
02134     IN ULONG Flags,
02135     IN PVOID Base,
02136     IN SIZE_T Size
02137     )
02138 
02139 <span class="comment">/*++</span>
02140 <span class="comment"></span>
02141 <span class="comment">Routine Description:</span>
02142 <span class="comment"></span>
02143 <span class="comment">    This routine grows the specified heap by adding a new segment to its</span>
02144 <span class="comment">    storage.  The memory for the segment is supplied by the caller.</span>
02145 <span class="comment"></span>
02146 <span class="comment">Arguments:</span>
02147 <span class="comment"></span>
02148 <span class="comment">    HeapHandle - Supplies a pointer to the heap being modified</span>
02149 <span class="comment"></span>
02150 <span class="comment">    Flags - Supplies a set of flags used to augment those already</span>
02151 <span class="comment">        enforced by the heap</span>
02152 <span class="comment"></span>
02153 <span class="comment">    Base - Supplies the starting address for the new segment being added</span>
02154 <span class="comment">        to the input heap</span>
02155 <span class="comment"></span>
02156 <span class="comment">    Size - Supplies the size, in bytes, of the new segment. Note that this</span>
02157 <span class="comment">        routine will actually use more memory than specified by this</span>
02158 <span class="comment">        variable.  It will use whatever is committed and reserved provided</span>
02159 <span class="comment">        the amount is greater than or equal to "Size"</span>
02160 <span class="comment"></span>
02161 <span class="comment">Return Value:</span>
02162 <span class="comment"></span>
02163 <span class="comment">    NTSTATUS - An appropriate status value</span>
02164 <span class="comment"></span>
02165 <span class="comment">--*/</span>
02166 
02167 {
02168     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
02169     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02170     <a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a> Segment;
02171     BOOLEAN LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02172     UCHAR SegmentIndex, EmptySegmentIndex;
02173     SIZE_T CommitSize;
02174     SIZE_T ReserveSize;
02175     ULONG SegmentFlags;
02176     PVOID CommittedBase;
02177     PVOID UnCommittedBase;
02178     MEMORY_BASIC_INFORMATION MemoryInformation;
02179 
02180     <span class="comment">//</span>
02181     <span class="comment">//  Check if the guard page version of heap can do the work</span>
02182     <span class="comment">//</span>
02183 
02184     <a class="code" href="../../d7/d9/heappage_8h.html#a6">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>,
02185                                     <a class="code" href="../../d7/d9/heappage_8h.html#a25">RtlpDebugPageHeapExtend</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, Flags, Base, <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> ));
02186 
02187     <span class="comment">//</span>
02188     <span class="comment">//  See what Mm thinks about the base address we were passed in.</span>
02189     <span class="comment">//  The address must not be free.</span>
02190     <span class="comment">//</span>
02191 
02192     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d5/d3/queryvm_8c.html#a4">NtQueryVirtualMemory</a>( NtCurrentProcess(),
02193                                    Base,
02194                                    MemoryBasicInformation,
02195                                    &amp;MemoryInformation,
02196                                    <span class="keyword">sizeof</span>( MemoryInformation ),
02197                                    <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
02198 
02199     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
02200 
02201         <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02202     }
02203 
02204     <span class="keywordflow">if</span> (MemoryInformation.State == MEM_FREE) {
02205 
02206         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
02207     }
02208 
02209     <span class="comment">//</span>
02210     <span class="comment">//  If what we were passed in as a base address is not on a page boundary then</span>
02211     <span class="comment">//  adjust the information supplied by MM to the page boundary right after</span>
02212     <span class="comment">//  the input base address</span>
02213     <span class="comment">//</span>
02214 
02215     <span class="keywordflow">if</span> (MemoryInformation.BaseAddress != Base) {
02216 
02217         MemoryInformation.BaseAddress = (PCHAR)MemoryInformation.BaseAddress + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
02218         MemoryInformation.RegionSize -= <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
02219     }
02220 
02221     <span class="keywordflow">try</span> {
02222 
02223         <span class="comment">//</span>
02224         <span class="comment">//  Lock the heap</span>
02225         <span class="comment">//</span>
02226 
02227         <span class="keywordflow">if</span> (!(Flags &amp; HEAP_NO_SERIALIZE)) {
02228 
02229             <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
02230 
02231             LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02232         }
02233 
02234         <span class="comment">//</span>
02235         <span class="comment">//  Scan the heap's segment list for a free segment.  And make sure the address</span>
02236         <span class="comment">//  of all the segment does not contain the input base address</span>
02237         <span class="comment">//</span>
02238 
02239         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INSUFFICIENT_RESOURCES;
02240 
02241         EmptySegmentIndex = <a class="code" href="../../d3/d9/heap_8h.html#a7">HEAP_MAXIMUM_SEGMENTS</a>;
02242 
02243         <span class="keywordflow">for</span> (SegmentIndex=0; SegmentIndex&lt;<a class="code" href="../../d3/d9/heap_8h.html#a7">HEAP_MAXIMUM_SEGMENTS</a>; SegmentIndex++) {
02244 
02245             Segment = Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o22">Segments</a>[ SegmentIndex ];
02246 
02247             <span class="keywordflow">if</span> (Segment) {
02248 
02249                 <span class="keywordflow">if</span> (((ULONG_PTR)Base &gt;= (ULONG_PTR)Segment) &amp;&amp;
02250                     ((ULONG_PTR)Base &lt; (ULONG_PTR)(Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o8">LastValidEntry</a>))) {
02251 
02252                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_PARAMETER;
02253 
02254                     <span class="keywordflow">break</span>;
02255                 }
02256 
02257             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Segment == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
02258                        (EmptySegmentIndex == <a class="code" href="../../d3/d9/heap_8h.html#a7">HEAP_MAXIMUM_SEGMENTS</a>)) {
02259 
02260                 EmptySegmentIndex = SegmentIndex;
02261 
02262                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
02263             }
02264         }
02265 
02266         <span class="comment">//</span>
02267         <span class="comment">//  At this point if status is success then the empty segment index</span>
02268         <span class="comment">//  is available for us to use and base address doesn't overlap an</span>
02269         <span class="comment">//  existing segment.</span>
02270         <span class="comment">//</span>
02271 
02272         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
02273 
02274             <span class="comment">//</span>
02275             <span class="comment">//  Indicate that this segment is user supplied</span>
02276             <span class="comment">//</span>
02277 
02278             SegmentFlags = <a class="code" href="../../d3/d9/heap_8h.html#a18">HEAP_SEGMENT_USER_ALLOCATED</a>;
02279 
02280             CommittedBase = MemoryInformation.BaseAddress;
02281 
02282             <span class="comment">//</span>
02283             <span class="comment">//  If the start of the memory supplied by the use is already</span>
02284             <span class="comment">//  committed then check the state of the following</span>
02285             <span class="comment">//  uncommitted piece of memory to see if it is reserved</span>
02286             <span class="comment">//</span>
02287 
02288             <span class="keywordflow">if</span> (MemoryInformation.State == MEM_COMMIT) {
02289 
02290                 CommitSize = MemoryInformation.RegionSize;
02291 
02292                 UnCommittedBase = (PCHAR)CommittedBase + CommitSize;
02293 
02294                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d5/d3/queryvm_8c.html#a4">NtQueryVirtualMemory</a>( NtCurrentProcess(),
02295                                                UnCommittedBase,
02296                                                MemoryBasicInformation,
02297                                                &amp;MemoryInformation,
02298                                                <span class="keyword">sizeof</span>( MemoryInformation ),
02299                                                <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
02300 
02301                 ReserveSize = CommitSize;
02302 
02303                 <span class="keywordflow">if</span> ((<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) &amp;&amp;
02304                     (MemoryInformation.State == MEM_RESERVE)) {
02305 
02306                     ReserveSize += MemoryInformation.RegionSize;
02307                 }
02308 
02309             } <span class="keywordflow">else</span> {
02310 
02311                 <span class="comment">//</span>
02312                 <span class="comment">//  Otherwise the user hasn't committed anything in the</span>
02313                 <span class="comment">//  the address they gave us and we know it is not free</span>
02314                 <span class="comment">//  so it must be reserved.</span>
02315                 <span class="comment">//</span>
02316 
02317                 UnCommittedBase = CommittedBase;
02318 
02319                 ReserveSize = MemoryInformation.RegionSize;
02320             }
02321 
02322             <span class="comment">//</span>
02323             <span class="comment">//  Now if the reserved size is smaller than a page size or</span>
02324             <span class="comment">//  the user specified size is greater than the reserved size</span>
02325             <span class="comment">//  then the buffer we're given is too small to be a segment</span>
02326             <span class="comment">//  of heap</span>
02327             <span class="comment">//</span>
02328 
02329             <span class="keywordflow">if</span> ((ReserveSize &lt; <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>) ||
02330                 (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> &gt; ReserveSize)) {
02331 
02332                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_BUFFER_TOO_SMALL;
02333 
02334             } <span class="keywordflow">else</span> {
02335 
02336                 <span class="comment">//</span>
02337                 <span class="comment">//  Otherwise the size is okay, now check if we need</span>
02338                 <span class="comment">//  to do the commit of the base.  If so we'll commit</span>
02339                 <span class="comment">//  one page</span>
02340 
02341                 <span class="keywordflow">if</span> (UnCommittedBase == CommittedBase) {
02342 
02343                     CommitSize = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
02344 
02345                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwAllocateVirtualMemory( NtCurrentProcess(),
02346                                                       (PVOID *)&amp;Segment,
02347                                                       0,
02348                                                       &amp;CommitSize,
02349                                                       MEM_COMMIT,
02350                                                       PAGE_READWRITE );
02351                 }
02352             }
02353 
02354             <span class="comment">//</span>
02355             <span class="comment">//  At this point the if status is good then memory is all set up</span>
02356             <span class="comment">//  with at least one page of committed memory to start with.  So</span>
02357             <span class="comment">//  initialize the heap segment and we're done.</span>
02358             <span class="comment">//</span>
02359 
02360             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
02361 
02362                 <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a33">RtlpInitializeHeapSegment</a>( Heap,
02363                                                Segment,
02364                                                EmptySegmentIndex,
02365                                                0,
02366                                                Segment,
02367                                                (PCHAR)Segment + CommitSize,
02368                                                (PCHAR)Segment + ReserveSize )) {
02369 
02370                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_NO_MEMORY;
02371                 }
02372             }
02373         }
02374 
02375     } finally {
02376 
02377         <span class="comment">//</span>
02378         <span class="comment">//  Unlock the heap</span>
02379         <span class="comment">//</span>
02380 
02381         <span class="keywordflow">if</span> (LockAcquired) {
02382 
02383             <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
02384         }
02385     }
02386 
02387     <span class="comment">//</span>
02388     <span class="comment">//  And return to our caller</span>
02389     <span class="comment">//</span>
02390 
02391     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02392 }
02393 
02394 
02395 <span class="comment">//</span>
02396 <span class="comment">//  Declared in nturtl.h</span>
02397 <span class="comment">//</span>
02398 
02399 SIZE_T
02400 NTAPI
<a name="l02401"></a><a class="code" href="../../d5/d9/heapdll_8c.html#a31">02401</a> <a class="code" href="../../d5/d9/heapdll_8c.html#a31">RtlCompactHeap</a> (
02402     IN PVOID HeapHandle,
02403     IN ULONG Flags
02404     )
02405 
02406 <span class="comment">/*++</span>
02407 <span class="comment"></span>
02408 <span class="comment">Routine Description:</span>
02409 <span class="comment"></span>
02410 <span class="comment">    This routine compacts the specified heap by coalescing all the free block.</span>
02411 <span class="comment">    It also determines the size of the largest available free block and</span>
02412 <span class="comment">    returns its, in bytes, back to the caller.</span>
02413 <span class="comment"></span>
02414 <span class="comment">Arguments:</span>
02415 <span class="comment"></span>
02416 <span class="comment">    HeapHandle - Supplies a pointer to the heap being modified</span>
02417 <span class="comment"></span>
02418 <span class="comment">    Flags - Supplies a set of flags used to augment those already</span>
02419 <span class="comment">        enforced by the heap</span>
02420 <span class="comment"></span>
02421 <span class="comment">Return Value:</span>
02422 <span class="comment"></span>
02423 <span class="comment">    SIZE_T - Returns the size, in bytes, of the largest free block</span>
02424 <span class="comment">        available in the heap</span>
02425 <span class="comment"></span>
02426 <span class="comment">--*/</span>
02427 
02428 {
02429     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
02430     <a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a> FreeBlock;
02431     <a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a> Segment;
02432     UCHAR SegmentIndex;
02433     SIZE_T LargestFreeSize;
02434     BOOLEAN LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02435 
02436     <span class="comment">//</span>
02437     <span class="comment">//  Augment the heap flags</span>
02438     <span class="comment">//</span>
02439 
02440     Flags |= Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o3">ForceFlags</a>;
02441 
02442     <span class="comment">//</span>
02443     <span class="comment">//  Check if this is a debug version of heap</span>
02444     <span class="comment">//</span>
02445 
02446     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a8">DEBUG_HEAP</a>( Flags )) {
02447 
02448         <span class="keywordflow">return</span> <a class="code" href="../../d5/d9/heapdll_8c.html#a12">RtlDebugCompactHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, Flags );
02449     }
02450 
02451     <span class="keywordflow">try</span> {
02452 
02453         <span class="comment">//</span>
02454         <span class="comment">//  Lock the heap</span>
02455         <span class="comment">//</span>
02456 
02457         <span class="keywordflow">if</span> (!(Flags &amp; HEAP_NO_SERIALIZE)) {
02458 
02459             <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
02460 
02461             LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02462         }
02463 
02464         LargestFreeSize = 0;
02465 
02466         <span class="keywordflow">try</span> {
02467 
02468             <span class="comment">//</span>
02469             <span class="comment">//  Coalesce the heap into its largest free blocks possible</span>
02470             <span class="comment">//  and get the largest free block in the heap</span>
02471             <span class="comment">//</span>
02472 
02473             FreeBlock = <a class="code" href="../../d9/d9/heappriv_8h.html#a45">RtlpCoalesceHeap</a>( (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> );
02474 
02475             <span class="comment">//</span>
02476             <span class="comment">//  If there is a free block then compute its byte size</span>
02477             <span class="comment">//</span>
02478 
02479             <span class="keywordflow">if</span> (FreeBlock != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02480 
02481                 LargestFreeSize = FreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a> &lt;&lt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>;
02482             }
02483 
02484             <span class="comment">//</span>
02485             <span class="comment">//  Scan every segment in the heap looking at its largest uncommitted</span>
02486             <span class="comment">//  range.  Remember the largest range if its bigger than anything</span>
02487             <span class="comment">//  we've found so far</span>
02488             <span class="comment">//</span>
02489 
02490             <span class="keywordflow">for</span> (SegmentIndex=0; SegmentIndex&lt;<a class="code" href="../../d3/d9/heap_8h.html#a7">HEAP_MAXIMUM_SEGMENTS</a>; SegmentIndex++) {
02491 
02492                 Segment = Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o22">Segments</a>[ SegmentIndex ];
02493 
02494                 <span class="keywordflow">if</span> (Segment &amp;&amp; Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o4">LargestUnCommittedRange</a> &gt; LargestFreeSize) {
02495 
02496                     LargestFreeSize = Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o4">LargestUnCommittedRange</a>;
02497                 }
02498             }
02499 
02500         } except( <a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a> ) {
02501 
02502             <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( GetExceptionCode() );
02503         }
02504 
02505     } finally {
02506 
02507         <span class="comment">//</span>
02508         <span class="comment">//  Unlock the heap</span>
02509         <span class="comment">//</span>
02510 
02511         <span class="keywordflow">if</span> (LockAcquired) {
02512 
02513             <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
02514         }
02515     }
02516 
02517     <span class="comment">//</span>
02518     <span class="comment">//  And return the largest free size to our caller</span>
02519     <span class="comment">//</span>
02520 
02521     <span class="keywordflow">return</span> LargestFreeSize;
02522 }
02523 
02524 
02525 <span class="comment">//</span>
02526 <span class="comment">//  Declared in nturtl.h</span>
02527 <span class="comment">//</span>
02528 
02529 BOOLEAN
<a name="l02530"></a><a class="code" href="../../d5/d9/heapdll_8c.html#a32">02530</a> <a class="code" href="../../d5/d9/heapdll_8c.html#a32">RtlValidateHeap</a> (
02531     PVOID HeapHandle,
02532     IN ULONG Flags,
02533     IN PVOID BaseAddress
02534     )
02535 
02536 <span class="comment">/*++</span>
02537 <span class="comment"></span>
02538 <span class="comment">Routine Description:</span>
02539 <span class="comment"></span>
02540 <span class="comment">    This routine verifies the structure of a heap and/or heap block</span>
02541 <span class="comment"></span>
02542 <span class="comment">Arguments:</span>
02543 <span class="comment"></span>
02544 <span class="comment">    HeapHandle - Supplies a pointer to the heap being queried</span>
02545 <span class="comment"></span>
02546 <span class="comment">    Flags - Supplies a set of flags used to augment those already</span>
02547 <span class="comment">        enforced by the heap</span>
02548 <span class="comment"></span>
02549 <span class="comment">    BaseAddress - Optionally supplies a pointer to the heap block</span>
02550 <span class="comment">        that should be individually validated</span>
02551 <span class="comment"></span>
02552 <span class="comment">Return Value:</span>
02553 <span class="comment"></span>
02554 <span class="comment">    BOOLEAN - TRUE if the heap/block is okay and FALSE otherwise</span>
02555 <span class="comment"></span>
02556 <span class="comment">--*/</span>
02557 
02558 {
02559     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
02560     BOOLEAN LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02561     BOOLEAN Result;
02562 
02563     <span class="keywordflow">try</span> {
02564 
02565         <span class="keywordflow">try</span> {
02566 
02567             <span class="comment">//</span>
02568             <span class="comment">//  Check for the guard page version of heap</span>
02569             <span class="comment">//</span>
02570 
02571             <span class="keywordflow">if</span> ( <a class="code" href="../../d7/d9/heappage_8h.html#a5">IS_DEBUG_PAGE_HEAP_HANDLE</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> )) {
02572 
02573                 Result = <a class="code" href="../../d7/d9/heappage_8h.html#a17">RtlpDebugPageHeapValidate</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, Flags, BaseAddress );
02574 
02575             } <span class="keywordflow">else</span> {
02576 
02577                 <span class="comment">//</span>
02578                 <span class="comment">//  If there is an active lookaside list then drain and remove it.</span>
02579                 <span class="comment">//  By setting the lookaside field in the heap to null we guarantee</span>
02580                 <span class="comment">//  that the call the free heap will not try and use the lookaside</span>
02581                 <span class="comment">//  list logic.</span>
02582                 <span class="comment">//</span>
02583                 <span class="comment">//  We'll actually capture the lookaside pointer from the heap and</span>
02584                 <span class="comment">//  only use the captured pointer.  This will take care of the</span>
02585                 <span class="comment">//  condition where another walk or lock heap can cause us to check</span>
02586                 <span class="comment">//  for a non null pointer and then have it become null when we read</span>
02587                 <span class="comment">//  it again.  If it is non null to start with then even if the</span>
02588                 <span class="comment">//  user walks or locks the heap via another thread the pointer to</span>
02589                 <span class="comment">//  still valid here so we can still try and do a lookaside list pop.</span>
02590                 <span class="comment">//</span>
02591 
02592                 <a class="code" href="../../d6/d6/struct__HEAP__LOOKASIDE.html">PHEAP_LOOKASIDE</a> Lookaside = (<a class="code" href="../../d6/d6/struct__HEAP__LOOKASIDE.html">PHEAP_LOOKASIDE</a>)Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o33">Lookaside</a>;
02593 
02594                 <span class="keywordflow">if</span> (Lookaside != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02595 
02596                     ULONG i;
02597                     PVOID Block;
02598 
02599                     Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o33">Lookaside</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02600 
02601                     <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="../../d3/d9/heap_8h.html#a6">HEAP_MAXIMUM_FREELISTS</a>; i += 1) {
02602 
02603                         <span class="keywordflow">while</span> ((Block = <a class="code" href="../../d0/d6/rtl_2lookasid_8c.html#a5">RtlpAllocateFromHeapLookaside</a>(&amp;(Lookaside[i]))) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02604 
02605                             <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, Block );
02606                         }
02607                     }
02608                 }
02609 
02610                 Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02611 
02612                 <span class="comment">//</span>
02613                 <span class="comment">//  Validate that HeapAddress points to a HEAP structure.</span>
02614                 <span class="comment">//</span>
02615 
02616                 <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a46">RtlpCheckHeapSignature</a>( Heap, <span class="stringliteral">"RtlValidateHeap"</span> )) {
02617 
02618                     Flags |= Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o3">ForceFlags</a>;
02619 
02620                     <span class="comment">//</span>
02621                     <span class="comment">//  Lock the heap</span>
02622                     <span class="comment">//</span>
02623 
02624                     <span class="keywordflow">if</span> (!(Flags &amp; HEAP_NO_SERIALIZE)) {
02625 
02626                         <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
02627 
02628                         LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02629                     }
02630 
02631                     <span class="comment">//</span>
02632                     <span class="comment">//  If the user did not supply a base address then verify</span>
02633                     <span class="comment">//  the complete heap otherwise just do a single heap</span>
02634                     <span class="comment">//  entry</span>
02635                     <span class="comment">//</span>
02636 
02637                     <span class="keywordflow">if</span> (BaseAddress == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02638 
02639                         Result = <a class="code" href="../../d9/d9/heappriv_8h.html#a48">RtlpValidateHeap</a>( Heap, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
02640 
02641                     } <span class="keywordflow">else</span> {
02642 
02643                         Result = <a class="code" href="../../d9/d9/heappriv_8h.html#a47">RtlpValidateHeapEntry</a>( Heap, (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)BaseAddress - 1, <span class="stringliteral">"RtlValidateHeap"</span> );
02644                     }
02645                 }
02646             }
02647 
02648         } except( <a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a> ) {
02649 
02650             <a class="code" href="../../d9/d9/heappriv_8h.html#a9">SET_LAST_STATUS</a>( GetExceptionCode() );
02651 
02652             Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02653         }
02654 
02655     } finally {
02656 
02657         <span class="comment">//</span>
02658         <span class="comment">//  Unlock the heap</span>
02659         <span class="comment">//</span>
02660 
02661         <span class="keywordflow">if</span> (LockAcquired) {
02662 
02663             <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
02664         }
02665     }
02666 
02667     <span class="comment">//</span>
02668     <span class="comment">//  And return to our caller</span>
02669     <span class="comment">//</span>
02670 
02671     <span class="keywordflow">return</span> Result;
02672 }
02673 
02674 
02675 <span class="comment">//</span>
02676 <span class="comment">//  Declared in nturtl.h</span>
02677 <span class="comment">//</span>
02678 
02679 BOOLEAN
<a name="l02680"></a><a class="code" href="../../d5/d9/heapdll_8c.html#a33">02680</a> <a class="code" href="../../d5/d9/heapdll_8c.html#a33">RtlValidateProcessHeaps</a> (
02681     VOID
02682     )
02683 
02684 <span class="comment">/*++</span>
02685 <span class="comment"></span>
02686 <span class="comment">Routine Description:</span>
02687 <span class="comment"></span>
02688 <span class="comment">    This routine cycles through all and validates each heap in the current</span>
02689 <span class="comment">    process.</span>
02690 <span class="comment"></span>
02691 <span class="comment">Arguments:</span>
02692 <span class="comment"></span>
02693 <span class="comment">    None.</span>
02694 <span class="comment"></span>
02695 <span class="comment">Return Value:</span>
02696 <span class="comment"></span>
02697 <span class="comment">    BOOLEAN - TRUE if all the heap verify okay and FALSE for any other</span>
02698 <span class="comment">        reason.</span>
02699 <span class="comment"></span>
02700 <span class="comment">--*/</span>
02701 
02702 {
02703     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02704     ULONG i, NumberOfHeaps;
02705     PVOID HeapsArray[ 512 ];
02706     PVOID *Heaps;
02707     SIZE_T <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
02708     BOOLEAN Result;
02709 
02710     Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02711 
02712     Heaps = &amp;HeapsArray[ 0 ];
02713 
02714     <span class="comment">//</span>
02715     <span class="comment">//  By default we can handle 512 heaps per process any more than</span>
02716     <span class="comment">//  that and we'll need to allocate storage to do the processing</span>
02717     <span class="comment">//</span>
02718     <span class="comment">//  So now determine how many heaps are in the current process</span>
02719     <span class="comment">//</span>
02720 
02721     NumberOfHeaps = <a class="code" href="../../d5/d9/heapdll_8c.html#a34">RtlGetProcessHeaps</a>( 512, Heaps );
02722 
02723     <span class="comment">//</span>
02724     <span class="comment">//  **** this is bogus because the preceeding routine will</span>
02725     <span class="comment">//  **** never return more than 512.  Either this routine</span>
02726     <span class="comment">//  **** needs to get the heap count from the peb itself</span>
02727     <span class="comment">//  **** or the called routine needs to return the actual</span>
02728     <span class="comment">//  **** number of heaps in the process, Then we have to know</span>
02729     <span class="comment">//  **** not to to beyond the heap array size</span>
02730     <span class="comment">//</span>
02731 
02732     <span class="keywordflow">if</span> (NumberOfHeaps &gt; 512) {
02733 
02734         <span class="comment">//</span>
02735         <span class="comment">//  The number of heaps is greater than 512 so</span>
02736         <span class="comment">//  allocate extra memory to store the array of</span>
02737         <span class="comment">//  heap pointers</span>
02738         <span class="comment">//</span>
02739 
02740         Heaps = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02741         <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> = NumberOfHeaps * <span class="keyword">sizeof</span>( PVOID );
02742 
02743         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwAllocateVirtualMemory( NtCurrentProcess(),
02744                                           (PVOID *)&amp;Heaps,
02745                                           0,
02746                                           &amp;<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>,
02747                                           MEM_COMMIT,
02748                                           PAGE_READWRITE );
02749 
02750         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
02751 
02752             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02753         }
02754 
02755         <span class="comment">//</span>
02756         <span class="comment">//  And retry getting the heaps</span>
02757         <span class="comment">//</span>
02758         <span class="comment">//  **** this won't work again because it still uses 512</span>
02759         <span class="comment">//</span>
02760 
02761         NumberOfHeaps = <a class="code" href="../../d5/d9/heapdll_8c.html#a34">RtlGetProcessHeaps</a>( 512, Heaps );
02762     }
02763 
02764     <span class="comment">//</span>
02765     <span class="comment">//  Now for each heap in our heap array we'll validate</span>
02766     <span class="comment">//  that heap</span>
02767     <span class="comment">//</span>
02768 
02769     <span class="keywordflow">for</span> (i=0; i&lt;NumberOfHeaps; i++) {
02770 
02771         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d9/heapdll_8c.html#a32">RtlValidateHeap</a>( Heaps[i], 0, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> )) {
02772 
02773             Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02774         }
02775     }
02776 
02777     <span class="comment">//</span>
02778     <span class="comment">//  Check if we need to return the memory that we use for</span>
02779     <span class="comment">//  an enlarged heap array</span>
02780     <span class="comment">//</span>
02781 
02782     <span class="keywordflow">if</span> (Heaps != &amp;HeapsArray[ 0 ]) {
02783 
02784         ZwFreeVirtualMemory( NtCurrentProcess(),
02785                              (PVOID *)&amp;Heaps,
02786                              &amp;<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>,
02787                              MEM_RELEASE );
02788     }
02789 
02790     <span class="comment">//</span>
02791     <span class="comment">//  And return to our caller</span>
02792     <span class="comment">//</span>
02793 
02794     <span class="keywordflow">return</span> Result;
02795 }
02796 
02797 
02798 <span class="comment">//</span>
02799 <span class="comment">//  Declared in nturtl.h</span>
02800 <span class="comment">//</span>
02801 
02802 ULONG
<a name="l02803"></a><a class="code" href="../../d5/d9/heapdll_8c.html#a34">02803</a> <a class="code" href="../../d5/d9/heapdll_8c.html#a34">RtlGetProcessHeaps</a> (
02804     ULONG NumberOfHeapsToReturn,
02805     PVOID *ProcessHeaps
02806     )
02807 
02808 <span class="comment">/*++</span>
02809 <span class="comment"></span>
02810 <span class="comment">Routine Description:</span>
02811 <span class="comment"></span>
02812 <span class="comment">    This routine determines how many individual heaps there are in the</span>
02813 <span class="comment">    current process and fills an array with pointers to each heap.</span>
02814 <span class="comment"></span>
02815 <span class="comment">Arguments:</span>
02816 <span class="comment"></span>
02817 <span class="comment">    NumberOfHeapsToReturn - Indicates how many heaps the caller</span>
02818 <span class="comment">        is willing to accept in the second parameter</span>
02819 <span class="comment"></span>
02820 <span class="comment">    ProcessHeaps - Supplies a pointer to an array of heap pointer</span>
02821 <span class="comment">        to be filled in by this routine.  The maximum size of this</span>
02822 <span class="comment">        array is specified by the first parameter</span>
02823 <span class="comment"></span>
02824 <span class="comment">Return Value:</span>
02825 <span class="comment"></span>
02826 <span class="comment">    ULONG - Returns the smaller of the actual number of heaps in the</span>
02827 <span class="comment">        the process or the size of the output buffer</span>
02828 <span class="comment"></span>
02829 <span class="comment">--*/</span>
02830 
02831 {
02832     PPEB Peb = NtCurrentPeb();
02833     ULONG NumberOfHeapsToCopy;
02834     ULONG TotalHeaps;
02835 
02836     <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( &amp;<a class="code" href="../../d5/d9/heapdll_8c.html#a3">RtlpProcessHeapsListLock</a>.<a class="code" href="../../d4/d6/struct__HEAP__LOCK.html#o2">Lock</a> );
02837 
02838     <span class="keywordflow">try</span> {
02839 
02840         <span class="comment">//</span>
02841         <span class="comment">//  Return no more than the number of heaps currently in use</span>
02842         <span class="comment">//</span>
02843 
02844         TotalHeaps = Peb-&gt;NumberOfHeaps;
02845 
02846         <span class="keywordflow">if</span> (TotalHeaps &gt; NumberOfHeapsToReturn) {
02847 
02848             NumberOfHeapsToCopy = NumberOfHeapsToReturn;
02849 
02850         } <span class="keywordflow">else</span> {
02851 
02852             NumberOfHeapsToCopy = TotalHeaps;
02853 
02854         }
02855 
02856         <span class="comment">//</span>
02857         <span class="comment">//  Return the heap pointers to the caller</span>
02858         <span class="comment">//</span>
02859 
02860         RtlMoveMemory( ProcessHeaps,
02861                        Peb-&gt;ProcessHeaps,
02862                        NumberOfHeapsToCopy * <span class="keyword">sizeof</span>( *ProcessHeaps ));
02863 
02864         ProcessHeaps += NumberOfHeapsToCopy;
02865         NumberOfHeapsToReturn -= NumberOfHeapsToCopy;
02866 
02867     } finally {
02868 
02869         <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( &amp;<a class="code" href="../../d5/d9/heapdll_8c.html#a3">RtlpProcessHeapsListLock</a>.<a class="code" href="../../d4/d6/struct__HEAP__LOCK.html#o2">Lock</a> );
02870     }
02871 
02872 <span class="preprocessor">#ifdef DEBUG_PAGE_HEAP</span>
02873 <span class="preprocessor"></span>
02874     <span class="comment">//</span>
02875     <span class="comment">//  If we have debugging page heaps, go return what we can from them</span>
02876     <span class="comment">//</span>
02877 
02878     <span class="keywordflow">if</span> ( <a class="code" href="../../d6/d9/heappage_8c.html#a36">RtlpDebugPageHeap</a> ) {
02879 
02880         TotalHeaps +=
02881             <a class="code" href="../../d7/d9/heappage_8h.html#a15">RtlpDebugPageHeapGetProcessHeaps</a>( NumberOfHeapsToReturn, ProcessHeaps );
02882 
02883     }
02884 
02885 <span class="preprocessor">#endif</span>
02886 <span class="preprocessor"></span>
02887     <span class="keywordflow">return</span> TotalHeaps;
02888 }
02889 
02890 
02891 <span class="comment">//</span>
02892 <span class="comment">//  Declared in nturtl.h</span>
02893 <span class="comment">//</span>
02894 
02895 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l02896"></a><a class="code" href="../../d5/d9/heapdll_8c.html#a35">02896</a> <a class="code" href="../../d5/d9/heapdll_8c.html#a35">RtlEnumProcessHeaps</a> (
02897     PRTL_ENUM_HEAPS_ROUTINE EnumRoutine,
02898     PVOID Parameter
02899     )
02900 
02901 <span class="comment">/*++</span>
02902 <span class="comment"></span>
02903 <span class="comment">Routine Description:</span>
02904 <span class="comment"></span>
02905 <span class="comment">    This routine cycles through all the heaps in a process and</span>
02906 <span class="comment">    invokes the specified call back routine for that heap</span>
02907 <span class="comment"></span>
02908 <span class="comment">Arguments:</span>
02909 <span class="comment"></span>
02910 <span class="comment">    EnumRoutine - Supplies the callback to invoke for each heap</span>
02911 <span class="comment">        in the process</span>
02912 <span class="comment"></span>
02913 <span class="comment">    Parameter - Provides an additional parameter to pass to the</span>
02914 <span class="comment">        callback routine</span>
02915 <span class="comment"></span>
02916 <span class="comment">Return Value:</span>
02917 <span class="comment"></span>
02918 <span class="comment">    NTSTATUS - returns success or the first error status returned</span>
02919 <span class="comment">        by the callback routine</span>
02920 <span class="comment"></span>
02921 <span class="comment">--*/</span>
02922 
02923 {
02924     PPEB Peb = NtCurrentPeb();
02925     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02926     ULONG i;
02927 
02928     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
02929 
02930     <span class="comment">//</span>
02931     <span class="comment">//  Lock the heap</span>
02932     <span class="comment">//</span>
02933 
02934     <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( &amp;<a class="code" href="../../d5/d9/heapdll_8c.html#a3">RtlpProcessHeapsListLock</a>.<a class="code" href="../../d4/d6/struct__HEAP__LOCK.html#o2">Lock</a> );
02935 
02936     <span class="keywordflow">try</span> {
02937 
02938         <span class="comment">//</span>
02939         <span class="comment">//  For each heap in the process invoke the callback routine</span>
02940         <span class="comment">//  and if the callback returns anything other than success</span>
02941         <span class="comment">//  then break out and return immediately to our caller</span>
02942         <span class="comment">//</span>
02943 
02944         <span class="keywordflow">for</span> (i=0; i&lt;Peb-&gt;NumberOfHeaps; i++) {
02945 
02946             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = (*EnumRoutine)( (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)(Peb-&gt;ProcessHeaps[ i ]), Parameter );
02947 
02948             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
02949 
02950                 <span class="keywordflow">break</span>;
02951             }
02952         }
02953 
02954     } finally {
02955 
02956         <span class="comment">//</span>
02957         <span class="comment">//  Unlock the heap</span>
02958         <span class="comment">//</span>
02959 
02960         <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( &amp;<a class="code" href="../../d5/d9/heapdll_8c.html#a3">RtlpProcessHeapsListLock</a>.<a class="code" href="../../d4/d6/struct__HEAP__LOCK.html#o2">Lock</a> );
02961     }
02962 
02963     <span class="comment">//</span>
02964     <span class="comment">//  And return to our caller</span>
02965     <span class="comment">//</span>
02966 
02967     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02968 }
02969 
02970 
02971 <span class="comment">//</span>
02972 <span class="comment">//  Declared in nturtl.h</span>
02973 <span class="comment">//</span>
02974 
02975 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l02976"></a><a class="code" href="../../d5/d9/heapdll_8c.html#a36">02976</a> <a class="code" href="../../d5/d9/heapdll_8c.html#a36">RtlUsageHeap</a> (
02977     IN PVOID HeapHandle,
02978     IN ULONG Flags,
02979     IN OUT PRTL_HEAP_USAGE Usage
02980     )
02981 
02982 <span class="comment">/*++</span>
02983 <span class="comment"></span>
02984 <span class="comment">Routine Description:</span>
02985 <span class="comment"></span>
02986 <span class="comment">    This is a rather bizzare routine.  It models heap usage in that it returns</span>
02987 <span class="comment">    to the caller the various heap sizes, but it also return three lists.  One</span>
02988 <span class="comment">    is a list of entries for each active allocation in the heap.  The next two</span>
02989 <span class="comment">    are used for tracking difference between usage calls.  There is a list of</span>
02990 <span class="comment">    what was added and a list of what was removed.</span>
02991 <span class="comment"></span>
02992 <span class="comment">Arguments:</span>
02993 <span class="comment"></span>
02994 <span class="comment">    HeapHandle - Supplies a pointer to the heap being queried</span>
02995 <span class="comment"></span>
02996 <span class="comment">    Flags - Supplies a set of flags needed to augment those enforced</span>
02997 <span class="comment">        by the heap.</span>
02998 <span class="comment"></span>
02999 <span class="comment">        HEAP_USAGE_ALLOCATED_BLOCKS - Denotes that the calls wants the list</span>
03000 <span class="comment">            of allocated entries.</span>
03001 <span class="comment"></span>
03002 <span class="comment">        HEAP_USAGE_FREE_BUFFER - Denotes the last call to this procedure and</span>
03003 <span class="comment">            that any temporary storage can now be freed</span>
03004 <span class="comment"></span>
03005 <span class="comment">    Usage - Receives the current usage statistics for the heap.  This variable</span>
03006 <span class="comment">        is also used to store state information between calls to this routine.</span>
03007 <span class="comment"></span>
03008 <span class="comment">Return Value:</span>
03009 <span class="comment"></span>
03010 <span class="comment">    NTSTATUS - An appropriate status value.  STATUS_SUCCESS if the heap has</span>
03011 <span class="comment">        not changed at all between calls and STATUS_MORE_ENTRIES if thep changed</span>
03012 <span class="comment">        between two calls.</span>
03013 <span class="comment"></span>
03014 <span class="comment">--*/</span>
03015 
03016 {
03017     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
03018     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
03019     <a class="code" href="../../d5/d9/heapdll_8c.html#a2">PRTL_HEAP_USAGE_INTERNAL</a> <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>;
03020     <a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a> Segment;
03021     <a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html">PHEAP_UNCOMMMTTED_RANGE</a> UnCommittedRange;
03022     <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a> CurrentBlock;
03023     <a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html">PHEAP_ENTRY_EXTRA</a> ExtraStuff;
03024     PLIST_ENTRY Head, Next;
03025     <a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html">PHEAP_VIRTUAL_ALLOC_ENTRY</a> VirtualAllocBlock;
03026     SIZE_T BytesFree;
03027     UCHAR SegmentIndex;
03028     BOOLEAN LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03029     BOOLEAN VirtualAllocBlockSeen;
03030     PRTL_HEAP_USAGE_ENTRY pOldEntries, pNewEntries, pNewEntry;
03031     PRTL_HEAP_USAGE_ENTRY *ppEntries, *ppAddedEntries, *ppRemovedEntries, *pp;
03032     PVOID DataAddress;
03033     SIZE_T DataSize;
03034 
03035     <span class="comment">//</span>
03036     <span class="comment">//  Augment the heap flags</span>
03037     <span class="comment">//</span>
03038 
03039     Flags |= Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o3">ForceFlags</a>;
03040 
03041     <span class="comment">//</span>
03042     <span class="comment">//  Check if we should be using the debug version of heap</span>
03043     <span class="comment">//</span>
03044 
03045     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a8">DEBUG_HEAP</a>( Flags )) {
03046 
03047         <span class="keywordflow">return</span> <a class="code" href="../../d5/d9/heapdll_8c.html#a15">RtlDebugUsageHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, Flags, <a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a> );
03048     }
03049 
03050     <span class="comment">//</span>
03051     <span class="comment">//  Make sure that the size of the input buffer is correct</span>
03052     <span class="comment">//</span>
03053 
03054     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;Length != <span class="keyword">sizeof</span>( RTL_HEAP_USAGE )) {
03055 
03056         <span class="keywordflow">return</span> STATUS_INFO_LENGTH_MISMATCH;
03057     }
03058 
03059     <span class="comment">//</span>
03060     <span class="comment">//  Zero out the output fields</span>
03061     <span class="comment">//</span>
03062 
03063     <a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;BytesAllocated = 0;
03064     <a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;BytesCommitted = 0;
03065     <a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;BytesReserved = 0;
03066     <a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;BytesReservedMaximum = 0;
03067 
03068     <span class="comment">//</span>
03069     <span class="comment">//  Use the reserved area of the output buffer as an internal</span>
03070     <span class="comment">//  heap usage storage space between calls</span>
03071     <span class="comment">//</span>
03072 
03073     <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = (<a class="code" href="../../d5/d9/heapdll_8c.html#a2">PRTL_HEAP_USAGE_INTERNAL</a>)&amp;<a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;Reserved[ 0 ];
03074 
03075     <span class="comment">//</span>
03076     <span class="comment">//  Check if there is not a base buffer and we should allocate</span>
03077     <span class="comment">//  one then do so now</span>
03078     <span class="comment">//</span>
03079 
03080     <span class="keywordflow">if</span> ((<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;Base == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
03081         (Flags &amp; HEAP_USAGE_ALLOCATED_BLOCKS)) {
03082 
03083         <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;ReservedSize = 4 * 1024 * 1024;
03084 
03085         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d6/allocvm_8c.html#a7">NtAllocateVirtualMemory</a>( NtCurrentProcess(),
03086                                           &amp;<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;Base,
03087                                           0,
03088                                           &amp;<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;ReservedSize,
03089                                           MEM_RESERVE,
03090                                           PAGE_READWRITE );
03091 
03092         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
03093 
03094             <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
03095         }
03096 
03097         <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;CommittedSize = 0;
03098         <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;FreeList = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03099         <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;LargeEntriesSentinal = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03100 
03101     <span class="comment">//</span>
03102     <span class="comment">//  Otherwise check if there already is a base buffer</span>
03103     <span class="comment">//  and we should free it now</span>
03104     <span class="comment">//</span>
03105 
03106     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;Base != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
03107                (Flags &amp; HEAP_USAGE_FREE_BUFFER)) {
03108 
03109         <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;ReservedSize = 0;
03110 
03111         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d7/freevm_8c.html#a6">NtFreeVirtualMemory</a>( NtCurrentProcess(),
03112                                       &amp;<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;Base,
03113                                       &amp;<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;ReservedSize,
03114                                       MEM_RELEASE );
03115 
03116         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
03117 
03118             <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
03119         }
03120 
03121         RtlZeroMemory( <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, <span class="keyword">sizeof</span>( *<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> ) );
03122     }
03123 
03124     <span class="comment">//</span>
03125     <span class="comment">//  **** Augment the heap flags again</span>
03126     <span class="comment">//</span>
03127 
03128     Flags |= Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o3">ForceFlags</a>;
03129 
03130     <span class="keywordflow">try</span> {
03131 
03132         <span class="comment">//</span>
03133         <span class="comment">//  Lock the heap</span>
03134         <span class="comment">//</span>
03135 
03136         <span class="keywordflow">if</span> (!(Flags &amp; HEAP_NO_SERIALIZE)) {
03137 
03138             <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
03139 
03140             LockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03141         }
03142 
03143         <span class="comment">//</span>
03144         <span class="comment">//  Scan through the heap segments and for every in-use segment</span>
03145         <span class="comment">//  we add it to the amount of committed and reserved bytes</span>
03146         <span class="comment">//  If the segment is not in use and the heap is growable then</span>
03147         <span class="comment">//  we just add it to the reserved maximum</span>
03148         <span class="comment">//</span>
03149 
03150         <span class="keywordflow">for</span> (SegmentIndex=0; SegmentIndex&lt;<a class="code" href="../../d3/d9/heap_8h.html#a7">HEAP_MAXIMUM_SEGMENTS</a>; SegmentIndex++) {
03151 
03152             Segment = Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o22">Segments</a>[ SegmentIndex ];
03153 
03154             <span class="keywordflow">if</span> (Segment) {
03155 
03156                 <a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;BytesCommitted += (Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o6">NumberOfPages</a> -
03157                                           Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o9">NumberOfUnCommittedPages</a>) * <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
03158 
03159                 <a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;BytesReserved += Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o6">NumberOfPages</a> * <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
03160 
03161             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o2">Flags</a> &amp; HEAP_GROWABLE) {
03162 
03163                 <a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;BytesReservedMaximum += Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o5">SegmentReserve</a>;
03164             }
03165         }
03166 
03167         <a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;BytesReservedMaximum += <a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;BytesReserved;
03168         <a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;BytesAllocated = <a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;BytesCommitted - (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o9">TotalFreeSize</a> &lt;&lt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>);
03169 
03170         <span class="comment">//</span>
03171         <span class="comment">//  Scan through the big allocations and add those amounts to the</span>
03172         <span class="comment">//  usage statistics</span>
03173         <span class="comment">//</span>
03174 
03175         Head = &amp;Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o21">VirtualAllocdBlocks</a>;
03176         Next = Head-&gt;Flink;
03177 
03178         <span class="keywordflow">while</span> (Head != Next) {
03179 
03180             VirtualAllocBlock = CONTAINING_RECORD( Next, <a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html">HEAP_VIRTUAL_ALLOC_ENTRY</a>, Entry );
03181 
03182             <a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;BytesAllocated += VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o2">CommitSize</a>;
03183             <a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;BytesCommitted += VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o2">CommitSize</a>;
03184 
03185             Next = Next-&gt;Flink;
03186         }
03187 
03188         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
03189 
03190         <span class="comment">//</span>
03191         <span class="comment">//  Now check if we have a base buffer and we are suppose to account</span>
03192         <span class="comment">//  for allocated blocks</span>
03193         <span class="comment">//</span>
03194 
03195         <span class="keywordflow">if</span> ((<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;Base != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
03196             (Flags &amp; HEAP_USAGE_ALLOCATED_BLOCKS)) {
03197 
03198             <span class="comment">//</span>
03199             <span class="comment">//  Setup a pointer to the old entries, added entries, and removed</span>
03200             <span class="comment">//  entries in the usage struct.  Also drain the added entries</span>
03201             <span class="comment">//  and removed entries list</span>
03202             <span class="comment">//</span>
03203 
03204             pOldEntries = <a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;Entries;
03205 
03206             ppEntries = &amp;<a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;Entries;
03207 
03208             *ppEntries = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03209 
03210             ppAddedEntries = &amp;<a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;AddedEntries;
03211 
03212             <span class="keywordflow">while</span> (*ppAddedEntries = <a class="code" href="../../d5/d9/heapdll_8c.html#a18">RtlpFreeHeapUsageEntry</a>( <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, *ppAddedEntries )) { NOTHING; }
03213 
03214             ppRemovedEntries = &amp;<a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;RemovedEntries;
03215 
03216             <span class="keywordflow">while</span> (*ppRemovedEntries = <a class="code" href="../../d5/d9/heapdll_8c.html#a18">RtlpFreeHeapUsageEntry</a>( <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, *ppRemovedEntries )) { NOTHING; }
03217 
03218             <span class="comment">//</span>
03219             <span class="comment">//  The way the code works is that ppEntries, ppAddedEntries, and</span>
03220             <span class="comment">//  ppRemovedEntries point to the tail of their respective lists.  If</span>
03221             <span class="comment">//  the list is empty then they point to the head.</span>
03222             <span class="comment">//</span>
03223 
03224             <span class="comment">//</span>
03225             <span class="comment">//  Process every segment in the heap</span>
03226             <span class="comment">//</span>
03227 
03228             <span class="keywordflow">for</span> (SegmentIndex=0; SegmentIndex&lt;<a class="code" href="../../d3/d9/heap_8h.html#a7">HEAP_MAXIMUM_SEGMENTS</a>; SegmentIndex++) {
03229 
03230                 Segment = Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o22">Segments</a>[ SegmentIndex ];
03231 
03232                 <span class="comment">//</span>
03233                 <span class="comment">//  Only deal with segments that are in use</span>
03234                 <span class="comment">//</span>
03235 
03236                 <span class="keywordflow">if</span> (Segment) {
03237 
03238                     <span class="comment">//</span>
03239                     <span class="comment">//  The current block is really the first block in current</span>
03240                     <span class="comment">//  segment.  We need to special case the computation to</span>
03241                     <span class="comment">//  account for the first heap segment.</span>
03242                     <span class="comment">//</span>
03243 
03244                     <span class="keywordflow">if</span> (Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o5">BaseAddress</a> == Heap) {
03245 
03246                         CurrentBlock = &amp;Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o0">Entry</a>;
03247 
03248                     } <span class="keywordflow">else</span> {
03249 
03250                         CurrentBlock = &amp;Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o0">Entry</a>;
03251                     }
03252 
03253                     <span class="comment">//</span>
03254                     <span class="comment">//  Now for every busy block in the segment we'll check if</span>
03255                     <span class="comment">//  we need to allocate a heap usage entry and put it in the</span>
03256                     <span class="comment">//  the entries list</span>
03257                     <span class="comment">//</span>
03258 
03259                     <span class="keywordflow">while</span> (CurrentBlock &lt; Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o8">LastValidEntry</a>) {
03260 
03261                         <span class="keywordflow">if</span> (CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a8">HEAP_ENTRY_BUSY</a>) {
03262 
03263                             <span class="comment">//</span>
03264                             <span class="comment">//  Compute the users data address and size</span>
03265                             <span class="comment">//</span>
03266 
03267                             DataAddress = (CurrentBlock+1);
03268                             DataSize = (CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a> &lt;&lt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>) -
03269                                        CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o4">UnusedBytes</a>;
03270 
03271     keepLookingAtOldEntries:
03272 
03273                             <span class="comment">//</span>
03274                             <span class="comment">//  The first time through this routine will have</span>
03275                             <span class="comment">//  both of these variables null so we'll start off</span>
03276                             <span class="comment">//  by looking at new entries.</span>
03277                             <span class="comment">//</span>
03278 
03279                             <span class="keywordflow">if</span> (pOldEntries == <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;LargeEntriesSentinal) {
03280 
03281                                 <span class="keywordflow">goto</span> keepLookingAtNewEntries;
03282                             }
03283 
03284                             <span class="comment">//</span>
03285                             <span class="comment">//  Check if this entry hasn't changed.</span>
03286                             <span class="comment">//</span>
03287                             <span class="comment">//  If the old entry is equal to this data block</span>
03288                             <span class="comment">//  then move the old entry back to the entries</span>
03289                             <span class="comment">//  list and go on to the next block.</span>
03290                             <span class="comment">//</span>
03291 
03292                             <span class="keywordflow">if</span> ((pOldEntries-&gt;Address == DataAddress) &amp;&amp;
03293                                 (pOldEntries-&gt;Size == DataSize)) {
03294 
03295                                 <span class="comment">//</span>
03296                                 <span class="comment">//  Same block, keep in entries list</span>
03297                                 <span class="comment">//</span>
03298 
03299                                 *ppEntries = pOldEntries;
03300                                 pOldEntries = pOldEntries-&gt;Next;
03301                                 ppEntries = &amp;(*ppEntries)-&gt;Next;
03302 
03303                                 *ppEntries = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03304 
03305                             <span class="comment">//</span>
03306                             <span class="comment">//  Check if an entry was removed</span>
03307                             <span class="comment">//</span>
03308                             <span class="comment">//  If this entry is beyond the old entry then move</span>
03309                             <span class="comment">//  the old entry to the removed entry list and keep</span>
03310                             <span class="comment">//  looking at the old entry list without advancing</span>
03311                             <span class="comment">//  the current data block</span>
03312                             <span class="comment">//</span>
03313 
03314                             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pOldEntries-&gt;Address &lt;= DataAddress) {
03315 
03316                                 *ppRemovedEntries = pOldEntries;
03317                                 pOldEntries = pOldEntries-&gt;Next;
03318                                 ppRemovedEntries = &amp;(*ppRemovedEntries)-&gt;Next;
03319 
03320                                 *ppRemovedEntries = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03321 
03322                                 <span class="keywordflow">goto</span> keepLookingAtOldEntries;
03323 
03324                             <span class="comment">//</span>
03325                             <span class="comment">//  Otherwise the we want to process the current data block</span>
03326                             <span class="comment">//</span>
03327 
03328                             } <span class="keywordflow">else</span> {
03329 
03330     keepLookingAtNewEntries:
03331 
03332                                 <span class="comment">//</span>
03333                                 <span class="comment">//  Allocate a new heap usage entry</span>
03334                                 <span class="comment">//</span>
03335 
03336                                 pNewEntry = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03337 
03338                                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d5/d9/heapdll_8c.html#a19">RtlpAllocateHeapUsageEntry</a>( <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, &amp;pNewEntry );
03339 
03340                                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
03341 
03342                                     <span class="keywordflow">break</span>;
03343                                 }
03344 
03345                                 <span class="comment">//</span>
03346                                 <span class="comment">//  And fill in the new entry</span>
03347                                 <span class="comment">//</span>
03348 
03349                                 pNewEntry-&gt;Address = DataAddress;
03350                                 pNewEntry-&gt;Size = DataSize;
03351 
03352                                 <span class="comment">//</span>
03353                                 <span class="comment">//  If there is an extra stuff struct then fill it in</span>
03354                                 <span class="comment">//  with the stack backtrace, and appropriate tag index</span>
03355                                 <span class="comment">//</span>
03356 
03357                                 <span class="keywordflow">if</span> (CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a9">HEAP_ENTRY_EXTRA_PRESENT</a>) {
03358 
03359                                     ExtraStuff = <a class="code" href="../../d9/d9/heappriv_8h.html#a41">RtlpGetExtraStuffPointer</a>( CurrentBlock );
03360 
03361 <span class="preprocessor">    #if i386</span>
03362 <span class="preprocessor"></span>
03363                                     pNewEntry-&gt;AllocatorBackTraceIndex = ExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o0">AllocatorBackTraceIndex</a>;
03364 
03365 <span class="preprocessor">    #endif // i386</span>
03366 <span class="preprocessor"></span>
03367                                     <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d9/heappriv_8h.html#a22">IS_HEAP_TAGGING_ENABLED</a>()) {
03368 
03369                                         pNewEntry-&gt;TagIndex = 0;
03370 
03371                                     } <span class="keywordflow">else</span> {
03372 
03373                                         pNewEntry-&gt;TagIndex = ExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o1">TagIndex</a>;
03374                                     }
03375 
03376                                 } <span class="keywordflow">else</span> {
03377 
03378                                     <span class="comment">//</span>
03379                                     <span class="comment">//  Otherwise there is no extra stuff so there is</span>
03380                                     <span class="comment">//  no backtrace and the tag is from the small index</span>
03381                                     <span class="comment">//</span>
03382 
03383 <span class="preprocessor">    #if i386</span>
03384 <span class="preprocessor"></span>
03385                                     pNewEntry-&gt;AllocatorBackTraceIndex = 0;
03386 
03387 <span class="preprocessor">    #endif // i386</span>
03388 <span class="preprocessor"></span>
03389                                     <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d9/heappriv_8h.html#a22">IS_HEAP_TAGGING_ENABLED</a>()) {
03390 
03391                                         pNewEntry-&gt;TagIndex = 0;
03392 
03393                                     } <span class="keywordflow">else</span> {
03394 
03395                                         pNewEntry-&gt;TagIndex = CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o5">SmallTagIndex</a>;
03396                                     }
03397                                 }
03398 
03399                                 <span class="comment">//</span>
03400                                 <span class="comment">//  Allocate another new heap usage entry as part of the added</span>
03401                                 <span class="comment">//  entry list</span>
03402                                 <span class="comment">//</span>
03403 
03404                                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d5/d9/heapdll_8c.html#a19">RtlpAllocateHeapUsageEntry</a>( <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, ppAddedEntries );
03405 
03406                                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
03407 
03408                                     <span class="keywordflow">break</span>;
03409                                 }
03410 
03411                                 <span class="comment">//</span>
03412                                 <span class="comment">//  Copy over the contents of the new entry to the added entry</span>
03413                                 <span class="comment">//</span>
03414 
03415                                 **ppAddedEntries = *pNewEntry;
03416 
03417                                 <span class="comment">//</span>
03418                                 <span class="comment">//  Advance the added entry pointer to the next slot</span>
03419                                 <span class="comment">//</span>
03420 
03421                                 ppAddedEntries = &amp;((*ppAddedEntries)-&gt;Next);
03422 
03423                                 *ppAddedEntries = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03424 
03425                                 pNewEntry-&gt;Next = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03426 
03427                                 <span class="comment">//</span>
03428                                 <span class="comment">//  Add the new entry to the entries list</span>
03429                                 <span class="comment">//</span>
03430 
03431                                 *ppEntries = pNewEntry;
03432                                 ppEntries = &amp;pNewEntry-&gt;Next;
03433                             }
03434                         }
03435 
03436                         <span class="comment">//</span>
03437                         <span class="comment">//  Now advance to the next block in the segment</span>
03438                         <span class="comment">//</span>
03439                         <span class="comment">//  If the next block doesn't exist then zoom through the</span>
03440                         <span class="comment">//  uncommitted ranges in the segment until we find a</span>
03441                         <span class="comment">//  match and can recompute the next real block</span>
03442                         <span class="comment">//</span>
03443 
03444                         <span class="keywordflow">if</span> (CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>) {
03445 
03446                             CurrentBlock += CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a>;
03447 
03448                             <span class="keywordflow">if</span> (CurrentBlock &lt; Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o8">LastValidEntry</a>) {
03449 
03450                                 UnCommittedRange = Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o11">UnCommittedRanges</a>;
03451 
03452                                 <span class="keywordflow">while</span> ((UnCommittedRange != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
03453                                        (UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o1">Address</a> != (ULONG_PTR)CurrentBlock)) {
03454 
03455                                     UnCommittedRange = UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o0">Next</a>;
03456                                 }
03457 
03458                                 <span class="keywordflow">if</span> (UnCommittedRange == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03459 
03460                                     CurrentBlock = Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o8">LastValidEntry</a>;
03461 
03462                                 } <span class="keywordflow">else</span> {
03463 
03464                                     CurrentBlock = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)(UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o1">Address</a> +
03465                                                                  UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o2">Size</a>);
03466                                 }
03467                             }
03468 
03469                         } <span class="keywordflow">else</span> {
03470 
03471                             <span class="comment">//</span>
03472                             <span class="comment">//  Otherwise the next block exists and so point</span>
03473                             <span class="comment">//  directly at it</span>
03474                             <span class="comment">//</span>
03475 
03476                             CurrentBlock += CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a>;
03477                         }
03478                     }
03479                 }
03480             }
03481 
03482             <span class="comment">//</span>
03483             <span class="comment">//  At this point we've scanned through every segment in the heap</span>
03484             <span class="comment">//</span>
03485             <span class="comment">//  The first time through we now have two lists one of entries and</span>
03486             <span class="comment">//  another of added entries.  In each case Usage-&gt;Entries, and</span>
03487             <span class="comment">//  Usage-&gt;AddedEntries points to the start of the list and ppEntries,</span>
03488             <span class="comment">//  and ppAddedEntries points to the tail of the list.  The first</span>
03489             <span class="comment">//  time through we has seem to have a one-to-one correspondence</span>
03490             <span class="comment">//  between Entries and AddedEntries, but the AddedEntries records</span>
03491             <span class="comment">//  do not contain anything useful</span>
03492             <span class="comment">//</span>
03493 
03494             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
03495 
03496                 <span class="comment">//</span>
03497                 <span class="comment">//  Now we'll examine each big allocation, and for each big allocation</span>
03498                 <span class="comment">//  we'll make a heap usage entry</span>
03499                 <span class="comment">//</span>
03500 
03501                 Head = &amp;Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o21">VirtualAllocdBlocks</a>;
03502                 Next = Head-&gt;Flink;
03503                 VirtualAllocBlockSeen = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03504 
03505                 <span class="keywordflow">while</span> (Head != Next) {
03506 
03507                     VirtualAllocBlock = CONTAINING_RECORD( Next, <a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html">HEAP_VIRTUAL_ALLOC_ENTRY</a>, Entry );
03508 
03509                     <span class="comment">//</span>
03510                     <span class="comment">//  Allocate a new heap usage entry</span>
03511                     <span class="comment">//</span>
03512 
03513                     pNewEntry = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03514 
03515                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d5/d9/heapdll_8c.html#a19">RtlpAllocateHeapUsageEntry</a>( <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, &amp;pNewEntry );
03516 
03517                     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
03518 
03519                         <span class="keywordflow">break</span>;
03520                     }
03521 
03522                     VirtualAllocBlockSeen = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03523 
03524                     <span class="comment">//</span>
03525                     <span class="comment">//  Fill in the new heap usage entry</span>
03526                     <span class="comment">//</span>
03527 
03528                     pNewEntry-&gt;Address = (VirtualAllocBlock + 1);
03529                     pNewEntry-&gt;Size = VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o2">CommitSize</a> - VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o4">BusyBlock</a>.<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a>;
03530 
03531 <span class="preprocessor">    #if i386</span>
03532 <span class="preprocessor"></span>
03533                     pNewEntry-&gt;AllocatorBackTraceIndex = VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o1">ExtraStuff</a>.<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o0">AllocatorBackTraceIndex</a>;
03534 
03535 <span class="preprocessor">    #endif // i386</span>
03536 <span class="preprocessor"></span>
03537                     <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d9/heappriv_8h.html#a22">IS_HEAP_TAGGING_ENABLED</a>()) {
03538 
03539                         pNewEntry-&gt;TagIndex = 0;
03540 
03541                     } <span class="keywordflow">else</span> {
03542 
03543                         pNewEntry-&gt;TagIndex = VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o1">ExtraStuff</a>.<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o1">TagIndex</a>;
03544                     }
03545 
03546                     <span class="comment">//</span>
03547                     <span class="comment">//  Search the heap usage entries list until we find the address</span>
03548                     <span class="comment">//  that right after the new entry address and then insert</span>
03549                     <span class="comment">//  this new entry.  This will keep the entries list sorted in</span>
03550                     <span class="comment">//  assending addresses</span>
03551                     <span class="comment">//</span>
03552                     <span class="comment">//</span>
03553                     <span class="comment">//  The first time through this function ppEntries will point</span>
03554                     <span class="comment">//  to the tail and so *pp should actually start off as null,</span>
03555                     <span class="comment">//  which means that the big allocation simply get tacked on</span>
03556                     <span class="comment">//  the end of the entries list.  We do not augment the</span>
03557                     <span class="comment">//  AddedEntries list for these big allocations.</span>
03558                     <span class="comment">//</span>
03559 
03560                     pp = ppEntries;
03561 
03562                     <span class="keywordflow">while</span> (*pp) {
03563 
03564                         <span class="keywordflow">if</span> ((*pp)-&gt;Address &gt;= pNewEntry-&gt;Address) {
03565 
03566                             <span class="keywordflow">break</span>;
03567                         }
03568 
03569                         pp = &amp;(*pp)-&gt;Next;
03570                     }
03571 
03572                     pNewEntry-&gt;Next = *pp;
03573                     *pp = pNewEntry;
03574 
03575                     <span class="comment">//</span>
03576                     <span class="comment">//  Get the next big allocation block</span>
03577                     <span class="comment">//</span>
03578 
03579                     Next = Next-&gt;Flink;
03580                 }
03581 
03582                 <span class="comment">//</span>
03583                 <span class="comment">//  At this point we've scanned through the heap segments and the</span>
03584                 <span class="comment">//  big allocations.</span>
03585                 <span class="comment">//</span>
03586                 <span class="comment">//  The first time through this procedure we have built two lists</span>
03587                 <span class="comment">//  the Entries and the AddedEntries</span>
03588                 <span class="comment">//</span>
03589 
03590                 <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
03591 
03592                     pOldEntries = <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;LargeEntriesSentinal;
03593                     <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;LargeEntriesSentinal = *ppEntries;
03594 
03595                     <span class="comment">//</span>
03596                     <span class="comment">//  Now we'll process the previous large entries sentinal list</span>
03597                     <span class="comment">//</span>
03598                     <span class="comment">//  This path is not taken the first time through this procedure</span>
03599                     <span class="comment">//</span>
03600 
03601                     <span class="keywordflow">while</span> (pOldEntries != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03602 
03603                         <span class="comment">//</span>
03604                         <span class="comment">//  If we have new entries and the entry is equal to the</span>
03605                         <span class="comment">//  entry in the previous large sentinal list then</span>
03606                         <span class="comment">//  we move one down on the new list and remove the previous</span>
03607                         <span class="comment">//  sentinal entry</span>
03608                         <span class="comment">//</span>
03609 
03610                         <span class="keywordflow">if</span> ((*ppEntries != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
03611                             (pOldEntries-&gt;Address == (*ppEntries)-&gt;Address) &amp;&amp;
03612                             (pOldEntries-&gt;Size == (*ppEntries)-&gt;Size)) {
03613 
03614                             ppEntries = &amp;(*ppEntries)-&gt;Next;
03615 
03616                             pOldEntries = <a class="code" href="../../d5/d9/heapdll_8c.html#a18">RtlpFreeHeapUsageEntry</a>( <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, pOldEntries );
03617 
03618                         <span class="comment">//</span>
03619                         <span class="comment">//  If we do now have any new entries or the previous</span>
03620                         <span class="comment">//  sentinal entry is comes before this new entry then</span>
03621                         <span class="comment">//  we'll add the sentinal entry to the remove list</span>
03622                         <span class="comment">//</span>
03623 
03624                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((*ppEntries == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) ||
03625                                    (pOldEntries-&gt;Address &lt; (*ppEntries)-&gt;Address)) {
03626 
03627                             *ppRemovedEntries = pOldEntries;
03628 
03629                             pOldEntries = pOldEntries-&gt;Next;
03630 
03631                             ppRemovedEntries = &amp;(*ppRemovedEntries)-&gt;Next;
03632 
03633                             *ppRemovedEntries = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03634 
03635                         <span class="comment">//</span>
03636                         <span class="comment">//  Otherwise the old sentinal entry is put on the added</span>
03637                         <span class="comment">//  entries list</span>
03638                         <span class="comment">//</span>
03639 
03640                         } <span class="keywordflow">else</span> {
03641 
03642                             *ppAddedEntries = pOldEntries;
03643 
03644                             pOldEntries = pOldEntries-&gt;Next;
03645 
03646                             **ppAddedEntries = **ppEntries;
03647 
03648                             ppAddedEntries = &amp;(*ppAddedEntries)-&gt;Next;
03649 
03650                             *ppAddedEntries = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03651                         }
03652                     }
03653 
03654                     <span class="comment">//</span>
03655                     <span class="comment">//  This path is not taken the first time through this procedure</span>
03656                     <span class="comment">//</span>
03657 
03658                     <span class="keywordflow">while</span> (pNewEntry = *ppEntries) {
03659 
03660                         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d5/d9/heapdll_8c.html#a19">RtlpAllocateHeapUsageEntry</a>( <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, ppAddedEntries );
03661 
03662                         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
03663 
03664                             <span class="keywordflow">break</span>;
03665                         }
03666 
03667                         **ppAddedEntries = *pNewEntry;
03668 
03669                         ppAddedEntries = &amp;(*ppAddedEntries)-&gt;Next;
03670 
03671                         *ppAddedEntries = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03672 
03673                         ppEntries = &amp;pNewEntry-&gt;Next;
03674                     }
03675 
03676                     <span class="comment">//</span>
03677                     <span class="comment">//  Tell the user that something has changed between the</span>
03678                     <span class="comment">//  previous call and this one</span>
03679                     <span class="comment">//</span>
03680 
03681                     <span class="keywordflow">if</span> ((<a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;AddedEntries != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) || (<a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;RemovedEntries != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
03682 
03683                         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_MORE_ENTRIES;
03684                     }
03685                 }
03686             }
03687         }
03688 
03689     } finally {
03690 
03691         <span class="comment">//</span>
03692         <span class="comment">//  Unlock the heap</span>
03693         <span class="comment">//</span>
03694 
03695         <span class="keywordflow">if</span> (LockAcquired) {
03696 
03697             <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> );
03698         }
03699     }
03700 
03701     <span class="comment">//</span>
03702     <span class="comment">//  And return to our caller</span>
03703     <span class="comment">//</span>
03704 
03705     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
03706 }
03707 
03708 
03709 <span class="comment">//</span>
03710 <span class="comment">//  Declared in nturtl.h</span>
03711 <span class="comment">//</span>
03712 
03713 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l03714"></a><a class="code" href="../../d5/d9/heapdll_8c.html#a37">03714</a> <a class="code" href="../../d5/d9/heapdll_8c.html#a37">RtlWalkHeap</a> (
03715     IN PVOID HeapHandle,
03716     IN OUT PRTL_HEAP_WALK_ENTRY Entry
03717     )
03718 
03719 <span class="comment">/*++</span>
03720 <span class="comment"></span>
03721 <span class="comment">Routine Description:</span>
03722 <span class="comment"></span>
03723 <span class="comment">    This routine is used to enumerate all the entries within a heap.  For each</span>
03724 <span class="comment">    call it returns a new information in entry.</span>
03725 <span class="comment"></span>
03726 <span class="comment">Arguments:</span>
03727 <span class="comment"></span>
03728 <span class="comment">    HeapHandle - Supplies a pointer to the heap being queried</span>
03729 <span class="comment"></span>
03730 <span class="comment">    Entry - Supplies storage for the entry information.  If the DataAddress field</span>
03731 <span class="comment">        is null then the enumeration starts over from the beginning otherwise it</span>
03732 <span class="comment">        resumes from where it left off</span>
03733 <span class="comment"></span>
03734 <span class="comment">Return Value:</span>
03735 <span class="comment"></span>
03736 <span class="comment">    NTSTATUS - An appropriate status value</span>
03737 <span class="comment"></span>
03738 <span class="comment">--*/</span>
03739 
03740 {
03741     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
03742     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
03743     <a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a> Segment;
03744     UCHAR SegmentIndex;
03745     <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a> CurrentBlock;
03746     <a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html">PHEAP_ENTRY_EXTRA</a> ExtraStuff;
03747     <a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html">PHEAP_UNCOMMMTTED_RANGE</a> UnCommittedRange, *pp;
03748     PLIST_ENTRY Next, Head;
03749     <a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html">PHEAP_VIRTUAL_ALLOC_ENTRY</a> VirtualAllocBlock;
03750 
03751     <span class="comment">//</span>
03752     <span class="comment">//  Check if we should be using the guard page verion of heap</span>
03753     <span class="comment">//</span>
03754 
03755     <a class="code" href="../../d7/d9/heappage_8h.html#a6">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>,
03756                                     <a class="code" href="../../d7/d9/heappage_8h.html#a18">RtlpDebugPageHeapWalk</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, Entry ));
03757 
03758     <span class="comment">//</span>
03759     <span class="comment">//  If this is the debug version of heap then validate the heap</span>
03760     <span class="comment">//  before we go on</span>
03761     <span class="comment">//</span>
03762 
03763     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a8">DEBUG_HEAP</a>( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o2">Flags</a> )) {
03764 
03765         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d9/heapdll_8c.html#a16">RtlDebugWalkHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, Entry )) {
03766 
03767             <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
03768         }
03769     }
03770 
03771     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
03772 
03773     <span class="comment">//</span>
03774     <span class="comment">//  If there is an active lookaside list then drain and remove it.</span>
03775     <span class="comment">//  By setting the lookaside field in the heap to null we guarantee</span>
03776     <span class="comment">//  that the call the free heap will not try and use the lookaside</span>
03777     <span class="comment">//  list logic.</span>
03778     <span class="comment">//</span>
03779     <span class="comment">//  We'll actually capture the lookaside pointer from the heap and</span>
03780     <span class="comment">//  only use the captured pointer.  This will take care of the</span>
03781     <span class="comment">//  condition where another walk or lock heap can cause us to check</span>
03782     <span class="comment">//  for a non null pointer and then have it become null when we read</span>
03783     <span class="comment">//  it again.  If it is non null to start with then even if the</span>
03784     <span class="comment">//  user walks or locks the heap via another thread the pointer to</span>
03785     <span class="comment">//  still valid here so we can still try and do a lookaside list pop.</span>
03786     <span class="comment">//</span>
03787 
03788     {
03789         <a class="code" href="../../d6/d6/struct__HEAP__LOOKASIDE.html">PHEAP_LOOKASIDE</a> Lookaside = (<a class="code" href="../../d6/d6/struct__HEAP__LOOKASIDE.html">PHEAP_LOOKASIDE</a>)Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o33">Lookaside</a>;
03790 
03791         <span class="keywordflow">if</span> (Lookaside != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03792 
03793             ULONG i;
03794             PVOID Block;
03795 
03796             Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o33">Lookaside</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03797 
03798             <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="../../d3/d9/heap_8h.html#a6">HEAP_MAXIMUM_FREELISTS</a>; i += 1) {
03799 
03800                 <span class="keywordflow">while</span> ((Block = <a class="code" href="../../d0/d6/rtl_2lookasid_8c.html#a5">RtlpAllocateFromHeapLookaside</a>(&amp;(Lookaside[i]))) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03801 
03802                     <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, 0, Block );
03803                 }
03804             }
03805         }
03806     }
03807 
03808     <span class="comment">//</span>
03809     <span class="comment">//  Check if this is the first time we've been called to walk the heap</span>
03810     <span class="comment">//</span>
03811 
03812     <span class="keywordflow">if</span> (Entry-&gt;DataAddress == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03813 
03814         <span class="comment">//</span>
03815         <span class="comment">//  Start with the first segement in the heap</span>
03816         <span class="comment">//</span>
03817 
03818         SegmentIndex = 0;
03819 
03820 nextSegment:
03821 
03822         CurrentBlock = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03823 
03824         <span class="comment">//</span>
03825         <span class="comment">//  Now find the next in use segment for the heap</span>
03826         <span class="comment">//</span>
03827 
03828         Segment = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03829 
03830         <span class="keywordflow">while</span> ((SegmentIndex &lt; <a class="code" href="../../d3/d9/heap_8h.html#a7">HEAP_MAXIMUM_SEGMENTS</a>) &amp;&amp;
03831                ((Segment = Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o22">Segments</a>[ SegmentIndex ]) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
03832 
03833             SegmentIndex += 1;
03834         }
03835 
03836         <span class="comment">//</span>
03837         <span class="comment">//  If there are no more valid segments then we'll try the big</span>
03838         <span class="comment">//  allocation</span>
03839         <span class="comment">//</span>
03840 
03841         <span class="keywordflow">if</span> (Segment == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03842 
03843             Head = &amp;Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o21">VirtualAllocdBlocks</a>;
03844             Next = Head-&gt;Flink;
03845 
03846             <span class="keywordflow">if</span> (Next == Head) {
03847 
03848                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_NO_MORE_ENTRIES;
03849 
03850             } <span class="keywordflow">else</span> {
03851 
03852                 VirtualAllocBlock = CONTAINING_RECORD( Next, <a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html">HEAP_VIRTUAL_ALLOC_ENTRY</a>, Entry );
03853 
03854                 CurrentBlock = &amp;VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o4">BusyBlock</a>;
03855             }
03856 
03857         <span class="comment">//</span>
03858         <span class="comment">//  Otherwise we'll grab information about the segment.  Note that</span>
03859         <span class="comment">//  the current block is still null so when we fall out of this</span>
03860         <span class="comment">//  block we'll return directly to our caller with this segment</span>
03861         <span class="comment">//  information</span>
03862         <span class="comment">//</span>
03863 
03864         } <span class="keywordflow">else</span> {
03865 
03866             Entry-&gt;DataAddress = Segment;
03867 
03868             Entry-&gt;DataSize = 0;
03869 
03870             Entry-&gt;OverheadBytes = <span class="keyword">sizeof</span>( *Segment );
03871 
03872             Entry-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o2">Flags</a> = RTL_HEAP_SEGMENT;
03873 
03874             Entry-&gt;SegmentIndex = SegmentIndex;
03875 
03876             Entry-&gt;Segment.CommittedSize = (Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o6">NumberOfPages</a> -
03877                                             Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o9">NumberOfUnCommittedPages</a>) * <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
03878 
03879             Entry-&gt;Segment.UnCommittedSize = Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o9">NumberOfUnCommittedPages</a> * <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
03880 
03881             Entry-&gt;Segment.FirstEntry = (Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o7">FirstEntry</a>-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a8">HEAP_ENTRY_BUSY</a>) ?
03882                 ((<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o7">FirstEntry</a> + 1) :
03883                 (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)((<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o7">FirstEntry</a> + 1);
03884 
03885             Entry-&gt;Segment.LastEntry = Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o8">LastValidEntry</a>;
03886         }
03887 
03888     <span class="comment">//</span>
03889     <span class="comment">//  This is not the first time through.  Check if last time we gave back</span>
03890     <span class="comment">//  an heap segement or an uncommitted range</span>
03891     <span class="comment">//</span>
03892 
03893     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Entry-&gt;Flags &amp; (RTL_HEAP_SEGMENT | RTL_HEAP_UNCOMMITTED_RANGE)) {
03894 
03895         <span class="comment">//</span>
03896         <span class="comment">//  Check that the segment index is still valid</span>
03897         <span class="comment">//</span>
03898 
03899         <span class="keywordflow">if</span> ((SegmentIndex = Entry-&gt;SegmentIndex) &gt;= <a class="code" href="../../d3/d9/heap_8h.html#a7">HEAP_MAXIMUM_SEGMENTS</a>) {
03900 
03901             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_ADDRESS;
03902 
03903             CurrentBlock = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03904 
03905         } <span class="keywordflow">else</span> {
03906 
03907             <span class="comment">//</span>
03908             <span class="comment">//  Check that the segment is still in use</span>
03909             <span class="comment">//</span>
03910 
03911             Segment = Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o22">Segments</a>[ SegmentIndex ];
03912 
03913             <span class="keywordflow">if</span> (Segment == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03914 
03915                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_ADDRESS;
03916 
03917                 CurrentBlock = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03918 
03919             <span class="comment">//</span>
03920             <span class="comment">//  The segment is still in use if what we returned last time</span>
03921             <span class="comment">//  as the segment header then this time we'll return the</span>
03922             <span class="comment">//  segments first entry</span>
03923             <span class="comment">//</span>
03924 
03925             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Entry-&gt;Flags &amp; RTL_HEAP_SEGMENT) {
03926 
03927                 CurrentBlock = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o7">FirstEntry</a>;
03928 
03929             <span class="comment">//</span>
03930             <span class="comment">//  Otherwise what we returned last time as an uncommitted</span>
03931             <span class="comment">//  range so now we need to get the next block</span>
03932             <span class="comment">//</span>
03933 
03934             } <span class="keywordflow">else</span> {
03935 
03936                 CurrentBlock = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)((PCHAR)Entry-&gt;DataAddress + Entry-&gt;DataSize);
03937 
03938                 <span class="comment">//</span>
03939                 <span class="comment">//  Check if we are beyond this segment and need to get the</span>
03940                 <span class="comment">//  next one</span>
03941                 <span class="comment">//</span>
03942 
03943                 <span class="keywordflow">if</span> (CurrentBlock &gt;= Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o8">LastValidEntry</a>) {
03944 
03945                     SegmentIndex += 1;
03946 
03947                     <span class="keywordflow">goto</span> nextSegment;
03948                 }
03949             }
03950         }
03951 
03952     <span class="comment">//</span>
03953     <span class="comment">//  Otherwise this is not the first time through and last time we gave back a</span>
03954     <span class="comment">//  valid heap entry</span>
03955     <span class="comment">//</span>
03956 
03957     } <span class="keywordflow">else</span> {
03958 
03959         <span class="comment">//</span>
03960         <span class="comment">//  Check if the last entry we gave back was in use</span>
03961         <span class="comment">//</span>
03962 
03963         <span class="keywordflow">if</span> (Entry-&gt;Flags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a8">HEAP_ENTRY_BUSY</a>) {
03964 
03965             <span class="comment">//</span>
03966             <span class="comment">//  Get the last entry we returned</span>
03967             <span class="comment">//</span>
03968 
03969             CurrentBlock = ((<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)Entry-&gt;DataAddress - 1);
03970 
03971             <span class="comment">//</span>
03972             <span class="comment">//  If the last entry was for a big allocation then</span>
03973             <span class="comment">//  get the next big block if there is one otherwise</span>
03974             <span class="comment">//  say there are no more entries</span>
03975             <span class="comment">//</span>
03976 
03977             <span class="keywordflow">if</span> (CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a11">HEAP_ENTRY_VIRTUAL_ALLOC</a>) {
03978 
03979                 Head = &amp;Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o21">VirtualAllocdBlocks</a>;
03980 
03981                 VirtualAllocBlock = CONTAINING_RECORD( CurrentBlock, <a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html">HEAP_VIRTUAL_ALLOC_ENTRY</a>, BusyBlock );
03982 
03983                 Next = VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o0">Entry</a>.Flink;
03984 
03985                 <span class="keywordflow">if</span> (Next == Head) {
03986 
03987                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_NO_MORE_ENTRIES;
03988 
03989                 } <span class="keywordflow">else</span> {
03990 
03991                     VirtualAllocBlock = CONTAINING_RECORD( Next, <a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html">HEAP_VIRTUAL_ALLOC_ENTRY</a>, Entry );
03992 
03993                     CurrentBlock = &amp;VirtualAllocBlock-&gt;<a class="code" href="../../d6/d7/struct__HEAP__VIRTUAL__ALLOC__ENTRY.html#o4">BusyBlock</a>;
03994                 }
03995 
03996             <span class="comment">//</span>
03997             <span class="comment">//  Our previous result is a busy normal block</span>
03998             <span class="comment">//</span>
03999 
04000             } <span class="keywordflow">else</span> {
04001 
04002                 <span class="comment">//</span>
04003                 <span class="comment">//  Get the segment and make sure it it still valid and in use</span>
04004                 <span class="comment">//</span>
04005                 <span class="comment">//  **** this should also check that segment index is not</span>
04006                 <span class="comment">//  **** greater than HEAP MAXIMUM SEGMENTS</span>
04007                 <span class="comment">//</span>
04008 
04009                 Segment = Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o22">Segments</a>[ SegmentIndex = CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o2">SegmentIndex</a> ];
04010 
04011                 <span class="keywordflow">if</span> (Segment == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04012 
04013                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_ADDRESS;
04014 
04015                     CurrentBlock = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04016 
04017                 <span class="comment">//</span>
04018                 <span class="comment">//  The segment is still in use, check if what we returned</span>
04019                 <span class="comment">//  previously was a last entry</span>
04020                 <span class="comment">//</span>
04021 
04022                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>) {
04023 
04024 findUncommittedRange:
04025 
04026                     <span class="comment">//</span>
04027                     <span class="comment">//  We are at a last entry so now if the segment is done</span>
04028                     <span class="comment">//  then go get another segment</span>
04029                     <span class="comment">//</span>
04030 
04031                     CurrentBlock += CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a>;
04032 
04033                     <span class="keywordflow">if</span> (CurrentBlock &gt;= Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o8">LastValidEntry</a>) {
04034 
04035                         SegmentIndex += 1;
04036 
04037                         <span class="keywordflow">goto</span> nextSegment;
04038                     }
04039 
04040                     <span class="comment">//</span>
04041                     <span class="comment">//  Otherwise we will find the uncommitted range entry that</span>
04042                     <span class="comment">//  immediately follows this last entry</span>
04043                     <span class="comment">//</span>
04044 
04045                     pp = &amp;Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o11">UnCommittedRanges</a>;
04046 
04047                     <span class="keywordflow">while</span> ((UnCommittedRange = *pp) &amp;&amp; UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o1">Address</a> != (ULONG_PTR)CurrentBlock ) {
04048 
04049                         pp = &amp;UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o0">Next</a>;
04050                     }
04051 
04052                     <span class="keywordflow">if</span> (UnCommittedRange == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04053 
04054                         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_PARAMETER;
04055 
04056                     } <span class="keywordflow">else</span> {
04057 
04058                         <span class="comment">//</span>
04059                         <span class="comment">//  Now fill in the entry to denote that uncommitted</span>
04060                         <span class="comment">//  range information</span>
04061                         <span class="comment">//</span>
04062 
04063                         Entry-&gt;DataAddress = (PVOID)UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o1">Address</a>;
04064 
04065                         Entry-&gt;DataSize = UnCommittedRange-&gt;<a class="code" href="../../d5/d7/struct__HEAP__UNCOMMMTTED__RANGE.html#o2">Size</a>;
04066 
04067                         Entry-&gt;OverheadBytes = 0;
04068 
04069                         Entry-&gt;SegmentIndex = SegmentIndex;
04070 
04071                         Entry-&gt;Flags = RTL_HEAP_UNCOMMITTED_RANGE;
04072                     }
04073 
04074                     <span class="comment">//</span>
04075                     <span class="comment">//  Null out the current block because we've just filled in</span>
04076                     <span class="comment">//  the entry</span>
04077                     <span class="comment">//</span>
04078 
04079                     CurrentBlock = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04080 
04081                 } <span class="keywordflow">else</span> {
04082 
04083                     <span class="comment">//</span>
04084                     <span class="comment">//  Otherwise the entry has a following entry so now</span>
04085                     <span class="comment">//  advance to the next entry</span>
04086                     <span class="comment">//</span>
04087 
04088                     CurrentBlock += CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a>;
04089                 }
04090             }
04091 
04092         <span class="comment">//</span>
04093         <span class="comment">//  Otherwise the previous entry we returned is not in use</span>
04094         <span class="comment">//</span>
04095 
04096         } <span class="keywordflow">else</span> {
04097 
04098             <span class="comment">//</span>
04099             <span class="comment">//  Get the last entry we returned</span>
04100             <span class="comment">//</span>
04101 
04102             CurrentBlock = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)((<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)Entry-&gt;DataAddress - 1);
04103 
04104             <span class="comment">//</span>
04105             <span class="comment">//  Get the segment and make sure it it still valid and in use</span>
04106             <span class="comment">//</span>
04107             <span class="comment">//  **** this should also check that segment index is not</span>
04108             <span class="comment">//  **** greater than HEAP MAXIMUM SEGMENTS</span>
04109             <span class="comment">//</span>
04110 
04111             Segment = Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o22">Segments</a>[ SegmentIndex = CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o2">SegmentIndex</a> ];
04112 
04113             <span class="keywordflow">if</span> (Segment == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04114 
04115                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_ADDRESS;
04116 
04117                 CurrentBlock = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04118 
04119             <span class="comment">//</span>
04120             <span class="comment">//  If the block is the last entry then go find the next uncommitted</span>
04121             <span class="comment">//  range or segment</span>
04122             <span class="comment">//</span>
04123 
04124             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>) {
04125 
04126                 <span class="keywordflow">goto</span> findUncommittedRange;
04127 
04128             <span class="comment">//</span>
04129             <span class="comment">//  Otherwise we'll just move on to the next entry</span>
04130             <span class="comment">//</span>
04131 
04132             } <span class="keywordflow">else</span> {
04133 
04134                 CurrentBlock += CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a>;
04135             }
04136         }
04137     }
04138 
04139     <span class="comment">//</span>
04140     <span class="comment">//  At this point if current block is not null then we've found another</span>
04141     <span class="comment">//  entry to return.  We could also have found a segment or uncommitted</span>
04142     <span class="comment">//  range but those are handled separately above and keep current block</span>
04143     <span class="comment">//  null</span>
04144     <span class="comment">//</span>
04145 
04146     <span class="keywordflow">if</span> (CurrentBlock != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04147 
04148         <span class="comment">//</span>
04149         <span class="comment">//  Check if the block is in use</span>
04150         <span class="comment">//</span>
04151 
04152         <span class="keywordflow">if</span> (CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a8">HEAP_ENTRY_BUSY</a>) {
04153 
04154             <span class="comment">//</span>
04155             <span class="comment">//  Fill in the entry field for this block</span>
04156             <span class="comment">//</span>
04157 
04158             Entry-&gt;DataAddress = (CurrentBlock+1);
04159 
04160             <span class="keywordflow">if</span> (CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a11">HEAP_ENTRY_VIRTUAL_ALLOC</a>) {
04161 
04162                 Entry-&gt;DataSize = <a class="code" href="../../d9/d9/heappriv_8h.html#a40">RtlpGetSizeOfBigBlock</a>( CurrentBlock );
04163 
04164                 Entry-&gt;OverheadBytes = (UCHAR)( <span class="keyword">sizeof</span>( *VirtualAllocBlock ) + CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a>);
04165 
04166                 Entry-&gt;SegmentIndex = <a class="code" href="../../d3/d9/heap_8h.html#a7">HEAP_MAXIMUM_SEGMENTS</a>;
04167 
04168                 Entry-&gt;Flags = RTL_HEAP_BUSY |  <a class="code" href="../../d3/d9/heap_8h.html#a11">HEAP_ENTRY_VIRTUAL_ALLOC</a>;
04169 
04170             } <span class="keywordflow">else</span> {
04171 
04172                 Entry-&gt;DataSize = (CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a> &lt;&lt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>) -
04173                                   CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o4">UnusedBytes</a>;
04174 
04175                 Entry-&gt;OverheadBytes = CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o4">UnusedBytes</a>;
04176 
04177                 Entry-&gt;SegmentIndex = CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o2">SegmentIndex</a>;
04178 
04179                 Entry-&gt;Flags = RTL_HEAP_BUSY;
04180             }
04181 
04182             <span class="keywordflow">if</span> (CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a9">HEAP_ENTRY_EXTRA_PRESENT</a>) {
04183 
04184                 ExtraStuff = <a class="code" href="../../d9/d9/heappriv_8h.html#a41">RtlpGetExtraStuffPointer</a>( CurrentBlock );
04185 
04186                 Entry-&gt;Block.Settable = ExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o2">Settable</a>;
04187 <span class="preprocessor">#if i386</span>
04188 <span class="preprocessor"></span>
04189                 Entry-&gt;Block.AllocatorBackTraceIndex = ExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o0">AllocatorBackTraceIndex</a>;
04190 
04191 <span class="preprocessor">#endif // i386</span>
04192 <span class="preprocessor"></span>
04193                 <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d9/heappriv_8h.html#a22">IS_HEAP_TAGGING_ENABLED</a>()) {
04194 
04195                     Entry-&gt;Block.TagIndex = 0;
04196 
04197                 } <span class="keywordflow">else</span> {
04198 
04199                     Entry-&gt;Block.TagIndex = ExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o1">TagIndex</a>;
04200                 }
04201 
04202                 Entry-&gt;Flags |= RTL_HEAP_SETTABLE_VALUE;
04203 
04204             } <span class="keywordflow">else</span> {
04205 
04206                 <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d9/heappriv_8h.html#a22">IS_HEAP_TAGGING_ENABLED</a>()) {
04207 
04208                     Entry-&gt;Block.TagIndex = 0;
04209 
04210                 } <span class="keywordflow">else</span> {
04211 
04212                     Entry-&gt;Block.TagIndex = CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o5">SmallTagIndex</a>;
04213                 }
04214             }
04215 
04216             Entry-&gt;Flags |= CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a16">HEAP_ENTRY_SETTABLE_FLAGS</a>;
04217 
04218         <span class="comment">//</span>
04219         <span class="comment">//  Otherwise the block is not in use</span>
04220         <span class="comment">//</span>
04221 
04222         } <span class="keywordflow">else</span> {
04223 
04224             Entry-&gt;DataAddress = ((<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)CurrentBlock+1);
04225 
04226             Entry-&gt;DataSize = (CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a> &lt;&lt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>) -
04227                               <span class="keyword">sizeof</span>( <a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">HEAP_FREE_ENTRY</a> );
04228 
04229             Entry-&gt;OverheadBytes = <span class="keyword">sizeof</span>( <a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">HEAP_FREE_ENTRY</a> );
04230 
04231             Entry-&gt;SegmentIndex = CurrentBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o2">SegmentIndex</a>;
04232 
04233             Entry-&gt;Flags = 0;
04234         }
04235     }
04236 
04237     <span class="comment">//</span>
04238     <span class="comment">//  And return to our caller</span>
04239     <span class="comment">//</span>
04240 
04241     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
04242 }
04243 
04244 
04245 <span class="comment">//</span>
04246 <span class="comment">//  Declared in heappriv.h</span>
04247 <span class="comment">//</span>
04248 
04249 BOOLEAN
<a name="l04250"></a><a class="code" href="../../d9/d9/heappriv_8h.html#a46">04250</a> <a class="code" href="../../d9/d9/heappriv_8h.html#a46">RtlpCheckHeapSignature</a> (
04251     IN <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap,
04252     IN PCHAR Caller
04253     )
04254 
04255 <span class="comment">/*++</span>
04256 <span class="comment"></span>
04257 <span class="comment">Routine Description:</span>
04258 <span class="comment"></span>
04259 <span class="comment">    This routine verifies that it is being called with a properly identified</span>
04260 <span class="comment">    heap.</span>
04261 <span class="comment"></span>
04262 <span class="comment">Arguments:</span>
04263 <span class="comment"></span>
04264 <span class="comment">    Heap - Supplies a pointer to the heap being checked</span>
04265 <span class="comment"></span>
04266 <span class="comment">    Caller - Supplies a string that can be used to identify the caller</span>
04267 <span class="comment"></span>
04268 <span class="comment">Return Value:</span>
04269 <span class="comment"></span>
04270 <span class="comment">    BOOLEAN - TRUE if the heap signature is present, and FALSE otherwise</span>
04271 <span class="comment"></span>
04272 <span class="comment">--*/</span>
04273 
04274 {
04275     <span class="comment">//</span>
04276     <span class="comment">//  If the heap signature matches then that is the only</span>
04277     <span class="comment">//  checking we do</span>
04278     <span class="comment">//</span>
04279 
04280     <span class="keywordflow">if</span> (Heap-&gt;Signature == <a class="code" href="../../d3/d9/heap_8h.html#a19">HEAP_SIGNATURE</a>) {
04281 
04282         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04283 
04284     } <span class="keywordflow">else</span> {
04285 
04286         <span class="comment">//</span>
04287         <span class="comment">//  We have a bad heap signature.  Print out some information, break</span>
04288         <span class="comment">//  into the debugger, and then return false</span>
04289         <span class="comment">//</span>
04290 
04291         <a class="code" href="../../d9/d9/heappriv_8h.html#a10">HeapDebugPrint</a>(( <span class="stringliteral">"Invalid heap signature for heap at %x"</span>, Heap ));
04292 
04293         <span class="keywordflow">if</span> (Caller != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04294 
04295             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( <span class="stringliteral">", passed to %s"</span>, Caller );
04296         }
04297 
04298         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( <span class="stringliteral">"\n"</span> );
04299 
04300         <a class="code" href="../../d9/d9/heappriv_8h.html#a11">HeapDebugBreak</a>( &amp;Heap-&gt;Signature );
04301 
04302         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04303     }
04304 }
04305 
04306 
04307 <span class="comment">//</span>
04308 <span class="comment">//  Declared in heappriv.h</span>
04309 <span class="comment">//</span>
04310 
04311 <a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>
<a name="l04312"></a><a class="code" href="../../d9/d9/heappriv_8h.html#a45">04312</a> <a class="code" href="../../d9/d9/heappriv_8h.html#a45">RtlpCoalesceHeap</a> (
04313     IN <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap
04314     )
04315 
04316 <span class="comment">/*++</span>
04317 <span class="comment"></span>
04318 <span class="comment">Routine Description:</span>
04319 <span class="comment"></span>
04320 <span class="comment">    This routine scans through heap and coalesces its free blocks</span>
04321 <span class="comment"></span>
04322 <span class="comment">Arguments:</span>
04323 <span class="comment"></span>
04324 <span class="comment">    Heap - Supplies a pointer to the heap being modified</span>
04325 <span class="comment"></span>
04326 <span class="comment">Return Value:</span>
04327 <span class="comment"></span>
04328 <span class="comment">    PHEAP_FREE_ENTRY - returns a pointer to the largest free block</span>
04329 <span class="comment">        in the heap</span>
04330 <span class="comment"></span>
04331 <span class="comment">--*/</span>
04332 
04333 {
04334     SIZE_T OldFreeSize;
04335     SIZE_T FreeSize;
04336     ULONG <a class="code" href="../../d7/d0/exts_8h.html#a0">n</a>;
04337     <a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a> FreeBlock, LargestFreeBlock;
04338     PLIST_ENTRY FreeListHead, Next;
04339 
04340     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
04341 
04342     LargestFreeBlock = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04343 
04344     <span class="comment">//</span>
04345     <span class="comment">//  For every free list in the heap, going from smallest to</span>
04346     <span class="comment">//  largest and skipping the zero index one we will</span>
04347     <span class="comment">//  scan the free list coalesceing the free blocks</span>
04348     <span class="comment">//</span>
04349 
04350     FreeListHead = &amp;Heap-&gt;FreeLists[ 1 ];
04351 
04352     <a class="code" href="../../d7/d0/exts_8h.html#a0">n</a> = <a class="code" href="../../d3/d9/heap_8h.html#a6">HEAP_MAXIMUM_FREELISTS</a>;
04353 
04354     <span class="keywordflow">while</span> (<a class="code" href="../../d7/d0/exts_8h.html#a0">n</a>--) {
04355 
04356         <span class="comment">//</span>
04357         <span class="comment">//  Scan the individual free list</span>
04358         <span class="comment">//</span>
04359 
04360         Next = FreeListHead-&gt;Blink;
04361 
04362         <span class="keywordflow">while</span> (FreeListHead != Next) {
04363 
04364             <span class="comment">//</span>
04365             <span class="comment">//  Get a pointer to the current free list entry, and remember its</span>
04366             <span class="comment">//  next and size</span>
04367             <span class="comment">//</span>
04368 
04369             FreeBlock = CONTAINING_RECORD( Next, <a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">HEAP_FREE_ENTRY</a>, FreeList );
04370 
04371             Next = Next-&gt;Flink;
04372             OldFreeSize = FreeSize = FreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a>;
04373 
04374             <span class="comment">//</span>
04375             <span class="comment">//  Coalesce the block</span>
04376             <span class="comment">//</span>
04377 
04378             FreeBlock = <a class="code" href="../../d9/d9/heappriv_8h.html#a34">RtlpCoalesceFreeBlocks</a>( Heap,
04379                                                 FreeBlock,
04380                                                 &amp;FreeSize,
04381                                                 <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
04382 
04383             <span class="comment">//</span>
04384             <span class="comment">//  If the new free size is not equal to the old free size</span>
04385             <span class="comment">//  then we actually did some changes otherwise the coalesce</span>
04386             <span class="comment">//  calll was essentialy a noop</span>
04387             <span class="comment">//</span>
04388 
04389             <span class="keywordflow">if</span> (FreeSize != OldFreeSize) {
04390 
04391                 <span class="comment">//</span>
04392                 <span class="comment">//  Check if we should decommit this block because it is too</span>
04393                 <span class="comment">//  large and it is either at the beginning or end of a</span>
04394                 <span class="comment">//  committed run.  Otherwise just insert the new sized</span>
04395                 <span class="comment">//  block into its corresponding free list.  We'll hit this</span>
04396                 <span class="comment">//  block again when we visit larger free lists.</span>
04397                 <span class="comment">//</span>
04398 
04399                 <span class="keywordflow">if</span> (FreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a> &gt;= (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> &gt;&gt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>)
04400 
04401                         &amp;&amp;
04402 
04403                     (FreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o1">PreviousSize</a> == 0 ||
04404                      (FreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>))) {
04405 
04406                     <a class="code" href="../../d9/d9/heappriv_8h.html#a35">RtlpDeCommitFreeBlock</a>( Heap, FreeBlock, FreeSize );
04407 
04408                 } <span class="keywordflow">else</span> {
04409 
04410                     <a class="code" href="../../d9/d9/heappriv_8h.html#a36">RtlpInsertFreeBlock</a>( Heap, FreeBlock, FreeSize );
04411                 }
04412 
04413                 Next = FreeListHead-&gt;Blink;
04414 
04415             } <span class="keywordflow">else</span> {
04416 
04417                 <span class="comment">//</span>
04418                 <span class="comment">//  Remember the largest free block we've found so far</span>
04419                 <span class="comment">//</span>
04420 
04421                 <span class="keywordflow">if</span> ((LargestFreeBlock == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) ||
04422                     (LargestFreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a> &lt; FreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a>)) {
04423 
04424                     LargestFreeBlock = FreeBlock;
04425                 }
04426             }
04427         }
04428 
04429         <span class="comment">//</span>
04430         <span class="comment">//  Go to the next free list.  When we hit the largest dedicated</span>
04431         <span class="comment">//  size free list we'll fall back to the [0] index list</span>
04432         <span class="comment">//</span>
04433 
04434         <span class="keywordflow">if</span> (<a class="code" href="../../d7/d0/exts_8h.html#a0">n</a> == 1) {
04435 
04436             FreeListHead = &amp;Heap-&gt;FreeLists[ 0 ];
04437 
04438         } <span class="keywordflow">else</span> {
04439 
04440             FreeListHead++;
04441         }
04442     }
04443 
04444     <span class="comment">//</span>
04445     <span class="comment">//  And return to our caller</span>
04446     <span class="comment">//</span>
04447 
04448     <span class="keywordflow">return</span> LargestFreeBlock;
04449 }
04450 
04451 
04452 <span class="comment">//</span>
04453 <span class="comment">//  Declared in heappriv.h</span>
04454 <span class="comment">//</span>
04455 
04456 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l04457"></a><a class="code" href="../../d9/d9/heappriv_8h.html#a43">04457</a> <a class="code" href="../../d9/d9/heappriv_8h.html#a43">RtlpAddHeapToProcessList</a> (
04458     IN <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap
04459     )
04460 
04461 <span class="comment">/*++</span>
04462 <span class="comment"></span>
04463 <span class="comment">Routine Description:</span>
04464 <span class="comment"></span>
04465 <span class="comment">    This routine adds the specified heap to the heap list for the</span>
04466 <span class="comment">    current process</span>
04467 <span class="comment"></span>
04468 <span class="comment">Arguments:</span>
04469 <span class="comment"></span>
04470 <span class="comment">    Heap - Supplies a pointer to the heap being added</span>
04471 <span class="comment"></span>
04472 <span class="comment">Return Value:</span>
04473 <span class="comment"></span>
04474 <span class="comment">    None.</span>
04475 <span class="comment"></span>
04476 <span class="comment">--*/</span>
04477 
04478 {
04479     PPEB Peb = NtCurrentPeb();
04480     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> *NewList;
04481 
04482     <span class="comment">//</span>
04483     <span class="comment">//  Lock the processes heap list</span>
04484     <span class="comment">//</span>
04485 
04486     <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( &amp;<a class="code" href="../../d5/d9/heapdll_8c.html#a3">RtlpProcessHeapsListLock</a>.<a class="code" href="../../d4/d6/struct__HEAP__LOCK.html#o2">Lock</a> );
04487 
04488     <span class="keywordflow">try</span> {
04489 
04490         <span class="comment">//</span>
04491         <span class="comment">//  If the processes heap list is already full then we'll</span>
04492         <span class="comment">//  double the size of the heap list for the process</span>
04493         <span class="comment">//</span>
04494 
04495         <span class="keywordflow">if</span> (Peb-&gt;NumberOfHeaps == Peb-&gt;MaximumNumberOfHeaps) {
04496 
04497             <span class="comment">//</span>
04498             <span class="comment">//  Double the size</span>
04499             <span class="comment">//</span>
04500 
04501             Peb-&gt;MaximumNumberOfHeaps *= 2;
04502 
04503             <span class="comment">//</span>
04504             <span class="comment">//  Allocate space for the new list</span>
04505             <span class="comment">//</span>
04506 
04507             NewList = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>( RtlProcessHeap(),
04508                                        0,
04509                                        Peb-&gt;MaximumNumberOfHeaps * <span class="keyword">sizeof</span>( *NewList ));
04510 
04511             <span class="keywordflow">if</span> (NewList == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04512 
04513                 leave;
04514             }
04515 
04516             <span class="comment">//</span>
04517             <span class="comment">//  Copy over the old buffer to the new buffer</span>
04518             <span class="comment">//</span>
04519 
04520             RtlMoveMemory( NewList,
04521                            Peb-&gt;ProcessHeaps,
04522                            Peb-&gt;NumberOfHeaps * <span class="keyword">sizeof</span>( *NewList ));
04523 
04524             <span class="comment">//</span>
04525             <span class="comment">//  Check if we should free the previous heap list buffer</span>
04526             <span class="comment">//</span>
04527 
04528             <span class="keywordflow">if</span> (Peb-&gt;ProcessHeaps != <a class="code" href="../../d5/d9/heapdll_8c.html#a4">RtlpProcessHeapsListBuffer</a>) {
04529 
04530                 <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( RtlProcessHeap(), 0, Peb-&gt;ProcessHeaps );
04531             }
04532 
04533             <span class="comment">//</span>
04534             <span class="comment">//  Set the new list</span>
04535             <span class="comment">//</span>
04536 
04537             Peb-&gt;ProcessHeaps = NewList;
04538         }
04539 
04540         <span class="comment">//</span>
04541         <span class="comment">//  Add the input heap to the next free heap list slot, and note that</span>
04542         <span class="comment">//  the processes heap list index is really one beyond the actualy</span>
04543         <span class="comment">//  index used to get the processes heap</span>
04544         <span class="comment">//</span>
04545 
04546         Peb-&gt;ProcessHeaps[ Peb-&gt;NumberOfHeaps++ ] = Heap;
04547         Heap-&gt;ProcessHeapsListIndex = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)Peb-&gt;NumberOfHeaps;
04548 
04549     } finally {
04550 
04551         <span class="comment">//</span>
04552         <span class="comment">//  Unlock the processes heap list</span>
04553         <span class="comment">//</span>
04554 
04555         <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( &amp;<a class="code" href="../../d5/d9/heapdll_8c.html#a3">RtlpProcessHeapsListLock</a>.<a class="code" href="../../d4/d6/struct__HEAP__LOCK.html#o2">Lock</a> );
04556     }
04557 
04558     <span class="comment">//</span>
04559     <span class="comment">//  And return to our caller</span>
04560     <span class="comment">//</span>
04561 
04562     <span class="keywordflow">return</span>;
04563 }
04564 
04565 
04566 <span class="comment">//</span>
04567 <span class="comment">//  Delcared in heappriv.h</span>
04568 <span class="comment">//</span>
04569 
04570 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l04571"></a><a class="code" href="../../d9/d9/heappriv_8h.html#a44">04571</a> <a class="code" href="../../d9/d9/heappriv_8h.html#a44">RtlpRemoveHeapFromProcessList</a> (
04572     IN <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap
04573     )
04574 
04575 <span class="comment">/*++</span>
04576 <span class="comment"></span>
04577 <span class="comment">Routine Description:</span>
04578 <span class="comment"></span>
04579 <span class="comment">    This routine removes the specified heap to the heap list for the</span>
04580 <span class="comment">    current process</span>
04581 <span class="comment"></span>
04582 <span class="comment">Arguments:</span>
04583 <span class="comment"></span>
04584 <span class="comment">    Heap - Supplies a pointer to the heap being removed</span>
04585 <span class="comment"></span>
04586 <span class="comment">Return Value:</span>
04587 <span class="comment"></span>
04588 <span class="comment">    None.</span>
04589 <span class="comment"></span>
04590 <span class="comment">--*/</span>
04591 
04592 {
04593     PPEB Peb = NtCurrentPeb();
04594     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> *p, *p1;
04595     ULONG <a class="code" href="../../d7/d0/exts_8h.html#a0">n</a>;
04596 
04597     <span class="comment">//</span>
04598     <span class="comment">//  Lock the current processes heap list lock</span>
04599     <span class="comment">//</span>
04600 
04601     <a class="code" href="../../d9/d9/heappriv_8h.html#a3">RtlAcquireLockRoutine</a>( &amp;<a class="code" href="../../d5/d9/heapdll_8c.html#a3">RtlpProcessHeapsListLock</a>.<a class="code" href="../../d4/d6/struct__HEAP__LOCK.html#o2">Lock</a> );
04602 
04603     <span class="keywordflow">try</span> {
04604 
04605         <span class="comment">//</span>
04606         <span class="comment">//  We only want to the the work if the current process actually has some</span>
04607         <span class="comment">//  heaps, the index stored in the heap is within the range for active</span>
04608         <span class="comment">//  heaps.  Note that the heaps stored index is bias by one.</span>
04609         <span class="comment">//</span>
04610 
04611         <span class="keywordflow">if</span> ((Peb-&gt;NumberOfHeaps != 0) &amp;&amp;
04612             (Heap-&gt;ProcessHeapsListIndex != 0) &amp;&amp;
04613             (Heap-&gt;ProcessHeapsListIndex &lt;= Peb-&gt;NumberOfHeaps)) {
04614 
04615             <span class="comment">//</span>
04616             <span class="comment">//  Establish a pointer into the array of process heaps at the</span>
04617             <span class="comment">//  current heap location and one beyond</span>
04618             <span class="comment">//</span>
04619 
04620             p = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> *)&amp;Peb-&gt;ProcessHeaps[ Heap-&gt;ProcessHeapsListIndex - 1 ];
04621 
04622             p1 = p + 1;
04623 
04624             <span class="comment">//</span>
04625             <span class="comment">//  Calculate the number of heaps that exist beyond the current</span>
04626             <span class="comment">//  heap in the array including the current heap location</span>
04627             <span class="comment">//</span>
04628 
04629             <a class="code" href="../../d7/d0/exts_8h.html#a0">n</a> = Peb-&gt;NumberOfHeaps - (Heap-&gt;ProcessHeapsListIndex - 1);
04630 
04631             <span class="comment">//</span>
04632             <span class="comment">//  For every heap beyond the current one that we are removing</span>
04633             <span class="comment">//  we'll move that heap down to the previous index.</span>
04634             <span class="comment">//</span>
04635 
04636             <span class="keywordflow">while</span> (--<a class="code" href="../../d7/d0/exts_8h.html#a0">n</a>) {
04637 
04638                 <span class="comment">//</span>
04639                 <span class="comment">//  Copy the heap process array entry of the next entry to</span>
04640                 <span class="comment">//  the current entry, and move p1 to the next next entry</span>
04641                 <span class="comment">//</span>
04642 
04643                 *p = *p1++;
04644 
04645                 <span class="comment">//</span>
04646                 <span class="comment">//  This is simply a debugging call</span>
04647                 <span class="comment">//</span>
04648 
04649                 <a class="code" href="../../d9/d9/heappriv_8h.html#a49">RtlpUpdateHeapListIndex</a>( (*p)-&gt;ProcessHeapsListIndex,
04650                                          (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)((*p)-&gt;ProcessHeapsListIndex - 1));
04651 
04652                 <span class="comment">//</span>
04653                 <span class="comment">//  Assign the moved heap its new heap index</span>
04654                 <span class="comment">//</span>
04655 
04656                 (*p)-&gt;ProcessHeapsListIndex -= 1;
04657 
04658                 <span class="comment">//</span>
04659                 <span class="comment">//  Move on to the next heap entry</span>
04660                 <span class="comment">//</span>
04661 
04662                 p += 1;
04663             }
04664 
04665             <span class="comment">//</span>
04666             <span class="comment">//  Zero out the last process heap pointer, update the count, and</span>
04667             <span class="comment">//  make the heap we just removed realize it has been removed by</span>
04668             <span class="comment">//  zeroing out its process heap list index</span>
04669             <span class="comment">//</span>
04670 
04671             Peb-&gt;ProcessHeaps[ --Peb-&gt;NumberOfHeaps ] = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04672             Heap-&gt;ProcessHeapsListIndex = 0;
04673         }
04674 
04675     } finally {
04676 
04677         <span class="comment">//</span>
04678         <span class="comment">//  Unlock the current processes heap list lock</span>
04679         <span class="comment">//</span>
04680 
04681         <a class="code" href="../../d9/d9/heappriv_8h.html#a4">RtlReleaseLockRoutine</a>( &amp;<a class="code" href="../../d5/d9/heapdll_8c.html#a3">RtlpProcessHeapsListLock</a>.<a class="code" href="../../d4/d6/struct__HEAP__LOCK.html#o2">Lock</a> );
04682     }
04683 
04684     <span class="keywordflow">return</span>;
04685 }
04686 
04687 
04688 <span class="comment">//</span>
04689 <span class="comment">//  Local Support routine</span>
04690 <span class="comment">//</span>
04691 
04692 BOOLEAN
<a name="l04693"></a><a class="code" href="../../d5/d9/heapdll_8c.html#a7">04693</a> <a class="code" href="../../d5/d9/heapdll_8c.html#a7">RtlpGrowBlockInPlace</a> (
04694     IN <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap,
04695     IN ULONG Flags,
04696     IN <a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a> BusyBlock,
04697     IN SIZE_T Size,
04698     IN SIZE_T AllocationIndex
04699     )
04700 
04701 <span class="comment">/*++</span>
04702 <span class="comment"></span>
04703 <span class="comment">Routine Description:</span>
04704 <span class="comment"></span>
04705 <span class="comment">    This routine will try and grow a heap allocation block at its current</span>
04706 <span class="comment">    location</span>
04707 <span class="comment"></span>
04708 <span class="comment">Arguments:</span>
04709 <span class="comment"></span>
04710 <span class="comment">    Heap - Supplies a pointer to the heap being modified</span>
04711 <span class="comment"></span>
04712 <span class="comment">    Flags - Supplies a set of flags to augment those already enforced by</span>
04713 <span class="comment">        the heap</span>
04714 <span class="comment"></span>
04715 <span class="comment">    BusyBlock - Supplies a pointer to the block being resized</span>
04716 <span class="comment"></span>
04717 <span class="comment">    Size - Supplies the size, in bytes, needed by the resized block</span>
04718 <span class="comment"></span>
04719 <span class="comment">    AllocationIndex - Supplies the allocation index for the resized block</span>
04720 <span class="comment">        Note that the size variable has not been rounded up to the next</span>
04721 <span class="comment">        granular block size, but that allocation index has.</span>
04722 <span class="comment"></span>
04723 <span class="comment">Return Value:</span>
04724 <span class="comment"></span>
04725 <span class="comment">    BOOLEAN - TRUE if the block has been resized and FALSE otherwise</span>
04726 <span class="comment"></span>
04727 <span class="comment">--*/</span>
04728 
04729 {
04730     SIZE_T FreeSize;
04731     SIZE_T OldSize;
04732     UCHAR EntryFlags, FreeFlags;
04733     <a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a> FreeBlock, SplitBlock, SplitBlock2;
04734     <a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html">PHEAP_ENTRY_EXTRA</a> OldExtraStuff, NewExtraStuff;
04735 
04736     <span class="comment">//</span>
04737     <span class="comment">//  Check if the allocation index is too large for even the nondedicated</span>
04738     <span class="comment">//  free list (i.e., too large for list [0])</span>
04739     <span class="comment">//</span>
04740 
04741     <span class="keywordflow">if</span> (AllocationIndex &gt; Heap-&gt;VirtualMemoryThreshold) {
04742 
04743         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04744     }
04745 
04746     <span class="comment">//</span>
04747     <span class="comment">//  Get the flags for the current block and a pointer to the next</span>
04748     <span class="comment">//  block following the current block</span>
04749     <span class="comment">//</span>
04750 
04751     EntryFlags = BusyBlock-&gt;Flags;
04752 
04753     FreeBlock = (<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)(BusyBlock + BusyBlock-&gt;Size);
04754 
04755     <span class="comment">//</span>
04756     <span class="comment">//  If the current block is the last entry before an uncommitted range</span>
04757     <span class="comment">//  we'll try and extend the uncommitted range to fit our new allocation</span>
04758     <span class="comment">//</span>
04759 
04760     <span class="keywordflow">if</span> (EntryFlags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>) {
04761 
04762         <span class="comment">//</span>
04763         <span class="comment">//  Calculate how must more we need beyond the current block</span>
04764         <span class="comment">//  size</span>
04765         <span class="comment">//</span>
04766 
04767         FreeSize = (AllocationIndex - BusyBlock-&gt;Size) &lt;&lt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>;
04768         FreeSize = <a class="code" href="../../d3/d9/heap_8h.html#a1">ROUND_UP_TO_POWER2</a>( FreeSize, <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> );
04769 
04770         <span class="comment">//</span>
04771         <span class="comment">//  Try and commit memory at the desired location</span>
04772         <span class="comment">//</span>
04773 
04774         FreeBlock = <a class="code" href="../../d9/d9/heappriv_8h.html#a37">RtlpFindAndCommitPages</a>( Heap,
04775                                             Heap-&gt;Segments[ BusyBlock-&gt;SegmentIndex ],
04776                                             &amp;FreeSize,
04777                                             (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)FreeBlock );
04778 
04779         <span class="comment">//</span>
04780         <span class="comment">//  Check if the commit succeeded</span>
04781         <span class="comment">//</span>
04782 
04783         <span class="keywordflow">if</span> (FreeBlock == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04784 
04785             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04786         }
04787 
04788         <span class="comment">//</span>
04789         <span class="comment">//  New coalesce this newly committed space with whatever is free</span>
04790         <span class="comment">//  around it</span>
04791         <span class="comment">//</span>
04792 
04793         FreeSize = FreeSize &gt;&gt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>;
04794 
04795         FreeBlock = <a class="code" href="../../d9/d9/heappriv_8h.html#a34">RtlpCoalesceFreeBlocks</a>( Heap, FreeBlock, &amp;FreeSize, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
04796 
04797         FreeFlags = FreeBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o3">Flags</a>;
04798 
04799         <span class="comment">//</span>
04800         <span class="comment">//  If the newly allocated space plus the current block size is still</span>
04801         <span class="comment">//  not big enough for our resize effort then put this newly</span>
04802         <span class="comment">//  allocated block into the appropriate free list and tell our caller</span>
04803         <span class="comment">//  that a resize wasn't possible</span>
04804         <span class="comment">//</span>
04805 
04806         <span class="keywordflow">if</span> ((FreeSize + BusyBlock-&gt;Size) &lt; AllocationIndex) {
04807 
04808             <a class="code" href="../../d9/d9/heappriv_8h.html#a36">RtlpInsertFreeBlock</a>( Heap, FreeBlock, FreeSize );
04809 
04810             Heap-&gt;TotalFreeSize += FreeSize;
04811 
04812             <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a8">DEBUG_HEAP</a>(Flags)) {
04813 
04814                 <a class="code" href="../../d9/d9/heappriv_8h.html#a50">RtlpValidateHeapHeaders</a>( Heap, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
04815             }
04816 
04817             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04818         }
04819 
04820         <span class="comment">//</span>
04821         <span class="comment">//  We were able to generate enough space for the resize effort, so</span>
04822         <span class="comment">//  now free size will be the index for the current block plus the</span>
04823         <span class="comment">//  new free space</span>
04824         <span class="comment">//</span>
04825 
04826         FreeSize += BusyBlock-&gt;Size;
04827 
04828     } <span class="keywordflow">else</span> {
04829 
04830         <span class="comment">//</span>
04831         <span class="comment">//  The following block is present so grab its flags and see if</span>
04832         <span class="comment">//  it is free or busy.  If busy then we cannot grow the current</span>
04833         <span class="comment">//  block</span>
04834         <span class="comment">//</span>
04835 
04836         FreeFlags = FreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a>;
04837 
04838         <span class="keywordflow">if</span> (FreeFlags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a8">HEAP_ENTRY_BUSY</a>) {
04839 
04840             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04841         }
04842 
04843         <span class="comment">//</span>
04844         <span class="comment">//  Compute the index if we combine current block with its following</span>
04845         <span class="comment">//  free block and check if it is big enough</span>
04846         <span class="comment">//</span>
04847 
04848         FreeSize = BusyBlock-&gt;Size + FreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a>;
04849 
04850         <span class="keywordflow">if</span> (FreeSize &lt; AllocationIndex) {
04851 
04852             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04853         }
04854 
04855         <span class="comment">//</span>
04856         <span class="comment">//  The two blocks together are big enough so now remove the free</span>
04857         <span class="comment">//  block from its free list, and update the heap's total free size</span>
04858         <span class="comment">//</span>
04859 
04860         <a class="code" href="../../d9/d9/heappriv_8h.html#a18">RtlpRemoveFreeBlock</a>( Heap, FreeBlock );
04861 
04862         Heap-&gt;TotalFreeSize -= FreeBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a>;
04863     }
04864 
04865     <span class="comment">//</span>
04866     <span class="comment">//  At this point we have a busy block followed by a free block that</span>
04867     <span class="comment">//  together have enough space for the resize.  The free block has been</span>
04868     <span class="comment">//  removed from its list and free size is the index of the two combined</span>
04869     <span class="comment">//  blocks.</span>
04870     <span class="comment">//</span>
04871     <span class="comment">//  Calculate the number of bytes in use in the old block</span>
04872     <span class="comment">//</span>
04873 
04874     OldSize = (BusyBlock-&gt;Size &lt;&lt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>) - BusyBlock-&gt;UnusedBytes;
04875 
04876     <span class="comment">//</span>
04877     <span class="comment">//  Calculate the index for whatever excess we'll have when we combine</span>
04878     <span class="comment">//  the two blocks</span>
04879     <span class="comment">//</span>
04880 
04881     FreeSize -= AllocationIndex;
04882 
04883     <span class="comment">//</span>
04884     <span class="comment">//  If the excess is not too much then put it back in our allocation</span>
04885     <span class="comment">//  (i.e., we don't want small free pieces left over)</span>
04886     <span class="comment">//</span>
04887 
04888     <span class="keywordflow">if</span> (FreeSize &lt;= 2) {
04889 
04890         AllocationIndex += FreeSize;
04891 
04892         FreeSize = 0;
04893     }
04894 
04895     <span class="comment">//</span>
04896     <span class="comment">//  If the busy block has an extra stuff struct present then copy over the</span>
04897     <span class="comment">//  extra stuff</span>
04898     <span class="comment">//</span>
04899 
04900     <span class="keywordflow">if</span> (EntryFlags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a9">HEAP_ENTRY_EXTRA_PRESENT</a>) {
04901 
04902         OldExtraStuff = (<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html">PHEAP_ENTRY_EXTRA</a>)(BusyBlock + BusyBlock-&gt;Size - 1);
04903         NewExtraStuff = (<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html">PHEAP_ENTRY_EXTRA</a>)(BusyBlock + AllocationIndex - 1);
04904 
04905         *NewExtraStuff = *OldExtraStuff;
04906 
04907         <span class="comment">//</span>
04908         <span class="comment">//  If heap tagging is enabled then update the heap tag from the extra</span>
04909         <span class="comment">//  stuff struct</span>
04910         <span class="comment">//</span>
04911 
04912         <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a22">IS_HEAP_TAGGING_ENABLED</a>()) {
04913 
04914             NewExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o1">TagIndex</a> =
04915                 <a class="code" href="../../d9/d9/heappriv_8h.html#a52">RtlpUpdateTagEntry</a>( Heap,
04916                                     NewExtraStuff-&gt;<a class="code" href="../../d8/d5/struct__HEAP__ENTRY__EXTRA.html#o1">TagIndex</a>,
04917                                     BusyBlock-&gt;Size,
04918                                     AllocationIndex,
04919                                     <a class="code" href="../../d9/d9/heappriv_8h.html#a60a31">ReAllocationAction</a> );
04920         }
04921 
04922     <span class="comment">//</span>
04923     <span class="comment">//  Otherwise extra stuff is not in use so see if heap tagging is enabled</span>
04924     <span class="comment">//  and if so then update small tag index</span>
04925     <span class="comment">//</span>
04926 
04927     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/heappriv_8h.html#a22">IS_HEAP_TAGGING_ENABLED</a>()) {
04928 
04929         BusyBlock-&gt;SmallTagIndex = (UCHAR)
04930             <a class="code" href="../../d9/d9/heappriv_8h.html#a52">RtlpUpdateTagEntry</a>( Heap,
04931                                 BusyBlock-&gt;SmallTagIndex,
04932                                 BusyBlock-&gt;Size,
04933                                 AllocationIndex,
04934                                 <a class="code" href="../../d9/d9/heappriv_8h.html#a60a31">ReAllocationAction</a> );
04935     }
04936 
04937     <span class="comment">//</span>
04938     <span class="comment">//  Check if we will have any free space to give back.</span>
04939     <span class="comment">//</span>
04940 
04941     <span class="keywordflow">if</span> (FreeSize == 0) {
04942 
04943         <span class="comment">//</span>
04944         <span class="comment">//  No following free space so update the flags, size and byte counts</span>
04945         <span class="comment">//  for the resized block.  If the free block was a last entry</span>
04946         <span class="comment">//  then the busy block must also now be a last entry.</span>
04947         <span class="comment">//</span>
04948 
04949         BusyBlock-&gt;Flags |= FreeFlags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>;
04950 
04951         BusyBlock-&gt;Size = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)AllocationIndex;
04952 
04953         BusyBlock-&gt;UnusedBytes = (UCHAR)
04954             ((AllocationIndex &lt;&lt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>) - <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>);
04955 
04956         <span class="comment">//</span>
04957         <span class="comment">//  Update the previous size field of the following block if it exists</span>
04958         <span class="comment">//</span>
04959 
04960         <span class="keywordflow">if</span> (!(FreeFlags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>)) {
04961 
04962             (BusyBlock + BusyBlock-&gt;Size)-&gt;PreviousSize = BusyBlock-&gt;Size;
04963 
04964         } <span class="keywordflow">else</span> {
04965 
04966             <a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a> Segment;
04967 
04968             Segment = Heap-&gt;Segments[BusyBlock-&gt;SegmentIndex];
04969             Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o14">LastEntryInSegment</a> = BusyBlock;
04970         }
04971 
04972     <span class="comment">//</span>
04973     <span class="comment">//  Otherwise there is some free space to return to the heap</span>
04974     <span class="comment">//</span>
04975 
04976     } <span class="keywordflow">else</span> {
04977 
04978         <span class="comment">//</span>
04979         <span class="comment">//  Update the size and byte counts for the resized block.</span>
04980         <span class="comment">//</span>
04981 
04982         BusyBlock-&gt;<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html#o0">Size</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)AllocationIndex;
04983 
04984         BusyBlock-&gt;UnusedBytes = (UCHAR)
04985             ((AllocationIndex &lt;&lt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a>) - <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>);
04986 
04987         <span class="comment">//</span>
04988         <span class="comment">//  Determine where the new free block starts and fill in its fields</span>
04989         <span class="comment">//</span>
04990 
04991         SplitBlock = (<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)((<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)BusyBlock + AllocationIndex);
04992 
04993         SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o1">PreviousSize</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)AllocationIndex;
04994 
04995         SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o2">SegmentIndex</a> = BusyBlock-&gt;SegmentIndex;
04996 
04997         <span class="comment">//</span>
04998         <span class="comment">//  If this new free block will be the last entry then update its</span>
04999         <span class="comment">//  flags and size and put it into the appropriate free list</span>
05000         <span class="comment">//</span>
05001 
05002         <span class="keywordflow">if</span> (FreeFlags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>) {
05003 
05004             <a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a> Segment;
05005 
05006             Segment = Heap-&gt;Segments[SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o2">SegmentIndex</a>];
05007             Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o14">LastEntryInSegment</a> = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)SplitBlock;
05008 
05009             SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a> = FreeFlags;
05010             SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)FreeSize;
05011 
05012             <a class="code" href="../../d9/d9/heappriv_8h.html#a14">RtlpInsertFreeBlockDirect</a>( Heap, SplitBlock, (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)FreeSize );
05013 
05014             Heap-&gt;TotalFreeSize += FreeSize;
05015 
05016         <span class="comment">//</span>
05017         <span class="comment">//  The free block is followed by another valid block</span>
05018         <span class="comment">//</span>
05019 
05020         } <span class="keywordflow">else</span> {
05021 
05022             <span class="comment">//</span>
05023             <span class="comment">//  Point to the block following our new free block</span>
05024             <span class="comment">//</span>
05025 
05026             SplitBlock2 = (<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html">PHEAP_FREE_ENTRY</a>)((<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)SplitBlock + FreeSize);
05027 
05028             <span class="comment">//</span>
05029             <span class="comment">//  If the block following the new free block is busy then</span>
05030             <span class="comment">//  update the flags and size for the new free block, update</span>
05031             <span class="comment">//  the following blocks previous size, and put the free block</span>
05032             <span class="comment">//  into the appropriate free list</span>
05033             <span class="comment">//</span>
05034 
05035             <span class="keywordflow">if</span> (SplitBlock2-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a8">HEAP_ENTRY_BUSY</a>) {
05036 
05037                 SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a> = FreeFlags &amp; (~<a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>);
05038                 SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)FreeSize;
05039 
05040                 <span class="comment">//</span>
05041                 <span class="comment">//  **** note that this test must be true because we are</span>
05042                 <span class="comment">//  **** already in the else clause of the</span>
05043                 <span class="comment">//  **** if (FreeFlags &amp; HEAP_ENTRY_LAST_ENTRY) statement</span>
05044                 <span class="comment">//</span>
05045 
05046                 <span class="keywordflow">if</span> (!(FreeFlags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>)) {
05047 
05048                     ((<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)SplitBlock + FreeSize)-&gt;PreviousSize = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)FreeSize;
05049 
05050                 } <span class="keywordflow">else</span> {
05051 
05052                     <a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a> Segment;
05053 
05054                     Segment = Heap-&gt;Segments[SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o2">SegmentIndex</a>];
05055                     Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o14">LastEntryInSegment</a> = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)SplitBlock;
05056                 }
05057 
05058                 <a class="code" href="../../d9/d9/heappriv_8h.html#a14">RtlpInsertFreeBlockDirect</a>( Heap, SplitBlock, (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)FreeSize );
05059 
05060                 Heap-&gt;TotalFreeSize += FreeSize;
05061 
05062             <span class="comment">//</span>
05063             <span class="comment">//  Otherwise the following block is also free so we can combine</span>
05064             <span class="comment">//  these two blocks</span>
05065             <span class="comment">//</span>
05066 
05067             } <span class="keywordflow">else</span> {
05068 
05069                 <span class="comment">//</span>
05070                 <span class="comment">//  Remember the new free flags from the following block</span>
05071                 <span class="comment">//</span>
05072 
05073                 FreeFlags = SplitBlock2-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a>;
05074 
05075                 <span class="comment">//</span>
05076                 <span class="comment">//  Remove the following block from its free list</span>
05077                 <span class="comment">//</span>
05078 
05079                 <a class="code" href="../../d9/d9/heappriv_8h.html#a18">RtlpRemoveFreeBlock</a>( Heap, SplitBlock2 );
05080 
05081                 Heap-&gt;TotalFreeSize -= SplitBlock2-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a>;
05082 
05083                 <span class="comment">//</span>
05084                 <span class="comment">//  Calculate the size of the new combined free block</span>
05085                 <span class="comment">//</span>
05086 
05087                 FreeSize += SplitBlock2-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a>;
05088 
05089                 <span class="comment">//</span>
05090                 <span class="comment">//  Give the new the its new flags</span>
05091                 <span class="comment">//</span>
05092 
05093                 SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o3">Flags</a> = FreeFlags;
05094 
05095                 <span class="comment">//</span>
05096                 <span class="comment">//  If the combited block is not too large for the dedicated</span>
05097                 <span class="comment">//  free lists then that where we'll put it</span>
05098                 <span class="comment">//</span>
05099 
05100                 <span class="keywordflow">if</span> (FreeSize &lt;= <a class="code" href="../../d3/d9/heap_8h.html#a5">HEAP_MAXIMUM_BLOCK_SIZE</a>) {
05101 
05102                     SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o0">Size</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)FreeSize;
05103 
05104                     <span class="comment">//</span>
05105                     <span class="comment">//  If present update the previous size for the following block</span>
05106                     <span class="comment">//</span>
05107 
05108                     <span class="keywordflow">if</span> (!(FreeFlags &amp; <a class="code" href="../../d3/d9/heap_8h.html#a12">HEAP_ENTRY_LAST_ENTRY</a>)) {
05109 
05110                         ((<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)SplitBlock + FreeSize)-&gt;PreviousSize = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)FreeSize;
05111 
05112                     } <span class="keywordflow">else</span> {
05113 
05114                         <a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html">PHEAP_SEGMENT</a> Segment;
05115 
05116                         Segment = Heap-&gt;Segments[SplitBlock-&gt;<a class="code" href="../../d1/d6/struct__HEAP__FREE__ENTRY.html#o2">SegmentIndex</a>];
05117                         Segment-&gt;<a class="code" href="../../d8/d6/struct__HEAP__SEGMENT.html#o14">LastEntryInSegment</a> = (<a class="code" href="../../d7/d5/struct__HEAP__ENTRY.html">PHEAP_ENTRY</a>)SplitBlock;
05118                     }
05119 
05120                     <span class="comment">//</span>
05121                     <span class="comment">//  Insert the new combined free block into the free list</span>
05122                     <span class="comment">//</span>
05123 
05124                     <a class="code" href="../../d9/d9/heappriv_8h.html#a14">RtlpInsertFreeBlockDirect</a>( Heap, SplitBlock, (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)FreeSize );
05125 
05126                     Heap-&gt;TotalFreeSize += FreeSize;
05127 
05128                 } <span class="keywordflow">else</span> {
05129 
05130                     <span class="comment">//</span>
05131                     <span class="comment">//  Otherwise the new free block is too large to go into</span>
05132                     <span class="comment">//  a dedicated free list so put it in the general free list</span>
05133                     <span class="comment">//  which might involve breaking it apart.</span>
05134                     <span class="comment">//</span>
05135 
05136                     <a class="code" href="../../d9/d9/heappriv_8h.html#a36">RtlpInsertFreeBlock</a>( Heap, SplitBlock, FreeSize );
05137                 }
05138             }
05139         }
05140     }
05141 
05142     <span class="comment">//</span>
05143     <span class="comment">//  At this point the block has been resized and any extra space has been</span>
05144     <span class="comment">//  returned to the free list</span>
05145     <span class="comment">//</span>
05146     <span class="comment">//  Check if we should zero out the new space</span>
05147     <span class="comment">//</span>
05148 
05149     <span class="keywordflow">if</span> (Flags &amp; HEAP_ZERO_MEMORY) {
05150 
05151         <span class="comment">//</span>
05152         <span class="comment">//  **** this test is sort of bogus because we're resizing and the new</span>
05153         <span class="comment">//  **** size by definition must be larger than the old size</span>
05154         <span class="comment">//</span>
05155 
05156         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> &gt; OldSize) {
05157 
05158             RtlZeroMemory( (PCHAR)(BusyBlock + 1) + OldSize,
05159                            <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> - OldSize );
05160         }
05161 
05162     <span class="comment">//</span>
05163     <span class="comment">//  Check if we should be filling in heap after it as</span>
05164     <span class="comment">//  been freed, and if so then fill in the newly allocated</span>
05165     <span class="comment">//  space beyond the old bytes.</span>
05166     <span class="comment">//</span>
05167 
05168     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Heap-&gt;Flags &amp; HEAP_FREE_CHECKING_ENABLED) {
05169 
05170         SIZE_T PartialBytes, ExtraSize;
05171 
05172         PartialBytes = OldSize &amp; (<span class="keyword">sizeof</span>( ULONG ) - 1);
05173 
05174         <span class="keywordflow">if</span> (PartialBytes) {
05175 
05176             PartialBytes = 4 - PartialBytes;
05177         }
05178 
05179         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> &gt; (OldSize + PartialBytes)) {
05180 
05181             ExtraSize = (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> - (OldSize + PartialBytes)) &amp; ~(<span class="keyword">sizeof</span>( ULONG ) - 1);
05182 
05183             <span class="keywordflow">if</span> (ExtraSize != 0) {
05184 
05185                 RtlFillMemoryUlong( (PCHAR)(BusyBlock + 1) + OldSize + PartialBytes,
05186                                     ExtraSize,
05187                                     <a class="code" href="../../d3/d9/heap_8h.html#a28">ALLOC_HEAP_FILL</a> );
05188             }
05189         }
05190     }
05191 
05192     <span class="comment">//</span>
05193     <span class="comment">//  If we are going tailing checking then fill in the space right beyond</span>
05194     <span class="comment">//  the new allocation</span>
05195     <span class="comment">//</span>
05196 
05197     <span class="keywordflow">if</span> (Heap-&gt;Flags &amp; HEAP_TAIL_CHECKING_ENABLED) {
05198 
05199         RtlFillMemory( (PCHAR)(BusyBlock + 1) + <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>,
05200                        <a class="code" href="../../d3/d9/heap_8h.html#a25">CHECK_HEAP_TAIL_SIZE</a>,
05201                        <a class="code" href="../../d3/d9/heap_8h.html#a26">CHECK_HEAP_TAIL_FILL</a> );
05202     }
05203 
05204     <span class="comment">//</span>
05205     <span class="comment">//  Give the resized block any user settable flags send in by the</span>
05206     <span class="comment">//  caller</span>
05207     <span class="comment">//</span>
05208 
05209     BusyBlock-&gt;Flags &amp;= ~<a class="code" href="../../d3/d9/heap_8h.html#a16">HEAP_ENTRY_SETTABLE_FLAGS</a>;
05210     BusyBlock-&gt;Flags |= ((Flags &amp; HEAP_SETTABLE_USER_FLAGS) &gt;&gt; 4);
05211 
05212     <span class="comment">//</span>
05213     <span class="comment">//  And return to our caller</span>
05214     <span class="comment">//</span>
05215 
05216     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
05217 }
05218 
05219 
05220 <span class="comment">//</span>
05221 <span class="comment">//  Local support routine</span>
05222 <span class="comment">//</span>
05223 
05224 <a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html">PHEAP_TAG_ENTRY</a>
<a name="l05225"></a><a class="code" href="../../d5/d9/heapdll_8c.html#a17">05225</a> <a class="code" href="../../d5/d9/heapdll_8c.html#a17">RtlpAllocateTags</a> (
05226     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap,
05227     ULONG NumberOfTags
05228     )
05229 
05230 <span class="comment">/*++</span>
05231 <span class="comment"></span>
05232 <span class="comment">Routine Description:</span>
05233 <span class="comment"></span>
05234 <span class="comment">    This routine is used to allocate space for additional tags within</span>
05235 <span class="comment">    a heap</span>
05236 <span class="comment"></span>
05237 <span class="comment">Arguments:</span>
05238 <span class="comment"></span>
05239 <span class="comment">    Heap - Supplies a pointer to the heap being modified.  If not specified</span>
05240 <span class="comment">        then the processes global tag heap is used</span>
05241 <span class="comment"></span>
05242 <span class="comment">    NumberOfTags - Supplies the number of tags that we want stored in the</span>
05243 <span class="comment">        heap.  This is the number to grow the tag list by.</span>
05244 <span class="comment"></span>
05245 <span class="comment">Return Value:</span>
05246 <span class="comment"></span>
05247 <span class="comment">    PHEAP_TAG_ENTRY - Returns a pointer to the next available tag entry in the</span>
05248 <span class="comment">        heap</span>
05249 <span class="comment"></span>
05250 <span class="comment">--*/</span>
05251 
05252 {
05253     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
05254     ULONG TagIndex;
05255     SIZE_T ReserveSize;
05256     SIZE_T CommitSize;
05257     <a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html">PHEAP_TAG_ENTRY</a> TagEntry;
05258     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> CreatorBackTraceIndex;
05259     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> MaximumTagIndex;
05260     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> TagIndexFlag;
05261 
05262     <span class="comment">//</span>
05263     <span class="comment">//  Check if the process has a global tag heap.  If not then there is</span>
05264     <span class="comment">//  nothing for us to do</span>
05265     <span class="comment">//</span>
05266 
05267     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d9/heap_8h.html#a64">RtlpGlobalTagHeap</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05268 
05269         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05270     }
05271 
05272     <span class="comment">//</span>
05273     <span class="comment">//  If the user didn't give us a heap then use the processes global</span>
05274     <span class="comment">//  tag heap</span>
05275     <span class="comment">//</span>
05276 
05277     <span class="keywordflow">if</span> (Heap == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05278 
05279         <a class="code" href="../../d3/d9/heap_8h.html#a64">RtlpGlobalTagHeap</a>-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o1">Signature</a> = <a class="code" href="../../d3/d9/heap_8h.html#a19">HEAP_SIGNATURE</a>;
05280 
05281         <a class="code" href="../../d3/d9/heap_8h.html#a64">RtlpGlobalTagHeap</a>-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o2">Flags</a> = HEAP_NO_SERIALIZE;
05282 
05283         TagIndexFlag = HEAP_GLOBAL_TAG;
05284 
05285         Heap = <a class="code" href="../../d3/d9/heap_8h.html#a64">RtlpGlobalTagHeap</a>;
05286 
05287     } <span class="keywordflow">else</span> {
05288 
05289         TagIndexFlag = 0;
05290     }
05291 
05292     <span class="comment">//</span>
05293     <span class="comment">//  Grab the stack backtrace if possible and if we should</span>
05294     <span class="comment">//</span>
05295 
05296     CreatorBackTraceIndex = 0;
05297 
05298 <span class="preprocessor">#if i386</span>
05299 <span class="preprocessor"></span>
05300     <span class="keywordflow">if</span> (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o2">Flags</a> &amp; <a class="code" href="../../d3/d9/heap_8h.html#a24">HEAP_CAPTURE_STACK_BACKTRACES</a>) {
05301 
05302         CreatorBackTraceIndex = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)RtlLogStackBackTrace();
05303     }
05304 
05305 <span class="preprocessor">#endif // i386</span>
05306 <span class="preprocessor"></span>
05307     <span class="comment">//</span>
05308     <span class="comment">//  If the heap does not already have tag entries then we'll</span>
05309     <span class="comment">//  reserve space for them</span>
05310     <span class="comment">//</span>
05311 
05312     <span class="keywordflow">if</span> (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05313 
05314         MaximumTagIndex = HEAP_MAXIMUM_TAG &amp; ~HEAP_GLOBAL_TAG;
05315 
05316         ReserveSize = MaximumTagIndex * <span class="keyword">sizeof</span>( <a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html">HEAP_TAG_ENTRY</a> );
05317 
05318         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d6/allocvm_8c.html#a7">NtAllocateVirtualMemory</a>( NtCurrentProcess(),
05319                                           &amp;Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a>,
05320                                           0,
05321                                           &amp;ReserveSize,
05322                                           MEM_RESERVE,
05323                                           PAGE_READWRITE );
05324 
05325         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
05326 
05327             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05328         }
05329 
05330         Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o15">MaximumTagIndex</a> = MaximumTagIndex;
05331 
05332         Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o14">NextAvailableTagIndex</a> = 0;
05333 
05334         <span class="comment">//</span>
05335         <span class="comment">// Add one for zero tag, as that is always reserved for heap name</span>
05336         <span class="comment">//</span>
05337 
05338         NumberOfTags += 1;
05339     }
05340 
05341     <span class="comment">//</span>
05342     <span class="comment">//  At this point we have a space reserved for tag entries.  If the number</span>
05343     <span class="comment">//  of tags that we need to grow is too large then tell the user we can't</span>
05344     <span class="comment">//  do it.</span>
05345     <span class="comment">//</span>
05346 
05347     <span class="keywordflow">if</span> (NumberOfTags &gt; (ULONG)(Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o15">MaximumTagIndex</a> - Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o14">NextAvailableTagIndex</a>)) {
05348 
05349         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05350     }
05351 
05352     <span class="comment">//</span>
05353     <span class="comment">//  Get a pointer to the next available tag entry, and for</span>
05354     <span class="comment">//  every tag entry that we want to grow by we'll commit</span>
05355     <span class="comment">//  the page containing the tag entry.  We only need to do</span>
05356     <span class="comment">//  this for every page just once.  We'll determine this</span>
05357     <span class="comment">//  by seeing when the tag entry crosses a page boundary</span>
05358     <span class="comment">//</span>
05359 
05360     TagEntry = Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a> + Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o14">NextAvailableTagIndex</a>;
05361 
05362     <span class="keywordflow">for</span> (TagIndex = Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o14">NextAvailableTagIndex</a>;
05363          TagIndex &lt; Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o14">NextAvailableTagIndex</a> + NumberOfTags;
05364          TagIndex++ ) {
05365 
05366         <span class="keywordflow">if</span> (((((ULONG_PTR)TagEntry + <span class="keyword">sizeof</span>(*TagEntry)) &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>-1)) &lt;=
05367             <span class="keyword">sizeof</span>(*TagEntry))) {
05368 
05369             CommitSize = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
05370 
05371             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d6/allocvm_8c.html#a7">NtAllocateVirtualMemory</a>( NtCurrentProcess(),
05372                                               &amp;TagEntry,
05373                                               0,
05374                                               &amp;CommitSize,
05375                                               MEM_COMMIT,
05376                                               PAGE_READWRITE );
05377 
05378             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
05379 
05380                 <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05381             }
05382         }
05383 
05384         <span class="comment">//</span>
05385         <span class="comment">//  Bias the tag index if this is the global tag heap</span>
05386         <span class="comment">//</span>
05387 
05388         TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o3">TagIndex</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)TagIndex | TagIndexFlag;
05389 
05390         <span class="comment">//</span>
05391         <span class="comment">//  Set the stack back trace</span>
05392         <span class="comment">//</span>
05393 
05394         TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o4">CreatorBackTraceIndex</a> = CreatorBackTraceIndex;
05395 
05396         <span class="comment">//</span>
05397         <span class="comment">//  Move on to the next tag entry</span>
05398         <span class="comment">//</span>
05399 
05400         TagEntry += 1;
05401     }
05402 
05403     <span class="comment">//</span>
05404     <span class="comment">//  At this point we've build the new tag list so now pop off the next</span>
05405     <span class="comment">//  available tag entry</span>
05406     <span class="comment">//</span>
05407 
05408     TagEntry = Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a> + Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o14">NextAvailableTagIndex</a>;
05409 
05410     Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o14">NextAvailableTagIndex</a> += (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)NumberOfTags;
05411 
05412     <span class="comment">//</span>
05413     <span class="comment">//  And return to our caller</span>
05414     <span class="comment">//</span>
05415 
05416     <span class="keywordflow">return</span> TagEntry;
05417 }
05418 
05419 
05420 <span class="comment">//</span>
05421 <span class="comment">//  Declared in heappriv.h</span>
05422 <span class="comment">//</span>
05423 
05424 PWSTR
<a name="l05425"></a><a class="code" href="../../d9/d9/heappriv_8h.html#a51">05425</a> <a class="code" href="../../d9/d9/heappriv_8h.html#a51">RtlpGetTagName</a> (
05426     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap,
05427     USHORT TagIndex
05428     )
05429 
05430 <span class="comment">/*++</span>
05431 <span class="comment"></span>
05432 <span class="comment">Routine Description:</span>
05433 <span class="comment"></span>
05434 <span class="comment">    This routine returns the name of the tag denoted by the heap, tagindex</span>
05435 <span class="comment">    tuple.</span>
05436 <span class="comment"></span>
05437 <span class="comment">    This routine is only called by heapdbg when doing a debug print to</span>
05438 <span class="comment">    generate a tag name for printing</span>
05439 <span class="comment"></span>
05440 <span class="comment">Arguments:</span>
05441 <span class="comment"></span>
05442 <span class="comment">    Heap - Supplies the tag being queried</span>
05443 <span class="comment"></span>
05444 <span class="comment">    TagIndex - Supplies the index for the tag being queried</span>
05445 <span class="comment"></span>
05446 <span class="comment">Return Value:</span>
05447 <span class="comment"></span>
05448 <span class="comment">    PWSTR - returns the name of the indicated tag</span>
05449 <span class="comment"></span>
05450 <span class="comment">--*/</span>
05451 
05452 {
05453     <span class="comment">//</span>
05454     <span class="comment">//  If the processes global tag heap has not been initialized then</span>
05455     <span class="comment">//  not tag has a name</span>
05456     <span class="comment">//</span>
05457 
05458     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d9/heap_8h.html#a64">RtlpGlobalTagHeap</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05459 
05460         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05461     }
05462 
05463     <span class="comment">//</span>
05464     <span class="comment">//  We only deal with non zero tag indices</span>
05465     <span class="comment">//</span>
05466 
05467     <span class="keywordflow">if</span> (TagIndex != 0) {
05468 
05469         <span class="comment">//</span>
05470         <span class="comment">//  If the tag index is for a pseudo tag then we clear the</span>
05471         <span class="comment">//  the psuedo bit and generate a pseudo tag name</span>
05472         <span class="comment">//</span>
05473 
05474         <span class="keywordflow">if</span> (TagIndex &amp; HEAP_PSEUDO_TAG_FLAG) {
05475 
05476             TagIndex &amp;= ~HEAP_PSEUDO_TAG_FLAG;
05477 
05478             <span class="comment">//</span>
05479             <span class="comment">//  Check that the tag index is valid and that the heap</span>
05480             <span class="comment">//  has some psuedo tag entries</span>
05481             <span class="comment">//</span>
05482 
05483             <span class="keywordflow">if</span> ((TagIndex &lt; <a class="code" href="../../d3/d9/heap_8h.html#a32">HEAP_NUMBER_OF_PSEUDO_TAG</a>) &amp;&amp;
05484                 (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o29">PseudoTagEntries</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
05485 
05486                 <span class="comment">//</span>
05487                 <span class="comment">//  A pseudo tag index of zero denote objects</span>
05488                 <span class="comment">//</span>
05489 
05490                 <span class="keywordflow">if</span> (TagIndex == 0) {
05491 
05492                     swprintf( <a class="code" href="../../d5/d9/heapdll_8c.html#a6">RtlpPseudoTagNameBuffer</a>, <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"Objects&gt;%4u"</span>,
05493                               <a class="code" href="../../d3/d9/heap_8h.html#a6">HEAP_MAXIMUM_FREELISTS</a> &lt;&lt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a> );
05494 
05495                 <span class="comment">//</span>
05496                 <span class="comment">//  A psuedo tag index less than the free list maximum</span>
05497                 <span class="comment">//  denotes the dedicated free list</span>
05498                 <span class="comment">//</span>
05499 
05500                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (TagIndex &lt; <a class="code" href="../../d3/d9/heap_8h.html#a6">HEAP_MAXIMUM_FREELISTS</a>) {
05501 
05502                     swprintf( <a class="code" href="../../d5/d9/heapdll_8c.html#a6">RtlpPseudoTagNameBuffer</a>, <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"Objects=%4u"</span>, TagIndex &lt;&lt; <a class="code" href="../../d3/d9/heap_8h.html#a4">HEAP_GRANULARITY_SHIFT</a> );
05503 
05504                 <span class="comment">//</span>
05505                 <span class="comment">//  Otherwise the pseudo tag is for the big allocations</span>
05506                 <span class="comment">//</span>
05507 
05508                 } <span class="keywordflow">else</span> {
05509 
05510                     swprintf( <a class="code" href="../../d5/d9/heapdll_8c.html#a6">RtlpPseudoTagNameBuffer</a>, <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"VirtualAlloc"</span> );
05511                 }
05512 
05513                 <span class="keywordflow">return</span> <a class="code" href="../../d5/d9/heapdll_8c.html#a6">RtlpPseudoTagNameBuffer</a>;
05514             }
05515 
05516         <span class="comment">//</span>
05517         <span class="comment">//  Otherwise if the tag index is for a global tag then we pull</span>
05518         <span class="comment">//  the name off of the global heap.  Provided the index is valid</span>
05519         <span class="comment">//  and the heap does have some tag entries</span>
05520         <span class="comment">//</span>
05521 
05522         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (TagIndex &amp; HEAP_GLOBAL_TAG) {
05523 
05524             TagIndex &amp;= ~HEAP_GLOBAL_TAG;
05525 
05526             <span class="keywordflow">if</span> ((TagIndex &lt; <a class="code" href="../../d3/d9/heap_8h.html#a64">RtlpGlobalTagHeap</a>-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o14">NextAvailableTagIndex</a>) &amp;&amp;
05527                 (<a class="code" href="../../d3/d9/heap_8h.html#a64">RtlpGlobalTagHeap</a>-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
05528 
05529                 <span class="keywordflow">return</span> <a class="code" href="../../d3/d9/heap_8h.html#a64">RtlpGlobalTagHeap</a>-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a>[ TagIndex ].<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o5">TagName</a>;
05530             }
05531 
05532         <span class="comment">//</span>
05533         <span class="comment">//  Otherwise we'll pull the name off of the input heap</span>
05534         <span class="comment">//  provided the index is valid and the heap does have some</span>
05535         <span class="comment">//  tag entries</span>
05536         <span class="comment">//</span>
05537 
05538         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((TagIndex &lt; Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o14">NextAvailableTagIndex</a>) &amp;&amp;
05539                    (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
05540 
05541             <span class="keywordflow">return</span> Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a>[ TagIndex ].<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o5">TagName</a>;
05542         }
05543     }
05544 
05545     <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05546 }
05547 
05548 
05549 <span class="comment">//</span>
05550 <span class="comment">//  Declared in heappriv.h</span>
05551 <span class="comment">//</span>
05552 
05553 <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>
<a name="l05554"></a><a class="code" href="../../d9/d9/heappriv_8h.html#a52">05554</a> <a class="code" href="../../d9/d9/heappriv_8h.html#a52">RtlpUpdateTagEntry</a> (
05555     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap,
05556     USHORT TagIndex,
05557     SIZE_T OldSize,              <span class="comment">// Only valid for ReAllocation and Free actions</span>
05558     SIZE_T NewSize,              <span class="comment">// Only valid for ReAllocation and Allocation actions</span>
05559     <a class="code" href="../../d9/d9/heappriv_8h.html#a24">HEAP_TAG_ACTION</a> Action
05560     )
05561 
05562 <span class="comment">/*++</span>
05563 <span class="comment"></span>
05564 <span class="comment">Routine Description:</span>
05565 <span class="comment"></span>
05566 <span class="comment">    This routine is used to modify a tag entry</span>
05567 <span class="comment"></span>
05568 <span class="comment">Arguments:</span>
05569 <span class="comment"></span>
05570 <span class="comment">    Heap - Supplies a pointer to the heap being modified</span>
05571 <span class="comment"></span>
05572 <span class="comment">    TagIndex - Supplies the tag being modified</span>
05573 <span class="comment"></span>
05574 <span class="comment">    OldSize - Supplies the old allocation index of the block associated with the tag</span>
05575 <span class="comment"></span>
05576 <span class="comment">    NewSize - Supplies the new allocation index of the block associated with the tag</span>
05577 <span class="comment"></span>
05578 <span class="comment">    Action - Supplies the type of action being performed on the heap tag</span>
05579 <span class="comment"></span>
05580 <span class="comment">Return Value:</span>
05581 <span class="comment"></span>
05582 <span class="comment">    USHORT - Returns a tag index for the newly updated tag</span>
05583 <span class="comment"></span>
05584 <span class="comment">--*/</span>
05585 
05586 {
05587     <a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html">PHEAP_TAG_ENTRY</a> TagEntry;
05588 
05589     <span class="comment">//</span>
05590     <span class="comment">//  If the processes tag heap does not exist then we'll return a zero index</span>
05591     <span class="comment">//  right away</span>
05592     <span class="comment">//</span>
05593 
05594     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d9/heap_8h.html#a64">RtlpGlobalTagHeap</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05595 
05596         <span class="keywordflow">return</span> 0;
05597     }
05598 
05599     <span class="comment">//</span>
05600     <span class="comment">//  If the action is greater than or equal to free action then it is</span>
05601     <span class="comment">//  either FreeAction, VirtualFreeAction, ReAllocationAction, or</span>
05602     <span class="comment">//  VirtualReAllocationAction.  Which means we already should have a tag</span>
05603     <span class="comment">//  that is simply being modified</span>
05604     <span class="comment">//</span>
05605 
05606     <span class="keywordflow">if</span> (<a class="code" href="../../d7/d0/cmdat2_8c.html#a18">Action</a> &gt;= <a class="code" href="../../d9/d9/heappriv_8h.html#a60a29">FreeAction</a>) {
05607 
05608         <span class="comment">//</span>
05609         <span class="comment">//  If the tag index is zero then there is nothing for us to do</span>
05610         <span class="comment">//</span>
05611 
05612         <span class="keywordflow">if</span> (TagIndex == 0) {
05613 
05614             <span class="keywordflow">return</span> 0;
05615         }
05616 
05617         <span class="comment">//</span>
05618         <span class="comment">//  If this is a pseudo tag then make sure the rest of the tag index</span>
05619         <span class="comment">//  after we remove the psuedo bit is valid and that the heap is</span>
05620         <span class="comment">//  actually maintaining pseudo tags</span>
05621         <span class="comment">//</span>
05622 
05623         <span class="keywordflow">if</span> (TagIndex &amp; HEAP_PSEUDO_TAG_FLAG) {
05624 
05625             TagIndex &amp;= ~HEAP_PSEUDO_TAG_FLAG;
05626 
05627             <span class="keywordflow">if</span> ((TagIndex &lt; <a class="code" href="../../d3/d9/heap_8h.html#a32">HEAP_NUMBER_OF_PSEUDO_TAG</a>) &amp;&amp;
05628                 (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o29">PseudoTagEntries</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
05629 
05630                 TagEntry = (<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html">PHEAP_TAG_ENTRY</a>)(Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o29">PseudoTagEntries</a> + TagIndex);
05631 
05632                 TagIndex |= HEAP_PSEUDO_TAG_FLAG;
05633 
05634             } <span class="keywordflow">else</span> {
05635 
05636                 <span class="keywordflow">return</span> 0;
05637             }
05638 
05639         <span class="comment">//</span>
05640         <span class="comment">//  Otherwise if this is a global tag then make sure the tag index</span>
05641         <span class="comment">//  after we remove the global bit is valid and that the global tag</span>
05642         <span class="comment">//  heap has some tag entries</span>
05643         <span class="comment">//</span>
05644 
05645         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (TagIndex &amp; HEAP_GLOBAL_TAG) {
05646 
05647             TagIndex &amp;= ~HEAP_GLOBAL_TAG;
05648 
05649             <span class="keywordflow">if</span> ((TagIndex &lt; <a class="code" href="../../d3/d9/heap_8h.html#a64">RtlpGlobalTagHeap</a>-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o14">NextAvailableTagIndex</a>) &amp;&amp;
05650                 (<a class="code" href="../../d3/d9/heap_8h.html#a64">RtlpGlobalTagHeap</a>-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
05651 
05652                 TagEntry = &amp;<a class="code" href="../../d3/d9/heap_8h.html#a64">RtlpGlobalTagHeap</a>-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a>[ TagIndex ];
05653 
05654                 TagIndex |= HEAP_GLOBAL_TAG;
05655 
05656             } <span class="keywordflow">else</span> {
05657 
05658                 <span class="keywordflow">return</span> 0;
05659             }
05660 
05661         <span class="comment">//</span>
05662         <span class="comment">//  Otherwise we have a regular tag index that we need to make sure</span>
05663         <span class="comment">//  is a valid value and that the heap has some tag entries</span>
05664         <span class="comment">//</span>
05665 
05666         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((TagIndex &lt; Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o14">NextAvailableTagIndex</a>) &amp;&amp;
05667                    (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
05668 
05669             TagEntry = &amp;Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a>[ TagIndex ];
05670 
05671         } <span class="keywordflow">else</span> {
05672 
05673             <span class="keywordflow">return</span> 0;
05674         }
05675 
05676         <span class="comment">//</span>
05677         <span class="comment">//  At this point we have a tag entry and tag index.  Increment the</span>
05678         <span class="comment">//  number of frees we've done on the tag, and decrement the size by</span>
05679         <span class="comment">//  the number of bytes we've just freed</span>
05680         <span class="comment">//</span>
05681 
05682         TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o1">Frees</a> += 1;
05683 
05684         TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o2">Size</a> -= OldSize;
05685 
05686         <span class="comment">//</span>
05687         <span class="comment">//  Now if the action is either ReAllocationAction or</span>
05688         <span class="comment">//  VirtualReAllocationAction.  Then we get to add back in the</span>
05689         <span class="comment">//  new size and the allocation count</span>
05690         <span class="comment">//</span>
05691 
05692         <span class="keywordflow">if</span> (<a class="code" href="../../d7/d0/cmdat2_8c.html#a18">Action</a> &gt;= <a class="code" href="../../d9/d9/heappriv_8h.html#a60a31">ReAllocationAction</a>) {
05693 
05694             <span class="comment">//</span>
05695             <span class="comment">//  If the this is a pseudo tag then we tag entry goes off the</span>
05696             <span class="comment">//  pseudo tag list</span>
05697             <span class="comment">//</span>
05698 
05699             <span class="keywordflow">if</span> (TagIndex &amp; HEAP_PSEUDO_TAG_FLAG) {
05700 
05701                 TagIndex = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(NewSize &lt; <a class="code" href="../../d3/d9/heap_8h.html#a6">HEAP_MAXIMUM_FREELISTS</a> ?
05702                                         NewSize :
05703                                         (<a class="code" href="../../d7/d0/cmdat2_8c.html#a18">Action</a> == <a class="code" href="../../d9/d9/heappriv_8h.html#a60a32">VirtualReAllocationAction</a> ? <a class="code" href="../../d3/d9/heap_8h.html#a6">HEAP_MAXIMUM_FREELISTS</a> : 0));
05704 
05705                 TagEntry = (<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html">PHEAP_TAG_ENTRY</a>)(Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o29">PseudoTagEntries</a> + TagIndex);
05706 
05707                 TagIndex |= HEAP_PSEUDO_TAG_FLAG;
05708             }
05709 
05710             TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o0">Allocs</a> += 1;
05711 
05712             TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o2">Size</a> += NewSize;
05713         }
05714 
05715     <span class="comment">//</span>
05716     <span class="comment">//  The action is either AllocationAction or VirtualAllocationAction</span>
05717     <span class="comment">//</span>
05718 
05719     } <span class="keywordflow">else</span> {
05720 
05721         <span class="comment">//</span>
05722         <span class="comment">//  Check if the supplied tag index is a regular tag and that it is</span>
05723         <span class="comment">//  valid for the tags in this heap</span>
05724         <span class="comment">//</span>
05725 
05726         <span class="keywordflow">if</span> ((TagIndex != 0) &amp;&amp;
05727             (TagIndex &lt; Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o14">NextAvailableTagIndex</a>) &amp;&amp;
05728             (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
05729 
05730             TagEntry = &amp;Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a>[ TagIndex ];
05731 
05732         <span class="comment">//</span>
05733         <span class="comment">//  Otherwise if this is a global tag then make sure that it is a</span>
05734         <span class="comment">//  valid global index</span>
05735         <span class="comment">//</span>
05736 
05737         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (TagIndex &amp; HEAP_GLOBAL_TAG) {
05738 
05739             TagIndex &amp;= ~HEAP_GLOBAL_TAG;
05740 
05741             Heap = <a class="code" href="../../d3/d9/heap_8h.html#a64">RtlpGlobalTagHeap</a>;
05742 
05743             <span class="keywordflow">if</span> ((TagIndex &lt; Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o14">NextAvailableTagIndex</a>) &amp;&amp;
05744                 (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
05745 
05746                 TagEntry = &amp;Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a>[ TagIndex ];
05747 
05748                 TagIndex |= HEAP_GLOBAL_TAG;
05749 
05750             } <span class="keywordflow">else</span> {
05751 
05752                 <span class="keywordflow">return</span> 0;
05753             }
05754 
05755         <span class="comment">//</span>
05756         <span class="comment">//  Otherwise if this is a pseudo tag then build a valid tag index</span>
05757         <span class="comment">//  based on the new size of the allocation</span>
05758         <span class="comment">//</span>
05759 
05760         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o29">PseudoTagEntries</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05761 
05762             TagIndex = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(NewSize &lt; <a class="code" href="../../d3/d9/heap_8h.html#a6">HEAP_MAXIMUM_FREELISTS</a> ?
05763                                     NewSize :
05764                                     (<a class="code" href="../../d7/d0/cmdat2_8c.html#a18">Action</a> == <a class="code" href="../../d9/d9/heappriv_8h.html#a60a28">VirtualAllocationAction</a> ? <a class="code" href="../../d3/d9/heap_8h.html#a6">HEAP_MAXIMUM_FREELISTS</a> : 0));
05765 
05766             TagEntry = (<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html">PHEAP_TAG_ENTRY</a>)(Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o29">PseudoTagEntries</a> + TagIndex);
05767 
05768             TagIndex |= HEAP_PSEUDO_TAG_FLAG;
05769 
05770         <span class="comment">//</span>
05771         <span class="comment">//  Otherwise the user didn't call us with a valid tag</span>
05772         <span class="comment">//</span>
05773 
05774         } <span class="keywordflow">else</span> {
05775 
05776             <span class="keywordflow">return</span> 0;
05777         }
05778 
05779         <span class="comment">//</span>
05780         <span class="comment">//  At this point we have a valid tag entry and tag index, so</span>
05781         <span class="comment">//  update the tag entry state to reflect this new allocation</span>
05782         <span class="comment">//</span>
05783 
05784         TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o0">Allocs</a> += 1;
05785 
05786         TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o2">Size</a> += NewSize;
05787     }
05788 
05789     <span class="comment">//</span>
05790     <span class="comment">//  And return to our caller with the new tag index</span>
05791     <span class="comment">//</span>
05792 
05793     <span class="keywordflow">return</span> TagIndex;
05794 }
05795 
05796 
05797 <span class="comment">//</span>
05798 <span class="comment">//  Declared in heappriv.h</span>
05799 <span class="comment">//</span>
05800 
05801 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l05802"></a><a class="code" href="../../d9/d9/heappriv_8h.html#a53">05802</a> <a class="code" href="../../d9/d9/heappriv_8h.html#a53">RtlpResetTags</a> (
05803     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap
05804     )
05805 
05806 <span class="comment">/*++</span>
05807 <span class="comment"></span>
05808 <span class="comment">Routine Description:</span>
05809 <span class="comment"></span>
05810 <span class="comment">    This routine is used to reset all the tag entries in a heap</span>
05811 <span class="comment"></span>
05812 <span class="comment">Arguments:</span>
05813 <span class="comment"></span>
05814 <span class="comment">    Heap - Supplies a pointer to the heap being modified</span>
05815 <span class="comment"></span>
05816 <span class="comment">Return Value:</span>
05817 <span class="comment"></span>
05818 <span class="comment">    None.</span>
05819 <span class="comment"></span>
05820 <span class="comment">--*/</span>
05821 
05822 {
05823     <a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html">PHEAP_TAG_ENTRY</a> TagEntry;
05824     <a class="code" href="../../d7/d6/struct__HEAP__PSEUDO__TAG__ENTRY.html">PHEAP_PSEUDO_TAG_ENTRY</a> PseudoTagEntry;
05825     ULONG i;
05826 
05827     <span class="comment">//</span>
05828     <span class="comment">//  We only have work to do if the heap has any allocated tag entries</span>
05829     <span class="comment">//</span>
05830 
05831     TagEntry = Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a>;
05832 
05833     <span class="keywordflow">if</span> (TagEntry != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05834 
05835         <span class="comment">//</span>
05836         <span class="comment">//  For every tag entry in the heap we will zero out its counters</span>
05837         <span class="comment">//</span>
05838 
05839         <span class="keywordflow">for</span> (i=0; i&lt;Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o14">NextAvailableTagIndex</a>; i++) {
05840 
05841             TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o0">Allocs</a> = 0;
05842             TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o1">Frees</a> = 0;
05843             TagEntry-&gt;<a class="code" href="../../d3/d7/struct__HEAP__TAG__ENTRY.html#o2">Size</a> = 0;
05844 
05845             <span class="comment">//</span>
05846             <span class="comment">//  Advance to the next tag entry</span>
05847             <span class="comment">//</span>
05848 
05849             TagEntry += 1;
05850         }
05851     }
05852 
05853     <span class="comment">//</span>
05854     <span class="comment">//  We will only reset the pseudo tags if they exist</span>
05855     <span class="comment">//</span>
05856 
05857     PseudoTagEntry = Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o29">PseudoTagEntries</a>;
05858 
05859     <span class="keywordflow">if</span> (PseudoTagEntry != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05860 
05861         <span class="comment">//</span>
05862         <span class="comment">//  For every pseudo tag entry in the heap we will zero out its</span>
05863         <span class="comment">//  counters</span>
05864         <span class="comment">//</span>
05865 
05866         <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="../../d3/d9/heap_8h.html#a32">HEAP_NUMBER_OF_PSEUDO_TAG</a>; i++) {
05867 
05868             PseudoTagEntry-&gt;<a class="code" href="../../d7/d6/struct__HEAP__PSEUDO__TAG__ENTRY.html#o0">Allocs</a> = 0;
05869             PseudoTagEntry-&gt;<a class="code" href="../../d7/d6/struct__HEAP__PSEUDO__TAG__ENTRY.html#o1">Frees</a> = 0;
05870             PseudoTagEntry-&gt;<a class="code" href="../../d7/d6/struct__HEAP__PSEUDO__TAG__ENTRY.html#o2">Size</a> = 0;
05871 
05872             <span class="comment">//</span>
05873             <span class="comment">//  Advance to the next pseudo tag entry</span>
05874             <span class="comment">//</span>
05875 
05876             PseudoTagEntry += 1;
05877         }
05878     }
05879 
05880     <span class="comment">//</span>
05881     <span class="comment">//  And return to our caller</span>
05882     <span class="comment">//</span>
05883 
05884     <span class="keywordflow">return</span>;
05885 }
05886 
05887 
05888 <span class="comment">//</span>
05889 <span class="comment">//  Declared in heappriv.h</span>
05890 <span class="comment">//</span>
05891 
05892 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l05893"></a><a class="code" href="../../d9/d9/heappriv_8h.html#a54">05893</a> <a class="code" href="../../d9/d9/heappriv_8h.html#a54">RtlpDestroyTags</a> (
05894     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap
05895     )
05896 
05897 <span class="comment">/*++</span>
05898 <span class="comment"></span>
05899 <span class="comment">Routine Description:</span>
05900 <span class="comment"></span>
05901 <span class="comment">    This routine is used to completely remove all the normal tag entries</span>
05902 <span class="comment">    in use by a heap</span>
05903 <span class="comment"></span>
05904 <span class="comment">Arguments:</span>
05905 <span class="comment"></span>
05906 <span class="comment">    Heap - Supplies a pointer to the heap being modified</span>
05907 <span class="comment"></span>
05908 <span class="comment">Return Value:</span>
05909 <span class="comment"></span>
05910 <span class="comment">    None.</span>
05911 <span class="comment"></span>
05912 <span class="comment">--*/</span>
05913 
05914 {
05915     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
05916     SIZE_T RegionSize;
05917 
05918     <span class="comment">//</span>
05919     <span class="comment">//  We will only do the action if the heap has some tag entries</span>
05920     <span class="comment">//</span>
05921 
05922     <span class="keywordflow">if</span> (Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05923 
05924         <span class="comment">//</span>
05925         <span class="comment">//  Release all the memory used by the tag entries</span>
05926         <span class="comment">//</span>
05927 
05928         RegionSize = 0;
05929 
05930         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d7/freevm_8c.html#a6">NtFreeVirtualMemory</a>( NtCurrentProcess(),
05931                                       &amp;Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a>,
05932                                       &amp;RegionSize,
05933                                       MEM_RELEASE );
05934 
05935         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
05936 
05937             Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o16">TagEntries</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05938         }
05939     }
05940 
05941     <span class="comment">//</span>
05942     <span class="comment">//  And return to our caller</span>
05943     <span class="comment">//</span>
05944 
05945     <span class="keywordflow">return</span>;
05946 }
05947 
05948 
05949 <span class="comment">//</span>
05950 <span class="comment">//  Local support routine</span>
05951 <span class="comment">//</span>
05952 
05953 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l05954"></a><a class="code" href="../../d5/d9/heapdll_8c.html#a19">05954</a> <a class="code" href="../../d5/d9/heapdll_8c.html#a19">RtlpAllocateHeapUsageEntry</a> (
05955     PRTL_HEAP_USAGE_INTERNAL Buffer,
05956     PRTL_HEAP_USAGE_ENTRY *pp
05957     )
05958 
05959 <span class="comment">/*++</span>
05960 <span class="comment"></span>
05961 <span class="comment">Routine Description:</span>
05962 <span class="comment"></span>
05963 <span class="comment">    This routine is used to allocate an new heap usage entry</span>
05964 <span class="comment">    from the internal heap usage buffer</span>
05965 <span class="comment"></span>
05966 <span class="comment">Arguments:</span>
05967 <span class="comment"></span>
05968 <span class="comment">    Buffer - Supplies a pointer to the internal heap usage</span>
05969 <span class="comment">        buffer from which to allocate an entry</span>
05970 <span class="comment"></span>
05971 <span class="comment">    pp - Receives a pointer to the newly allocated heap</span>
05972 <span class="comment">        usage entry.  If pp is already pointing to an existing</span>
05973 <span class="comment">        heap usage entry then on return we'll have this old</span>
05974 <span class="comment">        entry point to the new entry, but still return the new</span>
05975 <span class="comment">        entry.</span>
05976 <span class="comment"></span>
05977 <span class="comment">Return Value:</span>
05978 <span class="comment"></span>
05979 <span class="comment">    NTSTATUS - An appropriate status value</span>
05980 <span class="comment"></span>
05981 <span class="comment">--*/</span>
05982 
05983 {
05984     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
05985     PRTL_HEAP_USAGE_ENTRY p;
05986     PVOID CommitAddress;
05987     SIZE_T PageSize;
05988 
05989     <span class="comment">//</span>
05990     <span class="comment">//  Check if the free list is empty and then we have to allocate more</span>
05991     <span class="comment">//  memory for the free list</span>
05992     <span class="comment">//</span>
05993 
05994     <span class="keywordflow">if</span> (<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;FreeList == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05995 
05996         <span class="comment">//</span>
05997         <span class="comment">//  We cannot grow the buffer any larger than the reserved size</span>
05998         <span class="comment">//</span>
05999 
06000         <span class="keywordflow">if</span> (<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;CommittedSize &gt;= <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;ReservedSize) {
06001 
06002             <span class="keywordflow">return</span> STATUS_NO_MEMORY;
06003         }
06004 
06005         <span class="comment">//</span>
06006         <span class="comment">//  Try and add one page of committed memory to the buffer</span>
06007         <span class="comment">//  starting right after the currently committed space</span>
06008         <span class="comment">//</span>
06009 
06010         PageSize = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
06011 
06012         CommitAddress = (PCHAR)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;Base + <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;CommittedSize;
06013 
06014         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d6/allocvm_8c.html#a7">NtAllocateVirtualMemory</a>( NtCurrentProcess(),
06015                                           &amp;CommitAddress,
06016                                           0,
06017                                           &amp;PageSize,
06018                                           MEM_COMMIT,
06019                                           PAGE_READWRITE );
06020 
06021         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
06022 
06023             <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
06024         }
06025 
06026         <span class="comment">//</span>
06027         <span class="comment">//  Update the committed buffer size</span>
06028         <span class="comment">//</span>
06029 
06030         <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;CommittedSize += PageSize;
06031 
06032         <span class="comment">//</span>
06033         <span class="comment">//  Add the newly allocated space to the free list and</span>
06034         <span class="comment">//  build up the free list</span>
06035         <span class="comment">//</span>
06036 
06037         <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;FreeList = CommitAddress;
06038 
06039         p = <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;FreeList;
06040 
06041         <span class="keywordflow">while</span> (PageSize != 0) {
06042 
06043             p-&gt;Next = (p+1);
06044             p += 1;
06045             PageSize -= <span class="keyword">sizeof</span>( *p );
06046         }
06047 
06048         <span class="comment">//</span>
06049         <span class="comment">//  Null terminate the next pointer in the last free entry</span>
06050         <span class="comment">//</span>
06051 
06052         p -= 1;
06053         p-&gt;Next = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
06054     }
06055 
06056     <span class="comment">//</span>
06057     <span class="comment">//  At this point the free list contains at least one entry</span>
06058     <span class="comment">//  so simply pop the entry.</span>
06059     <span class="comment">//</span>
06060 
06061     p = <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;FreeList;
06062 
06063     <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;FreeList = p-&gt;Next;
06064 
06065     p-&gt;Next = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
06066 
06067     <span class="comment">//</span>
06068     <span class="comment">//  Now if the caller supplied an existing heap entry then</span>
06069     <span class="comment">//  we'll make the old heap entry point to this new entry</span>
06070     <span class="comment">//</span>
06071 
06072     <span class="keywordflow">if</span> (*pp) {
06073 
06074         (*pp)-&gt;Next = p;
06075     }
06076 
06077     <span class="comment">//</span>
06078     <span class="comment">//  And then return the new entry to our caller</span>
06079     <span class="comment">//</span>
06080 
06081     *pp = p;
06082 
06083     <span class="keywordflow">return</span> STATUS_SUCCESS;
06084 }
06085 
06086 
06087 <span class="comment">//</span>
06088 <span class="comment">//  Local support routine</span>
06089 <span class="comment">//</span>
06090 
06091 PRTL_HEAP_USAGE_ENTRY
<a name="l06092"></a><a class="code" href="../../d5/d9/heapdll_8c.html#a18">06092</a> <a class="code" href="../../d5/d9/heapdll_8c.html#a18">RtlpFreeHeapUsageEntry</a> (
06093     PRTL_HEAP_USAGE_INTERNAL Buffer,
06094     PRTL_HEAP_USAGE_ENTRY p
06095     )
06096 
06097 <span class="comment">/*++</span>
06098 <span class="comment"></span>
06099 <span class="comment">Routine Description:</span>
06100 <span class="comment"></span>
06101 <span class="comment">    This routine moves a heap usage entry from its current</span>
06102 <span class="comment">    list onto the free list and returns a pointer to the</span>
06103 <span class="comment">    next heap usage entry in the list.  It is like doing a pop</span>
06104 <span class="comment">    of the list denoted by "p"</span>
06105 <span class="comment"></span>
06106 <span class="comment">Arguments:</span>
06107 <span class="comment"></span>
06108 <span class="comment">    Buffer - Supplies a pointer to the internal heap usage buffer</span>
06109 <span class="comment">        being modified</span>
06110 <span class="comment"></span>
06111 <span class="comment">    p - Supplies a pointer to the entry being moved.  Okay if</span>
06112 <span class="comment">        it's null</span>
06113 <span class="comment"></span>
06114 <span class="comment">Return Value:</span>
06115 <span class="comment"></span>
06116 <span class="comment">    PRTL_HEAP_USAGE_ENTRY - Returns a pointer to the next heap usage</span>
06117 <span class="comment">        entry</span>
06118 <span class="comment"></span>
06119 <span class="comment">--*/</span>
06120 
06121 {
06122     PRTL_HEAP_USAGE_ENTRY pTmp;
06123 
06124     <span class="comment">//</span>
06125     <span class="comment">//  Check if we have a non null heap entry and if so then add</span>
06126     <span class="comment">//  the entry to the front of the free list and return the next</span>
06127     <span class="comment">//  entry in the list</span>
06128     <span class="comment">//</span>
06129 
06130     <span class="keywordflow">if</span> (p != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
06131 
06132         pTmp = p-&gt;Next;
06133 
06134         p-&gt;Next = <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;FreeList;
06135 
06136         <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>-&gt;FreeList = p;
06137 
06138     } <span class="keywordflow">else</span> {
06139 
06140         pTmp = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
06141     }
06142 
06143     <span class="keywordflow">return</span> pTmp;
06144 }
06145 
06146 
06147 <span class="comment">//</span>
06148 <span class="comment">//  Declared in heap.h</span>
06149 <span class="comment">//</span>
06150 
06151 BOOLEAN
<a name="l06152"></a><a class="code" href="../../d5/d9/heapdll_8c.html#a46">06152</a> <a class="code" href="../../d5/d9/heapdll_8c.html#a46">RtlpHeapIsLocked</a> (
06153     IN PVOID HeapHandle
06154     )
06155 
06156 <span class="comment">/*++</span>
06157 <span class="comment"></span>
06158 <span class="comment">Routine Description:</span>
06159 <span class="comment"></span>
06160 <span class="comment">    This routine is used to determine if a heap is locked</span>
06161 <span class="comment"></span>
06162 <span class="comment">Arguments:</span>
06163 <span class="comment"></span>
06164 <span class="comment">    HeapHandle - Supplies a pointer to the heap being queried</span>
06165 <span class="comment"></span>
06166 <span class="comment">Return Value:</span>
06167 <span class="comment"></span>
06168 <span class="comment">    BOOLEAN - TRUE if the heap is locked and FALSE otherwise</span>
06169 <span class="comment"></span>
06170 <span class="comment">--*/</span>
06171 
06172 {
06173     <a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a> Heap;
06174 
06175     <span class="comment">//</span>
06176     <span class="comment">//  Check if this is guard page version of heap</span>
06177     <span class="comment">//</span>
06178 
06179     <a class="code" href="../../d7/d9/heappage_8h.html#a6">IF_DEBUG_PAGE_HEAP_THEN_RETURN</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>,
06180                                     <a class="code" href="../../d7/d9/heappage_8h.html#a29">RtlpDebugPageHeapIsLocked</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> ));
06181 
06182     Heap = (<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
06183 
06184     <span class="comment">//</span>
06185     <span class="comment">//  The heap is locked if there is a lock variable, and it has an</span>
06186     <span class="comment">//  owning thread or the lockcount is not -1</span>
06187     <span class="comment">//</span>
06188 
06189     <span class="keywordflow">return</span> (( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) &amp;&amp;
06190             ( Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a>-&gt;<a class="code" href="../../d4/d6/struct__HEAP__LOCK.html#o2">Lock</a>.CriticalSection.OwningThread ||
06191               Heap-&gt;<a class="code" href="../../d5/d5/struct__HEAP.html#o31">LockVariable</a>-&gt;<a class="code" href="../../d4/d6/struct__HEAP__LOCK.html#o2">Lock</a>.CriticalSection.LockCount != -1 ));
06192 }
06193 
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:16 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
