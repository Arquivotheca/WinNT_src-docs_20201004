<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: exdsptch.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>exdsptch.c</h1><a href="../../d5/d9/alpha_2exdsptch_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1990  Microsoft Corporation</span>
00004 <span class="comment">Copyright (c) 1993  Digital Equipment Corporation</span>
00005 <span class="comment"></span>
00006 <span class="comment">Module Name:</span>
00007 <span class="comment"></span>
00008 <span class="comment">    exdsptch.c</span>
00009 <span class="comment"></span>
00010 <span class="comment">Abstract:</span>
00011 <span class="comment"></span>
00012 <span class="comment">    This module implements the dispatching of exceptions and the unwinding of</span>
00013 <span class="comment">    procedure call frames.</span>
00014 <span class="comment"></span>
00015 <span class="comment">Author:</span>
00016 <span class="comment"></span>
00017 <span class="comment">    David N. Cutler (davec) 11-Sep-1990</span>
00018 <span class="comment"></span>
00019 <span class="comment">Environment:</span>
00020 <span class="comment"></span>
00021 <span class="comment">    Any mode.</span>
00022 <span class="comment"></span>
00023 <span class="comment">Revision History:</span>
00024 <span class="comment"></span>
00025 <span class="comment">    Thomas Van Baak (tvb) 13-May-1992</span>
00026 <span class="comment"></span>
00027 <span class="comment">        Adapted for Alpha AXP.</span>
00028 <span class="comment"></span>
00029 <span class="comment">    Florence Lee (Digital) 10-Apr-1997</span>
00030 <span class="comment"></span>
00031 <span class="comment">        Add support for dynamic function tables (user mode only)</span>
00032 <span class="comment">        1) Modify RtlLookupFunctionEntry to search dynamic function tables</span>
00033 <span class="comment">        2) Add RtlAddFunctionTable: Add an array of RUNTIME_FUNCTION entries</span>
00034 <span class="comment">           to the dynamic function table list.</span>
00035 <span class="comment">        3) Add RtlDeleteFunctionTable: Remove dynamic from table the</span>
00036 <span class="comment">           dynamic function table list.</span>
00037 <span class="comment"></span>
00038 <span class="comment">    Monty VanderBilt (Digital) 16-Jun-1997</span>
00039 <span class="comment"></span>
00040 <span class="comment">        1) Use macros defined in ntalpha.h to access RUNTIME_FUNCTION</span>
00041 <span class="comment">           fields without low order bits used for other information</span>
00042 <span class="comment">        2) Modify RtlLookupFunctionEntry() and RtlVirtualUnwind() to</span>
00043 <span class="comment">           handle the variations of secondary function entry types.</span>
00044 <span class="comment">           </span>
00045 <span class="comment">    Monty VanderBilt (Compaq) 10-Aug-1999</span>
00046 <span class="comment">    </span>
00047 <span class="comment">        ECO (Engineering Change Order) numbers refer to Alpha NT calling standard changes </span>
00048 <span class="comment">        ECO 11: Support for compiler optimizations: tail calls, floating return sequences, shrinkwrap.</span>
00049 <span class="comment">        ECO 12: Minor change to ECO 11 moving StackAllocation field from the 3rd to 4th longword</span>
00050 <span class="comment">                in the secondary function entry.</span>
00051 <span class="comment">        ECO 14: Fixed return function entries to support (among other uses) exception handling in</span>
00052 <span class="comment">                instrumentation code.</span>
00053 <span class="comment">           </span>
00054 <span class="comment">--*/</span>
00055 
00056 <span class="preprocessor">#include "<a class="code" href="../../d5/d9/ntrtlp_8h.html">ntrtlp.h</a>"</span>
00057 <span class="keywordtype">int</span> __cdecl <a class="code" href="../../d6/d9/heappage_8c.html#a68">sprintf</a>(<span class="keywordtype">char</span> *, <span class="keyword">const</span> <span class="keywordtype">char</span> *, ...);
00058 
00059 <span class="comment">//</span>
00060 <span class="comment">// Define local macros.</span>
00061 <span class="comment">//</span>
00062 <span class="comment">// Raise noncontinuable exception with associated exception record.</span>
00063 <span class="comment">//</span>
00064 
<a name="l00065"></a><a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a0">00065</a> <span class="preprocessor">#define RAISE_EXCEPTION(Status, ExceptionRecordt) { \</span>
00066 <span class="preprocessor">    EXCEPTION_RECORD ExceptionRecordn; \</span>
00067 <span class="preprocessor">                                            \</span>
00068 <span class="preprocessor">    ExceptionRecordn.ExceptionCode = Status; \</span>
00069 <span class="preprocessor">    ExceptionRecordn.ExceptionFlags = EXCEPTION_NONCONTINUABLE; \</span>
00070 <span class="preprocessor">    ExceptionRecordn.ExceptionRecord = ExceptionRecordt; \</span>
00071 <span class="preprocessor">    ExceptionRecordn.NumberParameters = 0; \</span>
00072 <span class="preprocessor">    RtlRaiseException(&amp;ExceptionRecordn); \</span>
00073 <span class="preprocessor">    }</span>
00074 <span class="preprocessor"></span>
00075 <span class="comment">//</span>
00076 <span class="comment">// Determine if ExceptionHandler is defined</span>
00077 <span class="comment">//</span>
00078 
<a name="l00079"></a><a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a1">00079</a> <span class="preprocessor">#define IS_HANDLER_DEFINED(FunctionEntry) \</span>
00080 <span class="preprocessor">    (RF_EXCEPTION_HANDLER(FunctionEntry) != 0)</span>
00081 <span class="preprocessor"></span>
00082 <span class="preprocessor">#if DBG</span>
00083 <span class="preprocessor"></span>
00084 <span class="comment">//</span>
00085 <span class="comment">// Maintain a short history of PC's for malformed function table errors.</span>
00086 <span class="comment">//</span>
00087 
00088 <span class="preprocessor">#define PC_HISTORY_DEPTH 4</span>
00089 <span class="preprocessor"></span>
00090 <span class="comment">//</span>
00091 <span class="comment">// Definition of global flag to debug/validate exception handling.</span>
00092 <span class="comment">// See ntrtlalp.h for the bit definitions in this flag word.</span>
00093 <span class="comment">//</span>
00094 
00095 ULONG RtlDebugFlags = 0;
00096 
00097 <span class="keywordtype">void</span>
00098 ShowRuntimeFunction(
00099     PRUNTIME_FUNCTION FunctionEntry,
00100     PSTR Label
00101     );
00102 
00103 <span class="preprocessor">#endif</span>
00104 <span class="preprocessor"></span>
<a name="l00105"></a><a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a2">00105</a> <span class="preprocessor">#define Virtual VirtualFramePointer</span>
<a name="l00106"></a><a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a3">00106</a> <span class="preprocessor"></span><span class="preprocessor">#define Real RealFramePointer</span>
00107 <span class="preprocessor"></span>
00108 <span class="comment">//</span>
00109 <span class="comment">// Define private function prototypes.</span>
00110 <span class="comment">//</span>
00111 
00112 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00113 <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a4">RtlpRaiseException</a> (
00114     IN PEXCEPTION_RECORD ExceptionRecord
00115     );
00116 
00117 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00118 <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a5">RtlpRaiseStatus</a> (
00119     IN NTSTATUS Status
00120     );
00121 
00122 ULONG_PTR
00123 <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a6">RtlpVirtualUnwind</a> (
00124     IN ULONG_PTR ControlPc,
00125     IN PRUNTIME_FUNCTION FunctionEntry,
00126     IN PCONTEXT ContextRecord,
00127     OUT PBOOLEAN InFunction,
00128     OUT PFRAME_POINTERS EstablisherFrame
00129     );
00130 
00131 <span class="preprocessor">#if !defined(NTOS_KERNEL_RUNTIME)</span>
00132 <span class="preprocessor"></span>
00133 <span class="comment">//</span>
00134 <span class="comment">// List head for DYNAMIC_FUNCTION_TABLE entries.</span>
00135 <span class="comment">//</span>
00136 
<a name="l00137"></a><a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a7">00137</a> LIST_ENTRY <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a7">DynamicFunctionTable</a>;
00138 
00139 PRUNTIME_FUNCTION
00140 <a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a10">RtlLookupDynamicFunctionEntry</a>(
00141     IN ULONG_PTR ControlPc
00142     );
00143 
00144 <span class="preprocessor">#endif</span>
00145 <span class="preprocessor"></span>
00146 PRUNTIME_FUNCTION
00147 <a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a9">RtlLookupStaticFunctionEntry</a>(
00148     IN ULONG_PTR ControlPc,
00149     OUT PBOOLEAN InImage
00150     );
00151 
00152 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00153 <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a14">RtlGetUnwindFunctionEntry</a>(
00154     IN ULONG_PTR ControlPc,
00155     IN PRUNTIME_FUNCTION FunctionEntry,
00156     OUT PRUNTIME_FUNCTION UnwindFunctionEntry,
00157     OUT PULONG StackAdjust,
00158     OUT PULONG_PTR FixedReturn
00159     );
00160 
00161 BOOLEAN
<a name="l00162"></a><a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a15">00162</a> <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a7">RtlDispatchException</a> (
00163     IN PEXCEPTION_RECORD ExceptionRecord,
00164     IN PCONTEXT ContextRecord
00165     )
00166 
00167 <span class="comment">/*++</span>
00168 <span class="comment"></span>
00169 <span class="comment">Routine Description:</span>
00170 <span class="comment"></span>
00171 <span class="comment">    This function attempts to dispatch an exception to a frame based</span>
00172 <span class="comment">    handler by searching backwards through the stack based call frames.</span>
00173 <span class="comment">    The search begins with the frame specified in the context record and</span>
00174 <span class="comment">    continues backward until either a handler is found that handles the</span>
00175 <span class="comment">    exception, the stack is found to be invalid (i.e., out of limits or</span>
00176 <span class="comment">    unaligned), or the end of the call hierarchy is reached.</span>
00177 <span class="comment"></span>
00178 <span class="comment">    As each frame is encountered, the PC where control left the corresponding</span>
00179 <span class="comment">    function is determined and used to lookup exception handler information</span>
00180 <span class="comment">    in the runtime function table built by the linker. If the respective</span>
00181 <span class="comment">    routine has an exception handler, then the handler is called. If the</span>
00182 <span class="comment">    handler does not handle the exception, then the prologue of the routine</span>
00183 <span class="comment">    is executed backwards to "unwind" the effect of the prologue and then</span>
00184 <span class="comment">    the next frame is examined.</span>
00185 <span class="comment"></span>
00186 <span class="comment">Arguments:</span>
00187 <span class="comment"></span>
00188 <span class="comment">    ExceptionRecord - Supplies a pointer to an exception record.</span>
00189 <span class="comment"></span>
00190 <span class="comment">    ContextRecord - Supplies a pointer to a context record.</span>
00191 <span class="comment"></span>
00192 <span class="comment">Return Value:</span>
00193 <span class="comment"></span>
00194 <span class="comment">    If the exception is handled by one of the frame based handlers, then</span>
00195 <span class="comment">    a value of TRUE is returned. Otherwise a value of FALSE is returned.</span>
00196 <span class="comment"></span>
00197 <span class="comment">--*/</span>
00198 
00199 {
00200 
00201     CONTEXT ContextRecord1;
00202     ULONG_PTR ControlPc;
00203 <span class="preprocessor">#if DBG</span>
00204 <span class="preprocessor"></span>    ULONG_PTR ControlPcHistory[PC_HISTORY_DEPTH];
00205     ULONG ControlPcHistoryIndex = 0;
00206 <span class="preprocessor">#endif</span>
00207 <span class="preprocessor"></span>    <a class="code" href="../../d0/d6/struct__DISPATCHER__CONTEXT.html">DISPATCHER_CONTEXT</a> DispatcherContext;
00208     EXCEPTION_DISPOSITION Disposition;
00209     FRAME_POINTERS EstablisherFrame;
00210     ULONG ExceptionFlags;
00211 <span class="preprocessor">#if DBG</span>
00212 <span class="preprocessor"></span>    LONG FrameDepth = 0;
00213 <span class="preprocessor">#endif</span>
00214 <span class="preprocessor"></span>    PRUNTIME_FUNCTION FunctionEntry;
00215     ULONG_PTR HighLimit;
00216     BOOLEAN InFunction;
00217     ULONG_PTR LowLimit;
00218     ULONG_PTR NestedFrame;
00219     ULONG_PTR NextPc;
00220 
00221     <span class="comment">//</span>
00222     <span class="comment">// Get current stack limits, copy the context record, get the initial</span>
00223     <span class="comment">// PC value, capture the exception flags, and set the nested exception</span>
00224     <span class="comment">// frame pointer.</span>
00225     <span class="comment">//</span>
00226     <span class="comment">// The initial PC value is obtained from ExceptionAddress rather than</span>
00227     <span class="comment">// from ContextRecord.Fir since some Alpha exceptions are asynchronous.</span>
00228     <span class="comment">//</span>
00229 
00230     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a30">RtlpGetStackLimits</a>(&amp;LowLimit, &amp;HighLimit);
00231     RtlMoveMemory(&amp;ContextRecord1, ContextRecord, <span class="keyword">sizeof</span>(CONTEXT));
00232     ControlPc = (ULONG_PTR)ExceptionRecord-&gt;ExceptionAddress;
00233 
00234 <span class="preprocessor">#if DBG</span>
00235 <span class="preprocessor"></span>    <span class="keywordflow">if</span> ((ULONG_PTR)ExceptionRecord-&gt;ExceptionAddress != (ULONG_PTR)ContextRecord-&gt;Fir) {
00236         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlDispatchException: ExceptionAddress = %p, Fir = %p\n"</span>,
00237                  ExceptionRecord-&gt;ExceptionAddress, (ULONG_PTR)ContextRecord-&gt;Fir);
00238     }
00239 <span class="preprocessor">#endif</span>
00240 <span class="preprocessor"></span>
00241     ExceptionFlags = ExceptionRecord-&gt;ExceptionFlags &amp; <a class="code" href="../../d6/d7/halmips_8h.html#a25">EXCEPTION_NONCONTINUABLE</a>;
00242     NestedFrame = 0;
00243 
00244 <span class="preprocessor">#if DBG</span>
00245 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_DISPATCH_EXCEPTION) {
00246         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\nRtlDispatchException(ExceptionRecord = %p, ContextRecord = %p)\n"</span>,
00247                  ExceptionRecord, ContextRecord);
00248         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlDispatchException: ControlPc = %p, ExceptionRecord-&gt;ExceptionCode = %lx\n"</span>,
00249                  ControlPc, ExceptionRecord-&gt;ExceptionCode);
00250     }
00251 <span class="preprocessor">#endif</span>
00252 <span class="preprocessor"></span>
00253     <span class="comment">//</span>
00254     <span class="comment">// Start with the frame specified by the context record and search</span>
00255     <span class="comment">// backwards through the call frame hierarchy attempting to find an</span>
00256     <span class="comment">// exception handler that will handle the exception.</span>
00257     <span class="comment">//</span>
00258 
00259     <span class="keywordflow">do</span> {
00260 <span class="preprocessor">#if DBG</span>
00261 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_DISPATCH_EXCEPTION_DETAIL) {
00262             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlDispatchException: Loop: FrameDepth = %d, sp = %p, ControlPc = %p\n"</span>,
00263                      FrameDepth, (ULONG_PTR)ContextRecord1.IntSp, ControlPc);
00264             FrameDepth -= 1;
00265         }
00266 <span class="preprocessor">#endif</span>
00267 <span class="preprocessor"></span>
00268         <span class="comment">//</span>
00269         <span class="comment">// Lookup the function table entry using the point at which control</span>
00270         <span class="comment">// left the procedure.</span>
00271         <span class="comment">//</span>
00272 
00273         FunctionEntry = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>(ControlPc);
00274 
00275         <span class="comment">//</span>
00276         <span class="comment">// If there is a function table entry for the routine, then virtually</span>
00277         <span class="comment">// unwind to the caller of the current routine to obtain the virtual</span>
00278         <span class="comment">// frame pointer of the establisher and check if there is an exception</span>
00279         <span class="comment">// handler for the frame.</span>
00280         <span class="comment">//</span>
00281 
00282         <span class="keywordflow">if</span> (FunctionEntry != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00283             NextPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc,
00284                                       FunctionEntry,
00285                                       &amp;ContextRecord1,
00286                                       &amp;InFunction,
00287                                       &amp;EstablisherFrame,
00288                                       <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00289 
00290             <span class="comment">//</span>
00291             <span class="comment">// If the virtual frame pointer is not within the specified stack</span>
00292             <span class="comment">// limits or the virtual frame pointer is unaligned, then set the</span>
00293             <span class="comment">// stack invalid flag in the exception record and return exception</span>
00294             <span class="comment">// not handled. Otherwise, check if the current routine has an</span>
00295             <span class="comment">// exception handler.</span>
00296             <span class="comment">//</span>
00297 
00298             <span class="keywordflow">if</span> ((EstablisherFrame.Virtual &lt; LowLimit) ||
00299                 (EstablisherFrame.Virtual &gt; HighLimit) ||
00300                 ((EstablisherFrame.Virtual &amp; 0xF) != 0)) {
00301 
00302 <span class="preprocessor">#if DBG</span>
00303 <span class="preprocessor"></span>                <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\n****** Warning - stack invalid (exception).\n"</span>);
00304                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  EstablisherFrame.Virtual = %p, EstablisherFrame.Real = %p\n"</span>,
00305                          EstablisherFrame.Virtual, EstablisherFrame.Real);
00306                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  LowLimit = %p, HighLimit = %p\n"</span>,
00307                          LowLimit, HighLimit);
00308                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  NextPc = %p, ControlPc = %p\n"</span>,
00309                          NextPc, ControlPc);
00310                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  Now setting EXCEPTION_STACK_INVALID flag.\n"</span>);
00311 <span class="preprocessor">#endif</span>
00312 <span class="preprocessor"></span>
00313                 ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a28">EXCEPTION_STACK_INVALID</a>;
00314                 <span class="keywordflow">break</span>;
00315 
00316             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a1">IS_HANDLER_DEFINED</a>(FunctionEntry) &amp;&amp; InFunction) {
00317 
00318                 ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00319 
00320 <span class="preprocessor">#if DBG</span>
00321 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_DISPATCH_EXCEPTION_DETAIL) {
00322                     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlDispatchException: ExceptionHandler = %p, HandlerData = %p\n"</span>,
00323                              FunctionEntry-&gt;ExceptionHandler, FunctionEntry-&gt;HandlerData);
00324                 }
00325 <span class="preprocessor">#endif</span>
00326 <span class="preprocessor"></span>
00327                 <span class="comment">//</span>
00328                 <span class="comment">// The frame has an exception handler. The handler must be</span>
00329                 <span class="comment">// executed by calling another routine that is written in</span>
00330                 <span class="comment">// assembler. This is required because up level addressing</span>
00331                 <span class="comment">// of the handler information is required when a nested</span>
00332                 <span class="comment">// exception is encountered.</span>
00333                 <span class="comment">//</span>
00334 
00335                 DispatcherContext.ControlPc = ControlPc;
00336                 DispatcherContext.FunctionEntry = FunctionEntry;
00337                 DispatcherContext.EstablisherFrame = EstablisherFrame.Virtual;
00338                 DispatcherContext.ContextRecord = ContextRecord;
00339                 ExceptionRecord-&gt;ExceptionFlags = ExceptionFlags;
00340 
00341                 <span class="keywordflow">if</span> (<a class="code" href="../../d9/d2/ldrp_8h.html#a33">NtGlobalFlag</a> &amp; FLG_ENABLE_EXCEPTION_LOGGING) {
00342                     <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = <a class="code" href="../../d5/d9/ntrtlp_8h.html#a48">RtlpLogExceptionHandler</a>(
00343                                     ExceptionRecord,
00344                                     ContextRecord,
00345                                     ControlPc,
00346                                     FunctionEntry,
00347                                     <span class="keyword">sizeof</span>(RUNTIME_FUNCTION));
00348                 }
00349 
00350 <span class="preprocessor">#if DBG</span>
00351 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_DISPATCH_EXCEPTION_DETAIL) {
00352                     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlDispatchException: calling RtlpExecuteHandlerForException, ControlPc = %lx Handler = %lx\n"</span>,
00353                              ControlPc, RF_EXCEPTION_HANDLER(FunctionEntry) );
00354                 }
00355 <span class="preprocessor">#endif</span>
00356 <span class="preprocessor"></span>                Disposition =
00357                     <a class="code" href="../../d6/d9/ntrtlppc_8h.html#a0">RtlpExecuteHandlerForException</a>(ExceptionRecord,
00358                                                    EstablisherFrame.Virtual,
00359                                                    ContextRecord,
00360                                                    &amp;DispatcherContext,
00361                                                    RF_EXCEPTION_HANDLER(FunctionEntry));
00362 <span class="preprocessor">#if DBG</span>
00363 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_DISPATCH_EXCEPTION_DETAIL) {
00364                     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlDispatchException: RtlpExecuteHandlerForException returned Disposition = %lx\n"</span>, Disposition);
00365                 }
00366 <span class="preprocessor">#endif</span>
00367 <span class="preprocessor"></span>
00368                 <span class="keywordflow">if</span> (<a class="code" href="../../d9/d2/ldrp_8h.html#a33">NtGlobalFlag</a> &amp; FLG_ENABLE_EXCEPTION_LOGGING) {
00369                     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a49">RtlpLogLastExceptionDisposition</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>, Disposition);
00370                 }
00371 
00372                 ExceptionFlags |=
00373                     (ExceptionRecord-&gt;ExceptionFlags &amp; <a class="code" href="../../d6/d7/halmips_8h.html#a25">EXCEPTION_NONCONTINUABLE</a>);
00374 
00375                 <span class="comment">//</span>
00376                 <span class="comment">// If the current scan is within a nested context and the frame</span>
00377                 <span class="comment">// just examined is the end of the nested region, then clear</span>
00378                 <span class="comment">// the nested context frame and the nested exception flag in</span>
00379                 <span class="comment">// the exception flags.</span>
00380                 <span class="comment">//</span>
00381 
00382                 <span class="keywordflow">if</span> (NestedFrame == EstablisherFrame.Virtual) {
00383                     ExceptionFlags &amp;= (~<a class="code" href="../../d6/d7/halmips_8h.html#a29">EXCEPTION_NESTED_CALL</a>);
00384                     NestedFrame = 0;
00385                 }
00386 
00387                 <span class="comment">//</span>
00388                 <span class="comment">// Case on the handler disposition.</span>
00389                 <span class="comment">//</span>
00390 
00391                 <span class="keywordflow">switch</span> (Disposition) {
00392 
00393                     <span class="comment">//</span>
00394                     <span class="comment">// The disposition is to continue execution.</span>
00395                     <span class="comment">//</span>
00396                     <span class="comment">// If the exception is not continuable, then raise the</span>
00397                     <span class="comment">// exception STATUS_NONCONTINUABLE_EXCEPTION. Otherwise</span>
00398                     <span class="comment">// return exception handled.</span>
00399                     <span class="comment">//</span>
00400 
00401                 <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a36">ExceptionContinueExecution</a> :
00402                     <span class="keywordflow">if</span> ((ExceptionFlags &amp; <a class="code" href="../../d6/d7/halmips_8h.html#a25">EXCEPTION_NONCONTINUABLE</a>) != 0) {
00403                         <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a0">RAISE_EXCEPTION</a>(STATUS_NONCONTINUABLE_EXCEPTION, ExceptionRecord);
00404 
00405                     } <span class="keywordflow">else</span> {
00406 <span class="preprocessor">#if DBG</span>
00407 <span class="preprocessor"></span>                        <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_DISPATCH_EXCEPTION) {
00408                             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlDispatchException: returning TRUE\n"</span>);
00409                         }
00410 <span class="preprocessor">#endif</span>
00411 <span class="preprocessor"></span>                        <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00412                     }
00413 
00414                     <span class="comment">//</span>
00415                     <span class="comment">// The disposition is to continue the search.</span>
00416                     <span class="comment">//</span>
00417                     <span class="comment">// Get next frame address and continue the search.</span>
00418                     <span class="comment">//</span>
00419 
00420                 <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a37">ExceptionContinueSearch</a> :
00421                     <span class="keywordflow">break</span>;
00422 
00423                     <span class="comment">//</span>
00424                     <span class="comment">// The disposition is nested exception.</span>
00425                     <span class="comment">//</span>
00426                     <span class="comment">// Set the nested context frame to the establisher frame</span>
00427                     <span class="comment">// address and set the nested exception flag in the</span>
00428                     <span class="comment">// exception flags.</span>
00429                     <span class="comment">//</span>
00430 
00431                 <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a38">ExceptionNestedException</a> :
00432                     ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a29">EXCEPTION_NESTED_CALL</a>;
00433                     <span class="keywordflow">if</span> (DispatcherContext.EstablisherFrame &gt; NestedFrame) {
00434                         NestedFrame = DispatcherContext.EstablisherFrame;
00435                     }
00436 
00437                     <span class="keywordflow">break</span>;
00438 
00439                     <span class="comment">//</span>
00440                     <span class="comment">// All other disposition values are invalid.</span>
00441                     <span class="comment">//</span>
00442                     <span class="comment">// Raise invalid disposition exception.</span>
00443                     <span class="comment">//</span>
00444 
00445                 <span class="keywordflow">default</span> :
00446                     <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a0">RAISE_EXCEPTION</a>(STATUS_INVALID_DISPOSITION, ExceptionRecord);
00447                 }
00448             }
00449 
00450         } <span class="keywordflow">else</span> {
00451 
00452             <span class="comment">//</span>
00453             <span class="comment">// Set point at which control left the previous routine.</span>
00454             <span class="comment">//</span>
00455 
00456             NextPc = (ULONG_PTR)ContextRecord1.IntRa - 4;
00457 
00458             <span class="comment">//</span>
00459             <span class="comment">// If the next control PC is the same as the old control PC, then</span>
00460             <span class="comment">// the function table is not correctly formed.</span>
00461             <span class="comment">//</span>
00462 
00463             <span class="keywordflow">if</span> (NextPc == ControlPc) {
00464 <span class="preprocessor">#if DBG</span>
00465 <span class="preprocessor"></span>                ULONG <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>;
00466                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\n****** Warning - malformed function table (exception).\n"</span>);
00467                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"ControlPc = %p, NextPc %p"</span>, NextPc, ControlPc);
00468                 <span class="keywordflow">for</span> (<a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> = 0; <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> &lt; PC_HISTORY_DEPTH; <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> += 1) {
00469                     <span class="keywordflow">if</span> (ControlPcHistoryIndex &gt; 0) {
00470                         ControlPcHistoryIndex -= 1;
00471                         ControlPc = ControlPcHistory[ControlPcHistoryIndex % PC_HISTORY_DEPTH];
00472                         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">", %p"</span>, ControlPc);
00473                     }
00474                 }
00475                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(ControlPcHistoryIndex == 0 ? <span class="stringliteral">".\n"</span> : <span class="stringliteral">", ...\n"</span>);
00476 <span class="preprocessor">#endif</span>
00477 <span class="preprocessor"></span>                <span class="keywordflow">break</span>;
00478             }
00479         }
00480 
00481         <span class="comment">//</span>
00482         <span class="comment">// Set point at which control left the previous routine.</span>
00483         <span class="comment">//</span>
00484 
00485 <span class="preprocessor">#if DBG</span>
00486 <span class="preprocessor"></span>        ControlPcHistory[ControlPcHistoryIndex % PC_HISTORY_DEPTH] = ControlPc;
00487         ControlPcHistoryIndex += 1;
00488 <span class="preprocessor">#endif</span>
00489 <span class="preprocessor"></span>        ControlPc = NextPc;
00490 
00491     } <span class="keywordflow">while</span> ((ULONG_PTR)ContextRecord1.IntSp &lt; HighLimit);
00492 
00493     <span class="comment">//</span>
00494     <span class="comment">// Set final exception flags and return exception not handled.</span>
00495     <span class="comment">//</span>
00496 
00497     ExceptionRecord-&gt;ExceptionFlags = ExceptionFlags;
00498 <span class="preprocessor">#if DBG</span>
00499 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_DISPATCH_EXCEPTION) {
00500         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlDispatchException: returning FALSE\n"</span>);
00501     }
00502 <span class="preprocessor">#endif</span>
00503 <span class="preprocessor"></span>    <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00504 }
00505 
00506 PRUNTIME_FUNCTION
<a name="l00507"></a><a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a16">00507</a> <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a> (
00508     IN ULONG_PTR ControlPc
00509     )
00510 
00511 <span class="comment">/*++</span>
00512 <span class="comment"></span>
00513 <span class="comment">Routine Description:</span>
00514 <span class="comment"></span>
00515 <span class="comment">    This function searches the currently active function tables (static and dynamic)</span>
00516 <span class="comment">    for an entry that corresponds to the specified PC value. If the entry is for a</span>
00517 <span class="comment">    secondary function entry then the primary function table entry is obtained</span>
00518 <span class="comment">    via an indirection through the PrologEndAddress. RtlLookupDirectFunctionEntry()</span>
00519 <span class="comment">    performs the same function without the indirection to the primary function table.</span>
00520 <span class="comment">    Because RtlLookupFunctionEntry() always returns the primary function entry, it</span>
00521 <span class="comment">    has the property such that</span>
00522 <span class="comment"></span>
00523 <span class="comment">        RtlLookupFunctionEntry(Pc1) == RtlLookupFunctionEntry(Pc2)</span>
00524 <span class="comment"></span>
00525 <span class="comment">        implies</span>
00526 <span class="comment"></span>
00527 <span class="comment">        Pc1 and Pc2 are in the same procedure.</span>
00528 <span class="comment"></span>
00529 <span class="comment">Arguments:</span>
00530 <span class="comment"></span>
00531 <span class="comment">    ControlPc - Supplies the address of an instruction within the specified</span>
00532 <span class="comment">        function.</span>
00533 <span class="comment"></span>
00534 <span class="comment">Return Value:</span>
00535 <span class="comment"></span>
00536 <span class="comment">    If there is no entry in the function table for the specified PC, then</span>
00537 <span class="comment">    NULL is returned. Otherwise, the address of the primary function table</span>
00538 <span class="comment">    entry that corresponds to the specified PC is returned.</span>
00539 <span class="comment"></span>
00540 <span class="comment">--*/</span>
00541 
00542 {
00543     PRUNTIME_FUNCTION FunctionEntry;
00544 
00545     <span class="comment">// Look for a static or dynamic function entry</span>
00546 
00547     FunctionEntry = <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a22">RtlLookupDirectFunctionEntry</a>( ControlPc );
00548 
00549     <span class="keywordflow">if</span> (FunctionEntry != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00550 
00551         <span class="comment">//</span>
00552         <span class="comment">// The capability exists for more than one function entry</span>
00553         <span class="comment">// to map to the same function. This permits a function to</span>
00554         <span class="comment">// have discontiguous code segments described by separate</span>
00555         <span class="comment">// function table entries. If the ending prologue address</span>
00556         <span class="comment">// is not within the limits of the begining and ending</span>
00557         <span class="comment">// address of the function able entry, then the prologue</span>
00558         <span class="comment">// ending address is the address of the primary function</span>
00559         <span class="comment">// table entry that accurately describes the ending prologue</span>
00560         <span class="comment">// address.</span>
00561         <span class="comment">//</span>
00562 
00563         <span class="keywordflow">if</span> ((RF_PROLOG_END_ADDRESS(FunctionEntry) &lt;  RF_BEGIN_ADDRESS(FunctionEntry)) ||
00564             (RF_PROLOG_END_ADDRESS(FunctionEntry) &gt;= RF_END_ADDRESS(FunctionEntry))) {
00565 <span class="preprocessor">#if DBG</span>
00566 <span class="preprocessor"></span>            ShowRuntimeFunction(FunctionEntry, <span class="stringliteral">"RtlLookupFunctionEntry: secondary entry"</span> );
00567 <span class="preprocessor">#endif</span>
00568 <span class="preprocessor"></span>            <span class="comment">// Officially the PrologEndAddress field in secondary function entries</span>
00569             <span class="comment">// doesn't have the exception mode bits there have been some versions</span>
00570             <span class="comment">// of alpha tools that put them there. Strip them off to be safe.</span>
00571 
00572             FunctionEntry = (PRUNTIME_FUNCTION)RF_PROLOG_END_ADDRESS(FunctionEntry);
00573         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (RF_IS_FIXED_RETURN(FunctionEntry)) {
00574             ULONG_PTR FixedReturn = RF_FIXED_RETURN(FunctionEntry);
00575     
00576 <span class="preprocessor">#if DBG</span>
00577 <span class="preprocessor"></span>            ShowRuntimeFunction(FunctionEntry, <span class="stringliteral">"LookupFunctionEntry: fixed return entry"</span>);
00578 <span class="preprocessor">#endif</span>
00579 <span class="preprocessor"></span>            <span class="comment">// Recursively call LookupFunctionEntry to ensure we get a primary function entry here.</span>
00580             <span class="comment">// Check for incorrectly formed function entry where the fixed return points to itself.</span>
00581     
00582             <span class="keywordflow">if</span> ((FixedReturn &lt;  RF_BEGIN_ADDRESS(FunctionEntry)) ||
00583                 (FixedReturn &gt;= RF_END_ADDRESS(FunctionEntry))) {
00584                 FunctionEntry = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>( RF_FIXED_RETURN(FunctionEntry) );
00585             }
00586         }
00587 <span class="preprocessor">#if DBG</span>
00588 <span class="preprocessor"></span>        <span class="keywordflow">else</span> {
00589             ShowRuntimeFunction(FunctionEntry, <span class="stringliteral">"RtlLookupFunctionEntry: primary entry"</span> );
00590         }
00591 <span class="preprocessor">#endif</span>
00592 <span class="preprocessor"></span>    }
00593 
00594 <span class="preprocessor">#if DBG</span>
00595 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_FUNCTION_ENTRY) {
00596         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlLookupFunctionEntry: returning FunctionEntry = %lx\n"</span>, FunctionEntry);
00597     }
00598 <span class="preprocessor">#endif</span>
00599 <span class="preprocessor"></span>    <span class="keywordflow">return</span> FunctionEntry;
00600 }
00601 
00602 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00603"></a><a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a17">00603</a> <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a9">RtlRaiseException</a> (
00604     IN PEXCEPTION_RECORD ExceptionRecord
00605     )
00606 
00607 <span class="comment">/*++</span>
00608 <span class="comment"></span>
00609 <span class="comment">Routine Description:</span>
00610 <span class="comment"></span>
00611 <span class="comment">    This function raises a software exception by building a context record</span>
00612 <span class="comment">    and calling the raise exception system service.</span>
00613 <span class="comment"></span>
00614 <span class="comment">    N.B. This routine is a shell routine that simply calls another routine</span>
00615 <span class="comment">         to do the real work. The reason this is done is to avoid a problem</span>
00616 <span class="comment">         in try/finally scopes where the last statement in the scope is a</span>
00617 <span class="comment">         call to raise an exception.</span>
00618 <span class="comment"></span>
00619 <span class="comment">Arguments:</span>
00620 <span class="comment"></span>
00621 <span class="comment">    ExceptionRecord - Supplies a pointer to an exception record.</span>
00622 <span class="comment"></span>
00623 <span class="comment">Return Value:</span>
00624 <span class="comment"></span>
00625 <span class="comment">    None.</span>
00626 <span class="comment"></span>
00627 <span class="comment">--*/</span>
00628 
00629 {
00630 
00631 <span class="preprocessor">#if DBG</span>
00632 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_RAISE_EXCEPTION) {
00633         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlRaiseException(ExceptionRecord = %p) Status = %lx\n"</span>,
00634                  ExceptionRecord, ExceptionRecord-&gt;ExceptionCode);
00635     }
00636 <span class="preprocessor">#endif</span>
00637 <span class="preprocessor"></span>
00638     <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a4">RtlpRaiseException</a>(ExceptionRecord);
00639     <span class="keywordflow">return</span>;
00640 }
00641 
00642 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00643"></a><a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a9">00643</a> <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a4">RtlpRaiseException</a> (
00644     IN PEXCEPTION_RECORD ExceptionRecord
00645     )
00646 
00647 <span class="comment">/*++</span>
00648 <span class="comment"></span>
00649 <span class="comment">Routine Description:</span>
00650 <span class="comment"></span>
00651 <span class="comment">    This function raises a software exception by building a context record</span>
00652 <span class="comment">    and calling the raise exception system service.</span>
00653 <span class="comment"></span>
00654 <span class="comment">Arguments:</span>
00655 <span class="comment"></span>
00656 <span class="comment">    ExceptionRecord - Supplies a pointer to an exception record.</span>
00657 <span class="comment"></span>
00658 <span class="comment">Return Value:</span>
00659 <span class="comment"></span>
00660 <span class="comment">    None.</span>
00661 <span class="comment"></span>
00662 <span class="comment">--*/</span>
00663 
00664 {
00665 
00666     ULONG_PTR ControlPc;
00667     CONTEXT ContextRecord;
00668     FRAME_POINTERS EstablisherFrame;
00669     PRUNTIME_FUNCTION FunctionEntry;
00670     BOOLEAN InFunction;
00671     ULONG_PTR NextPc;
00672     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00673 
00674     <span class="comment">//</span>
00675     <span class="comment">// Capture the current context, virtually unwind to the caller of this</span>
00676     <span class="comment">// routine, set the fault instruction address to that of the caller, and</span>
00677     <span class="comment">// call the raise exception system service.</span>
00678     <span class="comment">//</span>
00679 
00680     RtlCaptureContext(&amp;ContextRecord);
00681     ControlPc = (ULONG_PTR)ContextRecord.IntRa - 4;
00682     FunctionEntry = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>(ControlPc);
00683     NextPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc,
00684                               FunctionEntry,
00685                               &amp;ContextRecord,
00686                               &amp;InFunction,
00687                               &amp;EstablisherFrame,
00688                               <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00689 
00690     ContextRecord.Fir = (ULONGLONG)(LONG_PTR)NextPc + 4;
00691     ExceptionRecord-&gt;ExceptionAddress = (PVOID)ContextRecord.Fir;
00692     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwRaiseException(ExceptionRecord, &amp;ContextRecord, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
00693 
00694     <span class="comment">//</span>
00695     <span class="comment">// There should never be a return from this system service unless</span>
00696     <span class="comment">// there is a problem with the argument list itself. Raise another</span>
00697     <span class="comment">// exception specifying the status value returned.</span>
00698     <span class="comment">//</span>
00699 
00700     <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a10">RtlRaiseStatus</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>);
00701     <span class="keywordflow">return</span>;
00702 }
00703 
00704 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00705"></a><a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a18">00705</a> <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a10">RtlRaiseStatus</a> (
00706     IN NTSTATUS Status
00707     )
00708 
00709 <span class="comment">/*++</span>
00710 <span class="comment"></span>
00711 <span class="comment">Routine Description:</span>
00712 <span class="comment"></span>
00713 <span class="comment">    This function raises an exception with the specified status value. The</span>
00714 <span class="comment">    exception is marked as noncontinuable with no parameters.</span>
00715 <span class="comment"></span>
00716 <span class="comment">    N.B. This routine is a shell routine that simply calls another routine</span>
00717 <span class="comment">         to do the real work. The reason this is done is to avoid a problem</span>
00718 <span class="comment">         in try/finally scopes where the last statement in the scope is a</span>
00719 <span class="comment">         call to raise an exception.</span>
00720 <span class="comment"></span>
00721 <span class="comment">Arguments:</span>
00722 <span class="comment"></span>
00723 <span class="comment">    Status - Supplies the status value to be used as the exception code</span>
00724 <span class="comment">        for the exception that is to be raised.</span>
00725 <span class="comment"></span>
00726 <span class="comment">Return Value:</span>
00727 <span class="comment"></span>
00728 <span class="comment">    None.</span>
00729 <span class="comment"></span>
00730 <span class="comment">--*/</span>
00731 
00732 {
00733 
00734 <span class="preprocessor">#if DBG</span>
00735 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_RAISE_EXCEPTION) {
00736         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlRaiseStatus(Status = %lx)\n"</span>, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>);
00737     }
00738 <span class="preprocessor">#endif</span>
00739 <span class="preprocessor"></span>
00740     <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a5">RtlpRaiseStatus</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>);
00741     <span class="keywordflow">return</span>;
00742 }
00743 
00744 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00745"></a><a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a10">00745</a> <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a5">RtlpRaiseStatus</a> (
00746     IN NTSTATUS Status
00747     )
00748 
00749 <span class="comment">/*++</span>
00750 <span class="comment"></span>
00751 <span class="comment">Routine Description:</span>
00752 <span class="comment"></span>
00753 <span class="comment">    This function raises an exception with the specified status value. The</span>
00754 <span class="comment">    exception is marked as noncontinuable with no parameters.</span>
00755 <span class="comment"></span>
00756 <span class="comment">Arguments:</span>
00757 <span class="comment"></span>
00758 <span class="comment">    Status - Supplies the status value to be used as the exception code</span>
00759 <span class="comment">        for the exception that is to be raised.</span>
00760 <span class="comment"></span>
00761 <span class="comment">Return Value:</span>
00762 <span class="comment"></span>
00763 <span class="comment">    None.</span>
00764 <span class="comment"></span>
00765 <span class="comment">--*/</span>
00766 
00767 {
00768 
00769     ULONG_PTR ControlPc;
00770     CONTEXT ContextRecord;
00771     FRAME_POINTERS EstablisherFrame;
00772     EXCEPTION_RECORD ExceptionRecord;
00773     PRUNTIME_FUNCTION FunctionEntry;
00774     BOOLEAN InFunction;
00775     ULONG_PTR NextPc;
00776 
00777     <span class="comment">//</span>
00778     <span class="comment">// Construct an exception record.</span>
00779     <span class="comment">//</span>
00780 
00781     ExceptionRecord.ExceptionCode = <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00782     ExceptionRecord.ExceptionRecord = (PEXCEPTION_RECORD)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00783     ExceptionRecord.NumberParameters = 0;
00784     ExceptionRecord.ExceptionFlags = <a class="code" href="../../d6/d7/halmips_8h.html#a25">EXCEPTION_NONCONTINUABLE</a>;
00785 
00786     <span class="comment">//</span>
00787     <span class="comment">// Capture the current context, virtually unwind to the caller of this</span>
00788     <span class="comment">// routine, set the fault instruction address to that of the caller, and</span>
00789     <span class="comment">// call the raise exception system service.</span>
00790     <span class="comment">//</span>
00791 
00792     RtlCaptureContext(&amp;ContextRecord);
00793     ControlPc = (ULONG_PTR)ContextRecord.IntRa - 4;
00794     FunctionEntry = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>(ControlPc);
00795     NextPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc,
00796                               FunctionEntry,
00797                               &amp;ContextRecord,
00798                               &amp;InFunction,
00799                               &amp;EstablisherFrame,
00800                               <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00801 
00802     ContextRecord.Fir = (ULONGLONG)(LONG_PTR)NextPc + 4;
00803     ExceptionRecord.ExceptionAddress = (PVOID)ContextRecord.Fir;
00804     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwRaiseException(&amp;ExceptionRecord, &amp;ContextRecord, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
00805 
00806     <span class="comment">//</span>
00807     <span class="comment">// There should never be a return from this system service unless</span>
00808     <span class="comment">// there is a problem with the argument list itself. Raise another</span>
00809     <span class="comment">// exception specifying the status value returned.</span>
00810     <span class="comment">//</span>
00811 
00812     <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a10">RtlRaiseStatus</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>);
00813     <span class="keywordflow">return</span>;
00814 }
00815 
00816 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00817"></a><a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a19">00817</a> <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a11">RtlUnwind</a> (
00818     IN PVOID TargetFrame OPTIONAL,
00819     IN PVOID TargetIp OPTIONAL,
00820     IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
00821     IN PVOID ReturnValue
00822     )
00823 
00824 <span class="comment">/*++</span>
00825 <span class="comment"></span>
00826 <span class="comment">Routine Description:</span>
00827 <span class="comment"></span>
00828 <span class="comment">    This function initiates an unwind of procedure call frames. The machine</span>
00829 <span class="comment">    state at the time of the call to unwind is captured in a context record</span>
00830 <span class="comment">    and the unwinding flag is set in the exception flags of the exception</span>
00831 <span class="comment">    record. If the TargetFrame parameter is not specified, then the exit unwind</span>
00832 <span class="comment">    flag is also set in the exception flags of the exception record. A backward</span>
00833 <span class="comment">    scan through the procedure call frames is then performed to find the target</span>
00834 <span class="comment">    of the unwind operation.</span>
00835 <span class="comment"></span>
00836 <span class="comment">    As each frame is encounter, the PC where control left the corresponding</span>
00837 <span class="comment">    function is determined and used to lookup exception handler information</span>
00838 <span class="comment">    in the runtime function table built by the linker. If the respective</span>
00839 <span class="comment">    routine has an exception handler, then the handler is called.</span>
00840 <span class="comment"></span>
00841 <span class="comment">    N.B. This routine is provided for backward compatibility with release 1.</span>
00842 <span class="comment"></span>
00843 <span class="comment">Arguments:</span>
00844 <span class="comment"></span>
00845 <span class="comment">    TargetFrame - Supplies an optional pointer to the call frame that is the</span>
00846 <span class="comment">        target of the unwind. If this parameter is not specified, then an exit</span>
00847 <span class="comment">        unwind is performed.</span>
00848 <span class="comment"></span>
00849 <span class="comment">    TargetIp - Supplies an optional instruction address that specifies the</span>
00850 <span class="comment">        continuation address of the unwind. This address is ignored if the</span>
00851 <span class="comment">        target frame parameter is not specified.</span>
00852 <span class="comment"></span>
00853 <span class="comment">    ExceptionRecord - Supplies an optional pointer to an exception record.</span>
00854 <span class="comment"></span>
00855 <span class="comment">    ReturnValue - Supplies a value that is to be placed in the integer</span>
00856 <span class="comment">        function return register just before continuing execution.</span>
00857 <span class="comment"></span>
00858 <span class="comment">Return Value:</span>
00859 <span class="comment"></span>
00860 <span class="comment">    None.</span>
00861 <span class="comment"></span>
00862 <span class="comment">--*/</span>
00863 
00864 {
00865     CONTEXT ContextRecord;
00866 
00867 
00868     <span class="comment">//</span>
00869     <span class="comment">// Call real unwind routine specifying a context record as an</span>
00870     <span class="comment">// extra argument.</span>
00871     <span class="comment">//</span>
00872 
00873     <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a12">RtlUnwind2</a>(TargetFrame,
00874                TargetIp,
00875                ExceptionRecord,
00876                ReturnValue,
00877                &amp;ContextRecord);
00878 
00879     <span class="keywordflow">return</span>;
00880 }
00881 
00882 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00883"></a><a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a20">00883</a> <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a12">RtlUnwind2</a> (
00884     IN PVOID TargetFrame OPTIONAL,
00885     IN PVOID TargetIp OPTIONAL,
00886     IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
00887     IN PVOID ReturnValue,
00888     IN PCONTEXT ContextRecord
00889     )
00890 
00891 <span class="comment">/*++</span>
00892 <span class="comment"></span>
00893 <span class="comment">Routine Description:</span>
00894 <span class="comment"></span>
00895 <span class="comment">    This function initiates an unwind of procedure call frames. The machine</span>
00896 <span class="comment">    state at the time of the call to unwind is captured in a context record</span>
00897 <span class="comment">    and the unwinding flag is set in the exception flags of the exception</span>
00898 <span class="comment">    record. If the TargetFrame parameter is not specified, then the exit unwind</span>
00899 <span class="comment">    flag is also set in the exception flags of the exception record. A backward</span>
00900 <span class="comment">    scan through the procedure call frames is then performed to find the target</span>
00901 <span class="comment">    of the unwind operation.</span>
00902 <span class="comment"></span>
00903 <span class="comment">    As each frame is encounter, the PC where control left the corresponding</span>
00904 <span class="comment">    function is determined and used to lookup exception handler information</span>
00905 <span class="comment">    in the runtime function table built by the linker. If the respective</span>
00906 <span class="comment">    routine has an exception handler, then the handler is called.</span>
00907 <span class="comment"></span>
00908 <span class="comment">    N.B. This routine is provided for backward compatibility with release 1.</span>
00909 <span class="comment"></span>
00910 <span class="comment">Arguments:</span>
00911 <span class="comment"></span>
00912 <span class="comment">    TargetFrame - Supplies an optional pointer to the call frame that is the</span>
00913 <span class="comment">        target of the unwind. If this parameter is not specified, then an exit</span>
00914 <span class="comment">        unwind is performed.</span>
00915 <span class="comment"></span>
00916 <span class="comment">    TargetIp - Supplies an optional instruction address that specifies the</span>
00917 <span class="comment">        continuation address of the unwind. This address is ignored if the</span>
00918 <span class="comment">        target frame parameter is not specified.</span>
00919 <span class="comment"></span>
00920 <span class="comment">    ExceptionRecord - Supplies an optional pointer to an exception record.</span>
00921 <span class="comment"></span>
00922 <span class="comment">    ReturnValue - Supplies a value that is to be placed in the integer</span>
00923 <span class="comment">        function return register just before continuing execution.</span>
00924 <span class="comment"></span>
00925 <span class="comment">Return Value:</span>
00926 <span class="comment"></span>
00927 <span class="comment">    None.</span>
00928 <span class="comment"></span>
00929 <span class="comment">--*/</span>
00930 
00931 {
00932     ULONG_PTR ControlPc;
00933 <span class="preprocessor">#if DBG</span>
00934 <span class="preprocessor"></span>    ULONG_PTR ControlPcHistory[PC_HISTORY_DEPTH];
00935     ULONG ControlPcHistoryIndex = 0;
00936 <span class="preprocessor">#endif</span>
00937 <span class="preprocessor"></span>    <a class="code" href="../../d0/d6/struct__DISPATCHER__CONTEXT.html">DISPATCHER_CONTEXT</a> DispatcherContext;
00938     EXCEPTION_DISPOSITION Disposition;
00939     FRAME_POINTERS EstablisherFrame;
00940     ULONG ExceptionFlags;
00941     EXCEPTION_RECORD ExceptionRecord1;
00942 <span class="preprocessor">#if DBG</span>
00943 <span class="preprocessor"></span>    LONG FrameDepth = 0;
00944 <span class="preprocessor">#endif</span>
00945 <span class="preprocessor"></span>    PRUNTIME_FUNCTION FunctionEntry;
00946     ULONG_PTR HighLimit;
00947     BOOLEAN InFunction;
00948     ULONG_PTR LowLimit;
00949     ULONG_PTR NextPc;
00950 
00951 <span class="preprocessor">#if DBG</span>
00952 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_UNWIND) {
00953         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\nRtlUnwind(TargetFrame = %p, TargetIp = %p,, ReturnValue = %lx)\n"</span>,
00954                  TargetFrame, TargetIp, ReturnValue);
00955     }
00956 <span class="preprocessor">#endif</span>
00957 <span class="preprocessor"></span>
00958     <span class="comment">//</span>
00959     <span class="comment">// Get current stack limits, capture the current context, virtually</span>
00960     <span class="comment">// unwind to the caller of this routine, get the initial PC value, and</span>
00961     <span class="comment">// set the unwind target address.</span>
00962     <span class="comment">//</span>
00963 
00964     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a30">RtlpGetStackLimits</a>(&amp;LowLimit, &amp;HighLimit);
00965     RtlCaptureContext(ContextRecord);
00966     ControlPc = (ULONG_PTR)ContextRecord-&gt;IntRa - 4;
00967     FunctionEntry = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>(ControlPc);
00968     NextPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc,
00969                               FunctionEntry,
00970                               ContextRecord,
00971                               &amp;InFunction,
00972                               &amp;EstablisherFrame,
00973                               <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00974 
00975     ControlPc = NextPc;
00976     ContextRecord-&gt;Fir = (ULONGLONG)(LONG_PTR)TargetIp;
00977 
00978     <span class="comment">//</span>
00979     <span class="comment">// If an exception record is not specified, then build a local exception</span>
00980     <span class="comment">// record for use in calling exception handlers during the unwind operation.</span>
00981     <span class="comment">//</span>
00982 
00983     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(ExceptionRecord) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00984         ExceptionRecord = &amp;ExceptionRecord1;
00985         ExceptionRecord1.ExceptionCode = STATUS_UNWIND;
00986         ExceptionRecord1.ExceptionRecord = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00987         ExceptionRecord1.ExceptionAddress = (PVOID)ControlPc;
00988         ExceptionRecord1.NumberParameters = 0;
00989     }
00990 
00991     <span class="comment">//</span>
00992     <span class="comment">// If the target frame of the unwind is specified, then a normal unwind</span>
00993     <span class="comment">// is being performed. Otherwise, an exit unwind is being performed.</span>
00994     <span class="comment">//</span>
00995 
00996     ExceptionFlags = <a class="code" href="../../d6/d7/halmips_8h.html#a26">EXCEPTION_UNWINDING</a>;
00997     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(TargetFrame) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00998         ExceptionRecord-&gt;ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a27">EXCEPTION_EXIT_UNWIND</a>;
00999     }
01000 
01001     <span class="comment">//</span>
01002     <span class="comment">// Scan backward through the call frame hierarchy and call exception</span>
01003     <span class="comment">// handlers until the target frame of the unwind is reached.</span>
01004     <span class="comment">//</span>
01005 
01006     <span class="keywordflow">do</span> {
01007 
01008 <span class="preprocessor">#if DBG</span>
01009 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_UNWIND_DETAIL) {
01010         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlUnwind: Loop: FrameDepth = %d, sp = %p, ControlPc = %p\n"</span>,
01011                  FrameDepth, (ULONG_PTR)ContextRecord-&gt;IntSp, ControlPc);
01012         FrameDepth -= 1;
01013     }
01014 <span class="preprocessor">#endif</span>
01015 <span class="preprocessor"></span>
01016         <span class="comment">//</span>
01017         <span class="comment">// Lookup the function table entry using the point at which control</span>
01018         <span class="comment">// left the procedure.</span>
01019         <span class="comment">//</span>
01020 
01021         FunctionEntry = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>(ControlPc);
01022 
01023         <span class="comment">//</span>
01024         <span class="comment">// If there is a function table entry for the routine, then virtually</span>
01025         <span class="comment">// unwind to the caller of the routine to obtain the virtual frame</span>
01026         <span class="comment">// pointer of the establisher, but don't update the context record.</span>
01027         <span class="comment">//</span>
01028 
01029         <span class="keywordflow">if</span> (FunctionEntry != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01030             NextPc = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a6">RtlpVirtualUnwind</a>(ControlPc,
01031                                        FunctionEntry,
01032                                        ContextRecord,
01033                                        &amp;InFunction,
01034                                        &amp;EstablisherFrame);
01035 
01036             <span class="comment">//</span>
01037             <span class="comment">// If the virtual frame pointer is not within the specified stack</span>
01038             <span class="comment">// limits, the virtual frame pointer is unaligned, or the target</span>
01039             <span class="comment">// frame is below the virtual frame and an exit unwind is not being</span>
01040             <span class="comment">// performed, then raise the exception STATUS_BAD_STACK. Otherwise,</span>
01041             <span class="comment">// check to determine if the current routine has an exception</span>
01042             <span class="comment">// handler.</span>
01043             <span class="comment">//</span>
01044 
01045             <span class="keywordflow">if</span> ((EstablisherFrame.Virtual &lt; LowLimit) ||
01046                 (EstablisherFrame.Virtual &gt; HighLimit) ||
01047                 ((ARGUMENT_PRESENT(TargetFrame) != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
01048                  ((ULONG_PTR)TargetFrame &lt; EstablisherFrame.Virtual)) ||
01049                 ((EstablisherFrame.Virtual &amp; 0xF) != 0)) {
01050 
01051 <span class="preprocessor">#if DBG</span>
01052 <span class="preprocessor"></span>                <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\n****** Warning - bad stack or target frame (unwind).\n"</span>);
01053                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  EstablisherFrame Virtual = %p, Real = %p\n"</span>,
01054                          EstablisherFrame.Virtual, EstablisherFrame.Real);
01055                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  TargetFrame = %p\n"</span>, TargetFrame);
01056                 <span class="keywordflow">if</span> ((ARGUMENT_PRESENT(TargetFrame) != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
01057                     ((ULONG_PTR)TargetFrame &lt; EstablisherFrame.Virtual)) {
01058                     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  TargetFrame is below EstablisherFrame!\n"</span>);
01059                 }
01060                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  Previous EstablisherFrame (sp) = %p\n"</span>,
01061                          (ULONG_PTR)ContextRecord-&gt;IntSp);
01062                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  LowLimit = %p, HighLimit = %p\n"</span>,
01063                          LowLimit, HighLimit);
01064                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  NextPc = %p, ControlPc = %p\n"</span>,
01065                          NextPc, ControlPc);
01066                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  Now raising STATUS_BAD_STACK exception.\n"</span>);
01067 <span class="preprocessor">#endif</span>
01068 <span class="preprocessor"></span>
01069                 <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a0">RAISE_EXCEPTION</a>(STATUS_BAD_STACK, ExceptionRecord);
01070 
01071             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a1">IS_HANDLER_DEFINED</a>(FunctionEntry) &amp;&amp; InFunction) {
01072 
01073 <span class="preprocessor">#if DBG</span>
01074 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_DISPATCH_EXCEPTION_DETAIL) {
01075     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlUnwind: ExceptionHandler = %p, HandlerData = %p\n"</span>,
01076              FunctionEntry-&gt;ExceptionHandler, FunctionEntry-&gt;HandlerData);
01077 }
01078 <span class="preprocessor">#endif</span>
01079 <span class="preprocessor"></span>
01080                 <span class="comment">//</span>
01081                 <span class="comment">// The frame has an exception handler.</span>
01082                 <span class="comment">//</span>
01083                 <span class="comment">// The control PC, establisher frame pointer, the address</span>
01084                 <span class="comment">// of the function table entry, and the address of the</span>
01085                 <span class="comment">// context record are all stored in the dispatcher context.</span>
01086                 <span class="comment">// This information is used by the unwind linkage routine</span>
01087                 <span class="comment">// and can be used by the exception handler itself.</span>
01088                 <span class="comment">//</span>
01089                 <span class="comment">// A linkage routine written in assembler is used to actually</span>
01090                 <span class="comment">// call the actual exception handler. This is required by the</span>
01091                 <span class="comment">// exception handler that is associated with the linkage</span>
01092                 <span class="comment">// routine so it can have access to two sets of dispatcher</span>
01093                 <span class="comment">// context when it is called.</span>
01094                 <span class="comment">//</span>
01095 
01096                 DispatcherContext.ControlPc = ControlPc;
01097                 DispatcherContext.FunctionEntry = FunctionEntry;
01098                 DispatcherContext.EstablisherFrame = EstablisherFrame.Virtual;
01099                 DispatcherContext.ContextRecord = ContextRecord;
01100 
01101                 <span class="comment">//</span>
01102                 <span class="comment">// Call the exception handler.</span>
01103                 <span class="comment">//</span>
01104 
01105                 <span class="keywordflow">do</span> {
01106 
01107                     <span class="comment">//</span>
01108                     <span class="comment">// If the establisher frame is the target of the unwind</span>
01109                     <span class="comment">// operation, then set the target unwind flag.</span>
01110                     <span class="comment">//</span>
01111 
01112                     <span class="keywordflow">if</span> ((ULONG_PTR)TargetFrame == EstablisherFrame.Virtual) {
01113                         ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a30">EXCEPTION_TARGET_UNWIND</a>;
01114                     }
01115 
01116                     ExceptionRecord-&gt;ExceptionFlags = ExceptionFlags;
01117 
01118                     <span class="comment">//</span>
01119                     <span class="comment">// Set the specified return value in case the exception</span>
01120                     <span class="comment">// handler directly continues execution.</span>
01121                     <span class="comment">//</span>
01122 
01123                     ContextRecord-&gt;IntV0 = (ULONGLONG)(LONG_PTR)ReturnValue;
01124 <span class="preprocessor">#if DBG</span>
01125 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_UNWIND_DETAIL) {
01126         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlUnwind: calling RtlpExecuteHandlerForUnwind, ControlPc = %p\n"</span>, ControlPc);
01127     }
01128 <span class="preprocessor">#endif</span>
01129 <span class="preprocessor"></span>                    Disposition =
01130                         <a class="code" href="../../d6/d9/ntrtlppc_8h.html#a1">RtlpExecuteHandlerForUnwind</a>(ExceptionRecord,
01131                                                     EstablisherFrame.Virtual,
01132                                                     ContextRecord,
01133                                                     &amp;DispatcherContext,
01134                                                     RF_EXCEPTION_HANDLER(FunctionEntry));
01135 <span class="preprocessor">#if DBG</span>
01136 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_UNWIND_DETAIL) {
01137         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlUnwind: RtlpExecuteHandlerForUnwind returned Disposition = %lx\n"</span>, Disposition);
01138     }
01139 <span class="preprocessor">#endif</span>
01140 <span class="preprocessor"></span>
01141                     <span class="comment">//</span>
01142                     <span class="comment">// Clear target unwind and collided unwind flags.</span>
01143                     <span class="comment">//</span>
01144 
01145                     ExceptionFlags &amp;= ~(<a class="code" href="../../d6/d7/halmips_8h.html#a31">EXCEPTION_COLLIDED_UNWIND</a> |
01146                                         <a class="code" href="../../d6/d7/halmips_8h.html#a30">EXCEPTION_TARGET_UNWIND</a>);
01147 
01148                     <span class="comment">//</span>
01149                     <span class="comment">// Case on the handler disposition.</span>
01150                     <span class="comment">//</span>
01151 
01152                     <span class="keywordflow">switch</span> (Disposition) {
01153 
01154                         <span class="comment">//</span>
01155                         <span class="comment">// The disposition is to continue the search.</span>
01156                         <span class="comment">//</span>
01157                         <span class="comment">// If the target frame has not been reached, then</span>
01158                         <span class="comment">// virtually unwind to the caller of the current</span>
01159                         <span class="comment">// routine, update the context record, and continue</span>
01160                         <span class="comment">// the search for a handler.</span>
01161                         <span class="comment">//</span>
01162 
01163                     <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a37">ExceptionContinueSearch</a> :
01164                         <span class="keywordflow">if</span> (EstablisherFrame.Virtual != (ULONG_PTR)TargetFrame) {
01165                             NextPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc,
01166                                                       FunctionEntry,
01167                                                       ContextRecord,
01168                                                       &amp;InFunction,
01169                                                       &amp;EstablisherFrame,
01170                                                       <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
01171                         }
01172 
01173                         <span class="keywordflow">break</span>;
01174 
01175                         <span class="comment">//</span>
01176                         <span class="comment">// The disposition is collided unwind.</span>
01177                         <span class="comment">//</span>
01178                         <span class="comment">// Set the target of the current unwind to the context</span>
01179                         <span class="comment">// record of the previous unwind, and reexecute the</span>
01180                         <span class="comment">// exception handler from the collided frame with the</span>
01181                         <span class="comment">// collided unwind flag set in the exception record.</span>
01182                         <span class="comment">//</span>
01183 
01184                     <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a39">ExceptionCollidedUnwind</a> :
01185                         ControlPc = DispatcherContext.ControlPc;
01186                         FunctionEntry = DispatcherContext.FunctionEntry;
01187                         ContextRecord = DispatcherContext.ContextRecord;
01188                         ContextRecord-&gt;Fir = (ULONGLONG)(LONG_PTR)TargetIp;
01189                         ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a31">EXCEPTION_COLLIDED_UNWIND</a>;
01190                         EstablisherFrame.Virtual = DispatcherContext.EstablisherFrame;
01191                         <span class="keywordflow">break</span>;
01192 
01193                         <span class="comment">//</span>
01194                         <span class="comment">// All other disposition values are invalid.</span>
01195                         <span class="comment">//</span>
01196                         <span class="comment">// Raise invalid disposition exception.</span>
01197                         <span class="comment">//</span>
01198 
01199                     <span class="keywordflow">default</span> :
01200                         <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a0">RAISE_EXCEPTION</a>(STATUS_INVALID_DISPOSITION, ExceptionRecord);
01201                     }
01202 
01203                 } <span class="keywordflow">while</span> ((ExceptionFlags &amp; <a class="code" href="../../d6/d7/halmips_8h.html#a31">EXCEPTION_COLLIDED_UNWIND</a>) != 0);
01204             } <span class="keywordflow">else</span> {
01205 
01206                 <span class="comment">//</span>
01207                 <span class="comment">// Virtually unwind to the caller of the current routine and</span>
01208                 <span class="comment">// update the context record.</span>
01209                 <span class="comment">//</span>
01210 
01211                 <span class="keywordflow">if</span> (EstablisherFrame.Virtual != (ULONG_PTR)TargetFrame) {
01212                     NextPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc,
01213                                               FunctionEntry,
01214                                               ContextRecord,
01215                                               &amp;InFunction,
01216                                               &amp;EstablisherFrame,
01217                                               <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
01218                 }
01219             }
01220 
01221         } <span class="keywordflow">else</span> {
01222 
01223             <span class="comment">//</span>
01224             <span class="comment">// Set point at which control left the previous routine.</span>
01225             <span class="comment">//</span>
01226 
01227             NextPc = (ULONG_PTR)ContextRecord-&gt;IntRa - 4;
01228 
01229             <span class="comment">//</span>
01230             <span class="comment">// If the next control PC is the same as the old control PC, then</span>
01231             <span class="comment">// the function table is not correctly formed.</span>
01232             <span class="comment">//</span>
01233 
01234             <span class="keywordflow">if</span> (NextPc == ControlPc) {
01235 <span class="preprocessor">#if DBG</span>
01236 <span class="preprocessor"></span>                ULONG <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>;
01237                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\n****** Warning - malformed function table (unwind).\n"</span>);
01238                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"ControlPc = %p, %p"</span>, NextPc, ControlPc);
01239                 <span class="keywordflow">for</span> (<a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> = 0; <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> &lt; PC_HISTORY_DEPTH; <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> += 1) {
01240                     <span class="keywordflow">if</span> (ControlPcHistoryIndex &gt; 0) {
01241                         ControlPcHistoryIndex -= 1;
01242                         ControlPc = ControlPcHistory[ControlPcHistoryIndex % PC_HISTORY_DEPTH];
01243                         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">", %p"</span>, ControlPc);
01244                     }
01245                 }
01246                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(ControlPcHistoryIndex == 0 ? <span class="stringliteral">".\n"</span> : <span class="stringliteral">", ...\n"</span>);
01247                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  Now raising STATUS_BAD_FUNCTION_TABLE exception.\n"</span>);
01248 <span class="preprocessor">#endif</span>
01249 <span class="preprocessor"></span>                <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a10">RtlRaiseStatus</a>(STATUS_BAD_FUNCTION_TABLE);
01250             }
01251         }
01252 
01253         <span class="comment">//</span>
01254         <span class="comment">// Set point at which control left the previous routine.</span>
01255         <span class="comment">//</span>
01256 
01257 <span class="preprocessor">#if DBG</span>
01258 <span class="preprocessor"></span>        ControlPcHistory[ControlPcHistoryIndex % PC_HISTORY_DEPTH] = ControlPc;
01259         ControlPcHistoryIndex += 1;
01260 <span class="preprocessor">#endif</span>
01261 <span class="preprocessor"></span>        ControlPc = NextPc;
01262 
01263     } <span class="keywordflow">while</span> ((EstablisherFrame.Virtual &lt; HighLimit) &amp;&amp;
01264              (EstablisherFrame.Virtual != (ULONG_PTR)TargetFrame));
01265 
01266     <span class="comment">//</span>
01267     <span class="comment">// If the establisher stack pointer is equal to the target frame</span>
01268     <span class="comment">// pointer, then continue execution. Otherwise, an exit unwind was</span>
01269     <span class="comment">// performed or the target of the unwind did not exist and the</span>
01270     <span class="comment">// debugger and subsystem are given a second chance to handle the</span>
01271     <span class="comment">// unwind.</span>
01272     <span class="comment">//</span>
01273 
01274     <span class="keywordflow">if</span> (EstablisherFrame.Virtual == (ULONG_PTR)TargetFrame) {
01275         ContextRecord-&gt;IntV0 = (ULONGLONG)(LONG_PTR)ReturnValue;
01276 
01277 <span class="preprocessor">#if DBG</span>
01278 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_UNWIND) {
01279         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlUnwind: finished unwinding, and calling RtlpRestoreContext(%lx)\n"</span>,ContextRecord);
01280     }
01281 <span class="preprocessor">#endif</span>
01282 <span class="preprocessor"></span>
01283         <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a3">RtlpRestoreContext</a>(ContextRecord);
01284 
01285     } <span class="keywordflow">else</span> {
01286 
01287 <span class="preprocessor">#if DBG</span>
01288 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_UNWIND) {
01289         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlUnwind: finished unwinding, but calling ZwRaiseException\n"</span>);
01290     }
01291 <span class="preprocessor">#endif</span>
01292 <span class="preprocessor"></span>
01293         ZwRaiseException(ExceptionRecord, ContextRecord, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
01294     }
01295 
01296 }
01297 
01298 <span class="preprocessor">#if DBG</span>
01299 <span class="preprocessor"></span><span class="comment">//</span>
01300 <span class="comment">// Define an array of symbolic names for the integer registers.</span>
01301 <span class="comment">//</span>
01302 
01303 PCHAR RtlpIntegerRegisterNames[32] = {
01304     <span class="stringliteral">"v0"</span>,  <span class="stringliteral">"t0"</span>,  <span class="stringliteral">"t1"</span>,  <span class="stringliteral">"t2"</span>,  <span class="stringliteral">"t3"</span>,  <span class="stringliteral">"t4"</span>,  <span class="stringliteral">"t5"</span>,  <span class="stringliteral">"t6"</span>,      <span class="comment">// 0 - 7</span>
01305     <span class="stringliteral">"t7"</span>,  <span class="stringliteral">"s0"</span>,  <span class="stringliteral">"s1"</span>,  <span class="stringliteral">"s2"</span>,  <span class="stringliteral">"s3"</span>,  <span class="stringliteral">"s4"</span>,  <span class="stringliteral">"s5"</span>,  <span class="stringliteral">"fp"</span>,      <span class="comment">// 8 - 15</span>
01306     <span class="stringliteral">"a0"</span>,  <span class="stringliteral">"a1"</span>,  <span class="stringliteral">"a2"</span>,  <span class="stringliteral">"a3"</span>,  <span class="stringliteral">"a4"</span>,  <span class="stringliteral">"a5"</span>,  <span class="stringliteral">"t8"</span>,  <span class="stringliteral">"t9"</span>,      <span class="comment">// 16 - 23</span>
01307     <span class="stringliteral">"t10"</span>, <span class="stringliteral">"t11"</span>, <span class="stringliteral">"ra"</span>,  <span class="stringliteral">"t12"</span>, <span class="stringliteral">"at"</span>,  <span class="stringliteral">"gp"</span>,  <span class="stringliteral">"sp"</span>,  <span class="stringliteral">"zero"</span>,    <span class="comment">// 24 - 31</span>
01308 };
01309 
01310 <span class="comment">//</span>
01311 <span class="comment">// This function disassembles the instruction at the given address. It is</span>
01312 <span class="comment">// only used for debugging and recognizes only those few instructions that</span>
01313 <span class="comment">// are relevant during reverse execution of the prologue by virtual unwind.</span>
01314 <span class="comment">//</span>
01315 
01316 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01317 <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a4">_RtlpDebugDisassemble</a> (
01318     IN ULONG_PTR ControlPc,
01319     IN PCONTEXT ContextRecord
01320     )
01321 
01322 {
01323     UCHAR Comments[50];
01324     PULONGLONG FloatingRegister;
01325     ULONG Function;
01326     ULONG Hint;
01327     ULONG Literal8;
01328     ALPHA_INSTRUCTION Instruction;
01329     PULONGLONG IntegerRegister;
01330     LONG  Offset16;
01331     UCHAR Operands[20];
01332     ULONG Opcode;
01333     PCHAR OpName;
01334     ULONG Ra;
01335     ULONG Rb;
01336     ULONG Rc;
01337     PCHAR RaName;
01338     PCHAR RbName;
01339     PCHAR RcName;
01340 
01341     <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_VIRTUAL_UNWIND_DETAIL) {
01342         Instruction.Long = *((PULONG)ControlPc);
01343         Hint = Instruction.Jump.Hint;
01344         Literal8 = Instruction.OpLit.Literal;
01345         Offset16 = Instruction.Memory.MemDisp;
01346         Opcode = Instruction.Memory.Opcode;
01347         Ra = Instruction.OpReg.Ra;
01348         RaName = RtlpIntegerRegisterNames[Ra];
01349         Rb = Instruction.OpReg.Rb;
01350         RbName = RtlpIntegerRegisterNames[Rb];
01351         Rc = Instruction.OpReg.Rc;
01352         RcName = RtlpIntegerRegisterNames[Rc];
01353 
01354         IntegerRegister = &amp;ContextRecord-&gt;IntV0;
01355         FloatingRegister = &amp;ContextRecord-&gt;FltF0;
01356 
01357         OpName = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01358         <span class="keywordflow">switch</span> (Opcode) {
01359         <span class="keywordflow">case</span> JMP_OP :
01360             <span class="keywordflow">if</span> (Instruction.Jump.Function == RET_FUNC) {
01361                 OpName = <span class="stringliteral">"ret"</span>;
01362                 <a class="code" href="../../d6/d9/heappage_8c.html#a68">sprintf</a>(Operands, <span class="stringliteral">"%s, (%s), %04lx"</span>, RaName, RbName, Hint);
01363                 <a class="code" href="../../d6/d9/heappage_8c.html#a68">sprintf</a>(Comments, <span class="stringliteral">"%s = %Lx"</span>, RbName, IntegerRegister[Rb]);
01364             }
01365             <span class="keywordflow">break</span>;
01366 
01367         <span class="keywordflow">case</span> LDAH_OP :
01368         <span class="keywordflow">case</span> <a class="code" href="../../d5/d5/ia64_2alignem_8c.html#a3">LDA_OP</a> :
01369         <span class="keywordflow">case</span> STQ_OP :
01370             <span class="keywordflow">if</span> (Opcode == <a class="code" href="../../d5/d5/ia64_2alignem_8c.html#a3">LDA_OP</a>) {
01371                 OpName = <span class="stringliteral">"lda"</span>;
01372 
01373             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Opcode == LDAH_OP) {
01374                 OpName = <span class="stringliteral">"ldah"</span>;
01375 
01376             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Opcode == STQ_OP) {
01377                 OpName = <span class="stringliteral">"stq"</span>;
01378             }
01379             <a class="code" href="../../d6/d9/heappage_8c.html#a68">sprintf</a>(Operands, <span class="stringliteral">"%s, $%d(%s)"</span>, RaName, Offset16, RbName);
01380             <a class="code" href="../../d6/d9/heappage_8c.html#a68">sprintf</a>(Comments, <span class="stringliteral">"%s = %Lx"</span>, RaName, IntegerRegister[Ra]);
01381             <span class="keywordflow">break</span>;
01382 
01383         <span class="keywordflow">case</span> ARITH_OP :
01384         <span class="keywordflow">case</span> BIT_OP :
01385             Function = Instruction.OpReg.Function;
01386             <span class="keywordflow">if</span> ((Opcode == ARITH_OP) &amp;&amp; (Function == ADDQ_FUNC)) {
01387                     OpName = <span class="stringliteral">"addq"</span>;
01388 
01389             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Opcode == ARITH_OP) &amp;&amp; (Function == SUBQ_FUNC)) {
01390                     OpName = <span class="stringliteral">"subq"</span>;
01391 
01392             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Opcode == BIT_OP) &amp;&amp; (Function == BIS_FUNC)) {
01393                     OpName = <span class="stringliteral">"bis"</span>;
01394 
01395             } <span class="keywordflow">else</span> {
01396                 <span class="keywordflow">break</span>;
01397             }
01398             <span class="keywordflow">if</span> (Instruction.OpReg.RbvType == RBV_REGISTER_FORMAT) {
01399                 <a class="code" href="../../d6/d9/heappage_8c.html#a68">sprintf</a>(Operands, <span class="stringliteral">"%s, %s, %s"</span>, RaName, RbName, RcName);
01400 
01401             } <span class="keywordflow">else</span> {
01402                 <a class="code" href="../../d6/d9/heappage_8c.html#a68">sprintf</a>(Operands, <span class="stringliteral">"%s, $%d, %s"</span>, RaName, Literal8, RcName);
01403             }
01404             <a class="code" href="../../d6/d9/heappage_8c.html#a68">sprintf</a>(Comments, <span class="stringliteral">"%s = %Lx"</span>, RcName, IntegerRegister[Rc]);
01405             <span class="keywordflow">break</span>;
01406 
01407         <span class="keywordflow">case</span> FPOP_OP :
01408             <span class="keywordflow">if</span> (Instruction.FpOp.Function == CPYS_FUNC) {
01409                 OpName = <span class="stringliteral">"cpys"</span>;
01410                 <a class="code" href="../../d6/d9/heappage_8c.html#a68">sprintf</a>(Operands, <span class="stringliteral">"f%d, f%d, f%d"</span>, Ra, Rb, Rc);
01411                 <a class="code" href="../../d6/d9/heappage_8c.html#a68">sprintf</a>(Comments, <span class="stringliteral">"f%d = %Lx"</span>, Rc, FloatingRegister[Rc]);
01412             }
01413             <span class="keywordflow">break</span>;
01414 
01415         <span class="keywordflow">case</span> STT_OP :
01416             OpName = <span class="stringliteral">"stt"</span>;
01417             <a class="code" href="../../d6/d9/heappage_8c.html#a68">sprintf</a>(Operands, <span class="stringliteral">"f%d, $%d(%s)"</span>, Ra, Offset16, RbName);
01418             <a class="code" href="../../d6/d9/heappage_8c.html#a68">sprintf</a>(Comments, <span class="stringliteral">"f%d = %Lx"</span>, Ra, FloatingRegister[Ra]);
01419             <span class="keywordflow">break</span>;
01420         }
01421         <span class="keywordflow">if</span> (OpName == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01422             OpName = <span class="stringliteral">"???"</span>;
01423             <a class="code" href="../../d6/d9/heappage_8c.html#a68">sprintf</a>(Operands, <span class="stringliteral">"..."</span>);
01424             <a class="code" href="../../d6/d9/heappage_8c.html#a68">sprintf</a>(Comments, <span class="stringliteral">"Unknown to virtual unwind."</span>);
01425         }
01426         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"    %p: %08lx  %-5s %-16s // %s\n"</span>,
01427                  ControlPc, Instruction.Long, OpName, Operands, Comments);
01428     }
01429     <span class="keywordflow">return</span>;
01430 }
01431 
01432 <span class="preprocessor">#define _RtlpFoundTrapFrame(NextPc) \</span>
01433 <span class="preprocessor">    if (RtlDebugFlags &amp; RTL_DBG_VIRTUAL_UNWIND) { \</span>
01434 <span class="preprocessor">        DbgPrint("    *** Looks like a trap frame (fake prologue), Fir = %lx\n", \</span>
01435 <span class="preprocessor">                 NextPc); \</span>
01436 <span class="preprocessor">    }</span>
01437 <span class="preprocessor"></span>
01438 <span class="preprocessor">#define _RtlpVirtualUnwindExit(NextPc, ContextRecord, EstablisherFrame) \</span>
01439 <span class="preprocessor">    if (RtlDebugFlags &amp; RTL_DBG_VIRTUAL_UNWIND) { \</span>
01440 <span class="preprocessor">        DbgPrint("RtlVirtualUnwind: EstablisherFrame Virtual = %08lx, Real = %08lx\n", \</span>
01441 <span class="preprocessor">        (EstablisherFrame)-&gt;Virtual, (EstablisherFrame)-&gt;Real); \</span>
01442 <span class="preprocessor">        DbgPrint("RtlVirtualUnwind: returning NextPc = %p, sp = %p\n\n", \</span>
01443 <span class="preprocessor">                 NextPc, (ULONG_PTR)ContextRecord-&gt;IntSp); \</span>
01444 <span class="preprocessor">    }</span>
01445 <span class="preprocessor"></span>
01446 <span class="preprocessor">#else</span>
01447 <span class="preprocessor"></span>
<a name="l01448"></a><a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a4">01448</a> <span class="preprocessor">#define _RtlpDebugDisassemble(ControlPc, ContextRecord)</span>
<a name="l01449"></a><a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a5">01449</a> <span class="preprocessor"></span><span class="preprocessor">#define _RtlpFoundTrapFrame(NextPc)</span>
<a name="l01450"></a><a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a6">01450</a> <span class="preprocessor"></span><span class="preprocessor">#define _RtlpVirtualUnwindExit(NextPc, ContextRecord, EstablisherFrame)</span>
01451 <span class="preprocessor"></span>
01452 <span class="preprocessor">#endif</span>
01453 <span class="preprocessor"></span>
01454 ULONG_PTR
<a name="l01455"></a><a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a21">01455</a> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a> (
01456     IN ULONG_PTR ControlPc,
01457     IN PRUNTIME_FUNCTION FunctionEntry,
01458     IN OUT PCONTEXT ContextRecord,
01459     OUT PBOOLEAN InFunction,
01460     OUT PFRAME_POINTERS EstablisherFrame,
01461     IN OUT PKNONVOLATILE_CONTEXT_POINTERS ContextPointers OPTIONAL
01462     )
01463 
01464 <span class="comment">/*++</span>
01465 <span class="comment"></span>
01466 <span class="comment">Routine Description:</span>
01467 <span class="comment"></span>
01468 <span class="comment">    This function virtually unwinds the specified function by executing its</span>
01469 <span class="comment">    prologue code backwards. Given the current context and the instructions</span>
01470 <span class="comment">    that preserve registers in the prologue, it is possible to recreate the</span>
01471 <span class="comment">    nonvolatile context at the point the function was called.</span>
01472 <span class="comment"></span>
01473 <span class="comment">    If the function is a leaf function, then the address where control left</span>
01474 <span class="comment">    the previous frame is obtained from the context record. If the function</span>
01475 <span class="comment">    is a nested function, but not an exception or interrupt frame, then the</span>
01476 <span class="comment">    prologue code is executed backwards and the address where control left</span>
01477 <span class="comment">    the previous frame is obtained from the updated context record.</span>
01478 <span class="comment"></span>
01479 <span class="comment">    Otherwise, an exception or interrupt entry to the system is being unwound</span>
01480 <span class="comment">    and a specially coded prologue restores the return address twice. Once</span>
01481 <span class="comment">    from the fault instruction address and once from the saved return address</span>
01482 <span class="comment">    register. The first restore is returned as the function value and the</span>
01483 <span class="comment">    second restore is placed in the updated context record.</span>
01484 <span class="comment"></span>
01485 <span class="comment">    During the unwind, the virtual and real frame pointers for the function</span>
01486 <span class="comment">    are calculated and returned in the given frame pointers structure.</span>
01487 <span class="comment"></span>
01488 <span class="comment">    If a context pointers record is specified, then the address where each</span>
01489 <span class="comment">    register is restored from is recorded in the appropriate element of the</span>
01490 <span class="comment">    context pointers record.</span>
01491 <span class="comment"></span>
01492 <span class="comment">Arguments:</span>
01493 <span class="comment"></span>
01494 <span class="comment">    ControlPc - Supplies the address where control left the specified</span>
01495 <span class="comment">        function.</span>
01496 <span class="comment"></span>
01497 <span class="comment">    FunctionEntry - Supplies the address of the function table entry for the</span>
01498 <span class="comment">        specified function.</span>
01499 <span class="comment"></span>
01500 <span class="comment">    ContextRecord - Supplies the address of a context record.</span>
01501 <span class="comment"></span>
01502 <span class="comment">    InFunction - Supplies a pointer to a variable that receives whether the</span>
01503 <span class="comment">        control PC is within the current function.</span>
01504 <span class="comment"></span>
01505 <span class="comment">    EstablisherFrame - Supplies a pointer to a frame pointers structure</span>
01506 <span class="comment">        that will receive the values for the virtual frame pointer and the</span>
01507 <span class="comment">        real frame pointer. The value of the real frame pointer is reliable</span>
01508 <span class="comment">        only when InFunction is TRUE.</span>
01509 <span class="comment"></span>
01510 <span class="comment">    ContextPointers - Supplies an optional pointer to a context pointers</span>
01511 <span class="comment">        record.</span>
01512 <span class="comment"></span>
01513 <span class="comment">Return Value:</span>
01514 <span class="comment"></span>
01515 <span class="comment">    The address where control left the previous frame is returned as the</span>
01516 <span class="comment">    function value.</span>
01517 <span class="comment"></span>
01518 <span class="comment">Implementation Notes:</span>
01519 <span class="comment"></span>
01520 <span class="comment">    N.B. "where control left" is not the "return address" of the call in the</span>
01521 <span class="comment">    previous frame. For normal frames, NextPc points to the last instruction</span>
01522 <span class="comment">    that completed in the previous frame (the JSR/BSR). The difference between</span>
01523 <span class="comment">    NextPc and NextPc + 4 (return address) is important for correct behavior</span>
01524 <span class="comment">    in boundary cases of exception addresses and scope tables.</span>
01525 <span class="comment"></span>
01526 <span class="comment">    For exception and interrupt frames, NextPc is obtained from the trap frame</span>
01527 <span class="comment">    contination address (Fir). For faults and synchronous traps, NextPc is both</span>
01528 <span class="comment">    the last instruction to execute in the previous frame and the next</span>
01529 <span class="comment">    instruction to execute if the function were to return. For asynchronous</span>
01530 <span class="comment">    traps, NextPc is the continuation address. It is the responsibility of the</span>
01531 <span class="comment">    compiler to insert TRAPB instructions to insure asynchronous traps do not</span>
01532 <span class="comment">    occur outside the scope from the instruction(s) that caused them.</span>
01533 <span class="comment"></span>
01534 <span class="comment">    N.B. in this and other files where RtlVirtualUnwind is used, the variable</span>
01535 <span class="comment">    named NextPc is perhaps more accurately, LastPc - the last PC value in</span>
01536 <span class="comment">    the previous frame, or CallPc - the address of the call instruction, or</span>
01537 <span class="comment">    ControlPc - the address where control left the previous frame. Instead</span>
01538 <span class="comment">    think of NextPc as the next PC to use in another call to virtual unwind.</span>
01539 <span class="comment"></span>
01540 <span class="comment">    The Alpha version of virtual unwind is similar in design, but slightly</span>
01541 <span class="comment">    more complex than the Mips version. This is because Alpha compilers</span>
01542 <span class="comment">    are given more flexibility to optimize generated code and instruction</span>
01543 <span class="comment">    sequences, including within procedure prologues. In addition, because of</span>
01544 <span class="comment">    the current inability of the GEM compiler to materialize virtual frame</span>
01545 <span class="comment">    pointers, this function must manage both virtual and real frame pointers.</span>
01546 <span class="comment"></span>
01547 <span class="comment">--*/</span>
01548 
01549 {
01550 
01551     ULONG_PTR Address;
01552     ULONG DecrementOffset;
01553     ULONG DecrementRegister;
01554     ALPHA_INSTRUCTION FollowingInstruction;
01555     PULONGLONG FloatingRegister;
01556     ULONG_PTR FrameSize;
01557     ULONG Function;
01558     ALPHA_INSTRUCTION Instruction;
01559     PULONGLONG IntegerRegister;
01560     ULONG Literal8;
01561     ULONG_PTR NextPc;
01562     LONG Offset16;
01563     ULONG Opcode;
01564     ULONG Ra;
01565     ULONG Rb;
01566     ULONG Rc;
01567     BOOLEAN RestoredRa;
01568     BOOLEAN RestoredSp;
01569     RUNTIME_FUNCTION UnwindFunctionEntry;
01570     ULONG StackAdjust;
01571     ULONG_PTR FixedReturn;
01572 
01573 <span class="preprocessor">#if DBG</span>
01574 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_VIRTUAL_UNWIND) {
01575         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\nRtlVirtualUnwind(ControlPc = %p, FunctionEntry = %p,) sp = %p\n"</span>,
01576                  ControlPc, FunctionEntry, (ULONG_PTR)ContextRecord-&gt;IntSp);
01577     }
01578 <span class="preprocessor">#endif</span>
01579 <span class="preprocessor"></span>
01580     <span class="comment">// Construct a function entry suitable for unwinding from ControlPc</span>
01581 
01582     <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a14">RtlGetUnwindFunctionEntry</a>( ControlPc, FunctionEntry, &amp;UnwindFunctionEntry, &amp;StackAdjust, &amp;FixedReturn );
01583 
01584 <span class="preprocessor">#if DBG</span>
01585 <span class="preprocessor"></span>    ShowRuntimeFunction(&amp;UnwindFunctionEntry, <span class="stringliteral">"RtlVirtualUnwind: unwind function entry"</span> );
01586 <span class="preprocessor">#endif</span>
01587 <span class="preprocessor"></span>    <span class="comment">//</span>
01588     <span class="comment">// Set the base address of the integer and floating register arrays within</span>
01589     <span class="comment">// the context record. Each set of 32 registers is known to be contiguous.</span>
01590     <span class="comment">//</span>
01591 
01592     IntegerRegister = &amp;ContextRecord-&gt;IntV0;
01593     FloatingRegister = &amp;ContextRecord-&gt;FltF0;
01594 
01595     <span class="comment">//</span>
01596     <span class="comment">// Handle the epilogue case where the next instruction is a return.</span>
01597     <span class="comment">//</span>
01598     <span class="comment">// Exception handlers cannot be called if the ControlPc is within the</span>
01599     <span class="comment">// epilogue because exception handlers expect to operate with a current</span>
01600     <span class="comment">// stack frame. The value of SP is not current within the epilogue.</span>
01601     <span class="comment">//</span>
01602 
01603     Instruction.Long = *((PULONG)ControlPc);
01604     <span class="keywordflow">if</span> (IS_RETURN_0001_INSTRUCTION(Instruction.Long)) {
01605         Rb = Instruction.Jump.Rb;
01606         NextPc = (ULONG_PTR)IntegerRegister[Rb] - 4;
01607 
01608         <span class="comment">//</span>
01609         <span class="comment">// The instruction at the point where control left the specified</span>
01610         <span class="comment">// function is a return, so any saved registers have already been</span>
01611         <span class="comment">// restored, and the stack pointer has already been adjusted. The</span>
01612         <span class="comment">// stack does not need to be unwound in this case and the saved</span>
01613         <span class="comment">// return address register is returned as the function value.</span>
01614         <span class="comment">//</span>
01615         <span class="comment">// In fact, reverse execution of the prologue is not possible in</span>
01616         <span class="comment">// this case: the stack pointer has already been incremented and</span>
01617         <span class="comment">// so, for this frame, neither a valid stack pointer nor frame</span>
01618         <span class="comment">// pointer exists from which to begin reverse execution of the</span>
01619         <span class="comment">// prologue. In addition, the integrity of any data on the stack</span>
01620         <span class="comment">// below the stack pointer is never guaranteed (due to interrupts</span>
01621         <span class="comment">// and exceptions).</span>
01622         <span class="comment">//</span>
01623         <span class="comment">// The epilogue instruction sequence is:</span>
01624         <span class="comment">//</span>
01625         <span class="comment">// ==&gt;  ret   zero, (Ra), 1     // return</span>
01626         <span class="comment">// or</span>
01627         <span class="comment">//</span>
01628         <span class="comment">//      mov   ra, Rx            // save return address</span>
01629         <span class="comment">//      ...</span>
01630         <span class="comment">// ==&gt;  ret   zero, (Rx), 1     // return</span>
01631         <span class="comment">//</span>
01632 
01633         EstablisherFrame-&gt;Real = 0;
01634         EstablisherFrame-&gt;Virtual = (ULONG_PTR)ContextRecord-&gt;IntSp;
01635         *InFunction = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01636         <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a4">_RtlpDebugDisassemble</a>(ControlPc, ContextRecord);
01637         <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a6">_RtlpVirtualUnwindExit</a>(NextPc, ContextRecord, EstablisherFrame);
01638         <span class="keywordflow">return</span> NextPc;
01639     }
01640 
01641     <span class="comment">//</span>
01642     <span class="comment">// Handle the epilogue case where the next two instructions are a stack</span>
01643     <span class="comment">// frame deallocation and a return.</span>
01644     <span class="comment">//</span>
01645 
01646     FollowingInstruction.Long = *((PULONG)(ControlPc + 4));
01647     <span class="keywordflow">if</span> (IS_RETURN_0001_INSTRUCTION(FollowingInstruction.Long)) {
01648         Rb = FollowingInstruction.Jump.Rb;
01649         NextPc = (ULONG_PTR)IntegerRegister[Rb] - 4;
01650 
01651         <span class="comment">//</span>
01652         <span class="comment">// The second instruction following the point where control</span>
01653         <span class="comment">// left the specified function is a return. If the instruction</span>
01654         <span class="comment">// before the return is a stack increment instruction, then all</span>
01655         <span class="comment">// saved registers have already been restored except for SP.</span>
01656         <span class="comment">// The value of the stack pointer register cannot be recovered</span>
01657         <span class="comment">// through reverse execution of the prologue because in order</span>
01658         <span class="comment">// to begin reverse execution either the stack pointer or the</span>
01659         <span class="comment">// frame pointer (if any) must still be valid.</span>
01660         <span class="comment">//</span>
01661         <span class="comment">// Instead, the effect that the stack increment instruction</span>
01662         <span class="comment">// would have had on the context is manually applied to the</span>
01663         <span class="comment">// current context. This is forward execution of the epilogue</span>
01664         <span class="comment">// rather than reverse execution of the prologue.</span>
01665         <span class="comment">//</span>
01666         <span class="comment">// In an epilogue, as in a prologue, the stack pointer is always</span>
01667         <span class="comment">// adjusted with a single instruction: either an immediate-value</span>
01668         <span class="comment">// (lda) or a register-value (addq) add instruction.</span>
01669         <span class="comment">//</span>
01670 
01671         Function = Instruction.OpReg.Function;
01672         Offset16 = Instruction.Memory.MemDisp;
01673         Opcode = Instruction.OpReg.Opcode;
01674         Ra = Instruction.OpReg.Ra;
01675         Rb = Instruction.OpReg.Rb;
01676         Rc = Instruction.OpReg.Rc;
01677 
01678         <span class="keywordflow">if</span> ((Opcode == <a class="code" href="../../d5/d5/ia64_2alignem_8c.html#a3">LDA_OP</a>) &amp;&amp; (Ra == SP_REG)) {
01679 
01680             <span class="comment">//</span>
01681             <span class="comment">// Load Address instruction.</span>
01682             <span class="comment">//</span>
01683             <span class="comment">// Since the destination (Ra) register is SP, an immediate-</span>
01684             <span class="comment">// value stack deallocation operation is being performed. The</span>
01685             <span class="comment">// displacement value should be added to SP. The displacement</span>
01686             <span class="comment">// value is assumed to be positive. The amount of stack</span>
01687             <span class="comment">// deallocation possible using this instruction ranges from</span>
01688             <span class="comment">// 16 to 32752 (32768 - 16) bytes. The base register (Rb) is</span>
01689             <span class="comment">// usually SP, but may be another register.</span>
01690             <span class="comment">//</span>
01691             <span class="comment">// The epilogue instruction sequence is:</span>
01692             <span class="comment">//</span>
01693             <span class="comment">// ==&gt;  lda   sp, +N(sp)        // deallocate stack frame</span>
01694             <span class="comment">//      ret   zero, (ra)        // return</span>
01695             <span class="comment">// or</span>
01696             <span class="comment">//</span>
01697             <span class="comment">// ==&gt;  lda   sp, +N(Rx)        // restore SP and deallocate frame</span>
01698             <span class="comment">//      ret   zero, (ra)        // return</span>
01699             <span class="comment">//</span>
01700 
01701             ContextRecord-&gt;IntSp = Offset16 + IntegerRegister[Rb];
01702             EstablisherFrame-&gt;Real = 0;
01703             EstablisherFrame-&gt;Virtual = (ULONG_PTR)ContextRecord-&gt;IntSp;
01704             *InFunction = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01705             <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a4">_RtlpDebugDisassemble</a>(ControlPc, ContextRecord);
01706             <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a4">_RtlpDebugDisassemble</a>(ControlPc + 4, ContextRecord);
01707             <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a6">_RtlpVirtualUnwindExit</a>(NextPc, ContextRecord, EstablisherFrame);
01708             <span class="keywordflow">return</span> NextPc;
01709 
01710         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Opcode == ARITH_OP) &amp;&amp; (Function == ADDQ_FUNC) &amp;&amp;
01711                    (Rc == SP_REG) &amp;&amp;
01712                    (Instruction.OpReg.RbvType == RBV_REGISTER_FORMAT)) {
01713 
01714             <span class="comment">//</span>
01715             <span class="comment">// Add Quadword instruction.</span>
01716             <span class="comment">//</span>
01717             <span class="comment">// Since both source operands are registers, and the</span>
01718             <span class="comment">// destination register is SP, a register-value stack</span>
01719             <span class="comment">// deallocation is being performed. The value of the two</span>
01720             <span class="comment">// source registers should be added and this is the new</span>
01721             <span class="comment">// value of SP. One of the source registers is usually SP,</span>
01722             <span class="comment">// but may be another register.</span>
01723             <span class="comment">//</span>
01724             <span class="comment">// The epilogue instruction sequence is:</span>
01725             <span class="comment">//</span>
01726             <span class="comment">//      ldiq  Rx, N             // set [large] frame size</span>
01727             <span class="comment">//      ...</span>
01728             <span class="comment">// ==&gt;  addq  sp, Rx, sp        // deallocate stack frame</span>
01729             <span class="comment">//      ret   zero, (ra)        // return</span>
01730             <span class="comment">// or</span>
01731             <span class="comment">//</span>
01732             <span class="comment">// ==&gt;  addq  Rx, Ry, sp        // restore SP and deallocate frame</span>
01733             <span class="comment">//      ret   zero, (ra)        // return</span>
01734             <span class="comment">//</span>
01735 
01736             ContextRecord-&gt;IntSp = IntegerRegister[Ra] + IntegerRegister[Rb];
01737             EstablisherFrame-&gt;Real = 0;
01738             EstablisherFrame-&gt;Virtual = (ULONG_PTR)ContextRecord-&gt;IntSp;
01739             *InFunction = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01740             <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a4">_RtlpDebugDisassemble</a>(ControlPc, ContextRecord);
01741             <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a4">_RtlpDebugDisassemble</a>(ControlPc + 4, ContextRecord);
01742             <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a6">_RtlpVirtualUnwindExit</a>(NextPc, ContextRecord, EstablisherFrame);
01743             <span class="keywordflow">return</span> NextPc;
01744         }
01745     }
01746 
01747     <span class="comment">//</span>
01748     <span class="comment">// By default set the frame pointers to the current value of SP.</span>
01749     <span class="comment">//</span>
01750     <span class="comment">// When a procedure is called, the value of SP before the stack</span>
01751     <span class="comment">// allocation instruction is the virtual frame pointer. When reverse</span>
01752     <span class="comment">// executing instructions in the prologue, the value of SP before the</span>
01753     <span class="comment">// stack allocation instruction is encountered is the real frame</span>
01754     <span class="comment">// pointer. This is the current value of SP unless the procedure uses</span>
01755     <span class="comment">// a frame pointer (e.g., FP_REG).</span>
01756     <span class="comment">//</span>
01757 
01758     EstablisherFrame-&gt;Real = (ULONG_PTR)ContextRecord-&gt;IntSp;
01759     EstablisherFrame-&gt;Virtual = (ULONG_PTR)ContextRecord-&gt;IntSp;
01760 
01761     <span class="comment">//</span>
01762     <span class="comment">// If the address where control left the specified function is beyond</span>
01763     <span class="comment">// the end of the prologue, then the control PC is considered to be</span>
01764     <span class="comment">// within the function and the control address is set to the end of</span>
01765     <span class="comment">// the prologue. Otherwise, the control PC is not considered to be</span>
01766     <span class="comment">// within the function (i.e., the prologue).</span>
01767     <span class="comment">//</span>
01768     <span class="comment">// N.B. PrologEndAddress is equal to BeginAddress for a leaf function.</span>
01769     <span class="comment">//</span>
01770     <span class="comment">// The low-order two bits of PrologEndAddress are reserved for the IEEE</span>
01771     <span class="comment">// exception mode and so must be masked out.</span>
01772     <span class="comment">//</span>
01773 
01774     <span class="keywordflow">if</span> ((ControlPc &lt; UnwindFunctionEntry.BeginAddress) ||
01775         (ControlPc &gt;= UnwindFunctionEntry.PrologEndAddress)) {
01776         *InFunction = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01777         ControlPc = (UnwindFunctionEntry.PrologEndAddress &amp; (~(UINT_PTR)0x3));
01778 
01779     } <span class="keywordflow">else</span> {
01780         *InFunction = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01781     }
01782 
01783     <span class="comment">//</span>
01784     <span class="comment">// Scan backward through the prologue to reload callee saved registers</span>
01785     <span class="comment">// that were stored or copied and to increment the stack pointer if it</span>
01786     <span class="comment">// was decremented.</span>
01787     <span class="comment">//</span>
01788 
01789     DecrementRegister = ZERO_REG;
01790     NextPc = (ULONG_PTR)ContextRecord-&gt;IntRa - 4;
01791     RestoredRa = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01792     RestoredSp = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01793     <span class="keywordflow">while</span> (ControlPc &gt; UnwindFunctionEntry.BeginAddress) {
01794 
01795         <span class="comment">//</span>
01796         <span class="comment">// Get instruction value, decode fields, case on opcode value, and</span>
01797         <span class="comment">// reverse register store and stack decrement operations.</span>
01798         <span class="comment">// N.B. The location of Opcode, Ra, Rb, and Rc is the same across</span>
01799         <span class="comment">// all opcode formats. The same is not true for Function.</span>
01800         <span class="comment">//</span>
01801 
01802         ControlPc -= 4;
01803         Instruction.Long = *((PULONG)ControlPc);
01804         Function = Instruction.OpReg.Function;
01805         Literal8 = Instruction.OpLit.Literal;
01806         Offset16 = Instruction.Memory.MemDisp;
01807         Opcode = Instruction.OpReg.Opcode;
01808         Ra = Instruction.OpReg.Ra;
01809         Rb = Instruction.OpReg.Rb;
01810         Rc = Instruction.OpReg.Rc;
01811 
01812         <span class="comment">//</span>
01813         <span class="comment">// Compare against each instruction type that will affect the context</span>
01814         <span class="comment">// and that is allowed in a prologue. Any other instructions found</span>
01815         <span class="comment">// in the prologue will be ignored since they are assumed to have no</span>
01816         <span class="comment">// effect on the context.</span>
01817         <span class="comment">//</span>
01818 
01819         <span class="keywordflow">switch</span> (Opcode) {
01820 
01821         <span class="keywordflow">case</span> STQ_OP :
01822 
01823             <span class="comment">//</span>
01824             <span class="comment">// Store Quad instruction.</span>
01825             <span class="comment">//</span>
01826             <span class="comment">// If the base register is SP, then reload the source register</span>
01827             <span class="comment">// value from the value stored on the stack.</span>
01828             <span class="comment">//</span>
01829             <span class="comment">// The prologue instruction sequence is:</span>
01830             <span class="comment">//</span>
01831             <span class="comment">// ==&gt;  stq   Rx, N(sp)         // save integer register Rx</span>
01832             <span class="comment">//</span>
01833 
01834             <span class="keywordflow">if</span> ((Rb == SP_REG) &amp;&amp; (Ra != ZERO_REG)) {
01835 
01836                 <span class="comment">//</span>
01837                 <span class="comment">// Reload the register by retrieving the value previously</span>
01838                 <span class="comment">// stored on the stack.</span>
01839                 <span class="comment">//</span>
01840 
01841                 Address = Offset16 + (LONG_PTR)ContextRecord-&gt;IntSp;
01842                 IntegerRegister[Ra] = *((PULONGLONG)Address);
01843 
01844                 <span class="comment">//</span>
01845                 <span class="comment">// If the destination register is RA and this is the first</span>
01846                 <span class="comment">// time that RA is being restored, then set the address of</span>
01847                 <span class="comment">// where control left the previous frame. Otherwise, if this</span>
01848                 <span class="comment">// is the second time RA is being restored, then the first</span>
01849                 <span class="comment">// one was an interrupt or exception address and the return</span>
01850                 <span class="comment">// PC should not have been biased by 4.</span>
01851                 <span class="comment">//</span>
01852 
01853                 <span class="keywordflow">if</span> (Ra == RA_REG) {
01854                     <span class="keywordflow">if</span> (RestoredRa == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01855                         NextPc = (ULONG_PTR)ContextRecord-&gt;IntRa - 4;
01856                         RestoredRa = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01857 
01858                     } <span class="keywordflow">else</span> {
01859                         NextPc += 4;
01860                         <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a5">_RtlpFoundTrapFrame</a>(NextPc);
01861                     }
01862 
01863                 <span class="comment">//</span>
01864                 <span class="comment">// Otherwise, if the destination register is SP and this is</span>
01865                 <span class="comment">// the first time that SP is being restored, then set the</span>
01866                 <span class="comment">// establisher frame pointers.</span>
01867                 <span class="comment">//</span>
01868 
01869                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Ra == SP_REG) &amp;&amp; (RestoredSp == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
01870                     EstablisherFrame-&gt;Virtual = (ULONG_PTR)ContextRecord-&gt;IntSp;
01871                     EstablisherFrame-&gt;Real = (ULONG_PTR)ContextRecord-&gt;IntSp;
01872                     RestoredSp = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01873                 }
01874 
01875                 <span class="comment">//</span>
01876                 <span class="comment">// If a context pointer record is specified, then record</span>
01877                 <span class="comment">// the address where the destination register contents</span>
01878                 <span class="comment">// are stored.</span>
01879                 <span class="comment">//</span>
01880 
01881                 <span class="keywordflow">if</span> (ARGUMENT_PRESENT(ContextPointers)) {
01882                     ContextPointers-&gt;IntegerContext[Ra] = (PULONGLONG)Address;
01883                 }
01884                 <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a4">_RtlpDebugDisassemble</a>(ControlPc, ContextRecord);
01885             }
01886             <span class="keywordflow">break</span>;
01887 
01888         <span class="keywordflow">case</span> LDAH_OP :
01889             Offset16 &lt;&lt;= 16;
01890 
01891         <span class="keywordflow">case</span> <a class="code" href="../../d5/d5/ia64_2alignem_8c.html#a3">LDA_OP</a> :
01892 
01893             <span class="comment">//</span>
01894             <span class="comment">// Load Address High, Load Address instruction.</span>
01895             <span class="comment">//</span>
01896             <span class="comment">// There are several cases where the lda and/or ldah instructions</span>
01897             <span class="comment">// are used: one to decrement the stack pointer directly, and the</span>
01898             <span class="comment">// others to load immediate values into another register and that</span>
01899             <span class="comment">// register is then used to decrement the stack pointer.</span>
01900             <span class="comment">//</span>
01901             <span class="comment">// In the examples below, as a single instructions or as a pair,</span>
01902             <span class="comment">// a lda may be substituted for a ldah and visa-versa.</span>
01903             <span class="comment">//</span>
01904 
01905             <span class="keywordflow">if</span> (Ra == SP_REG) {
01906                 <span class="keywordflow">if</span> (Rb == SP_REG) {
01907 
01908                     <span class="comment">//</span>
01909                     <span class="comment">// If both the destination (Ra) and base (Rb) registers</span>
01910                     <span class="comment">// are SP, then a standard stack allocation was performed</span>
01911                     <span class="comment">// and the negated displacement value is the stack frame</span>
01912                     <span class="comment">// size. The amount of stack allocation possible using</span>
01913                     <span class="comment">// the lda instruction ranges from 16 to 32768 bytes and</span>
01914                     <span class="comment">// the amount of stack allocation possible using the ldah</span>
01915                     <span class="comment">// instruction ranges from 65536 to 2GB in multiples of</span>
01916                     <span class="comment">// 65536 bytes. It is rare for the ldah instruction to be</span>
01917                     <span class="comment">// used in this manner.</span>
01918                     <span class="comment">//</span>
01919                     <span class="comment">// The prologue instruction sequence is:</span>
01920                     <span class="comment">//</span>
01921                     <span class="comment">// ==&gt;  lda   sp, -N(sp)    // allocate stack frame</span>
01922                     <span class="comment">//</span>
01923 
01924                     FrameSize = -Offset16;
01925                     <span class="keywordflow">goto</span> StackAllocation;
01926 
01927                 } <span class="keywordflow">else</span> {
01928 
01929                     <span class="comment">//</span>
01930                     <span class="comment">// The destination register is SP and the base register</span>
01931                     <span class="comment">// is not SP, so this instruction must be the second</span>
01932                     <span class="comment">// half of an instruction pair to allocate a large size</span>
01933                     <span class="comment">// (&gt;32768 bytes) stack frame. Save the displacement value</span>
01934                     <span class="comment">// as the partial decrement value and postpone adjusting</span>
01935                     <span class="comment">// the value of SP until the first instruction of the pair</span>
01936                     <span class="comment">// is encountered.</span>
01937                     <span class="comment">//</span>
01938                     <span class="comment">// The prologue instruction sequence is:</span>
01939                     <span class="comment">//</span>
01940                     <span class="comment">//      ldah  Rx, -N(sp)    // prepare new SP (upper)</span>
01941                     <span class="comment">// ==&gt;  lda   sp, sN(Rx)    // allocate stack frame</span>
01942                     <span class="comment">//</span>
01943 
01944                     DecrementRegister = Rb;
01945                     DecrementOffset = Offset16;
01946                     <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a4">_RtlpDebugDisassemble</a>(ControlPc, ContextRecord);
01947                 }
01948 
01949             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Ra == DecrementRegister) {
01950                 <span class="keywordflow">if</span> (Rb == DecrementRegister) {
01951 
01952                     <span class="comment">//</span>
01953                     <span class="comment">// Both the destination and base registers are the</span>
01954                     <span class="comment">// decrement register, so this instruction exists as the</span>
01955                     <span class="comment">// second half of a two instruction pair to load a</span>
01956                     <span class="comment">// 31-bit immediate value into the decrement register.</span>
01957                     <span class="comment">// Save the displacement value as the partial decrement</span>
01958                     <span class="comment">// value.</span>
01959                     <span class="comment">//</span>
01960                     <span class="comment">// The prologue instruction sequence is:</span>
01961                     <span class="comment">//</span>
01962                     <span class="comment">//      ldah  Rx, +N(zero)      // set frame size (upper)</span>
01963                     <span class="comment">// ==&gt;  lda   Rx, sN(Rx)        // set frame size (+lower)</span>
01964                     <span class="comment">//      ...</span>
01965                     <span class="comment">//      subq  sp, Rx, sp        // allocate stack frame</span>
01966                     <span class="comment">//</span>
01967 
01968                     DecrementOffset += Offset16;
01969                     <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a4">_RtlpDebugDisassemble</a>(ControlPc, ContextRecord);
01970 
01971                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Rb == ZERO_REG) {
01972 
01973                     <span class="comment">//</span>
01974                     <span class="comment">// The destination register is the decrement register and</span>
01975                     <span class="comment">// the base register is zero, so this instruction exists</span>
01976                     <span class="comment">// to load an immediate value into the decrement register.</span>
01977                     <span class="comment">// The stack frame size is the new displacement value added</span>
01978                     <span class="comment">// to the previous displacement value, if any.</span>
01979                     <span class="comment">//</span>
01980                     <span class="comment">// The prologue instruction sequence is:</span>
01981                     <span class="comment">//</span>
01982                     <span class="comment">// ==&gt;  lda   Rx, +N(zero)      // set frame size</span>
01983                     <span class="comment">//      ...</span>
01984                     <span class="comment">//      subq  sp, Rx, sp        // allocate stack frame</span>
01985                     <span class="comment">// or</span>
01986                     <span class="comment">//</span>
01987                     <span class="comment">// ==&gt;  ldah  Rx, +N(zero)      // set frame size (upper)</span>
01988                     <span class="comment">//      lda   Rx, sN(Rx)        // set frame size (+lower)</span>
01989                     <span class="comment">//      ...</span>
01990                     <span class="comment">//      subq  sp, Rx, sp        // allocate stack frame</span>
01991                     <span class="comment">//</span>
01992 
01993                     FrameSize = (Offset16 + DecrementOffset);
01994                     <span class="keywordflow">goto</span> StackAllocation;
01995 
01996                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Rb == SP_REG) {
01997 
01998                     <span class="comment">//</span>
01999                     <span class="comment">// The destination (Ra) register is SP and the base (Rb)</span>
02000                     <span class="comment">// register is the decrement register, so a two</span>
02001                     <span class="comment">// instruction, large size (&gt;32768 bytes) stack frame</span>
02002                     <span class="comment">// allocation was performed. Add the new displacement</span>
02003                     <span class="comment">// value to the previous displacement value. The negated</span>
02004                     <span class="comment">// displacement value is the stack frame size.</span>
02005                     <span class="comment">//</span>
02006                     <span class="comment">// The prologue instruction sequence is:</span>
02007                     <span class="comment">//</span>
02008                     <span class="comment">// ==&gt;  ldah  Rx, -N(sp)    // prepare new SP (upper)</span>
02009                     <span class="comment">//      lda   sp, sN(Rx)    // allocate stack frame</span>
02010                     <span class="comment">//</span>
02011 
02012                     FrameSize = -(Offset16 + (LONG)DecrementOffset);
02013                     <span class="keywordflow">goto</span> StackAllocation;
02014                 }
02015             }
02016             <span class="keywordflow">break</span>;
02017 
02018         <span class="keywordflow">case</span> ARITH_OP :
02019 
02020             <span class="keywordflow">if</span> ((Function == ADDQ_FUNC) &amp;&amp;
02021                 (Instruction.OpReg.RbvType != RBV_REGISTER_FORMAT)) {
02022 
02023                 <span class="comment">//</span>
02024                 <span class="comment">// Add Quadword (immediate) instruction.</span>
02025                 <span class="comment">//</span>
02026                 <span class="comment">// If the first source register is zero, and the second</span>
02027                 <span class="comment">// operand is a literal, and the destination register is</span>
02028                 <span class="comment">// the decrement register, then the instruction exists</span>
02029                 <span class="comment">// to load an unsigned immediate value less than 256 into</span>
02030                 <span class="comment">// the decrement register. The immediate value is the stack</span>
02031                 <span class="comment">// frame size.</span>
02032                 <span class="comment">//</span>
02033                 <span class="comment">// The prologue instruction sequence is:</span>
02034                 <span class="comment">//</span>
02035                 <span class="comment">// ==&gt;  addq  zero, N, Rx       // set frame size</span>
02036                 <span class="comment">//      ...</span>
02037                 <span class="comment">//      subq  sp, Rx, sp        // allocate stack frame</span>
02038                 <span class="comment">//</span>
02039 
02040                 <span class="keywordflow">if</span> ((Ra == ZERO_REG) &amp;&amp; (Rc == DecrementRegister)) {
02041                     FrameSize = Literal8;
02042                     <span class="keywordflow">goto</span> StackAllocation;
02043                 }
02044 
02045             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Function == SUBQ_FUNC) &amp;&amp;
02046                        (Instruction.OpReg.RbvType == RBV_REGISTER_FORMAT)) {
02047 
02048                 <span class="comment">//</span>
02049                 <span class="comment">// Subtract Quadword (register) instruction.</span>
02050                 <span class="comment">//</span>
02051                 <span class="comment">// If both source operands are registers and the first</span>
02052                 <span class="comment">// source (minuend) register and the destination</span>
02053                 <span class="comment">// (difference) register are both SP, then a register value</span>
02054                 <span class="comment">// stack allocation was performed and the second source</span>
02055                 <span class="comment">// (subtrahend) register value will be added to SP when its</span>
02056                 <span class="comment">// value is known. Until that time save the register number of</span>
02057                 <span class="comment">// this decrement register.</span>
02058                 <span class="comment">//</span>
02059                 <span class="comment">// The prologue instruction sequence is:</span>
02060                 <span class="comment">//</span>
02061                 <span class="comment">//      ldiq  Rx, N             // set frame size</span>
02062                 <span class="comment">//      ...</span>
02063                 <span class="comment">// ==&gt;  subq  sp, Rx, sp        // allocate stack frame</span>
02064                 <span class="comment">//</span>
02065 
02066                 <span class="keywordflow">if</span> ((Ra == SP_REG) &amp;&amp; (Rc == SP_REG)) {
02067                     DecrementRegister = Rb;
02068                     DecrementOffset = 0;
02069                     <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a4">_RtlpDebugDisassemble</a>(ControlPc, ContextRecord);
02070                 }
02071             }
02072             <span class="keywordflow">break</span>;
02073 
02074         <span class="keywordflow">case</span> BIT_OP :
02075 
02076             <span class="comment">//</span>
02077             <span class="comment">// If the second operand is a register the bit set instruction</span>
02078             <span class="comment">// may be a register move instruction, otherwise if the second</span>
02079             <span class="comment">// operand is a literal, the bit set instruction may be a load</span>
02080             <span class="comment">// immediate value instruction.</span>
02081             <span class="comment">//</span>
02082 
02083             <span class="keywordflow">if</span> ((Function == BIS_FUNC) &amp;&amp; (Rc != ZERO_REG)) {
02084                 <span class="keywordflow">if</span> (Instruction.OpReg.RbvType == RBV_REGISTER_FORMAT) {
02085 
02086                     <span class="comment">//</span>
02087                     <span class="comment">// Bit Set (register move) instruction.</span>
02088                     <span class="comment">//</span>
02089                     <span class="comment">// If both source registers are the same register, or</span>
02090                     <span class="comment">// one of the source registers is zero, then this is a</span>
02091                     <span class="comment">// register move operation. Restore the value of the</span>
02092                     <span class="comment">// source register by copying the current destination</span>
02093                     <span class="comment">// register value back to the source register.</span>
02094                     <span class="comment">//</span>
02095                     <span class="comment">// The prologue instruction sequence is:</span>
02096                     <span class="comment">//</span>
02097                     <span class="comment">// ==&gt;  bis   Rx, Rx, Ry        // copy register Rx</span>
02098                     <span class="comment">// or</span>
02099                     <span class="comment">//</span>
02100                     <span class="comment">// ==&gt;  bis   Rx, zero, Ry      // copy register Rx</span>
02101                     <span class="comment">// or</span>
02102                     <span class="comment">//</span>
02103                     <span class="comment">// ==&gt;  bis   zero, Rx, Ry      // copy register Rx</span>
02104                     <span class="comment">//</span>
02105 
02106                     <span class="keywordflow">if</span> (Ra == ZERO_REG) {
02107 
02108                         <span class="comment">//</span>
02109                         <span class="comment">// Map the third case above to the first case.</span>
02110                         <span class="comment">//</span>
02111 
02112                         Ra = Rb;
02113 
02114                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Rb == ZERO_REG) {
02115 
02116                         <span class="comment">//</span>
02117                         <span class="comment">// Map the second case above to the first case.</span>
02118                         <span class="comment">//</span>
02119 
02120                         Rb = Ra;
02121                     }
02122 
02123                     <span class="keywordflow">if</span> ((Ra == Rb) &amp;&amp; (Ra != ZERO_REG)) {
02124                         IntegerRegister[Ra] = IntegerRegister[Rc];
02125 
02126                         <span class="comment">//</span>
02127                         <span class="comment">// If the destination register is RA and this is the</span>
02128                         <span class="comment">// first time that RA is being restored, then set the</span>
02129                         <span class="comment">// address of where control left the previous frame.</span>
02130                         <span class="comment">// Otherwise, if this is the second time RA is being</span>
02131                         <span class="comment">// restored, then the first one was an interrupt or</span>
02132                         <span class="comment">// exception address and the return PC should not</span>
02133                         <span class="comment">// have been biased by 4.</span>
02134                         <span class="comment">//</span>
02135 
02136                         <span class="keywordflow">if</span> (Ra == RA_REG) {
02137                             <span class="keywordflow">if</span> (RestoredRa == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
02138                                 NextPc = (ULONG_PTR)ContextRecord-&gt;IntRa - 4;
02139                                 RestoredRa = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02140 
02141                             } <span class="keywordflow">else</span> {
02142                                 NextPc += 4;
02143                                 <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a5">_RtlpFoundTrapFrame</a>(NextPc);
02144                             }
02145 
02146                         <span class="comment">//</span>
02147                         <span class="comment">// If the source register is SP and this is the first</span>
02148                         <span class="comment">// time SP is set, then this is a frame pointer set</span>
02149                         <span class="comment">// instruction. Reset the frame pointers to this new</span>
02150                         <span class="comment">// value of SP.</span>
02151                         <span class="comment">//</span>
02152 
02153                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Ra == SP_REG) &amp;&amp; (RestoredSp == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
02154                             EstablisherFrame-&gt;Virtual = (ULONG_PTR)ContextRecord-&gt;IntSp;
02155                             EstablisherFrame-&gt;Real = (ULONG_PTR)ContextRecord-&gt;IntSp;
02156                             RestoredSp = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02157                         }
02158 
02159                         <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a4">_RtlpDebugDisassemble</a>(ControlPc, ContextRecord);
02160                     }
02161 
02162                 } <span class="keywordflow">else</span> {
02163 
02164                     <span class="comment">//</span>
02165                     <span class="comment">// Bit Set (load immediate) instruction.</span>
02166                     <span class="comment">//</span>
02167                     <span class="comment">// If the first source register is zero, and the second</span>
02168                     <span class="comment">// operand is a literal, and the destination register is</span>
02169                     <span class="comment">// the decrement register, then this instruction exists</span>
02170                     <span class="comment">// to load an unsigned immediate value less than 256 into</span>
02171                     <span class="comment">// the decrement register. The decrement register value is</span>
02172                     <span class="comment">// the stack frame size.</span>
02173                     <span class="comment">//</span>
02174                     <span class="comment">// The prologue instruction sequence is:</span>
02175                     <span class="comment">//</span>
02176                     <span class="comment">// ==&gt;  bis   zero, N, Rx       // set frame size</span>
02177                     <span class="comment">//      ...</span>
02178                     <span class="comment">//      subq  sp, Rx, sp        // allocate stack frame</span>
02179                     <span class="comment">//</span>
02180 
02181                     <span class="keywordflow">if</span> ((Ra == ZERO_REG) &amp;&amp; (Rc == DecrementRegister)) {
02182                         FrameSize = Literal8;
02183 StackAllocation:
02184                         <span class="comment">//</span>
02185                         <span class="comment">// Add the frame size to SP to reverse the stack frame</span>
02186                         <span class="comment">// allocation, leave the real frame pointer as is, set</span>
02187                         <span class="comment">// the virtual frame pointer with the updated SP value,</span>
02188                         <span class="comment">// and clear the decrement register.</span>
02189                         <span class="comment">//</span>
02190 
02191                         ContextRecord-&gt;IntSp += FrameSize;
02192                         EstablisherFrame-&gt;Virtual = (ULONG_PTR)ContextRecord-&gt;IntSp;
02193                         DecrementRegister = ZERO_REG;
02194                         <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a4">_RtlpDebugDisassemble</a>(ControlPc, ContextRecord);
02195                     }
02196                 }
02197             }
02198             <span class="keywordflow">break</span>;
02199 
02200         <span class="keywordflow">case</span> STT_OP :
02201 
02202             <span class="comment">//</span>
02203             <span class="comment">// Store T-Floating (quadword integer) instruction.</span>
02204             <span class="comment">//</span>
02205             <span class="comment">// If the base register is SP, then reload the source register</span>
02206             <span class="comment">// value from the value stored on the stack.</span>
02207             <span class="comment">//</span>
02208             <span class="comment">// The prologue instruction sequence is:</span>
02209             <span class="comment">//</span>
02210             <span class="comment">// ==&gt;  stt   Fx, N(sp)         // save floating register Fx</span>
02211             <span class="comment">//</span>
02212 
02213             <span class="keywordflow">if</span> ((Rb == SP_REG) &amp;&amp; (Ra != FZERO_REG)) {
02214 
02215                 <span class="comment">//</span>
02216                 <span class="comment">// Reload the register by retrieving the value previously</span>
02217                 <span class="comment">// stored on the stack.</span>
02218                 <span class="comment">//</span>
02219 
02220                 Address = Offset16 + (LONG_PTR)ContextRecord-&gt;IntSp;
02221                 FloatingRegister[Ra] = *((PULONGLONG)Address);
02222 
02223                 <span class="comment">//</span>
02224                 <span class="comment">// If a context pointer record is specified, then record</span>
02225                 <span class="comment">// the address where the destination register contents are</span>
02226                 <span class="comment">// stored.</span>
02227                 <span class="comment">//</span>
02228 
02229                 <span class="keywordflow">if</span> (ARGUMENT_PRESENT(ContextPointers)) {
02230                     ContextPointers-&gt;FloatingContext[Ra] = (PULONGLONG)Address;
02231                 }
02232                 <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a4">_RtlpDebugDisassemble</a>(ControlPc, ContextRecord);
02233             }
02234             <span class="keywordflow">break</span>;
02235 
02236         <span class="keywordflow">case</span> FPOP_OP :
02237 
02238             <span class="comment">//</span>
02239             <span class="comment">// N.B. The floating operate function field is not the same as</span>
02240             <span class="comment">// the integer operate nor the jump function fields.</span>
02241             <span class="comment">//</span>
02242 
02243             <span class="keywordflow">if</span> (Instruction.FpOp.Function == CPYS_FUNC) {
02244 
02245                 <span class="comment">//</span>
02246                 <span class="comment">// Copy Sign (floating-point move) instruction.</span>
02247                 <span class="comment">//</span>
02248                 <span class="comment">// If both source registers are the same register, then this is</span>
02249                 <span class="comment">// a floating-point register move operation. Restore the value</span>
02250                 <span class="comment">// of the source register by copying the current destination</span>
02251                 <span class="comment">// register value to the source register.</span>
02252                 <span class="comment">//</span>
02253                 <span class="comment">// The prologue instruction sequence is:</span>
02254                 <span class="comment">//</span>
02255                 <span class="comment">// ==&gt;  cpys  Fx, Fx, Fy        // copy floating register Fx</span>
02256                 <span class="comment">//</span>
02257 
02258                 <span class="keywordflow">if</span> ((Ra == Rb) &amp;&amp; (Ra != FZERO_REG)) {
02259                     FloatingRegister[Ra] = FloatingRegister[Rc];
02260                     <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a4">_RtlpDebugDisassemble</a>(ControlPc, ContextRecord);
02261                 }
02262             }
02263 
02264         <span class="keywordflow">default</span> :
02265             <span class="keywordflow">break</span>;
02266         }
02267     }
02268     
02269     <span class="comment">// Check for exlicit stack adjust amount</span>
02270     
02271     <span class="keywordflow">if</span> (StackAdjust) {
02272         ContextRecord-&gt;IntSp += StackAdjust;
02273     }
02274 
02275     <span class="keywordflow">if</span> (FixedReturn != 0) {
02276         NextPc = FixedReturn;
02277     }
02278     
02279     <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a6">_RtlpVirtualUnwindExit</a>(NextPc, ContextRecord, EstablisherFrame);
02280     <span class="keywordflow">return</span> NextPc;
02281 }
02282 
02283 ULONG_PTR
<a name="l02284"></a><a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a11">02284</a> <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a6">RtlpVirtualUnwind</a> (
02285     IN ULONG_PTR ControlPc,
02286     IN PRUNTIME_FUNCTION FunctionEntry,
02287     IN PCONTEXT ContextRecord,
02288     OUT PBOOLEAN InFunction,
02289     OUT PFRAME_POINTERS EstablisherFrame
02290     )
02291 
02292 <span class="comment">/*++</span>
02293 <span class="comment"></span>
02294 <span class="comment">Routine Description:</span>
02295 <span class="comment"></span>
02296 <span class="comment">    This function virtually unwinds the specfified function by executing its</span>
02297 <span class="comment">    prologue code backwards.</span>
02298 <span class="comment"></span>
02299 <span class="comment">    If the function is a leaf function, then the address where control left</span>
02300 <span class="comment">    the previous frame is obtained from the context record. If the function</span>
02301 <span class="comment">    is a nested function, but not an exception or interrupt frame, then the</span>
02302 <span class="comment">    prologue code is executed backwards and the address where control left</span>
02303 <span class="comment">    the previous frame is obtained from the updated context record.</span>
02304 <span class="comment"></span>
02305 <span class="comment">    Otherwise, an exception or interrupt entry to the system is being unwound</span>
02306 <span class="comment">    and a specially coded prologue restores the return address twice. Once</span>
02307 <span class="comment">    from the fault instruction address and once from the saved return address</span>
02308 <span class="comment">    register. The first restore is returned as the function value and the</span>
02309 <span class="comment">    second restore is place in the updated context record.</span>
02310 <span class="comment"></span>
02311 <span class="comment">    If a context pointers record is specified, then the address where each</span>
02312 <span class="comment">    nonvolatile registers is restored from is recorded in the appropriate</span>
02313 <span class="comment">    element of the context pointers record.</span>
02314 <span class="comment"></span>
02315 <span class="comment">    N.B. This function copies the specified context record and only computes</span>
02316 <span class="comment">         the establisher frame and whether control is actually in a function.</span>
02317 <span class="comment"></span>
02318 <span class="comment">Arguments:</span>
02319 <span class="comment"></span>
02320 <span class="comment">    ControlPc - Supplies the address where control left the specified</span>
02321 <span class="comment">        function.</span>
02322 <span class="comment"></span>
02323 <span class="comment">    FunctionEntry - Supplies the address of the function table entry for the</span>
02324 <span class="comment">        specified function.</span>
02325 <span class="comment"></span>
02326 <span class="comment">    ContextRecord - Supplies the address of a context record.</span>
02327 <span class="comment"></span>
02328 <span class="comment">    InFunction - Supplies a pointer to a variable that receives whether the</span>
02329 <span class="comment">        control PC is within the current function.</span>
02330 <span class="comment"></span>
02331 <span class="comment">    EstablisherFrame - Supplies a pointer to a variable that receives the</span>
02332 <span class="comment">        the establisher frame pointer value.</span>
02333 <span class="comment"></span>
02334 <span class="comment">    ContextPointers - Supplies an optional pointer to a context pointers</span>
02335 <span class="comment">        record.</span>
02336 <span class="comment"></span>
02337 <span class="comment">Return Value:</span>
02338 <span class="comment"></span>
02339 <span class="comment">    The address where control left the previous frame is returned as the</span>
02340 <span class="comment">    function value.</span>
02341 <span class="comment"></span>
02342 <span class="comment">--*/</span>
02343 
02344 {
02345 
02346     CONTEXT LocalContext;
02347 
02348     <span class="comment">//</span>
02349     <span class="comment">// Copy the context record so updates will not be reflected in the</span>
02350     <span class="comment">// original copy and then virtually unwind to the caller of the</span>
02351     <span class="comment">// specified control point.</span>
02352     <span class="comment">//</span>
02353 
02354     RtlMoveMemory((PVOID)&amp;LocalContext, ContextRecord, <span class="keyword">sizeof</span>(CONTEXT));
02355     <span class="keywordflow">return</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc,
02356                             FunctionEntry,
02357                             &amp;LocalContext,
02358                             InFunction,
02359                             EstablisherFrame,
02360                             <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
02361 }
02362 
02363 PRUNTIME_FUNCTION
<a name="l02364"></a><a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a22">02364</a> <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a22">RtlLookupDirectFunctionEntry</a> (
02365     IN ULONG_PTR ControlPc
02366     )
02367 
02368 <span class="comment">/*++</span>
02369 <span class="comment"></span>
02370 <span class="comment">Routine Description:</span>
02371 <span class="comment"></span>
02372 <span class="comment">    This function searches the currently active function tables (static and dynamic)</span>
02373 <span class="comment">    for an entry that corresponds to the specified PC value.</span>
02374 <span class="comment"></span>
02375 <span class="comment">Arguments:</span>
02376 <span class="comment"></span>
02377 <span class="comment">    ControlPc - Supplies the address of an instruction within the specified</span>
02378 <span class="comment">        function.</span>
02379 <span class="comment"></span>
02380 <span class="comment">Return Value:</span>
02381 <span class="comment"></span>
02382 <span class="comment">    If there is no entry in the function table for the specified PC, then</span>
02383 <span class="comment">    NULL is returned. Otherwise, the address of the function table entry</span>
02384 <span class="comment">    that corresponds to the specified PC is returned.</span>
02385 <span class="comment"></span>
02386 <span class="comment">--*/</span>
02387 
02388 {
02389     PRUNTIME_FUNCTION FunctionEntry;
02390     BOOLEAN InImage;
02391 
02392     <span class="comment">//</span>
02393     <span class="comment">// look for function entry in static function tables</span>
02394     <span class="comment">//</span>
02395 
02396     FunctionEntry = <a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a9">RtlLookupStaticFunctionEntry</a>( ControlPc, &amp;InImage );
02397 
02398 <span class="preprocessor">#if !defined(NTOS_KERNEL_RUNTIME)</span>
02399 <span class="preprocessor"></span>    <span class="comment">//</span>
02400     <span class="comment">// If not in static image range and no static function entry</span>
02401     <span class="comment">// found then look for a dynamic function entry</span>
02402     <span class="comment">//</span>
02403 
02404     <span class="keywordflow">if</span> (FunctionEntry == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> &amp;&amp; !InImage) {
02405 
02406         FunctionEntry = <a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a10">RtlLookupDynamicFunctionEntry</a>( ControlPc );
02407 
02408     }
02409 <span class="preprocessor">#endif</span>
02410 <span class="preprocessor"></span>
02411 <span class="preprocessor">#if DBG</span>
02412 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_FUNCTION_ENTRY) {
02413         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlLookupDirectFunctionEntry: returning FunctionEntry = %p\n"</span>, FunctionEntry);
02414     }
02415 <span class="preprocessor">#endif</span>
02416 <span class="preprocessor"></span>
02417     <span class="keywordflow">return</span> FunctionEntry;
02418 }
02419 
02420 PRUNTIME_FUNCTION
<a name="l02421"></a><a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a13">02421</a> <a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a9">RtlLookupStaticFunctionEntry</a>(
02422     IN ULONG_PTR ControlPc,
02423     OUT PBOOLEAN InImage
02424     )
02425 
02426 <span class="comment">/*++</span>
02427 <span class="comment"></span>
02428 <span class="comment">Routine Description:</span>
02429 <span class="comment"></span>
02430 <span class="comment">    This function searches the currently active static function tables for an</span>
02431 <span class="comment">    entry that corresponds to the specified PC value.</span>
02432 <span class="comment"></span>
02433 <span class="comment">Arguments:</span>
02434 <span class="comment"></span>
02435 <span class="comment">    ControlPc - Supplies the address of an instruction within the specified</span>
02436 <span class="comment">        function.</span>
02437 <span class="comment"></span>
02438 <span class="comment">    InImage - Address to recieve a flag indicating whether the ControlPc</span>
02439 <span class="comment">        was in the range of a static function table</span>
02440 <span class="comment"></span>
02441 <span class="comment">Return Value:</span>
02442 <span class="comment"></span>
02443 <span class="comment">    If there is no entry in the static function tables for the specified PC,</span>
02444 <span class="comment">    then NULL is returned. Otherwise, the address of the function table entry</span>
02445 <span class="comment">    that corresponds to the specified PC is returned.</span>
02446 <span class="comment"></span>
02447 <span class="comment">--*/</span>
02448 
02449 {
02450     PRUNTIME_FUNCTION FunctionEntry;
02451     PRUNTIME_FUNCTION FunctionTable;
02452     ULONG SizeOfExceptionTable;
02453     LONG High;
02454     PVOID ImageBase;
02455     LONG Low;
02456     LONG Middle;
02457 
02458     <span class="comment">//</span>
02459     <span class="comment">// Search for the image that includes the specified PC value.</span>
02460     <span class="comment">//</span>
02461 
02462     ImageBase = <a class="code" href="../../d6/d4/pctohdr_8c.html#a1">RtlPcToFileHeader</a>((PVOID)ControlPc, &amp;ImageBase);
02463 
02464 <span class="preprocessor">#if DBG</span>
02465 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_FUNCTION_ENTRY) {
02466         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlLookupStaticFunctionEntry(ControlPc = %p) ImageBase = %p\n"</span>,
02467                  ControlPc, ImageBase);
02468     }
02469 <span class="preprocessor">#endif</span>
02470 <span class="preprocessor"></span>
02471     <span class="comment">//</span>
02472     <span class="comment">// If an image is found that includes the specified PC, then locate the</span>
02473     <span class="comment">// function table for the image.</span>
02474     <span class="comment">//</span>
02475 
02476     *InImage = (ImageBase != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
02477     FunctionEntry = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02478     <span class="keywordflow">if</span> (ImageBase != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02479         FunctionTable = (PRUNTIME_FUNCTION)<a class="code" href="../../d8/d9/imagedir_8c.html#a5">RtlImageDirectoryEntryToData</a>(
02480                          ImageBase, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, IMAGE_DIRECTORY_ENTRY_EXCEPTION,
02481                          &amp;SizeOfExceptionTable);
02482 <span class="preprocessor">#if DBG</span>
02483 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_FUNCTION_ENTRY_DETAIL) {
02484             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlLookupStaticFunctionEntry: FunctionTable = %p, SizeOfExceptionTable = %lx\n"</span>,
02485                      FunctionTable, SizeOfExceptionTable);
02486         }
02487 <span class="preprocessor">#endif</span>
02488 <span class="preprocessor"></span>
02489         <span class="comment">//</span>
02490         <span class="comment">// If a function table is located, then search the function table</span>
02491         <span class="comment">// for a function table entry for the specified PC.</span>
02492         <span class="comment">//</span>
02493 
02494         <span class="keywordflow">if</span> (FunctionTable != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02495 
02496             <span class="comment">//</span>
02497             <span class="comment">// Initialize search indicies.</span>
02498             <span class="comment">//</span>
02499 
02500             Low = 0;
02501             High = (SizeOfExceptionTable / <span class="keyword">sizeof</span>(RUNTIME_FUNCTION)) - 1;
02502 
02503             <span class="comment">//</span>
02504             <span class="comment">// Perform binary search on the function table for a function table</span>
02505             <span class="comment">// entry that subsumes the specified PC.</span>
02506             <span class="comment">//</span>
02507 
02508             <span class="keywordflow">while</span> (High &gt;= Low) {
02509 
02510                 <span class="comment">//</span>
02511                 <span class="comment">// Compute next probe index and test entry. If the specified PC</span>
02512                 <span class="comment">// is greater than of equal to the beginning address and less</span>
02513                 <span class="comment">// than the ending address of the function table entry, then</span>
02514                 <span class="comment">// return the address of the function table entry. Otherwise,</span>
02515                 <span class="comment">// continue the search.</span>
02516                 <span class="comment">//</span>
02517 
02518                 Middle = (Low + High) &gt;&gt; 1;
02519                 FunctionEntry = &amp;FunctionTable[Middle];
02520                 <span class="keywordflow">if</span> (ControlPc &lt; RF_BEGIN_ADDRESS(FunctionEntry)) {
02521                     High = Middle - 1;
02522 
02523                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ControlPc &gt;= RF_END_ADDRESS(FunctionEntry)) {
02524                     Low = Middle + 1;
02525 
02526                 } <span class="keywordflow">else</span> {
02527                     <span class="keywordflow">return</span> FunctionEntry;
02528                 }
02529             } <span class="comment">// while (High &gt;= Low)</span>
02530         } <span class="comment">// FunctionTable != NULL</span>
02531     } <span class="comment">// ImageBase != NULL</span>
02532     <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02533 }
02534 
02535 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02536"></a><a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a14">02536</a> <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a14">RtlGetUnwindFunctionEntry</a>(
02537     IN ULONG_PTR ControlPc,
02538     IN PRUNTIME_FUNCTION FunctionEntry,
02539     OUT PRUNTIME_FUNCTION UnwindFunctionEntry,
02540     OUT PULONG StackAdjust,
02541     OUT PULONG_PTR FixedReturn
02542     )
02543 <span class="comment">/*++</span>
02544 <span class="comment"></span>
02545 <span class="comment">Routine Description:</span>
02546 <span class="comment"></span>
02547 <span class="comment">    This function returns a function entry (RUNTIME_FUNCTION) suitable</span>
02548 <span class="comment">    for unwinding from ControlPc. It encapsulates the handling of primary</span>
02549 <span class="comment">    and secondary function entries so that this processing is not duplicated</span>
02550 <span class="comment">    in RtlVirtualUnwind and other similar functions.</span>
02551 <span class="comment"></span>
02552 <span class="comment">Arguments:</span>
02553 <span class="comment"></span>
02554 <span class="comment">    ControlPc - Supplies the address where control left the specified</span>
02555 <span class="comment">        function.</span>
02556 <span class="comment"></span>
02557 <span class="comment">    FunctionEntry - Supplies the address of the function table entry for the</span>
02558 <span class="comment">        specified function.</span>
02559 <span class="comment"></span>
02560 <span class="comment">    UnwindFunctionEntry - Supplies the address of a function table entry which</span>
02561 <span class="comment">        will be setup with appropriate fields for unwinding from ControlPc</span>
02562 <span class="comment"></span>
02563 <span class="comment">    StackAdjust - Receives the optional stack adjustment amount specified</span>
02564 <span class="comment">        in RF_NULL_CONTEXT type secondary function entries. Will be zero</span>
02565 <span class="comment">        if no null-context stack adjustment is required.</span>
02566 <span class="comment">        </span>
02567 <span class="comment">    FixedReturn - Receives the return address specified by fixed-return functin</span>
02568 <span class="comment">        entries. Will be zero if a fixed return address was not specified.</span>
02569 <span class="comment"></span>
02570 <span class="comment">Return Value:</span>
02571 <span class="comment"></span>
02572 <span class="comment">    None.</span>
02573 <span class="comment"></span>
02574 <span class="comment">--*/</span>
02575 
02576 {
02577     ULONG EntryType = 0;
02578     PRUNTIME_FUNCTION SecondaryFunctionEntry = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02579     ULONG_PTR AlternateProlog;
02580 
02581     *FixedReturn = 0;
02582     *StackAdjust = 0;
02583     
02584     <span class="comment">// FunctionEntry should never be null, but if it is create one that</span>
02585     <span class="comment">// looks like a leaf entry for ControlPc</span>
02586 
02587     <span class="keywordflow">if</span> (FunctionEntry == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02588 <span class="preprocessor">#if DBG</span>
02589 <span class="preprocessor"></span>        <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\n****** Warning - Null function table entry for unwinding.\n"</span>);
02590 <span class="preprocessor">#endif</span>
02591 <span class="preprocessor"></span>        UnwindFunctionEntry-&gt;BeginAddress     = ControlPc;
02592         UnwindFunctionEntry-&gt;EndAddress       = ControlPc+4;
02593         UnwindFunctionEntry-&gt;ExceptionHandler = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02594         UnwindFunctionEntry-&gt;HandlerData      = 0;
02595         UnwindFunctionEntry-&gt;PrologEndAddress = ControlPc;
02596         <span class="keywordflow">return</span>;
02597     }
02598 
02599     <span class="comment">//</span>
02600     <span class="comment">// Because of the secondary-to-primary function entry indirection applied by</span>
02601     <span class="comment">// RtlLookupFunctionEntry() ControlPc may not be within the range described</span>
02602     <span class="comment">// by the supplied function entry. Call RtlLookupDirectFunctionEntry()</span>
02603     <span class="comment">// to recover the actual (secondary) function entry.  If we don't get a</span>
02604     <span class="comment">// valid associated function entry then process the unwind with the one</span>
02605     <span class="comment">// supplied, trusting that the caller has supplied the given entry intentionally.</span>
02606     <span class="comment">//</span>
02607     <span class="comment">// A secondary function entry is a RUNTIME_FUNCTION entry where</span>
02608     <span class="comment">// PrologEndAddress is not in the range of BeginAddress to EndAddress.</span>
02609     <span class="comment">// There are three types of secondary function entries. They are</span>
02610     <span class="comment">// distinquished by the Entry Type field (2 bits):</span>
02611     <span class="comment">//</span>
02612     <span class="comment">// RF_NOT_CONTIGUOUS - discontiguous code</span>
02613     <span class="comment">// RF_ALT_ENT_PROLOG - alternate entry point prologue</span>
02614     <span class="comment">// RF_NULL_CONTEXT   - null-context code</span>
02615     <span class="comment">//</span>
02616 
02617     <span class="keywordflow">if</span> ((ControlPc &lt;  RF_BEGIN_ADDRESS(FunctionEntry)) ||
02618         (ControlPc &gt;= RF_END_ADDRESS(FunctionEntry))) {
02619 
02620         <span class="comment">// ControlPC is not in the range of the supplied function entry.</span>
02621         <span class="comment">// Get the actual function entry which is expected to be the</span>
02622         <span class="comment">// associated secondary function entry.</span>
02623 
02624 <span class="preprocessor">#if DBG</span>
02625 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_FUNCTION_ENTRY) {
02626             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\nGetUnwindFunctionEntry:RtlLookupDirectFunctionEntry(ControlPc=%lx)\n"</span>, ControlPc);
02627         }
02628 <span class="preprocessor">#endif</span>
02629 <span class="preprocessor"></span>        SecondaryFunctionEntry = <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a22">RtlLookupDirectFunctionEntry</a>( ControlPc );
02630 
02631         <span class="keywordflow">if</span> (SecondaryFunctionEntry) {
02632             
02633 <span class="preprocessor">#if DBG</span>
02634 <span class="preprocessor"></span>            ShowRuntimeFunction(SecondaryFunctionEntry, <span class="stringliteral">"GetUnwindFunctionEntry: LookupDirectFunctionEntry"</span>);
02635 <span class="preprocessor">#endif</span>
02636 <span class="preprocessor"></span>            
02637             <span class="comment">// If this is a null-context tail region then unwind with a null-context-like descriptor</span>
02638 
02639             <span class="keywordflow">if</span> ((ControlPc &gt;= RF_END_ADDRESS(SecondaryFunctionEntry)-(RF_NULL_CONTEXT_COUNT(SecondaryFunctionEntry)*4)) &amp;&amp;
02640                 (ControlPc &lt;  RF_END_ADDRESS(SecondaryFunctionEntry))) {
02641 
02642                 <span class="comment">// Use the secondary function entry with PrologEndAddress = BeginAddress.</span>
02643                 <span class="comment">// This ensures that the prologue is not reverse executed.</span>
02644 
02645                 UnwindFunctionEntry-&gt;BeginAddress     = RF_BEGIN_ADDRESS(SecondaryFunctionEntry);
02646                 UnwindFunctionEntry-&gt;EndAddress       = RF_END_ADDRESS(SecondaryFunctionEntry);
02647                 UnwindFunctionEntry-&gt;ExceptionHandler = 0;
02648                 UnwindFunctionEntry-&gt;HandlerData      = 0;
02649                 UnwindFunctionEntry-&gt;PrologEndAddress = RF_BEGIN_ADDRESS(SecondaryFunctionEntry);
02650                 <span class="keywordflow">return</span>;
02651             }
02652             
02653             <span class="keywordflow">if</span> ((SecondaryFunctionEntry-&gt;PrologEndAddress &lt; RF_BEGIN_ADDRESS(SecondaryFunctionEntry)) ||
02654                 (SecondaryFunctionEntry-&gt;PrologEndAddress &gt; RF_END_ADDRESS(SecondaryFunctionEntry))) {
02655                 
02656                 <span class="comment">// Got a secondary function entry as expected. But if indirection doesn't point</span>
02657                 <span class="comment">// to FunctionEntry then ignore it and use the caller supplied FunctionEntry.</span>
02658 
02659                 <span class="keywordflow">if</span> (RF_PROLOG_END_ADDRESS(SecondaryFunctionEntry) != (ULONG_PTR)FunctionEntry) {
02660 <span class="preprocessor">#if DBG</span>
02661 <span class="preprocessor"></span>                    <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlGetUnwindFunctionEntry: unexpected secondary function entry from RtlLookupDirectFunctionEntry\n"</span>);
02662 <span class="preprocessor">#endif</span>
02663 <span class="preprocessor"></span>                    SecondaryFunctionEntry = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02664                 }
02665             } <span class="keywordflow">else</span> {
02666 
02667                 <span class="comment">// Got a primary function entry. The only valid type is a</span>
02668                 <span class="comment">// Fixed Return Function Entry, which if present gets processed</span>
02669                 <span class="comment">// at the end.  Even if it is not a fixed return function entry,</span>
02670                 <span class="comment">// use it, since its prolog matches up with the control PC.</span>
02671 
02672                 FunctionEntry = SecondaryFunctionEntry;
02673                 SecondaryFunctionEntry = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02674 
02675 <span class="preprocessor">#if DBG</span>
02676 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (!RF_FIXED_RETURN(FunctionEntry)) {
02677                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlGetUnwindFunctionEntry: unexpected primary function entry from RtlLookupDirectFunctionEntry\n"</span>);
02678                 }
02679 <span class="preprocessor">#endif</span>
02680 <span class="preprocessor"></span>            }
02681 <span class="preprocessor">#if DBG</span>
02682 <span class="preprocessor"></span>        } <span class="keywordflow">else</span> {
02683             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"GetUnwindFunctionEntry: LookupDirectFunctionEntry returned NULL\n"</span>);
02684 <span class="preprocessor">#endif</span>
02685 <span class="preprocessor"></span>        }
02686         
02687     } <span class="keywordflow">else</span> {
02688 
02689         <span class="comment">// ControlPC is in the range of the supplied function entry.</span>
02690         <span class="comment">// Check if it is a secondary function entry. If so, get the</span>
02691         <span class="comment">// associated primary function entry.</span>
02692 
02693         <span class="comment">// If this is a null-context tail region then unwind with a null-context-like descriptor</span>
02694 
02695         <span class="keywordflow">if</span> ((ControlPc &gt;= RF_END_ADDRESS(FunctionEntry)-(RF_NULL_CONTEXT_COUNT(FunctionEntry)*4)) &amp;&amp;
02696             (ControlPc &lt;  RF_END_ADDRESS(FunctionEntry))) {
02697             
02698             <span class="comment">// Create the unwind function entry with PrologEndAddress = BeginAddress.</span>
02699             <span class="comment">// This ensures that the prologue is not reverse executed.</span>
02700 
02701             UnwindFunctionEntry-&gt;BeginAddress     = RF_BEGIN_ADDRESS(FunctionEntry);
02702             UnwindFunctionEntry-&gt;EndAddress       = RF_END_ADDRESS(FunctionEntry);
02703             UnwindFunctionEntry-&gt;ExceptionHandler = 0;
02704             UnwindFunctionEntry-&gt;HandlerData      = 0;
02705             UnwindFunctionEntry-&gt;PrologEndAddress = RF_BEGIN_ADDRESS(FunctionEntry);
02706             <span class="keywordflow">return</span>;
02707         }
02708         
02709         <span class="keywordflow">if</span> ((FunctionEntry-&gt;PrologEndAddress &lt; RF_BEGIN_ADDRESS(FunctionEntry)) ||
02710             (FunctionEntry-&gt;PrologEndAddress &gt; RF_END_ADDRESS(FunctionEntry))) {
02711 
02712             SecondaryFunctionEntry = FunctionEntry;
02713             FunctionEntry = (PRUNTIME_FUNCTION)RF_PROLOG_END_ADDRESS(SecondaryFunctionEntry);
02714 <span class="preprocessor">#if DBG</span>
02715 <span class="preprocessor"></span>            <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlGetUnwindFunctionEntry: received secondary function entry\n"</span>);
02716 <span class="preprocessor">#endif</span>
02717 <span class="preprocessor"></span>        }
02718     }
02719 
02720 <span class="preprocessor">#if DBG</span>
02721 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (ControlPc &amp; 0x3) {
02722         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlGetUnwindFunctionEntry: Warning - Invalid ControlPc %lx for unwinding.\n"</span>, ControlPc);
02723     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (RF_BEGIN_ADDRESS(FunctionEntry) &gt;= RF_END_ADDRESS(FunctionEntry)) {
02724         ShowRuntimeFunction(FunctionEntry, <span class="stringliteral">"RtlGetUnwindFunctionEntry: Warning - BeginAddress &lt; EndAddress."</span>);
02725     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (FunctionEntry-&gt;PrologEndAddress &lt; RF_BEGIN_ADDRESS(FunctionEntry)) {
02726         ShowRuntimeFunction(FunctionEntry, <span class="stringliteral">"RtlGetUnwindFunctionEntry: Warning - PrologEndAddress &lt; BeginAddress."</span>);
02727     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (FunctionEntry-&gt;PrologEndAddress &gt; RF_END_ADDRESS(FunctionEntry)) {
02728         ShowRuntimeFunction(FunctionEntry, <span class="stringliteral">"RtlGetUnwindFunctionEntry: Warning - PrologEndAddress &gt; EndAddress."</span>);
02729     }
02730 <span class="preprocessor">#endif</span>
02731 <span class="preprocessor"></span>
02732     <span class="comment">// FunctionEntry is now the primary function entry and if SecondaryFunctionEntry is</span>
02733     <span class="comment">// not NULL then it is the secondary function entry that contains the ControlPC. Setup a</span>
02734     <span class="comment">// copy of the FunctionEntry suitable for unwinding. By default use the supplied FunctionEntry.</span>
02735 
02736     <span class="keywordflow">if</span> (SecondaryFunctionEntry) {
02737 
02738         <span class="comment">// Extract the secondary function entry type.</span>
02739 
02740         EntryType = RF_ENTRY_TYPE(SecondaryFunctionEntry);
02741 
02742         <span class="keywordflow">if</span> (EntryType == RF_NOT_CONTIGUOUS) {
02743             <span class="comment">// The exception happened in the body of the procedure but in a non-contiguous</span>
02744             <span class="comment">// section of code. Regardless of what entry point was used, it is normally valid</span>
02745             <span class="comment">// to unwind using the primary entry point prologue. The only exception is when an</span>
02746             <span class="comment">// alternate prologue is specified However, there may be an</span>
02747             <span class="comment">// alternate prologue end addresss specified in which case unwind using this</span>
02748             <span class="comment">// block as though it were the primary.</span>
02749     
02750             AlternateProlog = RF_ALT_PROLOG(SecondaryFunctionEntry);
02751     
02752             <span class="keywordflow">if</span> ((AlternateProlog &gt;= RF_BEGIN_ADDRESS(SecondaryFunctionEntry)) &amp;&amp;
02753                 (AlternateProlog &lt;  RF_END_ADDRESS(SecondaryFunctionEntry))) {
02754 
02755                 <span class="comment">// If the control PC is in the alternate prologue, use the secondary.</span>
02756                 <span class="comment">// The control Pc is not in procedure context.</span>
02757 
02758                 <span class="keywordflow">if</span> ((ControlPc &gt;= RF_BEGIN_ADDRESS(SecondaryFunctionEntry)) &amp;&amp;
02759                     (ControlPc &lt;  AlternateProlog)) {
02760 
02761                     UnwindFunctionEntry-&gt;BeginAddress     = RF_BEGIN_ADDRESS(SecondaryFunctionEntry);
02762                     UnwindFunctionEntry-&gt;EndAddress       = RF_END_ADDRESS(SecondaryFunctionEntry);
02763                     UnwindFunctionEntry-&gt;ExceptionHandler = 0;
02764                     UnwindFunctionEntry-&gt;HandlerData      = 0;
02765                     UnwindFunctionEntry-&gt;PrologEndAddress = AlternateProlog;
02766                     <span class="keywordflow">return</span>;
02767                 }
02768             }
02769 
02770             <span class="comment">// Fall out of the if statement to pick up the primary function entry below.</span>
02771             <span class="comment">// This code is in-procedure-context and subject to the primary's prologue</span>
02772             <span class="comment">// and exception handlers.</span>
02773         
02774         
02775         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (EntryType == RF_ALT_ENT_PROLOG) {
02776             
02777             <span class="comment">// Exception occured in an alternate entry point prologue.</span>
02778             <span class="comment">// Use the secondary function entry with a fixed-up PrologEndAddress.</span>
02779 
02780             UnwindFunctionEntry-&gt;BeginAddress     = RF_BEGIN_ADDRESS(SecondaryFunctionEntry);
02781             UnwindFunctionEntry-&gt;EndAddress       = RF_END_ADDRESS(SecondaryFunctionEntry);
02782             UnwindFunctionEntry-&gt;ExceptionHandler = 0;
02783             UnwindFunctionEntry-&gt;HandlerData      = 0;
02784             UnwindFunctionEntry-&gt;PrologEndAddress = RF_END_ADDRESS(UnwindFunctionEntry);
02785             
02786             <span class="comment">// Check for an alternate prologue.</span>
02787             
02788             AlternateProlog = RF_ALT_PROLOG(SecondaryFunctionEntry);
02789             <span class="keywordflow">if</span> (AlternateProlog &gt;= UnwindFunctionEntry-&gt;BeginAddress &amp;&amp;
02790                 AlternateProlog &lt;  UnwindFunctionEntry-&gt;EndAddress ) {
02791                 <span class="comment">// The prologue is only part of the procedure</span>
02792                 UnwindFunctionEntry-&gt;PrologEndAddress = AlternateProlog;
02793             }
02794 
02795             <span class="keywordflow">return</span>;
02796         
02797         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (EntryType == RF_NULL_CONTEXT) {
02798 
02799             <span class="comment">// Exception occured in null-context code associated with a primary function.</span>
02800             <span class="comment">// Use the secondary function entry with a PrologEndAddress = BeginAddress.</span>
02801             <span class="comment">// There is no prologue for null-context code.</span>
02802 
02803             *StackAdjust = RF_STACK_ADJUST(SecondaryFunctionEntry);
02804             UnwindFunctionEntry-&gt;BeginAddress     = RF_BEGIN_ADDRESS(SecondaryFunctionEntry);
02805             UnwindFunctionEntry-&gt;EndAddress       = RF_END_ADDRESS(SecondaryFunctionEntry);
02806             UnwindFunctionEntry-&gt;ExceptionHandler = 0;
02807             UnwindFunctionEntry-&gt;HandlerData      = 0;
02808             UnwindFunctionEntry-&gt;PrologEndAddress = RF_BEGIN_ADDRESS(SecondaryFunctionEntry);
02809             <span class="keywordflow">return</span>;
02810         }
02811 
02812     }
02813     
02814     <span class="comment">// Use the primary function entry</span>
02815     
02816     *UnwindFunctionEntry = *FunctionEntry;
02817     UnwindFunctionEntry-&gt;EndAddress = RF_END_ADDRESS(UnwindFunctionEntry);  <span class="comment">// Remove null-context count</span>
02818     
02819     <span class="comment">// If the primary has a fixed return address, pull that out now.</span>
02820 
02821     <span class="keywordflow">if</span> (RF_IS_FIXED_RETURN(FunctionEntry)) {
02822         *FixedReturn = RF_FIXED_RETURN(FunctionEntry);
02823         UnwindFunctionEntry-&gt;ExceptionHandler = 0;
02824         UnwindFunctionEntry-&gt;HandlerData      = 0;
02825     }
02826 
02827     <span class="comment">// If the ControlPc is in the primary Null context, return null context.</span>
02828     <span class="comment">// Otherwise, remove Null context count</span>
02829 
02830     <span class="keywordflow">if</span> ((ControlPc &gt;= RF_END_ADDRESS(FunctionEntry)-(RF_NULL_CONTEXT_COUNT(FunctionEntry)*4)) &amp;&amp;
02831         (ControlPc &lt;  RF_END_ADDRESS(FunctionEntry))) {
02832 
02833         <span class="comment">// Exception occured in null-context code associated with a primary function.</span>
02834         <span class="comment">// Create the unwind function entry with a PrologEndAddress = BeginAddress.</span>
02835         <span class="comment">// This ensures that the prologue is not reverse executed.</span>
02836 
02837         UnwindFunctionEntry-&gt;EndAddress       = RF_END_ADDRESS(FunctionEntry);
02838         UnwindFunctionEntry-&gt;ExceptionHandler = 0;
02839         UnwindFunctionEntry-&gt;HandlerData      = 0;
02840         UnwindFunctionEntry-&gt;PrologEndAddress = RF_BEGIN_ADDRESS(FunctionEntry);
02841     }
02842     <span class="keywordflow">else</span> {
02843         UnwindFunctionEntry-&gt;EndAddress       = RF_END_ADDRESS(FunctionEntry);
02844     }
02845 }
02846 <span class="preprocessor">#if !defined(NTOS_KERNEL_RUNTIME)</span>
02847 <span class="preprocessor"></span>
02848 PLIST_ENTRY
<a name="l02849"></a><a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a23">02849</a> <a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a23">RtlGetFunctionTableListHead</a> (
02850     VOID
02851     )
02852 
02853 <span class="comment">/*++</span>
02854 <span class="comment"></span>
02855 <span class="comment">Routine Description:</span>
02856 <span class="comment"></span>
02857 <span class="comment">    Return the address of the dynamic function table list head.</span>
02858 <span class="comment"></span>
02859 <span class="comment">Return value:</span>
02860 <span class="comment"></span>
02861 <span class="comment">    Address of dynamic function table list head.</span>
02862 <span class="comment"></span>
02863 <span class="comment">--*/</span>
02864 {
02865     <span class="keywordflow">return</span> &amp;<a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a7">DynamicFunctionTable</a>;
02866 }
02867 
02868 BOOLEAN
<a name="l02869"></a><a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a24">02869</a> <a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a24">RtlAddFunctionTable</a>(
02870     IN PRUNTIME_FUNCTION FunctionTable,
02871     IN ULONG EntryCount
02872     )
02873 
02874 <span class="comment">/*++</span>
02875 <span class="comment"></span>
02876 <span class="comment">Routine Description:</span>
02877 <span class="comment"></span>
02878 <span class="comment">    Add a dynamic function table to the dynamic function table list. Dynamic</span>
02879 <span class="comment">    function tables describe code generated at run-time. The dynamic function</span>
02880 <span class="comment">    tables are searched via a call to RtlLookupDynamicFunctionEntry().</span>
02881 <span class="comment">    Normally this is only invoked via calls to RtlLookupFunctionEntry().</span>
02882 <span class="comment"></span>
02883 <span class="comment">    The FunctionTable entries need not be sorted in any particular order. The</span>
02884 <span class="comment">    list is scanned for a Min and Max address range and whether or not it is</span>
02885 <span class="comment">    sorted. If the latter RtlLookupDynamicFunctionEntry() uses a binary</span>
02886 <span class="comment">    search, otherwise it uses a linear search.</span>
02887 <span class="comment"></span>
02888 <span class="comment">    The dynamic function entries will be searched only after a search</span>
02889 <span class="comment">    through the static function entries associated with all current</span>
02890 <span class="comment">    process images has failed.</span>
02891 <span class="comment"></span>
02892 <span class="comment">Arguments:</span>
02893 <span class="comment"></span>
02894 <span class="comment">   FunctionTable       Address of an array of function entries where</span>
02895 <span class="comment">                       each element is of type RUNTIME_FUNCTION.</span>
02896 <span class="comment"></span>
02897 <span class="comment">   EntryCount          The number of function entries in the array</span>
02898 <span class="comment"></span>
02899 <span class="comment">Return value:</span>
02900 <span class="comment"></span>
02901 <span class="comment">   TRUE                if RtlAddFunctionTable completed successfully</span>
02902 <span class="comment">   FALSE               if RtlAddFunctionTable completed unsuccessfully</span>
02903 <span class="comment"></span>
02904 <span class="comment">--*/</span>
02905 {
02906     PDYNAMIC_FUNCTION_TABLE pNew;
02907     PRUNTIME_FUNCTION FunctionEntry;
02908     ULONG i;
02909 
02910     <span class="keywordflow">if</span> (EntryCount == 0)
02911         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02912 
02913     <span class="comment">//</span>
02914     <span class="comment">// Make sure the link list is initialized;</span>
02915     <span class="comment">//</span>
02916 
02917     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a7">DynamicFunctionTable</a>.Flink == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02918        InitializeListHead(&amp;<a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a7">DynamicFunctionTable</a>);
02919     }
02920 
02921     <span class="comment">//</span>
02922     <span class="comment">//  Allocate memory for this link list entry</span>
02923     <span class="comment">//</span>
02924 
02925     pNew = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>( RtlProcessHeap(), 0, <span class="keyword">sizeof</span>(DYNAMIC_FUNCTION_TABLE) );
02926 
02927     <span class="keywordflow">if</span> (pNew != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02928         pNew-&gt;FunctionTable = FunctionTable;
02929         pNew-&gt;EntryCount = EntryCount;
02930         NtQuerySystemTime( &amp;pNew-&gt;TimeStamp );
02931 
02932         <span class="comment">//</span>
02933         <span class="comment">// Scan the function table for Minimum/Maximum and to determine</span>
02934         <span class="comment">// if it is sorted. If the latter, we can perform a binary search.</span>
02935         <span class="comment">//</span>
02936 
02937         FunctionEntry = FunctionTable;
02938         pNew-&gt;MinimumAddress = RF_BEGIN_ADDRESS(FunctionEntry);
02939         pNew-&gt;MaximumAddress = RF_END_ADDRESS(FunctionEntry);
02940         pNew-&gt;Sorted = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02941         FunctionEntry++;
02942 
02943         <span class="keywordflow">for</span> (i = 1; i &lt; EntryCount; FunctionEntry++, i++) {
02944             <span class="keywordflow">if</span> (pNew-&gt;Sorted &amp;&amp; FunctionEntry-&gt;BeginAddress &lt; FunctionTable[i-1].BeginAddress) {
02945                 pNew-&gt;Sorted = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02946             }
02947             <span class="keywordflow">if</span> (FunctionEntry-&gt;BeginAddress &lt; pNew-&gt;MinimumAddress) {
02948                 pNew-&gt;MinimumAddress = RF_BEGIN_ADDRESS(FunctionEntry);
02949             }
02950             <span class="keywordflow">if</span> (FunctionEntry-&gt;EndAddress &gt; pNew-&gt;MaximumAddress) {
02951                 pNew-&gt;MaximumAddress = RF_END_ADDRESS(FunctionEntry);
02952             }
02953         }
02954 
02955         <span class="comment">//</span>
02956         <span class="comment">// Insert the new entry in the dynamic function table list.</span>
02957         <span class="comment">// Protect the insertion with the loader lock.</span>
02958         <span class="comment">//</span>
02959 
02960         RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()-&gt;<a class="code" href="../../d8/d2/ldrinit_8c.html#a12">LoaderLock</a>);
02961         InsertTailList((PLIST_ENTRY)&amp;<a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a7">DynamicFunctionTable</a>, (PLIST_ENTRY)pNew);
02962         RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()-&gt;<a class="code" href="../../d8/d2/ldrinit_8c.html#a12">LoaderLock</a>);
02963 
02964         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02965     } <span class="keywordflow">else</span> {
02966         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02967     }
02968 }
02969 
02970 BOOLEAN
<a name="l02971"></a><a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a25">02971</a> <a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a25">RtlDeleteFunctionTable</a> (
02972     IN PRUNTIME_FUNCTION FunctionTable
02973     )
02974 {
02975 
02976 <span class="comment">/*++</span>
02977 <span class="comment"></span>
02978 <span class="comment">Routine Description:</span>
02979 <span class="comment"></span>
02980 <span class="comment">    Remove a dynamic function table from the dynamic function table list.</span>
02981 <span class="comment"></span>
02982 <span class="comment">Arguments:</span>
02983 <span class="comment"></span>
02984 <span class="comment">   FunctionTable       Address of an array of function entries that</span>
02985 <span class="comment">                       was passed in a previous call to RtlAddFunctionTable</span>
02986 <span class="comment"></span>
02987 <span class="comment">Return Value</span>
02988 <span class="comment"></span>
02989 <span class="comment">    TRUE - If function completed successfully</span>
02990 <span class="comment">    FALSE - If function completed unsuccessfully</span>
02991 <span class="comment"></span>
02992 <span class="comment">--*/</span>
02993 
02994     PDYNAMIC_FUNCTION_TABLE CurrentEntry;
02995     PLIST_ENTRY Head;
02996     PLIST_ENTRY Next;
02997     BOOLEAN <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02998 
02999     RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()-&gt;<a class="code" href="../../d8/d2/ldrinit_8c.html#a12">LoaderLock</a>);
03000 
03001     <span class="comment">//</span>
03002     <span class="comment">// Search the dynamic function table list for a match on the the function</span>
03003     <span class="comment">// table address.</span>
03004     <span class="comment">//</span>
03005 
03006     Head = &amp;<a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a7">DynamicFunctionTable</a>;
03007     <span class="keywordflow">for</span> (Next = Head-&gt;Blink; Next != Head; Next = Next-&gt;Blink) {
03008         CurrentEntry = CONTAINING_RECORD(Next,DYNAMIC_FUNCTION_TABLE,Links);
03009         <span class="keywordflow">if</span> (CurrentEntry-&gt;FunctionTable == FunctionTable) {
03010             RemoveEntryList((PLIST_ENTRY)CurrentEntry);
03011             <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( RtlProcessHeap(), 0, CurrentEntry );
03012             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03013             <span class="keywordflow">break</span>;
03014         }
03015     }
03016 
03017     RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()-&gt;<a class="code" href="../../d8/d2/ldrinit_8c.html#a12">LoaderLock</a>);
03018     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
03019 }
03020 
03021 PRUNTIME_FUNCTION
<a name="l03022"></a><a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a12">03022</a> <a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a10">RtlLookupDynamicFunctionEntry</a>(
03023     IN ULONG_PTR ControlPc
03024     )
03025 
03026 <span class="comment">/*++</span>
03027 <span class="comment"></span>
03028 <span class="comment">Routine Description:</span>
03029 <span class="comment"></span>
03030 <span class="comment">  This function searches through the dynamic function entry</span>
03031 <span class="comment">  tables and returns the function entry address that corresponds</span>
03032 <span class="comment">  to the specified ControlPc. This routine does NOT perform the</span>
03033 <span class="comment">  secondary function entry indirection. That is performed</span>
03034 <span class="comment">  by RtlLookupFunctionEntry().</span>
03035 <span class="comment"></span>
03036 <span class="comment">  Argument:</span>
03037 <span class="comment"></span>
03038 <span class="comment">     ControlPc           Supplies a ControlPc.</span>
03039 <span class="comment"></span>
03040 <span class="comment">  Return Value</span>
03041 <span class="comment"></span>
03042 <span class="comment">     NULL - No function entry found that contains the ControlPc.</span>
03043 <span class="comment"></span>
03044 <span class="comment">     NON-NULL - Address of the function entry that describes the</span>
03045 <span class="comment">                code containing ControlPC.</span>
03046 <span class="comment"></span>
03047 <span class="comment">--*/</span>
03048 
03049 {
03050     PDYNAMIC_FUNCTION_TABLE CurrentEntry;
03051     PLIST_ENTRY Next,Head;
03052     PRUNTIME_FUNCTION FunctionTable;
03053     PRUNTIME_FUNCTION FunctionEntry;
03054     LONG High;
03055     LONG Low;
03056     LONG Middle;
03057 
03058     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a7">DynamicFunctionTable</a>.Flink == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)
03059         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03060 
03061     <span class="keywordflow">if</span> (RtlTryEnterCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()-&gt;<a class="code" href="../../d8/d2/ldrinit_8c.html#a12">LoaderLock</a>) ) {
03062 
03063         <span class="comment">//</span>
03064         <span class="comment">//  Search the tree starting from the head, continue until the entry</span>
03065         <span class="comment">//  is found or we reach the end of the list.</span>
03066         <span class="comment">//</span>
03067 
03068         Head = &amp;<a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a7">DynamicFunctionTable</a>;
03069         <span class="keywordflow">for</span> (Next = Head-&gt;Blink; Next != Head; Next = Next-&gt;Blink) {
03070             CurrentEntry = CONTAINING_RECORD(Next,DYNAMIC_FUNCTION_TABLE,Links);
03071             FunctionTable = CurrentEntry-&gt;FunctionTable;
03072 
03073             <span class="comment">//</span>
03074             <span class="comment">// Check if the ControlPC is within the range of this function table</span>
03075             <span class="comment">//</span>
03076 
03077             <span class="keywordflow">if</span> ((ControlPc &gt;= CurrentEntry-&gt;MinimumAddress) &amp;&amp;
03078                 (ControlPc &lt;  CurrentEntry-&gt;MaximumAddress) ) {
03079 
03080                 <span class="comment">// If this function table is sorted do a binary search.</span>
03081 
03082                 <span class="keywordflow">if</span> (CurrentEntry-&gt;Sorted) {
03083 
03084                     <span class="comment">//</span>
03085                     <span class="comment">// Perform binary search on the function table for a function table</span>
03086                     <span class="comment">// entry that subsumes the specified PC.</span>
03087                     <span class="comment">//</span>
03088 
03089                     Low = 0;
03090                     High = CurrentEntry-&gt;EntryCount -1 ;
03091                     <span class="keywordflow">while</span> (High &gt;= Low) {
03092 
03093                         <span class="comment">//</span>
03094                         <span class="comment">// Compute next probe index and test entry. If the specified PC</span>
03095                         <span class="comment">// is greater than of equal to the beginning address and less</span>
03096                         <span class="comment">// than the ending address of the function table entry, then</span>
03097                         <span class="comment">// return the address of the function table entry. Otherwise,</span>
03098                         <span class="comment">// continue the search.</span>
03099                         <span class="comment">//</span>
03100 
03101                         Middle = (Low + High) &gt;&gt; 1;
03102                         FunctionEntry = &amp;FunctionTable[Middle];
03103                         <span class="keywordflow">if</span> (ControlPc &lt; RF_BEGIN_ADDRESS(FunctionEntry)) {
03104                             High = Middle - 1;
03105 
03106                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ControlPc &gt;= RF_END_ADDRESS(FunctionEntry)) {
03107                             Low = Middle + 1;
03108 
03109                         } <span class="keywordflow">else</span> {
03110 <span class="preprocessor">#if DBG</span>
03111 <span class="preprocessor"></span>                            ShowRuntimeFunction(FunctionEntry, <span class="stringliteral">"RtlLookupDynamicFunctionEntry: binary search"</span> );
03112 <span class="preprocessor">#endif</span>
03113 <span class="preprocessor"></span>                            RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()-&gt;<a class="code" href="../../d8/d2/ldrinit_8c.html#a12">LoaderLock</a>);
03114                             <span class="keywordflow">return</span> FunctionEntry;
03115                         }
03116                     }
03117 
03118                 } <span class="keywordflow">else</span> {    <span class="comment">// Not sorted. Do linear search.</span>
03119 
03120                     PRUNTIME_FUNCTION LastFunctionEntry = &amp;FunctionTable[CurrentEntry-&gt;EntryCount];
03121 
03122                     <span class="keywordflow">for</span> (FunctionEntry = FunctionTable; FunctionEntry &lt; LastFunctionEntry; FunctionEntry++) {
03123                         <span class="keywordflow">if</span> ((ControlPc &gt;= RF_BEGIN_ADDRESS(FunctionEntry)) &amp;&amp;
03124                             (ControlPc &lt;  RF_END_ADDRESS(FunctionEntry))) {
03125 <span class="preprocessor">#if DBG</span>
03126 <span class="preprocessor"></span>                            ShowRuntimeFunction(FunctionEntry, <span class="stringliteral">"RtlLookupDynamicFunctionEntry: linear search"</span> );
03127 <span class="preprocessor">#endif</span>
03128 <span class="preprocessor"></span>                            RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()-&gt;<a class="code" href="../../d8/d2/ldrinit_8c.html#a12">LoaderLock</a>);
03129                             <span class="keywordflow">return</span> FunctionEntry;
03130                         }
03131                     }
03132                 } <span class="comment">// binary/linear search</span>
03133             } <span class="comment">// if in range</span>
03134         } <span class="comment">// for (... Next != Head ...)</span>
03135 
03136         RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()-&gt;<a class="code" href="../../d8/d2/ldrinit_8c.html#a12">LoaderLock</a>);
03137     } <span class="comment">// LoaderLock</span>
03138 
03139     
03140     <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03141 }
03142 <span class="preprocessor">#endif</span>
03143 <span class="preprocessor"></span><span class="preprocessor">#if DBG</span>
03144 <span class="preprocessor"></span>
03145 <span class="keywordtype">void</span>
03146 ShowRuntimeFunction( PRUNTIME_FUNCTION FunctionEntry, PSTR Label )
03147 {
03148     BOOLEAN Secondary;
03149     BOOLEAN FixedReturn;
03150     ULONG EntryType;
03151     ULONG NullCount;
03152     
03153     <span class="keywordflow">if</span> (!(RtlDebugFlags &amp; RTL_DBG_FUNCTION_ENTRY_DETAIL)) {
03154         <span class="keywordflow">return</span>;
03155     }
03156     
03157     <span class="keywordflow">if</span> (FunctionEntry) {
03158         Secondary = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03159         FixedReturn = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03160         EntryType = 0;
03161         NullCount = 0;
03162         
03163         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"    %lx: %s\n"</span>, FunctionEntry, Label );
03164         
03165         <span class="keywordflow">if</span> ((RF_PROLOG_END_ADDRESS(FunctionEntry) &lt; RF_BEGIN_ADDRESS(FunctionEntry)) ||
03166             (RF_PROLOG_END_ADDRESS(FunctionEntry) &gt; RF_END_ADDRESS(FunctionEntry))) {
03167             Secondary = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03168             EntryType = RF_ENTRY_TYPE(FunctionEntry);
03169         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (RF_IS_FIXED_RETURN(FunctionEntry)) {
03170             FixedReturn = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03171         }
03172         NullCount = RF_NULL_CONTEXT_COUNT(FunctionEntry);
03173     
03174         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"    BeginAddress     = %lx\n"</span>, FunctionEntry-&gt;BeginAddress);
03175         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"    EndAddress       = %lx"</span>, FunctionEntry-&gt;EndAddress);
03176         <span class="keywordflow">if</span> (NullCount) {
03177             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">" %d null-context instructions"</span>, NullCount);
03178         }
03179         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\n"</span>);
03180         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"    ExceptionHandler = %lx"</span>, FunctionEntry-&gt;ExceptionHandler);
03181         <span class="keywordflow">if</span> (FunctionEntry-&gt;ExceptionHandler != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03182             <span class="keywordflow">if</span> (Secondary) {
03183                 ULONG_PTR AlternateProlog = RF_ALT_PROLOG(FunctionEntry);
03184     
03185                 <span class="keywordflow">switch</span>( EntryType ) {
03186                 <span class="keywordflow">case</span> RF_NOT_CONTIGUOUS:
03187                 <span class="keywordflow">case</span> RF_ALT_ENT_PROLOG:
03188                     
03189                     <span class="keywordflow">if</span> ((AlternateProlog &gt;= RF_BEGIN_ADDRESS(FunctionEntry)) &amp;&amp;
03190                         (AlternateProlog &lt;= RF_END_ADDRESS(FunctionEntry))) {
03191                             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">" alternate PrologEndAddress"</span>);
03192                     }
03193                     <span class="keywordflow">break</span>;
03194                 <span class="keywordflow">case</span> RF_NULL_CONTEXT:
03195                     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">" stack adjustment"</span>);
03196                 <span class="keywordflow">default</span>:
03197                     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">" invalid entry type"</span>);
03198                 }
03199             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (FixedReturn) {
03200                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">" fixed return address"</span>);
03201             }
03202         }
03203         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\n"</span>);
03204         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"    HandlerData      = %lx"</span>, FunctionEntry-&gt;HandlerData);
03205         <span class="keywordflow">if</span> (Secondary) {
03206             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">" type %d: "</span>, EntryType);
03207             <span class="keywordflow">if</span>      (EntryType == RF_NOT_CONTIGUOUS) <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RF_NOT_CONTIGUOUS"</span>);
03208             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (EntryType == RF_ALT_ENT_PROLOG) <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RF_ALT_ENT_PROLOG"</span>);
03209             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (EntryType == RF_NULL_CONTEXT)   <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RF_NULL_CONTEXT"</span>);
03210             <span class="keywordflow">else</span> <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"***INVALID***"</span>);
03211         }
03212         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\n"</span>);
03213         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"    PrologEndAddress = %lx\n"</span>,   FunctionEntry-&gt;PrologEndAddress );
03214     }
03215 }
03216 <span class="preprocessor">#endif</span>
03217 <span class="preprocessor"></span>
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:39:57 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
