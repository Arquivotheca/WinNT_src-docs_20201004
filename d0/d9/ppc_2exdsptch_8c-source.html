<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: exdsptch.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>exdsptch.c</h1><a href="../../d9/d9/ppc_2exdsptch_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1993  IBM Corporation and Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    exdsptch.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module implements the dispatching of exception and the unwinding of</span>
00012 <span class="comment">    procedure call frames for PowerPC.</span>
00013 <span class="comment"></span>
00014 <span class="comment">Author:</span>
00015 <span class="comment"></span>
00016 <span class="comment">    Rick Simpson  16-Aug-1993</span>
00017 <span class="comment"></span>
00018 <span class="comment">    based on MIPS version by David N. Cutler (davec) 11-Sep-1990</span>
00019 <span class="comment"></span>
00020 <span class="comment">Environment:</span>
00021 <span class="comment"></span>
00022 <span class="comment">    Any mode.</span>
00023 <span class="comment"></span>
00024 <span class="comment">Revision History:</span>
00025 <span class="comment"></span>
00026 <span class="comment">    Tom Wood (twood) 19-Aug-1994</span>
00027 <span class="comment">    Update to use RtlVirtualUnwind even when there isn't a function table</span>
00028 <span class="comment">    entry.  Add stack limit parameters to RtlVirtualUnwind.</span>
00029 <span class="comment"></span>
00030 <span class="comment">    Changed RtlLookupFunctionEntry to deal with the indirect entries.</span>
00031 <span class="comment"></span>
00032 <span class="comment">--*/</span>
00033 
00034 <span class="preprocessor">#include "<a class="code" href="../../d5/d9/ntrtlp_8h.html">ntrtlp.h</a>"</span>
00035 
00036 <span class="comment">//</span>
00037 <span class="comment">// Define local macros.</span>
00038 <span class="comment">//</span>
00039 
00040 <span class="preprocessor">#ifndef ROS_DEBUG</span>
00041 <span class="preprocessor"></span><span class="preprocessor">#ifndef READ_ULONG</span>
<a name="l00042"></a><a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a0">00042</a> <span class="preprocessor"></span><span class="preprocessor">#define READ_ULONG(addr,dest) dest = (*((PULONG)(addr)))</span>
<a name="l00043"></a><a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a1">00043</a> <span class="preprocessor"></span><span class="preprocessor">#define READ_DOUBLE(addr,dest) dest = (*((PDOUBLE)(addr)))</span>
00044 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00045 <span class="preprocessor"></span>
00046 <span class="preprocessor">#include "<a class="code" href="../../d0/d7/ppc_2vunwind_8c.html">vunwind.c</a>"</span>
00047 <span class="preprocessor">#endif // ROS_DEBUG</span>
00048 <span class="preprocessor"></span>
00049 <span class="comment">//</span>
00050 <span class="comment">// Define local macros.</span>
00051 <span class="comment">//</span>
00052 <span class="comment">// Raise noncontinuable exception with associated exception record.</span>
00053 <span class="comment">//</span>
00054 
<a name="l00055"></a><a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a2">00055</a> <span class="preprocessor">#define RAISE_EXCEPTION(Status, ExceptionRecordt) { \</span>
00056 <span class="preprocessor">    EXCEPTION_RECORD ExceptionRecordn; \</span>
00057 <span class="preprocessor">                                            \</span>
00058 <span class="preprocessor">    ExceptionRecordn.ExceptionCode = Status; \</span>
00059 <span class="preprocessor">    ExceptionRecordn.ExceptionFlags = EXCEPTION_NONCONTINUABLE; \</span>
00060 <span class="preprocessor">    ExceptionRecordn.ExceptionRecord = ExceptionRecordt; \</span>
00061 <span class="preprocessor">    ExceptionRecordn.NumberParameters = 0; \</span>
00062 <span class="preprocessor">    RtlRaiseException(&amp;ExceptionRecordn); \</span>
00063 <span class="preprocessor">    }</span>
00064 <span class="preprocessor"></span>
00065 <span class="comment">//</span>
00066 <span class="comment">// Define private function prototypes.</span>
00067 <span class="comment">//</span>
00068 
00069 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00070 <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a3">RtlpRestoreContext</a> (
00071     IN PCONTEXT Context,
00072     IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL
00073     );
00074 
00075 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00076 <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a4">RtlpRaiseException</a> (
00077     IN PEXCEPTION_RECORD ExceptionRecord
00078     );
00079 
00080 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00081 <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a5">RtlpRaiseStatus</a> (
00082     IN NTSTATUS Status
00083     );
00084 
00085 ULONG
00086 <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a6">RtlpVirtualUnwind</a> (
00087     IN ULONG ControlPc,
00088     IN PRUNTIME_FUNCTION FunctionEntry,
00089     IN PCONTEXT ContextRecord,
00090     OUT PBOOLEAN InFunction,
00091     OUT PULONG EstablisherFrame,
00092     IN OUT PKNONVOLATILE_CONTEXT_POINTERS ContextPointers OPTIONAL,
00093     IN ULONG LowStackLimit,
00094     IN ULONG HighStackLimit
00095     );
00096 
00097 BOOLEAN
<a name="l00098"></a><a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a7">00098</a> <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a7">RtlDispatchException</a> (
00099     IN PEXCEPTION_RECORD ExceptionRecord,
00100     IN PCONTEXT ContextRecord
00101     )
00102 
00103 <span class="comment">/*++</span>
00104 <span class="comment"></span>
00105 <span class="comment">Routine Description:</span>
00106 <span class="comment"></span>
00107 <span class="comment">    This function attempts to dispatch an exception to a frame based</span>
00108 <span class="comment">    handler by searching backwards through the stack based call frames.</span>
00109 <span class="comment">    The search begins with the frame specified in the context record and</span>
00110 <span class="comment">    continues backward until either a handler is found that handles the</span>
00111 <span class="comment">    exception, the stack is found to be invalid (i.e., out of limits or</span>
00112 <span class="comment">    unaligned), or the end of the call hierarchy is reached.</span>
00113 <span class="comment"></span>
00114 <span class="comment">    As each frame is encountered, the PC where control left the corresponding</span>
00115 <span class="comment">    function is determined and used to lookup exception handler information</span>
00116 <span class="comment">    in the runtime function table built by the linker. If the respective</span>
00117 <span class="comment">    routine has an exception handler, then the handler is called. If the</span>
00118 <span class="comment">    handler does not handle the exception, then the prologue of the routine</span>
00119 <span class="comment">    is executed backwards to "unwind" the effect of the prologue and then</span>
00120 <span class="comment">    the next frame is examined.</span>
00121 <span class="comment"></span>
00122 <span class="comment">Arguments:</span>
00123 <span class="comment"></span>
00124 <span class="comment">    ExceptionRecord - Supplies a pointer to an exception record.</span>
00125 <span class="comment"></span>
00126 <span class="comment">    ContextRecord - Supplies a pointer to a context record.</span>
00127 <span class="comment"></span>
00128 <span class="comment">Return Value:</span>
00129 <span class="comment"></span>
00130 <span class="comment">    If the exception is handled by one of the frame based handlers, then</span>
00131 <span class="comment">    a value of TRUE is returned. Otherwise a value of FALSE is returned.</span>
00132 <span class="comment"></span>
00133 <span class="comment">--*/</span>
00134 
00135 {
00136 
00137     CONTEXT ContextRecord1;
00138     ULONG ControlPc;
00139     <a class="code" href="../../d0/d6/struct__DISPATCHER__CONTEXT.html">DISPATCHER_CONTEXT</a> DispatcherContext;
00140     EXCEPTION_DISPOSITION Disposition;
00141     ULONG EstablisherFrame;
00142     ULONG ExceptionFlags;
00143     PRUNTIME_FUNCTION FunctionEntry;
00144     BOOLEAN InFunction;
00145     ULONG HighLimit;
00146     ULONG LowLimit;
00147     ULONG NestedFrame;
00148     ULONG NextPc;
00149 
00150     <span class="comment">//</span>
00151     <span class="comment">// Get current stack limits, copy the context record, get the initial</span>
00152     <span class="comment">// PC value, capture the exception flags, and set the nested exception</span>
00153     <span class="comment">// frame pointer.</span>
00154     <span class="comment">//</span>
00155 
00156     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a30">RtlpGetStackLimits</a>(&amp;LowLimit, &amp;HighLimit);
00157     RtlMoveMemory(&amp;ContextRecord1, ContextRecord, <span class="keyword">sizeof</span>(CONTEXT));
00158     ControlPc = ContextRecord1.Iar;
00159     ExceptionFlags = ExceptionRecord-&gt;ExceptionFlags &amp; <a class="code" href="../../d6/d7/halmips_8h.html#a25">EXCEPTION_NONCONTINUABLE</a>;
00160     NestedFrame = 0;
00161 
00162     <span class="comment">//</span>
00163     <span class="comment">// Start with the frame specified by the context record and search</span>
00164     <span class="comment">// backwards through the call frame hierarchy attempting to find an</span>
00165     <span class="comment">// exception handler that will handle the exception.</span>
00166     <span class="comment">//</span>
00167 
00168     <span class="keywordflow">do</span> {
00169 
00170         <span class="comment">//</span>
00171         <span class="comment">// Lookup the function table entry using the point at which control</span>
00172         <span class="comment">// left the procedure.</span>
00173         <span class="comment">//</span>
00174 
00175         FunctionEntry = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>(ControlPc);
00176 
00177         <span class="comment">//</span>
00178         <span class="comment">// Virtually unwind to the caller of the current routine to obtain</span>
00179         <span class="comment">// the virtual frame pointer of the establisher and the next PC.</span>
00180         <span class="comment">//</span>
00181 
00182         NextPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc,
00183                                   FunctionEntry,
00184                                   &amp;ContextRecord1,
00185                                   &amp;InFunction,
00186                                   &amp;EstablisherFrame,
00187                                   <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00188                                   LowLimit,
00189                                   HighLimit);
00190 
00191         <span class="comment">//</span>
00192         <span class="comment">// If there is a function table entry for the routine, check if</span>
00193         <span class="comment">// there is an exception handler for the frame.</span>
00194         <span class="comment">//</span>
00195 
00196         <span class="keywordflow">if</span> (FunctionEntry != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00197             <span class="comment">//</span>
00198             <span class="comment">// If the virtual frame pointer is not within the specified stack</span>
00199             <span class="comment">// limits or the virtual frame pointer is unaligned, then set the</span>
00200             <span class="comment">// stack invalid flag in the exception record and return exception</span>
00201             <span class="comment">// not handled. Otherwise, check if the current routine has an</span>
00202             <span class="comment">// exception handler.</span>
00203             <span class="comment">//</span>
00204 
00205             <span class="keywordflow">if</span> ((EstablisherFrame &lt; LowLimit) || (EstablisherFrame &gt; HighLimit) ||
00206                ((EstablisherFrame &amp; 0x7) != 0)) {
00207                 ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a28">EXCEPTION_STACK_INVALID</a>;
00208                 <span class="keywordflow">break</span>;
00209 
00210             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((FunctionEntry-&gt;ExceptionHandler != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp; InFunction) {
00211                 ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00212 
00213                 <span class="comment">//</span>
00214                 <span class="comment">// The frame has an exception handler. The handler must be</span>
00215                 <span class="comment">// executed by calling another routine that is written in</span>
00216                 <span class="comment">// assembler. This is required because up level addressing</span>
00217                 <span class="comment">// of the handler information is required when a nested</span>
00218                 <span class="comment">// exception is encountered.</span>
00219                 <span class="comment">//</span>
00220 
00221                 DispatcherContext.ControlPc = ControlPc;
00222                 DispatcherContext.FunctionEntry = FunctionEntry;
00223                 DispatcherContext.EstablisherFrame = EstablisherFrame;
00224                 DispatcherContext.ContextRecord = ContextRecord;
00225                 ExceptionRecord-&gt;ExceptionFlags = ExceptionFlags;
00226 
00227                 <span class="keywordflow">if</span> (<a class="code" href="../../d9/d2/ldrp_8h.html#a33">NtGlobalFlag</a> &amp; FLG_ENABLE_EXCEPTION_LOGGING) {
00228                     <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = <a class="code" href="../../d5/d9/ntrtlp_8h.html#a48">RtlpLogExceptionHandler</a>(
00229                                     ExceptionRecord,
00230                                     ContextRecord,
00231                                     ControlPc,
00232                                     FunctionEntry,
00233                                     <span class="keyword">sizeof</span>(RUNTIME_FUNCTION));
00234                 }
00235 
00236                 Disposition =
00237                     <a class="code" href="../../d6/d9/ntrtlppc_8h.html#a0">RtlpExecuteHandlerForException</a>(ExceptionRecord,
00238                                                    EstablisherFrame,
00239                                                    ContextRecord,
00240                                                    &amp;DispatcherContext,
00241                                                    FunctionEntry-&gt;ExceptionHandler);
00242 
00243                 <span class="keywordflow">if</span> (<a class="code" href="../../d9/d2/ldrp_8h.html#a33">NtGlobalFlag</a> &amp; FLG_ENABLE_EXCEPTION_LOGGING) {
00244                     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a49">RtlpLogLastExceptionDisposition</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>, Disposition);
00245                 }
00246 
00247                 ExceptionFlags |=
00248                     (ExceptionRecord-&gt;ExceptionFlags &amp; <a class="code" href="../../d6/d7/halmips_8h.html#a25">EXCEPTION_NONCONTINUABLE</a>);
00249 
00250                 <span class="comment">//</span>
00251                 <span class="comment">// If the current scan is within a nested context and the frame</span>
00252                 <span class="comment">// just examined is the end of the nested region, then clear</span>
00253                 <span class="comment">// the nested context frame and the nested exception flag in</span>
00254                 <span class="comment">// the exception flags.</span>
00255                 <span class="comment">//</span>
00256 
00257                 <span class="keywordflow">if</span> (NestedFrame == EstablisherFrame) {
00258                     ExceptionFlags &amp;= (~<a class="code" href="../../d6/d7/halmips_8h.html#a29">EXCEPTION_NESTED_CALL</a>);
00259                     NestedFrame = 0;
00260                 }
00261 
00262                 <span class="comment">//</span>
00263                 <span class="comment">// Case on the handler disposition.</span>
00264                 <span class="comment">//</span>
00265 
00266                 <span class="keywordflow">switch</span> (Disposition) {
00267 
00268                     <span class="comment">//</span>
00269                     <span class="comment">// The disposition is to continue execution.</span>
00270                     <span class="comment">//</span>
00271                     <span class="comment">// If the exception is not continuable, then raise the</span>
00272                     <span class="comment">// exception STATUS_NONCONTINUABLE_EXCEPTION. Otherwise</span>
00273                     <span class="comment">// return exception handled.</span>
00274                     <span class="comment">//</span>
00275 
00276                 <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a36">ExceptionContinueExecution</a> :
00277                     <span class="keywordflow">if</span> ((ExceptionFlags &amp; <a class="code" href="../../d6/d7/halmips_8h.html#a25">EXCEPTION_NONCONTINUABLE</a>) != 0) {
00278                         <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a0">RAISE_EXCEPTION</a>(STATUS_NONCONTINUABLE_EXCEPTION, ExceptionRecord);
00279 
00280                     } <span class="keywordflow">else</span> {
00281                         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00282                     }
00283 
00284                     <span class="comment">//</span>
00285                     <span class="comment">// The disposition is to continue the search.</span>
00286                     <span class="comment">//</span>
00287                     <span class="comment">// Get next frame address and continue the search.</span>
00288                     <span class="comment">//</span>
00289 
00290                 <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a37">ExceptionContinueSearch</a> :
00291                     <span class="keywordflow">break</span>;
00292 
00293                     <span class="comment">//</span>
00294                     <span class="comment">// The disposition is nested exception.</span>
00295                     <span class="comment">//</span>
00296                     <span class="comment">// Set the nested context frame to the establisher frame</span>
00297                     <span class="comment">// address and set the nested exception flag in the</span>
00298                     <span class="comment">// exception flags.</span>
00299                     <span class="comment">//</span>
00300 
00301                 <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a38">ExceptionNestedException</a> :
00302                     ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a29">EXCEPTION_NESTED_CALL</a>;
00303                     <span class="keywordflow">if</span> (DispatcherContext.EstablisherFrame &gt; NestedFrame) {
00304                         NestedFrame = DispatcherContext.EstablisherFrame;
00305                     }
00306 
00307                     <span class="keywordflow">break</span>;
00308 
00309                     <span class="comment">//</span>
00310                     <span class="comment">// All other disposition values are invalid.</span>
00311                     <span class="comment">//</span>
00312                     <span class="comment">// Raise invalid disposition exception.</span>
00313                     <span class="comment">//</span>
00314 
00315                 <span class="keywordflow">default</span> :
00316                     <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a0">RAISE_EXCEPTION</a>(STATUS_INVALID_DISPOSITION, ExceptionRecord);
00317                 }
00318             }
00319 
00320         } <span class="keywordflow">else</span> {
00321 
00322             <span class="comment">//</span>
00323             <span class="comment">// If the next control PC is the same as the old control PC, then</span>
00324             <span class="comment">// the function table is not correctly formed.</span>
00325             <span class="comment">//</span>
00326 
00327             <span class="keywordflow">if</span> (NextPc == ControlPc) {
00328                 <span class="keywordflow">break</span>;
00329             }
00330         }
00331 
00332         <span class="comment">//</span>
00333         <span class="comment">// Set point at which control left the previous routine.</span>
00334         <span class="comment">//</span>
00335 
00336         ControlPc = NextPc;
00337     } <span class="keywordflow">while</span> (ContextRecord1.Gpr1 &lt; HighLimit);
00338 
00339     <span class="comment">//</span>
00340     <span class="comment">// Set final exception flags and return exception not handled.</span>
00341     <span class="comment">//</span>
00342 
00343     ExceptionRecord-&gt;ExceptionFlags = ExceptionFlags;
00344     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00345 }
00346 
00347 PRUNTIME_FUNCTION
<a name="l00348"></a><a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">00348</a> <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a> (
00349     IN ULONG ControlPc
00350     )
00351 
00352 <span class="comment">/*++</span>
00353 <span class="comment"></span>
00354 <span class="comment">Routine Description:</span>
00355 <span class="comment"></span>
00356 <span class="comment">    This function searches the currently active function tables for an entry</span>
00357 <span class="comment">    that corresponds to the specified PC value.</span>
00358 <span class="comment"></span>
00359 <span class="comment">Arguments:</span>
00360 <span class="comment"></span>
00361 <span class="comment">    ControlPc - Supplies the address of an instruction within the specified</span>
00362 <span class="comment">        function.</span>
00363 <span class="comment"></span>
00364 <span class="comment">Return Value:</span>
00365 <span class="comment"></span>
00366 <span class="comment">    If there is no entry in the function table for the specified PC, then</span>
00367 <span class="comment">    NULL is returned. Otherwise, the address of the function table entry</span>
00368 <span class="comment">    that corresponds to the specified PC is returned.</span>
00369 <span class="comment"></span>
00370 <span class="comment">--*/</span>
00371 
00372 {
00373 
00374     PRUNTIME_FUNCTION FunctionEntry;
00375     PRUNTIME_FUNCTION FunctionTable;
00376     ULONG SizeOfExceptionTable;
00377     LONG High;
00378     PVOID ImageBase;
00379     LONG Low;
00380     LONG Middle;
00381 
00382     <span class="comment">//</span>
00383     <span class="comment">// Search for the image that includes the specified PC value.</span>
00384     <span class="comment">//</span>
00385 
00386     ImageBase = <a class="code" href="../../d6/d4/pctohdr_8c.html#a1">RtlPcToFileHeader</a>((PVOID)ControlPc, &amp;ImageBase);
00387 
00388     <span class="comment">//</span>
00389     <span class="comment">// If an image is found that includes the specified PC, then locate the</span>
00390     <span class="comment">// function table for the image.</span>
00391     <span class="comment">//</span>
00392 
00393     <span class="keywordflow">if</span> (ImageBase != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00394         FunctionTable = (PRUNTIME_FUNCTION)<a class="code" href="../../d8/d9/imagedir_8c.html#a5">RtlImageDirectoryEntryToData</a>(
00395                          ImageBase, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, IMAGE_DIRECTORY_ENTRY_EXCEPTION,
00396                          &amp;SizeOfExceptionTable);
00397 
00398         <span class="comment">//</span>
00399         <span class="comment">// If a function table is located, then search the function table</span>
00400         <span class="comment">// for a function table entry for the specified PC.</span>
00401         <span class="comment">//</span>
00402 
00403         <span class="keywordflow">if</span> (FunctionTable != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00404 
00405             <span class="comment">//</span>
00406             <span class="comment">// Initialize search indicies.</span>
00407             <span class="comment">//</span>
00408 
00409             Low = 0;
00410             High = (SizeOfExceptionTable / <span class="keyword">sizeof</span>(RUNTIME_FUNCTION)) - 1;
00411 
00412             <span class="comment">//</span>
00413             <span class="comment">// Perform binary search on the function table for a function table</span>
00414             <span class="comment">// entry that subsumes the specified PC.</span>
00415             <span class="comment">//</span>
00416 
00417             <span class="keywordflow">while</span> (High &gt;= Low) {
00418 
00419                 <span class="comment">//</span>
00420                 <span class="comment">// Compute next probe index and test entry. If the specified PC</span>
00421                 <span class="comment">// is greater than of equal to the beginning address and less</span>
00422                 <span class="comment">// than the ending address of the function table entry, then</span>
00423                 <span class="comment">// return the address of the function table entry. Otherwise,</span>
00424                 <span class="comment">// continue the search.</span>
00425                 <span class="comment">//</span>
00426 
00427                 Middle = (Low + High) &gt;&gt; 1;
00428                 FunctionEntry = &amp;FunctionTable[Middle];
00429                 <span class="keywordflow">if</span> (ControlPc &lt; FunctionEntry-&gt;BeginAddress) {
00430                     High = Middle - 1;
00431 
00432                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ControlPc &gt;= FunctionEntry-&gt;EndAddress) {
00433                     Low = Middle + 1;
00434 
00435                 } <span class="keywordflow">else</span> {
00436 
00437                     <span class="comment">//</span>
00438                     <span class="comment">// The capability exists for more than one function entry</span>
00439                     <span class="comment">// to map to the same function. This permits a function to</span>
00440                     <span class="comment">// have (within reason) discontiguous code segment(s). If</span>
00441                     <span class="comment">// PrologEndAddress is out of range, it is re-interpreted</span>
00442                     <span class="comment">// as a pointer to the primary function table entry for</span>
00443                     <span class="comment">// that function.  The out of range test takes into account</span>
00444                     <span class="comment">// the redundant encoding of millicode and glue code.</span>
00445                     <span class="comment">//</span>
00446 
00447                     <span class="keywordflow">if</span> (((FunctionEntry-&gt;PrologEndAddress &lt; FunctionEntry-&gt;BeginAddress) ||
00448                          (FunctionEntry-&gt;PrologEndAddress &gt; FunctionEntry-&gt;EndAddress)) &amp;&amp;
00449                         (FunctionEntry-&gt;PrologEndAddress &amp; 3) == 0) {
00450                         FunctionEntry = (PRUNTIME_FUNCTION)FunctionEntry-&gt;PrologEndAddress;
00451                     }
00452                     <span class="keywordflow">return</span> FunctionEntry;
00453                 }
00454             }
00455         }
00456     }
00457 
00458     <span class="comment">//</span>
00459     <span class="comment">// A function table entry for the specified PC was not found.</span>
00460     <span class="comment">//</span>
00461 
00462     <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00463 }
00464 
00465 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00466"></a><a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a9">00466</a> <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a9">RtlRaiseException</a> (
00467     IN PEXCEPTION_RECORD ExceptionRecord
00468     )
00469 
00470 <span class="comment">/*++</span>
00471 <span class="comment"></span>
00472 <span class="comment">Routine Description:</span>
00473 <span class="comment"></span>
00474 <span class="comment">    This function raises a software exception by building a context record</span>
00475 <span class="comment">    and calling the raise exception system service.</span>
00476 <span class="comment"></span>
00477 <span class="comment">    N.B. This routine is a shell routine that simply calls another routine</span>
00478 <span class="comment">         to do the real work. The reason this is done is to avoid a problem</span>
00479 <span class="comment">         in try/finally scopes where the last statement in the scope is a</span>
00480 <span class="comment">         call to raise an exception.</span>
00481 <span class="comment"></span>
00482 <span class="comment">Arguments:</span>
00483 <span class="comment"></span>
00484 <span class="comment">    ExceptionRecord - Supplies a pointer to an exception record.</span>
00485 <span class="comment"></span>
00486 <span class="comment">Return Value:</span>
00487 <span class="comment"></span>
00488 <span class="comment">    None.</span>
00489 <span class="comment"></span>
00490 <span class="comment">--*/</span>
00491 
00492 {
00493 
00494     <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a4">RtlpRaiseException</a>(ExceptionRecord);
00495     <span class="keywordflow">return</span>;
00496 }
00497 
00498 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00499 <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a4">RtlpRaiseException</a> (
00500     IN PEXCEPTION_RECORD ExceptionRecord
00501     )
00502 
00503 <span class="comment">/*++</span>
00504 <span class="comment"></span>
00505 <span class="comment">Routine Description:</span>
00506 <span class="comment"></span>
00507 <span class="comment">    This function raises a software exception by building a context record</span>
00508 <span class="comment">    and calling the raise exception system service.</span>
00509 <span class="comment"></span>
00510 <span class="comment">Arguments:</span>
00511 <span class="comment"></span>
00512 <span class="comment">    ExceptionRecord - Supplies a pointer to an exception record.</span>
00513 <span class="comment"></span>
00514 <span class="comment">Return Value:</span>
00515 <span class="comment"></span>
00516 <span class="comment">    None.</span>
00517 <span class="comment"></span>
00518 <span class="comment">--*/</span>
00519 
00520 {
00521 
00522     ULONG ControlPc;
00523     CONTEXT ContextRecord;
00524     ULONG EstablisherFrame;
00525     PRUNTIME_FUNCTION FunctionEntry;
00526     BOOLEAN InFunction;
00527     ULONG NextPc;
00528     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00529 
00530     <span class="comment">//</span>
00531     <span class="comment">// Capture the current context, virtually unwind to the caller of this</span>
00532     <span class="comment">// routine, set the fault instruction address to that of the caller, and</span>
00533     <span class="comment">// call the raise exception system service.</span>
00534     <span class="comment">//</span>
00535 
00536     RtlCaptureContext(&amp;ContextRecord);
00537     ControlPc = ContextRecord.Lr - 4;
00538     FunctionEntry = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>(ControlPc);
00539     NextPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc,
00540                               FunctionEntry,
00541                               &amp;ContextRecord,
00542                               &amp;InFunction,
00543                               &amp;EstablisherFrame,
00544                               NULL,
00545                               0,
00546                               0xffffffff);
00547 
00548     ContextRecord.Iar = NextPc + 4;
00549     ExceptionRecord-&gt;ExceptionAddress = (PVOID)ContextRecord.Iar;
00550     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwRaiseException(ExceptionRecord, &amp;ContextRecord, TRUE);
00551 
00552     <span class="comment">//</span>
00553     <span class="comment">// There should never be a return from this system service unless</span>
00554     <span class="comment">// there is a problem with the argument list itself. Raise another</span>
00555     <span class="comment">// exception specifying the status value returned.</span>
00556     <span class="comment">//</span>
00557 
00558     <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a10">RtlRaiseStatus</a>(Status);
00559     <span class="keywordflow">return</span>;
00560 }
00561 
00562 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00563"></a><a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a10">00563</a> <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a10">RtlRaiseStatus</a> (
00564     IN NTSTATUS Status
00565     )
00566 
00567 <span class="comment">/*++</span>
00568 <span class="comment"></span>
00569 <span class="comment">Routine Description:</span>
00570 <span class="comment"></span>
00571 <span class="comment">    This function raises an exception with the specified status value. The</span>
00572 <span class="comment">    exception is marked as noncontinuable with no parameters.</span>
00573 <span class="comment"></span>
00574 <span class="comment">    N.B. This routine is a shell routine that simply calls another routine</span>
00575 <span class="comment">         to do the real work. The reason this is done is to avoid a problem</span>
00576 <span class="comment">         in try/finally scopes where the last statement in the scope is a</span>
00577 <span class="comment">         call to raise an exception.</span>
00578 <span class="comment"></span>
00579 <span class="comment">Arguments:</span>
00580 <span class="comment"></span>
00581 <span class="comment">    Status - Supplies the status value to be used as the exception code</span>
00582 <span class="comment">        for the exception that is to be raised.</span>
00583 <span class="comment"></span>
00584 <span class="comment">Return Value:</span>
00585 <span class="comment"></span>
00586 <span class="comment">    None.</span>
00587 <span class="comment"></span>
00588 <span class="comment">--*/</span>
00589 
00590 {
00591 
00592     <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a5">RtlpRaiseStatus</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>);
00593     <span class="keywordflow">return</span>;
00594 }
00595 
00596 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00597 <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a5">RtlpRaiseStatus</a> (
00598     IN NTSTATUS Status
00599     )
00600 
00601 <span class="comment">/*++</span>
00602 <span class="comment"></span>
00603 <span class="comment">Routine Description:</span>
00604 <span class="comment"></span>
00605 <span class="comment">    This function raises an exception with the specified status value. The</span>
00606 <span class="comment">    exception is marked as noncontinuable with no parameters.</span>
00607 <span class="comment"></span>
00608 <span class="comment">Arguments:</span>
00609 <span class="comment"></span>
00610 <span class="comment">    Status - Supplies the status value to be used as the exception code</span>
00611 <span class="comment">        for the exception that is to be raised.</span>
00612 <span class="comment"></span>
00613 <span class="comment">Return Value:</span>
00614 <span class="comment"></span>
00615 <span class="comment">    None.</span>
00616 <span class="comment"></span>
00617 <span class="comment">--*/</span>
00618 
00619 {
00620 
00621     ULONG ControlPc;
00622     CONTEXT ContextRecord;
00623     ULONG EstablisherFrame;
00624     EXCEPTION_RECORD ExceptionRecord;
00625     PRUNTIME_FUNCTION FunctionEntry;
00626     BOOLEAN InFunction;
00627     ULONG NextPc;
00628 
00629     <span class="comment">//</span>
00630     <span class="comment">// Construct an exception record.</span>
00631     <span class="comment">//</span>
00632 
00633     ExceptionRecord.ExceptionCode = <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00634     ExceptionRecord.ExceptionRecord = (PEXCEPTION_RECORD)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00635     ExceptionRecord.NumberParameters = 0;
00636     ExceptionRecord.ExceptionFlags = <a class="code" href="../../d6/d7/halmips_8h.html#a25">EXCEPTION_NONCONTINUABLE</a>;
00637 
00638     <span class="comment">//</span>
00639     <span class="comment">// Capture the current context, virtually unwind to the caller of this</span>
00640     <span class="comment">// routine, set the fault instruction address to that of the caller, and</span>
00641     <span class="comment">// call the raise exception system service.</span>
00642     <span class="comment">//</span>
00643 
00644     RtlCaptureContext(&amp;ContextRecord);
00645     ControlPc = ContextRecord.Lr - 4;
00646     FunctionEntry = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>(ControlPc);
00647     NextPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc,
00648                               FunctionEntry,
00649                               &amp;ContextRecord,
00650                               &amp;InFunction,
00651                               &amp;EstablisherFrame,
00652                               NULL,
00653                               0,
00654                               0xffffffff);
00655 
00656     ContextRecord.Iar = NextPc + 4;
00657     ExceptionRecord.ExceptionAddress = (PVOID)ContextRecord.Iar;
00658     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwRaiseException(&amp;ExceptionRecord, &amp;ContextRecord, TRUE);
00659 
00660     <span class="comment">//</span>
00661     <span class="comment">// There should never be a return from this system service unless</span>
00662     <span class="comment">// there is a problem with the argument list itself. Raise another</span>
00663     <span class="comment">// exception specifying the status value returned.</span>
00664     <span class="comment">//</span>
00665 
00666     <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a10">RtlRaiseStatus</a>(Status);
00667     <span class="keywordflow">return</span>;
00668 }
00669 
00670 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00671"></a><a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a11">00671</a> <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a11">RtlUnwind</a> (
00672     IN PVOID TargetFrame OPTIONAL,
00673     IN PVOID TargetIp OPTIONAL,
00674     IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
00675     IN PVOID ReturnValue
00676     )
00677 
00678 <span class="comment">/*++</span>
00679 <span class="comment"></span>
00680 <span class="comment">Routine Description:</span>
00681 <span class="comment"></span>
00682 <span class="comment">    This function initiates an unwind of procedure call frames. The machine</span>
00683 <span class="comment">    state at the time of the call to unwind is captured in a context record</span>
00684 <span class="comment">    and the unwinding flag is set in the exception flags of the exception</span>
00685 <span class="comment">    record. If the TargetFrame parameter is not specified, then the exit unwind</span>
00686 <span class="comment">    flag is also set in the exception flags of the exception record. A backward</span>
00687 <span class="comment">    scan through the procedure call frames is then performed to find the target</span>
00688 <span class="comment">    of the unwind operation.</span>
00689 <span class="comment"></span>
00690 <span class="comment">    As each frame is encounter, the PC where control left the corresponding</span>
00691 <span class="comment">    function is determined and used to lookup exception handler information</span>
00692 <span class="comment">    in the runtime function table built by the linker. If the respective</span>
00693 <span class="comment">    routine has an exception handler, then the handler is called.</span>
00694 <span class="comment"></span>
00695 <span class="comment">    N.B. This routine is provided for backward compatibility with release 1.</span>
00696 <span class="comment"></span>
00697 <span class="comment">Arguments:</span>
00698 <span class="comment"></span>
00699 <span class="comment">    TargetFrame - Supplies an optional pointer to the call frame that is the</span>
00700 <span class="comment">        target of the unwind. If this parameter is not specified, then an exit</span>
00701 <span class="comment">        unwind is performed.</span>
00702 <span class="comment"></span>
00703 <span class="comment">    TargetIp - Supplies an optional instruction address that specifies the</span>
00704 <span class="comment">        continuation address of the unwind. This address is ignored if the</span>
00705 <span class="comment">        target frame parameter is not specified.</span>
00706 <span class="comment"></span>
00707 <span class="comment">    ExceptionRecord - Supplies an optional pointer to an exception record.</span>
00708 <span class="comment"></span>
00709 <span class="comment">    ReturnValue - Supplies a value that is to be placed in the integer</span>
00710 <span class="comment">        function return register just before continuing execution.</span>
00711 <span class="comment"></span>
00712 <span class="comment">Return Value:</span>
00713 <span class="comment"></span>
00714 <span class="comment">    None.</span>
00715 <span class="comment"></span>
00716 <span class="comment">--*/</span>
00717 
00718 {
00719 
00720     CONTEXT ContextRecord;
00721 
00722     <span class="comment">//</span>
00723     <span class="comment">// Call real unwind routine specifying a context record as an</span>
00724     <span class="comment">// extra argument.</span>
00725     <span class="comment">//</span>
00726 
00727     <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a12">RtlUnwind2</a>(TargetFrame,
00728                TargetIp,
00729                ExceptionRecord,
00730                ReturnValue,
00731                &amp;ContextRecord);
00732 
00733     <span class="keywordflow">return</span>;
00734 }
00735 
00736 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00737"></a><a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a12">00737</a> <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a12">RtlUnwind2</a> (
00738     IN PVOID TargetFrame OPTIONAL,
00739     IN PVOID TargetIp OPTIONAL,
00740     IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
00741     IN PVOID ReturnValue,
00742     IN PCONTEXT ContextRecord
00743     )
00744 
00745 <span class="comment">/*++</span>
00746 <span class="comment"></span>
00747 <span class="comment">Routine Description:</span>
00748 <span class="comment"></span>
00749 <span class="comment">    This function initiates an unwind of procedure call frames. The machine</span>
00750 <span class="comment">    state at the time of the call to unwind is captured in a context record</span>
00751 <span class="comment">    and the unwinding flag is set in the exception flags of the exception</span>
00752 <span class="comment">    record. If the TargetFrame parameter is not specified, then the exit unwind</span>
00753 <span class="comment">    flag is also set in the exception flags of the exception record. A backward</span>
00754 <span class="comment">    scan through the procedure call frames is then performed to find the target</span>
00755 <span class="comment">    of the unwind operation.</span>
00756 <span class="comment"></span>
00757 <span class="comment">    As each frame is encounter, the PC where control left the corresponding</span>
00758 <span class="comment">    function is determined and used to lookup exception handler information</span>
00759 <span class="comment">    in the runtime function table built by the linker. If the respective</span>
00760 <span class="comment">    routine has an exception handler, then the handler is called.</span>
00761 <span class="comment"></span>
00762 <span class="comment">Arguments:</span>
00763 <span class="comment"></span>
00764 <span class="comment">    TargetFrame - Supplies an optional pointer to the call frame that is the</span>
00765 <span class="comment">        target of the unwind. If this parameter is not specified, then an exit</span>
00766 <span class="comment">        unwind is performed.</span>
00767 <span class="comment"></span>
00768 <span class="comment">    TargetIp - Supplies an optional instruction address that specifies the</span>
00769 <span class="comment">        continuation address of the unwind. This address is ignored if the</span>
00770 <span class="comment">        target frame parameter is not specified.</span>
00771 <span class="comment"></span>
00772 <span class="comment">    ExceptionRecord - Supplies an optional pointer to an exception record.</span>
00773 <span class="comment"></span>
00774 <span class="comment">    ReturnValue - Supplies a value that is to be placed in the integer</span>
00775 <span class="comment">        function return register just before continuing execution.</span>
00776 <span class="comment"></span>
00777 <span class="comment">    ContextRecord - Supplies a pointer to a context record that can be used</span>
00778 <span class="comment">        to store context druing the unwind operation.</span>
00779 <span class="comment"></span>
00780 <span class="comment">Return Value:</span>
00781 <span class="comment"></span>
00782 <span class="comment">    None.</span>
00783 <span class="comment"></span>
00784 <span class="comment">--*/</span>
00785 
00786 {
00787 
00788     ULONG ControlPc;
00789     <a class="code" href="../../d0/d6/struct__DISPATCHER__CONTEXT.html">DISPATCHER_CONTEXT</a> DispatcherContext;
00790     EXCEPTION_DISPOSITION Disposition;
00791     ULONG EstablisherFrame;
00792     ULONG ExceptionFlags;
00793     EXCEPTION_RECORD ExceptionRecord1;
00794     PRUNTIME_FUNCTION FunctionEntry;
00795     BOOLEAN InFunction;
00796     ULONG HighLimit;
00797     ULONG LowLimit;
00798     ULONG NextPc;
00799 
00800     <span class="comment">//</span>
00801     <span class="comment">// Get current stack limits, capture the current context, virtually</span>
00802     <span class="comment">// unwind to the caller of this routine, get the initial PC value, and</span>
00803     <span class="comment">// set the unwind target address.</span>
00804     <span class="comment">//</span>
00805 
00806     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a30">RtlpGetStackLimits</a>(&amp;LowLimit, &amp;HighLimit);
00807     RtlCaptureContext(ContextRecord);
00808     ControlPc = ContextRecord-&gt;Lr - 4;
00809     FunctionEntry = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>(ControlPc);
00810     NextPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc,
00811                               FunctionEntry,
00812                               ContextRecord,
00813                               &amp;InFunction,
00814                               &amp;EstablisherFrame,
00815                               <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00816                               0,
00817                               0xffffffff);
00818 
00819     ControlPc = NextPc;
00820     ContextRecord-&gt;Iar = (ULONG)TargetIp;
00821 
00822     <span class="comment">//</span>
00823     <span class="comment">// If an exception record is not specified, then build a local exception</span>
00824     <span class="comment">// record for use in calling exception handlers during the unwind operation.</span>
00825     <span class="comment">//</span>
00826 
00827     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(ExceptionRecord) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00828         ExceptionRecord = &amp;ExceptionRecord1;
00829         ExceptionRecord1.ExceptionCode = STATUS_UNWIND;
00830         ExceptionRecord1.ExceptionRecord = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00831         ExceptionRecord1.ExceptionAddress = (PVOID)ControlPc;
00832         ExceptionRecord1.NumberParameters = 0;
00833     }
00834 
00835     <span class="comment">//</span>
00836     <span class="comment">// If the target frame of the unwind is specified, then a normal unwind</span>
00837     <span class="comment">// is being performed. Otherwise, an exit unwind is being performed.</span>
00838     <span class="comment">//</span>
00839 
00840     ExceptionFlags = <a class="code" href="../../d6/d7/halmips_8h.html#a26">EXCEPTION_UNWINDING</a>;
00841     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(TargetFrame) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00842         ExceptionRecord-&gt;ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a27">EXCEPTION_EXIT_UNWIND</a>;
00843     }
00844 
00845     <span class="comment">//</span>
00846     <span class="comment">// Scan backward through the call frame hierarchy and call exception</span>
00847     <span class="comment">// handlers until the target frame of the unwind is reached.</span>
00848     <span class="comment">//</span>
00849 
00850     <span class="keywordflow">do</span> {
00851 
00852         <span class="comment">//</span>
00853         <span class="comment">// Lookup the function table entry using the point at which control</span>
00854         <span class="comment">// left the procedure.</span>
00855         <span class="comment">//</span>
00856 
00857         FunctionEntry = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>(ControlPc);
00858 
00859         <span class="comment">//</span>
00860         <span class="comment">// If there is a function table entry for the routine, then virtually</span>
00861         <span class="comment">// unwind to the caller of the routine to obtain the virtual frame</span>
00862         <span class="comment">// pointer of the establisher, but don't update the context record.</span>
00863         <span class="comment">//</span>
00864 
00865         <span class="keywordflow">if</span> (FunctionEntry != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00866             NextPc = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a6">RtlpVirtualUnwind</a>(ControlPc,
00867                                        FunctionEntry,
00868                                        ContextRecord,
00869                                        &amp;InFunction,
00870                                        &amp;EstablisherFrame,
00871                                        <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00872                                        LowLimit,
00873                                        HighLimit);
00874 
00875             <span class="comment">//</span>
00876             <span class="comment">// If the virtual frame pointer is not within the specified stack</span>
00877             <span class="comment">// limits, the virtual frame pointer is unaligned, or the target</span>
00878             <span class="comment">// frame is below the virtual frame and an exit unwind is not being</span>
00879             <span class="comment">// performed, then raise the exception STATUS_BAD_STACK. Otherwise,</span>
00880             <span class="comment">// check to determine if the current routine has an exception</span>
00881             <span class="comment">// handler.</span>
00882             <span class="comment">//</span>
00883 
00884             <span class="keywordflow">if</span> ((EstablisherFrame &lt; LowLimit) || (EstablisherFrame &gt; HighLimit) ||
00885                ((ARGUMENT_PRESENT(TargetFrame) != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
00886                ((ULONG)TargetFrame &lt; EstablisherFrame)) ||
00887                ((EstablisherFrame &amp; 0x7) != 0)) {
00888                 <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a0">RAISE_EXCEPTION</a>(STATUS_BAD_STACK, ExceptionRecord);
00889 
00890             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((FunctionEntry-&gt;ExceptionHandler != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp; InFunction) {
00891 
00892                 <span class="comment">//</span>
00893                 <span class="comment">// The frame has an exception handler.</span>
00894                 <span class="comment">//</span>
00895                 <span class="comment">// The control PC, establisher frame pointer, the address</span>
00896                 <span class="comment">// of the function table entry, and the address of the</span>
00897                 <span class="comment">// context record are all stored in the dispatcher context.</span>
00898                 <span class="comment">// This information is used by the unwind linkage routine</span>
00899                 <span class="comment">// and can be used by the exception handler itself.</span>
00900                 <span class="comment">//</span>
00901                 <span class="comment">// A linkage routine written in assembler is used to actually</span>
00902                 <span class="comment">// call the actual exception handler. This is required by the</span>
00903                 <span class="comment">// exception handler that is associated with the linkage</span>
00904                 <span class="comment">// routine so it can have access to two sets of dispatcher</span>
00905                 <span class="comment">// context when it is called.</span>
00906                 <span class="comment">//</span>
00907 
00908                 DispatcherContext.ControlPc = ControlPc;
00909                 DispatcherContext.FunctionEntry = FunctionEntry;
00910                 DispatcherContext.EstablisherFrame = EstablisherFrame;
00911                 DispatcherContext.ContextRecord = ContextRecord;
00912 
00913                 <span class="comment">//</span>
00914                 <span class="comment">// Call the exception handler.</span>
00915                 <span class="comment">//</span>
00916 
00917                 <span class="keywordflow">do</span> {
00918 
00919                     <span class="comment">//</span>
00920                     <span class="comment">// If the establisher frame is the target of the unwind</span>
00921                     <span class="comment">// operation, then set the target unwind flag.</span>
00922                     <span class="comment">//</span>
00923 
00924                     <span class="keywordflow">if</span> ((ULONG)TargetFrame == EstablisherFrame) {
00925                         ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a30">EXCEPTION_TARGET_UNWIND</a>;
00926                     }
00927 
00928                     ExceptionRecord-&gt;ExceptionFlags = ExceptionFlags;
00929 
00930                     <span class="comment">//</span>
00931                     <span class="comment">// Set the specified return value in case the exception</span>
00932                     <span class="comment">// handler directly continues execution.</span>
00933                     <span class="comment">//</span>
00934 
00935                     ContextRecord-&gt;Gpr3 = (ULONG)ReturnValue;
00936                     Disposition =
00937                         <a class="code" href="../../d6/d9/ntrtlppc_8h.html#a1">RtlpExecuteHandlerForUnwind</a>(ExceptionRecord,
00938                                                     EstablisherFrame,
00939                                                     ContextRecord,
00940                                                     &amp;DispatcherContext,
00941                                                     FunctionEntry-&gt;ExceptionHandler);
00942 
00943                     <span class="comment">//</span>
00944                     <span class="comment">// Clear target unwind and collided unwind flags.</span>
00945                     <span class="comment">//</span>
00946 
00947                     ExceptionFlags &amp;= ~(<a class="code" href="../../d6/d7/halmips_8h.html#a31">EXCEPTION_COLLIDED_UNWIND</a> |
00948                                                         <a class="code" href="../../d6/d7/halmips_8h.html#a30">EXCEPTION_TARGET_UNWIND</a>);
00949 
00950                     <span class="comment">//</span>
00951                     <span class="comment">// Case on the handler disposition.</span>
00952                     <span class="comment">//</span>
00953 
00954                     <span class="keywordflow">switch</span> (Disposition) {
00955 
00956                         <span class="comment">//</span>
00957                         <span class="comment">// The disposition is to continue the search.</span>
00958                         <span class="comment">//</span>
00959                         <span class="comment">// If the target frame has not been reached, then</span>
00960                         <span class="comment">// virtually unwind to the caller of the current</span>
00961                         <span class="comment">// routine, update the context record, and continue</span>
00962                         <span class="comment">// the search for a handler.</span>
00963                         <span class="comment">//</span>
00964 
00965                     <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a37">ExceptionContinueSearch</a> :
00966                         <span class="keywordflow">if</span> (EstablisherFrame != (ULONG)TargetFrame) {
00967                             NextPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc,
00968                                                       FunctionEntry,
00969                                                       ContextRecord,
00970                                                       &amp;InFunction,
00971                                                       &amp;EstablisherFrame,
00972                                                       <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00973                                                       0,
00974                                                       0xffffffff);
00975                         }
00976 
00977                         <span class="keywordflow">break</span>;
00978 
00979                         <span class="comment">//</span>
00980                         <span class="comment">// The disposition is collided unwind.</span>
00981                         <span class="comment">//</span>
00982                         <span class="comment">// Set the target of the current unwind to the context</span>
00983                         <span class="comment">// record of the previous unwind, and reexecute the</span>
00984                         <span class="comment">// exception handler from the collided frame with the</span>
00985                         <span class="comment">// collided unwind flag set in the exception record.</span>
00986                         <span class="comment">//</span>
00987 
00988                     <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a39">ExceptionCollidedUnwind</a> :
00989                         ControlPc = DispatcherContext.ControlPc;
00990                         FunctionEntry = DispatcherContext.FunctionEntry;
00991                         ContextRecord = DispatcherContext.ContextRecord;
00992                         ContextRecord-&gt;Iar = (ULONG)TargetIp;
00993                         ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a31">EXCEPTION_COLLIDED_UNWIND</a>;
00994                         EstablisherFrame = DispatcherContext.EstablisherFrame;
00995                         <span class="keywordflow">break</span>;
00996 
00997                         <span class="comment">//</span>
00998                         <span class="comment">// All other disposition values are invalid.</span>
00999                         <span class="comment">//</span>
01000                         <span class="comment">// Raise invalid disposition exception.</span>
01001                         <span class="comment">//</span>
01002 
01003                     <span class="keywordflow">default</span> :
01004                         <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a0">RAISE_EXCEPTION</a>(STATUS_INVALID_DISPOSITION, ExceptionRecord);
01005                     }
01006 
01007                 } <span class="keywordflow">while</span> ((ExceptionFlags &amp; <a class="code" href="../../d6/d7/halmips_8h.html#a31">EXCEPTION_COLLIDED_UNWIND</a>) != 0);
01008 
01009             } <span class="keywordflow">else</span> {
01010 
01011                 <span class="comment">//</span>
01012                 <span class="comment">// If the target frame has not been reached, then virtually unwind to the</span>
01013                 <span class="comment">// caller of the current routine and update the context record.</span>
01014                 <span class="comment">//</span>
01015 
01016                 <span class="keywordflow">if</span> (EstablisherFrame != (ULONG)TargetFrame) {
01017                     NextPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc,
01018                                               FunctionEntry,
01019                                               ContextRecord,
01020                                               &amp;InFunction,
01021                                               &amp;EstablisherFrame,
01022                                               <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
01023                                               0,
01024                                               0xffffffff);
01025                 }
01026             }
01027 
01028         } <span class="keywordflow">else</span> {
01029 
01030             <span class="comment">//</span>
01031             <span class="comment">// Set point at which control left the previous routine.</span>
01032             <span class="comment">//</span>
01033             NextPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc,
01034                                       FunctionEntry,
01035                                       ContextRecord,
01036                                       &amp;InFunction,
01037                                       &amp;EstablisherFrame,
01038                                       <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
01039                                       0,
01040                                       0xffffffff);
01041 
01042             <span class="comment">//</span>
01043             <span class="comment">// If the next control PC is the same as the old control PC, then</span>
01044             <span class="comment">// the function table is not correctly formed.</span>
01045             <span class="comment">//</span>
01046 
01047             <span class="keywordflow">if</span> (NextPc == ControlPc) {
01048                 <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a10">RtlRaiseStatus</a>(STATUS_BAD_FUNCTION_TABLE);
01049             }
01050         }
01051 
01052         <span class="comment">//</span>
01053         <span class="comment">// Set point at which control left the previous routine.</span>
01054         <span class="comment">//</span>
01055         <span class="comment">// N.B. Make sure the address is in the delay slot of the jal</span>
01056         <span class="comment">//      to prevent the boundary condition of the return address</span>
01057         <span class="comment">//      being at the front of a try body.</span>
01058         <span class="comment">//</span>
01059 
01060         ControlPc = NextPc;
01061 
01062     } <span class="keywordflow">while</span> ((EstablisherFrame &lt; HighLimit) &amp;&amp;
01063             (EstablisherFrame != (ULONG)TargetFrame));
01064 
01065     <span class="comment">//</span>
01066     <span class="comment">// If the establisher stack pointer is equal to the target frame</span>
01067     <span class="comment">// pointer, then continue execution. Otherwise, an exit unwind was</span>
01068     <span class="comment">// performed or the target of the unwind did not exist and the</span>
01069     <span class="comment">// debugger and subsystem are given a second chance to handle the</span>
01070     <span class="comment">// unwind.</span>
01071     <span class="comment">//</span>
01072 
01073     <span class="keywordflow">if</span> (EstablisherFrame == (ULONG)TargetFrame) {
01074         <span class="comment">//</span>
01075         <span class="comment">// Virtually unwind the target frame to recover the value of r.2.</span>
01076         <span class="comment">// We must take care to not unwind a glue sequence that may have</span>
01077         <span class="comment">// been used to reach the target frame.  This is done by giving</span>
01078         <span class="comment">// stack limit values that will regard any stack pointer as bad.</span>
01079         <span class="comment">//</span>
01080         CONTEXT TocContext;
01081         RtlMoveMemory((PVOID)&amp;TocContext, ContextRecord, <span class="keyword">sizeof</span>(CONTEXT));
01082         ControlPc = ContextRecord-&gt;Iar;
01083         FunctionEntry = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>(ControlPc);
01084         NextPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc,
01085                                   FunctionEntry,
01086                                   &amp;TocContext,
01087                                   &amp;InFunction,
01088                                   &amp;EstablisherFrame,
01089                                   <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
01090                                   0xffffffff,
01091                                   0);
01092         ContextRecord-&gt;Gpr2 = TocContext.Gpr2;
01093         ContextRecord-&gt;Gpr3 = (ULONG)ReturnValue;
01094         <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a3">RtlpRestoreContext</a>(ContextRecord, ExceptionRecord);
01095 
01096     } <span class="keywordflow">else</span> {
01097         ZwRaiseException(ExceptionRecord, ContextRecord, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
01098     }
01099 }
01100 
01101 ULONG
<a name="l01102"></a><a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a6">01102</a> <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a6">RtlpVirtualUnwind</a> (
01103     IN ULONG ControlPc,
01104     IN PRUNTIME_FUNCTION FunctionEntry,
01105     IN PCONTEXT ContextRecord,
01106     OUT PBOOLEAN InFunction,
01107     OUT PULONG EstablisherFrame,
01108     IN OUT PKNONVOLATILE_CONTEXT_POINTERS ContextPointers OPTIONAL,
01109     IN ULONG LowStackLimit,
01110     IN ULONG HighStackLimit
01111     )
01112 
01113 <span class="comment">/*++</span>
01114 <span class="comment"></span>
01115 <span class="comment">Routine Description:</span>
01116 <span class="comment"></span>
01117 <span class="comment">    This function virtually unwinds the specfified function by executing its</span>
01118 <span class="comment">    prologue code backwards.</span>
01119 <span class="comment"></span>
01120 <span class="comment">    If the function is a leaf function, then the address where control left</span>
01121 <span class="comment">    the previous frame is obtained from the context record. If the function</span>
01122 <span class="comment">    is a nested function, but not an exception or interrupt frame, then the</span>
01123 <span class="comment">    prologue code is executed backwards and the address where control left</span>
01124 <span class="comment">    the previous frame is obtained from the updated context record.</span>
01125 <span class="comment"></span>
01126 <span class="comment">    If the function is register save millicode, it is treated as a leaf</span>
01127 <span class="comment">    function.  If the function is register restore millicode, the remaining</span>
01128 <span class="comment">    body is executed forwards and the address where control left the</span>
01129 <span class="comment">    previous frame is obtained from the final blr instruction.</span>
01130 <span class="comment"></span>
01131 <span class="comment">    If the function was called via glue code and is not that glue code,</span>
01132 <span class="comment">    the prologe of the glue code is executed backwards in addition to the</span>
01133 <span class="comment">    above actions.</span>
01134 <span class="comment"></span>
01135 <span class="comment">    Otherwise, an exception or interrupt entry to the system is being</span>
01136 <span class="comment">    unwound and a specially coded prologue restores the return address</span>
01137 <span class="comment">    twice. Once from the fault instruction address and once from the saved</span>
01138 <span class="comment">    return address register. The first restore is returned as the function</span>
01139 <span class="comment">    value and the second restore is place in the updated context record.</span>
01140 <span class="comment"></span>
01141 <span class="comment">    If a context pointers record is specified, then the address where each</span>
01142 <span class="comment">    nonvolatile registers is restored from is recorded in the appropriate</span>
01143 <span class="comment">    element of the context pointers record.</span>
01144 <span class="comment"></span>
01145 <span class="comment">    N.B. This function copies the specified context record and only computes</span>
01146 <span class="comment">         the establisher frame and whether control is actually in a function.</span>
01147 <span class="comment"></span>
01148 <span class="comment">Arguments:</span>
01149 <span class="comment"></span>
01150 <span class="comment">    ControlPc - Supplies the address where control left the specified</span>
01151 <span class="comment">        function.</span>
01152 <span class="comment"></span>
01153 <span class="comment">    FunctionEntry - Supplies the address of the function table entry for the</span>
01154 <span class="comment">        specified function or NULL if the function is a leaf function.</span>
01155 <span class="comment"></span>
01156 <span class="comment">    ContextRecord - Supplies the address of a context record.</span>
01157 <span class="comment"></span>
01158 <span class="comment">    InFunction - Supplies a pointer to a variable that receives whether the</span>
01159 <span class="comment">        control PC is within the current function.</span>
01160 <span class="comment"></span>
01161 <span class="comment">    EstablisherFrame - Supplies a pointer to a variable that receives the</span>
01162 <span class="comment">        the establisher frame pointer value.</span>
01163 <span class="comment"></span>
01164 <span class="comment">    ContextPointers - Supplies an optional pointer to a context pointers</span>
01165 <span class="comment">        record.</span>
01166 <span class="comment"></span>
01167 <span class="comment">    LowStackLimit, HighStackLimit - Range of valid values for the stack</span>
01168 <span class="comment">        pointer.  This indicates whether it is valid to examine NextPc.</span>
01169 <span class="comment"></span>
01170 <span class="comment">Return Value:</span>
01171 <span class="comment"></span>
01172 <span class="comment">    The address where control left the previous frame is returned as the</span>
01173 <span class="comment">    function value.</span>
01174 <span class="comment"></span>
01175 <span class="comment">--*/</span>
01176 
01177 {
01178 
01179     CONTEXT LocalContext;
01180 
01181     <span class="comment">//</span>
01182     <span class="comment">// Copy the context record so updates will not be reflected in the</span>
01183     <span class="comment">// original copy and then virtually unwind to the caller of the</span>
01184     <span class="comment">// specified control point.</span>
01185     <span class="comment">//</span>
01186 
01187     RtlMoveMemory((PVOID)&amp;LocalContext, ContextRecord, <span class="keyword">sizeof</span>(CONTEXT));
01188     <span class="keywordflow">return</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc,
01189                             FunctionEntry,
01190                             &amp;LocalContext,
01191                             InFunction,
01192                             EstablisherFrame,
01193                             ContextPointers,
01194                             LowStackLimit,
01195                             HighStackLimit);
01196 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:39:57 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
