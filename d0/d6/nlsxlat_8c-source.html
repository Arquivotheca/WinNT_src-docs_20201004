<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: nlsxlat.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>nlsxlat.c</h1><a href="../../d9/d6/nlsxlat_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/****************************** Module Header ******************************\</span>
00002 <span class="comment">* Module Name: nlsxlat.c</span>
00003 <span class="comment">*</span>
00004 <span class="comment">* Copyright (c) 1985-91, Microsoft Corporation</span>
00005 <span class="comment">*</span>
00006 <span class="comment">* This modules contains the private routines for character translation:</span>
00007 <span class="comment">* 8-bit &lt;=&gt; Unicode.</span>
00008 <span class="comment">*</span>
00009 <span class="comment">* History:</span>
00010 <span class="comment">* 03-Jan-1992    gregoryw</span>
00011 <span class="comment">* 16-Feb-1993    JulieB      Added Upcase Routines &amp; Macros.</span>
00012 <span class="comment">* 17-Feb-1993    JulieB      Fixed Tables; Fixed DBCS Code.</span>
00013 <span class="comment">* 08-Mar-1993    JulieB      Moved Upcase Macro to ntrtlp.h.</span>
00014 <span class="comment">\***************************************************************************/</span>
00015 
00016 <span class="preprocessor">#include "<a class="code" href="../../d5/d9/ntrtlp_8h.html">ntrtlp.h</a>"</span>
00017 
00018 
00019 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00020 <a class="code" href="../../d9/d6/nlsxlat_8c.html#a31">RtlConsoleMultiByteToUnicodeN</a>(
00021     OUT PWCH UnicodeString,
00022     IN ULONG MaxBytesInUnicodeString,
00023     OUT PULONG BytesInUnicodeString OPTIONAL,
00024     IN PCH MultiByteString,
00025     IN ULONG BytesInMultiByteString,
00026     OUT PULONG pdwSpecialChar );
00027 
00028 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00029 <a class="code" href="../../d9/d6/nlsxlat_8c.html#a32">RtlpInitUpcaseTable</a>(
00030     IN PUSHORT TableBase,
00031     OUT PNLSTABLEINFO CodePageTable
00032     );
00033 
00034 <span class="preprocessor">#if defined(ALLOC_PRAGMA) &amp;&amp; defined(NTOS_KERNEL_RUNTIME)</span>
00035 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlConsoleMultiByteToUnicodeN)</span>
00036 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlMultiByteToUnicodeN)</span>
00037 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlOemToUnicodeN)</span>
00038 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlUnicodeToMultiByteN)</span>
00039 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlUpcaseUnicodeToMultiByteN)</span>
00040 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlUnicodeToOemN)</span>
00041 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlUpcaseUnicodeToOemN)</span>
00042 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlpDidUnicodeToOemWork)</span>
00043 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlCustomCPToUnicodeN)</span>
00044 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlUnicodeToCustomCPN)</span>
00045 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlUpcaseUnicodeToCustomCPN)</span>
00046 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlInitCodePageTable)</span>
00047 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlpInitUpcaseTable)</span>
00048 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlInitNlsTables)</span>
00049 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlResetRtlTranslations)</span>
00050 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlMultiByteToUnicodeSize)</span>
00051 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlUnicodeToMultiByteSize)</span>
00052 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlGetDefaultCodePage)</span>
00053 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00054 <span class="preprocessor"></span>
00055 
00056 
00057 <span class="comment">//</span>
00058 <span class="comment">// Various defines and convenient macros for data access</span>
00059 <span class="comment">//</span>
00060 
<a name="l00061"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a0">00061</a> <span class="preprocessor">#define DBCS_TABLE_SIZE 256</span>
00062 <span class="preprocessor"></span>
00063 
00064 <span class="comment">/*</span>
00065 <span class="comment"> * Global data used by the translation routines.</span>
00066 <span class="comment"> *</span>
00067 <span class="comment"> */</span>
00068 
00069 <span class="comment">//</span>
00070 <span class="comment">// Upcase and Lowercase data</span>
00071 <span class="comment">//</span>
<a name="l00072"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a9">00072</a> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a> <a class="code" href="../../d9/d6/nlsxlat_8c.html#a9">Nls844UnicodeUpcaseTable</a>;
<a name="l00073"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a10">00073</a> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a> <a class="code" href="../../d9/d6/nlsxlat_8c.html#a10">Nls844UnicodeLowercaseTable</a>;
00074 
00075 <span class="comment">//</span>
00076 <span class="comment">// ACP related data</span>
00077 <span class="comment">//</span>
<a name="l00078"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a11">00078</a> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>   <a class="code" href="../../d9/d6/nlsxlat_8c.html#a11">NlsLeadByteInfoTable</a>[<a class="code" href="../../d9/d6/nlsxlat_8c.html#a0">DBCS_TABLE_SIZE</a>]; <span class="comment">// Lead byte info. for ACP</span>
<a name="l00079"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a12">00079</a> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>   <a class="code" href="../../d9/d6/nlsxlat_8c.html#a12">NlsAnsiCodePage</a>;                  <span class="comment">// Default ANSI code page</span>
<a name="l00080"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a13">00080</a> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>   <a class="code" href="../../d9/d6/nlsxlat_8c.html#a13">NlsOemCodePage</a>;                   <span class="comment">// Default OEM code page</span>
<a name="l00081"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a14">00081</a> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>  <a class="code" href="../../d6/d6/nls_8c.html#a20">NlsLeadByteInfo</a> = <a class="code" href="../../d9/d6/nlsxlat_8c.html#a11">NlsLeadByteInfoTable</a>;
<a name="l00082"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a15">00082</a> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>  <a class="code" href="../../d9/d6/nlsxlat_8c.html#a15">NlsMbAnsiCodePageTables</a>;          <span class="comment">// Multibyte to Unicode translation tables</span>
<a name="l00083"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a16">00083</a> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>  <a class="code" href="../../d6/d6/nls_8c.html#a19">NlsAnsiToUnicodeData</a>;             <span class="comment">// Ansi CP to Unicode translation table</span>
<a name="l00084"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a17">00084</a> PCH      <a class="code" href="../../d9/d6/nlsxlat_8c.html#a17">NlsUnicodeToAnsiData</a>;             <span class="comment">// Unicode to Ansi CP translation table</span>
<a name="l00085"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a18">00085</a> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>  <a class="code" href="../../d9/d6/nlsxlat_8c.html#a18">NlsUnicodeToMbAnsiData</a>;           <span class="comment">// Unicode to Multibyte Ansi CP translation table</span>
<a name="l00086"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a19">00086</a> BOOLEAN  <a class="code" href="../../d9/d6/nlsxlat_8c.html#a19">NlsMbCodePageTag</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;         <span class="comment">// TRUE -&gt; Multibyte ACP, FALSE -&gt; Singlebyte ACP</span>
00087 
00088 <span class="comment">//</span>
00089 <span class="comment">// OEM related data</span>
00090 <span class="comment">//</span>
<a name="l00091"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a20">00091</a> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>   <a class="code" href="../../d9/d6/nlsxlat_8c.html#a20">NlsOemLeadByteInfoTable</a>[<a class="code" href="../../d9/d6/nlsxlat_8c.html#a0">DBCS_TABLE_SIZE</a>]; <span class="comment">// Lead byte info. for 0CP</span>
<a name="l00092"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a21">00092</a> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>  <a class="code" href="../../d5/d9/gen8dot3_8c.html#a6">NlsOemLeadByteInfo</a> = <a class="code" href="../../d9/d6/nlsxlat_8c.html#a20">NlsOemLeadByteInfoTable</a>;
<a name="l00093"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a22">00093</a> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>  <a class="code" href="../../d5/d9/gen8dot3_8c.html#a4">NlsMbOemCodePageTables</a>;              <span class="comment">// OEM Multibyte to Unicode translation tables</span>
<a name="l00094"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a23">00094</a> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>  <a class="code" href="../../d5/d9/gen8dot3_8c.html#a2">NlsOemToUnicodeData</a>;                 <span class="comment">// Oem CP to Unicode translation table</span>
<a name="l00095"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a24">00095</a> PCH      <a class="code" href="../../d5/d9/gen8dot3_8c.html#a3">NlsUnicodeToOemData</a>;                 <span class="comment">// Unicode to Oem CP translation table</span>
<a name="l00096"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a25">00096</a> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>  <a class="code" href="../../d5/d9/gen8dot3_8c.html#a1">NlsUnicodeToMbOemData</a>;               <span class="comment">// Unicode to Multibyte Oem CP translation table</span>
<a name="l00097"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a26">00097</a> BOOLEAN  <a class="code" href="../../d5/d9/gen8dot3_8c.html#a5">NlsMbOemCodePageTag</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;         <span class="comment">// TRUE -&gt; Multibyte OCP, FALSE -&gt; Singlebyte OCP</span>
00098 
00099 <span class="comment">//</span>
00100 <span class="comment">// Default info taken from data files</span>
00101 <span class="comment">//</span>
<a name="l00102"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a27">00102</a> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>   <a class="code" href="../../d9/d6/nlsxlat_8c.html#a27">UnicodeDefaultChar</a>;
00103 
<a name="l00104"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a28">00104</a> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>   <a class="code" href="../../d5/d9/gen8dot3_8c.html#a7">OemDefaultChar</a>;
<a name="l00105"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a29">00105</a> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>   <a class="code" href="../../d9/d6/nlsxlat_8c.html#a29">OemTransUniDefaultChar</a>;
00106 
00107 <span class="comment">//</span>
00108 <span class="comment">// Default info NOT taken from data files</span>
00109 <span class="comment">//</span>
<a name="l00110"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a30">00110</a> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>   <a class="code" href="../../d9/d6/nlsxlat_8c.html#a30">UnicodeNull</a>  = 0x0000;
00111 
00112 
00113 
00114 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00115"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a31">00115</a> <a class="code" href="../../d9/d6/nlsxlat_8c.html#a31">RtlConsoleMultiByteToUnicodeN</a>(
00116     OUT PWCH UnicodeString,
00117     IN ULONG MaxBytesInUnicodeString,
00118     OUT PULONG BytesInUnicodeString OPTIONAL,
00119     IN PCH MultiByteString,
00120     IN ULONG BytesInMultiByteString,
00121     OUT PULONG pdwSpecialChar )
00122 
00123 <span class="comment">/*++</span>
00124 <span class="comment"></span>
00125 <span class="comment">Routine Description:</span>
00126 <span class="comment"></span>
00127 <span class="comment">    This function is a superset of MultiByteToUnicode for the</span>
00128 <span class="comment">    console.  It works just like the other, except it will detect</span>
00129 <span class="comment">    if any characters were under 0x20.</span>
00130 <span class="comment"></span>
00131 <span class="comment">    This functions converts the specified ansi source string into a</span>
00132 <span class="comment">    Unicode string. The translation is done with respect to the</span>
00133 <span class="comment">    ANSI Code Page (ACP) installed at boot time.  Single byte characters</span>
00134 <span class="comment">    in the range 0x00 - 0x7f are simply zero extended as a performance</span>
00135 <span class="comment">    enhancement.  In some far eastern code pages 0x5c is defined as the</span>
00136 <span class="comment">    Yen sign.  For system translation we always want to consider 0x5c</span>
00137 <span class="comment">    to be the backslash character.  We get this for free by zero extending.</span>
00138 <span class="comment"></span>
00139 <span class="comment">    NOTE: This routine only supports precomposed Unicode characters.</span>
00140 <span class="comment"></span>
00141 <span class="comment">Arguments:</span>
00142 <span class="comment"></span>
00143 <span class="comment">    UnicodeString - Returns a unicode string that is equivalent to</span>
00144 <span class="comment">        the ansi source string.</span>
00145 <span class="comment"></span>
00146 <span class="comment">    MaxBytesInUnicodeString - Supplies the maximum number of bytes to be</span>
00147 <span class="comment">        written to UnicodeString.  If this causes UnicodeString to be a</span>
00148 <span class="comment">        truncated equivalent of MultiByteString, no error condition results.</span>
00149 <span class="comment"></span>
00150 <span class="comment">    BytesInUnicodeString - Returns the number of bytes in the returned</span>
00151 <span class="comment">        unicode string pointed to by UnicodeString.</span>
00152 <span class="comment"></span>
00153 <span class="comment">    MultiByteString - Supplies the ansi source string that is to be</span>
00154 <span class="comment">        converted to unicode.</span>
00155 <span class="comment"></span>
00156 <span class="comment">    BytesInMultiByteString - The number of bytes in the string pointed to</span>
00157 <span class="comment">        by MultiByteString.</span>
00158 <span class="comment"></span>
00159 <span class="comment">    pdwSpecialChar - will be zero if non detected, else it will contain the</span>
00160 <span class="comment">       approximate index (can be off by 32).</span>
00161 <span class="comment"></span>
00162 <span class="comment">Return Value:</span>
00163 <span class="comment"></span>
00164 <span class="comment">    SUCCESS - The conversion was successful.</span>
00165 <span class="comment"></span>
00166 <span class="comment"></span>
00167 <span class="comment">--*/</span>
00168 
00169 {
00170     ULONG LoopCount;
00171     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a> TranslateTable;
00172     ULONG MaxCharsInUnicodeString;
00173 
00174     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00175 
00176     *pdwSpecialChar = 0;
00177 
00178     <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d6/nlsxlat_8c.html#a19">NlsMbCodePageTag</a>) {
00179         MaxCharsInUnicodeString = MaxBytesInUnicodeString / <span class="keyword">sizeof</span>(WCHAR);
00180 
00181         LoopCount = (MaxCharsInUnicodeString &lt; BytesInMultiByteString) ?
00182                      MaxCharsInUnicodeString : BytesInMultiByteString;
00183 
00184         <span class="keywordflow">if</span> (ARGUMENT_PRESENT(BytesInUnicodeString))
00185             *BytesInUnicodeString = LoopCount * <span class="keyword">sizeof</span>(WCHAR);
00186 
00187         TranslateTable = <a class="code" href="../../d6/d6/nls_8c.html#a19">NlsAnsiToUnicodeData</a>;  <span class="comment">// used to help the mips compiler</span>
00188 
00189         quick_copy:
00190             <span class="keywordflow">switch</span>( LoopCount ) {
00191             <span class="keywordflow">default</span>:
00192                 <span class="keywordflow">if</span> ((UCHAR)MultiByteString[0x1F] &lt; 0x20)    <span class="keywordflow">goto</span>  bad_case;
00193                 UnicodeString[0x1F] = TranslateTable[(UCHAR)MultiByteString[0x1F]];
00194             <span class="keywordflow">case</span> 0x1F:
00195                 <span class="keywordflow">if</span> ((UCHAR)MultiByteString[0x1E] &lt; 0x20)    <span class="keywordflow">goto</span>  bad_case;
00196                 UnicodeString[0x1E] = TranslateTable[(UCHAR)MultiByteString[0x1E]];
00197             <span class="keywordflow">case</span> 0x1E:
00198                 <span class="keywordflow">if</span> ((UCHAR)MultiByteString[0x1D] &lt; 0x20)    <span class="keywordflow">goto</span>  bad_case;
00199                 UnicodeString[0x1D] = TranslateTable[(UCHAR)MultiByteString[0x1D]];
00200             <span class="keywordflow">case</span> 0x1D:
00201                 <span class="keywordflow">if</span> ((UCHAR)MultiByteString[0x1C] &lt; 0x20)    <span class="keywordflow">goto</span>  bad_case;
00202                 UnicodeString[0x1C] = TranslateTable[(UCHAR)MultiByteString[0x1C]];
00203             <span class="keywordflow">case</span> 0x1C:
00204                 <span class="keywordflow">if</span> ((UCHAR)MultiByteString[0x1B] &lt; 0x20)    <span class="keywordflow">goto</span>  bad_case;
00205                 UnicodeString[0x1B] = TranslateTable[(UCHAR)MultiByteString[0x1B]];
00206             <span class="keywordflow">case</span> 0x1B:
00207                 <span class="keywordflow">if</span> ((UCHAR)MultiByteString[0x1A] &lt; 0x20)    <span class="keywordflow">goto</span>  bad_case;
00208                 UnicodeString[0x1A] = TranslateTable[(UCHAR)MultiByteString[0x1A]];
00209             <span class="keywordflow">case</span> 0x1A:
00210                 <span class="keywordflow">if</span> ((UCHAR)MultiByteString[0x19] &lt; 0x20)    <span class="keywordflow">goto</span>  bad_case;
00211                 UnicodeString[0x19] = TranslateTable[(UCHAR)MultiByteString[0x19]];
00212             <span class="keywordflow">case</span> 0x19:
00213                 <span class="keywordflow">if</span> ((UCHAR)MultiByteString[0x18] &lt; 0x20)    <span class="keywordflow">goto</span>  bad_case;
00214                 UnicodeString[0x18] = TranslateTable[(UCHAR)MultiByteString[0x18]];
00215             <span class="keywordflow">case</span> 0x18:
00216                 <span class="keywordflow">if</span> ((UCHAR)MultiByteString[0x17] &lt; 0x20)    <span class="keywordflow">goto</span>  bad_case;
00217                 UnicodeString[0x17] = TranslateTable[(UCHAR)MultiByteString[0x17]];
00218             <span class="keywordflow">case</span> 0x17:
00219                 <span class="keywordflow">if</span> ((UCHAR)MultiByteString[0x16] &lt; 0x20)    <span class="keywordflow">goto</span>  bad_case;
00220                 UnicodeString[0x16] = TranslateTable[(UCHAR)MultiByteString[0x16]];
00221             <span class="keywordflow">case</span> 0x16:
00222                 <span class="keywordflow">if</span> ((UCHAR)MultiByteString[0x15] &lt; 0x20)    <span class="keywordflow">goto</span>  bad_case;
00223                 UnicodeString[0x15] = TranslateTable[(UCHAR)MultiByteString[0x15]];
00224             <span class="keywordflow">case</span> 0x15:
00225                 <span class="keywordflow">if</span> ((UCHAR)MultiByteString[0x14] &lt; 0x20)    <span class="keywordflow">goto</span>  bad_case;
00226                 UnicodeString[0x14] = TranslateTable[(UCHAR)MultiByteString[0x14]];
00227             <span class="keywordflow">case</span> 0x14:
00228                 <span class="keywordflow">if</span> ((UCHAR)MultiByteString[0x13] &lt; 0x20)    <span class="keywordflow">goto</span>  bad_case;
00229                 UnicodeString[0x13] = TranslateTable[(UCHAR)MultiByteString[0x13]];
00230             <span class="keywordflow">case</span> 0x13:
00231                 <span class="keywordflow">if</span> ((UCHAR)MultiByteString[0x12] &lt; 0x20)    <span class="keywordflow">goto</span>  bad_case;
00232                 UnicodeString[0x12] = TranslateTable[(UCHAR)MultiByteString[0x12]];
00233             <span class="keywordflow">case</span> 0x12:
00234                 <span class="keywordflow">if</span> ((UCHAR)MultiByteString[0x11] &lt; 0x20)    <span class="keywordflow">goto</span>  bad_case;
00235                 UnicodeString[0x11] = TranslateTable[(UCHAR)MultiByteString[0x11]];
00236             <span class="keywordflow">case</span> 0x11:
00237                 <span class="keywordflow">if</span> ((UCHAR)MultiByteString[0x10] &lt; 0x20)    <span class="keywordflow">goto</span>  bad_case;
00238                 UnicodeString[0x10] = TranslateTable[(UCHAR)MultiByteString[0x10]];
00239             <span class="keywordflow">case</span> 0x10:
00240                 <span class="keywordflow">if</span> ((UCHAR)MultiByteString[0x0F] &lt; 0x20)    <span class="keywordflow">goto</span>  bad_case;
00241                 UnicodeString[0x0F] = TranslateTable[(UCHAR)MultiByteString[0x0F]];
00242             <span class="keywordflow">case</span> 0x0F:
00243                 <span class="keywordflow">if</span> ((UCHAR)MultiByteString[0x0E] &lt; 0x20)    <span class="keywordflow">goto</span>  bad_case;
00244                 UnicodeString[0x0E] = TranslateTable[(UCHAR)MultiByteString[0x0E]];
00245             <span class="keywordflow">case</span> 0x0E:
00246                 <span class="keywordflow">if</span> ((UCHAR)MultiByteString[0x0D] &lt; 0x20)    <span class="keywordflow">goto</span>  bad_case;
00247                 UnicodeString[0x0D] = TranslateTable[(UCHAR)MultiByteString[0x0D]];
00248             <span class="keywordflow">case</span> 0x0D:
00249                 <span class="keywordflow">if</span> ((UCHAR)MultiByteString[0x0C] &lt; 0x20)    <span class="keywordflow">goto</span>  bad_case;
00250                 UnicodeString[0x0C] = TranslateTable[(UCHAR)MultiByteString[0x0C]];
00251             <span class="keywordflow">case</span> 0x0C:
00252                 <span class="keywordflow">if</span> ((UCHAR)MultiByteString[0x0B] &lt; 0x20)    <span class="keywordflow">goto</span>  bad_case;
00253                 UnicodeString[0x0B] = TranslateTable[(UCHAR)MultiByteString[0x0B]];
00254             <span class="keywordflow">case</span> 0x0B:
00255                 <span class="keywordflow">if</span> ((UCHAR)MultiByteString[0x0A] &lt; 0x20)    <span class="keywordflow">goto</span>  bad_case;
00256                 UnicodeString[0x0A] = TranslateTable[(UCHAR)MultiByteString[0x0A]];
00257             <span class="keywordflow">case</span> 0x0A:
00258                 <span class="keywordflow">if</span> ((UCHAR)MultiByteString[0x09] &lt; 0x20)    <span class="keywordflow">goto</span>  bad_case;
00259                 UnicodeString[0x09] = TranslateTable[(UCHAR)MultiByteString[0x09]];
00260             <span class="keywordflow">case</span> 0x09:
00261                 <span class="keywordflow">if</span> ((UCHAR)MultiByteString[0x08] &lt; 0x20)    <span class="keywordflow">goto</span>  bad_case;
00262                 UnicodeString[0x08] = TranslateTable[(UCHAR)MultiByteString[0x08]];
00263             <span class="keywordflow">case</span> 0x08:
00264                 <span class="keywordflow">if</span> ((UCHAR)MultiByteString[0x07] &lt; 0x20)    <span class="keywordflow">goto</span>  bad_case;
00265                 UnicodeString[0x07] = TranslateTable[(UCHAR)MultiByteString[0x07]];
00266             <span class="keywordflow">case</span> 0x07:
00267                 <span class="keywordflow">if</span> ((UCHAR)MultiByteString[0x06] &lt; 0x20)    <span class="keywordflow">goto</span>  bad_case;
00268                 UnicodeString[0x06] = TranslateTable[(UCHAR)MultiByteString[0x06]];
00269             <span class="keywordflow">case</span> 0x06:
00270                 <span class="keywordflow">if</span> ((UCHAR)MultiByteString[0x05] &lt; 0x20)    <span class="keywordflow">goto</span>  bad_case;
00271                 UnicodeString[0x05] = TranslateTable[(UCHAR)MultiByteString[0x05]];
00272             <span class="keywordflow">case</span> 0x05:
00273                 <span class="keywordflow">if</span> ((UCHAR)MultiByteString[0x04] &lt; 0x20)    <span class="keywordflow">goto</span>  bad_case;
00274                 UnicodeString[0x04] = TranslateTable[(UCHAR)MultiByteString[0x04]];
00275             <span class="keywordflow">case</span> 0x04:
00276                 <span class="keywordflow">if</span> ((UCHAR)MultiByteString[0x03] &lt; 0x20)    <span class="keywordflow">goto</span>  bad_case;
00277                 UnicodeString[0x03] = TranslateTable[(UCHAR)MultiByteString[0x03]];
00278             <span class="keywordflow">case</span> 0x03:
00279                 <span class="keywordflow">if</span> ((UCHAR)MultiByteString[0x02] &lt; 0x20)    <span class="keywordflow">goto</span>  bad_case;
00280                 UnicodeString[0x02] = TranslateTable[(UCHAR)MultiByteString[0x02]];
00281             <span class="keywordflow">case</span> 0x02:
00282                 <span class="keywordflow">if</span> ((UCHAR)MultiByteString[0x01] &lt; 0x20)    <span class="keywordflow">goto</span>  bad_case;
00283                 UnicodeString[0x01] = TranslateTable[(UCHAR)MultiByteString[0x01]];
00284             <span class="keywordflow">case</span> 0x01:
00285                 <span class="keywordflow">if</span> ((UCHAR)MultiByteString[0x00] &lt; 0x20)    <span class="keywordflow">goto</span>  bad_case;
00286                 UnicodeString[0x00] = TranslateTable[(UCHAR)MultiByteString[0x00]];
00287             <span class="keywordflow">case</span> 0x00:
00288                 ;
00289             }
00290 
00291             <span class="keywordflow">if</span> ( LoopCount &gt; 0x20 ) {
00292                 LoopCount -= 0x20;
00293                 UnicodeString += 0x20;
00294                 MultiByteString += 0x20;
00295 
00296                 <span class="keywordflow">goto</span>  quick_copy;
00297             }
00298         <span class="comment">/* end of copy... */</span>
00299     } <span class="keywordflow">else</span> {
00300         <span class="keyword">register</span> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> Entry;
00301 
00302         PWCH UnicodeStringAnchor = UnicodeString;
00303         TranslateTable = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>)<a class="code" href="../../d9/d6/nlsxlat_8c.html#a15">NlsMbAnsiCodePageTables</a>;
00304 
00305         <span class="comment">// yea, this line is duplicated, but the compiler can handle opt</span>
00306         <span class="comment">// better by moving it around</span>
00307         MaxCharsInUnicodeString = MaxBytesInUnicodeString / <span class="keyword">sizeof</span>(WCHAR);
00308 
00309         <span class="comment">//</span>
00310         <span class="comment">// The ACP is a multibyte code page.  Check each character</span>
00311         <span class="comment">// to see if it is a lead byte before doing the translation.</span>
00312         <span class="comment">//</span>
00313         <span class="keywordflow">while</span> (MaxCharsInUnicodeString &amp;&amp; BytesInMultiByteString) {
00314             MaxCharsInUnicodeString--;
00315             BytesInMultiByteString--;
00316             <span class="keywordflow">if</span> (<a class="code" href="../../d6/d6/nls_8c.html#a20">NlsLeadByteInfo</a>[*(PUCHAR)MultiByteString]) {
00317                 <span class="comment">//</span>
00318                 <span class="comment">// Lead byte - Make sure there is a trail byte.  If not,</span>
00319                 <span class="comment">// pass back a space rather than an error.  Some 3.x</span>
00320                 <span class="comment">// applications pass incorrect strings and don't expect</span>
00321                 <span class="comment">// to get an error.</span>
00322                 <span class="comment">//</span>
00323                 <span class="keywordflow">if</span> (BytesInMultiByteString == 0)
00324                 {
00325                     *UnicodeString++ = <a class="code" href="../../d9/d6/nlsxlat_8c.html#a30">UnicodeNull</a>;
00326                     <span class="keywordflow">break</span>;
00327                 }
00328 
00329                 <span class="comment">//</span>
00330                 <span class="comment">// Get the unicode character.</span>
00331                 <span class="comment">//</span>
00332                 Entry = <a class="code" href="../../d6/d6/nls_8c.html#a20">NlsLeadByteInfo</a>[*(PUCHAR)MultiByteString++];
00333                 *UnicodeString = (WCHAR)TranslateTable[ Entry + *(PUCHAR)MultiByteString++ ];
00334                 UnicodeString++;
00335 
00336                 <span class="comment">//</span>
00337                 <span class="comment">// Decrement count of bytes in multibyte string to account</span>
00338                 <span class="comment">// for the double byte character.</span>
00339                 <span class="comment">//</span>
00340                 BytesInMultiByteString--;
00341             } <span class="keywordflow">else</span> {
00342                 <span class="comment">//</span>
00343                 <span class="comment">// Single byte character.</span>
00344                 <span class="comment">//</span>
00345                 <span class="keywordflow">if</span> ((UCHAR)MultiByteString[0x00] &lt; 0x20)
00346                     *pdwSpecialChar = 1;
00347                 *UnicodeString++ = <a class="code" href="../../d6/d6/nls_8c.html#a19">NlsAnsiToUnicodeData</a>[*(PUCHAR)MultiByteString++];
00348             }
00349         }
00350 
00351         <span class="keywordflow">if</span> (ARGUMENT_PRESENT(BytesInUnicodeString))
00352             *BytesInUnicodeString = (ULONG)((PCH)UnicodeString - (PCH)UnicodeStringAnchor);
00353     }
00354 
00355     <span class="keywordflow">return</span> STATUS_SUCCESS;
00356 
00357     bad_case:
00358         <span class="comment">//</span>
00359         <span class="comment">// this is a low probability case, so we optimized the loop.  If have a</span>
00360         <span class="comment">// special char, finish trans and notify caller.</span>
00361         <span class="comment">//</span>
00362         *pdwSpecialChar = 1;
00363         <span class="keywordflow">return</span> <a class="code" href="../../d9/d6/nlsxlat_8c.html#a33">RtlMultiByteToUnicodeN</a>(UnicodeString, MaxBytesInUnicodeString,
00364                 <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, MultiByteString, LoopCount);
00365 }
00366 
00367 
00368 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00369"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a33">00369</a> <a class="code" href="../../d9/d6/nlsxlat_8c.html#a33">RtlMultiByteToUnicodeN</a>(
00370     OUT PWCH UnicodeString,
00371     IN ULONG MaxBytesInUnicodeString,
00372     OUT PULONG BytesInUnicodeString OPTIONAL,
00373     IN PCH MultiByteString,
00374     IN ULONG BytesInMultiByteString)
00375 
00376 <span class="comment">/*++</span>
00377 <span class="comment"></span>
00378 <span class="comment">Routine Description:</span>
00379 <span class="comment"></span>
00380 <span class="comment">    This functions converts the specified ansi source string into a</span>
00381 <span class="comment">    Unicode string. The translation is done with respect to the</span>
00382 <span class="comment">    ANSI Code Page (ACP) installed at boot time.  Single byte characters</span>
00383 <span class="comment">    in the range 0x00 - 0x7f are simply zero extended as a performance</span>
00384 <span class="comment">    enhancement.  In some far eastern code pages 0x5c is defined as the</span>
00385 <span class="comment">    Yen sign.  For system translation we always want to consider 0x5c</span>
00386 <span class="comment">    to be the backslash character.  We get this for free by zero extending.</span>
00387 <span class="comment"></span>
00388 <span class="comment">    NOTE: This routine only supports precomposed Unicode characters.</span>
00389 <span class="comment"></span>
00390 <span class="comment">Arguments:</span>
00391 <span class="comment"></span>
00392 <span class="comment">    UnicodeString - Returns a unicode string that is equivalent to</span>
00393 <span class="comment">        the ansi source string.</span>
00394 <span class="comment"></span>
00395 <span class="comment">    MaxBytesInUnicodeString - Supplies the maximum number of bytes to be</span>
00396 <span class="comment">        written to UnicodeString.  If this causes UnicodeString to be a</span>
00397 <span class="comment">        truncated equivalent of MultiByteString, no error condition results.</span>
00398 <span class="comment"></span>
00399 <span class="comment">    BytesInUnicodeString - Returns the number of bytes in the returned</span>
00400 <span class="comment">        unicode string pointed to by UnicodeString.</span>
00401 <span class="comment"></span>
00402 <span class="comment">    MultiByteString - Supplies the ansi source string that is to be</span>
00403 <span class="comment">        converted to unicode.  For single-byte character sets, this address</span>
00404 <span class="comment">        CAN be the same as UnicodeString.</span>
00405 <span class="comment"></span>
00406 <span class="comment">    BytesInMultiByteString - The number of bytes in the string pointed to</span>
00407 <span class="comment">        by MultiByteString.</span>
00408 <span class="comment"></span>
00409 <span class="comment">Return Value:</span>
00410 <span class="comment"></span>
00411 <span class="comment">    SUCCESS - The conversion was successful.</span>
00412 <span class="comment"></span>
00413 <span class="comment"></span>
00414 <span class="comment">--*/</span>
00415 
00416 {
00417     ULONG LoopCount;
00418     ULONG TmpCount;
00419     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a> TranslateTable;
00420     ULONG MaxCharsInUnicodeString;
00421 
00422     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00423 
00424     <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d6/nlsxlat_8c.html#a19">NlsMbCodePageTag</a>) {
00425         MaxCharsInUnicodeString = MaxBytesInUnicodeString / <span class="keyword">sizeof</span>(WCHAR);
00426 
00427         LoopCount = (MaxCharsInUnicodeString &lt; BytesInMultiByteString) ?
00428                      MaxCharsInUnicodeString : BytesInMultiByteString;
00429 
00430         <span class="keywordflow">if</span> (ARGUMENT_PRESENT(BytesInUnicodeString))
00431             *BytesInUnicodeString = LoopCount * <span class="keyword">sizeof</span>(WCHAR);
00432 
00433         TranslateTable = <a class="code" href="../../d6/d6/nls_8c.html#a19">NlsAnsiToUnicodeData</a>;  <span class="comment">// used to help the mips compiler</span>
00434 
00435         TmpCount = LoopCount &amp; 0x1F;
00436         UnicodeString += (LoopCount - TmpCount);
00437         MultiByteString += (LoopCount - TmpCount);
00438         quick_copy:
00439             <span class="keywordflow">switch</span>( TmpCount ) {
00440             <span class="keywordflow">default</span>:
00441                 UnicodeString[0x1F] = TranslateTable[(UCHAR)MultiByteString[0x1F]];
00442             <span class="keywordflow">case</span> 0x1F:
00443                 UnicodeString[0x1E] = TranslateTable[(UCHAR)MultiByteString[0x1E]];
00444             <span class="keywordflow">case</span> 0x1E:
00445                 UnicodeString[0x1D] = TranslateTable[(UCHAR)MultiByteString[0x1D]];
00446             <span class="keywordflow">case</span> 0x1D:
00447                 UnicodeString[0x1C] = TranslateTable[(UCHAR)MultiByteString[0x1C]];
00448             <span class="keywordflow">case</span> 0x1C:
00449                 UnicodeString[0x1B] = TranslateTable[(UCHAR)MultiByteString[0x1B]];
00450             <span class="keywordflow">case</span> 0x1B:
00451                 UnicodeString[0x1A] = TranslateTable[(UCHAR)MultiByteString[0x1A]];
00452             <span class="keywordflow">case</span> 0x1A:
00453                 UnicodeString[0x19] = TranslateTable[(UCHAR)MultiByteString[0x19]];
00454             <span class="keywordflow">case</span> 0x19:
00455                 UnicodeString[0x18] = TranslateTable[(UCHAR)MultiByteString[0x18]];
00456             <span class="keywordflow">case</span> 0x18:
00457                 UnicodeString[0x17] = TranslateTable[(UCHAR)MultiByteString[0x17]];
00458             <span class="keywordflow">case</span> 0x17:
00459                 UnicodeString[0x16] = TranslateTable[(UCHAR)MultiByteString[0x16]];
00460             <span class="keywordflow">case</span> 0x16:
00461                 UnicodeString[0x15] = TranslateTable[(UCHAR)MultiByteString[0x15]];
00462             <span class="keywordflow">case</span> 0x15:
00463                 UnicodeString[0x14] = TranslateTable[(UCHAR)MultiByteString[0x14]];
00464             <span class="keywordflow">case</span> 0x14:
00465                 UnicodeString[0x13] = TranslateTable[(UCHAR)MultiByteString[0x13]];
00466             <span class="keywordflow">case</span> 0x13:
00467                 UnicodeString[0x12] = TranslateTable[(UCHAR)MultiByteString[0x12]];
00468             <span class="keywordflow">case</span> 0x12:
00469                 UnicodeString[0x11] = TranslateTable[(UCHAR)MultiByteString[0x11]];
00470             <span class="keywordflow">case</span> 0x11:
00471                 UnicodeString[0x10] = TranslateTable[(UCHAR)MultiByteString[0x10]];
00472             <span class="keywordflow">case</span> 0x10:
00473                 UnicodeString[0x0F] = TranslateTable[(UCHAR)MultiByteString[0x0F]];
00474             <span class="keywordflow">case</span> 0x0F:
00475                 UnicodeString[0x0E] = TranslateTable[(UCHAR)MultiByteString[0x0E]];
00476             <span class="keywordflow">case</span> 0x0E:
00477                 UnicodeString[0x0D] = TranslateTable[(UCHAR)MultiByteString[0x0D]];
00478             <span class="keywordflow">case</span> 0x0D:
00479                 UnicodeString[0x0C] = TranslateTable[(UCHAR)MultiByteString[0x0C]];
00480             <span class="keywordflow">case</span> 0x0C:
00481                 UnicodeString[0x0B] = TranslateTable[(UCHAR)MultiByteString[0x0B]];
00482             <span class="keywordflow">case</span> 0x0B:
00483                 UnicodeString[0x0A] = TranslateTable[(UCHAR)MultiByteString[0x0A]];
00484             <span class="keywordflow">case</span> 0x0A:
00485                 UnicodeString[0x09] = TranslateTable[(UCHAR)MultiByteString[0x09]];
00486             <span class="keywordflow">case</span> 0x09:
00487                 UnicodeString[0x08] = TranslateTable[(UCHAR)MultiByteString[0x08]];
00488             <span class="keywordflow">case</span> 0x08:
00489                 UnicodeString[0x07] = TranslateTable[(UCHAR)MultiByteString[0x07]];
00490             <span class="keywordflow">case</span> 0x07:
00491                 UnicodeString[0x06] = TranslateTable[(UCHAR)MultiByteString[0x06]];
00492             <span class="keywordflow">case</span> 0x06:
00493                 UnicodeString[0x05] = TranslateTable[(UCHAR)MultiByteString[0x05]];
00494             <span class="keywordflow">case</span> 0x05:
00495                 UnicodeString[0x04] = TranslateTable[(UCHAR)MultiByteString[0x04]];
00496             <span class="keywordflow">case</span> 0x04:
00497                 UnicodeString[0x03] = TranslateTable[(UCHAR)MultiByteString[0x03]];
00498             <span class="keywordflow">case</span> 0x03:
00499                 UnicodeString[0x02] = TranslateTable[(UCHAR)MultiByteString[0x02]];
00500             <span class="keywordflow">case</span> 0x02:
00501                 UnicodeString[0x01] = TranslateTable[(UCHAR)MultiByteString[0x01]];
00502             <span class="keywordflow">case</span> 0x01:
00503                 UnicodeString[0x00] = TranslateTable[(UCHAR)MultiByteString[0x00]];
00504             <span class="keywordflow">case</span> 0x00:
00505                 ;
00506             }
00507 
00508             <span class="keywordflow">if</span> ( LoopCount &gt;= 0x20 ) {
00509                 TmpCount = 0x20;
00510                 LoopCount -= 0x20;
00511                 UnicodeString -= 0x20;
00512                 MultiByteString -= 0x20;
00513 
00514                 <span class="keywordflow">goto</span>  quick_copy;
00515             }
00516         <span class="comment">/* end of copy... */</span>
00517     } <span class="keywordflow">else</span> {
00518         <span class="keyword">register</span> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> Entry;
00519         PWCH UnicodeStringAnchor = UnicodeString;
00520         TranslateTable = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>)<a class="code" href="../../d9/d6/nlsxlat_8c.html#a15">NlsMbAnsiCodePageTables</a>;
00521 
00522         <span class="comment">// yea, this line is duplicated, but the compiler can handle opt</span>
00523         <span class="comment">// better buy moving it around</span>
00524         MaxCharsInUnicodeString = MaxBytesInUnicodeString / <span class="keyword">sizeof</span>(WCHAR);
00525 
00526         <span class="comment">//</span>
00527         <span class="comment">// The ACP is a multibyte code page.  Check each character</span>
00528         <span class="comment">// to see if it is a lead byte before doing the translation.</span>
00529         <span class="comment">//</span>
00530         <span class="keywordflow">while</span> (MaxCharsInUnicodeString &amp;&amp; BytesInMultiByteString) {
00531             MaxCharsInUnicodeString--;
00532             BytesInMultiByteString--;
00533             <span class="keywordflow">if</span> (<a class="code" href="../../d6/d6/nls_8c.html#a20">NlsLeadByteInfo</a>[*(PUCHAR)MultiByteString]) {
00534                 <span class="comment">//</span>
00535                 <span class="comment">// Lead byte - Make sure there is a trail byte.  If not,</span>
00536                 <span class="comment">// pass back a space rather than an error.  Some 3.x</span>
00537                 <span class="comment">// applications pass incorrect strings and don't expect</span>
00538                 <span class="comment">// to get an error.</span>
00539                 <span class="comment">//</span>
00540                 <span class="keywordflow">if</span> (BytesInMultiByteString == 0)
00541                 {
00542                     *UnicodeString++ = <a class="code" href="../../d9/d6/nlsxlat_8c.html#a30">UnicodeNull</a>;
00543                     <span class="keywordflow">break</span>;
00544                 }
00545 
00546                 <span class="comment">//</span>
00547                 <span class="comment">// Get the unicode character.</span>
00548                 <span class="comment">//</span>
00549                 Entry = <a class="code" href="../../d6/d6/nls_8c.html#a20">NlsLeadByteInfo</a>[*(PUCHAR)MultiByteString++];
00550                 *UnicodeString = (WCHAR)TranslateTable[ Entry + *(PUCHAR)MultiByteString++ ];
00551                 UnicodeString++;
00552 
00553                 <span class="comment">//</span>
00554                 <span class="comment">// Decrement count of bytes in multibyte string to account</span>
00555                 <span class="comment">// for the double byte character.</span>
00556                 <span class="comment">//</span>
00557                 BytesInMultiByteString--;
00558             } <span class="keywordflow">else</span> {
00559                 <span class="comment">//</span>
00560                 <span class="comment">// Single byte character.</span>
00561                 <span class="comment">//</span>
00562                 *UnicodeString++ = <a class="code" href="../../d6/d6/nls_8c.html#a19">NlsAnsiToUnicodeData</a>[*(PUCHAR)MultiByteString++];
00563             }
00564         }
00565 
00566         <span class="keywordflow">if</span> (ARGUMENT_PRESENT(BytesInUnicodeString))
00567             *BytesInUnicodeString = (ULONG)((PCH)UnicodeString - (PCH)UnicodeStringAnchor);
00568     }
00569 
00570     <span class="keywordflow">return</span> STATUS_SUCCESS;
00571 
00572 }
00573 
00574 
00575 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00576"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a34">00576</a> <a class="code" href="../../d9/d6/nlsxlat_8c.html#a34">RtlOemToUnicodeN</a>(
00577     OUT PWCH UnicodeString,
00578     IN ULONG MaxBytesInUnicodeString,
00579     OUT PULONG BytesInUnicodeString OPTIONAL,
00580     IN PCH OemString,
00581     IN ULONG BytesInOemString)
00582 
00583 <span class="comment">/*++</span>
00584 <span class="comment"></span>
00585 <span class="comment">Routine Description:</span>
00586 <span class="comment"></span>
00587 <span class="comment">    This functions converts the specified oem source string into a</span>
00588 <span class="comment">    Unicode string. The translation is done with respect to the</span>
00589 <span class="comment">    OEM Code Page (OCP) installed at boot time.  Single byte characters</span>
00590 <span class="comment">    in the range 0x00 - 0x7f are simply zero extended as a performance</span>
00591 <span class="comment">    enhancement.  In some far eastern code pages 0x5c is defined as the</span>
00592 <span class="comment">    Yen sign.  For system translation we always want to consider 0x5c</span>
00593 <span class="comment">    to be the backslash character.  We get this for free by zero extending.</span>
00594 <span class="comment"></span>
00595 <span class="comment">    NOTE: This routine only supports precomposed Unicode characters.</span>
00596 <span class="comment"></span>
00597 <span class="comment">Arguments:</span>
00598 <span class="comment"></span>
00599 <span class="comment">    UnicodeString - Returns a unicode string that is equivalent to</span>
00600 <span class="comment">        the oem source string.</span>
00601 <span class="comment"></span>
00602 <span class="comment">    MaxBytesInUnicodeString - Supplies the maximum number of bytes to be</span>
00603 <span class="comment">        written to UnicodeString.  If this causes UnicodeString to be a</span>
00604 <span class="comment">        truncated equivalent of OemString, no error condition results.</span>
00605 <span class="comment"></span>
00606 <span class="comment">    BytesInUnicodeString - Returns the number of bytes in the returned</span>
00607 <span class="comment">        unicode string pointed to by UnicodeString.</span>
00608 <span class="comment"></span>
00609 <span class="comment">    OemString - Supplies the oem source string that is to be</span>
00610 <span class="comment">        converted to unicode.</span>
00611 <span class="comment"></span>
00612 <span class="comment">    BytesInOemString - The number of bytes in the string pointed to</span>
00613 <span class="comment">        by OemString.</span>
00614 <span class="comment"></span>
00615 <span class="comment">Return Value:</span>
00616 <span class="comment"></span>
00617 <span class="comment">    SUCCESS - The conversion was successful</span>
00618 <span class="comment"></span>
00619 <span class="comment">    STATUS_ILLEGAL_CHARACTER - The final Oem character was illegal</span>
00620 <span class="comment"></span>
00621 <span class="comment">    STATUS_BUFFER_OVERFLOW - MaxBytesInUnicodeString was not enough to hold</span>
00622 <span class="comment">        the whole Oem string.  It was converted correct to the point though.</span>
00623 <span class="comment"></span>
00624 <span class="comment">--*/</span>
00625 
00626 {
00627     ULONG LoopCount;
00628     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a> TranslateTable;
00629     ULONG MaxCharsInUnicodeString;
00630 
00631     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00632 
00633     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d9/gen8dot3_8c.html#a5">NlsMbOemCodePageTag</a>) {
00634         <span class="comment">//</span>
00635         <span class="comment">// The OCP is a single byte code page.</span>
00636         <span class="comment">//</span>
00637         MaxCharsInUnicodeString = MaxBytesInUnicodeString / <span class="keyword">sizeof</span>(WCHAR);
00638 
00639         LoopCount = (MaxCharsInUnicodeString &lt; BytesInOemString) ?
00640                      MaxCharsInUnicodeString : BytesInOemString;
00641 
00642         <span class="keywordflow">if</span> (ARGUMENT_PRESENT(BytesInUnicodeString))
00643             *BytesInUnicodeString = LoopCount * <span class="keyword">sizeof</span>(WCHAR);
00644 
00645 
00646         TranslateTable = <a class="code" href="../../d5/d9/gen8dot3_8c.html#a2">NlsOemToUnicodeData</a>;  <span class="comment">// used to help the mips compiler</span>
00647 
00648         quick_copy:
00649             <span class="keywordflow">switch</span>( LoopCount ) {
00650             <span class="keywordflow">default</span>:
00651                 UnicodeString[0x0F] = TranslateTable[(UCHAR)OemString[0x0F]];
00652             <span class="keywordflow">case</span> 0x0F:
00653                 UnicodeString[0x0E] = TranslateTable[(UCHAR)OemString[0x0E]];
00654             <span class="keywordflow">case</span> 0x0E:
00655                 UnicodeString[0x0D] = TranslateTable[(UCHAR)OemString[0x0D]];
00656             <span class="keywordflow">case</span> 0x0D:
00657                 UnicodeString[0x0C] = TranslateTable[(UCHAR)OemString[0x0C]];
00658             <span class="keywordflow">case</span> 0x0C:
00659                 UnicodeString[0x0B] = TranslateTable[(UCHAR)OemString[0x0B]];
00660             <span class="keywordflow">case</span> 0x0B:
00661                 UnicodeString[0x0A] = TranslateTable[(UCHAR)OemString[0x0A]];
00662             <span class="keywordflow">case</span> 0x0A:
00663                 UnicodeString[0x09] = TranslateTable[(UCHAR)OemString[0x09]];
00664             <span class="keywordflow">case</span> 0x09:
00665                 UnicodeString[0x08] = TranslateTable[(UCHAR)OemString[0x08]];
00666             <span class="keywordflow">case</span> 0x08:
00667                 UnicodeString[0x07] = TranslateTable[(UCHAR)OemString[0x07]];
00668             <span class="keywordflow">case</span> 0x07:
00669                 UnicodeString[0x06] = TranslateTable[(UCHAR)OemString[0x06]];
00670             <span class="keywordflow">case</span> 0x06:
00671                 UnicodeString[0x05] = TranslateTable[(UCHAR)OemString[0x05]];
00672             <span class="keywordflow">case</span> 0x05:
00673                 UnicodeString[0x04] = TranslateTable[(UCHAR)OemString[0x04]];
00674             <span class="keywordflow">case</span> 0x04:
00675                 UnicodeString[0x03] = TranslateTable[(UCHAR)OemString[0x03]];
00676             <span class="keywordflow">case</span> 0x03:
00677                 UnicodeString[0x02] = TranslateTable[(UCHAR)OemString[0x02]];
00678             <span class="keywordflow">case</span> 0x02:
00679                 UnicodeString[0x01] = TranslateTable[(UCHAR)OemString[0x01]];
00680             <span class="keywordflow">case</span> 0x01:
00681                 UnicodeString[0x00] = TranslateTable[(UCHAR)OemString[0x00]];
00682             <span class="keywordflow">case</span> 0x00:
00683                 ;
00684             }
00685 
00686             <span class="keywordflow">if</span> ( LoopCount &gt; 0x10 ) {
00687                 LoopCount -= 0x10;
00688                 OemString += 0x10;
00689                 UnicodeString += 0x10;
00690 
00691                 <span class="keywordflow">goto</span>  quick_copy;
00692             }
00693         <span class="comment">/* end of copy... */</span>
00694     } <span class="keywordflow">else</span> {
00695         <span class="keyword">register</span> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> Entry;
00696         PWCH UnicodeStringAnchor = UnicodeString;
00697 
00698         <span class="comment">//</span>
00699         <span class="comment">// The OCP is a multibyte code page.  Check each character</span>
00700         <span class="comment">// to see if it is a lead byte before doing the translation.</span>
00701         <span class="comment">//</span>
00702         MaxCharsInUnicodeString = MaxBytesInUnicodeString / <span class="keyword">sizeof</span>(WCHAR);
00703         TranslateTable = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>)<a class="code" href="../../d5/d9/gen8dot3_8c.html#a4">NlsMbOemCodePageTables</a>;
00704 
00705         <span class="keywordflow">while</span> (MaxCharsInUnicodeString &amp;&amp; BytesInOemString) {
00706             MaxCharsInUnicodeString--;
00707             BytesInOemString--;
00708             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d9/gen8dot3_8c.html#a6">NlsOemLeadByteInfo</a>[*(PUCHAR)OemString]) {
00709                 <span class="comment">//</span>
00710                 <span class="comment">// Lead byte - Make sure there is a trail byte.  If not,</span>
00711                 <span class="comment">// pass back a space rather than an error.  Some 3.x</span>
00712                 <span class="comment">// applications pass incorrect strings and don't expect</span>
00713                 <span class="comment">// to get an error.</span>
00714                 <span class="comment">//</span>
00715                 <span class="keywordflow">if</span> (BytesInOemString == 0)
00716                 {
00717                     *UnicodeString++ = <a class="code" href="../../d9/d6/nlsxlat_8c.html#a30">UnicodeNull</a>;
00718                     <span class="keywordflow">break</span>;
00719                 }
00720 
00721                 <span class="comment">//</span>
00722                 <span class="comment">// Get the unicode character.</span>
00723                 <span class="comment">//</span>
00724                 Entry = <a class="code" href="../../d5/d9/gen8dot3_8c.html#a6">NlsOemLeadByteInfo</a>[*(PUCHAR)OemString++];
00725                 *UnicodeString = TranslateTable[ Entry + *(PUCHAR)OemString++ ];
00726                 UnicodeString++;
00727 
00728                 <span class="comment">//</span>
00729                 <span class="comment">// Decrement count of bytes in oem string to account</span>
00730                 <span class="comment">// for the double byte character.</span>
00731                 <span class="comment">//</span>
00732                 BytesInOemString--;
00733             } <span class="keywordflow">else</span> {
00734                 <span class="comment">//</span>
00735                 <span class="comment">// Single byte character.</span>
00736                 <span class="comment">//</span>
00737                 *UnicodeString++ = <a class="code" href="../../d5/d9/gen8dot3_8c.html#a2">NlsOemToUnicodeData</a>[*(PUCHAR)OemString++];
00738             }
00739         }
00740 
00741         <span class="keywordflow">if</span> (ARGUMENT_PRESENT(BytesInUnicodeString))
00742             *BytesInUnicodeString = (ULONG)((PCH)UnicodeString - (PCH)UnicodeStringAnchor);
00743     }
00744 
00745     <span class="comment">//</span>
00746     <span class="comment">//  Check if we were able to use all of the source Oem String</span>
00747     <span class="comment">//</span>
00748     <span class="keywordflow">return</span> (BytesInOemString &lt;= MaxCharsInUnicodeString) ?
00749            STATUS_SUCCESS :
00750            STATUS_BUFFER_OVERFLOW;
00751 }
00752 
00753 
00754 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00755"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a35">00755</a> <a class="code" href="../../d9/d6/nlsxlat_8c.html#a35">RtlMultiByteToUnicodeSize</a>(
00756     OUT PULONG BytesInUnicodeString,
00757     IN PCH MultiByteString,
00758     IN ULONG BytesInMultiByteString)
00759 
00760 <span class="comment">/*++</span>
00761 <span class="comment"></span>
00762 <span class="comment">Routine Description:</span>
00763 <span class="comment"></span>
00764 <span class="comment">    This functions determines how many bytes would be needed to represent</span>
00765 <span class="comment">    the specified ANSI source string in Unicode string (not counting the</span>
00766 <span class="comment">    null terminator)</span>
00767 <span class="comment">    The translation is done with respect to the ANSI Code Page (ACP) installed</span>
00768 <span class="comment">    at boot time.  Single byte characters in the range 0x00 - 0x7f are simply</span>
00769 <span class="comment">    zero extended as a performance enhancement.  In some far eastern code pages</span>
00770 <span class="comment">    0x5c is defined as the Yen sign.  For system translation we always want to</span>
00771 <span class="comment">    consider 0x5c to be the backslash character.  We get this for free by zero</span>
00772 <span class="comment">    extending.</span>
00773 <span class="comment"></span>
00774 <span class="comment">    NOTE: This routine only supports precomposed Unicode characters.</span>
00775 <span class="comment"></span>
00776 <span class="comment">Arguments:</span>
00777 <span class="comment"></span>
00778 <span class="comment">    BytesInUnicodeString - Returns the number of bytes a Unicode translation</span>
00779 <span class="comment">        of the ANSI string pointed to by MultiByteString would contain.</span>
00780 <span class="comment"></span>
00781 <span class="comment">    MultiByteString - Supplies the ansi source string whose Unicode length</span>
00782 <span class="comment">        is to be calculated.</span>
00783 <span class="comment"></span>
00784 <span class="comment">    BytesInMultiByteString - The number of bytes in the string pointed to</span>
00785 <span class="comment">        by MultiByteString.</span>
00786 <span class="comment"></span>
00787 <span class="comment">Return Value:</span>
00788 <span class="comment"></span>
00789 <span class="comment">    SUCCESS - The conversion was successful</span>
00790 <span class="comment"></span>
00791 <span class="comment"></span>
00792 <span class="comment">--*/</span>
00793 
00794 {
00795     ULONG cbUnicode = 0;
00796 
00797     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00798 
00799     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d6/nlsxlat_8c.html#a19">NlsMbCodePageTag</a>) {
00800         <span class="comment">//</span>
00801         <span class="comment">// The ACP is a multibyte code page.  Check each character</span>
00802         <span class="comment">// to see if it is a lead byte before doing the translation.</span>
00803         <span class="comment">//</span>
00804         <span class="keywordflow">while</span> (BytesInMultiByteString--) {
00805             <span class="keywordflow">if</span> (<a class="code" href="../../d6/d6/nls_8c.html#a20">NlsLeadByteInfo</a>[*(PUCHAR)MultiByteString++]) {
00806                 <span class="comment">//</span>
00807                 <span class="comment">// Lead byte - translate the trail byte using the table</span>
00808                 <span class="comment">// that corresponds to this lead byte.  NOTE: make sure</span>
00809                 <span class="comment">// we have a trail byte to convert.</span>
00810                 <span class="comment">//</span>
00811                 <span class="keywordflow">if</span> (BytesInMultiByteString == 0) {
00812                     <span class="comment">//</span>
00813                     <span class="comment">// RtlMultibyteToUnicodeN() uses the unicode</span>
00814                     <span class="comment">// default character if the last multibyte</span>
00815                     <span class="comment">// character is a lead byte.</span>
00816                     <span class="comment">//</span>
00817                     cbUnicode += <span class="keyword">sizeof</span>(WCHAR);
00818                     <span class="keywordflow">break</span>;
00819                 } <span class="keywordflow">else</span> {
00820                     BytesInMultiByteString--;
00821                     MultiByteString++;
00822                 }
00823             }
00824             cbUnicode += <span class="keyword">sizeof</span>(WCHAR);
00825         }
00826         *BytesInUnicodeString = cbUnicode;
00827     } <span class="keywordflow">else</span> {
00828         <span class="comment">//</span>
00829         <span class="comment">// The ACP is a single byte code page.</span>
00830         <span class="comment">//</span>
00831         *BytesInUnicodeString = BytesInMultiByteString * <span class="keyword">sizeof</span>(WCHAR);
00832     }
00833 
00834     <span class="keywordflow">return</span> STATUS_SUCCESS;
00835 }
00836 
00837 
00838 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00839"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a36">00839</a> <a class="code" href="../../d9/d6/nlsxlat_8c.html#a36">RtlUnicodeToMultiByteSize</a>(
00840     OUT PULONG BytesInMultiByteString,
00841     IN PWCH UnicodeString,
00842     IN ULONG BytesInUnicodeString)
00843 
00844 <span class="comment">/*++</span>
00845 <span class="comment"></span>
00846 <span class="comment">Routine Description:</span>
00847 <span class="comment"></span>
00848 <span class="comment">    This functions determines how many bytes would be needed to represent</span>
00849 <span class="comment">    the specified Unicode source string as an ANSI string (not counting the</span>
00850 <span class="comment">    null terminator)</span>
00851 <span class="comment"></span>
00852 <span class="comment">Arguments:</span>
00853 <span class="comment"></span>
00854 <span class="comment">    BytesInMultiByteString - Returns the number of bytes an ANSI translation</span>
00855 <span class="comment">        of the Unicode string pointed to by UnicodeString would contain.</span>
00856 <span class="comment"></span>
00857 <span class="comment">    UnicodeString - Supplies the unicode source string whose ANSI length</span>
00858 <span class="comment">        is to be calculated.</span>
00859 <span class="comment"></span>
00860 <span class="comment">    BytesInUnicodeString - The number of bytes in the the string pointed to by</span>
00861 <span class="comment">        UnicodeString.</span>
00862 <span class="comment"></span>
00863 <span class="comment">Return Value:</span>
00864 <span class="comment"></span>
00865 <span class="comment">    SUCCESS - The conversion was successful</span>
00866 <span class="comment"></span>
00867 <span class="comment">    !SUCCESS - The conversion failed.  A unicode character was encountered</span>
00868 <span class="comment">        that has no translation for the current ANSI Code Page (ACP).</span>
00869 <span class="comment"></span>
00870 <span class="comment">--*/</span>
00871 
00872 {
00873     ULONG cbMultiByte = 0;
00874     ULONG CharsInUnicodeString;
00875 
00876     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00877 
00878     <span class="comment">/*</span>
00879 <span class="comment">     * convert from bytes to chars for easier loop handling.</span>
00880 <span class="comment">     */</span>
00881     CharsInUnicodeString = BytesInUnicodeString / <span class="keyword">sizeof</span>(WCHAR);
00882 
00883     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d6/nlsxlat_8c.html#a19">NlsMbCodePageTag</a>) {
00884         <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> MbChar;
00885 
00886         <span class="keywordflow">while</span> (CharsInUnicodeString--) {
00887             MbChar = <a class="code" href="../../d9/d6/nlsxlat_8c.html#a18">NlsUnicodeToMbAnsiData</a>[ *UnicodeString++ ];
00888             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d9/ntrtlp_8h.html#a5">HIBYTE</a>(MbChar) == 0) {
00889                 cbMultiByte++ ;
00890             } <span class="keywordflow">else</span> {
00891                 cbMultiByte += 2;
00892             }
00893         }
00894         *BytesInMultiByteString = cbMultiByte;
00895     }
00896     <span class="keywordflow">else</span> {
00897         *BytesInMultiByteString = CharsInUnicodeString;
00898     }
00899 
00900     <span class="keywordflow">return</span> STATUS_SUCCESS;
00901 }
00902 
00903 
00904 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00905"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a37">00905</a> <a class="code" href="../../d9/d6/nlsxlat_8c.html#a37">RtlUnicodeToMultiByteN</a>(
00906     OUT PCH MultiByteString,
00907     IN ULONG MaxBytesInMultiByteString,
00908     OUT PULONG BytesInMultiByteString OPTIONAL,
00909     IN PWCH UnicodeString,
00910     IN ULONG BytesInUnicodeString)
00911 
00912 <span class="comment">/*++</span>
00913 <span class="comment"></span>
00914 <span class="comment">Routine Description:</span>
00915 <span class="comment"></span>
00916 <span class="comment">    This functions converts the specified unicode source string into an</span>
00917 <span class="comment">    ansi string. The translation is done with respect to the</span>
00918 <span class="comment">    ANSI Code Page (ACP) loaded at boot time.</span>
00919 <span class="comment"></span>
00920 <span class="comment">Arguments:</span>
00921 <span class="comment"></span>
00922 <span class="comment">    MultiByteString - Returns an ansi string that is equivalent to the</span>
00923 <span class="comment">        unicode source string.  If the translation can not be done,</span>
00924 <span class="comment">        an error is returned.</span>
00925 <span class="comment"></span>
00926 <span class="comment">    MaxBytesInMultiByteString - Supplies the maximum number of bytes to be</span>
00927 <span class="comment">        written to MultiByteString.  If this causes MultiByteString to be a</span>
00928 <span class="comment">        truncated equivalent of UnicodeString, no error condition results.</span>
00929 <span class="comment"></span>
00930 <span class="comment">    BytesInMultiByteString - Returns the number of bytes in the returned</span>
00931 <span class="comment">        ansi string pointed to by MultiByteString.</span>
00932 <span class="comment"></span>
00933 <span class="comment">    UnicodeString - Supplies the unicode source string that is to be</span>
00934 <span class="comment">        converted to ansi.</span>
00935 <span class="comment"></span>
00936 <span class="comment">    BytesInUnicodeString - The number of bytes in the the string pointed to by</span>
00937 <span class="comment">        UnicodeString.</span>
00938 <span class="comment"></span>
00939 <span class="comment">Return Value:</span>
00940 <span class="comment"></span>
00941 <span class="comment">    SUCCESS - The conversion was successful</span>
00942 <span class="comment"></span>
00943 <span class="comment">--*/</span>
00944 
00945 {
00946     ULONG TmpCount;
00947     ULONG LoopCount;
00948     PCH TranslateTable;
00949     ULONG CharsInUnicodeString;
00950 
00951     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00952 
00953     <span class="comment">//</span>
00954     <span class="comment">// Convert Unicode byte count to character count. Byte count of</span>
00955     <span class="comment">// multibyte string is equivalent to character count.</span>
00956     <span class="comment">//</span>
00957     <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d6/nlsxlat_8c.html#a19">NlsMbCodePageTag</a>) {
00958         CharsInUnicodeString = BytesInUnicodeString / <span class="keyword">sizeof</span>(WCHAR);
00959 
00960         LoopCount = (CharsInUnicodeString &lt; MaxBytesInMultiByteString) ?
00961                      CharsInUnicodeString : MaxBytesInMultiByteString;
00962 
00963         <span class="keywordflow">if</span> (ARGUMENT_PRESENT(BytesInMultiByteString))
00964             *BytesInMultiByteString = LoopCount;
00965 
00966         TranslateTable = <a class="code" href="../../d9/d6/nlsxlat_8c.html#a17">NlsUnicodeToAnsiData</a>;  <span class="comment">// used to help the mips compiler</span>
00967 
00968         TmpCount = LoopCount &amp; 0x0F;
00969         UnicodeString += TmpCount;
00970         MultiByteString += TmpCount;
00971 
00972         <span class="keywordflow">do</span>
00973         {
00974             <span class="keywordflow">switch</span>( TmpCount ) {
00975             <span class="keywordflow">default</span>:
00976                 UnicodeString += 0x10;
00977                 MultiByteString += 0x10;
00978 
00979                 MultiByteString[-0x10] = TranslateTable[UnicodeString[-0x10]];
00980             <span class="keywordflow">case</span> 0x0F:
00981                 MultiByteString[-0x0F] = TranslateTable[UnicodeString[-0x0F]];
00982             <span class="keywordflow">case</span> 0x0E:
00983                 MultiByteString[-0x0E] = TranslateTable[UnicodeString[-0x0E]];
00984             <span class="keywordflow">case</span> 0x0D:
00985                 MultiByteString[-0x0D] = TranslateTable[UnicodeString[-0x0D]];
00986             <span class="keywordflow">case</span> 0x0C:
00987                 MultiByteString[-0x0C] = TranslateTable[UnicodeString[-0x0C]];
00988             <span class="keywordflow">case</span> 0x0B:
00989                 MultiByteString[-0x0B] = TranslateTable[UnicodeString[-0x0B]];
00990             <span class="keywordflow">case</span> 0x0A:
00991                 MultiByteString[-0x0A] = TranslateTable[UnicodeString[-0x0A]];
00992             <span class="keywordflow">case</span> 0x09:
00993                 MultiByteString[-0x09] = TranslateTable[UnicodeString[-0x09]];
00994             <span class="keywordflow">case</span> 0x08:
00995                 MultiByteString[-0x08] = TranslateTable[UnicodeString[-0x08]];
00996             <span class="keywordflow">case</span> 0x07:
00997                 MultiByteString[-0x07] = TranslateTable[UnicodeString[-0x07]];
00998             <span class="keywordflow">case</span> 0x06:
00999                 MultiByteString[-0x06] = TranslateTable[UnicodeString[-0x06]];
01000             <span class="keywordflow">case</span> 0x05:
01001                 MultiByteString[-0x05] = TranslateTable[UnicodeString[-0x05]];
01002             <span class="keywordflow">case</span> 0x04:
01003                 MultiByteString[-0x04] = TranslateTable[UnicodeString[-0x04]];
01004             <span class="keywordflow">case</span> 0x03:
01005                 MultiByteString[-0x03] = TranslateTable[UnicodeString[-0x03]];
01006             <span class="keywordflow">case</span> 0x02:
01007                 MultiByteString[-0x02] = TranslateTable[UnicodeString[-0x02]];
01008             <span class="keywordflow">case</span> 0x01:
01009                 MultiByteString[-0x01] = TranslateTable[UnicodeString[-0x01]];
01010             <span class="keywordflow">case</span> 0x00:
01011                 ;
01012             }
01013 
01014             LoopCount -= TmpCount;
01015             TmpCount = 0x10;
01016         } <span class="keywordflow">while</span> ( LoopCount &gt; 0 );
01017 
01018         <span class="comment">/* end of copy... */</span>
01019     } <span class="keywordflow">else</span> {
01020         <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> MbChar;
01021         PCH MultiByteStringAnchor = MultiByteString;
01022 
01023         CharsInUnicodeString = BytesInUnicodeString / <span class="keyword">sizeof</span>(WCHAR);
01024 
01025         <span class="keywordflow">while</span> ( CharsInUnicodeString &amp;&amp; MaxBytesInMultiByteString ) {
01026 
01027             MbChar = <a class="code" href="../../d9/d6/nlsxlat_8c.html#a18">NlsUnicodeToMbAnsiData</a>[ *UnicodeString++ ];
01028             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d9/ntrtlp_8h.html#a5">HIBYTE</a>(MbChar) != 0) {
01029                 <span class="comment">//</span>
01030                 <span class="comment">// Need at least 2 bytes to copy a double byte char.</span>
01031                 <span class="comment">// Don't want to truncate in the middle of a DBCS char.</span>
01032                 <span class="comment">//</span>
01033                 <span class="keywordflow">if</span> (MaxBytesInMultiByteString-- &lt; 2) {
01034                     <span class="keywordflow">break</span>;
01035                 }
01036                 *MultiByteString++ = <a class="code" href="../../d5/d9/ntrtlp_8h.html#a5">HIBYTE</a>(MbChar);  <span class="comment">// lead byte</span>
01037             }
01038             *MultiByteString++ = <a class="code" href="../../d5/d9/ntrtlp_8h.html#a4">LOBYTE</a>(MbChar);
01039             MaxBytesInMultiByteString--;
01040 
01041             CharsInUnicodeString--;
01042         }
01043 
01044         <span class="keywordflow">if</span> (ARGUMENT_PRESENT(BytesInMultiByteString))
01045             *BytesInMultiByteString = (ULONG)(MultiByteString - MultiByteStringAnchor);
01046     }
01047 
01048     <span class="keywordflow">return</span> STATUS_SUCCESS;
01049 }
01050 
01051 
01052 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01053"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a38">01053</a> <a class="code" href="../../d9/d6/nlsxlat_8c.html#a38">RtlUpcaseUnicodeToMultiByteN</a>(
01054     OUT PCH MultiByteString,
01055     IN ULONG MaxBytesInMultiByteString,
01056     OUT PULONG BytesInMultiByteString OPTIONAL,
01057     IN PWCH UnicodeString,
01058     IN ULONG BytesInUnicodeString)
01059 
01060 <span class="comment">/*++</span>
01061 <span class="comment"></span>
01062 <span class="comment">Routine Description:</span>
01063 <span class="comment"></span>
01064 <span class="comment">    This functions upper cases the specified unicode source string and</span>
01065 <span class="comment">    converts it into an ansi string. The translation is done with respect</span>
01066 <span class="comment">    to the ANSI Code Page (ACP) loaded at boot time.</span>
01067 <span class="comment"></span>
01068 <span class="comment">Arguments:</span>
01069 <span class="comment"></span>
01070 <span class="comment">    MultiByteString - Returns an ansi string that is equivalent to the</span>
01071 <span class="comment">        upper case of the unicode source string.  If the translation can</span>
01072 <span class="comment">        not be done, an error is returned.</span>
01073 <span class="comment"></span>
01074 <span class="comment">    MaxBytesInMultiByteString - Supplies the maximum number of bytes to be</span>
01075 <span class="comment">        written to MultiByteString.  If this causes MultiByteString to be a</span>
01076 <span class="comment">        truncated equivalent of UnicodeString, no error condition results.</span>
01077 <span class="comment"></span>
01078 <span class="comment">    BytesInMultiByteString - Returns the number of bytes in the returned</span>
01079 <span class="comment">        ansi string pointed to by MultiByteString.</span>
01080 <span class="comment"></span>
01081 <span class="comment">    UnicodeString - Supplies the unicode source string that is to be</span>
01082 <span class="comment">        converted to ansi.</span>
01083 <span class="comment"></span>
01084 <span class="comment">    BytesInUnicodeString - The number of bytes in the the string pointed to by</span>
01085 <span class="comment">        UnicodeString.</span>
01086 <span class="comment"></span>
01087 <span class="comment">Return Value:</span>
01088 <span class="comment"></span>
01089 <span class="comment">    SUCCESS - The conversion was successful</span>
01090 <span class="comment"></span>
01091 <span class="comment">--*/</span>
01092 
01093 {
01094     ULONG TmpCount;
01095     ULONG LoopCount;
01096     PCH TranslateTable;
01097     ULONG CharsInUnicodeString;
01098     UCHAR SbChar;
01099     WCHAR UnicodeChar;
01100 
01101     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01102 
01103     <span class="comment">//</span>
01104     <span class="comment">// Convert Unicode byte count to character count. Byte count of</span>
01105     <span class="comment">// multibyte string is equivalent to character count.</span>
01106     <span class="comment">//</span>
01107     <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d6/nlsxlat_8c.html#a19">NlsMbCodePageTag</a>) {
01108         CharsInUnicodeString = BytesInUnicodeString / <span class="keyword">sizeof</span>(WCHAR);
01109 
01110         LoopCount = (CharsInUnicodeString &lt; MaxBytesInMultiByteString) ?
01111                      CharsInUnicodeString : MaxBytesInMultiByteString;
01112 
01113         <span class="keywordflow">if</span> (ARGUMENT_PRESENT(BytesInMultiByteString))
01114             *BytesInMultiByteString = LoopCount;
01115 
01116         TranslateTable = <a class="code" href="../../d9/d6/nlsxlat_8c.html#a17">NlsUnicodeToAnsiData</a>;  <span class="comment">// used to help the mips compiler</span>
01117 
01118         TmpCount = LoopCount &amp; 0x0F;
01119         UnicodeString += TmpCount;
01120         MultiByteString += TmpCount;
01121 
01122         <span class="keywordflow">do</span>
01123         {
01124             <span class="comment">//</span>
01125             <span class="comment">// Convert to ANSI and back to Unicode before upper casing</span>
01126             <span class="comment">// to ensure the visual best fits are converted and</span>
01127             <span class="comment">// upper cased properly.</span>
01128             <span class="comment">//</span>
01129             <span class="keywordflow">switch</span>( TmpCount ) {
01130             <span class="keywordflow">default</span>:
01131                 UnicodeString += 0x10;
01132                 MultiByteString += 0x10;
01133 
01134                 SbChar = TranslateTable[UnicodeString[-0x10]];
01135                 UnicodeChar = <a class="code" href="../../d6/d6/nls_8c.html#a19">NlsAnsiToUnicodeData</a>[SbChar];
01136                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
01137                 MultiByteString[-0x10] = TranslateTable[UnicodeChar];
01138             <span class="keywordflow">case</span> 0x0F:
01139                 SbChar = TranslateTable[UnicodeString[-0x0F]];
01140                 UnicodeChar = <a class="code" href="../../d6/d6/nls_8c.html#a19">NlsAnsiToUnicodeData</a>[SbChar];
01141                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
01142                 MultiByteString[-0x0F] = TranslateTable[UnicodeChar];
01143             <span class="keywordflow">case</span> 0x0E:
01144                 SbChar = TranslateTable[UnicodeString[-0x0E]];
01145                 UnicodeChar = <a class="code" href="../../d6/d6/nls_8c.html#a19">NlsAnsiToUnicodeData</a>[SbChar];
01146                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
01147                 MultiByteString[-0x0E] = TranslateTable[UnicodeChar];
01148             <span class="keywordflow">case</span> 0x0D:
01149                 SbChar = TranslateTable[UnicodeString[-0x0D]];
01150                 UnicodeChar = <a class="code" href="../../d6/d6/nls_8c.html#a19">NlsAnsiToUnicodeData</a>[SbChar];
01151                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
01152                 MultiByteString[-0x0D] = TranslateTable[UnicodeChar];
01153             <span class="keywordflow">case</span> 0x0C:
01154                 SbChar = TranslateTable[UnicodeString[-0x0C]];
01155                 UnicodeChar = <a class="code" href="../../d6/d6/nls_8c.html#a19">NlsAnsiToUnicodeData</a>[SbChar];
01156                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
01157                 MultiByteString[-0x0C] = TranslateTable[UnicodeChar];
01158             <span class="keywordflow">case</span> 0x0B:
01159                 SbChar = TranslateTable[UnicodeString[-0x0B]];
01160                 UnicodeChar = <a class="code" href="../../d6/d6/nls_8c.html#a19">NlsAnsiToUnicodeData</a>[SbChar];
01161                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
01162                 MultiByteString[-0x0B] = TranslateTable[UnicodeChar];
01163             <span class="keywordflow">case</span> 0x0A:
01164                 SbChar = TranslateTable[UnicodeString[-0x0A]];
01165                 UnicodeChar = <a class="code" href="../../d6/d6/nls_8c.html#a19">NlsAnsiToUnicodeData</a>[SbChar];
01166                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
01167                 MultiByteString[-0x0A] = TranslateTable[UnicodeChar];
01168             <span class="keywordflow">case</span> 0x09:
01169                 SbChar = TranslateTable[UnicodeString[-0x09]];
01170                 UnicodeChar = <a class="code" href="../../d6/d6/nls_8c.html#a19">NlsAnsiToUnicodeData</a>[SbChar];
01171                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
01172                 MultiByteString[-0x09] = TranslateTable[UnicodeChar];
01173             <span class="keywordflow">case</span> 0x08:
01174                 SbChar = TranslateTable[UnicodeString[-0x08]];
01175                 UnicodeChar = <a class="code" href="../../d6/d6/nls_8c.html#a19">NlsAnsiToUnicodeData</a>[SbChar];
01176                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
01177                 MultiByteString[-0x08] = TranslateTable[UnicodeChar];
01178             <span class="keywordflow">case</span> 0x07:
01179                 SbChar = TranslateTable[UnicodeString[-0x07]];
01180                 UnicodeChar = <a class="code" href="../../d6/d6/nls_8c.html#a19">NlsAnsiToUnicodeData</a>[SbChar];
01181                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
01182                 MultiByteString[-0x07] = TranslateTable[UnicodeChar];
01183             <span class="keywordflow">case</span> 0x06:
01184                 SbChar = TranslateTable[UnicodeString[-0x06]];
01185                 UnicodeChar = <a class="code" href="../../d6/d6/nls_8c.html#a19">NlsAnsiToUnicodeData</a>[SbChar];
01186                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
01187                 MultiByteString[-0x06] = TranslateTable[UnicodeChar];
01188             <span class="keywordflow">case</span> 0x05:
01189                 SbChar = TranslateTable[UnicodeString[-0x05]];
01190                 UnicodeChar = <a class="code" href="../../d6/d6/nls_8c.html#a19">NlsAnsiToUnicodeData</a>[SbChar];
01191                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
01192                 MultiByteString[-0x05] = TranslateTable[UnicodeChar];
01193             <span class="keywordflow">case</span> 0x04:
01194                 SbChar = TranslateTable[UnicodeString[-0x04]];
01195                 UnicodeChar = <a class="code" href="../../d6/d6/nls_8c.html#a19">NlsAnsiToUnicodeData</a>[SbChar];
01196                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
01197                 MultiByteString[-0x04] = TranslateTable[UnicodeChar];
01198             <span class="keywordflow">case</span> 0x03:
01199                 SbChar = TranslateTable[UnicodeString[-0x03]];
01200                 UnicodeChar = <a class="code" href="../../d6/d6/nls_8c.html#a19">NlsAnsiToUnicodeData</a>[SbChar];
01201                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
01202                 MultiByteString[-0x03] = TranslateTable[UnicodeChar];
01203             <span class="keywordflow">case</span> 0x02:
01204                 SbChar = TranslateTable[UnicodeString[-0x02]];
01205                 UnicodeChar = <a class="code" href="../../d6/d6/nls_8c.html#a19">NlsAnsiToUnicodeData</a>[SbChar];
01206                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
01207                 MultiByteString[-0x02] = TranslateTable[UnicodeChar];
01208             <span class="keywordflow">case</span> 0x01:
01209                 SbChar = TranslateTable[UnicodeString[-0x01]];
01210                 UnicodeChar = <a class="code" href="../../d6/d6/nls_8c.html#a19">NlsAnsiToUnicodeData</a>[SbChar];
01211                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
01212                 MultiByteString[-0x01] = TranslateTable[UnicodeChar];
01213             <span class="keywordflow">case</span> 0x00:
01214                 ;
01215             }
01216 
01217             LoopCount -= TmpCount;
01218             TmpCount = 0x10;
01219         } <span class="keywordflow">while</span> ( LoopCount &gt; 0 );
01220 
01221         <span class="comment">/* end of copy... */</span>
01222     } <span class="keywordflow">else</span> {
01223         <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> MbChar;
01224         <span class="keyword">register</span> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> Entry;
01225         PCH MultiByteStringAnchor = MultiByteString;
01226 
01227         CharsInUnicodeString = BytesInUnicodeString / <span class="keyword">sizeof</span>(WCHAR);
01228 
01229         <span class="keywordflow">while</span> ( CharsInUnicodeString &amp;&amp; MaxBytesInMultiByteString ) {
01230             <span class="comment">//</span>
01231             <span class="comment">// Convert to ANSI and back to Unicode before upper casing</span>
01232             <span class="comment">// to ensure the visual best fits are converted and</span>
01233             <span class="comment">// upper cased properly.</span>
01234             <span class="comment">//</span>
01235             MbChar = <a class="code" href="../../d9/d6/nlsxlat_8c.html#a18">NlsUnicodeToMbAnsiData</a>[ *UnicodeString++ ];
01236             <span class="keywordflow">if</span> ( <a class="code" href="../../d6/d6/nls_8c.html#a20">NlsLeadByteInfo</a>[<a class="code" href="../../d5/d9/ntrtlp_8h.html#a5">HIBYTE</a>(MbChar)] ) {
01237                 <span class="comment">//</span>
01238                 <span class="comment">// Lead byte - translate the trail byte using the table</span>
01239                 <span class="comment">// that corresponds to this lead byte.</span>
01240                 <span class="comment">//</span>
01241                 Entry = <a class="code" href="../../d6/d6/nls_8c.html#a20">NlsLeadByteInfo</a>[<a class="code" href="../../d5/d9/ntrtlp_8h.html#a5">HIBYTE</a>(MbChar)];
01242                 UnicodeChar = (WCHAR)<a class="code" href="../../d9/d6/nlsxlat_8c.html#a15">NlsMbAnsiCodePageTables</a>[ Entry + <a class="code" href="../../d5/d9/ntrtlp_8h.html#a4">LOBYTE</a>(MbChar) ];
01243             } <span class="keywordflow">else</span> {
01244                 <span class="comment">//</span>
01245                 <span class="comment">// Single byte character.</span>
01246                 <span class="comment">//</span>
01247                 UnicodeChar = <a class="code" href="../../d6/d6/nls_8c.html#a19">NlsAnsiToUnicodeData</a>[<a class="code" href="../../d5/d9/ntrtlp_8h.html#a4">LOBYTE</a>(MbChar)];
01248             }
01249             UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
01250             MbChar = <a class="code" href="../../d9/d6/nlsxlat_8c.html#a18">NlsUnicodeToMbAnsiData</a>[UnicodeChar];
01251 
01252             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d9/ntrtlp_8h.html#a5">HIBYTE</a>(MbChar) != 0) {
01253                 <span class="comment">//</span>
01254                 <span class="comment">// Need at least 2 bytes to copy a double byte char.</span>
01255                 <span class="comment">// Don't want to truncate in the middle of a DBCS char.</span>
01256                 <span class="comment">//</span>
01257                 <span class="keywordflow">if</span> (MaxBytesInMultiByteString-- &lt; 2) {
01258                     <span class="keywordflow">break</span>;
01259                 }
01260                 *MultiByteString++ = <a class="code" href="../../d5/d9/ntrtlp_8h.html#a5">HIBYTE</a>(MbChar);  <span class="comment">// lead byte</span>
01261             }
01262             *MultiByteString++ = <a class="code" href="../../d5/d9/ntrtlp_8h.html#a4">LOBYTE</a>(MbChar);
01263             MaxBytesInMultiByteString--;
01264 
01265             CharsInUnicodeString--;
01266         }
01267 
01268         <span class="keywordflow">if</span> (ARGUMENT_PRESENT(BytesInMultiByteString))
01269             *BytesInMultiByteString = (ULONG)(MultiByteString - MultiByteStringAnchor);
01270     }
01271 
01272     <span class="keywordflow">return</span> STATUS_SUCCESS;
01273 }
01274 
01275 
01276 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01277"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a39">01277</a> <a class="code" href="../../d9/d6/nlsxlat_8c.html#a39">RtlUnicodeToOemN</a>(
01278     OUT PCH OemString,
01279     IN ULONG MaxBytesInOemString,
01280     OUT PULONG BytesInOemString OPTIONAL,
01281     IN PWCH UnicodeString,
01282     IN ULONG BytesInUnicodeString)
01283 
01284 <span class="comment">/*++</span>
01285 <span class="comment"></span>
01286 <span class="comment">Routine Description:</span>
01287 <span class="comment"></span>
01288 <span class="comment">    This functions converts the specified unicode source string into an</span>
01289 <span class="comment">    oem string. The translation is done with respect to the OEM Code</span>
01290 <span class="comment">    Page (OCP) loaded at boot time.</span>
01291 <span class="comment"></span>
01292 <span class="comment">Arguments:</span>
01293 <span class="comment"></span>
01294 <span class="comment">    OemString - Returns an oem string that is equivalent to the</span>
01295 <span class="comment">        unicode source string.  If the translation can not be done,</span>
01296 <span class="comment">        an error is returned.</span>
01297 <span class="comment"></span>
01298 <span class="comment">    MaxBytesInOemString - Supplies the maximum number of bytes to be</span>
01299 <span class="comment">        written to OemString.  If this causes OemString to be a</span>
01300 <span class="comment">        truncated equivalent of UnicodeString, no error condition results.</span>
01301 <span class="comment"></span>
01302 <span class="comment">    BytesInOemString - Returns the number of bytes in the returned</span>
01303 <span class="comment">        oem string pointed to by OemString.</span>
01304 <span class="comment"></span>
01305 <span class="comment">    UnicodeString - Supplies the unicode source string that is to be</span>
01306 <span class="comment">        converted to oem.</span>
01307 <span class="comment"></span>
01308 <span class="comment">    BytesInUnicodeString - The number of bytes in the the string pointed to by</span>
01309 <span class="comment">        UnicodeString.</span>
01310 <span class="comment"></span>
01311 <span class="comment">Return Value:</span>
01312 <span class="comment"></span>
01313 <span class="comment">    SUCCESS - The conversion was successful</span>
01314 <span class="comment"></span>
01315 <span class="comment">    STATUS_BUFFER_OVERFLOW - MaxBytesInUnicodeString was not enough to hold</span>
01316 <span class="comment">        the whole Oem string.  It was converted correct to the point though.</span>
01317 <span class="comment"></span>
01318 <span class="comment">--*/</span>
01319 
01320 {
01321     ULONG TmpCount;
01322     ULONG LoopCount;
01323     PCH TranslateTable;
01324     ULONG CharsInUnicodeString;
01325 
01326     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01327 
01328     <span class="comment">//</span>
01329     <span class="comment">// Convert Unicode byte count to character count. Byte count of</span>
01330     <span class="comment">// multibyte string is equivalent to character count.</span>
01331     <span class="comment">//</span>
01332     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d9/gen8dot3_8c.html#a5">NlsMbOemCodePageTag</a>) {
01333         CharsInUnicodeString = BytesInUnicodeString / <span class="keyword">sizeof</span>(WCHAR);
01334 
01335         LoopCount = (CharsInUnicodeString &lt; MaxBytesInOemString) ?
01336                      CharsInUnicodeString : MaxBytesInOemString;
01337 
01338         <span class="keywordflow">if</span> (ARGUMENT_PRESENT(BytesInOemString))
01339             *BytesInOemString = LoopCount;
01340 
01341         TranslateTable = <a class="code" href="../../d5/d9/gen8dot3_8c.html#a3">NlsUnicodeToOemData</a>;  <span class="comment">// used to help the mips compiler</span>
01342 
01343         TmpCount = LoopCount &amp; 0x0F;
01344         UnicodeString += TmpCount;
01345         OemString += TmpCount;
01346 
01347         <span class="keywordflow">do</span>
01348         {
01349             <span class="keywordflow">switch</span>( TmpCount ) {
01350             <span class="keywordflow">default</span>:
01351                 UnicodeString += 0x10;
01352                 OemString += 0x10;
01353 
01354                 OemString[-0x10] = TranslateTable[UnicodeString[-0x10]];
01355             <span class="keywordflow">case</span> 0x0F:
01356                 OemString[-0x0F] = TranslateTable[UnicodeString[-0x0F]];
01357             <span class="keywordflow">case</span> 0x0E:
01358                 OemString[-0x0E] = TranslateTable[UnicodeString[-0x0E]];
01359             <span class="keywordflow">case</span> 0x0D:
01360                 OemString[-0x0D] = TranslateTable[UnicodeString[-0x0D]];
01361             <span class="keywordflow">case</span> 0x0C:
01362                 OemString[-0x0C] = TranslateTable[UnicodeString[-0x0C]];
01363             <span class="keywordflow">case</span> 0x0B:
01364                 OemString[-0x0B] = TranslateTable[UnicodeString[-0x0B]];
01365             <span class="keywordflow">case</span> 0x0A:
01366                 OemString[-0x0A] = TranslateTable[UnicodeString[-0x0A]];
01367             <span class="keywordflow">case</span> 0x09:
01368                 OemString[-0x09] = TranslateTable[UnicodeString[-0x09]];
01369             <span class="keywordflow">case</span> 0x08:
01370                 OemString[-0x08] = TranslateTable[UnicodeString[-0x08]];
01371             <span class="keywordflow">case</span> 0x07:
01372                 OemString[-0x07] = TranslateTable[UnicodeString[-0x07]];
01373             <span class="keywordflow">case</span> 0x06:
01374                 OemString[-0x06] = TranslateTable[UnicodeString[-0x06]];
01375             <span class="keywordflow">case</span> 0x05:
01376                 OemString[-0x05] = TranslateTable[UnicodeString[-0x05]];
01377             <span class="keywordflow">case</span> 0x04:
01378                 OemString[-0x04] = TranslateTable[UnicodeString[-0x04]];
01379             <span class="keywordflow">case</span> 0x03:
01380                 OemString[-0x03] = TranslateTable[UnicodeString[-0x03]];
01381             <span class="keywordflow">case</span> 0x02:
01382                 OemString[-0x02] = TranslateTable[UnicodeString[-0x02]];
01383             <span class="keywordflow">case</span> 0x01:
01384                 OemString[-0x01] = TranslateTable[UnicodeString[-0x01]];
01385             <span class="keywordflow">case</span> 0x00:
01386                 ;
01387             }
01388 
01389             LoopCount -= TmpCount;
01390             TmpCount = 0x10;
01391         } <span class="keywordflow">while</span> ( LoopCount &gt; 0 );
01392 
01393         <span class="comment">/* end of copy... */</span>
01394     } <span class="keywordflow">else</span> {
01395         <span class="keyword">register</span> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> MbChar;
01396         PCH OemStringAnchor = OemString;
01397 
01398         CharsInUnicodeString = BytesInUnicodeString / <span class="keyword">sizeof</span>(WCHAR);
01399 
01400         <span class="keywordflow">while</span> ( CharsInUnicodeString &amp;&amp; MaxBytesInOemString ) {
01401 
01402             MbChar = <a class="code" href="../../d5/d9/gen8dot3_8c.html#a1">NlsUnicodeToMbOemData</a>[ *UnicodeString++ ];
01403             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d9/ntrtlp_8h.html#a5">HIBYTE</a>(MbChar) != 0) {
01404                 <span class="comment">//</span>
01405                 <span class="comment">// Need at least 2 bytes to copy a double byte char.</span>
01406                 <span class="comment">// Don't want to truncate in the middle of a DBCS char.</span>
01407                 <span class="comment">//</span>
01408                 <span class="keywordflow">if</span> (MaxBytesInOemString-- &lt; 2) {
01409                     <span class="keywordflow">break</span>;
01410                 }
01411                 *OemString++ = <a class="code" href="../../d5/d9/ntrtlp_8h.html#a5">HIBYTE</a>(MbChar);  <span class="comment">// lead byte</span>
01412             }
01413             *OemString++ = <a class="code" href="../../d5/d9/ntrtlp_8h.html#a4">LOBYTE</a>(MbChar);
01414             MaxBytesInOemString--;
01415 
01416             CharsInUnicodeString--;
01417         }
01418 
01419         <span class="keywordflow">if</span> (ARGUMENT_PRESENT(BytesInOemString))
01420             *BytesInOemString = (ULONG)(OemString - OemStringAnchor);
01421     }
01422 
01423     <span class="comment">//</span>
01424     <span class="comment">//  Check if we were able to use all of the source Unicode String</span>
01425     <span class="comment">//</span>
01426     <span class="keywordflow">return</span> ( CharsInUnicodeString &lt;= MaxBytesInOemString ) ?
01427            STATUS_SUCCESS :
01428            STATUS_BUFFER_OVERFLOW;
01429 }
01430 
01431 
01432 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01433"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a40">01433</a> <a class="code" href="../../d9/d6/nlsxlat_8c.html#a40">RtlUpcaseUnicodeToOemN</a>(
01434     OUT PCH OemString,
01435     IN ULONG MaxBytesInOemString,
01436     OUT PULONG BytesInOemString OPTIONAL,
01437     IN PWCH UnicodeString,
01438     IN ULONG BytesInUnicodeString)
01439 
01440 <span class="comment">/*++</span>
01441 <span class="comment"></span>
01442 <span class="comment">Routine Description:</span>
01443 <span class="comment"></span>
01444 <span class="comment">    This functions upper cases the specified unicode source string and</span>
01445 <span class="comment">    converts it into an oem string. The translation is done with respect</span>
01446 <span class="comment">    to the OEM Code Page (OCP) loaded at boot time.</span>
01447 <span class="comment"></span>
01448 <span class="comment">Arguments:</span>
01449 <span class="comment"></span>
01450 <span class="comment">    OemString - Returns an oem string that is equivalent to the upper</span>
01451 <span class="comment">        case of the unicode source string.  If the translation can not</span>
01452 <span class="comment">        be done, an error is returned.</span>
01453 <span class="comment"></span>
01454 <span class="comment">    MaxBytesInOemString - Supplies the maximum number of bytes to be</span>
01455 <span class="comment">        written to OemString.  If this causes OemString to be a</span>
01456 <span class="comment">        truncated equivalent of UnicodeString, no error condition results.</span>
01457 <span class="comment"></span>
01458 <span class="comment">    BytesInOemString - Returns the number of bytes in the returned</span>
01459 <span class="comment">        oem string pointed to by OemString.</span>
01460 <span class="comment"></span>
01461 <span class="comment">    UnicodeString - Supplies the unicode source string that is to be</span>
01462 <span class="comment">        converted to oem.</span>
01463 <span class="comment"></span>
01464 <span class="comment">    BytesInUnicodeString - The number of bytes in the the string pointed</span>
01465 <span class="comment">        to by UnicodeString.</span>
01466 <span class="comment"></span>
01467 <span class="comment">Return Value:</span>
01468 <span class="comment"></span>
01469 <span class="comment">    SUCCESS - The conversion was successful</span>
01470 <span class="comment"></span>
01471 <span class="comment">    STATUS_BUFFER_OVERFLOW - MaxBytesInUnicodeString was not enough to</span>
01472 <span class="comment">        hold the whole Oem string.  It was converted correctly to that</span>
01473 <span class="comment">        point, though.</span>
01474 <span class="comment"></span>
01475 <span class="comment">--*/</span>
01476 
01477 {
01478     ULONG TmpCount;
01479     ULONG LoopCount;
01480     PCH TranslateTable;
01481     ULONG CharsInUnicodeString;
01482     UCHAR SbChar;
01483     WCHAR UnicodeChar;
01484 
01485     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01486 
01487     <span class="comment">//</span>
01488     <span class="comment">// Convert Unicode byte count to character count. Byte count of</span>
01489     <span class="comment">// multibyte string is equivalent to character count.</span>
01490     <span class="comment">//</span>
01491     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d9/gen8dot3_8c.html#a5">NlsMbOemCodePageTag</a>) {
01492         CharsInUnicodeString = BytesInUnicodeString / <span class="keyword">sizeof</span>(WCHAR);
01493 
01494         LoopCount = (CharsInUnicodeString &lt; MaxBytesInOemString) ?
01495                      CharsInUnicodeString : MaxBytesInOemString;
01496 
01497         <span class="keywordflow">if</span> (ARGUMENT_PRESENT(BytesInOemString))
01498             *BytesInOemString = LoopCount;
01499 
01500         TranslateTable = <a class="code" href="../../d5/d9/gen8dot3_8c.html#a3">NlsUnicodeToOemData</a>;  <span class="comment">// used to help the mips compiler</span>
01501 
01502         TmpCount = LoopCount &amp; 0x0F;
01503         UnicodeString += TmpCount;
01504         OemString += TmpCount;
01505 
01506         <span class="keywordflow">do</span>
01507         {
01508             <span class="comment">//</span>
01509             <span class="comment">// Convert to OEM and back to Unicode before upper casing</span>
01510             <span class="comment">// to ensure the visual best fits are converted and</span>
01511             <span class="comment">// upper cased properly.</span>
01512             <span class="comment">//</span>
01513             <span class="keywordflow">switch</span>( TmpCount ) {
01514             <span class="keywordflow">default</span>:
01515                 UnicodeString += 0x10;
01516                 OemString += 0x10;
01517 
01518                 SbChar = TranslateTable[UnicodeString[-0x10]];
01519                 UnicodeChar = <a class="code" href="../../d5/d9/gen8dot3_8c.html#a2">NlsOemToUnicodeData</a>[SbChar];
01520                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
01521                 OemString[-0x10] = TranslateTable[UnicodeChar];
01522             <span class="keywordflow">case</span> 0x0F:
01523                 SbChar = TranslateTable[UnicodeString[-0x0F]];
01524                 UnicodeChar = <a class="code" href="../../d5/d9/gen8dot3_8c.html#a2">NlsOemToUnicodeData</a>[SbChar];
01525                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
01526                 OemString[-0x0F] = TranslateTable[UnicodeChar];
01527             <span class="keywordflow">case</span> 0x0E:
01528                 SbChar = TranslateTable[UnicodeString[-0x0E]];
01529                 UnicodeChar = <a class="code" href="../../d5/d9/gen8dot3_8c.html#a2">NlsOemToUnicodeData</a>[SbChar];
01530                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
01531                 OemString[-0x0E] = TranslateTable[UnicodeChar];
01532             <span class="keywordflow">case</span> 0x0D:
01533                 SbChar = TranslateTable[UnicodeString[-0x0D]];
01534                 UnicodeChar = <a class="code" href="../../d5/d9/gen8dot3_8c.html#a2">NlsOemToUnicodeData</a>[SbChar];
01535                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
01536                 OemString[-0x0D] = TranslateTable[UnicodeChar];
01537             <span class="keywordflow">case</span> 0x0C:
01538                 SbChar = TranslateTable[UnicodeString[-0x0C]];
01539                 UnicodeChar = <a class="code" href="../../d5/d9/gen8dot3_8c.html#a2">NlsOemToUnicodeData</a>[SbChar];
01540                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
01541                 OemString[-0x0C] = TranslateTable[UnicodeChar];
01542             <span class="keywordflow">case</span> 0x0B:
01543                 SbChar = TranslateTable[UnicodeString[-0x0B]];
01544                 UnicodeChar = <a class="code" href="../../d5/d9/gen8dot3_8c.html#a2">NlsOemToUnicodeData</a>[SbChar];
01545                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
01546                 OemString[-0x0B] = TranslateTable[UnicodeChar];
01547             <span class="keywordflow">case</span> 0x0A:
01548                 SbChar = TranslateTable[UnicodeString[-0x0A]];
01549                 UnicodeChar = <a class="code" href="../../d5/d9/gen8dot3_8c.html#a2">NlsOemToUnicodeData</a>[SbChar];
01550                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
01551                 OemString[-0x0A] = TranslateTable[UnicodeChar];
01552             <span class="keywordflow">case</span> 0x09:
01553                 SbChar = TranslateTable[UnicodeString[-0x09]];
01554                 UnicodeChar = <a class="code" href="../../d5/d9/gen8dot3_8c.html#a2">NlsOemToUnicodeData</a>[SbChar];
01555                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
01556                 OemString[-0x09] = TranslateTable[UnicodeChar];
01557             <span class="keywordflow">case</span> 0x08:
01558                 SbChar = TranslateTable[UnicodeString[-0x08]];
01559                 UnicodeChar = <a class="code" href="../../d5/d9/gen8dot3_8c.html#a2">NlsOemToUnicodeData</a>[SbChar];
01560                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
01561                 OemString[-0x08] = TranslateTable[UnicodeChar];
01562             <span class="keywordflow">case</span> 0x07:
01563                 SbChar = TranslateTable[UnicodeString[-0x07]];
01564                 UnicodeChar = <a class="code" href="../../d5/d9/gen8dot3_8c.html#a2">NlsOemToUnicodeData</a>[SbChar];
01565                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
01566                 OemString[-0x07] = TranslateTable[UnicodeChar];
01567             <span class="keywordflow">case</span> 0x06:
01568                 SbChar = TranslateTable[UnicodeString[-0x06]];
01569                 UnicodeChar = <a class="code" href="../../d5/d9/gen8dot3_8c.html#a2">NlsOemToUnicodeData</a>[SbChar];
01570                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
01571                 OemString[-0x06] = TranslateTable[UnicodeChar];
01572             <span class="keywordflow">case</span> 0x05:
01573                 SbChar = TranslateTable[UnicodeString[-0x05]];
01574                 UnicodeChar = <a class="code" href="../../d5/d9/gen8dot3_8c.html#a2">NlsOemToUnicodeData</a>[SbChar];
01575                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
01576                 OemString[-0x05] = TranslateTable[UnicodeChar];
01577             <span class="keywordflow">case</span> 0x04:
01578                 SbChar = TranslateTable[UnicodeString[-0x04]];
01579                 UnicodeChar = <a class="code" href="../../d5/d9/gen8dot3_8c.html#a2">NlsOemToUnicodeData</a>[SbChar];
01580                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
01581                 OemString[-0x04] = TranslateTable[UnicodeChar];
01582             <span class="keywordflow">case</span> 0x03:
01583                 SbChar = TranslateTable[UnicodeString[-0x03]];
01584                 UnicodeChar = <a class="code" href="../../d5/d9/gen8dot3_8c.html#a2">NlsOemToUnicodeData</a>[SbChar];
01585                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
01586                 OemString[-0x03] = TranslateTable[UnicodeChar];
01587             <span class="keywordflow">case</span> 0x02:
01588                 SbChar = TranslateTable[UnicodeString[-0x02]];
01589                 UnicodeChar = <a class="code" href="../../d5/d9/gen8dot3_8c.html#a2">NlsOemToUnicodeData</a>[SbChar];
01590                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
01591                 OemString[-0x02] = TranslateTable[UnicodeChar];
01592             <span class="keywordflow">case</span> 0x01:
01593                 SbChar = TranslateTable[UnicodeString[-0x01]];
01594                 UnicodeChar = <a class="code" href="../../d5/d9/gen8dot3_8c.html#a2">NlsOemToUnicodeData</a>[SbChar];
01595                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
01596                 OemString[-0x01] = TranslateTable[UnicodeChar];
01597             <span class="keywordflow">case</span> 0x00:
01598                 ;
01599             }
01600 
01601             LoopCount -= TmpCount;
01602             TmpCount = 0x10;
01603         } <span class="keywordflow">while</span> ( LoopCount &gt; 0 );
01604 
01605         <span class="comment">/* end of copy... */</span>
01606     } <span class="keywordflow">else</span> {
01607         <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> MbChar;
01608         <span class="keyword">register</span> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> Entry;
01609         PCH OemStringAnchor = OemString;
01610 
01611         CharsInUnicodeString = BytesInUnicodeString / <span class="keyword">sizeof</span>(WCHAR);
01612 
01613         <span class="keywordflow">while</span> ( CharsInUnicodeString &amp;&amp; MaxBytesInOemString ) {
01614             <span class="comment">//</span>
01615             <span class="comment">// Convert to OEM and back to Unicode before upper casing</span>
01616             <span class="comment">// to ensure the visual best fits are converted and</span>
01617             <span class="comment">// upper cased properly.</span>
01618             <span class="comment">//</span>
01619             MbChar = <a class="code" href="../../d5/d9/gen8dot3_8c.html#a1">NlsUnicodeToMbOemData</a>[ *UnicodeString++ ];
01620             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d9/gen8dot3_8c.html#a6">NlsOemLeadByteInfo</a>[<a class="code" href="../../d5/d9/ntrtlp_8h.html#a5">HIBYTE</a>(MbChar)]) {
01621                 <span class="comment">//</span>
01622                 <span class="comment">// Lead byte - translate the trail byte using the table</span>
01623                 <span class="comment">// that corresponds to this lead byte.</span>
01624                 <span class="comment">//</span>
01625                 Entry = <a class="code" href="../../d5/d9/gen8dot3_8c.html#a6">NlsOemLeadByteInfo</a>[<a class="code" href="../../d5/d9/ntrtlp_8h.html#a5">HIBYTE</a>(MbChar)];
01626                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/gen8dot3_8c.html#a4">NlsMbOemCodePageTables</a>[ Entry + <a class="code" href="../../d5/d9/ntrtlp_8h.html#a4">LOBYTE</a>(MbChar) ];
01627             } <span class="keywordflow">else</span> {
01628                 <span class="comment">//</span>
01629                 <span class="comment">// Single byte character.</span>
01630                 <span class="comment">//</span>
01631                 UnicodeChar = <a class="code" href="../../d5/d9/gen8dot3_8c.html#a2">NlsOemToUnicodeData</a>[<a class="code" href="../../d5/d9/ntrtlp_8h.html#a4">LOBYTE</a>(MbChar)];
01632             }
01633             UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
01634             MbChar = <a class="code" href="../../d5/d9/gen8dot3_8c.html#a1">NlsUnicodeToMbOemData</a>[UnicodeChar];
01635 
01636             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d9/ntrtlp_8h.html#a5">HIBYTE</a>(MbChar) != 0) {
01637                 <span class="comment">//</span>
01638                 <span class="comment">// Need at least 2 bytes to copy a double byte char.</span>
01639                 <span class="comment">// Don't want to truncate in the middle of a DBCS char.</span>
01640                 <span class="comment">//</span>
01641                 <span class="keywordflow">if</span> (MaxBytesInOemString-- &lt; 2) {
01642                     <span class="keywordflow">break</span>;
01643                 }
01644                 *OemString++ = <a class="code" href="../../d5/d9/ntrtlp_8h.html#a5">HIBYTE</a>(MbChar);  <span class="comment">// lead byte</span>
01645             }
01646             *OemString++ = <a class="code" href="../../d5/d9/ntrtlp_8h.html#a4">LOBYTE</a>(MbChar);
01647             MaxBytesInOemString--;
01648 
01649             CharsInUnicodeString--;
01650         }
01651 
01652         <span class="keywordflow">if</span> (ARGUMENT_PRESENT(BytesInOemString))
01653             *BytesInOemString = (ULONG)(OemString - OemStringAnchor);
01654     }
01655 
01656     <span class="comment">//</span>
01657     <span class="comment">//  Check if we were able to use all of the source Unicode String</span>
01658     <span class="comment">//</span>
01659     <span class="keywordflow">return</span> ( CharsInUnicodeString &lt;= MaxBytesInOemString ) ?
01660            STATUS_SUCCESS :
01661            STATUS_BUFFER_OVERFLOW;
01662 }
01663 
01664 BOOLEAN
<a name="l01665"></a><a class="code" href="../../d5/d9/ntrtlp_8h.html#a37">01665</a> <a class="code" href="../../d5/d9/ntrtlp_8h.html#a37">RtlpDidUnicodeToOemWork</a>(
01666     IN POEM_STRING OemString,
01667     IN PUNICODE_STRING UnicodeString
01668     )
01669 
01670 <span class="comment">/*++</span>
01671 <span class="comment"></span>
01672 <span class="comment">Routine Description:</span>
01673 <span class="comment"></span>
01674 <span class="comment">    This function looks for the default character in the Oem string, making</span>
01675 <span class="comment">    sure it was not a correct translation from the Unicode source string.</span>
01676 <span class="comment"></span>
01677 <span class="comment">    This allows us to test whether or not a translation was really successful.</span>
01678 <span class="comment"></span>
01679 <span class="comment">Arguments:</span>
01680 <span class="comment"></span>
01681 <span class="comment">    OemString - The result of conversion from the unicode string.</span>
01682 <span class="comment"></span>
01683 <span class="comment">    UnicodeString - The source of the Oem string.</span>
01684 <span class="comment"></span>
01685 <span class="comment">Return Value:</span>
01686 <span class="comment"></span>
01687 <span class="comment">    TRUE if the Unicode to Oem translation caused no default characters to be</span>
01688 <span class="comment">        inserted.  FALSE otherwise.</span>
01689 <span class="comment"></span>
01690 <span class="comment">--*/</span>
01691 
01692 {
01693     ULONG OemOffset;
01694     BOOLEAN Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01695 
01696     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01697 
01698     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d9/gen8dot3_8c.html#a5">NlsMbOemCodePageTag</a>) {
01699 
01700         <span class="keywordflow">for</span> (OemOffset = 0;
01701              OemOffset &lt; OemString-&gt;Length;
01702              OemOffset += 1) {
01703 
01704             <span class="keywordflow">if</span> ((OemString-&gt;Buffer[OemOffset] == (UCHAR)<a class="code" href="../../d5/d9/gen8dot3_8c.html#a7">OemDefaultChar</a>) &amp;&amp;
01705                 (UnicodeString-&gt;Buffer[OemOffset] != <a class="code" href="../../d9/d6/nlsxlat_8c.html#a29">OemTransUniDefaultChar</a>)) {
01706 
01707                 Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01708                 <span class="keywordflow">break</span>;
01709             }
01710         }
01711 
01712     } <span class="keywordflow">else</span> {
01713 
01714         ULONG UnicodeOffset;
01715 
01716         <span class="keywordflow">for</span> (OemOffset = 0, UnicodeOffset = 0;
01717              OemOffset &lt; OemString-&gt;Length;
01718              OemOffset += 1, UnicodeOffset += 1) {
01719 
01720             <span class="comment">//</span>
01721             <span class="comment">//  If we landed on a DBCS character handle it accordingly</span>
01722             <span class="comment">//</span>
01723 
01724             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d9/gen8dot3_8c.html#a6">NlsOemLeadByteInfo</a>[(UCHAR)OemString-&gt;Buffer[OemOffset]]) {
01725 
01726                 <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> DbcsChar;
01727 
01728                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( OemOffset + 1 &lt; OemString-&gt;Length );
01729 
01730                 DbcsChar = (OemString-&gt;Buffer[OemOffset] &lt;&lt; 8) + (UCHAR)OemString-&gt;Buffer[OemOffset+1];
01731                 OemOffset++;
01732 
01733                 <span class="keywordflow">if</span> ((DbcsChar == <a class="code" href="../../d5/d9/gen8dot3_8c.html#a7">OemDefaultChar</a>) &amp;&amp;
01734                     (UnicodeString-&gt;Buffer[UnicodeOffset] != <a class="code" href="../../d9/d6/nlsxlat_8c.html#a29">OemTransUniDefaultChar</a>)) {
01735 
01736                     Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01737                     <span class="keywordflow">break</span>;
01738                 }
01739 
01740                 <span class="keywordflow">continue</span>;
01741             }
01742 
01743             <span class="keywordflow">if</span> ((OemString-&gt;Buffer[OemOffset] == (UCHAR)<a class="code" href="../../d5/d9/gen8dot3_8c.html#a7">OemDefaultChar</a>) &amp;&amp;
01744                 (UnicodeString-&gt;Buffer[UnicodeOffset] != <a class="code" href="../../d9/d6/nlsxlat_8c.html#a29">OemTransUniDefaultChar</a>)) {
01745 
01746                 Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01747                 <span class="keywordflow">break</span>;
01748             }
01749         }
01750     }
01751 
01752     <span class="keywordflow">return</span> Result;
01753 }
01754 
01755 
01756 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01757"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a42">01757</a> <a class="code" href="../../d9/d6/nlsxlat_8c.html#a42">RtlCustomCPToUnicodeN</a>(
01758     IN PCPTABLEINFO CustomCP,
01759     OUT PWCH UnicodeString,
01760     IN ULONG MaxBytesInUnicodeString,
01761     OUT PULONG BytesInUnicodeString OPTIONAL,
01762     IN PCH CustomCPString,
01763     IN ULONG BytesInCustomCPString)
01764 
01765 <span class="comment">/*++</span>
01766 <span class="comment"></span>
01767 <span class="comment">Routine Description:</span>
01768 <span class="comment"></span>
01769 <span class="comment">    This functions converts the specified CustomCP source string into a</span>
01770 <span class="comment">    Unicode string. The translation is done with respect to the</span>
01771 <span class="comment">    CustomCP Code Page specified.  Single byte characters</span>
01772 <span class="comment">    in the range 0x00 - 0x7f are simply zero extended as a performance</span>
01773 <span class="comment">    enhancement.  In some far eastern code pages 0x5c is defined as the</span>
01774 <span class="comment">    Yen sign.  For system translation we always want to consider 0x5c</span>
01775 <span class="comment">    to be the backslash character.  We get this for free by zero extending.</span>
01776 <span class="comment"></span>
01777 <span class="comment">    NOTE: This routine only supports precomposed Unicode characters.</span>
01778 <span class="comment"></span>
01779 <span class="comment">Arguments:</span>
01780 <span class="comment"></span>
01781 <span class="comment">    CustomCP - Supplies the address of the code page that translations</span>
01782 <span class="comment">        are done relative to</span>
01783 <span class="comment"></span>
01784 <span class="comment">    UnicodeString - Returns a unicode string that is equivalent to</span>
01785 <span class="comment">        the CustomCP source string.</span>
01786 <span class="comment"></span>
01787 <span class="comment">    MaxBytesInUnicodeString - Supplies the maximum number of bytes to be</span>
01788 <span class="comment">        written to UnicodeString.  If this causes UnicodeString to be a</span>
01789 <span class="comment">        truncated equivalent of CustomCPString, no error condition results.</span>
01790 <span class="comment"></span>
01791 <span class="comment">    BytesInUnicodeString - Returns the number of bytes in the returned</span>
01792 <span class="comment">        unicode string pointed to by UnicodeString.</span>
01793 <span class="comment"></span>
01794 <span class="comment">    CustomCPString - Supplies the CustomCP source string that is to be</span>
01795 <span class="comment">        converted to unicode.</span>
01796 <span class="comment"></span>
01797 <span class="comment">    BytesInCustomCPString - The number of bytes in the string pointed to</span>
01798 <span class="comment">        by CustomCPString.</span>
01799 <span class="comment"></span>
01800 <span class="comment">Return Value:</span>
01801 <span class="comment"></span>
01802 <span class="comment">    SUCCESS - The conversion was successful</span>
01803 <span class="comment"></span>
01804 <span class="comment">    STATUS_ILLEGAL_CHARACTER - The final CustomCP character was illegal</span>
01805 <span class="comment"></span>
01806 <span class="comment">    STATUS_BUFFER_OVERFLOW - MaxBytesInUnicodeString was not enough to hold</span>
01807 <span class="comment">        the whole CustomCP string.  It was converted correct to the point though.</span>
01808 <span class="comment"></span>
01809 <span class="comment">--*/</span>
01810 
01811 {
01812     ULONG LoopCount;
01813     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a> TranslateTable;
01814     ULONG MaxCharsInUnicodeString;
01815 
01816     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01817 
01818     <span class="keywordflow">if</span> (!(CustomCP-&gt;DBCSCodePage)) {
01819         <span class="comment">//</span>
01820         <span class="comment">// The Custom CP is a single byte code page.</span>
01821         <span class="comment">//</span>
01822         MaxCharsInUnicodeString = MaxBytesInUnicodeString / <span class="keyword">sizeof</span>(WCHAR);
01823 
01824         LoopCount = (MaxCharsInUnicodeString &lt; BytesInCustomCPString) ?
01825                      MaxCharsInUnicodeString : BytesInCustomCPString;
01826 
01827         <span class="keywordflow">if</span> (ARGUMENT_PRESENT(BytesInUnicodeString))
01828             *BytesInUnicodeString = LoopCount * <span class="keyword">sizeof</span>(WCHAR);
01829 
01830 
01831         TranslateTable = CustomCP-&gt;MultiByteTable;
01832 
01833         quick_copy:
01834             <span class="keywordflow">switch</span>( LoopCount ) {
01835             <span class="keywordflow">default</span>:
01836                 UnicodeString[0x0F] = TranslateTable[(UCHAR)CustomCPString[0x0F]];
01837             <span class="keywordflow">case</span> 0x0F:
01838                 UnicodeString[0x0E] = TranslateTable[(UCHAR)CustomCPString[0x0E]];
01839             <span class="keywordflow">case</span> 0x0E:
01840                 UnicodeString[0x0D] = TranslateTable[(UCHAR)CustomCPString[0x0D]];
01841             <span class="keywordflow">case</span> 0x0D:
01842                 UnicodeString[0x0C] = TranslateTable[(UCHAR)CustomCPString[0x0C]];
01843             <span class="keywordflow">case</span> 0x0C:
01844                 UnicodeString[0x0B] = TranslateTable[(UCHAR)CustomCPString[0x0B]];
01845             <span class="keywordflow">case</span> 0x0B:
01846                 UnicodeString[0x0A] = TranslateTable[(UCHAR)CustomCPString[0x0A]];
01847             <span class="keywordflow">case</span> 0x0A:
01848                 UnicodeString[0x09] = TranslateTable[(UCHAR)CustomCPString[0x09]];
01849             <span class="keywordflow">case</span> 0x09:
01850                 UnicodeString[0x08] = TranslateTable[(UCHAR)CustomCPString[0x08]];
01851             <span class="keywordflow">case</span> 0x08:
01852                 UnicodeString[0x07] = TranslateTable[(UCHAR)CustomCPString[0x07]];
01853             <span class="keywordflow">case</span> 0x07:
01854                 UnicodeString[0x06] = TranslateTable[(UCHAR)CustomCPString[0x06]];
01855             <span class="keywordflow">case</span> 0x06:
01856                 UnicodeString[0x05] = TranslateTable[(UCHAR)CustomCPString[0x05]];
01857             <span class="keywordflow">case</span> 0x05:
01858                 UnicodeString[0x04] = TranslateTable[(UCHAR)CustomCPString[0x04]];
01859             <span class="keywordflow">case</span> 0x04:
01860                 UnicodeString[0x03] = TranslateTable[(UCHAR)CustomCPString[0x03]];
01861             <span class="keywordflow">case</span> 0x03:
01862                 UnicodeString[0x02] = TranslateTable[(UCHAR)CustomCPString[0x02]];
01863             <span class="keywordflow">case</span> 0x02:
01864                 UnicodeString[0x01] = TranslateTable[(UCHAR)CustomCPString[0x01]];
01865             <span class="keywordflow">case</span> 0x01:
01866                 UnicodeString[0x00] = TranslateTable[(UCHAR)CustomCPString[0x00]];
01867             <span class="keywordflow">case</span> 0x00:
01868                 ;
01869             }
01870 
01871             <span class="keywordflow">if</span> ( LoopCount &gt; 0x10 ) {
01872                 LoopCount -= 0x10;
01873                 CustomCPString += 0x10;
01874                 UnicodeString += 0x10;
01875 
01876                 <span class="keywordflow">goto</span>  quick_copy;
01877             }
01878         <span class="comment">/* end of copy... */</span>
01879     } <span class="keywordflow">else</span> {
01880         <span class="keyword">register</span> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> Entry;
01881         PWCH UnicodeStringAnchor = UnicodeString;
01882         <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a> NlsCustomLeadByteInfo = CustomCP-&gt;DBCSOffsets;
01883 
01884         <span class="comment">//</span>
01885         <span class="comment">// The CP is a multibyte code page.  Check each character</span>
01886         <span class="comment">// to see if it is a lead byte before doing the translation.</span>
01887         <span class="comment">//</span>
01888         MaxCharsInUnicodeString = MaxBytesInUnicodeString / <span class="keyword">sizeof</span>(WCHAR);
01889         TranslateTable = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>)(CustomCP-&gt;DBCSOffsets);
01890 
01891         <span class="keywordflow">while</span> (MaxCharsInUnicodeString &amp;&amp; BytesInCustomCPString) {
01892             MaxCharsInUnicodeString--;
01893             BytesInCustomCPString--;
01894             <span class="keywordflow">if</span> (NlsCustomLeadByteInfo[*(PUCHAR)CustomCPString]) {
01895                 <span class="comment">//</span>
01896                 <span class="comment">// Lead byte - Make sure there is a trail byte.  If not,</span>
01897                 <span class="comment">// pass back a space rather than an error.  Some 3.x</span>
01898                 <span class="comment">// applications pass incorrect strings and don't expect</span>
01899                 <span class="comment">// to get an error.</span>
01900                 <span class="comment">//</span>
01901                 <span class="keywordflow">if</span> (BytesInCustomCPString == 0)
01902                 {
01903                     *UnicodeString++ = <a class="code" href="../../d9/d6/nlsxlat_8c.html#a30">UnicodeNull</a>;
01904                     <span class="keywordflow">break</span>;
01905                 }
01906 
01907                 <span class="comment">//</span>
01908                 <span class="comment">// Get the unicode character.</span>
01909                 <span class="comment">//</span>
01910                 Entry = NlsCustomLeadByteInfo[*(PUCHAR)CustomCPString++];
01911                 *UnicodeString = TranslateTable[ Entry + *(PUCHAR)CustomCPString++ ];
01912                 UnicodeString++;
01913 
01914                 <span class="comment">//</span>
01915                 <span class="comment">// Decrement count of bytes in multibyte string to account</span>
01916                 <span class="comment">// for the double byte character.</span>
01917                 <span class="comment">//</span>
01918                 BytesInCustomCPString--;
01919             } <span class="keywordflow">else</span> {
01920                 <span class="comment">//</span>
01921                 <span class="comment">// Single byte character.</span>
01922                 <span class="comment">//</span>
01923                 *UnicodeString++ = (CustomCP-&gt;MultiByteTable)[*(PUCHAR)CustomCPString++];
01924             }
01925         }
01926 
01927         <span class="keywordflow">if</span> (ARGUMENT_PRESENT(BytesInUnicodeString))
01928             *BytesInUnicodeString = (ULONG)((PCH)UnicodeString - (PCH)UnicodeStringAnchor);
01929     }
01930 
01931     <span class="comment">//</span>
01932     <span class="comment">//  Check if we were able to use all of the source CustomCP String</span>
01933     <span class="comment">//</span>
01934     <span class="keywordflow">return</span> ( BytesInCustomCPString &lt;= MaxCharsInUnicodeString ) ?
01935            STATUS_SUCCESS :
01936            STATUS_BUFFER_OVERFLOW;
01937 }
01938 
01939 
01940 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01941"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a43">01941</a> <a class="code" href="../../d9/d6/nlsxlat_8c.html#a43">RtlUnicodeToCustomCPN</a>(
01942     IN PCPTABLEINFO CustomCP,
01943     OUT PCH CustomCPString,
01944     IN ULONG MaxBytesInCustomCPString,
01945     OUT PULONG BytesInCustomCPString OPTIONAL,
01946     IN PWCH UnicodeString,
01947     IN ULONG BytesInUnicodeString)
01948 
01949 <span class="comment">/*++</span>
01950 <span class="comment"></span>
01951 <span class="comment">Routine Description:</span>
01952 <span class="comment"></span>
01953 <span class="comment">    This functions converts the specified unicode source string into an</span>
01954 <span class="comment">    CustomCP string.  The translation is done with respect to the</span>
01955 <span class="comment">    CustomCP Code Page specified by CustomCp.</span>
01956 <span class="comment"></span>
01957 <span class="comment">Arguments:</span>
01958 <span class="comment"></span>
01959 <span class="comment">    CustomCP - Supplies the address of the code page that translations</span>
01960 <span class="comment">        are done relative to</span>
01961 <span class="comment"></span>
01962 <span class="comment">    CustomCPString - Returns an CustomCP string that is equivalent to the</span>
01963 <span class="comment">        unicode source string.  If the translation can not be done,</span>
01964 <span class="comment">        an error is returned.</span>
01965 <span class="comment"></span>
01966 <span class="comment">    MaxBytesInCustomCPString - Supplies the maximum number of bytes to be</span>
01967 <span class="comment">        written to CustomCPString.  If this causes CustomCPString to be a</span>
01968 <span class="comment">        truncated equivalent of UnicodeString, no error condition results.</span>
01969 <span class="comment"></span>
01970 <span class="comment">    BytesInCustomCPString - Returns the number of bytes in the returned</span>
01971 <span class="comment">        CustomCP string pointed to by CustomCPString.</span>
01972 <span class="comment"></span>
01973 <span class="comment">    UnicodeString - Supplies the unicode source string that is to be</span>
01974 <span class="comment">        converted to CustomCP.</span>
01975 <span class="comment"></span>
01976 <span class="comment">    BytesInUnicodeString - The number of bytes in the the string pointed to by</span>
01977 <span class="comment">        UnicodeString.</span>
01978 <span class="comment"></span>
01979 <span class="comment">Return Value:</span>
01980 <span class="comment"></span>
01981 <span class="comment">    SUCCESS - The conversion was successful</span>
01982 <span class="comment"></span>
01983 <span class="comment">    STATUS_BUFFER_OVERFLOW - MaxBytesInUnicodeString was not enough to hold</span>
01984 <span class="comment">        the whole CustomCP string.  It was converted correct to the point though.</span>
01985 <span class="comment"></span>
01986 <span class="comment">--*/</span>
01987 
01988 {
01989     ULONG TmpCount;
01990     ULONG LoopCount;
01991     PCH TranslateTable;
01992     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a> WideTranslateTable;
01993     ULONG CharsInUnicodeString;
01994 
01995     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01996 
01997     <span class="comment">//</span>
01998     <span class="comment">// Convert Unicode byte count to character count. Byte count of</span>
01999     <span class="comment">// multibyte string is equivalent to character count.</span>
02000     <span class="comment">//</span>
02001     <span class="keywordflow">if</span> (!(CustomCP-&gt;DBCSCodePage)) {
02002         CharsInUnicodeString = BytesInUnicodeString / <span class="keyword">sizeof</span>(WCHAR);
02003 
02004         LoopCount = (CharsInUnicodeString &lt; MaxBytesInCustomCPString) ?
02005                      CharsInUnicodeString : MaxBytesInCustomCPString;
02006 
02007         <span class="keywordflow">if</span> (ARGUMENT_PRESENT(BytesInCustomCPString))
02008             *BytesInCustomCPString = LoopCount;
02009 
02010         TranslateTable = CustomCP-&gt;WideCharTable;
02011 
02012         TmpCount = LoopCount &amp; 0x0F;
02013         UnicodeString += TmpCount;
02014         CustomCPString += TmpCount;
02015 
02016         <span class="keywordflow">do</span>
02017         {
02018             <span class="keywordflow">switch</span>( TmpCount ) {
02019             <span class="keywordflow">default</span>:
02020                 UnicodeString += 0x10;
02021                 CustomCPString += 0x10;
02022 
02023                 CustomCPString[-0x10] = TranslateTable[UnicodeString[-0x10]];
02024             <span class="keywordflow">case</span> 0x0F:
02025                 CustomCPString[-0x0F] = TranslateTable[UnicodeString[-0x0F]];
02026             <span class="keywordflow">case</span> 0x0E:
02027                 CustomCPString[-0x0E] = TranslateTable[UnicodeString[-0x0E]];
02028             <span class="keywordflow">case</span> 0x0D:
02029                 CustomCPString[-0x0D] = TranslateTable[UnicodeString[-0x0D]];
02030             <span class="keywordflow">case</span> 0x0C:
02031                 CustomCPString[-0x0C] = TranslateTable[UnicodeString[-0x0C]];
02032             <span class="keywordflow">case</span> 0x0B:
02033                 CustomCPString[-0x0B] = TranslateTable[UnicodeString[-0x0B]];
02034             <span class="keywordflow">case</span> 0x0A:
02035                 CustomCPString[-0x0A] = TranslateTable[UnicodeString[-0x0A]];
02036             <span class="keywordflow">case</span> 0x09:
02037                 CustomCPString[-0x09] = TranslateTable[UnicodeString[-0x09]];
02038             <span class="keywordflow">case</span> 0x08:
02039                 CustomCPString[-0x08] = TranslateTable[UnicodeString[-0x08]];
02040             <span class="keywordflow">case</span> 0x07:
02041                 CustomCPString[-0x07] = TranslateTable[UnicodeString[-0x07]];
02042             <span class="keywordflow">case</span> 0x06:
02043                 CustomCPString[-0x06] = TranslateTable[UnicodeString[-0x06]];
02044             <span class="keywordflow">case</span> 0x05:
02045                 CustomCPString[-0x05] = TranslateTable[UnicodeString[-0x05]];
02046             <span class="keywordflow">case</span> 0x04:
02047                 CustomCPString[-0x04] = TranslateTable[UnicodeString[-0x04]];
02048             <span class="keywordflow">case</span> 0x03:
02049                 CustomCPString[-0x03] = TranslateTable[UnicodeString[-0x03]];
02050             <span class="keywordflow">case</span> 0x02:
02051                 CustomCPString[-0x02] = TranslateTable[UnicodeString[-0x02]];
02052             <span class="keywordflow">case</span> 0x01:
02053                 CustomCPString[-0x01] = TranslateTable[UnicodeString[-0x01]];
02054             <span class="keywordflow">case</span> 0x00:
02055                 ;
02056             }
02057 
02058             LoopCount -= TmpCount;
02059             TmpCount = 0x10;
02060         } <span class="keywordflow">while</span> ( LoopCount &gt; 0 );
02061 
02062         <span class="comment">/* end of copy... */</span>
02063     } <span class="keywordflow">else</span> {
02064         <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> MbChar;
02065         PCH CustomCPStringAnchor = CustomCPString;
02066 
02067         WideTranslateTable = CustomCP-&gt;WideCharTable;
02068 
02069         CharsInUnicodeString = BytesInUnicodeString / <span class="keyword">sizeof</span>(WCHAR);
02070 
02071         <span class="keywordflow">while</span> (CharsInUnicodeString &amp;&amp; MaxBytesInCustomCPString) {
02072 
02073             MbChar = WideTranslateTable[ *UnicodeString++ ];
02074             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d9/ntrtlp_8h.html#a5">HIBYTE</a>(MbChar) != 0) {
02075                 <span class="comment">//</span>
02076                 <span class="comment">// Need at least 2 bytes to copy a double byte char.</span>
02077                 <span class="comment">// Don't want to truncate in the middle of a DBCS char.</span>
02078                 <span class="comment">//</span>
02079                 <span class="keywordflow">if</span> (MaxBytesInCustomCPString-- &lt; 2) {
02080                     <span class="keywordflow">break</span>;
02081                 }
02082                 *CustomCPString++ = <a class="code" href="../../d5/d9/ntrtlp_8h.html#a5">HIBYTE</a>(MbChar);  <span class="comment">// lead byte</span>
02083             }
02084             *CustomCPString++ = <a class="code" href="../../d5/d9/ntrtlp_8h.html#a4">LOBYTE</a>(MbChar);
02085             MaxBytesInCustomCPString--;
02086 
02087             CharsInUnicodeString--;
02088         }
02089 
02090         <span class="keywordflow">if</span> (ARGUMENT_PRESENT(BytesInCustomCPString))
02091             *BytesInCustomCPString = (ULONG)(CustomCPString - CustomCPStringAnchor);
02092     }
02093 
02094     <span class="comment">//</span>
02095     <span class="comment">//  Check if we were able to use all of the source Unicode String</span>
02096     <span class="comment">//</span>
02097     <span class="keywordflow">return</span> ( CharsInUnicodeString &lt;= MaxBytesInCustomCPString ) ?
02098            STATUS_SUCCESS :
02099            STATUS_BUFFER_OVERFLOW;
02100 }
02101 
02102 
02103 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l02104"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a44">02104</a> <a class="code" href="../../d9/d6/nlsxlat_8c.html#a44">RtlUpcaseUnicodeToCustomCPN</a>(
02105     IN PCPTABLEINFO CustomCP,
02106     OUT PCH CustomCPString,
02107     IN ULONG MaxBytesInCustomCPString,
02108     OUT PULONG BytesInCustomCPString OPTIONAL,
02109     IN PWCH UnicodeString,
02110     IN ULONG BytesInUnicodeString)
02111 
02112 <span class="comment">/*++</span>
02113 <span class="comment"></span>
02114 <span class="comment">Routine Description:</span>
02115 <span class="comment"></span>
02116 <span class="comment">    This functions upper cases the specified unicode source string and</span>
02117 <span class="comment">    converts it into a CustomCP string.  The translation is done with</span>
02118 <span class="comment">    respect to the CustomCP Code Page specified by CustomCp.</span>
02119 <span class="comment"></span>
02120 <span class="comment">Arguments:</span>
02121 <span class="comment"></span>
02122 <span class="comment">    CustomCP - Supplies the address of the code page that translations</span>
02123 <span class="comment">        are done relative to</span>
02124 <span class="comment"></span>
02125 <span class="comment">    CustomCPString - Returns an CustomCP string that is equivalent to the</span>
02126 <span class="comment">        unicode source string.  If the translation can not be done,</span>
02127 <span class="comment">        an error is returned.</span>
02128 <span class="comment"></span>
02129 <span class="comment">    MaxBytesInCustomCPString - Supplies the maximum number of bytes to be</span>
02130 <span class="comment">        written to CustomCPString.  If this causes CustomCPString to be a</span>
02131 <span class="comment">        truncated equivalent of UnicodeString, no error condition results.</span>
02132 <span class="comment"></span>
02133 <span class="comment">    BytesInCustomCPString - Returns the number of bytes in the returned</span>
02134 <span class="comment">        CustomCP string pointed to by CustomCPString.</span>
02135 <span class="comment"></span>
02136 <span class="comment">    UnicodeString - Supplies the unicode source string that is to be</span>
02137 <span class="comment">        converted to CustomCP.</span>
02138 <span class="comment"></span>
02139 <span class="comment">    BytesInUnicodeString - The number of bytes in the the string pointed</span>
02140 <span class="comment">        to by UnicodeString.</span>
02141 <span class="comment"></span>
02142 <span class="comment">Return Value:</span>
02143 <span class="comment"></span>
02144 <span class="comment">    SUCCESS - The conversion was successful</span>
02145 <span class="comment"></span>
02146 <span class="comment">    STATUS_BUFFER_OVERFLOW - MaxBytesInUnicodeString was not enough to</span>
02147 <span class="comment">        hold the whole CustomCP string.  It was converted correctly to</span>
02148 <span class="comment">        that point, though.</span>
02149 <span class="comment"></span>
02150 <span class="comment">--*/</span>
02151 
02152 {
02153     ULONG TmpCount;
02154     ULONG LoopCount;
02155     PCH TranslateTable;
02156     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a> WideTranslateTable;
02157     ULONG CharsInUnicodeString;
02158     UCHAR SbChar;
02159     WCHAR UnicodeChar;
02160 
02161     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
02162 
02163     <span class="comment">//</span>
02164     <span class="comment">// Convert Unicode byte count to character count. Byte count of</span>
02165     <span class="comment">// multibyte string is equivalent to character count.</span>
02166     <span class="comment">//</span>
02167     <span class="keywordflow">if</span> (!(CustomCP-&gt;DBCSCodePage)) {
02168         CharsInUnicodeString = BytesInUnicodeString / <span class="keyword">sizeof</span>(WCHAR);
02169 
02170         LoopCount = (CharsInUnicodeString &lt; MaxBytesInCustomCPString) ?
02171                      CharsInUnicodeString : MaxBytesInCustomCPString;
02172 
02173         <span class="keywordflow">if</span> (ARGUMENT_PRESENT(BytesInCustomCPString))
02174             *BytesInCustomCPString = LoopCount;
02175 
02176         TranslateTable = CustomCP-&gt;WideCharTable;
02177 
02178         TmpCount = LoopCount &amp; 0x0F;
02179         UnicodeString += TmpCount;
02180         CustomCPString += TmpCount;
02181 
02182         <span class="keywordflow">do</span>
02183         {
02184             <span class="comment">//</span>
02185             <span class="comment">// Convert to Single Byte and back to Unicode before upper</span>
02186             <span class="comment">// casing to ensure the visual best fits are converted and</span>
02187             <span class="comment">// upper cased properly.</span>
02188             <span class="comment">//</span>
02189             <span class="keywordflow">switch</span>( TmpCount ) {
02190             <span class="keywordflow">default</span>:
02191                 UnicodeString += 0x10;
02192                 CustomCPString += 0x10;
02193 
02194                 SbChar = TranslateTable[UnicodeString[-0x10]];
02195                 UnicodeChar = (CustomCP-&gt;MultiByteTable)[SbChar];
02196                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
02197                 CustomCPString[-0x10] = TranslateTable[UnicodeChar];
02198             <span class="keywordflow">case</span> 0x0F:
02199                 SbChar = TranslateTable[UnicodeString[-0x0F]];
02200                 UnicodeChar = (CustomCP-&gt;MultiByteTable)[SbChar];
02201                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
02202                 CustomCPString[-0x0F] = TranslateTable[UnicodeChar];
02203             <span class="keywordflow">case</span> 0x0E:
02204                 SbChar = TranslateTable[UnicodeString[-0x0E]];
02205                 UnicodeChar = (CustomCP-&gt;MultiByteTable)[SbChar];
02206                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
02207                 CustomCPString[-0x0E] = TranslateTable[UnicodeChar];
02208             <span class="keywordflow">case</span> 0x0D:
02209                 SbChar = TranslateTable[UnicodeString[-0x0D]];
02210                 UnicodeChar = (CustomCP-&gt;MultiByteTable)[SbChar];
02211                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
02212                 CustomCPString[-0x0D] = TranslateTable[UnicodeChar];
02213             <span class="keywordflow">case</span> 0x0C:
02214                 SbChar = TranslateTable[UnicodeString[-0x0C]];
02215                 UnicodeChar = (CustomCP-&gt;MultiByteTable)[SbChar];
02216                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
02217                 CustomCPString[-0x0C] = TranslateTable[UnicodeChar];
02218             <span class="keywordflow">case</span> 0x0B:
02219                 SbChar = TranslateTable[UnicodeString[-0x0B]];
02220                 UnicodeChar = (CustomCP-&gt;MultiByteTable)[SbChar];
02221                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
02222                 CustomCPString[-0x0B] = TranslateTable[UnicodeChar];
02223             <span class="keywordflow">case</span> 0x0A:
02224                 SbChar = TranslateTable[UnicodeString[-0x0A]];
02225                 UnicodeChar = (CustomCP-&gt;MultiByteTable)[SbChar];
02226                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
02227                 CustomCPString[-0x0A] = TranslateTable[UnicodeChar];
02228             <span class="keywordflow">case</span> 0x09:
02229                 SbChar = TranslateTable[UnicodeString[-0x09]];
02230                 UnicodeChar = (CustomCP-&gt;MultiByteTable)[SbChar];
02231                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
02232                 CustomCPString[-0x09] = TranslateTable[UnicodeChar];
02233             <span class="keywordflow">case</span> 0x08:
02234                 SbChar = TranslateTable[UnicodeString[-0x08]];
02235                 UnicodeChar = (CustomCP-&gt;MultiByteTable)[SbChar];
02236                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
02237                 CustomCPString[-0x08] = TranslateTable[UnicodeChar];
02238             <span class="keywordflow">case</span> 0x07:
02239                 SbChar = TranslateTable[UnicodeString[-0x07]];
02240                 UnicodeChar = (CustomCP-&gt;MultiByteTable)[SbChar];
02241                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
02242                 CustomCPString[-0x07] = TranslateTable[UnicodeChar];
02243             <span class="keywordflow">case</span> 0x06:
02244                 SbChar = TranslateTable[UnicodeString[-0x06]];
02245                 UnicodeChar = (CustomCP-&gt;MultiByteTable)[SbChar];
02246                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
02247                 CustomCPString[-0x06] = TranslateTable[UnicodeChar];
02248             <span class="keywordflow">case</span> 0x05:
02249                 SbChar = TranslateTable[UnicodeString[-0x05]];
02250                 UnicodeChar = (CustomCP-&gt;MultiByteTable)[SbChar];
02251                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
02252                 CustomCPString[-0x05] = TranslateTable[UnicodeChar];
02253             <span class="keywordflow">case</span> 0x04:
02254                 SbChar = TranslateTable[UnicodeString[-0x04]];
02255                 UnicodeChar = (CustomCP-&gt;MultiByteTable)[SbChar];
02256                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
02257                 CustomCPString[-0x04] = TranslateTable[UnicodeChar];
02258             <span class="keywordflow">case</span> 0x03:
02259                 SbChar = TranslateTable[UnicodeString[-0x03]];
02260                 UnicodeChar = (CustomCP-&gt;MultiByteTable)[SbChar];
02261                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
02262                 CustomCPString[-0x03] = TranslateTable[UnicodeChar];
02263             <span class="keywordflow">case</span> 0x02:
02264                 SbChar = TranslateTable[UnicodeString[-0x02]];
02265                 UnicodeChar = (CustomCP-&gt;MultiByteTable)[SbChar];
02266                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
02267                 CustomCPString[-0x02] = TranslateTable[UnicodeChar];
02268             <span class="keywordflow">case</span> 0x01:
02269                 SbChar = TranslateTable[UnicodeString[-0x01]];
02270                 UnicodeChar = (CustomCP-&gt;MultiByteTable)[SbChar];
02271                 UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
02272                 CustomCPString[-0x01] = TranslateTable[UnicodeChar];
02273             <span class="keywordflow">case</span> 0x00:
02274                 ;
02275             }
02276 
02277             LoopCount -= TmpCount;
02278             TmpCount = 0x10;
02279         } <span class="keywordflow">while</span> ( LoopCount &gt; 0 );
02280 
02281         <span class="comment">/* end of copy... */</span>
02282     } <span class="keywordflow">else</span> {
02283         <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> MbChar;
02284         <span class="keyword">register</span> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> Entry;
02285         PCH CustomCPStringAnchor = CustomCPString;
02286         <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a> NlsCustomLeadByteInfo = CustomCP-&gt;DBCSOffsets;
02287 
02288         WideTranslateTable = CustomCP-&gt;WideCharTable;
02289 
02290         CharsInUnicodeString = BytesInUnicodeString / <span class="keyword">sizeof</span>(WCHAR);
02291 
02292         <span class="keywordflow">while</span> ( CharsInUnicodeString &amp;&amp; MaxBytesInCustomCPString ) {
02293             <span class="comment">//</span>
02294             <span class="comment">// Convert to Single Byte and back to Unicode before upper</span>
02295             <span class="comment">// casing to ensure the visual best fits are converted and</span>
02296             <span class="comment">// upper cased properly.</span>
02297             <span class="comment">//</span>
02298             MbChar = WideTranslateTable[ *UnicodeString++ ];
02299             <span class="keywordflow">if</span> (NlsCustomLeadByteInfo[<a class="code" href="../../d5/d9/ntrtlp_8h.html#a5">HIBYTE</a>(MbChar)]) {
02300                 <span class="comment">//</span>
02301                 <span class="comment">// Lead byte - translate the trail byte using the table</span>
02302                 <span class="comment">// that corresponds to this lead byte.</span>
02303                 <span class="comment">//</span>
02304                 Entry = NlsCustomLeadByteInfo[<a class="code" href="../../d5/d9/ntrtlp_8h.html#a5">HIBYTE</a>(MbChar)];
02305                 UnicodeChar = NlsCustomLeadByteInfo[ Entry + <a class="code" href="../../d5/d9/ntrtlp_8h.html#a4">LOBYTE</a>(MbChar) ];
02306             } <span class="keywordflow">else</span> {
02307                 <span class="comment">//</span>
02308                 <span class="comment">// Single byte character.</span>
02309                 <span class="comment">//</span>
02310                 UnicodeChar = (CustomCP-&gt;MultiByteTable)[<a class="code" href="../../d5/d9/ntrtlp_8h.html#a4">LOBYTE</a>(MbChar)];
02311             }
02312             UnicodeChar = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(UnicodeChar);
02313             MbChar = WideTranslateTable[UnicodeChar];
02314 
02315             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d9/ntrtlp_8h.html#a5">HIBYTE</a>(MbChar) != 0) {
02316                 <span class="comment">//</span>
02317                 <span class="comment">// Need at least 2 bytes to copy a double byte char.</span>
02318                 <span class="comment">// Don't want to truncate in the middle of a DBCS char.</span>
02319                 <span class="comment">//</span>
02320                 <span class="keywordflow">if</span> (MaxBytesInCustomCPString-- &lt; 2) {
02321                     <span class="keywordflow">break</span>;
02322                 }
02323                 *CustomCPString++ = <a class="code" href="../../d5/d9/ntrtlp_8h.html#a5">HIBYTE</a>(MbChar);  <span class="comment">// lead byte</span>
02324             }
02325             *CustomCPString++ = <a class="code" href="../../d5/d9/ntrtlp_8h.html#a4">LOBYTE</a>(MbChar);
02326             MaxBytesInCustomCPString--;
02327 
02328             CharsInUnicodeString--;
02329         }
02330 
02331         <span class="keywordflow">if</span> (ARGUMENT_PRESENT(BytesInCustomCPString))
02332             *BytesInCustomCPString = (ULONG)(CustomCPString - CustomCPStringAnchor);
02333     }
02334 
02335     <span class="comment">//</span>
02336     <span class="comment">//  Check if we were able to use all of the source Unicode String</span>
02337     <span class="comment">//</span>
02338     <span class="keywordflow">return</span> ( CharsInUnicodeString &lt;= MaxBytesInCustomCPString ) ?
02339            STATUS_SUCCESS :
02340            STATUS_BUFFER_OVERFLOW;
02341 }
02342 
<a name="l02343"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a1">02343</a> <span class="preprocessor">#define MB_TBL_SIZE      256             </span><span class="comment">/* size of MB tables */</span>
<a name="l02344"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a2">02344</a> <span class="preprocessor">#define GLYPH_TBL_SIZE   MB_TBL_SIZE     </span><span class="comment">/* size of GLYPH tables */</span>
<a name="l02345"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a3">02345</a> <span class="preprocessor">#define DBCS_TBL_SIZE    256             </span><span class="comment">/* size of DBCS tables */</span>
<a name="l02346"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a4">02346</a> <span class="preprocessor">#define GLYPH_HEADER     1               </span><span class="comment">/* size of GLYPH table header */</span>
<a name="l02347"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a5">02347</a> <span class="preprocessor">#define DBCS_HEADER      1               </span><span class="comment">/* size of DBCS table header */</span>
<a name="l02348"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a6">02348</a> <span class="preprocessor">#define LANG_HEADER      1               </span><span class="comment">/* size of LANGUAGE file header */</span>
<a name="l02349"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a7">02349</a> <span class="preprocessor">#define UP_HEADER        1               </span><span class="comment">/* size of UPPERCASE table header */</span>
<a name="l02350"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a8">02350</a> <span class="preprocessor">#define LO_HEADER        1               </span><span class="comment">/* size of LOWERCASE table header */</span>
02351 
02352 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02353"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a45">02353</a> <a class="code" href="../../d9/d6/nlsxlat_8c.html#a45">RtlInitCodePageTable</a>(
02354     IN PUSHORT TableBase,
02355     OUT PCPTABLEINFO CodePageTable
02356     )
02357 {
02358     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> offMB;
02359     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> offWC;
02360     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a> pGlyph;
02361     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a> pRange;
02362 
02363     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
02364 
02365     <span class="comment">//</span>
02366     <span class="comment">// Get the offsets.</span>
02367     <span class="comment">//</span>
02368 
02369     offMB = TableBase[0];
02370     offWC = offMB + TableBase[offMB];
02371 
02372 
02373     <span class="comment">//</span>
02374     <span class="comment">// Attach Code Page Info to CP hash node.</span>
02375     <span class="comment">//</span>
02376 
02377     CodePageTable-&gt;CodePage = TableBase[1];
02378     CodePageTable-&gt;MaximumCharacterSize = TableBase[2];
02379     CodePageTable-&gt;DefaultChar = TableBase[3];           <span class="comment">// default character (MB)</span>
02380     CodePageTable-&gt;UniDefaultChar = TableBase[4];        <span class="comment">// default character (Unicode)</span>
02381     CodePageTable-&gt;TransDefaultChar = TableBase[5];      <span class="comment">// trans of default char (Unicode)</span>
02382     CodePageTable-&gt;TransUniDefaultChar = TableBase[6];   <span class="comment">// trans of Uni default char (MB)</span>
02383     RtlMoveMemory(
02384         &amp;CodePageTable-&gt;LeadByte,
02385         &amp;TableBase[7],
02386         MAXIMUM_LEADBYTES
02387         );
02388     CodePageTable-&gt;MultiByteTable = (TableBase + offMB + 1);
02389 
02390     pGlyph = CodePageTable-&gt;MultiByteTable + <a class="code" href="../../d9/d6/nlsxlat_8c.html#a1">MB_TBL_SIZE</a>;
02391 
02392     <span class="keywordflow">if</span> (pGlyph[0] != 0) {
02393         pRange = CodePageTable-&gt;DBCSRanges = pGlyph + <a class="code" href="../../d9/d6/nlsxlat_8c.html#a4">GLYPH_HEADER</a> + <a class="code" href="../../d9/d6/nlsxlat_8c.html#a2">GLYPH_TBL_SIZE</a>;
02394         }
02395     <span class="keywordflow">else</span> {
02396         pRange = CodePageTable-&gt;DBCSRanges = pGlyph + <a class="code" href="../../d9/d6/nlsxlat_8c.html#a4">GLYPH_HEADER</a>;
02397         }
02398 
02399     <span class="comment">//</span>
02400     <span class="comment">//  Attach DBCS information to CP hash node.</span>
02401     <span class="comment">//</span>
02402 
02403     <span class="keywordflow">if</span> (pRange[0] &gt; 0) {
02404         CodePageTable-&gt;DBCSOffsets = pRange + <a class="code" href="../../d9/d6/nlsxlat_8c.html#a5">DBCS_HEADER</a>;
02405         CodePageTable-&gt;DBCSCodePage = 1;
02406         }
02407     <span class="keywordflow">else</span> {
02408         CodePageTable-&gt;DBCSCodePage = 0;
02409         CodePageTable-&gt;DBCSOffsets = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02410         }
02411 
02412     CodePageTable-&gt;WideCharTable = (TableBase + offWC + 1);
02413 }
02414 
02415 
02416 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02417"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a32">02417</a> <a class="code" href="../../d9/d6/nlsxlat_8c.html#a32">RtlpInitUpcaseTable</a>(
02418     IN PUSHORT TableBase,
02419     OUT PNLSTABLEINFO CodePageTable
02420     )
02421 {
02422     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> offUP;
02423     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> offLO;
02424 
02425     <span class="comment">//</span>
02426     <span class="comment">// Get the offsets.</span>
02427     <span class="comment">//</span>
02428 
02429     offUP = <a class="code" href="../../d9/d6/nlsxlat_8c.html#a6">LANG_HEADER</a>;
02430     offLO = offUP + TableBase[offUP];
02431 
02432     CodePageTable-&gt;UpperCaseTable = TableBase + offUP + <a class="code" href="../../d9/d6/nlsxlat_8c.html#a7">UP_HEADER</a>;
02433     CodePageTable-&gt;LowerCaseTable = TableBase + offLO + <a class="code" href="../../d9/d6/nlsxlat_8c.html#a8">LO_HEADER</a>;
02434 }
02435 
02436 
02437 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02438"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a46">02438</a> <a class="code" href="../../d9/d6/nlsxlat_8c.html#a46">RtlInitNlsTables</a>(
02439     IN PUSHORT AnsiNlsBase,
02440     IN PUSHORT OemNlsBase,
02441     IN PUSHORT LanguageNlsBase,
02442     OUT PNLSTABLEINFO TableInfo
02443     )
02444 {
02445     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
02446 
02447     <a class="code" href="../../d9/d6/nlsxlat_8c.html#a45">RtlInitCodePageTable</a>(AnsiNlsBase,&amp;TableInfo-&gt;AnsiTableInfo);
02448     <a class="code" href="../../d9/d6/nlsxlat_8c.html#a45">RtlInitCodePageTable</a>(OemNlsBase,&amp;TableInfo-&gt;OemTableInfo);
02449     <a class="code" href="../../d9/d6/nlsxlat_8c.html#a32">RtlpInitUpcaseTable</a>(LanguageNlsBase,TableInfo);
02450 }
02451 
02452 
02453 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02454"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a47">02454</a> <a class="code" href="../../d9/d6/nlsxlat_8c.html#a47">RtlResetRtlTranslations</a>(
02455     PNLSTABLEINFO TableInfo
02456     )
02457 {
02458     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
02459 
02460     <span class="keywordflow">if</span> ( TableInfo-&gt;AnsiTableInfo.DBCSCodePage ) {
02461         RtlMoveMemory(<a class="code" href="../../d6/d6/nls_8c.html#a20">NlsLeadByteInfo</a>,TableInfo-&gt;AnsiTableInfo.DBCSOffsets,<a class="code" href="../../d9/d6/nlsxlat_8c.html#a3">DBCS_TBL_SIZE</a>*<span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>));
02462         }
02463     <span class="keywordflow">else</span> {
02464         RtlZeroMemory(<a class="code" href="../../d6/d6/nls_8c.html#a20">NlsLeadByteInfo</a>,<a class="code" href="../../d9/d6/nlsxlat_8c.html#a3">DBCS_TBL_SIZE</a>*<span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>));
02465         }
02466 
02467     <a class="code" href="../../d9/d6/nlsxlat_8c.html#a15">NlsMbAnsiCodePageTables</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>)TableInfo-&gt;AnsiTableInfo.DBCSOffsets;
02468 
02469     <a class="code" href="../../d6/d6/nls_8c.html#a19">NlsAnsiToUnicodeData</a> = TableInfo-&gt;AnsiTableInfo.MultiByteTable;
02470     <a class="code" href="../../d9/d6/nlsxlat_8c.html#a17">NlsUnicodeToAnsiData</a> = (PCH)TableInfo-&gt;AnsiTableInfo.WideCharTable;
02471     <a class="code" href="../../d9/d6/nlsxlat_8c.html#a18">NlsUnicodeToMbAnsiData</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>)TableInfo-&gt;AnsiTableInfo.WideCharTable;
02472     <a class="code" href="../../d9/d6/nlsxlat_8c.html#a19">NlsMbCodePageTag</a> = TableInfo-&gt;AnsiTableInfo.DBCSCodePage ? <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> : <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02473     <a class="code" href="../../d9/d6/nlsxlat_8c.html#a12">NlsAnsiCodePage</a> = TableInfo-&gt;AnsiTableInfo.CodePage;
02474 
02475     <span class="keywordflow">if</span> ( TableInfo-&gt;OemTableInfo.DBCSCodePage ) {
02476         RtlMoveMemory(<a class="code" href="../../d5/d9/gen8dot3_8c.html#a6">NlsOemLeadByteInfo</a>,TableInfo-&gt;OemTableInfo.DBCSOffsets,<a class="code" href="../../d9/d6/nlsxlat_8c.html#a3">DBCS_TBL_SIZE</a>*<span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>));
02477         }
02478     <span class="keywordflow">else</span> {
02479         RtlZeroMemory(<a class="code" href="../../d5/d9/gen8dot3_8c.html#a6">NlsOemLeadByteInfo</a>,<a class="code" href="../../d9/d6/nlsxlat_8c.html#a3">DBCS_TBL_SIZE</a>*<span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>));
02480         }
02481 
02482     <a class="code" href="../../d5/d9/gen8dot3_8c.html#a4">NlsMbOemCodePageTables</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>)TableInfo-&gt;OemTableInfo.DBCSOffsets;
02483 
02484     <a class="code" href="../../d5/d9/gen8dot3_8c.html#a2">NlsOemToUnicodeData</a> = TableInfo-&gt;OemTableInfo.MultiByteTable;
02485     <a class="code" href="../../d5/d9/gen8dot3_8c.html#a3">NlsUnicodeToOemData</a> = (PCH)TableInfo-&gt;OemTableInfo.WideCharTable;
02486     <a class="code" href="../../d5/d9/gen8dot3_8c.html#a1">NlsUnicodeToMbOemData</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>)TableInfo-&gt;OemTableInfo.WideCharTable;
02487     <a class="code" href="../../d5/d9/gen8dot3_8c.html#a5">NlsMbOemCodePageTag</a> = TableInfo-&gt;OemTableInfo.DBCSCodePage ? <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> : <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02488     <a class="code" href="../../d9/d6/nlsxlat_8c.html#a13">NlsOemCodePage</a> = TableInfo-&gt;OemTableInfo.CodePage;
02489     <a class="code" href="../../d5/d9/gen8dot3_8c.html#a7">OemDefaultChar</a> = TableInfo-&gt;OemTableInfo.DefaultChar;
02490     <a class="code" href="../../d9/d6/nlsxlat_8c.html#a29">OemTransUniDefaultChar</a> = TableInfo-&gt;OemTableInfo.TransDefaultChar;
02491 
02492     <a class="code" href="../../d9/d6/nlsxlat_8c.html#a9">Nls844UnicodeUpcaseTable</a> = TableInfo-&gt;UpperCaseTable;
02493     <a class="code" href="../../d9/d6/nlsxlat_8c.html#a10">Nls844UnicodeLowercaseTable</a> = TableInfo-&gt;LowerCaseTable;
02494     <a class="code" href="../../d9/d6/nlsxlat_8c.html#a27">UnicodeDefaultChar</a> = TableInfo-&gt;AnsiTableInfo.UniDefaultChar;
02495 }
02496 
02497 <span class="keywordtype">void</span>
<a name="l02498"></a><a class="code" href="../../d9/d6/nlsxlat_8c.html#a48">02498</a> <a class="code" href="../../d9/d6/nlsxlat_8c.html#a48">RtlGetDefaultCodePage</a>(
02499     OUT PUSHORT AnsiCodePage,
02500     OUT PUSHORT OemCodePage
02501     )
02502 {
02503     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
02504     *AnsiCodePage = <a class="code" href="../../d9/d6/nlsxlat_8c.html#a12">NlsAnsiCodePage</a>;
02505     *OemCodePage = <a class="code" href="../../d9/d6/nlsxlat_8c.html#a13">NlsOemCodePage</a>;
02506 }
02507 
02508 
02509 
02510 
02511 
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:57 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
