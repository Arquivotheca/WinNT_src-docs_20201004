<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: exceptn.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>exceptn.c</h1><a href="../../d9/d8/i386_2exceptn_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1989  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    exceptn.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module implement the code necessary to dispatch expections to the</span>
00012 <span class="comment">    proper mode and invoke the exception dispatcher.</span>
00013 <span class="comment"></span>
00014 <span class="comment">Author:</span>
00015 <span class="comment"></span>
00016 <span class="comment">    David N. Cutler (davec) 30-Apr-1989</span>
00017 <span class="comment"></span>
00018 <span class="comment">Environment:</span>
00019 <span class="comment"></span>
00020 <span class="comment">    Kernel mode only.</span>
00021 <span class="comment"></span>
00022 <span class="comment">Revision History:</span>
00023 <span class="comment"></span>
00024 <span class="comment">    14-Feb-1990    shielint</span>
00025 <span class="comment"></span>
00026 <span class="comment">                   Modified for NT386 interrupt manager</span>
00027 <span class="comment"></span>
00028 <span class="comment">    6-April-1990    bryanwi</span>
00029 <span class="comment"></span>
00030 <span class="comment">                   Fix non-canonical stack case for 386.</span>
00031 <span class="comment"></span>
00032 <span class="comment">--*/</span>
00033 
00034 <span class="preprocessor">#include "<a class="code" href="../../d0/d0/ki_8h.html">ki.h</a>"</span>
00035 
<a name="l00036"></a><a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a0">00036</a> <span class="preprocessor">#define FN_BITS_PER_TAGWORD     16</span>
<a name="l00037"></a><a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a1">00037</a> <span class="preprocessor"></span><span class="preprocessor">#define FN_TAG_EMPTY            0x3</span>
<a name="l00038"></a><a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a2">00038</a> <span class="preprocessor"></span><span class="preprocessor">#define FN_TAG_MASK             0x3</span>
<a name="l00039"></a><a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a3">00039</a> <span class="preprocessor"></span><span class="preprocessor">#define FX_TAG_VALID            0x1</span>
<a name="l00040"></a><a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a4">00040</a> <span class="preprocessor"></span><span class="preprocessor">#define NUMBER_OF_FP_REGISTERS  8</span>
<a name="l00041"></a><a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a5">00041</a> <span class="preprocessor"></span><span class="preprocessor">#define BYTES_PER_FP_REGISTER   10</span>
<a name="l00042"></a><a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a6">00042</a> <span class="preprocessor"></span><span class="preprocessor">#define BYTES_PER_FX_REGISTER   16</span>
00043 <span class="preprocessor"></span>
<a name="l00044"></a><a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a7">00044</a> <span class="keyword">extern</span> UCHAR <a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a7">VdmUserCr0MapIn</a>[];
<a name="l00045"></a><a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a8">00045</a> <span class="keyword">extern</span> BOOLEAN <a class="code" href="../../d5/d3/i386_8h.html#a24">KeI386FxsrPresent</a>;
<a name="l00046"></a><a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a9">00046</a> <span class="keyword">extern</span> BOOLEAN <a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a9">KeI386XMMIPresent</a>;
00047 
00048 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00049 <a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a10">Ki386AdjustEsp0</a>(
00050     IN PKTRAP_FRAME TrapFrame
00051     );
00052 
00053 BOOLEAN
00054 <a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a11">KiEm87StateToNpxFrame</a>(
00055     OUT PFLOATING_SAVE_AREA NpxFrmae
00056     );
00057 
00058 BOOLEAN
00059 <a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a12">KiNpxFrameToEm87State</a>(
00060     IN PFLOATING_SAVE_AREA NpxFrmae
00061     );
00062 
00063 
00064 ULONG
<a name="l00065"></a><a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a13">00065</a> <a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a13">KiEspFromTrapFrame</a>(
00066     IN PKTRAP_FRAME TrapFrame
00067     )
00068 
00069 <span class="comment">/*++</span>
00070 <span class="comment"></span>
00071 <span class="comment">Routine Description:</span>
00072 <span class="comment"></span>
00073 <span class="comment">    This routine fetches the correct esp from a trapframe, accounting</span>
00074 <span class="comment">    for whether the frame is a user or kernel mode frame, and whether</span>
00075 <span class="comment">    it has been edited.</span>
00076 <span class="comment"></span>
00077 <span class="comment">Arguments:</span>
00078 <span class="comment"></span>
00079 <span class="comment">    TrapFrame - Supplies a pointer to a trap frame from which volatile context</span>
00080 <span class="comment">        should be copied into the context record.</span>
00081 <span class="comment"></span>
00082 <span class="comment">Return Value:</span>
00083 <span class="comment"></span>
00084 <span class="comment">    Value of Esp.</span>
00085 <span class="comment"></span>
00086 <span class="comment">--*/</span>
00087 
00088 {
00089     <span class="keywordflow">if</span> (((TrapFrame-&gt;SegCs &amp; MODE_MASK) != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) ||
00090          (TrapFrame-&gt;EFlags &amp; EFLAGS_V86_MASK)) {
00091 
00092         <span class="comment">//  User mode frame, real value of Esp is always in HardwareEsp.</span>
00093 
00094         <span class="keywordflow">return</span> TrapFrame-&gt;HardwareEsp;
00095 
00096     } <span class="keywordflow">else</span> {
00097 
00098         <span class="keywordflow">if</span> ((TrapFrame-&gt;SegCs &amp; FRAME_EDITED) == 0) {
00099 
00100             <span class="comment">//  Kernel mode frame which has had esp edited,</span>
00101             <span class="comment">//  value of Esp is in TempEsp.</span>
00102 
00103             <span class="keywordflow">return</span> TrapFrame-&gt;TempEsp;
00104 
00105         } <span class="keywordflow">else</span> {
00106 
00107             <span class="comment">//  Kernel mode frame has has not had esp edited, compute esp.</span>
00108 
00109             <span class="keywordflow">return</span> (ULONG)&amp;TrapFrame-&gt;HardwareEsp;
00110         }
00111     }
00112 }
00113 
00114 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00115"></a><a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a14">00115</a> <a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a14">KiEspToTrapFrame</a>(
00116     IN PKTRAP_FRAME TrapFrame,
00117     IN ULONG Esp
00118     )
00119 
00120 <span class="comment">/*++</span>
00121 <span class="comment"></span>
00122 <span class="comment">Routine Description:</span>
00123 <span class="comment"></span>
00124 <span class="comment">    This routine sets the specified value Esp into the trap frame,</span>
00125 <span class="comment">    accounting for whether the frame is a user or kernel mode frame,</span>
00126 <span class="comment">    and whether it has been edited before.</span>
00127 <span class="comment"></span>
00128 <span class="comment">Arguments:</span>
00129 <span class="comment"></span>
00130 <span class="comment">    TrapFrame - Supplies a pointer to a trap frame from which volatile context</span>
00131 <span class="comment">        should be copied into the context record.</span>
00132 <span class="comment"></span>
00133 <span class="comment">    Esp - New value for Esp.</span>
00134 <span class="comment"></span>
00135 <span class="comment">Return Value:</span>
00136 <span class="comment"></span>
00137 <span class="comment">    None.</span>
00138 <span class="comment"></span>
00139 <span class="comment">--*/</span>
00140 {
00141     ULONG   OldEsp;
00142 
00143     OldEsp = <a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a13">KiEspFromTrapFrame</a>(TrapFrame);
00144 
00145     <span class="keywordflow">if</span> (((TrapFrame-&gt;SegCs &amp; MODE_MASK) != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) ||
00146          (TrapFrame-&gt;EFlags &amp; EFLAGS_V86_MASK)) {
00147 
00148         <span class="comment">//</span>
00149         <span class="comment">//  User mode trap frame</span>
00150         <span class="comment">//</span>
00151 
00152         TrapFrame-&gt;HardwareEsp = Esp;
00153 
00154     } <span class="keywordflow">else</span> {
00155 
00156         <span class="comment">//</span>
00157         <span class="comment">//  Kernel mode esp can't be lowered or iret emulation will fail</span>
00158         <span class="comment">//</span>
00159 
00160         <span class="keywordflow">if</span> (Esp &lt; OldEsp)
00161             <a class="code" href="../../d9/d1/bugcheck_8c.html#a13">KeBugCheck</a>(SET_OF_INVALID_CONTEXT);
00162 
00163         <span class="comment">//</span>
00164         <span class="comment">//  Edit frame, setting edit marker as needed.</span>
00165         <span class="comment">//</span>
00166 
00167         <span class="keywordflow">if</span> ((TrapFrame-&gt;SegCs &amp; FRAME_EDITED) == 0) {
00168 
00169             <span class="comment">//  Kernel frame that has already been edited,</span>
00170             <span class="comment">//  store value in TempEsp.</span>
00171 
00172             TrapFrame-&gt;TempEsp = Esp;
00173 
00174         } <span class="keywordflow">else</span> {
00175 
00176             <span class="comment">//  Kernel frame for which Esp is being edited first time.</span>
00177             <span class="comment">//  Save real SegCs, set marked in SegCs, save Esp value.</span>
00178 
00179             <span class="keywordflow">if</span> (OldEsp != Esp) {
00180                 TrapFrame-&gt;TempSegCs = TrapFrame-&gt;SegCs;
00181                 TrapFrame-&gt;SegCs = TrapFrame-&gt;SegCs &amp; ~FRAME_EDITED;
00182                 TrapFrame-&gt;TempEsp = Esp;
00183             }
00184         }
00185     }
00186 }
00187 
00188 ULONG
<a name="l00189"></a><a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a15">00189</a> <a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a15">KiSegSsFromTrapFrame</a>(
00190     IN PKTRAP_FRAME TrapFrame
00191     )
00192 
00193 <span class="comment">/*++</span>
00194 <span class="comment"></span>
00195 <span class="comment">Routine Description:</span>
00196 <span class="comment"></span>
00197 <span class="comment">    This routine fetches the correct ss from a trapframe, accounting</span>
00198 <span class="comment">    for whether the frame is a user or kernel mode frame.</span>
00199 <span class="comment"></span>
00200 <span class="comment">Arguments:</span>
00201 <span class="comment"></span>
00202 <span class="comment">    TrapFrame - Supplies a pointer to a trap frame from which volatile context</span>
00203 <span class="comment">        should be copied into the context record.</span>
00204 <span class="comment"></span>
00205 <span class="comment">Return Value:</span>
00206 <span class="comment"></span>
00207 <span class="comment">    Value of SegSs.</span>
00208 <span class="comment"></span>
00209 <span class="comment">--*/</span>
00210 
00211 {
00212     <span class="keywordflow">if</span> (TrapFrame-&gt;EFlags &amp; EFLAGS_V86_MASK){
00213         <span class="keywordflow">return</span> TrapFrame-&gt;HardwareSegSs;
00214     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((TrapFrame-&gt;SegCs &amp; MODE_MASK) != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
00215 
00216         <span class="comment">//</span>
00217         <span class="comment">// It's user mode.  The HardwareSegSs contains R3 data selector.</span>
00218         <span class="comment">//</span>
00219 
00220         <span class="keywordflow">return</span> TrapFrame-&gt;HardwareSegSs | RPL_MASK;
00221     } <span class="keywordflow">else</span> {
00222         <span class="keywordflow">return</span> KGDT_R0_DATA;
00223     }
00224 }
00225 
00226 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00227"></a><a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a16">00227</a> <a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a16">KiSegSsToTrapFrame</a>(
00228     IN PKTRAP_FRAME TrapFrame,
00229     IN ULONG SegSs
00230     )
00231 
00232 <span class="comment">/*++</span>
00233 <span class="comment"></span>
00234 <span class="comment">Routine Description:</span>
00235 <span class="comment"></span>
00236 <span class="comment">    It turns out that in a flat system there are only two legal values</span>
00237 <span class="comment">    for SS.  Therefore, this procedure forces the appropriate one</span>
00238 <span class="comment">    of those values to be used.  The legal SS value is a function of</span>
00239 <span class="comment">    which CS value is already set.</span>
00240 <span class="comment"></span>
00241 <span class="comment">Arguments:</span>
00242 <span class="comment"></span>
00243 <span class="comment">    TrapFrame - Supplies a pointer to a trap frame from which volatile context</span>
00244 <span class="comment">        should be copied into the context record.</span>
00245 <span class="comment"></span>
00246 <span class="comment">    SegSs - value of SS caller would like to set.</span>
00247 <span class="comment"></span>
00248 <span class="comment">Return Value:</span>
00249 <span class="comment"></span>
00250 <span class="comment">    Nothing.</span>
00251 <span class="comment"></span>
00252 <span class="comment">--*/</span>
00253 
00254 {
00255     SegSs &amp;= SEGMENT_MASK;  <span class="comment">// Throw away the high order trash bits</span>
00256 
00257     <span class="keywordflow">if</span> (TrapFrame-&gt;EFlags &amp; EFLAGS_V86_MASK) {
00258         TrapFrame-&gt;HardwareSegSs = SegSs;
00259     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((TrapFrame-&gt;SegCs &amp; MODE_MASK) == <a class="code" href="../../d0/d9/ntosdef_8h.html#a76a70">UserMode</a>) {
00260 
00261         <span class="comment">//</span>
00262         <span class="comment">// If user mode, we simply put SegSs to trapfram.  If the SegSs</span>
00263         <span class="comment">// is a bogus value.  The trap0d handler will be able to detect</span>
00264         <span class="comment">// this and handle it appropriately.</span>
00265         <span class="comment">//</span>
00266 
00267         TrapFrame-&gt;HardwareSegSs = SegSs | RPL_MASK;
00268     }
00269 
00270     <span class="comment">//</span>
00271     <span class="comment">//  else {</span>
00272     <span class="comment">//      The frame is a kernel mode frame, which does not have</span>
00273     <span class="comment">//      a place to store SS.  Therefore, do nothing.</span>
00274     <span class="comment">//</span>
00275 }
00276 
00277 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00278"></a><a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a17">00278</a> <a class="code" href="../../d2/d9/ppc_2exceptn_8c.html#a9">KeContextFromKframes</a> (
00279     IN PKTRAP_FRAME TrapFrame,
00280     IN PKEXCEPTION_FRAME ExceptionFrame,
00281     IN OUT PCONTEXT ContextFrame
00282     )
00283 
00284 <span class="comment">/*++</span>
00285 <span class="comment"></span>
00286 <span class="comment">Routine Description:</span>
00287 <span class="comment"></span>
00288 <span class="comment">    This routine moves the selected contents of the specified trap and exception frames</span>
00289 <span class="comment">    frames into the specified context frame according to the specified context</span>
00290 <span class="comment">    flags.</span>
00291 <span class="comment"></span>
00292 <span class="comment">Arguments:</span>
00293 <span class="comment"></span>
00294 <span class="comment">    TrapFrame - Supplies a pointer to a trap frame from which volatile context</span>
00295 <span class="comment">        should be copied into the context record.</span>
00296 <span class="comment"></span>
00297 <span class="comment">    ExceptionFrame - Supplies a pointer to an exception frame from which context</span>
00298 <span class="comment">        should be copied into the context record. This argument is ignored since</span>
00299 <span class="comment">        there is no exception frame on NT386.</span>
00300 <span class="comment"></span>
00301 <span class="comment">    ContextFrame - Supplies a pointer to the context frame that receives the</span>
00302 <span class="comment">        context copied from the trap and exception frames.</span>
00303 <span class="comment"></span>
00304 <span class="comment">Return Value:</span>
00305 <span class="comment"></span>
00306 <span class="comment">    None.</span>
00307 <span class="comment"></span>
00308 <span class="comment">--*/</span>
00309 
00310 {
00311 
00312     PFX_SAVE_AREA NpxFrame;
00313     BOOLEAN StateSaved;
00314     ULONG i;
00315     <span class="keyword">struct </span>_FPSaveBuffer {
00316         UCHAR               <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>[15];
00317         FLOATING_SAVE_AREA  SaveArea;
00318     } FloatSaveBuffer;
00319     PFLOATING_SAVE_AREA PSaveArea;
00320 
00321     UNREFERENCED_PARAMETER( ExceptionFrame );
00322 
00323     <span class="comment">//</span>
00324     <span class="comment">// Set control information if specified.</span>
00325     <span class="comment">//</span>
00326 
00327     <span class="keywordflow">if</span> ((ContextFrame-&gt;ContextFlags &amp; <a class="code" href="../../d6/d7/halmips_8h.html#a153">CONTEXT_CONTROL</a>) == <a class="code" href="../../d6/d7/halmips_8h.html#a153">CONTEXT_CONTROL</a>) {
00328 
00329         <span class="comment">//</span>
00330         <span class="comment">// Set registers ebp, eip, cs, eflag, esp and ss.</span>
00331         <span class="comment">//</span>
00332 
00333         ContextFrame-&gt;Ebp = TrapFrame-&gt;Ebp;
00334         ContextFrame-&gt;Eip = TrapFrame-&gt;Eip;
00335 
00336         <span class="keywordflow">if</span> (((TrapFrame-&gt;SegCs &amp; FRAME_EDITED) == 0) &amp;&amp;
00337             ((TrapFrame-&gt;EFlags &amp; EFLAGS_V86_MASK) == 0)) {
00338             ContextFrame-&gt;SegCs = TrapFrame-&gt;TempSegCs &amp; SEGMENT_MASK;
00339         } <span class="keywordflow">else</span> {
00340             ContextFrame-&gt;SegCs = TrapFrame-&gt;SegCs &amp; SEGMENT_MASK;
00341         }
00342         ContextFrame-&gt;EFlags = TrapFrame-&gt;EFlags;
00343         ContextFrame-&gt;SegSs = <a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a15">KiSegSsFromTrapFrame</a>(TrapFrame);
00344         ContextFrame-&gt;Esp = <a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a13">KiEspFromTrapFrame</a>(TrapFrame);
00345     }
00346 
00347     <span class="comment">//</span>
00348     <span class="comment">// Set segment register contents if specified.</span>
00349     <span class="comment">//</span>
00350 
00351     <span class="keywordflow">if</span> ((ContextFrame-&gt;ContextFlags &amp; CONTEXT_SEGMENTS) == CONTEXT_SEGMENTS) {
00352 
00353         <span class="comment">//</span>
00354         <span class="comment">// Set segment registers gs, fs, es, ds.</span>
00355         <span class="comment">//</span>
00356         <span class="comment">// These values are junk most of the time, but useful</span>
00357         <span class="comment">// for debugging under certain conditions.  Therefore,</span>
00358         <span class="comment">// we report whatever was in the frame.</span>
00359         <span class="comment">//</span>
00360         <span class="keywordflow">if</span> (TrapFrame-&gt;EFlags &amp; EFLAGS_V86_MASK) {
00361             ContextFrame-&gt;SegGs = TrapFrame-&gt;V86Gs &amp; SEGMENT_MASK;
00362             ContextFrame-&gt;SegFs = TrapFrame-&gt;V86Fs &amp; SEGMENT_MASK;
00363             ContextFrame-&gt;SegEs = TrapFrame-&gt;V86Es &amp; SEGMENT_MASK;
00364             ContextFrame-&gt;SegDs = TrapFrame-&gt;V86Ds &amp; SEGMENT_MASK;
00365         }
00366         <span class="keywordflow">else</span> {
00367             <span class="keywordflow">if</span> (TrapFrame-&gt;SegCs == KGDT_R0_CODE) {
00368                 <span class="comment">//</span>
00369                 <span class="comment">// Trap frames created from R0_CODE traps do not save</span>
00370                 <span class="comment">// the following selectors.  Set them in the frame now.</span>
00371                 <span class="comment">//</span>
00372 
00373                 TrapFrame-&gt;SegGs = 0;
00374                 TrapFrame-&gt;SegFs = KGDT_R0_PCR;
00375                 TrapFrame-&gt;SegEs = KGDT_R3_DATA | RPL_MASK;
00376                 TrapFrame-&gt;SegDs = KGDT_R3_DATA | RPL_MASK;
00377             }
00378 
00379             ContextFrame-&gt;SegGs = TrapFrame-&gt;SegGs &amp; SEGMENT_MASK;
00380             ContextFrame-&gt;SegFs = TrapFrame-&gt;SegFs &amp; SEGMENT_MASK;
00381             ContextFrame-&gt;SegEs = TrapFrame-&gt;SegEs &amp; SEGMENT_MASK;
00382             ContextFrame-&gt;SegDs = TrapFrame-&gt;SegDs &amp; SEGMENT_MASK;
00383         }
00384 
00385     }
00386 
00387     <span class="comment">//</span>
00388     <span class="comment">// Set integer register contents if specified.</span>
00389     <span class="comment">//</span>
00390 
00391     <span class="keywordflow">if</span> ((ContextFrame-&gt;ContextFlags &amp; <a class="code" href="../../d6/d7/halmips_8h.html#a155">CONTEXT_INTEGER</a>) == <a class="code" href="../../d6/d7/halmips_8h.html#a155">CONTEXT_INTEGER</a>) {
00392 
00393         <span class="comment">//</span>
00394         <span class="comment">// Set integer registers edi, esi, ebx, edx, ecx, eax</span>
00395         <span class="comment">//</span>
00396 
00397         ContextFrame-&gt;Edi = TrapFrame-&gt;Edi;
00398         ContextFrame-&gt;Esi = TrapFrame-&gt;Esi;
00399         ContextFrame-&gt;Ebx = TrapFrame-&gt;Ebx;
00400         ContextFrame-&gt;Ecx = TrapFrame-&gt;Ecx;
00401         ContextFrame-&gt;Edx = TrapFrame-&gt;Edx;
00402         ContextFrame-&gt;Eax = TrapFrame-&gt;Eax;
00403     }
00404 
00405     <span class="keywordflow">if</span> (((ContextFrame-&gt;ContextFlags &amp; CONTEXT_EXTENDED_REGISTERS) ==
00406         CONTEXT_EXTENDED_REGISTERS) &amp;&amp;
00407         ((TrapFrame-&gt;SegCs &amp; MODE_MASK) == <a class="code" href="../../d0/d9/ntosdef_8h.html#a76a70">UserMode</a>)) {
00408 
00409         <span class="comment">//</span>
00410         <span class="comment">// This is the base TrapFrame, and the NpxFrame is on the base</span>
00411         <span class="comment">// of the kernel stack, just above it in memory.</span>
00412         <span class="comment">//</span>
00413 
00414         NpxFrame = (PFX_SAVE_AREA)(TrapFrame + 1);
00415 
00416         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d3/i386_8h.html#a23">KeI386NpxPresent</a>) {
00417             KiFlushNPXState (<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00418             RtlCopyMemory( (PVOID)&amp;(ContextFrame-&gt;ExtendedRegisters[0]),
00419                            (PVOID)&amp;(NpxFrame-&gt;U.FxArea),                    
00420                            MAXIMUM_SUPPORTED_EXTENSION
00421                          );
00422         }
00423     }
00424 
00425     <span class="comment">//</span>
00426     <span class="comment">// Fetch floating register contents if requested, and type of target</span>
00427     <span class="comment">// is user.  (system frames have no fp state, so ignore request)</span>
00428     <span class="comment">//</span>
00429     <span class="keywordflow">if</span> ( ((ContextFrame-&gt;ContextFlags &amp; <a class="code" href="../../d6/d7/halmips_8h.html#a154">CONTEXT_FLOATING_POINT</a>) ==
00430           <a class="code" href="../../d6/d7/halmips_8h.html#a154">CONTEXT_FLOATING_POINT</a>) &amp;&amp;
00431          ((TrapFrame-&gt;SegCs &amp; MODE_MASK) == <a class="code" href="../../d0/d9/ntosdef_8h.html#a76a70">UserMode</a>)) {
00432 
00433         <span class="comment">//</span>
00434         <span class="comment">// This is the base TrapFrame, and the NpxFrame is on the base</span>
00435         <span class="comment">// of the kernel stack, just above it in memory.</span>
00436         <span class="comment">//</span>
00437 
00438         NpxFrame = (PFX_SAVE_AREA)(TrapFrame + 1);
00439 
00440         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d3/i386_8h.html#a23">KeI386NpxPresent</a>) {
00441 
00442             <span class="comment">//</span>
00443             <span class="comment">// Force the coprocessors state to the save area and copy it</span>
00444             <span class="comment">// to the context frame.</span>
00445             <span class="comment">//</span>
00446 
00447             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d3/i386_8h.html#a24">KeI386FxsrPresent</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00448 
00449                 <span class="comment">//</span>
00450                 <span class="comment">// FP state save was done using fxsave. Get the save</span>
00451                 <span class="comment">// area in fnsave format</span>
00452                 <span class="comment">//</span>
00453                 <span class="comment">// Save area must be 16 byte aligned so we cushion it with</span>
00454                 <span class="comment">// 15 bytes (in the locals declaration above) and round</span>
00455                 <span class="comment">// down to align.</span>
00456                 <span class="comment">//</span>
00457 
00458                 ULONG_PTR Temp;
00459                 Temp = (ULONG_PTR)&amp;FloatSaveBuffer.SaveArea;
00460                 Temp &amp;= ~0xf;
00461                 PSaveArea = (PFLOATING_SAVE_AREA)Temp;
00462                 KiFlushNPXState (PSaveArea);
00463             } <span class="keywordflow">else</span> {
00464 
00465                 PSaveArea = (PFLOATING_SAVE_AREA)&amp;(NpxFrame-&gt;U.FnArea);
00466                 KiFlushNPXState (<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00467 
00468             }
00469 
00470             ContextFrame-&gt;FloatSave.ControlWord   = PSaveArea-&gt;ControlWord;
00471             ContextFrame-&gt;FloatSave.StatusWord    = PSaveArea-&gt;StatusWord;
00472             ContextFrame-&gt;FloatSave.TagWord       = PSaveArea-&gt;TagWord;
00473             ContextFrame-&gt;FloatSave.ErrorOffset   = PSaveArea-&gt;ErrorOffset;
00474             ContextFrame-&gt;FloatSave.ErrorSelector = PSaveArea-&gt;ErrorSelector;
00475             ContextFrame-&gt;FloatSave.DataOffset    = PSaveArea-&gt;DataOffset;
00476             ContextFrame-&gt;FloatSave.DataSelector  = PSaveArea-&gt;DataSelector;
00477             ContextFrame-&gt;FloatSave.Cr0NpxState   = NpxFrame-&gt;Cr0NpxState;
00478 
00479             <span class="keywordflow">for</span> (i = 0; i &lt; SIZE_OF_80387_REGISTERS; i++) {
00480                 ContextFrame-&gt;FloatSave.RegisterArea[i] = PSaveArea-&gt;RegisterArea[i];
00481             }
00482 
00483         } <span class="keywordflow">else</span> {
00484 
00485             <span class="comment">//</span>
00486             <span class="comment">// The 80387 is being emulated by the R3 emulator.</span>
00487             <span class="comment">// ** The only time the Npx state is ever obtained or set is</span>
00488             <span class="comment">// ** for userlevel handling.  Current Irql must be 0 or 1.</span>
00489             <span class="comment">// Go slurp the emulator's R3 data and generate the</span>
00490             <span class="comment">// floating point context</span>
00491             <span class="comment">//</span>
00492 
00493             StateSaved = <a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a11">KiEm87StateToNpxFrame</a>(&amp;ContextFrame-&gt;FloatSave);
00494             <span class="keywordflow">if</span> (StateSaved) {
00495                 ContextFrame-&gt;FloatSave.Cr0NpxState = NpxFrame-&gt;Cr0NpxState;
00496             } <span class="keywordflow">else</span> {
00497 
00498                 <span class="comment">//</span>
00499                 <span class="comment">// The floatingpoint state can not be determined.</span>
00500                 <span class="comment">// Remove the floatingpoint flag from the context frame flags.</span>
00501                 <span class="comment">//</span>
00502 
00503                 ContextFrame-&gt;ContextFlags &amp;= (~<a class="code" href="../../d6/d7/halmips_8h.html#a154">CONTEXT_FLOATING_POINT</a>) | CONTEXT_i386;
00504             }
00505         }
00506     }
00507 
00508     <span class="comment">//</span>
00509     <span class="comment">// Fetch Dr register contents if requested.  Values may be trash.</span>
00510     <span class="comment">//</span>
00511 
00512     <span class="keywordflow">if</span> ((ContextFrame-&gt;ContextFlags &amp; CONTEXT_DEBUG_REGISTERS) ==
00513         CONTEXT_DEBUG_REGISTERS) {
00514 
00515         ContextFrame-&gt;Dr0 = TrapFrame-&gt;Dr0;
00516         ContextFrame-&gt;Dr1 = TrapFrame-&gt;Dr1;
00517         ContextFrame-&gt;Dr2 = TrapFrame-&gt;Dr2;
00518         ContextFrame-&gt;Dr3 = TrapFrame-&gt;Dr3;
00519         ContextFrame-&gt;Dr6 = TrapFrame-&gt;Dr6;
00520 
00521         <span class="comment">//</span>
00522         <span class="comment">// If it's a user mode frame, and the thread doesn't have DRs set,</span>
00523         <span class="comment">// and we just return the trash in the frame, we risk accidentally</span>
00524         <span class="comment">// making the thread active with trash values on a set.  Therefore,</span>
00525         <span class="comment">// Dr7 must be set to 0 if we get a non-active user mode frame.</span>
00526         <span class="comment">//</span>
00527 
00528         <span class="keywordflow">if</span> ((((TrapFrame-&gt;SegCs &amp; MODE_MASK) != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) ||
00529             ((TrapFrame-&gt;EFlags &amp; EFLAGS_V86_MASK) != 0)) &amp;&amp;
00530             (<a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>()-&gt;DebugActive == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>)) {
00531 
00532             ContextFrame-&gt;Dr7 = TrapFrame-&gt;Dr7;
00533 
00534         } <span class="keywordflow">else</span> {
00535 
00536             ContextFrame-&gt;Dr7 = 0<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>;
00537 
00538         }
00539     }
00540 
00541 }
00542 
00543 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00544"></a><a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a18">00544</a> <a class="code" href="../../d2/d9/ppc_2exceptn_8c.html#a10">KeContextToKframes</a> (
00545     IN OUT PKTRAP_FRAME TrapFrame,
00546     IN OUT PKEXCEPTION_FRAME ExceptionFrame,
00547     IN PCONTEXT ContextFrame,
00548     IN ULONG ContextFlags,
00549     IN KPROCESSOR_MODE PreviousMode
00550     )
00551 
00552 <span class="comment">/*++</span>
00553 <span class="comment"></span>
00554 <span class="comment">Routine Description:</span>
00555 <span class="comment"></span>
00556 <span class="comment">    This routine moves the selected contents of the specified context frame into</span>
00557 <span class="comment">    the specified trap and exception frames according to the specified context</span>
00558 <span class="comment">    flags.</span>
00559 <span class="comment"></span>
00560 <span class="comment">Arguments:</span>
00561 <span class="comment"></span>
00562 <span class="comment">    TrapFrame - Supplies a pointer to a trap frame that receives the volatile</span>
00563 <span class="comment">        context from the context record.</span>
00564 <span class="comment"></span>
00565 <span class="comment">    ExceptionFrame - Supplies a pointer to an exception frame that receives</span>
00566 <span class="comment">        the nonvolatile context from the context record. This argument is</span>
00567 <span class="comment">        ignored since there is no exception frame on NT386.</span>
00568 <span class="comment"></span>
00569 <span class="comment">    ContextFrame - Supplies a pointer to a context frame that contains the</span>
00570 <span class="comment">        context that is to be copied into the trap and exception frames.</span>
00571 <span class="comment"></span>
00572 <span class="comment">    ContextFlags - Supplies the set of flags that specify which parts of the</span>
00573 <span class="comment">        context frame are to be copied into the trap and exception frames.</span>
00574 <span class="comment"></span>
00575 <span class="comment">    PreviousMode - Supplies the processor mode for which the trap and exception</span>
00576 <span class="comment">        frames are being built.</span>
00577 <span class="comment"></span>
00578 <span class="comment">Return Value:</span>
00579 <span class="comment"></span>
00580 <span class="comment">    None.</span>
00581 <span class="comment"></span>
00582 <span class="comment">--*/</span>
00583 
00584 {
00585 
00586     PFX_SAVE_AREA     NpxFrame;
00587     ULONG i;
00588     ULONG j;
00589     ULONG TagWord;
00590     BOOLEAN StateSaved;
00591     BOOLEAN ModeChanged;
00592 <span class="preprocessor">#if DBG</span>
00593 <span class="preprocessor"></span>    PKPCR   Pcr;
00594     KIRQL   OldIrql;
00595 <span class="preprocessor">#endif</span>
00596 <span class="preprocessor"></span>
00597     UNREFERENCED_PARAMETER( ExceptionFrame );
00598 
00599     <span class="comment">//</span>
00600     <span class="comment">// Set control information if specified.</span>
00601     <span class="comment">//</span>
00602 
00603     <span class="keywordflow">if</span> ((ContextFlags &amp; <a class="code" href="../../d6/d7/halmips_8h.html#a153">CONTEXT_CONTROL</a>) == <a class="code" href="../../d6/d7/halmips_8h.html#a153">CONTEXT_CONTROL</a>) {
00604 
00605         <span class="keywordflow">if</span> ((ContextFrame-&gt;EFlags &amp; EFLAGS_V86_MASK) !=
00606             (TrapFrame-&gt;EFlags &amp; EFLAGS_V86_MASK)) {
00607             ModeChanged = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00608         } <span class="keywordflow">else</span> {
00609             ModeChanged = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00610         }
00611 
00612 
00613         <span class="comment">//</span>
00614         <span class="comment">// Set registers eflag, ebp, eip, cs, esp and ss.</span>
00615         <span class="comment">// Eflags is set first, so that the auxilliary routines</span>
00616         <span class="comment">// can check the v86 bit to determine as well as cs, to</span>
00617         <span class="comment">// determine if the frame is kernel or user mode. (v86 mode cs</span>
00618         <span class="comment">// can have any value)</span>
00619         <span class="comment">//</span>
00620 
00621         TrapFrame-&gt;EFlags = SANITIZE_FLAGS(ContextFrame-&gt;EFlags, PreviousMode);
00622         TrapFrame-&gt;Ebp = ContextFrame-&gt;Ebp;
00623         TrapFrame-&gt;Eip = ContextFrame-&gt;Eip;
00624         <span class="keywordflow">if</span> (TrapFrame-&gt;EFlags &amp; EFLAGS_V86_MASK) {
00625             TrapFrame-&gt;SegCs = ContextFrame-&gt;SegCs;
00626         } <span class="keywordflow">else</span> {
00627             TrapFrame-&gt;SegCs = SANITIZE_SEG(ContextFrame-&gt;SegCs, PreviousMode);
00628             <span class="keywordflow">if</span> (PreviousMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a> &amp;&amp; TrapFrame-&gt;SegCs &lt; 8) {
00629 
00630                 <span class="comment">//</span>
00631                 <span class="comment">// If user mode and the selector value is less than 8, we</span>
00632                 <span class="comment">// know it is an invalid selector.  Set it to flat user</span>
00633                 <span class="comment">// mode selector.  Another reason we need to check for this</span>
00634                 <span class="comment">// is that any cs value less than 8 causes our exit kernel</span>
00635                 <span class="comment">// macro to treat its exit trap fram as an edited frame.</span>
00636                 <span class="comment">//</span>
00637 
00638                 TrapFrame-&gt;SegCs = KGDT_R3_CODE | RPL_MASK;
00639             }
00640         }
00641         <a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a16">KiSegSsToTrapFrame</a>(TrapFrame, ContextFrame-&gt;SegSs);
00642         <a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a14">KiEspToTrapFrame</a>(TrapFrame, ContextFrame-&gt;Esp);
00643         <span class="keywordflow">if</span> (ModeChanged) {
00644             <a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a10">Ki386AdjustEsp0</a>(TrapFrame);             <span class="comment">// realign esp0 in the tss</span>
00645         }
00646     }
00647 
00648     <span class="comment">//</span>
00649     <span class="comment">// Set segment register contents if specified.</span>
00650     <span class="comment">//</span>
00651 
00652     <span class="keywordflow">if</span> ((ContextFlags &amp; CONTEXT_SEGMENTS) == CONTEXT_SEGMENTS) {
00653 
00654         <span class="comment">//</span>
00655         <span class="comment">// Set segment registers gs, fs, es, ds.</span>
00656         <span class="comment">//</span>
00657 
00658         <span class="comment">//</span>
00659         <span class="comment">// There's only one legal value for DS and ES, so simply set it.</span>
00660         <span class="comment">// This allows KeContextFromKframes to report the real values in</span>
00661         <span class="comment">// the frame. (which are junk most of the time, but sometimes useful</span>
00662         <span class="comment">// for debugging.)</span>
00663         <span class="comment">// Only 2 legal values for FS, let either one be set.</span>
00664         <span class="comment">// Force GS to be 0 to deal with entry via SysCall and exit</span>
00665         <span class="comment">// via exception.</span>
00666         <span class="comment">//</span>
00667         <span class="comment">// For V86 mode, the FS, GS, DS, and ES registers must be properly</span>
00668         <span class="comment">// set from the supplied context.</span>
00669         <span class="comment">//</span>
00670 
00671         <span class="keywordflow">if</span> (TrapFrame-&gt;EFlags &amp; EFLAGS_V86_MASK) {
00672             TrapFrame-&gt;V86Fs = ContextFrame-&gt;SegFs;
00673             TrapFrame-&gt;V86Es = ContextFrame-&gt;SegEs;
00674             TrapFrame-&gt;V86Ds = ContextFrame-&gt;SegDs;
00675             TrapFrame-&gt;V86Gs = ContextFrame-&gt;SegGs;
00676         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (((TrapFrame-&gt;SegCs &amp; MODE_MASK) == <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>)) {
00677 
00678             <span class="comment">//</span>
00679             <span class="comment">// set up the standard selectors</span>
00680             <span class="comment">//</span>
00681 
00682             TrapFrame-&gt;SegFs = SANITIZE_SEG(ContextFrame-&gt;SegFs, PreviousMode);
00683             TrapFrame-&gt;SegEs = KGDT_R3_DATA | RPL_MASK;
00684             TrapFrame-&gt;SegDs = KGDT_R3_DATA | RPL_MASK;
00685             TrapFrame-&gt;SegGs = 0;
00686         } <span class="keywordflow">else</span> {
00687 
00688             <span class="comment">//</span>
00689             <span class="comment">// If user mode, we simply return whatever left in context frame</span>
00690             <span class="comment">// and let trap 0d handle it (if later we trap while popping the</span>
00691             <span class="comment">// trap frame.) V86 mode also get handled here.</span>
00692             <span class="comment">//</span>
00693 
00694             TrapFrame-&gt;SegFs = ContextFrame-&gt;SegFs;
00695             TrapFrame-&gt;SegEs = ContextFrame-&gt;SegEs;
00696             TrapFrame-&gt;SegDs = ContextFrame-&gt;SegDs;
00697             <span class="keywordflow">if</span> (TrapFrame-&gt;SegCs == (KGDT_R3_CODE | RPL_MASK)) {
00698                 TrapFrame-&gt;SegGs = 0;
00699             } <span class="keywordflow">else</span> {
00700                 TrapFrame-&gt;SegGs = ContextFrame-&gt;SegGs;
00701             }
00702         }
00703     }
00704     <span class="comment">//</span>
00705     <span class="comment">// Set integer registers contents if specified.</span>
00706     <span class="comment">//</span>
00707 
00708     <span class="keywordflow">if</span> ((ContextFlags &amp; <a class="code" href="../../d6/d7/halmips_8h.html#a155">CONTEXT_INTEGER</a>) == <a class="code" href="../../d6/d7/halmips_8h.html#a155">CONTEXT_INTEGER</a>) {
00709 
00710         <span class="comment">//</span>
00711         <span class="comment">// Set integer registers edi, esi, ebx, edx, ecx, eax.</span>
00712         <span class="comment">//</span>
00713         <span class="comment">//  Can NOT call RtlMoveMemory here because the regs aren't</span>
00714         <span class="comment">//  contiguous in pusha frame, and we don't want to export</span>
00715         <span class="comment">//  bits of junk into context record.</span>
00716         <span class="comment">//</span>
00717 
00718         TrapFrame-&gt;Edi = ContextFrame-&gt;Edi;
00719         TrapFrame-&gt;Esi = ContextFrame-&gt;Esi;
00720         TrapFrame-&gt;Ebx = ContextFrame-&gt;Ebx;
00721         TrapFrame-&gt;Ecx = ContextFrame-&gt;Ecx;
00722         TrapFrame-&gt;Edx = ContextFrame-&gt;Edx;
00723         TrapFrame-&gt;Eax = ContextFrame-&gt;Eax;
00724 
00725     }
00726 
00727     <span class="comment">//</span>
00728     <span class="comment">// Set extended register contents if requested, and type of target</span>
00729     <span class="comment">// is user.  (system frames have no extended state, so ignore request)</span>
00730     <span class="comment">//</span>
00731 
00732     <span class="keywordflow">if</span> (((ContextFlags &amp; CONTEXT_EXTENDED_REGISTERS) == CONTEXT_EXTENDED_REGISTERS) &amp;&amp;
00733         ((TrapFrame-&gt;SegCs &amp; MODE_MASK) == <a class="code" href="../../d0/d9/ntosdef_8h.html#a76a70">UserMode</a>)) {
00734 
00735         <span class="comment">//</span>
00736         <span class="comment">// This is the base TrapFrame, and the NpxFrame is on the base</span>
00737         <span class="comment">// of the kernel stack, just above it in memory.</span>
00738         <span class="comment">//</span>
00739 
00740         NpxFrame = (PFX_SAVE_AREA)(TrapFrame + 1);
00741 
00742         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d3/i386_8h.html#a23">KeI386NpxPresent</a>) {
00743             KiFlushNPXState (<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00744             RtlCopyMemory( (PVOID)&amp;(NpxFrame-&gt;U.FxArea),
00745                       (PVOID)&amp;(ContextFrame-&gt;ExtendedRegisters[0]),
00746                            MAXIMUM_SUPPORTED_EXTENSION
00747                          );
00748             <span class="comment">//</span>
00749             <span class="comment">// Make sure only valid floating state bits are moved to Cr0NpxState.</span>
00750             <span class="comment">//</span>
00751 
00752             NpxFrame-&gt;Cr0NpxState &amp;= ~(CR0_EM | CR0_MP | CR0_TS);
00753 
00754             <span class="comment">//</span>
00755             <span class="comment">// Make sure all reserved bits are clear in MXCSR so we don't get a GP</span>
00756             <span class="comment">// fault when doing an FRSTOR on this state.</span>
00757             <span class="comment">//</span>
00758             NpxFrame-&gt;U.FxArea.MXCsr = SANITIZE_MXCSR(NpxFrame-&gt;U.FxArea.MXCsr);
00759 
00760             <span class="comment">//</span>
00761             <span class="comment">// Only let VDMs turn on the EM bit.  The kernel can't do</span>
00762             <span class="comment">// anything for FLAT apps</span>
00763             <span class="comment">//</span>
00764             <span class="keywordflow">if</span> (<a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>()-&gt;ApcState.Process-&gt;VdmFlag &amp; 0xf) {
00765                 NpxFrame-&gt;Cr0NpxState |= ContextFrame-&gt;FloatSave.Cr0NpxState &amp;
00766                                       (CR0_EM | CR0_MP);
00767             }
00768         }
00769     }
00770 
00771     <span class="comment">//</span>
00772     <span class="comment">// Set floating register contents if requested, and type of target</span>
00773     <span class="comment">// is user.  (system frames have no fp state, so ignore request)</span>
00774     <span class="comment">//</span>
00775 
00776     <span class="keywordflow">if</span> (((ContextFlags &amp; <a class="code" href="../../d6/d7/halmips_8h.html#a154">CONTEXT_FLOATING_POINT</a>) == <a class="code" href="../../d6/d7/halmips_8h.html#a154">CONTEXT_FLOATING_POINT</a>) &amp;&amp;
00777         ((TrapFrame-&gt;SegCs &amp; MODE_MASK) == <a class="code" href="../../d0/d9/ntosdef_8h.html#a76a70">UserMode</a>)) {
00778 
00779         <span class="comment">//</span>
00780         <span class="comment">// This is the base TrapFrame, and the NpxFrame is on the base</span>
00781         <span class="comment">// of the kernel stack, just above it in memory.</span>
00782         <span class="comment">//</span>
00783 
00784         NpxFrame = (PFX_SAVE_AREA)(TrapFrame + 1);
00785 
00786         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d3/i386_8h.html#a23">KeI386NpxPresent</a>) {
00787 
00788             <span class="comment">//</span>
00789             <span class="comment">// Set coprocessor stack, control and status registers</span>
00790             <span class="comment">//</span>
00791 
00792             KiFlushNPXState (<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00793 
00794             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d3/i386_8h.html#a24">KeI386FxsrPresent</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00795 
00796                 <span class="comment">//</span>
00797                 <span class="comment">// Restore FP state in the fxrstor format</span>
00798                 <span class="comment">//</span>
00799 
00800                 NpxFrame-&gt;U.FxArea.ControlWord   =
00801                                     (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)ContextFrame-&gt;FloatSave.ControlWord;
00802                 NpxFrame-&gt;U.FxArea.StatusWord    =
00803                                     (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)ContextFrame-&gt;FloatSave.StatusWord;
00804 
00805                 <span class="comment">//</span>
00806                 <span class="comment">// Construct the tag word from fnsave format to fxsave format</span>
00807                 <span class="comment">//</span>
00808 
00809                 NpxFrame-&gt;U.FxArea.TagWord = 0; <span class="comment">// Mark every register invalid</span>
00810 
00811                 TagWord = ContextFrame-&gt;FloatSave.TagWord;
00812 
00813                 <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a0">FN_BITS_PER_TAGWORD</a>; i+=2) {
00814 
00815                     <span class="keywordflow">if</span> (((TagWord &gt;&gt; i) &amp; <a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a2">FN_TAG_MASK</a>) != <a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a1">FN_TAG_EMPTY</a>) {
00816 
00817                         <span class="comment">//</span>
00818                         <span class="comment">// This register is valid</span>
00819                         <span class="comment">//</span>
00820 
00821                         NpxFrame-&gt;U.FxArea.TagWord |= (<a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a3">FX_TAG_VALID</a> &lt;&lt; (i/2));
00822                     }
00823                 }
00824 
00825                 NpxFrame-&gt;U.FxArea.ErrorOffset   =
00826                                         ContextFrame-&gt;FloatSave.ErrorOffset;
00827                 NpxFrame-&gt;U.FxArea.ErrorSelector =
00828                                (ContextFrame-&gt;FloatSave.ErrorSelector &amp; 0xFFFF);
00829                 NpxFrame-&gt;U.FxArea.ErrorOpcode =
00830                     (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)((ContextFrame-&gt;FloatSave.ErrorSelector &gt;&gt; 16) &amp; 0xFFFF);
00831                 NpxFrame-&gt;U.FxArea.DataOffset    =
00832                                 ContextFrame-&gt;FloatSave.DataOffset;
00833                 NpxFrame-&gt;U.FxArea.DataSelector  =
00834                                 ContextFrame-&gt;FloatSave.DataSelector;
00835 
00836                 <span class="comment">//</span>
00837                 <span class="comment">// Fxrstor format has each FP register in 128 bits (16 bytes)</span>
00838                 <span class="comment">// where as fnsave saves each FP register in 80 bits (10 bytes)</span>
00839                 <span class="comment">//</span>
00840                 RtlZeroMemory ((PVOID)&amp;NpxFrame-&gt;U.FxArea.RegisterArea[0],
00841                                SIZE_OF_FX_REGISTERS
00842                               );
00843 
00844                 <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a4">NUMBER_OF_FP_REGISTERS</a>; i++) {
00845                     <span class="keywordflow">for</span> (j = 0; j &lt; <a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a5">BYTES_PER_FP_REGISTER</a>; j++) {
00846                         NpxFrame-&gt;U.FxArea.RegisterArea[i*<a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a6">BYTES_PER_FX_REGISTER</a>+j] =
00847                                 ContextFrame-&gt;FloatSave.RegisterArea[i*<a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a5">BYTES_PER_FP_REGISTER</a>+j];
00848                     }
00849                 }
00850 
00851             } <span class="keywordflow">else</span> {
00852                 NpxFrame-&gt;U.FnArea.ControlWord   =
00853                                         ContextFrame-&gt;FloatSave.ControlWord;
00854                 NpxFrame-&gt;U.FnArea.StatusWord    =
00855                                         ContextFrame-&gt;FloatSave.StatusWord;
00856                 NpxFrame-&gt;U.FnArea.TagWord       =
00857                                         ContextFrame-&gt;FloatSave.TagWord;
00858                 NpxFrame-&gt;U.FnArea.ErrorOffset   =
00859                                         ContextFrame-&gt;FloatSave.ErrorOffset;
00860                 NpxFrame-&gt;U.FnArea.ErrorSelector =
00861                                         ContextFrame-&gt;FloatSave.ErrorSelector;
00862                 NpxFrame-&gt;U.FnArea.DataOffset    =
00863                                         ContextFrame-&gt;FloatSave.DataOffset;
00864                 NpxFrame-&gt;U.FnArea.DataSelector  =
00865                                         ContextFrame-&gt;FloatSave.DataSelector;
00866 
00867                 <span class="keywordflow">for</span> (i = 0; i &lt; SIZE_OF_80387_REGISTERS; i++) {
00868                     NpxFrame-&gt;U.FnArea.RegisterArea[i] =
00869                             ContextFrame-&gt;FloatSave.RegisterArea[i];
00870                 }
00871 
00872             }
00873 
00874             <span class="comment">//</span>
00875             <span class="comment">// Make sure only valid floating state bits are moved to Cr0NpxState.</span>
00876             <span class="comment">//</span>
00877 
00878             NpxFrame-&gt;Cr0NpxState &amp;= ~(CR0_EM | CR0_MP | CR0_TS);
00879 
00880             <span class="comment">//</span>
00881             <span class="comment">// Only let VDMs turn on the EM bit.  The kernel can't do</span>
00882             <span class="comment">// anything for FLAT apps</span>
00883             <span class="comment">//</span>
00884             <span class="keywordflow">if</span> (<a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>()-&gt;ApcState.Process-&gt;VdmFlag &amp; 0xf) {
00885                 NpxFrame-&gt;Cr0NpxState |= ContextFrame-&gt;FloatSave.Cr0NpxState &amp;
00886                                       (CR0_EM | CR0_MP);
00887             }
00888 
00889         } <span class="keywordflow">else</span> {
00890 
00891             <span class="keywordflow">if</span> (<a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>()-&gt;ApcState.Process-&gt;VdmFlag &amp; 0xf) {
00892 
00893                 <span class="comment">//</span>
00894                 <span class="comment">// This is a special hack to allow SetContext for VDMs to</span>
00895                 <span class="comment">// turn on/off it's CR0_EM bit.</span>
00896                 <span class="comment">//</span>
00897 
00898                 NpxFrame-&gt;Cr0NpxState &amp;= ~(CR0_MP | CR0_TS | CR0_EM | CR0_PE);
00899                 NpxFrame-&gt;Cr0NpxState |=
00900                     <a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a7">VdmUserCr0MapIn</a>[ContextFrame-&gt;FloatSave.Cr0NpxState &amp; (CR0_EM | CR0_MP)];
00901 
00902             } <span class="keywordflow">else</span> {
00903 
00904                 <span class="comment">//</span>
00905                 <span class="comment">// The 80387 is being emulated by the R3 emulator.</span>
00906                 <span class="comment">// ** The only time the Npx state is ever obtained or set is</span>
00907                 <span class="comment">// ** for userlevel handling.  Current Irql must be 0 or 1.</span>
00908                 <span class="comment">// And the context being set must be for the current thread.</span>
00909                 <span class="comment">// Go smash the floatingpoint context into the R3 emulator's</span>
00910                 <span class="comment">// data area.</span>
00911                 <span class="comment">//</span>
00912 <span class="preprocessor">#if DBG</span>
00913 <span class="preprocessor"></span>                OldIrql = KeRaiseIrqlToSynchLevel();
00914                 Pcr = <a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a1">KeGetPcr</a>();
00915                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pcr-&gt;Prcb-&gt;CurrentThread-&gt;Teb == Pcr-&gt;NtTib.Self);
00916                 <a class="code" href="../../d9/d5/verifier_8c.html#a117">KeLowerIrql</a> (OldIrql);
00917 <span class="preprocessor">#endif</span>
00918 <span class="preprocessor"></span>
00919                 StateSaved = <a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a12">KiNpxFrameToEm87State</a>(&amp;ContextFrame-&gt;FloatSave);
00920                 <span class="keywordflow">if</span> (StateSaved) {
00921 
00922                     <span class="comment">//</span>
00923                     <span class="comment">// Make sure only valid floating state bits are moved to</span>
00924                     <span class="comment">// Cr0NpxState.  Since we are emulating, don't allow</span>
00925                     <span class="comment">// resetting CR0_EM.</span>
00926                     <span class="comment">//</span>
00927 
00928                     NpxFrame-&gt;Cr0NpxState &amp;= ~(CR0_MP | CR0_TS);
00929                     NpxFrame-&gt;Cr0NpxState |=
00930                         ContextFrame-&gt;FloatSave.Cr0NpxState &amp; CR0_MP;
00931                 }
00932             }
00933         }
00934     }
00935 
00936     <span class="comment">//</span>
00937     <span class="comment">// Set debug register state if specified.  If previous mode is user</span>
00938     <span class="comment">// mode (i.e. it's a user frame we're setting) and if effect will be to</span>
00939     <span class="comment">// cause at least one of the LE (local enable) bits in Dr7 to be</span>
00940     <span class="comment">// set (i.e. at least one of Dr0,1,2,3 are active) then set DebugActive</span>
00941     <span class="comment">// in the thread object to true.  Otherwise set it to false.</span>
00942     <span class="comment">//</span>
00943 
00944     <span class="keywordflow">if</span> ((ContextFlags &amp; CONTEXT_DEBUG_REGISTERS) == CONTEXT_DEBUG_REGISTERS) {
00945 
00946         TrapFrame-&gt;Dr0 = SANITIZE_DRADDR(ContextFrame-&gt;Dr0, PreviousMode);
00947         TrapFrame-&gt;Dr1 = SANITIZE_DRADDR(ContextFrame-&gt;Dr1, PreviousMode);
00948         TrapFrame-&gt;Dr2 = SANITIZE_DRADDR(ContextFrame-&gt;Dr2, PreviousMode);
00949         TrapFrame-&gt;Dr3 = SANITIZE_DRADDR(ContextFrame-&gt;Dr3, PreviousMode);
00950         TrapFrame-&gt;Dr6 = SANITIZE_DR6(ContextFrame-&gt;Dr6, PreviousMode);
00951         TrapFrame-&gt;Dr7 = SANITIZE_DR7(ContextFrame-&gt;Dr7, PreviousMode);
00952 
00953         <span class="keywordflow">if</span> (PreviousMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
00954             <a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a1">KeGetPcr</a>()-&gt;DebugActive = <a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>()-&gt;DebugActive =
00955                 (BOOLEAN)((ContextFrame-&gt;Dr7 &amp; DR7_ACTIVE) != 0);
00956         }
00957     }
00958 
00959     <span class="comment">//</span>
00960     <span class="comment">// If thread is supposed to have IOPL, then force it on in eflags</span>
00961     <span class="comment">//</span>
00962     <span class="keywordflow">if</span> (<a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>()-&gt;Iopl) {
00963         TrapFrame-&gt;EFlags |= (EFLAGS_IOPL_MASK &amp; -1);  <span class="comment">// IOPL = 3</span>
00964     }
00965 
00966     <span class="keywordflow">return</span>;
00967 }
00968 
00969 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00970"></a><a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a19">00970</a> <a class="code" href="../../d2/d9/ppc_2exceptn_8c.html#a11">KiDispatchException</a> (
00971     IN PEXCEPTION_RECORD ExceptionRecord,
00972     IN PKEXCEPTION_FRAME ExceptionFrame,
00973     IN PKTRAP_FRAME TrapFrame,
00974     IN KPROCESSOR_MODE PreviousMode,
00975     IN BOOLEAN FirstChance
00976     )
00977 
00978 <span class="comment">/*++</span>
00979 <span class="comment"></span>
00980 <span class="comment">Routine Description:</span>
00981 <span class="comment"></span>
00982 <span class="comment">    This function is called to dispatch an exception to the proper mode and</span>
00983 <span class="comment">    to cause the exception dispatcher to be called. If the previous mode is</span>
00984 <span class="comment">    kernel, then the exception dispatcher is called directly to process the</span>
00985 <span class="comment">    exception. Otherwise the exception record, exception frame, and trap</span>
00986 <span class="comment">    frame contents are copied to the user mode stack. The contents of the</span>
00987 <span class="comment">    exception frame and trap are then modified such that when control is</span>
00988 <span class="comment">    returned, execution will commense in user mode in a routine which will</span>
00989 <span class="comment">    call the exception dispatcher.</span>
00990 <span class="comment"></span>
00991 <span class="comment">Arguments:</span>
00992 <span class="comment"></span>
00993 <span class="comment">    ExceptionRecord - Supplies a pointer to an exception record.</span>
00994 <span class="comment"></span>
00995 <span class="comment">    ExceptionFrame - Supplies a pointer to an exception frame. For NT386,</span>
00996 <span class="comment">        this should be NULL.</span>
00997 <span class="comment"></span>
00998 <span class="comment">    TrapFrame - Supplies a pointer to a trap frame.</span>
00999 <span class="comment"></span>
01000 <span class="comment">    PreviousMode - Supplies the previous processor mode.</span>
01001 <span class="comment"></span>
01002 <span class="comment">    FirstChance - Supplies a boolean value that specifies whether this is</span>
01003 <span class="comment">        the first (TRUE) or second (FALSE) chance for the exception.</span>
01004 <span class="comment"></span>
01005 <span class="comment">Return Value:</span>
01006 <span class="comment"></span>
01007 <span class="comment">    None.</span>
01008 <span class="comment"></span>
01009 <span class="comment">--*/</span>
01010 
01011 {
01012     CONTEXT ContextFrame;
01013     EXCEPTION_RECORD ExceptionRecord1, ExceptionRecord2;
01014     LONG Length;
01015     ULONG UserStack1;
01016     ULONG UserStack2;
01017 
01018     <span class="comment">//</span>
01019     <span class="comment">// Move machine state from trap and exception frames to a context frame,</span>
01020     <span class="comment">// and increment the number of exceptions dispatched.</span>
01021     <span class="comment">//</span>
01022 
01023     <a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a2">KeGetCurrentPrcb</a>()-&gt;KeExceptionDispatchCount += 1;
01024     ContextFrame.ContextFlags = <a class="code" href="../../d6/d7/halmips_8h.html#a152">CONTEXT_FULL</a> | CONTEXT_DEBUG_REGISTERS;
01025     <span class="keywordflow">if</span> (PreviousMode == <a class="code" href="../../d0/d9/ntosdef_8h.html#a76a70">UserMode</a>) {
01026         <span class="comment">//</span>
01027         <span class="comment">// For usermode exceptions always try to dispatch the floating</span>
01028         <span class="comment">// point state.  This allows expection handlers &amp; debuggers to</span>
01029         <span class="comment">// examine/edit the npx context if required.  Plus it allows</span>
01030         <span class="comment">// exception handlers to use fp instructions without detroying</span>
01031         <span class="comment">// the npx state at the time of the exception.</span>
01032         <span class="comment">//</span>
01033         <span class="comment">// Note: If there's no 80387, ContextTo/FromKFrames will use the</span>
01034         <span class="comment">// emulator's current state.  If the emulator can not give the</span>
01035         <span class="comment">// current state, then the context_floating_point bit will be</span>
01036         <span class="comment">// turned off by ContextFromKFrames.</span>
01037         <span class="comment">//</span>
01038 
01039         ContextFrame.ContextFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a154">CONTEXT_FLOATING_POINT</a>;
01040         <span class="keywordflow">if</span> (<a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a9">KeI386XMMIPresent</a>) {
01041             ContextFrame.ContextFlags |= CONTEXT_EXTENDED_REGISTERS;
01042         }
01043     }
01044 
01045     <a class="code" href="../../d2/d9/ppc_2exceptn_8c.html#a9">KeContextFromKframes</a>(TrapFrame, ExceptionFrame, &amp;ContextFrame);
01046 
01047     <span class="comment">//</span>
01048     <span class="comment">// if it is BREAK_POINT exception, we subtract 1 from EIP and report</span>
01049     <span class="comment">// the updated EIP to user.  This is because Cruiser requires EIP</span>
01050     <span class="comment">// points to the int 3 instruction (not the instruction following int 3).</span>
01051     <span class="comment">// In this case, BreakPoint exception is fatal. Otherwise we will step</span>
01052     <span class="comment">// on the int 3 over and over again, if user does not handle it</span>
01053     <span class="comment">//</span>
01054     <span class="comment">// if the BREAK_POINT occured in V86 mode, the debugger running in the</span>
01055     <span class="comment">// VDM will expect CS:EIP to point after the exception (the way the</span>
01056     <span class="comment">// processor left it.  this is also true for protected mode dos</span>
01057     <span class="comment">// app debuggers.  We will need a way to detect this.</span>
01058     <span class="comment">//</span>
01059     <span class="comment">//</span>
01060 
01061 <span class="comment">//    if ((ExceptionRecord-&gt;ExceptionCode == STATUS_BREAKPOINT) &amp;&amp;</span>
01062 <span class="comment">//      !(ContextFrame.EFlags &amp; EFLAGS_V86_MASK)) {</span>
01063 
01064     <span class="keywordflow">switch</span> (ExceptionRecord-&gt;ExceptionCode) {
01065         <span class="keywordflow">case</span> STATUS_BREAKPOINT:
01066             ContextFrame.Eip--;
01067             <span class="keywordflow">break</span>;
01068     }
01069 
01070     <span class="comment">//</span>
01071     <span class="comment">// Select the method of handling the exception based on the previous mode.</span>
01072     <span class="comment">//</span>
01073 
01074     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((
01075              !((PreviousMode == <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) &amp;&amp;
01076              (ContextFrame.EFlags &amp; EFLAGS_V86_MASK))
01077            ));
01078 
01079     <span class="keywordflow">if</span> (PreviousMode == <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
01080 
01081         <span class="comment">//</span>
01082         <span class="comment">// Previous mode was kernel.</span>
01083         <span class="comment">//</span>
01084         <span class="comment">// If the kernel debugger is active, then give the kernel debugger the</span>
01085         <span class="comment">// first chance to handle the exception. If the kernel debugger handles</span>
01086         <span class="comment">// the exception, then continue execution. Else attempt to dispatch the</span>
01087         <span class="comment">// exception to a frame based handler. If a frame based handler handles</span>
01088         <span class="comment">// the exception, then continue execution.</span>
01089         <span class="comment">//</span>
01090         <span class="comment">// If a frame based handler does not handle the exception,</span>
01091         <span class="comment">// give the kernel debugger a second chance, if it's present.</span>
01092         <span class="comment">//</span>
01093         <span class="comment">// If the exception is still unhandled, call KeBugCheck().</span>
01094         <span class="comment">//</span>
01095 
01096         <span class="keywordflow">if</span> (FirstChance == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01097 
01098             <span class="keywordflow">if</span> ((<a class="code" href="../../d0/d7/kdp_8h.html#a24">KiDebugRoutine</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
01099                (((<a class="code" href="../../d0/d7/kdp_8h.html#a24">KiDebugRoutine</a>) (TrapFrame,
01100                                    ExceptionFrame,
01101                                    ExceptionRecord,
01102                                    &amp;ContextFrame,
01103                                    PreviousMode,
01104                                    <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
01105 
01106                 <span class="keywordflow">goto</span> Handled1;
01107             }
01108 
01109             <span class="comment">// Kernel debugger didn't handle exception.</span>
01110 
01111             <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a7">RtlDispatchException</a>(ExceptionRecord, &amp;ContextFrame) == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01112                 <span class="keywordflow">goto</span> Handled1;
01113             }
01114         }
01115 
01116         <span class="comment">//</span>
01117         <span class="comment">// This is the second chance to handle the exception.</span>
01118         <span class="comment">//</span>
01119 
01120         <span class="keywordflow">if</span> ((<a class="code" href="../../d0/d7/kdp_8h.html#a24">KiDebugRoutine</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
01121             (((<a class="code" href="../../d0/d7/kdp_8h.html#a24">KiDebugRoutine</a>) (TrapFrame,
01122                                 ExceptionFrame,
01123                                 ExceptionRecord,
01124                                 &amp;ContextFrame,
01125                                 PreviousMode,
01126                                 <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>)) != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
01127 
01128             <span class="keywordflow">goto</span> Handled1;
01129         }
01130 
01131         <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a>(
01132             <a class="code" href="../../d6/d7/halmips_8h.html#a13">KMODE_EXCEPTION_NOT_HANDLED</a>,
01133             ExceptionRecord-&gt;ExceptionCode,
01134             (ULONG)ExceptionRecord-&gt;ExceptionAddress,
01135             ExceptionRecord-&gt;ExceptionInformation[0],
01136             ExceptionRecord-&gt;ExceptionInformation[1]
01137             );
01138 
01139     } <span class="keywordflow">else</span> {
01140 
01141         <span class="comment">//</span>
01142         <span class="comment">// Previous mode was user.</span>
01143         <span class="comment">//</span>
01144         <span class="comment">// If this is the first chance and the current process has a debugger</span>
01145         <span class="comment">// port, then send a message to the debugger port and wait for a reply.</span>
01146         <span class="comment">// If the debugger handles the exception, then continue execution. Else</span>
01147         <span class="comment">// transfer the exception information to the user stack, transition to</span>
01148         <span class="comment">// user mode, and attempt to dispatch the exception to a frame based</span>
01149         <span class="comment">// handler. If a frame based handler handles the exception, then continue</span>
01150         <span class="comment">// execution with the continue system service. Else execute the</span>
01151         <span class="comment">// NtRaiseException system service with FirstChance == FALSE, which</span>
01152         <span class="comment">// will call this routine a second time to process the exception.</span>
01153         <span class="comment">//</span>
01154         <span class="comment">// If this is the second chance and the current process has a debugger</span>
01155         <span class="comment">// port, then send a message to the debugger port and wait for a reply.</span>
01156         <span class="comment">// If the debugger handles the exception, then continue execution. Else</span>
01157         <span class="comment">// if the current process has a subsystem port, then send a message to</span>
01158         <span class="comment">// the subsystem port and wait for a reply. If the subsystem handles the</span>
01159         <span class="comment">// exception, then continue execution. Else terminate the thread.</span>
01160         <span class="comment">//</span>
01161 
01162 
01163         <span class="keywordflow">if</span> (FirstChance == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01164 
01165             <span class="comment">//</span>
01166             <span class="comment">// This is the first chance to handle the exception.</span>
01167             <span class="comment">//</span>
01168 
01169             <span class="keywordflow">if</span> ( <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>()-&gt;DebugPort ) {
01170                 <span class="keywordflow">if</span> ( (<a class="code" href="../../d0/d7/kdp_8h.html#a24">KiDebugRoutine</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
01171                      <a class="code" href="../../d3/d9/4_2ia64_2kdtrap_8c.html#a1">KdIsThisAKdTrap</a>(ExceptionRecord, &amp;ContextFrame, <a class="code" href="../../d0/d9/ntosdef_8h.html#a76a70">UserMode</a>) ) {
01172 
01173                     <span class="keywordflow">if</span> ((((<a class="code" href="../../d0/d7/kdp_8h.html#a24">KiDebugRoutine</a>) (TrapFrame,
01174                                             ExceptionFrame,
01175                                             ExceptionRecord,
01176                                             &amp;ContextFrame,
01177                                             PreviousMode,
01178                                             <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
01179 
01180                         <span class="keywordflow">goto</span> Handled1;
01181                     }
01182                 }
01183             } <span class="keywordflow">else</span> {
01184                 <span class="keywordflow">if</span> ((<a class="code" href="../../d0/d7/kdp_8h.html#a24">KiDebugRoutine</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
01185                     (((<a class="code" href="../../d0/d7/kdp_8h.html#a24">KiDebugRoutine</a>) (TrapFrame,
01186                                         ExceptionFrame,
01187                                         ExceptionRecord,
01188                                         &amp;ContextFrame,
01189                                         PreviousMode,
01190                                         <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
01191 
01192                     <span class="keywordflow">goto</span> Handled1;
01193                 }
01194             }
01195 
01196             <span class="keywordflow">if</span> (<a class="code" href="../../d4/d3/dbgk_8h.html#a5">DbgkForwardException</a>(ExceptionRecord, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
01197                 <span class="keywordflow">goto</span> Handled2;
01198             }
01199 
01200             <span class="comment">//</span>
01201             <span class="comment">// Transfer exception information to the user stack, transition</span>
01202             <span class="comment">// to user mode, and attempt to dispatch the exception to a frame</span>
01203             <span class="comment">// based handler.</span>
01204 
01205         repeat:
01206             <span class="keywordflow">try</span> {
01207 
01208                 <span class="comment">//</span>
01209                 <span class="comment">// If the SS segment is not 32 bit flat, there is no point</span>
01210                 <span class="comment">// to dispatch exception to frame based exception handler.</span>
01211                 <span class="comment">//</span>
01212 
01213                 <span class="keywordflow">if</span> (TrapFrame-&gt;HardwareSegSs != (KGDT_R3_DATA | RPL_MASK) ||
01214                     TrapFrame-&gt;EFlags &amp; EFLAGS_V86_MASK ) {
01215                     ExceptionRecord2.ExceptionCode = STATUS_ACCESS_VIOLATION;
01216                     ExceptionRecord2.ExceptionFlags = 0;
01217                     ExceptionRecord2.NumberParameters = 0;
01218                     <a class="code" href="../../d5/d8/ex_8h.html#a302">ExRaiseException</a>(&amp;ExceptionRecord2);
01219                 }
01220 
01221                 <span class="comment">//</span>
01222                 <span class="comment">// Compute length of context record and new aligned user stack</span>
01223                 <span class="comment">// pointer.</span>
01224                 <span class="comment">//</span>
01225 
01226                 Length = (<span class="keyword">sizeof</span>(CONTEXT) + CONTEXT_ROUND) &amp; ~CONTEXT_ROUND;
01227                 UserStack1 = (ContextFrame.Esp &amp; ~CONTEXT_ROUND) - Length;
01228 
01229                 <span class="comment">//</span>
01230                 <span class="comment">// Probe user stack area for writeability and then transfer the</span>
01231                 <span class="comment">// context record to the user stack.</span>
01232                 <span class="comment">//</span>
01233 
01234                 <a class="code" href="../../d5/d8/ex_8h.html#a259">ProbeForWrite</a>((PCHAR)UserStack1, Length, CONTEXT_ALIGN);
01235                 RtlMoveMemory((PULONG)UserStack1, &amp;ContextFrame, <span class="keyword">sizeof</span>(CONTEXT));
01236 
01237                 <span class="comment">//</span>
01238                 <span class="comment">// Compute length of exception record and new aligned stack</span>
01239                 <span class="comment">// address.</span>
01240                 <span class="comment">//</span>
01241 
01242                 Length = (<span class="keyword">sizeof</span>(EXCEPTION_RECORD) - (EXCEPTION_MAXIMUM_PARAMETERS -
01243                          ExceptionRecord-&gt;NumberParameters) * <span class="keyword">sizeof</span>(ULONG) +3) &amp;
01244                          (~3);
01245                 UserStack2 = UserStack1 - Length;
01246 
01247                 <span class="comment">//</span>
01248                 <span class="comment">// Probe user stack area for writeability and then transfer the</span>
01249                 <span class="comment">// context record to the user stack area.</span>
01250                 <span class="comment">// N.B. The probing length is Length+8 because there are two</span>
01251                 <span class="comment">//      arguments need to be pushed to user stack later.</span>
01252                 <span class="comment">//</span>
01253 
01254                 <a class="code" href="../../d5/d8/ex_8h.html#a259">ProbeForWrite</a>((PCHAR)(UserStack2 - 8), Length + 8, <span class="keyword">sizeof</span>(ULONG));
01255                 RtlMoveMemory((PULONG)UserStack2, ExceptionRecord, Length);
01256 
01257                 <span class="comment">//</span>
01258                 <span class="comment">// Push address of exception record, context record to the</span>
01259                 <span class="comment">// user stack.  They are the two parameters required by</span>
01260                 <span class="comment">// _KiUserExceptionDispatch.</span>
01261                 <span class="comment">//</span>
01262 
01263                 *(PULONG)(UserStack2 - <span class="keyword">sizeof</span>(ULONG)) = UserStack1;
01264                 *(PULONG)(UserStack2 - 2*<span class="keyword">sizeof</span>(ULONG)) = UserStack2;
01265 
01266                 <span class="comment">//</span>
01267                 <span class="comment">// Set new stack pointer to the trap frame.</span>
01268                 <span class="comment">//</span>
01269 
01270                 <a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a16">KiSegSsToTrapFrame</a>(TrapFrame, KGDT_R3_DATA);
01271                 <a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a14">KiEspToTrapFrame</a>(TrapFrame, (UserStack2 - <span class="keyword">sizeof</span>(ULONG)*2));
01272 
01273                 <span class="comment">//</span>
01274                 <span class="comment">// Force correct R3 selectors into TrapFrame.</span>
01275                 <span class="comment">//</span>
01276 
01277                 TrapFrame-&gt;SegCs = SANITIZE_SEG(KGDT_R3_CODE, PreviousMode);
01278                 TrapFrame-&gt;SegDs = SANITIZE_SEG(KGDT_R3_DATA, PreviousMode);
01279                 TrapFrame-&gt;SegEs = SANITIZE_SEG(KGDT_R3_DATA, PreviousMode);
01280                 TrapFrame-&gt;SegFs = SANITIZE_SEG(KGDT_R3_TEB, PreviousMode);
01281                 TrapFrame-&gt;SegGs = 0;
01282 
01283                 <span class="comment">//</span>
01284                 <span class="comment">// Set the address of the exception routine that will call the</span>
01285                 <span class="comment">// exception dispatcher and then return to the trap handler.</span>
01286                 <span class="comment">// The trap handler will restore the exception and trap frame</span>
01287                 <span class="comment">// context and continue execution in the routine that will</span>
01288                 <span class="comment">// call the exception dispatcher.</span>
01289                 <span class="comment">//</span>
01290 
01291                 TrapFrame-&gt;Eip = (ULONG)<a class="code" href="../../d4/d9/ke_8h.html#a150">KeUserExceptionDispatcher</a>;
01292                 <span class="keywordflow">return</span>;
01293 
01294             } except (<a class="code" href="../../d2/d9/ppc_2exceptn_8c.html#a12">KiCopyInformation</a>(&amp;ExceptionRecord1,
01295                         (GetExceptionInformation())-&gt;ExceptionRecord)) {
01296 
01297                 <span class="comment">//</span>
01298                 <span class="comment">// If the exception is a stack overflow, then attempt</span>
01299                 <span class="comment">// to raise the stack overflow exception. Otherwise,</span>
01300                 <span class="comment">// the user's stack is not accessible, or is misaligned,</span>
01301                 <span class="comment">// and second chance processing is performed.</span>
01302                 <span class="comment">//</span>
01303 
01304                 <span class="keywordflow">if</span> (ExceptionRecord1.ExceptionCode == STATUS_STACK_OVERFLOW) {
01305                     ExceptionRecord1.ExceptionAddress = ExceptionRecord-&gt;ExceptionAddress;
01306                     RtlMoveMemory((PVOID)ExceptionRecord,
01307                                   &amp;ExceptionRecord1, <span class="keyword">sizeof</span>(EXCEPTION_RECORD));
01308                     <span class="keywordflow">goto</span> repeat;
01309                 }
01310             }
01311         }
01312 
01313         <span class="comment">//</span>
01314         <span class="comment">// This is the second chance to handle the exception.</span>
01315         <span class="comment">//</span>
01316 
01317         <span class="keywordflow">if</span> (<a class="code" href="../../d4/d3/dbgk_8h.html#a5">DbgkForwardException</a>(ExceptionRecord, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>)) {
01318             <span class="keywordflow">goto</span> Handled2;
01319         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d4/d3/dbgk_8h.html#a5">DbgkForwardException</a>(ExceptionRecord, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>)) {
01320             <span class="keywordflow">goto</span> Handled2;
01321         } <span class="keywordflow">else</span> {
01322             ZwTerminateThread(NtCurrentThread(), ExceptionRecord-&gt;ExceptionCode);
01323             <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a>(
01324                 <a class="code" href="../../d6/d7/halmips_8h.html#a13">KMODE_EXCEPTION_NOT_HANDLED</a>,
01325                 ExceptionRecord-&gt;ExceptionCode,
01326                 (ULONG)ExceptionRecord-&gt;ExceptionAddress,
01327                 ExceptionRecord-&gt;ExceptionInformation[0],
01328                 ExceptionRecord-&gt;ExceptionInformation[1]
01329                 );
01330         }
01331     }
01332 
01333     <span class="comment">//</span>
01334     <span class="comment">// Move machine state from context frame to trap and exception frames and</span>
01335     <span class="comment">// then return to continue execution with the restored state.</span>
01336     <span class="comment">//</span>
01337 
01338 Handled1:
01339     <a class="code" href="../../d2/d9/ppc_2exceptn_8c.html#a10">KeContextToKframes</a>(TrapFrame, ExceptionFrame, &amp;ContextFrame,
01340                        ContextFrame.ContextFlags, PreviousMode);
01341 
01342     <span class="comment">//</span>
01343     <span class="comment">// Exception was handled by the debugger or the associated subsystem</span>
01344     <span class="comment">// and state was modified, if necessary, using the get state and set</span>
01345     <span class="comment">// state capabilities. Therefore the context frame does not need to</span>
01346     <span class="comment">// be transfered to the trap and exception frames.</span>
01347     <span class="comment">//</span>
01348 
01349 Handled2:
01350     <span class="keywordflow">return</span>;
01351 }
01352 
01353 ULONG
<a name="l01354"></a><a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a20">01354</a> <a class="code" href="../../d2/d9/ppc_2exceptn_8c.html#a12">KiCopyInformation</a> (
01355     IN OUT PEXCEPTION_RECORD ExceptionRecord1,
01356     IN PEXCEPTION_RECORD ExceptionRecord2
01357     )
01358 
01359 <span class="comment">/*++</span>
01360 <span class="comment"></span>
01361 <span class="comment">Routine Description:</span>
01362 <span class="comment"></span>
01363 <span class="comment">    This function is called from an exception filter to copy the exception</span>
01364 <span class="comment">    information from one exception record to another when an exception occurs.</span>
01365 <span class="comment"></span>
01366 <span class="comment">Arguments:</span>
01367 <span class="comment"></span>
01368 <span class="comment">    ExceptionRecord1 - Supplies a pointer to the destination exception record.</span>
01369 <span class="comment"></span>
01370 <span class="comment">    ExceptionRecord2 - Supplies a pointer to the source exception record.</span>
01371 <span class="comment"></span>
01372 <span class="comment">Return Value:</span>
01373 <span class="comment"></span>
01374 <span class="comment">    A value of EXCEPTION_EXECUTE_HANDLER is returned as the function value.</span>
01375 <span class="comment"></span>
01376 <span class="comment">--*/</span>
01377 
01378 {
01379 
01380     <span class="comment">//</span>
01381     <span class="comment">// Copy one exception record to another and return value that causes</span>
01382     <span class="comment">// an exception handler to be executed.</span>
01383     <span class="comment">//</span>
01384 
01385     RtlMoveMemory((PVOID)ExceptionRecord1,
01386                   (PVOID)ExceptionRecord2,
01387                   <span class="keyword">sizeof</span>(EXCEPTION_RECORD));
01388 
01389     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>;
01390 }
01391 
01392 
01393 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01394"></a><a class="code" href="../../d9/d8/i386_2exceptn_8c.html#a21">01394</a> <a class="code" href="../../d2/d9/ppc_2exceptn_8c.html#a13">KeRaiseUserException</a>(
01395     IN NTSTATUS ExceptionCode
01396     )
01397 
01398 <span class="comment">/*++</span>
01399 <span class="comment"></span>
01400 <span class="comment">Routine Description:</span>
01401 <span class="comment"></span>
01402 <span class="comment">    This function causes an exception to be raised in the calling thread's user-mode</span>
01403 <span class="comment">    context. It does this by editing the trap frame the kernel was entered with to</span>
01404 <span class="comment">    point to trampoline code that raises the requested exception.</span>
01405 <span class="comment"></span>
01406 <span class="comment">Arguments:</span>
01407 <span class="comment"></span>
01408 <span class="comment">    ExceptionCode - Supplies the status value to be used as the exception</span>
01409 <span class="comment">        code for the exception that is to be raised.</span>
01410 <span class="comment"></span>
01411 <span class="comment">Return Value:</span>
01412 <span class="comment"></span>
01413 <span class="comment">    The status value that should be returned by the caller.</span>
01414 <span class="comment"></span>
01415 <span class="comment">--*/</span>
01416 
01417 {
01418     <a class="code" href="../../d1/d8/struct__KTHREAD.html">PKTHREAD</a> Thread;
01419     PKTRAP_FRAME TrapFrame;
01420     PTEB Teb;
01421     ULONG PreviousEip;
01422 
01423     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(KeGetPreviousMode() == <a class="code" href="../../d0/d9/ntosdef_8h.html#a76a70">UserMode</a>);
01424 
01425     Thread = <a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>();
01426     TrapFrame = Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o48">TrapFrame</a>;
01427     Teb = (PTEB)Thread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o4">Teb</a>;
01428 
01429     <span class="comment">//</span>
01430     <span class="comment">// In order to create the correct call stack, we return the previous</span>
01431     <span class="comment">// EIP as the status code. The usermode trampoline code will push this</span>
01432     <span class="comment">// onto the stack for use as the return address. The status code to</span>
01433     <span class="comment">// be raised is passed in the TEB.</span>
01434     <span class="comment">//</span>
01435 
01436     <span class="keywordflow">try</span> {
01437         Teb-&gt;ExceptionCode = ExceptionCode;
01438     } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
01439         <span class="keywordflow">return</span>(ExceptionCode);
01440     }
01441 
01442     PreviousEip = TrapFrame-&gt;Eip;
01443     TrapFrame-&gt;Eip = (ULONG)<a class="code" href="../../d4/d9/ke_8h.html#a151">KeRaiseUserExceptionDispatcher</a>;
01444 
01445     <span class="keywordflow">return</span>((<a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>)PreviousEip);
01446 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:39:57 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
