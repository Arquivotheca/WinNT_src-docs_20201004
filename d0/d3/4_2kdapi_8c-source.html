<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: kdapi.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>kdapi.c</h1><a href="../../d9/d3/4_2kdapi_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1990  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    kdapi.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    Implementation of Kernel Debugger portable remote APIs.</span>
00012 <span class="comment"></span>
00013 <span class="comment">Author:</span>
00014 <span class="comment"></span>
00015 <span class="comment">    Mark Lucovsky (markl) 31-Aug-1990</span>
00016 <span class="comment"></span>
00017 <span class="comment">Revision History:</span>
00018 <span class="comment"></span>
00019 <span class="comment">    John Vert (jvert) 28-May-1991</span>
00020 <span class="comment"></span>
00021 <span class="comment">        Added APIs for reading and writing physical memory</span>
00022 <span class="comment">        (KdpReadPhysicalMemory and KdpWritePhysicalMemory)</span>
00023 <span class="comment"></span>
00024 <span class="comment">    Wesley Witt (wesw) 18-Aug-1993</span>
00025 <span class="comment"></span>
00026 <span class="comment">        Added KdpGetVersion, KdpWriteBreakPointEx, &amp; KdpRestoreBreakPointEx</span>
00027 <span class="comment"></span>
00028 <span class="comment"></span>
00029 <span class="comment">--*/</span>
00030 
00031 <span class="preprocessor">#include "<a class="code" href="../../d1/d7/4_2kdp_8h.html">kdp.h</a>"</span>
00032 
00033 <span class="preprocessor">#if ACCASM &amp;&amp; !defined(_MSC_VER)</span>
00034 <span class="preprocessor"></span><span class="keywordtype">long</span> <span class="keyword">asm</span>(<span class="keyword">const</span> <span class="keywordtype">char</span> *,...);
00035 <span class="preprocessor">#pragma intrinsic(asm)</span>
00036 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00037 <span class="preprocessor"></span>
00038 LARGE_INTEGER <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a5">KdpQueryPerformanceCounter</a> (
00039     IN PKTRAP_FRAME TrapFrame
00040     );
00041 
<a name="l00042"></a><a class="code" href="../../d9/d3/4_2kdapi_8c.html#a2">00042</a> <span class="keyword">extern</span> LARGE_INTEGER <a class="code" href="../../d8/d3/kdapi_8c.html#a2">Magic10000</a>;
<a name="l00043"></a><a class="code" href="../../d9/d3/4_2kdapi_8c.html#a0">00043</a> <span class="preprocessor">#define SHIFT10000   13</span>
<a name="l00044"></a><a class="code" href="../../d9/d3/4_2kdapi_8c.html#a1">00044</a> <span class="preprocessor"></span><span class="preprocessor">#define Convert100nsToMilliseconds(LARGE_INTEGER) (                         \</span>
00045 <span class="preprocessor">    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic10000, SHIFT10000 )       \</span>
00046 <span class="preprocessor">    )</span>
00047 <span class="preprocessor"></span>
00048 <span class="comment">//</span>
00049 <span class="comment">// Define forward referenced function prototypes.</span>
00050 <span class="comment">//</span>
00051 
00052 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00053 <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a6">KdpProcessInternalBreakpoint</a> (
00054     ULONG BreakpointNumber
00055     );
00056 
00057 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00058 <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a7">KdpGetVersion</a>(
00059     IN PDBGKD_MANIPULATE_STATE64 m
00060     );
00061 
00062 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00063 <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a8">KdpNotSupported</a>(
00064     IN PDBGKD_MANIPULATE_STATE64 m
00065     );
00066 
00067 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00068 <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a9">KdpCauseBugCheck</a>(
00069     IN PDBGKD_MANIPULATE_STATE64 m
00070     );
00071 
00072 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00073 <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a10">KdpWriteBreakPointEx</a>(
00074     IN PDBGKD_MANIPULATE_STATE64 m,
00075     IN PSTRING AdditionalData,
00076     IN PCONTEXT Context
00077     );
00078 
00079 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00080 <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a11">KdpRestoreBreakPointEx</a>(
00081     IN PDBGKD_MANIPULATE_STATE64 m,
00082     IN PSTRING AdditionalData,
00083     IN PCONTEXT Context
00084     );
00085 
00086 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00087 <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a12">KdpSearchMemory</a>(
00088     IN PDBGKD_MANIPULATE_STATE64 m,
00089     IN PSTRING AdditionalData,
00090     IN PCONTEXT Context
00091     );
00092 
00093 ULONG
00094 <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a13">KdpSearchHammingDistance</a> (
00095     ULONG_PTR Left,
00096     ULONG_PTR Right
00097     );
00098 
00099 LOGICAL
00100 <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a14">KdpSearchPhysicalPage</a> (
00101     IN PFN_NUMBER PageFrameIndex,
00102     ULONG_PTR RangeStart,
00103     ULONG_PTR RangeEnd,
00104     ULONG Flags
00105     );
00106 
00107 LOGICAL
00108 <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a15">KdpSearchPhysicalMemoryRequested</a> (
00109     VOID
00110     );
00111 
00112 LOGICAL
00113 <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a16">KdpSearchPhysicalPageRange</a> (
00114     VOID
00115     );
00116 
00117 
00118 <span class="preprocessor">#if i386</span>
00119 <span class="preprocessor"></span><a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00120 InternalBreakpointCheck (
00121     <a class="code" href="../../d1/d6/struct__KDPC.html">PKDPC</a> Dpc,
00122     PVOID DeferredContext,
00123     PVOID SystemArgument1,
00124     PVOID SystemArgument2
00125     );
00126 
00127 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00128 KdGetInternalBreakpoint(
00129     IN PDBGKD_MANIPULATE_STATE64 m
00130     );
00131 
00132 <span class="keywordtype">long</span>
00133 SymNumFor(
00134     ULONG_PTR pc
00135     );
00136 
00137 <span class="keywordtype">void</span> PotentialNewSymbol (ULONG_PTR pc);
00138 
00139 <span class="keywordtype">void</span> DumpTraceData(PSTRING MessageData);
00140 
00141 BOOLEAN
00142 TraceDataRecordCallInfo(
00143     ULONG InstructionsTraced,
00144     LONG CallLevelChange,
00145     ULONG_PTR pc
00146     );
00147 
00148 BOOLEAN
00149 SkippingWhichBP (
00150     PVOID thread,
00151     PULONG BPNum
00152     );
00153 
00154 BOOLEAN
00155 <a class="code" href="../../d2/d9/4_2i386_2kdtrap_8c.html#a3">KdpCheckTracePoint</a>(
00156     IN PEXCEPTION_RECORD ExceptionRecord,
00157     IN OUT PCONTEXT ContextRecord
00158     );
00159 
00160 ULONG_PTR
00161 <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a8">KdpGetReturnAddress</a>(
00162     IN PCONTEXT ContextRecord
00163     );
00164 
00165 ULONG_PTR
00166 <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a9">KdpGetCallNextOffset</a> (
00167     ULONG_PTR Pc,
00168     IN PCONTEXT ContextRecord
00169     );
00170 
00171 LONG
00172 <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a5">KdpLevelChange</a> (
00173     ULONG_PTR Pc,
00174     PCONTEXT ContextRecord,
00175     IN OUT PBOOLEAN SpecialCall
00176     );
00177 
00178 <span class="preprocessor">#endif // i386</span>
00179 <span class="preprocessor"></span>
00180 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00181 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdEnterDebugger)</span>
00182 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdExitDebugger)</span>
00183 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpTimeSlipDpcRoutine)</span>
00184 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpTimeSlipWork)</span>
00185 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpSendWaitContinue)</span>
00186 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpReadVirtualMemory)</span>
00187 <span class="preprocessor"></span><span class="comment">//#pragma alloc_text(PAGEKD, KdpReadVirtualMemory64)</span>
00188 <span class="preprocessor">#pragma alloc_text(PAGEKD, KdpWriteVirtualMemory)</span>
00189 <span class="preprocessor"></span><span class="comment">//#pragma alloc_text(PAGEKD, KdpWriteVirtualMemory64)</span>
00190 <span class="preprocessor">#pragma alloc_text(PAGEKD, KdpGetContext)</span>
00191 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpSetContext)</span>
00192 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpWriteBreakpoint)</span>
00193 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpRestoreBreakpoint)</span>
00194 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpReportExceptionStateChange)</span>
00195 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpReportLoadSymbolsStateChange)</span>
00196 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpReadPhysicalMemory)</span>
00197 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpWritePhysicalMemory)</span>
00198 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpGetVersion)</span>
00199 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpNotSupported)</span>
00200 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpCauseBugCheck)</span>
00201 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpWriteBreakPointEx)</span>
00202 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpRestoreBreakPointEx)</span>
00203 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpSearchMemory)</span>
00204 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpSearchHammingDistance)</span>
00205 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpSearchPhysicalPage)</span>
00206 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpSearchPhysicalMemoryRequested)</span>
00207 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpSearchPhysicalPageRange)</span>
00208 <span class="preprocessor"></span><span class="preprocessor">#if DBG</span>
00209 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpDprintf)</span>
00210 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00211 <span class="preprocessor"></span><span class="preprocessor">#if i386</span>
00212 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, InternalBreakpointCheck)</span>
00213 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdSetInternalBreakpoint)</span>
00214 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdGetTraceInformation)</span>
00215 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdGetInternalBreakpoint)</span>
00216 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, SymNumFor)</span>
00217 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, PotentialNewSymbol)</span>
00218 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, DumpTraceData)</span>
00219 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, TraceDataRecordCallInfo)</span>
00220 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, SkippingWhichBP)</span>
00221 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdQuerySpecialCalls)</span>
00222 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdSetSpecialCall)</span>
00223 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdClearSpecialCalls)</span>
00224 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpCheckTracePoint)</span>
00225 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpProcessInternalBreakpoint)</span>
00226 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpCheckLowMemory)</span>
00227 <span class="preprocessor"></span><span class="preprocessor">#endif // i386</span>
00228 <span class="preprocessor"></span><span class="preprocessor">#endif // ALLOC_PRAGMA</span>
00229 <span class="preprocessor"></span>
00230 
00231 <span class="comment">//</span>
00232 <span class="comment">// This variable has a count for each time KdDisableDebugger has been called.</span>
00233 <span class="comment">//</span>
<a name="l00234"></a><a class="code" href="../../d9/d3/4_2kdapi_8c.html#a3">00234</a> LONG <a class="code" href="../../d8/d3/kdapi_8c.html#a3">KdDisableCount</a> = 0 ;
<a name="l00235"></a><a class="code" href="../../d9/d3/4_2kdapi_8c.html#a4">00235</a> BOOLEAN <a class="code" href="../../d8/d3/kdapi_8c.html#a4">KdPreviouslyEnabled</a> ;
00236 
00237 
00238 <span class="preprocessor">#if DBG</span>
00239 <span class="preprocessor"></span><a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00240 KdpDprintf(
00241     IN PCHAR f,
00242     ...
00243     )
00244 <span class="comment">/*++</span>
00245 <span class="comment"></span>
00246 <span class="comment">Routine Description:</span>
00247 <span class="comment"></span>
00248 <span class="comment">    Printf routine for the debugger that is safer than DbgPrint.  Calls</span>
00249 <span class="comment">    the packet driver instead of reentering the debugger.</span>
00250 <span class="comment"></span>
00251 <span class="comment">Arguments:</span>
00252 <span class="comment"></span>
00253 <span class="comment">    f - Supplies printf format</span>
00254 <span class="comment"></span>
00255 <span class="comment">Return Value:</span>
00256 <span class="comment"></span>
00257 <span class="comment">    None</span>
00258 <span class="comment"></span>
00259 <span class="comment">--*/</span>
00260 {
00261     <span class="keywordtype">char</span>    buf[100];
00262     STRING  Output;
00263     va_list mark;
00264 
00265     va_start(mark, f);
00266     _vsnprintf(buf, 100, f, mark);
00267     va_end(mark);
00268 
00269     Output.Buffer = buf;
00270     Output.Length = <a class="code" href="../../d2/d7/regtest_8c.html#a2">strlen</a>(Output.Buffer);
00271     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a102">KdpPrintString</a>(&amp;Output);
00272 }
00273 <span class="preprocessor">#endif // DBG</span>
00274 <span class="preprocessor"></span>
00275 
00276 BOOLEAN
<a name="l00277"></a><a class="code" href="../../d9/d3/4_2kdapi_8c.html#a17">00277</a> <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a17">KdEnterDebugger</a>(
00278     IN PKTRAP_FRAME TrapFrame,
00279     IN PKEXCEPTION_FRAME ExceptionFrame
00280     )
00281 
00282 <span class="comment">/*++</span>
00283 <span class="comment"></span>
00284 <span class="comment">Routine Description:</span>
00285 <span class="comment"></span>
00286 <span class="comment">    This function is used to enter the kernel debugger. Its purpose</span>
00287 <span class="comment">    is to freeze all other processors and aqcuire the kernel debugger</span>
00288 <span class="comment">    comm port.</span>
00289 <span class="comment"></span>
00290 <span class="comment">Arguments:</span>
00291 <span class="comment"></span>
00292 <span class="comment">    TrapFrame - Supplies a pointer to a trap frame that describes the</span>
00293 <span class="comment">        trap.</span>
00294 <span class="comment"></span>
00295 <span class="comment">    ExceptionFrame - Supplies a pointer to an exception frame that</span>
00296 <span class="comment">        describes the trap.</span>
00297 <span class="comment"></span>
00298 <span class="comment">Return Value:</span>
00299 <span class="comment"></span>
00300 <span class="comment">    Returns the previous interrupt enable.</span>
00301 <span class="comment"></span>
00302 <span class="comment">--*/</span>
00303 
00304 {
00305 
00306     BOOLEAN Enable;
00307     TIME_FIELDS <a class="code" href="../../d6/d6/ttime_8c.html#a13">TimeFields</a>;
00308 <span class="preprocessor">#if DBG</span>
00309 <span class="preprocessor"></span>    <span class="keyword">extern</span> ULONG <a class="code" href="../../d5/d9/kernldat_8c.html#a43">KiFreezeFlag</a>;
00310 <span class="preprocessor">#endif</span>
00311 <span class="preprocessor"></span>
00312     <span class="comment">//</span>
00313     <span class="comment">// HACKHACK - do some crude timer support</span>
00314     <span class="comment">//            but not if called from KdSetOwedBreakpoints()</span>
00315     <span class="comment">//</span>
00316 
00317     <span class="keywordflow">if</span> (TrapFrame) {
00318         <a class="code" href="../../d8/d5/kddata_8c.html#a57">KdTimerStop</a> = <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a5">KdpQueryPerformanceCounter</a> (TrapFrame);
00319         <a class="code" href="../../d8/d5/kddata_8c.html#a58">KdTimerDifference</a>.QuadPart = <a class="code" href="../../d8/d5/kddata_8c.html#a57">KdTimerStop</a>.QuadPart - <a class="code" href="../../d8/d5/kddata_8c.html#a56">KdTimerStart</a>.QuadPart;
00320     } <span class="keywordflow">else</span> {
00321         <a class="code" href="../../d8/d5/kddata_8c.html#a57">KdTimerStop</a>.QuadPart = 0;
00322     }
00323 
00324     <span class="comment">//</span>
00325     <span class="comment">// Freeze all other processors, raise IRQL to HIGH_LEVEL, and save debug</span>
00326     <span class="comment">// port state.  We lock the port so that KdPollBreakin and a debugger</span>
00327     <span class="comment">// operation don't interfere with each other.</span>
00328     <span class="comment">//</span>
00329 
00330     Enable = <a class="code" href="../../d9/d4/ke_2debug_8c.html#a9">KeFreezeExecution</a>(TrapFrame, ExceptionFrame);
00331     <a class="code" href="../../d8/d5/kddata_8c.html#a68">KdpPortLocked</a> = <a class="code" href="../../d0/d0/ki_8h.html#a155">KiTryToAcquireSpinLock</a>(&amp;<a class="code" href="../../d4/d4/alpha_2splocks_8c.html#a9">KdpDebuggerLock</a>);
00332     <a class="code" href="../../d2/d7/hal_8h.html#a204">KdPortSave</a>();
00333     <a class="code" href="../../d8/d5/kddata_8c.html#a109">KdEnteredDebugger</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00334 
00335 <span class="preprocessor">#if DBG</span>
00336 <span class="preprocessor"></span>
00337     <span class="keywordflow">if</span> ((<a class="code" href="../../d5/d9/kernldat_8c.html#a43">KiFreezeFlag</a> &amp; <a class="code" href="../../d7/d3/kd_8h.html#a3">FREEZE_BACKUP</a>) != 0) {
00338         <a class="code" href="../../d0/d7/kdp_8h.html#a16">DPRINT</a>((<span class="stringliteral">"FreezeLock was jammed!  Backup SpinLock was used!\n"</span>));
00339     }
00340 
00341     <span class="keywordflow">if</span> ((<a class="code" href="../../d5/d9/kernldat_8c.html#a43">KiFreezeFlag</a> &amp; <a class="code" href="../../d7/d3/kd_8h.html#a4">FREEZE_SKIPPED_PROCESSOR</a>) != 0) {
00342         <a class="code" href="../../d0/d7/kdp_8h.html#a16">DPRINT</a>((<span class="stringliteral">"Some processors not frozen in debugger!\n"</span>));
00343     }
00344 
00345     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a68">KdpPortLocked</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00346         <a class="code" href="../../d0/d7/kdp_8h.html#a16">DPRINT</a>((<span class="stringliteral">"Port lock was not acquired!\n"</span>));
00347     }
00348 
00349 <span class="preprocessor">#endif</span>
00350 <span class="preprocessor"></span>
00351     <span class="keywordflow">return</span> Enable;
00352 }
00353 
00354 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00355"></a><a class="code" href="../../d9/d3/4_2kdapi_8c.html#a18">00355</a> <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a18">KdExitDebugger</a>(
00356     IN BOOLEAN Enable
00357     )
00358 
00359 <span class="comment">/*++</span>
00360 <span class="comment"></span>
00361 <span class="comment">Routine Description:</span>
00362 <span class="comment"></span>
00363 <span class="comment">    This function is used to exit the kernel debugger. It is the reverse</span>
00364 <span class="comment">    of KdEnterDebugger.</span>
00365 <span class="comment"></span>
00366 <span class="comment">Arguments:</span>
00367 <span class="comment"></span>
00368 <span class="comment">    Enable - Supplies the previous interrupt enable which is to be restored.</span>
00369 <span class="comment"></span>
00370 <span class="comment">Return Value:</span>
00371 <span class="comment"></span>
00372 <span class="comment">    None.</span>
00373 <span class="comment"></span>
00374 <span class="comment">--*/</span>
00375 
00376 {
00377     ULONG ElapsedTime;
00378     ULARGE_INTEGER TimeDifference;
00379     TIME_FIELDS <a class="code" href="../../d6/d6/ttime_8c.html#a13">TimeFields</a>;
00380     ULONG Pending;
00381 
00382     <span class="comment">//</span>
00383     <span class="comment">// restore stuff and exit</span>
00384     <span class="comment">//</span>
00385 
00386     <a class="code" href="../../d2/d7/hal_8h.html#a203">KdPortRestore</a>();
00387     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a68">KdpPortLocked</a>) {
00388         <a class="code" href="../../d1/d7/4_2kdp_8h.html#a146">KdpPortUnlock</a>();
00389     }
00390 
00391     <a class="code" href="../../d9/d4/ke_2debug_8c.html#a12">KeThawExecution</a>(Enable);
00392 
00393     <span class="comment">//</span>
00394     <span class="comment">// Do some crude timer support.  If KdEnterDebugger didn't</span>
00395     <span class="comment">// Query the performance counter, then don't do it here either.</span>
00396     <span class="comment">//</span>
00397 
00398     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a57">KdTimerStop</a>.QuadPart == 0) {
00399         <a class="code" href="../../d8/d5/kddata_8c.html#a56">KdTimerStart</a> = <a class="code" href="../../d8/d5/kddata_8c.html#a57">KdTimerStop</a>;
00400     } <span class="keywordflow">else</span> {
00401         <a class="code" href="../../d8/d5/kddata_8c.html#a56">KdTimerStart</a> = <a class="code" href="../../d2/d7/hal_8h.html#a205">KeQueryPerformanceCounter</a>(<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00402     }
00403 
00404     <span class="comment">//</span>
00405     <span class="comment">// Process a time slip</span>
00406     <span class="comment">//</span>
00407 
00408     <span class="keywordflow">if</span> (!<a class="code" href="../../d1/d2/po_8h.html#a55">PoHiberInProgress</a>) {
00409 
00410         Pending = InterlockedIncrement(&amp;<a class="code" href="../../d8/d5/kddata_8c.html#a103">KdpTimeSlipPending</a>);
00411 
00412         <span class="comment">//</span>
00413         <span class="comment">// If there's wasn't a time slip pending, queue the DPC to handle it</span>
00414         <span class="comment">//</span>
00415 
00416         <span class="keywordflow">if</span> (Pending == 1) {
00417             InterlockedIncrement(&amp;<a class="code" href="../../d8/d5/kddata_8c.html#a103">KdpTimeSlipPending</a>);
00418             <a class="code" href="../../d4/d1/dpcobj_8c.html#a2">KeInsertQueueDpc</a>(&amp;<a class="code" href="../../d8/d5/kddata_8c.html#a100">KdpTimeSlipDpc</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00419         }
00420     }
00421 
00422     <span class="keywordflow">return</span>;
00423 }
00424 
00425 
00426 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00427"></a><a class="code" href="../../d9/d3/4_2kdapi_8c.html#a19">00427</a> <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a19">KdUpdateTimeSlipEvent</a>(
00428     PVOID Event
00429     )
00430 
00431 <span class="comment">/*++</span>
00432 <span class="comment"></span>
00433 <span class="comment">Routine Description:</span>
00434 <span class="comment"></span>
00435 <span class="comment">    Update the reference to an event object which will be signalled when</span>
00436 <span class="comment">    the debugger has caused the system clock to skew.</span>
00437 <span class="comment"></span>
00438 <span class="comment">Arguments:</span>
00439 <span class="comment"></span>
00440 <span class="comment">    Event - Supplies a pointer to an event object</span>
00441 <span class="comment"></span>
00442 <span class="comment">Return Value:</span>
00443 <span class="comment"></span>
00444 <span class="comment">    None</span>
00445 <span class="comment"></span>
00446 <span class="comment">--*/</span>
00447 
00448 {
00449     KIRQL OldIrql;
00450 
00451     <a class="code" href="../../d4/d9/ke_8h.html#a37">KeAcquireSpinLock</a>(&amp;<a class="code" href="../../d8/d5/kddata_8c.html#a98">KdpTimeSlipEventLock</a>, &amp;OldIrql);
00452 
00453     <span class="comment">//</span>
00454     <span class="comment">// Dereference the old event and forget about it.</span>
00455     <span class="comment">// Remember the new event if there is one.</span>
00456     <span class="comment">//</span>
00457 
00458     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a99">KdpTimeSlipEvent</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00459         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>(<a class="code" href="../../d8/d5/kddata_8c.html#a99">KdpTimeSlipEvent</a>);
00460     }
00461 
00462     <a class="code" href="../../d8/d5/kddata_8c.html#a99">KdpTimeSlipEvent</a> = <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>;
00463 
00464     <a class="code" href="../../d9/d5/verifier_8c.html#a119">KeReleaseSpinLock</a>(&amp;<a class="code" href="../../d8/d5/kddata_8c.html#a98">KdpTimeSlipEventLock</a>, OldIrql);
00465 }
00466 
00467 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00468"></a><a class="code" href="../../d9/d3/4_2kdapi_8c.html#a20">00468</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a141">KdpTimeSlipDpcRoutine</a> (
00469     <a class="code" href="../../d1/d6/struct__KDPC.html">PKDPC</a> Dpc,
00470     PVOID DeferredContext,
00471     PVOID SystemArgument1,
00472     PVOID SystemArgument2
00473     )
00474 {
00475     LONG OldCount, NewCount, j;
00476 
00477     <span class="comment">//</span>
00478     <span class="comment">// Reset pending count.  If the current count is 1, then clear</span>
00479     <span class="comment">// the pending count.  if the current count is greater then 1,</span>
00480     <span class="comment">// then set to one and update the time now.</span>
00481     <span class="comment">//</span>
00482 
00483     j = <a class="code" href="../../d8/d5/kddata_8c.html#a103">KdpTimeSlipPending</a>;
00484     <span class="keywordflow">do</span> {
00485         OldCount = j;
00486         NewCount = OldCount &gt; 1 ? 1 : 0;
00487 
00488         j = InterlockedCompareExchange(&amp;<a class="code" href="../../d8/d5/kddata_8c.html#a103">KdpTimeSlipPending</a>, NewCount, OldCount);
00489 
00490     } <span class="keywordflow">while</span> (j != OldCount);
00491 
00492     <span class="comment">//</span>
00493     <span class="comment">// If new count is non-zero, then process a time slip now</span>
00494     <span class="comment">//</span>
00495 
00496     <span class="keywordflow">if</span> (NewCount) {
00497         <a class="code" href="../../d5/d8/ex_8h.html#a261">ExQueueWorkItem</a>(&amp;<a class="code" href="../../d8/d5/kddata_8c.html#a101">KdpTimeSlipWorkItem</a>, <a class="code" href="../../d5/d8/ex_8h.html#a332a206">DelayedWorkQueue</a>);
00498     }
00499 }
00500 
00501 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00502"></a><a class="code" href="../../d9/d3/4_2kdapi_8c.html#a21">00502</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a142">KdpTimeSlipWork</a> (
00503     IN PVOID Context
00504     )
00505 {
00506     KIRQL               OldIrql;
00507     LARGE_INTEGER       DueTime;
00508 
00509     <span class="comment">//</span>
00510     <span class="comment">// Update time from the real time clock</span>
00511     <span class="comment">//</span>
00512 
00513     <a class="code" href="../../d5/d8/ex_8h.html#a312">ExAcquireTimeRefreshLock</a>();
00514     <a class="code" href="../../d5/d8/ex_8h.html#a314">ExUpdateSystemTimeFromCmos</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, 0);
00515     <a class="code" href="../../d5/d8/ex_8h.html#a313">ExReleaseTimeRefreshLock</a>();
00516 
00517     <span class="comment">//</span>
00518     <span class="comment">// If there's a time service installed, signal it's time slip event</span>
00519     <span class="comment">//</span>
00520 
00521     <a class="code" href="../../d4/d9/ke_8h.html#a37">KeAcquireSpinLock</a>(&amp;<a class="code" href="../../d8/d5/kddata_8c.html#a98">KdpTimeSlipEventLock</a>, &amp;OldIrql);
00522     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a99">KdpTimeSlipEvent</a>) {
00523         <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a> (<a class="code" href="../../d8/d5/kddata_8c.html#a99">KdpTimeSlipEvent</a>, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00524     }
00525     <a class="code" href="../../d9/d5/verifier_8c.html#a119">KeReleaseSpinLock</a>(&amp;<a class="code" href="../../d8/d5/kddata_8c.html#a98">KdpTimeSlipEventLock</a>, OldIrql);
00526 
00527     <span class="comment">//</span>
00528     <span class="comment">// Insert a forced delay between time slip operations</span>
00529     <span class="comment">//</span>
00530 
00531     DueTime.QuadPart = -1800000000;
00532     <a class="code" href="../../d3/d2/timerobj_8c.html#a6">KeSetTimer</a> (&amp;<a class="code" href="../../d8/d5/kddata_8c.html#a102">KdpTimeSlipTimer</a>, DueTime, &amp;<a class="code" href="../../d8/d5/kddata_8c.html#a100">KdpTimeSlipDpc</a>);
00533 }
00534 
00535 <span class="preprocessor">#if i386</span>
00536 <span class="preprocessor"></span><a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00537 InternalBreakpointCheck (
00538     <a class="code" href="../../d1/d6/struct__KDPC.html">PKDPC</a> Dpc,
00539     PVOID DeferredContext,
00540     PVOID SystemArgument1,
00541     PVOID SystemArgument2
00542     )
00543 {
00544     LARGE_INTEGER dueTime;
00545     ULONG i;
00546 
00547     UNREFERENCED_PARAMETER(Dpc);
00548     UNREFERENCED_PARAMETER(DeferredContext);
00549     UNREFERENCED_PARAMETER(SystemArgument1);
00550     UNREFERENCED_PARAMETER(SystemArgument2);
00551 
00552     dueTime.LowPart = (ULONG)(-1 * 10 * 1000 * 1000);
00553     dueTime.HighPart = -1;
00554 
00555     <a class="code" href="../../d3/d2/timerobj_8c.html#a6">KeSetTimer</a>(
00556         &amp;InternalBreakpointTimer,
00557         dueTime,
00558         &amp;InternalBreakpointCheckDpc
00559         );
00560 
00561     <span class="keywordflow">for</span> ( i = 0 ; i &lt; <a class="code" href="../../d8/d5/kddata_8c.html#a65">KdpNumInternalBreakpoints</a>; i++ ) {
00562         <span class="keywordflow">if</span> ( !(<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[i].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o1">Flags</a> &amp; DBGKD_INTERNAL_BP_FLAG_INVALID) &amp;&amp;
00563              (<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[i].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o1">Flags</a> &amp; DBGKD_INTERNAL_BP_FLAG_COUNTONLY) ) {
00564 
00565             <a class="code" href="../../d0/d7/kdp_8h.html#a39">PDBGKD_INTERNAL_BREAKPOINT</a> b = <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a> + i;
00566             ULONG callsThisPeriod;
00567 
00568             callsThisPeriod = b-&gt;<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o2">Calls</a> - b-&gt;CallsLastCheck;
00569             <span class="keywordflow">if</span> ( callsThisPeriod &gt; b-&gt;MaxCallsPerPeriod ) {
00570                 b-&gt;MaxCallsPerPeriod = callsThisPeriod;
00571             }
00572             b-&gt;CallsLastCheck = b-&gt;Calls;
00573         }
00574     }
00575 
00576     <span class="keywordflow">return</span>;
00577 
00578 } <span class="comment">// InternalBreakpointCheck</span>
00579 
00580 
00581 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00582 KdSetInternalBreakpoint (
00583     IN PDBGKD_MANIPULATE_STATE64 m
00584     )
00585 
00586 <span class="comment">/*++</span>
00587 <span class="comment"></span>
00588 <span class="comment">Routine Description:</span>
00589 <span class="comment"></span>
00590 <span class="comment">    This function sets an internal breakpoint.  "Internal breakpoint"</span>
00591 <span class="comment">    means one in which control is not returned to the kernel debugger at</span>
00592 <span class="comment">    all, but rather just update internal counting routines and resume.</span>
00593 <span class="comment"></span>
00594 <span class="comment">Arguments:</span>
00595 <span class="comment"></span>
00596 <span class="comment">    m - Supplies the state manipulation message.</span>
00597 <span class="comment"></span>
00598 <span class="comment">Return Value:</span>
00599 <span class="comment"></span>
00600 <span class="comment">    None.</span>
00601 <span class="comment">--*/</span>
00602 
00603 {
00604     ULONG i;
00605     <a class="code" href="../../d0/d7/kdp_8h.html#a39">PDBGKD_INTERNAL_BREAKPOINT</a> bp = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00606     ULONG savedFlags;
00607 
00608     <span class="keywordflow">for</span> ( i = 0 ; i &lt; <a class="code" href="../../d8/d5/kddata_8c.html#a65">KdpNumInternalBreakpoints</a>; i++ ) {
00609         <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[i].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o0">Addr</a> ==
00610                             m-&gt;u.SetInternalBreakpoint.BreakpointAddress ) {
00611             bp = &amp;<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[i];
00612             <span class="keywordflow">break</span>;
00613         }
00614     }
00615 
00616     <span class="keywordflow">if</span> ( !bp ) {
00617         <span class="keywordflow">for</span> ( i = 0; i &lt; <a class="code" href="../../d8/d5/kddata_8c.html#a65">KdpNumInternalBreakpoints</a>; i++ ) {
00618             <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[i].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o1">Flags</a> &amp; DBGKD_INTERNAL_BP_FLAG_INVALID ) {
00619                 bp = &amp;<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[i];
00620                 <span class="keywordflow">break</span>;
00621             }
00622         }
00623     }
00624 
00625     <span class="keywordflow">if</span> ( !bp ) {
00626         <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d5/kddata_8c.html#a65">KdpNumInternalBreakpoints</a> &gt;= <a class="code" href="../../d0/d7/kdp_8h.html#a15">DBGKD_MAX_INTERNAL_BREAKPOINTS</a> ) {
00627             <span class="keywordflow">return</span>; <span class="comment">// no space.  Probably should report error.</span>
00628         }
00629         bp = &amp;<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[<a class="code" href="../../d8/d5/kddata_8c.html#a65">KdpNumInternalBreakpoints</a>++];
00630         bp-&gt;<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o1">Flags</a> |= DBGKD_INTERNAL_BP_FLAG_INVALID; <span class="comment">// force initialization</span>
00631     }
00632 
00633     <span class="keywordflow">if</span> ( bp-&gt;Flags &amp; DBGKD_INTERNAL_BP_FLAG_INVALID ) {
00634         <span class="keywordflow">if</span> ( m-&gt;u.SetInternalBreakpoint.Flags &amp;
00635                                         DBGKD_INTERNAL_BP_FLAG_INVALID ) {
00636             <span class="keywordflow">return</span>; <span class="comment">// tried clearing a non-existant BP.  Ignore the request</span>
00637         }
00638         bp-&gt;Calls = bp-&gt;MaxInstructions = bp-&gt;TotalInstructions = 0;
00639         bp-&gt;CallsLastCheck = bp-&gt;MaxCallsPerPeriod = 0;
00640         bp-&gt;MinInstructions = 0xffffffff;
00641         bp-&gt;Handle = 0;
00642         bp-&gt;Thread = 0;
00643     }
00644 
00645     savedFlags = bp-&gt;Flags;
00646     bp-&gt;Flags = m-&gt;u.SetInternalBreakpoint.Flags; <span class="comment">// this could possibly invalidate the BP</span>
00647     bp-&gt;Addr = m-&gt;u.SetInternalBreakpoint.BreakpointAddress;
00648 
00649     <span class="keywordflow">if</span> ( bp-&gt;Flags &amp; (DBGKD_INTERNAL_BP_FLAG_INVALID |
00650                       DBGKD_INTERNAL_BP_FLAG_SUSPENDED) ) {
00651 
00652         <span class="keywordflow">if</span> ( (bp-&gt;Flags &amp; DBGKD_INTERNAL_BP_FLAG_INVALID) &amp;&amp;
00653              (bp-&gt;Thread != 0) ) {
00654             <span class="comment">// The breakpoint is active; defer its deletion</span>
00655             bp-&gt;Flags &amp;= ~DBGKD_INTERNAL_BP_FLAG_INVALID;
00656             bp-&gt;Flags |= DBGKD_INTERNAL_BP_FLAG_DYING;
00657         }
00658 
00659         <span class="comment">// This is really a CLEAR bp request.</span>
00660 
00661         <span class="keywordflow">if</span> ( bp-&gt;Handle != 0 ) {
00662             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a105">KdpDeleteBreakpoint</a>( bp-&gt;Handle );
00663         }
00664         bp-&gt;Handle = 0;
00665 
00666         <span class="keywordflow">return</span>;
00667     }
00668 
00669     <span class="comment">// now set the real breakpoint and remember its handle.</span>
00670 
00671     <span class="keywordflow">if</span> ( savedFlags &amp; (DBGKD_INTERNAL_BP_FLAG_INVALID |
00672                        DBGKD_INTERNAL_BP_FLAG_SUSPENDED) ) {
00673         <span class="comment">// breakpoint was invalid; activate it now</span>
00674         bp-&gt;Handle = <a class="code" href="../../d1/d7/4_2kdp_8h.html#a104">KdpAddBreakpoint</a>( (PVOID)bp-&gt;Addr );
00675     }
00676 
00677     <span class="keywordflow">if</span> ( <a class="code" href="../../d8/d5/kddata_8c.html#a86">BreakpointsSuspended</a> ) {
00678         <a class="code" href="../../d1/d7/4_2kdp_8h.html#a138">KdpSuspendBreakpoint</a>( bp-&gt;Handle );
00679     }
00680 
00681 } <span class="comment">// KdSetInternalBreakpoint</span>
00682 
00683 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00684 KdGetTraceInformation(
00685     PVOID SystemInformation,
00686     ULONG SystemInformationLength,
00687     PULONG ReturnLength
00688     )
00689 
00690 <span class="comment">/*++</span>
00691 <span class="comment"></span>
00692 <span class="comment">Routine Description:</span>
00693 <span class="comment"></span>
00694 <span class="comment">    This function gets data about an internal breakpoint and returns it</span>
00695 <span class="comment">    in a buffer provided for it.  It is designed to be called from</span>
00696 <span class="comment">    NTQuerySystemInformation.  It is morally equivalent to GetInternalBP</span>
00697 <span class="comment">    except that it communicates locally, and returns all the breakpoints</span>
00698 <span class="comment">    at once.</span>
00699 <span class="comment"></span>
00700 <span class="comment">Arguments:</span>
00701 <span class="comment"></span>
00702 <span class="comment">    SystemInforamtion - the buffer into which to write the result.</span>
00703 <span class="comment">    SystemInformationLength - the maximum length to write</span>
00704 <span class="comment">    RetrunLength - How much data was really written</span>
00705 <span class="comment"></span>
00706 <span class="comment">Return Value:</span>
00707 <span class="comment"></span>
00708 <span class="comment">    None.</span>
00709 <span class="comment"></span>
00710 <span class="comment">--*/</span>
00711 
00712 {
00713     ULONG numEntries = 0;
00714     ULONG i = 0;
00715     PDBGKD_GET_INTERNAL_BREAKPOINT64 outPtr;
00716 
00717     <span class="keywordflow">for</span> ( i = 0; i &lt; <a class="code" href="../../d8/d5/kddata_8c.html#a65">KdpNumInternalBreakpoints</a>; i++ ) {
00718         <span class="keywordflow">if</span> ( !(<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[i].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o1">Flags</a> &amp; DBGKD_INTERNAL_BP_FLAG_INVALID) ) {
00719             numEntries++;
00720         }
00721     }
00722 
00723     *ReturnLength = numEntries * <span class="keyword">sizeof</span>(DBGKD_GET_INTERNAL_BREAKPOINT64);
00724     <span class="keywordflow">if</span> ( *ReturnLength &gt; SystemInformationLength ) {
00725         <span class="keywordflow">return</span> STATUS_INFO_LENGTH_MISMATCH;
00726     }
00727 
00728     <span class="comment">//</span>
00729     <span class="comment">// We've got enough space.  Copy it in.</span>
00730     <span class="comment">//</span>
00731 
00732     outPtr = (PDBGKD_GET_INTERNAL_BREAKPOINT64)SystemInformation;
00733     <span class="keywordflow">for</span> ( i = 0; i &lt; <a class="code" href="../../d8/d5/kddata_8c.html#a65">KdpNumInternalBreakpoints</a>; i++ ) {
00734         <span class="keywordflow">if</span> ( !(<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[i].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o1">Flags</a> &amp; DBGKD_INTERNAL_BP_FLAG_INVALID) ) {
00735             outPtr-&gt;BreakpointAddress = <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[i].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o0">Addr</a>;
00736             outPtr-&gt;Flags = <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[i].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o1">Flags</a>;
00737             outPtr-&gt;Calls = <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[i].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o2">Calls</a>;
00738             outPtr-&gt;MaxCallsPerPeriod = <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[i].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o4">MaxCallsPerPeriod</a>;
00739             outPtr-&gt;MinInstructions = <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[i].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o5">MinInstructions</a>;
00740             outPtr-&gt;MaxInstructions = <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[i].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o6">MaxInstructions</a>;
00741             outPtr-&gt;TotalInstructions = <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[i].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o7">TotalInstructions</a>;
00742             outPtr++;
00743         }
00744     }
00745 
00746     <span class="keywordflow">return</span> STATUS_SUCCESS;
00747 
00748 } <span class="comment">// KdGetTraceInformation</span>
00749 
00750 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00751 KdGetInternalBreakpoint(
00752     IN PDBGKD_MANIPULATE_STATE64 m
00753     )
00754 
00755 <span class="comment">/*++</span>
00756 <span class="comment"></span>
00757 <span class="comment">Routine Description:</span>
00758 <span class="comment"></span>
00759 <span class="comment">    This function gets data about an internal breakpoint and returns it</span>
00760 <span class="comment">    to the calling debugger.</span>
00761 <span class="comment"></span>
00762 <span class="comment">Arguments:</span>
00763 <span class="comment"></span>
00764 <span class="comment">    m - Supplies the state manipulation message.</span>
00765 <span class="comment"></span>
00766 <span class="comment">Return Value:</span>
00767 <span class="comment"></span>
00768 <span class="comment">    None.</span>
00769 <span class="comment"></span>
00770 <span class="comment">--*/</span>
00771 
00772 {
00773     ULONG i;
00774     <a class="code" href="../../d0/d7/kdp_8h.html#a39">PDBGKD_INTERNAL_BREAKPOINT</a> bp = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00775     STRING messageHeader;
00776 
00777     messageHeader.Length = <span class="keyword">sizeof</span>(*m);
00778     messageHeader.Buffer = (PCHAR)m;
00779 
00780     <span class="keywordflow">for</span> ( i = 0; i &lt; <a class="code" href="../../d8/d5/kddata_8c.html#a65">KdpNumInternalBreakpoints</a>; i++ ) {
00781         <span class="keywordflow">if</span> ( !(<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[i].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o1">Flags</a> &amp; (DBGKD_INTERNAL_BP_FLAG_INVALID |
00782                                           DBGKD_INTERNAL_BP_FLAG_SUSPENDED)) &amp;&amp;
00783              (<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[i].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o0">Addr</a> ==
00784                         m-&gt;u.GetInternalBreakpoint.BreakpointAddress) ) {
00785             bp = &amp;<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[i];
00786             <span class="keywordflow">break</span>;
00787         }
00788     }
00789 
00790     <span class="keywordflow">if</span> ( !bp ) {
00791         m-&gt;u.GetInternalBreakpoint.<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o1">Flags</a> = DBGKD_INTERNAL_BP_FLAG_INVALID;
00792         m-&gt;u.GetInternalBreakpoint.Calls = 0;
00793         m-&gt;u.GetInternalBreakpoint.MaxCallsPerPeriod = 0;
00794         m-&gt;u.GetInternalBreakpoint.MinInstructions = 0;
00795         m-&gt;u.GetInternalBreakpoint.MaxInstructions = 0;
00796         m-&gt;u.GetInternalBreakpoint.TotalInstructions = 0;
00797         m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
00798     } <span class="keywordflow">else</span> {
00799         m-&gt;u.GetInternalBreakpoint.Flags = bp-&gt;Flags;
00800         m-&gt;u.GetInternalBreakpoint.Calls = bp-&gt;Calls;
00801         m-&gt;u.GetInternalBreakpoint.MaxCallsPerPeriod = bp-&gt;MaxCallsPerPeriod;
00802         m-&gt;u.GetInternalBreakpoint.MinInstructions = bp-&gt;MinInstructions;
00803         m-&gt;u.GetInternalBreakpoint.MaxInstructions = bp-&gt;MaxInstructions;
00804         m-&gt;u.GetInternalBreakpoint.TotalInstructions = bp-&gt;TotalInstructions;
00805         m-&gt;ReturnStatus = STATUS_SUCCESS;
00806     }
00807 
00808     m-&gt;ApiNumber = DbgKdGetInternalBreakPointApi;
00809 
00810     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(PACKET_TYPE_KD_STATE_MANIPULATE,
00811                     &amp;messageHeader,
00812                     NULL
00813                     );
00814 
00815     <span class="keywordflow">return</span>;
00816 
00817 } <span class="comment">// KdGetInternalBreakpoint</span>
00818 <span class="preprocessor">#endif // i386</span>
00819 <span class="preprocessor"></span>
00820 <a class="code" href="../../d4/d9/ke_8h.html#a408">KCONTINUE_STATUS</a>
<a name="l00821"></a><a class="code" href="../../d9/d3/4_2kdapi_8c.html#a22">00821</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a122">KdpSendWaitContinue</a> (
00822     IN ULONG OutPacketType,
00823     IN PSTRING OutMessageHeader,
00824     IN PSTRING OutMessageData OPTIONAL,
00825     IN OUT PCONTEXT ContextRecord
00826     )
00827 
00828 <span class="comment">/*++</span>
00829 <span class="comment"></span>
00830 <span class="comment">Routine Description:</span>
00831 <span class="comment"></span>
00832 <span class="comment">    This function sends a packet, and then waits for a continue message.</span>
00833 <span class="comment">    BreakIns received while waiting will always cause a resend of the</span>
00834 <span class="comment">    packet originally sent out.  While waiting, manipulate messages</span>
00835 <span class="comment">    will be serviced.</span>
00836 <span class="comment"></span>
00837 <span class="comment">    A resend always resends the original event sent to the debugger,</span>
00838 <span class="comment">    not the last response to some debugger command.</span>
00839 <span class="comment"></span>
00840 <span class="comment">Arguments:</span>
00841 <span class="comment"></span>
00842 <span class="comment">    OutPacketType - Supplies the type of packet to send.</span>
00843 <span class="comment"></span>
00844 <span class="comment">    OutMessageHeader - Supplies a pointer to a string descriptor that describes</span>
00845 <span class="comment">        the message information.</span>
00846 <span class="comment"></span>
00847 <span class="comment">    OutMessageData - Supplies a pointer to a string descriptor that describes</span>
00848 <span class="comment">        the optional message data.</span>
00849 <span class="comment"></span>
00850 <span class="comment">    ContextRecord - Exception context</span>
00851 <span class="comment"></span>
00852 <span class="comment">Return Value:</span>
00853 <span class="comment"></span>
00854 <span class="comment">    A value of TRUE is returned if the continue message indicates</span>
00855 <span class="comment">    success, Otherwise, a value of FALSE is returned.</span>
00856 <span class="comment"></span>
00857 <span class="comment">--*/</span>
00858 
00859 {
00860 
00861     ULONG Length;
00862     STRING MessageData;
00863     STRING MessageHeader;
00864     DBGKD_MANIPULATE_STATE64 ManipulateState;
00865     ULONG ReturnCode;
00866     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00867     <a class="code" href="../../d4/d9/ke_8h.html#a408">KCONTINUE_STATUS</a> ContinueStatus;
00868 
00869     <span class="comment">//</span>
00870     <span class="comment">// Loop servicing state manipulation message until a continue message</span>
00871     <span class="comment">// is received.</span>
00872     <span class="comment">//</span>
00873 
00874     MessageHeader.MaximumLength = <span class="keyword">sizeof</span>(DBGKD_MANIPULATE_STATE64);
00875     MessageHeader.Buffer = (PCHAR)&amp;ManipulateState;
00876     MessageData.MaximumLength = <a class="code" href="../../d0/d7/kdp_8h.html#a14">KDP_MESSAGE_BUFFER_SIZE</a>;
00877     MessageData.Buffer = (PCHAR)<a class="code" href="../../d8/d5/kddata_8c.html#a52">KdpMessageBuffer</a>;
00878 
00879 ResendPacket:
00880 
00881     <span class="comment">//</span>
00882     <span class="comment">// Send event notification packet to debugger on host.  Come back</span>
00883     <span class="comment">// here any time we see a breakin sequence.</span>
00884     <span class="comment">//</span>
00885 
00886     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(
00887                   OutPacketType,
00888                   OutMessageHeader,
00889                   OutMessageData
00890                   );
00891 
00892     <span class="comment">//</span>
00893     <span class="comment">// After sending packet, if there is no response from debugger</span>
00894     <span class="comment">// AND the packet is for reporting symbol (un)load, the debugger</span>
00895     <span class="comment">// will be declared to be not present.  Note If the packet is for</span>
00896     <span class="comment">// reporting exception, the KdpSendPacket will never stop.</span>
00897     <span class="comment">//</span>
00898 
00899     <span class="keywordflow">if</span> (<a class="code" href="../../d7/d3/kd_8h.html#a12">KdDebuggerNotPresent</a>) {
00900         <span class="keywordflow">return</span> <a class="code" href="../../d4/d9/ke_8h.html#a408a227">ContinueSuccess</a>;
00901     }
00902 
00903     <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00904 
00905         <span class="comment">//</span>
00906         <span class="comment">// Wait for State Manipulate Packet without timeout.</span>
00907         <span class="comment">//</span>
00908 
00909         <span class="keywordflow">do</span> {
00910 
00911             ReturnCode = <a class="code" href="../../d1/d7/4_2kdp_8h.html#a112">KdpReceivePacket</a>(
00912                             PACKET_TYPE_KD_STATE_MANIPULATE,
00913                             &amp;MessageHeader,
00914                             &amp;MessageData,
00915                             &amp;Length
00916                             );
00917             <span class="keywordflow">if</span> (ReturnCode == (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d0/d7/kdp_8h.html#a11">KDP_PACKET_RESEND</a>) {
00918                 <span class="keywordflow">goto</span> ResendPacket;
00919             }
00920         } <span class="keywordflow">while</span> (ReturnCode == <a class="code" href="../../d0/d7/kdp_8h.html#a10">KDP_PACKET_TIMEOUT</a>);
00921 
00922         <span class="comment">//</span>
00923         <span class="comment">// Switch on the return message API number.</span>
00924         <span class="comment">//</span>
00925 
00926         <span class="keywordflow">switch</span> (ManipulateState.ApiNumber) {
00927 
00928         <span class="keywordflow">case</span> DbgKdReadVirtualMemoryApi:
00929             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a123">KdpReadVirtualMemory</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
00930             <span class="keywordflow">break</span>;
00931 <span class="preprocessor">#if 0</span>
00932 <span class="preprocessor"></span>        <span class="keywordflow">case</span> DbgKdReadVirtualMemory64Api:
00933             <a class="code" href="../../d0/d7/kdp_8h.html#a110">KdpReadVirtualMemory64</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
00934             <span class="keywordflow">break</span>;
00935 <span class="preprocessor">#endif</span>
00936 <span class="preprocessor"></span>        <span class="keywordflow">case</span> DbgKdWriteVirtualMemoryApi:
00937             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a124">KdpWriteVirtualMemory</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
00938             <span class="keywordflow">break</span>;
00939 <span class="preprocessor">#if 0</span>
00940 <span class="preprocessor"></span>        <span class="keywordflow">case</span> DbgKdWriteVirtualMemory64Api:
00941             <a class="code" href="../../d0/d7/kdp_8h.html#a112">KdpWriteVirtualMemory64</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
00942             <span class="keywordflow">break</span>;
00943 <span class="preprocessor">#endif</span>
00944 <span class="preprocessor"></span>
00945         <span class="keywordflow">case</span> DbgKdCheckLowMemoryApi:
00946             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a127">KdpCheckLowMemory</a> (&amp;ManipulateState);
00947             <span class="keywordflow">break</span>;
00948 
00949         <span class="keywordflow">case</span> DbgKdReadPhysicalMemoryApi:
00950             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a125">KdpReadPhysicalMemory</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
00951             <span class="keywordflow">break</span>;
00952 
00953         <span class="keywordflow">case</span> DbgKdWritePhysicalMemoryApi:
00954             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a126">KdpWritePhysicalMemory</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
00955             <span class="keywordflow">break</span>;
00956 
00957         <span class="keywordflow">case</span> DbgKdGetContextApi:
00958             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a128">KdpGetContext</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
00959             <span class="keywordflow">break</span>;
00960 
00961         <span class="keywordflow">case</span> DbgKdSetContextApi:
00962             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a129">KdpSetContext</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
00963             <span class="keywordflow">break</span>;
00964 
00965         <span class="keywordflow">case</span> DbgKdWriteBreakPointApi:
00966             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a130">KdpWriteBreakpoint</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
00967             <span class="keywordflow">break</span>;
00968 
00969         <span class="keywordflow">case</span> DbgKdRestoreBreakPointApi:
00970             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a131">KdpRestoreBreakpoint</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
00971             <span class="keywordflow">break</span>;
00972 
00973         <span class="keywordflow">case</span> DbgKdReadControlSpaceApi:
00974             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a132">KdpReadControlSpace</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
00975             <span class="keywordflow">break</span>;
00976 
00977         <span class="keywordflow">case</span> DbgKdWriteControlSpaceApi:
00978             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a133">KdpWriteControlSpace</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
00979             <span class="keywordflow">break</span>;
00980 
00981         <span class="keywordflow">case</span> DbgKdReadIoSpaceApi:
00982             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a134">KdpReadIoSpace</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
00983             <span class="keywordflow">break</span>;
00984 
00985         <span class="keywordflow">case</span> DbgKdWriteIoSpaceApi:
00986             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a136">KdpWriteIoSpace</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
00987             <span class="keywordflow">break</span>;
00988 
00989 <span class="preprocessor">#ifdef _ALPHA_</span>
00990 <span class="preprocessor"></span>
00991         <span class="keywordflow">case</span> DbgKdReadIoSpaceExtendedApi:
00992             <a class="code" href="../../d7/d7/4_2axp64_2kdpcpu_8h.html#a10">KdpReadIoSpaceExtended</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
00993             <span class="keywordflow">break</span>;
00994 
00995         <span class="keywordflow">case</span> DbgKdWriteIoSpaceExtendedApi:
00996             <a class="code" href="../../d7/d7/4_2axp64_2kdpcpu_8h.html#a11">KdpWriteIoSpaceExtended</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
00997             <span class="keywordflow">break</span>;
00998 
00999         <span class="keywordflow">case</span> DbgKdGetBusDataApi:
01000             <a class="code" href="../../d5/d5/4_2alpha_2kdcpuapi_8c.html#a10">KdpGetBusData</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
01001             <span class="keywordflow">break</span>;
01002 
01003         <span class="keywordflow">case</span> DbgKdSetBusDataApi:
01004             <a class="code" href="../../d5/d5/4_2alpha_2kdcpuapi_8c.html#a11">KdpSetBusData</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
01005             <span class="keywordflow">break</span>;
01006 
01007 <span class="preprocessor">#endif // _ALPHA_</span>
01008 <span class="preprocessor"></span>
01009         <span class="keywordflow">case</span> DbgKdContinueApi:
01010             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(ManipulateState.u.Continue.ContinueStatus) != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01011                 <span class="keywordflow">return</span> <a class="code" href="../../d4/d9/ke_8h.html#a408a227">ContinueSuccess</a>;
01012             } <span class="keywordflow">else</span> {
01013                 <span class="keywordflow">return</span> <a class="code" href="../../d4/d9/ke_8h.html#a408a226">ContinueError</a>;
01014             }
01015             <span class="keywordflow">break</span>;
01016 
01017         <span class="keywordflow">case</span> DbgKdContinueApi2:
01018             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(ManipulateState.u.Continue2.ContinueStatus) != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01019                 <a class="code" href="../../d1/d7/4_2kdp_8h.html#a115">KdpGetStateChange</a>(&amp;ManipulateState,ContextRecord);
01020                 <span class="keywordflow">return</span> <a class="code" href="../../d4/d9/ke_8h.html#a408a227">ContinueSuccess</a>;
01021             } <span class="keywordflow">else</span> {
01022                 <span class="keywordflow">return</span> <a class="code" href="../../d4/d9/ke_8h.html#a408a226">ContinueError</a>;
01023             }
01024             <span class="keywordflow">break</span>;
01025 
01026         <span class="keywordflow">case</span> DbgKdRebootApi:
01027             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a101">KdpReboot</a>();
01028             <span class="keywordflow">break</span>;
01029 
01030 <span class="preprocessor">#if i386</span>
01031 <span class="preprocessor"></span>        <span class="keywordflow">case</span> DbgKdReadMachineSpecificRegister:
01032             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a135">KdpReadMachineSpecificRegister</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
01033             <span class="keywordflow">break</span>;
01034 
01035         <span class="keywordflow">case</span> DbgKdWriteMachineSpecificRegister:
01036             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a137">KdpWriteMachineSpecificRegister</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
01037             <span class="keywordflow">break</span>;
01038 
01039         <span class="keywordflow">case</span> DbgKdSetSpecialCallApi:
01040             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a108">KdSetSpecialCall</a>(&amp;ManipulateState,ContextRecord);
01041             <span class="keywordflow">break</span>;
01042 
01043         <span class="keywordflow">case</span> DbgKdClearSpecialCallsApi:
01044             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a109">KdClearSpecialCalls</a>();
01045             <span class="keywordflow">break</span>;
01046 
01047         <span class="keywordflow">case</span> DbgKdSetInternalBreakPointApi:
01048             KdSetInternalBreakpoint(&amp;ManipulateState);
01049             <span class="keywordflow">break</span>;
01050 
01051         <span class="keywordflow">case</span> DbgKdGetInternalBreakPointApi:
01052             KdGetInternalBreakpoint(&amp;ManipulateState);
01053             <span class="keywordflow">break</span>;
01054 <span class="preprocessor">#endif</span>
01055 <span class="preprocessor"></span>
01056         <span class="keywordflow">case</span> DbgKdGetVersionApi:
01057             <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a7">KdpGetVersion</a>(&amp;ManipulateState);
01058             <span class="keywordflow">break</span>;
01059 
01060         <span class="keywordflow">case</span> DbgKdCauseBugCheckApi:
01061             <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a9">KdpCauseBugCheck</a>(&amp;ManipulateState);
01062             <span class="keywordflow">break</span>;
01063 
01064         <span class="keywordflow">case</span> DbgKdPageInApi:
01065             <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a8">KdpNotSupported</a>(&amp;ManipulateState);
01066             <span class="keywordflow">break</span>;
01067 
01068         <span class="keywordflow">case</span> DbgKdWriteBreakPointExApi:
01069             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a10">KdpWriteBreakPointEx</a>(&amp;ManipulateState,
01070                                           &amp;MessageData,
01071                                           ContextRecord);
01072             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>) {
01073                 ManipulateState.ApiNumber = DbgKdContinueApi;
01074                 ManipulateState.u.Continue.ContinueStatus = <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01075                 <span class="keywordflow">return</span> <a class="code" href="../../d4/d9/ke_8h.html#a408a226">ContinueError</a>;
01076             }
01077             <span class="keywordflow">break</span>;
01078 
01079         <span class="keywordflow">case</span> DbgKdRestoreBreakPointExApi:
01080             <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a11">KdpRestoreBreakPointEx</a>(&amp;ManipulateState,&amp;MessageData,ContextRecord);
01081             <span class="keywordflow">break</span>;
01082 
01083         <span class="keywordflow">case</span> DbgKdSwitchProcessor:
01084             <a class="code" href="../../d2/d7/hal_8h.html#a203">KdPortRestore</a> ();
01085             ContinueStatus = <a class="code" href="../../d9/d4/ke_2debug_8c.html#a11">KeSwitchFrozenProcessor</a>(ManipulateState.Processor);
01086             <a class="code" href="../../d2/d7/hal_8h.html#a204">KdPortSave</a> ();
01087             <span class="keywordflow">return</span> ContinueStatus;
01088 
01089         <span class="keywordflow">case</span> DbgKdSearchMemoryApi:
01090             <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a12">KdpSearchMemory</a>(&amp;ManipulateState, &amp;MessageData, ContextRecord);
01091             <span class="keywordflow">break</span>;
01092 
01093             <span class="comment">//</span>
01094             <span class="comment">// Invalid message.</span>
01095             <span class="comment">//</span>
01096 
01097         <span class="keywordflow">default</span>:
01098             MessageData.Length = 0;
01099             ManipulateState.ReturnStatus = STATUS_UNSUCCESSFUL;
01100             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(PACKET_TYPE_KD_STATE_MANIPULATE, &amp;MessageHeader, &amp;MessageData);
01101             <span class="keywordflow">break</span>;
01102         }
01103 
01104 <span class="preprocessor">#ifdef _ALPHA_</span>
01105 <span class="preprocessor"></span>
01106         <span class="comment">//</span>
01107         <span class="comment">//jnfix</span>
01108         <span class="comment">// this is embarrasing, we have an icache coherency problem that</span>
01109         <span class="comment">// the following imb fixes, later we must track this down to the</span>
01110         <span class="comment">// exact offending API but for now this statement allows the stub</span>
01111         <span class="comment">// work to appropriately for Alpha.</span>
01112         <span class="comment">//</span>
01113 
01114 <span class="preprocessor">#if defined(_MSC_VER)</span>
01115 <span class="preprocessor"></span>        __PAL_IMB();
01116 <span class="preprocessor">#else</span>
01117 <span class="preprocessor"></span>        <span class="keyword">asm</span>( <span class="stringliteral">"call_pal 0x86"</span> );   <span class="comment">// x86 = imb</span>
01118 <span class="preprocessor">#endif</span>
01119 <span class="preprocessor"></span>
01120 <span class="preprocessor">#endif</span>
01121 <span class="preprocessor"></span>
01122     }
01123 }
01124 
01125 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01126"></a><a class="code" href="../../d1/d7/4_2kdp_8h.html#a123">01126</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a123">KdpReadVirtualMemory</a>(
01127     IN PDBGKD_MANIPULATE_STATE64 m,
01128     IN PSTRING AdditionalData,
01129     IN PCONTEXT Context
01130     )
01131 
01132 <span class="comment">/*++</span>
01133 <span class="comment"></span>
01134 <span class="comment">Routine Description:</span>
01135 <span class="comment"></span>
01136 <span class="comment">    This function is called in response to a read virtual memory 32-bit</span>
01137 <span class="comment">    state manipulation message. Its function is to read virtual memory</span>
01138 <span class="comment">    and return.</span>
01139 <span class="comment"></span>
01140 <span class="comment">Arguments:</span>
01141 <span class="comment"></span>
01142 <span class="comment">    m - Supplies a pointer to the state manipulation message.</span>
01143 <span class="comment"></span>
01144 <span class="comment">    AdditionalData - Supplies a pointer to a descriptor for the data to read.</span>
01145 <span class="comment"></span>
01146 <span class="comment">    Context - Supplies a pointer to the current context.</span>
01147 <span class="comment"></span>
01148 <span class="comment">Return Value:</span>
01149 <span class="comment"></span>
01150 <span class="comment">    None.</span>
01151 <span class="comment"></span>
01152 <span class="comment">--*/</span>
01153 
01154 {
01155     ULONG Length;
01156     STRING MessageHeader;
01157 <span class="preprocessor">#if defined(_ALPHA_) &amp;&amp; !defined(_AXP64_)</span>
01158 <span class="preprocessor"></span>    UCHAR * POINTER_64 Address;
01159     PUCHAR Destination;
01160     UCHAR * POINTER_64 Source;
01161     PUCHAR Source32;
01162 <span class="preprocessor">#endif</span>
01163 <span class="preprocessor"></span>
01164     <span class="comment">//</span>
01165     <span class="comment">// Trim the transfer count to fit in a single message.</span>
01166     <span class="comment">//</span>
01167 
01168     Length = m-&gt;u.ReadMemory.TransferCount;
01169     <span class="keywordflow">if</span> (Length &gt; (PACKET_MAX_SIZE - <span class="keyword">sizeof</span>(DBGKD_MANIPULATE_STATE64))) {
01170         Length = PACKET_MAX_SIZE - <span class="keyword">sizeof</span>(DBGKD_MANIPULATE_STATE64);
01171     }
01172 
01173     <span class="comment">//</span>
01174     <span class="comment">// Move the data to the destination buffer.</span>
01175     <span class="comment">//</span>
01176 
01177 <span class="preprocessor">#if defined(_ALPHA_) &amp;&amp; !defined(_AXP64_)</span>
01178 <span class="preprocessor"></span>
01179     AdditionalData-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)Length;
01180 
01181     Destination = AdditionalData-&gt;Buffer;
01182     Source = (UCHAR * POINTER_64)m-&gt;u.ReadMemory.TargetBaseAddress;
01183     Source32 = (PUCHAR)m-&gt;u.ReadMemory.TargetBaseAddress;
01184     <span class="keywordflow">while</span> (Length &gt; 0) {
01185         <span class="keywordflow">if</span> ((LONGLONG)Source != (LONGLONG)((LONG)Source)) {
01186             <span class="keywordflow">if</span> ((Address = <a class="code" href="../../d4/d6/ppc_2debugsup_8c.html#a2">MmDbgReadCheck64</a>(Source)) == NULL64) {
01187                 <span class="keywordflow">break</span>;
01188             }
01189         } <span class="keywordflow">else</span> {
01190             <span class="keywordflow">if</span> ((Address = <a class="code" href="../../d4/d6/ppc_2debugsup_8c.html#a0">MmDbgReadCheck</a>(Source32)) == NULL64) {
01191                 <span class="keywordflow">break</span>;
01192             }
01193         }
01194 
01195         *Destination++ = *Address;
01196         Source   += 1;
01197         Source32 += 1;
01198         Length -= 1;
01199     }
01200 
01201     <span class="comment">//</span>
01202     <span class="comment">// If all the data is read, then return a success status. Otherwise,</span>
01203     <span class="comment">// return an unsuccessful status.</span>
01204     <span class="comment">//</span>
01205 
01206     m-&gt;ReturnStatus = STATUS_SUCCESS;
01207     <span class="keywordflow">if</span> (Length != 0) {
01208         m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
01209     }
01210 
01211     <span class="comment">//</span>
01212     <span class="comment">// Set the actual number of bytes read, initialize the message header,</span>
01213     <span class="comment">// and send the reply packet to the host debugger.</span>
01214     <span class="comment">//</span>
01215 
01216     m-&gt;u.ReadMemory.ActualBytesRead = AdditionalData-&gt;Length - Length;
01217 <span class="preprocessor">#else</span>
01218 <span class="preprocessor"></span>    AdditionalData-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>(AdditionalData-&gt;Buffer,
01219                                                    (PVOID)m-&gt;u.ReadMemory.TargetBaseAddress,
01220                                                    Length);
01221 
01222     <span class="comment">//</span>
01223     <span class="comment">// If all the data is read, then return a success status. Otherwise,</span>
01224     <span class="comment">// return an unsuccessful status.</span>
01225     <span class="comment">//</span>
01226 
01227     m-&gt;ReturnStatus = STATUS_SUCCESS;
01228     <span class="keywordflow">if</span> (Length != AdditionalData-&gt;Length) {
01229         m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
01230     }
01231 
01232     <span class="comment">//</span>
01233     <span class="comment">// Set the actual number of bytes read, initialize the message header,</span>
01234     <span class="comment">// and send the reply packet to the host debugger.</span>
01235     <span class="comment">//</span>
01236 
01237     m-&gt;u.ReadMemory.ActualBytesRead = AdditionalData-&gt;Length;
01238 <span class="preprocessor">#endif</span>
01239 <span class="preprocessor"></span>
01240     MessageHeader.Length = <span class="keyword">sizeof</span>(DBGKD_MANIPULATE_STATE64);
01241     MessageHeader.Buffer = (PCHAR)m;
01242     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(PACKET_TYPE_KD_STATE_MANIPULATE,
01243                   &amp;MessageHeader,
01244                   AdditionalData);
01245 
01246     <span class="keywordflow">return</span>;
01247 }
01248 
01249 <span class="preprocessor">#if 0</span>
01250 <span class="preprocessor"></span><a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01251 <a class="code" href="../../d0/d7/kdp_8h.html#a110">KdpReadVirtualMemory64</a>(
01252     IN PDBGKD_MANIPULATE_STATE64 m,
01253     IN PSTRING AdditionalData,
01254     IN PCONTEXT Context
01255     )
01256 
01257 <span class="comment">/*++</span>
01258 <span class="comment"></span>
01259 <span class="comment">Routine Description:</span>
01260 <span class="comment"></span>
01261 <span class="comment">    This function is called in response of a read virtual memory 64-bit</span>
01262 <span class="comment">    state manipulation message. Its function is to read virtual memory</span>
01263 <span class="comment">    and return.</span>
01264 <span class="comment"></span>
01265 <span class="comment">Arguments:</span>
01266 <span class="comment"></span>
01267 <span class="comment">    m - Supplies a pointer to a state manipulation message.</span>
01268 <span class="comment"></span>
01269 <span class="comment">    AdditionalData - Supplies a pointer to descriptor for the data to read.</span>
01270 <span class="comment"></span>
01271 <span class="comment">    Context - Supplies a pointer to the current context.</span>
01272 <span class="comment"></span>
01273 <span class="comment">Return Value:</span>
01274 <span class="comment"></span>
01275 <span class="comment">    None.</span>
01276 <span class="comment"></span>
01277 <span class="comment">--*/</span>
01278 
01279 {
01280 
01281     UCHAR * POINTER_64 Address;
01282     PUCHAR Destination;
01283     ULONG Length;
01284     STRING MessageHeader;
01285     UCHAR * POINTER_64 Source;
01286 
01287     <span class="comment">//</span>
01288     <span class="comment">// Trim the transfer count to fit in a single message.</span>
01289     <span class="comment">//</span>
01290 
01291     Length = m-&gt;u.ReadMemory64.TransferCount;
01292     <span class="keywordflow">if</span> (Length &gt; (PACKET_MAX_SIZE - <span class="keyword">sizeof</span>(DBGKD_MANIPULATE_STATE64))) {
01293         Length = PACKET_MAX_SIZE - <span class="keyword">sizeof</span>(DBGKD_MANIPULATE_STATE64);
01294     }
01295 
01296     <span class="comment">//</span>
01297     <span class="comment">// Move the data to the destination buffer.</span>
01298     <span class="comment">//</span>
01299 
01300     AdditionalData-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)Length;
01301 
01302 <span class="preprocessor">#if defined(_MIPS_) || defined(_ALPHA_)</span>
01303 <span class="preprocessor"></span>
01304     Destination = AdditionalData-&gt;Buffer;
01305     Source = (UCHAR * POINTER_64)m-&gt;u.ReadMemory64.TargetBaseAddress;
01306     <span class="keywordflow">while</span> (Length &gt; 0) {
01307         <span class="keywordflow">if</span> ((Address = <a class="code" href="../../d4/d6/ppc_2debugsup_8c.html#a2">MmDbgReadCheck64</a>(Source)) == NULL64) {
01308             <span class="keywordflow">break</span>;
01309         }
01310 
01311         *Destination++ = *Address;
01312         Source += 1;
01313         Length -= 1;
01314     }
01315 
01316 <span class="preprocessor">#endif</span>
01317 <span class="preprocessor"></span>
01318     <span class="comment">//</span>
01319     <span class="comment">// If all the data is read, then return a success status. Otherwise,</span>
01320     <span class="comment">// return an unsuccessful status.</span>
01321     <span class="comment">//</span>
01322 
01323     m-&gt;ReturnStatus = STATUS_SUCCESS;
01324     <span class="keywordflow">if</span> (Length != 0) {
01325         m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
01326     }
01327 
01328     <span class="comment">//</span>
01329     <span class="comment">// Set the actual number of bytes read, initialize the message header,</span>
01330     <span class="comment">// and send the reply packet to the host debugger.</span>
01331     <span class="comment">//</span>
01332 
01333     m-&gt;u.ReadMemory64.ActualBytesRead = AdditionalData-&gt;Length - Length;
01334     MessageHeader.Length = <span class="keyword">sizeof</span>(DBGKD_MANIPULATE_STATE64);
01335     MessageHeader.Buffer = (PCHAR)m;
01336     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(PACKET_TYPE_KD_STATE_MANIPULATE,
01337                   &amp;MessageHeader,
01338                   AdditionalData);
01339 
01340     <span class="keywordflow">return</span>;
01341 }
01342 <span class="preprocessor">#endif</span>
01343 <span class="preprocessor"></span>
01344 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01345"></a><a class="code" href="../../d1/d7/4_2kdp_8h.html#a124">01345</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a124">KdpWriteVirtualMemory</a>(
01346     IN PDBGKD_MANIPULATE_STATE64 m,
01347     IN PSTRING AdditionalData,
01348     IN PCONTEXT Context
01349     )
01350 
01351 <span class="comment">/*++</span>
01352 <span class="comment"></span>
01353 <span class="comment">Routine Description:</span>
01354 <span class="comment"></span>
01355 <span class="comment">    This function is called in response of a write virtual memory 32-bit</span>
01356 <span class="comment">    state manipulation message. Its function is to write virtual memory</span>
01357 <span class="comment">    and return.</span>
01358 <span class="comment"></span>
01359 <span class="comment">Arguments:</span>
01360 <span class="comment"></span>
01361 <span class="comment">    m - Supplies a pointer to the state manipulation message.</span>
01362 <span class="comment"></span>
01363 <span class="comment">    AdditionalData - Supplies a pointer to a descriptor for the data to write.</span>
01364 <span class="comment"></span>
01365 <span class="comment">    Context - Supplies a pointer to the current context.</span>
01366 <span class="comment"></span>
01367 <span class="comment">Return Value:</span>
01368 <span class="comment"></span>
01369 <span class="comment">    None.</span>
01370 <span class="comment"></span>
01371 <span class="comment">--*/</span>
01372 
01373 {
01374 
01375     ULONG Length;
01376     STRING MessageHeader;
01377     HARDWARE_PTE Opaque;
01378 
01379 <span class="preprocessor">#if defined(_ALPHA_) &amp;&amp; !defined(_AXP64_)</span>
01380 <span class="preprocessor"></span>    UCHAR * POINTER_64 Address;
01381     UCHAR * POINTER_64 Destination;
01382     PUCHAR Address32;
01383     PUCHAR Source;
01384     PUCHAR Destination32;
01385 
01386 
01387     <span class="comment">//</span>
01388     <span class="comment">// Move the data to the destination buffer.</span>
01389     <span class="comment">//</span>
01390 
01391     Length = AdditionalData-&gt;Length;
01392 
01393     Destination = (UCHAR * POINTER_64)m-&gt;u.WriteMemory.TargetBaseAddress;
01394     Destination32 = (PUCHAR)m-&gt;u.WriteMemory.TargetBaseAddress;
01395     Source = AdditionalData-&gt;Buffer;
01396     <span class="keywordflow">while</span> (Length &gt; 0) {
01397         Address=Destination;
01398         Address32 = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01399         <span class="keywordflow">if</span> ((LONGLONG)Destination != (LONGLONG)((LONG)Destination)) {
01400             <span class="keywordflow">if</span> ((Address = <a class="code" href="../../d4/d6/ppc_2debugsup_8c.html#a3">MmDbgWriteCheck64</a>(Destination)) == NULL64) {
01401                 <span class="keywordflow">break</span>;
01402             }
01403         } <span class="keywordflow">else</span> {
01404             <span class="keywordflow">if</span> ((Address32 = <a class="code" href="../../d4/d6/ppc_2debugsup_8c.html#a1">MmDbgWriteCheck</a>(Destination32, &amp;Opaque)) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01405                 <span class="keywordflow">break</span>;
01406             }
01407         }
01408 
01409         <span class="keywordflow">if</span> (Address32 != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01410             *Address32 = *Source++;
01411             <a class="code" href="../../d2/d6/ia64_2debugsup_8c.html#a2">MmDbgReleaseAddress</a>(Address32, &amp;Opaque);
01412         }
01413         <span class="keywordflow">else</span> {
01414             *Address = *Source++;
01415         }
01416         Destination   += 1;
01417         Destination32 += 1;
01418         Length -= 1;
01419     }
01420 
01421     <span class="comment">//</span>
01422     <span class="comment">// If all the data is written, then return a success status. Otherwise,</span>
01423     <span class="comment">// return an unsuccessful status.</span>
01424     <span class="comment">//</span>
01425 
01426     m-&gt;ReturnStatus = STATUS_SUCCESS;
01427     <span class="keywordflow">if</span> (Length != 0) {
01428         m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
01429     }
01430 
01431     <span class="comment">//</span>
01432     <span class="comment">// Set the actual number of bytes written, initialize the message header,</span>
01433     <span class="comment">// and send the reply packet to the host debugger.</span>
01434     <span class="comment">//</span>
01435 
01436     m-&gt;u.WriteMemory.ActualBytesWritten = AdditionalData-&gt;Length - Length;
01437     MessageHeader.Length = <span class="keyword">sizeof</span>(DBGKD_MANIPULATE_STATE64);
01438     MessageHeader.Buffer = (PCHAR)m;
01439     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(PACKET_TYPE_KD_STATE_MANIPULATE,
01440                   &amp;MessageHeader,
01441                   <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
01442 
01443     <span class="keywordflow">return</span>;
01444 <span class="preprocessor">#else</span>
01445 <span class="preprocessor"></span>
01446     <span class="comment">//</span>
01447     <span class="comment">// Move the data to the destination buffer.</span>
01448     <span class="comment">//</span>
01449 
01450     Length = <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>((PVOID)m-&gt;u.WriteMemory.TargetBaseAddress,
01451                            AdditionalData-&gt;Buffer,
01452                            AdditionalData-&gt;Length);
01453 
01454     <span class="comment">//</span>
01455     <span class="comment">// If all the data is written, then return a success status. Otherwise,</span>
01456     <span class="comment">// return an unsuccessful status.</span>
01457     <span class="comment">//</span>
01458 
01459     m-&gt;ReturnStatus = STATUS_SUCCESS;
01460     <span class="keywordflow">if</span> (Length != AdditionalData-&gt;Length) {
01461         m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
01462     }
01463 
01464     <span class="comment">//</span>
01465     <span class="comment">// Set the actual number of bytes written, initialize the message header,</span>
01466     <span class="comment">// and send the reply packet to the host debugger.</span>
01467     <span class="comment">//</span>
01468 
01469     m-&gt;u.WriteMemory.ActualBytesWritten = Length;
01470     MessageHeader.Length = <span class="keyword">sizeof</span>(DBGKD_MANIPULATE_STATE64);
01471     MessageHeader.Buffer = (PCHAR)m;
01472     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(PACKET_TYPE_KD_STATE_MANIPULATE,
01473                   &amp;MessageHeader,
01474                   <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
01475 
01476     <span class="keywordflow">return</span>;
01477 <span class="preprocessor">#endif</span>
01478 <span class="preprocessor"></span>}
01479 
01480 <span class="preprocessor">#if 0</span>
01481 <span class="preprocessor"></span><a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01482 <a class="code" href="../../d0/d7/kdp_8h.html#a112">KdpWriteVirtualMemory64</a>(
01483     IN PDBGKD_MANIPULATE_STATE64 m,
01484     IN PSTRING AdditionalData,
01485     IN PCONTEXT Context
01486     )
01487 
01488 <span class="comment">/*++</span>
01489 <span class="comment"></span>
01490 <span class="comment">Routine Description:</span>
01491 <span class="comment"></span>
01492 <span class="comment">    This function is called in response of a write virtual memory 64-bit</span>
01493 <span class="comment">    state manipulation message. Its function is to write virtual memory</span>
01494 <span class="comment">    and return.</span>
01495 <span class="comment"></span>
01496 <span class="comment">Arguments:</span>
01497 <span class="comment"></span>
01498 <span class="comment">    m - Supplies a pointer to the state manipulation message.</span>
01499 <span class="comment"></span>
01500 <span class="comment">    AdditionalData - Supplies a pointer to a descriptor for the data to write.</span>
01501 <span class="comment"></span>
01502 <span class="comment">    Context - Supplies a pointer to the current context.</span>
01503 <span class="comment"></span>
01504 <span class="comment">Return Value:</span>
01505 <span class="comment"></span>
01506 <span class="comment">    None.</span>
01507 <span class="comment"></span>
01508 <span class="comment">--*/</span>
01509 
01510 {
01511 
01512     UCHAR * POINTER_64 Address;
01513     UCHAR * POINTER_64 Destination;
01514     ULONG Length;
01515     STRING MessageHeader;
01516     PUCHAR Source;
01517     ULONG_PTR Opaque;
01518 
01519     <span class="comment">//</span>
01520     <span class="comment">// Move the data to the destination buffer.</span>
01521     <span class="comment">//</span>
01522 
01523     Length = AdditionalData-&gt;Length;
01524 
01525 <span class="preprocessor">#if defined(_MIPS_) || defined(_ALPHA_)</span>
01526 <span class="preprocessor"></span>
01527     Destination = (UCHAR * POINTER_64)m-&gt;u.WriteMemory64.TargetBaseAddress;
01528     Source = AdditionalData-&gt;Buffer;
01529     <span class="keywordflow">while</span> (Length &gt; 0) {
01530         <span class="keywordflow">if</span> ((Address = <a class="code" href="../../d4/d6/ppc_2debugsup_8c.html#a3">MmDbgWriteCheck64</a>(Destination, &amp;Opaque)) == NULL64) {
01531             <span class="keywordflow">break</span>;
01532         }
01533 
01534         *Address = *Source++;
01535         Destination += 1;
01536         Length -= 1;
01537     }
01538 
01539 <span class="preprocessor">#endif</span>
01540 <span class="preprocessor"></span>
01541     <span class="comment">//</span>
01542     <span class="comment">// If all the data is written, then return a success status. Otherwise,</span>
01543     <span class="comment">// return an unsuccessful status.</span>
01544     <span class="comment">//</span>
01545 
01546     m-&gt;ReturnStatus = STATUS_SUCCESS;
01547     <span class="keywordflow">if</span> (Length != 0) {
01548         m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
01549     }
01550 
01551     <span class="comment">//</span>
01552     <span class="comment">// Set the actual number of bytes written, initialize the message header,</span>
01553     <span class="comment">// and send the reply packet to the host debugger.</span>
01554     <span class="comment">//</span>
01555 
01556     m-&gt;u.WriteMemory64.ActualBytesWritten = AdditionalData-&gt;Length - Length;
01557     MessageHeader.Length = <span class="keyword">sizeof</span>(DBGKD_MANIPULATE_STATE64);
01558     MessageHeader.Buffer = (PCHAR)m;
01559     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(PACKET_TYPE_KD_STATE_MANIPULATE,
01560                   &amp;MessageHeader,
01561                   NULL);
01562 
01563     <span class="keywordflow">return</span>;
01564 }
01565 <span class="preprocessor">#endif</span>
01566 <span class="preprocessor"></span>
01567 
01568 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01569"></a><a class="code" href="../../d1/d7/4_2kdp_8h.html#a128">01569</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a128">KdpGetContext</a>(
01570     IN PDBGKD_MANIPULATE_STATE64 m,
01571     IN PSTRING AdditionalData,
01572     IN PCONTEXT Context
01573     )
01574 
01575 <span class="comment">/*++</span>
01576 <span class="comment"></span>
01577 <span class="comment">Routine Description:</span>
01578 <span class="comment"></span>
01579 <span class="comment">    This function is called in response of a get context state</span>
01580 <span class="comment">    manipulation message.  Its function is to return the current</span>
01581 <span class="comment">    context.</span>
01582 <span class="comment"></span>
01583 <span class="comment">Arguments:</span>
01584 <span class="comment"></span>
01585 <span class="comment">    m - Supplies the state manipulation message.</span>
01586 <span class="comment"></span>
01587 <span class="comment">    AdditionalData - Supplies any additional data for the message.</span>
01588 <span class="comment"></span>
01589 <span class="comment">    Context - Supplies the current context.</span>
01590 <span class="comment"></span>
01591 <span class="comment">Return Value:</span>
01592 <span class="comment"></span>
01593 <span class="comment">    None.</span>
01594 <span class="comment"></span>
01595 <span class="comment">--*/</span>
01596 
01597 {
01598     PDBGKD_GET_CONTEXT a = &amp;m-&gt;u.GetContext;
01599     STRING MessageHeader;
01600 
01601     MessageHeader.Length = <span class="keyword">sizeof</span>(*m);
01602     MessageHeader.Buffer = (PCHAR)m;
01603 
01604     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(AdditionalData-&gt;Length == 0);
01605 
01606     <span class="keywordflow">if</span> (m-&gt;Processor &gt;= (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d4/d9/ke_8h.html#a133">KeNumberProcessors</a>) {
01607         m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
01608     } <span class="keywordflow">else</span> {
01609         m-&gt;ReturnStatus = STATUS_SUCCESS;
01610         AdditionalData-&gt;Length = <span class="keyword">sizeof</span>(CONTEXT);
01611         <span class="keywordflow">if</span> (m-&gt;Processor == (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a2">KeGetCurrentPrcb</a>()-&gt;Number) {
01612             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a111">KdpQuickMoveMemory</a>(AdditionalData-&gt;Buffer, (PCHAR)Context, <span class="keyword">sizeof</span>(CONTEXT));
01613         } <span class="keywordflow">else</span> {
01614             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a111">KdpQuickMoveMemory</a>(AdditionalData-&gt;Buffer,
01615                           (PCHAR)&amp;<a class="code" href="../../d4/d9/ke_8h.html#a139">KiProcessorBlock</a>[m-&gt;Processor]-&gt;ProcessorState.ContextFrame,
01616                           <span class="keyword">sizeof</span>(CONTEXT)
01617                          );
01618         }
01619     }
01620 
01621     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(
01622                   PACKET_TYPE_KD_STATE_MANIPULATE,
01623                   &amp;MessageHeader,
01624                   AdditionalData
01625                   );
01626 }
01627 
01628 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01629"></a><a class="code" href="../../d1/d7/4_2kdp_8h.html#a129">01629</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a129">KdpSetContext</a>(
01630     IN PDBGKD_MANIPULATE_STATE64 m,
01631     IN PSTRING AdditionalData,
01632     IN PCONTEXT Context
01633     )
01634 
01635 <span class="comment">/*++</span>
01636 <span class="comment"></span>
01637 <span class="comment">Routine Description:</span>
01638 <span class="comment"></span>
01639 <span class="comment">    This function is called in response of a set context state</span>
01640 <span class="comment">    manipulation message.  Its function is set the current</span>
01641 <span class="comment">    context.</span>
01642 <span class="comment"></span>
01643 <span class="comment">Arguments:</span>
01644 <span class="comment"></span>
01645 <span class="comment">    m - Supplies the state manipulation message.</span>
01646 <span class="comment"></span>
01647 <span class="comment">    AdditionalData - Supplies any additional data for the message.</span>
01648 <span class="comment"></span>
01649 <span class="comment">    Context - Supplies the current context.</span>
01650 <span class="comment"></span>
01651 <span class="comment">Return Value:</span>
01652 <span class="comment"></span>
01653 <span class="comment">    None.</span>
01654 <span class="comment"></span>
01655 <span class="comment">--*/</span>
01656 
01657 {
01658     PDBGKD_SET_CONTEXT a = &amp;m-&gt;u.SetContext;
01659     STRING MessageHeader;
01660 
01661     MessageHeader.Length = <span class="keyword">sizeof</span>(*m);
01662     MessageHeader.Buffer = (PCHAR)m;
01663 
01664     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(AdditionalData-&gt;Length == <span class="keyword">sizeof</span>(CONTEXT));
01665 
01666     <span class="keywordflow">if</span> (m-&gt;Processor &gt;= (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d4/d9/ke_8h.html#a133">KeNumberProcessors</a>) {
01667         m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
01668     } <span class="keywordflow">else</span> {
01669         m-&gt;ReturnStatus = STATUS_SUCCESS;
01670         <span class="keywordflow">if</span> (m-&gt;Processor == (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a2">KeGetCurrentPrcb</a>()-&gt;Number) {
01671             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a111">KdpQuickMoveMemory</a>((PCHAR)Context, AdditionalData-&gt;Buffer, <span class="keyword">sizeof</span>(CONTEXT));
01672         } <span class="keywordflow">else</span> {
01673             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a111">KdpQuickMoveMemory</a>((PCHAR)&amp;<a class="code" href="../../d4/d9/ke_8h.html#a139">KiProcessorBlock</a>[m-&gt;Processor]-&gt;ProcessorState.ContextFrame,
01674                           AdditionalData-&gt;Buffer,
01675                           <span class="keyword">sizeof</span>(CONTEXT)
01676                          );
01677         }
01678     }
01679 
01680     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(
01681                   PACKET_TYPE_KD_STATE_MANIPULATE,
01682                   &amp;MessageHeader,
01683                   <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
01684                   );
01685 }
01686 
01687 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01688"></a><a class="code" href="../../d1/d7/4_2kdp_8h.html#a130">01688</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a130">KdpWriteBreakpoint</a>(
01689     IN PDBGKD_MANIPULATE_STATE64 m,
01690     IN PSTRING AdditionalData,
01691     IN PCONTEXT Context
01692     )
01693 
01694 <span class="comment">/*++</span>
01695 <span class="comment"></span>
01696 <span class="comment">Routine Description:</span>
01697 <span class="comment"></span>
01698 <span class="comment">    This function is called in response of a write breakpoint state</span>
01699 <span class="comment">    manipulation message.  Its function is to write a breakpoint</span>
01700 <span class="comment">    and return a handle to the breakpoint.</span>
01701 <span class="comment"></span>
01702 <span class="comment">Arguments:</span>
01703 <span class="comment"></span>
01704 <span class="comment">    m - Supplies the state manipulation message.</span>
01705 <span class="comment"></span>
01706 <span class="comment">    AdditionalData - Supplies any additional data for the message.</span>
01707 <span class="comment"></span>
01708 <span class="comment">    Context - Supplies the current context.</span>
01709 <span class="comment"></span>
01710 <span class="comment">Return Value:</span>
01711 <span class="comment"></span>
01712 <span class="comment">    None.</span>
01713 <span class="comment"></span>
01714 <span class="comment">--*/</span>
01715 
01716 {
01717     PDBGKD_WRITE_BREAKPOINT64 a = &amp;m-&gt;u.WriteBreakPoint;
01718     STRING MessageHeader;
01719 
01720     MessageHeader.Length = <span class="keyword">sizeof</span>(*m);
01721     MessageHeader.Buffer = (PCHAR)m;
01722 
01723     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(AdditionalData-&gt;Length == 0);
01724 
01725     a-&gt;BreakPointHandle = <a class="code" href="../../d1/d7/4_2kdp_8h.html#a104">KdpAddBreakpoint</a>((PVOID)a-&gt;BreakPointAddress);
01726     <span class="keywordflow">if</span> (a-&gt;BreakPointHandle != 0) {
01727         m-&gt;ReturnStatus = STATUS_SUCCESS;
01728     } <span class="keywordflow">else</span> {
01729         m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
01730     }
01731     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(
01732                   PACKET_TYPE_KD_STATE_MANIPULATE,
01733                   &amp;MessageHeader,
01734                   <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
01735                   );
01736     UNREFERENCED_PARAMETER(Context);
01737 }
01738 
01739 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01740"></a><a class="code" href="../../d1/d7/4_2kdp_8h.html#a131">01740</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a131">KdpRestoreBreakpoint</a>(
01741     IN PDBGKD_MANIPULATE_STATE64 m,
01742     IN PSTRING AdditionalData,
01743     IN PCONTEXT Context
01744     )
01745 
01746 <span class="comment">/*++</span>
01747 <span class="comment"></span>
01748 <span class="comment">Routine Description:</span>
01749 <span class="comment"></span>
01750 <span class="comment">    This function is called in response of a restore breakpoint state</span>
01751 <span class="comment">    manipulation message.  Its function is to restore a breakpoint</span>
01752 <span class="comment">    using the specified handle.</span>
01753 <span class="comment"></span>
01754 <span class="comment">Arguments:</span>
01755 <span class="comment"></span>
01756 <span class="comment">    m - Supplies the state manipulation message.</span>
01757 <span class="comment"></span>
01758 <span class="comment">    AdditionalData - Supplies any additional data for the message.</span>
01759 <span class="comment"></span>
01760 <span class="comment">    Context - Supplies the current context.</span>
01761 <span class="comment"></span>
01762 <span class="comment">Return Value:</span>
01763 <span class="comment"></span>
01764 <span class="comment">    None.</span>
01765 <span class="comment"></span>
01766 <span class="comment">--*/</span>
01767 
01768 {
01769     PDBGKD_RESTORE_BREAKPOINT a = &amp;m-&gt;u.RestoreBreakPoint;
01770     STRING MessageHeader;
01771 
01772     MessageHeader.Length = <span class="keyword">sizeof</span>(*m);
01773     MessageHeader.Buffer = (PCHAR)m;
01774 
01775     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(AdditionalData-&gt;Length == 0);
01776     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d7/4_2kdp_8h.html#a105">KdpDeleteBreakpoint</a>(a-&gt;BreakPointHandle)) {
01777         m-&gt;ReturnStatus = STATUS_SUCCESS;
01778     } <span class="keywordflow">else</span> {
01779         m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
01780     }
01781     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(
01782                   PACKET_TYPE_KD_STATE_MANIPULATE,
01783                   &amp;MessageHeader,
01784                   <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
01785                   );
01786     UNREFERENCED_PARAMETER(Context);
01787 }
01788 
01789 <span class="preprocessor">#if i386</span>
01790 <span class="preprocessor"></span><span class="keywordtype">long</span>
01791 SymNumFor(
01792     ULONG pc
01793     )
01794 {
01795     ULONG index;
01796 
01797     <span class="keywordflow">for</span> (index = 0; index &lt; <a class="code" href="../../d8/d5/kddata_8c.html#a73">NumTraceDataSyms</a>; index++) {
01798         <span class="keywordflow">if</span> ((<a class="code" href="../../d8/d5/kddata_8c.html#a71">TraceDataSyms</a>[index].<a class="code" href="../../d9/d1/struct__TRACE__DATA__SYM.html#o0">SymMin</a> &lt;= pc) &amp;&amp;
01799             (<a class="code" href="../../d8/d5/kddata_8c.html#a71">TraceDataSyms</a>[index].<a class="code" href="../../d9/d1/struct__TRACE__DATA__SYM.html#o1">SymMax</a> &gt; pc)) <span class="keywordflow">return</span>(index);
01800     }
01801     <span class="keywordflow">return</span>(-1);
01802 }
01803 
01804 BOOLEAN TraceDataBufferFilled = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01805 
01806 <span class="keywordtype">void</span> PotentialNewSymbol (ULONG pc)
01807 {
01808     <span class="keywordflow">if</span> (!TraceDataBufferFilled &amp;&amp;
01809         -1 != SymNumFor(pc)) {     <span class="comment">// we've already seen this one</span>
01810         <span class="keywordflow">return</span>;
01811     }
01812 
01813     TraceDataBufferFilled = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01814 
01815     <span class="comment">// OK, we've got to start up a TraceDataRecord</span>
01816     <a class="code" href="../../d8/d5/kddata_8c.html#a69">TraceDataBuffer</a>[<a class="code" href="../../d8/d5/kddata_8c.html#a70">TraceDataBufferPosition</a>].s.LevelChange = 0;
01817 
01818     <span class="keywordflow">if</span> (-1 != SymNumFor(pc)) {
01819         <span class="keywordtype">int</span> sym = SymNumFor(pc);
01820         <a class="code" href="../../d8/d5/kddata_8c.html#a69">TraceDataBuffer</a>[<a class="code" href="../../d8/d5/kddata_8c.html#a70">TraceDataBufferPosition</a>].s.SymbolNumber = (UCHAR) sym;
01821         <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a1">KdpCurrentSymbolStart</a> = <a class="code" href="../../d8/d5/kddata_8c.html#a71">TraceDataSyms</a>[sym].<a class="code" href="../../d9/d1/struct__TRACE__DATA__SYM.html#o0">SymMin</a>;
01822         <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a2">KdpCurrentSymbolEnd</a> = <a class="code" href="../../d8/d5/kddata_8c.html#a71">TraceDataSyms</a>[sym].<a class="code" href="../../d9/d1/struct__TRACE__DATA__SYM.html#o1">SymMax</a>;
01823 
01824         <span class="keywordflow">return</span>;  <span class="comment">// we've already seen this one</span>
01825     }
01826 
01827     <a class="code" href="../../d8/d5/kddata_8c.html#a71">TraceDataSyms</a>[<a class="code" href="../../d8/d5/kddata_8c.html#a72">NextTraceDataSym</a>].<a class="code" href="../../d9/d1/struct__TRACE__DATA__SYM.html#o0">SymMin</a> = <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a1">KdpCurrentSymbolStart</a>;
01828     <a class="code" href="../../d8/d5/kddata_8c.html#a71">TraceDataSyms</a>[<a class="code" href="../../d8/d5/kddata_8c.html#a72">NextTraceDataSym</a>].<a class="code" href="../../d9/d1/struct__TRACE__DATA__SYM.html#o1">SymMax</a> = <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a2">KdpCurrentSymbolEnd</a>;
01829 
01830     <a class="code" href="../../d8/d5/kddata_8c.html#a69">TraceDataBuffer</a>[<a class="code" href="../../d8/d5/kddata_8c.html#a70">TraceDataBufferPosition</a>].s.SymbolNumber = <a class="code" href="../../d8/d5/kddata_8c.html#a72">NextTraceDataSym</a>;
01831 
01832     <span class="comment">// Bump the "next" pointer, wrapping if necessary.  Also bump the</span>
01833     <span class="comment">// "valid" pointer if we need to.</span>
01834     <a class="code" href="../../d8/d5/kddata_8c.html#a72">NextTraceDataSym</a> = (<a class="code" href="../../d8/d5/kddata_8c.html#a72">NextTraceDataSym</a> + 1) % 256;
01835     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a73">NumTraceDataSyms</a> &lt; <a class="code" href="../../d8/d5/kddata_8c.html#a72">NextTraceDataSym</a>) {
01836         <a class="code" href="../../d8/d5/kddata_8c.html#a73">NumTraceDataSyms</a> = <a class="code" href="../../d8/d5/kddata_8c.html#a72">NextTraceDataSym</a>;
01837     }
01838 
01839 }
01840 
01841 <span class="keywordtype">void</span> DumpTraceData(PSTRING MessageData)
01842 {
01843 
01844  <a class="code" href="../../d8/d5/kddata_8c.html#a69">TraceDataBuffer</a>[0].LongNumber = <a class="code" href="../../d8/d5/kddata_8c.html#a70">TraceDataBufferPosition</a>;
01845  MessageData-&gt;Length = <span class="keyword">sizeof</span>(<a class="code" href="../../d8/d5/kddata_8c.html#a69">TraceDataBuffer</a>[0]) * <a class="code" href="../../d8/d5/kddata_8c.html#a70">TraceDataBufferPosition</a>;
01846  MessageData-&gt;Buffer = (PVOID)<a class="code" href="../../d8/d5/kddata_8c.html#a69">TraceDataBuffer</a>;
01847  <a class="code" href="../../d8/d5/kddata_8c.html#a70">TraceDataBufferPosition</a> = 1;
01848 }
01849 
01850 BOOLEAN
01851 TraceDataRecordCallInfo(
01852     ULONG InstructionsTraced,
01853     LONG CallLevelChange,
01854     ULONG pc
01855     )
01856 {
01857     <span class="comment">// We've just exited a symbol scope.  The InstructionsTraced number goes</span>
01858     <span class="comment">// with the old scope, the CallLevelChange goes with the new, and the</span>
01859     <span class="comment">// pc fills in the symbol for the new TraceData record.</span>
01860 
01861     <span class="keywordtype">long</span> SymNum = SymNumFor(pc);
01862 
01863     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a61">KdpNextCallLevelChange</a> != 0) {
01864         <a class="code" href="../../d8/d5/kddata_8c.html#a69">TraceDataBuffer</a>[<a class="code" href="../../d8/d5/kddata_8c.html#a70">TraceDataBufferPosition</a>].s.LevelChange =
01865                                                 (<span class="keywordtype">char</span>) <a class="code" href="../../d8/d5/kddata_8c.html#a61">KdpNextCallLevelChange</a>;
01866         <a class="code" href="../../d8/d5/kddata_8c.html#a61">KdpNextCallLevelChange</a> = 0;
01867     }
01868 
01869 
01870     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a81">InstructionsTraced</a> &gt;= TRACE_DATA_INSTRUCTIONS_BIG) {
01871        <a class="code" href="../../d8/d5/kddata_8c.html#a69">TraceDataBuffer</a>[<a class="code" href="../../d8/d5/kddata_8c.html#a70">TraceDataBufferPosition</a>].s.Instructions =
01872            TRACE_DATA_INSTRUCTIONS_BIG;
01873        <a class="code" href="../../d8/d5/kddata_8c.html#a69">TraceDataBuffer</a>[<a class="code" href="../../d8/d5/kddata_8c.html#a70">TraceDataBufferPosition</a>+1].LongNumber =
01874            <a class="code" href="../../d8/d5/kddata_8c.html#a81">InstructionsTraced</a>;
01875        <a class="code" href="../../d8/d5/kddata_8c.html#a70">TraceDataBufferPosition</a> += 2;
01876     } <span class="keywordflow">else</span> {
01877        <a class="code" href="../../d8/d5/kddata_8c.html#a69">TraceDataBuffer</a>[<a class="code" href="../../d8/d5/kddata_8c.html#a70">TraceDataBufferPosition</a>].s.Instructions =
01878            (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>)<a class="code" href="../../d8/d5/kddata_8c.html#a81">InstructionsTraced</a>;
01879        <a class="code" href="../../d8/d5/kddata_8c.html#a70">TraceDataBufferPosition</a>++;
01880     }
01881 
01882     <span class="keywordflow">if</span> ((<a class="code" href="../../d8/d5/kddata_8c.html#a70">TraceDataBufferPosition</a> + 2 &gt;= TRACE_DATA_BUFFER_MAX_SIZE) ||
01883         (-1 == SymNum)) {
01884         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a70">TraceDataBufferPosition</a> +2 &gt;= TRACE_DATA_BUFFER_MAX_SIZE) {
01885             TraceDataBufferFilled = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01886         }
01887        <a class="code" href="../../d8/d5/kddata_8c.html#a61">KdpNextCallLevelChange</a> = <a class="code" href="../../d8/d5/kddata_8c.html#a83">CallLevelChange</a>;
01888        <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01889     }
01890 
01891     <a class="code" href="../../d8/d5/kddata_8c.html#a69">TraceDataBuffer</a>[<a class="code" href="../../d8/d5/kddata_8c.html#a70">TraceDataBufferPosition</a>].s.LevelChange =(<span class="keywordtype">char</span>)<a class="code" href="../../d8/d5/kddata_8c.html#a83">CallLevelChange</a>;
01892     <a class="code" href="../../d8/d5/kddata_8c.html#a69">TraceDataBuffer</a>[<a class="code" href="../../d8/d5/kddata_8c.html#a70">TraceDataBufferPosition</a>].s.SymbolNumber = (UCHAR) SymNum;
01893     <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a1">KdpCurrentSymbolStart</a> = <a class="code" href="../../d8/d5/kddata_8c.html#a71">TraceDataSyms</a>[SymNum].<a class="code" href="../../d9/d1/struct__TRACE__DATA__SYM.html#o0">SymMin</a>;
01894     <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a2">KdpCurrentSymbolEnd</a> = <a class="code" href="../../d8/d5/kddata_8c.html#a71">TraceDataSyms</a>[SymNum].<a class="code" href="../../d9/d1/struct__TRACE__DATA__SYM.html#o1">SymMax</a>;
01895 
01896     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01897 }
01898 
01899 BOOLEAN
01900 SkippingWhichBP (
01901     PVOID thread,
01902     PULONG BPNum
01903     )
01904 
01905 <span class="comment">/*</span>
01906 <span class="comment"> * Return TRUE iff the pc corresponds to an internal breakpoint</span>
01907 <span class="comment"> * that has just been replaced for execution.  If TRUE, then return</span>
01908 <span class="comment"> * the breakpoint number in BPNum.</span>
01909 <span class="comment"> */</span>
01910 
01911 {
01912     ULONG index;
01913 
01914     <span class="keywordflow">if</span> (!<a class="code" href="../../d8/d5/kddata_8c.html#a74">IntBPsSkipping</a>) <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01915 
01916     <span class="keywordflow">for</span> (index = 0; index &lt; <a class="code" href="../../d8/d5/kddata_8c.html#a65">KdpNumInternalBreakpoints</a>; index++) {
01917         <span class="keywordflow">if</span> (!(<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[index].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o1">Flags</a> &amp; DBGKD_INTERNAL_BP_FLAG_INVALID) &amp;&amp;
01918             (<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[index].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o9">Thread</a> == thread)) {
01919             *BPNum = index;
01920             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01921         }
01922     }
01923     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>; <span class="comment">// didn't match any</span>
01924 }
01925 
01926 
01927 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01928 <a class="code" href="../../d1/d7/4_2kdp_8h.html#a107">KdQuerySpecialCalls</a> (
01929     IN PDBGKD_MANIPULATE_STATE64 m,
01930     ULONG Length,
01931     PULONG RequiredLength
01932     )
01933 {
01934     *RequiredLength = <span class="keyword">sizeof</span>(DBGKD_MANIPULATE_STATE64) +
01935                         (<span class="keyword">sizeof</span>(ULONG) * <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a4">KdNumberOfSpecialCalls</a>);
01936 
01937     <span class="keywordflow">if</span> ( Length &lt; *RequiredLength ) {
01938         <span class="keywordflow">return</span> STATUS_INFO_LENGTH_MISMATCH;
01939     }
01940 
01941     m-&gt;u.QuerySpecialCalls.NumberOfSpecialCalls = <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a4">KdNumberOfSpecialCalls</a>;
01942         RtlCopyMemory(
01943         m + 1,
01944         KdSpecialCalls,
01945         <span class="keyword">sizeof</span>(ULONG) * KdNumberOfSpecialCalls
01946         );
01947 
01948     <span class="keywordflow">return</span> STATUS_SUCCESS;
01949 
01950 } <span class="comment">// KdQuerySpecialCalls</span>
01951 
01952 
01953 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01954 <a class="code" href="../../d1/d7/4_2kdp_8h.html#a108">KdSetSpecialCall</a> (
01955     IN PDBGKD_MANIPULATE_STATE64 m,
01956     IN PCONTEXT ContextRecord
01957     )
01958 
01959 <span class="comment">/*++</span>
01960 <span class="comment"></span>
01961 <span class="comment">Routine Description:</span>
01962 <span class="comment"></span>
01963 <span class="comment">    This function sets the addresses of the "special" call addresses</span>
01964 <span class="comment">    that the watchtrace facility pushes back to the kernel debugger</span>
01965 <span class="comment">    rather than stepping through.</span>
01966 <span class="comment"></span>
01967 <span class="comment">Arguments:</span>
01968 <span class="comment"></span>
01969 <span class="comment">    m - Supplies the state manipulation message.</span>
01970 <span class="comment"></span>
01971 <span class="comment">Return Value:</span>
01972 <span class="comment"></span>
01973 <span class="comment">    None.</span>
01974 <span class="comment">--*/</span>
01975 
01976 {
01977     <span class="keywordflow">if</span> ( <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a4">KdNumberOfSpecialCalls</a> &gt;= <a class="code" href="../../d0/d7/kdp_8h.html#a13">DBGKD_MAX_SPECIAL_CALLS</a> ) {
01978         <span class="keywordflow">return</span>; <span class="comment">// too bad</span>
01979     }
01980 
01981     <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a3">KdSpecialCalls</a>[<a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a4">KdNumberOfSpecialCalls</a>++] = (ULONG_PTR)m-&gt;u.SetSpecialCall.SpecialCall;
01982 
01983     <a class="code" href="../../d8/d5/kddata_8c.html#a72">NextTraceDataSym</a> = 0;
01984     <a class="code" href="../../d8/d5/kddata_8c.html#a73">NumTraceDataSyms</a> = 0;
01985     <a class="code" href="../../d8/d5/kddata_8c.html#a61">KdpNextCallLevelChange</a> = 0;
01986     <span class="keywordflow">if</span> (ContextRecord &amp;&amp; !<a class="code" href="../../d8/d5/kddata_8c.html#a85">InstrCountInternal</a>) {
01987         <a class="code" href="../../d8/d5/kddata_8c.html#a64">InitialSP</a> = ContextRecord-&gt;Esp;
01988     }
01989 
01990 } <span class="comment">// KdSetSpecialCall</span>
01991 
01992 
01993 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01994 <a class="code" href="../../d1/d7/4_2kdp_8h.html#a109">KdClearSpecialCalls</a> (
01995     VOID
01996     )
01997 
01998 <span class="comment">/*++</span>
01999 <span class="comment"></span>
02000 <span class="comment">Routine Description:</span>
02001 <span class="comment"></span>
02002 <span class="comment">    This function clears the addresses of the "special" call addresses</span>
02003 <span class="comment">    that the watchtrace facility pushes back to the kernel debugger</span>
02004 <span class="comment">    rather than stepping through.</span>
02005 <span class="comment"></span>
02006 <span class="comment">Arguments:</span>
02007 <span class="comment"></span>
02008 <span class="comment">    None.</span>
02009 <span class="comment"></span>
02010 <span class="comment">Return Value:</span>
02011 <span class="comment"></span>
02012 <span class="comment">    None.</span>
02013 <span class="comment"></span>
02014 <span class="comment">--*/</span>
02015 
02016 {
02017     <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a4">KdNumberOfSpecialCalls</a> = 0;
02018     <span class="keywordflow">return</span>;
02019 
02020 } <span class="comment">// KdClearSpecialCalls</span>
02021 
02022 
02023 BOOLEAN
02024 <a class="code" href="../../d2/d9/4_2i386_2kdtrap_8c.html#a3">KdpCheckTracePoint</a>(
02025     IN PEXCEPTION_RECORD ExceptionRecord,
02026     IN OUT PCONTEXT ContextRecord
02027     )
02028 {
02029     ULONG pc = (ULONG)CONTEXT_TO_PROGRAM_COUNTER(ContextRecord);
02030     LONG BpNum;
02031     ULONG SkippedBPNum;
02032     BOOLEAN AfterSC = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02033 
02034     <span class="keywordflow">if</span> (ExceptionRecord-&gt;ExceptionCode == STATUS_SINGLE_STEP) {
02035         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a80">WatchStepOverSuspended</a>) {
02036             <span class="comment">//</span>
02037             <span class="comment">//  For background, see the comment below where WSOThread is</span>
02038             <span class="comment">//  wrong.  We've now stepped over the breakpoint in the non-traced</span>
02039             <span class="comment">//  thread, and need to replace it and restart the non-traced</span>
02040             <span class="comment">//  thread at full speed.</span>
02041             <span class="comment">//</span>
02042 
02043             <a class="code" href="../../d8/d5/kddata_8c.html#a78">WatchStepOverHandle</a> = <a class="code" href="../../d1/d7/4_2kdp_8h.html#a104">KdpAddBreakpoint</a>((PVOID)WatchStepOverBreakAddr);
02044             <a class="code" href="../../d8/d5/kddata_8c.html#a80">WatchStepOverSuspended</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02045             ContextRecord-&gt;EFlags &amp;= ~0x100<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>; <span class="comment">/* clear trace flag */</span>
02046             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>; <span class="comment">// resume non-traced thread at full speed</span>
02047         }
02048 
02049         <span class="keywordflow">if</span> ((!<a class="code" href="../../d8/d5/kddata_8c.html#a82">SymbolRecorded</a>) &amp;&amp; (<a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a1">KdpCurrentSymbolStart</a> != 0) &amp;&amp; (<a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a2">KdpCurrentSymbolEnd</a> != 0)) {
02050             <span class="comment">//</span>
02051             <span class="comment">//  We need to use oldpc here, because this may have been</span>
02052             <span class="comment">//  a 1 instruction call.  We've ALREADY executed the instruction</span>
02053             <span class="comment">//  that the new symbol is for, and if the pc has moved out of</span>
02054             <span class="comment">//  range, we might screw up.  Hence, use the pc from when</span>
02055             <span class="comment">//  SymbolRecorded was set.  Yuck.</span>
02056             <span class="comment">//</span>
02057 
02058             PotentialNewSymbol(oldpc);
02059             <a class="code" href="../../d8/d5/kddata_8c.html#a82">SymbolRecorded</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02060         }
02061 
02062         <span class="keywordflow">if</span> (!<a class="code" href="../../d8/d5/kddata_8c.html#a85">InstrCountInternal</a> &amp;&amp;
02063             SkippingWhichBP((PVOID)<a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>(),&amp;SkippedBPNum)) {
02064 
02065             <span class="comment">//</span>
02066             <span class="comment">//  We just single-stepped over a temporarily removed internal</span>
02067             <span class="comment">//  breakpoint.</span>
02068             <span class="comment">//  If it's a COUNTONLY breakpoint:</span>
02069             <span class="comment">//      Put the breakpoint instruction back and resume</span>
02070             <span class="comment">//      regular execution.</span>
02071             <span class="comment">//</span>
02072 
02073             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[SkippedBPNum].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o1">Flags</a> &amp;
02074                 DBGKD_INTERNAL_BP_FLAG_COUNTONLY) {
02075 
02076                 <a class="code" href="../../d8/d5/kddata_8c.html#a74">IntBPsSkipping</a> --;
02077 
02078                 <a class="code" href="../../d1/d7/4_2kdp_8h.html#a140">KdpRestoreAllBreakpoints</a>();
02079 
02080                 ContextRecord-&gt;EFlags &amp;= ~0x100<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>;  <span class="comment">// Clear trace flag</span>
02081                 <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[SkippedBPNum].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o9">Thread</a> = 0;
02082 
02083                 <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[SkippedBPNum].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o1">Flags</a> &amp;
02084                         DBGKD_INTERNAL_BP_FLAG_DYING) {
02085                     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a105">KdpDeleteBreakpoint</a>(KdpInternalBPs[SkippedBPNum].Handle);
02086                     <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[SkippedBPNum].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o1">Flags</a> |=
02087                             DBGKD_INTERNAL_BP_FLAG_INVALID; <span class="comment">// bye, bye</span>
02088                 }
02089 
02090                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02091             }
02092 
02093             <span class="comment">//</span>
02094             <span class="comment">//  If it's not:</span>
02095             <span class="comment">//      set up like it's a ww, by setting Begin and KdpCurrentSymbolEnd</span>
02096             <span class="comment">//      and bop off into single step land.  We probably ought to</span>
02097             <span class="comment">//      disable all breakpoints here, too, so that we don't do</span>
02098             <span class="comment">//      anything foul like trying two non-COUNTONLY's at the</span>
02099             <span class="comment">//      same time or something...</span>
02100             <span class="comment">//</span>
02101 
02102             <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a2">KdpCurrentSymbolEnd</a> = 0;
02103             <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a1">KdpCurrentSymbolStart</a> = (ULONG_PTR) <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[SkippedBPNum].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o10">ReturnAddress</a>;
02104 
02105             ContextRecord-&gt;EFlags |= 0x100<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>; <span class="comment">/* Trace on. */</span>
02106             <a class="code" href="../../d8/d5/kddata_8c.html#a64">InitialSP</a> = ContextRecord-&gt;Esp;
02107 
02108             <a class="code" href="../../d8/d5/kddata_8c.html#a81">InstructionsTraced</a> = 1;  <span class="comment">/* Count the initial call instruction. */</span>
02109             <a class="code" href="../../d8/d5/kddata_8c.html#a85">InstrCountInternal</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02110         }
02111 
02112     } <span class="comment">/* if single step */</span>
02113     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ExceptionRecord-&gt;ExceptionCode == STATUS_BREAKPOINT) {
02114         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a75">WatchStepOver</a> &amp;&amp; pc == <a class="code" href="../../d8/d5/kddata_8c.html#a79">WatchStepOverBreakAddr</a>) {
02115             <span class="comment">//</span>
02116             <span class="comment">//  This is a breakpoint after completion of a "special call"</span>
02117             <span class="comment">//</span>
02118 
02119             <span class="keywordflow">if</span> ((<a class="code" href="../../d8/d5/kddata_8c.html#a76">WSOThread</a> != (PVOID)<a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>()) ||
02120                 (<a class="code" href="../../d8/d5/kddata_8c.html#a77">WSOEsp</a> + 0x20 &lt; ContextRecord-&gt;Esp) ||
02121                 (ContextRecord-&gt;Esp + 0x20 &lt; <a class="code" href="../../d8/d5/kddata_8c.html#a77">WSOEsp</a>)) {
02122                 <span class="comment">//</span>
02123                 <span class="comment">//  Here's the story up to this point: the traced thread</span>
02124                 <span class="comment">//  cruised along until it it a special call.  The tracer</span>
02125                 <span class="comment">//  placed a breakpoint on the instruction immediately after</span>
02126                 <span class="comment">//  the special call returns and restarted the traced thread</span>
02127                 <span class="comment">//  at full speed.  Then, some *other* thread hit the</span>
02128                 <span class="comment">//  breakpoint.  So, to correct for this, we're going to</span>
02129                 <span class="comment">//  remove the breakpoint, single step the non-traced</span>
02130                 <span class="comment">//  thread one instruction, replace the breakpoint,</span>
02131                 <span class="comment">//  restart the non-traced thread at full speed, and wait</span>
02132                 <span class="comment">//  for the traced thread to get to this breakpoint, just</span>
02133                 <span class="comment">//  like we were when this happened.  The assumption</span>
02134                 <span class="comment">//  here is that the traced thread won't hit the breakpoint</span>
02135                 <span class="comment">//  while it's removed, which I believe to be true, because</span>
02136                 <span class="comment">//  I don't think a context switch can occur during a single</span>
02137                 <span class="comment">//  step operation.</span>
02138                 <span class="comment">//</span>
02139                 <span class="comment">//  For extra added fun, it's possible to execute interrupt</span>
02140                 <span class="comment">//  routines IN THE SAME THREAD!!!  That's why we need to keep</span>
02141                 <span class="comment">//  the stack pointer as well as the thread address: the APC</span>
02142                 <span class="comment">//  code can result in pushing on the stack and doing a call</span>
02143                 <span class="comment">//  that's really part on an interrupt service routine in the</span>
02144                 <span class="comment">//  context of the current thread.  Lovely, isn't it?</span>
02145                 <span class="comment">//</span>
02146 
02147                 <a class="code" href="../../d8/d5/kddata_8c.html#a80">WatchStepOverSuspended</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02148                 <a class="code" href="../../d1/d7/4_2kdp_8h.html#a105">KdpDeleteBreakpoint</a>(WatchStepOverHandle);
02149                 ContextRecord-&gt;EFlags |= 0x100<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>; <span class="comment">// Set trace flag</span>
02150                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>; <span class="comment">// single step "non-traced" thread</span>
02151             }
02152 
02153             <span class="comment">//</span>
02154             <span class="comment">//  we're in the thread we started in; resume in single-step mode</span>
02155             <span class="comment">//  to continue the trace.</span>
02156             <span class="comment">//</span>
02157 
02158             <a class="code" href="../../d8/d5/kddata_8c.html#a75">WatchStepOver</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02159             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a105">KdpDeleteBreakpoint</a>(WatchStepOverHandle);
02160             ContextRecord-&gt;EFlags |= 0x100<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>; <span class="comment">// back to single step mode</span>
02161             AfterSC = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>; <span class="comment">// put us into the regular watchStep code</span>
02162 
02163         } <span class="keywordflow">else</span> {
02164 
02165             <span class="keywordflow">for</span> ( BpNum = 0; BpNum &lt; (LONG) <a class="code" href="../../d8/d5/kddata_8c.html#a65">KdpNumInternalBreakpoints</a>; BpNum++ ) {
02166                 <span class="keywordflow">if</span> ( !(<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[BpNum].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o1">Flags</a> &amp;
02167                        (DBGKD_INTERNAL_BP_FLAG_INVALID |
02168                         DBGKD_INTERNAL_BP_FLAG_SUSPENDED) ) &amp;&amp;
02169                      (<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[BpNum].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o0">Addr</a> == pc) ) {
02170                     <span class="keywordflow">break</span>;
02171                 }
02172             }
02173 
02174             <span class="keywordflow">if</span> ( BpNum &lt; (LONG) <a class="code" href="../../d8/d5/kddata_8c.html#a65">KdpNumInternalBreakpoints</a> ) {
02175 
02176                 <span class="comment">//</span>
02177                 <span class="comment">//  This is an internal monitoring breakpoint.</span>
02178                 <span class="comment">//  Restore the instruction and start in single-step</span>
02179                 <span class="comment">//  mode so that we can retore the breakpoint once the</span>
02180                 <span class="comment">//  instruction executes, or continue stepping if this isn't</span>
02181                 <span class="comment">//  a COUNTONLY breakpoint.</span>
02182                 <span class="comment">//</span>
02183 
02184                 <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a6">KdpProcessInternalBreakpoint</a>( BpNum );
02185                 <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[BpNum].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o9">Thread</a> = (PVOID)<a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>();
02186                 <a class="code" href="../../d8/d5/kddata_8c.html#a74">IntBPsSkipping</a> ++;
02187 
02188                 <a class="code" href="../../d1/d7/4_2kdp_8h.html#a139">KdpSuspendAllBreakpoints</a>();
02189 
02190                 ContextRecord-&gt;EFlags |= 0x100<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>;  <span class="comment">// Set trace flag</span>
02191                 <span class="keywordflow">if</span> (!(<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[BpNum].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o1">Flags</a> &amp;
02192                         DBGKD_INTERNAL_BP_FLAG_COUNTONLY)) {
02193                     <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[BpNum].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o10">ReturnAddress</a> =
02194                                     <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a8">KdpGetReturnAddress</a>( ContextRecord );
02195                 }
02196                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02197             }
02198         }
02199     } <span class="comment">/* if breakpoint */</span>
02200 
02201 <span class="comment">//  if (AfterSC) {</span>
02202 <span class="comment">//      DPRINT(( "1: KdpCurrentSymbolStart %x  KdpCurrentSymbolEnd %x\n", KdpCurrentSymbolStart, KdpCurrentSymbolEnd ));</span>
02203 <span class="comment">//  }</span>
02204 
02205     <span class="keywordflow">if</span> ((AfterSC || ExceptionRecord-&gt;ExceptionCode == STATUS_SINGLE_STEP) &amp;&amp;
02206         <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a1">KdpCurrentSymbolStart</a> != 0 &amp;&amp;
02207         ((<a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a2">KdpCurrentSymbolEnd</a> == 0 &amp;&amp; ContextRecord-&gt;Esp &lt;= <a class="code" href="../../d8/d5/kddata_8c.html#a64">InitialSP</a>) ||
02208          (<a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a1">KdpCurrentSymbolStart</a> &lt;= pc &amp;&amp; pc &lt; <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a2">KdpCurrentSymbolEnd</a>))) {
02209         ULONG lc;
02210         BOOLEAN IsSpecialCall;
02211 
02212         <span class="comment">//</span>
02213         <span class="comment">//  We've taken a step trace, but are still executing in the current</span>
02214         <span class="comment">//  function.  Remember that we executed an instruction and see if the</span>
02215         <span class="comment">//  instruction changes the call level.</span>
02216         <span class="comment">//</span>
02217 
02218         lc = <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a5">KdpLevelChange</a>( pc, ContextRecord, &amp;IsSpecialCall );
02219         <a class="code" href="../../d8/d5/kddata_8c.html#a81">InstructionsTraced</a>++;
02220         <a class="code" href="../../d8/d5/kddata_8c.html#a83">CallLevelChange</a> += lc;
02221 
02222         <span class="comment">//</span>
02223         <span class="comment">//  See if instruction is a transfer to a special routine, one that we</span>
02224         <span class="comment">//  cannot trace through since it may swap contexts</span>
02225         <span class="comment">//</span>
02226 
02227         <span class="keywordflow">if</span> (IsSpecialCall) {
02228 
02229 <span class="comment">//  DPRINT( ("2: pc=%x, level change %d\n", pc, lc) );</span>
02230 
02231             <span class="comment">//</span>
02232             <span class="comment">//  We are about to transfer to a special call routine.  Since we</span>
02233             <span class="comment">//  cannot trace through this routine, we execute it atomically by</span>
02234             <span class="comment">//  setting a breakpoint at the next logical offset.</span>
02235             <span class="comment">//</span>
02236             <span class="comment">//  Note in the case of an indirect jump to a special call routine, the</span>
02237             <span class="comment">//  level change will be -1 and the next offset will be the ULONG that's</span>
02238             <span class="comment">//  on the top of the stack.</span>
02239             <span class="comment">//</span>
02240             <span class="comment">//  However, we've already adjusted the level based on this</span>
02241             <span class="comment">//  instruction.  We need to undo this except for the magic -1 call.</span>
02242             <span class="comment">//</span>
02243 
02244             <span class="keywordflow">if</span> (lc != -1) {
02245                 <a class="code" href="../../d8/d5/kddata_8c.html#a83">CallLevelChange</a> -= lc;
02246             }
02247 
02248             <span class="comment">//</span>
02249             <span class="comment">//  Set up for stepping over a procedure</span>
02250             <span class="comment">//</span>
02251 
02252             <a class="code" href="../../d8/d5/kddata_8c.html#a75">WatchStepOver</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02253             <a class="code" href="../../d8/d5/kddata_8c.html#a79">WatchStepOverBreakAddr</a> = <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a9">KdpGetCallNextOffset</a>( pc, ContextRecord );
02254             <a class="code" href="../../d8/d5/kddata_8c.html#a76">WSOThread</a> = (PVOID)<a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>( );
02255             <a class="code" href="../../d8/d5/kddata_8c.html#a77">WSOEsp</a> = ContextRecord-&gt;Esp;
02256 
02257             <span class="comment">//</span>
02258             <span class="comment">//  Establish the breakpoint</span>
02259             <span class="comment">//</span>
02260 
02261             <a class="code" href="../../d8/d5/kddata_8c.html#a78">WatchStepOverHandle</a> = <a class="code" href="../../d1/d7/4_2kdp_8h.html#a104">KdpAddBreakpoint</a>( (PVOID)WatchStepOverBreakAddr );
02262 
02263 
02264             <span class="comment">//</span>
02265             <span class="comment">//  Note that we are continuing rather than tracing and rely on hitting</span>
02266             <span class="comment">//  the breakpoint in the current thread context to resume the watch</span>
02267             <span class="comment">//  action.</span>
02268             <span class="comment">//</span>
02269 
02270             ContextRecord-&gt;EFlags &amp;= ~0x100<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>;
02271             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02272         }
02273 
02274         <span class="comment">//</span>
02275         <span class="comment">//  Resume execution with the trace flag set.  Avoid going over the wire to</span>
02276         <span class="comment">//  the remote debugger.</span>
02277         <span class="comment">//</span>
02278 
02279         ContextRecord-&gt;EFlags |= 0x100<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>;  <span class="comment">// Set trace flag</span>
02280 
02281         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02282     }
02283 
02284     <span class="keywordflow">if</span> ((AfterSC || (ExceptionRecord-&gt;ExceptionCode == STATUS_SINGLE_STEP)) &amp;&amp;
02285         (<a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a1">KdpCurrentSymbolStart</a> != 0)) {
02286         <span class="comment">//</span>
02287         <span class="comment">// We're WatchTracing, but have just changed symbol range.</span>
02288         <span class="comment">// Fill in the call record and return to the debugger if</span>
02289         <span class="comment">// either we're full or the pc is outside of the known</span>
02290         <span class="comment">// symbol scopes.  Otherwise, resume stepping.</span>
02291         <span class="comment">//</span>
02292         <span class="keywordtype">int</span> lc;
02293         BOOLEAN IsSpecialCall;
02294 
02295         <a class="code" href="../../d8/d5/kddata_8c.html#a81">InstructionsTraced</a>++; <span class="comment">// don't forget to count the call/ret instruction.</span>
02296 
02297 <span class="comment">//  if (AfterSC) {</span>
02298 <span class="comment">//      DPRINT(( "3: InstrCountInternal: %x\n", InstrCountInternal ));</span>
02299 <span class="comment">//  }</span>
02300 
02301         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a85">InstrCountInternal</a>) {
02302 
02303             <span class="comment">// We've just finished processing a non-COUNTONLY breakpoint.</span>
02304             <span class="comment">// Record the appropriate data and resume full speed execution.</span>
02305 
02306             SkippingWhichBP((PVOID)<a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>(),&amp;SkippedBPNum);
02307 
02308             <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[SkippedBPNum].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o2">Calls</a>++;
02309 
02310 
02311             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[SkippedBPNum].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o5">MinInstructions</a> &gt; <a class="code" href="../../d8/d5/kddata_8c.html#a81">InstructionsTraced</a>) {
02312                 <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[SkippedBPNum].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o5">MinInstructions</a> = <a class="code" href="../../d8/d5/kddata_8c.html#a81">InstructionsTraced</a>;
02313             }
02314             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[SkippedBPNum].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o6">MaxInstructions</a> &lt; <a class="code" href="../../d8/d5/kddata_8c.html#a81">InstructionsTraced</a>) {
02315                 <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[SkippedBPNum].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o6">MaxInstructions</a> = <a class="code" href="../../d8/d5/kddata_8c.html#a81">InstructionsTraced</a>;
02316             }
02317             <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[SkippedBPNum].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o7">TotalInstructions</a> += <a class="code" href="../../d8/d5/kddata_8c.html#a81">InstructionsTraced</a>;
02318 
02319             <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[SkippedBPNum].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o9">Thread</a> = 0;
02320 
02321             <a class="code" href="../../d8/d5/kddata_8c.html#a74">IntBPsSkipping</a>--;
02322             <a class="code" href="../../d8/d5/kddata_8c.html#a85">InstrCountInternal</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02323             <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a1">KdpCurrentSymbolStart</a> = 0;
02324             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a140">KdpRestoreAllBreakpoints</a>();
02325 
02326             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[SkippedBPNum].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o1">Flags</a> &amp;
02327                     DBGKD_INTERNAL_BP_FLAG_DYING) {
02328                 <a class="code" href="../../d1/d7/4_2kdp_8h.html#a105">KdpDeleteBreakpoint</a>(KdpInternalBPs[SkippedBPNum].Handle);
02329                 <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[SkippedBPNum].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o1">Flags</a> |=
02330                         DBGKD_INTERNAL_BP_FLAG_INVALID; <span class="comment">// bye, bye</span>
02331             }
02332 
02333             ContextRecord-&gt;EFlags &amp;= ~0x100<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>; <span class="comment">// clear trace flag</span>
02334             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>; <span class="comment">// Back to normal execution.</span>
02335         }
02336 
02337         <span class="keywordflow">if</span> (TraceDataRecordCallInfo( InstructionsTraced, CallLevelChange, pc)) {
02338 
02339             <span class="comment">//</span>
02340             <span class="comment">//  Everything was cool internally.  We can keep executing without</span>
02341             <span class="comment">//  going back to the remote debugger.</span>
02342             <span class="comment">//</span>
02343             <span class="comment">//  We have to compute lc after calling</span>
02344             <span class="comment">//  TraceDataRecordCallInfo, because LevelChange relies on</span>
02345             <span class="comment">//  KdpCurrentSymbolStart and KdpCurrentSymbolEnd corresponding to</span>
02346             <span class="comment">//  the pc.</span>
02347             <span class="comment">//</span>
02348 
02349             lc = <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a5">KdpLevelChange</a>( pc, ContextRecord, &amp;IsSpecialCall );
02350             <a class="code" href="../../d8/d5/kddata_8c.html#a81">InstructionsTraced</a> = 0;
02351             <a class="code" href="../../d8/d5/kddata_8c.html#a83">CallLevelChange</a> = lc;
02352 
02353             <span class="comment">//</span>
02354             <span class="comment">//  See if instruction is a transfer to a special routine, one that we</span>
02355             <span class="comment">//  cannot trace through since it may swap contexts</span>
02356             <span class="comment">//</span>
02357 
02358             <span class="keywordflow">if</span> (IsSpecialCall) {
02359 
02360 <span class="comment">//  DPRINT(( "4: pc=%x, level change %d\n", pc, lc));</span>
02361 
02362                 <span class="comment">//</span>
02363                 <span class="comment">//  We are about to transfer to a special call routine.  Since we</span>
02364                 <span class="comment">//  cannot trace through this routine, we execute it atomically by</span>
02365                 <span class="comment">//  setting a breakpoint at the next logical offset.</span>
02366                 <span class="comment">//</span>
02367                 <span class="comment">//  Note in the case of an indirect jump to a special call routine, the</span>
02368                 <span class="comment">//  level change will be -1 and the next offset will be the ULONG that's</span>
02369                 <span class="comment">//  on the top of the stack.</span>
02370                 <span class="comment">//</span>
02371                 <span class="comment">//  However, we've already adjusted the level based on this</span>
02372                 <span class="comment">//  instruction.  We need to undo this except for the magic -1 call.</span>
02373                 <span class="comment">//</span>
02374 
02375                 <span class="keywordflow">if</span> (lc != -1) {
02376                     <a class="code" href="../../d8/d5/kddata_8c.html#a83">CallLevelChange</a> -= lc;
02377                 }
02378 
02379                 <span class="comment">//</span>
02380                 <span class="comment">//  Set up for stepping over a procedure</span>
02381                 <span class="comment">//</span>
02382 
02383                 <a class="code" href="../../d8/d5/kddata_8c.html#a75">WatchStepOver</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02384                 <a class="code" href="../../d8/d5/kddata_8c.html#a76">WSOThread</a> = (PVOID)<a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>();
02385 
02386                 <span class="comment">//</span>
02387                 <span class="comment">//  Establish the breakpoint</span>
02388                 <span class="comment">//</span>
02389 
02390                 <a class="code" href="../../d8/d5/kddata_8c.html#a78">WatchStepOverHandle</a> =
02391                     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a104">KdpAddBreakpoint</a>( (PVOID)<a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a9">KdpGetCallNextOffset</a>( pc, ContextRecord ));
02392 
02393                 <span class="comment">//</span>
02394                 <span class="comment">//  Resume execution with the trace flag set.  Avoid going over the wire to</span>
02395                 <span class="comment">//  the remote debugger.</span>
02396                 <span class="comment">//</span>
02397 
02398                 ContextRecord-&gt;EFlags &amp;= ~0x100<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>;
02399                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02400             }
02401 
02402             ContextRecord-&gt;EFlags |= 0x100<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>; <span class="comment">// Set trace flag</span>
02403             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>; <span class="comment">// Off we go</span>
02404         }
02405 
02406         lc = <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a5">KdpLevelChange</a>( pc, ContextRecord, &amp;IsSpecialCall );
02407         <a class="code" href="../../d8/d5/kddata_8c.html#a81">InstructionsTraced</a> = 0;
02408         <a class="code" href="../../d8/d5/kddata_8c.html#a83">CallLevelChange</a> = lc;
02409 
02410         <span class="comment">// We need to go back to the remote debugger.  Just fall through.</span>
02411 
02412         <span class="keywordflow">if</span> ((lc != 0) &amp;&amp; IsSpecialCall) {
02413             <span class="comment">// We're hosed</span>
02414             <a class="code" href="../../d0/d7/kdp_8h.html#a16">DPRINT</a>(( <span class="stringliteral">"Special call on first entry to symbol scope @ %x\n"</span>, pc ));
02415         }
02416     }
02417 
02418     <a class="code" href="../../d8/d5/kddata_8c.html#a82">SymbolRecorded</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02419     <a class="code" href="../../d8/d5/kddata_8c.html#a84">oldpc</a> = pc;
02420 
02421     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02422 }
02423 <span class="preprocessor">#endif // i386</span>
02424 <span class="preprocessor"></span>
02425 BOOLEAN
<a name="l02426"></a><a class="code" href="../../d9/d3/4_2kdapi_8c.html#a29">02426</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a119">KdpSwitchProcessor</a> (
02427     IN PEXCEPTION_RECORD ExceptionRecord,
02428     IN OUT PCONTEXT ContextRecord,
02429     IN BOOLEAN SecondChance
02430     )
02431 {
02432     BOOLEAN <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02433 
02434     <span class="comment">//</span>
02435     <span class="comment">// Save port state</span>
02436     <span class="comment">//</span>
02437 
02438     <a class="code" href="../../d2/d7/hal_8h.html#a204">KdPortSave</a> ();
02439 
02440     <span class="comment">//</span>
02441     <span class="comment">// Process state change for this processor</span>
02442     <span class="comment">//</span>
02443 
02444     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d1/d7/4_2kdp_8h.html#a120">KdpReportExceptionStateChange</a> (
02445                 ExceptionRecord,
02446                 ContextRecord,
02447                 SecondChance
02448                 );
02449 
02450     <span class="comment">//</span>
02451     <span class="comment">// Restore port state and return status</span>
02452     <span class="comment">//</span>
02453 
02454     <a class="code" href="../../d2/d7/hal_8h.html#a203">KdPortRestore</a> ();
02455     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02456 }
02457 
02458 BOOLEAN
<a name="l02459"></a><a class="code" href="../../d9/d3/4_2kdapi_8c.html#a30">02459</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a120">KdpReportExceptionStateChange</a> (
02460     IN PEXCEPTION_RECORD ExceptionRecord,
02461     IN OUT PCONTEXT ContextRecord,
02462     IN BOOLEAN SecondChance
02463     )
02464 
02465 <span class="comment">/*++</span>
02466 <span class="comment"></span>
02467 <span class="comment">Routine Description:</span>
02468 <span class="comment"></span>
02469 <span class="comment">    This routine sends an exception state change packet to the kernel</span>
02470 <span class="comment">    debugger and waits for a manipulate state message.</span>
02471 <span class="comment"></span>
02472 <span class="comment">Arguments:</span>
02473 <span class="comment"></span>
02474 <span class="comment">    ExceptionRecord - Supplies a pointer to an exception record.</span>
02475 <span class="comment"></span>
02476 <span class="comment">    ContextRecord - Supplies a pointer to a context record.</span>
02477 <span class="comment"></span>
02478 <span class="comment">    SecondChance - Supplies a boolean value that determines whether this is</span>
02479 <span class="comment">        the first or second chance for the exception.</span>
02480 <span class="comment"></span>
02481 <span class="comment">Return Value:</span>
02482 <span class="comment"></span>
02483 <span class="comment">    A value of TRUE is returned if the exception is handled. Otherwise, a</span>
02484 <span class="comment">    value of FALSE is returned.</span>
02485 <span class="comment"></span>
02486 <span class="comment">--*/</span>
02487 
02488 {
02489     STRING MessageData;
02490     STRING MessageHeader;
02491     DBGKD_WAIT_STATE_CHANGE64 WaitStateChange;
02492     <a class="code" href="../../d4/d9/ke_8h.html#a408">KCONTINUE_STATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02493 
02494 <span class="preprocessor">#if i386</span>
02495 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (<a class="code" href="../../d2/d9/4_2i386_2kdtrap_8c.html#a3">KdpCheckTracePoint</a>(ExceptionRecord,ContextRecord)) <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02496 <span class="preprocessor">#endif</span>
02497 <span class="preprocessor"></span>
02498     <span class="keywordflow">do</span> {
02499 
02500         <span class="comment">//</span>
02501         <span class="comment">// Construct the wait state change message and message descriptor.</span>
02502         <span class="comment">//</span>
02503 
02504         <a class="code" href="../../d1/d7/4_2kdp_8h.html#a114">KdpSetStateChange</a>(&amp;WaitStateChange,
02505                             ExceptionRecord,
02506                             ContextRecord,
02507                             SecondChance
02508                             );
02509 
02510         MessageHeader.Length = <span class="keyword">sizeof</span>(DBGKD_WAIT_STATE_CHANGE64);
02511         MessageHeader.Buffer = (PCHAR)&amp;WaitStateChange;
02512 
02513 <span class="preprocessor">#if i386</span>
02514 <span class="preprocessor"></span>        <span class="comment">//</span>
02515         <span class="comment">// Construct the wait state change data and data descriptor.</span>
02516         <span class="comment">//</span>
02517 
02518         DumpTraceData(&amp;MessageData);
02519 <span class="preprocessor">#else</span>
02520 <span class="preprocessor"></span>        MessageData.Length = 0;
02521 <span class="preprocessor">#endif</span>
02522 <span class="preprocessor"></span>
02523         <span class="comment">//</span>
02524         <span class="comment">// Send packet to the kernel debugger on the host machine,</span>
02525         <span class="comment">// wait for answer.</span>
02526         <span class="comment">//</span>
02527 
02528         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d1/d7/4_2kdp_8h.html#a122">KdpSendWaitContinue</a>(
02529                     PACKET_TYPE_KD_STATE_CHANGE64,
02530                     &amp;MessageHeader,
02531                     &amp;MessageData,
02532                     ContextRecord
02533                     );
02534 
02535     } <span class="keywordflow">while</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == <a class="code" href="../../d4/d9/ke_8h.html#a408a228">ContinueProcessorReselected</a>) ;
02536 
02537     <span class="keywordflow">return</span> (BOOLEAN) <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02538 }
02539 
02540 
02541 BOOLEAN
<a name="l02542"></a><a class="code" href="../../d9/d3/4_2kdapi_8c.html#a31">02542</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a121">KdpReportLoadSymbolsStateChange</a> (
02543     IN PSTRING PathName,
02544     IN <a class="code" href="../../d6/d5/struct__KD__SYMBOLS__INFO.html">PKD_SYMBOLS_INFO</a> SymbolInfo,
02545     IN BOOLEAN UnloadSymbols,
02546     IN OUT PCONTEXT ContextRecord
02547     )
02548 
02549 <span class="comment">/*++</span>
02550 <span class="comment"></span>
02551 <span class="comment">Routine Description:</span>
02552 <span class="comment"></span>
02553 <span class="comment">    This routine sends a load symbols state change packet to the kernel</span>
02554 <span class="comment">    debugger and waits for a manipulate state message.</span>
02555 <span class="comment"></span>
02556 <span class="comment">Arguments:</span>
02557 <span class="comment"></span>
02558 <span class="comment">    PathName - Supplies a pointer to the pathname of the image whose</span>
02559 <span class="comment">        symbols are to be loaded.</span>
02560 <span class="comment"></span>
02561 <span class="comment">    BaseOfDll - Supplies the base address where the image was loaded.</span>
02562 <span class="comment"></span>
02563 <span class="comment">    ProcessId - Unique 32-bit identifier for process that is using</span>
02564 <span class="comment">        the symbols.  -1 for system process.</span>
02565 <span class="comment"></span>
02566 <span class="comment">    CheckSum - Unique 32-bit identifier from image header.</span>
02567 <span class="comment"></span>
02568 <span class="comment">    UnloadSymbol - TRUE if the symbols that were previously loaded for</span>
02569 <span class="comment">        the named image are to be unloaded from the debugger.</span>
02570 <span class="comment"></span>
02571 <span class="comment">Return Value:</span>
02572 <span class="comment"></span>
02573 <span class="comment">    A value of TRUE is returned if the exception is handled. Otherwise, a</span>
02574 <span class="comment">    value of FALSE is returned.</span>
02575 <span class="comment"></span>
02576 <span class="comment">--*/</span>
02577 
02578 {
02579 
02580     PSTRING AdditionalData;
02581     STRING MessageData;
02582     STRING MessageHeader;
02583     DBGKD_WAIT_STATE_CHANGE64 WaitStateChange;
02584     <a class="code" href="../../d4/d9/ke_8h.html#a408">KCONTINUE_STATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02585 
02586     <span class="keywordflow">do</span> {
02587 
02588         <span class="comment">//</span>
02589         <span class="comment">// Construct the wait state change message and message descriptor.</span>
02590         <span class="comment">//</span>
02591 
02592         WaitStateChange.NewState = DbgKdLoadSymbolsStateChange;
02593         WaitStateChange.ProcessorLevel = <a class="code" href="../../d4/d9/ke_8h.html#a135">KeProcessorLevel</a>;
02594         WaitStateChange.Processor = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a2">KeGetCurrentPrcb</a>()-&gt;Number;
02595         WaitStateChange.NumberProcessors = (ULONG)<a class="code" href="../../d4/d9/ke_8h.html#a133">KeNumberProcessors</a>;
02596         WaitStateChange.Thread = (ULONG64)(LONG64)(LONG_PTR) <a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>();
02597         WaitStateChange.ProgramCounter = (ULONG64)(LONG64)(LONG_PTR) CONTEXT_TO_PROGRAM_COUNTER(ContextRecord);
02598         <a class="code" href="../../d1/d7/4_2kdp_8h.html#a113">KdpSetLoadState</a>(&amp;WaitStateChange, ContextRecord);
02599         WaitStateChange.u.LoadSymbols.UnloadSymbols = UnloadSymbols;
02600         WaitStateChange.u.LoadSymbols.BaseOfDll = (ULONG64)SymbolInfo-&gt;BaseOfDll;
02601         WaitStateChange.u.LoadSymbols.ProcessId = (ULONG) SymbolInfo-&gt;ProcessId;
02602         WaitStateChange.u.LoadSymbols.CheckSum = SymbolInfo-&gt;CheckSum;
02603         WaitStateChange.u.LoadSymbols.SizeOfImage = SymbolInfo-&gt;SizeOfImage;
02604         <span class="keywordflow">if</span> (ARGUMENT_PRESENT( PathName )) {
02605             WaitStateChange.u.LoadSymbols.PathNameLength =
02606                 <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>(
02607                     (PCHAR)<a class="code" href="../../d8/d5/kddata_8c.html#a53">KdpPathBuffer</a>,
02608                     (PCHAR)PathName-&gt;Buffer,
02609                     PathName-&gt;Length
02610                     ) + 1;
02611 
02612             MessageData.Buffer = <a class="code" href="../../d8/d5/kddata_8c.html#a53">KdpPathBuffer</a>;
02613             MessageData.Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)WaitStateChange.u.LoadSymbols.PathNameLength;
02614             MessageData.Buffer[MessageData.Length-1] = <span class="charliteral">'\0'</span>;
02615             AdditionalData = &amp;MessageData;
02616         } <span class="keywordflow">else</span> {
02617             WaitStateChange.u.LoadSymbols.PathNameLength = 0;
02618             AdditionalData = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02619         }
02620 
02621         MessageHeader.Length = <span class="keyword">sizeof</span>(DBGKD_WAIT_STATE_CHANGE64);
02622         MessageHeader.Buffer = (PCHAR)&amp;WaitStateChange;
02623 
02624         <span class="comment">//</span>
02625         <span class="comment">// Send packet to the kernel debugger on the host machine, wait</span>
02626         <span class="comment">// for the reply.</span>
02627         <span class="comment">//</span>
02628 
02629         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d1/d7/4_2kdp_8h.html#a122">KdpSendWaitContinue</a>(
02630                     PACKET_TYPE_KD_STATE_CHANGE64,
02631                     &amp;MessageHeader,
02632                     AdditionalData,
02633                     ContextRecord
02634                     );
02635 
02636     } <span class="keywordflow">while</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == <a class="code" href="../../d4/d9/ke_8h.html#a408a228">ContinueProcessorReselected</a>);
02637 
02638     <span class="keywordflow">return</span> (BOOLEAN) <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02639 }
02640 
02641 
02642 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02643"></a><a class="code" href="../../d1/d7/4_2kdp_8h.html#a125">02643</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a125">KdpReadPhysicalMemory</a>(
02644     IN PDBGKD_MANIPULATE_STATE64 m,
02645     IN PSTRING AdditionalData,
02646     IN PCONTEXT Context
02647     )
02648 
02649 <span class="comment">/*++</span>
02650 <span class="comment"></span>
02651 <span class="comment">Routine Description:</span>
02652 <span class="comment"></span>
02653 <span class="comment">    This function is called in response to a read physical memory</span>
02654 <span class="comment">    state manipulation message. Its function is to read physical memory</span>
02655 <span class="comment">    and return.</span>
02656 <span class="comment"></span>
02657 <span class="comment">Arguments:</span>
02658 <span class="comment"></span>
02659 <span class="comment">    m - Supplies the state manipulation message.</span>
02660 <span class="comment"></span>
02661 <span class="comment">    AdditionalData - Supplies any additional data for the message.</span>
02662 <span class="comment"></span>
02663 <span class="comment">    Context - Supplies the current context.</span>
02664 <span class="comment"></span>
02665 <span class="comment">Return Value:</span>
02666 <span class="comment"></span>
02667 <span class="comment">    None.</span>
02668 <span class="comment"></span>
02669 <span class="comment">--*/</span>
02670 
02671 {
02672     PDBGKD_READ_MEMORY64 a = &amp;m-&gt;u.ReadMemory;
02673     ULONG Length;
02674     STRING MessageHeader;
02675     PVOID64 VirtualAddress;
02676     PHYSICAL_ADDRESS Source;
02677     UCHAR UNALIGNED *Destination;
02678     ULONG NumberBytes;
02679     ULONG BytesLeft;
02680 
02681     MessageHeader.Length = <span class="keyword">sizeof</span>(*m);
02682     MessageHeader.Buffer = (PCHAR)m;
02683 
02684     <span class="comment">//</span>
02685     <span class="comment">// make sure that nothing but a read memory message was transmitted</span>
02686     <span class="comment">//</span>
02687 
02688     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(AdditionalData-&gt;Length == 0);
02689 
02690     <span class="comment">//</span>
02691     <span class="comment">// Trim transfer count to fit in a single message</span>
02692     <span class="comment">//</span>
02693 
02694     <span class="keywordflow">if</span> (a-&gt;TransferCount &gt; (PACKET_MAX_SIZE - <span class="keyword">sizeof</span>(DBGKD_MANIPULATE_STATE64))) {
02695         Length = PACKET_MAX_SIZE - <span class="keyword">sizeof</span>(DBGKD_MANIPULATE_STATE64);
02696     } <span class="keywordflow">else</span> {
02697         Length = a-&gt;TransferCount;
02698     }
02699 
02700     <span class="comment">//</span>
02701     <span class="comment">// Since the MmDbgTranslatePhysicalAddress64 only maps in one physical</span>
02702     <span class="comment">// page at a time (on non-alpha systems),</span>
02703     <span class="comment">// we need to break the memory move up into smaller</span>
02704     <span class="comment">// moves which don't cross page boundaries.  It is important that we</span>
02705     <span class="comment">// access physical memory on naturally-aligned boundaries and with the</span>
02706     <span class="comment">// largest size possible.  (We could be accessing memory-mapped I/O</span>
02707     <span class="comment">// space).  These rules allow kdexts to read physical memory reliably.</span>
02708     <span class="comment">//</span>
02709 
02710     Source.QuadPart = a-&gt;TargetBaseAddress;
02711     Destination = AdditionalData-&gt;Buffer;
02712     <span class="keywordflow">while</span> (Length &gt; 0) {
02713         VirtualAddress = <a class="code" href="../../d2/d6/ia64_2debugsup_8c.html#a3">MmDbgTranslatePhysicalAddress64</a>(Source);
02714         <span class="keywordflow">if</span> (VirtualAddress == NULL64) {
02715             <span class="keywordflow">break</span>;
02716         }
02717         NumberBytes = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - <a class="code" href="../../d2/d1/mm_8h.html#a6">BYTE_OFFSET</a>(Source.LowPart);
02718         <span class="keywordflow">if</span> (NumberBytes &gt; Length) {
02719             NumberBytes = Length;
02720         }
02721 
02722 <span class="preprocessor">#ifdef _ALPHA_</span>
02723 <span class="preprocessor"></span>        BytesLeft = NumberBytes;
02724         <span class="keywordflow">while</span> (BytesLeft &gt; 0) {
02725             __MB();
02726 
02727             <span class="keywordflow">if</span> (((ULONG64)VirtualAddress &amp; 7) == 0 &amp;&amp; BytesLeft &gt; 7) {
02728                 *((ULONGLONG UNALIGNED *)Destination)++ =
02729                     *((ULONGLONG * POINTER_64)VirtualAddress)++;
02730                 BytesLeft -= 8;
02731             } <span class="keywordflow">else</span> {
02732                 <span class="keywordflow">if</span> (((ULONG64)VirtualAddress &amp; 3) == 0 &amp;&amp; BytesLeft &gt; 3) {
02733                     *((ULONG UNALIGNED *)Destination)++ =
02734                         *((ULONG * POINTER_64)VirtualAddress)++;
02735                     BytesLeft -= 4;
02736                 } <span class="keywordflow">else</span> {
02737                     <span class="keywordflow">if</span> (((ULONG64)VirtualAddress &amp; 1) == 0 &amp;&amp; BytesLeft &gt; 1) {
02738                         *((<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> UNALIGNED *)Destination)++ =
02739                             *((<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> * POINTER_64)VirtualAddress)++;
02740                         BytesLeft -= 2;
02741                     } <span class="keywordflow">else</span> {
02742                         *Destination++ =
02743                             *((UCHAR * POINTER_64)VirtualAddress)++;
02744                         BytesLeft -= 1;
02745                     }
02746                 }
02747             }
02748         }
02749 <span class="preprocessor">#else</span>
02750 <span class="preprocessor"></span>        <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>(Destination, VirtualAddress, NumberBytes);
02751         Destination += NumberBytes;
02752 
02753 <span class="preprocessor">#endif</span>
02754 <span class="preprocessor"></span>        Source.QuadPart += NumberBytes;
02755         Length -= NumberBytes;
02756         AdditionalData-&gt;Length += (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)NumberBytes;
02757     }
02758 
02759     <span class="keywordflow">if</span> (Length == 0) {
02760         m-&gt;ReturnStatus = STATUS_SUCCESS;
02761     } <span class="keywordflow">else</span> {
02762         m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
02763     }
02764 
02765     a-&gt;ActualBytesRead = AdditionalData-&gt;Length;
02766 
02767     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(
02768                   PACKET_TYPE_KD_STATE_MANIPULATE,
02769                   &amp;MessageHeader,
02770                   AdditionalData
02771                   );
02772     UNREFERENCED_PARAMETER(Context);
02773 
02774 }
02775 
02776 
02777 
02778 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02779"></a><a class="code" href="../../d1/d7/4_2kdp_8h.html#a126">02779</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a126">KdpWritePhysicalMemory</a>(
02780     IN PDBGKD_MANIPULATE_STATE64 m,
02781     IN PSTRING AdditionalData,
02782     IN PCONTEXT Context
02783     )
02784 
02785 <span class="comment">/*++</span>
02786 <span class="comment"></span>
02787 <span class="comment">Routine Description:</span>
02788 <span class="comment"></span>
02789 <span class="comment">    This function is called in response to a write physical memory</span>
02790 <span class="comment">    state manipulation message. Its function is to write physical memory</span>
02791 <span class="comment">    and return.</span>
02792 <span class="comment"></span>
02793 <span class="comment">Arguments:</span>
02794 <span class="comment"></span>
02795 <span class="comment">    m - Supplies the state manipulation message.</span>
02796 <span class="comment"></span>
02797 <span class="comment">    AdditionalData - Supplies any additional data for the message.</span>
02798 <span class="comment"></span>
02799 <span class="comment">    Context - Supplies the current context.</span>
02800 <span class="comment"></span>
02801 <span class="comment">Return Value:</span>
02802 <span class="comment"></span>
02803 <span class="comment">    None.</span>
02804 <span class="comment"></span>
02805 <span class="comment">--*/</span>
02806 
02807 {
02808     PDBGKD_WRITE_MEMORY64 a = &amp;m-&gt;u.WriteMemory;
02809     STRING MessageHeader;
02810     ULONG Length;
02811     PVOID64 VirtualAddress;
02812     PHYSICAL_ADDRESS Destination;
02813     UCHAR UNALIGNED *Source;
02814     ULONG NumberBytes;
02815     ULONG BytesLeft;
02816 
02817     MessageHeader.Length = <span class="keyword">sizeof</span>(*m);
02818     MessageHeader.Buffer = (PCHAR)m;
02819 
02820 
02821     Length = a-&gt;TransferCount;
02822 
02823     <span class="comment">//</span>
02824     <span class="comment">// The following code depends on the existence of the</span>
02825     <span class="comment">// MmDbgTranslatePhysicalAddress64() routine.  This has only been</span>
02826     <span class="comment">// implemented for Alpha.</span>
02827     <span class="comment">//</span>
02828 
02829     <span class="comment">//</span>
02830     <span class="comment">// Since the MmDbgTranslatePhysicalAddress64 only maps in one physical</span>
02831     <span class="comment">// page at a time, we need to break the memory move up into smaller</span>
02832     <span class="comment">// moves which don't cross page boundaries.  It is important that we</span>
02833     <span class="comment">// access physical memory on naturally-aligned boundaries and with the</span>
02834     <span class="comment">// largest size possible.  (We could be accessing memory-mapped I/O</span>
02835     <span class="comment">// space).  These rules allow kdexts to write physical memory reliably.</span>
02836     <span class="comment">//</span>
02837 
02838     Source = AdditionalData-&gt;Buffer;
02839     Destination.QuadPart = a-&gt;TargetBaseAddress;
02840     <span class="keywordflow">while</span> (Length &gt; 0) {
02841         VirtualAddress = <a class="code" href="../../d2/d6/ia64_2debugsup_8c.html#a3">MmDbgTranslatePhysicalAddress64</a>(Destination);
02842         <span class="keywordflow">if</span> (VirtualAddress == NULL64) {
02843             <span class="keywordflow">break</span>;
02844         }
02845         NumberBytes = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - <a class="code" href="../../d2/d1/mm_8h.html#a6">BYTE_OFFSET</a>(Destination.LowPart);
02846         <span class="keywordflow">if</span> (NumberBytes &gt; Length) {
02847             NumberBytes = Length;
02848         }
02849 <span class="preprocessor">#ifdef _ALPHA_</span>
02850 <span class="preprocessor"></span>        BytesLeft = NumberBytes;
02851         <span class="keywordflow">while</span> (BytesLeft &gt; 0) {
02852             <span class="keywordflow">if</span> (((ULONG64)VirtualAddress &amp; 7) == 0 &amp;&amp; BytesLeft &gt; 7) {
02853                 *((ULONGLONG * POINTER_64)VirtualAddress)++ =
02854                     *((ULONGLONG UNALIGNED *)Source)++;
02855                 BytesLeft -= 8;
02856             } <span class="keywordflow">else</span> {
02857                 <span class="keywordflow">if</span> (((ULONG64)VirtualAddress &amp; 3) == 0 &amp;&amp; BytesLeft &gt; 3) {
02858                     *((ULONG * POINTER_64)VirtualAddress)++ =
02859                         *((ULONG UNALIGNED *)Source)++;
02860                     BytesLeft -= 4;
02861                 } <span class="keywordflow">else</span> {
02862                     <span class="keywordflow">if</span> (((ULONG64)VirtualAddress &amp; 1) == 0 &amp;&amp; BytesLeft &gt; 1) {
02863                         *((<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> * POINTER_64)VirtualAddress)++ =
02864                             *((<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> UNALIGNED *)Source)++;
02865                         BytesLeft -= 2;
02866                     } <span class="keywordflow">else</span> {
02867                         *((UCHAR * POINTER_64)VirtualAddress)++ =
02868                             *(UCHAR UNALIGNED *)Source++;
02869                         BytesLeft -= 1;
02870                     }
02871                 }
02872             }
02873 
02874             __MB();
02875         }
02876 <span class="preprocessor">#else</span>
02877 <span class="preprocessor"></span>        <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>(VirtualAddress, Source, NumberBytes);
02878         Source += NumberBytes;
02879 
02880 <span class="preprocessor">#endif</span>
02881 <span class="preprocessor"></span>        Destination.QuadPart += NumberBytes;
02882         Length -= NumberBytes;
02883         a-&gt;ActualBytesWritten += NumberBytes;
02884     }
02885 
02886     <span class="keywordflow">if</span> (Length == 0) {
02887         m-&gt;ReturnStatus = STATUS_SUCCESS;
02888     } <span class="keywordflow">else</span> {
02889         m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
02890     }
02891 
02892     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(
02893                   PACKET_TYPE_KD_STATE_MANIPULATE,
02894                   &amp;MessageHeader,
02895                   <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
02896                   );
02897     UNREFERENCED_PARAMETER(Context);
02898 }
02899 
02900 
02901 
02902 <span class="preprocessor">#if i386</span>
02903 <span class="preprocessor"></span><a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
02904 <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a6">KdpProcessInternalBreakpoint</a> (
02905     ULONG BreakpointNumber
02906     )
02907 {
02908     <span class="keyword">static</span> BOOLEAN timerStarted = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02909     LARGE_INTEGER dueTime;
02910 
02911     <span class="keywordflow">if</span> ( !(<a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[BreakpointNumber].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o1">Flags</a> &amp;
02912            DBGKD_INTERNAL_BP_FLAG_COUNTONLY) ) {
02913         <span class="keywordflow">return</span>;     <span class="comment">// We only deal with COUNTONLY breakpoints</span>
02914     }
02915 
02916     <span class="comment">//</span>
02917     <span class="comment">// We've hit a real internal breakpoint; make sure the timeout is</span>
02918     <span class="comment">// kicked off.</span>
02919     <span class="comment">//</span>
02920 
02921     <span class="keywordflow">if</span> ( !timerStarted ) { <span class="comment">// ok, maybe there's a prettier way to do this.</span>
02922         dueTime.LowPart = (ULONG)(-1 * 10 * 1000 * 1000);
02923         dueTime.HighPart = -1;
02924         <a class="code" href="../../d4/d1/dpcobj_8c.html#a1">KeInitializeDpc</a>(
02925             &amp;InternalBreakpointCheckDpc,
02926             &amp;InternalBreakpointCheck,
02927             NULL
02928             );
02929         <a class="code" href="../../d3/d2/timerobj_8c.html#a1">KeInitializeTimer</a>( &amp;InternalBreakpointTimer );
02930         <a class="code" href="../../d3/d2/timerobj_8c.html#a6">KeSetTimer</a>(
02931             &amp;InternalBreakpointTimer,
02932             dueTime,
02933             &amp;InternalBreakpointCheckDpc
02934             );
02935         timerStarted = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02936     }
02937 
02938     <a class="code" href="../../d8/d5/kddata_8c.html#a54">KdpInternalBPs</a>[BreakpointNumber].<a class="code" href="../../d6/d7/structDBGKD__INTERNAL__BREAKPOINT.html#o2">Calls</a>++;
02939 
02940 } <span class="comment">// KdpProcessInternalBreakpoint</span>
02941 <span class="preprocessor">#endif</span>
02942 <span class="preprocessor"></span>
02943 
02944 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02945"></a><a class="code" href="../../d9/d3/4_2kdapi_8c.html#a7">02945</a> <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a7">KdpGetVersion</a>(
02946     IN PDBGKD_MANIPULATE_STATE64 m
02947     )
02948 
02949 <span class="comment">/*++</span>
02950 <span class="comment"></span>
02951 <span class="comment">Routine Description:</span>
02952 <span class="comment"></span>
02953 <span class="comment">    This function returns to the caller a general information packet</span>
02954 <span class="comment">    that contains useful information to a debugger.  This packet is also</span>
02955 <span class="comment">    used for a debugger to determine if the writebreakpointex and</span>
02956 <span class="comment">    readbreakpointex apis are available.</span>
02957 <span class="comment"></span>
02958 <span class="comment">Arguments:</span>
02959 <span class="comment"></span>
02960 <span class="comment">    m - Supplies the state manipulation message.</span>
02961 <span class="comment"></span>
02962 <span class="comment">Return Value:</span>
02963 <span class="comment"></span>
02964 <span class="comment">    None.</span>
02965 <span class="comment"></span>
02966 <span class="comment">--*/</span>
02967 
02968 {
02969     STRING                   messageHeader;
02970 
02971 
02972     messageHeader.Length = <span class="keyword">sizeof</span>(*m);
02973     messageHeader.Buffer = (PCHAR)m;
02974 
02975     RtlZeroMemory(&amp;m-&gt;u.GetVersion64, <span class="keyword">sizeof</span>(m-&gt;u.GetVersion64));
02976     <span class="comment">//</span>
02977     <span class="comment">// the current build number</span>
02978     <span class="comment">//</span>
02979     m-&gt;u.GetVersion64.MinorVersion = (<span class="keywordtype">short</span>)<a class="code" href="../../d5/d5/triage_8c.html#a0">NtBuildNumber</a>;
02980     m-&gt;u.GetVersion64.MajorVersion = (<span class="keywordtype">short</span>)((<a class="code" href="../../d5/d5/triage_8c.html#a0">NtBuildNumber</a> &gt;&gt; 28) &amp; 0xFFFFFFF);
02981 
02982     <span class="comment">//</span>
02983     <span class="comment">// kd protocol version number.  this should be incremented if the</span>
02984     <span class="comment">// protocol changes.</span>
02985     <span class="comment">//</span>
02986     m-&gt;u.GetVersion64.ProtocolVersion = 5;
02987     m-&gt;u.GetVersion64.Flags = DBGKD_VERS_FLAG_DATA;
02988 
02989 <span class="preprocessor">#if !defined(NT_UP)</span>
02990 <span class="preprocessor"></span>    m-&gt;u.GetVersion64.Flags |= DBGKD_VERS_FLAG_MP;
02991 <span class="preprocessor">#endif</span>
02992 <span class="preprocessor"></span>
02993 <span class="preprocessor">#if defined(_M_IX86)</span>
02994 <span class="preprocessor"></span>    m-&gt;u.GetVersion64.MachineType = IMAGE_FILE_MACHINE_I386;
02995 <span class="preprocessor">#elif defined(_M_MRX000)</span>
02996 <span class="preprocessor"></span>    m-&gt;u.GetVersion64.MachineType = IMAGE_FILE_MACHINE_R4000;
02997 <span class="preprocessor">#elif defined(_M_ALPHA)</span>
02998 <span class="preprocessor"></span>    m-&gt;u.GetVersion64.MachineType = IMAGE_FILE_MACHINE_ALPHA;
02999 <span class="preprocessor">#if defined(_AXP64_)</span>
03000 <span class="preprocessor"></span>    m-&gt;u.GetVersion64.Flags |= DBGKD_VERS_FLAG_PTR64;
03001 <span class="preprocessor">#endif</span>
03002 <span class="preprocessor"></span><span class="preprocessor">#elif defined(_M_PPC)</span>
03003 <span class="preprocessor"></span>    m-&gt;u.GetVersion64.MachineType = IMAGE_FILE_MACHINE_POWERPC;
03004 <span class="preprocessor">#elif defined(_M_IA64)</span>
03005 <span class="preprocessor"></span>    m-&gt;u.GetVersion64.MachineType = IMAGE_FILE_MACHINE_IA64;
03006     m-&gt;u.GetVersion64.Flags |= DBGKD_VERS_FLAG_PTR64;
03007 <span class="preprocessor">#else</span>
03008 <span class="preprocessor"></span><span class="preprocessor">#error( "unknown target machine" );</span>
03009 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
03010 <span class="preprocessor"></span>
03011     <span class="comment">//</span>
03012     <span class="comment">// address of the loader table</span>
03013     <span class="comment">//</span>
03014     m-&gt;u.GetVersion64.PsLoadedModuleList = (ULONG64)(LONG64)(LONG_PTR)&amp;<a class="code" href="../../d1/d9/ps_8h.html#a56">PsLoadedModuleList</a>;
03015 
03016     <span class="comment">//</span>
03017     <span class="comment">// If the debugger is being initialized during boot, PsNtosImageBase</span>
03018     <span class="comment">// and PsLoadedModuleList are not yet valid.  KdInitSystem got</span>
03019     <span class="comment">// the image base from the loader block.</span>
03020     <span class="comment">// On the other hand, if the debugger was initialized by a bugcheck,</span>
03021     <span class="comment">// it didn't get a loader block to look at, but the system was</span>
03022     <span class="comment">// running so the other variables are valid.</span>
03023     <span class="comment">//</span>
03024 
03025     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a94">KdpNtosImageBase</a>) {
03026         m-&gt;u.GetVersion64.KernBase = (ULONG64)(LONG64)(LONG_PTR)<a class="code" href="../../d8/d5/kddata_8c.html#a94">KdpNtosImageBase</a>;
03027     } <span class="keywordflow">else</span> {
03028         m-&gt;u.GetVersion64.KernBase = (ULONG64)(LONG64)(LONG_PTR)<a class="code" href="../../d1/d9/ps_8h.html#a54">PsNtosImageBase</a>;
03029     }
03030 
03031     m-&gt;u.GetVersion64.DebuggerDataList = (ULONG64)(LONG64)(LONG_PTR)&amp;<a class="code" href="../../d8/d5/kddata_8c.html#a97">KdpDebuggerDataListHead</a>;
03032 
03033     <span class="comment">//</span>
03034     <span class="comment">// the usual stuff</span>
03035     <span class="comment">//</span>
03036     m-&gt;ReturnStatus = STATUS_SUCCESS;
03037     m-&gt;ApiNumber = DbgKdGetVersionApi;
03038 
03039     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(PACKET_TYPE_KD_STATE_MANIPULATE,
03040                   &amp;messageHeader,
03041                   <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
03042                  );
03043 
03044     <span class="keywordflow">return</span>;
03045 } <span class="comment">// KdGetVersion</span>
03046 
03047 
03048 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l03049"></a><a class="code" href="../../d9/d3/4_2kdapi_8c.html#a8">03049</a> <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a8">KdpNotSupported</a>(
03050     IN PDBGKD_MANIPULATE_STATE64 m
03051     )
03052 
03053 <span class="comment">/*++</span>
03054 <span class="comment"></span>
03055 <span class="comment">Routine Description:</span>
03056 <span class="comment"></span>
03057 <span class="comment">    This routine returns STATUS_UNSUCCESSFUL to the debugger</span>
03058 <span class="comment"></span>
03059 <span class="comment">Arguments:</span>
03060 <span class="comment"></span>
03061 <span class="comment">    m - Supplies a DBGKD_MANIPULATE_STATE64 struct to answer with</span>
03062 <span class="comment"></span>
03063 <span class="comment">Return Value:</span>
03064 <span class="comment"></span>
03065 <span class="comment">    0, to indicate that the system should not continue</span>
03066 <span class="comment"></span>
03067 <span class="comment">--*/</span>
03068 
03069 {
03070     STRING          MessageHeader;
03071 
03072     <span class="comment">//</span>
03073     <span class="comment">// setup packet</span>
03074     <span class="comment">//</span>
03075     MessageHeader.Length = <span class="keyword">sizeof</span>(*m);
03076     MessageHeader.Buffer = (PCHAR)m;
03077     m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
03078 
03079     <span class="comment">//</span>
03080     <span class="comment">// send back our response</span>
03081     <span class="comment">//</span>
03082     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(
03083         PACKET_TYPE_KD_STATE_MANIPULATE,
03084         &amp;MessageHeader,
03085         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
03086         );
03087 
03088     <span class="comment">//</span>
03089     <span class="comment">// return the caller's continue status value.  if this is a non-zero</span>
03090     <span class="comment">// value the system is continued using this value as the continuestatus.</span>
03091     <span class="comment">//</span>
03092     <span class="keywordflow">return</span> 0;
03093 } <span class="comment">// KdpNotSupported</span>
03094 
03095 
03096 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l03097"></a><a class="code" href="../../d9/d3/4_2kdapi_8c.html#a9">03097</a> <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a9">KdpCauseBugCheck</a>(
03098     IN PDBGKD_MANIPULATE_STATE64 m
03099     )
03100 
03101 <span class="comment">/*++</span>
03102 <span class="comment"></span>
03103 <span class="comment">Routine Description:</span>
03104 <span class="comment"></span>
03105 <span class="comment">    This routine causes a bugcheck.  It is used for testing the debugger.</span>
03106 <span class="comment"></span>
03107 <span class="comment">Arguments:</span>
03108 <span class="comment"></span>
03109 <span class="comment">    m - Supplies the state manipulation message.</span>
03110 <span class="comment"></span>
03111 <span class="comment">Return Value:</span>
03112 <span class="comment"></span>
03113 <span class="comment">    None.</span>
03114 <span class="comment"></span>
03115 <span class="comment">--*/</span>
03116 
03117 {
03118 
03119     <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a>( MANUALLY_INITIATED_CRASH, 0, 0, 0, 0 );
03120 
03121 } <span class="comment">// KdCauseBugCheck</span>
03122 
03123 
03124 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l03125"></a><a class="code" href="../../d9/d3/4_2kdapi_8c.html#a10">03125</a> <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a10">KdpWriteBreakPointEx</a>(
03126     IN PDBGKD_MANIPULATE_STATE64 m,
03127     IN PSTRING AdditionalData,
03128     IN PCONTEXT Context
03129     )
03130 
03131 <span class="comment">/*++</span>
03132 <span class="comment"></span>
03133 <span class="comment">Routine Description:</span>
03134 <span class="comment"></span>
03135 <span class="comment">    This function is called in response of a write breakpoint state 'ex'</span>
03136 <span class="comment">    manipulation message.  Its function is to clear breakpoints, write</span>
03137 <span class="comment">    new breakpoints, and continue the target system.  The clearing of</span>
03138 <span class="comment">    breakpoints is conditional based on the presence of breakpoint handles.</span>
03139 <span class="comment">    The setting of breakpoints is conditional based on the presence of</span>
03140 <span class="comment">    valid, non-zero, addresses.  The continueing of the target system</span>
03141 <span class="comment">    is conditional based on a non-zero continuestatus.</span>
03142 <span class="comment"></span>
03143 <span class="comment">    This api allows a debugger to clear breakpoints, add new breakpoint,</span>
03144 <span class="comment">    and continue the target system all in one api packet.  This reduces the</span>
03145 <span class="comment">    amount of traffic across the wire and greatly improves source stepping.</span>
03146 <span class="comment"></span>
03147 <span class="comment"></span>
03148 <span class="comment">Arguments:</span>
03149 <span class="comment"></span>
03150 <span class="comment">    m - Supplies the state manipulation message.</span>
03151 <span class="comment"></span>
03152 <span class="comment">    AdditionalData - Supplies any additional data for the message.</span>
03153 <span class="comment"></span>
03154 <span class="comment">    Context - Supplies the current context.</span>
03155 <span class="comment"></span>
03156 <span class="comment">Return Value:</span>
03157 <span class="comment"></span>
03158 <span class="comment">    None.</span>
03159 <span class="comment"></span>
03160 <span class="comment">--*/</span>
03161 
03162 {
03163     PDBGKD_BREAKPOINTEX       a = &amp;m-&gt;u.BreakPointEx;
03164     PDBGKD_WRITE_BREAKPOINT64 b;
03165     STRING                    MessageHeader;
03166     ULONG                     i;
03167     DBGKD_WRITE_BREAKPOINT64  BpBuf[BREAKPOINT_TABLE_SIZE];
03168 
03169 
03170     MessageHeader.Length = <span class="keyword">sizeof</span>(*m);
03171     MessageHeader.Buffer = (PCHAR)m;
03172 
03173     <span class="comment">//</span>
03174     <span class="comment">// verify that the packet size is correct</span>
03175     <span class="comment">//</span>
03176     <span class="keywordflow">if</span> (AdditionalData-&gt;Length !=
03177                          a-&gt;BreakPointCount*<span class="keyword">sizeof</span>(DBGKD_WRITE_BREAKPOINT64)) {
03178         m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
03179         <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(
03180                       PACKET_TYPE_KD_STATE_MANIPULATE,
03181                       &amp;MessageHeader,
03182                       AdditionalData
03183                       );
03184         <span class="keywordflow">return</span> m-&gt;ReturnStatus;
03185     }
03186 
03187     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>((PUCHAR)BpBuf,
03188                   AdditionalData-&gt;Buffer,
03189                   a-&gt;BreakPointCount*<span class="keyword">sizeof</span>(DBGKD_WRITE_BREAKPOINT64));
03190 
03191     <span class="comment">//</span>
03192     <span class="comment">// assume success</span>
03193     <span class="comment">//</span>
03194     m-&gt;ReturnStatus = STATUS_SUCCESS;
03195 
03196     <span class="comment">//</span>
03197     <span class="comment">// loop thru the breakpoint handles passed in from the debugger and</span>
03198     <span class="comment">// clear any breakpoint that has a non-zero handle</span>
03199     <span class="comment">//</span>
03200     b = BpBuf;
03201     <span class="keywordflow">for</span> (i=0; i&lt;a-&gt;BreakPointCount; i++,b++) {
03202         <span class="keywordflow">if</span> (b-&gt;BreakPointHandle) {
03203             <span class="keywordflow">if</span> (!<a class="code" href="../../d1/d7/4_2kdp_8h.html#a105">KdpDeleteBreakpoint</a>(b-&gt;BreakPointHandle)) {
03204                 m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
03205             }
03206             b-&gt;BreakPointHandle = 0;
03207         }
03208     }
03209 
03210     <span class="comment">//</span>
03211     <span class="comment">// loop thru the breakpoint addesses passed in from the debugger and</span>
03212     <span class="comment">// add any new breakpoints that have a non-zero address</span>
03213     <span class="comment">//</span>
03214     b = BpBuf;
03215     <span class="keywordflow">for</span> (i=0; i&lt;a-&gt;BreakPointCount; i++,b++) {
03216         <span class="keywordflow">if</span> (b-&gt;BreakPointAddress) {
03217             b-&gt;BreakPointHandle = <a class="code" href="../../d1/d7/4_2kdp_8h.html#a104">KdpAddBreakpoint</a>( (PVOID)b-&gt;BreakPointAddress );
03218             <span class="keywordflow">if</span> (!b-&gt;BreakPointHandle) {
03219                 m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
03220             }
03221         }
03222     }
03223 
03224     <span class="comment">//</span>
03225     <span class="comment">// send back our response</span>
03226     <span class="comment">//</span>
03227 
03228     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>(AdditionalData-&gt;Buffer,
03229                   (PUCHAR)BpBuf,
03230                   a-&gt;BreakPointCount*<span class="keyword">sizeof</span>(DBGKD_WRITE_BREAKPOINT64));
03231 
03232     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(
03233                   PACKET_TYPE_KD_STATE_MANIPULATE,
03234                   &amp;MessageHeader,
03235                   AdditionalData
03236                   );
03237 
03238     <span class="comment">//</span>
03239     <span class="comment">// return the caller's continue status value.  if this is a non-zero</span>
03240     <span class="comment">// value the system is continued using this value as the continuestatus.</span>
03241     <span class="comment">//</span>
03242     <span class="keywordflow">return</span> a-&gt;ContinueStatus;
03243 }
03244 
03245 
03246 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l03247"></a><a class="code" href="../../d9/d3/4_2kdapi_8c.html#a11">03247</a> <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a11">KdpRestoreBreakPointEx</a>(
03248     IN PDBGKD_MANIPULATE_STATE64 m,
03249     IN PSTRING AdditionalData,
03250     IN PCONTEXT Context
03251     )
03252 
03253 <span class="comment">/*++</span>
03254 <span class="comment"></span>
03255 <span class="comment">Routine Description:</span>
03256 <span class="comment"></span>
03257 <span class="comment">    This function is called in response of a restore breakpoint state 'ex'</span>
03258 <span class="comment">    manipulation message.  Its function is to clear a list of breakpoints.</span>
03259 <span class="comment"></span>
03260 <span class="comment">Arguments:</span>
03261 <span class="comment"></span>
03262 <span class="comment">    m - Supplies the state manipulation message.</span>
03263 <span class="comment"></span>
03264 <span class="comment">    AdditionalData - Supplies any additional data for the message.</span>
03265 <span class="comment"></span>
03266 <span class="comment">    Context - Supplies the current context.</span>
03267 <span class="comment"></span>
03268 <span class="comment">Return Value:</span>
03269 <span class="comment"></span>
03270 <span class="comment">    None.</span>
03271 <span class="comment"></span>
03272 <span class="comment">--*/</span>
03273 
03274 {
03275     PDBGKD_BREAKPOINTEX         a = &amp;m-&gt;u.BreakPointEx;
03276     PDBGKD_RESTORE_BREAKPOINT   b;
03277     STRING                      MessageHeader;
03278     ULONG                       i;
03279     DBGKD_RESTORE_BREAKPOINT    BpBuf[BREAKPOINT_TABLE_SIZE];
03280 
03281 
03282     MessageHeader.Length = <span class="keyword">sizeof</span>(*m);
03283     MessageHeader.Buffer = (PCHAR)m;
03284 
03285     <span class="comment">//</span>
03286     <span class="comment">// verify that the packet size is correct</span>
03287     <span class="comment">//</span>
03288     <span class="keywordflow">if</span> (AdditionalData-&gt;Length !=
03289                        a-&gt;BreakPointCount*<span class="keyword">sizeof</span>(DBGKD_RESTORE_BREAKPOINT)) {
03290         m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
03291         <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(
03292                       PACKET_TYPE_KD_STATE_MANIPULATE,
03293                       &amp;MessageHeader,
03294                       AdditionalData
03295                       );
03296         <span class="keywordflow">return</span>;
03297     }
03298 
03299     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>((PUCHAR)BpBuf,
03300                   AdditionalData-&gt;Buffer,
03301                   a-&gt;BreakPointCount*<span class="keyword">sizeof</span>(DBGKD_RESTORE_BREAKPOINT));
03302 
03303     <span class="comment">//</span>
03304     <span class="comment">// assume success</span>
03305     <span class="comment">//</span>
03306     m-&gt;ReturnStatus = STATUS_SUCCESS;
03307 
03308     <span class="comment">//</span>
03309     <span class="comment">// loop thru the breakpoint handles passed in from the debugger and</span>
03310     <span class="comment">// clear any breakpoint that has a non-zero handle</span>
03311     <span class="comment">//</span>
03312     b = BpBuf;
03313     <span class="keywordflow">for</span> (i=0; i&lt;a-&gt;BreakPointCount; i++,b++) {
03314         <span class="keywordflow">if</span> (!<a class="code" href="../../d1/d7/4_2kdp_8h.html#a105">KdpDeleteBreakpoint</a>(b-&gt;BreakPointHandle)) {
03315             m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
03316         }
03317     }
03318 
03319     <span class="comment">//</span>
03320     <span class="comment">// send back our response</span>
03321     <span class="comment">//</span>
03322     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(
03323                   PACKET_TYPE_KD_STATE_MANIPULATE,
03324                   &amp;MessageHeader,
03325                   AdditionalData
03326                   );
03327 }
03328 
03329 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l03330"></a><a class="code" href="../../d9/d3/4_2kdapi_8c.html#a34">03330</a> <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a34">KdDisableDebugger</a>(
03331     VOID
03332     )
03333 <span class="comment">/*++</span>
03334 <span class="comment"></span>
03335 <span class="comment">Routine Description:</span>
03336 <span class="comment"></span>
03337 <span class="comment">    This function is called to disable the debugger.</span>
03338 <span class="comment"></span>
03339 <span class="comment">Arguments:</span>
03340 <span class="comment"></span>
03341 <span class="comment">    None.</span>
03342 <span class="comment"></span>
03343 <span class="comment">Return Value:</span>
03344 <span class="comment"></span>
03345 <span class="comment">    None.</span>
03346 <span class="comment"></span>
03347 <span class="comment">--*/</span>
03348 
03349 {
03350     KIRQL oldIrql ;
03351 
03352     <a class="code" href="../../d9/d5/verifier_8c.html#a116">KeRaiseIrql</a>(<a class="code" href="../../d6/d7/halmips_8h.html#a53">DISPATCH_LEVEL</a>, &amp;oldIrql) ;
03353     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a145">KdpPortLock</a>();
03354 
03355     <span class="keywordflow">if</span> (!<a class="code" href="../../d8/d3/kdapi_8c.html#a3">KdDisableCount</a>) {
03356 
03357         <a class="code" href="../../d8/d3/kdapi_8c.html#a4">KdPreviouslyEnabled</a> = <a class="code" href="../../d7/d3/kd_8h.html#a13">KdDebuggerEnabled</a> &amp;&amp; (!<a class="code" href="../../d7/d3/kd_8h.html#a7">KdPitchDebugger</a>) ;
03358         <span class="keywordflow">if</span> (<a class="code" href="../../d7/d3/kd_8h.html#a13">KdDebuggerEnabled</a>) {
03359 
03360             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a139">KdpSuspendAllBreakpoints</a>() ;
03361             <a class="code" href="../../d0/d7/kdp_8h.html#a24">KiDebugRoutine</a> = <a class="code" href="../../d7/d8/alpha_2kdtrap_8c.html#a2">KdpStub</a>;
03362             <a class="code" href="../../d7/d3/kd_8h.html#a13">KdDebuggerEnabled</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> ;
03363         }
03364     }
03365     <a class="code" href="../../d8/d3/kdapi_8c.html#a3">KdDisableCount</a>++ ;
03366     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a146">KdpPortUnlock</a>();
03367     <a class="code" href="../../d9/d5/verifier_8c.html#a117">KeLowerIrql</a>(oldIrql);
03368 }
03369 
03370 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l03371"></a><a class="code" href="../../d9/d3/4_2kdapi_8c.html#a35">03371</a> <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a35">KdEnableDebugger</a>(
03372    VOID
03373    )
03374 <span class="comment">/*++</span>
03375 <span class="comment"></span>
03376 <span class="comment">Routine Description:</span>
03377 <span class="comment"></span>
03378 <span class="comment">    This function is called to reenable the debugger after a call to</span>
03379 <span class="comment">    KdDisableDebugger.</span>
03380 <span class="comment"></span>
03381 <span class="comment">Arguments:</span>
03382 <span class="comment"></span>
03383 <span class="comment">    None.</span>
03384 <span class="comment"></span>
03385 <span class="comment">Return Value:</span>
03386 <span class="comment"></span>
03387 <span class="comment">    None.</span>
03388 <span class="comment"></span>
03389 <span class="comment">--*/</span>
03390 {
03391     KIRQL oldIrql ;
03392 
03393     <a class="code" href="../../d9/d5/verifier_8c.html#a116">KeRaiseIrql</a>(<a class="code" href="../../d6/d7/halmips_8h.html#a53">DISPATCH_LEVEL</a>, &amp;oldIrql) ;
03394     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a145">KdpPortLock</a>();
03395 
03396     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d8/d3/kdapi_8c.html#a3">KdDisableCount</a> &gt; 0) ;
03397     <a class="code" href="../../d8/d3/kdapi_8c.html#a3">KdDisableCount</a>-- ;
03398 
03399     <span class="keywordflow">if</span> (!<a class="code" href="../../d8/d3/kdapi_8c.html#a3">KdDisableCount</a>) {
03400         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d3/kdapi_8c.html#a4">KdPreviouslyEnabled</a>) {
03401 
03402             <span class="comment">//</span>
03403             <span class="comment">// Ugly HACKHACK - Make sure the timers aren't reset.</span>
03404             <span class="comment">//</span>
03405             <a class="code" href="../../d1/d2/po_8h.html#a55">PoHiberInProgress</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> ;
03406             <a class="code" href="../../d5/d6/4_2kdinit_8c.html#a4">KdInitSystem</a>(<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) ;
03407             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a140">KdpRestoreAllBreakpoints</a>();
03408             <a class="code" href="../../d1/d2/po_8h.html#a55">PoHiberInProgress</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> ;
03409         }
03410     }
03411     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a146">KdpPortUnlock</a>();
03412     <a class="code" href="../../d9/d5/verifier_8c.html#a117">KeLowerIrql</a>(oldIrql);
03413 }
03414 
03415 
03416 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l03417"></a><a class="code" href="../../d9/d3/4_2kdapi_8c.html#a12">03417</a> <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a12">KdpSearchMemory</a>(
03418     IN PDBGKD_MANIPULATE_STATE64 m,
03419     IN PSTRING AdditionalData,
03420     IN PCONTEXT Context
03421     )
03422 
03423 <span class="comment">/*++</span>
03424 <span class="comment"></span>
03425 <span class="comment">Routine Description:</span>
03426 <span class="comment"></span>
03427 <span class="comment">    This function implements a memory pattern searcher.  This will</span>
03428 <span class="comment">    find an instance of a pattern that begins in the range</span>
03429 <span class="comment">    SearchAddress..SearchAddress+SearchLength.  The pattern may</span>
03430 <span class="comment">    end outside of the range.</span>
03431 <span class="comment"></span>
03432 <span class="comment">Arguments:</span>
03433 <span class="comment"></span>
03434 <span class="comment">    m - Supplies the state manipulation message.</span>
03435 <span class="comment"></span>
03436 <span class="comment">    AdditionalData - Supplies the pattern to search for</span>
03437 <span class="comment"></span>
03438 <span class="comment">    Context - Supplies the current context.</span>
03439 <span class="comment"></span>
03440 <span class="comment">Return Value:</span>
03441 <span class="comment"></span>
03442 <span class="comment">    None.</span>
03443 <span class="comment"></span>
03444 <span class="comment">--*/</span>
03445 
03446 {
03447     PUCHAR <a class="code" href="../../d9/d4/localrtl_8c.html#a2">Pattern</a> = AdditionalData-&gt;Buffer;
03448     ULONG_PTR StartAddress = (ULONG_PTR)m-&gt;u.SearchMemory.SearchAddress;
03449     ULONG_PTR EndAddress = (ULONG_PTR)(StartAddress + m-&gt;u.SearchMemory.SearchLength);
03450     ULONG PatternLength = m-&gt;u.SearchMemory.PatternLength;
03451 
03452     STRING MessageHeader;
03453     ULONG MaskIndex;
03454     PUCHAR PatternTail;
03455     PUCHAR DataTail;
03456     ULONG TailLength;
03457     ULONG Data;
03458     ULONG FirstWordPattern[4];
03459     ULONG FirstWordMask[4];
03460 
03461 
03462     <span class="comment">//</span>
03463     <span class="comment">// On failure, return STATUS_NO_MORE_ENTRIES.  DON'T RETURN</span>
03464     <span class="comment">// STATUS_UNSUCCESSFUL!  That return status indicates that the</span>
03465     <span class="comment">// operation is not supported, and the debugger will fall back</span>
03466     <span class="comment">// to a debugger-side search.</span>
03467     <span class="comment">//</span>
03468 
03469     m-&gt;ReturnStatus = STATUS_NO_MORE_ENTRIES;
03470 
03471     <span class="comment">//</span>
03472     <span class="comment">// Do a fast search for the beginning of the pattern</span>
03473     <span class="comment">//</span>
03474 
03475     <span class="keywordflow">if</span> (PatternLength &gt; 3) {
03476         FirstWordMask[0] = 0xffffffff;
03477     } <span class="keywordflow">else</span> {
03478         FirstWordMask[0] = 0xffffffff &gt;&gt; (8*(4-PatternLength));
03479     }
03480 
03481     FirstWordMask[1] = FirstWordMask[0] &lt;&lt; 8;
03482     FirstWordMask[2] = FirstWordMask[1] &lt;&lt; 8;
03483     FirstWordMask[3] = FirstWordMask[2] &lt;&lt; 8;
03484 
03485     FirstWordPattern[0] = 0;
03486     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a111">KdpQuickMoveMemory</a>((PVOID)FirstWordPattern,
03487                        <a class="code" href="../../d9/d4/localrtl_8c.html#a2">Pattern</a>,
03488                        PatternLength &lt; 5 ? PatternLength : 4);
03489 
03490     FirstWordPattern[1] = FirstWordPattern[0] &lt;&lt; 8;
03491     FirstWordPattern[2] = FirstWordPattern[1] &lt;&lt; 8;
03492     FirstWordPattern[3] = FirstWordPattern[2] &lt;&lt; 8;
03493 
03494 
03495 <span class="comment">/*</span>
03496 <span class="comment">{</span>
03497 <span class="comment">    int i;</span>
03498 <span class="comment">    for (i = 0; i &lt; (int)PatternLength; i++) {</span>
03499 <span class="comment">        KdpDprintf("%08x: %02x\n", &amp;Pattern[i], Pattern[i]);</span>
03500 <span class="comment">    }</span>
03501 <span class="comment">    for (i = 0; i &lt; 4; i++) {</span>
03502 <span class="comment">        KdpDprintf("%d: %08x %08x\n", i, FirstWordPattern[i], FirstWordMask[i]);</span>
03503 <span class="comment">    }</span>
03504 <span class="comment">}</span>
03505 <span class="comment">*/</span>
03506 
03507 
03508 
03509     <span class="comment">//</span>
03510     <span class="comment">// Get starting mask</span>
03511     <span class="comment">//</span>
03512 
03513     MaskIndex = (ULONG) (StartAddress &amp; 3);
03514     StartAddress = StartAddress &amp; ~3;
03515 
03516     <span class="comment">//</span>
03517     <span class="comment">// check that the starting page is available</span>
03518     <span class="comment">//</span>
03519 
03520     <span class="keywordflow">if</span> (<a class="code" href="../../d4/d6/ppc_2debugsup_8c.html#a0">MmDbgReadCheck</a>((PVOID)StartAddress) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03521         StartAddress = (StartAddress + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>) &amp; ~(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>-1);
03522         MaskIndex = 0;
03523     }
03524 
03525     <span class="keywordflow">while</span> (StartAddress &lt; EndAddress) {
03526 
03527         <span class="comment">//</span>
03528         <span class="comment">// check when starting a new page</span>
03529         <span class="comment">//</span>
03530         <span class="keywordflow">if</span> ((StartAddress &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>-1)) == 0) {
03531             <span class="keywordflow">if</span> (<a class="code" href="../../d4/d6/ppc_2debugsup_8c.html#a0">MmDbgReadCheck</a>((PVOID)StartAddress) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03532                 StartAddress = StartAddress + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
03533                 <span class="keywordflow">continue</span>;
03534             }
03535         }
03536 
03537         <span class="comment">//</span>
03538         <span class="comment">// search for a match in each of the 4 starting positions</span>
03539         <span class="comment">//</span>
03540 
03541         Data = *(ULONG*)StartAddress;
03542 <span class="comment">//KdpDprintf("\n%08x: %08x ", StartAddress, Data);</span>
03543 
03544         <span class="keywordflow">for</span> ( ; MaskIndex &lt; 4; MaskIndex++) {
03545 <span class="comment">//KdpDprintf(" %d", MaskIndex);</span>
03546 
03547             <span class="keywordflow">if</span> ( (Data &amp; FirstWordMask[MaskIndex]) == FirstWordPattern[MaskIndex]) {
03548 
03549                 <span class="comment">//</span>
03550                 <span class="comment">// first word matched</span>
03551                 <span class="comment">//</span>
03552 
03553                 <span class="keywordflow">if</span> ( (4-MaskIndex) &gt;= PatternLength ) {
03554 
03555                     <span class="comment">//</span>
03556                     <span class="comment">// string is all in this word; good match</span>
03557                     <span class="comment">//</span>
03558 <span class="comment">//KdpDprintf(" %d hit, complete\n", MaskIndex);</span>
03559 
03560                     m-&gt;u.SearchMemory.FoundAddress = StartAddress + MaskIndex;
03561                     m-&gt;ReturnStatus = STATUS_SUCCESS;
03562                     <span class="keywordflow">goto</span> done;
03563 
03564                 } <span class="keywordflow">else</span> {
03565 
03566                     <span class="comment">//</span>
03567                     <span class="comment">// string is longer; see if tail matches</span>
03568                     <span class="comment">//</span>
03569 <span class="comment">//KdpDprintf(" %d hit, check tail\n", MaskIndex);</span>
03570 
03571                     PatternTail = <a class="code" href="../../d9/d4/localrtl_8c.html#a2">Pattern</a> + 4 - MaskIndex;
03572                     DataTail = (PUCHAR)StartAddress + 4;
03573                     TailLength = PatternLength - 4 + MaskIndex;
03574 
03575 <span class="comment">//KdpDprintf("Pattern == %08x\n", Pattern);</span>
03576 <span class="comment">//KdpDprintf("PatternTail == %08x\n", PatternTail);</span>
03577 <span class="comment">//KdpDprintf("DataTail == %08x\n", DataTail);</span>
03578 
03579                     <span class="keywordflow">while</span> (TailLength) {
03580                         <span class="keywordflow">if</span> ( ((ULONG_PTR)DataTail &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>-1)) == 0 &amp;&amp;
03581                              <a class="code" href="../../d4/d6/ppc_2debugsup_8c.html#a0">MmDbgReadCheck</a>(DataTail) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
03582 <span class="comment">//KdpDprintf("Tail failed: page not present at %08x\n", DataTail);</span>
03583                             <span class="keywordflow">break</span>;
03584                         } <span class="keywordflow">else</span>
03585 {
03586 <span class="comment">//KdpDprintf("D: %02x  P: %02x\n", *DataTail, *PatternTail);</span>
03587 
03588                         <span class="keywordflow">if</span> (*DataTail != *PatternTail) {
03589 <span class="comment">//KdpDprintf("Tail failed at %08x\n", DataTail);</span>
03590                             <span class="keywordflow">break</span>;
03591                         } <span class="keywordflow">else</span> {
03592                             DataTail++;
03593                             PatternTail++;
03594                             TailLength--;
03595                         }
03596 }
03597                     }
03598 
03599                     <span class="keywordflow">if</span> (TailLength == 0) {
03600 
03601                         <span class="comment">//</span>
03602                         <span class="comment">// A winner</span>
03603                         <span class="comment">//</span>
03604 
03605                         m-&gt;u.SearchMemory.FoundAddress = StartAddress + MaskIndex;
03606                         m-&gt;ReturnStatus = STATUS_SUCCESS;
03607                         <span class="keywordflow">goto</span> done;
03608 
03609                     }
03610                 }
03611             }
03612         }
03613 
03614         StartAddress += 4;
03615         MaskIndex = 0;
03616     }
03617 
03618 done:
03619 <span class="comment">//KdpDprintf("\n");</span>
03620     MessageHeader.Length = <span class="keyword">sizeof</span>(*m);
03621     MessageHeader.Buffer = (PCHAR)m;
03622 
03623     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(
03624         PACKET_TYPE_KD_STATE_MANIPULATE,
03625         &amp;MessageHeader,
03626         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
03627         );
03628 
03629 }
03630 
03631 
03632 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l03633"></a><a class="code" href="../../d1/d7/4_2kdp_8h.html#a127">03633</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a127">KdpCheckLowMemory</a>(
03634     IN PDBGKD_MANIPULATE_STATE64 Message
03635     )
03636 
03637 <span class="comment">/*++</span>
03638 <span class="comment"></span>
03639 <span class="comment">Routine Description:</span>
03640 <span class="comment"></span>
03641 <span class="comment"></span>
03642 <span class="comment">Arguments:</span>
03643 <span class="comment"></span>
03644 <span class="comment">    Message - Supplies the state manipulation message.</span>
03645 <span class="comment"></span>
03646 <span class="comment">Return Value:</span>
03647 <span class="comment"></span>
03648 <span class="comment">    None.</span>
03649 <span class="comment">    </span>
03650 <span class="comment">Description:</span>
03651 <span class="comment"></span>
03652 <span class="comment">    This function gets called when the !chklowmem</span>
03653 <span class="comment">    debugger extension is used.    </span>
03654 <span class="comment"></span>
03655 <span class="comment">--*/</span>
03656 
03657 {
03658 <span class="comment">//+silviuc: move to a header</span>
03659 <span class="preprocessor">#if defined (_X86PAE_)</span>
03660 <span class="preprocessor"></span>    LOGICAL
03661         MiCheckPhysicalPagePattern (
03662         PFN_NUMBER Page,
03663         PULONG CorruptionOffset
03664         );
03665 
03666     <span class="keyword">extern</span> PFN_NUMBER <a class="code" href="../../d6/d8/sysinfo_8c.html#a6">MmLowestPhysicalPage</a>;
03667     <span class="keyword">extern</span> PFN_NUMBER <a class="code" href="../../d6/d8/sysinfo_8c.html#a7">MmHighestPhysicalPage</a>;
03668     <span class="keyword">extern</span> LOGICAL <a class="code" href="../../d5/d6/iosup_8c.html#a15">MiNoLowMemory</a>;
03669 <span class="preprocessor">#endif // #if defined (_X86PAE_)</span>
03670 <span class="preprocessor"></span><span class="comment">//-silviuc</span>
03671 
03672     STRING MessageHeader;
03673     PFN_NUMBER Page;
03674     PHYSICAL_ADDRESS P;
03675     PVOID64 VirtualAddress;
03676     ULONG CorruptionOffset;
03677 
03678     Message-&gt;ReturnStatus = STATUS_SUCCESS;
03679     MessageHeader.Length = <span class="keyword">sizeof</span>(*Message);
03680     MessageHeader.Buffer = (PCHAR)Message;
03681     
03682     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d3/4_2kdapi_8c.html#a15">KdpSearchPhysicalMemoryRequested</a>()) {
03683       
03684         <span class="comment">//</span>
03685         <span class="comment">// This is a !search kd extension call.</span>
03686         <span class="comment">//</span>
03687 
03688         <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a16">KdpSearchPhysicalPageRange</a>();
03689     }
03690     <span class="keywordflow">else</span> {
03691 
03692         <span class="comment">//</span>
03693         <span class="comment">// Check PAE low physical memory</span>
03694         <span class="comment">//</span>
03695 
03696 <span class="preprocessor">#if defined (_X86PAE_)</span>
03697 <span class="preprocessor"></span>
03698         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/iosup_8c.html#a15">MiNoLowMemory</a>) {
03699 
03700             <span class="keywordflow">for</span> (Page = <a class="code" href="../../d6/d8/sysinfo_8c.html#a6">MmLowestPhysicalPage</a>;
03701                 Page &lt; <a class="code" href="../../d6/d8/sysinfo_8c.html#a7">MmHighestPhysicalPage</a> &amp;&amp; Page &lt; 1024 * 1024;
03702                 Page += 1) {
03703 
03704 
03705                 <span class="keywordflow">if</span> (! MiCheckPhysicalPagePattern (Page, &amp;CorruptionOffset)) {
03706                     Message-&gt;ReturnStatus = Page;
03707                     <span class="keywordflow">break</span>;
03708                 }
03709             }
03710         }
03711 
03712 <span class="preprocessor">#endif // #if defined (_X86PAE_)</span>
03713 <span class="preprocessor"></span>    }
03714 
03715     <span class="comment">//</span>
03716     <span class="comment">// Acknowledge the packet received.</span>
03717     <span class="comment">//</span>
03718 
03719     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a> (
03720         PACKET_TYPE_KD_STATE_MANIPULATE,
03721         &amp;MessageHeader,
03722         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
03723         );
03724 }
03725 
03726 
03727 
03728 <span class="comment">//</span>
03729 <span class="comment">// !search support routines</span>
03730 <span class="comment">//</span>
03731 
03732 
03733 
03734 ULONG
<a name="l03735"></a><a class="code" href="../../d9/d3/4_2kdapi_8c.html#a13">03735</a> <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a13">KdpSearchHammingDistance</a> (
03736     ULONG_PTR Left,
03737     ULONG_PTR Right
03738     )
03739 <span class="comment">/*++</span>
03740 <span class="comment"></span>
03741 <span class="comment">Routine Description:</span>
03742 <span class="comment"></span>
03743 <span class="comment">    This routine computes the Hamming distance (# of positions where the</span>
03744 <span class="comment">    values are different). </span>
03745 <span class="comment">    </span>
03746 <span class="comment">    If this function becomes a bottleneck we should switch to a function </span>
03747 <span class="comment">    table version.</span>
03748 <span class="comment"></span>
03749 <span class="comment">Arguments:</span>
03750 <span class="comment"></span>
03751 <span class="comment">    Left, Right operand.</span>
03752 <span class="comment"></span>
03753 <span class="comment">Return Value:</span>
03754 <span class="comment"></span>
03755 <span class="comment">    Hamming distance.</span>
03756 <span class="comment"></span>
03757 <span class="comment">Environment:</span>
03758 <span class="comment"></span>
03759 <span class="comment">    Any.</span>
03760 <span class="comment"></span>
03761 <span class="comment">--*/</span>
03762 
03763 {
03764     ULONG_PTR Value;
03765     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
03766     ULONG Distance;
03767 
03768     Value = Left ^ Right;
03769     Distance = 0;
03770 
03771     <span class="keywordflow">for</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; 8 * <span class="keyword">sizeof</span>(ULONG_PTR); <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>++) {
03772 
03773         <span class="keywordflow">if</span> ((Value &amp; (ULONG_PTR)0x01)) {
03774             
03775             Distance += 1;
03776         }
03777 
03778         Value &gt;&gt;= 1;        
03779     }
03780 
03781     <span class="keywordflow">return</span> Distance;
03782 }
03783 
03784 
03785 
03786 LOGICAL
<a name="l03787"></a><a class="code" href="../../d9/d3/4_2kdapi_8c.html#a14">03787</a> <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a14">KdpSearchPhysicalPage</a> (
03788     IN PFN_NUMBER PageFrameIndex,
03789     ULONG_PTR RangeStart,
03790     ULONG_PTR RangeEnd,
03791     ULONG Flags
03792     )
03793 <span class="comment">/*++</span>
03794 <span class="comment"></span>
03795 <span class="comment">Routine Description:</span>
03796 <span class="comment"></span>
03797 <span class="comment">    This routine searches the physical page corresponding to a</span>
03798 <span class="comment">    certain PFN index for any ULONG_PTR values in range [Start..End].</span>
03799 <span class="comment"></span>
03800 <span class="comment">Arguments:</span>
03801 <span class="comment"></span>
03802 <span class="comment">    PageFrameIndex - PFN index</span>
03803 <span class="comment">    </span>
03804 <span class="comment">    RangeStart - lowest possible value searched for</span>
03805 <span class="comment">    </span>
03806 <span class="comment">    RangeEnd - highest possible value searched for</span>
03807 <span class="comment">    </span>
03808 <span class="comment">    Flags - flags to control the search</span>
03809 <span class="comment"></span>
03810 <span class="comment">Return Value:</span>
03811 <span class="comment"></span>
03812 <span class="comment">    TRUE if a hit has been found, FALSE otherwise.</span>
03813 <span class="comment">    The function stops after the first hit in the page is</span>
03814 <span class="comment">    encountered and the infromation related to the hit (PFN index,</span>
03815 <span class="comment">    offset, corrsponding VA) is registered in the hit database.</span>
03816 <span class="comment"></span>
03817 <span class="comment">Environment:</span>
03818 <span class="comment"></span>
03819 <span class="comment">    Call triggered only from Kd extension.</span>
03820 <span class="comment"></span>
03821 <span class="comment">--*/</span>
03822 
03823 {
03824     PCHAR Va;
03825     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
03826     PHYSICAL_ADDRESS Pa;
03827     ULONG_PTR Value;
03828 
03829     <span class="comment">//</span>
03830     <span class="comment">// Map the physical page using the debug PTE.</span>
03831     <span class="comment">//</span>
03832 
03833     Pa.QuadPart = ((ULONGLONG)PageFrameIndex) &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
03834 
03835     Va = (PCHAR) <a class="code" href="../../d2/d6/ia64_2debugsup_8c.html#a3">MmDbgTranslatePhysicalAddress64</a> (Pa);
03836 
03837     <span class="keywordflow">for</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - <span class="keyword">sizeof</span>(ULONG_PTR); <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> += 1, Va += 1) {
03838 
03839         Value = *((PULONG_PTR)Va);
03840 
03841         <span class="keywordflow">if</span> ((Value &gt;= RangeStart &amp;&amp; Value &lt;= RangeEnd) 
03842             || <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a13">KdpSearchHammingDistance</a>(Value, RangeStart) == 1) {
03843 
03844             <span class="keywordflow">if</span> (<a class="code" href="../../d9/d5/4_2kddata_8c.html#a110">KdpSearchPageHitIndex</a> &lt; <a class="code" href="../../d1/d7/4_2kdp_8h.html#a17">SEARCH_PAGE_HIT_DATABASE_SIZE</a>) {
03845 
03846                 <a class="code" href="../../d9/d5/4_2kddata_8c.html#a108">KdpSearchPageHits</a>[<a class="code" href="../../d9/d5/4_2kddata_8c.html#a110">KdpSearchPageHitIndex</a>] = PageFrameIndex;
03847                 <a class="code" href="../../d9/d5/4_2kddata_8c.html#a109">KdpSearchPageHitOffsets</a>[<a class="code" href="../../d9/d5/4_2kddata_8c.html#a110">KdpSearchPageHitIndex</a>] = <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
03848                 
03849                 <a class="code" href="../../d9/d5/4_2kddata_8c.html#a110">KdpSearchPageHitIndex</a> += 1;
03850             }
03851 
03852             <span class="keywordflow">if</span> ((Flags &amp; <a class="code" href="../../d1/d7/4_2kdp_8h.html#a19">KDP_SEARCH_ALL_OFFSETS_IN_PAGE</a>)) {
03853 
03854                 <span class="keywordflow">continue</span>;
03855             }
03856             <span class="keywordflow">else</span> {
03857 
03858                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03859             }
03860         }
03861     }
03862 
03863     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03864 }
03865 
03866 
03867 
03868 LOGICAL
<a name="l03869"></a><a class="code" href="../../d9/d3/4_2kdapi_8c.html#a15">03869</a> <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a15">KdpSearchPhysicalMemoryRequested</a> (
03870     VOID
03871     )
03872 <span class="comment">/*++</span>
03873 <span class="comment"></span>
03874 <span class="comment">Routine Description:</span>
03875 <span class="comment"></span>
03876 <span class="comment">    This routine determines if a physical range search has been</span>
03877 <span class="comment">    requested. This is controlled by a global variable set in</span>
03878 <span class="comment">    the `!search' debug extension.</span>
03879 <span class="comment"></span>
03880 <span class="comment">Arguments:</span>
03881 <span class="comment"></span>
03882 <span class="comment">    None</span>
03883 <span class="comment"></span>
03884 <span class="comment">Return Value:</span>
03885 <span class="comment"></span>
03886 <span class="comment">    TRUE if physical range search was requested.</span>
03887 <span class="comment">    </span>
03888 <span class="comment"></span>
03889 <span class="comment">Environment:</span>
03890 <span class="comment"></span>
03891 <span class="comment">    Call triggered only from Kd extension.</span>
03892 <span class="comment"></span>
03893 <span class="comment">--*/</span>
03894 {
03895     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d5/4_2kddata_8c.html#a111">KdpSearchInProgress</a>) {
03896         
03897         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03898     }
03899     <span class="keywordflow">else</span> {
03900 
03901         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03902     }
03903 
03904 }
03905 
03906 
03907 
03908 LOGICAL
<a name="l03909"></a><a class="code" href="../../d9/d3/4_2kdapi_8c.html#a16">03909</a> <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a16">KdpSearchPhysicalPageRange</a> (
03910     VOID
03911     )
03912 <span class="comment">/*++</span>
03913 <span class="comment"></span>
03914 <span class="comment">Routine Description:</span>
03915 <span class="comment"></span>
03916 <span class="comment">    This routine will start a search in a range of physical pages in case</span>
03917 <span class="comment">    `KdpSearchInProgress' is true. the parameters for the search are picked up</span>
03918 <span class="comment">    from global vairiables that are set inside a kernel debugger extension.</span>
03919 <span class="comment"></span>
03920 <span class="comment">Arguments:</span>
03921 <span class="comment"></span>
03922 <span class="comment">    None</span>
03923 <span class="comment"></span>
03924 <span class="comment">Return Value:</span>
03925 <span class="comment"></span>
03926 <span class="comment">    TRUE if the function executed a search and FALSE otherwise.</span>
03927 <span class="comment">    The results of the search are specified in the KdpSearchPageHits</span>
03928 <span class="comment">    and related variables. this global variables offers the mechanism</span>
03929 <span class="comment">    for the debugger extension to pickup the results of the search.</span>
03930 <span class="comment">    </span>
03931 <span class="comment"></span>
03932 <span class="comment">Environment:</span>
03933 <span class="comment"></span>
03934 <span class="comment">    Call triggered only from Kd extension.</span>
03935 <span class="comment">    </span>
03936 <span class="comment">    Note. The !search extension make sure that the range requested</span>
03937 <span class="comment">    is part of the system memory therefore we do not have to</span>
03938 <span class="comment">    worry about sparse PFN databases here.</span>
03939 <span class="comment"></span>
03940 <span class="comment">--*/</span>
03941 
03942 {
03943     PFN_NUMBER CurrentFrame;
03944     ULONG Flags;
03945 
03946     <span class="comment">//</span>
03947     <span class="comment">// The debugger extension is supposed to set KdpSearchInProgress</span>
03948     <span class="comment">// to TRUE if a search is requested. </span>
03949     <span class="comment">//</span>
03950 
03951     <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d5/4_2kddata_8c.html#a111">KdpSearchInProgress</a>) {
03952 
03953         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03954     }
03955 
03956 
03957     Flags = 0;
03958 
03959     <span class="comment">//</span>
03960     <span class="comment">// If the search range is only one page we will give all</span>
03961     <span class="comment">// hits inside a page. By default we get only the first hit inside</span>
03962     <span class="comment">// a page.</span>
03963     <span class="comment">//</span>
03964 
03965     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d5/4_2kddata_8c.html#a113">KdpSearchEndPageFrame</a> == <a class="code" href="../../d9/d5/4_2kddata_8c.html#a112">KdpSearchStartPageFrame</a>) {
03966 
03967         <a class="code" href="../../d9/d5/4_2kddata_8c.html#a113">KdpSearchEndPageFrame</a> += 1;
03968 
03969         Flags |= <a class="code" href="../../d1/d7/4_2kdp_8h.html#a19">KDP_SEARCH_ALL_OFFSETS_IN_PAGE</a>;
03970     }
03971 
03972     <span class="keywordflow">for</span> (CurrentFrame = <a class="code" href="../../d9/d5/4_2kddata_8c.html#a112">KdpSearchStartPageFrame</a>; 
03973          CurrentFrame &lt; <a class="code" href="../../d9/d5/4_2kddata_8c.html#a113">KdpSearchEndPageFrame</a>; 
03974          CurrentFrame += 1) {
03975 
03976         <a class="code" href="../../d9/d3/4_2kdapi_8c.html#a14">KdpSearchPhysicalPage</a> (CurrentFrame, 
03977                               <a class="code" href="../../d9/d5/4_2kddata_8c.html#a114">KdpSearchAddressRangeStart</a>,
03978                               <a class="code" href="../../d9/d5/4_2kddata_8c.html#a115">KdpSearchAddressRangeEnd</a>,
03979                               Flags);
03980         
03981     }
03982 
03983     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03984 }
03985 
03986 
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:33 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
