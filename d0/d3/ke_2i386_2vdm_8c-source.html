<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: vdm.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>vdm.c</h1><a href="../../d9/d3/ke_2i386_2vdm_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1990  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    VDM.C</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module contains support routines for the x86 monitor for</span>
00012 <span class="comment">    running Dos applications in V86 mode.</span>
00013 <span class="comment"></span>
00014 <span class="comment">Author:</span>
00015 <span class="comment"></span>
00016 <span class="comment">    Dave Hastings (daveh) 20 Mar 1991</span>
00017 <span class="comment"></span>
00018 <span class="comment">Environment:</span>
00019 <span class="comment"></span>
00020 <span class="comment">    The code in this module is all x86 specific.</span>
00021 <span class="comment"></span>
00022 <span class="comment">Notes:</span>
00023 <span class="comment"></span>
00024 <span class="comment">    In its current implementation, this code is less robust than it needs</span>
00025 <span class="comment">    to be.  This will be fixed.  Specifically, parameter verification needs</span>
00026 <span class="comment">    to be done. (daveh 7/15/91)</span>
00027 <span class="comment"></span>
00028 <span class="comment">    Support for 32 bit segements (2/2/92)</span>
00029 <span class="comment">Revision History:</span>
00030 <span class="comment"></span>
00031 <span class="comment">    20-Mar-1991 daveh</span>
00032 <span class="comment">        created</span>
00033 <span class="comment">--*/</span>
00034 
00035 <span class="preprocessor">#include "<a class="code" href="../../d0/d0/ki_8h.html">ki.h</a>"</span>
00036 <span class="preprocessor">#pragma hdrstop</span>
00037 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="../../d1/d5/vdmntos_8h.html">vdmntos.h</a>"</span>
00038 
<a name="l00039"></a><a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a0">00039</a> <span class="preprocessor">#define VDM_IO_TEST 0</span>
00040 <span class="preprocessor"></span>
00041 <span class="preprocessor">#if VDM_IO_TEST</span>
00042 <span class="preprocessor"></span><a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00043 TestIoHandlerStuff(
00044     VOID
00045     );
00046 <span class="preprocessor">#endif</span>
00047 <span class="preprocessor"></span>
00048 BOOLEAN
00049 <a class="code" href="../../d8/d4/vdmint21_8c.html#a6">Ki386GetSelectorParameters</a>(
00050     IN USHORT Selector,
00051     OUT PULONG Flags,
00052     OUT PULONG Base,
00053     OUT PULONG Limit
00054     );
00055 
00056 
00057 BOOLEAN
00058 <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a10">Ki386VdmDispatchIo</a>(
00059     IN ULONG PortNumber,
00060     IN ULONG Size,
00061     IN BOOLEAN Read,
00062     IN UCHAR InstructionSize,
00063     IN PKTRAP_FRAME TrapFrame
00064     );
00065 
00066 BOOLEAN
00067 <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a11">Ki386VdmDispatchStringIo</a>(
00068     IN ULONG PortNumber,
00069     IN ULONG Size,
00070     IN BOOLEAN Rep,
00071     IN BOOLEAN Read,
00072     IN ULONG Count,
00073     IN ULONG Address,
00074     IN UCHAR InstructionSize,
00075     IN PKTRAP_FRAME TrapFrame
00076     );
00077 
00078 
00079 BOOLEAN
00080 <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a12">VdmDispatchIoToHandler</a>(
00081     IN PVDM_IO_HANDLER VdmIoHandler,
00082     IN ULONG Context,
00083     IN ULONG PortNumber,
00084     IN ULONG Size,
00085     IN BOOLEAN Read,
00086     IN OUT PULONG Data
00087     );
00088 
00089 BOOLEAN
00090 <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a13">VdmDispatchUnalignedIoToHandler</a>(
00091     IN PVDM_IO_HANDLER VdmIoHandler,
00092     IN ULONG Context,
00093     IN ULONG PortNumber,
00094     IN ULONG Size,
00095     IN BOOLEAN Read,
00096     IN OUT PULONG Data
00097     );
00098 
00099 BOOLEAN
00100 <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a14">VdmDispatchStringIoToHandler</a>(
00101     IN PVDM_IO_HANDLER VdmIoHandler,
00102     IN ULONG Context,
00103     IN ULONG PortNumber,
00104     IN ULONG Size,
00105     IN ULONG Count,
00106     IN BOOLEAN Read,
00107     IN ULONG Data
00108     );
00109 
00110 BOOLEAN
00111 <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a15">VdmCallStringIoHandler</a>(
00112     IN PVDM_IO_HANDLER VdmIoHandler,
00113     IN PVOID StringIoRoutine,
00114     IN ULONG Context,
00115     IN ULONG PortNumber,
00116     IN ULONG Size,
00117     IN ULONG Count,
00118     IN BOOLEAN Read,
00119     IN ULONG Data
00120     );
00121 
00122 BOOLEAN
00123 <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a19">VdmConvertToLinearAddress</a>(
00124     IN ULONG SegmentedAddress,
00125     IN PVOID *LinearAddress
00126     );
00127 
00128 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00129 <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a17">KeI386VdmInitialize</a>(
00130     VOID
00131     );
00132 
00133 ULONG
00134 <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a18">Ki386VdmEnablePentiumExtentions</a>(
00135     ULONG
00136     );
00137 
00138 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00139 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, Ki386GetSelectorParameters)</span>
00140 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, Ki386VdmDispatchIo)</span>
00141 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, Ki386VdmDispatchStringIo)</span>
00142 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, VdmDispatchIoToHandler)</span>
00143 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, VdmDispatchUnalignedIoToHandler)</span>
00144 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, VdmDispatchStringIoToHandler)</span>
00145 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, VdmCallStringIoHandler)</span>
00146 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, VdmConvertToLinearAddress)</span>
00147 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(INIT, KeI386VdmInitialize)</span>
00148 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00149 <span class="preprocessor"></span>
<a name="l00150"></a><a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a2">00150</a> <a class="code" href="../../d3/d7/struct__KMUTANT.html">KMUTEX</a> <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a2">VdmStringIoMutex</a>;
<a name="l00151"></a><a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a3">00151</a> ULONG <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a3">VdmFixedStateLinear</a>;
00152 
<a name="l00153"></a><a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a4">00153</a> ULONG <a class="code" href="../../d5/d3/i386_8h.html#a17">KeI386EFlagsAndMaskV86</a> = EFLAGS_USER_SANITIZE;
<a name="l00154"></a><a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a5">00154</a> ULONG <a class="code" href="../../d5/d3/i386_8h.html#a18">KeI386EFlagsOrMaskV86</a> = EFLAGS_INTERRUPT_MASK;
<a name="l00155"></a><a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a6">00155</a> BOOLEAN <a class="code" href="../../d5/d3/i386_8h.html#a19">KeI386VdmIoplAllowed</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
<a name="l00156"></a><a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a7">00156</a> ULONG <a class="code" href="../../d5/d3/i386_8h.html#a20">KeI386VirtualIntExtensions</a> = 0;
00157 
00158 
00159 BOOLEAN
<a name="l00160"></a><a class="code" href="../../d5/d3/i386_8h.html#a35">00160</a> <a class="code" href="../../d8/d4/vdmint21_8c.html#a6">Ki386GetSelectorParameters</a>(
00161     IN USHORT Selector,
00162     OUT PULONG Flags,
00163     OUT PULONG Base,
00164     OUT PULONG Limit
00165     )
00166 
00167 <span class="comment">/*++</span>
00168 <span class="comment"></span>
00169 <span class="comment">Routine Description:</span>
00170 <span class="comment"></span>
00171 <span class="comment">    This routine gets information about a selector in the ldt, and</span>
00172 <span class="comment">    returns it to the caller.</span>
00173 <span class="comment"></span>
00174 <span class="comment">Arguments:</span>
00175 <span class="comment"></span>
00176 <span class="comment">    IN USHORT Selector -- selector number for selector to return info for</span>
00177 <span class="comment">    OUT PULONG Flags -- flags indicating the type of the selector.</span>
00178 <span class="comment">    OUT PULONG Base -- base linear address of the selector</span>
00179 <span class="comment">    OUT PULONG Limit -- limit of the selector.</span>
00180 <span class="comment"></span>
00181 <span class="comment">Return Value:</span>
00182 <span class="comment"></span>
00183 <span class="comment">    return-value - True if the selector is in the LDT, and present.</span>
00184 <span class="comment">                    False otherwise.</span>
00185 <span class="comment">Note:</span>
00186 <span class="comment"></span>
00187 <span class="comment">    This routine should probably be somewhere else.  There are a number</span>
00188 <span class="comment">    of issues to clear up with respect to selectors and the kernel, and</span>
00189 <span class="comment">    after they have been cleared up, this code will be moved to its</span>
00190 <span class="comment">    correct place</span>
00191 <span class="comment"></span>
00192 <span class="comment">--*/</span>
00193 
00194 {
00195 
00196     PLDT_ENTRY Ldt,OldLdt;
00197     ULONG LdtLimit,OldLdtLimit,RetryCount = 0;
00198     <a class="code" href="../../d5/d7/struct__KPROCESS.html">PKPROCESS</a> Process;
00199     BOOLEAN ReturnValue;
00200 
00201     *Flags = 0;
00202 
00203     <span class="keywordflow">if</span> ((Selector &amp; (SELECTOR_TABLE_INDEX | DPL_USER))
00204         != (SELECTOR_TABLE_INDEX | DPL_USER)) {
00205         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00206     }
00207 
00208 
00209     Process = <a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>()-&gt;ApcState.Process;
00210     Ldt = (PLDT_ENTRY)((Process-&gt;LdtDescriptor.BaseLow) |
00211         (Process-&gt;LdtDescriptor.HighWord.Bytes.BaseMid &lt;&lt; 16) |
00212         (Process-&gt;LdtDescriptor.HighWord.Bytes.BaseHi &lt;&lt; 24));
00213 
00214     LdtLimit = ((Process-&gt;LdtDescriptor.LimitLow) |
00215         (Process-&gt;LdtDescriptor.HighWord.Bits.LimitHi &lt;&lt; 16));
00216 
00217     Selector &amp;= ~(SELECTOR_TABLE_INDEX | DPL_USER);
00218 
00219     <span class="comment">//</span>
00220     <span class="comment">// Under normal circumstances, we will only execute the following loop</span>
00221     <span class="comment">// once.  If there is a bug in the user mode wow code however, the LDT</span>
00222     <span class="comment">// may change while we execute the following code.  We don't want to take</span>
00223     <span class="comment">// the Ldt mutex, because that is expensive.</span>
00224     <span class="comment">//</span>
00225 
00226     <span class="keywordflow">do</span> {
00227 
00228         RetryCount++;
00229 
00230         <span class="keywordflow">if</span> (((ULONG)Selector &gt;= LdtLimit) || (!Ldt)) {
00231             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00232         }
00233 
00234         <span class="keywordflow">try</span> {
00235 
00236             <span class="keywordflow">if</span> (!Ldt[Selector/<span class="keyword">sizeof</span>(LDT_ENTRY)].HighWord.Bits.Pres) {
00237                 *Flags = SEL_TYPE_NP;
00238                 ReturnValue = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00239             } <span class="keywordflow">else</span> {
00240 
00241                 *Base = (Ldt[Selector/<span class="keyword">sizeof</span>(LDT_ENTRY)].BaseLow |
00242                     (Ldt[Selector/<span class="keyword">sizeof</span>(LDT_ENTRY)].HighWord.Bytes.BaseMid &lt;&lt; 16) |
00243                     (Ldt[Selector/<span class="keyword">sizeof</span>(LDT_ENTRY)].HighWord.Bytes.BaseHi &lt;&lt; 24));
00244 
00245                 *Limit = (Ldt[Selector/<span class="keyword">sizeof</span>(LDT_ENTRY)].LimitLow |
00246                     (Ldt[Selector/<span class="keyword">sizeof</span>(LDT_ENTRY)].HighWord.Bits.LimitHi &lt;&lt; 16));
00247 
00248                 *Flags = 0;
00249 
00250                 <span class="keywordflow">if</span> ((Ldt[Selector/<span class="keyword">sizeof</span>(LDT_ENTRY)].HighWord.Bits.Type &amp; 0x18) == 0x18) {
00251                     *Flags |= <a class="code" href="../../d2/d5/ke_2i386_2vdmp_8h.html#a7">SEL_TYPE_EXECUTE</a>;
00252 
00253                     <span class="keywordflow">if</span> (Ldt[Selector/<span class="keyword">sizeof</span>(LDT_ENTRY)].HighWord.Bits.Type &amp; 0x02) {
00254                         *Flags |= <a class="code" href="../../d2/d5/ke_2i386_2vdmp_8h.html#a5">SEL_TYPE_READ</a>;
00255                     }
00256                 } <span class="keywordflow">else</span> {
00257                     *Flags |= <a class="code" href="../../d2/d5/ke_2i386_2vdmp_8h.html#a5">SEL_TYPE_READ</a>;
00258                     <span class="keywordflow">if</span> (Ldt[Selector/<span class="keyword">sizeof</span>(LDT_ENTRY)].HighWord.Bits.Type &amp; 0x02) {
00259                         *Flags |= <a class="code" href="../../d2/d5/ke_2i386_2vdmp_8h.html#a6">SEL_TYPE_WRITE</a>;
00260                     }
00261                     <span class="keywordflow">if</span> (Ldt[Selector/<span class="keyword">sizeof</span>(LDT_ENTRY)].HighWord.Bits.Type &amp; 0x04) {
00262                         *Flags |= <a class="code" href="../../d2/d5/ke_2i386_2vdmp_8h.html#a9">SEL_TYPE_ED</a>;
00263                     }
00264                 }
00265 
00266                 <span class="keywordflow">if</span> (Ldt[Selector/<span class="keyword">sizeof</span>(LDT_ENTRY)].HighWord.Bits.Default_Big) {
00267                     *Flags |= <a class="code" href="../../d2/d5/ke_2i386_2vdmp_8h.html#a8">SEL_TYPE_BIG</a>;
00268                 }
00269 
00270                 <span class="keywordflow">if</span> (Ldt[Selector/<span class="keyword">sizeof</span>(LDT_ENTRY)].HighWord.Bits.Granularity) {
00271                     *Flags |= <a class="code" href="../../d2/d5/ke_2i386_2vdmp_8h.html#a10">SEL_TYPE_2GIG</a>;
00272                 }
00273             }
00274             ReturnValue = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00275         } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00276             <span class="comment">// Don't do anything here.  We took the fault because the</span>
00277             <span class="comment">// Ldt moved.  We will get an answer the next time around</span>
00278         }
00279 
00280         <span class="comment">//</span>
00281         <span class="comment">// If we can't get an answer in 10 tries, we never will</span>
00282         <span class="comment">//</span>
00283         <span class="keywordflow">if</span> ((RetryCount &gt; 10)) {
00284             ReturnValue = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00285         }
00286 
00287         <span class="keywordflow">if</span> (ReturnValue == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00288             <span class="keywordflow">break</span>;
00289         }
00290 
00291         OldLdt = Ldt;
00292         OldLdtLimit = LdtLimit;
00293 
00294         Ldt = (PLDT_ENTRY)((Process-&gt;LdtDescriptor.BaseLow) |
00295             (Process-&gt;LdtDescriptor.HighWord.Bytes.BaseMid &lt;&lt; 16) |
00296             (Process-&gt;LdtDescriptor.HighWord.Bytes.BaseHi &lt;&lt; 24));
00297 
00298         LdtLimit = ((Process-&gt;LdtDescriptor.LimitLow) |
00299             (Process-&gt;LdtDescriptor.HighWord.Bits.LimitHi &lt;&lt; 16));
00300 
00301     } <span class="keywordflow">while</span> ((Ldt != OldLdt) || (LdtLimit != OldLdtLimit));
00302 
00303     <span class="keywordflow">return</span> ReturnValue;
00304 }
00305 
00306 BOOLEAN
<a name="l00307"></a><a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a10">00307</a> <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a10">Ki386VdmDispatchIo</a>(
00308     IN ULONG PortNumber,
00309     IN ULONG Size,
00310     IN BOOLEAN Read,
00311     IN UCHAR InstructionSize,
00312     IN PKTRAP_FRAME TrapFrame
00313     )
00314 <span class="comment">/*++</span>
00315 <span class="comment"></span>
00316 <span class="comment">Routine Description:</span>
00317 <span class="comment"></span>
00318 <span class="comment">    This routine sets up the Event info for an IO event, and causes the</span>
00319 <span class="comment">    event to be reflected to the Monitor.</span>
00320 <span class="comment"></span>
00321 <span class="comment">    It is assumed that interrupts are enabled upon entry, and Irql is</span>
00322 <span class="comment">    at APC level.</span>
00323 <span class="comment"></span>
00324 <span class="comment">Arguments:</span>
00325 <span class="comment"></span>
00326 <span class="comment">    PortNumber -- Supplies the port number the IO was done to</span>
00327 <span class="comment">    Size -- Supplies the size of the IO operation.</span>
00328 <span class="comment">    Read -- Indicates whether the IO operation was a read or a write.</span>
00329 <span class="comment">    InstructionSize -- Supplies the size of the IO instruction in bytes.</span>
00330 <span class="comment"></span>
00331 <span class="comment">Return Value:</span>
00332 <span class="comment"></span>
00333 <span class="comment">    True if the io instruction will be reflected to User mode.</span>
00334 <span class="comment"></span>
00335 <span class="comment">--*/</span>
00336 {
00337     <a class="code" href="../../d0/d6/struct__Vdm__Tib.html">PVDM_TIB</a> VdmTib;
00338     EXCEPTION_RECORD ExceptionRecord;
00339     VDM_IO_HANDLER VdmIoHandler;
00340     ULONG Result;
00341     BOOLEAN Success = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00342     ULONG Context;
00343 
00344     Success = <a class="code" href="../../d3/d2/i386_2psvdm_8c.html#a10">Ps386GetVdmIoHandler</a>(
00345         <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>(),
00346         PortNumber &amp; ~0x3,
00347         &amp;VdmIoHandler,
00348         &amp;Context
00349         );
00350 
00351     <span class="keywordflow">if</span> (Success) {
00352         Result = TrapFrame-&gt;Eax;
00353         <span class="comment">// if port is not aligned, perform unaligned IO</span>
00354         <span class="comment">// else do the io the easy way</span>
00355         <span class="keywordflow">if</span> (PortNumber % <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>) {
00356             Success = <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a13">VdmDispatchUnalignedIoToHandler</a>(
00357                 &amp;VdmIoHandler,
00358                 Context,
00359                 PortNumber,
00360                 <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>,
00361                 Read,
00362                 &amp;Result
00363                 );
00364         } <span class="keywordflow">else</span> {
00365             Success = <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a12">VdmDispatchIoToHandler</a>(
00366                 &amp;VdmIoHandler,
00367                 Context,
00368                 PortNumber,
00369                 <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>,
00370                 Read,
00371                 &amp;Result
00372                 );
00373         }
00374     }
00375 
00376     <span class="keywordflow">if</span> (Success) {
00377         <span class="keywordflow">if</span> (Read) {
00378             <span class="keywordflow">switch</span> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>) {
00379             <span class="keywordflow">case</span> 4:
00380                 TrapFrame-&gt;Eax = Result;
00381                 <span class="keywordflow">break</span>;
00382             <span class="keywordflow">case</span> 2:
00383                 *(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>)(&amp;TrapFrame-&gt;Eax) = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)Result;
00384                 <span class="keywordflow">break</span>;
00385             <span class="keywordflow">case</span> 1:
00386                 *(PUCHAR)(&amp;TrapFrame-&gt;Eax) = (UCHAR)Result;
00387                 <span class="keywordflow">break</span>;
00388             }
00389         }
00390         TrapFrame-&gt;Eip += (ULONG) InstructionSize;
00391         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00392     } <span class="keywordflow">else</span> {
00393         <span class="keywordflow">try</span> {
00394             VdmTib = 
00395                 ((PVDM_PROCESS_OBJECTS)<a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>()-&gt;VdmObjects)-&gt;VdmTib;
00396             VdmTib-&gt;<a class="code" href="../../d0/d6/struct__Vdm__Tib.html#o5">EventInfo</a>.<a class="code" href="../../d1/d6/struct__VdmEventInfo.html#o2">InstructionSize</a> = (ULONG) InstructionSize;
00397             VdmTib-&gt;<a class="code" href="../../d0/d6/struct__Vdm__Tib.html#o5">EventInfo</a>.<a class="code" href="../../d1/d6/struct__VdmEventInfo.html#o1">Event</a> = <a class="code" href="../../d2/d5/ke_2i386_2vdmp_8h.html#a33a25">VdmIO</a>;
00398             VdmTib-&gt;<a class="code" href="../../d0/d6/struct__Vdm__Tib.html#o5">EventInfo</a>.<a class="code" href="../../d1/d6/struct__VdmEventInfo.html#o3">IoInfo</a>.<a class="code" href="../../d3/d6/struct__VdmIoInfo.html#o0">PortNumber</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)PortNumber;
00399             VdmTib-&gt;<a class="code" href="../../d0/d6/struct__Vdm__Tib.html#o5">EventInfo</a>.<a class="code" href="../../d1/d6/struct__VdmEventInfo.html#o3">IoInfo</a>.<a class="code" href="../../d3/d6/struct__VdmIoInfo.html#o1">Size</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
00400             VdmTib-&gt;<a class="code" href="../../d0/d6/struct__Vdm__Tib.html#o5">EventInfo</a>.<a class="code" href="../../d1/d6/struct__VdmEventInfo.html#o3">IoInfo</a>.<a class="code" href="../../d3/d6/struct__VdmIoInfo.html#o2">Read</a> = Read;
00401         } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00402             ExceptionRecord.ExceptionCode = STATUS_ACCESS_VIOLATION;
00403             ExceptionRecord.ExceptionFlags = 0;
00404             ExceptionRecord.NumberParameters = 0;
00405             <a class="code" href="../../d5/d8/ex_8h.html#a302">ExRaiseException</a>(&amp;ExceptionRecord);
00406             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00407         }
00408     }
00409 
00410     <a class="code" href="../../d7/d7/strtexec_8c.html#a1">VdmEndExecution</a>(TrapFrame, VdmTib);
00411 
00412     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00413 
00414 }
00415 
00416 
00417 BOOLEAN
<a name="l00418"></a><a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a11">00418</a> <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a11">Ki386VdmDispatchStringIo</a>(
00419     IN ULONG PortNumber,
00420     IN ULONG Size,
00421     IN BOOLEAN Rep,
00422     IN BOOLEAN Read,
00423     IN ULONG Count,
00424     IN ULONG Address,
00425     IN UCHAR InstructionSize,
00426     IN PKTRAP_FRAME TrapFrame
00427     )
00428 <span class="comment">/*++</span>
00429 <span class="comment"></span>
00430 <span class="comment">Routine Description:</span>
00431 <span class="comment"></span>
00432 <span class="comment">    This routine sets up the Event info for a string IO event, and causes the</span>
00433 <span class="comment">    event to be reflected to the Monitor.</span>
00434 <span class="comment"></span>
00435 <span class="comment">    It is assumed that interrupts are enabled upon entry, and Irql is</span>
00436 <span class="comment">    at APC level.</span>
00437 <span class="comment"></span>
00438 <span class="comment">Arguments:</span>
00439 <span class="comment"></span>
00440 <span class="comment">    PortNumber -- Supplies the port number the IO was done to</span>
00441 <span class="comment">    Size -- Supplies the size of the IO operation.</span>
00442 <span class="comment">    Read -- Indicates whether the IO operation was a read or a write.</span>
00443 <span class="comment">    Count -- indicates the number of IO operations of Size size</span>
00444 <span class="comment">    Address -- Indicates address for string io</span>
00445 <span class="comment">    InstructionSize -- Supplies the size of the IO instruction in bytes.</span>
00446 <span class="comment"></span>
00447 <span class="comment"></span>
00448 <span class="comment">Return Value:</span>
00449 <span class="comment"></span>
00450 <span class="comment">    True if the io instruction will be reflected to User mode.</span>
00451 <span class="comment"></span>
00452 <span class="comment"></span>
00453 <span class="comment"></span>
00454 <span class="comment">--*/</span>
00455 {
00456     <a class="code" href="../../d0/d6/struct__Vdm__Tib.html">PVDM_TIB</a> VdmTib;
00457     EXCEPTION_RECORD ExceptionRecord;
00458     BOOLEAN Success = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00459     VDM_IO_HANDLER VdmIoHandler;
00460     ULONG Context;
00461 
00462     Success = <a class="code" href="../../d3/d2/i386_2psvdm_8c.html#a10">Ps386GetVdmIoHandler</a>(
00463         <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>(),
00464         PortNumber &amp; ~0x3,
00465         &amp;VdmIoHandler,
00466         &amp;Context
00467         );
00468 
00469 
00470     <span class="keywordflow">if</span> (Success) {
00471         Success = <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a14">VdmDispatchStringIoToHandler</a>(
00472             &amp;VdmIoHandler,
00473             Context,
00474             PortNumber,
00475             <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>,
00476             <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>,
00477             Read,
00478             Address
00479             );
00480     }
00481 
00482     <span class="keywordflow">if</span> (Success) {
00483         <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a> pIndexRegister;
00484         <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00485 
00486         <span class="comment">// WARNING no 32 bit address support</span>
00487 
00488         pIndexRegister = Read ? (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>)&amp;TrapFrame-&gt;Edi
00489                               : (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>)&amp;TrapFrame-&gt;Esi;
00490 
00491         <span class="keywordflow">if</span> (TrapFrame-&gt;EFlags &amp; EFLAGS_DF_MASK) {
00492             <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = *pIndexRegister - (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(<a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> * <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>);
00493             }
00494         <span class="keywordflow">else</span> {
00495             <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = *pIndexRegister + (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(<a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> * <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>);
00496             }
00497 
00498         *pIndexRegister = <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00499 
00500         <span class="keywordflow">if</span> (Rep) {
00501             (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)TrapFrame-&gt;Ecx = 0;
00502             }
00503 
00504         TrapFrame-&gt;Eip += (ULONG) InstructionSize;
00505         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00506     }
00507 
00508     <span class="keywordflow">try</span> {
00509         VdmTib = 
00510             ((PVDM_PROCESS_OBJECTS)<a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>()-&gt;VdmObjects)-&gt;VdmTib;
00511         VdmTib-&gt;<a class="code" href="../../d0/d6/struct__Vdm__Tib.html#o5">EventInfo</a>.<a class="code" href="../../d1/d6/struct__VdmEventInfo.html#o2">InstructionSize</a> = (ULONG) InstructionSize;
00512         VdmTib-&gt;<a class="code" href="../../d0/d6/struct__Vdm__Tib.html#o5">EventInfo</a>.<a class="code" href="../../d1/d6/struct__VdmEventInfo.html#o1">Event</a> = <a class="code" href="../../d2/d5/ke_2i386_2vdmp_8h.html#a33a26">VdmStringIO</a>;
00513         VdmTib-&gt;<a class="code" href="../../d0/d6/struct__Vdm__Tib.html#o5">EventInfo</a>.<a class="code" href="../../d1/d6/struct__VdmEventInfo.html#o4">StringIoInfo</a>.<a class="code" href="../../d4/d6/struct__VdmStringIoInfo.html#o0">PortNumber</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)PortNumber;
00514         VdmTib-&gt;<a class="code" href="../../d0/d6/struct__Vdm__Tib.html#o5">EventInfo</a>.<a class="code" href="../../d1/d6/struct__VdmEventInfo.html#o4">StringIoInfo</a>.<a class="code" href="../../d4/d6/struct__VdmStringIoInfo.html#o1">Size</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
00515         VdmTib-&gt;<a class="code" href="../../d0/d6/struct__Vdm__Tib.html#o5">EventInfo</a>.<a class="code" href="../../d1/d6/struct__VdmEventInfo.html#o4">StringIoInfo</a>.Rep = Rep;
00516         VdmTib-&gt;<a class="code" href="../../d0/d6/struct__Vdm__Tib.html#o5">EventInfo</a>.<a class="code" href="../../d1/d6/struct__VdmEventInfo.html#o4">StringIoInfo</a>.<a class="code" href="../../d4/d6/struct__VdmStringIoInfo.html#o2">Read</a> = Read;
00517         VdmTib-&gt;<a class="code" href="../../d0/d6/struct__Vdm__Tib.html#o5">EventInfo</a>.<a class="code" href="../../d1/d6/struct__VdmEventInfo.html#o4">StringIoInfo</a>.<a class="code" href="../../d4/d6/struct__VdmStringIoInfo.html#o3">Count</a> = <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>;
00518         VdmTib-&gt;<a class="code" href="../../d0/d6/struct__Vdm__Tib.html#o5">EventInfo</a>.<a class="code" href="../../d1/d6/struct__VdmEventInfo.html#o4">StringIoInfo</a>.<a class="code" href="../../d4/d6/struct__VdmStringIoInfo.html#o4">Address</a> = Address;
00519     } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00520         ExceptionRecord.ExceptionCode = STATUS_ACCESS_VIOLATION;
00521         ExceptionRecord.ExceptionFlags = 0;
00522         ExceptionRecord.NumberParameters = 0;
00523         <a class="code" href="../../d5/d8/ex_8h.html#a302">ExRaiseException</a>(&amp;ExceptionRecord);
00524         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00525     }
00526 
00527 
00528     <a class="code" href="../../d7/d7/strtexec_8c.html#a1">VdmEndExecution</a>(TrapFrame, VdmTib);
00529 
00530     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00531 }
00532 
00533 
00534 BOOLEAN
<a name="l00535"></a><a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a12">00535</a> <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a12">VdmDispatchIoToHandler</a>(
00536     IN PVDM_IO_HANDLER VdmIoHandler,
00537     IN ULONG Context,
00538     IN ULONG PortNumber,
00539     IN ULONG Size,
00540     IN BOOLEAN Read,
00541     IN OUT PULONG Data
00542     )
00543 <span class="comment">/*++</span>
00544 <span class="comment"></span>
00545 <span class="comment">Routine Description:</span>
00546 <span class="comment"></span>
00547 <span class="comment">     This routine calls the handler for the IO.  If there is not a handler</span>
00548 <span class="comment">     of the proper size, it will call this function for 2 io's to the next</span>
00549 <span class="comment">     smaller size.  If the size was a byte, and there was no handler, FALSE</span>
00550 <span class="comment">     is returned.</span>
00551 <span class="comment"></span>
00552 <span class="comment">Arguments:</span>
00553 <span class="comment"></span>
00554 <span class="comment">    VdmIoHandler -- Supplies a pointer to the handler table</span>
00555 <span class="comment">    Context -- Supplies 32 bits of data set when the port was trapped</span>
00556 <span class="comment">    PortNumber -- Supplies the port number the IO was done to</span>
00557 <span class="comment">    Size -- Supplies the size of the IO operation.</span>
00558 <span class="comment">    Read -- Indicates whether the IO operation was a read or a write.</span>
00559 <span class="comment">    Result -- Supplies a pointer to the location to put the result</span>
00560 <span class="comment"></span>
00561 <span class="comment">Return Value:</span>
00562 <span class="comment"></span>
00563 <span class="comment">    True if one or more handlers were called to take care of the IO.</span>
00564 <span class="comment">    False if no handler was called to take care of the IO.</span>
00565 <span class="comment"></span>
00566 <span class="comment">--*/</span>
00567 {
00568     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00569     BOOLEAN Success1, Success2;
00570     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> FnIndex;
00571     UCHAR AccessType;
00572 
00573     <span class="comment">// Insure that Io is aligned</span>
00574     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((!(PortNumber % <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>)));
00575 
00576     <span class="keywordflow">if</span> (Read) {
00577         FnIndex = 0;
00578         AccessType = <a class="code" href="../../d4/d3/v86emul_8h.html#a0">EMULATOR_READ_ACCESS</a>;
00579     } <span class="keywordflow">else</span> {
00580         FnIndex = 1;
00581         AccessType = <a class="code" href="../../d4/d3/v86emul_8h.html#a1">EMULATOR_WRITE_ACCESS</a>;
00582     }
00583 
00584     <span class="keywordflow">switch</span> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>) {
00585     <span class="keywordflow">case</span> 1:
00586         <span class="keywordflow">if</span> (VdmIoHandler-&gt;IoFunctions[FnIndex].UcharIo[PortNumber % 4]) {
00587             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = (*(VdmIoHandler-&gt;IoFunctions[FnIndex].UcharIo[PortNumber % 4]))(
00588                 Context,
00589                 PortNumber,
00590                 AccessType,
00591                 (PUCHAR)Data
00592                 );
00593             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
00594                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00595             }
00596         }
00597         <span class="comment">// No handler for this port</span>
00598         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00599 
00600     <span class="keywordflow">case</span> 2:
00601         <span class="keywordflow">if</span> (VdmIoHandler-&gt;IoFunctions[FnIndex].UshortIo[PortNumber % 2]) {
00602             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = (*(VdmIoHandler-&gt;IoFunctions[FnIndex].UshortIo[PortNumber % 2]))(
00603                 Context,
00604                 PortNumber,
00605                 AccessType,
00606                 (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>)Data
00607                 );
00608             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
00609                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00610             }
00611         } <span class="keywordflow">else</span> {
00612             <span class="comment">// Dispatch to the two uchar handlers for this ushort port</span>
00613             Success1 = <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a12">VdmDispatchIoToHandler</a>(
00614                 VdmIoHandler,
00615                 Context,
00616                 PortNumber,
00617                 <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> /2,
00618                 Read,
00619                 Data
00620                 );
00621 
00622             Success2 = <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a12">VdmDispatchIoToHandler</a>(
00623                 VdmIoHandler,
00624                 Context,
00625                 PortNumber + 1,
00626                 <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> / 2,
00627                 Read,
00628                 (PULONG)((PUCHAR)Data + 1)
00629                 );
00630 
00631             <span class="keywordflow">return</span> (Success1 || Success2);
00632 
00633         }
00634         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00635 
00636     <span class="keywordflow">case</span> 4:
00637         <span class="keywordflow">if</span> (VdmIoHandler-&gt;IoFunctions[FnIndex].UlongIo) {
00638             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = (*(VdmIoHandler-&gt;IoFunctions[FnIndex].UlongIo))(
00639                 Context,
00640                 PortNumber,
00641                 AccessType,
00642                 Data
00643                 );
00644             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
00645                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00646             }
00647         } <span class="keywordflow">else</span> {
00648             <span class="comment">// Dispatch to the two ushort handlers for this port</span>
00649             Success1 = <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a12">VdmDispatchIoToHandler</a>(
00650                 VdmIoHandler,
00651                 Context,
00652                 PortNumber,
00653                 <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> /2,
00654                 Read,
00655                 Data);
00656             Success2 = <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a12">VdmDispatchIoToHandler</a>(
00657                 VdmIoHandler,
00658                 Context,
00659                 PortNumber + 2,
00660                 <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> / 2,
00661                 Read,
00662                 (PULONG)((<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>)Data + 1)
00663                 );
00664 
00665             <span class="keywordflow">return</span> (Success1 || Success2);
00666         }
00667         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00668     }
00669 }
00670 
00671 BOOLEAN
<a name="l00672"></a><a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a13">00672</a> <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a13">VdmDispatchUnalignedIoToHandler</a>(
00673     IN PVDM_IO_HANDLER VdmIoHandler,
00674     IN ULONG Context,
00675     IN ULONG PortNumber,
00676     IN ULONG Size,
00677     IN BOOLEAN Read,
00678     IN OUT PULONG Data
00679     )
00680 <span class="comment">/*++</span>
00681 <span class="comment"></span>
00682 <span class="comment">Routine Description:</span>
00683 <span class="comment"></span>
00684 <span class="comment">     This routine converts the unaligned IO to the necessary number of aligned</span>
00685 <span class="comment">     IOs to smaller ports.</span>
00686 <span class="comment"></span>
00687 <span class="comment">Arguments:</span>
00688 <span class="comment"></span>
00689 <span class="comment">    VdmIoHandler -- Supplies a pointer to the handler table</span>
00690 <span class="comment">    Context -- Supplies 32 bits of data set when the port was trapped</span>
00691 <span class="comment">    PortNumber -- Supplies the port number the IO was done to</span>
00692 <span class="comment">    Size -- Supplies the size of the IO operation.</span>
00693 <span class="comment">    Read -- Indicates whether the IO operation was a read or a write.</span>
00694 <span class="comment">    Result -- Supplies a pointer to the location to put the result</span>
00695 <span class="comment"></span>
00696 <span class="comment">Return Value:</span>
00697 <span class="comment"></span>
00698 <span class="comment">    True if one or more handlers were called to take care of the IO.</span>
00699 <span class="comment">    False if no handler was called to take care of the IO.</span>
00700 <span class="comment"></span>
00701 <span class="comment">--*/</span>
00702 {
00703     ULONG <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
00704     BOOLEAN Success;
00705 
00706     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> &gt; 1));
00707     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((PortNumber % <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>));
00708 
00709     <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> = 0;
00710 
00711     <span class="comment">//</span>
00712     <span class="comment">//  The possible unaligned io situations are as follows.</span>
00713     <span class="comment">//</span>
00714     <span class="comment">//  1.  Uchar aligned Ulong io</span>
00715     <span class="comment">//          We have to dispatch a uchar io, a ushort io, and a uchar io</span>
00716     <span class="comment">//</span>
00717     <span class="comment">//  2.  Ushort aligned Ulong Io</span>
00718     <span class="comment">//          We have to dispatch a ushort io, and a ushort io</span>
00719     <span class="comment">//</span>
00720     <span class="comment">//  3.  Uchar aligned Ushort Io</span>
00721     <span class="comment">//          We have to dispatch a uchar io and a uchar io</span>
00722     <span class="comment">//</span>
00723 
00724     <span class="comment">// if the port is uchar aligned</span>
00725     <span class="keywordflow">if</span> ((PortNumber % <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>) &amp; 1) {
00726         Success = <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a12">VdmDispatchIoToHandler</a>(
00727             VdmIoHandler,
00728             Context,
00729             PortNumber,
00730             1,
00731             Read,
00732             Data
00733             );
00734         <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> += 1;
00735     <span class="comment">// else it is ushort aligned (and therefore must be a ulong port)</span>
00736     } <span class="keywordflow">else</span> {
00737         Success = <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a12">VdmDispatchIoToHandler</a>(
00738             VdmIoHandler,
00739             Context,
00740             PortNumber,
00741             2,
00742             Read,
00743             Data
00744             );
00745         <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> += 2;
00746     }
00747 
00748     <span class="comment">// if it is a ulong port, we know we have a ushort IO to dispatch</span>
00749     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> == 4) {
00750         Success |= <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a12">VdmDispatchIoToHandler</a>(
00751             VdmIoHandler,
00752             Context,
00753             PortNumber + <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>,
00754             2,
00755             Read,
00756             (PULONG)((PUCHAR)Data + <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>)
00757             );
00758         <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> += 2;
00759     }
00760 
00761     <span class="comment">// If we haven't dispatched the entire port, dispatch the final uchar</span>
00762     <span class="keywordflow">if</span> (<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> != 4) {
00763         Success |= <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a12">VdmDispatchIoToHandler</a>(
00764             VdmIoHandler,
00765             Context,
00766             PortNumber + <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>,
00767             1,
00768             Read,
00769             (PULONG)((PUCHAR)Data + <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>)
00770             );
00771     }
00772 
00773     <span class="keywordflow">return</span> Success;
00774 }
00775 
00776 BOOLEAN
<a name="l00777"></a><a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a14">00777</a> <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a14">VdmDispatchStringIoToHandler</a>(
00778     IN PVDM_IO_HANDLER VdmIoHandler,
00779     IN ULONG Context,
00780     IN ULONG PortNumber,
00781     IN ULONG Size,
00782     IN ULONG Count,
00783     IN BOOLEAN Read,
00784     IN ULONG Data
00785     )
00786 <span class="comment">/*++</span>
00787 <span class="comment"></span>
00788 <span class="comment">Routine Description:</span>
00789 <span class="comment"></span>
00790 <span class="comment">     This routine calls the handler for the IO.  If there is not a handler</span>
00791 <span class="comment">     of the proper size, or the io is not aligned, it will simulate the io</span>
00792 <span class="comment">     to the normal io handlers.</span>
00793 <span class="comment"></span>
00794 <span class="comment">Arguments:</span>
00795 <span class="comment"></span>
00796 <span class="comment">    VdmIoHandler -- Supplies a pointer to the handler table</span>
00797 <span class="comment">    Context -- Supplies 32 bits of data set when the port was trapped</span>
00798 <span class="comment">    PortNumber -- Supplies the port number the IO was done to</span>
00799 <span class="comment">    Size -- Supplies the size of the IO operation.</span>
00800 <span class="comment">    Count -- Supplies the number of IO operations.</span>
00801 <span class="comment">    Read -- Indicates whether the IO operation was a read or a write.</span>
00802 <span class="comment">    Data -- Supplies a segmented address at which to put the result.</span>
00803 <span class="comment"></span>
00804 <span class="comment">Return Value:</span>
00805 <span class="comment"></span>
00806 <span class="comment">    True if one or more handlers were called to take care of the IO.</span>
00807 <span class="comment">    False if no handler was called to take care of the IO.</span>
00808 <span class="comment"></span>
00809 <span class="comment">--*/</span>
00810 {
00811     BOOLEAN Success = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00812     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> FnIndex;
00813     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00814 
00815     <span class="keywordflow">if</span> (Read) {
00816         FnIndex = 0;
00817     } <span class="keywordflow">else</span> {
00818         FnIndex = 1;
00819     }
00820 
00821     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>(
00822         &amp;<a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a2">VdmStringIoMutex</a>,
00823         <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
00824         <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
00825         <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00826         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
00827         );
00828 
00829     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
00830         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00831     }
00832 
00833     <span class="keywordflow">switch</span> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>) {
00834     <span class="keywordflow">case</span> 1:
00835         Success = <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a15">VdmCallStringIoHandler</a>(
00836             VdmIoHandler,
00837             (PVOID)VdmIoHandler-&gt;IoFunctions[FnIndex].UcharStringIo[PortNumber % 4],
00838             Context,
00839             PortNumber,
00840             <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>,
00841             <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>,
00842             Read,
00843             Data
00844             );
00845         <span class="keywordflow">break</span>;
00846 
00847     <span class="keywordflow">case</span> 2:
00848         Success = <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a15">VdmCallStringIoHandler</a>(
00849             VdmIoHandler,
00850             (PVOID)VdmIoHandler-&gt;IoFunctions[FnIndex].UshortStringIo[PortNumber % 2],
00851             Context,
00852             PortNumber,
00853             <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>,
00854             <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>,
00855             Read,
00856             Data
00857             );
00858         <span class="keywordflow">break</span>;
00859 
00860     <span class="keywordflow">case</span> 4:
00861         Success = <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a15">VdmCallStringIoHandler</a>(
00862             VdmIoHandler,
00863             (PVOID)VdmIoHandler-&gt;IoFunctions[FnIndex].UlongStringIo,
00864             Context,
00865             PortNumber,
00866             <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>,
00867             <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>,
00868             Read,
00869             Data
00870             );
00871         <span class="keywordflow">break</span>;
00872 
00873     }
00874     <a class="code" href="../../d3/d5/mutntobj_8c.html#a5">KeReleaseMutex</a>(&amp;<a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a2">VdmStringIoMutex</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00875     <span class="keywordflow">return</span> Success;
00876 }
00877 
<a name="l00878"></a><a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a1">00878</a> <span class="preprocessor">#define STRINGIO_BUFFER_SIZE 1024</span>
<a name="l00879"></a><a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a8">00879</a> <span class="preprocessor"></span>UCHAR <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a8">VdmStringIoBuffer</a>[<a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a1">STRINGIO_BUFFER_SIZE</a>];
00880 
00881 BOOLEAN
<a name="l00882"></a><a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a15">00882</a> <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a15">VdmCallStringIoHandler</a>(
00883     IN PVDM_IO_HANDLER VdmIoHandler,
00884     IN PVOID StringIoRoutine,
00885     IN ULONG Context,
00886     IN ULONG PortNumber,
00887     IN ULONG Size,
00888     IN ULONG Count,
00889     IN BOOLEAN Read,
00890     IN ULONG Data
00891     )
00892 <span class="comment">/*++</span>
00893 <span class="comment"></span>
00894 <span class="comment">Routine Description:</span>
00895 <span class="comment"></span>
00896 <span class="comment">    This routine actually performs the call to string io routine.  It takes</span>
00897 <span class="comment">    care of buffering the user data in kernel space so that the device driver</span>
00898 <span class="comment">    does not have to.  If there is not a string io function, or the io is</span>
00899 <span class="comment">    misaligned, it will be simulated as a series of normal io operations</span>
00900 <span class="comment"></span>
00901 <span class="comment">Arguments:</span>
00902 <span class="comment"></span>
00903 <span class="comment">    StringIoRoutine -- Supplies a pointer to the string Io routine</span>
00904 <span class="comment">    Context -- Supplies 32 bits of data set when the port was trapped</span>
00905 <span class="comment">    PortNumber -- Supplies the number of the port to perform Io to</span>
00906 <span class="comment">    Size -- Supplies the size of the io operations</span>
00907 <span class="comment">    Count -- Supplies the number of Io operations in the string.</span>
00908 <span class="comment">    Read -- Indicates a read operation</span>
00909 <span class="comment">    Data -- Supplies a pointer to the user buffer to perform the io on.</span>
00910 <span class="comment"></span>
00911 <span class="comment">Returns</span>
00912 <span class="comment"></span>
00913 <span class="comment">    TRUE if a handler was called</span>
00914 <span class="comment">    FALSE if not.</span>
00915 <span class="comment"></span>
00916 <span class="comment">--*/</span>
00917 {
00918     ULONG TotalBytes,BytesDone,BytesToDo,LoopCount,NumberIo;
00919     PUCHAR CurrentDataPtr;
00920     UCHAR AccessType;
00921     EXCEPTION_RECORD ExceptionRecord;
00922     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00923     BOOLEAN Success;
00924 
00925     Success = <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a19">VdmConvertToLinearAddress</a>(
00926         Data,
00927         &amp;CurrentDataPtr
00928         );
00929 
00930     <span class="keywordflow">if</span> (!Success) {
00931         ExceptionRecord.ExceptionCode = STATUS_ACCESS_VIOLATION;
00932         ExceptionRecord.ExceptionFlags = 0;
00933         ExceptionRecord.NumberParameters = 0;
00934         <a class="code" href="../../d5/d8/ex_8h.html#a302">ExRaiseException</a>(&amp;ExceptionRecord);
00935         <span class="comment">// Cause kernel exit, rather than Io reflection</span>
00936         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00937     }
00938 
00939 
00940     TotalBytes = <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> * <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
00941     BytesDone = 0;
00942 
00943     <span class="keywordflow">if</span> (PortNumber % <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>) {
00944         StringIoRoutine = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00945     }
00946 
00947     <span class="keywordflow">if</span> (Read) {
00948         AccessType = <a class="code" href="../../d4/d3/v86emul_8h.html#a0">EMULATOR_READ_ACCESS</a>;
00949     } <span class="keywordflow">else</span> {
00950         AccessType = <a class="code" href="../../d4/d3/v86emul_8h.html#a1">EMULATOR_WRITE_ACCESS</a>;
00951     }
00952 
00953 
00954     <span class="comment">// Set up try out here to avoid overhead in loop</span>
00955     <span class="keywordflow">try</span> {
00956         <span class="keywordflow">while</span> (BytesDone &lt; TotalBytes) {
00957             <span class="keywordflow">if</span> ((BytesDone + <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a1">STRINGIO_BUFFER_SIZE</a>) &gt; TotalBytes) {
00958                 BytesToDo = TotalBytes - BytesDone;
00959             } <span class="keywordflow">else</span> {
00960                 BytesToDo = <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a1">STRINGIO_BUFFER_SIZE</a>;
00961             }
00962 
00963             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((!(BytesToDo % <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>)));
00964 
00965             <span class="keywordflow">if</span> (!Read) {
00966                 RtlMoveMemory(<a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a8">VdmStringIoBuffer</a>, CurrentDataPtr, BytesToDo);
00967             }
00968 
00969             NumberIo = BytesToDo / <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
00970 
00971             <span class="keywordflow">if</span> (StringIoRoutine) {
00972                 <span class="comment">// in order to avoid having 3 separate calls, one for each size</span>
00973                 <span class="comment">// we simply cast the parameters appropriately for the</span>
00974                 <span class="comment">// byte routine.</span>
00975 
00976                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = (*((<a class="code" href="../../d4/d3/v86emul_8h.html#a7">PDRIVER_IO_PORT_UCHAR_STRING</a>)StringIoRoutine))(
00977                     Context,
00978                     PortNumber,
00979                     AccessType,
00980                     <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a8">VdmStringIoBuffer</a>,
00981                     NumberIo
00982                     );
00983 
00984                 <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
00985                     Success |= <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00986                 }
00987             } <span class="keywordflow">else</span> {
00988                 <span class="keywordflow">if</span> (PortNumber % <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>) {
00989                     <span class="keywordflow">for</span> (LoopCount = 0; LoopCount &lt; NumberIo; LoopCount++ ) {
00990                         Success |= <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a13">VdmDispatchUnalignedIoToHandler</a>(
00991                             VdmIoHandler,
00992                             Context,
00993                             PortNumber,
00994                             <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>,
00995                             Read,
00996                             (PULONG)(<a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a8">VdmStringIoBuffer</a> + LoopCount * <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>)
00997                             );
00998                     }
00999                 } <span class="keywordflow">else</span> {
01000                     <span class="keywordflow">for</span> (LoopCount = 0; LoopCount &lt; NumberIo; LoopCount++ ) {
01001                         Success |= <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a12">VdmDispatchIoToHandler</a>(
01002                             VdmIoHandler,
01003                             Context,
01004                             PortNumber,
01005                             <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>,
01006                             Read,
01007                             (PULONG)(<a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a8">VdmStringIoBuffer</a> + LoopCount * <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>)
01008                             );
01009                     }
01010 
01011                 }
01012             }
01013 
01014             <span class="keywordflow">if</span> (Read) {
01015                 RtlMoveMemory(CurrentDataPtr, <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a8">VdmStringIoBuffer</a>, BytesToDo);
01016             }
01017 
01018             BytesDone += BytesToDo;
01019             CurrentDataPtr += BytesToDo;
01020         }
01021     } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
01022         ExceptionRecord.ExceptionCode = GetExceptionCode();
01023         ExceptionRecord.ExceptionFlags = 0;
01024         ExceptionRecord.NumberParameters = 0;
01025         <a class="code" href="../../d5/d8/ex_8h.html#a302">ExRaiseException</a>(&amp;ExceptionRecord);
01026         <span class="comment">// Cause kernel exit, rather than Io reflection</span>
01027         Success = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01028     }
01029     <span class="keywordflow">return</span> Success;
01030 
01031 }
01032 
01033 BOOLEAN
<a name="l01034"></a><a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a19">01034</a> <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a19">VdmConvertToLinearAddress</a>(
01035     IN ULONG SegmentedAddress,
01036     OUT PVOID *LinearAddress
01037     )
01038 <span class="comment">/*++</span>
01039 <span class="comment"></span>
01040 <span class="comment">Routine Description:</span>
01041 <span class="comment"></span>
01042 <span class="comment">    This routine converts the specified segmented address into a linear</span>
01043 <span class="comment">    address, based on processor mode in user mode.</span>
01044 <span class="comment"></span>
01045 <span class="comment">Arguments:</span>
01046 <span class="comment"></span>
01047 <span class="comment">    SegmentedAddress -- Supplies the segmented address to convert.</span>
01048 <span class="comment">    LinearAddress -- Supplies a pointer to the destination for the</span>
01049 <span class="comment">        coresponding linear address</span>
01050 <span class="comment"></span>
01051 <span class="comment">Return Value:</span>
01052 <span class="comment"></span>
01053 <span class="comment">    True if the address was converted.</span>
01054 <span class="comment">    False otherwise</span>
01055 <span class="comment"></span>
01056 <span class="comment">Note:</span>
01057 <span class="comment"></span>
01058 <span class="comment">    A linear address of 0 is a valid return</span>
01059 <span class="comment">--*/</span>
01060 {
01061     <a class="code" href="../../d1/d8/struct__KTHREAD.html">PKTHREAD</a> Thread;
01062     PKTRAP_FRAME TrapFrame;
01063     BOOLEAN Success;
01064     ULONG Base, Limit, Flags;
01065 
01066     Thread = <a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>();
01067     TrapFrame = VdmGetTrapFrame(Thread);
01068 
01069     <span class="keywordflow">if</span> (TrapFrame-&gt;EFlags &amp; EFLAGS_V86_MASK) {
01070         *LinearAddress = (PVOID)(((SegmentedAddress &amp; 0xFFFF0000) &gt;&gt; 12) +
01071             (SegmentedAddress &amp; 0xFFFF));
01072         Success = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01073     } <span class="keywordflow">else</span> {
01074         Success = <a class="code" href="../../d8/d4/vdmint21_8c.html#a6">Ki386GetSelectorParameters</a>(
01075             (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)((SegmentedAddress &amp; 0xFFFF0000) &gt;&gt; 16),
01076             &amp;Flags,
01077             &amp;Base,
01078             &amp;Limit
01079             );
01080         <span class="keywordflow">if</span> (Success) {
01081             *LinearAddress = (PVOID)(Base + (SegmentedAddress &amp; 0xFFFF));
01082         }
01083     }
01084     <span class="keywordflow">return</span> Success;
01085 }
01086 
01087 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01088"></a><a class="code" href="../../d5/d3/i386_8h.html#a49">01088</a> <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a17">KeI386VdmInitialize</a>(
01089     VOID
01090     )
01091 <span class="comment">/*++</span>
01092 <span class="comment"></span>
01093 <span class="comment">Routine Description:</span>
01094 <span class="comment"></span>
01095 <span class="comment">    This routine initializes the vdm stuff</span>
01096 <span class="comment"></span>
01097 <span class="comment">Arguments:</span>
01098 <span class="comment"></span>
01099 <span class="comment">    None</span>
01100 <span class="comment"></span>
01101 <span class="comment">Return Value:</span>
01102 <span class="comment"></span>
01103 <span class="comment">    None</span>
01104 <span class="comment">--*/</span>
01105 {
01106     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01107     OBJECT_ATTRIBUTES <a class="code" href="../../d7/d0/ctlnpqos_8c.html#a4">ObjectAttributes</a>;
01108     HANDLE RegistryHandle = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01109     UNICODE_STRING WorkString;
01110     UCHAR KeyInformation[<span class="keyword">sizeof</span>(KEY_VALUE_BASIC_INFORMATION) + 30];
01111     ULONG ResultLength;
01112 
01113     <a class="code" href="../../d3/d5/mutntobj_8c.html#a2">KeInitializeMutex</a>( &amp;<a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a2">VdmStringIoMutex</a>, <a class="code" href="../../d3/d0/exlevels_8h.html#a0">MUTEX_LEVEL_VDM_IO</a> );
01114 
01115     <span class="comment">//</span>
01116     <span class="comment">// Set up and open KeyPath to wow key</span>
01117     <span class="comment">//</span>
01118 
01119     <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(
01120         &amp;WorkString,
01121         <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Wow"</span>
01122         );
01123 
01124     InitializeObjectAttributes(
01125         &amp;<a class="code" href="../../d7/d0/ctlnpqos_8c.html#a4">ObjectAttributes</a>,
01126         &amp;WorkString,
01127         OBJ_CASE_INSENSITIVE,
01128         (HANDLE)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
01129         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
01130         );
01131 
01132     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwOpenKey(
01133         &amp;RegistryHandle,
01134         KEY_READ,
01135         &amp;<a class="code" href="../../d7/d0/ctlnpqos_8c.html#a4">ObjectAttributes</a>
01136         );
01137 
01138     <span class="comment">//</span>
01139     <span class="comment">// If there is no Wow key, don't allow Vdms to run</span>
01140     <span class="comment">//</span>
01141     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
01142         <span class="keywordflow">return</span>;
01143     }
01144 
01145     <span class="comment">//</span>
01146     <span class="comment">// Set up for using virtual interrupt extensions if they are available</span>
01147     <span class="comment">//</span>
01148 
01149     <span class="comment">//</span>
01150     <span class="comment">// Get the Pentium Feature disable value.</span>
01151     <span class="comment">// If this value is present, don't enable vme stuff.</span>
01152     <span class="comment">//</span>
01153     <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(
01154         &amp;WorkString,
01155         <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"DisableVme"</span>
01156         );
01157 
01158     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwQueryValueKey(
01159         RegistryHandle,
01160         &amp;WorkString,
01161         KeyValueBasicInformation,
01162         &amp;KeyInformation,
01163         <span class="keyword">sizeof</span>(KEY_VALUE_BASIC_INFORMATION) + 30,
01164         &amp;ResultLength
01165         );
01166 
01167     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
01168 
01169         <span class="comment">//</span>
01170         <span class="comment">// If we have the extensions, set the appropriate bits</span>
01171         <span class="comment">// in cr4</span>
01172         <span class="comment">//</span>
01173         <span class="keywordflow">if</span> (<a class="code" href="../../d4/d9/ke_8h.html#a137">KeFeatureBits</a> &amp; <a class="code" href="../../d5/d3/i386_8h.html#a0">KF_V86_VIS</a>) {
01174             <a class="code" href="../../d2/d1/xipi_8c.html#a1">KiIpiGenericCall</a>(
01175                 <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a18">Ki386VdmEnablePentiumExtentions</a>,
01176                 <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>
01177                 );
01178             <a class="code" href="../../d5/d3/i386_8h.html#a20">KeI386VirtualIntExtensions</a> = V86_VIRTUAL_INT_EXTENSIONS;
01179         }
01180     }
01181 
01182     <span class="comment">//</span>
01183     <span class="comment">// If we have V86 mode int extensions, we don't want to run with</span>
01184     <span class="comment">// IOPL in v86 mode</span>
01185     <span class="comment">//</span>
01186     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d3/i386_8h.html#a20">KeI386VirtualIntExtensions</a> &amp; V86_VIRTUAL_INT_EXTENSIONS) {
01187         <span class="comment">//</span>
01188         <span class="comment">// Read registry to determine if Vdms will run with IOPL in v86 mode</span>
01189         <span class="comment">//</span>
01190 
01191         <span class="comment">//</span>
01192         <span class="comment">// Get the VdmIOPL value.</span>
01193         <span class="comment">//</span>
01194         <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(
01195             &amp;WorkString,
01196             <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"VdmIOPL"</span>
01197             );
01198 
01199         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwQueryValueKey(
01200             RegistryHandle,
01201             &amp;WorkString,
01202             KeyValueBasicInformation,
01203             &amp;KeyInformation,
01204             <span class="keyword">sizeof</span>(KEY_VALUE_BASIC_INFORMATION) + 30,
01205             &amp;ResultLength
01206             );
01207 
01208         <span class="comment">//</span>
01209         <span class="comment">// If the value exists, let Vdms run with IOPL in V86 mode</span>
01210         <span class="comment">//</span>
01211         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
01212             <span class="comment">//</span>
01213             <span class="comment">// KeEflagsAndMaskV86 and KeEflagsOrMaskV86 are used</span>
01214             <span class="comment">// in SANITIZE_FLAGS, and the Vdm code to make sure the</span>
01215             <span class="comment">// values in EFlags for v86 mode trap frames are acceptable</span>
01216             <span class="comment">//</span>
01217             <a class="code" href="../../d5/d3/i386_8h.html#a17">KeI386EFlagsAndMaskV86</a> = EFLAGS_USER_SANITIZE | EFLAGS_INTERRUPT_MASK;
01218             <a class="code" href="../../d5/d3/i386_8h.html#a18">KeI386EFlagsOrMaskV86</a> = EFLAGS_IOPL_MASK;
01219 
01220             <span class="comment">//</span>
01221             <span class="comment">// KeVdmIoplAllowed is used by the Vdm code to determine if</span>
01222             <span class="comment">// the virtual interrupt flag is in EFlags, or 40:xx</span>
01223             <span class="comment">//</span>
01224             <a class="code" href="../../d5/d3/i386_8h.html#a19">KeI386VdmIoplAllowed</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01225 
01226         }
01227     }
01228 
01229     ZwClose(RegistryHandle);
01230 
01231     <span class="comment">//</span>
01232     <span class="comment">//  Initialize the address of the Vdm communications area based on</span>
01233     <span class="comment">//  machine type because of non-AT Japanese PCs.  Note that we only</span>
01234     <span class="comment">//  have to change the op-code for PC-98 machines as the default is</span>
01235     <span class="comment">//  the PC/AT value.</span>
01236     <span class="comment">//</span>
01237 
01238     <span class="keywordflow">if</span> (<a class="code" href="../../d7/d3/i386init_8c.html#a1">KeI386MachineType</a> &amp; MACHINE_TYPE_PC_9800_COMPATIBLE) {
01239 
01240         <span class="comment">//</span>
01241         <span class="comment">//  Set NTVDM state liner for PC-9800 Series</span>
01242         <span class="comment">//</span>
01243 
01244         <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a3">VdmFixedStateLinear</a> = FIXED_NTVDMSTATE_LINEAR_PC_98;
01245     } <span class="keywordflow">else</span> {
01246 
01247         <span class="comment">//</span>
01248         <span class="comment">//  We are running on an normal PC/AT or a Fujitsu FMR comaptible.</span>
01249         <span class="comment">//</span>
01250 
01251         <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a3">VdmFixedStateLinear</a> = FIXED_NTVDMSTATE_LINEAR_PC_AT;
01252     }
01253 }
01254 
01255 
01256 BOOLEAN
<a name="l01257"></a><a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a20">01257</a> <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a20">Ke386VdmInsertQueueApc</a> (
01258     IN <a class="code" href="../../d1/d5/struct__KAPC.html">PKAPC</a>             Apc,
01259     IN <a class="code" href="../../d1/d8/struct__KTHREAD.html">PKTHREAD</a>          Thread,
01260     IN KPROCESSOR_MODE   ApcMode,
01261     IN PKKERNEL_ROUTINE  KernelRoutine,
01262     IN PKRUNDOWN_ROUTINE RundownRoutine OPTIONAL,
01263     IN PKNORMAL_ROUTINE  NormalRoutine  OPTIONAL,
01264     IN PVOID             NormalContext   OPTIONAL,
01265     IN KPRIORITY         Increment
01266     )
01267 
01268 <span class="comment">/*++</span>
01269 <span class="comment"></span>
01270 <span class="comment">Routine Description:</span>
01271 <span class="comment"></span>
01272 <span class="comment">    This function initializes, and queues a vdm type of APC to the</span>
01273 <span class="comment">    specified thread.</span>
01274 <span class="comment"></span>
01275 <span class="comment"></span>
01276 <span class="comment">    A Vdm type of APC:</span>
01277 <span class="comment">       - OriginalApcEnvironment</span>
01278 <span class="comment">       - will only be queued to one thread at a time</span>
01279 <span class="comment">       - if UserMode Fires on the next system exit. A UserMode apc should</span>
01280 <span class="comment">         not be queued if the current vdm context is not application mode.</span>
01281 <span class="comment"></span>
01282 <span class="comment">Arguments:</span>
01283 <span class="comment"></span>
01284 <span class="comment">    Apc - Supplies a pointer to a control object of type APC.</span>
01285 <span class="comment"></span>
01286 <span class="comment">    Thread - Supplies a pointer to a dispatcher object of type thread.</span>
01287 <span class="comment"></span>
01288 <span class="comment">    ApcMode - Supplies the processor mode user\kernel of the Apc</span>
01289 <span class="comment"></span>
01290 <span class="comment">    KernelRoutine - Supplies a pointer to a function that is to be</span>
01291 <span class="comment">        executed at IRQL APC_LEVEL in kernel mode.</span>
01292 <span class="comment"></span>
01293 <span class="comment">    RundownRoutine - Supplies an optional pointer to a function that is to be</span>
01294 <span class="comment">        called if the APC is in a thread's APC queue when the thread terminates.</span>
01295 <span class="comment"></span>
01296 <span class="comment">    NormalRoutine - Supplies an optional pointer to a function that is</span>
01297 <span class="comment">        to be executed at IRQL 0 in the specified processor mode. If this</span>
01298 <span class="comment">        parameter is not specified, then the ProcessorMode and NormalContext</span>
01299 <span class="comment">        parameters are ignored.</span>
01300 <span class="comment"></span>
01301 <span class="comment">    NormalContext - Supplies a pointer to an arbitrary data structure which is</span>
01302 <span class="comment">        to be passed to the function specified by the NormalRoutine parameter.</span>
01303 <span class="comment"></span>
01304 <span class="comment">    Increment - Supplies the priority increment that is to be applied if</span>
01305 <span class="comment">        queuing the APC causes a thread wait to be satisfied.</span>
01306 <span class="comment"></span>
01307 <span class="comment"></span>
01308 <span class="comment">Return Value:</span>
01309 <span class="comment"></span>
01310 <span class="comment">    If APC queuing is disabled, then a value of FALSE is returned.</span>
01311 <span class="comment">    Otherwise a value of TRUE is returned.</span>
01312 <span class="comment"></span>
01313 <span class="comment"></span>
01314 <span class="comment">--*/</span>
01315 
01316 {
01317 
01318     <a class="code" href="../../d3/d5/struct__KAPC__STATE.html">PKAPC_STATE</a> ApcState;
01319     <a class="code" href="../../d1/d8/struct__KTHREAD.html">PKTHREAD</a> ApcThread;
01320     KIRQL   OldIrql;
01321     BOOLEAN Inserted;
01322 
01323     <span class="comment">//</span>
01324     <span class="comment">// Raise IRQL to dispatcher level and lock dispatcher database.</span>
01325     <span class="comment">//</span>
01326 
01327     <a class="code" href="../../d4/d9/ke_8h.html#a36">KiLockDispatcherDatabase</a>(&amp;OldIrql);
01328 
01329     <span class="comment">//</span>
01330     <span class="comment">// If the apc object not initialized, then initialize it and acquire</span>
01331     <span class="comment">// the target thread APC queue lock.</span>
01332     <span class="comment">//</span>
01333 
01334     <span class="keywordflow">if</span> (Apc-&gt;Type != <a class="code" href="../../d4/d9/ke_8h.html#a402a175">ApcObject</a>) {
01335         Apc-&gt;Type = <a class="code" href="../../d4/d9/ke_8h.html#a402a175">ApcObject</a>;
01336         Apc-&gt;Size = <span class="keyword">sizeof</span>(<a class="code" href="../../d1/d5/struct__KAPC.html">KAPC</a>);
01337         Apc-&gt;ApcStateIndex  = <a class="code" href="../../d4/d9/ke_8h.html#a403a181">OriginalApcEnvironment</a>;
01338     } <span class="keywordflow">else</span> {
01339 
01340         <span class="comment">//</span>
01341         <span class="comment">// Acquire the APC thread APC queue lock.</span>
01342         <span class="comment">//</span>
01343         <span class="comment">// If the APC is inserted in the corresponding APC queue, and the</span>
01344         <span class="comment">// APC thread is not the same thread as the target thread, then</span>
01345         <span class="comment">// the APC is removed from its current queue, the APC pending state</span>
01346         <span class="comment">// is updated, the APC thread APC queue lock is released, and the</span>
01347         <span class="comment">// target thread APC queue lock is acquired. Otherwise, the APC</span>
01348         <span class="comment">// thread and the target thread are same thread and the APC is already</span>
01349         <span class="comment">// queued to the correct thread.</span>
01350         <span class="comment">//</span>
01351         <span class="comment">// If the APC is not inserted in an APC queue, then release the</span>
01352         <span class="comment">// APC thread APC queue lock and acquire the target thread APC queue</span>
01353         <span class="comment">// lock.</span>
01354         <span class="comment">//</span>
01355 
01356         ApcThread = Apc-&gt;Thread;
01357         <span class="keywordflow">if</span> (ApcThread) {
01358             KiAcquireSpinLock(&amp;ApcThread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o38">ApcQueueLock</a>);
01359             <span class="keywordflow">if</span> (Apc-&gt;Inserted) {
01360                 <span class="keywordflow">if</span> (ApcThread == Apc-&gt;Thread &amp;&amp; Apc-&gt;Thread != Thread) {
01361                     Apc-&gt;Inserted = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01362                     RemoveEntryList(&amp;Apc-&gt;ApcListEntry);
01363                     ApcState = Apc-&gt;Thread-&gt;ApcStatePointer[Apc-&gt;ApcStateIndex];
01364                     <span class="keywordflow">if</span> (IsListEmpty(&amp;ApcState-&gt;<a class="code" href="../../d3/d5/struct__KAPC__STATE.html#o0">ApcListHead</a>[Apc-&gt;ApcMode]) != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01365                         <span class="keywordflow">if</span> (Apc-&gt;ApcMode == <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
01366                             ApcState-&gt;<a class="code" href="../../d3/d5/struct__KAPC__STATE.html#o3">KernelApcPending</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01367 
01368                         } <span class="keywordflow">else</span> {
01369                             ApcState-&gt;<a class="code" href="../../d3/d5/struct__KAPC__STATE.html#o4">UserApcPending</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01370                         }
01371                     }
01372 
01373                 } <span class="keywordflow">else</span> {
01374                     KiReleaseSpinLock(&amp;ApcThread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o38">ApcQueueLock</a>);
01375                     <a class="code" href="../../d0/d0/ki_8h.html#a84">KiUnlockDispatcherDatabase</a>(OldIrql);
01376                     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01377                 }
01378             }
01379 
01380             KiReleaseSpinLock(&amp;ApcThread-&gt;<a class="code" href="../../d1/d8/struct__KTHREAD.html#o38">ApcQueueLock</a>);
01381         }
01382     }
01383 
01384 
01385     KiAcquireSpinLock(&amp;Thread-&gt;ApcQueueLock);
01386 
01387     Apc-&gt;ApcMode = ApcMode;
01388     Apc-&gt;Thread  = Thread;
01389     Apc-&gt;KernelRoutine   = KernelRoutine;
01390     Apc-&gt;RundownRoutine  = RundownRoutine;
01391     Apc-&gt;NormalRoutine   = NormalRoutine;
01392     Apc-&gt;SystemArgument1 = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01393     Apc-&gt;SystemArgument2 = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01394     Apc-&gt;NormalContext   = NormalContext;
01395 
01396     <span class="comment">//</span>
01397     <span class="comment">// Unlock the target thread APC queue.</span>
01398     <span class="comment">//</span>
01399 
01400     KiReleaseSpinLock(&amp;Thread-&gt;ApcQueueLock);
01401 
01402     <span class="comment">//</span>
01403     <span class="comment">// If APC queuing is enable, then attempt to queue the APC object.</span>
01404     <span class="comment">//</span>
01405 
01406     <span class="keywordflow">if</span> (Thread-&gt;ApcQueueable &amp;&amp; <a class="code" href="../../d0/d0/ki_8h.html#a123">KiInsertQueueApc</a>(Apc, <a class="code" href="../../d6/d4/rtl_2random_8c.html#a1">Increment</a>)) {
01407         Inserted = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01408 
01409         <span class="comment">//</span>
01410         <span class="comment">// If UserMode:</span>
01411         <span class="comment">//    For vdm a UserMode Apc is only queued by a kernel mode</span>
01412         <span class="comment">//    apc which is on the current thread for the target thread.</span>
01413         <span class="comment">//    Force UserApcPending for User mode apcstate, so that</span>
01414         <span class="comment">//    the apc will fire when this thread exits the kernel.</span>
01415         <span class="comment">//</span>
01416 
01417         <span class="keywordflow">if</span> (ApcMode == <a class="code" href="../../d0/d9/ntosdef_8h.html#a76a70">UserMode</a>) {
01418             <a class="code" href="../../d0/d0/ki_8h.html#a14">KiBoostPriorityThread</a>(Thread, <a class="code" href="../../d6/d4/rtl_2random_8c.html#a1">Increment</a>);
01419             Thread-&gt;ApcState.UserApcPending = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01420         }
01421 
01422     } <span class="keywordflow">else</span> {
01423         Inserted = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01424     }
01425 
01426     <span class="comment">//</span>
01427     <span class="comment">// Unlock the dispatcher database, lower IRQL to its previous value, and</span>
01428     <span class="comment">// return whether the APC object was inserted.</span>
01429     <span class="comment">//</span>
01430 
01431     <a class="code" href="../../d0/d0/ki_8h.html#a84">KiUnlockDispatcherDatabase</a>(OldIrql);
01432     <span class="keywordflow">return</span> Inserted;
01433 }
01434 
01435 
01436 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01437"></a><a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a21">01437</a> <a class="code" href="../../d9/d3/ke_2i386_2vdm_8c.html#a21">Ke386VdmClearApcObject</a>(
01438     IN <a class="code" href="../../d1/d5/struct__KAPC.html">PKAPC</a> Apc
01439     )
01440 <span class="comment">/*++</span>
01441 <span class="comment"></span>
01442 <span class="comment">Routine Description:</span>
01443 <span class="comment"></span>
01444 <span class="comment">    Clears a VDM APC object, synchronously with Ke386VdmInsertQueueApc, and</span>
01445 <span class="comment">    is expected to be called by one of the vdm kernel apc routine or the</span>
01446 <span class="comment">    rundown routine.</span>
01447 <span class="comment"></span>
01448 <span class="comment"></span>
01449 <span class="comment">Arguments:</span>
01450 <span class="comment"></span>
01451 <span class="comment">    Apc - Supplies a pointer to a control object of type APC.</span>
01452 <span class="comment"></span>
01453 <span class="comment"></span>
01454 <span class="comment">Return Value:</span>
01455 <span class="comment"></span>
01456 <span class="comment">    void</span>
01457 <span class="comment"></span>
01458 <span class="comment">--*/</span>
01459 {
01460 
01461     KIRQL   OldIrql;
01462 
01463     <span class="comment">//</span>
01464     <span class="comment">// Take Dispatcher database lock, to sync with Ke386VDMInsertQueueApc</span>
01465     <span class="comment">//</span>
01466 
01467     <a class="code" href="../../d4/d9/ke_8h.html#a36">KiLockDispatcherDatabase</a>(&amp;OldIrql);
01468     Apc-&gt;Thread  = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01469     <a class="code" href="../../d0/d0/ki_8h.html#a84">KiUnlockDispatcherDatabase</a>(OldIrql);
01470 
01471 }
01472 
01473 
01474 
01475 
01476 
01477 
01478 
01479 <span class="comment">//</span>
01480 <span class="comment">//  END of ACTIVE CODE</span>
01481 <span class="comment">//</span>
01482 
01483 
01484 
01485 
01486 
01487 
01488 
01489 <span class="preprocessor">#if VDM_IO_TEST</span>
01490 <span class="preprocessor"></span><a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01491 TestIoByteRoutine(
01492     IN ULONG Port,
01493     IN UCHAR AccessMode,
01494     IN OUT PUCHAR Data
01495     )
01496 {
01497     <span class="keywordflow">if</span> (AccessMode &amp; <a class="code" href="../../d4/d3/v86emul_8h.html#a0">EMULATOR_READ_ACCESS</a>) {
01498         *Data = Port - 400;
01499     }
01500 
01501     <span class="keywordflow">return</span> STATUS_SUCCESS;
01502 }
01503 
01504 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01505 TestIoWordReadRoutine(
01506     IN ULONG Port,
01507     IN UCHAR AccessMode,
01508     IN OUT PUSHORT Data
01509     )
01510 {
01511     <span class="keywordflow">if</span> (AccessMode &amp; <a class="code" href="../../d4/d3/v86emul_8h.html#a0">EMULATOR_READ_ACCESS</a>) {
01512         *Data = Port - 200;
01513     }
01514 
01515     <span class="keywordflow">return</span> STATUS_SUCCESS;
01516 }
01517 
01518 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01519 TestIoWordWriteRoutine(
01520     IN ULONG Port,
01521     IN UCHAR AccessMode,
01522     IN OUT PUSHORT Data
01523     )
01524 {
01525     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"Word Write routine port # %lx, %x\n"</span>,Port,*Data);
01526 
01527     <span class="keywordflow">return</span> STATUS_SUCCESS;
01528 }
01529 
01530 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01531 TestIoDwordRoutine(
01532     IN ULONG Port,
01533     IN USHORT AccessMode,
01534     IN OUT PULONG Data
01535     )
01536 {
01537     <span class="keywordflow">if</span> (AccessMode &amp; <a class="code" href="../../d4/d3/v86emul_8h.html#a0">EMULATOR_READ_ACCESS</a>) {
01538         *Data = Port;
01539     }
01540 
01541     <span class="keywordflow">return</span> STATUS_SUCCESS;
01542 }
01543 
01544 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01545 TestIoStringRoutine(
01546     IN ULONG Port,
01547     IN USHORT AccessMode,
01548     IN OUT PSHORT Data,
01549     IN ULONG Count
01550     )
01551 {
01552     ULONG i;
01553 
01554     <span class="keywordflow">if</span> (AccessMode &amp; <a class="code" href="../../d4/d3/v86emul_8h.html#a0">EMULATOR_READ_ACCESS</a>) {
01555         <span class="keywordflow">for</span> (i = 0;i &lt; <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> ;i++ ) {
01556             Data[i] = i;
01557         }
01558     } <span class="keywordflow">else</span> {
01559         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"String Port Called for write port #%lx,"</span>,Port);
01560         <span class="keywordflow">for</span> (i = 0;i &lt; <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> ;i++ ) {
01561             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"%x\n"</span>,Data[i]);
01562         }
01563     }
01564 
01565     <span class="keywordflow">return</span> STATUS_SUCCESS;
01566 }
01567 
01568 PROCESS_IO_PORT_HANDLER_INFORMATION IoPortHandler;
01569 <a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html">EMULATOR_ACCESS_ENTRY</a> Entry[4];
01570 BOOLEAN Connect = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, Disconnect = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01571 
01572 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01573 TestIoHandlerStuff(
01574     VOID
01575     )
01576 {
01577     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01578 
01579     IoPortHandler.Install = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01580     IoPortHandler.NumEntries = 5<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>;
01581     IoPortHandler.EmulatorAccessEntries = Entry;
01582 
01583     Entry[0].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o0">BasePort</a> = 0x400;
01584     Entry[0].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o1">NumConsecutivePorts</a> = 0x30;
01585     Entry[0].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o2">AccessType</a> = <a class="code" href="../../d4/d3/v86emul_8h.html#a15a12">Uchar</a>;
01586     Entry[0].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o3">AccessMode</a> = <a class="code" href="../../d4/d3/v86emul_8h.html#a0">EMULATOR_READ_ACCESS</a> | <a class="code" href="../../d4/d3/v86emul_8h.html#a1">EMULATOR_WRITE_ACCESS</a>;
01587     Entry[0].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o4">StringSupport</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01588     Entry[0].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o5">Routine</a> = TestIoByteRoutine;
01589 
01590     Entry[1].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o0">BasePort</a> = 0x400;
01591     Entry[1].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o1">NumConsecutivePorts</a> = 0x18;
01592     Entry[1].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o2">AccessType</a> = <a class="code" href="../../d4/d3/v86emul_8h.html#a15a13">Ushort</a>;
01593     Entry[1].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o3">AccessMode</a> = <a class="code" href="../../d4/d3/v86emul_8h.html#a0">EMULATOR_READ_ACCESS</a> | <a class="code" href="../../d4/d3/v86emul_8h.html#a1">EMULATOR_WRITE_ACCESS</a>;
01594     Entry[1].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o4">StringSupport</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01595     Entry[1].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o5">Routine</a> = TestIoWordReadRoutine;
01596 
01597     Entry[2].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o0">BasePort</a> = 0x400;
01598     Entry[2].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o1">NumConsecutivePorts</a> = 0xc;
01599     Entry[2].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o2">AccessType</a> = <a class="code" href="../../d4/d3/v86emul_8h.html#a15a14">Ulong</a>;
01600     Entry[2].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o3">AccessMode</a> = <a class="code" href="../../d4/d3/v86emul_8h.html#a0">EMULATOR_READ_ACCESS</a> | <a class="code" href="../../d4/d3/v86emul_8h.html#a1">EMULATOR_WRITE_ACCESS</a>;
01601     Entry[2].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o4">StringSupport</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01602     Entry[2].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o5">Routine</a> = TestIoDwordRoutine;
01603 
01604     Entry[3].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o0">BasePort</a> = 0x400;
01605     Entry[3].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o1">NumConsecutivePorts</a> = 0x18;
01606     Entry[3].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o2">AccessType</a> = <a class="code" href="../../d4/d3/v86emul_8h.html#a15a13">Ushort</a>;
01607     Entry[3].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o3">AccessMode</a> = <a class="code" href="../../d4/d3/v86emul_8h.html#a0">EMULATOR_READ_ACCESS</a> | <a class="code" href="../../d4/d3/v86emul_8h.html#a1">EMULATOR_WRITE_ACCESS</a>;
01608     Entry[3].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o4">StringSupport</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01609     Entry[3].<a class="code" href="../../d2/d3/struct__EMULATOR__ACCESS__ENTRY.html#o5">Routine</a> = TestIoStringRoutine;
01610 
01611      <span class="keywordflow">if</span> (Connect) {
01612         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwSetInformationProcess(
01613             NtCurrentProcess(),
01614             ProcessIoPortHandlers,
01615             &amp;IoPortHandler,
01616             <span class="keyword">sizeof</span>(PROCESS_IO_PORT_HANDLER_INFORMATION)
01617             ) ;
01618         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status)) {
01619             DbgBreakPoint();
01620         }
01621         Connect = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01622     }
01623 
01624     IoPortHandler.Install = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01625     <span class="keywordflow">if</span> (Disconnect) {
01626         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwSetInformationProcess(
01627             NtCurrentProcess(),
01628             ProcessIoPortHandlers,
01629             &amp;IoPortHandler,
01630             <span class="keyword">sizeof</span>(PROCESS_IO_PORT_HANDLER_INFORMATION)
01631             );
01632         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status)) {
01633             DbgBreakPoint();
01634         }
01635         Disconnect = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01636     }
01637 }
01638 <span class="preprocessor">#endif</span>
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:42:21 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
