<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: udf.h Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>udf.h</h1><a href="../../d9/d7/udf_8h.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1996  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    Udf.h</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module contains all definitions specified by the OSTA UDF standard which</span>
00012 <span class="comment">    are not defined in ISO 13346 and associated errta.  UDF is a subset of ISO 13346</span>
00013 <span class="comment">    which restricts many facets of the ISO standard and is currently standardized</span>
00014 <span class="comment">    by the Optical Storage Technology Association (http://www.osta.org).  Some</span>
00015 <span class="comment">    aspects of the structures we read may seem illogical unless viewed in this light.</span>
00016 <span class="comment"></span>
00017 <span class="comment">    Unless otherwise specified, section references will be to ISO 13346.</span>
00018 <span class="comment"></span>
00019 <span class="comment">    Also unless otherwise specified, all descriptors mentioned will be sector aligned </span>
00020 <span class="comment"></span>
00021 <span class="comment">    A UDF volume is recognized by searching the Volume Recognition Area (2/8.3) for a</span>
00022 <span class="comment">    Volume Structure Descriptor (2/9.1) which advertises itself as NSR02, the filesystem</span>
00023 <span class="comment">    format specified by ISO 13346 section 4.  This is aligned to match ISO 9660, and the</span>
00024 <span class="comment">    first descriptor may in fact be a 9660 PVD.  ISO 13346 descriptors are bounded by</span>
00025 <span class="comment">    a Begin Extended Area descriptor (2/9.2) and a Terminate Extended Area descriptor</span>
00026 <span class="comment">    (2/9.3).</span>
00027 <span class="comment"></span>
00028 <span class="comment">    +-------+-------+     +-------+     +-------+</span>
00029 <span class="comment">    |       |       |     |       |     |       |</span>
00030 <span class="comment">    | CD001 | BEA01 | ... | NSR02 | ... | TEA01 |</span>
00031 <span class="comment">    |       |       |     |       |     |       |</span>
00032 <span class="comment">    +-------+-------+     +-------+     +-------+</span>
00033 <span class="comment"></span>
00034 <span class="comment">    A UDF volume is then discovered by looking for an Anchor Volume Descriptor (3/10.2),</span>
00035 <span class="comment">    which reveals the location of a pair of extents of the physical volume that contain</span>
00036 <span class="comment">    copies of the Volume Descriptor Sequence.  Both of these copies are defined to be</span>
00037 <span class="comment">    equivalent (duplication is intended for diasaster recovery).</span>
00038 <span class="comment"></span>
00039 <span class="comment">    +-------+              +------------------------------------+</span>
00040 <span class="comment">    |       | -----------&gt; |                                    |</span>
00041 <span class="comment">    |  AVD  |              |   Main Volume Descriptor Sequence  |</span>
00042 <span class="comment">    |       | ----+        |                                    |</span>
00043 <span class="comment">    +-------+     |        +------------------------------------+</span>
00044 <span class="comment">                  |         </span>
00045 <span class="comment">                  |        +------------------------------------+</span>
00046 <span class="comment">                  |        |                                    | </span>
00047 <span class="comment">                  +------&gt; | Reserve Volume Descriptor Sequence |</span>
00048 <span class="comment">                           |                                    |</span>
00049 <span class="comment">                           +------------------------------------+</span>
00050 <span class="comment"></span>
00051 <span class="comment">    An ISO 13346 logical (mountable) volume is composed of a number Np of physical partitions</span>
00052 <span class="comment">    spread across a number Nd of physical volumes (media), all of which may be multiply</span>
00053 <span class="comment">    referenced to create a numbed Nv of logical volumes.  While ISO 13346 allows this level of</span>
00054 <span class="comment">    complexity, UDF restricts as follows: Nv = 1 and Np = Nd except if Nd = 1 then perhaps</span>
00055 <span class="comment">    Np = 2 and one partition is read/write while the other is readonly.  There are three levels</span>
00056 <span class="comment">    of conforming implementations which are defined by ISO 1336 in 3/11 which progress from 1,</span>
00057 <span class="comment">    a restricted Nd = 1, to 3 where Nd &gt; 1.  This is a readonly level 2 implementation, which</span>
00058 <span class="comment">    is an unrestricted single physical media implementation - other than those imposed by UDF.</span>
00059 <span class="comment"></span>
00060 <span class="comment">    A Volume Descriptor Sequence is composed of a number of descriptors which collectively nail</span>
00061 <span class="comment">    down a volume:</span>
00062 <span class="comment"></span>
00063 <span class="comment">        Primary Volume Descriptor           (PVD)  Identification of the physical media and its</span>
00064 <span class="comment">        (3/10.1)                                     relation to a volume set.</span>
00065 <span class="comment"></span>
00066 <span class="comment">        Volume Descriptor Pointer           (VSD)  Identification of a continuing extent of the Volume</span>
00067 <span class="comment">        (3/10.3)                                    Descriptor Sequence (the VDS need not be a single</span>
00068 <span class="comment">                                                    extent).</span>
00069 <span class="comment">                                                </span>
00070 <span class="comment">        Implementation Use Volume Desciptor (IUVD) Exactly that.</span>
00071 <span class="comment">        (3/10.4)</span>
00072 <span class="comment"></span>
00073 <span class="comment">        Partition Descriptor                (PD)   Identification of a linear extent of sectors</span>
00074 <span class="comment">        (3/10.5)                                    on a physical media (type 1) or an implementation</span>
00075 <span class="comment">                                                    defined object (type 2).</span>
00076 <span class="comment"></span>
00077 <span class="comment">        Logical Volume Descriptor           (LVD)  Identification of a mountable volume by</span>
00078 <span class="comment">        (3/10.6)                                    referring to partition(s) and a location for</span>
00079 <span class="comment">                                                    a File Set Descriptor.</span>
00080 <span class="comment">                                                </span>
00081 <span class="comment">        Unallocated Space Descriptor        (USD)  Identification of an unallocated extents of the</span>
00082 <span class="comment">        (3/10.8)                                    media which could be added to existing partitions</span>
00083 <span class="comment">                                                    or allocated through new partitions.</span>
00084 <span class="comment"></span>
00085 <span class="comment">        Terminating Descriptor              (TD)   A method of terminating the Volume Descriptor</span>
00086 <span class="comment">        (3/10.9)                                    Sequence.  A VDS may also be terminated by an</span>
00087 <span class="comment">                                                    unrecorded sector or running to the end of an</span>
00088 <span class="comment">                                                    extent.</span>
00089 <span class="comment"></span>
00090 <span class="comment">    An ISO 13346 volume set is a grouping of physical media, identified collectively by examining</span>
00091 <span class="comment">    the PVD of each unit. A Volume Descriptor Sequence is recorded on each constituent of the volume</span>
00092 <span class="comment">    set, but only the volume with the highest Volume Sequence Number may contain LVD.  An LVD may</span>
00093 <span class="comment">    refer to any PD on any member of the volume set.</span>
00094 <span class="comment"></span>
00095 <span class="comment">    Each descriptor contains a Volume Sequence Number which allows an otherwise identification</span>
00096 <span class="comment">    equivalent descriptor (i.e., specifies the same Partition Number (for PD), same Logical</span>
00097 <span class="comment">    Volume Identifier (for LVD), etc. (3/8.4.3)) to override one of lower VSN.</span>
00098 <span class="comment">    </span>
00099 <span class="comment">    So, a picture of what a Volume Descriptor Sequence could look like is</span>
00100 <span class="comment">    </span>
00101 <span class="comment">    +------+------+------+------+------+</span>
00102 <span class="comment">    |      |      |      |      |      |</span>
00103 <span class="comment">    | PVD  | LVD  |  PD  |  PD  |  VDP |</span>
00104 <span class="comment">    |      |      |      |      |      |</span>
00105 <span class="comment">    +------+------+------+------+------+</span>
00106 <span class="comment">                                    |</span>
00107 <span class="comment">                                    |  +------+------+------+------+</span>
00108 <span class="comment">                                    |  |      |      |      |      |</span>
00109 <span class="comment">                                    +-&gt;| USD  | IUVD | IUVD |  TD  |</span>
00110 <span class="comment">                                       |      |      |      |      |</span>
00111 <span class="comment">                                       +------+------+------+------+</span>
00112 <span class="comment">                                       </span>
00113 <span class="comment">    The LVD points to a File Set Descriptor (4/14.1), which finally points to a root directory.</span>
00114 <span class="comment">    </span>
00115 <span class="comment">Author:</span>
00116 <span class="comment"></span>
00117 <span class="comment">    Dan Lovinger    [DanLo]   10-Jul-1996</span>
00118 <span class="comment"></span>
00119 <span class="comment">Revision History:</span>
00120 <span class="comment"></span>
00121 <span class="comment">--*/</span>
00122 
00123 <span class="preprocessor">#ifndef _UDF_</span>
00124 <span class="preprocessor"></span><span class="preprocessor">#define _UDF_</span>
00125 <span class="preprocessor"></span>
00126 <span class="preprocessor">#include &lt;<a class="code" href="../../d0/d7/iso13346_8h.html">iso13346.h</a>&gt;</span>
00127 
00128 <span class="comment">//</span>
00129 <span class="comment">//  This is the version of UDF that we recognize, per the Domain Identifier</span>
00130 <span class="comment">//  specification in UDF 2.1.5.3.</span>
00131 <span class="comment">//</span>
00132 <span class="comment">//  The values below indicate we understand UDF 1.50.  We will also define</span>
00133 <span class="comment">//  specific revisions so that we can assert correctness for some structures</span>
00134 <span class="comment">//  that we know appeared for the first time in certain specifications.</span>
00135 <span class="comment">//</span>
00136 <span class="comment">//</span>
00137 
<a name="l00138"></a><a class="code" href="../../d9/d7/udf_8h.html#a0">00138</a> <span class="preprocessor">#define UDF_VERSION_100         0x0100</span>
<a name="l00139"></a><a class="code" href="../../d9/d7/udf_8h.html#a1">00139</a> <span class="preprocessor"></span><span class="preprocessor">#define UDF_VERSION_101         0x0101</span>
<a name="l00140"></a><a class="code" href="../../d9/d7/udf_8h.html#a2">00140</a> <span class="preprocessor"></span><span class="preprocessor">#define UDF_VERSION_102         0x0102</span>
<a name="l00141"></a><a class="code" href="../../d9/d7/udf_8h.html#a3">00141</a> <span class="preprocessor"></span><span class="preprocessor">#define UDF_VERSION_150         0x0150</span>
00142 <span class="preprocessor"></span>
<a name="l00143"></a><a class="code" href="../../d9/d7/udf_8h.html#a4">00143</a> <span class="preprocessor">#define UDF_VERSION_RECOGNIZED  UDF_VERSION_150</span>
00144 <span class="preprocessor"></span>
<a name="l00145"></a><a class="code" href="../../d9/d7/udf_8h.html#a5">00145</a> <span class="preprocessor">#define UDF_VERSION_MINIMUM     UDF_VERSION_100</span>
00146 <span class="preprocessor"></span>
00147 
00148 <span class="comment">//</span>
00149 <span class="comment">//  Method 2 Fixup.</span>
00150 <span class="comment">//</span>
00151 <span class="comment">//  This really isn't UDF, but for lack of a better place ... and since we are doing</span>
00152 <span class="comment">//  the work for UDF only.  In the filesystem.  Sigh.</span>
00153 <span class="comment">//</span>
00154 <span class="comment">//  Various bad CD-ROM units, when reading fixed-packet CD-RW media, fail to map out</span>
00155 <span class="comment">//  the runin/out  blocks that follow each packet of 32 sectors on the media.  As a</span>
00156 <span class="comment">//  result, we have to fixup all of the byte offsets to read the image.</span>
00157 <span class="comment">//</span>
00158 <span class="comment">//  Note: fixed packet. Variable packet discs do have the runin/out exposed, but</span>
00159 <span class="comment">//  imaging software will have realized this and numbered sectors right.</span>
00160 <span class="comment">//</span>
00161 <span class="comment">//  Normally we would refuse to deal with this garbage, but Adaptec made the decision</span>
00162 <span class="comment">//  for us by having their reader handle these drives.  So that we don't have to deal</span>
00163 <span class="comment">//  with endless "but it works with Adaptec", we've got to do it here.</span>
00164 <span class="comment">//</span>
00165 <span class="comment">//  This is really depressing.</span>
00166 <span class="comment">//</span>
00167 
<a name="l00168"></a><a class="code" href="../../d9/d7/udf_8h.html#a6">00168</a> <span class="preprocessor">#define CDRW_PACKET_LENGTH              32</span>
<a name="l00169"></a><a class="code" href="../../d9/d7/udf_8h.html#a7">00169</a> <span class="preprocessor"></span><span class="preprocessor">#define CDRW_RUNOUT_LENGTH              7</span>
00170 <span class="preprocessor"></span>
00171 <span class="comment">//</span>
00172 <span class="comment">//  LONGLONG UdfMethod2TransformByteOffset (</span>
00173 <span class="comment">//      PVCB Vcb,</span>
00174 <span class="comment">//      LONGLONG ByteOffset</span>
00175 <span class="comment">//      )</span>
00176 <span class="comment">//</span>
00177 <span class="comment">//  Takes a normal byteoffset and adds in the differential implied by the number</span>
00178 <span class="comment">//  of runout areas it spans.</span>
00179 <span class="comment">//</span>
00180 
<a name="l00181"></a><a class="code" href="../../d9/d7/udf_8h.html#a8">00181</a> <span class="preprocessor">#define UdfMethod2TransformByteOffset(V, BO)                                \</span>
00182 <span class="preprocessor">    ((BO) + LlBytesFromSectors((V), ((LlSectorsFromBytes((V), BO) / CDRW_PACKET_LENGTH) * CDRW_RUNOUT_LENGTH)))</span>
00183 <span class="preprocessor"></span>
<a name="l00184"></a><a class="code" href="../../d9/d7/udf_8h.html#a9">00184</a> <span class="preprocessor">#define UdfMethod2TransformSector(V, S)                                     \</span>
00185 <span class="preprocessor">    ((S) + ((S) / CDRW_PACKET_LENGTH) * CDRW_RUNOUT_LENGTH)</span>
00186 <span class="preprocessor"></span>
00187 <span class="comment">//</span>
00188 <span class="comment">//  ULONG UdfMethod2NextRunoutInSectors (</span>
00189 <span class="comment">//      PVCB Vcb,</span>
00190 <span class="comment">//      LONGLONG ByteOffset</span>
00191 <span class="comment">//      )</span>
00192 <span class="comment">//</span>
00193 <span class="comment">//  Takes a normal byteoffset and figures out how many sectors remain until the next</span>
00194 <span class="comment">//  (forward) runout area.</span>
00195 <span class="comment">//</span>
00196 
<a name="l00197"></a><a class="code" href="../../d9/d7/udf_8h.html#a10">00197</a> <span class="preprocessor">#define UdfMethod2NextRunoutInSectors(V, BO)                                \</span>
00198 <span class="preprocessor">    (CDRW_PACKET_LENGTH - (LlSectorsFromBytes((V), (BO)) % CDRW_PACKET_LENGTH))</span>
00199 <span class="preprocessor"></span>
00200 
00201 <span class="comment">//</span>
00202 <span class="comment">//  Generic constants</span>
00203 <span class="comment">//</span>
00204 
<a name="l00205"></a><a class="code" href="../../d9/d7/udf_8h.html#a11">00205</a> <span class="preprocessor">#define BYTE_COUNT_8_DOT_3                          (24)</span>
00206 <span class="preprocessor"></span>
00207 <span class="comment">//</span>
00208 <span class="comment">//  Constants for the name transform algorithm.  Names greater than MAXLEN will be</span>
00209 <span class="comment">//  rendered.  MAX_PATH comes from user-side includes that we don't get here.</span>
00210 <span class="comment">//</span>
00211 <span class="comment">//  UDF specifies rules for converting names from illegal-&gt;legal forms for a given OS.</span>
00212 <span class="comment">//  The rest of the constants/macros are used to convert the clipped code for these</span>
00213 <span class="comment">//  algorithims into a form we can directly use.</span>
00214 <span class="comment">//</span>
00215 <span class="comment">//  The NativeCharLength question is really not answerable for the non-8.3 case, since</span>
00216 <span class="comment">//  NT internally is completely ignorant of the eventual destination of the name.</span>
00217 <span class="comment">//</span>
00218 
<a name="l00219"></a><a class="code" href="../../d9/d7/udf_8h.html#a12">00219</a> <span class="preprocessor">#define MAX_PATH            260</span>
00220 <span class="preprocessor"></span>
<a name="l00221"></a><a class="code" href="../../d9/d7/udf_8h.html#a13">00221</a> <span class="preprocessor">#define MAX_LEN             (MAX_PATH - 5)</span>
<a name="l00222"></a><a class="code" href="../../d9/d7/udf_8h.html#a14">00222</a> <span class="preprocessor"></span><span class="preprocessor">#define EXT_LEN             5</span>
<a name="l00223"></a><a class="code" href="../../d9/d7/udf_8h.html#a15">00223</a> <span class="preprocessor"></span><span class="preprocessor">#define CRC_LEN             5</span>
00224 <span class="preprocessor"></span>
<a name="l00225"></a><a class="code" href="../../d9/d7/udf_8h.html#a16">00225</a> <span class="preprocessor">#define DOS_NAME_LEN        8</span>
<a name="l00226"></a><a class="code" href="../../d9/d7/udf_8h.html#a17">00226</a> <span class="preprocessor"></span><span class="preprocessor">#define DOS_EXT_LEN         3</span>
<a name="l00227"></a><a class="code" href="../../d9/d7/udf_8h.html#a18">00227</a> <span class="preprocessor"></span><span class="preprocessor">#define DOS_CRC_LEN         4</span>
00228 <span class="preprocessor"></span>
<a name="l00229"></a><a class="code" href="../../d9/d7/udf_8h.html#a19">00229</a> <span class="preprocessor">#define IsFileNameCharLegal(c)      UdfIsCharacterLegal(c)</span>
<a name="l00230"></a><a class="code" href="../../d9/d7/udf_8h.html#a20">00230</a> <span class="preprocessor"></span><span class="preprocessor">#define IsDeviceName(s, n)          FALSE</span>
<a name="l00231"></a><a class="code" href="../../d9/d7/udf_8h.html#a21">00231</a> <span class="preprocessor"></span><span class="preprocessor">#define NativeCharLength(c)         1</span>
<a name="l00232"></a><a class="code" href="../../d9/d7/udf_8h.html#a22">00232</a> <span class="preprocessor"></span><span class="preprocessor">#define UnicodeToUpper(c)           (c)</span>
00233 <span class="preprocessor"></span>
<a name="l00234"></a><a class="code" href="../../d9/d7/udf_8h.html#a23">00234</a> <span class="preprocessor">#define INT16 LONG</span>
<a name="l00235"></a><a class="code" href="../../d9/d7/udf_8h.html#a24">00235</a> <span class="preprocessor"></span><span class="preprocessor">#define UINT16 ULONG</span>
<a name="l00236"></a><a class="code" href="../../d9/d7/udf_8h.html#a25">00236</a> <span class="preprocessor"></span><span class="preprocessor">#define UNICODE_CHAR WCHAR</span>
00237 <span class="preprocessor"></span>
<a name="l00238"></a><a class="code" href="../../d9/d7/udf_8h.html#a26">00238</a> <span class="preprocessor">#define PERIOD              (L'.')</span>
<a name="l00239"></a><a class="code" href="../../d9/d7/udf_8h.html#a27">00239</a> <span class="preprocessor"></span><span class="preprocessor">#define SPACE               (L' ')</span>
<a name="l00240"></a><a class="code" href="../../d9/d7/udf_8h.html#a28">00240</a> <span class="preprocessor"></span><span class="preprocessor">#define CRC_MARK            (L'#')</span>
<a name="l00241"></a><a class="code" href="../../d9/d7/udf_8h.html#a29">00241</a> <span class="preprocessor"></span><span class="preprocessor">#define ILLEGAL_CHAR_MARK   (L'_')</span>
00242 <span class="preprocessor"></span>
00243 <span class="comment">//</span>
00244 <span class="comment">//  Place a non-tail recursable depth limit on ICB hierarchies.  We cannot read</span>
00245 <span class="comment">//  ICB hierarchies that are deeper than this.</span>
00246 <span class="comment">//</span>
00247 
<a name="l00248"></a><a class="code" href="../../d9/d7/udf_8h.html#a30">00248</a> <span class="preprocessor">#define UDF_ICB_RECURSION_LIMIT 10</span>
00249 <span class="preprocessor"></span>
00250 
00251 <span class="comment">//</span>
00252 <span class="comment">//  Entity ID (REGID) Suffixes are used in UDF to encode extra information away from</span>
00253 <span class="comment">//  the string data in the Identifier.  See UDF 2.1.4.2.</span>
00254 <span class="comment">//</span>
00255 
00256 <span class="comment">//</span>
00257 <span class="comment">//  A Domain Suffix is encoded for the Logical Volume Descriptor and File Set Descriptor</span>
00258 <span class="comment">//</span>
00259 
<a name="l00260"></a><a class="code" href="../../d6/d3/struct__UDF__SUFFIX__DOMAIN.html">00260</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d6/d3/struct__UDF__SUFFIX__DOMAIN.html">_UDF_SUFFIX_DOMAIN</a> {
00261 
<a name="l00262"></a><a class="code" href="../../d6/d3/struct__UDF__SUFFIX__DOMAIN.html#o0">00262</a>     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> <a class="code" href="../../d6/d3/struct__UDF__SUFFIX__DOMAIN.html#o0">UdfRevision</a>;
<a name="l00263"></a><a class="code" href="../../d6/d3/struct__UDF__SUFFIX__DOMAIN.html#o1">00263</a>     UCHAR <a class="code" href="../../d6/d3/struct__UDF__SUFFIX__DOMAIN.html#o1">Flags</a>;
<a name="l00264"></a><a class="code" href="../../d6/d3/struct__UDF__SUFFIX__DOMAIN.html#o2">00264</a>     UCHAR <a class="code" href="../../d6/d3/struct__UDF__SUFFIX__DOMAIN.html#o2">Reserved</a>[5];
00265 
00266 } <a class="code" href="../../d6/d3/struct__UDF__SUFFIX__DOMAIN.html">UDF_SUFFIX_DOMAIN</a>, *<a class="code" href="../../d6/d3/struct__UDF__SUFFIX__DOMAIN.html">PUDF_SUFFIX_DOMAIN</a>;
00267 
<a name="l00268"></a><a class="code" href="../../d9/d7/udf_8h.html#a31">00268</a> <span class="preprocessor">#define UDF_SUFFIX_DOMAIN_FLAG_HARD_WRITEPROTECT 0x01</span>
<a name="l00269"></a><a class="code" href="../../d9/d7/udf_8h.html#a32">00269</a> <span class="preprocessor"></span><span class="preprocessor">#define UDF_SUFFIX_DOMAIN_FLAG_SOFT_WRITEPROTECT 0x02</span>
00270 <span class="preprocessor"></span>
00271 <span class="comment">//</span>
00272 <span class="comment">//  A UDF Suffix is encoded for extended attributes, Implementation Use Volume</span>
00273 <span class="comment">//  Descriptors and VATs (among others).</span>
00274 <span class="comment">//</span>
00275 
<a name="l00276"></a><a class="code" href="../../d8/d3/struct__UDF__SUFFIX__UDF.html">00276</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d8/d3/struct__UDF__SUFFIX__UDF.html">_UDF_SUFFIX_UDF</a> {
00277 
<a name="l00278"></a><a class="code" href="../../d8/d3/struct__UDF__SUFFIX__UDF.html#o0">00278</a>     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> <a class="code" href="../../d8/d3/struct__UDF__SUFFIX__UDF.html#o0">UdfRevision</a>;
<a name="l00279"></a><a class="code" href="../../d8/d3/struct__UDF__SUFFIX__UDF.html#o1">00279</a>     UCHAR <a class="code" href="../../d8/d3/struct__UDF__SUFFIX__UDF.html#o1">OSClass</a>;
<a name="l00280"></a><a class="code" href="../../d8/d3/struct__UDF__SUFFIX__UDF.html#o2">00280</a>     UCHAR <a class="code" href="../../d8/d3/struct__UDF__SUFFIX__UDF.html#o2">OSIdentifier</a>;
<a name="l00281"></a><a class="code" href="../../d8/d3/struct__UDF__SUFFIX__UDF.html#o3">00281</a>     UCHAR <a class="code" href="../../d8/d3/struct__UDF__SUFFIX__UDF.html#o3">Reserved</a>[4];
00282 
00283 } <a class="code" href="../../d8/d3/struct__UDF__SUFFIX__UDF.html">UDF_SUFFIX_UDF</a>, *<a class="code" href="../../d8/d3/struct__UDF__SUFFIX__UDF.html">PUDF_SUFFIX_UDF</a>;
00284 
00285 <span class="comment">//</span>
00286 <span class="comment">//  An Implementation Suffix is encoded for almost every other structure containing</span>
00287 <span class="comment">//  an Entity ID.</span>
00288 <span class="comment">//</span>
00289 
<a name="l00290"></a><a class="code" href="../../d7/d3/struct__UDF__SUFFIX__IMPLEMENTATION.html">00290</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d7/d3/struct__UDF__SUFFIX__IMPLEMENTATION.html">_UDF_SUFFIX_IMPLEMENTATION</a> {
00291 
<a name="l00292"></a><a class="code" href="../../d7/d3/struct__UDF__SUFFIX__IMPLEMENTATION.html#o0">00292</a>     UCHAR <a class="code" href="../../d7/d3/struct__UDF__SUFFIX__IMPLEMENTATION.html#o0">OSClass</a>;
<a name="l00293"></a><a class="code" href="../../d7/d3/struct__UDF__SUFFIX__IMPLEMENTATION.html#o1">00293</a>     UCHAR <a class="code" href="../../d7/d3/struct__UDF__SUFFIX__IMPLEMENTATION.html#o1">OSIdentifier</a>;
<a name="l00294"></a><a class="code" href="../../d7/d3/struct__UDF__SUFFIX__IMPLEMENTATION.html#o2">00294</a>     UCHAR <a class="code" href="../../d7/d3/struct__UDF__SUFFIX__IMPLEMENTATION.html#o2">ImplementationUse</a>[6];
00295 
00296 } <a class="code" href="../../d7/d3/struct__UDF__SUFFIX__IMPLEMENTATION.html">UDF_SUFFIX_IMPLEMENTATION</a>, *<a class="code" href="../../d7/d3/struct__UDF__SUFFIX__IMPLEMENTATION.html">PUDF_SUFFIX_IMPLEMENTATION</a>;
00297 
00298 <span class="comment">//</span>
00299 <span class="comment">//  OS Classes and Identifiers are defined by OSTA as of UDF 1.50</span>
00300 <span class="comment">//</span>
00301 <span class="comment">//  We also take the minor liberty of defining an invalid set for</span>
00302 <span class="comment">//  the purposes of hinting internally that we don't care about them.</span>
00303 <span class="comment">//  It is unlikely that UDF will ever hit 255, even though these are</span>
00304 <span class="comment">//  technically avaliable for allocation.</span>
00305 <span class="comment">//</span>
00306 
<a name="l00307"></a><a class="code" href="../../d9/d7/udf_8h.html#a33">00307</a> <span class="preprocessor">#define OSCLASS_INVALID             255</span>
<a name="l00308"></a><a class="code" href="../../d9/d7/udf_8h.html#a34">00308</a> <span class="preprocessor"></span><span class="preprocessor">#define OSIDENTIFIER_INVALID        255</span>
00309 <span class="preprocessor"></span>
00310 
<a name="l00311"></a><a class="code" href="../../d9/d7/udf_8h.html#a35">00311</a> <span class="preprocessor">#define OSCLASS_UNDEFINED           0</span>
<a name="l00312"></a><a class="code" href="../../d9/d7/udf_8h.html#a36">00312</a> <span class="preprocessor"></span><span class="preprocessor">#define OSCLASS_DOS                 1</span>
<a name="l00313"></a><a class="code" href="../../d9/d7/udf_8h.html#a37">00313</a> <span class="preprocessor"></span><span class="preprocessor">#define OSCLASS_OS2                 2</span>
<a name="l00314"></a><a class="code" href="../../d9/d7/udf_8h.html#a38">00314</a> <span class="preprocessor"></span><span class="preprocessor">#define OSCLASS_MACOS               3</span>
<a name="l00315"></a><a class="code" href="../../d9/d7/udf_8h.html#a39">00315</a> <span class="preprocessor"></span><span class="preprocessor">#define OSCLASS_UNIX                4</span>
<a name="l00316"></a><a class="code" href="../../d9/d7/udf_8h.html#a40">00316</a> <span class="preprocessor"></span><span class="preprocessor">#define OSCLASS_WIN9X               5</span>
<a name="l00317"></a><a class="code" href="../../d9/d7/udf_8h.html#a41">00317</a> <span class="preprocessor"></span><span class="preprocessor">#define OSCLASS_WINNT               6</span>
00318 <span class="preprocessor"></span>
<a name="l00319"></a><a class="code" href="../../d9/d7/udf_8h.html#a42">00319</a> <span class="preprocessor">#define OSIDENTIFIER_DOS_DOS        0</span>
00320 <span class="preprocessor"></span>
<a name="l00321"></a><a class="code" href="../../d9/d7/udf_8h.html#a43">00321</a> <span class="preprocessor">#define OSIDENTIFIER_OS2_OS2        0</span>
00322 <span class="preprocessor"></span>
<a name="l00323"></a><a class="code" href="../../d9/d7/udf_8h.html#a44">00323</a> <span class="preprocessor">#define OSIDENTIFIER_MACOS_MACOS7   0</span>
00324 <span class="preprocessor"></span>
<a name="l00325"></a><a class="code" href="../../d9/d7/udf_8h.html#a45">00325</a> <span class="preprocessor">#define OSIDENTIFIER_UNIX_GENERIC   0</span>
<a name="l00326"></a><a class="code" href="../../d9/d7/udf_8h.html#a46">00326</a> <span class="preprocessor"></span><span class="preprocessor">#define OSIDENTIFIER_UNIX_AIX       1</span>
<a name="l00327"></a><a class="code" href="../../d9/d7/udf_8h.html#a47">00327</a> <span class="preprocessor"></span><span class="preprocessor">#define OSIDENTIFIER_UNIX_SOLARIS   2</span>
<a name="l00328"></a><a class="code" href="../../d9/d7/udf_8h.html#a48">00328</a> <span class="preprocessor"></span><span class="preprocessor">#define OSIDENTIFIER_UNIX_HPUX      3</span>
<a name="l00329"></a><a class="code" href="../../d9/d7/udf_8h.html#a49">00329</a> <span class="preprocessor"></span><span class="preprocessor">#define OSIDENTIFIER_UNIX_IRIX      4</span>
<a name="l00330"></a><a class="code" href="../../d9/d7/udf_8h.html#a50">00330</a> <span class="preprocessor"></span><span class="preprocessor">#define OSIDENTIFIER_UNIX_LINUX     5</span>
<a name="l00331"></a><a class="code" href="../../d9/d7/udf_8h.html#a51">00331</a> <span class="preprocessor"></span><span class="preprocessor">#define OSIDENTIFIER_UNIX_MKLINUX   6</span>
<a name="l00332"></a><a class="code" href="../../d9/d7/udf_8h.html#a52">00332</a> <span class="preprocessor"></span><span class="preprocessor">#define OSIDENTIFIER_UNIX_FREEBSD   7</span>
00333 <span class="preprocessor"></span>
<a name="l00334"></a><a class="code" href="../../d9/d7/udf_8h.html#a53">00334</a> <span class="preprocessor">#define OSIDENTIFIER_WIN9X_WIN95    0</span>
00335 <span class="preprocessor"></span>
<a name="l00336"></a><a class="code" href="../../d9/d7/udf_8h.html#a54">00336</a> <span class="preprocessor">#define OSIDENTIFIED_WINNT_WINNT    0</span>
00337 <span class="preprocessor"></span>
00338 
00339 <span class="comment">//</span>
00340 <span class="comment">//  Character Set Lists are actually just a 32bit word where each bit N on/off specifies</span>
00341 <span class="comment">//  that Character Set N is used on the volume.  Per UDF, the only character set we</span>
00342 <span class="comment">//  recognize is CS0, so construct a bitmask Character Set List for that. (1/7.2.11)</span>
00343 <span class="comment">//</span>
00344 
<a name="l00345"></a><a class="code" href="../../d9/d7/udf_8h.html#a55">00345</a> <span class="preprocessor">#define UDF_CHARSETLIST 0x00000001</span>
00346 <span class="preprocessor"></span>
00347 
00348 <span class="comment">//</span>
00349 <span class="comment">//  Generic partition map for UDF.  This allows partition maps to be typed and the</span>
00350 <span class="comment">//  UDF entity identifier for the various type 2 maps to be inspected.</span>
00351 <span class="comment">//</span>
00352 
<a name="l00353"></a><a class="code" href="../../d0/d9/struct__PARTMAP__UDF__GENERIC.html">00353</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d0/d9/struct__PARTMAP__UDF__GENERIC.html">_PARTMAP_UDF_GENERIC</a> {
00354 
<a name="l00355"></a><a class="code" href="../../d0/d9/struct__PARTMAP__UDF__GENERIC.html#o0">00355</a>     UCHAR       <a class="code" href="../../d0/d9/struct__PARTMAP__UDF__GENERIC.html#o0">Type</a>;                   <span class="comment">//  Partition Map Type = 2</span>
<a name="l00356"></a><a class="code" href="../../d0/d9/struct__PARTMAP__UDF__GENERIC.html#o1">00356</a>     UCHAR       <a class="code" href="../../d0/d9/struct__PARTMAP__UDF__GENERIC.html#o1">Length</a>;                 <span class="comment">//  Partition Map Length = 64</span>
<a name="l00357"></a><a class="code" href="../../d0/d9/struct__PARTMAP__UDF__GENERIC.html#o2">00357</a>     UCHAR       <a class="code" href="../../d0/d9/struct__PARTMAP__UDF__GENERIC.html#o2">Reserved2</a>[2];           <span class="comment">//  Reserved Padding</span>
<a name="l00358"></a><a class="code" href="../../d0/d9/struct__PARTMAP__UDF__GENERIC.html#o3">00358</a>     <a class="code" href="../../d6/d6/structREGID.html">REGID</a>       <a class="code" href="../../d0/d9/struct__PARTMAP__UDF__GENERIC.html#o3">PartID</a>;                 <span class="comment">//  Paritition Entity Identifier</span>
<a name="l00359"></a><a class="code" href="../../d0/d9/struct__PARTMAP__UDF__GENERIC.html#o4">00359</a>     UCHAR       <a class="code" href="../../d0/d9/struct__PARTMAP__UDF__GENERIC.html#o4">Reserved24</a>[28];         <span class="comment">//  Reserved Padding</span>
00360 
00361 } <a class="code" href="../../d0/d9/struct__PARTMAP__UDF__GENERIC.html">PARTMAP_UDF_GENERIC</a>, *<a class="code" href="../../d0/d9/struct__PARTMAP__UDF__GENERIC.html">PPARTMAP_UDF_GENERIC</a>;
00362 
00363 <span class="comment">//</span>
00364 <span class="comment">//  UDF 1.50 CD UDF Partition Types</span>
00365 <span class="comment">//</span>
00366 
00368 <span class="comment">//  UDF Virtual Partitions are identified via a type 2 partition map of the following form.</span>
00370 <span class="comment"></span>
<a name="l00371"></a><a class="code" href="../../d1/d9/struct__PARTMAP__VIRTUAL.html">00371</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d1/d9/struct__PARTMAP__VIRTUAL.html">_PARTMAP_VIRTUAL</a> {
00372 
<a name="l00373"></a><a class="code" href="../../d1/d9/struct__PARTMAP__VIRTUAL.html#o0">00373</a>     UCHAR       <a class="code" href="../../d1/d9/struct__PARTMAP__VIRTUAL.html#o0">Type</a>;                   <span class="comment">//  Partition Map Type = 2</span>
<a name="l00374"></a><a class="code" href="../../d1/d9/struct__PARTMAP__VIRTUAL.html#o1">00374</a>     UCHAR       <a class="code" href="../../d1/d9/struct__PARTMAP__VIRTUAL.html#o1">Length</a>;                 <span class="comment">//  Partition Map Length = 64</span>
<a name="l00375"></a><a class="code" href="../../d1/d9/struct__PARTMAP__VIRTUAL.html#o2">00375</a>     UCHAR       <a class="code" href="../../d1/d9/struct__PARTMAP__VIRTUAL.html#o2">Reserved2</a>[2];           <span class="comment">//  Reserved Padding</span>
<a name="l00376"></a><a class="code" href="../../d1/d9/struct__PARTMAP__VIRTUAL.html#o3">00376</a>     <a class="code" href="../../d6/d6/structREGID.html">REGID</a>       <a class="code" href="../../d1/d9/struct__PARTMAP__VIRTUAL.html#o3">PartID</a>;                 <span class="comment">//  Paritition Entity Identifier</span>
00377                                         <span class="comment">//   == UdfVirtualPartitionDomainIdentifier</span>
<a name="l00378"></a><a class="code" href="../../d1/d9/struct__PARTMAP__VIRTUAL.html#o4">00378</a>     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>      <a class="code" href="../../d1/d9/struct__PARTMAP__VIRTUAL.html#o4">VolSetSeq</a>;              <span class="comment">//  Volume Set Sequence</span>
<a name="l00379"></a><a class="code" href="../../d1/d9/struct__PARTMAP__VIRTUAL.html#o5">00379</a>     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>      <a class="code" href="../../d1/d9/struct__PARTMAP__VIRTUAL.html#o5">Partition</a>;              <span class="comment">//  Related Partition</span>
<a name="l00380"></a><a class="code" href="../../d1/d9/struct__PARTMAP__VIRTUAL.html#o6">00380</a>     UCHAR       <a class="code" href="../../d1/d9/struct__PARTMAP__VIRTUAL.html#o6">Reserved40</a>[24];         <span class="comment">//  Reserved Padding</span>
00381 
00382 } <a class="code" href="../../d1/d9/struct__PARTMAP__VIRTUAL.html">PARTMAP_VIRTUAL</a>, *<a class="code" href="../../d1/d9/struct__PARTMAP__VIRTUAL.html">PPARTMAP_VIRTUAL</a>;
00383 
00384 <span class="comment">//</span>
00385 <span class="comment">//  A VAT minimally contains a mapping for a single block, the REGID identifying</span>
00386 <span class="comment">//  the VAT, and the identification of a previous VAT ICB location.  We also identify</span>
00387 <span class="comment">//  an arbitrary sanity limit that the VAT isn't bigger than 8mb since it is extremely</span>
00388 <span class="comment">//  difficult to imagine such a VAT existing in practice since each sector describes</span>
00389 <span class="comment">//  (on most of our media) 2048/4 = 512 entries ... meaning at 8mb the VAT would</span>
00390 <span class="comment">//  describe ~2^21 blocks.</span>
00391 <span class="comment">//</span>
00392 
<a name="l00393"></a><a class="code" href="../../d9/d7/udf_8h.html#a56">00393</a> <span class="preprocessor">#define UDF_CDUDF_TRAILING_DATA_SIZE    (sizeof(REGID) + sizeof(ULONG))</span>
00394 <span class="preprocessor"></span>
<a name="l00395"></a><a class="code" href="../../d9/d7/udf_8h.html#a57">00395</a> <span class="preprocessor">#define UDF_CDUDF_MINIMUM_VAT_SIZE      (sizeof(ULONG) + UDF_CDUDF_TRAILING_DATA_SIZE)</span>
<a name="l00396"></a><a class="code" href="../../d9/d7/udf_8h.html#a58">00396</a> <span class="preprocessor"></span><span class="preprocessor">#define UDF_CDUDF_MAXIMUM_VAT_SIZE      (UDF_CDUDF_MINIMUM_VAT_SIZE + (8 * 1024 * 1024))</span>
00397 <span class="preprocessor"></span>
00399 <span class="comment">//  UDF Sparable Partitions are identified via a type 2 partition map of the following form.</span>
00401 <span class="comment"></span>
<a name="l00402"></a><a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html">00402</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html">_PARTMAP_SPARABLE</a> {
00403 
<a name="l00404"></a><a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o0">00404</a>     UCHAR       <a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o0">Type</a>;                   <span class="comment">//  Partition Map Type = 2</span>
<a name="l00405"></a><a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o1">00405</a>     UCHAR       <a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o1">Length</a>;                 <span class="comment">//  Partition Map Length = 64</span>
<a name="l00406"></a><a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o2">00406</a>     UCHAR       <a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o2">Reserved2</a>[2];           <span class="comment">//  Reserved Padding</span>
<a name="l00407"></a><a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o3">00407</a>     <a class="code" href="../../d6/d6/structREGID.html">REGID</a>       <a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o3">PartID</a>;                 <span class="comment">//  Paritition Entity Identifier</span>
00408                                         <span class="comment">//   == UdfSparablePartitionDomainIdentifier</span>
<a name="l00409"></a><a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o4">00409</a>     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>      <a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o4">VolSetSeq</a>;              <span class="comment">//  Volume Set Sequence</span>
<a name="l00410"></a><a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o5">00410</a>     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>      <a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o5">Partition</a>;              <span class="comment">//  Related Partition</span>
<a name="l00411"></a><a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o6">00411</a>     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>      <a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o6">PacketLength</a>;           <span class="comment">//  Packet Length == 32 (number of data blocks</span>
00412                                         <span class="comment">//   per packet)</span>
<a name="l00413"></a><a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o7">00413</a>     UCHAR       <a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o7">NumSparingTables</a>;       <span class="comment">//  Number of pparing tables on the media</span>
<a name="l00414"></a><a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o8">00414</a>     UCHAR       <a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o8">Reserved43</a>;             <span class="comment">//  Reserved Padding</span>
<a name="l00415"></a><a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o9">00415</a>     ULONG       <a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o9">TableSize</a>;              <span class="comment">//  Size of sparing tables</span>
<a name="l00416"></a><a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o10">00416</a>     ULONG       <a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o10">TableLocation</a>[4];       <span class="comment">//  Location of each sparing table (each</span>
00417                                         <span class="comment">//   sparing table should be in a distinct packet)</span>
00418 
00419 } <a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html">PARTMAP_SPARABLE</a>, *<a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html">PPARTMAP_SPARABLE</a>;
00420 
00421 <span class="comment">//</span>
00422 <span class="comment">//  Sparing tables lead off with this header structure.</span>
00423 <span class="comment">//</span>
00424 
<a name="l00425"></a><a class="code" href="../../d5/d5/struct__SPARING__TABLE__HEADER.html">00425</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d5/d5/struct__SPARING__TABLE__HEADER.html">_SPARING_TABLE_HEADER</a> {
00426 
<a name="l00427"></a><a class="code" href="../../d5/d5/struct__SPARING__TABLE__HEADER.html#o0">00427</a>     <a class="code" href="../../d7/d7/structDESTAG.html">DESTAG</a>      <a class="code" href="../../d5/d5/struct__SPARING__TABLE__HEADER.html#o0">Destag</a>;                 <span class="comment">//  Ident = 0</span>
<a name="l00428"></a><a class="code" href="../../d5/d5/struct__SPARING__TABLE__HEADER.html#o1">00428</a>     <a class="code" href="../../d6/d6/structREGID.html">REGID</a>       <a class="code" href="../../d5/d5/struct__SPARING__TABLE__HEADER.html#o1">RegID</a>;                  <span class="comment">//  == UdfSparingTableIdentifier</span>
<a name="l00429"></a><a class="code" href="../../d5/d5/struct__SPARING__TABLE__HEADER.html#o2">00429</a>     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>      <a class="code" href="../../d5/d5/struct__SPARING__TABLE__HEADER.html#o2">TableEntries</a>;           <span class="comment">//  Number of entries in the table</span>
<a name="l00430"></a><a class="code" href="../../d5/d5/struct__SPARING__TABLE__HEADER.html#o3">00430</a>     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>      <a class="code" href="../../d5/d5/struct__SPARING__TABLE__HEADER.html#o3">Reserved50</a>;             <span class="comment">//  Reserved Padding</span>
<a name="l00431"></a><a class="code" href="../../d5/d5/struct__SPARING__TABLE__HEADER.html#o4">00431</a>     ULONG       <a class="code" href="../../d5/d5/struct__SPARING__TABLE__HEADER.html#o4">Sequence</a>;               <span class="comment">//  Sequence Number (incremented on rewrite of table)</span>
00432 
00433 } *<a class="code" href="../../d5/d5/struct__SPARING__TABLE__HEADER.html">PSPARING_TABLE_HEADER</a>, <a class="code" href="../../d5/d5/struct__SPARING__TABLE__HEADER.html">SPARING_TABLE_HEADER</a>;
00434 
00435 <span class="comment">//</span>
00436 <span class="comment">//  Sparing table map entries.</span>
00437 <span class="comment">//</span>
00438 
<a name="l00439"></a><a class="code" href="../../d4/d5/struct__SPARING__TABLE__ENTRY.html">00439</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d4/d5/struct__SPARING__TABLE__ENTRY.html">_SPARING_TABLE_ENTRY</a> {
00440 
<a name="l00441"></a><a class="code" href="../../d4/d5/struct__SPARING__TABLE__ENTRY.html#o0">00441</a>     ULONG <a class="code" href="../../d4/d5/struct__SPARING__TABLE__ENTRY.html#o0">Original</a>;                     <span class="comment">//  Original LBN</span>
<a name="l00442"></a><a class="code" href="../../d4/d5/struct__SPARING__TABLE__ENTRY.html#o1">00442</a>     ULONG <a class="code" href="../../d4/d5/struct__SPARING__TABLE__ENTRY.html#o1">Mapped</a>;                       <span class="comment">//  Mapped PSN</span>
00443 
00444 } *<a class="code" href="../../d4/d5/struct__SPARING__TABLE__ENTRY.html">PSPARING_TABLE_ENTRY</a>, <a class="code" href="../../d4/d5/struct__SPARING__TABLE__ENTRY.html">SPARING_TABLE_ENTRY</a>;
00445 
00446 <span class="comment">//</span>
00447 <span class="comment">//  Fixed values for original sectors, indicating that either the</span>
00448 <span class="comment">//  mapped packet is avaliable for sparing use or is defective.</span>
00449 <span class="comment">//</span>
00450 
<a name="l00451"></a><a class="code" href="../../d9/d7/udf_8h.html#a59">00451</a> <span class="preprocessor">#define UDF_SPARING_AVALIABLE           0xffffffff</span>
<a name="l00452"></a><a class="code" href="../../d9/d7/udf_8h.html#a60">00452</a> <span class="preprocessor"></span><span class="preprocessor">#define UDF_SPARING_DEFECTIVE           0xfffffff0</span>
00453 <span class="preprocessor"></span> 
00454 <span class="comment">//</span>
00455 <span class="comment">//  The unit of media in each sparing packet is fixed at 32 physical sectors.</span>
00456 <span class="comment">//</span>
00457 
<a name="l00458"></a><a class="code" href="../../d9/d7/udf_8h.html#a61">00458</a> <span class="preprocessor">#define UDF_SPARING_PACKET_LENGTH       CDRW_PACKET_LENGTH</span>
00459 <span class="preprocessor"></span>
00460 <span class="preprocessor">#endif // _UDF_</span>
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:42:10 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
