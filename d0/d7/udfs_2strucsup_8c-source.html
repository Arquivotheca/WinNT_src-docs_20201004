<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: strucsup.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>strucsup.c</h1><a href="../../d9/d7/udfs_2strucsup_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1989  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    StrucSup.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module implements the Udfs in-memory data structure manipulation</span>
00012 <span class="comment">    routines</span>
00013 <span class="comment"></span>
00014 <span class="comment">Author:</span>
00015 <span class="comment"></span>
00016 <span class="comment">    Dan Lovinger    [DanLo]   19-Jun-1996</span>
00017 <span class="comment"></span>
00018 <span class="comment">Revision History:</span>
00019 <span class="comment"></span>
00020 <span class="comment">--*/</span>
00021 
00022 <span class="preprocessor">#include "UdfProcs.h"</span>
00023 
00024 <span class="comment">//</span>
00025 <span class="comment">//  The Bug check file id for this module</span>
00026 <span class="comment">//</span>
00027 
<a name="l00028"></a><a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a0">00028</a> <span class="preprocessor">#define BugCheckFileId                   (UDFS_BUG_CHECK_STRUCSUP)</span>
00029 <span class="preprocessor"></span>
00030 <span class="comment">//</span>
00031 <span class="comment">//  The local debug trace level</span>
00032 <span class="comment">//</span>
00033 
<a name="l00034"></a><a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a1">00034</a> <span class="preprocessor">#define Dbg                              (UDFS_DEBUG_LEVEL_STRUCSUP)</span>
00035 <span class="preprocessor"></span>
00036 <span class="comment">//</span>
00037 <span class="comment">//  Local structures</span>
00038 <span class="comment">//</span>
00039 
<a name="l00040"></a><a class="code" href="../../d5/d0/struct__FCB__TABLE__ELEMENT.html">00040</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d5/d0/struct__FCB__TABLE__ELEMENT.html">_FCB_TABLE_ELEMENT</a> {
00041 
<a name="l00042"></a><a class="code" href="../../d5/d0/struct__FCB__TABLE__ELEMENT.html#o0">00042</a>     <a class="code" href="../../d6/d8/udfstruc_8h.html#a77">FILE_ID</a> <a class="code" href="../../d5/d0/struct__FCB__TABLE__ELEMENT.html#o0">FileId</a>;
<a name="l00043"></a><a class="code" href="../../d5/d0/struct__FCB__TABLE__ELEMENT.html#o1">00043</a>     <a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a> <a class="code" href="../../d5/d0/struct__FCB__TABLE__ELEMENT.html#o1">Fcb</a>;
00044 
00045 } <a class="code" href="../../d5/d0/struct__FCB__TABLE__ELEMENT.html">FCB_TABLE_ELEMENT</a>, *<a class="code" href="../../d5/d0/struct__FCB__TABLE__ELEMENT.html">PFCB_TABLE_ELEMENT</a>;
00046 
00047 <span class="comment">//</span>
00048 <span class="comment">//  Local macros</span>
00049 <span class="comment">//</span>
00050 
00051 <span class="comment">//</span>
00052 <span class="comment">//  PFCB</span>
00053 <span class="comment">//  UdfAllocateFcbData (</span>
00054 <span class="comment">//      IN PIRP_CONTEXT IrpContext</span>
00055 <span class="comment">//      );</span>
00056 <span class="comment">//</span>
00057 <span class="comment">//  VOID</span>
00058 <span class="comment">//  UdfDeallocateFcbData (</span>
00059 <span class="comment">//      IN PIRP_CONTEXT IrpContext,</span>
00060 <span class="comment">//      IN PFCB Fcb</span>
00061 <span class="comment">//      );</span>
00062 <span class="comment">//</span>
00063 <span class="comment">//  PFCB</span>
00064 <span class="comment">//  UdfAllocateFcbIndex (</span>
00065 <span class="comment">//      IN PIRP_CONTEXT IrpContext</span>
00066 <span class="comment">//      );</span>
00067 <span class="comment">//</span>
00068 <span class="comment">//  VOID</span>
00069 <span class="comment">//  UdfDeallocateFcbIndex (</span>
00070 <span class="comment">//      IN PIRP_CONTEXT IrpContext,</span>
00071 <span class="comment">//      IN PFCB Fcb</span>
00072 <span class="comment">//      );</span>
00073 <span class="comment">//</span>
00074 <span class="comment">//  PFCB_NONPAGED</span>
00075 <span class="comment">//  UdfAllocateFcbNonpaged (</span>
00076 <span class="comment">//      IN PIRP_CONTEXT IrpContext</span>
00077 <span class="comment">//      );</span>
00078 <span class="comment">//</span>
00079 <span class="comment">//  VOID</span>
00080 <span class="comment">//  UdfDeallocateFcbNonpaged (</span>
00081 <span class="comment">//      IN PIRP_CONTEXT IrpContext,</span>
00082 <span class="comment">//      IN PFCB_NONPAGED FcbNonpaged</span>
00083 <span class="comment">//      );</span>
00084 <span class="comment">//</span>
00085 <span class="comment">//  PCCB</span>
00086 <span class="comment">//  UdfAllocateCcb (</span>
00087 <span class="comment">//      IN PIRP_CONTEXT IrpContext</span>
00088 <span class="comment">//      );</span>
00089 <span class="comment">//</span>
00090 <span class="comment">//  VOID</span>
00091 <span class="comment">//  UdfDeallocateCcb (</span>
00092 <span class="comment">//      IN PIRP_CONTEXT IrpContext,</span>
00093 <span class="comment">//      IN PCCB Ccb</span>
00094 <span class="comment">//      );</span>
00095 <span class="comment">//</span>
00096 
<a name="l00097"></a><a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a2">00097</a> <span class="preprocessor">#define UdfAllocateFcbData(IC) \</span>
00098 <span class="preprocessor">    ExAllocateFromPagedLookasideList( &amp;UdfFcbDataLookasideList );</span>
00099 <span class="preprocessor"></span>
<a name="l00100"></a><a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a3">00100</a> <span class="preprocessor">#define UdfDeallocateFcbData(IC,F) \</span>
00101 <span class="preprocessor">    ExFreeToPagedLookasideList( &amp;UdfFcbDataLookasideList, F );</span>
00102 <span class="preprocessor"></span>
<a name="l00103"></a><a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a4">00103</a> <span class="preprocessor">#define UdfAllocateFcbIndex(IC) \</span>
00104 <span class="preprocessor">    ExAllocateFromPagedLookasideList( &amp;UdfFcbIndexLookasideList );</span>
00105 <span class="preprocessor"></span>
<a name="l00106"></a><a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a5">00106</a> <span class="preprocessor">#define UdfDeallocateFcbIndex(IC,F) \</span>
00107 <span class="preprocessor">    ExFreeToPagedLookasideList( &amp;UdfFcbIndexLookasideList, F );</span>
00108 <span class="preprocessor"></span>
<a name="l00109"></a><a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a6">00109</a> <span class="preprocessor">#define UdfAllocateFcbNonpaged(IC) \</span>
00110 <span class="preprocessor">    ExAllocateFromNPagedLookasideList( &amp;UdfFcbNonPagedLookasideList );</span>
00111 <span class="preprocessor"></span>
<a name="l00112"></a><a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a7">00112</a> <span class="preprocessor">#define UdfDeallocateFcbNonpaged(IC,FNP) \</span>
00113 <span class="preprocessor">    ExFreeToNPagedLookasideList( &amp;UdfFcbNonPagedLookasideList, FNP );</span>
00114 <span class="preprocessor"></span>
<a name="l00115"></a><a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a8">00115</a> <span class="preprocessor">#define UdfAllocateCcb(IC) \</span>
00116 <span class="preprocessor">    ExAllocateFromPagedLookasideList( &amp;UdfCcbLookasideList );</span>
00117 <span class="preprocessor"></span>
<a name="l00118"></a><a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a9">00118</a> <span class="preprocessor">#define UdfDeallocateCcb(IC,C) \</span>
00119 <span class="preprocessor">    ExFreeToPagedLookasideList( &amp;UdfCcbLookasideList, C );</span>
00120 <span class="preprocessor"></span>
00121 <span class="comment">//</span>
00122 <span class="comment">//  VOID</span>
00123 <span class="comment">//  UdfInsertFcbTable (</span>
00124 <span class="comment">//      IN PIRP_CONTEXT IrpContext,</span>
00125 <span class="comment">//      IN PFCB Fcb</span>
00126 <span class="comment">//      );</span>
00127 <span class="comment">//</span>
00128 <span class="comment">//  VOID</span>
00129 <span class="comment">//  UdfDeleteFcbTable (</span>
00130 <span class="comment">//      IN PIRP_CONTEXT IrpContext,</span>
00131 <span class="comment">//      IN PFCB Fcb</span>
00132 <span class="comment">//      );</span>
00133 <span class="comment">//</span>
00134 
00135 
<a name="l00136"></a><a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a10">00136</a> <span class="preprocessor">#define UdfInsertFcbTable(IC,F) {                                   \</span>
00137 <span class="preprocessor">    FCB_TABLE_ELEMENT _Key;                                         \</span>
00138 <span class="preprocessor">    _Key.Fcb = (F);                                                 \</span>
00139 <span class="preprocessor">    _Key.FileId = (F)-&gt;FileId;                                      \</span>
00140 <span class="preprocessor">    RtlInsertElementGenericTable( &amp;(F)-&gt;Vcb-&gt;FcbTable,              \</span>
00141 <span class="preprocessor">                                  &amp;_Key,                            \</span>
00142 <span class="preprocessor">                                  sizeof( FCB_TABLE_ELEMENT ),      \</span>
00143 <span class="preprocessor">                                  NULL );                           \</span>
00144 <span class="preprocessor">}</span>
00145 <span class="preprocessor"></span>
<a name="l00146"></a><a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a11">00146</a> <span class="preprocessor">#define UdfDeleteFcbTable(IC,F) {                                   \</span>
00147 <span class="preprocessor">    FCB_TABLE_ELEMENT _Key;                                         \</span>
00148 <span class="preprocessor">    _Key.FileId = (F)-&gt;FileId;                                      \</span>
00149 <span class="preprocessor">    RtlDeleteElementGenericTable( &amp;(F)-&gt;Vcb-&gt;FcbTable, &amp;_Key );     \</span>
00150 <span class="preprocessor">}</span>
00151 <span class="preprocessor"></span>
00152 <span class="comment">//</span>
00153 <span class="comment">//  Discovers the partition the current allocation descriptor's referred extent</span>
00154 <span class="comment">//  is on, either explicitly throuigh the descriptor or implicitly through the</span>
00155 <span class="comment">//  mapped view.</span>
00156 <span class="comment">//</span>
00157 
00158 <a class="code" href="../../d5/d3/filelock_8c.html#a1">INLINE</a>
00159 <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>
<a name="l00160"></a><a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a14">00160</a> <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a14">UdfGetPartitionOfCurrentAllocation</a> (
00161     IN <a class="code" href="../../d2/d6/struct__ALLOC__ENUM__CONTEXT.html">PALLOC_ENUM_CONTEXT</a> AllocContext
00162     )
00163 {
00164     <span class="keywordflow">if</span> (AllocContext-&gt;AllocType == <a class="code" href="../../d0/d7/iso13346_8h.html#a113">ICBTAG_F_ALLOC_LONG</a>) {
00165 
00166         <span class="keywordflow">return</span> ((<a class="code" href="../../d4/d9/structLONGAD.html">PLONGAD</a>) AllocContext-&gt;Alloc)-&gt;Start.Partition;
00167     
00168     } <span class="keywordflow">else</span> {
00169 
00170         <span class="keywordflow">return</span> AllocContext-&gt;IcbContext-&gt;Active.Partition;
00171     }
00172 }
00173 
00174 <span class="comment">//</span>
00175 <span class="comment">//  Builds the Mcb in an Fcb.  Use this after knowing that an Mcb is required</span>
00176 <span class="comment">//  for mapping information.</span>
00177 <span class="comment">//</span>
00178 
00179 <a class="code" href="../../d5/d3/filelock_8c.html#a1">INLINE</a>
00180 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00181"></a><a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a15">00181</a> <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a15">UdfInitializeFcbMcb</a> (
00182     IN <a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a> Fcb
00183     )
00184 {
00185     <span class="comment">//</span>
00186     <span class="comment">//  In certain rare situations, we may get called more than once.</span>
00187     <span class="comment">//  Just reset the allocations.</span>
00188     <span class="comment">//</span>
00189     
00190     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( Fcb-&gt;FcbState, <a class="code" href="../../d6/d8/udfstruc_8h.html#a17">FCB_STATE_MCB_INITIALIZED</a> )) {
00191     
00192         <a class="code" href="../../d1/d8/fsrtl_8h.html#a141">FsRtlResetLargeMcb</a>( &amp;Fcb-&gt;Mcb, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00193 
00194     } <span class="keywordflow">else</span> {
00195     
00196         <a class="code" href="../../d1/d8/fsrtl_8h.html#a139">FsRtlInitializeLargeMcb</a>( &amp;Fcb-&gt;Mcb, <a class="code" href="../../d3/d8/udfprocs_8h.html#a65">UdfPagedPool</a> );
00197         <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( Fcb-&gt;FcbState, <a class="code" href="../../d6/d8/udfstruc_8h.html#a17">FCB_STATE_MCB_INITIALIZED</a> );
00198     }
00199 }
00200 
00201 <span class="comment">//</span>
00202 <span class="comment">//  Teardown an Fcb's Mcb as required.</span>
00203 <span class="comment">//</span>
00204 
00205 <a class="code" href="../../d5/d3/filelock_8c.html#a1">INLINE</a>
00206 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00207"></a><a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a16">00207</a> <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a16">UdfUninitializeFcbMcb</a> (
00208     IN <a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a> Fcb
00209     )
00210 {
00211     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( Fcb-&gt;FcbState, <a class="code" href="../../d6/d8/udfstruc_8h.html#a17">FCB_STATE_MCB_INITIALIZED</a> )) {
00212     
00213         <a class="code" href="../../d1/d8/fsrtl_8h.html#a140">FsRtlUninitializeLargeMcb</a>( &amp;Fcb-&gt;Mcb );
00214         <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>( Fcb-&gt;FcbState, <a class="code" href="../../d6/d8/udfstruc_8h.html#a17">FCB_STATE_MCB_INITIALIZED</a> );
00215     }
00216 }
00217 
00218 <span class="comment">//</span>
00219 <span class="comment">//  Local support routines</span>
00220 <span class="comment">//</span>
00221 
00222 PVOID
00223 <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a17">UdfAllocateTable</a> (
00224     IN PRTL_GENERIC_TABLE Table,
00225     IN CLONG ByteSize
00226     );
00227 
00228 <a class="code" href="../../d4/d0/struct__FCB__NONPAGED.html">PFCB_NONPAGED</a>
00229 <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a18">UdfCreateFcbNonPaged</a> (
00230     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext
00231     );
00232 
00233 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00234 <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a19">UdfDeleteFcbNonpaged</a> (
00235     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00236     IN <a class="code" href="../../d4/d0/struct__FCB__NONPAGED.html">PFCB_NONPAGED</a> FcbNonpaged
00237     );
00238 
00239 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00240 <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a20">UdfDeallocateTable</a> (
00241     IN PRTL_GENERIC_TABLE Table,
00242     IN PVOID Buffer
00243     );
00244 
00245 RTL_GENERIC_COMPARE_RESULTS
00246 <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a21">UdfFcbTableCompare</a> (
00247     IN PRTL_GENERIC_TABLE Table,
00248     IN PVOID id1,
00249     IN PVOID id2
00250     );
00251 
00252 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00253 <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a22">UdfInitializeAllocationContext</a> (
00254     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00255     IN <a class="code" href="../../d2/d6/struct__ALLOC__ENUM__CONTEXT.html">PALLOC_ENUM_CONTEXT</a> AllocContext,
00256     IN <a class="code" href="../../d9/d9/struct__ICB__SEARCH__CONTEXT.html">PICB_SEARCH_CONTEXT</a> IcbContext
00257     );
00258 
00259 BOOLEAN
00260 <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a23">UdfGetNextAllocation</a> (
00261     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00262     IN <a class="code" href="../../d2/d6/struct__ALLOC__ENUM__CONTEXT.html">PALLOC_ENUM_CONTEXT</a> AllocContext
00263     );
00264 
00265 BOOLEAN
00266 <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a24">UdfGetNextAllocationPostProcessing</a> (
00267     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00268     IN <a class="code" href="../../d2/d6/struct__ALLOC__ENUM__CONTEXT.html">PALLOC_ENUM_CONTEXT</a> AllocContext
00269     );
00270 
00271 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00272 <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a25">UdfLookupActiveIcbInExtent</a> (
00273     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00274     IN <a class="code" href="../../d9/d9/struct__ICB__SEARCH__CONTEXT.html">PICB_SEARCH_CONTEXT</a> IcbContext,
00275     IN ULONG Recurse
00276     );
00277 
00278 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00279 <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a26">UdfInitializeEaContext</a> (
00280     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00281     IN <a class="code" href="../../d6/d1/struct__EA__SEARCH__CONTEXT.html">PEA_SEARCH_CONTEXT</a> EaContext,
00282     IN <a class="code" href="../../d9/d9/struct__ICB__SEARCH__CONTEXT.html">PICB_SEARCH_CONTEXT</a> IcbContext,
00283     IN ULONG EAType,
00284     IN UCHAR EASubType
00285     );
00286 
00287 BOOLEAN
00288 <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a27">UdfLookupEa</a> (
00289     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00290     IN <a class="code" href="../../d6/d1/struct__EA__SEARCH__CONTEXT.html">PEA_SEARCH_CONTEXT</a> EaContext
00291     );
00292 
00293 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00294 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfAllocateTable)</span>
00295 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfCleanupIcbContext)</span>
00296 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfCleanupIrpContext)</span>
00297 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfCreateCcb)</span>
00298 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfCreateFcb)</span>
00299 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfCreateFcbNonPaged)</span>
00300 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfCreateIrpContext)</span>
00301 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfDeallocateTable)</span>
00302 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfDeleteCcb)</span>
00303 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfDeleteFcb)</span>
00304 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfDeleteFcbNonpaged)</span>
00305 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfDeleteVcb)</span>
00306 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfFcbTableCompare)</span>
00307 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfFindInParseTable)</span>
00308 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfGetNextAllocation)</span>
00309 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfGetNextAllocationPostProcessing)</span>
00310 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfGetNextFcb)</span>
00311 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfInitializeAllocationContext)</span>
00312 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfInitializeAllocations)</span>
00313 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfInitializeEaContext)</span>
00314 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfInitializeFcbFromIcbContext)</span>
00315 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfInitializeIcbContext)</span>
00316 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfInitializeStackIrpContext)</span>
00317 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfInitializeVcb)</span>
00318 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfLookupActiveIcb)</span>
00319 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfLookupActiveIcbInExtent)</span>
00320 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfLookupEa)</span>
00321 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfLookupFcbTable)</span>
00322 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfTeardownStructures)</span>
00323 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfUpdateTimestampsFromIcbContext)</span>
00324 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfUpdateVcbPhase0)</span>
00325 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfUpdateVcbPhase1)</span>
00326 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfVerifyDescriptor)</span>
00327 <span class="preprocessor"></span><span class="preprocessor">#endif ALLOC_PRAGMA</span>
00328 <span class="preprocessor"></span>
00329 
00330 BOOLEAN
<a name="l00331"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a203">00331</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a203">UdfInitializeVcb</a> (
00332     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00333     IN OUT <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb,
00334     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> TargetDeviceObject,
00335     IN <a class="code" href="../../d7/d7/struct__VPB.html">PVPB</a> Vpb,
00336     IN PDISK_GEOMETRY DiskGeometry,
00337     IN ULONG MediaChangeCount
00338     )
00339 
00340 <span class="comment">/*++</span>
00341 <span class="comment"></span>
00342 <span class="comment">Routine Description:</span>
00343 <span class="comment"></span>
00344 <span class="comment">    This routine initializes and inserts a new Vcb record into the in-memory</span>
00345 <span class="comment">    data structure.  The Vcb record "hangs" off the end of the Volume device</span>
00346 <span class="comment">    object and must be allocated by our caller.</span>
00347 <span class="comment"></span>
00348 <span class="comment">Arguments:</span>
00349 <span class="comment"></span>
00350 <span class="comment">    Vcb - Supplies the address of the Vcb record being initialized.</span>
00351 <span class="comment"></span>
00352 <span class="comment">    TargetDeviceObject - Supplies the address of the target device object to</span>
00353 <span class="comment">        associate with the Vcb record.</span>
00354 <span class="comment"></span>
00355 <span class="comment">    Vpb - Supplies the address of the Vpb to associate with the Vcb record.</span>
00356 <span class="comment"></span>
00357 <span class="comment">    MediaChangeCount - Initial media change count of the target device</span>
00358 <span class="comment"></span>
00359 <span class="comment">Return Value:</span>
00360 <span class="comment"></span>
00361 <span class="comment">    Boolean TRUE if the volume looks reasonable to continue mounting, FALSE</span>
00362 <span class="comment">    otherwise.  This routine can raise on allocation failure.</span>
00363 <span class="comment"></span>
00364 <span class="comment">--*/</span>
00365 
00366 {
00367     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00368 
00369     <span class="comment">//</span>
00370     <span class="comment">//  We start by first zeroing out all of the VCB, this will guarantee</span>
00371     <span class="comment">//  that any stale data is wiped clean.</span>
00372     <span class="comment">//</span>
00373 
00374     RtlZeroMemory( Vcb, <span class="keyword">sizeof</span>( <a class="code" href="../../d7/d5/struct__VCB.html">VCB</a> ));
00375 
00376     <span class="comment">//</span>
00377     <span class="comment">//  Set the proper node type code and node byte size.</span>
00378     <span class="comment">//</span>
00379 
00380     Vcb-&gt;NodeTypeCode = <a class="code" href="../../d1/d7/udfs_2nodetype_8h.html#a2">UDFS_NTC_VCB</a>;
00381     Vcb-&gt;NodeByteSize = <span class="keyword">sizeof</span>( <a class="code" href="../../d6/d8/udfstruc_8h.html#a73">VCB</a> );
00382 
00383     <span class="comment">//</span>
00384     <span class="comment">//  Initialize the DirNotify structures.  Do this first so there is</span>
00385     <span class="comment">//  no cleanup if it raises.  Nothing else below will fail with</span>
00386     <span class="comment">//  a raise.</span>
00387     <span class="comment">//</span>
00388 
00389     InitializeListHead( &amp;Vcb-&gt;DirNotifyList );
00390     <a class="code" href="../../d1/d8/fsrtl_8h.html#a169">FsRtlNotifyInitializeSync</a>( &amp;Vcb-&gt;NotifySync );
00391 
00392     <span class="comment">//</span>
00393     <span class="comment">//  Initialize the resource variable for the Vcb and files.</span>
00394     <span class="comment">//</span>
00395 
00396     <a class="code" href="../../d5/d8/ex_8h.html#a68">ExInitializeResource</a>( &amp;Vcb-&gt;VcbResource );
00397     <a class="code" href="../../d5/d8/ex_8h.html#a68">ExInitializeResource</a>( &amp;Vcb-&gt;FileResource );
00398     <a class="code" href="../../d5/d8/ex_8h.html#a8">ExInitializeFastMutex</a>( &amp;Vcb-&gt;VcbMutex );
00399 
00400     <span class="comment">//</span>
00401     <span class="comment">//  Insert this Vcb record on the UdfData.VcbQueue.</span>
00402     <span class="comment">//</span>
00403 
00404     InsertHeadList( &amp;<a class="code" href="../../d0/d8/udfdata_8c.html#a2">UdfData</a>.<a class="code" href="../../d2/d3/struct__UDF__DATA.html#o3">VcbQueue</a>, &amp;Vcb-&gt;VcbLinks );
00405 
00406     <span class="comment">//</span>
00407     <span class="comment">//  Set the Target Device Object and Vpb fields, referencing the</span>
00408     <span class="comment">//  target device.</span>
00409     <span class="comment">//</span>
00410 
00411     <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a>( TargetDeviceObject );
00412     Vcb-&gt;TargetDeviceObject = TargetDeviceObject;
00413     Vcb-&gt;Vpb = Vpb;
00414 
00415     <span class="comment">//</span>
00416     <span class="comment">//  Set the removable media flag based on the real device's</span>
00417     <span class="comment">//  characteristics</span>
00418     <span class="comment">//</span>
00419 
00420     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( Vpb-&gt;RealDevice-&gt;Characteristics, FILE_REMOVABLE_MEDIA )) {
00421 
00422         <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( Vcb-&gt;VcbState, <a class="code" href="../../d6/d8/udfstruc_8h.html#a6">VCB_STATE_REMOVABLE_MEDIA</a> );
00423     }
00424 
00425     <span class="comment">//</span>
00426     <span class="comment">//  Initialize the generic Fcb Table.</span>
00427     <span class="comment">//</span>
00428 
00429     <a class="code" href="../../d6/d1/gentable_8c.html#a3">RtlInitializeGenericTable</a>( &amp;Vcb-&gt;FcbTable,
00430                                (PRTL_GENERIC_COMPARE_ROUTINE) <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a21">UdfFcbTableCompare</a>,
00431                                (PRTL_GENERIC_ALLOCATE_ROUTINE) <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a17">UdfAllocateTable</a>,
00432                                (PRTL_GENERIC_FREE_ROUTINE) <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a20">UdfDeallocateTable</a>,
00433                                <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00434 
00435     <span class="comment">//</span>
00436     <span class="comment">//  Show that we have a mount in progress.</span>
00437     <span class="comment">//</span>
00438 
00439     Vcb-&gt;VcbCondition = <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a118">VcbMountInProgress</a>;
00440 
00441     <span class="comment">//</span>
00442     <span class="comment">//  Refererence the Vcb for two reasons.  The first is a reference</span>
00443     <span class="comment">//  that prevents the Vcb from going away on the last close unless</span>
00444     <span class="comment">//  dismount has already occurred.  The second is to make sure</span>
00445     <span class="comment">//  we don't go into the dismount path on any error during mount</span>
00446     <span class="comment">//  until we get to the Mount cleanup.</span>
00447     <span class="comment">//</span>
00448 
00449     Vcb-&gt;VcbResidualReference = <a class="code" href="../../d1/d8/udfdata_8h.html#a0">UDFS_BASE_RESIDUAL_REFERENCE</a>;
00450     Vcb-&gt;VcbResidualUserReference = <a class="code" href="../../d1/d8/udfdata_8h.html#a1">UDFS_BASE_RESIDUAL_USER_REFERENCE</a>;
00451 
00452     Vcb-&gt;VcbReference = 1 + Vcb-&gt;VcbResidualReference;
00453 
00454     <span class="comment">//</span>
00455     <span class="comment">//  Set the sector size.</span>
00456     <span class="comment">//</span>
00457 
00458     Vcb-&gt;SectorSize = DiskGeometry-&gt;BytesPerSector;
00459 
00460     <span class="comment">//</span>
00461     <span class="comment">//  Set the sector shift amount.</span>
00462     <span class="comment">//</span>
00463 
00464     Vcb-&gt;SectorShift = <a class="code" href="../../d3/d8/udfprocs_8h.html#a136">UdfHighBit</a>( DiskGeometry-&gt;BytesPerSector );
00465 
00466     <span class="comment">//</span>
00467     <span class="comment">//  Set the media change count on the device</span>
00468     <span class="comment">//</span>
00469 
00470     Vcb-&gt;MediaChangeCount = MediaChangeCount;
00471 
00472     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00473 }
00474 
00475 
00476 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00477"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a204">00477</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a204">UdfUpdateVcbPhase0</a> (
00478     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00479     IN OUT <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb
00480     )
00481 
00482 <span class="comment">/*++</span>
00483 <span class="comment"></span>
00484 <span class="comment">Routine Description:</span>
00485 <span class="comment"></span>
00486 <span class="comment">    This routine is called to perform the initial spinup of the volume so that</span>
00487 <span class="comment">    we can do reads into it.  Primarily, this is required since virtual partitions</span>
00488 <span class="comment">    make us lift the remapping table, and the final sets of descriptors from the volume</span>
00489 <span class="comment">    can be off in these virtual partitions.</span>
00490 <span class="comment">    </span>
00491 <span class="comment">    So, we need to get everything set up to read.</span>
00492 <span class="comment"></span>
00493 <span class="comment">Arguments:</span>
00494 <span class="comment"></span>
00495 <span class="comment">    Vcb - Vcb for the volume being mounted.  We have already set up and completed</span>
00496 <span class="comment">        the Pcb.</span>
00497 <span class="comment"></span>
00498 <span class="comment">Return Value:</span>
00499 <span class="comment"></span>
00500 <span class="comment">    None</span>
00501 <span class="comment"></span>
00502 <span class="comment">--*/</span>
00503 
00504 {
00505     <a class="code" href="../../d9/d9/struct__ICB__SEARCH__CONTEXT.html">ICB_SEARCH_CONTEXT</a> IcbContext;
00506 
00507     LONGLONG FileId = 0;
00508 
00509     <a class="code" href="../../d8/d0/structICBFILE.html">PICBFILE</a> VatIcb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00510     <a class="code" href="../../d6/d6/structREGID.html">PREGID</a> RegId;
00511     ULONG ThisPass;
00512     ULONG Psn;
00513     ULONG Vsn;
00514     ULONG Lbn;
00515     ULONG SectorCount;
00516     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> Reference;
00517 
00518     BOOLEAN UnlockVcb = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00519     BOOLEAN CleanupIcbContext = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00520 
00521     <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> Bcb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00522     LARGE_INTEGER <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
00523 
00524     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00525 
00526     <span class="comment">//</span>
00527     <span class="comment">//  Check input.</span>
00528     <span class="comment">//</span>
00529 
00530     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
00531     <a class="code" href="../../d1/d8/udfdata_8h.html#a12">ASSERT_VCB</a>( Vcb );
00532 
00533     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfUpdateVcbPhase0, Vcb %08x\n"</span>, Vcb ));
00534 
00535     <span class="keywordflow">try</span> {
00536         
00538         <span class="comment">//</span>
00539         <span class="comment">//  Create the Metadata Fcb and refererence it and the Vcb.</span>
00540         <span class="comment">//</span>
00542 <span class="comment"></span>
00543         <a class="code" href="../../d3/d8/udfprocs_8h.html#a88">UdfLockVcb</a>( IrpContext, Vcb );
00544         UnlockVcb = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00545 
00546         Vcb-&gt;MetadataFcb = <a class="code" href="../../d3/d8/udfprocs_8h.html#a213">UdfCreateFcb</a>( IrpContext,
00547                                          *((<a class="code" href="../../d6/d8/udfstruc_8h.html#a78">PFILE_ID</a>) &amp;FileId),
00548                                          <a class="code" href="../../d1/d7/udfs_2nodetype_8h.html#a3">UDFS_NTC_FCB_INDEX</a>,
00549                                          <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00550 
00551         <a class="code" href="../../d3/d8/udfprocs_8h.html#a98">UdfIncrementReferenceCounts</a>( IrpContext, Vcb-&gt;MetadataFcb, 1, 1 );
00552         <a class="code" href="../../d3/d8/udfprocs_8h.html#a89">UdfUnlockVcb</a>( IrpContext, Vcb );
00553         UnlockVcb = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00554 
00555         <span class="comment">//</span>
00556         <span class="comment">//  The metadata stream is grown lazily as we reference disk structures.</span>
00557         <span class="comment">//</span>
00558 
00559         Vcb-&gt;MetadataFcb-&gt;FileSize.QuadPart =
00560         Vcb-&gt;MetadataFcb-&gt;ValidDataLength.QuadPart = 
00561         Vcb-&gt;MetadataFcb-&gt;AllocationSize.QuadPart = 0;
00562 
00563         <span class="comment">//</span>
00564         <span class="comment">//  Initialize the volume Vmcb</span>
00565         <span class="comment">//</span>
00566 
00567         <a class="code" href="../../d3/d8/udfprocs_8h.html#a90">UdfLockFcb</a>( IrpContext, Vcb-&gt;MetadataFcb );
00568 
00569         <a class="code" href="../../d6/d6/vmcbsup_8c.html#a5">UdfInitializeVmcb</a>( &amp;Vcb-&gt;Vmcb,
00570                            <a class="code" href="../../d3/d8/udfprocs_8h.html#a65">UdfPagedPool</a>,
00571                            MAXULONG,
00572                            <a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a>(Vcb) );
00573 
00574         <a class="code" href="../../d3/d8/udfprocs_8h.html#a91">UdfUnlockFcb</a>( IrpContext, Vcb-&gt;MetadataFcb );
00575 
00576         <span class="comment">//</span>
00577         <span class="comment">//  Point to the file resource and set the flag that will cause mappings</span>
00578         <span class="comment">//  to go through the Vmcb</span>
00579         <span class="comment">//</span>
00580 
00581         Vcb-&gt;MetadataFcb-&gt;Resource = &amp;Vcb-&gt;FileResource;
00582 
00583         <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( Vcb-&gt;MetadataFcb-&gt;FcbState, <a class="code" href="../../d6/d8/udfstruc_8h.html#a15">FCB_STATE_VMCB_MAPPING</a> | <a class="code" href="../../d6/d8/udfstruc_8h.html#a13">FCB_STATE_INITIALIZED</a> );
00584 
00585         <span class="comment">//</span>
00586         <span class="comment">//  Create the stream file for this.</span>
00587         <span class="comment">//</span>
00588 
00589         <a class="code" href="../../d3/d8/udfprocs_8h.html#a154">UdfCreateInternalStream</a>( IrpContext, Vcb, Vcb-&gt;MetadataFcb );
00590 
00592         <span class="comment">//</span>
00593         <span class="comment">//  If this is a volume containing a virtual partition, set up the</span>
00594         <span class="comment">//  Virtual Allocation Table Fcb and adjust the residual reference</span>
00595         <span class="comment">//  counts comensurately.</span>
00596         <span class="comment">//</span>
00598 <span class="comment"></span>
00599         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( Vcb-&gt;Pcb-&gt;Flags, <a class="code" href="../../d6/d8/udfstruc_8h.html#a2">PCB_FLAG_VIRTUAL_PARTITION</a> )) {
00600 
00601             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfUpdateVcbPhase0, handling VAT setup\n"</span> ));
00602 
00603             <span class="comment">//</span>
00604             <span class="comment">//  Now if some dummy has stuck us in the situation of not giving us</span>
00605             <span class="comment">//  the tools to figure out where the end of the media is, tough luck.</span>
00606             <span class="comment">//</span>
00607 
00608             <span class="keywordflow">if</span> (!Vcb-&gt;BoundN || Vcb-&gt;BoundN &lt; <a class="code" href="../../d0/d7/iso13346_8h.html#a63">ANCHOR_SECTOR</a>) {
00609 
00610                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfUpdateVcbPhase0, no end bound was discoverable!\n"</span> ));
00611 
00612                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, STATUS_UNRECOGNIZED_VOLUME );
00613             }
00614 
00615             <span class="comment">//</span>
00616             <span class="comment">//  We take care of this first since the residuals must be in place</span>
00617             <span class="comment">//  if we raise while finding the VAT, else we will get horribly</span>
00618             <span class="comment">//  confused when the in-progress references are seen.  We will think</span>
00619             <span class="comment">//  that the extra real referenes are indications that the volume can't</span>
00620             <span class="comment">//  be dismounted.</span>
00621             <span class="comment">//</span>
00622             
00623             Vcb-&gt;VcbResidualReference += <a class="code" href="../../d1/d8/udfdata_8h.html#a2">UDFS_CDUDF_RESIDUAL_REFERENCE</a>;
00624             Vcb-&gt;VcbResidualUserReference += <a class="code" href="../../d1/d8/udfdata_8h.html#a3">UDFS_CDUDF_RESIDUAL_USER_REFERENCE</a>;
00625 
00626             Vcb-&gt;VcbReference += <a class="code" href="../../d1/d8/udfdata_8h.html#a2">UDFS_CDUDF_RESIDUAL_REFERENCE</a>;
00627 
00628             <span class="comment">//</span>
00629             <span class="comment">//  Now, we need to hunt about for the VAT ICB.  This is defined, on</span>
00630             <span class="comment">//  closed media (meaning that the sessions have been finalized for use</span>
00631             <span class="comment">//  in CDROM drives), to be in the very last information sector on the</span>
00632             <span class="comment">//  media.  Complicating this simple picture is that CDROMs tell us the</span>
00633             <span class="comment">//  "last sector" by telling us where the start of the leadout area is,</span>
00634             <span class="comment">//  not where the end of the informational sectors are.  This is an</span>
00635             <span class="comment">//  important distinction because any combination of the following can</span>
00636             <span class="comment">//  be used in closing a CDROM session: 2 runout sectors, and/or 150</span>
00637             <span class="comment">//  sectors (2 seconds) of postgap, or nothing.  Immediately after these</span>
00638             <span class="comment">//  "closing" writes is where the leadout begins.</span>
00639             <span class="comment">//</span>
00640             <span class="comment">//  Runout is usually found on CD-E media and corresponds to the time it</span>
00641             <span class="comment">//  will take to turn the writing laser off.  Postgap is what is used to</span>
00642             <span class="comment">//  generate audio pauses.  It is easy to see that the kind of media and</span>
00643             <span class="comment">//  kind of mastering tool/system used will affect us here.  There is no</span>
00644             <span class="comment">//  way to know either ahead of time.</span>
00645             <span class="comment">//</span>
00646             <span class="comment">//  So, finally, these are the offsets from our previously discovered</span>
00647             <span class="comment">//  bounding information where we might find the last information sector:</span>
00648             <span class="comment">//</span>
00649             <span class="comment">//          -152    runout + postgap</span>
00650             <span class="comment">//          -150    postgap</span>
00651             <span class="comment">//          -2      runout</span>
00652             <span class="comment">//          0       nothing</span>
00653             <span class="comment">//</span>
00654             <span class="comment">//  We must search these from low to high since it is extrememly expensive</span>
00655             <span class="comment">//  to guess wrong - CDROMs will sit there for tens of seconds trying to</span>
00656             <span class="comment">//  read unwritten/unreadable sectors.  Hopefully we will find the VAT</span>
00657             <span class="comment">//  ICB beforehand.</span>
00658             <span class="comment">//</span>
00659             <span class="comment">//  This should all be highly disturbing.</span>
00660             <span class="comment">//</span>
00661 
00662             VatIcb = <a class="code" href="../../d1/d8/fsrtl_8h.html#a37">FsRtlAllocatePoolWithTag</a>( <a class="code" href="../../d3/d8/udfprocs_8h.html#a65">UdfPagedPool</a>,
00663                                                <a class="code" href="../../d3/d8/udfprocs_8h.html#a163">UdfRawBufferSize</a>( Vcb, <a class="code" href="../../d3/d8/udfprocs_8h.html#a54">BlockSize</a>( Vcb )),
00664                                                <a class="code" href="../../d1/d7/udfs_2nodetype_8h.html#a88">TAG_NSR_VDSD</a>);
00665 
00666             <span class="keywordflow">for</span> (ThisPass = 0; ThisPass &lt; 4; ThisPass++) {
00667 
00668                 <span class="comment">//</span>
00669                 <span class="comment">//  Lift the appropriate sector.  The discerning reader will be confused that</span>
00670                 <span class="comment">//  this is done in sector terms, not block.  So is the implementor.</span>
00671                 <span class="comment">//</span>
00672                 
00673                 Psn = Vcb-&gt;BoundN - ( ThisPass == 0? 152 :
00674                                     ( ThisPass == 1? 150 :
00675                                     ( ThisPass == 2? 2 : 0 )));
00676 
00677                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfUpdateVcbPhase0, looking at Psn 0x%08x\n"</span>, Psn ));
00678 
00679                 <span class="comment">//</span>
00680                 <span class="comment">//  Now, try to figure out what physical partition this sector lives in so</span>
00681                 <span class="comment">//  that we can eventually establish workable metadata mappings to it and</span>
00682                 <span class="comment">//  dereference short allocation descriptors it may use.</span>
00683                 <span class="comment">//</span>
00684 
00685                 <span class="keywordflow">for</span> (Reference = 0;
00686                      Reference &lt; Vcb-&gt;Pcb-&gt;Partitions;
00687                      Reference++) {
00688     
00689                     <span class="keywordflow">if</span> (Vcb-&gt;Pcb-&gt;Partition[Reference].Type == <a class="code" href="../../d6/d8/udfstruc_8h.html#a129a115">Physical</a> &amp;&amp;
00690                         Vcb-&gt;Pcb-&gt;Partition[Reference].Physical.Start &lt;= Psn &amp;&amp;
00691                         Vcb-&gt;Pcb-&gt;Partition[Reference].Physical.Start +
00692                         Vcb-&gt;Pcb-&gt;Partition[Reference].Physical.Length &gt; Psn) {
00693     
00694                         <span class="keywordflow">break</span>;
00695                     }
00696                 }
00697                 
00698                 <span class="comment">//</span>
00699                 <span class="comment">//  If this sector is not contained in a partition, we do not</span>
00700                 <span class="comment">//  need to look at it.</span>
00701                 <span class="comment">//</span>
00702                 
00703                 <span class="keywordflow">if</span> (Reference == Vcb-&gt;Pcb-&gt;Partitions) {
00704                     
00705                     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfUpdateVcbPhase0, ... but it isn't in a partition.\n"</span> ));
00706 
00707                     <span class="keywordflow">continue</span>;
00708                 }
00709                 
00710                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfUpdateVcbPhase0, ... in partition Ref %u.\n"</span>,  Reference ));
00711 
00712                 <span class="comment">//</span>
00713                 <span class="comment">//  We must locate the Lbn of this Psn by figuring out the offset of it</span>
00714                 <span class="comment">//  in the partition we already know that it is recorded in.</span>
00715                 <span class="comment">//</span>
00716                 
00717                 Lbn = <a class="code" href="../../d3/d8/udfprocs_8h.html#a53">BlocksFromSectors</a>( Vcb, Psn - Vcb-&gt;Pcb-&gt;Partition[Reference].Physical.Start );
00718 
00719                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d3/d8/udfprocs_8h.html#a160">UdfReadSectors</a>( IrpContext,
00720                                                  <a class="code" href="../../d3/d8/udfprocs_8h.html#a39">LlBytesFromSectors</a>( Vcb, Psn ),
00721                                                  <a class="code" href="../../d3/d8/udfprocs_8h.html#a164">UdfRawReadSize</a>( Vcb, <a class="code" href="../../d3/d8/udfprocs_8h.html#a54">BlockSize</a>( Vcb )),
00722                                                  <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00723                                                  VatIcb,
00724                                                  Vcb-&gt;TargetDeviceObject ))) {
00725                     
00726                     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfUpdateVcbPhase0, ... but couldn't read it.\n"</span> ));
00727 
00728                     <span class="keywordflow">continue</span>;
00729                 }
00730 
00731                 <span class="comment">//</span>
00732                 <span class="comment">//  First make sure this looks vageuly like a file entry.</span>
00733                 <span class="comment">//</span>
00734                 
00735                 <span class="keywordflow">if</span> (!<a class="code" href="../../d3/d8/udfprocs_8h.html#a219">UdfVerifyDescriptor</a>( IrpContext,
00736                                           (<a class="code" href="../../d7/d7/structDESTAG.html">PDESTAG</a>) VatIcb,
00737                                           <a class="code" href="../../d0/d7/iso13346_8h.html#a54">DESTAG_ID_NSR_FILE</a>,
00738                                           <a class="code" href="../../d3/d8/udfprocs_8h.html#a54">BlockSize</a>( Vcb ),
00739                                           Lbn,
00740                                           <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> )) {
00741                     
00742                     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfUpdateVcbPhase0, ... but it didn't verify.\n"</span> ));
00743 
00744                     <span class="keywordflow">continue</span>;
00745                 }
00746 
00747                 <span class="comment">//</span>
00748                 <span class="comment">//  Make sure this is a NOTSPEC object.  We can also presume that a VAT isn't</span>
00749                 <span class="comment">//  linked into any directory, so it would be surprising if the link count was</span>
00750                 <span class="comment">//  nonzero.</span>
00751                 <span class="comment">//</span>
00752 
00753                 <span class="keywordflow">if</span> (VatIcb-&gt;Icbtag.FileType != <a class="code" href="../../d0/d7/iso13346_8h.html#a98">ICBTAG_FILE_T_NOTSPEC</a> ||
00754                     VatIcb-&gt;LinkCount) {
00755 
00756                     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfUpdateVcbPhase0, ... but the type/linkcount is wrong.\n"</span> ));
00757 
00758                     <span class="keywordflow">continue</span>;
00759                 }
00760 
00761                 <span class="comment">//</span>
00762                 <span class="comment">//  The VAT must be at least large enough to contain the required information and</span>
00763                 <span class="comment">//  be a multiple of 4byte elements in length.  We also have defined a sanity upper</span>
00764                 <span class="comment">//  bound beyond which we never expect to see a VAT go.</span>
00765                 <span class="comment">//</span>
00766 
00767                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( !<a class="code" href="../../d3/d8/udfprocs_8h.html#a24">LongOffset</a>( <a class="code" href="../../d9/d7/udf_8h.html#a57">UDF_CDUDF_MINIMUM_VAT_SIZE</a> ));
00768             
00769                 <span class="keywordflow">if</span> (VatIcb-&gt;InfoLength &lt; <a class="code" href="../../d9/d7/udf_8h.html#a57">UDF_CDUDF_MINIMUM_VAT_SIZE</a> ||
00770                     VatIcb-&gt;InfoLength &gt; <a class="code" href="../../d9/d7/udf_8h.html#a58">UDF_CDUDF_MAXIMUM_VAT_SIZE</a> ||
00771                     <a class="code" href="../../d3/d8/udfprocs_8h.html#a24">LongOffset</a>( VatIcb-&gt;InfoLength )) {
00772                 
00773                     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfUpdateVcbPhase0, ... but the size looks pretty bogus.\n"</span> ));
00774 
00775                     <span class="keywordflow">continue</span>;
00776                 }
00777 
00778                 <span class="comment">//</span>
00779                 <span class="comment">//  At this point we have to take a wild guess that this will be the guy.  Since the only</span>
00780                 <span class="comment">//  way to be sure is to look at the very end of the file an look for the regid, we've got</span>
00781                 <span class="comment">//  to go map this thing.</span>
00782                 <span class="comment">//</span>
00783             
00784                 <span class="comment">//</span>
00785                 <span class="comment">//  This is pretty ugly, but we have to cobble this maybe-Icb into the metadata stream</span>
00786                 <span class="comment">//  so that initialization/use is possible (embedded data!).  Normally regular Icb searches</span>
00787                 <span class="comment">//  would have done this for us, but since we have to go through such an amusing search</span>
00788                 <span class="comment">//  procedure that isn't possible.  So, add it as a single sector mapping.</span>
00789                 <span class="comment">//</span>
00790                 <span class="comment">//  Since this lives in a partition, we can just do the "lookup" in the metadata stream.</span>
00791                 <span class="comment">//  If we did not have this guarantee, we'd need to do a bit more of this by hand.</span>
00792                 <span class="comment">//</span>
00793                 <span class="comment">//  As this is at mount time, we are very sure we are the only person messing with the</span>
00794                 <span class="comment">//  metadata stream.</span>
00795                 <span class="comment">//</span>
00796     
00797                 <span class="comment">//</span>
00798                 <span class="comment">//  Zap the previous mapping and invalidate the metadata and VAT stream content.</span>
00799                 <span class="comment">//</span>
00800                 
00801                 <span class="keywordflow">if</span> (Vcb-&gt;VatFcb) {
00802                 
00803                     <a class="code" href="../../d6/d6/vmcbsup_8c.html#a7">UdfResetVmcb</a>( &amp;Vcb-&gt;Vmcb );
00804 
00805                     <a class="code" href="../../d3/d8/udfprocs_8h.html#a69">UdfUnpinData</a>( IrpContext, &amp;Bcb );
00806 
00807                     <a class="code" href="../../d4/d2/cache_8h.html#a61">CcPurgeCacheSection</a>( Vcb-&gt;MetadataFcb-&gt;FileObject-&gt;SectionObjectPointer,
00808                                          <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00809                                          0,
00810                                          <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00811                     
00812                     <a class="code" href="../../d4/d2/cache_8h.html#a61">CcPurgeCacheSection</a>( Vcb-&gt;VatFcb-&gt;FileObject-&gt;SectionObjectPointer,
00813                                          <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00814                                          0,
00815                                          <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00816                 }
00817 
00818                 Vsn = <a class="code" href="../../d3/d8/udfprocs_8h.html#a153">UdfLookupMetaVsnOfExtent</a>( IrpContext,
00819                                                 Vcb,
00820                                                 Reference,
00821                                                 Lbn,
00822                                                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a54">BlockSize</a>( Vcb ),
00823                                                 <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00824                 
00825                 <span class="keywordflow">if</span> (Vcb-&gt;VatFcb == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00826                     
00827                     <span class="comment">//</span>
00828                     <span class="comment">//  Now stamp out the Fcb.</span>
00829                     <span class="comment">//</span>
00830         
00831                     <a class="code" href="../../d3/d8/udfprocs_8h.html#a88">UdfLockVcb</a>( IrpContext, Vcb );
00832                     UnlockVcb = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00833         
00834                     Vcb-&gt;VatFcb = <a class="code" href="../../d3/d8/udfprocs_8h.html#a213">UdfCreateFcb</a>( IrpContext,
00835                                                 *((<a class="code" href="../../d6/d8/udfstruc_8h.html#a78">PFILE_ID</a>) &amp;FileId),
00836                                                 <a class="code" href="../../d1/d7/udfs_2nodetype_8h.html#a3">UDFS_NTC_FCB_INDEX</a>,
00837                                                 <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00838         
00839                     <a class="code" href="../../d3/d8/udfprocs_8h.html#a98">UdfIncrementReferenceCounts</a>( IrpContext, Vcb-&gt;VatFcb, 1, 1 );
00840                     <a class="code" href="../../d3/d8/udfprocs_8h.html#a89">UdfUnlockVcb</a>( IrpContext, Vcb );
00841                     UnlockVcb = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00842                                         
00843                     <span class="comment">//</span>
00844                     <span class="comment">//  Point to the file resource and set the flag that will cause mappings</span>
00845                     <span class="comment">//  to go through the Vmcb</span>
00846                     <span class="comment">//</span>
00847     
00848                     Vcb-&gt;VatFcb-&gt;Resource = &amp;Vcb-&gt;FileResource;
00849                 }
00850                 
00851                 <span class="comment">//</span>
00852                 <span class="comment">//  Now size and try to pick up all of the allocation descriptors for this guy.</span>
00853                 <span class="comment">//  We're going to need to conjure an IcbContext for this.</span>
00854                 <span class="comment">//</span>
00855     
00856                 Vcb-&gt;VatFcb-&gt;AllocationSize.QuadPart = <a class="code" href="../../d3/d8/udfprocs_8h.html#a34">LlSectorAlign</a>( Vcb, VatIcb-&gt;InfoLength );
00857             
00858                 Vcb-&gt;VatFcb-&gt;FileSize.QuadPart =
00859                 Vcb-&gt;VatFcb-&gt;ValidDataLength.QuadPart = VatIcb-&gt;InfoLength;
00860 
00861                 <span class="comment">//</span>
00862                 <span class="comment">//  Clean out any previous failed attempts.</span>
00863                 <span class="comment">//</span>
00864                 
00865                 <span class="keywordflow">if</span> (CleanupIcbContext) {
00866 
00867                     <a class="code" href="../../d3/d8/udfprocs_8h.html#a224">UdfCleanupIcbContext</a>( IrpContext, &amp;IcbContext );
00868                 
00869                 } <span class="keywordflow">else</span> {
00870 
00871                     RtlZeroMemory( &amp;IcbContext, <span class="keyword">sizeof</span>( <a class="code" href="../../d9/d9/struct__ICB__SEARCH__CONTEXT.html">ICB_SEARCH_CONTEXT</a> ));
00872                 }
00873 
00874                 <span class="comment">//</span>
00875                 <span class="comment">//  Now construct the ICB search context we would have had</span>
00876                 <span class="comment">//  made in the process of normal ICB discovery.  Since we</span>
00877                 <span class="comment">//  were unable to do that, gotta do it by hand.</span>
00878                 <span class="comment">//</span>
00879                 
00880                 IcbContext.<a class="code" href="../../d9/d9/struct__ICB__SEARCH__CONTEXT.html#o2">Active</a>.<a class="code" href="../../d6/d6/struct__MAPPED__PVIEW.html#o0">View</a> = (PVOID) VatIcb;
00881                 IcbContext.<a class="code" href="../../d9/d9/struct__ICB__SEARCH__CONTEXT.html#o2">Active</a>.<a class="code" href="../../d6/d6/struct__MAPPED__PVIEW.html#o2">Partition</a> = Reference;
00882                 IcbContext.<a class="code" href="../../d9/d9/struct__ICB__SEARCH__CONTEXT.html#o2">Active</a>.<a class="code" href="../../d6/d6/struct__MAPPED__PVIEW.html#o3">Lbn</a> = Lbn;
00883                 CleanupIcbContext = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00884     
00885                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a225">UdfInitializeAllocations</a>( IrpContext,
00886                                           Vcb-&gt;VatFcb,
00887                                           &amp;IcbContext );
00888     
00889                 <span class="comment">//</span>
00890                 <span class="comment">//  Create or resize the stream file for the VAT as appropriate.</span>
00891                 <span class="comment">//</span>
00892 
00893                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( Vcb-&gt;VatFcb-&gt;FcbState, <a class="code" href="../../d6/d8/udfstruc_8h.html#a13">FCB_STATE_INITIALIZED</a> )) {
00894                 
00895                     <a class="code" href="../../d3/d8/udfprocs_8h.html#a154">UdfCreateInternalStream</a>( IrpContext, Vcb, Vcb-&gt;VatFcb );
00896                     <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( Vcb-&gt;VatFcb-&gt;FcbState, <a class="code" href="../../d6/d8/udfstruc_8h.html#a13">FCB_STATE_INITIALIZED</a> );
00897     
00898                 } <span class="keywordflow">else</span> {
00899 
00900                     <a class="code" href="../../d4/d2/cache_8h.html#a60">CcSetFileSizes</a>( Vcb-&gt;VatFcb-&gt;FileObject, (<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html">PCC_FILE_SIZES</a>) &amp;Vcb-&gt;VatFcb-&gt;AllocationSize );
00901                 }
00902 
00903                 <span class="comment">//</span>
00904                 <span class="comment">//  To complete VAT discovery, we now look for the regid at the end of the stream</span>
00905                 <span class="comment">//  that will definitively tell us that this is really a VAT.  Bias from the back</span>
00906                 <span class="comment">//  by the previous VAT pointer and the regid itself.  We already know the stream</span>
00907                 <span class="comment">//  is big enough by virtue of our preliminary sanity checks.</span>
00908                 <span class="comment">//</span>
00909 
00910                 <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.QuadPart = Vcb-&gt;VatFcb-&gt;FileSize.QuadPart - <a class="code" href="../../d9/d7/udf_8h.html#a56">UDF_CDUDF_TRAILING_DATA_SIZE</a>;
00911 
00912                 <a class="code" href="../../d4/d2/cache_8h.html#a88">CcMapData</a>( Vcb-&gt;VatFcb-&gt;FileObject,
00913                            &amp;<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>,
00914                            <span class="keyword">sizeof</span>(<a class="code" href="../../d6/d6/structREGID.html">REGID</a>),
00915                            <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00916                            &amp;Bcb,
00917                            &amp;RegId );
00918 
00919                 <span class="keywordflow">if</span> (!<a class="code" href="../../d3/d8/udfprocs_8h.html#a231">UdfUdfIdentifierContained</a>( RegId,
00920                                                 &amp;<a class="code" href="../../d0/d8/udfdata_8c.html#a14">UdfVatTableIdentifier</a>,
00921                                                 <a class="code" href="../../d9/d7/udf_8h.html#a3">UDF_VERSION_150</a>,
00922                                                 <a class="code" href="../../d9/d7/udf_8h.html#a4">UDF_VERSION_RECOGNIZED</a>,
00923                                                 <a class="code" href="../../d9/d7/udf_8h.html#a33">OSCLASS_INVALID</a>,
00924                                                 <a class="code" href="../../d9/d7/udf_8h.html#a34">OSIDENTIFIER_INVALID</a> )) {
00925 
00926                     <span class="comment">//</span>
00927                     <span class="comment">//  Oh well, no go here.</span>
00928                     <span class="comment">//</span>
00929 
00930                     <span class="keywordflow">continue</span>;
00931                 }
00932 
00933                 <span class="comment">//</span>
00934                 <span class="comment">//  Got it!</span>
00935                 <span class="comment">//</span>
00936 
00937                 <span class="keywordflow">break</span>;
00938             }
00939 
00940             <span class="comment">//</span>
00941             <span class="comment">//  If we didn't find anything ...</span>
00942             <span class="comment">//</span>
00943             
00944             <span class="keywordflow">if</span> (ThisPass == 4) {
00945 
00946                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfUpdateVcbPhase0, ... and so we didn't find a VAT!\n"</span> ));
00947 
00948                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, STATUS_DISK_CORRUPT_ERROR );
00949             }
00950 
00951             <span class="comment">//</span>
00952             <span class="comment">//  Go find the virtual reference so we can further update the Pcb</span>
00953             <span class="comment">//  with information from the VAT.</span>
00954             <span class="comment">//</span>
00955 
00956             <span class="keywordflow">for</span> (Reference = 0;
00957                  Reference &lt; Vcb-&gt;Pcb-&gt;Partitions;
00958                  Reference++) {
00959 
00960                 <span class="keywordflow">if</span> (Vcb-&gt;Pcb-&gt;Partition[Reference].Type == <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a2">Virtual</a>) {
00961 
00962                     <span class="keywordflow">break</span>;
00963                 }
00964             }
00965 
00966             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( Reference &lt; Vcb-&gt;Pcb-&gt;Partitions );
00967 
00968             <span class="comment">//</span>
00969             <span class="comment">//  We note the length so we can easily do bounds checking for</span>
00970             <span class="comment">//  virtual mappings.</span>
00971             <span class="comment">//</span>
00972             
00973             <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.QuadPart = (Vcb-&gt;VatFcb-&gt;FileSize.QuadPart -
00974                                <a class="code" href="../../d9/d7/udf_8h.html#a56">UDF_CDUDF_TRAILING_DATA_SIZE</a>) / <span class="keyword">sizeof</span>(ULONG);
00975 
00976             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.HighPart == 0 );
00977             Vcb-&gt;Pcb-&gt;Partition[Reference].Virtual.Length = <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.LowPart;
00978 
00979             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfUpdateVcbPhase0, ... got it!\n"</span> ));
00980         }
00981 
00982     } finally {
00983 
00984         <a class="code" href="../../d8/d3/lfsdata_8h.html#a3">DebugUnwind</a>( <span class="stringliteral">"UdfUpdateVcbPhase0"</span> );
00985 
00986         <a class="code" href="../../d3/d8/udfprocs_8h.html#a69">UdfUnpinData</a>( IrpContext, &amp;Bcb );
00987         <span class="keywordflow">if</span> (CleanupIcbContext) { <a class="code" href="../../d3/d8/udfprocs_8h.html#a224">UdfCleanupIcbContext</a>( IrpContext, &amp;IcbContext ); }
00988         <span class="keywordflow">if</span> (UnlockVcb) { <a class="code" href="../../d3/d8/udfprocs_8h.html#a89">UdfUnlockVcb</a>( IrpContext, Vcb ); }
00989         <span class="keywordflow">if</span> (VatIcb) { <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( VatIcb ); }
00990     }
00991 
00992     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfUpdateVcbPhase0 -&gt; VOID\n"</span> ));
00993 }
00994 
00995 
00996 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00997"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a205">00997</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a205">UdfUpdateVcbPhase1</a> (
00998     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00999     IN OUT <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb,
01000     IN <a class="code" href="../../d2/d2/structNSR__FSD.html">PNSR_FSD</a> Fsd
01001     )
01002 
01003 <span class="comment">/*++</span>
01004 <span class="comment"></span>
01005 <span class="comment">Routine Description:</span>
01006 <span class="comment"></span>
01007 <span class="comment">    This routine is called to perform the final initialization of a Vcb and Vpb</span>
01008 <span class="comment">    from the volume descriptors on the disk.</span>
01009 <span class="comment"></span>
01010 <span class="comment">Arguments:</span>
01011 <span class="comment"></span>
01012 <span class="comment">    Vcb - Vcb for the volume being mounted.  We have already done phase 0.</span>
01013 <span class="comment"></span>
01014 <span class="comment">    Fsd - The fileset descriptor for this volume.</span>
01015 <span class="comment">    </span>
01016 <span class="comment">Return Value:</span>
01017 <span class="comment"></span>
01018 <span class="comment">    None</span>
01019 <span class="comment"></span>
01020 <span class="comment">--*/</span>
01021 
01022 {
01023     <a class="code" href="../../d9/d9/struct__ICB__SEARCH__CONTEXT.html">ICB_SEARCH_CONTEXT</a> IcbContext;
01024 
01025     LONGLONG FileId = 0;
01026 
01027     <a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a> Fcb;
01028 
01029     BOOLEAN UnlockVcb = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01030     BOOLEAN UnlockFcb = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01031     BOOLEAN CleanupIcbContext = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01032 
01033     ULONG Reference;
01034 
01035     ULONG BoundSector = 0;
01036 
01037     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01038 
01039     <span class="comment">//</span>
01040     <span class="comment">//  Check input.</span>
01041     <span class="comment">//</span>
01042 
01043     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
01044     <a class="code" href="../../d1/d8/udfdata_8h.html#a12">ASSERT_VCB</a>( Vcb );
01045 
01046     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfUpdateVcbPhase1, Vcb %08x Fsd %08x\n"</span>, Vcb, Fsd ));
01047 
01048     <span class="comment">//</span>
01049     <span class="comment">//  Use a try-finally to facilitate cleanup.</span>
01050     <span class="comment">//</span>
01051 
01052     <span class="keywordflow">try</span> {
01053 
01054         <span class="comment">//</span>
01055         <span class="comment">//  Do the final internal Fcb's and other Vcb fields.</span>
01056         <span class="comment">//</span>
01057 
01059         <span class="comment">//</span>
01060         <span class="comment">//  Create the root index and reference it in the Vcb.</span>
01061         <span class="comment">//</span>
01063 <span class="comment"></span>
01064         <a class="code" href="../../d3/d8/udfprocs_8h.html#a88">UdfLockVcb</a>( IrpContext, Vcb );
01065         UnlockVcb = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01066         
01067         Vcb-&gt;RootIndexFcb = <a class="code" href="../../d3/d8/udfprocs_8h.html#a213">UdfCreateFcb</a>( IrpContext,
01068                                           *((<a class="code" href="../../d6/d8/udfstruc_8h.html#a78">PFILE_ID</a>) &amp;FileId),
01069                                           <a class="code" href="../../d1/d7/udfs_2nodetype_8h.html#a3">UDFS_NTC_FCB_INDEX</a>,
01070                                           <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01071 
01072         <a class="code" href="../../d3/d8/udfprocs_8h.html#a98">UdfIncrementReferenceCounts</a>( IrpContext, Vcb-&gt;RootIndexFcb, 1, 1 );
01073         <a class="code" href="../../d3/d8/udfprocs_8h.html#a89">UdfUnlockVcb</a>( IrpContext, Vcb );
01074         UnlockVcb = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01075 
01076         <span class="comment">//</span>
01077         <span class="comment">//  Create the File id by hand for this Fcb.</span>
01078         <span class="comment">//</span>
01079 
01080         <a class="code" href="../../d6/d8/udfstruc_8h.html#a44">UdfSetFidFromLbAddr</a>( Vcb-&gt;RootIndexFcb-&gt;FileId, Fsd-&gt;IcbRoot.Start );
01081         <a class="code" href="../../d6/d8/udfstruc_8h.html#a49">UdfSetFidDirectory</a>( Vcb-&gt;RootIndexFcb-&gt;FileId );
01082         Vcb-&gt;RootIndexFcb-&gt;RootExtentLength = Fsd-&gt;IcbRoot.Length.Length;
01083 
01084         <span class="comment">//</span>
01085         <span class="comment">//  Get the direct entry for the root directory and initialize</span>
01086         <span class="comment">//  the Fcb from it.</span>
01087         <span class="comment">//</span>
01088 
01089         <a class="code" href="../../d3/d8/udfprocs_8h.html#a220">UdfInitializeIcbContextFromFcb</a>( IrpContext,
01090                                         &amp;IcbContext,
01091                                         Vcb-&gt;RootIndexFcb );
01092         CleanupIcbContext = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01093 
01094         <a class="code" href="../../d3/d8/udfprocs_8h.html#a223">UdfLookupActiveIcb</a>( IrpContext, &amp;IcbContext );
01095 
01096         <a class="code" href="../../d3/d8/udfprocs_8h.html#a215">UdfInitializeFcbFromIcbContext</a>( IrpContext,
01097                                         Vcb-&gt;RootIndexFcb,
01098                                         &amp;IcbContext );
01099 
01100         <a class="code" href="../../d3/d8/udfprocs_8h.html#a224">UdfCleanupIcbContext</a>( IrpContext, &amp;IcbContext );
01101         CleanupIcbContext = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01102 
01103         <span class="comment">//</span>
01104         <span class="comment">//  Create the stream file for the root directory.</span>
01105         <span class="comment">//</span>
01106 
01107         <a class="code" href="../../d3/d8/udfprocs_8h.html#a154">UdfCreateInternalStream</a>( IrpContext, Vcb, Vcb-&gt;RootIndexFcb );
01108 
01110         <span class="comment">//</span>
01111         <span class="comment">//  Now do the volume dasd Fcb.  Create this and reference it in the</span>
01112         <span class="comment">//  Vcb.</span>
01113         <span class="comment">//</span>
01115 <span class="comment"></span>
01116         <a class="code" href="../../d3/d8/udfprocs_8h.html#a88">UdfLockVcb</a>( IrpContext, Vcb );
01117         UnlockVcb = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01118 
01119         Vcb-&gt;VolumeDasdFcb = <a class="code" href="../../d3/d8/udfprocs_8h.html#a213">UdfCreateFcb</a>( IrpContext,
01120                                            *((<a class="code" href="../../d6/d8/udfstruc_8h.html#a78">PFILE_ID</a>) &amp;FileId),
01121                                            <a class="code" href="../../d1/d7/udfs_2nodetype_8h.html#a4">UDFS_NTC_FCB_DATA</a>,
01122                                            <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01123 
01124         <a class="code" href="../../d3/d8/udfprocs_8h.html#a98">UdfIncrementReferenceCounts</a>( IrpContext, Vcb-&gt;VolumeDasdFcb, 1, 1 );
01125         <a class="code" href="../../d3/d8/udfprocs_8h.html#a89">UdfUnlockVcb</a>( IrpContext, Vcb );
01126         UnlockVcb = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01127 
01128         Fcb = Vcb-&gt;VolumeDasdFcb;
01129         <a class="code" href="../../d3/d8/udfprocs_8h.html#a90">UdfLockFcb</a>( IrpContext, Fcb );
01130         UnlockFcb = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01131 
01132         <span class="comment">//</span>
01133         <span class="comment">//  If we were unable to determine a last sector on the media, walk the Pcb and guess</span>
01134         <span class="comment">//  that it is probably OK to think of the last sector of the last partition as The</span>
01135         <span class="comment">//  Last Sector.  Note that we couldn't do this before since the notion of a last</span>
01136         <span class="comment">//  sector has significance at mount time, if it had been possible to find one.</span>
01137         <span class="comment">//</span>
01138 
01139         <span class="keywordflow">for</span> ( Reference = 0;
01140               Reference &lt; Vcb-&gt;Pcb-&gt;Partitions;
01141               Reference++ ) {
01142 
01143             <span class="keywordflow">if</span> (Vcb-&gt;Pcb-&gt;Partition[Reference].Type == <a class="code" href="../../d6/d8/udfstruc_8h.html#a129a115">Physical</a> &amp;&amp;
01144                 Vcb-&gt;Pcb-&gt;Partition[Reference].Physical.Start +
01145                 Vcb-&gt;Pcb-&gt;Partition[Reference].Physical.Length &gt; BoundSector) {
01146 
01147                 BoundSector = Vcb-&gt;Pcb-&gt;Partition[Reference].Physical.Start +
01148                               Vcb-&gt;Pcb-&gt;Partition[Reference].Physical.Length;
01149             }
01150         }
01151 
01152         <span class="comment">//</span>
01153         <span class="comment">//  Note that we cannot restrict the bound by the "physical" bound discovered</span>
01154         <span class="comment">//  eariler.  This is because the MSF format of the TOC request we send is only</span>
01155         <span class="comment">//  capable of representing about 2.3gb, and a lot of media we will be on that</span>
01156         <span class="comment">//  responds to TOCs will be quite a bit larger - ex: DVD.</span>
01157         <span class="comment">//</span>
01158         <span class="comment">//  This, of course, barring proper means of discovering media bounding, prohibits</span>
01159         <span class="comment">//  the possibility of having UDF virtual partitions on DVD-R.</span>
01160         <span class="comment">//</span>
01161 
01162         <span class="comment">//</span>
01163         <span class="comment">//  Build the mapping from [0, Bound).  We have to initialize the Mcb by hand since</span>
01164         <span class="comment">//  this is usually left to when we lift retrieval information from an Icb in</span>
01165         <span class="comment">//  UdfInitializeAllocations.</span>
01166         <span class="comment">//</span>
01167 
01168         <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a15">UdfInitializeFcbMcb</a>( Fcb );
01169 
01170         <a class="code" href="../../d1/d8/fsrtl_8h.html#a143">FsRtlAddLargeMcbEntry</a>( &amp;Fcb-&gt;<a class="code" href="../../d7/d9/struct__FCB.html#o14">Mcb</a>,
01171                                (LONGLONG) 0,
01172                                (LONGLONG) 0,
01173                                (LONGLONG) BoundSector );
01174                                
01175         Fcb-&gt;FileSize.QuadPart += <a class="code" href="../../d3/d8/udfprocs_8h.html#a39">LlBytesFromSectors</a>( Vcb, BoundSector );
01176 
01177         Fcb-&gt;AllocationSize.QuadPart =
01178         Fcb-&gt;ValidDataLength.QuadPart = Fcb-&gt;FileSize.QuadPart;
01179 
01180         <a class="code" href="../../d3/d8/udfprocs_8h.html#a91">UdfUnlockFcb</a>( IrpContext, Fcb );
01181         UnlockFcb = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01182 
01183         <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( Fcb-&gt;<a class="code" href="../../d7/d9/struct__FCB.html#o10">FcbState</a>, <a class="code" href="../../d6/d8/udfstruc_8h.html#a13">FCB_STATE_INITIALIZED</a> );
01184 
01185         <span class="comment">//</span>
01186         <span class="comment">//  Point to the file resource.</span>
01187         <span class="comment">//</span>
01188 
01189         Vcb-&gt;VolumeDasdFcb-&gt;Resource = &amp;Vcb-&gt;FileResource;
01190 
01191         Vcb-&gt;VolumeDasdFcb-&gt;FileAttributes = FILE_ATTRIBUTE_READONLY;
01192 
01193     } finally {
01194 
01195         <a class="code" href="../../d8/d3/lfsdata_8h.html#a3">DebugUnwind</a>( <span class="stringliteral">"UdfUpdateVcbPhase1"</span> );
01196 
01197         <span class="keywordflow">if</span> (CleanupIcbContext) { <a class="code" href="../../d3/d8/udfprocs_8h.html#a224">UdfCleanupIcbContext</a>( IrpContext, &amp;IcbContext ); }
01198 
01199         <span class="keywordflow">if</span> (UnlockFcb) { <a class="code" href="../../d3/d8/udfprocs_8h.html#a91">UdfUnlockFcb</a>( IrpContext, Fcb ); }
01200         <span class="keywordflow">if</span> (UnlockVcb) { <a class="code" href="../../d3/d8/udfprocs_8h.html#a89">UdfUnlockVcb</a>( IrpContext, Vcb ); }
01201     }
01202 
01203     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfUpdateVcbPhase1 -&gt; VOID\n"</span> ));
01204 
01205     <span class="keywordflow">return</span>;
01206 }
01207 
01208 
01209 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01210"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a206">01210</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a206">UdfDeleteVcb</a> (
01211     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01212     IN OUT <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb
01213     )
01214 
01215 <span class="comment">/*++</span>
01216 <span class="comment"></span>
01217 <span class="comment">Routine Description:</span>
01218 <span class="comment"></span>
01219 <span class="comment">    This routine is called to delete a Vcb which failed mount or has been</span>
01220 <span class="comment">    dismounted.  The dismount code should have already removed all of the</span>
01221 <span class="comment">    open Fcb's.  We do nothing here but clean up other auxilary structures.</span>
01222 <span class="comment"></span>
01223 <span class="comment">Arguments:</span>
01224 <span class="comment"></span>
01225 <span class="comment">    Vcb - Vcb to delete.</span>
01226 <span class="comment"></span>
01227 <span class="comment">Return Value:</span>
01228 <span class="comment"></span>
01229 <span class="comment">    None</span>
01230 <span class="comment"></span>
01231 <span class="comment">--*/</span>
01232 
01233 {
01234     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01235 
01236     <a class="code" href="../../d1/d8/udfdata_8h.html#a39">ASSERT_EXCLUSIVE_UDFDATA</a>;
01237     <a class="code" href="../../d1/d8/udfdata_8h.html#a40">ASSERT_EXCLUSIVE_VCB</a>( Vcb );
01238 
01239     <span class="comment">//</span>
01240     <span class="comment">//  If there is a Vpb then we must delete it ourselves.</span>
01241     <span class="comment">//</span>
01242 
01243     <span class="keywordflow">if</span> (Vcb-&gt;Vpb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01244 
01245         <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>( &amp;Vcb-&gt;Vpb );
01246     }
01247 
01248     <span class="comment">//</span>
01249     <span class="comment">//  Drop the Pcb.</span>
01250     <span class="comment">//</span>
01251 
01252     <span class="keywordflow">if</span> (Vcb-&gt;Pcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01253 
01254         <a class="code" href="../../d3/d8/udfprocs_8h.html#a147">UdfDeletePcb</a>( Vcb-&gt;Pcb );
01255     }
01256 
01257     <span class="comment">//</span>
01258     <span class="comment">//  Dereference our target if we haven't already done so.</span>
01259     <span class="comment">//</span>
01260 
01261     <span class="keywordflow">if</span> (Vcb-&gt;TargetDeviceObject != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01262         
01263         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( Vcb-&gt;TargetDeviceObject );
01264     }
01265     
01266     <span class="comment">//</span>
01267     <span class="comment">//  Remove this entry from the global queue.</span>
01268     <span class="comment">//</span>
01269 
01270     RemoveEntryList( &amp;Vcb-&gt;VcbLinks );
01271 
01272     <span class="comment">//</span>
01273     <span class="comment">//  Delete the Vcb and File resources.</span>
01274     <span class="comment">//</span>
01275 
01276     <a class="code" href="../../d5/d8/ex_8h.html#a73">ExDeleteResource</a>( &amp;Vcb-&gt;VcbResource );
01277     <a class="code" href="../../d5/d8/ex_8h.html#a73">ExDeleteResource</a>( &amp;Vcb-&gt;FileResource );
01278 
01279     <span class="comment">//</span>
01280     <span class="comment">//  Uninitialize the notify structures.</span>
01281     <span class="comment">//</span>
01282 
01283     <span class="keywordflow">if</span> (Vcb-&gt;NotifySync != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01284 
01285         <a class="code" href="../../d1/d8/fsrtl_8h.html#a170">FsRtlNotifyUninitializeSync</a>( &amp;Vcb-&gt;NotifySync );
01286     }
01287 
01288     <span class="comment">//</span>
01289     <span class="comment">//  Now delete the volume device object.</span>
01290     <span class="comment">//</span>
01291 
01292     <a class="code" href="../../d4/d6/iosubs_8c.html#a55">IoDeleteDevice</a>( (<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>) CONTAINING_RECORD( Vcb,
01293                                                         <a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html">VOLUME_DEVICE_OBJECT</a>,
01294                                                         Vcb ));
01295 
01296     <span class="keywordflow">return</span>;
01297 }
01298 
01299 
01300 <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a>
<a name="l01301"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a207">01301</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a207">UdfCreateIrpContext</a> (
01302     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
01303     IN BOOLEAN Wait
01304     )
01305 
01306 <span class="comment">/*++</span>
01307 <span class="comment"></span>
01308 <span class="comment">Routine Description:</span>
01309 <span class="comment"></span>
01310 <span class="comment">    This routine is called to initialize an IrpContext for the current</span>
01311 <span class="comment">    UDFS request.  We allocate the structure and then initialize it from</span>
01312 <span class="comment">    the given Irp.</span>
01313 <span class="comment"></span>
01314 <span class="comment">Arguments:</span>
01315 <span class="comment"></span>
01316 <span class="comment">    Irp - Irp for this request.</span>
01317 <span class="comment"></span>
01318 <span class="comment">    Wait - TRUE if this request is synchronous, FALSE otherwise.</span>
01319 <span class="comment"></span>
01320 <span class="comment">Return Value:</span>
01321 <span class="comment"></span>
01322 <span class="comment">    PIRP_CONTEXT - Allocated IrpContext.</span>
01323 <span class="comment"></span>
01324 <span class="comment">--*/</span>
01325 
01326 {
01327     <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> NewIrpContext = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01328     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> IrpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
01329     BOOLEAN IsFsDo = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01330     ULONG <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>;
01331 
01332     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01333 
01334     <span class="keywordflow">for</span> (<a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> = 0; <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> &lt; <a class="code" href="../../d6/d8/udfstruc_8h.html#a0">NUMBER_OF_FS_OBJECTS</a>; <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>++) {
01335     
01336         <span class="keywordflow">if</span> (IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o57">DeviceObject</a> == <a class="code" href="../../d0/d8/udfdata_8c.html#a2">UdfData</a>.<a class="code" href="../../d2/d3/struct__UDF__DATA.html#o7">FileSystemDeviceObjects</a>[<a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>]) {
01337 
01338             IsFsDo = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01339             <span class="keywordflow">break</span>;
01340         }
01341     }
01342 
01343     <span class="comment">//</span>
01344     <span class="comment">//  The only operations a filesystem device object should ever receive</span>
01345     <span class="comment">//  are create/teardown of fsdo handles and operations which do not</span>
01346     <span class="comment">//  occur in the context of fileobjects (i.e., mount).</span>
01347     <span class="comment">//</span>
01348 
01349     <span class="keywordflow">if</span> (IsFsDo) {
01350 
01351         <span class="keywordflow">if</span> (IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> &amp;&amp;
01352             IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> != <a class="code" href="../../d0/d5/io_8h.html#a13">IRP_MJ_CREATE</a> &amp;&amp;
01353             IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> != <a class="code" href="../../d0/d5/io_8h.html#a31">IRP_MJ_CLEANUP</a> &amp;&amp;
01354             IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> != <a class="code" href="../../d0/d5/io_8h.html#a15">IRP_MJ_CLOSE</a>) {
01355 
01356             <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INVALID_DEVICE_REQUEST );
01357         }
01358 
01359         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ||
01360                 
01361                 (IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> == <a class="code" href="../../d0/d5/io_8h.html#a26">IRP_MJ_FILE_SYSTEM_CONTROL</a> &amp;&amp;
01362                  IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o1">MinorFunction</a> == <a class="code" href="../../d0/d5/io_8h.html#a46">IRP_MN_USER_FS_REQUEST</a> &amp;&amp;
01363                  IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.FileSystemControl.FsControlCode == FSCTL_INVALIDATE_VOLUMES) ||
01364                 
01365                 (IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> == <a class="code" href="../../d0/d5/io_8h.html#a26">IRP_MJ_FILE_SYSTEM_CONTROL</a> &amp;&amp;
01366                  IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o1">MinorFunction</a> == <a class="code" href="../../d0/d5/io_8h.html#a47">IRP_MN_MOUNT_VOLUME</a> ) ||
01367 
01368                 IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> == <a class="code" href="../../d0/d5/io_8h.html#a29">IRP_MJ_SHUTDOWN</a> );
01369     }
01370     
01371     NewIrpContext = <a class="code" href="../../d5/d8/ex_8h.html#a248">ExAllocateFromNPagedLookasideList</a>( &amp;<a class="code" href="../../d0/d8/udfdata_8c.html#a24">UdfIrpContextLookasideList</a> );
01372 
01373     RtlZeroMemory( NewIrpContext, <span class="keyword">sizeof</span>( <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">IRP_CONTEXT</a> ));
01374 
01375     <span class="comment">//</span>
01376     <span class="comment">//  Set the proper node type code and node byte size</span>
01377     <span class="comment">//</span>
01378 
01379     NewIrpContext-&gt;<a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html#o0">NodeTypeCode</a> = <a class="code" href="../../d1/d7/udfs_2nodetype_8h.html#a7">UDFS_NTC_IRP_CONTEXT</a>;
01380     NewIrpContext-&gt;<a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html#o1">NodeByteSize</a> = <span class="keyword">sizeof</span>( <a class="code" href="../../d6/d8/udfstruc_8h.html#a92">IRP_CONTEXT</a> );
01381 
01382     <span class="comment">//</span>
01383     <span class="comment">//  Set the originating Irp field</span>
01384     <span class="comment">//</span>
01385 
01386     NewIrpContext-&gt;<a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html#o2">Irp</a> = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>;
01387 
01388     <span class="comment">//</span>
01389     <span class="comment">//  Copy RealDevice for workque algorithms.  We will update this in the Mount or</span>
01390     <span class="comment">//  Verify since they have no file objects to use here.</span>
01391     <span class="comment">//</span>
01392 
01393     <span class="keywordflow">if</span> (IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01394 
01395         NewIrpContext-&gt;<a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html#o6">RealDevice</a> = IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a>-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o2">DeviceObject</a>;
01396     }
01397 
01398     <span class="comment">//</span>
01399     <span class="comment">//  This may be one of our filesystem device objects.  In that case don't</span>
01400     <span class="comment">//  initialize the Vcb field.</span>
01401     <span class="comment">//</span>
01402 
01403     <span class="keywordflow">if</span> (!IsFsDo) {
01404         
01405         NewIrpContext-&gt;<a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html#o3">Vcb</a> = &amp;((<a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html">PVOLUME_DEVICE_OBJECT</a>) IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o57">DeviceObject</a>)-&gt;Vcb;
01406     }
01407 
01408     <span class="comment">//</span>
01409     <span class="comment">//  Major/Minor Function codes</span>
01410     <span class="comment">//</span>
01411 
01412     NewIrpContext-&gt;<a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html#o10">MajorFunction</a> = IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a>;
01413     NewIrpContext-&gt;<a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html#o11">MinorFunction</a> = IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o1">MinorFunction</a>;
01414 
01415     <span class="comment">//</span>
01416     <span class="comment">//  Set the wait parameter</span>
01417     <span class="comment">//</span>
01418 
01419     <span class="keywordflow">if</span> (Wait) {
01420 
01421         <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( NewIrpContext-&gt;<a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html#o5">Flags</a>, <a class="code" href="../../d6/d8/udfstruc_8h.html#a30">IRP_CONTEXT_FLAG_WAIT</a> );
01422 
01423     } <span class="keywordflow">else</span> {
01424 
01425         <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( NewIrpContext-&gt;<a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html#o5">Flags</a>, <a class="code" href="../../d6/d8/udfstruc_8h.html#a31">IRP_CONTEXT_FLAG_FORCE_POST</a> );
01426     }
01427 
01428     <span class="comment">//</span>
01429     <span class="comment">//  return and tell the caller</span>
01430     <span class="comment">//</span>
01431 
01432     <span class="keywordflow">return</span> NewIrpContext;
01433 }
01434 
01435 
01436 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01437"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a208">01437</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a208">UdfCleanupIrpContext</a> (
01438     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01439     IN BOOLEAN Post
01440     )
01441 
01442 <span class="comment">/*++</span>
01443 <span class="comment"></span>
01444 <span class="comment">Routine Description:</span>
01445 <span class="comment"></span>
01446 <span class="comment">    This routine is called to cleanup and possibly deallocate the Irp Context.</span>
01447 <span class="comment">    If the request is being posted or this Irp Context is possibly on the</span>
01448 <span class="comment">    stack then we only cleanup any auxilary structures.</span>
01449 <span class="comment"></span>
01450 <span class="comment">Arguments:</span>
01451 <span class="comment"></span>
01452 <span class="comment">    Post - TRUE if we are posting this request, FALSE if we are deleting</span>
01453 <span class="comment">        or retrying this in the current thread.</span>
01454 <span class="comment"></span>
01455 <span class="comment">Return Value:</span>
01456 <span class="comment"></span>
01457 <span class="comment">    None.</span>
01458 <span class="comment"></span>
01459 <span class="comment">--*/</span>
01460 
01461 {
01462     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01463 
01464     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
01465 
01466     <span class="comment">//</span>
01467     <span class="comment">//  If we aren't doing more processing then deallocate this as appropriate.</span>
01468     <span class="comment">//</span>
01469 
01470     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( IrpContext-&gt;Flags, <a class="code" href="../../d6/d8/udfstruc_8h.html#a29">IRP_CONTEXT_FLAG_MORE_PROCESSING</a>)) {
01471 
01472         <span class="comment">//</span>
01473         <span class="comment">//  If this context is the top level UDFS context then we need to</span>
01474         <span class="comment">//  restore the top level thread context.</span>
01475         <span class="comment">//</span>
01476 
01477         <span class="keywordflow">if</span> (IrpContext-&gt;ThreadContext != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01478 
01479             <a class="code" href="../../d3/d8/udfprocs_8h.html#a131">UdfRestoreThreadContext</a>( IrpContext );
01480         }
01481         
01482         <span class="comment">//</span>
01483         <span class="comment">//  Deallocate the Io context if allocated.</span>
01484         <span class="comment">//</span>
01485 
01486         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( IrpContext-&gt;Flags, <a class="code" href="../../d6/d8/udfstruc_8h.html#a36">IRP_CONTEXT_FLAG_ALLOC_IO</a> )) {
01487 
01488             <a class="code" href="../../d3/d8/udfprocs_8h.html#a95">UdfFreeIoContext</a>( IrpContext-&gt;IoContext );
01489         }
01490         
01491         <span class="comment">//</span>
01492         <span class="comment">//  Deallocate the IrpContext if not from the stack.</span>
01493         <span class="comment">//</span>
01494 
01495         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( IrpContext-&gt;Flags, <a class="code" href="../../d6/d8/udfstruc_8h.html#a28">IRP_CONTEXT_FLAG_ON_STACK</a> )) {
01496 
01497             <a class="code" href="../../d5/d8/ex_8h.html#a249">ExFreeToNPagedLookasideList</a>( &amp;<a class="code" href="../../d0/d8/udfdata_8c.html#a24">UdfIrpContextLookasideList</a>, IrpContext );
01498         }
01499 
01500     <span class="comment">//</span>
01501     <span class="comment">//  Clear the appropriate flags.</span>
01502     <span class="comment">//</span>
01503 
01504     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Post) {
01505 
01506         <span class="comment">//</span>
01507         <span class="comment">//  If this context is the top level UDFS context then we need to</span>
01508         <span class="comment">//  restore the top level thread context.</span>
01509         <span class="comment">//</span>
01510 
01511         <span class="keywordflow">if</span> (IrpContext-&gt;ThreadContext != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01512 
01513             <a class="code" href="../../d3/d8/udfprocs_8h.html#a131">UdfRestoreThreadContext</a>( IrpContext );
01514         }
01515 
01516         <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>( IrpContext-&gt;Flags, <a class="code" href="../../d6/d8/udfstruc_8h.html#a40">IRP_CONTEXT_FLAGS_CLEAR_ON_POST</a> );
01517 
01518     } <span class="keywordflow">else</span> {
01519 
01520         <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>( IrpContext-&gt;Flags, <a class="code" href="../../d6/d8/udfstruc_8h.html#a41">IRP_CONTEXT_FLAGS_CLEAR_ON_RETRY</a> );
01521     }
01522 
01523     <span class="keywordflow">return</span>;
01524 }
01525 
01526 
01527 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01528"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a209">01528</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a209">UdfInitializeStackIrpContext</a> (
01529     OUT <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01530     IN <a class="code" href="../../d2/d3/struct__IRP__CONTEXT__LITE.html">PIRP_CONTEXT_LITE</a> IrpContextLite
01531     )
01532 
01533 <span class="comment">/*++</span>
01534 <span class="comment"></span>
01535 <span class="comment">Routine Description:</span>
01536 <span class="comment"></span>
01537 <span class="comment">    This routine is called to initialize an IrpContext for the current</span>
01538 <span class="comment">    UDFS request.  The IrpContext is on the stack and we need to initialize</span>
01539 <span class="comment">    it for the current request.  The request is a close operation.</span>
01540 <span class="comment"></span>
01541 <span class="comment">Arguments:</span>
01542 <span class="comment"></span>
01543 <span class="comment">    IrpContext - IrpContext to initialize.</span>
01544 <span class="comment"></span>
01545 <span class="comment">    IrpContextLite - Structure containing the details of this request.</span>
01546 <span class="comment"></span>
01547 <span class="comment">Return Value:</span>
01548 <span class="comment"></span>
01549 <span class="comment">    None</span>
01550 <span class="comment"></span>
01551 <span class="comment">--*/</span>
01552 
01553 {
01554     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01555 
01556     <a class="code" href="../../d1/d8/udfdata_8h.html#a30">ASSERT_IRP_CONTEXT_LITE</a>( IrpContextLite );
01557 
01558     <span class="comment">//</span>
01559     <span class="comment">//  Zero and then initialize the structure.</span>
01560     <span class="comment">//</span>
01561 
01562     RtlZeroMemory( IrpContext, <span class="keyword">sizeof</span>( <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">IRP_CONTEXT</a> ));
01563 
01564     <span class="comment">//</span>
01565     <span class="comment">//  Set the proper node type code and node byte size</span>
01566     <span class="comment">//</span>
01567 
01568     IrpContext-&gt;NodeTypeCode = <a class="code" href="../../d1/d7/udfs_2nodetype_8h.html#a7">UDFS_NTC_IRP_CONTEXT</a>;
01569     IrpContext-&gt;NodeByteSize = <span class="keyword">sizeof</span>( <a class="code" href="../../d6/d8/udfstruc_8h.html#a92">IRP_CONTEXT</a> );
01570 
01571     <span class="comment">//</span>
01572     <span class="comment">//  Note that this is from the stack.</span>
01573     <span class="comment">//</span>
01574 
01575     <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( IrpContext-&gt;Flags, <a class="code" href="../../d6/d8/udfstruc_8h.html#a28">IRP_CONTEXT_FLAG_ON_STACK</a> );
01576 
01577     <span class="comment">//</span>
01578     <span class="comment">//  Copy RealDevice for workque algorithms.</span>
01579     <span class="comment">//</span>
01580 
01581     IrpContext-&gt;RealDevice = IrpContextLite-&gt;RealDevice;
01582 
01583     <span class="comment">//</span>
01584     <span class="comment">//  The Vcb is found in the Fcb.</span>
01585     <span class="comment">//</span>
01586 
01587     IrpContext-&gt;Vcb = IrpContextLite-&gt;Fcb-&gt;Vcb;
01588 
01589     <span class="comment">//</span>
01590     <span class="comment">//  Major/Minor Function codes</span>
01591     <span class="comment">//</span>
01592 
01593     IrpContext-&gt;MajorFunction = <a class="code" href="../../d0/d5/io_8h.html#a15">IRP_MJ_CLOSE</a>;
01594 
01595     <span class="comment">//</span>
01596     <span class="comment">//  Set the wait parameter</span>
01597     <span class="comment">//</span>
01598 
01599     <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( IrpContext-&gt;Flags, <a class="code" href="../../d6/d8/udfstruc_8h.html#a30">IRP_CONTEXT_FLAG_WAIT</a> );
01600 
01601     <span class="keywordflow">return</span>;
01602 }
01603 
01604 
01605 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01606"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a210">01606</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a210">UdfTeardownStructures</a> (
01607     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01608     IN <a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a> StartingFcb,
01609     IN BOOLEAN Recursive,
01610     OUT PBOOLEAN RemovedStartingFcb
01611     )
01612 
01613 <span class="comment">/*++</span>
01614 <span class="comment"></span>
01615 <span class="comment">Routine Description:</span>
01616 <span class="comment"></span>
01617 <span class="comment">    This routine is used to walk from some starting point in the Fcb tree towards</span>
01618 <span class="comment">    the root.  It will remove the Fcb and continue walking up the tree until</span>
01619 <span class="comment">    it finds a point where we can't remove an Fcb.</span>
01620 <span class="comment"></span>
01621 <span class="comment">    We look at the following fields in the Fcb to determine whether we can</span>
01622 <span class="comment">    remove this.</span>
01623 <span class="comment"></span>
01624 <span class="comment">        1 - Handle count must be zero.</span>
01625 <span class="comment">        2 - If directory then only the only reference can be for a stream file.</span>
01626 <span class="comment">        3 - Reference count must either be zero or go to zero here.</span>
01627 <span class="comment"></span>
01628 <span class="comment">    We return immediately if we are recursively entering this routine.</span>
01629 <span class="comment"></span>
01630 <span class="comment">Arguments:</span>
01631 <span class="comment"></span>
01632 <span class="comment">    StartingFcb - This is the Fcb node in the tree to begin with.  This Fcb</span>
01633 <span class="comment">        must currently be acquired exclusively.</span>
01634 <span class="comment">        </span>
01635 <span class="comment">    Recursive - Indicates if this call is an intentional recursion.</span>
01636 <span class="comment"></span>
01637 <span class="comment">    RemovedStartingFcb - Address to store whether we removed the starting Fcb.</span>
01638 <span class="comment"></span>
01639 <span class="comment">Return Value:</span>
01640 <span class="comment"></span>
01641 <span class="comment">    None</span>
01642 <span class="comment"></span>
01643 <span class="comment">--*/</span>
01644 
01645 {
01646     <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb = StartingFcb-&gt;Vcb;
01647     <a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a> CurrentFcb = StartingFcb;
01648     BOOLEAN AcquiredCurrentFcb = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01649     <a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a> ParentFcb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01650     <a class="code" href="../../d5/d9/struct__LCB.html">PLCB</a> Lcb;
01651 
01652     PLIST_ENTRY ListLinks;
01653     BOOLEAN Abort = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01654     BOOLEAN Removed;
01655     
01656     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01657 
01658     <span class="comment">//</span>
01659     <span class="comment">//  Check input.</span>
01660     <span class="comment">//</span>
01661 
01662     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
01663     <a class="code" href="../../d1/d8/udfdata_8h.html#a14">ASSERT_FCB</a>( StartingFcb );
01664 
01665     *RemovedStartingFcb = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01666 
01667     <span class="comment">//</span>
01668     <span class="comment">//  If this is not an intentionally recursive call we need to check if this</span>
01669     <span class="comment">//  is a layered close and we're already in another instance of teardown.</span>
01670     <span class="comment">//</span>
01671 
01672     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
01673                  <span class="stringliteral">"UdfTeardownStructures, StartingFcb %08x %s\n"</span>,
01674                  StartingFcb,
01675                  ( Recursive? <span class="stringliteral">"Recursive"</span> : <span class="stringliteral">"Flat"</span> )));
01676     
01677     <span class="keywordflow">if</span> (!Recursive) {
01678     
01679         <span class="comment">//</span>
01680         <span class="comment">//  If this is a recursive call to TearDownStructures we return immediately</span>
01681         <span class="comment">//  doing no operation.</span>
01682         <span class="comment">//</span>
01683 
01684         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( IrpContext-&gt;TopLevel-&gt;Flags, <a class="code" href="../../d6/d8/udfstruc_8h.html#a35">IRP_CONTEXT_FLAG_IN_TEARDOWN</a> )) {
01685 
01686             <span class="keywordflow">return</span>;
01687         }
01688 
01689         <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( IrpContext-&gt;TopLevel-&gt;Flags, <a class="code" href="../../d6/d8/udfstruc_8h.html#a35">IRP_CONTEXT_FLAG_IN_TEARDOWN</a> );
01690     }
01691 
01692     <span class="comment">//</span>
01693     <span class="comment">//  Use a try-finally to safely clear the top-level field.</span>
01694     <span class="comment">//</span>
01695 
01696     <span class="keywordflow">try</span> {
01697 
01698         <span class="comment">//</span>
01699         <span class="comment">//  Loop until we find an Fcb we can't remove.</span>
01700         <span class="comment">//</span>
01701 
01702         <span class="keywordflow">do</span> {
01703 
01704             <span class="comment">//</span>
01705             <span class="comment">//  See if there is an internal stream we should delete.</span>
01706             <span class="comment">//  Only do this if it is the last reference on the Fcb.</span>
01707             <span class="comment">//</span>
01708 
01709             <span class="keywordflow">if</span> ((<a class="code" href="../../d1/d7/udfs_2nodetype_8h.html#a12">SafeNodeType</a>( CurrentFcb ) != <a class="code" href="../../d1/d7/udfs_2nodetype_8h.html#a4">UDFS_NTC_FCB_DATA</a>) &amp;&amp;
01710                 (CurrentFcb-&gt;<a class="code" href="../../d7/d9/struct__FCB.html#o9">FcbUserReference</a> == 0) &amp;&amp;
01711                 (CurrentFcb-&gt;FileObject != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
01712 
01713                 <span class="comment">//</span>
01714                 <span class="comment">//  Go ahead and delete the stream file object.</span>
01715                 <span class="comment">//</span>
01716 
01717                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a155">UdfDeleteInternalStream</a>( IrpContext, CurrentFcb );
01718             }
01719 
01720             <span class="comment">//</span>
01721             <span class="comment">//  If the reference count is non-zero then break.</span>
01722             <span class="comment">//</span>
01723 
01724             <span class="keywordflow">if</span> (CurrentFcb-&gt;<a class="code" href="../../d7/d9/struct__FCB.html#o8">FcbReference</a> != 0) {
01725 
01726                 <span class="keywordflow">break</span>;
01727             }
01728 
01729             <span class="comment">//</span>
01730             <span class="comment">//  It looks like we have a candidate for removal here.  We</span>
01731             <span class="comment">//  will need to walk the list of prefixes and delete them</span>
01732             <span class="comment">//  from their parents.  If it turns out that we have multiple</span>
01733             <span class="comment">//  parents of this Fcb, we are going to recursively teardown</span>
01734             <span class="comment">//  on each of these.</span>
01735             <span class="comment">//</span>
01736 
01737             <span class="keywordflow">for</span> ( ListLinks = CurrentFcb-&gt;<a class="code" href="../../d7/d9/struct__FCB.html#o3">ParentLcbQueue</a>.Flink;
01738                   ListLinks != &amp;CurrentFcb-&gt;<a class="code" href="../../d7/d9/struct__FCB.html#o3">ParentLcbQueue</a>; ) {
01739 
01740                 Lcb = CONTAINING_RECORD( ListLinks, <a class="code" href="../../d5/d9/struct__LCB.html">LCB</a>, ChildFcbLinks );
01741 
01742                 <a class="code" href="../../d1/d8/udfdata_8h.html#a26">ASSERT_LCB</a>( Lcb );
01743 
01744                 <span class="comment">//</span>
01745                 <span class="comment">//  We advance the pointer now because we will be toasting this guy,</span>
01746                 <span class="comment">//  invalidating whatever is here.</span>
01747                 <span class="comment">//</span>
01748 
01749                 ListLinks = ListLinks-&gt;Flink;
01750 
01751                 <span class="comment">//</span>
01752                 <span class="comment">//  We may have multiple parents through hard links.  If the previous parent we</span>
01753                 <span class="comment">//  dealt with is not the parent of this new Lcb, lets do some work.</span>
01754                 <span class="comment">//</span>
01755                 
01756                 <span class="keywordflow">if</span> (ParentFcb != Lcb-&gt;<a class="code" href="../../d5/d9/struct__LCB.html#o9">ParentFcb</a>) {
01757 
01758                     <span class="comment">//</span>
01759                     <span class="comment">//  We need to deal with the previous parent.  It may now be the case that</span>
01760                     <span class="comment">//  we deleted the last child reference and it wants to go away at this point.</span>
01761                     <span class="comment">//</span>
01762                     
01763                     <span class="keywordflow">if</span> (ParentFcb) {
01764 
01765                         <span class="comment">//</span>
01766                         <span class="comment">//  It should never be the case that we have to recurse more than one level on</span>
01767                         <span class="comment">//  any teardown since no cross-linkage of directories is possible.</span>
01768                         <span class="comment">//</span>
01769                     
01770                         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( !Recursive );
01771                           
01772                         <a class="code" href="../../d3/d8/udfprocs_8h.html#a210">UdfTeardownStructures</a>( IrpContext, ParentFcb, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, &amp;Removed );
01773 
01774                         <span class="keywordflow">if</span> (!Removed) {
01775 
01776                             <a class="code" href="../../d3/d8/udfprocs_8h.html#a85">UdfReleaseFcb</a>( IrpContext, ParentFcb );
01777                         }
01778                     }
01779 
01780                     <span class="comment">//</span>
01781                     <span class="comment">//  Get this new parent Fcb to work on.</span>
01782                     <span class="comment">//</span>
01783                     
01784                     ParentFcb = Lcb-&gt;<a class="code" href="../../d5/d9/struct__LCB.html#o9">ParentFcb</a>;
01785                     <a class="code" href="../../d3/d8/udfprocs_8h.html#a83">UdfAcquireFcbExclusive</a>( IrpContext, ParentFcb, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01786                 }
01787                 
01788                 <span class="comment">//</span>
01789                 <span class="comment">//  Lock the Vcb so we can look at references.</span>
01790                 <span class="comment">//</span>
01791 
01792                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a88">UdfLockVcb</a>( IrpContext, Vcb );
01793 
01794                 <span class="comment">//</span>
01795                 <span class="comment">//  Now check that the reference counts on the Lcb are zero.</span>
01796                 <span class="comment">//</span>
01797 
01798                 <span class="keywordflow">if</span> ( Lcb-&gt;<a class="code" href="../../d5/d9/struct__LCB.html#o12">Reference</a> != 0 ) {
01799 
01800                     <span class="comment">//</span>
01801                     <span class="comment">//  A create is interested in getting in here, so we should</span>
01802                     <span class="comment">//  stop right now.</span>
01803                     <span class="comment">//</span>
01804 
01805                     <a class="code" href="../../d3/d8/udfprocs_8h.html#a89">UdfUnlockVcb</a>( IrpContext, Vcb );
01806                     <a class="code" href="../../d3/d8/udfprocs_8h.html#a85">UdfReleaseFcb</a>( IrpContext, ParentFcb );
01807                     Abort = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01808 
01809                     <span class="keywordflow">break</span>;
01810                 }
01811 
01812                 <span class="comment">//</span>
01813                 <span class="comment">//  Now remove this prefix and drop the references to the parent.</span>
01814                 <span class="comment">//</span>
01815 
01816                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( Lcb-&gt;<a class="code" href="../../d5/d9/struct__LCB.html#o11">ChildFcb</a> == CurrentFcb );
01817                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( Lcb-&gt;<a class="code" href="../../d5/d9/struct__LCB.html#o9">ParentFcb</a> == ParentFcb );
01818                 
01819                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
01820                              <span class="stringliteral">"UdfTeardownStructures, Lcb %08x P %08x &lt;-&gt; C %08x Vcb %d/%d PFcb %d/%d CFcb %d/%d\n"</span>,
01821                              Lcb,
01822                              ParentFcb,
01823                              CurrentFcb,
01824                              Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o16">VcbReference</a>,
01825                              Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o17">VcbUserReference</a>,
01826                              ParentFcb-&gt;<a class="code" href="../../d7/d9/struct__FCB.html#o8">FcbReference</a>,
01827                              ParentFcb-&gt;<a class="code" href="../../d7/d9/struct__FCB.html#o9">FcbUserReference</a>,
01828                              CurrentFcb-&gt;<a class="code" href="../../d7/d9/struct__FCB.html#o8">FcbReference</a>,
01829                              CurrentFcb-&gt;<a class="code" href="../../d7/d9/struct__FCB.html#o9">FcbUserReference</a> ));
01830 
01831                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a195">UdfRemovePrefix</a>( IrpContext, Lcb );
01832                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a99">UdfDecrementReferenceCounts</a>( IrpContext, ParentFcb, 1, 1 );
01833 
01834                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
01835                              <span class="stringliteral">"UdfTeardownStructures, Vcb %d/%d PFcb %d/%d\n"</span>,
01836                              Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o16">VcbReference</a>,
01837                              Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o17">VcbUserReference</a>,
01838                              ParentFcb-&gt;<a class="code" href="../../d7/d9/struct__FCB.html#o8">FcbReference</a>,
01839                              ParentFcb-&gt;<a class="code" href="../../d7/d9/struct__FCB.html#o9">FcbUserReference</a> ));
01840 
01841                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a89">UdfUnlockVcb</a>( IrpContext, Vcb );
01842             }
01843 
01844             <span class="comment">//</span>
01845             <span class="comment">//  Now really leave if we have to.</span>
01846             <span class="comment">//</span>
01847             
01848             <span class="keywordflow">if</span> (Abort) {
01849 
01850                 <span class="keywordflow">break</span>;
01851             }
01852 
01853             <span class="comment">//</span>
01854             <span class="comment">//  Now that we have removed all of the prefixes of this Fcb we can make the final check.</span>
01855             <span class="comment">//  Lock the Vcb again so we can inspect the child's references.</span>
01856             <span class="comment">//</span>
01857 
01858             <a class="code" href="../../d3/d8/udfprocs_8h.html#a88">UdfLockVcb</a>( IrpContext, Vcb );
01859 
01860             <span class="keywordflow">if</span> (CurrentFcb-&gt;<a class="code" href="../../d7/d9/struct__FCB.html#o8">FcbReference</a> != 0) {
01861 
01862                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
01863                              <span class="stringliteral">"UdfTeardownStructures, saving Fcb %08x %d/%d\n"</span>,
01864                              CurrentFcb,
01865                              CurrentFcb-&gt;<a class="code" href="../../d7/d9/struct__FCB.html#o8">FcbReference</a>,
01866                              CurrentFcb-&gt;<a class="code" href="../../d7/d9/struct__FCB.html#o9">FcbUserReference</a> ));
01867                 
01868                 <span class="comment">//</span>
01869                 <span class="comment">//  Nope, nothing more to do.  Stop right now.</span>
01870                 <span class="comment">//</span>
01871                 
01872                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a89">UdfUnlockVcb</a>( IrpContext, Vcb );
01873 
01874                 <span class="keywordflow">if</span> (ParentFcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01875 
01876                     <a class="code" href="../../d3/d8/udfprocs_8h.html#a85">UdfReleaseFcb</a>( IrpContext, ParentFcb );
01877                 }
01878 
01879                 <span class="keywordflow">break</span>;
01880             }
01881 
01882             <span class="comment">//</span>
01883             <span class="comment">//  This Fcb is toast.  Remove it from the Fcb Table as appropriate and delete.</span>
01884             <span class="comment">//</span>
01885 
01886             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( CurrentFcb-&gt;<a class="code" href="../../d7/d9/struct__FCB.html#o10">FcbState</a>, <a class="code" href="../../d6/d8/udfstruc_8h.html#a14">FCB_STATE_IN_FCB_TABLE</a> )) {
01887 
01888                 <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a11">UdfDeleteFcbTable</a>( IrpContext, CurrentFcb );
01889                 <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>( CurrentFcb-&gt;<a class="code" href="../../d7/d9/struct__FCB.html#o10">FcbState</a>, <a class="code" href="../../d6/d8/udfstruc_8h.html#a14">FCB_STATE_IN_FCB_TABLE</a> );
01890 
01891             }
01892 
01893             <span class="comment">//</span>
01894             <span class="comment">//  Unlock the Vcb but hold the parent in order to walk up</span>
01895             <span class="comment">//  the tree.</span>
01896             <span class="comment">//</span>
01897 
01898             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
01899                          <span class="stringliteral">"UdfTeardownStructures, toasting Fcb %08x %d/%d\n"</span>,
01900                          CurrentFcb,
01901                          CurrentFcb-&gt;<a class="code" href="../../d7/d9/struct__FCB.html#o8">FcbReference</a>,
01902                          CurrentFcb-&gt;<a class="code" href="../../d7/d9/struct__FCB.html#o9">FcbUserReference</a> ));
01903 
01904             <a class="code" href="../../d3/d8/udfprocs_8h.html#a89">UdfUnlockVcb</a>( IrpContext, Vcb );
01905             <a class="code" href="../../d3/d8/udfprocs_8h.html#a214">UdfDeleteFcb</a>( IrpContext, CurrentFcb );
01906 
01907             <span class="comment">//</span>
01908             <span class="comment">//  Move to the parent Fcb.</span>
01909             <span class="comment">//</span>
01910 
01911             CurrentFcb = ParentFcb;
01912             ParentFcb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01913             AcquiredCurrentFcb = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01914 
01915         } <span class="keywordflow">while</span> (CurrentFcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
01916 
01917     } finally {
01918 
01919         <span class="comment">//</span>
01920         <span class="comment">//  Release the current Fcb if we have acquired it.</span>
01921         <span class="comment">//</span>
01922 
01923         <span class="keywordflow">if</span> (AcquiredCurrentFcb &amp;&amp; (CurrentFcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
01924 
01925             <a class="code" href="../../d3/d8/udfprocs_8h.html#a85">UdfReleaseFcb</a>( IrpContext, CurrentFcb );
01926         }
01927 
01928         <span class="comment">//</span>
01929         <span class="comment">//  Clear the teardown flag.</span>
01930         <span class="comment">//</span>
01931 
01932         <span class="keywordflow">if</span> (!Recursive) {
01933         
01934             <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>( IrpContext-&gt;TopLevel-&gt;Flags, <a class="code" href="../../d6/d8/udfstruc_8h.html#a35">IRP_CONTEXT_FLAG_IN_TEARDOWN</a> );
01935         }
01936     }
01937 
01938     *RemovedStartingFcb = (CurrentFcb != StartingFcb);
01939 
01940     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
01941                  <span class="stringliteral">"UdfTeardownStructures, RemovedStartingFcb -&gt; %c\n"</span>,
01942                  ( *RemovedStartingFcb? <span class="charliteral">'T'</span> : <span class="charliteral">'F'</span> )));
01943 
01944     <span class="keywordflow">return</span>;
01945 }
01946 
01947 
01948 <a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a>
<a name="l01949"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a211">01949</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a211">UdfLookupFcbTable</a> (
01950     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01951     IN <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb,
01952     IN <a class="code" href="../../d6/d8/udfstruc_8h.html#a77">FILE_ID</a> FileId
01953     )
01954 
01955 <span class="comment">/*++</span>
01956 <span class="comment"></span>
01957 <span class="comment">Routine Description:</span>
01958 <span class="comment"></span>
01959 <span class="comment">    This routine will look through the Fcb table looking for a matching</span>
01960 <span class="comment">    entry.</span>
01961 <span class="comment"></span>
01962 <span class="comment">Arguments:</span>
01963 <span class="comment"></span>
01964 <span class="comment">    Vcb - Vcb for this volume.</span>
01965 <span class="comment"></span>
01966 <span class="comment">    FileId - This is the key value to use for the search.</span>
01967 <span class="comment"></span>
01968 <span class="comment">Return Value:</span>
01969 <span class="comment"></span>
01970 <span class="comment">    PFCB - A pointer to the matching entry or NULL otherwise.</span>
01971 <span class="comment"></span>
01972 <span class="comment">--*/</span>
01973 
01974 {
01975     <a class="code" href="../../d5/d0/struct__FCB__TABLE__ELEMENT.html">FCB_TABLE_ELEMENT</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>;
01976     <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a13">PFCB_TABLE_ELEMENT</a> Hit;
01977     <a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a> ReturnFcb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01978 
01979     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01980 
01981     <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>.FileId = FileId;
01982 
01983     Hit = (<a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a13">PFCB_TABLE_ELEMENT</a>) <a class="code" href="../../d6/d1/gentable_8c.html#a7">RtlLookupElementGenericTable</a>( &amp;Vcb-&gt;FcbTable, &amp;<a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a> );
01984 
01985     <span class="keywordflow">if</span> (Hit != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01986 
01987         ReturnFcb = Hit-&gt;<a class="code" href="../../d5/d0/struct__FCB__TABLE__ELEMENT.html#o1">Fcb</a>;
01988     }
01989 
01990     <span class="keywordflow">return</span> ReturnFcb;
01991 
01992     UNREFERENCED_PARAMETER( IrpContext );
01993 }
01994 
01995 
01996 <a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a>
<a name="l01997"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a212">01997</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a212">UdfGetNextFcb</a> (
01998     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01999     IN <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb,
02000     IN PVOID *RestartKey
02001     )
02002 
02003 <span class="comment">/*++</span>
02004 <span class="comment"></span>
02005 <span class="comment">Routine Description:</span>
02006 <span class="comment"></span>
02007 <span class="comment">    This routine will enumerate through all of the Fcb's in the Fcb table.</span>
02008 <span class="comment"></span>
02009 <span class="comment">Arguments:</span>
02010 <span class="comment"></span>
02011 <span class="comment">    Vcb - Vcb for this volume.</span>
02012 <span class="comment"></span>
02013 <span class="comment">    RestartKey - This value is used by the table package to maintain</span>
02014 <span class="comment">        its position in the enumeration.  It is initialized to NULL</span>
02015 <span class="comment">        for the first search.</span>
02016 <span class="comment"></span>
02017 <span class="comment">Return Value:</span>
02018 <span class="comment"></span>
02019 <span class="comment">    PFCB - A pointer to the next fcb or NULL if the enumeration is</span>
02020 <span class="comment">        completed</span>
02021 <span class="comment"></span>
02022 <span class="comment">--*/</span>
02023 
02024 {
02025     <a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a> Fcb;
02026 
02027     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02028 
02029     Fcb = (<a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a>) <a class="code" href="../../d6/d1/gentable_8c.html#a13">RtlEnumerateGenericTableWithoutSplaying</a>( &amp;Vcb-&gt;FcbTable, RestartKey );
02030 
02031     <span class="keywordflow">if</span> (Fcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02032 
02033         Fcb = ((<a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a13">PFCB_TABLE_ELEMENT</a>)(Fcb))-&gt;Fcb;
02034     }
02035 
02036     <span class="keywordflow">return</span> Fcb;
02037 }
02038 
02039 
02040 <a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a>
<a name="l02041"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a213">02041</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a213">UdfCreateFcb</a> (
02042     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
02043     IN FILE_ID FileId,
02044     IN NODE_TYPE_CODE NodeTypeCode,
02045     OUT PBOOLEAN FcbExisted OPTIONAL
02046     )
02047 
02048 <span class="comment">/*++</span>
02049 <span class="comment"></span>
02050 <span class="comment">Routine Description:</span>
02051 <span class="comment"></span>
02052 <span class="comment">    This routine is called to find the Fcb for the given FileId.  We will</span>
02053 <span class="comment">    look this up first in the Fcb table and if not found we will create</span>
02054 <span class="comment">    an Fcb.  We don't initialize it or insert it into the FcbTable in this</span>
02055 <span class="comment">    routine.</span>
02056 <span class="comment"></span>
02057 <span class="comment">    This routine is called while the Vcb is locked.</span>
02058 <span class="comment"></span>
02059 <span class="comment">Arguments:</span>
02060 <span class="comment"></span>
02061 <span class="comment">    FileId - This is the Id for the target Fcb.</span>
02062 <span class="comment"></span>
02063 <span class="comment">    NodeTypeCode - Node type for this Fcb if we need to create.</span>
02064 <span class="comment"></span>
02065 <span class="comment">    FcbExisted - If specified, we store whether the Fcb existed.</span>
02066 <span class="comment"></span>
02067 <span class="comment">Return Value:</span>
02068 <span class="comment"></span>
02069 <span class="comment">    PFCB - The Fcb found in the table or created if needed.</span>
02070 <span class="comment"></span>
02071 <span class="comment">--*/</span>
02072 
02073 {
02074     <a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a> NewFcb;
02075     BOOLEAN LocalFcbExisted;
02076 
02077     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02078 
02079     <span class="comment">//</span>
02080     <span class="comment">//  Use the local boolean if one was not passed in.</span>
02081     <span class="comment">//</span>
02082 
02083     <span class="keywordflow">if</span> (!ARGUMENT_PRESENT( FcbExisted )) {
02084 
02085         FcbExisted = &amp;LocalFcbExisted;
02086     }
02087 
02088     <span class="comment">//</span>
02089     <span class="comment">//  Maybe this is already in the table.</span>
02090     <span class="comment">//</span>
02091 
02092     NewFcb = <a class="code" href="../../d3/d8/udfprocs_8h.html#a211">UdfLookupFcbTable</a>( IrpContext, IrpContext-&gt;Vcb, FileId );
02093 
02094     <span class="comment">//</span>
02095     <span class="comment">//  If not then create the Fcb is requested by our caller.</span>
02096     <span class="comment">//</span>
02097 
02098     <span class="keywordflow">if</span> (NewFcb == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02099 
02100         <span class="comment">//</span>
02101         <span class="comment">//  Use a try-finally for cleanup</span>
02102         <span class="comment">//</span>
02103 
02104         <span class="keywordflow">try</span> {
02105 
02106             <span class="comment">//</span>
02107             <span class="comment">//  Allocate and initialize the structure depending on the</span>
02108             <span class="comment">//  type code.</span>
02109             <span class="comment">//</span>
02110     
02111             <span class="keywordflow">switch</span> (NodeTypeCode) {
02112     
02113             <span class="keywordflow">case</span> <a class="code" href="../../d1/d7/udfs_2nodetype_8h.html#a3">UDFS_NTC_FCB_INDEX</a>:
02114     
02115                 NewFcb = <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a4">UdfAllocateFcbIndex</a>( IrpContext );
02116     
02117                 RtlZeroMemory( NewFcb, <a class="code" href="../../d6/d8/udfstruc_8h.html#a19">SIZEOF_FCB_INDEX</a> );
02118     
02119                 NewFcb-&gt;NodeByteSize = <a class="code" href="../../d6/d8/udfstruc_8h.html#a19">SIZEOF_FCB_INDEX</a>;
02120     
02121                 <span class="keywordflow">break</span>;
02122     
02123             <span class="keywordflow">case</span> <a class="code" href="../../d1/d7/udfs_2nodetype_8h.html#a4">UDFS_NTC_FCB_DATA</a> :
02124     
02125                 NewFcb = <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a2">UdfAllocateFcbData</a>( IrpContext );
02126     
02127                 RtlZeroMemory( NewFcb, <a class="code" href="../../d6/d8/udfstruc_8h.html#a18">SIZEOF_FCB_DATA</a> );
02128     
02129                 NewFcb-&gt;NodeByteSize = <a class="code" href="../../d6/d8/udfstruc_8h.html#a18">SIZEOF_FCB_DATA</a>;
02130     
02131                 <span class="keywordflow">break</span>;
02132     
02133             <span class="keywordflow">default</span>:
02134     
02135                 <a class="code" href="../../d1/d7/udfs_2nodetype_8h.html#a66">UdfBugCheck</a>( 0, 0, 0 );
02136             }
02137     
02138             <span class="comment">//</span>
02139             <span class="comment">//  Now do the common initialization.</span>
02140             <span class="comment">//</span>
02141     
02142             NewFcb-&gt;NodeTypeCode = NodeTypeCode;
02143     
02144             NewFcb-&gt;<a class="code" href="../../d7/d9/struct__FCB.html#o2">Vcb</a> = IrpContext-&gt;Vcb;
02145             NewFcb-&gt;<a class="code" href="../../d7/d9/struct__FCB.html#o6">FileId</a> = FileId;
02146     
02147             InitializeListHead( &amp;NewFcb-&gt;<a class="code" href="../../d7/d9/struct__FCB.html#o3">ParentLcbQueue</a> );
02148             InitializeListHead( &amp;NewFcb-&gt;<a class="code" href="../../d7/d9/struct__FCB.html#o4">ChildLcbQueue</a> );
02149     
02150             <span class="comment">//</span>
02151             <span class="comment">//  Now create the non-paged section object.</span>
02152             <span class="comment">//</span>
02153     
02154             NewFcb-&gt;<a class="code" href="../../d7/d9/struct__FCB.html#o17">FcbNonpaged</a> = <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a18">UdfCreateFcbNonPaged</a>( IrpContext );
02155     
02156             *FcbExisted = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02157 
02158         } finally {
02159 
02160             <a class="code" href="../../d8/d3/lfsdata_8h.html#a3">DebugUnwind</a>( <span class="stringliteral">"UdfCreateFcb"</span> );
02161    
02162             <span class="keywordflow">if</span> (AbnormalTermination()) {
02163 
02164                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>( &amp;NewFcb );
02165             }
02166         }
02167 
02168     } <span class="keywordflow">else</span> {
02169 
02170         *FcbExisted = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02171     }
02172 
02173     <span class="keywordflow">return</span> NewFcb;
02174 }
02175 
02176 
02177 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02178"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a214">02178</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a214">UdfDeleteFcb</a> (
02179     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
02180     IN <a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a> Fcb
02181     )
02182 
02183 <span class="comment">/*++</span>
02184 <span class="comment"></span>
02185 <span class="comment">Routine Description:</span>
02186 <span class="comment"></span>
02187 <span class="comment">    This routine is called to cleanup and deallocate an Fcb.  We know there</span>
02188 <span class="comment">    are no references remaining.  We cleanup any auxilary structures and</span>
02189 <span class="comment">    deallocate this Fcb.</span>
02190 <span class="comment"></span>
02191 <span class="comment">Arguments:</span>
02192 <span class="comment"></span>
02193 <span class="comment">    Fcb - This is the Fcb to deallcoate.</span>
02194 <span class="comment"></span>
02195 <span class="comment">Return Value:</span>
02196 <span class="comment"></span>
02197 <span class="comment">    None</span>
02198 <span class="comment"></span>
02199 <span class="comment">--*/</span>
02200 
02201 {
02202     <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02203     
02204     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02205 
02206     <span class="comment">//</span>
02207     <span class="comment">//  Check inputs.</span>
02208     <span class="comment">//</span>
02209 
02210     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
02211     <a class="code" href="../../d1/d8/udfdata_8h.html#a14">ASSERT_FCB</a>( Fcb );
02212 
02213     <span class="comment">//</span>
02214     <span class="comment">//  Sanity check the counts and Lcb lists.</span>
02215     <span class="comment">//</span>
02216 
02217     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( Fcb-&gt;FcbCleanup == 0 );
02218     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( Fcb-&gt;FcbReference == 0 );
02219 
02220     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( IsListEmpty( &amp;Fcb-&gt;ChildLcbQueue ));
02221     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( IsListEmpty( &amp;Fcb-&gt;ParentLcbQueue ));
02222 
02223     <span class="comment">//</span>
02224     <span class="comment">//  Start with the common structures.</span>
02225     <span class="comment">//</span>
02226 
02227     <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a16">UdfUninitializeFcbMcb</a>( Fcb );
02228     
02229     <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a19">UdfDeleteFcbNonpaged</a>( IrpContext, Fcb-&gt;FcbNonpaged );
02230 
02231     <span class="comment">//</span>
02232     <span class="comment">//  Now do the type specific structures.</span>
02233     <span class="comment">//</span>
02234 
02235     <span class="keywordflow">switch</span> (Fcb-&gt;NodeTypeCode) {
02236 
02237     <span class="keywordflow">case</span> <a class="code" href="../../d1/d7/udfs_2nodetype_8h.html#a3">UDFS_NTC_FCB_INDEX</a>:
02238 
02239         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( Fcb-&gt;FileObject == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
02240 
02241         <span class="keywordflow">if</span> (Fcb == Fcb-&gt;Vcb-&gt;RootIndexFcb) {
02242 
02243             Vcb = Fcb-&gt;Vcb;
02244             Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o21">RootIndexFcb</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02245         
02246         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Fcb == Fcb-&gt;Vcb-&gt;MetadataFcb) {
02247 
02248             Vcb = Fcb-&gt;Vcb;
02249             Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o22">MetadataFcb</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02250 
02251             <a class="code" href="../../d6/d6/vmcbsup_8c.html#a6">UdfUninitializeVmcb</a>( &amp;Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o24">Vmcb</a> );
02252         
02253         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Fcb == Fcb-&gt;Vcb-&gt;VatFcb) {
02254 
02255             Vcb = Fcb-&gt;Vcb;
02256             Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o23">VatFcb</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02257         }
02258 
02259         <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a5">UdfDeallocateFcbIndex</a>( IrpContext, Fcb );
02260         <span class="keywordflow">break</span>;
02261 
02262     <span class="keywordflow">case</span> <a class="code" href="../../d1/d7/udfs_2nodetype_8h.html#a4">UDFS_NTC_FCB_DATA</a> :
02263 
02264         <span class="keywordflow">if</span> (Fcb-&gt;FileLock != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02265 
02266             <a class="code" href="../../d1/d8/fsrtl_8h.html#a113">FsRtlFreeFileLock</a>( Fcb-&gt;FileLock );
02267         }
02268 
02269         <a class="code" href="../../d1/d8/fsrtl_8h.html#a163">FsRtlUninitializeOplock</a>( &amp;Fcb-&gt;Oplock );
02270 
02271         <span class="keywordflow">if</span> (Fcb == Fcb-&gt;Vcb-&gt;VolumeDasdFcb) {
02272 
02273             Vcb = Fcb-&gt;Vcb;
02274             Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o20">VolumeDasdFcb</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02275         }
02276 
02277         <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a3">UdfDeallocateFcbData</a>( IrpContext, Fcb );
02278         <span class="keywordflow">break</span>;
02279     }
02280 
02281     <span class="comment">//</span>
02282     <span class="comment">//  Decrement the Vcb reference count if this is a system</span>
02283     <span class="comment">//  Fcb.</span>
02284     <span class="comment">//</span>
02285 
02286     <span class="keywordflow">if</span> (Vcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02287 
02288         InterlockedDecrement( &amp;Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o16">VcbReference</a> );
02289         InterlockedDecrement( &amp;Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o17">VcbUserReference</a> );
02290     }
02291 
02292     <span class="keywordflow">return</span>;
02293 }
02294 
02295 
02296 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02297"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a215">02297</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a215">UdfInitializeFcbFromIcbContext</a> (
02298     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
02299     IN <a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a> Fcb,
02300     IN <a class="code" href="../../d9/d9/struct__ICB__SEARCH__CONTEXT.html">PICB_SEARCH_CONTEXT</a> IcbContext
02301     )
02302 
02303 <span class="comment">/*++</span>
02304 <span class="comment"></span>
02305 <span class="comment">Routine Description:</span>
02306 <span class="comment"></span>
02307 <span class="comment">    This routine is called to initialize an Fcb from a direct ICB.  It should</span>
02308 <span class="comment">    only be called once in the lifetime of an Fcb and will fill in the Mcb</span>
02309 <span class="comment">    from the chained allocation descriptors of the ICB.</span>
02310 <span class="comment"></span>
02311 <span class="comment">Arguments:</span>
02312 <span class="comment"></span>
02313 <span class="comment">    Fcb - The Fcb being initialized</span>
02314 <span class="comment"></span>
02315 <span class="comment">    IcbOontext - An search context containing the active direct ICB for the object</span>
02316 <span class="comment"></span>
02317 <span class="comment">Return Value:</span>
02318 <span class="comment"></span>
02319 <span class="comment">    None.</span>
02320 <span class="comment"></span>
02321 <span class="comment">--*/</span>
02322 
02323 {
02324     <a class="code" href="../../d6/d1/struct__EA__SEARCH__CONTEXT.html">EA_SEARCH_CONTEXT</a> EaContext;
02325     <a class="code" href="../../d8/d0/structICBFILE.html">PICBFILE</a> Icb;
02326 
02327     <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb;
02328 
02329     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02330 
02331     <span class="comment">//</span>
02332     <span class="comment">//  Check inputs</span>
02333     <span class="comment">//</span>
02334 
02335     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
02336     <a class="code" href="../../d1/d8/udfdata_8h.html#a14">ASSERT_FCB</a>( Fcb );
02337 
02338     <span class="comment">//</span>
02339     <span class="comment">//  Directly reference for convenience</span>
02340     <span class="comment">//</span>
02341 
02342     Icb = IcbContext-&gt;Active.View;
02343     Vcb = Fcb-&gt;Vcb;
02344 
02345     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( IcbContext-&gt;IcbType == <a class="code" href="../../d0/d7/iso13346_8h.html#a54">DESTAG_ID_NSR_FILE</a> &amp;&amp; Icb-&gt;<a class="code" href="../../d8/d0/structICBFILE.html#o0">Destag</a>.<a class="code" href="../../d7/d7/structDESTAG.html#o0">Ident</a> == <a class="code" href="../../d0/d7/iso13346_8h.html#a54">DESTAG_ID_NSR_FILE</a> );
02346     
02347     <span class="comment">//</span>
02348     <span class="comment">//  Check that the full indicated size of the direct entry is sane and</span>
02349     <span class="comment">//  that the length of the EA segment is correctly aligned.  A direct</span>
02350     <span class="comment">//  entry is less than a single logical block in size.</span>
02351     <span class="comment">//</span>
02352     
02353     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d8/udfprocs_8h.html#a24">LongOffset</a>( Icb-&gt;<a class="code" href="../../d8/d0/structICBFILE.html#o18">EALength</a> ) ||
02354         FIELD_OFFSET( <a class="code" href="../../d8/d0/structICBFILE.html">ICBFILE</a>, EAs ) + Icb-&gt;<a class="code" href="../../d8/d0/structICBFILE.html#o18">EALength</a> + Icb-&gt;<a class="code" href="../../d8/d0/structICBFILE.html#o19">AllocLength</a> &gt; <a class="code" href="../../d3/d8/udfprocs_8h.html#a54">BlockSize</a>( IcbContext-&gt;Vcb )) {
02355 
02356         <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, STATUS_FILE_CORRUPT_ERROR );
02357     }
02358 
02359     <a class="code" href="../../d3/d8/udfprocs_8h.html#a90">UdfLockFcb</a>( IrpContext, Fcb );
02360 
02361     <span class="comment">//</span>
02362     <span class="comment">//  Try-finally for cleanup.</span>
02363     <span class="comment">//</span>
02364 
02365     <span class="keywordflow">try</span> {
02366         
02367         <span class="comment">//</span>
02368         <span class="comment">//  Verify that the types mesh and set state flags.</span>
02369         <span class="comment">//</span>
02370     
02371         <span class="keywordflow">if</span> (Fcb-&gt;NodeTypeCode == <a class="code" href="../../d1/d7/udfs_2nodetype_8h.html#a3">UDFS_NTC_FCB_INDEX</a> &amp;&amp; Icb-&gt;<a class="code" href="../../d8/d0/structICBFILE.html#o1">Icbtag</a>.<a class="code" href="../../d1/d1/structICBTAG.html#o5">FileType</a> == <a class="code" href="../../d0/d7/iso13346_8h.html#a102">ICBTAG_FILE_T_DIRECTORY</a>) {
02372     
02373             <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( Fcb-&gt;FileAttributes, FILE_ATTRIBUTE_DIRECTORY );
02374         
02375         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!(Fcb-&gt;NodeTypeCode == <a class="code" href="../../d1/d7/udfs_2nodetype_8h.html#a4">UDFS_NTC_FCB_DATA</a> &amp;&amp; Icb-&gt;<a class="code" href="../../d8/d0/structICBFILE.html#o1">Icbtag</a>.<a class="code" href="../../d1/d1/structICBTAG.html#o5">FileType</a> == <a class="code" href="../../d0/d7/iso13346_8h.html#a103">ICBTAG_FILE_T_FILE</a>)) {
02376     
02377             <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, STATUS_FILE_CORRUPT_ERROR );
02378         }
02379     
02380         <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( Fcb-&gt;FileAttributes, FILE_ATTRIBUTE_READONLY );
02381         
02382         <span class="comment">//</span>
02383         <span class="comment">//  Initialize the common header in the Fcb.</span>
02384         <span class="comment">//</span>
02385     
02386         Fcb-&gt;Resource = &amp;Fcb-&gt;Vcb-&gt;FileResource;
02387     
02388         <span class="comment">//</span>
02389         <span class="comment">//  Size and lookup all allocations for this object.</span>
02390         <span class="comment">//</span>
02391     
02392         Fcb-&gt;AllocationSize.QuadPart = <a class="code" href="../../d3/d8/udfprocs_8h.html#a46">LlBlockAlign</a>( Vcb, Icb-&gt;<a class="code" href="../../d8/d0/structICBFILE.html#o9">InfoLength</a> );
02393     
02394         Fcb-&gt;FileSize.QuadPart =
02395         Fcb-&gt;ValidDataLength.QuadPart = Icb-&gt;<a class="code" href="../../d8/d0/structICBFILE.html#o9">InfoLength</a>;
02396     
02397         <a class="code" href="../../d3/d8/udfprocs_8h.html#a225">UdfInitializeAllocations</a>( IrpContext,
02398                                   Fcb,
02399                                   IcbContext );
02400 
02401         <span class="comment">//</span>
02402         <span class="comment">//  Lift all of the timestamps for this guy.</span>
02403         <span class="comment">//</span>
02404         
02405         <a class="code" href="../../d3/d8/udfprocs_8h.html#a226">UdfUpdateTimestampsFromIcbContext</a>( IrpContext,
02406                                            IcbContext,
02407                                            &amp;Fcb-&gt;Timestamps );
02408 
02409         <span class="comment">//</span>
02410         <span class="comment">//  Pick up the link count.</span>
02411         <span class="comment">//</span>
02412 
02413         Fcb-&gt;LinkCount = Icb-&gt;<a class="code" href="../../d8/d0/structICBFILE.html#o5">LinkCount</a>;
02414     
02415         <span class="comment">//</span>
02416         <span class="comment">//  Link into the Fcb table.  Someone else is responsible for the name linkage, which is</span>
02417         <span class="comment">//  all that remains.  We also note that the Fcb is fully initialized at this point.</span>
02418         <span class="comment">//</span>
02419     
02420         <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a10">UdfInsertFcbTable</a>( IrpContext, Fcb );
02421         <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( Fcb-&gt;FcbState, <a class="code" href="../../d6/d8/udfstruc_8h.html#a14">FCB_STATE_IN_FCB_TABLE</a> | <a class="code" href="../../d6/d8/udfstruc_8h.html#a13">FCB_STATE_INITIALIZED</a> );
02422 
02423     } finally {
02424 
02425         <a class="code" href="../../d3/d8/udfprocs_8h.html#a91">UdfUnlockFcb</a>( IrpContext, Fcb );
02426     }
02427 
02428     <span class="keywordflow">return</span>;
02429 }
02430 
02431 
02432 <a class="code" href="../../d2/d9/struct__CCB.html">PCCB</a>
<a name="l02433"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a216">02433</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a216">UdfCreateCcb</a> (
02434     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
02435     IN <a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a> Fcb,
02436     IN <a class="code" href="../../d5/d9/struct__LCB.html">PLCB</a> Lcb OPTIONAL,
02437     IN ULONG Flags
02438     )
02439 
02440 <span class="comment">/*++</span>
02441 <span class="comment"></span>
02442 <span class="comment">Routine Description:</span>
02443 <span class="comment"></span>
02444 <span class="comment">    This routine is called to allocate and initialize the Ccb structure.</span>
02445 <span class="comment"></span>
02446 <span class="comment">Arguments:</span>
02447 <span class="comment"></span>
02448 <span class="comment">    Fcb - This is the Fcb for the file being opened.</span>
02449 <span class="comment">    </span>
02450 <span class="comment">    Lcb - This is the Lcb the Fcb is opened by.</span>
02451 <span class="comment"></span>
02452 <span class="comment">    Flags - User flags to set in this Ccb.</span>
02453 <span class="comment"></span>
02454 <span class="comment">Return Value:</span>
02455 <span class="comment"></span>
02456 <span class="comment">    PCCB - Pointer to the created Ccb.</span>
02457 <span class="comment"></span>
02458 <span class="comment">--*/</span>
02459 
02460 {
02461     <a class="code" href="../../d2/d9/struct__CCB.html">PCCB</a> NewCcb;
02462     
02463     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02464 
02465     <span class="comment">//</span>
02466     <span class="comment">//  Check inputs.</span>
02467     <span class="comment">//</span>
02468 
02469     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
02470     <a class="code" href="../../d1/d8/udfdata_8h.html#a14">ASSERT_FCB</a>( Fcb );
02471     <a class="code" href="../../d1/d8/udfdata_8h.html#a27">ASSERT_OPTIONAL_LCB</a>( Lcb );
02472 
02473     <span class="comment">//</span>
02474     <span class="comment">//  Allocate and initialize the structure.</span>
02475     <span class="comment">//</span>
02476 
02477     NewCcb = <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a8">UdfAllocateCcb</a>( IrpContext );
02478 
02479     <span class="comment">//</span>
02480     <span class="comment">//  Set the proper node type code and node byte size</span>
02481     <span class="comment">//</span>
02482 
02483     NewCcb-&gt;<a class="code" href="../../d2/d9/struct__CCB.html#o0">NodeTypeCode</a> = <a class="code" href="../../d1/d7/udfs_2nodetype_8h.html#a6">UDFS_NTC_CCB</a>;
02484     NewCcb-&gt;<a class="code" href="../../d2/d9/struct__CCB.html#o1">NodeByteSize</a> = <span class="keyword">sizeof</span>( <a class="code" href="../../d2/d9/struct__CCB.html">CCB</a> );
02485 
02486     <span class="comment">//</span>
02487     <span class="comment">//  Set the initial value for the flags and Fcb/Lcb</span>
02488     <span class="comment">//</span>
02489 
02490     NewCcb-&gt;<a class="code" href="../../d2/d9/struct__CCB.html#o2">Flags</a> = Flags;
02491     NewCcb-&gt;<a class="code" href="../../d2/d9/struct__CCB.html#o3">Fcb</a> = Fcb;
02492     NewCcb-&gt;<a class="code" href="../../d2/d9/struct__CCB.html#o4">Lcb</a> = Lcb;
02493 
02494     <span class="comment">//</span>
02495     <span class="comment">//  Initialize the directory enumeration context</span>
02496     <span class="comment">//</span>
02497     
02498     NewCcb-&gt;<a class="code" href="../../d2/d9/struct__CCB.html#o5">CurrentFileIndex</a> = 0;
02499     NewCcb-&gt;<a class="code" href="../../d2/d9/struct__CCB.html#o7">HighestReturnableFileIndex</a> = 0;
02500     
02501     NewCcb-&gt;<a class="code" href="../../d2/d9/struct__CCB.html#o6">SearchExpression</a>.Length = 
02502     NewCcb-&gt;<a class="code" href="../../d2/d9/struct__CCB.html#o6">SearchExpression</a>.MaximumLength = 0;
02503     NewCcb-&gt;<a class="code" href="../../d2/d9/struct__CCB.html#o6">SearchExpression</a>.Buffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02504 
02505     <span class="keywordflow">return</span> NewCcb;
02506 }
02507 
02508 
02509 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02510"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a217">02510</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a217">UdfDeleteCcb</a> (
02511     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
02512     IN <a class="code" href="../../d2/d9/struct__CCB.html">PCCB</a> Ccb
02513     )
02514 
02515 <span class="comment">/*++</span>
02516 <span class="comment"></span>
02517 <span class="comment">Routine Description:</span>
02518 <span class="comment"></span>
02519 <span class="comment">    This routine is called to cleanup and deallocate a Ccb structure.</span>
02520 <span class="comment"></span>
02521 <span class="comment">Arguments:</span>
02522 <span class="comment"></span>
02523 <span class="comment">    Ccb - This is the Ccb to delete.</span>
02524 <span class="comment"></span>
02525 <span class="comment">Return Value:</span>
02526 <span class="comment"></span>
02527 <span class="comment">    None</span>
02528 <span class="comment"></span>
02529 <span class="comment">--*/</span>
02530 
02531 {
02532     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02533 
02534     <span class="comment">//</span>
02535     <span class="comment">//  Check inputs.</span>
02536     <span class="comment">//</span>
02537 
02538     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
02539     <a class="code" href="../../d1/d8/udfdata_8h.html#a22">ASSERT_CCB</a>( Ccb );
02540 
02541     <span class="keywordflow">if</span> (Ccb-&gt;SearchExpression.Buffer != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02542 
02543         <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>( &amp;Ccb-&gt;SearchExpression.Buffer );
02544     }
02545 
02546     <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a9">UdfDeallocateCcb</a>( IrpContext, Ccb );
02547     <span class="keywordflow">return</span>;
02548 }
02549 
02550 
02551 ULONG
<a name="l02552"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a218">02552</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a218">UdfFindInParseTable</a> (
02553     IN <a class="code" href="../../d2/d8/struct__PARSE__KEYVALUE.html">PPARSE_KEYVALUE</a> ParseTable,
02554     IN PCHAR Id,
02555     IN ULONG MaxIdLen
02556     )
02557 
02558 <span class="comment">/*++</span>
02559 <span class="comment"></span>
02560 <span class="comment">Routine Description:</span>
02561 <span class="comment"></span>
02562 <span class="comment">    This routine walks a table of string key/value information for a match of the</span>
02563 <span class="comment">    input Id.  MaxIdLen can be set to get a prefix match.</span>
02564 <span class="comment"></span>
02565 <span class="comment">Arguments:</span>
02566 <span class="comment"></span>
02567 <span class="comment">    Table - This is the table being searched.</span>
02568 <span class="comment"></span>
02569 <span class="comment">    Id - Key value.</span>
02570 <span class="comment"></span>
02571 <span class="comment">    MaxIdLen - Maximum possible length of Id.</span>
02572 <span class="comment"></span>
02573 <span class="comment">Return Value:</span>
02574 <span class="comment"></span>
02575 <span class="comment">    Value of matching entry, or the terminating (NULL) entry's value.</span>
02576 <span class="comment"></span>
02577 <span class="comment">--*/</span>
02578 
02579 {
02580     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02581 
02582     <span class="keywordflow">while</span> (ParseTable-&gt;Key != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02583 
02584         <span class="keywordflow">if</span> (RtlEqualMemory(ParseTable-&gt;Key, Id, MaxIdLen)) {
02585 
02586             <span class="keywordflow">break</span>;
02587         }
02588 
02589         ParseTable++;
02590     }
02591 
02592     <span class="keywordflow">return</span> ParseTable-&gt;Value;
02593 }
02594 
02595 
02596 <span class="preprocessor">#ifdef UDF_SANITY</span>
02597 <span class="preprocessor"></span>
02598 <span class="comment">//</span>
02599 <span class="comment">//  Enumerate the reasons why a descriptor might be bad.</span>
02600 <span class="comment">//</span>
02601 
02602 <span class="keyword">typedef</span> <span class="keyword">enum</span> _VERIFY_FAILURE {
02603     
02604     Nothing,
02605     BadLbn,
02606     BadTag,
02607     BadChecksum,
02608     BadCrcLength,
02609     BadCrc,
02610     BadDestagVersion
02611 
02612 } VERIFY_FAILURE;
02613 
02614 <span class="preprocessor">#endif</span>
02615 <span class="preprocessor"></span>
02616 BOOLEAN
<a name="l02617"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a219">02617</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a219">UdfVerifyDescriptor</a> (
02618     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
02619     IN <a class="code" href="../../d7/d7/structDESTAG.html">PDESTAG</a> Descriptor,
02620     IN USHORT Tag,
02621     IN ULONG Size,
02622     IN ULONG Lbn,
02623     IN BOOLEAN ReturnError
02624     )
02625 
02626 <span class="comment">/*++</span>
02627 <span class="comment"></span>
02628 <span class="comment">Routine Description:</span>
02629 <span class="comment"></span>
02630 <span class="comment">    This routine verifies that a descriptor using a Descriptor tag (3/7.2) is </span>
02631 <span class="comment">    consistent with itself and the descriptor data.</span>
02632 <span class="comment"></span>
02633 <span class="comment">Arguments:</span>
02634 <span class="comment"></span>
02635 <span class="comment">    Descriptor - This is the pointer to the descriptor tag, which is always</span>
02636 <span class="comment">        at the front of a descriptor</span>
02637 <span class="comment"></span>
02638 <span class="comment">    Tag - The Tag Identifier this descriptor should have</span>
02639 <span class="comment"></span>
02640 <span class="comment">    Size - Size of this descriptor</span>
02641 <span class="comment"></span>
02642 <span class="comment">    Lbn - The logical block number this descriptor should claim it is recorded at</span>
02643 <span class="comment"></span>
02644 <span class="comment">    ReturnError - Whether this routine should return an error or raise</span>
02645 <span class="comment"></span>
02646 <span class="comment">Return Value:</span>
02647 <span class="comment"></span>
02648 <span class="comment">    Boolean TRUE if the descriptor is consistent, FALSE or a raised status of</span>
02649 <span class="comment">    STATUS_DISK_CORRUPT_ERROR otherwise.</span>
02650 <span class="comment"></span>
02651 <span class="comment">--*/</span>
02652 
02653 {
02654     UCHAR Checksum = 0;
02655     PCHAR CheckPtr;
02656     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> Crc;
02657 
02658 <span class="preprocessor">#ifdef UDF_SANITY</span>
02659 <span class="preprocessor"></span>    
02660     VERIFY_FAILURE FailReason = Nothing;
02661 
02662 <span class="preprocessor">#endif</span>
02663 <span class="preprocessor"></span>    
02664     <span class="comment">//</span>
02665     <span class="comment">//  Check our inputs</span>
02666     <span class="comment">//</span>
02667 
02668     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
02669 
02670     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02671 
02672 <span class="preprocessor">#ifdef UDF_SANITY</span>
02673 <span class="preprocessor"></span>
02674     <span class="keywordflow">if</span> (UdfNoisyVerifyDescriptor) {
02675 
02676         <span class="keywordflow">goto</span> BeNoisy;
02677     }
02678 
02679     RegularEntry:
02680 
02681 <span class="preprocessor">#endif</span>
02682 <span class="preprocessor"></span>
02683     <span class="comment">//</span>
02684     <span class="comment">//  The version of the Descriptor Tag specified in ISO 13346 and used in</span>
02685     <span class="comment">//  UDF is a particular value; presumeably, previous versions were used</span>
02686     <span class="comment">//  in some older revision of the standard.</span>
02687     <span class="comment">//</span>
02688 
02689 <span class="preprocessor">#ifdef UDF_SUPPORT_NONSTANDARD_ADAPTEC</span>
02690 <span class="preprocessor"></span>
02691     <span class="comment">//</span>
02692     <span class="comment">//  Let bad descriptor version numbers through.</span>
02693     <span class="comment">//</span>
02694     <span class="comment">//  Reasons:</span>
02695     <span class="comment">//</span>
02696     <span class="comment">//      ADAPTEC - early CDUDF wrote version 1 as opposed to version 2.</span>
02697     <span class="comment">//</span>
02698 
02699     <span class="keywordflow">if</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>)
02700 
02701 <span class="preprocessor">#else</span>
02702 <span class="preprocessor"></span>
02703     <span class="keywordflow">if</span> (Descriptor-&gt;Version == <a class="code" href="../../d0/d7/iso13346_8h.html#a61">DESTAG_VER_CURRENT</a>)
02704 
02705 <span class="preprocessor">#endif</span>
02706 <span class="preprocessor"></span>
02707     {
02708 
02709         <span class="comment">//</span>
02710         <span class="comment">//  A descriptor is stamped in four ways. First, the Lbn of the sector</span>
02711         <span class="comment">//  containing the descriptor is written here. (3/7.2.8)</span>
02712         <span class="comment">//</span>
02713 
02714         
02715 <span class="preprocessor">#ifdef UDF_SUPPORT_NONSTANDARD_HP</span>
02716 <span class="preprocessor"></span>        
02717         <span class="comment">//</span>
02718         <span class="comment">//  Let bad lbn through.</span>
02719         <span class="comment">//</span>
02720         <span class="comment">//  Reasons:</span>
02721         <span class="comment">//</span>
02722         <span class="comment">//      HP - Rob Sim;s CD-RW model disc doesn't record this reliably.</span>
02723         <span class="comment">//</span>
02724 
02725         <span class="keywordflow">if</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>)
02726 
02727 <span class="preprocessor">#else</span>
02728 <span class="preprocessor"></span>        
02729         <span class="keywordflow">if</span> (Descriptor-&gt;Lbn == Lbn)
02730 
02731 <span class="preprocessor">#endif</span>
02732 <span class="preprocessor"></span>        {
02733             <span class="comment">//</span>
02734             <span class="comment">//  Next, the descriptor tag itself has an identifier which should match</span>
02735             <span class="comment">//  the type we expect to find here (3/7.2.1)</span>
02736             <span class="comment">//</span>
02737             
02738             <span class="keywordflow">if</span> (Descriptor-&gt;Ident == Tag) {
02739         
02740                 <span class="comment">//</span>
02741                 <span class="comment">//  Next, the descriptor tag itself is checksumed, minus the byte</span>
02742                 <span class="comment">//  used to store the checksum. (3/7.2.3)</span>
02743                 <span class="comment">//</span>
02744             
02745                 <span class="keywordflow">for</span> (CheckPtr = (PCHAR) Descriptor;
02746                      CheckPtr &lt; (PCHAR) Descriptor + FIELD_OFFSET( <a class="code" href="../../d7/d7/structDESTAG.html">DESTAG</a>, Checksum );
02747                      CheckPtr++) {
02748             
02749                     Checksum += *CheckPtr;
02750                 }
02751         
02752                 <span class="keywordflow">for</span> (CheckPtr = (PCHAR) Descriptor + FIELD_OFFSET( <a class="code" href="../../d7/d7/structDESTAG.html">DESTAG</a>, Checksum ) + <span class="keyword">sizeof</span>(UCHAR);
02753                      CheckPtr &lt; (PCHAR) Descriptor + <span class="keyword">sizeof</span>(<a class="code" href="../../d7/d7/structDESTAG.html">DESTAG</a>);
02754                      CheckPtr++) {
02755             
02756                     Checksum += *CheckPtr;
02757                 }
02758         
02759                 <span class="keywordflow">if</span> (Descriptor-&gt;Checksum == Checksum) {
02760             
02761                     <span class="comment">//</span>
02762                     <span class="comment">//  Now we check that the CRC in the Descriptor tag is sized sanely</span>
02763                     <span class="comment">//  and matches the Descriptor data. (3/7.2.6)</span>
02764                     <span class="comment">//</span>
02765 
02766 <span class="preprocessor">#ifdef UDF_SUPPORT_NONSTANDARD_HP</span>
02767 <span class="preprocessor"></span>
02768                     <span class="comment">//</span>
02769                     <span class="comment">//  Let zero-length CRCs through.</span>
02770                     <span class="comment">//</span>
02771                     <span class="comment">//  Reasons:</span>
02772                     <span class="comment">//</span>
02773                     <span class="comment">//      HP - early CDUDF didn't CRC the terminationg descriptors (tag 8).</span>
02774                     <span class="comment">//</span>
02775                     
02776                     <span class="keywordflow">if</span> (!Descriptor-&gt;CRCLen ||
02777                         Descriptor-&gt;CRCLen &lt;= <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> - <span class="keyword">sizeof</span>(<a class="code" href="../../d7/d7/structDESTAG.html">DESTAG</a>))
02778 <span class="preprocessor">#else</span>
02779 <span class="preprocessor"></span>                    
02780                     <span class="keywordflow">if</span> (Descriptor-&gt;CRCLen &amp;&amp;
02781                         Descriptor-&gt;CRCLen &lt;= <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> - <span class="keyword">sizeof</span>(<a class="code" href="../../d7/d7/structDESTAG.html">DESTAG</a>))
02782 
02783 <span class="preprocessor">#endif                        </span>
02784 <span class="preprocessor"></span>                    {
02785     
02786                         Crc = <a class="code" href="../../d3/d8/udfprocs_8h.html#a134">UdfComputeCrc16</a>( (PCHAR) Descriptor + <span class="keyword">sizeof</span>(<a class="code" href="../../d7/d7/structDESTAG.html">DESTAG</a>),
02787                                                Descriptor-&gt;CRCLen );
02788                         
02789 <span class="preprocessor">#ifdef UDF_SUPPORT_NONSTANDARD_HP</span>
02790 <span class="preprocessor"></span>
02791                         <span class="comment">//</span>
02792                         <span class="comment">//  Let zero-length CRCs through.</span>
02793                         <span class="comment">//</span>
02794                         <span class="comment">//  Reasons: as above.</span>
02795                         <span class="comment">//</span>
02796                     
02797                         <span class="keywordflow">if</span> (!Descriptor-&gt;CRCLen ||
02798                             Descriptor-&gt;CRC == Crc)
02799 
02800 <span class="preprocessor">#else</span>
02801 <span class="preprocessor"></span>
02802                         <span class="keywordflow">if</span> (Descriptor-&gt;CRC == Crc)
02803 
02804 <span class="preprocessor">#endif</span>
02805 <span class="preprocessor"></span>                        {
02806                             
02807                             <span class="comment">//</span>
02808                             <span class="comment">//  This descriptor checks out.</span>
02809                             <span class="comment">//</span>
02810     
02811 <span class="preprocessor">#ifdef UDF_SANITY</span>
02812 <span class="preprocessor"></span>                            <span class="keywordflow">if</span> (UdfNoisyVerifyDescriptor) {
02813                             
02814                                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfVerifyDescriptor -&gt; TRUE\n"</span> ));
02815                             }
02816 <span class="preprocessor">#endif</span>
02817 <span class="preprocessor"></span>                            <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02818                     
02819                         } <span class="keywordflow">else</span> {
02820 <span class="preprocessor">#ifdef UDF_SANITY</span>
02821 <span class="preprocessor"></span>                            FailReason = BadCrc;
02822                             <span class="keywordflow">goto</span> ReportFailure;
02823 <span class="preprocessor">#endif</span>
02824 <span class="preprocessor"></span>                        }
02825     
02826                     } <span class="keywordflow">else</span> {
02827 <span class="preprocessor">#ifdef UDF_SANITY</span>
02828 <span class="preprocessor"></span>                        FailReason = BadCrcLength;
02829                         <span class="keywordflow">goto</span> ReportFailure;
02830 <span class="preprocessor">#endif</span>
02831 <span class="preprocessor"></span>                    }
02832             
02833                 } <span class="keywordflow">else</span> {
02834 <span class="preprocessor">#ifdef UDF_SANITY</span>
02835 <span class="preprocessor"></span>                    FailReason = BadChecksum;
02836                     <span class="keywordflow">goto</span> ReportFailure;
02837 <span class="preprocessor">#endif</span>
02838 <span class="preprocessor"></span>                }
02839             
02840             } <span class="keywordflow">else</span> {
02841 <span class="preprocessor">#ifdef UDF_SANITY</span>
02842 <span class="preprocessor"></span>                FailReason = BadTag;
02843                 <span class="keywordflow">goto</span> ReportFailure;
02844 <span class="preprocessor">#endif</span>
02845 <span class="preprocessor"></span>            }
02846         
02847         } <span class="keywordflow">else</span> {
02848 <span class="preprocessor">#ifdef UDF_SANITY</span>
02849 <span class="preprocessor"></span>            FailReason = BadLbn;
02850             <span class="keywordflow">goto</span> ReportFailure;
02851 <span class="preprocessor">#endif</span>
02852 <span class="preprocessor"></span>        }
02853     
02854     } <span class="keywordflow">else</span> {
02855 <span class="preprocessor">#ifdef UDF_SANITY</span>
02856 <span class="preprocessor"></span>        FailReason = BadDestagVersion;
02857         <span class="keywordflow">goto</span> ReportFailure;
02858 <span class="preprocessor">#endif</span>
02859 <span class="preprocessor"></span>    }
02860 
02861 <span class="preprocessor">#ifdef UDF_SANITY</span>
02862 <span class="preprocessor"></span>
02863     BeNoisy:
02864     
02865     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
02866                  <span class="stringliteral">"UdfVerifyDescriptor, Destag %08x, Tag %x, Size %x, Lbn %x\n"</span>,
02867                  Descriptor,
02868                  Tag,
02869                  <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>,
02870                  Lbn ));
02871 
02872     <span class="keywordflow">if</span> (FailReason == Nothing) {
02873 
02874         <span class="keywordflow">goto</span> RegularEntry;
02875     
02876     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!UdfNoisyVerifyDescriptor) {
02877 
02878         <span class="keywordflow">goto</span> ReallyReportFailure;
02879     }
02880 
02881     ReportFailure:
02882 
02883     <span class="keywordflow">if</span> (!UdfNoisyVerifyDescriptor) {
02884 
02885         <span class="keywordflow">goto</span> BeNoisy;
02886     }
02887 
02888     ReallyReportFailure:
02889 
02890     <span class="keywordflow">switch</span> (FailReason) {
02891         <span class="keywordflow">case</span> BadLbn:
02892             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, 
02893                          <span class="stringliteral">"Lbn mismatch - Lbn %x != expected %x\n"</span>,
02894                          Descriptor-&gt;Lbn,
02895                          Lbn ));
02896             <span class="keywordflow">break</span>;
02897 
02898         <span class="keywordflow">case</span> BadTag:
02899             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
02900                          <span class="stringliteral">"Tag mismatch - Ident %x != expected %x\n"</span>,
02901                          Descriptor-&gt;Ident,
02902                          Tag ));
02903             <span class="keywordflow">break</span>;
02904 
02905         <span class="keywordflow">case</span> BadChecksum:
02906             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
02907                          <span class="stringliteral">"Checksum mismatch - Checksum %x != descriptor's %x\n"</span>,
02908                          Checksum,
02909                          Descriptor-&gt;Checksum ));
02910             <span class="keywordflow">break</span>;
02911 
02912         <span class="keywordflow">case</span> BadCrcLength:
02913             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
02914                          <span class="stringliteral">"CRC'd size bad - CrcLen %x is 0 or &gt; max %x\n"</span>,
02915                          Descriptor-&gt;CRCLen,
02916                          <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> - <span class="keyword">sizeof</span>(<a class="code" href="../../d7/d7/structDESTAG.html">DESTAG</a>) ));
02917             <span class="keywordflow">break</span>;
02918 
02919         <span class="keywordflow">case</span> BadCrc:
02920             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
02921                          <span class="stringliteral">"CRC mismatch - Crc %x != descriptor's %x\n"</span>,
02922                          Crc,
02923                          Descriptor-&gt;CRC ));
02924             <span class="keywordflow">break</span>;
02925 
02926         <span class="keywordflow">case</span> BadDestagVersion:
02927             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
02928                          <span class="stringliteral">"Bad Destag Verion - %x != descriptor's %x\n"</span>,
02929                          <a class="code" href="../../d0/d7/iso13346_8h.html#a61">DESTAG_VER_CURRENT</a>,
02930                          Descriptor-&gt;Version ));
02931             <span class="keywordflow">break</span>;
02932 
02933         <span class="keywordflow">default</span>:
02934             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
02935     }
02936     
02937     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfVerifyDescriptor -&gt; FALSE\n"</span> ));
02938 
02939 <span class="preprocessor">#endif</span>
02940 <span class="preprocessor"></span>    
02941     <span class="keywordflow">if</span> (!ReturnError) {
02942 
02943         <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, STATUS_CRC_ERROR );
02944     }
02945 
02946     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02947 }
02948 
02949 
02950 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02951"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a220">02951</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a220">UdfInitializeIcbContextFromFcb</a> (
02952     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
02953     IN <a class="code" href="../../d9/d9/struct__ICB__SEARCH__CONTEXT.html">PICB_SEARCH_CONTEXT</a> IcbContext,
02954     IN <a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a> Fcb
02955     )
02956 
02957 <span class="comment">/*++</span>
02958 <span class="comment"></span>
02959 <span class="comment">Routine Description:</span>
02960 <span class="comment"></span>
02961 <span class="comment">    This routine is called to initialize a context to search the Icb hierarchy</span>
02962 <span class="comment">    associated with an Fcb.</span>
02963 <span class="comment"></span>
02964 <span class="comment">Arguments:</span>
02965 <span class="comment"></span>
02966 <span class="comment">    Fcb - Fcb associated with the hierarchy to search.</span>
02967 <span class="comment"></span>
02968 <span class="comment">Return Value:</span>
02969 <span class="comment"></span>
02970 <span class="comment">    None.</span>
02971 <span class="comment"></span>
02972 <span class="comment">--*/</span>
02973 
02974 {
02975     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02976 
02977     <span class="comment">//</span>
02978     <span class="comment">//  Check input parameters.</span>
02979     <span class="comment">//</span>
02980 
02981     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
02982     <a class="code" href="../../d1/d8/udfdata_8h.html#a14">ASSERT_FCB</a>( Fcb );
02983 
02984     RtlZeroMemory( IcbContext, <span class="keyword">sizeof</span>( <a class="code" href="../../d9/d9/struct__ICB__SEARCH__CONTEXT.html">ICB_SEARCH_CONTEXT</a> ));
02985 
02986     IcbContext-&gt;Vcb = Fcb-&gt;Vcb;
02987     IcbContext-&gt;IcbType = <a class="code" href="../../d0/d7/iso13346_8h.html#a54">DESTAG_ID_NSR_FILE</a>;
02988     
02989     <span class="comment">//</span>
02990     <span class="comment">//  It is possible that we don't have an idea what the length of the root extent is.</span>
02991     <span class="comment">//  This will commonly happen in the OpenById case.</span>
02992     <span class="comment">//</span>
02993     
02994     <span class="keywordflow">if</span> (Fcb-&gt;RootExtentLength == 0) {
02995 
02996         <a class="code" href="../../d8/d0/structICBFILE.html">PICBFILE</a> Icb;
02997 
02998         <span class="comment">//</span>
02999         <span class="comment">//  We have to lift the first entry from this (possibly bogus!) extent</span>
03000         <span class="comment">//  and find out how many entries can be recorded, then unmap/remap the view</span>
03001         <span class="comment">//  to try to get the extent.</span>
03002         <span class="comment">//</span>
03003 
03004         <a class="code" href="../../d3/d8/udfprocs_8h.html#a157">UdfMapMetadataView</a>( IrpContext,
03005                             &amp;IcbContext-&gt;Current,
03006                             IcbContext-&gt;Vcb,
03007                             <a class="code" href="../../d6/d8/udfstruc_8h.html#a46">UdfGetFidPartition</a>( Fcb-&gt;FileId ),
03008                             <a class="code" href="../../d6/d8/udfstruc_8h.html#a45">UdfGetFidLbn</a>( Fcb-&gt;FileId ),
03009                             <a class="code" href="../../d3/d8/udfprocs_8h.html#a54">BlockSize</a>( IcbContext-&gt;Vcb ));
03010 
03011         Icb = IcbContext-&gt;Current.View;
03012         
03013         <span class="comment">//</span>
03014         <span class="comment">//  We can only accomplish the guess if we have a descriptor which contains an ICB</span>
03015         <span class="comment">//  Tag, which contains a field that can tell us what we need to know.</span>
03016         <span class="comment">//</span>
03017         
03018         <span class="keywordflow">if</span> (Icb-&gt;<a class="code" href="../../d8/d0/structICBFILE.html#o0">Destag</a>.<a class="code" href="../../d7/d7/structDESTAG.html#o0">Ident</a> == <a class="code" href="../../d0/d7/iso13346_8h.html#a52">DESTAG_ID_NSR_ICBIND</a> ||
03019             Icb-&gt;<a class="code" href="../../d8/d0/structICBFILE.html#o0">Destag</a>.<a class="code" href="../../d7/d7/structDESTAG.html#o0">Ident</a> == <a class="code" href="../../d0/d7/iso13346_8h.html#a53">DESTAG_ID_NSR_ICBTRM</a> ||
03020             Icb-&gt;<a class="code" href="../../d8/d0/structICBFILE.html#o0">Destag</a>.<a class="code" href="../../d7/d7/structDESTAG.html#o0">Ident</a> == <a class="code" href="../../d0/d7/iso13346_8h.html#a54">DESTAG_ID_NSR_FILE</a> ||
03021             Icb-&gt;<a class="code" href="../../d8/d0/structICBFILE.html#o0">Destag</a>.<a class="code" href="../../d7/d7/structDESTAG.html#o0">Ident</a> == <a class="code" href="../../d0/d7/iso13346_8h.html#a56">DESTAG_ID_NSR_UASE</a> ||
03022             Icb-&gt;<a class="code" href="../../d8/d0/structICBFILE.html#o0">Destag</a>.<a class="code" href="../../d7/d7/structDESTAG.html#o0">Ident</a> == <a class="code" href="../../d0/d7/iso13346_8h.html#a58">DESTAG_ID_NSR_PINTEG</a>) {
03023         
03024             <a class="code" href="../../d3/d8/udfprocs_8h.html#a219">UdfVerifyDescriptor</a>( IrpContext,
03025                                  &amp;Icb-&gt;<a class="code" href="../../d8/d0/structICBFILE.html#o0">Destag</a>,
03026                                  Icb-&gt;<a class="code" href="../../d8/d0/structICBFILE.html#o0">Destag</a>.<a class="code" href="../../d7/d7/structDESTAG.html#o0">Ident</a>,
03027                                  <a class="code" href="../../d3/d8/udfprocs_8h.html#a54">BlockSize</a>( IcbContext-&gt;Vcb ),
03028                                  <a class="code" href="../../d6/d8/udfstruc_8h.html#a45">UdfGetFidLbn</a>( Fcb-&gt;FileId ),
03029                                  <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
03030         } <span class="keywordflow">else</span> {
03031 
03032             <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, STATUS_FILE_CORRUPT_ERROR );
03033         }
03034 
03035         <span class="comment">//</span>
03036         <span class="comment">//  Now the MaxEntries (4/14.6.4) field of the Icb Tag should tell us how big the extent</span>
03037         <span class="comment">//  should be.  The tail of this could be unrecorded.  We could even have landed in the middle</span>
03038         <span class="comment">//  of an extent.  This is only a guess.  For whatever reason we are having to guess this</span>
03039         <span class="comment">//  information, any results are expected to be coming with few guarantees.</span>
03040         <span class="comment">//</span>
03041 
03042         Fcb-&gt;RootExtentLength = Icb-&gt;<a class="code" href="../../d8/d0/structICBFILE.html#o1">Icbtag</a>.<a class="code" href="../../d1/d1/structICBTAG.html#o3">MaxEntries</a> * <a class="code" href="../../d3/d8/udfprocs_8h.html#a54">BlockSize</a>( IcbContext-&gt;Vcb );
03043     }
03044     
03045     <span class="comment">//</span>
03046     <span class="comment">//  Map the first extent into the current slot.</span>
03047     <span class="comment">//</span>
03048 
03049     <a class="code" href="../../d3/d8/udfprocs_8h.html#a157">UdfMapMetadataView</a>( IrpContext,
03050                         &amp;IcbContext-&gt;Current,
03051                         IcbContext-&gt;Vcb,
03052                         <a class="code" href="../../d6/d8/udfstruc_8h.html#a46">UdfGetFidPartition</a>( Fcb-&gt;FileId ),
03053                         <a class="code" href="../../d6/d8/udfstruc_8h.html#a45">UdfGetFidLbn</a>( Fcb-&gt;FileId ),
03054                         Fcb-&gt;RootExtentLength );
03055     <span class="keywordflow">return</span>;
03056 }
03057 
03058 
03059 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l03060"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a221">03060</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a221">UdfInitializeIcbContext</a> (
03061     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
03062     IN <a class="code" href="../../d9/d9/struct__ICB__SEARCH__CONTEXT.html">PICB_SEARCH_CONTEXT</a> IcbContext,
03063     IN <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb,
03064     IN USHORT IcbType,
03065     IN USHORT Partition,
03066     IN ULONG Lbn,
03067     IN ULONG Length
03068     )
03069 
03070 <span class="comment">/*++</span>
03071 <span class="comment"></span>
03072 <span class="comment">Routine Description:</span>
03073 <span class="comment"></span>
03074 <span class="comment">    This routine is called to initialize a context to search an Icb hierarchy.</span>
03075 <span class="comment"></span>
03076 <span class="comment">Arguments:</span>
03077 <span class="comment"></span>
03078 <span class="comment">    Vcb - Vcb for the volume.</span>
03079 <span class="comment">    </span>
03080 <span class="comment">    IcbType - Type of direct entry we expect to find (DESTAG_ID...)</span>
03081 <span class="comment">    </span>
03082 <span class="comment">    Partition - partition of the hierarchy.</span>
03083 <span class="comment">    </span>
03084 <span class="comment">    Lbn - lbn of the hierarchy.</span>
03085 <span class="comment">    </span>
03086 <span class="comment">    Length - length of the root extent of the hierarchy.</span>
03087 <span class="comment"></span>
03088 <span class="comment">Return Value:</span>
03089 <span class="comment"></span>
03090 <span class="comment">    None.</span>
03091 <span class="comment"></span>
03092 <span class="comment">--*/</span>
03093 
03094 {
03095     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
03096 
03097     <span class="comment">//</span>
03098     <span class="comment">//  Check input parameters.</span>
03099     <span class="comment">//</span>
03100 
03101     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
03102 
03103     RtlZeroMemory( IcbContext, <span class="keyword">sizeof</span>( <a class="code" href="../../d9/d9/struct__ICB__SEARCH__CONTEXT.html">ICB_SEARCH_CONTEXT</a> ));
03104 
03105     IcbContext-&gt;Vcb = Vcb;
03106     IcbContext-&gt;IcbType = IcbType;
03107     
03108     <span class="comment">//</span>
03109     <span class="comment">//  Map the first extent into the current slot.</span>
03110     <span class="comment">//</span>
03111 
03112     <a class="code" href="../../d3/d8/udfprocs_8h.html#a157">UdfMapMetadataView</a>( IrpContext,
03113                         &amp;IcbContext-&gt;Current,
03114                         Vcb,
03115                         Partition,
03116                         Lbn,
03117                         Length );
03118     <span class="keywordflow">return</span>;
03119 
03120 }
03121 
03122 
03123 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l03124"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a223">03124</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a223">UdfLookupActiveIcb</a> (
03125     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
03126     IN <a class="code" href="../../d9/d9/struct__ICB__SEARCH__CONTEXT.html">PICB_SEARCH_CONTEXT</a> IcbContext
03127     )
03128 
03129 <span class="comment">/*++</span>
03130 <span class="comment"></span>
03131 <span class="comment">Routine Description:</span>
03132 <span class="comment"></span>
03133 <span class="comment">    This routine is called to cause the active Icb for an Icb hierarchy to be mapped.</span>
03134 <span class="comment">    A context initialized by UdfInitializeIcbContext() is required.</span>
03135 <span class="comment"></span>
03136 <span class="comment">Arguments:</span>
03137 <span class="comment"></span>
03138 <span class="comment">    IcbContext - Context which has been initialized to point into an Icb hierarchy.</span>
03139 <span class="comment"></span>
03140 <span class="comment">Return Value:</span>
03141 <span class="comment"></span>
03142 <span class="comment">    None.</span>
03143 <span class="comment">    </span>
03144 <span class="comment">    Raised status if the Icb hierarchy is invalid.</span>
03145 <span class="comment"></span>
03146 <span class="comment">--*/</span>
03147 
03148 {
03149     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
03150 
03151     <span class="comment">//</span>
03152     <span class="comment">//  Check input parameters.</span>
03153     <span class="comment">//</span>
03154 
03155     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
03156 
03157     <span class="comment">//</span>
03158     <span class="comment">//  Travel the Icb hierarchy.  Due to the design of ISO 13346, it is convenient to</span>
03159     <span class="comment">//  recursively descend the hierarchy.  Place a limit on this recursion which will</span>
03160     <span class="comment">//  allow traversal of most reasonable hierarchies (this will tail recurse off of</span>
03161     <span class="comment">//  the end of extents).</span>
03162     <span class="comment">//</span>
03163 
03164     <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a25">UdfLookupActiveIcbInExtent</a>( IrpContext,
03165                                 IcbContext,
03166                                 <a class="code" href="../../d9/d7/udf_8h.html#a30">UDF_ICB_RECURSION_LIMIT</a> );
03167 
03168     <span class="comment">//</span>
03169     <span class="comment">//  We must have found an active ICB.  Drop the last mapped part of the enumeration</span>
03170     <span class="comment">//  at this point.</span>
03171     <span class="comment">//</span>
03172 
03173     <a class="code" href="../../d3/d8/udfprocs_8h.html#a68">UdfUnpinView</a>( IrpContext, &amp;IcbContext-&gt;Current );
03174 
03175     <span class="keywordflow">if</span> (IcbContext-&gt;Active.View == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03176 
03177         <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, STATUS_FILE_CORRUPT_ERROR );
03178     }
03179 }
03180 
03181 
03182 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l03183"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a224">03183</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a224">UdfCleanupIcbContext</a> (
03184     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
03185     IN <a class="code" href="../../d9/d9/struct__ICB__SEARCH__CONTEXT.html">PICB_SEARCH_CONTEXT</a> IcbContext
03186     )
03187 
03188 <span class="comment">/*++</span>
03189 <span class="comment"></span>
03190 <span class="comment">Routine Description:</span>
03191 <span class="comment"></span>
03192 <span class="comment">    This routine cleans an Icb search context for reuse/deletion.</span>
03193 <span class="comment"></span>
03194 <span class="comment">Arguments:</span>
03195 <span class="comment"></span>
03196 <span class="comment">    IcbContext - context to clean</span>
03197 <span class="comment"></span>
03198 <span class="comment">Return Value:</span>
03199 <span class="comment"></span>
03200 <span class="comment">    None.</span>
03201 <span class="comment"></span>
03202 <span class="comment">--*/</span>
03203 
03204 {
03205     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
03206 
03207     <span class="comment">//</span>
03208     <span class="comment">//  Check inputs</span>
03209     <span class="comment">//</span>
03210     
03211     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
03212 
03213     <a class="code" href="../../d3/d8/udfprocs_8h.html#a68">UdfUnpinView</a>( IrpContext, &amp;IcbContext-&gt;Active );
03214     <a class="code" href="../../d3/d8/udfprocs_8h.html#a68">UdfUnpinView</a>( IrpContext, &amp;IcbContext-&gt;Current );
03215 
03216     RtlZeroMemory( IcbContext, <span class="keyword">sizeof</span>( <a class="code" href="../../d9/d9/struct__ICB__SEARCH__CONTEXT.html">ICB_SEARCH_CONTEXT</a> ));
03217 }
03218 
03219 
03220 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l03221"></a><a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a26">03221</a> <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a26">UdfInitializeEaContext</a> (
03222     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
03223     IN <a class="code" href="../../d6/d1/struct__EA__SEARCH__CONTEXT.html">PEA_SEARCH_CONTEXT</a> EaContext,
03224     IN <a class="code" href="../../d9/d9/struct__ICB__SEARCH__CONTEXT.html">PICB_SEARCH_CONTEXT</a> IcbContext,
03225     IN ULONG EAType,
03226     IN UCHAR EASubType
03227     )
03228 
03229 <span class="comment">/*++</span>
03230 <span class="comment"></span>
03231 <span class="comment">Routine Description:</span>
03232 <span class="comment"></span>
03233 <span class="comment">    This routine initializes a walk through the EA space of an Icb which has been</span>
03234 <span class="comment">    previously discovered.</span>
03235 <span class="comment">    </span>
03236 <span class="comment">    Note: only the embedded EA space is supported now.</span>
03237 <span class="comment"></span>
03238 <span class="comment">Arguments:</span>
03239 <span class="comment"></span>
03240 <span class="comment">    EaContext - EA context to fill in</span>
03241 <span class="comment">    </span>
03242 <span class="comment">    IcbContext - Elaborated ICB search structure </span>
03243 <span class="comment"></span>
03244 <span class="comment">Return Value:</span>
03245 <span class="comment"></span>
03246 <span class="comment">--*/</span>
03247 
03248 {
03249     <a class="code" href="../../d8/d0/structICBFILE.html">PICBFILE</a> Icb;
03250 
03251     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
03252 
03253     <span class="comment">//</span>
03254     <span class="comment">//  Check inputs</span>
03255     <span class="comment">//</span>
03256     
03257     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
03258 
03259     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( IcbContext-&gt;Active.Bcb &amp;&amp; IcbContext-&gt;Active.View );
03260 
03261     Icb = IcbContext-&gt;Active.View;
03262 
03263     EaContext-&gt;IcbContext = IcbContext;
03264 
03265     <span class="comment">//</span>
03266     <span class="comment">//  Initialize to point at the first EA to return.</span>
03267     <span class="comment">//</span>
03268 
03269     EaContext-&gt;Ea = Icb-&gt;<a class="code" href="../../d8/d0/structICBFILE.html#o20">EAs</a>;
03270     EaContext-&gt;Remaining = Icb-&gt;<a class="code" href="../../d8/d0/structICBFILE.html#o18">EALength</a>;
03271 
03272     EaContext-&gt;EAType = EAType;
03273     EaContext-&gt;EASubType = EASubType;
03274 }
03275 
03276 
03277 BOOLEAN
<a name="l03278"></a><a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a27">03278</a> <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a27">UdfLookupEa</a> (
03279     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
03280     IN <a class="code" href="../../d6/d1/struct__EA__SEARCH__CONTEXT.html">PEA_SEARCH_CONTEXT</a> EaContext
03281     )
03282 
03283 <span class="comment">/*++</span>
03284 <span class="comment"></span>
03285 <span class="comment">Routine Description:</span>
03286 <span class="comment"></span>
03287 <span class="comment">    This routine finds an EA in the EA space of an ICB.</span>
03288 <span class="comment"></span>
03289 <span class="comment">Arguments:</span>
03290 <span class="comment"></span>
03291 <span class="comment">    EaContext - an initialized EA search context containing an elaborated</span>
03292 <span class="comment">        ICB search context and a description of the EA to find.</span>
03293 <span class="comment"></span>
03294 <span class="comment">Return Value:</span>
03295 <span class="comment"></span>
03296 <span class="comment">    BOOLEAN True if such an EA was found and returned, False otherwise.</span>
03297 <span class="comment"></span>
03298 <span class="comment">--*/</span>
03299 {
03300     <a class="code" href="../../d8/d0/structICBFILE.html">PICBFILE</a> Icb;
03301     <a class="code" href="../../d9/d1/structNSR__EA__GENERIC.html">PNSR_EA_GENERIC</a> GenericEa;
03302 
03303     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
03304 
03305     <span class="comment">//</span>
03306     <span class="comment">//  Check inputs</span>
03307     <span class="comment">//</span>
03308     
03309     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
03310 
03311     <span class="comment">//</span>
03312     <span class="comment">//  Quickly terminate if the EA space is empty or not capable of containing</span>
03313     <span class="comment">//  the header descriptor.  A null EA space is perfectly legal.</span>
03314     <span class="comment">//</span>
03315 
03316     <span class="keywordflow">if</span> (EaContext-&gt;Remaining == 0) {
03317 
03318         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03319     
03320     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (EaContext-&gt;Remaining &lt; <span class="keyword">sizeof</span>( <a class="code" href="../../d0/d2/structNSR__EAH.html">NSR_EAH</a> )) {
03321 
03322         <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, STATUS_FILE_CORRUPT_ERROR );
03323     }
03324 
03325     <span class="comment">//</span>
03326     <span class="comment">//  Verify the integrity of the EA header.  This has a side effect of making</span>
03327     <span class="comment">//  very sure that we really have an EA sequence underneath us.</span>
03328     <span class="comment">//</span>
03329 
03330     Icb = EaContext-&gt;IcbContext-&gt;Active.View;
03331 
03332     <a class="code" href="../../d3/d8/udfprocs_8h.html#a219">UdfVerifyDescriptor</a>( IrpContext,
03333                          &amp;((<a class="code" href="../../d0/d2/structNSR__EAH.html">PNSR_EAH</a>) EaContext-&gt;Ea)-&gt;Destag,
03334                          <a class="code" href="../../d0/d7/iso13346_8h.html#a55">DESTAG_ID_NSR_EA</a>,
03335                          <span class="keyword">sizeof</span>( <a class="code" href="../../d0/d2/structNSR__EAH.html">NSR_EAH</a> ),
03336                          Icb-&gt;<a class="code" href="../../d8/d0/structICBFILE.html#o0">Destag</a>.<a class="code" href="../../d7/d7/structDESTAG.html#o7">Lbn</a>,
03337                          <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
03338     
03339     <span class="comment">//</span>
03340     <span class="comment">//  Push forward the start of the EA space and loop while we have more EAs to inspect.</span>
03341     <span class="comment">//  Since we only scan for ISO EA's right now, we don't need to open the EA header to</span>
03342     <span class="comment">//  jump forward to the Implementation Use or Application Use segments.</span>
03343     <span class="comment">//</span>
03344 
03345     EaContext-&gt;Ea = <a class="code" href="../../d2/d7/notify_8c.html#a7">Add2Ptr</a>( EaContext-&gt;Ea, <span class="keyword">sizeof</span>( <a class="code" href="../../d0/d7/iso13346_8h.html#a247">NSR_EAH</a> ), PVOID );
03346     EaContext-&gt;Remaining -= <span class="keyword">sizeof</span>( <a class="code" href="../../d0/d7/iso13346_8h.html#a247">NSR_EAH</a> );
03347     
03348     <span class="keywordflow">while</span> (EaContext-&gt;Remaining) {
03349 
03350         GenericEa = EaContext-&gt;Ea;
03351 
03352         <span class="comment">//</span>
03353         <span class="comment">//  The EAs must appear on 4byte aligned boundaries, there must be room to find</span>
03354         <span class="comment">//  the generic EA preamble and the claimed length of the EA must fit in the</span>
03355         <span class="comment">//  remaining space.</span>
03356         <span class="comment">//</span>
03357         
03358         <span class="keywordflow">if</span> (<a class="code" href="../../d3/d8/udfprocs_8h.html#a30">LongOffsetPtr</a>( EaContext-&gt;Ea ) ||
03359             EaContext-&gt;Remaining &lt; FIELD_OFFSET( <a class="code" href="../../d9/d1/structNSR__EA__GENERIC.html">NSR_EA_GENERIC</a>, EAData ) ||
03360             EaContext-&gt;Remaining &lt; GenericEa-&gt;<a class="code" href="../../d9/d1/structNSR__EA__GENERIC.html#o3">EALength</a> ) {
03361         
03362             <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, STATUS_FILE_CORRUPT_ERROR );
03363         }
03364 
03365         <span class="keywordflow">if</span> (GenericEa-&gt;<a class="code" href="../../d9/d1/structNSR__EA__GENERIC.html#o0">EAType</a> == EaContext-&gt;EAType &amp;&amp; GenericEa-&gt;<a class="code" href="../../d9/d1/structNSR__EA__GENERIC.html#o1">EASubType</a> == EaContext-&gt;EASubType) {
03366 
03367             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03368         }
03369 
03370         EaContext-&gt;Ea = <a class="code" href="../../d2/d7/notify_8c.html#a7">Add2Ptr</a>( EaContext-&gt;Ea, GenericEa-&gt;<a class="code" href="../../d9/d1/structNSR__EA__GENERIC.html#o3">EALength</a>, PVOID );
03371         EaContext-&gt;Remaining -= GenericEa-&gt;<a class="code" href="../../d9/d1/structNSR__EA__GENERIC.html#o3">EALength</a>;
03372     }
03373 
03374     <span class="comment">//</span>
03375     <span class="comment">//  If we failed to find the EA, we should have stopped at the precise end of the EA space.</span>
03376     <span class="comment">//</span>
03377     
03378     <span class="keywordflow">if</span> (EaContext-&gt;Remaining) {
03379         
03380         <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, STATUS_FILE_CORRUPT_ERROR );
03381     }
03382 
03383     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03384 }
03385 
03386 
03387 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l03388"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a225">03388</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a225">UdfInitializeAllocations</a> (
03389     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
03390     IN <a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a> Fcb,
03391     IN <a class="code" href="../../d9/d9/struct__ICB__SEARCH__CONTEXT.html">PICB_SEARCH_CONTEXT</a> IcbContext
03392     )
03393 
03394 <span class="comment">/*++</span>
03395 <span class="comment"></span>
03396 <span class="comment">Routine Description:</span>
03397 <span class="comment"></span>
03398 <span class="comment">    This routine fills in the data retrieval information for an Fcb.</span>
03399 <span class="comment"></span>
03400 <span class="comment">Arguments:</span>
03401 <span class="comment"></span>
03402 <span class="comment">    Fcb - Fcb to add retrieval information to.</span>
03403 <span class="comment">    </span>
03404 <span class="comment">    IcbContext - Elaborated ICB search context corresponding to this Fcb.</span>
03405 <span class="comment"></span>
03406 <span class="comment">Return Value:</span>
03407 <span class="comment"></span>
03408 <span class="comment">    None.</span>
03409 <span class="comment"></span>
03410 <span class="comment">--*/</span>
03411 
03412 {
03413     <a class="code" href="../../d8/d0/structICBFILE.html">PICBFILE</a> Icb = IcbContext-&gt;Active.View;
03414     <a class="code" href="../../d2/d7/structSHORTAD.html">PAD_GENERIC</a> GenericAd;
03415     
03416     <a class="code" href="../../d2/d6/struct__ALLOC__ENUM__CONTEXT.html">ALLOC_ENUM_CONTEXT</a> AllocContext;
03417 
03418     LONGLONG RunningOffset;
03419     ULONG Psn;
03420     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> Partition;
03421 
03422     <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb = Fcb-&gt;Vcb;
03423 
03424     BOOLEAN Result;
03425     BOOLEAN InFileTail = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03426 
03427     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
03428 
03429     <span class="comment">//</span>
03430     <span class="comment">//  Check inputs</span>
03431     <span class="comment">//</span>
03432     
03433     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
03434     <a class="code" href="../../d1/d8/udfdata_8h.html#a14">ASSERT_FCB</a>( Fcb );
03435 
03436     <span class="comment">//</span>
03437     <span class="comment">//  Immediately return for objects with zero information space.  Note that</span>
03438     <span class="comment">//  passing this test does not indicate that the file has any recorded space.</span>
03439     <span class="comment">//</span>
03440 
03441     <span class="keywordflow">if</span> (Fcb-&gt;FileSize.QuadPart == 0) {
03442 
03443         <span class="keywordflow">return</span>;
03444     }
03445 
03446     <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a22">UdfInitializeAllocationContext</a>( IrpContext,
03447                                     &amp;AllocContext,
03448                                     IcbContext );
03449 
03450     <span class="comment">//</span>
03451     <span class="comment">//  Handle the case of embedded data.</span>
03452     <span class="comment">//</span>
03453 
03454     <span class="keywordflow">if</span> (AllocContext.<a class="code" href="../../d2/d6/struct__ALLOC__ENUM__CONTEXT.html#o2">AllocType</a> == <a class="code" href="../../d0/d7/iso13346_8h.html#a115">ICBTAG_F_ALLOC_IMMEDIATE</a>) {
03455 
03456         <span class="comment">//</span>
03457         <span class="comment">//  Teardown any existing mcb.</span>
03458         <span class="comment">//</span>
03459 
03460         <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a16">UdfUninitializeFcbMcb</a>( Fcb );
03461         
03462         <span class="comment">//</span>
03463         <span class="comment">//  Establish a single block mapping to the Icb itself and mark the Fcb as</span>
03464         <span class="comment">//  having embedded data.  Mapping will occur through the Metadata stream.</span>
03465         <span class="comment">//  Note that by virtue of having an Icb here we know it has already had</span>
03466         <span class="comment">//  a mapping established in the Metadata stream, so just retrieve that.</span>
03467         <span class="comment">//</span>
03468 
03469         <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( Fcb-&gt;FcbState, <a class="code" href="../../d6/d8/udfstruc_8h.html#a16">FCB_STATE_EMBEDDED_DATA</a> );
03470 
03471         Fcb-&gt;EmbeddedVsn = <a class="code" href="../../d3/d8/udfprocs_8h.html#a153">UdfLookupMetaVsnOfExtent</a>( IrpContext,
03472                                                      Vcb,
03473                                                      IcbContext-&gt;Active.Partition,
03474                                                      Icb-&gt;<a class="code" href="../../d8/d0/structICBFILE.html#o0">Destag</a>.<a class="code" href="../../d7/d7/structDESTAG.html#o7">Lbn</a>,
03475                                                      <a class="code" href="../../d3/d8/udfprocs_8h.html#a54">BlockSize</a>( Vcb ),
03476                                                      <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
03477         
03478         <span class="comment">//</span>
03479         <span class="comment">//  Note the offset of the data in the Icb.</span>
03480         <span class="comment">//</span>
03481 
03482         Fcb-&gt;EmbeddedOffset = FIELD_OFFSET( <a class="code" href="../../d8/d0/structICBFILE.html">ICBFILE</a>, EAs ) + Icb-&gt;<a class="code" href="../../d8/d0/structICBFILE.html#o18">EALength</a>;
03483 
03484         <span class="comment">//</span>
03485         <span class="comment">//  Check that the information length agrees.</span>
03486         <span class="comment">//</span>
03487 
03488         <span class="keywordflow">if</span> (Icb-&gt;<a class="code" href="../../d8/d0/structICBFILE.html#o19">AllocLength</a> != Fcb-&gt;FileSize.LowPart) {
03489 
03490             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfInitializeAllocations, embedded alloc %08x != filesize %08x\n"</span>,
03491                          Icb-&gt;<a class="code" href="../../d8/d0/structICBFILE.html#o19">AllocLength</a>,
03492                          Fcb-&gt;FileSize.LowPart ));
03493             <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, STATUS_FILE_CORRUPT_ERROR );
03494         }
03495 
03496         <span class="keywordflow">return</span>;
03497     }
03498 
03499     <span class="comment">//</span>
03500     <span class="comment">//  Now initialize the mapping structure for this Fcb.</span>
03501     <span class="comment">//</span>
03502 
03503     <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a15">UdfInitializeFcbMcb</a>( Fcb );
03504 
03505     <span class="comment">//</span>
03506     <span class="comment">//  Now walk the chain of allocation descriptors for the object, adding them into the</span>
03507     <span class="comment">//  mapping.</span>
03508     <span class="comment">//</span>
03509 
03510     RunningOffset = 0;
03511 
03512     <span class="keywordflow">do</span> {
03513         
03514         <span class="comment">//</span>
03515         <span class="comment">//  Do file tail consistency checking (4/12.1).  We will have a file body</span>
03516         <span class="comment">//  which is exactly the size of the information length, and a run of allocated</span>
03517         <span class="comment">//  but unrecorded space following.</span>
03518         <span class="comment">//</span>
03519         
03520         <span class="keywordflow">if</span> (Fcb-&gt;FileSize.QuadPart == RunningOffset) {
03521 
03522             InFileTail = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03523         }
03524         
03525         <span class="comment">//</span>
03526         <span class="comment">//  It is impermissible for an interior body extent of an object to not be</span>
03527         <span class="comment">//  an integral multiple of a logical block in size (note that the last</span>
03528         <span class="comment">//  will tend to be).  Also check that the body didn't overshoot the information</span>
03529         <span class="comment">//  length and that the tail descriptor type is correct.</span>
03530         <span class="comment">//</span>
03531         
03532         GenericAd = AllocContext.<a class="code" href="../../d2/d6/struct__ALLOC__ENUM__CONTEXT.html#o1">Alloc</a>;
03533 
03534         <span class="keywordflow">if</span> ((!InFileTail &amp;&amp; (<a class="code" href="../../d3/d8/udfprocs_8h.html#a55">BlockOffset</a>( Vcb, RunningOffset ) ||
03535                              Fcb-&gt;FileSize.QuadPart &lt; RunningOffset)) ||
03536             (InFileTail &amp;&amp; GenericAd-&gt;<a class="code" href="../../d2/d7/structSHORTAD.html#o0">Length</a>.<a class="code" href="../../d7/d3/structNSRLENGTH.html#o1">Type</a> != <a class="code" href="../../d0/d7/iso13346_8h.html#a22">NSRLENGTH_TYPE_UNRECORDED</a>)) {
03537 
03538             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfInitializeAllocations, InFileTail == %u, bad alloc\n"</span>,
03539                          InFileTail ));
03540             <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, STATUS_FILE_CORRUPT_ERROR );
03541         }
03542 
03543         <span class="comment">//</span>
03544         <span class="comment">//  In the file tail we'll just slum along an be a nitpick.  Technically, as a</span>
03545         <span class="comment">//  readonly implementation I don't have to care at all about what is here.</span>
03546         <span class="comment">//</span>
03547             
03548         <span class="keywordflow">if</span> (InFileTail) {
03549             
03550             <span class="keywordflow">continue</span>;
03551         }
03552             
03553         <span class="comment">//</span>
03554         <span class="comment">//  Based on the descriptor type, pull it apart and add the mapping.</span>
03555         <span class="comment">//</span>
03556 
03557         <span class="keywordflow">if</span> (GenericAd-&gt;<a class="code" href="../../d2/d7/structSHORTAD.html#o0">Length</a>.<a class="code" href="../../d7/d3/structNSRLENGTH.html#o1">Type</a> == <a class="code" href="../../d0/d7/iso13346_8h.html#a21">NSRLENGTH_TYPE_RECORDED</a>) {
03558 
03559             <span class="comment">//</span>
03560             <span class="comment">//  Grab the Psn this extent starts at and add the allocation.</span>
03561             <span class="comment">//</span>
03562 
03563             Psn = <a class="code" href="../../d3/d8/udfprocs_8h.html#a152">UdfLookupPsnOfExtent</a>( IrpContext,
03564                                         Vcb,
03565                                         <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a14">UdfGetPartitionOfCurrentAllocation</a>( &amp;AllocContext ),
03566                                         GenericAd-&gt;<a class="code" href="../../d2/d7/structSHORTAD.html#o1">Start</a>,
03567                                         GenericAd-&gt;<a class="code" href="../../d2/d7/structSHORTAD.html#o0">Length</a>.<a class="code" href="../../d7/d3/structNSRLENGTH.html#o0">Length</a> );
03568 
03569             Result = <a class="code" href="../../d1/d8/fsrtl_8h.html#a143">FsRtlAddLargeMcbEntry</a>( &amp;Fcb-&gt;Mcb,
03570                                             <a class="code" href="../../d3/d8/udfprocs_8h.html#a40">LlSectorsFromBytes</a>( Vcb, RunningOffset ),
03571                                             Psn,
03572                                             <a class="code" href="../../d3/d8/fsrtlp_8h.html#a13">SectorsFromBytes</a>( Vcb, <a class="code" href="../../d3/d8/fsrtlp_8h.html#a12">SectorAlign</a>( Vcb, GenericAd-&gt;<a class="code" href="../../d2/d7/structSHORTAD.html#o0">Length</a>.<a class="code" href="../../d7/d3/structNSRLENGTH.html#o0">Length</a> ) ));
03573 
03574             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( Result );
03575         }
03576 
03577         RunningOffset += GenericAd-&gt;<a class="code" href="../../d2/d7/structSHORTAD.html#o0">Length</a>.<a class="code" href="../../d7/d3/structNSRLENGTH.html#o0">Length</a>;
03578     
03579     } <span class="keywordflow">while</span> ( <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a23">UdfGetNextAllocation</a>( IrpContext, &amp;AllocContext ));
03580 
03581     <span class="comment">//</span>
03582     <span class="comment">//  We must have had body allocation descriptors for the entire file</span>
03583     <span class="comment">//  information length.</span>
03584     <span class="comment">//</span>
03585 
03586     <span class="keywordflow">if</span> (Fcb-&gt;FileSize.QuadPart != RunningOffset) {
03587 
03588         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfInitializeAllocations, total descriptors != filesize\n"</span> ));
03589         <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, STATUS_FILE_CORRUPT_ERROR );
03590     }
03591 }
03592 
03593 
03594 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l03595"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a226">03595</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a226">UdfUpdateTimestampsFromIcbContext</a> (
03596     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
03597     IN <a class="code" href="../../d9/d9/struct__ICB__SEARCH__CONTEXT.html">PICB_SEARCH_CONTEXT</a> IcbContext,
03598     IN <a class="code" href="../../d4/d1/struct__TIMESTAMP__BUNDLE.html">PTIMESTAMP_BUNDLE</a> Timestamps
03599     )
03600 
03601 <span class="comment">/*++</span>
03602 <span class="comment"></span>
03603 <span class="comment">Routine Description:</span>
03604 <span class="comment"></span>
03605 <span class="comment">    This routine converts the set of timestamps associated with a given ICB into</span>
03606 <span class="comment">    an NT native form.</span>
03607 <span class="comment"></span>
03608 <span class="comment">Arguments:</span>
03609 <span class="comment"></span>
03610 <span class="comment">    IcbOontext - An search context containing the active direct ICB for the object</span>
03611 <span class="comment">    </span>
03612 <span class="comment">    Timestamps - the bundle of timestamps to receive the converted times.</span>
03613 <span class="comment"></span>
03614 <span class="comment">Return Value:</span>
03615 <span class="comment"></span>
03616 <span class="comment">    None.</span>
03617 <span class="comment"></span>
03618 <span class="comment">--*/</span>
03619 
03620 {
03621     <a class="code" href="../../d6/d1/struct__EA__SEARCH__CONTEXT.html">EA_SEARCH_CONTEXT</a> EaContext;
03622     <a class="code" href="../../d8/d0/structICBFILE.html">PICBFILE</a> Icb;
03623 
03624     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
03625 
03626     <span class="comment">//</span>
03627     <span class="comment">//  Check inputs</span>
03628     <span class="comment">//</span>
03629 
03630     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
03631 
03632     <span class="comment">//</span>
03633     <span class="comment">//  Directly reference for convenience.</span>
03634     <span class="comment">//</span>
03635 
03636     Icb = IcbContext-&gt;Active.View;
03637 
03638     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( Icb-&gt;<a class="code" href="../../d8/d0/structICBFILE.html#o0">Destag</a>.<a class="code" href="../../d7/d7/structDESTAG.html#o0">Ident</a> == <a class="code" href="../../d0/d7/iso13346_8h.html#a54">DESTAG_ID_NSR_FILE</a> );
03639 
03640     <span class="comment">//</span>
03641     <span class="comment">//  Initialize the timestamps for this object.  Due to basic idiocy in ISO 13346,</span>
03642     <span class="comment">//  we must gather EAs and figure out which of several timestamps is most valid.</span>
03643     <span class="comment">//</span>
03644 
03645     <span class="comment">//</span>
03646     <span class="comment">//  Begin by using the fields in the ICB itself.</span>
03647     <span class="comment">//</span>
03648 
03649     <a class="code" href="../../d3/d8/udfprocs_8h.html#a228">UdfConvertUdfTimeToNtTime</a>( IrpContext,
03650                                &amp;Icb-&gt;<a class="code" href="../../d8/d0/structICBFILE.html#o12">ModifyTime</a>,
03651                                (PLARGE_INTEGER) &amp;Timestamps-&gt;ModificationTime );
03652 
03653     Timestamps-&gt;CreationTime = Timestamps-&gt;ModificationTime;
03654 
03655     <a class="code" href="../../d3/d8/udfprocs_8h.html#a228">UdfConvertUdfTimeToNtTime</a>( IrpContext,
03656                                &amp;Icb-&gt;<a class="code" href="../../d8/d0/structICBFILE.html#o11">AccessTime</a>,
03657                                (PLARGE_INTEGER) &amp;Timestamps-&gt;AccessTime );
03658 
03659     <span class="comment">//</span>
03660     <span class="comment">//  Gather the File Times and Information Times EAs for this object, if they exist,</span>
03661     <span class="comment">//  and set the timestamps.  Just override timestamps if they exist.</span>
03662     <span class="comment">//</span>
03663 
03664     <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a26">UdfInitializeEaContext</a>( IrpContext,
03665                             &amp;EaContext,
03666                             IcbContext,
03667                             <a class="code" href="../../d0/d7/iso13346_8h.html#a144">EA_TYPE_FILETIMES</a>,
03668                             <a class="code" href="../../d0/d7/iso13346_8h.html#a149">EA_SUBTYPE_BASE</a> );
03669 
03670     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a27">UdfLookupEa</a>( IrpContext, &amp;EaContext )) {
03671 
03672         <a class="code" href="../../d8/d1/structNSR__EA__FILETIMES.html">PNSR_EA_FILETIMES</a> FileTimes = EaContext.<a class="code" href="../../d6/d1/struct__EA__SEARCH__CONTEXT.html#o1">Ea</a>;
03673     
03674         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(FileTimes-&gt;<a class="code" href="../../d8/d1/structNSR__EA__FILETIMES.html#o5">Existence</a>, <a class="code" href="../../d0/d7/iso13346_8h.html#a150">EA_FILETIMES_E_CREATION</a>)) {
03675 
03676             <a class="code" href="../../d3/d8/udfprocs_8h.html#a228">UdfConvertUdfTimeToNtTime</a>( IrpContext,
03677                                        &amp;FileTimes-&gt;<a class="code" href="../../d8/d1/structNSR__EA__FILETIMES.html#o6">Stamps</a>[0],
03678                                        (PLARGE_INTEGER) &amp;Timestamps-&gt;CreationTime );
03679         }
03680     }
03681 
03682     <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a26">UdfInitializeEaContext</a>( IrpContext,
03683                             &amp;EaContext,
03684                             IcbContext,
03685                             <a class="code" href="../../d0/d7/iso13346_8h.html#a145">EA_TYPE_INFOTIMES</a>,
03686                             <a class="code" href="../../d0/d7/iso13346_8h.html#a149">EA_SUBTYPE_BASE</a> );
03687 
03688     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a27">UdfLookupEa</a>( IrpContext, &amp;EaContext )) {
03689 
03690         <a class="code" href="../../d8/d1/structNSR__EA__FILETIMES.html">PNSR_EA_FILETIMES</a> InfoTimes = EaContext.<a class="code" href="../../d6/d1/struct__EA__SEARCH__CONTEXT.html#o1">Ea</a>;
03691         BOOLEAN CreationPresent = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03692 
03693         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(InfoTimes-&gt;<a class="code" href="../../d8/d1/structNSR__EA__FILETIMES.html#o5">Existence</a>, <a class="code" href="../../d0/d7/iso13346_8h.html#a154">EA_INFOTIMES_E_CREATION</a>)) {
03694 
03695             <a class="code" href="../../d3/d8/udfprocs_8h.html#a228">UdfConvertUdfTimeToNtTime</a>( IrpContext,
03696                                        &amp;InfoTimes-&gt;<a class="code" href="../../d8/d1/structNSR__EA__FILETIMES.html#o6">Stamps</a>[0],
03697                                        (PLARGE_INTEGER) &amp;Timestamps-&gt;CreationTime );
03698 
03699             CreationPresent = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03700         }
03701 
03702         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(InfoTimes-&gt;<a class="code" href="../../d8/d1/structNSR__EA__FILETIMES.html#o5">Existence</a>, <a class="code" href="../../d0/d7/iso13346_8h.html#a155">EA_INFOTIMES_E_MODIFICATION</a>)) {
03703 
03704             <a class="code" href="../../d3/d8/udfprocs_8h.html#a228">UdfConvertUdfTimeToNtTime</a>( IrpContext,
03705                                        &amp;InfoTimes-&gt;<a class="code" href="../../d8/d1/structNSR__EA__FILETIMES.html#o6">Stamps</a>[CreationPresent? 1: 0],
03706                                        (PLARGE_INTEGER) &amp;Timestamps-&gt;CreationTime );
03707         }
03708     }
03709 }
03710 
03711 
03712 BOOLEAN
<a name="l03713"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a227">03713</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a227">UdfCreateFileLock</a> (
03714     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext OPTIONAL,
03715     IN <a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a> Fcb,
03716     IN BOOLEAN RaiseOnError
03717     )
03718 
03719 <span class="comment">/*++</span>
03720 <span class="comment"></span>
03721 <span class="comment">Routine Description:</span>
03722 <span class="comment"></span>
03723 <span class="comment">    This routine is called when we want to attach a file lock structure to the</span>
03724 <span class="comment">    given Fcb.  It is possible the file lock is already attached.</span>
03725 <span class="comment"></span>
03726 <span class="comment">    This routine is sometimes called from the fast path and sometimes in the</span>
03727 <span class="comment">    Irp-based path.  We don't want to raise in the fast path, just return FALSE.</span>
03728 <span class="comment"></span>
03729 <span class="comment">Arguments:</span>
03730 <span class="comment"></span>
03731 <span class="comment">    Fcb - This is the Fcb to create the file lock for.</span>
03732 <span class="comment"></span>
03733 <span class="comment">    RaiseOnError - If TRUE, we will raise on an allocation failure.  Otherwise we</span>
03734 <span class="comment">        return FALSE on an allocation failure.</span>
03735 <span class="comment"></span>
03736 <span class="comment">Return Value:</span>
03737 <span class="comment"></span>
03738 <span class="comment">    BOOLEAN - TRUE if the Fcb has a filelock, FALSE otherwise.</span>
03739 <span class="comment"></span>
03740 <span class="comment">--*/</span>
03741 
03742 {
03743     BOOLEAN Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03744     <a class="code" href="../../d7/d1/struct__FILE__LOCK.html">PFILE_LOCK</a> FileLock;
03745 
03746     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
03747 
03748     <span class="comment">//</span>
03749     <span class="comment">//  Lock the Fcb and check if there is really any work to do.</span>
03750     <span class="comment">//</span>
03751 
03752     <a class="code" href="../../d3/d8/udfprocs_8h.html#a90">UdfLockFcb</a>( IrpContext, Fcb );
03753 
03754     <span class="keywordflow">if</span> (Fcb-&gt;FileLock != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03755 
03756         <a class="code" href="../../d3/d8/udfprocs_8h.html#a91">UdfUnlockFcb</a>( IrpContext, Fcb );
03757         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03758     }
03759 
03760     Fcb-&gt;FileLock = FileLock =
03761         <a class="code" href="../../d1/d8/fsrtl_8h.html#a112">FsRtlAllocateFileLock</a>( <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
03762 
03763     <a class="code" href="../../d3/d8/udfprocs_8h.html#a91">UdfUnlockFcb</a>( IrpContext, Fcb );
03764 
03765     <span class="comment">//</span>
03766     <span class="comment">//  Return or raise as appropriate.</span>
03767     <span class="comment">//</span>
03768 
03769     <span class="keywordflow">if</span> (FileLock == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03770          
03771         <span class="keywordflow">if</span> (RaiseOnError) {
03772 
03773             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( ARGUMENT_PRESENT( IrpContext ));
03774 
03775             <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
03776         }
03777 
03778         Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03779     }
03780 
03781     <span class="keywordflow">return</span> Result;
03782 }
03783 
03784 
03785 <span class="comment">//</span>
03786 <span class="comment">//  Local support routine</span>
03787 <span class="comment">//</span>
03788 
03789 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l03790"></a><a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a25">03790</a> <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a25">UdfLookupActiveIcbInExtent</a> (
03791     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
03792     IN <a class="code" href="../../d9/d9/struct__ICB__SEARCH__CONTEXT.html">PICB_SEARCH_CONTEXT</a> IcbContext,
03793     IN ULONG Recurse
03794     )
03795 
03796 <span class="comment">/*++</span>
03797 <span class="comment"></span>
03798 <span class="comment">Routine Description:</span>
03799 <span class="comment"></span>
03800 <span class="comment">    This routine is called to traverse a single Icb hierarchy extent to discover</span>
03801 <span class="comment">    an active Icb.  This is a recursive operation on indirect Icbs that may be</span>
03802 <span class="comment">    found in the sequence.</span>
03803 <span class="comment">    </span>
03804 <span class="comment">Arguments:</span>
03805 <span class="comment"></span>
03806 <span class="comment">    IcbContext - Context which has been initialized to point into an Icb hierarchy.</span>
03807 <span class="comment">    </span>
03808 <span class="comment">    Recurse - Recursion limit. </span>
03809 <span class="comment"></span>
03810 <span class="comment">Return Value:</span>
03811 <span class="comment"></span>
03812 <span class="comment">    None.</span>
03813 <span class="comment">    </span>
03814 <span class="comment">    Raised status if the Icb hierarchy is invalid.</span>
03815 <span class="comment"></span>
03816 <span class="comment">--*/</span>
03817 
03818 {
03819     <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb = IcbContext-&gt;Vcb;
03820     <a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a> Fcb = Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o22">MetadataFcb</a>;
03821 
03822     ULONG Length;
03823     ULONG Lbn;
03824     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> Partition;
03825 
03826     ULONG Vsn;
03827 
03828     <a class="code" href="../../d9/d0/structICBIND.html">PICBIND</a> Icb;
03829 
03830     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
03831 
03832     <span class="comment">//</span>
03833     <span class="comment">//  Decrement our recursion allowance.</span>
03834     <span class="comment">//</span>
03835     
03836     Recurse--;
03837 
03838     <span class="comment">//</span>
03839     <span class="comment">//  Grab our starting point</span>
03840     <span class="comment">//</span>
03841 
03842     Partition = IcbContext-&gt;Current.Partition;
03843     Lbn = IcbContext-&gt;Current.Lbn;
03844     Length = IcbContext-&gt;Current.Length;
03845 
03846     Icb = IcbContext-&gt;Current.View;
03847 
03848     <span class="comment">//</span>
03849     <span class="comment">//  Walk across the extent</span>
03850     <span class="comment">//</span>
03851 
03852     <span class="keywordflow">do</span> {
03853         
03854         <span class="keywordflow">switch</span> (Icb-&gt;<a class="code" href="../../d9/d0/structICBIND.html#o0">Destag</a>.<a class="code" href="../../d7/d7/structDESTAG.html#o0">Ident</a>) {
03855                         
03856             <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/iso13346_8h.html#a52">DESTAG_ID_NSR_ICBIND</a>:
03857 
03858                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a219">UdfVerifyDescriptor</a>( IrpContext,
03859                                      &amp;Icb-&gt;<a class="code" href="../../d9/d0/structICBIND.html#o0">Destag</a>,
03860                                      <a class="code" href="../../d0/d7/iso13346_8h.html#a52">DESTAG_ID_NSR_ICBIND</a>,
03861                                      <span class="keyword">sizeof</span>( <a class="code" href="../../d9/d0/structICBIND.html">ICBIND</a> ),
03862                                      Lbn,
03863                                      <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
03864 
03865                 <span class="comment">//</span>
03866                 <span class="comment">//  Go to the next extent if this indirect Icb actually points to something.</span>
03867                 <span class="comment">//</span>
03868 
03869                 <span class="keywordflow">if</span> (Icb-&gt;<a class="code" href="../../d9/d0/structICBIND.html#o2">Icb</a>.<a class="code" href="../../d4/d9/structLONGAD.html#o0">Length</a>.<a class="code" href="../../d7/d3/structNSRLENGTH.html#o1">Type</a> == <a class="code" href="../../d0/d7/iso13346_8h.html#a21">NSRLENGTH_TYPE_RECORDED</a>) {
03870 
03871                     <span class="comment">//</span>
03872                     <span class="comment">//  If we are in the last entry of the Icb extent, we may tail recurse. This</span>
03873                     <span class="comment">//  is very important for strategy 4096, which is a linked list of extents</span>
03874                     <span class="comment">//  of depth equal to the number of times the direct Icb had to be re-recorded.</span>
03875                     <span class="comment">//</span>
03876 
03877                     <a class="code" href="../../d3/d8/udfprocs_8h.html#a157">UdfMapMetadataView</a>( IrpContext,
03878                                         &amp;IcbContext-&gt;Current,
03879                                         Vcb,
03880                                         Icb-&gt;<a class="code" href="../../d9/d0/structICBIND.html#o2">Icb</a>.<a class="code" href="../../d4/d9/structLONGAD.html#o1">Start</a>.<a class="code" href="../../d6/d3/structNSRLBA.html#o1">Partition</a>,
03881                                         Icb-&gt;<a class="code" href="../../d9/d0/structICBIND.html#o2">Icb</a>.<a class="code" href="../../d4/d9/structLONGAD.html#o1">Start</a>.<a class="code" href="../../d6/d3/structNSRLBA.html#o0">Lbn</a>,
03882                                         Icb-&gt;<a class="code" href="../../d9/d0/structICBIND.html#o2">Icb</a>.<a class="code" href="../../d4/d9/structLONGAD.html#o0">Length</a>.<a class="code" href="../../d7/d3/structNSRLENGTH.html#o0">Length</a> );
03883 
03884                     <span class="keywordflow">if</span> (Length != <a class="code" href="../../d3/d8/udfprocs_8h.html#a54">BlockSize</a>( Vcb )) {
03885 
03886                         <span class="comment">//</span>
03887                         <span class="comment">//  We have to give up on this if we're going too deep.</span>
03888                         <span class="comment">//</span>
03889                         
03890                         <span class="keywordflow">if</span> (Recurse == 0) {
03891                             
03892                             <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, STATUS_FILE_CORRUPT_ERROR );
03893                         }
03894 
03895                         <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a25">UdfLookupActiveIcbInExtent</a>( IrpContext,
03896                                                     IcbContext,
03897                                                     Recurse );
03898 
03899                         <span class="comment">//</span>
03900                         <span class="comment">//  Need to remap the extent we were working on.</span>
03901                         <span class="comment">//</span>
03902     
03903                         <a class="code" href="../../d3/d8/udfprocs_8h.html#a157">UdfMapMetadataView</a>( IrpContext,
03904                                             &amp;IcbContext-&gt;Current,
03905                                             Vcb,
03906                                             Partition,
03907                                             Lbn,
03908                                             Length );
03909                     } <span class="keywordflow">else</span> {
03910 
03911                         <span class="comment">//</span>
03912                         <span class="comment">//  Tail recursion was possible so adjust our pointers and restart the scan.</span>
03913                         <span class="comment">//</span>
03914 
03915                         Partition = IcbContext-&gt;Current.Partition;
03916                         Lbn = IcbContext-&gt;Current.Lbn;
03917                         Length = IcbContext-&gt;Current.Length;
03918                         
03919                         Icb = IcbContext-&gt;Current.View;
03920                         
03921                         <span class="keywordflow">continue</span>;
03922                     }
03923 
03924                 }
03925 
03926                 <span class="keywordflow">break</span>;
03927 
03928             <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/iso13346_8h.html#a53">DESTAG_ID_NSR_ICBTRM</a>:
03929 
03930                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a219">UdfVerifyDescriptor</a>( IrpContext,
03931                                      &amp;Icb-&gt;<a class="code" href="../../d9/d0/structICBIND.html#o0">Destag</a>,
03932                                      <a class="code" href="../../d0/d7/iso13346_8h.html#a53">DESTAG_ID_NSR_ICBTRM</a>,
03933                                      <span class="keyword">sizeof</span>( <a class="code" href="../../d2/d1/structICBTRM.html">ICBTRM</a> ),
03934                                      Lbn,
03935                                      <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
03936 
03937                 <span class="comment">//</span>
03938                 <span class="comment">//  Terminate the current extent.</span>
03939                 <span class="comment">//</span>
03940 
03941                 <span class="keywordflow">return</span>;
03942                 <span class="keywordflow">break</span>;
03943 
03944             <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/iso13346_8h.html#a37">DESTAG_ID_NOTSPEC</a>:
03945 
03946                 <span class="comment">//</span>
03947                 <span class="comment">//  Perhaps this is an unrecorded sector.  Treat this as terminating</span>
03948                 <span class="comment">//  the current extent.</span>
03949                 <span class="comment">//</span>
03950 
03951                 <span class="keywordflow">return</span>;
03952                 <span class="keywordflow">break</span>;
03953 
03954             <span class="keywordflow">default</span>:
03955 
03956                 <span class="comment">//</span>
03957                 <span class="comment">//  This is a data-full Icb.  It must be of the expected type.</span>
03958                 <span class="comment">//</span>
03959                 
03960                 <span class="keywordflow">if</span> (Icb-&gt;<a class="code" href="../../d9/d0/structICBIND.html#o0">Destag</a>.<a class="code" href="../../d7/d7/structDESTAG.html#o0">Ident</a> != IcbContext-&gt;IcbType) {
03961                     
03962                     <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, STATUS_FILE_CORRUPT_ERROR );
03963                 }
03964 
03965                 <span class="comment">//</span>
03966                 <span class="comment">//  Since direct entries are of variable size, we must allow up to</span>
03967                 <span class="comment">//  a block's worth of data.</span>
03968                 <span class="comment">//</span>
03969 
03970                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a219">UdfVerifyDescriptor</a>( IrpContext,
03971                                      &amp;Icb-&gt;<a class="code" href="../../d9/d0/structICBIND.html#o0">Destag</a>,
03972                                      Icb-&gt;<a class="code" href="../../d9/d0/structICBIND.html#o0">Destag</a>.<a class="code" href="../../d7/d7/structDESTAG.html#o0">Ident</a>,
03973                                      <a class="code" href="../../d3/d8/udfprocs_8h.html#a54">BlockSize</a>( Vcb ),
03974                                      Lbn,
03975                                      <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
03976                 <span class="comment">//</span>
03977                 <span class="comment">//  We perform an in-order traversal of the hierarchy.  This is important since</span>
03978                 <span class="comment">//  it means no tricks are neccesary to figure out the rightmost direct Icb -</span>
03979                 <span class="comment">//  always stash the last one we see.</span>
03980                 <span class="comment">//</span>
03981                 <span class="comment">//  Map this logical block into the active slot.  We know that a direct entry</span>
03982                 <span class="comment">//  must fit in a single logical block.</span>
03983                 <span class="comment">//</span>
03984 
03985                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a157">UdfMapMetadataView</a>( IrpContext,
03986                                     &amp;IcbContext-&gt;Active,
03987                                     Vcb,
03988                                     Partition,
03989                                     Lbn,
03990                                     <a class="code" href="../../d3/d8/udfprocs_8h.html#a54">BlockSize</a>( Vcb ) );
03991 
03992                 <span class="keywordflow">break</span>;
03993         }
03994 
03995         <span class="comment">//</span>
03996         <span class="comment">//  Advance our pointer set.</span>
03997         <span class="comment">//</span>
03998 
03999         Lbn++;
04000         Length -= <a class="code" href="../../d3/d8/udfprocs_8h.html#a54">BlockSize</a>( Vcb );
04001 
04002         Icb = <a class="code" href="../../d2/d7/notify_8c.html#a7">Add2Ptr</a>( Icb, <a class="code" href="../../d3/d8/udfprocs_8h.html#a54">BlockSize</a>( Vcb ), PVOID );
04003 
04004     } <span class="keywordflow">while</span> (Length);
04005 }
04006 
04007 
04008 <span class="comment">//</span>
04009 <span class="comment">//  Local support routine</span>
04010 <span class="comment">//</span>
04011 
04012 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l04013"></a><a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a22">04013</a> <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a22">UdfInitializeAllocationContext</a> (
04014     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
04015     IN <a class="code" href="../../d2/d6/struct__ALLOC__ENUM__CONTEXT.html">PALLOC_ENUM_CONTEXT</a> AllocContext,
04016     IN <a class="code" href="../../d9/d9/struct__ICB__SEARCH__CONTEXT.html">PICB_SEARCH_CONTEXT</a> IcbContext
04017     )
04018 
04019 <span class="comment">/*++</span>
04020 <span class="comment"></span>
04021 <span class="comment">Routine Description:</span>
04022 <span class="comment"></span>
04023 <span class="comment">    Initializes a walk of the allocation descriptors for an ICB which has already</span>
04024 <span class="comment">    been found.  The first allocation descriptor will be avaliable after the call.</span>
04025 <span class="comment"></span>
04026 <span class="comment">Arguments:</span>
04027 <span class="comment"></span>
04028 <span class="comment">    AllocContext - Allocation enumeration context to use</span>
04029 <span class="comment">    </span>
04030 <span class="comment">    IcbContext - Elaborated ICB search context for the ICB to enumerate</span>
04031 <span class="comment"></span>
04032 <span class="comment">Return Value:</span>
04033 <span class="comment"></span>
04034 <span class="comment">    None.</span>
04035 <span class="comment"></span>
04036 <span class="comment">--*/</span>
04037 
04038 {
04039     <a class="code" href="../../d8/d0/structICBFILE.html">PICBFILE</a> Icb;
04040 
04041     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
04042 
04043     <span class="comment">//</span>
04044     <span class="comment">//  Check inputs</span>
04045     <span class="comment">//</span>
04046     
04047     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
04048 
04049     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( IcbContext-&gt;Active.View );
04050 
04051     AllocContext-&gt;IcbContext = IcbContext;
04052 
04053     <span class="comment">//</span>
04054     <span class="comment">//  Figure out what kind of descriptors will be here.</span>
04055     <span class="comment">//</span>
04056 
04057     Icb = IcbContext-&gt;Active.View;
04058     AllocContext-&gt;AllocType = <a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( Icb-&gt;<a class="code" href="../../d8/d0/structICBFILE.html#o1">Icbtag</a>.<a class="code" href="../../d1/d1/structICBTAG.html#o7">Flags</a>, <a class="code" href="../../d0/d7/iso13346_8h.html#a111">ICBTAG_F_ALLOC_MASK</a> );
04059 
04060     <span class="comment">//</span>
04061     <span class="comment">//  We are done if this is actually immediate data.</span>
04062     <span class="comment">//</span>
04063     
04064     <span class="keywordflow">if</span> (AllocContext-&gt;AllocType == <a class="code" href="../../d0/d7/iso13346_8h.html#a115">ICBTAG_F_ALLOC_IMMEDIATE</a>) {
04065 
04066         <span class="keywordflow">return</span>;
04067     }
04068     
04069     <span class="comment">//</span>
04070     <span class="comment">//  The initial chunk of allocation descriptors is inline with the ICB and</span>
04071     <span class="comment">//  does not contain an Allocation Extent Descriptor.</span>
04072     <span class="comment">//</span>
04073 
04074     AllocContext-&gt;Alloc = <a class="code" href="../../d2/d7/notify_8c.html#a7">Add2Ptr</a>( Icb-&gt;<a class="code" href="../../d8/d0/structICBFILE.html#o20">EAs</a>, Icb-&gt;<a class="code" href="../../d8/d0/structICBFILE.html#o18">EALength</a>, PVOID );
04075     AllocContext-&gt;Remaining = Icb-&gt;<a class="code" href="../../d8/d0/structICBFILE.html#o19">AllocLength</a>;
04076 
04077     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d3/d8/udfprocs_8h.html#a30">LongOffsetPtr</a>( AllocContext-&gt;Alloc ) == 0 );
04078     
04079     <span class="comment">//</span>
04080     <span class="comment">//  Check that an integral number of the appropriate allocation descriptors fit in</span>
04081     <span class="comment">//  this extent and that the extent is not composed of extended allocation</span>
04082     <span class="comment">//  descriptors, which are illegal on UDF.</span>
04083     <span class="comment">//</span>
04084     <span class="comment">//  If the common post-processing fails, we probably did not find any allocation</span>
04085     <span class="comment">//  descriptors (case of nothing but continuation).  This is likewise bad.</span>
04086     <span class="comment">//</span>
04087 
04088     <span class="keywordflow">if</span> (AllocContext-&gt;Remaining == 0 ||
04089         AllocContext-&gt;Remaining % <a class="code" href="../../d0/d7/iso13346_8h.html#a116">ISOAllocationDescriptorSize</a>( AllocContext-&gt;AllocType ) ||
04090         AllocContext-&gt;AllocType == <a class="code" href="../../d0/d7/iso13346_8h.html#a114">ICBTAG_F_ALLOC_EXTENDED</a> ||
04091         !<a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a24">UdfGetNextAllocationPostProcessing</a>( IrpContext, AllocContext )) {
04092 
04093         <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, STATUS_FILE_CORRUPT_ERROR );
04094     }
04095 }
04096 
04097 
04098 <span class="comment">//</span>
04099 <span class="comment">//  Local support routine</span>
04100 <span class="comment">//</span>
04101 
04102 BOOLEAN
<a name="l04103"></a><a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a23">04103</a> <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a23">UdfGetNextAllocation</a> (
04104     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
04105     IN <a class="code" href="../../d2/d6/struct__ALLOC__ENUM__CONTEXT.html">PALLOC_ENUM_CONTEXT</a> AllocContext
04106     )
04107 
04108 <span class="comment">/*++</span>
04109 <span class="comment"></span>
04110 <span class="comment">Routine Description:</span>
04111 <span class="comment"></span>
04112 <span class="comment">    This routine retrieves the next logical allocation descriptor given an enumeration</span>
04113 <span class="comment">    context.</span>
04114 <span class="comment"></span>
04115 <span class="comment">Arguments:</span>
04116 <span class="comment"></span>
04117 <span class="comment">    AllocContext - Context to advance to the next descriptor</span>
04118 <span class="comment"></span>
04119 <span class="comment">Return Value:</span>
04120 <span class="comment"></span>
04121 <span class="comment">    BOOLEAN - TRUE if one is found, FALSE if the enumeration is complete.</span>
04122 <span class="comment">    </span>
04123 <span class="comment">    This routine will raise if malformation is discovered.</span>
04124 <span class="comment"></span>
04125 <span class="comment">--*/</span>
04126 
04127 {
04128     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
04129 
04130     <span class="comment">//</span>
04131     <span class="comment">//  Check inputs</span>
04132     <span class="comment">//</span>
04133     
04134     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
04135 
04136     AllocContext-&gt;Remaining -= <a class="code" href="../../d0/d7/iso13346_8h.html#a116">ISOAllocationDescriptorSize</a>( AllocContext-&gt;AllocType );
04137     AllocContext-&gt;Alloc = <a class="code" href="../../d2/d7/notify_8c.html#a7">Add2Ptr</a>( AllocContext-&gt;Alloc, <a class="code" href="../../d0/d7/iso13346_8h.html#a116">ISOAllocationDescriptorSize</a>( AllocContext-&gt;AllocType ), PVOID );
04138 
04139     <span class="keywordflow">return</span> <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a24">UdfGetNextAllocationPostProcessing</a>( IrpContext, AllocContext );
04140 }
04141     
04142 
04143 BOOLEAN
<a name="l04144"></a><a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a24">04144</a> <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a24">UdfGetNextAllocationPostProcessing</a> (
04145     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
04146     IN <a class="code" href="../../d2/d6/struct__ALLOC__ENUM__CONTEXT.html">PALLOC_ENUM_CONTEXT</a> AllocContext
04147     )
04148 
04149 <span class="comment">/*++</span>
04150 <span class="comment"></span>
04151 <span class="comment">Routine Description:</span>
04152 <span class="comment"></span>
04153 <span class="comment">    This routine retrieves the next logical allocation descriptor given an enumeration</span>
04154 <span class="comment">    context.</span>
04155 <span class="comment"></span>
04156 <span class="comment">Arguments:</span>
04157 <span class="comment"></span>
04158 <span class="comment">    AllocContext - Context to advance to the next descriptor</span>
04159 <span class="comment"></span>
04160 <span class="comment">Return Value:</span>
04161 <span class="comment"></span>
04162 <span class="comment">    BOOLEAN - TRUE if one is found, FALSE if the enumeration is complete.</span>
04163 <span class="comment">    </span>
04164 <span class="comment">    This routine will raise if malformation is discovered.</span>
04165 <span class="comment"></span>
04166 <span class="comment">--*/</span>
04167 
04168 {
04169     <a class="code" href="../../d2/d7/structSHORTAD.html">PAD_GENERIC</a> GenericAd;
04170     <a class="code" href="../../d6/d1/structNSR__ALLOC.html">PNSR_ALLOC</a> AllocDesc;
04171 
04172     <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb = AllocContext-&gt;IcbContext-&gt;Vcb;
04173 
04174     <span class="comment">//</span>
04175     <span class="comment">//  There are three ways to reach the end of the current block of allocation</span>
04176     <span class="comment">//  descriptors, per ISO 13346 4/12:</span>
04177     <span class="comment">//</span>
04178     <span class="comment">//      reach the end of the field (kept track of in the Remaining bytes)</span>
04179     <span class="comment">//      reach an allocation descriptor with an extent length of zero</span>
04180     <span class="comment">//      reach a continuation extent descriptor</span>
04181     <span class="comment">//</span>
04182     
04183     <span class="comment">//</span>
04184     <span class="comment">//  We are done in the first two cases.</span>
04185     <span class="comment">//</span>
04186 
04187     <span class="keywordflow">if</span> (AllocContext-&gt;Remaining == 0) {
04188         
04189         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04190     }
04191 
04192     <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
04193         
04194         GenericAd = AllocContext-&gt;Alloc;
04195     
04196         <span class="keywordflow">if</span> (GenericAd-&gt;<a class="code" href="../../d2/d7/structSHORTAD.html#o0">Length</a>.<a class="code" href="../../d7/d3/structNSRLENGTH.html#o0">Length</a> == 0) {
04197     
04198             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04199         }
04200         
04201         <span class="comment">//</span>
04202         <span class="comment">//  Check if this descriptor is a pointer to another extent of descriptors.</span>
04203         <span class="comment">//</span>
04204     
04205         <span class="keywordflow">if</span> (GenericAd-&gt;<a class="code" href="../../d2/d7/structSHORTAD.html#o0">Length</a>.<a class="code" href="../../d7/d3/structNSRLENGTH.html#o1">Type</a> != <a class="code" href="../../d0/d7/iso13346_8h.html#a24">NSRLENGTH_TYPE_CONTINUATION</a>) {
04206             
04207             <span class="keywordflow">break</span>;
04208         }
04209     
04210         <span class="comment">//</span>
04211         <span class="comment">//  UDF allocation extents are restricted to a single logical block.</span>
04212         <span class="comment">//</span>
04213 
04214         <span class="keywordflow">if</span> (GenericAd-&gt;<a class="code" href="../../d2/d7/structSHORTAD.html#o0">Length</a>.<a class="code" href="../../d7/d3/structNSRLENGTH.html#o0">Length</a> &gt; <a class="code" href="../../d3/d8/udfprocs_8h.html#a54">BlockSize</a>( Vcb )) {
04215             
04216             <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, STATUS_FILE_CORRUPT_ERROR );
04217         }
04218                 
04219         <a class="code" href="../../d3/d8/udfprocs_8h.html#a157">UdfMapMetadataView</a>( IrpContext,
04220                             &amp;AllocContext-&gt;IcbContext-&gt;Current,
04221                             Vcb,
04222                             <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a14">UdfGetPartitionOfCurrentAllocation</a>( AllocContext ),
04223                             GenericAd-&gt;<a class="code" href="../../d2/d7/structSHORTAD.html#o1">Start</a>,
04224                             <a class="code" href="../../d3/d8/udfprocs_8h.html#a54">BlockSize</a>( Vcb ) );
04225         
04226         <span class="comment">//</span>
04227         <span class="comment">//  Now check that the allocation descriptor is valid.</span>
04228         <span class="comment">//</span>
04229 
04230         AllocDesc = (<a class="code" href="../../d6/d1/structNSR__ALLOC.html">PNSR_ALLOC</a>) AllocContext-&gt;IcbContext-&gt;Current.View;
04231 
04232         <a class="code" href="../../d3/d8/udfprocs_8h.html#a219">UdfVerifyDescriptor</a>( IrpContext,
04233                              &amp;AllocDesc-&gt;<a class="code" href="../../d6/d1/structNSR__ALLOC.html#o0">Destag</a>,
04234                              <a class="code" href="../../d0/d7/iso13346_8h.html#a51">DESTAG_ID_NSR_ALLOC</a>,
04235                              <a class="code" href="../../d3/d8/udfprocs_8h.html#a54">BlockSize</a>( Vcb ),
04236                              AllocContext-&gt;IcbContext-&gt;Current.Lbn,
04237                              <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
04238 
04239         <span class="comment">//</span>
04240         <span class="comment">//  Note that a full logical block is mapped, but only the claimed number of</span>
04241         <span class="comment">//  bytes are valid.</span>
04242         <span class="comment">//</span>
04243 
04244         AllocContext-&gt;Remaining = AllocDesc-&gt;<a class="code" href="../../d6/d1/structNSR__ALLOC.html#o2">AllocLen</a>;
04245         AllocContext-&gt;Alloc = <a class="code" href="../../d2/d7/notify_8c.html#a7">Add2Ptr</a>( AllocContext-&gt;IcbContext-&gt;Current.View, <span class="keyword">sizeof</span>( <a class="code" href="../../d6/d1/structNSR__ALLOC.html">NSR_ALLOC</a> ), PVOID );
04246 
04247         <span class="comment">//</span>
04248         <span class="comment">//  Check that the size is sane and that an integral number of the appropriate</span>
04249         <span class="comment">//  allocation descriptors fit in this extent.</span>
04250         <span class="comment">//</span>
04251 
04252         <span class="keywordflow">if</span> (AllocContext-&gt;Remaining == 0 ||
04253             AllocContext-&gt;Remaining &gt; <a class="code" href="../../d3/d8/udfprocs_8h.html#a54">BlockSize</a>( Vcb ) - <span class="keyword">sizeof</span>( <a class="code" href="../../d0/d7/iso13346_8h.html#a237">NSR_ALLOC</a> ) ||
04254             AllocContext-&gt;Remaining % <a class="code" href="../../d0/d7/iso13346_8h.html#a116">ISOAllocationDescriptorSize</a>( AllocContext-&gt;AllocType )) {
04255 
04256             <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, STATUS_FILE_CORRUPT_ERROR );
04257         }
04258     }
04259     
04260     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04261 }
04262 
04263 
04264 <span class="comment">//</span>
04265 <span class="comment">//  Local support routine</span>
04266 <span class="comment">//</span>
04267 
04268 <a class="code" href="../../d4/d0/struct__FCB__NONPAGED.html">PFCB_NONPAGED</a>
<a name="l04269"></a><a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a18">04269</a> <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a18">UdfCreateFcbNonPaged</a> (
04270     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext
04271     )
04272 
04273 <span class="comment">/*++</span>
04274 <span class="comment"></span>
04275 <span class="comment">Routine Description:</span>
04276 <span class="comment"></span>
04277 <span class="comment">    This routine is called to create and initialize the non-paged portion</span>
04278 <span class="comment">    of an Fcb.</span>
04279 <span class="comment"></span>
04280 <span class="comment">Arguments:</span>
04281 <span class="comment"></span>
04282 <span class="comment">Return Value:</span>
04283 <span class="comment"></span>
04284 <span class="comment">    PFCB_NONPAGED - Pointer to the created nonpaged Fcb.  NULL if not created.</span>
04285 <span class="comment"></span>
04286 <span class="comment">--*/</span>
04287 
04288 {
04289     <a class="code" href="../../d4/d0/struct__FCB__NONPAGED.html">PFCB_NONPAGED</a> FcbNonpaged;
04290 
04291     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
04292 
04293     <span class="comment">//</span>
04294     <span class="comment">//  Allocate the non-paged pool and initialize the various</span>
04295     <span class="comment">//  synchronization objects.</span>
04296     <span class="comment">//</span>
04297 
04298     FcbNonpaged = <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a6">UdfAllocateFcbNonpaged</a>( IrpContext );
04299 
04300     RtlZeroMemory( FcbNonpaged, <span class="keyword">sizeof</span>( <a class="code" href="../../d4/d0/struct__FCB__NONPAGED.html">FCB_NONPAGED</a> ));
04301 
04302     FcbNonpaged-&gt;<a class="code" href="../../d4/d0/struct__FCB__NONPAGED.html#o0">NodeTypeCode</a> = <a class="code" href="../../d1/d7/udfs_2nodetype_8h.html#a5">UDFS_NTC_FCB_NONPAGED</a>;
04303     FcbNonpaged-&gt;<a class="code" href="../../d4/d0/struct__FCB__NONPAGED.html#o1">NodeByteSize</a> = <span class="keyword">sizeof</span>( <a class="code" href="../../d6/d8/udfstruc_8h.html#a82">FCB_NONPAGED</a> );
04304 
04305     <a class="code" href="../../d5/d8/ex_8h.html#a68">ExInitializeResource</a>( &amp;FcbNonpaged-&gt;<a class="code" href="../../d4/d0/struct__FCB__NONPAGED.html#o3">FcbResource</a> );
04306     <a class="code" href="../../d5/d8/ex_8h.html#a8">ExInitializeFastMutex</a>( &amp;FcbNonpaged-&gt;<a class="code" href="../../d4/d0/struct__FCB__NONPAGED.html#o4">FcbMutex</a> );
04307 
04308     <span class="keywordflow">return</span> FcbNonpaged;
04309 }
04310 
04311 
04312 <span class="comment">//</span>
04313 <span class="comment">//  Local support routine</span>
04314 <span class="comment">//</span>
04315 
04316 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l04317"></a><a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a19">04317</a> <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a19">UdfDeleteFcbNonpaged</a> (
04318     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
04319     IN <a class="code" href="../../d4/d0/struct__FCB__NONPAGED.html">PFCB_NONPAGED</a> FcbNonpaged
04320     )
04321 
04322 <span class="comment">/*++</span>
04323 <span class="comment"></span>
04324 <span class="comment">Routine Description:</span>
04325 <span class="comment"></span>
04326 <span class="comment">    This routine is called to cleanup the non-paged portion of an Fcb.</span>
04327 <span class="comment"></span>
04328 <span class="comment">Arguments:</span>
04329 <span class="comment"></span>
04330 <span class="comment">    FcbNonpaged - Structure to clean up.</span>
04331 <span class="comment"></span>
04332 <span class="comment">Return Value:</span>
04333 <span class="comment"></span>
04334 <span class="comment">    None</span>
04335 <span class="comment"></span>
04336 <span class="comment">--*/</span>
04337 
04338 {
04339     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
04340 
04341     <a class="code" href="../../d5/d8/ex_8h.html#a73">ExDeleteResource</a>( &amp;FcbNonpaged-&gt;FcbResource );
04342 
04343     <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a7">UdfDeallocateFcbNonpaged</a>( IrpContext, FcbNonpaged );
04344 
04345     <span class="keywordflow">return</span>;
04346 }
04347 
04348 
04349 <span class="comment">//</span>
04350 <span class="comment">//  Local support routine</span>
04351 <span class="comment">//</span>
04352 
04353 RTL_GENERIC_COMPARE_RESULTS
<a name="l04354"></a><a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a21">04354</a> <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a21">UdfFcbTableCompare</a> (
04355     IN PRTL_GENERIC_TABLE Table,
04356     IN PVOID id1,
04357     IN PVOID id2
04358     )
04359 
04360 <span class="comment">/*++</span>
04361 <span class="comment"></span>
04362 <span class="comment">Routine Description:</span>
04363 <span class="comment"></span>
04364 <span class="comment">    This routine is the Udfs compare routine called by the generic table package.</span>
04365 <span class="comment">    If will compare the two File Id values and return a comparison result.</span>
04366 <span class="comment"></span>
04367 <span class="comment">Arguments:</span>
04368 <span class="comment"></span>
04369 <span class="comment">    Table - This is the table being searched.</span>
04370 <span class="comment"></span>
04371 <span class="comment">    id1 - First key value.</span>
04372 <span class="comment"></span>
04373 <span class="comment">    id2 - Second key value.</span>
04374 <span class="comment"></span>
04375 <span class="comment">Return Value:</span>
04376 <span class="comment"></span>
04377 <span class="comment">    RTL_GENERIC_COMPARE_RESULTS - The results of comparing the two</span>
04378 <span class="comment">        input structures</span>
04379 <span class="comment"></span>
04380 <span class="comment">--*/</span>
04381 
04382 {
04383     <a class="code" href="../../d6/d8/udfstruc_8h.html#a77">FILE_ID</a> Id1, Id2;
04384     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
04385 
04386     Id1 = *((<a class="code" href="../../d6/d8/udfstruc_8h.html#a77">FILE_ID</a> UNALIGNED *) id1);
04387     Id2 = *((<a class="code" href="../../d6/d8/udfstruc_8h.html#a77">FILE_ID</a> UNALIGNED *) id2);
04388 
04389     <span class="keywordflow">if</span> (Id1.QuadPart &lt; Id2.QuadPart) {
04390 
04391         <span class="keywordflow">return</span> GenericLessThan;
04392 
04393     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Id1.QuadPart &gt; Id2.QuadPart) {
04394 
04395         <span class="keywordflow">return</span> GenericGreaterThan;
04396 
04397     } <span class="keywordflow">else</span> {
04398 
04399         <span class="keywordflow">return</span> GenericEqual;
04400     }
04401 
04402     UNREFERENCED_PARAMETER( Table );
04403 }
04404 
04405 
04406 <span class="comment">//</span>
04407 <span class="comment">//  Local support routine</span>
04408 <span class="comment">//</span>
04409 
04410 PVOID
<a name="l04411"></a><a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a17">04411</a> <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a17">UdfAllocateTable</a> (
04412     IN PRTL_GENERIC_TABLE Table,
04413     IN CLONG ByteSize
04414     )
04415 
04416 <span class="comment">/*++</span>
04417 <span class="comment"></span>
04418 <span class="comment">Routine Description:</span>
04419 <span class="comment"></span>
04420 <span class="comment">    This is a generic table support routine to allocate memory</span>
04421 <span class="comment"></span>
04422 <span class="comment">Arguments:</span>
04423 <span class="comment"></span>
04424 <span class="comment">    Table - Supplies the generic table being used</span>
04425 <span class="comment"></span>
04426 <span class="comment">    ByteSize - Supplies the number of bytes to allocate</span>
04427 <span class="comment"></span>
04428 <span class="comment">Return Value:</span>
04429 <span class="comment"></span>
04430 <span class="comment">    PVOID - Returns a pointer to the allocated data</span>
04431 <span class="comment"></span>
04432 <span class="comment">--*/</span>
04433 
04434 {
04435     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
04436 
04437     <span class="keywordflow">return</span>( <a class="code" href="../../d1/d8/fsrtl_8h.html#a37">FsRtlAllocatePoolWithTag</a>( <a class="code" href="../../d3/d8/udfprocs_8h.html#a65">UdfPagedPool</a>, ByteSize, <a class="code" href="../../d1/d7/udfs_2nodetype_8h.html#a76">TAG_GENERIC_TABLE</a> ));
04438 }
04439 
04440 
04441 <span class="comment">//</span>
04442 <span class="comment">//  Local support routine</span>
04443 <span class="comment">//</span>
04444 
04445 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l04446"></a><a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a20">04446</a> <a class="code" href="../../d9/d7/udfs_2strucsup_8c.html#a20">UdfDeallocateTable</a> (
04447     IN PRTL_GENERIC_TABLE Table,
04448     IN PVOID Buffer
04449     )
04450 
04451 <span class="comment">/*++</span>
04452 <span class="comment"></span>
04453 <span class="comment">Routine Description:</span>
04454 <span class="comment"></span>
04455 <span class="comment">    This is a generic table support routine that deallocates memory</span>
04456 <span class="comment"></span>
04457 <span class="comment">Arguments:</span>
04458 <span class="comment"></span>
04459 <span class="comment">    Table - Supplies the generic table being used</span>
04460 <span class="comment"></span>
04461 <span class="comment">    Buffer - Supplies the buffer being deallocated</span>
04462 <span class="comment"></span>
04463 <span class="comment">Return Value:</span>
04464 <span class="comment"></span>
04465 <span class="comment">    None.</span>
04466 <span class="comment"></span>
04467 <span class="comment">--*/</span>
04468 
04469 {
04470     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
04471 
04472     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> );
04473 
04474     <span class="keywordflow">return</span>;
04475     UNREFERENCED_PARAMETER( Table );
04476 }
04477 
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:41:54 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
