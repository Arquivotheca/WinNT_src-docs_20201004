<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: fsctrl.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>fsctrl.c</h1><a href="../../d9/d7/udfs_2fsctrl_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1996  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    FsCtrl.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module implements the File System Control routines for Udfs called</span>
00012 <span class="comment">    by the Fsd/Fsp dispatch drivers.</span>
00013 <span class="comment"></span>
00014 <span class="comment">Author:</span>
00015 <span class="comment"></span>
00016 <span class="comment">    Dan Lovinger    [DanLo]   11-Jun-1996</span>
00017 <span class="comment"></span>
00018 <span class="comment">Revision History:</span>
00019 <span class="comment"></span>
00020 <span class="comment">--*/</span>
00021 
00022 <span class="preprocessor">#include "UdfProcs.h"</span>
00023 
00024 <span class="comment">//</span>
00025 <span class="comment">//  The Bug check file id for this module</span>
00026 <span class="comment">//</span>
00027 
<a name="l00028"></a><a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a0">00028</a> <span class="preprocessor">#define BugCheckFileId                   (UDFS_BUG_CHECK_FSCTRL)</span>
00029 <span class="preprocessor"></span>
00030 <span class="comment">//</span>
00031 <span class="comment">//  The local debug trace level</span>
00032 <span class="comment">//</span>
00033 
<a name="l00034"></a><a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a1">00034</a> <span class="preprocessor">#define Dbg                              (UDFS_DEBUG_LEVEL_FSCTRL)</span>
00035 <span class="preprocessor"></span>
00036 <span class="comment">//</span>
00037 <span class="comment">//  Local constants</span>
00038 <span class="comment">//</span>
00039 
<a name="l00040"></a><a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a2">00040</a> BOOLEAN <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a2">UdfDisable</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00041 
00042 <span class="comment">//</span>
00043 <span class="comment">//  Local macros</span>
00044 <span class="comment">//</span>
00045 
00046 <a class="code" href="../../d5/d3/filelock_8c.html#a1">INLINE</a>
00047 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00048"></a><a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a3">00048</a> <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a3">UdfStoreFileSetDescriptorIfPrevailing</a> (
00049     IN OUT <a class="code" href="../../d2/d2/structNSR__FSD.html">PNSR_FSD</a> *StoredFSD,
00050     IN OUT <a class="code" href="../../d2/d2/structNSR__FSD.html">PNSR_FSD</a> *NewFSD
00051     )
00052 {
00053     <a class="code" href="../../d2/d2/structNSR__FSD.html">PNSR_FSD</a> TempFSD;
00054 
00055     <span class="comment">//</span>
00056     <span class="comment">//  If we haven't stored a fileset descriptor or the fileset number</span>
00057     <span class="comment">//  of the stored descriptor is less than the new descriptor, swap the</span>
00058     <span class="comment">//  pointers around.</span>
00059     <span class="comment">//</span>
00060 
00061     <span class="keywordflow">if</span> (*StoredFSD == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> || (*StoredFSD)-&gt;FileSet &lt; (*NewFSD)-&gt;FileSet) {
00062 
00063         TempFSD = *StoredFSD;
00064         *StoredFSD = *NewFSD;
00065         *NewFSD = TempFSD;
00066     }
00067 }
00068 
00069 <span class="comment">//</span>
00070 <span class="comment">//  Local support routines</span>
00071 <span class="comment">//</span>
00072 
00073 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00074 <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a4">UdfDetermineVolumeBounding</a> ( 
00075     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00076     IN <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb,
00077     IN PULONG S,
00078     IN PULONG N
00079     );
00080 
00081 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00082 <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a5">UdfDismountVolume</a> (
00083     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00084     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
00085     );
00086 
00087 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00088 <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a6">UdfFindAnchorVolumeDescriptor</a> (
00089     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00090     IN <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb,
00091     IN OUT <a class="code" href="../../d7/d1/structNSR__ANCHOR.html">PNSR_ANCHOR</a> *AnchorVolumeDescriptor
00092     );
00093 
00094 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00095 <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a7">UdfFindFileSetDescriptor</a> (
00096     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00097     IN <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb,
00098     IN <a class="code" href="../../d4/d9/structLONGAD.html">PLONGAD</a> LongAd,
00099     IN OUT <a class="code" href="../../d2/d2/structNSR__FSD.html">PNSR_FSD</a> *FileSetDescriptor
00100     );
00101 
00102 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00103 <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a8">UdfFindVolumeDescriptors</a> (
00104     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00105     IN <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb,
00106     IN <a class="code" href="../../d3/d9/structEXTENTAD.html">PEXTENTAD</a> Extent,
00107     IN OUT <a class="code" href="../../d4/d9/struct__PCB.html">PPCB</a> *Pcb,
00108     IN OUT <a class="code" href="../../d0/d3/structNSR__PVD.html">PNSR_PVD</a> *PrimaryVolumeDescriptor,
00109     IN OUT <a class="code" href="../../d6/d2/structNSR__LVOL.html">PNSR_LVOL</a> *LogicalVolumeDescriptor
00110     );
00111 
00112 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00113 <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a9">UdfInvalidateVolumes</a> (
00114     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00115     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
00116     );
00117 
00118 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00119 <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a10">UdfIsPathnameValid</a> (
00120     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00121     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
00122     );
00123 
00124 BOOLEAN
00125 <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a11">UdfIsRemount</a> (
00126     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00127     IN <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb,
00128     OUT <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> *OldVcb
00129     );
00130 
00131 <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a12">UdfIsVolumeDirty</a> (
00132     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00133     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
00134     );
00135 
00136 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00137 <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a13">UdfIsVolumeMounted</a> (
00138     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00139     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
00140     );
00141 
00142 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00143 <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a14">UdfLockVolume</a> (
00144     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00145     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
00146     );
00147 
00148 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00149 <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a15">UdfMountVolume</a>(
00150     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00151     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
00152     );
00153 
00154 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00155 <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a16">UdfOplockRequest</a> (
00156     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00157     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
00158     );
00159 
00160 BOOLEAN
00161 <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a17">UdfRecognizeVolume</a> (
00162     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00163     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
00164     IN ULONG SectorSize,
00165     IN OUT PBOOLEAN Bridge
00166     );
00167 
00168 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00169 <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a18">UdfScanForDismountedVcb</a> (
00170     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext
00171     );
00172 
00173 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00174 <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a19">UdfUnlockVolume</a> (
00175     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00176     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
00177     );
00178 
00179 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00180 <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a20">UdfUpdateVolumeLabel</a> (
00181     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00182     IN PWCHAR VolumeLabel,
00183     IN OUT PUSHORT VolumeLabelLength,
00184     IN PUCHAR Dstring,
00185     IN UCHAR FieldLength
00186     );
00187 
00188 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00189 <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a21">UdfUpdateVolumeSerialNumber</a> (
00190     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00191     IN OUT PULONG VolumeSerialNumber,
00192     IN <a class="code" href="../../d2/d2/structNSR__FSD.html">PNSR_FSD</a> Fsd
00193     );
00194 
00195 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00196 <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a22">UdfUserFsctl</a> (
00197     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00198     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
00199     );
00200 
00201 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00202 <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a23">UdfVerifyVolume</a> (
00203     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00204     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
00205     );
00206 
00207 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00208 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfCommonFsControl)</span>
00209 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfDetermineVolumeBounding)</span>
00210 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfDismountVolume)</span>
00211 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfFindAnchorVolumeDescriptor)</span>
00212 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfFindFileSetDescriptor)</span>
00213 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfFindVolumeDescriptors)</span>
00214 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfIsPathnameValid)</span>
00215 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfIsRemount)</span>
00216 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfIsVolumeDirty)</span>
00217 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfIsVolumeMounted)</span>
00218 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfLockVolume)</span>
00219 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfLockVolumeInternal)</span>
00220 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfMountVolume)</span>
00221 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfOplockRequest)</span>
00222 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfRecognizeVolume)</span>
00223 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfScanForDismountedVcb)</span>
00224 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfStoreVolumeDescriptorIfPrevailing)</span>
00225 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfUnlockVolume)</span>
00226 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfUnlockVolumeInternal)</span>
00227 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfUpdateVolumeLabel)</span>
00228 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfUpdateVolumeSerialNumber)</span>
00229 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfUserFsctl)</span>
00230 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfVerifyVolume)</span>
00231 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00232 <span class="preprocessor"></span>
00233 
00234 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00235"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a176">00235</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a176">UdfStoreVolumeDescriptorIfPrevailing</a> (
00236     IN OUT <a class="code" href="../../d4/d3/structNSR__VD__GENERIC.html">PNSR_VD_GENERIC</a> *StoredVD,
00237     IN OUT <a class="code" href="../../d4/d3/structNSR__VD__GENERIC.html">PNSR_VD_GENERIC</a> NewVD
00238     )
00239 
00240 <span class="comment">/*++</span>
00241 <span class="comment"></span>
00242 <span class="comment">Routine Description:</span>
00243 <span class="comment"></span>
00244 <span class="comment">    This routine updates Volume Descriptor if the new descriptor</span>
00245 <span class="comment">    is more prevailing than the one currently stored.</span>
00246 <span class="comment"></span>
00247 <span class="comment">Arguments:</span>
00248 <span class="comment"></span>
00249 <span class="comment">    StoredVD - pointer to a currently stored descriptor</span>
00250 <span class="comment"></span>
00251 <span class="comment">    NewVD - pointer to a candidate descriptor</span>
00252 <span class="comment"></span>
00253 <span class="comment">Return Value:</span>
00254 <span class="comment"></span>
00255 <span class="comment">    None.</span>
00256 <span class="comment"></span>
00257 <span class="comment">--*/</span>
00258 
00259 {
00260     <a class="code" href="../../d4/d3/structNSR__VD__GENERIC.html">PNSR_VD_GENERIC</a> TempVD;
00261 
00262     <span class="comment">//</span>
00263     <span class="comment">//  If we haven't stored a volume descriptor or the sequence number</span>
00264     <span class="comment">//  of the stored descriptor is less than the new descriptor, make a copy</span>
00265     <span class="comment">//  of it and store it.</span>
00266     <span class="comment">//</span>
00267 
00268     <span class="keywordflow">if</span> ((<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> == *StoredVD) || ((*StoredVD)-&gt;Sequence &lt; NewVD-&gt;Sequence)) {
00269 
00270         <span class="keywordflow">if</span> ( <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> == *StoredVD)  {
00271 
00272             *StoredVD = (<a class="code" href="../../d4/d3/structNSR__VD__GENERIC.html">PNSR_VD_GENERIC</a>) <a class="code" href="../../d1/d8/fsrtl_8h.html#a37">FsRtlAllocatePoolWithTag</a>( <a class="code" href="../../d3/d8/udfprocs_8h.html#a66">UdfNonPagedPool</a>,
00273                                                                     <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d3/structNSR__VD__GENERIC.html">NSR_VD_GENERIC</a>),
00274                                                                     <a class="code" href="../../d1/d7/udfs_2nodetype_8h.html#a88">TAG_NSR_VDSD</a> );
00275         }
00276 
00277         RtlCopyMemory( *StoredVD,  NewVD,  <span class="keyword">sizeof</span>( <a class="code" href="../../d4/d3/structNSR__VD__GENERIC.html">NSR_VD_GENERIC</a>));
00278     }
00279 }
00280 
00281 
00282 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00283"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a256">00283</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a256">UdfCommonFsControl</a> (
00284     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00285     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
00286     )
00287 
00288 <span class="comment">/*++</span>
00289 <span class="comment"></span>
00290 <span class="comment">Routine Description:</span>
00291 <span class="comment"></span>
00292 <span class="comment">    This is the common routine for doing FileSystem control operations called</span>
00293 <span class="comment">    by both the fsd and fsp threads</span>
00294 <span class="comment"></span>
00295 <span class="comment">Arguments:</span>
00296 <span class="comment"></span>
00297 <span class="comment">    Irp - Supplies the Irp to process</span>
00298 <span class="comment"></span>
00299 <span class="comment">Return Value:</span>
00300 <span class="comment"></span>
00301 <span class="comment">    NTSTATUS - The return status for the operation</span>
00302 <span class="comment"></span>
00303 <span class="comment">--*/</span>
00304 
00305 {
00306     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00307     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> IrpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
00308 
00309     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00310 
00311     <span class="comment">//</span>
00312     <span class="comment">//  Check the input parameters</span>
00313     <span class="comment">//</span>
00314 
00315     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
00316     <a class="code" href="../../d1/d8/udfdata_8h.html#a32">ASSERT_IRP</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
00317 
00318     <span class="comment">//</span>
00319     <span class="comment">//  Get a pointer to the current Irp stack location</span>
00320     <span class="comment">//</span>
00321 
00322     IrpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
00323 
00324     <span class="comment">//</span>
00325     <span class="comment">//  We know this is a file system control so we'll case on the</span>
00326     <span class="comment">//  minor function, and call a internal worker routine to complete</span>
00327     <span class="comment">//  the irp.</span>
00328     <span class="comment">//</span>
00329 
00330     <span class="keywordflow">switch</span> (IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o1">MinorFunction</a>) {
00331 
00332     <span class="keywordflow">case</span> <a class="code" href="../../d0/d5/io_8h.html#a47">IRP_MN_MOUNT_VOLUME</a>:
00333 
00334         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a15">UdfMountVolume</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
00335         <span class="keywordflow">break</span>;
00336 
00337     <span class="keywordflow">case</span> <a class="code" href="../../d0/d5/io_8h.html#a48">IRP_MN_VERIFY_VOLUME</a>:
00338 
00339         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a23">UdfVerifyVolume</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
00340         <span class="keywordflow">break</span>;
00341 
00342     <span class="keywordflow">case</span> <a class="code" href="../../d0/d5/io_8h.html#a46">IRP_MN_USER_FS_REQUEST</a>:
00343 
00344         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a22">UdfUserFsctl</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
00345         <span class="keywordflow">break</span>;
00346 
00347     <span class="keywordflow">default</span>:
00348 
00349         <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, STATUS_INVALID_DEVICE_REQUEST );
00350         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_DEVICE_REQUEST;
00351         <span class="keywordflow">break</span>;
00352     }
00353 
00354     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00355 }
00356 
00357 
00358 <span class="comment">//</span>
00359 <span class="comment">//  Local support routine</span>
00360 <span class="comment">//</span>
00361 
00362 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00363"></a><a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a22">00363</a> <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a22">UdfUserFsctl</a> (
00364     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00365     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
00366     )
00367 <span class="comment">/*++</span>
00368 <span class="comment"></span>
00369 <span class="comment">Routine Description:</span>
00370 <span class="comment"></span>
00371 <span class="comment">    This is the common routine for implementing the user's requests made</span>
00372 <span class="comment">    through NtFsControlFile.</span>
00373 <span class="comment"></span>
00374 <span class="comment">Arguments:</span>
00375 <span class="comment"></span>
00376 <span class="comment">    Irp - Supplies the Irp being processed</span>
00377 <span class="comment"></span>
00378 <span class="comment">Return Value:</span>
00379 <span class="comment"></span>
00380 <span class="comment">    NTSTATUS - The return status for the operation</span>
00381 <span class="comment"></span>
00382 <span class="comment">--*/</span>
00383 
00384 {
00385     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00386     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> IrpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
00387 
00388     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00389 
00390     <span class="comment">//</span>
00391     <span class="comment">//  Case on the control code.</span>
00392     <span class="comment">//</span>
00393 
00394     <span class="keywordflow">switch</span> ( IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.FileSystemControl.FsControlCode ) {
00395 
00396     <span class="keywordflow">case</span> FSCTL_REQUEST_OPLOCK_LEVEL_1 :
00397     <span class="keywordflow">case</span> FSCTL_REQUEST_OPLOCK_LEVEL_2 :
00398     <span class="keywordflow">case</span> FSCTL_REQUEST_BATCH_OPLOCK :
00399     <span class="keywordflow">case</span> FSCTL_OPLOCK_BREAK_ACKNOWLEDGE :
00400     <span class="keywordflow">case</span> FSCTL_OPBATCH_ACK_CLOSE_PENDING :
00401     <span class="keywordflow">case</span> FSCTL_OPLOCK_BREAK_NOTIFY :
00402     <span class="keywordflow">case</span> FSCTL_OPLOCK_BREAK_ACK_NO_2 :
00403     <span class="keywordflow">case</span> FSCTL_REQUEST_FILTER_OPLOCK :
00404 
00405         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a16">UdfOplockRequest</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
00406         <span class="keywordflow">break</span>;
00407 
00408     <span class="keywordflow">case</span> FSCTL_LOCK_VOLUME :
00409 
00410         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a14">UdfLockVolume</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
00411         <span class="keywordflow">break</span>;
00412 
00413     <span class="keywordflow">case</span> FSCTL_UNLOCK_VOLUME :
00414 
00415         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a19">UdfUnlockVolume</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
00416         <span class="keywordflow">break</span>;
00417 
00418     <span class="keywordflow">case</span> FSCTL_DISMOUNT_VOLUME :
00419 
00420         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a5">UdfDismountVolume</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
00421         <span class="keywordflow">break</span>;
00422 
00423     <span class="keywordflow">case</span> FSCTL_IS_VOLUME_DIRTY :
00424 
00425         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a12">UdfIsVolumeDirty</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
00426         <span class="keywordflow">break</span>;
00427 
00428     <span class="keywordflow">case</span> FSCTL_IS_VOLUME_MOUNTED :
00429 
00430         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a13">UdfIsVolumeMounted</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
00431         <span class="keywordflow">break</span>;
00432 
00433     <span class="keywordflow">case</span> FSCTL_IS_PATHNAME_VALID :
00434 
00435         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a10">UdfIsPathnameValid</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
00436         <span class="keywordflow">break</span>;
00437 
00438     <span class="keywordflow">case</span> FSCTL_INVALIDATE_VOLUMES :
00439 
00440         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a9">UdfInvalidateVolumes</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
00441         <span class="keywordflow">break</span>;
00442 
00443 
00444     <span class="comment">//</span>
00445     <span class="comment">//  We don't support any of the known or unknown requests.</span>
00446     <span class="comment">//</span>
00447 
00448     <span class="keywordflow">case</span> FSCTL_MARK_VOLUME_DIRTY :
00449     <span class="keywordflow">case</span> FSCTL_QUERY_RETRIEVAL_POINTERS :
00450     <span class="keywordflow">case</span> FSCTL_GET_COMPRESSION :
00451     <span class="keywordflow">case</span> FSCTL_SET_COMPRESSION :
00452     <span class="keywordflow">case</span> FSCTL_MARK_AS_SYSTEM_HIVE :
00453     <span class="keywordflow">case</span> FSCTL_QUERY_FAT_BPB :
00454     <span class="keywordflow">default</span>:
00455 
00456         <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, STATUS_INVALID_DEVICE_REQUEST );
00457         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_DEVICE_REQUEST;
00458         <span class="keywordflow">break</span>;
00459     }
00460 
00461     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00462 }
00463 
00464 
00465 <span class="comment">//</span>
00466 <span class="comment">//  Local support routine</span>
00467 <span class="comment">//</span>
00468 
00469 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00470"></a><a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a16">00470</a> <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a16">UdfOplockRequest</a> (
00471     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00472     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
00473     )
00474 
00475 <span class="comment">/*++</span>
00476 <span class="comment"></span>
00477 <span class="comment">Routine Description:</span>
00478 <span class="comment"></span>
00479 <span class="comment">    This is the common routine to handle oplock requests made via the</span>
00480 <span class="comment">    NtFsControlFile call.</span>
00481 <span class="comment"></span>
00482 <span class="comment">Arguments:</span>
00483 <span class="comment"></span>
00484 <span class="comment">    Irp - Supplies the Irp being processed</span>
00485 <span class="comment"></span>
00486 <span class="comment">Return Value:</span>
00487 <span class="comment"></span>
00488 <span class="comment">    NTSTATUS - The return status for the operation</span>
00489 <span class="comment"></span>
00490 <span class="comment">--*/</span>
00491 
00492 {
00493     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00494     <a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a> Fcb;
00495     <a class="code" href="../../d2/d9/struct__CCB.html">PCCB</a> Ccb;
00496 
00497     ULONG OplockCount = 0;
00498     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> IrpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
00499 
00500     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00501 
00502     <span class="comment">//</span>
00503     <span class="comment">//  We only permit oplock requests on files.</span>
00504     <span class="comment">//</span>
00505 
00506     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d8/udfprocs_8h.html#a174">UdfDecodeFileObject</a>( IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a>,
00507                              &amp;Fcb,
00508                              &amp;Ccb ) != <a class="code" href="../../d3/d8/udfprocs_8h.html#a263a117">UserFileOpen</a> ) {
00509 
00510         <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, STATUS_INVALID_PARAMETER );
00511         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
00512     }
00513 
00514     <span class="comment">//</span>
00515     <span class="comment">//  Make this a waitable Irpcontext so we don't fail to acquire</span>
00516     <span class="comment">//  the resources.</span>
00517     <span class="comment">//</span>
00518 
00519     <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( IrpContext-&gt;Flags, <a class="code" href="../../d6/d8/udfstruc_8h.html#a30">IRP_CONTEXT_FLAG_WAIT</a> );
00520     <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>( IrpContext-&gt;Flags, <a class="code" href="../../d6/d8/udfstruc_8h.html#a31">IRP_CONTEXT_FLAG_FORCE_POST</a> );
00521 
00522     <span class="comment">//</span>
00523     <span class="comment">//  Switch on the function control code.  We grab the Fcb exclusively</span>
00524     <span class="comment">//  for oplock requests, shared for oplock break acknowledgement.</span>
00525     <span class="comment">//</span>
00526 
00527     <span class="keywordflow">switch</span> (IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.FileSystemControl.FsControlCode) {
00528 
00529     <span class="keywordflow">case</span> FSCTL_REQUEST_OPLOCK_LEVEL_1 :
00530     <span class="keywordflow">case</span> FSCTL_REQUEST_OPLOCK_LEVEL_2 :
00531     <span class="keywordflow">case</span> FSCTL_REQUEST_BATCH_OPLOCK :
00532     <span class="keywordflow">case</span> FSCTL_REQUEST_FILTER_OPLOCK :
00533 
00534         <a class="code" href="../../d3/d8/udfprocs_8h.html#a83">UdfAcquireFcbExclusive</a>( IrpContext, Fcb, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00535 
00536         <span class="keywordflow">if</span> (IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.FileSystemControl.FsControlCode == FSCTL_REQUEST_OPLOCK_LEVEL_2) {
00537 
00538             <span class="keywordflow">if</span> (Fcb-&gt;FileLock != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00539 
00540                 OplockCount = (ULONG) <a class="code" href="../../d1/d8/fsrtl_8h.html#a19">FsRtlAreThereCurrentFileLocks</a>( Fcb-&gt;FileLock );
00541             }
00542 
00543         } <span class="keywordflow">else</span> {
00544 
00545             OplockCount = Fcb-&gt;<a class="code" href="../../d7/d9/struct__FCB.html#o7">FcbCleanup</a>;
00546         }
00547 
00548         <span class="keywordflow">break</span>;
00549 
00550     <span class="keywordflow">case</span> FSCTL_OPLOCK_BREAK_ACKNOWLEDGE:
00551     <span class="keywordflow">case</span> FSCTL_OPBATCH_ACK_CLOSE_PENDING:
00552     <span class="keywordflow">case</span> FSCTL_OPLOCK_BREAK_NOTIFY:
00553     <span class="keywordflow">case</span> FSCTL_OPLOCK_BREAK_ACK_NO_2:
00554 
00555         <a class="code" href="../../d3/d8/udfprocs_8h.html#a84">UdfAcquireFcbShared</a>( IrpContext, Fcb, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00556         <span class="keywordflow">break</span>;
00557 
00558     <span class="keywordflow">default</span>:
00559 
00560         <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, STATUS_INVALID_PARAMETER );
00561         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
00562     }
00563 
00564     <span class="comment">//</span>
00565     <span class="comment">//  Use a try finally to free the Fcb.</span>
00566     <span class="comment">//</span>
00567 
00568     <span class="keywordflow">try</span> {
00569 
00570         <span class="comment">//</span>
00571         <span class="comment">//  Verify the Fcb.</span>
00572         <span class="comment">//</span>
00573 
00574         <a class="code" href="../../d8/d5/udfs_2verfysup_8c.html#a6">UdfVerifyFcbOperation</a>( IrpContext, Fcb );
00575 
00576         <span class="comment">//</span>
00577         <span class="comment">//  Call the FsRtl routine to grant/acknowledge oplock.</span>
00578         <span class="comment">//</span>
00579 
00580         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d1/d8/fsrtl_8h.html#a164">FsRtlOplockFsctrl</a>( &amp;Fcb-&gt;Oplock,
00581                                     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>,
00582                                     OplockCount );
00583 
00584         <span class="comment">//</span>
00585         <span class="comment">//  Set the flag indicating if Fast I/O is possible</span>
00586         <span class="comment">//</span>
00587 
00588         <a class="code" href="../../d3/d8/udfprocs_8h.html#a90">UdfLockFcb</a>( IrpContext, Fcb );
00589         Fcb-&gt;IsFastIoPossible = <a class="code" href="../../d3/d8/udfprocs_8h.html#a63">UdfIsFastIoPossible</a>( Fcb );
00590         <a class="code" href="../../d3/d8/udfprocs_8h.html#a91">UdfUnlockFcb</a>( IrpContext, Fcb );
00591 
00592         <span class="comment">//</span>
00593         <span class="comment">//  The oplock package will complete the Irp.</span>
00594         <span class="comment">//</span>
00595 
00596         <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00597 
00598     } finally {
00599 
00600         <span class="comment">//</span>
00601         <span class="comment">//  Release all of our resources</span>
00602         <span class="comment">//</span>
00603 
00604         <a class="code" href="../../d3/d8/udfprocs_8h.html#a85">UdfReleaseFcb</a>( IrpContext, Fcb );
00605     }
00606 
00607     <span class="comment">//</span>
00608     <span class="comment">//  Complete the request if there was no exception.</span>
00609     <span class="comment">//</span>
00610 
00611     <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
00612     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00613 }
00614 
00615 
00616 <span class="comment">//</span>
00617 <span class="comment">//  Local support routine</span>
00618 <span class="comment">//</span>
00619 
00620 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00621"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a190">00621</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a190">UdfLockVolumeInternal</a> (
00622     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00623     IN <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb,
00624     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject OPTIONAL
00625     )
00626 
00627 <span class="comment">/*++</span>
00628 <span class="comment"></span>
00629 <span class="comment">Routine Description:</span>
00630 <span class="comment"></span>
00631 <span class="comment">    This routine performs the actual lock volume operation.  It will be called</span>
00632 <span class="comment">    by anyone wishing to try to protect the volume for a long duration.  PNP</span>
00633 <span class="comment">    operations are such a user.</span>
00634 <span class="comment">    </span>
00635 <span class="comment">    The volume must be held exclusive by the caller.</span>
00636 <span class="comment"></span>
00637 <span class="comment">Arguments:</span>
00638 <span class="comment"></span>
00639 <span class="comment">    Vcb - The volume being locked.</span>
00640 <span class="comment">    </span>
00641 <span class="comment">    FileObject - File corresponding to the handle locking the volume.  If this</span>
00642 <span class="comment">        is not specified, a system lock is assumed.</span>
00643 <span class="comment"></span>
00644 <span class="comment">Return Value:</span>
00645 <span class="comment"></span>
00646 <span class="comment">    NTSTATUS - The return status for the operation</span>
00647 <span class="comment"></span>
00648 <span class="comment">--*/</span>
00649 
00650 {
00651     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00652     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> FinalStatus = (FileObject? STATUS_ACCESS_DENIED: STATUS_DEVICE_BUSY);
00653     ULONG RemainingUserReferences = (FileObject? 1: 0);
00654 
00655     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00656 
00657     <a class="code" href="../../d1/d8/udfdata_8h.html#a40">ASSERT_EXCLUSIVE_VCB</a>( Vcb );
00658     
00659     <span class="comment">//</span>
00660     <span class="comment">//  If the volume is already locked then complete with success if this file</span>
00661     <span class="comment">//  object has the volume locked, fail otherwise.</span>
00662     <span class="comment">//</span>
00663 
00664     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( Vcb-&gt;VcbState, <a class="code" href="../../d6/d8/udfstruc_8h.html#a5">VCB_STATE_LOCKED</a> )) {
00665 
00666         <span class="keywordflow">if</span> (FileObject &amp;&amp; Vcb-&gt;VolumeLockFileObject == FileObject) {
00667 
00668             FinalStatus = STATUS_SUCCESS;
00669         }
00670 
00671     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Vcb-&gt;VcbCleanup == RemainingUserReferences) {
00672 
00673         <span class="comment">//</span>
00674         <span class="comment">//  The cleanup count for the volume only reflects the fileobject that</span>
00675         <span class="comment">//  will lock the volume.  Otherwise, we must fail the request.</span>
00676         <span class="comment">//</span>
00677         <span class="comment">//  Since the only cleanup is for the provided fileobject, we will try</span>
00678         <span class="comment">//  to get rid of all of the other user references.  If there is only one</span>
00679         <span class="comment">//  remaining after the purge then we can allow the volume to be locked.</span>
00680         <span class="comment">//</span>
00681         
00682         <a class="code" href="../../d3/d8/udfprocs_8h.html#a158">UdfPurgeVolume</a>( IrpContext, Vcb, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00683 
00684         <span class="comment">//</span>
00685         <span class="comment">//  Now back out of our synchronization and wait for the lazy writer</span>
00686         <span class="comment">//  to finish off any lazy closes that could have been outstanding.</span>
00687         <span class="comment">//</span>
00688         <span class="comment">//  Since we purged, we know that the lazy writer will issue all</span>
00689         <span class="comment">//  possible lazy closes in the next tick - if we hadn't, an otherwise</span>
00690         <span class="comment">//  unopened file with a large amount of dirty data could have hung</span>
00691         <span class="comment">//  around for a while as the data trickled out to the disk.</span>
00692         <span class="comment">//</span>
00693         <span class="comment">//  This is even more important now since we send notification to</span>
00694         <span class="comment">//  alert other folks that this style of check is about to happen so</span>
00695         <span class="comment">//  that they can close their handles.  We don't want to enter a fast</span>
00696         <span class="comment">//  race with the lazy writer tearing down his references to the file.</span>
00697         <span class="comment">//</span>
00698 
00699         <a class="code" href="../../d3/d8/udfprocs_8h.html#a76">UdfReleaseVcb</a>( IrpContext, Vcb );
00700 
00701         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d5/d1/lazyrite_8c.html#a6">CcWaitForCurrentLazyWriterActivity</a>();
00702 
00703         <span class="comment">//</span>
00704         <span class="comment">//  This is intentional. If we were able to get the Vcb before, just</span>
00705         <span class="comment">//  wait for it and take advantage of knowing that it is OK to leave</span>
00706         <span class="comment">//  the flag up.</span>
00707         <span class="comment">//</span>
00708 
00709         <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( IrpContext-&gt;Flags, <a class="code" href="../../d6/d8/udfstruc_8h.html#a30">IRP_CONTEXT_FLAG_WAIT</a> );
00710         <a class="code" href="../../d3/d8/udfprocs_8h.html#a74">UdfAcquireVcbExclusive</a>( IrpContext, Vcb, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00711         
00712         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
00713 
00714             <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00715         }
00716 
00717         <a class="code" href="../../d3/d8/udfprocs_8h.html#a250">UdfFspClose</a>( Vcb );
00718 
00719         <span class="keywordflow">if</span> (Vcb-&gt;VcbUserReference == Vcb-&gt;VcbResidualUserReference + RemainingUserReferences) {
00720 
00721             <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( Vcb-&gt;VcbState, <a class="code" href="../../d6/d8/udfstruc_8h.html#a5">VCB_STATE_LOCKED</a> );
00722             Vcb-&gt;VolumeLockFileObject = FileObject;
00723             FinalStatus = STATUS_SUCCESS;
00724         }
00725     }
00726     
00727     <span class="keywordflow">return</span> FinalStatus;
00728 }
00729 
00730 
00731 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00732"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a191">00732</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a191">UdfUnlockVolumeInternal</a> (
00733     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00734     IN <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb,
00735     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject OPTIONAL
00736     )
00737 
00738 <span class="comment">/*++</span>
00739 <span class="comment"></span>
00740 <span class="comment">Routine Description:</span>
00741 <span class="comment"></span>
00742 <span class="comment">    This routine performs the actual unlock volume operation. </span>
00743 <span class="comment">    </span>
00744 <span class="comment">    The volume must be held exclusive by the caller.</span>
00745 <span class="comment"></span>
00746 <span class="comment">Arguments:</span>
00747 <span class="comment"></span>
00748 <span class="comment">    Vcb - The volume being locked.</span>
00749 <span class="comment">    </span>
00750 <span class="comment">    FileObject - File corresponding to the handle locking the volume.  If this</span>
00751 <span class="comment">        is not specified, a system lock is assumed.</span>
00752 <span class="comment"></span>
00753 <span class="comment">Return Value:</span>
00754 <span class="comment"></span>
00755 <span class="comment">    NTSTATUS - The return status for the operation</span>
00756 <span class="comment">    </span>
00757 <span class="comment">    Attempting to remove a system lock that did not exist is OK.</span>
00758 <span class="comment"></span>
00759 <span class="comment">--*/</span>
00760 
00761 {
00762     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_PARAMETER;
00763     
00764     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(Vcb-&gt;VcbState, <a class="code" href="../../d6/d8/udfstruc_8h.html#a5">VCB_STATE_LOCKED</a>) &amp;&amp; FileObject == Vcb-&gt;VolumeLockFileObject) {
00765 
00766         <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>( Vcb-&gt;VcbState, <a class="code" href="../../d6/d8/udfstruc_8h.html#a5">VCB_STATE_LOCKED</a> );
00767         Vcb-&gt;VolumeLockFileObject = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00768         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
00769     }
00770 
00771     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00772 }
00773 
00774 
00775 <span class="comment">//</span>
00776 <span class="comment">//  Local support routine</span>
00777 <span class="comment">//</span>
00778 
00779 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00780"></a><a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a14">00780</a> <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a14">UdfLockVolume</a> (
00781     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00782     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
00783     )
00784 
00785 <span class="comment">/*++</span>
00786 <span class="comment"></span>
00787 <span class="comment">Routine Description:</span>
00788 <span class="comment"></span>
00789 <span class="comment">    This routine performs the lock volume operation.  It is responsible for</span>
00790 <span class="comment">    either completing of enqueuing the input Irp.</span>
00791 <span class="comment"></span>
00792 <span class="comment">Arguments:</span>
00793 <span class="comment"></span>
00794 <span class="comment">    Irp - Supplies the Irp to process</span>
00795 <span class="comment"></span>
00796 <span class="comment">Return Value:</span>
00797 <span class="comment"></span>
00798 <span class="comment">    NTSTATUS - The return status for the operation</span>
00799 <span class="comment"></span>
00800 <span class="comment">--*/</span>
00801 
00802 {
00803     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00804 
00805     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> IrpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
00806 
00807     <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb;
00808     <a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a> Fcb;
00809     <a class="code" href="../../d2/d9/struct__CCB.html">PCCB</a> Ccb;
00810 
00811     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00812 
00813     <span class="comment">//</span>
00814     <span class="comment">//  Decode the file object, the only type of opens we accept are</span>
00815     <span class="comment">//  user volume opens.</span>
00816     <span class="comment">//</span>
00817 
00818     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d8/udfprocs_8h.html#a174">UdfDecodeFileObject</a>( IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a>, &amp;Fcb, &amp;Ccb ) != <a class="code" href="../../d3/d8/udfprocs_8h.html#a263a115">UserVolumeOpen</a>) {
00819 
00820         <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, STATUS_INVALID_PARAMETER );
00821 
00822         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
00823     }
00824 
00825     <span class="comment">//</span>
00826     <span class="comment">//  Send our notification so that folks that like to hold handles on</span>
00827     <span class="comment">//  volumes can get out of the way.</span>
00828     <span class="comment">//</span>
00829 
00830     <a class="code" href="../../d1/d8/fsrtl_8h.html#a168">FsRtlNotifyVolumeEvent</a>( IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a>, <a class="code" href="../../d1/d8/fsrtl_8h.html#a41">FSRTL_VOLUME_LOCK</a> );
00831 
00832     <span class="comment">//</span>
00833     <span class="comment">//  Acquire exclusive access to the Vcb.</span>
00834     <span class="comment">//</span>
00835 
00836     Vcb = Fcb-&gt;<a class="code" href="../../d7/d9/struct__FCB.html#o2">Vcb</a>;
00837     <a class="code" href="../../d3/d8/udfprocs_8h.html#a74">UdfAcquireVcbExclusive</a>( IrpContext, Vcb, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00838 
00839     <span class="keywordflow">try</span> {
00840 
00841         <span class="comment">//</span>
00842         <span class="comment">//  Verify the Vcb.</span>
00843         <span class="comment">//</span>
00844 
00845         <a class="code" href="../../d8/d5/udfs_2verfysup_8c.html#a5">UdfVerifyVcb</a>( IrpContext, Vcb );
00846 
00847         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a190">UdfLockVolumeInternal</a>( IrpContext, Vcb, IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> );
00848 
00849     } finally {
00850 
00851         <span class="comment">//</span>
00852         <span class="comment">//  Release the Vcb.</span>
00853         <span class="comment">//</span>
00854 
00855         <a class="code" href="../../d3/d8/udfprocs_8h.html#a76">UdfReleaseVcb</a>( IrpContext, Vcb );
00856 
00857         <span class="keywordflow">if</span> (AbnormalTermination() || !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
00858 
00859             <a class="code" href="../../d1/d8/fsrtl_8h.html#a168">FsRtlNotifyVolumeEvent</a>( IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a>, <a class="code" href="../../d1/d8/fsrtl_8h.html#a42">FSRTL_VOLUME_LOCK_FAILED</a> );
00860         }
00861     }
00862 
00863     <span class="comment">//</span>
00864     <span class="comment">//  Complete the request if there haven't been any exceptions.</span>
00865     <span class="comment">//</span>
00866 
00867     <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
00868     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00869 }
00870 
00871 
00872 <span class="comment">//</span>
00873 <span class="comment">//  Local support routine</span>
00874 <span class="comment">//</span>
00875 
00876 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00877"></a><a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a19">00877</a> <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a19">UdfUnlockVolume</a> (
00878     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00879     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
00880     )
00881 
00882 <span class="comment">/*++</span>
00883 <span class="comment"></span>
00884 <span class="comment">Routine Description:</span>
00885 <span class="comment"></span>
00886 <span class="comment">    This routine performs the unlock volume operation.  It is responsible for</span>
00887 <span class="comment">    either completing of enqueuing the input Irp.</span>
00888 <span class="comment"></span>
00889 <span class="comment">Arguments:</span>
00890 <span class="comment"></span>
00891 <span class="comment">    Irp - Supplies the Irp to process</span>
00892 <span class="comment"></span>
00893 <span class="comment">Return Value:</span>
00894 <span class="comment"></span>
00895 <span class="comment">    NTSTATUS - The return status for the operation</span>
00896 <span class="comment"></span>
00897 <span class="comment">--*/</span>
00898 
00899 {
00900     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00901 
00902     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> IrpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
00903 
00904     <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb;
00905     <a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a> Fcb;
00906     <a class="code" href="../../d2/d9/struct__CCB.html">PCCB</a> Ccb;
00907 
00908     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00909 
00910     <span class="comment">//</span>
00911     <span class="comment">//  Decode the file object, the only type of opens we accept are</span>
00912     <span class="comment">//  user volume opens.</span>
00913     <span class="comment">//</span>
00914 
00915     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d8/udfprocs_8h.html#a174">UdfDecodeFileObject</a>( IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a>, &amp;Fcb, &amp;Ccb ) != <a class="code" href="../../d3/d8/udfprocs_8h.html#a263a115">UserVolumeOpen</a> ) {
00916 
00917         <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, STATUS_INVALID_PARAMETER );
00918         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
00919     }
00920 
00921     <span class="comment">//</span>
00922     <span class="comment">//  Acquire exclusive access to the Vcb.</span>
00923     <span class="comment">//</span>
00924 
00925     Vcb = Fcb-&gt;<a class="code" href="../../d7/d9/struct__FCB.html#o2">Vcb</a>;
00926 
00927     <a class="code" href="../../d3/d8/udfprocs_8h.html#a74">UdfAcquireVcbExclusive</a>( IrpContext, Vcb, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00928 
00929     <span class="comment">//</span>
00930     <span class="comment">//  We won't check for a valid Vcb for this request.  An unlock will always</span>
00931     <span class="comment">//  succeed on a locked volume.</span>
00932     <span class="comment">//</span>
00933 
00934     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a191">UdfUnlockVolumeInternal</a>( IrpContext, Vcb, IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> );    
00935     
00936     <span class="comment">//</span>
00937     <span class="comment">//  Release all of our resources</span>
00938     <span class="comment">//</span>
00939 
00940     <a class="code" href="../../d3/d8/udfprocs_8h.html#a76">UdfReleaseVcb</a>( IrpContext, Vcb );
00941 
00942     <span class="comment">//</span>
00943     <span class="comment">//  Send notification that the volume is avaliable.</span>
00944     <span class="comment">//</span>
00945 
00946     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
00947 
00948         <a class="code" href="../../d1/d8/fsrtl_8h.html#a168">FsRtlNotifyVolumeEvent</a>( IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a>, <a class="code" href="../../d1/d8/fsrtl_8h.html#a43">FSRTL_VOLUME_UNLOCK</a> );
00949     }
00950 
00951     <span class="comment">//</span>
00952     <span class="comment">//  Complete the request if there haven't been any exceptions.</span>
00953     <span class="comment">//</span>
00954 
00955     <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
00956     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00957 }
00958 
00959 
00960 
00961 <span class="comment">//</span>
00962 <span class="comment">//  Local support routine</span>
00963 <span class="comment">//</span>
00964 
00965 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00966"></a><a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a5">00966</a> <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a5">UdfDismountVolume</a> (
00967     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00968     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
00969     )
00970 
00971 <span class="comment">/*++</span>
00972 <span class="comment"></span>
00973 <span class="comment">Routine Description:</span>
00974 <span class="comment"></span>
00975 <span class="comment">    This routine performs the dismount volume operation.  It is responsible for</span>
00976 <span class="comment">    either completing of enqueuing the input Irp.  We only dismount a volume which</span>
00977 <span class="comment">    has been locked.  The intent here is that someone has locked the volume (they are the</span>
00978 <span class="comment">    only remaining handle).  We set the volume state to invalid so that it will be torn</span>
00979 <span class="comment">    down quickly.</span>
00980 <span class="comment"></span>
00981 <span class="comment">Arguments:</span>
00982 <span class="comment"></span>
00983 <span class="comment">    Irp - Supplies the Irp to process</span>
00984 <span class="comment"></span>
00985 <span class="comment">Return Value:</span>
00986 <span class="comment"></span>
00987 <span class="comment">    NTSTATUS - The return status for the operation</span>
00988 <span class="comment"></span>
00989 <span class="comment">--*/</span>
00990 
00991 {
00992     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00993     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> IrpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
00994 
00995     <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb;
00996     <a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a> Fcb;
00997     <a class="code" href="../../d2/d9/struct__CCB.html">PCCB</a> Ccb;
00998 
00999     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01000 
01001     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d8/udfprocs_8h.html#a174">UdfDecodeFileObject</a>( IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a>, &amp;Fcb, &amp;Ccb ) != <a class="code" href="../../d3/d8/udfprocs_8h.html#a263a115">UserVolumeOpen</a> ) {
01002 
01003         <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, STATUS_INVALID_PARAMETER );
01004         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
01005     }
01006 
01007     <span class="comment">//</span>
01008     <span class="comment">//  Send notification.</span>
01009     <span class="comment">//</span>
01010     
01011     <a class="code" href="../../d1/d8/fsrtl_8h.html#a168">FsRtlNotifyVolumeEvent</a>( IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a>, <a class="code" href="../../d1/d8/fsrtl_8h.html#a39">FSRTL_VOLUME_DISMOUNT</a> );
01012 
01013     <span class="comment">//</span>
01014     <span class="comment">//  Acquire exclusive access to the Vcb.</span>
01015     <span class="comment">//</span>
01016 
01017     Vcb = Fcb-&gt;<a class="code" href="../../d7/d9/struct__FCB.html#o2">Vcb</a>;
01018 
01019     <a class="code" href="../../d3/d8/udfprocs_8h.html#a74">UdfAcquireVcbExclusive</a>( IrpContext, Vcb, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01020 
01021     <span class="comment">//</span>
01022     <span class="comment">//  Mark the volume as invalid, but only do it if the vcb is locked</span>
01023     <span class="comment">//  by this handle and the volume is currently mounted.  No more</span>
01024     <span class="comment">//  operations will occur on this vcb except cleanup/close.</span>
01025     <span class="comment">//</span>
01026 
01027     <span class="keywordflow">if</span> ((Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o8">VcbCondition</a> != <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a119">VcbMounted</a>) &amp;&amp;
01028         (Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o9">VolumeLockFileObject</a> != IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a>)) {
01029 
01030         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_NOT_IMPLEMENTED;
01031 
01032     } <span class="keywordflow">else</span> {
01033 
01034         <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o2">Vpb</a>-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a>-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o8">Flags</a>, <a class="code" href="../../d0/d5/io_8h.html#a122">DO_VERIFY_VOLUME</a> );
01035         <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o7">VcbState</a>, <a class="code" href="../../d6/d8/udfstruc_8h.html#a7">VCB_STATE_NOTIFY_REMOUNT</a> );
01036 
01037         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
01038     }
01039 
01040     <span class="comment">//</span>
01041     <span class="comment">//  Release all of our resources</span>
01042     <span class="comment">//</span>
01043 
01044     <a class="code" href="../../d3/d8/udfprocs_8h.html#a76">UdfReleaseVcb</a>( IrpContext, Vcb );
01045 
01046     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
01047 
01048         <a class="code" href="../../d1/d8/fsrtl_8h.html#a168">FsRtlNotifyVolumeEvent</a>( IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a>, <a class="code" href="../../d1/d8/fsrtl_8h.html#a40">FSRTL_VOLUME_DISMOUNT_FAILED</a> );
01049     }
01050 
01051     <span class="comment">//</span>
01052     <span class="comment">//  Complete the request if there haven't been any exceptions.</span>
01053     <span class="comment">//</span>
01054 
01055     <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
01056     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01057 }
01058 
01059 
01060 <span class="comment">//</span>
01061 <span class="comment">//  Local support routine</span>
01062 <span class="comment">//</span>
01063 
<a name="l01064"></a><a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a12">01064</a> <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a12">UdfIsVolumeDirty</a> (
01065     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01066     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
01067     )
01068 
01069 <span class="comment">/*++</span>
01070 <span class="comment"></span>
01071 <span class="comment">Routine Description:</span>
01072 <span class="comment"></span>
01073 <span class="comment">    This routine determines if a volume is currently dirty.</span>
01074 <span class="comment"></span>
01075 <span class="comment">Arguments:</span>
01076 <span class="comment"></span>
01077 <span class="comment">    Irp - Supplies the Irp to process</span>
01078 <span class="comment"></span>
01079 <span class="comment">Return Value:</span>
01080 <span class="comment"></span>
01081 <span class="comment">    NTSTATUS - The return status for the operation</span>
01082 <span class="comment"></span>
01083 <span class="comment">--*/</span>
01084 
01085 {
01086     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> IrpSp;
01087 
01088     <a class="code" href="../../d3/d8/udfprocs_8h.html#a109">TYPE_OF_OPEN</a> TypeOfOpen;
01089     <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb;
01090     <a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a> Fcb;
01091     <a class="code" href="../../d2/d9/struct__CCB.html">PCCB</a> Ccb;
01092 
01093     PULONG VolumeState;
01094     
01095     <span class="comment">//</span>
01096     <span class="comment">//  Get the current stack location and extract the output</span>
01097     <span class="comment">//  buffer information.</span>
01098     <span class="comment">//</span>
01099 
01100     IrpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
01101 
01102     <span class="comment">//</span>
01103     <span class="comment">//  Get a pointer to the output buffer.  Look at the system buffer field in the</span>
01104     <span class="comment">//  irp first.  Then the Irp Mdl.</span>
01105     <span class="comment">//</span>
01106 
01107     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01108 
01109         VolumeState = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer;
01110 
01111     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01112 
01113         VolumeState = <a class="code" href="../../d2/d1/mm_8h.html#a25">MmGetSystemAddressForMdlSafe</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a>, <a class="code" href="../../d2/d1/mm_8h.html#a347a182">NormalPagePriority</a> );
01114 
01115         <span class="keywordflow">if</span> (<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> == VolumeState)  {
01116         
01117             <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, STATUS_INSUFFICIENT_RESOURCES );
01118             <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
01119         }
01120     } <span class="keywordflow">else</span> {
01121 
01122         <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, STATUS_INVALID_USER_BUFFER );
01123         <span class="keywordflow">return</span> STATUS_INVALID_USER_BUFFER;
01124     }
01125 
01126     <span class="comment">//</span>
01127     <span class="comment">//  Make sure the output buffer is large enough and then initialize</span>
01128     <span class="comment">//  the answer to be that the volume isn't dirty.</span>
01129     <span class="comment">//</span>
01130 
01131     <span class="keywordflow">if</span> (IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.FileSystemControl.OutputBufferLength &lt; <span class="keyword">sizeof</span>(ULONG)) {
01132 
01133         <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, STATUS_INVALID_PARAMETER );
01134         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
01135     }
01136 
01137     *VolumeState = 0;
01138 
01139     <span class="comment">//</span>
01140     <span class="comment">//  Decode the file object</span>
01141     <span class="comment">//</span>
01142 
01143     TypeOfOpen = <a class="code" href="../../d3/d8/udfprocs_8h.html#a174">UdfDecodeFileObject</a>( IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a>, &amp;Fcb, &amp;Ccb );
01144 
01145     <span class="keywordflow">if</span> (TypeOfOpen != <a class="code" href="../../d3/d8/udfprocs_8h.html#a263a115">UserVolumeOpen</a>) {
01146 
01147         <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, STATUS_INVALID_PARAMETER );
01148         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
01149     }
01150 
01151     <span class="keywordflow">if</span> (Fcb-&gt;<a class="code" href="../../d7/d9/struct__FCB.html#o2">Vcb</a>-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o8">VcbCondition</a> != <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a119">VcbMounted</a>) {
01152 
01153         <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, STATUS_VOLUME_DISMOUNTED );
01154         <span class="keywordflow">return</span> STATUS_VOLUME_DISMOUNTED;
01155     }
01156 
01157     <span class="comment">//</span>
01158     <span class="comment">//  Now set up to return the clean state.  If we paid attention to the dirty</span>
01159     <span class="comment">//  state of the media we could be more accurate, but since this is a readonly</span>
01160     <span class="comment">//  implementation at the moment we think it is clean all of the time.</span>
01161     <span class="comment">//</span>
01162     
01163     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information = <span class="keyword">sizeof</span>( ULONG );
01164 
01165     <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, STATUS_SUCCESS );
01166     <span class="keywordflow">return</span> STATUS_SUCCESS;
01167 }
01168 
01169 
01170 <span class="comment">//</span>
01171 <span class="comment">//  Local support routine</span>
01172 <span class="comment">//</span>
01173 
01174 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01175"></a><a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a13">01175</a> <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a13">UdfIsVolumeMounted</a> (
01176     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01177     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
01178     )
01179 
01180 <span class="comment">/*++</span>
01181 <span class="comment"></span>
01182 <span class="comment">Routine Description:</span>
01183 <span class="comment"></span>
01184 <span class="comment">    This routine determines if a volume is currently mounted.</span>
01185 <span class="comment"></span>
01186 <span class="comment">Arguments:</span>
01187 <span class="comment"></span>
01188 <span class="comment">    Irp - Supplies the Irp to process</span>
01189 <span class="comment"></span>
01190 <span class="comment">Return Value:</span>
01191 <span class="comment"></span>
01192 <span class="comment">    NTSTATUS - The return status for the operation</span>
01193 <span class="comment"></span>
01194 <span class="comment">--*/</span>
01195 
01196 {
01197     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> IrpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
01198 
01199     <a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a> Fcb;
01200     <a class="code" href="../../d2/d9/struct__CCB.html">PCCB</a> Ccb;
01201 
01202     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01203 
01204     <span class="comment">//</span>
01205     <span class="comment">//  Decode the file object.</span>
01206     <span class="comment">//</span>
01207 
01208     <a class="code" href="../../d3/d8/udfprocs_8h.html#a174">UdfDecodeFileObject</a>( IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a>, &amp;Fcb, &amp;Ccb );
01209 
01210     <span class="keywordflow">if</span> (Fcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01211 
01212         <span class="comment">//</span>
01213         <span class="comment">//  Disable PopUps, we want to return any error.</span>
01214         <span class="comment">//</span>
01215 
01216         <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( IrpContext-&gt;Flags, <a class="code" href="../../d6/d8/udfstruc_8h.html#a37">IRP_CONTEXT_FLAG_DISABLE_POPUPS</a> );
01217 
01218         <span class="comment">//</span>
01219         <span class="comment">//  Verify the Vcb.  This will raise in the error condition.</span>
01220         <span class="comment">//</span>
01221 
01222         <a class="code" href="../../d8/d5/udfs_2verfysup_8c.html#a5">UdfVerifyVcb</a>( IrpContext, Fcb-&gt;<a class="code" href="../../d7/d9/struct__FCB.html#o2">Vcb</a> );
01223     }
01224 
01225     <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, STATUS_SUCCESS );
01226 
01227     <span class="keywordflow">return</span> STATUS_SUCCESS;
01228 }
01229 
01230 
01231 <span class="comment">//</span>
01232 <span class="comment">//  Local support routine</span>
01233 <span class="comment">//</span>
01234 
01235 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01236"></a><a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a10">01236</a> <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a10">UdfIsPathnameValid</a> (
01237     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01238     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
01239     )
01240 
01241 <span class="comment">/*++</span>
01242 <span class="comment"></span>
01243 <span class="comment">Routine Description:</span>
01244 <span class="comment"></span>
01245 <span class="comment">    This routine determines if pathname is a valid UDFS pathname.</span>
01246 <span class="comment">    We always succeed this request.</span>
01247 <span class="comment"></span>
01248 <span class="comment">Arguments:</span>
01249 <span class="comment"></span>
01250 <span class="comment">    Irp - Supplies the Irp to process.</span>
01251 <span class="comment"></span>
01252 <span class="comment">Return Value:</span>
01253 <span class="comment"></span>
01254 <span class="comment">    None</span>
01255 <span class="comment"></span>
01256 <span class="comment">--*/</span>
01257 
01258 {
01259     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01260 
01261     <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, STATUS_SUCCESS );
01262     <span class="keywordflow">return</span> STATUS_SUCCESS;
01263 }
01264 
01265 
01266 <span class="comment">//</span>
01267 <span class="comment">//  Local support routine</span>
01268 <span class="comment">//</span>
01269 
01270 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01271"></a><a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a9">01271</a> <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a9">UdfInvalidateVolumes</a> (
01272     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01273     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
01274     )
01275 
01276 <span class="comment">/*++</span>
01277 <span class="comment"></span>
01278 <span class="comment">Routine Description:</span>
01279 <span class="comment"></span>
01280 <span class="comment">    This routine searches for all the volumes mounted on the same real device</span>
01281 <span class="comment">    of the current DASD handle, and marks them all bad.  The only operation</span>
01282 <span class="comment">    that can be done on such handles is cleanup and close.</span>
01283 <span class="comment"></span>
01284 <span class="comment">Arguments:</span>
01285 <span class="comment"></span>
01286 <span class="comment">    Irp - Supplies the Irp to process</span>
01287 <span class="comment"></span>
01288 <span class="comment">Return Value:</span>
01289 <span class="comment"></span>
01290 <span class="comment">    NTSTATUS - The return status for the operation</span>
01291 <span class="comment"></span>
01292 <span class="comment">--*/</span>
01293 
01294 {
01295     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01296     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> IrpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
01297     KIRQL SavedIrql;
01298 
01299     LUID <a class="code" href="../../d4/d6/tsevars_8c.html#a45">TcbPrivilege</a> = {SE_TCB_PRIVILEGE, 0};
01300 
01301     HANDLE <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>;
01302 
01303     <a class="code" href="../../d7/d7/struct__VPB.html">PVPB</a> NewVpb;
01304     <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb;
01305 
01306     PLIST_ENTRY Links;
01307 
01308     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileToMarkBad;
01309     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceToMarkBad;
01310 
01311     <span class="comment">//</span>
01312     <span class="comment">//  Check for the correct security access.</span>
01313     <span class="comment">//  The caller must have the SeTcbPrivilege.</span>
01314     <span class="comment">//</span>
01315 
01316     <span class="keywordflow">if</span> (!<a class="code" href="../../d8/d4/privileg_8c.html#a3">SeSinglePrivilegeCheck</a>( <a class="code" href="../../d4/d6/tsevars_8c.html#a45">TcbPrivilege</a>, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o10">RequestorMode</a> )) {
01317 
01318         <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, STATUS_PRIVILEGE_NOT_HELD );
01319 
01320         <span class="keywordflow">return</span> STATUS_PRIVILEGE_NOT_HELD;
01321     }
01322 
01323     <span class="comment">//</span>
01324     <span class="comment">//  Try to get a pointer to the device object from the handle passed in.</span>
01325     <span class="comment">//</span>
01326 
01327     <span class="keywordflow">if</span> (IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.FileSystemControl.InputBufferLength != <span class="keyword">sizeof</span>( HANDLE )) {
01328 
01329         <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, STATUS_INVALID_PARAMETER );
01330         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
01331     }
01332 
01333     <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a> = *((PHANDLE) <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer);
01334 
01335     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a>( <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>,
01336                                         0,
01337                                         *<a class="code" href="../../d5/d8/fssup_8c.html#a3">IoFileObjectType</a>,
01338                                         <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
01339                                         &amp;FileToMarkBad,
01340                                         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01341 
01342     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
01343 
01344         <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
01345         <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01346     }
01347 
01348     <span class="comment">//</span>
01349     <span class="comment">//  Grab the DeviceObject from the FileObject.</span>
01350     <span class="comment">//</span>
01351 
01352     DeviceToMarkBad = FileToMarkBad-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o2">DeviceObject</a>;
01353 
01354     <span class="comment">//</span>
01355     <span class="comment">//  We only needed the device object involved, not a reference to the file.</span>
01356     <span class="comment">//</span>
01357 
01358     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( FileToMarkBad );
01359 
01360     <span class="comment">//</span>
01361     <span class="comment">//  Create a new Vpb for this device so that any new opens will mount</span>
01362     <span class="comment">//  a new volume.</span>
01363     <span class="comment">//</span>
01364 
01365     NewVpb = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a175">NonPagedPoolMustSucceed</a>, <span class="keyword">sizeof</span>( <a class="code" href="../../d7/d7/struct__VPB.html">VPB</a> ), <a class="code" href="../../d1/d7/udfs_2nodetype_8h.html#a84">TAG_VPB</a> );
01366     RtlZeroMemory( NewVpb, <span class="keyword">sizeof</span>( <a class="code" href="../../d0/d5/io_8h.html#a332">VPB</a> ) );
01367 
01368     NewVpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o0">Type</a> = <a class="code" href="../../d0/d5/io_8h.html#a9">IO_TYPE_VPB</a>;
01369     NewVpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o1">Size</a> = <span class="keyword">sizeof</span>( <a class="code" href="../../d0/d5/io_8h.html#a332">VPB</a> );
01370     NewVpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a> = DeviceToMarkBad;
01371     NewVpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o2">Flags</a> = <a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( DeviceToMarkBad-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o10">Vpb</a>-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o2">Flags</a>, <a class="code" href="../../d0/d5/io_8h.html#a119">VPB_REMOVE_PENDING</a> );
01372 
01373     <span class="comment">//</span>
01374     <span class="comment">//  Make sure this request can wait.</span>
01375     <span class="comment">//</span>
01376 
01377     <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( IrpContext-&gt;Flags, <a class="code" href="../../d6/d8/udfstruc_8h.html#a30">IRP_CONTEXT_FLAG_WAIT</a> );
01378     <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>( IrpContext-&gt;Flags, <a class="code" href="../../d6/d8/udfstruc_8h.html#a31">IRP_CONTEXT_FLAG_FORCE_POST</a> );
01379 
01380     <a class="code" href="../../d3/d8/udfprocs_8h.html#a72">UdfAcquireUdfData</a>( IrpContext );
01381 
01382     <span class="comment">//</span>
01383     <span class="comment">//  Nothing can go wrong now.</span>
01384     <span class="comment">//</span>
01385 
01386     <a class="code" href="../../d4/d6/iosubs_8c.html#a10">IoAcquireVpbSpinLock</a>( &amp;SavedIrql );
01387     DeviceToMarkBad-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o10">Vpb</a> = NewVpb;
01388     <a class="code" href="../../d4/d6/iosubs_8c.html#a102">IoReleaseVpbSpinLock</a>( SavedIrql );
01389 
01390     <span class="comment">//</span>
01391     <span class="comment">//  Now walk through all the mounted Vcb's looking for candidates to</span>
01392     <span class="comment">//  mark invalid.</span>
01393     <span class="comment">//</span>
01394     <span class="comment">//  On volumes we mark invalid, check for dismount possibility (which is</span>
01395     <span class="comment">//  why we have to get the next link so early).</span>
01396     <span class="comment">//</span>
01397 
01398     Links = <a class="code" href="../../d0/d8/udfdata_8c.html#a2">UdfData</a>.<a class="code" href="../../d2/d3/struct__UDF__DATA.html#o3">VcbQueue</a>.Flink;
01399 
01400     <span class="keywordflow">while</span> (Links != &amp;<a class="code" href="../../d0/d8/udfdata_8c.html#a2">UdfData</a>.<a class="code" href="../../d2/d3/struct__UDF__DATA.html#o3">VcbQueue</a>) {
01401 
01402         Vcb = CONTAINING_RECORD( Links, <a class="code" href="../../d7/d5/struct__VCB.html">VCB</a>, VcbLinks);
01403 
01404         Links = Links-&gt;Flink;
01405 
01406         <span class="comment">//</span>
01407         <span class="comment">//  If we get a match, mark the volume Bad, and also check to</span>
01408         <span class="comment">//  see if the volume should go away.</span>
01409         <span class="comment">//</span>
01410 
01411         <a class="code" href="../../d3/d8/udfprocs_8h.html#a88">UdfLockVcb</a>( IrpContext, Vcb );
01412 
01413         <span class="keywordflow">if</span> (Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o2">Vpb</a>-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a> == DeviceToMarkBad) {
01414 
01415             <span class="keywordflow">if</span> (Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o8">VcbCondition</a> != <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a121">VcbDismountInProgress</a>) {
01416                 
01417                 Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o8">VcbCondition</a> = <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a120">VcbInvalid</a>;
01418             }
01419 
01420             <a class="code" href="../../d3/d8/udfprocs_8h.html#a89">UdfUnlockVcb</a>( IrpContext, Vcb );
01421 
01422             <a class="code" href="../../d3/d8/udfprocs_8h.html#a158">UdfPurgeVolume</a>( IrpContext, Vcb, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01423 
01424             <a class="code" href="../../d8/d5/udfs_2verfysup_8c.html#a3">UdfCheckForDismount</a>( IrpContext, Vcb, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01425 
01426         } <span class="keywordflow">else</span> {
01427 
01428             <a class="code" href="../../d3/d8/udfprocs_8h.html#a89">UdfUnlockVcb</a>( IrpContext, Vcb );
01429         }
01430     }
01431 
01432     <a class="code" href="../../d3/d8/udfprocs_8h.html#a73">UdfReleaseUdfData</a>( IrpContext );
01433 
01434     <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, STATUS_SUCCESS );
01435     <span class="keywordflow">return</span> STATUS_SUCCESS;
01436 }
01437 
01438 
01439 <span class="comment">//</span>
01440 <span class="comment">//  Local support routine</span>
01441 <span class="comment">//</span>
01442 
01443 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01444"></a><a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a15">01444</a> <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a15">UdfMountVolume</a> (
01445     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01446     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
01447     )
01448 
01449 <span class="comment">/*++</span>
01450 <span class="comment"></span>
01451 <span class="comment">Routine Description:</span>
01452 <span class="comment"></span>
01453 <span class="comment">    This routine performs the mount volume operation.  It is responsible for</span>
01454 <span class="comment">    either completing of enqueuing the input Irp.</span>
01455 <span class="comment"></span>
01456 <span class="comment">    Its job is to verify that the volume denoted in the IRP is a UDF volume,</span>
01457 <span class="comment">    and create the VCB and root directory FCB structures.  The algorithm it</span>
01458 <span class="comment">    uses is essentially as follows:</span>
01459 <span class="comment"></span>
01460 <span class="comment">    1. Create a new Vcb Structure, and initialize it enough to do I/O</span>
01461 <span class="comment">       through the on-disk volume descriptors.</span>
01462 <span class="comment"></span>
01463 <span class="comment">    2. Read the disk and check if it is a UDF volume.</span>
01464 <span class="comment"></span>
01465 <span class="comment">    3. If it is not a UDF volume then delete the Vcb and</span>
01466 <span class="comment">       complete the IRP with STATUS_UNRECOGNIZED_VOLUME</span>
01467 <span class="comment"></span>
01468 <span class="comment">    4. Check if the volume was previously mounted and if it was then do a</span>
01469 <span class="comment">       remount operation.  This involves deleting the VCB, hook in the</span>
01470 <span class="comment">       old VCB, and complete the IRP.</span>
01471 <span class="comment"></span>
01472 <span class="comment">    5. Otherwise create a Vcb and root directory FCB</span>
01473 <span class="comment"></span>
01474 <span class="comment">Arguments:</span>
01475 <span class="comment"></span>
01476 <span class="comment">    Irp - Supplies the Irp to process</span>
01477 <span class="comment"></span>
01478 <span class="comment">Return Value:</span>
01479 <span class="comment"></span>
01480 <span class="comment">    NTSTATUS - The return status for the operation</span>
01481 <span class="comment"></span>
01482 <span class="comment">--*/</span>
01483 
01484 {
01485     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01486 
01487     <a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html">PVOLUME_DEVICE_OBJECT</a> VolDo = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01488     <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01489     <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> OldVcb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01490     <a class="code" href="../../d4/d9/struct__PCB.html">PPCB</a> Pcb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01491 
01492     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> IrpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
01493     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObjectWeTalkTo = IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.MountVolume.DeviceObject;
01494     <a class="code" href="../../d7/d7/struct__VPB.html">PVPB</a> Vpb = IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.MountVolume.Vpb;
01495 
01496     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObjectToNotify = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01497 
01498     ULONG MediaChangeCount = 0;
01499 
01500     DISK_GEOMETRY DiskGeometry;
01501 
01502     <a class="code" href="../../d7/d1/structNSR__ANCHOR.html">PNSR_ANCHOR</a> AnchorVolumeDescriptor = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01503     <a class="code" href="../../d0/d3/structNSR__PVD.html">PNSR_PVD</a> PrimaryVolumeDescriptor = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01504     <a class="code" href="../../d6/d2/structNSR__LVOL.html">PNSR_LVOL</a> LogicalVolumeDescriptor = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01505     <a class="code" href="../../d2/d2/structNSR__FSD.html">PNSR_FSD</a> FileSetDescriptor = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01506 
01507     BOOLEAN BridgeMedia;
01508 
01509     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01510 
01511     <span class="comment">//</span>
01512     <span class="comment">//  Check the input parameters</span>
01513     <span class="comment">//</span>
01514 
01515     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
01516     <a class="code" href="../../d1/d8/udfdata_8h.html#a32">ASSERT_IRP</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
01517 
01518     <span class="comment">//</span>
01519     <span class="comment">//  Check that we are talking to a Cdrom or Disk device.  This request should</span>
01520     <span class="comment">//  always be waitable.</span>
01521     <span class="comment">//</span>
01522 
01523     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a>-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o12">DeviceType</a> == FILE_DEVICE_CD_ROM ||
01524             Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a>-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o12">DeviceType</a> == FILE_DEVICE_DISK );
01525     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( IrpContext-&gt;Flags, <a class="code" href="../../d6/d8/udfstruc_8h.html#a30">IRP_CONTEXT_FLAG_WAIT</a> ));
01526 
01527     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfMountVolume\n"</span> ));
01528 
01529     <span class="comment">//</span>
01530     <span class="comment">//  Update the real device in the IrpContext from the Vpb.  There was no available</span>
01531     <span class="comment">//  file object when the IrpContext was created.</span>
01532     <span class="comment">//</span>
01533 
01534     IrpContext-&gt;RealDevice = Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a>;
01535 
01536     <span class="comment">//</span>
01537     <span class="comment">//  Check if we have disabled the mount process.</span>
01538     <span class="comment">//</span>
01539 
01540     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a2">UdfDisable</a>) {
01541 
01542         <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, STATUS_UNRECOGNIZED_VOLUME );
01543         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfMountVolume, disabled\n"</span> ));
01544         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfMountVolume -&gt; STATUS_UNRECOGNIZED_VOLUME\n"</span> ));
01545 
01546         <span class="keywordflow">return</span> STATUS_UNRECOGNIZED_VOLUME;
01547     }
01548 
01549     <span class="comment">//</span>
01550     <span class="comment">//  Do a CheckVerify here to lift the MediaChange ticker from the driver</span>
01551     <span class="comment">//</span>
01552 
01553     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a159">UdfPerformDevIoCtrl</a>( IrpContext,
01554                                   ( Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a>-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o12">DeviceType</a> == FILE_DEVICE_CD_ROM ?
01555                                     IOCTL_CDROM_CHECK_VERIFY :
01556                                     IOCTL_DISK_CHECK_VERIFY ),
01557                                   DeviceObjectWeTalkTo,
01558                                   &amp;MediaChangeCount,
01559                                   <span class="keyword">sizeof</span>(ULONG),
01560                                   <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01561                                   <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
01562                                   <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01563 
01564     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
01565         
01566         <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
01567         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
01568                      <span class="stringliteral">"UdfMountVolume, CHECK_VERIFY handed back status %08x (so don't continue)\n"</span>,
01569                      <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ));
01570         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
01571                      <span class="stringliteral">"UdfMountVolume -&gt; %08x\n"</span>,
01572                      <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ));
01573 
01574         <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01575     }
01576     
01577     <span class="comment">//</span>
01578     <span class="comment">//  Now let's make Jeff delirious and call to get the disk geometry.  This</span>
01579     <span class="comment">//  will fix the case where the first change line is swallowed.</span>
01580     <span class="comment">//</span>
01581     <span class="comment">//  This IOCTL does not have a generic STORAGE equivalent, so we must figure</span>
01582     <span class="comment">//  our which variant to pass down from the real underlying device object (as</span>
01583     <span class="comment">//  opposed to the top of the driver filter stack we will really be attaching</span>
01584     <span class="comment">//  on top of).</span>
01585     <span class="comment">//</span>
01586 
01587     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a159">UdfPerformDevIoCtrl</a>( IrpContext,
01588                                   ( Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a>-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o12">DeviceType</a> == FILE_DEVICE_CD_ROM ?
01589                                     IOCTL_CDROM_GET_DRIVE_GEOMETRY :
01590                                     IOCTL_DISK_GET_DRIVE_GEOMETRY ),
01591                                   DeviceObjectWeTalkTo,
01592                                   &amp;DiskGeometry,
01593                                   <span class="keyword">sizeof</span>( DISK_GEOMETRY ),
01594                                   <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01595                                   <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
01596                                   <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01597 
01598     <span class="comment">//</span>
01599     <span class="comment">//  If this call failed, we might be able to get away with a heuristic guess as to</span>
01600     <span class="comment">//  what the sector size is (per CDFS), but that is playing with fire.  Nearly every</span>
01601     <span class="comment">//  failure here will be a permanent problem of some form.</span>
01602     <span class="comment">//</span>
01603 
01604     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
01605 
01606         <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
01607         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfMountVolume, GET_DRIVE_GEOMETRY failed\n"</span> ));
01608         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
01609                      <span class="stringliteral">"UdfMountVolume -&gt; %08x\n"</span>,
01610                      <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ));
01611 
01612         <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01613     }
01614 
01615     <span class="comment">//</span>
01616     <span class="comment">//  Acquire the global resource to do mount operations.</span>
01617     <span class="comment">//</span>
01618 
01619     <a class="code" href="../../d3/d8/udfprocs_8h.html#a72">UdfAcquireUdfData</a>( IrpContext );
01620 
01621     <span class="comment">//</span>
01622     <span class="comment">//  Use a try-finally to facilitate cleanup.</span>
01623     <span class="comment">//</span>
01624 
01625     <span class="keywordflow">try</span> {
01626 
01627         <span class="comment">//</span>
01628         <span class="comment">//  Do a quick check to see if there any Vcb's which can be removed.</span>
01629         <span class="comment">//</span>
01630 
01631         <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a18">UdfScanForDismountedVcb</a>( IrpContext );
01632 
01633         <span class="comment">//</span>
01634         <span class="comment">//  Make sure that the driver/drive is not screwing up underneath of us by</span>
01635         <span class="comment">//  feeding us garbage for the sector size.</span>
01636         <span class="comment">//</span>
01637 
01638         <span class="keywordflow">if</span> (DiskGeometry.BytesPerSector == 0 ||
01639             (DiskGeometry.BytesPerSector &amp; ~( 1 &lt;&lt; <a class="code" href="../../d3/d8/udfprocs_8h.html#a136">UdfHighBit</a>( DiskGeometry.BytesPerSector ))) != 0) {
01640 
01641             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, 0,
01642                          <span class="stringliteral">"UdfMountVolume, bad DiskGeometry (%08x) .BytesPerSector == %08x\n"</span>,
01643                          &amp;DiskGeometry,
01644                          DiskGeometry.BytesPerSector ));
01645 
01646             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01647 
01648             <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_DRIVER_INTERNAL_ERROR );
01649         }
01650 
01651         <span class="comment">//</span>
01652         <span class="comment">//  Now go confirm that this volume may be a UDF image by looking for a</span>
01653         <span class="comment">//  valid ISO 13346 Volume Recognition Sequence.</span>
01654         <span class="comment">//</span>
01655 
01656         <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a17">UdfRecognizeVolume</a>( IrpContext,
01657                                  DeviceObjectWeTalkTo,
01658                                  DiskGeometry.BytesPerSector,
01659                                  &amp;BridgeMedia )) {
01660 
01661             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfMountVolume, recognition failed so not mounting\n"</span> ));
01662 
01663             <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_UNRECOGNIZED_VOLUME );
01664         }
01665 
01666         <span class="comment">//</span>
01667         <span class="comment">//  Create the DeviceObject for this mount attempt</span>
01668         <span class="comment">//</span>
01669 
01670         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d4/d6/iosubs_8c.html#a45">IoCreateDevice</a>( <a class="code" href="../../d0/d8/udfdata_8c.html#a2">UdfData</a>.<a class="code" href="../../d2/d3/struct__UDF__DATA.html#o2">DriverObject</a>,
01671                                  <span class="keyword">sizeof</span>( <a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html">VOLUME_DEVICE_OBJECT</a> ) - <span class="keyword">sizeof</span>( <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">DEVICE_OBJECT</a> ),
01672                                  <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
01673                                  FILE_DEVICE_CD_ROM_FILE_SYSTEM,
01674                                  0,
01675                                  <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01676                                  (<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> *) &amp;VolDo );
01677 
01678         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
01679 
01680             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfMountVolume, couldn't get voldo! (%08x)\n"</span>, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ));
01681             <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
01682         }
01683 
01684         <span class="comment">//</span>
01685         <span class="comment">//  Our alignment requirement is the larger of the processor alignment requirement</span>
01686         <span class="comment">//  already in the volume device object and that in the DeviceObjectWeTalkTo</span>
01687         <span class="comment">//</span>
01688 
01689         <span class="keywordflow">if</span> (DeviceObjectWeTalkTo-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o17">AlignmentRequirement</a> &gt; VolDo-&gt;DeviceObject.<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o17">AlignmentRequirement</a>) {
01690 
01691             VolDo-&gt;DeviceObject.<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o17">AlignmentRequirement</a> = DeviceObjectWeTalkTo-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o17">AlignmentRequirement</a>;
01692         }
01693 
01694         <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>( VolDo-&gt;DeviceObject.<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o8">Flags</a>, <a class="code" href="../../d0/d5/io_8h.html#a128">DO_DEVICE_INITIALIZING</a> );
01695 
01696         <span class="comment">//</span>
01697         <span class="comment">//  Initialize the overflow queue for the volume</span>
01698         <span class="comment">//</span>
01699 
01700         VolDo-&gt;OverflowQueueCount = 0;
01701         InitializeListHead( &amp;VolDo-&gt;OverflowQueue );
01702 
01703         VolDo-&gt;PostedRequestCount = 0;
01704         <a class="code" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock</a>( &amp;VolDo-&gt;OverflowQueueSpinLock );
01705 
01706         <span class="comment">//</span>
01707         <span class="comment">//  Now before we can initialize the Vcb we need to set up the</span>
01708         <span class="comment">//  device object field in the VPB to point to our new volume device</span>
01709         <span class="comment">//  object.</span>
01710         <span class="comment">//</span>
01711 
01712         Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o4">DeviceObject</a> = (<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>) VolDo;
01713 
01714         <span class="comment">//</span>
01715         <span class="comment">//  Initialize the Vcb.  This routine will raise on an allocation</span>
01716         <span class="comment">//  failure.</span>
01717         <span class="comment">//</span>
01718 
01719         <a class="code" href="../../d3/d8/udfprocs_8h.html#a203">UdfInitializeVcb</a>( IrpContext,
01720                           &amp;VolDo-&gt;Vcb,
01721                           DeviceObjectWeTalkTo,
01722                           Vpb,
01723                           &amp;DiskGeometry,
01724                           MediaChangeCount );
01725 
01726         <span class="comment">//</span>
01727         <span class="comment">//  We must initialize the stack size in our device object before</span>
01728         <span class="comment">//  the following reads, because the I/O system has not done it yet.</span>
01729         <span class="comment">//</span>
01730 
01731         ((<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>) VolDo)-&gt;StackSize = (CCHAR) (DeviceObjectWeTalkTo-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o13">StackSize</a> + 1);
01732 
01733         <span class="comment">//</span>
01734         <span class="comment">//  Pick up a local pointer to the new Vcb.  Here is where we start</span>
01735         <span class="comment">//  thinking about cleanup of structures if the mount is failed.</span>
01736         <span class="comment">//</span>
01737 
01738         Vcb = &amp;VolDo-&gt;Vcb;
01739         Vpb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01740         VolDo = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01741 
01742         <span class="comment">//</span>
01743         <span class="comment">//  Store the Vcb in the IrpContext as we didn't have one before.</span>
01744         <span class="comment">//</span>
01745 
01746         IrpContext-&gt;Vcb = Vcb;
01747 
01748         <a class="code" href="../../d3/d8/udfprocs_8h.html#a74">UdfAcquireVcbExclusive</a>( IrpContext, Vcb, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01749 
01750         <span class="comment">//</span>
01751         <span class="comment">//  Let's reference the Vpb to make sure we are the one to</span>
01752         <span class="comment">//  have the last dereference.</span>
01753         <span class="comment">//</span>
01754 
01755         Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o2">Vpb</a>-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o7">ReferenceCount</a> += 1;
01756 
01757         <span class="comment">//</span>
01758         <span class="comment">//  Clear the verify bit for the start of mount.</span>
01759         <span class="comment">//</span>
01760 
01761         <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>( Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o2">Vpb</a>-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a>-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o8">Flags</a>, <a class="code" href="../../d0/d5/io_8h.html#a122">DO_VERIFY_VOLUME</a> );
01762 
01763         <span class="comment">//</span>
01764         <span class="comment">//  Now find the multi-session bounds on this media.</span>
01765         <span class="comment">//</span>
01766 
01767         <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a4">UdfDetermineVolumeBounding</a>( IrpContext,
01768                                     Vcb,
01769                                     &amp;Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o13">BoundS</a>,
01770                                     &amp;Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o14">BoundN</a> );
01771 
01772         <span class="comment">//</span>
01773         <span class="comment">//  Now find the Anchor Volume Descriptor so we can discover the Volume Set</span>
01774         <span class="comment">//  Descriptor Sequence extent.</span>
01775         <span class="comment">//</span>
01776 
01777         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a6">UdfFindAnchorVolumeDescriptor</a>( IrpContext,
01778                                                 Vcb,
01779                                                 &amp;AnchorVolumeDescriptor );
01780 
01781         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
01782 
01783             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfMountVolume, couldn't find anchor descriptors\n"</span> ));
01784             <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
01785         }
01786 
01787         <span class="comment">//</span>
01788         <span class="comment">//  Now search for the prevailing copies of the PVD, LVD, and related PD in the</span>
01789         <span class="comment">//  extents indicated by the AVD.</span>
01790         <span class="comment">//</span>
01791 
01792         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a8">UdfFindVolumeDescriptors</a>( IrpContext,
01793                                            Vcb,
01794                                            &amp;AnchorVolumeDescriptor-&gt;<a class="code" href="../../d7/d1/structNSR__ANCHOR.html#o1">Main</a>,
01795                                            &amp;Pcb,
01796                                            &amp;PrimaryVolumeDescriptor,
01797                                            &amp;LogicalVolumeDescriptor );
01798 
01799         <span class="comment">//</span>
01800         <span class="comment">//  If we discovered invalid structures on the main extent, we may still</span>
01801         <span class="comment">//  be able to use the reserve extent.  By definition the two extents</span>
01802         <span class="comment">//  must be logically equal, so just plow into it on any error.</span>
01803         <span class="comment">//</span>
01804 
01805         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
01806 
01807             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a8">UdfFindVolumeDescriptors</a>( IrpContext,
01808                                                Vcb,
01809                                                &amp;AnchorVolumeDescriptor-&gt;<a class="code" href="../../d7/d1/structNSR__ANCHOR.html#o2">Reserve</a>,
01810                                                &amp;Pcb,
01811                                                &amp;PrimaryVolumeDescriptor,
01812                                                &amp;LogicalVolumeDescriptor );
01813         }
01814 
01815         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
01816 
01817             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfMountVolume, couldn't find good VSD descriptors (PVD/LVD/PD)\n"</span> ));
01818             <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
01819         }
01820 
01821         <span class="comment">//</span>
01822         <span class="comment">//  Now go complete initialization of the Pcb.  After this point, we can perform</span>
01823         <span class="comment">//  physical partition mappings and know that the partition table is good.</span>
01824         <span class="comment">//</span>
01825 
01826         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a150">UdfCompletePcb</a>( IrpContext,
01827                                  Vcb,
01828                                  Pcb );
01829 
01830         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
01831 
01832             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfMountVolume, Pcb completion failed\n"</span> ));
01833             <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
01834         }
01835 
01836         Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o3">Pcb</a> = Pcb;
01837         Pcb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01838 
01839         <span class="comment">//</span>
01840         <span class="comment">//  Set up all the support we need to do reads into the volume.</span>
01841         <span class="comment">//</span>
01842 
01843         <a class="code" href="../../d3/d8/udfprocs_8h.html#a204">UdfUpdateVcbPhase0</a>( IrpContext, Vcb );
01844 
01845         <span class="comment">//</span>
01846         <span class="comment">//  Now go get the fileset descriptor that will finally reveal the location</span>
01847         <span class="comment">//  of the root directory on this volume.</span>
01848         <span class="comment">//</span>
01849 
01850         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a7">UdfFindFileSetDescriptor</a>( IrpContext,
01851                                            Vcb,
01852                                            &amp;LogicalVolumeDescriptor-&gt;<a class="code" href="../../d6/d2/structNSR__LVOL.html#o6">FSD</a>,
01853                                            &amp;FileSetDescriptor );
01854 
01855         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
01856 
01857             <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( NOTHING );
01858         }
01859 
01860         <span class="comment">//</span>
01861         <span class="comment">//  Now that we have everything together, update the Vpb with identification</span>
01862         <span class="comment">//  of this volume.</span>
01863         <span class="comment">//</span>
01864 
01865         <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a20">UdfUpdateVolumeLabel</a>( IrpContext,
01866                               Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o2">Vpb</a>-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o8">VolumeLabel</a>,
01867                               &amp;Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o2">Vpb</a>-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o3">VolumeLabelLength</a>,
01868                               LogicalVolumeDescriptor-&gt;<a class="code" href="../../d6/d2/structNSR__LVOL.html#o3">VolumeID</a>,
01869                               <span class="keyword">sizeof</span>( LogicalVolumeDescriptor-&gt;<a class="code" href="../../d6/d2/structNSR__LVOL.html#o3">VolumeID</a> ));
01870 
01871         <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a21">UdfUpdateVolumeSerialNumber</a>( IrpContext,
01872                                      &amp;Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o2">Vpb</a>-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o6">SerialNumber</a>,
01873                                      FileSetDescriptor );
01874 
01875         <span class="comment">//</span>
01876         <span class="comment">//  Check if this is a remount operation.  If so then clean up</span>
01877         <span class="comment">//  the data structures passed in and created here.</span>
01878         <span class="comment">//</span>
01879 
01880         <span class="keywordflow">if</span> (<a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a11">UdfIsRemount</a>( IrpContext, Vcb, &amp;OldVcb )) {
01881 
01882             <span class="comment">//</span>
01883             <span class="comment">//  Link the old Vcb to point to the new device object that we</span>
01884             <span class="comment">//  should be talking to, dereferencing the previous.</span>
01885             <span class="comment">//</span>
01886 
01887             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( OldVcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o4">TargetDeviceObject</a> );
01888 
01889             Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o2">Vpb</a>-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a>-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o10">Vpb</a> = OldVcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o2">Vpb</a>;
01890 
01891             OldVcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o2">Vpb</a>-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a> = Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o2">Vpb</a>-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a>;
01892 
01893             OldVcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o4">TargetDeviceObject</a> = DeviceObjectWeTalkTo;
01894             OldVcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o8">VcbCondition</a> = <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a119">VcbMounted</a>;
01895 
01896             OldVcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o10">MediaChangeCount</a> = Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o10">MediaChangeCount</a>;
01897 
01898             <span class="comment">//</span>
01899             <span class="comment">//  Push the state of the method 2 bit across.  In changing the device,</span>
01900             <span class="comment">//  we may now be on one with a different requirement.</span>
01901             <span class="comment">//</span>
01902 
01903             <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>( OldVcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o7">VcbState</a>, <a class="code" href="../../d6/d8/udfstruc_8h.html#a8">VCB_STATE_METHOD_2_FIXUP</a> );
01904             <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( OldVcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o7">VcbState</a>, <a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o7">VcbState</a>, <a class="code" href="../../d6/d8/udfstruc_8h.html#a8">VCB_STATE_METHOD_2_FIXUP</a> ));
01905             
01906             <span class="comment">//</span>
01907             <span class="comment">//  See if we will need to provide notification of the remount.  This is the readonly</span>
01908             <span class="comment">//  filesystem's form of dismount/mount notification - we promise that whenever a</span>
01909             <span class="comment">//  volume is "dismounted", that a mount notification will occur when it is revalidated.</span>
01910             <span class="comment">//  Note that we do not send mount on normal remounts - that would duplicate the media</span>
01911             <span class="comment">//  arrival notification of the device driver.</span>
01912             <span class="comment">//</span>
01913     
01914             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( OldVcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o7">VcbState</a>, <a class="code" href="../../d6/d8/udfstruc_8h.html#a7">VCB_STATE_NOTIFY_REMOUNT</a> )) {
01915     
01916                 <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>( OldVcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o7">VcbState</a>, <a class="code" href="../../d6/d8/udfstruc_8h.html#a7">VCB_STATE_NOTIFY_REMOUNT</a> );
01917                 
01918                 FileObjectToNotify = OldVcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o21">RootIndexFcb</a>-&gt;FileObject;
01919                 <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a>( FileObjectToNotify );
01920             }
01921             
01922             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfMountVolume, remounted old Vcb %08x\n"</span>, OldVcb ));
01923 
01924             <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS );
01925         }
01926 
01927         <span class="comment">//</span>
01928         <span class="comment">//  Initialize the Vcb and associated structures from our volume descriptors</span>
01929         <span class="comment">//</span>
01930 
01931         <a class="code" href="../../d3/d8/udfprocs_8h.html#a205">UdfUpdateVcbPhase1</a>( IrpContext,
01932                             Vcb,
01933                             FileSetDescriptor );
01934 
01935         <span class="comment">//</span>
01936         <span class="comment">//  Drop an extra reference on the root dir file so we'll be able to send</span>
01937         <span class="comment">//  notification.</span>
01938         <span class="comment">//</span>
01939 
01940         <span class="keywordflow">if</span> (Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o21">RootIndexFcb</a>) {
01941 
01942             FileObjectToNotify = Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o21">RootIndexFcb</a>-&gt;FileObject;
01943             <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a>( FileObjectToNotify );
01944         }
01945 
01946         <span class="comment">//</span>
01947         <span class="comment">//  The new mount is complete.  Remove the additional references on this</span>
01948         <span class="comment">//  Vcb since, at this point, we have added the real references this volume</span>
01949         <span class="comment">//  will have during its lifetime.  We also need to drop the additional</span>
01950         <span class="comment">//  reference on the device we mounted.</span>
01951         <span class="comment">//</span>
01952 
01953         Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o16">VcbReference</a> -= Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o18">VcbResidualReference</a>;
01954         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o16">VcbReference</a> == Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o18">VcbResidualReference</a> );
01955 
01956         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o4">TargetDeviceObject</a> );
01957 
01958         Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o8">VcbCondition</a> = <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a119">VcbMounted</a>;
01959 
01960         <a class="code" href="../../d3/d8/udfprocs_8h.html#a76">UdfReleaseVcb</a>( IrpContext, Vcb );
01961         Vcb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01962 
01963         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
01964 
01965     } finally {
01966 
01967         <a class="code" href="../../d8/d3/lfsdata_8h.html#a3">DebugUnwind</a>( <span class="stringliteral">"UdfMountVolume"</span> );
01968 
01969         <span class="comment">//</span>
01970         <span class="comment">//  If we didn't complete the mount then cleanup any remaining structures.</span>
01971         <span class="comment">//</span>
01972 
01973         <span class="keywordflow">if</span> (Vpb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) { Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o4">DeviceObject</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>; }
01974 
01975         <span class="keywordflow">if</span> (Pcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01976 
01977             <a class="code" href="../../d3/d8/udfprocs_8h.html#a147">UdfDeletePcb</a>( Pcb );
01978         }
01979 
01980         <span class="keywordflow">if</span> (Vcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01981 
01982             <span class="comment">//</span>
01983             <span class="comment">//  Make sure there is no Vcb in the IrpContext since it could go away</span>
01984             <span class="comment">//</span>
01985 
01986             IrpContext-&gt;Vcb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01987 
01988             Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o16">VcbReference</a> -= Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o18">VcbResidualReference</a>;
01989 
01990             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/udfs_2verfysup_8c.html#a4">UdfDismountVcb</a>( IrpContext, Vcb )) {
01991 
01992                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a76">UdfReleaseVcb</a>( IrpContext, Vcb );
01993             }
01994 
01995         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (VolDo != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01996 
01997             <a class="code" href="../../d4/d6/iosubs_8c.html#a55">IoDeleteDevice</a>( (<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>)VolDo );
01998             Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o4">DeviceObject</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01999         }
02000 
02001         <span class="comment">//</span>
02002         <span class="comment">//  Release the global resource.</span>
02003         <span class="comment">//</span>
02004 
02005         <a class="code" href="../../d3/d8/udfprocs_8h.html#a73">UdfReleaseUdfData</a>( IrpContext );
02006 
02007         <span class="comment">//</span>
02008         <span class="comment">//  Free any structures we may have been allocated</span>
02009         <span class="comment">//</span>
02010 
02011         <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>( &amp;AnchorVolumeDescriptor );
02012         <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>( &amp;PrimaryVolumeDescriptor );
02013         <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>( &amp;LogicalVolumeDescriptor );
02014         <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>( &amp;FileSetDescriptor );
02015     }
02016 
02017     <span class="comment">//</span>
02018     <span class="comment">//  Now send mount notification.</span>
02019     <span class="comment">//</span>
02020     
02021     <span class="keywordflow">if</span> (FileObjectToNotify) {
02022 
02023         <a class="code" href="../../d1/d8/fsrtl_8h.html#a168">FsRtlNotifyVolumeEvent</a>( FileObjectToNotify, <a class="code" href="../../d1/d8/fsrtl_8h.html#a44">FSRTL_VOLUME_MOUNT</a> );
02024         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( FileObjectToNotify );
02025     }
02026 
02027     <span class="comment">//</span>
02028     <span class="comment">//  Complete the request if no exception.</span>
02029     <span class="comment">//</span>
02030 
02031     <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
02032     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfMountVolume -&gt; %08x\n"</span>, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ));
02033 
02034     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02035 }
02036 
02037 
02038 <span class="comment">//</span>
02039 <span class="comment">//  Local support routine</span>
02040 <span class="comment">//</span>
02041 
02042 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l02043"></a><a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a23">02043</a> <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a23">UdfVerifyVolume</a> (
02044     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
02045     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
02046     )
02047 
02048 <span class="comment">/*++</span>
02049 <span class="comment"></span>
02050 <span class="comment">Routine Description:</span>
02051 <span class="comment"></span>
02052 <span class="comment">    This routine performs the verify volume operation.  It is responsible for</span>
02053 <span class="comment">    either completing of enqueuing the input Irp.</span>
02054 <span class="comment"></span>
02055 <span class="comment">Arguments:</span>
02056 <span class="comment"></span>
02057 <span class="comment">    Irp - Supplies the Irp to process</span>
02058 <span class="comment"></span>
02059 <span class="comment">Return Value:</span>
02060 <span class="comment"></span>
02061 <span class="comment">    NTSTATUS - The return status for the operation</span>
02062 <span class="comment"></span>
02063 <span class="comment">--*/</span>
02064 
02065 {
02066     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> IrpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
02067     <a class="code" href="../../d7/d7/struct__VPB.html">PVPB</a> Vpb = IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.VerifyVolume.Vpb;
02068     <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb = &amp;((<a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html">PVOLUME_DEVICE_OBJECT</a>) IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.VerifyVolume.DeviceObject)-&gt;Vcb;
02069 
02070     <a class="code" href="../../d4/d9/struct__PCB.html">PPCB</a> Pcb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02071 
02072     <a class="code" href="../../d7/d1/structNSR__ANCHOR.html">PNSR_ANCHOR</a> AnchorVolumeDescriptor = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02073     <a class="code" href="../../d0/d3/structNSR__PVD.html">PNSR_PVD</a> PrimaryVolumeDescriptor = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02074     <a class="code" href="../../d6/d2/structNSR__LVOL.html">PNSR_LVOL</a> LogicalVolumeDescriptor = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02075     <a class="code" href="../../d2/d2/structNSR__FSD.html">PNSR_FSD</a> FileSetDescriptor = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02076 
02077     ULONG MediaChangeCount = 0;
02078     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
02079 
02080     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObjectToNotify = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02081 
02082     BOOLEAN ReturnError;
02083     BOOLEAN ReleaseVcb;
02084 
02085     IO_STATUS_BLOCK Iosb;
02086 
02087     WCHAR VolumeLabel[ <a class="code" href="../../d0/d5/io_8h.html#a121">MAXIMUM_VOLUME_LABEL_LENGTH</a> / <span class="keyword">sizeof</span>( WCHAR )];
02088     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> VolumeLabelLength;
02089     ULONG VolumeSerialNumber;
02090 
02091     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02092 
02093     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02094 
02095     <span class="comment">//</span>
02096     <span class="comment">//  Check input.</span>
02097     <span class="comment">//</span>
02098 
02099     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
02100 
02101     <span class="comment">//</span>
02102     <span class="comment">//  Check that we are talking to a Cdrom or Disk device.  This request should</span>
02103     <span class="comment">//  always be waitable.</span>
02104     <span class="comment">//</span>
02105 
02106     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a>-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o12">DeviceType</a> == FILE_DEVICE_CD_ROM ||
02107             Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a>-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o12">DeviceType</a> == FILE_DEVICE_DISK );
02108 
02109     <a class="code" href="../../d1/d8/udfdata_8h.html#a12">ASSERT_VCB</a>( Vcb );
02110 
02111     <span class="comment">//</span>
02112     <span class="comment">//  Update the real device in the IrpContext from the Vpb.  There was no available</span>
02113     <span class="comment">//  file object when the IrpContext was created.</span>
02114     <span class="comment">//</span>
02115 
02116     IrpContext-&gt;RealDevice = Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a>;
02117 
02118     <span class="comment">//</span>
02119     <span class="comment">//  Acquire shared global access, the termination handler for the</span>
02120     <span class="comment">//  following try statement will free the access.</span>
02121     <span class="comment">//</span>
02122 
02123     <a class="code" href="../../d3/d8/udfprocs_8h.html#a72">UdfAcquireUdfData</a>( IrpContext );
02124     <a class="code" href="../../d3/d8/udfprocs_8h.html#a74">UdfAcquireVcbExclusive</a>( IrpContext, Vcb, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
02125     ReleaseVcb = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02126 
02127     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfVerifyVolume, Vcb %08x\n"</span>, Vcb ));
02128 
02129     <span class="keywordflow">try</span> {
02130 
02131         <span class="comment">//</span>
02132         <span class="comment">//  Check if the real device still needs to be verified.  If it doesn't</span>
02133         <span class="comment">//  then obviously someone beat us here and already did the work</span>
02134         <span class="comment">//  so complete the verify irp with success.  Otherwise reenable</span>
02135         <span class="comment">//  the real device and get to work.</span>
02136         <span class="comment">//</span>
02137 
02138         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a>-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o8">Flags</a>, <a class="code" href="../../d0/d5/io_8h.html#a122">DO_VERIFY_VOLUME</a> )) {
02139 
02140             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfVerifyVolume, verify bit was cleared out ahead of us\n"</span> ));
02141 
02142             MediaChangeCount = Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o10">MediaChangeCount</a>;
02143             <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS );
02144         }
02145 
02146         <span class="comment">//</span>
02147         <span class="comment">//  Verify that there is a disk here.</span>
02148         <span class="comment">//</span>
02149 
02150         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a159">UdfPerformDevIoCtrl</a>( IrpContext,
02151                                       ( Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a>-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o12">DeviceType</a> == FILE_DEVICE_CD_ROM ?
02152                                         IOCTL_CDROM_CHECK_VERIFY :
02153                                         IOCTL_DISK_CHECK_VERIFY ),
02154                                       Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o4">TargetDeviceObject</a>,
02155                                       &amp;MediaChangeCount,
02156                                       <span class="keyword">sizeof</span>(ULONG),
02157                                       <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
02158                                       <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
02159                                       &amp;Iosb );
02160 
02161         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
02162 
02163             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfVerifyVolume, CHECK_VERIFY failed\n"</span> ));
02164 
02165             <span class="comment">//</span>
02166             <span class="comment">//  If we will allow a raw mount then return WRONG_VOLUME to</span>
02167             <span class="comment">//  allow the volume to be mounted by raw.</span>
02168             <span class="comment">//</span>
02169 
02170             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o2">Flags</a>, <a class="code" href="../../d0/d5/io_8h.html#a212">SL_ALLOW_RAW_MOUNT</a> )) {
02171 
02172                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfVerifyVolume, ... allowing raw mount\n"</span> ));
02173 
02174                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_WRONG_VOLUME;
02175             }
02176 
02177             <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
02178         }
02179 
02180         <span class="keywordflow">if</span> (Iosb.Information != <span class="keyword">sizeof</span>(ULONG)) {
02181 
02182             <span class="comment">//</span>
02183             <span class="comment">//  Be safe about the count in case the driver didn't fill it in</span>
02184             <span class="comment">//</span>
02185 
02186             MediaChangeCount = 0;
02187         }
02188 
02189         <span class="comment">//</span>
02190         <span class="comment">//  Verify that the device actually saw a change. If the driver does not</span>
02191         <span class="comment">//  support the MCC, then we must verify the volume in any case.</span>
02192         <span class="comment">//</span>
02193 
02194         <span class="keywordflow">if</span> (MediaChangeCount == 0 || Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o10">MediaChangeCount</a> != MediaChangeCount) {
02195 
02196             <span class="comment">//</span>
02197             <span class="comment">//  Now we need to navigate the disc to find the relavent decriptors.  This is</span>
02198             <span class="comment">//  much the same as the mount process.</span>
02199             <span class="comment">//</span>
02200 
02201             <span class="comment">//</span>
02202             <span class="comment">//  Find the AVD.</span>
02203             <span class="comment">//</span>
02204 
02205             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a6">UdfFindAnchorVolumeDescriptor</a>( IrpContext,
02206                                                     Vcb,
02207                                                     &amp;AnchorVolumeDescriptor );
02208 
02209             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
02210                 
02211                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfVerifyVolume, No AVD visible\n"</span> ));
02212                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_WRONG_VOLUME );
02213             }
02214             
02215             <span class="comment">//</span>
02216             <span class="comment">//  Get the prevailing descriptors out of the VDS, building a fresh Pcb.</span>
02217             <span class="comment">//</span>
02218 
02219             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a8">UdfFindVolumeDescriptors</a>( IrpContext,
02220                                                Vcb,
02221                                                &amp;AnchorVolumeDescriptor-&gt;<a class="code" href="../../d7/d1/structNSR__ANCHOR.html#o1">Main</a>,
02222                                                &amp;Pcb,
02223                                                &amp;PrimaryVolumeDescriptor,
02224                                                &amp;LogicalVolumeDescriptor );
02225 
02226             <span class="comment">//</span>
02227             <span class="comment">//  Try the reserve sequence in case of error.</span>
02228             <span class="comment">//</span>
02229 
02230             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_DISK_CORRUPT_ERROR) {
02231 
02232                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a8">UdfFindVolumeDescriptors</a>( IrpContext,
02233                                                    Vcb,
02234                                                    &amp;AnchorVolumeDescriptor-&gt;<a class="code" href="../../d7/d1/structNSR__ANCHOR.html#o2">Reserve</a>,
02235                                                    &amp;Pcb,
02236                                                    &amp;PrimaryVolumeDescriptor,
02237                                                    &amp;LogicalVolumeDescriptor );
02238             }
02239 
02240             <span class="comment">//</span>
02241             <span class="comment">//  If we're totally unable to find a VDS, give up.</span>
02242             <span class="comment">//</span>
02243 
02244             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
02245 
02246                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfVerifyVolume, PVD/LVD/PD pickup failed\n"</span> ));
02247 
02248                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_WRONG_VOLUME );
02249             }
02250 
02251             <span class="comment">//</span>
02252             <span class="comment">//  Now go complete initialization of the Pcb so we can compare it.</span>
02253             <span class="comment">//</span>
02254 
02255             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a150">UdfCompletePcb</a>( IrpContext,
02256                                      Vcb,
02257                                      Pcb );
02258 
02259             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
02260 
02261                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfVerifyVolume, Pcb completion failed\n"</span> ));
02262 
02263                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_WRONG_VOLUME );
02264             }
02265 
02266             <span class="comment">//</span>
02267             <span class="comment">//  Now let's compare this new Pcb to the previous Vcb's Pcb to see if they</span>
02268             <span class="comment">//  appear to be equivalent.</span>
02269             <span class="comment">//</span>
02270 
02271             <span class="keywordflow">if</span> (!<a class="code" href="../../d3/d8/udfprocs_8h.html#a151">UdfEquivalentPcb</a>( IrpContext,
02272                                    Pcb,
02273                                    Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o3">Pcb</a>)) {
02274 
02275                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfVerifyVolume, Pcbs are not equivalent\n"</span> ));
02276 
02277                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_WRONG_VOLUME );
02278             }
02279 
02280             <span class="comment">//</span>
02281             <span class="comment">//  At this point we know that the Vcb's Pcb is OK for mapping to find the fileset</span>
02282             <span class="comment">//  descriptor, so we can drop the new one we built for comparison purposes.</span>
02283             <span class="comment">//</span>
02284 
02285             <a class="code" href="../../d3/d8/udfprocs_8h.html#a147">UdfDeletePcb</a>( Pcb );
02286             Pcb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02287 
02288             <span class="comment">//</span>
02289             <span class="comment">//  Go pick up the fileset descriptor.</span>
02290             <span class="comment">//</span>
02291 
02292             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a7">UdfFindFileSetDescriptor</a>( IrpContext,
02293                                                Vcb,
02294                                                &amp;LogicalVolumeDescriptor-&gt;<a class="code" href="../../d6/d2/structNSR__LVOL.html#o6">FSD</a>,
02295                                                &amp;FileSetDescriptor );
02296 
02297             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
02298 
02299                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_WRONG_VOLUME );
02300             }
02301 
02302             <span class="comment">//</span>
02303             <span class="comment">//  Now that everything is in place, build a volume label and serial number from these</span>
02304             <span class="comment">//  descriptors and perform the final check that this Vcb is (or is not) the right one</span>
02305             <span class="comment">//  for the media now in the drive.</span>
02306             <span class="comment">//</span>
02307 
02308             <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a20">UdfUpdateVolumeLabel</a>( IrpContext,
02309                                   VolumeLabel,
02310                                   &amp;VolumeLabelLength,
02311                                   LogicalVolumeDescriptor-&gt;<a class="code" href="../../d6/d2/structNSR__LVOL.html#o3">VolumeID</a>,
02312                                   <span class="keyword">sizeof</span>( LogicalVolumeDescriptor-&gt;<a class="code" href="../../d6/d2/structNSR__LVOL.html#o3">VolumeID</a> ));
02313 
02314             <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a21">UdfUpdateVolumeSerialNumber</a>( IrpContext,
02315                                          &amp;VolumeSerialNumber,
02316                                          FileSetDescriptor );
02317 
02318             <span class="keywordflow">if</span> (Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o2">Vpb</a>-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o6">SerialNumber</a> != VolumeSerialNumber ||
02319                 Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o2">Vpb</a>-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o3">VolumeLabelLength</a> != VolumeLabelLength ||
02320                 RtlCompareMemory( Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o2">Vpb</a>-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o8">VolumeLabel</a>,
02321                                   VolumeLabel,
02322                                   VolumeLabelLength )) {
02323 
02324                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfVerifyVolume, volume label/sn mismatch\n"</span> ));
02325 
02326                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_WRONG_VOLUME );
02327             }
02328         }
02329 
02330         <span class="comment">//</span>
02331         <span class="comment">//  The volume is OK, clear the verify bit.</span>
02332         <span class="comment">//</span>
02333 
02334         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfVerifyVolume, looks like the same volume\n"</span> ));
02335 
02336         Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o8">VcbCondition</a> = <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a119">VcbMounted</a>;
02337 
02338         <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>( Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a>-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o8">Flags</a>, <a class="code" href="../../d0/d5/io_8h.html#a122">DO_VERIFY_VOLUME</a> );
02339 
02340         <span class="comment">//</span>
02341         <span class="comment">//  See if we will need to provide notification of the remount.  This is the readonly</span>
02342         <span class="comment">//  filesystem's form of dismount/mount notification.</span>
02343         <span class="comment">//</span>
02344 
02345         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o7">VcbState</a>, <a class="code" href="../../d6/d8/udfstruc_8h.html#a7">VCB_STATE_NOTIFY_REMOUNT</a> )) {
02346 
02347             <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>( Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o7">VcbState</a>, <a class="code" href="../../d6/d8/udfstruc_8h.html#a7">VCB_STATE_NOTIFY_REMOUNT</a> );
02348             
02349             FileObjectToNotify = Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o21">RootIndexFcb</a>-&gt;FileObject;
02350             <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a>( FileObjectToNotify );
02351         }
02352         
02353     } finally {
02354 
02355         <span class="comment">//</span>
02356         <span class="comment">//  If we did not raise an exception, update the current Vcb.</span>
02357         <span class="comment">//</span>
02358 
02359         <span class="keywordflow">if</span> (!AbnormalTermination()) {
02360 
02361             <span class="comment">//</span>
02362             <span class="comment">//  Update the media change count to note that we have verified the volume</span>
02363             <span class="comment">//  at this value</span>
02364             <span class="comment">//</span>
02365 
02366             Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o10">MediaChangeCount</a> = MediaChangeCount;
02367 
02368             <span class="comment">//</span>
02369             <span class="comment">//  Mark the Vcb as not mounted.</span>
02370             <span class="comment">//</span>
02371 
02372             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_WRONG_VOLUME) {
02373 
02374                 Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o8">VcbCondition</a> = <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a117">VcbNotMounted</a>;
02375                 
02376                 <span class="comment">//</span>
02377                 <span class="comment">//  Now, if there are no user handles to the volume, try to spark</span>
02378                 <span class="comment">//  teardown by purging the volume.</span>
02379                 <span class="comment">//</span>
02380 
02381                 <span class="keywordflow">if</span> (Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o15">VcbCleanup</a> == 0) {
02382 
02383                     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d3/d8/udfprocs_8h.html#a158">UdfPurgeVolume</a>( IrpContext, Vcb, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> ))) {
02384 
02385                         ReleaseVcb = <a class="code" href="../../d8/d5/udfs_2verfysup_8c.html#a3">UdfCheckForDismount</a>( IrpContext, Vcb, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
02386                     }
02387                 }
02388             }
02389         }
02390 
02391         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfVerifyVolume -&gt; %08x\n"</span>, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ));
02392 
02393         <span class="keywordflow">if</span> (ReleaseVcb) {
02394             
02395             <a class="code" href="../../d3/d8/udfprocs_8h.html#a76">UdfReleaseVcb</a>( IrpContext, Vcb );
02396         }
02397 
02398         <a class="code" href="../../d3/d8/udfprocs_8h.html#a73">UdfReleaseUdfData</a>( IrpContext );
02399 
02400         <span class="comment">//</span>
02401         <span class="comment">//  Delete the Pcb if built.</span>
02402         <span class="comment">//</span>
02403 
02404         <span class="keywordflow">if</span> (Pcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02405 
02406             <a class="code" href="../../d3/d8/udfprocs_8h.html#a147">UdfDeletePcb</a>( Pcb );
02407         }
02408 
02409         <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>( &amp;AnchorVolumeDescriptor );
02410         <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>( &amp;PrimaryVolumeDescriptor );
02411         <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>( &amp;LogicalVolumeDescriptor );
02412         <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>( &amp;FileSetDescriptor );
02413     }
02414 
02415     <span class="comment">//</span>
02416     <span class="comment">//  Now send mount notification.</span>
02417     <span class="comment">//</span>
02418     
02419     <span class="keywordflow">if</span> (FileObjectToNotify) {
02420 
02421         <a class="code" href="../../d1/d8/fsrtl_8h.html#a168">FsRtlNotifyVolumeEvent</a>( FileObjectToNotify, <a class="code" href="../../d1/d8/fsrtl_8h.html#a44">FSRTL_VOLUME_MOUNT</a> );
02422         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( FileObjectToNotify );
02423     }
02424     
02425     <span class="comment">//</span>
02426     <span class="comment">//  Complete the request if no exception.</span>
02427     <span class="comment">//</span>
02428 
02429     <a class="code" href="../../d3/d8/udfprocs_8h.html#a129">UdfCompleteRequest</a>( IrpContext, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
02430     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02431 }
02432 
02433 
02434 <span class="comment">//</span>
02435 <span class="comment">//  Local support routine</span>
02436 <span class="comment">//</span>
02437 
02438 BOOLEAN
<a name="l02439"></a><a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a11">02439</a> <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a11">UdfIsRemount</a> (
02440     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
02441     IN <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb,
02442     OUT <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> *OldVcb
02443     )
02444 
02445 <span class="comment">/*++</span>
02446 <span class="comment"></span>
02447 <span class="comment">Routine Description:</span>
02448 <span class="comment"></span>
02449 <span class="comment">    This routine walks through the links of the Vcb chain in the global</span>
02450 <span class="comment">    data structure.  The remount condition is met when the following</span>
02451 <span class="comment">    conditions are all met:</span>
02452 <span class="comment"></span>
02453 <span class="comment">            1 - The 32 serial for this VPB matches that in a previous</span>
02454 <span class="comment">                VPB.</span>
02455 <span class="comment"></span>
02456 <span class="comment">            2 - The volume label for this VPB matches that in the previous</span>
02457 <span class="comment">                VPB.</span>
02458 <span class="comment"></span>
02459 <span class="comment">            3 - The system pointer to the real device object in the current</span>
02460 <span class="comment">                VPB matches that in the same previous VPB.</span>
02461 <span class="comment"></span>
02462 <span class="comment">            4 - Finally the previous Vcb cannot be invalid or have a dismount</span>
02463 <span class="comment">                underway.</span>
02464 <span class="comment"></span>
02465 <span class="comment">    If a VPB is found which matches these conditions, then the address of</span>
02466 <span class="comment">    the Vcb for that VPB is returned via the pointer OldVcb.</span>
02467 <span class="comment"></span>
02468 <span class="comment">    Skip over the current Vcb.</span>
02469 <span class="comment"></span>
02470 <span class="comment">Arguments:</span>
02471 <span class="comment"></span>
02472 <span class="comment">    Vcb - This is the Vcb we are checking for a remount.</span>
02473 <span class="comment"></span>
02474 <span class="comment">    OldVcb -  A pointer to the address to store the address for the Vcb</span>
02475 <span class="comment">              for the volume if this is a remount.  (This is a pointer to</span>
02476 <span class="comment">              a pointer)</span>
02477 <span class="comment"></span>
02478 <span class="comment">Return Value:</span>
02479 <span class="comment"></span>
02480 <span class="comment">    BOOLEAN - TRUE if this is in fact a remount, FALSE otherwise.</span>
02481 <span class="comment"></span>
02482 <span class="comment">--*/</span>
02483 
02484 {
02485     PLIST_ENTRY Link;
02486 
02487     <a class="code" href="../../d7/d7/struct__VPB.html">PVPB</a> Vpb = Vcb-&gt;Vpb;
02488     <a class="code" href="../../d7/d7/struct__VPB.html">PVPB</a> OldVpb;
02489 
02490     BOOLEAN Remount = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02491 
02492     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02493 
02494     <span class="comment">//</span>
02495     <span class="comment">//  Check input.</span>
02496     <span class="comment">//</span>
02497 
02498     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
02499     <a class="code" href="../../d1/d8/udfdata_8h.html#a12">ASSERT_VCB</a>( Vcb );
02500 
02501     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfIsRemount, Vcb %08x\n"</span>, Vcb ));
02502 
02503     <span class="keywordflow">for</span> (Link = <a class="code" href="../../d0/d8/udfdata_8c.html#a2">UdfData</a>.<a class="code" href="../../d2/d3/struct__UDF__DATA.html#o3">VcbQueue</a>.Flink;
02504          Link != &amp;<a class="code" href="../../d0/d8/udfdata_8c.html#a2">UdfData</a>.<a class="code" href="../../d2/d3/struct__UDF__DATA.html#o3">VcbQueue</a>;
02505          Link = Link-&gt;Flink) {
02506 
02507         *OldVcb = CONTAINING_RECORD( Link, <a class="code" href="../../d7/d5/struct__VCB.html">VCB</a>, VcbLinks );
02508 
02509         <span class="comment">//</span>
02510         <span class="comment">//  Skip ourselves.</span>
02511         <span class="comment">//</span>
02512 
02513         <span class="keywordflow">if</span> (Vcb == *OldVcb) { <span class="keywordflow">continue</span>; }
02514 
02515         <span class="comment">//</span>
02516         <span class="comment">//  Look at the Vpb and state of the previous Vcb.</span>
02517         <span class="comment">//</span>
02518 
02519         OldVpb = (*OldVcb)-&gt;Vpb;
02520 
02521         <span class="keywordflow">if</span> ((OldVpb != Vpb) &amp;&amp;
02522             (OldVpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a> == Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a>) &amp;&amp;
02523             ((*OldVcb)-&gt;VcbCondition == <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a117">VcbNotMounted</a>)) {
02524 
02525             <span class="comment">//</span>
02526             <span class="comment">//  Go ahead and compare serial numbers and volume label.</span>
02527             <span class="comment">//</span>
02528 
02529             <span class="keywordflow">if</span> ((OldVpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o6">SerialNumber</a> == Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o6">SerialNumber</a>) &amp;&amp;
02530                        (Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o3">VolumeLabelLength</a> == OldVpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o3">VolumeLabelLength</a>) &amp;&amp;
02531                        (RtlEqualMemory( OldVpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o8">VolumeLabel</a>,
02532                                         Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o8">VolumeLabel</a>,
02533                                         Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o3">VolumeLabelLength</a> ))) {
02534 
02535                 <span class="comment">//</span>
02536                 <span class="comment">//  Got it.</span>
02537                 <span class="comment">//</span>
02538 
02539                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfIsRemount, matched OldVcb %08x\n"</span>, *OldVcb ));
02540 
02541                 Remount = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02542                 <span class="keywordflow">break</span>;
02543             }
02544         }
02545     }
02546 
02547     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfIsRemount -&gt; %c\n"</span>, (Remount? <span class="charliteral">'T'</span> : <span class="charliteral">'F'</span> )));
02548 
02549     <span class="keywordflow">return</span> Remount;
02550 }
02551 
02552 
02553 <span class="comment">//</span>
02554 <span class="comment">//  Local support routine</span>
02555 <span class="comment">//</span>
02556 
02557 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l02558"></a><a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a7">02558</a> <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a7">UdfFindFileSetDescriptor</a> (
02559     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
02560     IN <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb,
02561     IN <a class="code" href="../../d4/d9/structLONGAD.html">PLONGAD</a> LongAd,
02562     IN OUT <a class="code" href="../../d2/d2/structNSR__FSD.html">PNSR_FSD</a> *FileSetDescriptor
02563     )
02564 
02565 <span class="comment">/*++</span>
02566 <span class="comment"></span>
02567 <span class="comment">Routine Description:</span>
02568 <span class="comment"></span>
02569 <span class="comment">    This routine walks a Fileset Descriptor Sequence looking for the default</span>
02570 <span class="comment">    descriptor.  This will reveal the location of the root directory on the</span>
02571 <span class="comment">    volume.</span>
02572 <span class="comment"></span>
02573 <span class="comment">Arguments:</span>
02574 <span class="comment"></span>
02575 <span class="comment">    Vcb - Vcb of volume to search</span>
02576 <span class="comment"></span>
02577 <span class="comment">    LongAd - Long allocation descriptor describing the start of the sequence</span>
02578 <span class="comment"></span>
02579 <span class="comment">    FileSetDescriptor - Address of caller's pointer to an FSD</span>
02580 <span class="comment"></span>
02581 <span class="comment">Return Value:</span>
02582 <span class="comment"></span>
02583 <span class="comment">    STATUS_SUCCESS if all descriptors are found, read, and are valid.</span>
02584 <span class="comment"></span>
02585 <span class="comment">    STATUS_DISK_CORRUPT_ERROR if corrupt/bad descriptors are found (may be raised)</span>
02586 <span class="comment"></span>
02587 <span class="comment">--*/</span>
02588 
02589 {
02590     <a class="code" href="../../d2/d2/structNSR__FSD.html">PNSR_FSD</a> FSD = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02591     ULONGLONG <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
02592     ULONG Lbn, Len;
02593 
02594     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
02595 
02596     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02597 
02598     <span class="comment">//</span>
02599     <span class="comment">//  Check inputs</span>
02600     <span class="comment">//</span>
02601 
02602     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
02603     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( *FileSetDescriptor == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
02604 
02605     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
02606                  <span class="stringliteral">"UdfFindFileSetDescriptor, Vcb %08x, LongAd %08x %x/%08x +%08x (type %x)\n"</span>,
02607                  Vcb,
02608                  LongAd,
02609                  LongAd-&gt;Start.Partition,
02610                  LongAd-&gt;Start.Lbn,
02611                  LongAd-&gt;Length.Length,
02612                  LongAd-&gt;Length.Type ));
02613     
02614     <span class="comment">//</span>
02615     <span class="comment">//  If the extent we begin from is not a whole number of recorded logical blocks,</span>
02616     <span class="comment">//  we can't continue.</span>
02617     <span class="comment">//</span>
02618 
02619 <span class="preprocessor">#ifndef UDF_SUPPORT_NONSTANDARD_ALLSTOR</span>
02620 <span class="preprocessor"></span>    
02621     <span class="comment">//</span>
02622     <span class="comment">//  Disable checking the sanity of the longad here.</span>
02623     <span class="comment">//</span>
02624     <span class="comment">//  Reason: first drop of Allstor media recorded the type as unrecorded (!)</span>
02625     <span class="comment">//</span>
02626 
02627     <span class="keywordflow">if</span> (LongAd-&gt;Length.Length == 0 ||
02628         LongAd-&gt;Length.Type != <a class="code" href="../../d0/d7/iso13346_8h.html#a21">NSRLENGTH_TYPE_RECORDED</a> ||
02629         <a class="code" href="../../d3/d8/udfprocs_8h.html#a55">BlockOffset</a>( Vcb, LongAd-&gt;Length.Length )) {
02630 
02631         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
02632                      <span class="stringliteral">"UdfFindFileSetDescriptor, bad longad length\n"</span> ));
02633         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
02634                      <span class="stringliteral">"UdfFindFileSetDescriptor -&gt;  STATUS_DISK_CORRUPT_ERROR\n"</span> ));
02635         
02636         <span class="keywordflow">return</span> STATUS_DISK_CORRUPT_ERROR;
02637     }
02638 
02639 <span class="preprocessor">#endif</span>
02640 <span class="preprocessor"></span>
02641     <span class="comment">//</span>
02642     <span class="comment">//  Use a try-finally for cleanup</span>
02643     <span class="comment">//</span>
02644 
02645     <span class="keywordflow">try</span> {
02646 
02647         <span class="keywordflow">try</span> {
02648             
02649             <span class="keywordflow">for</span> ( <span class="comment">//</span>
02650                   <span class="comment">//  Home ourselves in the search and make a pass through the sequence.</span>
02651                   <span class="comment">//</span>
02652 
02653                   Len = LongAd-&gt;Length.Length,
02654                   Lbn = LongAd-&gt;Start.Lbn,
02655                   <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a39">LlBytesFromSectors</a>( Vcb, <a class="code" href="../../d3/d8/udfprocs_8h.html#a152">UdfLookupPsnOfExtent</a>( IrpContext,
02656                                                                           Vcb,
02657                                                                           LongAd-&gt;Start.Partition,
02658                                                                           Lbn,
02659                                                                           Len ));
02660 
02661                   Len;
02662 
02663                   <span class="comment">//</span>
02664                   <span class="comment">//  Advance to the next descriptor offset in the sequence.</span>
02665                   <span class="comment">//</span>
02666 
02667                   Len -= <a class="code" href="../../d3/d8/udfprocs_8h.html#a54">BlockSize</a>( Vcb ),
02668                   Lbn++,
02669                   <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> += <a class="code" href="../../d3/d8/udfprocs_8h.html#a54">BlockSize</a>( Vcb )) {
02670 
02671                 <span class="comment">//</span>
02672                 <span class="comment">//  Allocate a buffer to read fileset descriptors.</span>
02673                 <span class="comment">//</span>
02674 
02675                 <span class="keywordflow">if</span> (FSD == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02676 
02677                     FSD = <a class="code" href="../../d1/d8/fsrtl_8h.html#a37">FsRtlAllocatePoolWithTag</a>( <a class="code" href="../../d3/d8/udfprocs_8h.html#a66">UdfNonPagedPool</a>,
02678                                                     <a class="code" href="../../d3/d8/udfprocs_8h.html#a163">UdfRawBufferSize</a>( Vcb, <span class="keyword">sizeof</span>(<a class="code" href="../../d2/d2/structNSR__FSD.html">NSR_FSD</a>) ),
02679                                                     <a class="code" href="../../d1/d7/udfs_2nodetype_8h.html#a86">TAG_NSR_FSD</a> );
02680                 }
02681 
02682                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a160">UdfReadSectors</a>( IrpContext,
02683                                          <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>,
02684                                          <a class="code" href="../../d3/d8/udfprocs_8h.html#a164">UdfRawReadSize</a>( Vcb, <span class="keyword">sizeof</span>(<a class="code" href="../../d2/d2/structNSR__FSD.html">NSR_FSD</a>) ),
02685                                          <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
02686                                          FSD,
02687                                          Vcb-&gt;TargetDeviceObject );
02688 
02689                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ) ||
02690                     FSD-&gt;<a class="code" href="../../d2/d2/structNSR__FSD.html#o0">Destag</a>.<a class="code" href="../../d7/d7/structDESTAG.html#o0">Ident</a> == <a class="code" href="../../d0/d7/iso13346_8h.html#a37">DESTAG_ID_NOTSPEC</a>) {
02691 
02692                     <span class="comment">//</span>
02693                     <span class="comment">//  These are both an excellent sign that this is an unrecorded sector, which</span>
02694                     <span class="comment">//  is defined to terminate the sequence. (3/8.4.2)</span>
02695                     <span class="comment">//</span>
02696 
02697                     <span class="keywordflow">break</span>;
02698                 }
02699 
02700                 <span class="keywordflow">if</span> ((FSD-&gt;<a class="code" href="../../d2/d2/structNSR__FSD.html#o0">Destag</a>.<a class="code" href="../../d7/d7/structDESTAG.html#o0">Ident</a> != <a class="code" href="../../d0/d7/iso13346_8h.html#a49">DESTAG_ID_NSR_FSD</a> &amp;&amp;
02701                      FSD-&gt;<a class="code" href="../../d2/d2/structNSR__FSD.html#o0">Destag</a>.<a class="code" href="../../d7/d7/structDESTAG.html#o0">Ident</a> != <a class="code" href="../../d0/d7/iso13346_8h.html#a45">DESTAG_ID_NSR_TERM</a>) ||
02702 
02703                     !<a class="code" href="../../d3/d8/udfprocs_8h.html#a219">UdfVerifyDescriptor</a>( IrpContext,
02704                                           &amp;FSD-&gt;<a class="code" href="../../d2/d2/structNSR__FSD.html#o0">Destag</a>,
02705                                           FSD-&gt;<a class="code" href="../../d2/d2/structNSR__FSD.html#o0">Destag</a>.<a class="code" href="../../d7/d7/structDESTAG.html#o0">Ident</a>,
02706                                           <span class="keyword">sizeof</span>(<a class="code" href="../../d0/d7/iso13346_8h.html#a231">NSR_FSD</a>),
02707                                           Lbn,
02708                                           <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>)) {
02709 
02710                     <span class="comment">//</span>
02711                     <span class="comment">//  If we spot an illegal descriptor type in the stream, there is no reasonable</span>
02712                     <span class="comment">//  way to guess that we can continue (the disc may be trash beyond this point).</span>
02713                     <span class="comment">//  Clearly, we also cannot trust the next extent pointed to by a corrupt</span>
02714                     <span class="comment">//  descriptor.</span>
02715                     <span class="comment">//</span>
02716 
02717                     <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_DISK_CORRUPT_ERROR );
02718                 }
02719 
02720                 <span class="keywordflow">if</span> (FSD-&gt;<a class="code" href="../../d2/d2/structNSR__FSD.html#o0">Destag</a>.<a class="code" href="../../d7/d7/structDESTAG.html#o0">Ident</a> == <a class="code" href="../../d0/d7/iso13346_8h.html#a45">DESTAG_ID_NSR_TERM</a>) {
02721 
02722                     <span class="comment">//</span>
02723                     <span class="comment">//  This is a way to terminate the sequence.</span>
02724                     <span class="comment">//</span>
02725 
02726                     <span class="keywordflow">break</span>;
02727                 }
02728 
02729                 <span class="comment">//</span>
02730                 <span class="comment">//  Reset the pointers to the possible next extent</span>
02731                 <span class="comment">//</span>
02732 
02733                 LongAd = &amp;FSD-&gt;<a class="code" href="../../d2/d2/structNSR__FSD.html#o16">NextExtent</a>;
02734 
02735                 <span class="keywordflow">if</span> (LongAd-&gt;Length.Length) {
02736 
02737                     <span class="comment">//</span>
02738                     <span class="comment">//  A fileset descriptor containing a nonzero next extent pointer also</span>
02739                     <span class="comment">//  terminates this extent of the FSD sequence. (4/8.3.1)</span>
02740                     <span class="comment">//</span>
02741                     <span class="comment">//  If the extent referred to is not fully recorded, this will</span>
02742                     <span class="comment">//  terminate the sequence.</span>
02743                     <span class="comment">//</span>
02744 
02745                     <span class="keywordflow">if</span> (LongAd-&gt;Length.Type != <a class="code" href="../../d0/d7/iso13346_8h.html#a21">NSRLENGTH_TYPE_RECORDED</a>) {
02746 
02747                         <span class="keywordflow">break</span>;
02748                     }
02749 
02750                     Len = LongAd-&gt;<a class="code" href="../../d4/d9/structLONGAD.html#o0">Length</a>.<a class="code" href="../../d7/d3/structNSRLENGTH.html#o0">Length</a>;
02751 
02752                     <span class="comment">//</span>
02753                     <span class="comment">//  The extent must be a multiple of a block size.</span>
02754                     <span class="comment">//</span>
02755 
02756                     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d8/udfprocs_8h.html#a55">BlockOffset</a>( Vcb, Len )) {
02757 
02758                         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
02759                                      <span class="stringliteral">"UdfFindFileSetDescriptor, interior extent not blocksize in length\n"</span> ));
02760                         <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a> ( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_DISK_CORRUPT_ERROR );
02761                     }
02762 
02763                     Lbn = LongAd-&gt;Start.Lbn;
02764 
02765                     <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a51">LlBytesFromBlocks</a>( Vcb, <a class="code" href="../../d3/d8/udfprocs_8h.html#a152">UdfLookupPsnOfExtent</a>( IrpContext,
02766                                                                            Vcb,
02767                                                                            LongAd-&gt;Start.Partition,
02768                                                                            Lbn,
02769                                                                            Len ));
02770 
02771                 }
02772 
02773                 <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a3">UdfStoreFileSetDescriptorIfPrevailing</a>( FileSetDescriptor, &amp;FSD );
02774             }
02775         
02776         } finally {
02777             
02778             <span class="comment">//</span>
02779             <span class="comment">//  Free up the buffer space we may have allocated</span>
02780             <span class="comment">//</span>
02781 
02782             <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>( &amp;FSD );
02783 
02784         }
02785     
02786     } except( <a class="code" href="../../d3/d8/udfprocs_8h.html#a127">UdfExceptionFilter</a>( IrpContext, GetExceptionInformation() )) {
02787 
02788         <span class="comment">//</span>
02789         <span class="comment">//  Transmute raised apparent file corruption to disk corruption - we are not</span>
02790         <span class="comment">//  yet touching the visible filesystem.</span>
02791         <span class="comment">//</span>
02792 
02793         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = IrpContext-&gt;ExceptionStatus;
02794         
02795         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
02796                      <span class="stringliteral">"UdfFindFileSetDescriptor, exception %08x thrown\n"</span>, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ));
02797 
02798         <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_FILE_CORRUPT_ERROR) {
02799 
02800             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
02801                          <span class="stringliteral">"UdfFindFileSetDescriptor, translating file corrupt to disk corrupt\n"</span> ));
02802             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_DISK_CORRUPT_ERROR;
02803         }
02804     }
02805 
02806     <span class="comment">//</span>
02807     <span class="comment">//  Success is when we've really found something.  If we failed to find the</span>
02808     <span class="comment">//  descriptor, commute whatever intermediate status was involved and clean up.</span>
02809     <span class="comment">//</span>
02810 
02811     <span class="keywordflow">if</span> (*FileSetDescriptor == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02812         
02813         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_UNRECOGNIZED_VOLUME;
02814     }
02815 
02816     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
02817 
02818         <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>( FileSetDescriptor );
02819     }
02820     
02821     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
02822                  <span class="stringliteral">"UdfFindFileSetDescriptor -&gt; %08x\n"</span>, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ));
02823     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02824 }
02825 
02826 
02827 <span class="comment">//</span>
02828 <span class="comment">//  Local support routine</span>
02829 <span class="comment">//</span>
02830 
02831 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l02832"></a><a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a8">02832</a> <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a8">UdfFindVolumeDescriptors</a> (
02833     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
02834     IN <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb,
02835     IN <a class="code" href="../../d3/d9/structEXTENTAD.html">PEXTENTAD</a> Extent,
02836     IN OUT <a class="code" href="../../d4/d9/struct__PCB.html">PPCB</a> *Pcb,
02837     IN OUT <a class="code" href="../../d0/d3/structNSR__PVD.html">PNSR_PVD</a> *PrimaryVolumeDescriptor,
02838     IN OUT <a class="code" href="../../d6/d2/structNSR__LVOL.html">PNSR_LVOL</a> *LogicalVolumeDescriptor
02839     )
02840 
02841 <span class="comment">/*++</span>
02842 <span class="comment"></span>
02843 <span class="comment">Routine Description:</span>
02844 <span class="comment"></span>
02845 <span class="comment">    This routine walks the indicated Volume Descriptor Sequence searching for the</span>
02846 <span class="comment">    active descriptors for this volume and generates an initializing Pcb from the</span>
02847 <span class="comment">    referenced partitions.  No updating of the Vcb occurs.</span>
02848 <span class="comment"></span>
02849 <span class="comment">Arguments:</span>
02850 <span class="comment"></span>
02851 <span class="comment">    Vcb - Vcb of volume to search</span>
02852 <span class="comment"></span>
02853 <span class="comment">    Extent - Extent to search</span>
02854 <span class="comment"></span>
02855 <span class="comment">    Pcb - Address of a caller's pointer to a Pcb</span>
02856 <span class="comment"></span>
02857 <span class="comment">    PrimaryVolumeDescriptor - Address of caller's pointer to a PVD</span>
02858 <span class="comment"></span>
02859 <span class="comment">    LogicalVolumeDescriptor - Address of caller's pointer to an LVD</span>
02860 <span class="comment"></span>
02861 <span class="comment">Return Value:</span>
02862 <span class="comment"></span>
02863 <span class="comment">    STATUS_SUCCESS if all descriptors are found, read, and are valid.</span>
02864 <span class="comment"></span>
02865 <span class="comment">    STATUS_DISK_CORRUPT_ERROR if corrupt descriptors are found.</span>
02866 <span class="comment"></span>
02867 <span class="comment">    STATUS_UNRECOGNIZED_VOLUME if noncompliant descriptors are found.</span>
02868 <span class="comment">    </span>
02869 <span class="comment">    Descriptors are only returned on success.</span>
02870 <span class="comment"></span>
02871 <span class="comment">--*/</span>
02872 
02873 {
02874     <a class="code" href="../../d4/d3/structNSR__VD__GENERIC.html">PNSR_VD_GENERIC</a> GenericVD = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02875     ULONGLONG <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
02876     ULONG Len;
02877     ULONG UnitSize = <a class="code" href="../../d3/d8/udfprocs_8h.html#a164">UdfRawReadSize</a>( Vcb, <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d3/structNSR__VD__GENERIC.html">NSR_VD_GENERIC</a>) );
02878 
02879     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
02880     ULONG ThisPass = 1;
02881 
02882     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02883 
02884     <span class="comment">//</span>
02885     <span class="comment">//  Check the input parameters</span>
02886     <span class="comment">//</span>
02887 
02888     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext);
02889     <a class="code" href="../../d1/d8/udfdata_8h.html#a12">ASSERT_VCB</a>( Vcb );
02890     <a class="code" href="../../d1/d8/udfdata_8h.html#a25">ASSERT_OPTIONAL_PCB</a>( *Pcb );
02891 
02892     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
02893                  <span class="stringliteral">"UdfFindVolumeDescriptors, Vcb %08x, Extent %08x +%08x\n"</span>,
02894                  Vcb,
02895                  Extent-&gt;Lsn,
02896                  Extent-&gt;Len ));
02897 
02898     <span class="comment">//</span>
02899     <span class="comment">//  If the extent we begin from is not at least the size of an aligned descriptor</span>
02900     <span class="comment">//  or is sized in base units other than aligned descriptors, we can't continue.</span>
02901     <span class="comment">//</span>
02902 
02903     <span class="keywordflow">if</span> (Extent-&gt;Len &lt; UnitSize ||
02904         Extent-&gt;Len % UnitSize) {
02905 
02906         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
02907                      <span class="stringliteral">"UdfFindVolumeDescriptors, Base extent length %08x is mismatched with read size %08x\n"</span>,
02908                      Extent-&gt;Len,
02909                      UnitSize ));
02910 
02911         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
02912                      <span class="stringliteral">"UdfFindVolumeDescriptors -&gt; STATUS_DISK_CORRUPT_ERROR\n"</span> ));
02913 
02914         <span class="keywordflow">return</span> STATUS_DISK_CORRUPT_ERROR;
02915     }
02916 
02917     <span class="comment">//</span>
02918     <span class="comment">//  Use a try-finally to facilitate cleanup.</span>
02919     <span class="comment">//</span>
02920 
02921     <span class="keywordflow">try</span> {
02922 
02923         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
02924                      <span class="stringliteral">"UdfFindVolumeDescriptors, starting pass 1, find LVD/PVD\n"</span> ));
02925 
02926         <span class="comment">//</span>
02927         <span class="comment">//  We will make at least one pass through the Volume Descriptor Sequence to find</span>
02928         <span class="comment">//  the prevailing versions of the two controlling descriptors - the PVD and LVD.</span>
02929         <span class="comment">//  In order to avoid picking up partition descriptors that aren't actually going</span>
02930         <span class="comment">//  to be referenced by the LVD, we will pick them up in a second pass if we find</span>
02931         <span class="comment">//  a PVD and LVD that look reasonable and then stick them in a Pcb.</span>
02932         <span class="comment">//</span>
02933 
02934         <span class="keywordflow">for</span> (ThisPass = 1; ThisPass &lt;= 2; ThisPass++) {
02935 
02936             <span class="keywordflow">for</span> ( <span class="comment">//</span>
02937                   <span class="comment">//  Home ourselves in the search and make a pass through the sequence.</span>
02938                   <span class="comment">//</span>
02939 
02940                   <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a39">LlBytesFromSectors</a>( Vcb, Extent-&gt;Lsn ),
02941                   Len = Extent-&gt;Len;
02942 
02943                   <span class="comment">//</span>
02944                   <span class="comment">//  If we have reached the end of the extent's indicated valid</span>
02945                   <span class="comment">//  length, we are done. This usually will not happen.</span>
02946                   <span class="comment">//</span>
02947 
02948                   Len;
02949 
02950                   <span class="comment">//</span>
02951                   <span class="comment">//  Advance to the next descriptor offset in the sequence.</span>
02952                   <span class="comment">//</span>
02953 
02954                   <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> += UnitSize,
02955                   Len -= UnitSize ) {
02956 
02957                 <span class="comment">//</span>
02958                 <span class="comment">//  Allocate a buffer to read generic volume descriptors.</span>
02959                 <span class="comment">//</span>
02960 
02961                 <span class="keywordflow">if</span> (GenericVD == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02962 
02963                     GenericVD = (<a class="code" href="../../d4/d3/structNSR__VD__GENERIC.html">PNSR_VD_GENERIC</a>) <a class="code" href="../../d1/d8/fsrtl_8h.html#a37">FsRtlAllocatePoolWithTag</a>( <a class="code" href="../../d3/d8/udfprocs_8h.html#a66">UdfNonPagedPool</a>,
02964                                                                             <a class="code" href="../../d3/d8/udfprocs_8h.html#a163">UdfRawBufferSize</a>( Vcb, <span class="keyword">sizeof</span>(<a class="code" href="../../d0/d7/iso13346_8h.html#a201">NSR_VD_GENERIC</a>) ),
02965                                                                             <a class="code" href="../../d1/d7/udfs_2nodetype_8h.html#a88">TAG_NSR_VDSD</a> );
02966                 }
02967 
02968                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a160">UdfReadSectors</a>( IrpContext,
02969                                          <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>,
02970                                          UnitSize,
02971                                          <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
02972                                          GenericVD,
02973                                          Vcb-&gt;TargetDeviceObject );
02974 
02975                 <span class="comment">//</span>
02976                 <span class="comment">//  Thise is a decent sign that this is an unrecorded sector and is</span>
02977                 <span class="comment">//  defined to terminate the sequence.</span>
02978                 <span class="comment">//</span>
02979 
02980                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
02981 
02982                     <span class="keywordflow">break</span>;
02983                 }
02984 
02985                 <span class="keywordflow">if</span> (GenericVD-&gt;<a class="code" href="../../d4/d3/structNSR__VD__GENERIC.html#o0">Destag</a>.<a class="code" href="../../d7/d7/structDESTAG.html#o0">Ident</a> &gt; <a class="code" href="../../d0/d7/iso13346_8h.html#a48">DESTAG_ID_MAXIMUM_PART3</a> ||
02986 
02987                     !<a class="code" href="../../d3/d8/udfprocs_8h.html#a219">UdfVerifyDescriptor</a>( IrpContext,
02988                                           &amp;GenericVD-&gt;<a class="code" href="../../d4/d3/structNSR__VD__GENERIC.html#o0">Destag</a>,
02989                                           GenericVD-&gt;<a class="code" href="../../d4/d3/structNSR__VD__GENERIC.html#o0">Destag</a>.<a class="code" href="../../d7/d7/structDESTAG.html#o0">Ident</a>,
02990                                           <span class="keyword">sizeof</span>(<a class="code" href="../../d0/d7/iso13346_8h.html#a201">NSR_VD_GENERIC</a>),
02991                                           (ULONG) <a class="code" href="../../d3/d8/fsrtlp_8h.html#a13">SectorsFromBytes</a>( Vcb, <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> ),
02992                                           <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>)) {
02993 
02994                     <span class="comment">//</span>
02995                     <span class="comment">//  If we spot an illegal descriptor type in the stream, there is no reasonable</span>
02996                     <span class="comment">//  way to guess that we can continue (the disc may be trash beyond this point).</span>
02997                     <span class="comment">//  Likewise, even if we have a single corrupt descriptor we cannot continue because</span>
02998                     <span class="comment">//  this may be corruption of a descriptor we may have otherwise required for operation</span>
02999                     <span class="comment">//  (i.e., one of the prevailing descriptors).</span>
03000                     <span class="comment">//</span>
03001 
03002                     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
03003                                  <span class="stringliteral">"UdfFindVolumeDescriptors, descriptor didn't verify\n"</span> ));
03004 
03005                     <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_DISK_CORRUPT_ERROR );
03006                 }
03007 
03008                 <span class="keywordflow">if</span> (GenericVD-&gt;<a class="code" href="../../d4/d3/structNSR__VD__GENERIC.html#o0">Destag</a>.<a class="code" href="../../d7/d7/structDESTAG.html#o0">Ident</a> == <a class="code" href="../../d0/d7/iso13346_8h.html#a45">DESTAG_ID_NSR_TERM</a>) {
03009 
03010                     <span class="comment">//</span>
03011                     <span class="comment">//  The Terminating Descriptor (3/10.9) is the usual way to stop a search.</span>
03012                     <span class="comment">//</span>
03013 
03014                     <span class="keywordflow">break</span>;
03015                 }
03016 
03017                 <span class="keywordflow">if</span> (GenericVD-&gt;<a class="code" href="../../d4/d3/structNSR__VD__GENERIC.html#o0">Destag</a>.<a class="code" href="../../d7/d7/structDESTAG.html#o0">Ident</a> == <a class="code" href="../../d0/d7/iso13346_8h.html#a40">DESTAG_ID_NSR_VDP</a>) {
03018 
03019                     <span class="comment">//</span>
03020                     <span class="comment">//  Follow a Volume Desciptor Pointer (3/10.3) to the next extent of the sequence.</span>
03021                     <span class="comment">//</span>
03022 
03023                     <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a39">LlBytesFromSectors</a>( Vcb, ((<a class="code" href="../../d5/d3/structNSR__VDP.html">PNSR_VDP</a>) GenericVD)-&gt;Next.Lsn );
03024                     Len = ((<a class="code" href="../../d5/d3/structNSR__VDP.html">PNSR_VDP</a>) GenericVD)-&gt;Next.Len;
03025 
03026                     <span class="comment">//</span>
03027                     <span class="comment">//  We cannot do anything if the extent is invalid</span>
03028                     <span class="comment">//</span>
03029 
03030                     <span class="keywordflow">if</span> (Len &lt; UnitSize ||
03031                         Len % UnitSize) {
03032 
03033                         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
03034                                      <span class="stringliteral">"UdfFindVolumeDescriptors, following extent length %08x is mismatched with read size %08x\n"</span>,
03035                                      Extent-&gt;Len,
03036                                      UnitSize ));
03037 
03038                         <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_DISK_CORRUPT_ERROR );
03039                     }
03040                 }
03041 
03042                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
03043                              <span class="stringliteral">"UdfFindVolumeDescriptors, descriptor tag %08x\n"</span>,
03044                              GenericVD-&gt;<a class="code" href="../../d4/d3/structNSR__VD__GENERIC.html#o0">Destag</a>.<a class="code" href="../../d7/d7/structDESTAG.html#o0">Ident</a> ));
03045 
03046                 <span class="keywordflow">if</span> (ThisPass == 1) {
03047 
03048                     <span class="comment">//</span>
03049                     <span class="comment">//  Our first pass is to find prevailing LVD and PVD.</span>
03050                     <span class="comment">//</span>
03051 
03052                     <span class="keywordflow">switch</span> (GenericVD-&gt;<a class="code" href="../../d4/d3/structNSR__VD__GENERIC.html#o0">Destag</a>.<a class="code" href="../../d7/d7/structDESTAG.html#o0">Ident</a>) {
03053 
03054                         <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/iso13346_8h.html#a38">DESTAG_ID_NSR_PVD</a>:
03055 
03056                             <a class="code" href="../../d3/d8/udfprocs_8h.html#a176">UdfStoreVolumeDescriptorIfPrevailing</a>( (<a class="code" href="../../d4/d3/structNSR__VD__GENERIC.html">PNSR_VD_GENERIC</a> *) PrimaryVolumeDescriptor,
03057                                                                   GenericVD );
03058                             <span class="keywordflow">break</span>;
03059 
03060                         <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/iso13346_8h.html#a43">DESTAG_ID_NSR_LVOL</a>:
03061 
03062                             <a class="code" href="../../d3/d8/udfprocs_8h.html#a176">UdfStoreVolumeDescriptorIfPrevailing</a>( (<a class="code" href="../../d4/d3/structNSR__VD__GENERIC.html">PNSR_VD_GENERIC</a> *) LogicalVolumeDescriptor,
03063                                                                   GenericVD );
03064                             <span class="keywordflow">break</span>;
03065 
03066                         <span class="keywordflow">default</span>:
03067 
03068                             <span class="keywordflow">break</span>;
03069                     }
03070 
03071                 } <span class="keywordflow">else</span> {
03072 
03073                     <a class="code" href="../../d7/d2/structNSR__PART.html">PNSR_PART</a> PartitionDescriptor = (<a class="code" href="../../d7/d2/structNSR__PART.html">PNSR_PART</a>) GenericVD;
03074 
03075                     <span class="comment">//</span>
03076                     <span class="comment">//  Our second pass is to pick up all relavent NSR02 PD</span>
03077                     <span class="comment">//</span>
03078 
03079                     <span class="keywordflow">if</span> (PartitionDescriptor-&gt;<a class="code" href="../../d7/d2/structNSR__PART.html#o0">Destag</a>.<a class="code" href="../../d7/d7/structDESTAG.html#o0">Ident</a> != <a class="code" href="../../d0/d7/iso13346_8h.html#a42">DESTAG_ID_NSR_PART</a> ||
03080                         !<a class="code" href="../../d3/d8/udfprocs_8h.html#a229">UdfEqualEntityId</a>( &amp;PartitionDescriptor-&gt;<a class="code" href="../../d7/d2/structNSR__PART.html#o4">ContentsID</a>, &amp;<a class="code" href="../../d0/d8/udfdata_8c.html#a20">UdfNSR02Identifier</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> )) {
03081 
03082                         <span class="keywordflow">continue</span>;
03083                     }
03084 
03085                     <a class="code" href="../../d3/d8/udfprocs_8h.html#a149">UdfAddToPcb</a>( *Pcb, (<a class="code" href="../../d7/d2/structNSR__PART.html">PNSR_PART</a>) GenericVD );
03086                 }
03087             }
03088 
03089             <span class="comment">//</span>
03090             <span class="comment">//  Now that a pass through the VDS has been completed, analyze the results.</span>
03091             <span class="comment">//</span>
03092 
03093             <span class="keywordflow">if</span> (ThisPass == 1) {
03094 
03095                 <a class="code" href="../../d0/d3/structNSR__PVD.html">PNSR_PVD</a> PVD;
03096                 <a class="code" href="../../d6/d2/structNSR__LVOL.html">PNSR_LVOL</a> LVD;
03097 
03098                 <span class="comment">//</span>
03099                 <span class="comment">//  Reference the descriptors for ease of use</span>
03100                 <span class="comment">//</span>
03101 
03102                 PVD = *PrimaryVolumeDescriptor;
03103                 LVD = *LogicalVolumeDescriptor;
03104 
03105                 <span class="comment">//</span>
03106                 <span class="comment">//  Check that the descriptors indicate a logical volume which appears to</span>
03107                 <span class="comment">//  be a valid UDF volume.</span>
03108                 <span class="comment">//</span>
03109 
03110                 <span class="keywordflow">if</span> ((PVD == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> &amp;&amp;
03111                      <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
03112                                   <span class="stringliteral">"UdfFindVolumeDescriptors, don't have a PVD\n"</span> ))) ||
03113                     (LVD == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> &amp;&amp;
03114                      <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
03115                                   <span class="stringliteral">"UdfFindVolumeDescriptors, don't have an LVD\n"</span> ))) ||
03116 
03117                     <span class="comment">//</span>
03118                     <span class="comment">//  Now check the PVD</span>
03119                     <span class="comment">//</span>
03120 
03121                     <span class="comment">//</span>
03122                     <span class="comment">//  The Volume Set Sequence fields indicates how many volumes form</span>
03123                     <span class="comment">//  the volume set and what number this volume is in that sequence.</span>
03124                     <span class="comment">//  We are a level 2 implementation, meaning that the volumes we read</span>
03125                     <span class="comment">//  consist of a single volume. (3/11)</span>
03126                     <span class="comment">//</span>
03127 
03128                     (PVD-&gt;<a class="code" href="../../d0/d3/structNSR__PVD.html#o4">VolSetSeq</a> &gt; 1 &amp;&amp;
03129                      <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
03130                                   <span class="stringliteral">"UdfFindVolumeDescriptors, PVD VolSetSeq %08x - not volume 1 of a volume set\n"</span>,
03131                                   PVD-&gt;<a class="code" href="../../d0/d3/structNSR__PVD.html#o4">VolSetSeq</a> ))) ||
03132                     (PVD-&gt;<a class="code" href="../../d0/d3/structNSR__PVD.html#o5">VolSetSeqMax</a> &gt; 1 &amp;&amp;
03133                      <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
03134                                   <span class="stringliteral">"UdfFindVolumeDescriptors, PVD VolSetSeqMax %08x - volume in a non-unit volume set\n"</span>,
03135                                   PVD-&gt;<a class="code" href="../../d0/d3/structNSR__PVD.html#o5">VolSetSeqMax</a> ))) ||
03136 
03137                     
03138 <span class="preprocessor">#ifndef UDF_SUPPORT_NONSTANDARD_ALLSTOR</span>
03139 <span class="preprocessor"></span>
03140                     <span class="comment">//</span>
03141                     <span class="comment">//  Disable checking of character set lists.</span>
03142                     <span class="comment">//</span>
03143                     <span class="comment">//  Reason: first drop of Allstor media recorded these fields as 0x0.</span>
03144                     <span class="comment">//</span>
03145 
03146                     <span class="comment">//</span>
03147                     <span class="comment">//  Insure that Character Set Lists conform to UDF</span>
03148                     <span class="comment">//</span>
03149 
03150                     (PVD-&gt;<a class="code" href="../../d0/d3/structNSR__PVD.html#o8">CharSetList</a> != <a class="code" href="../../d9/d7/udf_8h.html#a55">UDF_CHARSETLIST</a> &amp;&amp;
03151                      <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
03152                                   <span class="stringliteral">"UdfFindVolumeDescriptors, PVD CharSetList %08x != CS0 only\n"</span>,
03153                                   PVD-&gt;<a class="code" href="../../d0/d3/structNSR__PVD.html#o8">CharSetList</a> ))) ||
03154                     (PVD-&gt;<a class="code" href="../../d0/d3/structNSR__PVD.html#o9">CharSetListMax</a> != <a class="code" href="../../d9/d7/udf_8h.html#a55">UDF_CHARSETLIST</a> &amp;&amp;
03155                      <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
03156                                   <span class="stringliteral">"UdfFindVolumeDescriptors, PVD CharSetListMax %08x != CS0 only\n"</span>,
03157                                   PVD-&gt;<a class="code" href="../../d0/d3/structNSR__PVD.html#o9">CharSetListMax</a> ))) ||
03158 
03159                     <span class="comment">//</span>
03160                     <span class="comment">//  Disable checking of character set lists.</span>
03161                     <span class="comment">//</span>
03162                     <span class="comment">//  Reason: first drop of Allstor media misspelled "Compressed" as "Copmressed"</span>
03163                     <span class="comment">//</span>
03164 
03165                     <span class="comment">//</span>
03166                     <span class="comment">//  The two character sets must be UDF CS0.  CS0 is a "by convention"</span>
03167                     <span class="comment">//  character set in ISO 13346, which UDF specifies for our domain.</span>
03168                     <span class="comment">//</span>
03169 
03170                     (!<a class="code" href="../../d3/d8/udfprocs_8h.html#a248">UdfEqualCharspec</a>( &amp;PVD-&gt;<a class="code" href="../../d0/d3/structNSR__PVD.html#o11">CharsetDesc</a>, &amp;<a class="code" href="../../d0/d8/udfdata_8c.html#a8">UdfCS0Identifier</a>, <a class="code" href="../../d0/d7/iso13346_8h.html#a0">CHARSPEC_T_CS0</a> ) &amp;&amp;
03171                      <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
03172                                  <span class="stringliteral">"UdfFindVolumeDescriptors, PVD CharsetDesc != CS0 only\n"</span> ))) ||
03173                     (!<a class="code" href="../../d3/d8/udfprocs_8h.html#a248">UdfEqualCharspec</a>( &amp;PVD-&gt;<a class="code" href="../../d0/d3/structNSR__PVD.html#o12">CharsetExplan</a>, &amp;<a class="code" href="../../d0/d8/udfdata_8c.html#a8">UdfCS0Identifier</a>, <a class="code" href="../../d0/d7/iso13346_8h.html#a0">CHARSPEC_T_CS0</a> ) &amp;&amp;
03174                      <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
03175                                   <span class="stringliteral">"UdfFindVolumeDescriptors, PVD CharsetExplan != CS0 only\n"</span> ))) ||
03176 
03177 <span class="preprocessor">#endif</span>
03178 <span class="preprocessor"></span>                    <span class="comment">//</span>
03179                     <span class="comment">//  Now check the LVD</span>
03180                     <span class="comment">//</span>
03181 
03182                     <span class="comment">//</span>
03183                     <span class="comment">//  The LVD is a variant sized structure.  Check that the claimed size fits in a single</span>
03184                     <span class="comment">//  logical sector.  Although an LVD may legally exceed a single sector, we will never</span>
03185                     <span class="comment">//  want to deal with such a volume.</span>
03186                     <span class="comment">//</span>
03187 
03188                     (<a class="code" href="../../d0/d7/iso13346_8h.html#a80">ISONsrLvolSize</a>( LVD ) &gt; <a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a>( Vcb ) &amp;&amp;
03189                      <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
03190                                   <span class="stringliteral">"UdfFindVolumeDescriptors, LVD is bigger than a sector\n"</span> ))) ||
03191 
03192 <span class="preprocessor">#ifndef UDF_SUPPORT_NONSTANDARD_ALLSTOR</span>
03193 <span class="preprocessor"></span>                    
03194                     <span class="comment">//</span>
03195                     <span class="comment">//  Disable checking of character set lists.</span>
03196                     <span class="comment">//</span>
03197                     <span class="comment">//  Reason: first drop of Allstor media recorded these fields as 0x0.</span>
03198                     <span class="comment">//</span>
03199 
03200                     <span class="comment">//</span>
03201                     <span class="comment">//  The character set used in the LVD must be UDF CS0 as well.</span>
03202                     <span class="comment">//</span>
03203 
03204                     (!<a class="code" href="../../d3/d8/udfprocs_8h.html#a248">UdfEqualCharspec</a>( &amp;LVD-&gt;<a class="code" href="../../d6/d2/structNSR__LVOL.html#o2">Charset</a>, &amp;<a class="code" href="../../d0/d8/udfdata_8c.html#a8">UdfCS0Identifier</a>, <a class="code" href="../../d0/d7/iso13346_8h.html#a0">CHARSPEC_T_CS0</a> ) &amp;&amp;
03205                      <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
03206                                  <span class="stringliteral">"UdfFindVolumeDescriptors, LVD Charset != CS0 only\n"</span> ))) ||
03207 <span class="preprocessor">#endif</span>
03208 <span class="preprocessor"></span>
03209                     <span class="comment">//</span>
03210                     <span class="comment">//  The specified block size must equal the physical sector size.</span>
03211                     <span class="comment">//</span>
03212 
03213                     (LVD-&gt;<a class="code" href="../../d6/d2/structNSR__LVOL.html#o4">BlockSize</a> != <a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a>( Vcb ) &amp;&amp;
03214                      <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
03215                                   <span class="stringliteral">"UdfFindVolumeDescriptors, LVD BlockSize %08x != SectorSize %08x\n"</span> ))) ||
03216 
03217                     <span class="comment">//</span>
03218                     <span class="comment">//  The domain must be within the version we read</span>
03219                     <span class="comment">//</span>
03220 
03221                     (!<a class="code" href="../../d3/d8/udfprocs_8h.html#a230">UdfDomainIdentifierContained</a>( &amp;LVD-&gt;<a class="code" href="../../d6/d2/structNSR__LVOL.html#o5">DomainID</a>,
03222                                                     &amp;<a class="code" href="../../d0/d8/udfdata_8c.html#a10">UdfDomainIdentifier</a>,
03223                                                     <a class="code" href="../../d9/d7/udf_8h.html#a5">UDF_VERSION_MINIMUM</a>,
03224                                                     <a class="code" href="../../d9/d7/udf_8h.html#a4">UDF_VERSION_RECOGNIZED</a> ) &amp;&amp;
03225                      <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
03226                                   <span class="stringliteral">"UdfFindVolumeDescriptors, domain ID indicates unreadable volume\n"</span> ))) ||
03227 
03228                     <span class="comment">//</span>
03229                     <span class="comment">//  Although we can handle any number of partitions, UDF only specifies</span>
03230                     <span class="comment">//  a single partition or special dual partition formats.</span>
03231                     <span class="comment">//</span>
03232 
03233                     (LVD-&gt;<a class="code" href="../../d6/d2/structNSR__LVOL.html#o8">MapTableCount</a> &gt; 2 &amp;&amp;
03234                      <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
03235                                   <span class="stringliteral">"UdfFindVolumeDescriptors, LVD MapTableCount %08x greater than allowed (2)\n"</span>,
03236                                   LVD-&gt;<a class="code" href="../../d6/d2/structNSR__LVOL.html#o8">MapTableCount</a> )))
03237                     ) {
03238 
03239                     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
03240                                  <span class="stringliteral">"UdfFindVolumeDescriptors, ... so returning STATUS_UNRECOGNIZED_VOLUME\n"</span> ));
03241 
03242                     <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_UNRECOGNIZED_VOLUME );
03243                 }
03244 
03245                 <span class="comment">//</span>
03246                 <span class="comment">//  Now that we have performed the simple field checks, build a Pcb.</span>
03247                 <span class="comment">//</span>
03248 
03249                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a148">UdfInitializePcb</a>( IrpContext, Vcb, Pcb, LVD );
03250 
03251                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
03252 
03253                     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
03254                                  <span class="stringliteral">"UdfFindVolumeDescriptors, Pcb intialization failed (!)\n"</span> ));
03255 
03256                     <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
03257                 }
03258             }
03259 
03260             <span class="comment">//</span>
03261             <span class="comment">//  Go onto Pass 2 to find the Partition Descriptors</span>
03262             <span class="comment">//</span>
03263 
03264             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
03265                          <span class="stringliteral">"UdfFindVolumeDescriptors, starting pass 2, find associated PD\n"</span> ));
03266         }
03267 
03268     } finally {
03269 
03270         <a class="code" href="../../d8/d3/lfsdata_8h.html#a3">DebugUnwind</a>( <span class="stringliteral">"UdfFindVolumeDescriptors"</span> );
03271 
03272         <span class="comment">//</span>
03273         <span class="comment">//  Free up the buffer space we may have allocated</span>
03274         <span class="comment">//</span>
03275 
03276         <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>( &amp;GenericVD );
03277     }
03278 
03279     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
03280                  <span class="stringliteral">"UdfFindVolumeDescriptors -&gt; %08x\n"</span>, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ));
03281 
03282     <span class="comment">//</span>
03283     <span class="comment">//  Success is when we've really found something.  If we failed to find both</span>
03284     <span class="comment">//  descriptors, commute whatever intermediate status was involved and clean up.</span>
03285     <span class="comment">//</span>
03286 
03287     <span class="keywordflow">if</span> (*PrimaryVolumeDescriptor == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> || *LogicalVolumeDescriptor == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03288         
03289         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_UNRECOGNIZED_VOLUME;
03290     }
03291 
03292     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
03293         
03294         <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>(PrimaryVolumeDescriptor);
03295         <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>(LogicalVolumeDescriptor);
03296     }
03297     
03298     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
03299 }
03300 
03301 
03302 <span class="comment">//</span>
03303 <span class="comment">//  Local support routine</span>
03304 <span class="comment">//</span>
03305 
03306 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l03307"></a><a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a6">03307</a> <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a6">UdfFindAnchorVolumeDescriptor</a> (
03308     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
03309     IN <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb,
03310     IN OUT <a class="code" href="../../d7/d1/structNSR__ANCHOR.html">PNSR_ANCHOR</a> *AnchorVolumeDescriptor
03311     )
03312 
03313 <span class="comment">/*++</span>
03314 <span class="comment"></span>
03315 <span class="comment">Routine Description:</span>
03316 <span class="comment"></span>
03317 <span class="comment">    This routine will find the Anchor Volume Descriptor for a piece of media</span>
03318 <span class="comment"></span>
03319 <span class="comment">Arguments:</span>
03320 <span class="comment"></span>
03321 <span class="comment">    Vcb - Vcb of volume to search</span>
03322 <span class="comment"></span>
03323 <span class="comment">    AnchorVolumeDescriptor - Caller's pointer to an AVD</span>
03324 <span class="comment"></span>
03325 <span class="comment">Return Value:</span>
03326 <span class="comment"></span>
03327 <span class="comment">    Boolean TRUE if AVD is discovered, FALSE otherwise.</span>
03328 <span class="comment"></span>
03329 <span class="comment">--*/</span>
03330 
03331 {
03332     ULONG ThisPass;
03333     ULONG ReadLsn;
03334     ULONG Lsn;
03335     BOOLEAN Found = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03336     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
03337 
03338     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
03339 
03340     <span class="comment">//</span>
03341     <span class="comment">//  Check the input parameters</span>
03342     <span class="comment">//</span>
03343 
03344     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext);
03345     <a class="code" href="../../d1/d8/udfdata_8h.html#a12">ASSERT_VCB</a>( Vcb );
03346 
03347     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(*AnchorVolumeDescriptor == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
03348 
03349     <span class="comment">//</span>
03350     <span class="comment">//  Discover the Anchor Volume Descriptor, which will point towards the</span>
03351     <span class="comment">//  Volume Set Descriptor Sequence.  The AVD may exist at sector 256 or</span>
03352     <span class="comment">//  in the last sector of the volume.</span>
03353     <span class="comment">//</span>
03354 
03355     *AnchorVolumeDescriptor = (<a class="code" href="../../d7/d1/structNSR__ANCHOR.html">PNSR_ANCHOR</a>) <a class="code" href="../../d1/d8/fsrtl_8h.html#a37">FsRtlAllocatePoolWithTag</a>( <a class="code" href="../../d3/d8/udfprocs_8h.html#a66">UdfNonPagedPool</a>,
03356                                                                       <a class="code" href="../../d3/d8/udfprocs_8h.html#a163">UdfRawBufferSize</a>( Vcb, <span class="keyword">sizeof</span>(<a class="code" href="../../d7/d1/structNSR__ANCHOR.html">NSR_ANCHOR</a>) ),
03357                                                                       <a class="code" href="../../d1/d7/udfs_2nodetype_8h.html#a88">TAG_NSR_VDSD</a> );
03358 
03359 
03360     <span class="comment">//</span>
03361     <span class="comment">//  Search the three possible locations for an AVD to exist on the volume,</span>
03362     <span class="comment">//  plus check for the possibility of a method 2 fixup requirement.</span>
03363     <span class="comment">//</span>
03364 
03365     <span class="keywordflow">for</span> ( ThisPass = 1; ThisPass &lt;= 4; ThisPass++ ) {
03366 
03367         <span class="keywordflow">if</span> (ThisPass == 1) {
03368 
03369             ReadLsn = Lsn = <a class="code" href="../../d0/d7/iso13346_8h.html#a63">ANCHOR_SECTOR</a> + Vcb-&gt;BoundS;
03370 
03371         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ThisPass == 2) {
03372 
03373             <span class="comment">//</span>
03374             <span class="comment">//  It is so unlikely that we will get a disk that doesn't have</span>
03375             <span class="comment">//  an anchor at 256 that this is a pretty good indication we</span>
03376             <span class="comment">//  have a CD-RW here and the drive is method 2 goofy.  Take</span>
03377             <span class="comment">//  a shot.</span>
03378             <span class="comment">//</span>
03379 
03380             ReadLsn = <a class="code" href="../../d9/d7/udf_8h.html#a9">UdfMethod2TransformSector</a>( Vcb, <a class="code" href="../../d0/d7/iso13346_8h.html#a63">ANCHOR_SECTOR</a> );
03381             Lsn = <a class="code" href="../../d0/d7/iso13346_8h.html#a63">ANCHOR_SECTOR</a>;
03382 
03383         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ThisPass == 3) {
03384 
03385             <span class="comment">//</span>
03386             <span class="comment">//  Our remaining two chances depend on being able to determine</span>
03387             <span class="comment">//  the last recorded sector for the volume.  If we were unable</span>
03388             <span class="comment">//  to do this, stop.</span>
03389             <span class="comment">//</span>
03390 
03391             <span class="keywordflow">if</span> (!Vcb-&gt;BoundN) {
03392 
03393                 <span class="keywordflow">break</span>;
03394             }
03395 
03396             ReadLsn = Lsn = Vcb-&gt;BoundN;
03397 
03398         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ThisPass == 4) {
03399 
03400             ReadLsn = Lsn = Vcb-&gt;BoundN - <a class="code" href="../../d0/d7/iso13346_8h.html#a63">ANCHOR_SECTOR</a>;
03401         }
03402 
03403         <span class="comment">//</span>
03404         <span class="comment">//  We may have more chances to succeed if failure occurs.</span>
03405         <span class="comment">//</span>
03406 
03407         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a160">UdfReadSectors</a>( IrpContext,
03408                                  <a class="code" href="../../d3/d8/udfprocs_8h.html#a39">LlBytesFromSectors</a>( Vcb, ReadLsn ),
03409                                  <a class="code" href="../../d3/d8/udfprocs_8h.html#a164">UdfRawReadSize</a>( Vcb, <span class="keyword">sizeof</span>(<a class="code" href="../../d0/d7/iso13346_8h.html#a205">NSR_ANCHOR</a>) ),
03410                                  <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
03411                                  *AnchorVolumeDescriptor,
03412                                  Vcb-&gt;TargetDeviceObject );
03413 
03414         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
03415             <span class="keywordflow">continue</span>;
03416         }
03417 
03418         <span class="keywordflow">if</span> (!<a class="code" href="../../d3/d8/udfprocs_8h.html#a219">UdfVerifyDescriptor</a>( IrpContext,
03419                                   &amp;(*AnchorVolumeDescriptor)-&gt;Destag,
03420                                   <a class="code" href="../../d0/d7/iso13346_8h.html#a39">DESTAG_ID_NSR_ANCHOR</a>,
03421                                   <span class="keyword">sizeof</span>(<a class="code" href="../../d0/d7/iso13346_8h.html#a205">NSR_ANCHOR</a>),
03422                                   Lsn,
03423                                   <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>)) {
03424 
03425             <span class="keywordflow">continue</span>;
03426         }
03427         
03428         <span class="comment">//</span>
03429         <span class="comment">//  Got one!  Set the method 2 fixup appropriately.</span>
03430         <span class="comment">//</span>
03431 
03432         <span class="keywordflow">if</span> (ThisPass == 2) {
03433 
03434             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"************************************************\n"</span>));
03435             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"METHOD 2 FIXUPS ACTIVATED FOR Vcb @ %08x\n"</span>, Vcb ));
03436             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"************************************************\n"</span>));
03437 
03438             <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( Vcb-&gt;VcbState, <a class="code" href="../../d6/d8/udfstruc_8h.html#a8">VCB_STATE_METHOD_2_FIXUP</a> );
03439         
03440         } <span class="keywordflow">else</span> {
03441             
03442             <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>( Vcb-&gt;VcbState, <a class="code" href="../../d6/d8/udfstruc_8h.html#a8">VCB_STATE_METHOD_2_FIXUP</a> );
03443         }
03444         
03445         <span class="keywordflow">return</span> STATUS_SUCCESS;
03446     }
03447 
03448     <span class="keywordflow">return</span> STATUS_UNRECOGNIZED_VOLUME;
03449 }
03450 
03451 
03452 <span class="comment">//</span>
03453 <span class="comment">//  Local support routine</span>
03454 <span class="comment">//</span>
03455 
03456 BOOLEAN
<a name="l03457"></a><a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a17">03457</a> <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a17">UdfRecognizeVolume</a> (
03458     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
03459     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
03460     IN ULONG SectorSize,
03461     IN OUT PBOOLEAN Bridge
03462     )
03463 
03464 <span class="comment">/*++</span>
03465 <span class="comment"></span>
03466 <span class="comment">Routine Description:</span>
03467 <span class="comment"></span>
03468 <span class="comment">    This routine walks the Volume Recognition Sequence to determine</span>
03469 <span class="comment">    whether this volume contains an NSR02 (ISO 13346 Section 4) image.</span>
03470 <span class="comment"></span>
03471 <span class="comment">Arguments:</span>
03472 <span class="comment"></span>
03473 <span class="comment">    DeviceObject - device we are checking</span>
03474 <span class="comment"></span>
03475 <span class="comment">    SectorSize - size of a physical sector on this device</span>
03476 <span class="comment"></span>
03477 <span class="comment">    Bridge - will return whether there appear to be ISO 9660 structures</span>
03478 <span class="comment">        on the media</span>
03479 <span class="comment"></span>
03480 <span class="comment">Return Value:</span>
03481 <span class="comment"></span>
03482 <span class="comment">    Boolean TRUE if we found NSR02, FALSE otherwise.</span>
03483 <span class="comment"></span>
03484 <span class="comment">--*/</span>
03485 
03486 {
03487     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
03488 
03489     BOOLEAN FoundBEA = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03490     BOOLEAN FoundNSR = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03491     BOOLEAN Resolved = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03492 
03493     <a class="code" href="../../d4/d2/structVSD__GENERIC.html">PVSD_GENERIC</a> VolumeStructureDescriptor;
03494     ULONGLONG <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> = <a class="code" href="../../d5/d8/udfs__rec_8h.html#a11">SectorAlignN</a>( <a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a>, <a class="code" href="../../d5/d8/udfs__rec_8h.html#a0">VRA_BOUNDARY_LOCATION</a> );
03495 
03496     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
03497 
03498     <span class="comment">//</span>
03499     <span class="comment">//  Check the input parameters</span>
03500     <span class="comment">//</span>
03501 
03502     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext);
03503 
03504     VolumeStructureDescriptor = (<a class="code" href="../../d4/d2/structVSD__GENERIC.html">PVSD_GENERIC</a>) <a class="code" href="../../d1/d8/fsrtl_8h.html#a37">FsRtlAllocatePoolWithTag</a>( <a class="code" href="../../d3/d8/udfprocs_8h.html#a66">UdfNonPagedPool</a>,
03505                                                                          <a class="code" href="../../d3/d8/udfprocs_8h.html#a165">UdfRawBufferSizeN</a>( <a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a>,
03506                                                                                             <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d2/structVSD__GENERIC.html">VSD_GENERIC</a>) ),
03507                                                                          <a class="code" href="../../d1/d7/udfs_2nodetype_8h.html#a87">TAG_NSR_VSD</a> );
03508 
03509     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
03510                  <span class="stringliteral">"UdfRecognizeVolume, DevObj %08x SectorSize %08x\n"</span>,
03511                  DeviceObject,
03512                  <a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a> ));
03513 
03514     <span class="comment">//</span>
03515     <span class="comment">//  Use try-finally to facilitate cleanup</span>
03516     <span class="comment">//</span>
03517 
03518     <span class="keywordflow">try</span> {
03519 
03520 <span class="preprocessor">#ifdef UDF_SUPPORT_NONSTANDARD_ADAPTEC</span>
03521 <span class="preprocessor"></span>
03522         <span class="comment">//</span>
03523         <span class="comment">//  Disable checking the recognition area.</span>
03524         <span class="comment">//</span>
03525         <span class="comment">//  Reasons:</span>
03526         <span class="comment">//</span>
03527         <span class="comment">//      ADAPTEC - early CDUDF did not bound NSR02 with BEA/TEA, instead</span>
03528         <span class="comment">//              sticking it in the middle of the ISO 9660 sequence.</span>
03529         <span class="comment">//</span>
03530 
03531         Resolved = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03532 <span class="preprocessor">#endif</span>
03533 <span class="preprocessor"></span>
03534         <span class="keywordflow">while</span> (!Resolved) {
03535 
03536             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a160">UdfReadSectors</a>( IrpContext,
03537                                      <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>,
03538                                      <a class="code" href="../../d3/d8/udfprocs_8h.html#a166">UdfRawReadSizeN</a>( <a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a>,
03539                                                       <span class="keyword">sizeof</span>(<a class="code" href="../../d5/d8/udfs__rec_8h.html#a12">VSD_GENERIC</a>) ),
03540                                      <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
03541                                      VolumeStructureDescriptor,
03542                                      DeviceObject );
03543 
03544             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
03545                 <span class="keywordflow">break</span>;
03546             }
03547             
03548             <span class="comment">//</span>
03549             <span class="comment">//  Now check the type of the descriptor. All ISO 13346 VSDs are</span>
03550             <span class="comment">//  of Type 0, 9660 PVDs are Type 1, 9660 SVDs are Type 2, and 9660</span>
03551             <span class="comment">//  terminating descriptors are Type 255.</span>
03552             <span class="comment">//</span>
03553 
03554             <span class="keywordflow">if</span> (VolumeStructureDescriptor-&gt;<a class="code" href="../../d4/d2/structVSD__GENERIC.html#o0">Type</a> == 0) {
03555 
03556                 <span class="comment">//</span>
03557                 <span class="comment">//  In order to properly recognize the volume, we must know all of the</span>
03558                 <span class="comment">//  Structure identifiers in ISO 13346 so that we can terminate if a</span>
03559                 <span class="comment">//  badly formatted (or, shockingly, non 13346) volume is presented to us.</span>
03560                 <span class="comment">//</span>
03561 
03562                 <span class="keywordflow">switch</span> (<a class="code" href="../../d3/d8/udfprocs_8h.html#a218">UdfFindInParseTable</a>( <a class="code" href="../../d4/d8/udfs__rec_8c.html#a1">VsdIdentParseTable</a>,
03563                                              VolumeStructureDescriptor-&gt;<a class="code" href="../../d4/d2/structVSD__GENERIC.html#o1">Ident</a>,
03564                                              <a class="code" href="../../d5/d8/udfs__rec_8h.html#a1">VSD_LENGTH_IDENT</a> )) {
03565                     <span class="keywordflow">case</span> <a class="code" href="../../d5/d8/udfs__rec_8h.html#a30a19">VsdIdentBEA01</a>:
03566 
03567                         <span class="comment">//</span>
03568                         <span class="comment">//  Only one BEA may exist and its version must be 1 (2/9.2.3)</span>
03569                         <span class="comment">//</span>
03570 
03571                         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfRecognizeVolume, got a BEA01\n"</span> ));
03572 
03573 
03574                         <span class="keywordflow">if</span> ((FoundBEA &amp;&amp;
03575                              <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
03576                                           <span class="stringliteral">"UdfRecognizeVolume, ... but it is a duplicate!\n"</span> ))) ||
03577 
03578                             (VolumeStructureDescriptor-&gt;<a class="code" href="../../d4/d2/structVSD__GENERIC.html#o2">Version</a> != 1 &amp;&amp;
03579                              <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
03580                                           <span class="stringliteral">"UdfRecognizeVolume, ... but it has a wacky version number %02x != 1!\n"</span>,
03581                                           VolumeStructureDescriptor-&gt;<a class="code" href="../../d4/d2/structVSD__GENERIC.html#o2">Version</a> )))) {
03582 
03583                             Resolved = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03584                             <span class="keywordflow">break</span>;
03585                         }
03586 
03587                         FoundBEA = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03588                         <span class="keywordflow">break</span>;
03589 
03590                     <span class="keywordflow">case</span> <a class="code" href="../../d5/d8/udfs__rec_8h.html#a30a20">VsdIdentTEA01</a>:
03591 
03592                         <span class="comment">//</span>
03593                         <span class="comment">//  If we reach the TEA it must be the case that we don't recognize</span>
03594                         <span class="comment">//</span>
03595 
03596                         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfRecognizeVolume, got a TEA01\n"</span> ));
03597                         Resolved = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03598                         <span class="keywordflow">break</span>;
03599 
03600                     <span class="keywordflow">case</span> <a class="code" href="../../d5/d8/udfs__rec_8h.html#a30a26">VsdIdentNSR02</a>:
03601 
03602                         <span class="comment">//</span>
03603                         <span class="comment">//  We recognize NSR02 version 1 embedded after a BEA (3/9.1.3).  For</span>
03604                         <span class="comment">//  simplicity we will not bother being a complete nitpick and check</span>
03605                         <span class="comment">//  for a bounding TEA, although we will be optimistic in the case where</span>
03606                         <span class="comment">//  we fail to match the version.</span>
03607                         <span class="comment">//</span>
03608 
03609                         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfRecognizeVolume, got an NSR02\n"</span> ));
03610 
03611                         <span class="keywordflow">if</span> ((FoundBEA ||
03612                              !<a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfRecognizeVolume, ... but we haven't seen a BEA01 yet!\n"</span> ))) &amp;&amp;
03613 
03614                             (VolumeStructureDescriptor-&gt;<a class="code" href="../../d4/d2/structVSD__GENERIC.html#o2">Version</a> == 1 ||
03615                              !<a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfRecognizeVolume, ... but it has a wacky version number %02x != 1\n"</span>,
03616                                            VolumeStructureDescriptor-&gt;<a class="code" href="../../d4/d2/structVSD__GENERIC.html#o2">Version</a> )))) {
03617 
03618                             
03619                             FoundNSR = Resolved = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03620                             <span class="keywordflow">break</span>;
03621                         }
03622 
03623                         <span class="keywordflow">break</span>;
03624 
03625                     <span class="keywordflow">case</span> <a class="code" href="../../d5/d8/udfs__rec_8h.html#a30a22">VsdIdentCD001</a>:
03626                     <span class="keywordflow">case</span> <a class="code" href="../../d5/d8/udfs__rec_8h.html#a30a23">VsdIdentCDW01</a>:
03627                     <span class="keywordflow">case</span> <a class="code" href="../../d5/d8/udfs__rec_8h.html#a30a25">VsdIdentNSR01</a>:
03628                     <span class="keywordflow">case</span> <a class="code" href="../../d5/d8/udfs__rec_8h.html#a30a24">VsdIdentCDW02</a>:
03629                     <span class="keywordflow">case</span> <a class="code" href="../../d5/d8/udfs__rec_8h.html#a30a27">VsdIdentBOOT2</a>:
03630 
03631                         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfRecognizeVolume, got a valid but uninteresting 13346 descriptor\n"</span> ));
03632 
03633                         <span class="comment">//</span>
03634                         <span class="comment">//  Valid but uninteresting (to us) descriptors</span>
03635                         <span class="comment">//</span>
03636 
03637                         <span class="keywordflow">break</span>;
03638 
03639                     <span class="keywordflow">default</span>:
03640 
03641                         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfRecognizeVolume, got an invalid 13346 descriptor\n"</span> ));
03642 
03643                         <span class="comment">//</span>
03644                         <span class="comment">//  Stumbling across something we don't know, it must be that this</span>
03645                         <span class="comment">//  is not a valid 13346 image</span>
03646                         <span class="comment">//</span>
03647 
03648                         Resolved = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03649                         <span class="keywordflow">break</span>;
03650 
03651                 }
03652 
03653             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!FoundBEA &amp;&amp; (VolumeStructureDescriptor-&gt;<a class="code" href="../../d4/d2/structVSD__GENERIC.html#o0">Type</a> &lt; 3 ||
03654                                      VolumeStructureDescriptor-&gt;<a class="code" href="../../d4/d2/structVSD__GENERIC.html#o0">Type</a> == 255)) {
03655 
03656                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfRecognizeVolume, got a 9660 descriptor\n"</span> ));
03657 
03658                 <span class="comment">//</span>
03659                 <span class="comment">//  Only HSG (CDROM) and 9660 (CD001) are possible, and they are only legal</span>
03660                 <span class="comment">//  before the ISO 13346 BEA/TEA extent.  By design, an ISO 13346 VSD precisely</span>
03661                 <span class="comment">//  overlaps a 9660 PVD/SVD in the appropriate fields.</span>
03662                 <span class="comment">//</span>
03663                 <span class="comment">//  Note that we aren't being strict about the structure of the 9660 descriptors</span>
03664                 <span class="comment">//  since that really isn't very interesting.  We care more about the 13346.</span>
03665                 <span class="comment">//</span>
03666                 <span class="comment">//</span>
03667 
03668                 <span class="keywordflow">switch</span> (<a class="code" href="../../d3/d8/udfprocs_8h.html#a218">UdfFindInParseTable</a>( <a class="code" href="../../d4/d8/udfs__rec_8c.html#a1">VsdIdentParseTable</a>,
03669                                              VolumeStructureDescriptor-&gt;<a class="code" href="../../d4/d2/structVSD__GENERIC.html#o1">Ident</a>,
03670                                              <a class="code" href="../../d5/d8/udfs__rec_8h.html#a1">VSD_LENGTH_IDENT</a> )) {
03671                     <span class="keywordflow">case</span> <a class="code" href="../../d5/d8/udfs__rec_8h.html#a30a21">VsdIdentCDROM</a>:
03672                     <span class="keywordflow">case</span> <a class="code" href="../../d5/d8/udfs__rec_8h.html#a30a22">VsdIdentCD001</a>:
03673 
03674                         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfRecognizeVolume, ... seems we have 9660 here\n"</span> ));
03675 
03676                         <span class="comment">//</span>
03677                         <span class="comment">//  Note to our caller that we seem to have ISO 9660 here</span>
03678                         <span class="comment">//</span>
03679 
03680                         *Bridge = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03681 
03682                         <span class="keywordflow">break</span>;
03683 
03684                     <span class="keywordflow">default</span>:
03685 
03686                         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfRecognizeVolume, ... but it looks wacky\n"</span> ));
03687 
03688                         <span class="comment">//</span>
03689                         <span class="comment">//  This probably was a false alert, but in any case there is nothing</span>
03690                         <span class="comment">//  on this volume for us.</span>
03691                         <span class="comment">//</span>
03692 
03693                         Resolved = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03694                         <span class="keywordflow">break</span>;
03695                 }
03696 
03697             } <span class="keywordflow">else</span> {
03698 
03699                 <span class="comment">//</span>
03700                 <span class="comment">//  Something else must be recorded on this volume.</span>
03701                 <span class="comment">//</span>
03702 
03703                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfRecognizeVolume, got an unrecognizeable descriptor, probably not 13346/9660\n"</span> ));
03704                 <span class="keywordflow">break</span>;
03705             }
03706 
03707             <span class="comment">//</span>
03708             <span class="comment">//  Align our next read with the sector following the current descriptor</span>
03709             <span class="comment">//</span>
03710 
03711             <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> += <a class="code" href="../../d5/d8/udfs__rec_8h.html#a11">SectorAlignN</a>( <a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a>, <span class="keyword">sizeof</span>(<a class="code" href="../../d5/d8/udfs__rec_8h.html#a12">VSD_GENERIC</a>) );
03712         }
03713 
03714     } finally {
03715 
03716         <a class="code" href="../../d8/d3/lfsdata_8h.html#a3">DebugUnwind</a>( <span class="stringliteral">"UdfRecognizeVolume"</span> );
03717 
03718         <span class="comment">//</span>
03719         <span class="comment">//  Free up our temporary buffer</span>
03720         <span class="comment">//</span>
03721 
03722         <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>( &amp;VolumeStructureDescriptor );
03723 
03724         <span class="keywordflow">if</span> (AbnormalTermination()) {
03725 
03726             <span class="comment">//</span>
03727             <span class="comment">//  Commute a status we raised for empty devices so that other filesystems</span>
03728             <span class="comment">//  can have a crack at this.</span>
03729             <span class="comment">//</span>
03730 
03731             <span class="keywordflow">if</span> (<a class="code" href="../../d3/d8/udfprocs_8h.html#a100">UdfIsRawDevice</a>(IrpContext, IrpContext-&gt;ExceptionStatus)) {
03732 
03733                 IrpContext-&gt;ExceptionStatus = STATUS_UNRECOGNIZED_VOLUME;
03734             }
03735         }
03736     }
03737 
03738     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfRecognizeVolume -&gt; %u\n"</span>, FoundNSR ));
03739 
03740     <span class="keywordflow">return</span> FoundNSR;
03741 }
03742 
03743 
03744 <span class="comment">//</span>
03745 <span class="comment">//  Local support routine</span>
03746 <span class="comment">//</span>
03747 
03748 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l03749"></a><a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a18">03749</a> <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a18">UdfScanForDismountedVcb</a> (
03750     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext
03751     )
03752 
03753 <span class="comment">/*++</span>
03754 <span class="comment"></span>
03755 <span class="comment">Routine Description:</span>
03756 <span class="comment"></span>
03757 <span class="comment">    This routine walks through the list of Vcb's looking for any which may</span>
03758 <span class="comment">    now be deleted.  They may have been left on the list because there were</span>
03759 <span class="comment">    outstanding references.</span>
03760 <span class="comment"></span>
03761 <span class="comment">Arguments:</span>
03762 <span class="comment"></span>
03763 <span class="comment">Return Value:</span>
03764 <span class="comment"></span>
03765 <span class="comment">    None</span>
03766 <span class="comment"></span>
03767 <span class="comment">--*/</span>
03768 
03769 {
03770     <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb;
03771     PLIST_ENTRY Links;
03772 
03773     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
03774 
03775     <span class="comment">//</span>
03776     <span class="comment">//  Check input.</span>
03777     <span class="comment">//</span>
03778 
03779     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
03780 
03781     <a class="code" href="../../d1/d8/udfdata_8h.html#a39">ASSERT_EXCLUSIVE_UDFDATA</a>;
03782 
03783     <span class="comment">//</span>
03784     <span class="comment">//  Walk through all of the Vcb's attached to the global data.</span>
03785     <span class="comment">//</span>
03786 
03787     Links = <a class="code" href="../../d0/d8/udfdata_8c.html#a2">UdfData</a>.<a class="code" href="../../d2/d3/struct__UDF__DATA.html#o3">VcbQueue</a>.Flink;
03788 
03789     <span class="keywordflow">while</span> (Links != &amp;<a class="code" href="../../d0/d8/udfdata_8c.html#a2">UdfData</a>.<a class="code" href="../../d2/d3/struct__UDF__DATA.html#o3">VcbQueue</a>) {
03790 
03791         Vcb = CONTAINING_RECORD( Links, <a class="code" href="../../d7/d5/struct__VCB.html">VCB</a>, VcbLinks );
03792 
03793         <span class="comment">//</span>
03794         <span class="comment">//  Move to the next link now since the current Vcb may be deleted.</span>
03795         <span class="comment">//</span>
03796 
03797         Links = Links-&gt;Flink;
03798 
03799         <span class="comment">//</span>
03800         <span class="comment">//  If dismount is already underway then check if this Vcb can</span>
03801         <span class="comment">//  go away.</span>
03802         <span class="comment">//</span>
03803 
03804         <span class="keywordflow">if</span> ((Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o8">VcbCondition</a> == <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a121">VcbDismountInProgress</a>) ||
03805             (Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o8">VcbCondition</a> == <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a120">VcbInvalid</a>) ||
03806             ((Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o8">VcbCondition</a> == <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a117">VcbNotMounted</a>) &amp;&amp; (Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o16">VcbReference</a> &lt;= Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o18">VcbResidualReference</a>))) {
03807 
03808             <a class="code" href="../../d8/d5/udfs_2verfysup_8c.html#a3">UdfCheckForDismount</a>( IrpContext, Vcb, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
03809         }
03810     }
03811 
03812     <span class="keywordflow">return</span>;
03813 }
03814 
03815 
03816 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l03817"></a><a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a4">03817</a> <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a4">UdfDetermineVolumeBounding</a> (
03818     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
03819     IN <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb,
03820     IN PULONG S,
03821     IN PULONG N
03822     )
03823 
03824 <span class="comment">/*++</span>
03825 <span class="comment"></span>
03826 <span class="comment">Routine Description:</span>
03827 <span class="comment"></span>
03828 <span class="comment">    This routine will figure out where the base offset to discover volume descriptors</span>
03829 <span class="comment">    lies and where the end of the disc is.  In the case where this is a non-CD media,</span>
03830 <span class="comment">    this will tend to not to set the end bound since there is no uniform way to figure</span>
03831 <span class="comment">    that piece of information out.</span>
03832 <span class="comment">    </span>
03833 <span class="comment">    The bounding information is used to start the hunt for CD-UDF (UDF 1.5) volumes.</span>
03834 <span class="comment">    Anyone who puts CD-UDF on non-CD media deserves what they get.</span>
03835 <span class="comment"></span>
03836 <span class="comment">Arguments:</span>
03837 <span class="comment"></span>
03838 <span class="comment">    Vcb - the volume we are operating on</span>
03839 <span class="comment">    </span>
03840 <span class="comment">    S - an address to store the start of the volume for the purposes of finding descriptors</span>
03841 <span class="comment">    </span>
03842 <span class="comment">    N - an address to store the end of the volume for the purposes of finding descriptors</span>
03843 <span class="comment"></span>
03844 <span class="comment">Return Value:</span>
03845 <span class="comment"></span>
03846 <span class="comment">    None.</span>
03847 <span class="comment">    </span>
03848 <span class="comment">    Benign inability find the S/N information will result in 0/0 being returned.</span>
03849 <span class="comment"></span>
03850 <span class="comment">--*/</span>
03851 
03852 {
03853     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
03854     PCDROM_TOC CdromToc;
03855     PTRACK_DATA TrackData;
03856 
03857     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
03858 
03859     <span class="comment">//</span>
03860     <span class="comment">//  Check input.</span>
03861     <span class="comment">//</span>
03862 
03863     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
03864     <a class="code" href="../../d1/d8/udfdata_8h.html#a12">ASSERT_VCB</a>( Vcb );
03865 
03866     <span class="comment">//</span>
03867     <span class="comment">//  Allocate a buffer for the last session information.</span>
03868     <span class="comment">//</span>
03869 
03870     CdromToc = <a class="code" href="../../d1/d8/fsrtl_8h.html#a37">FsRtlAllocatePoolWithTag</a>( <a class="code" href="../../d3/d8/udfprocs_8h.html#a65">UdfPagedPool</a>,
03871                                          <span class="keyword">sizeof</span>( CDROM_TOC ),
03872                                          <a class="code" href="../../d1/d7/udfs_2nodetype_8h.html#a68">TAG_CDROM_TOC</a> );
03873 
03874     RtlZeroMemory( CdromToc, <span class="keyword">sizeof</span>( CDROM_TOC ));
03875 
03876     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
03877                <span class="stringliteral">"UdfDetermineVolumeBounding, Vcb %08x S %08x N %08x\n"</span>,
03878                Vcb,
03879                S,
03880                N ));
03881         
03882     <span class="comment">//</span>
03883     <span class="comment">//  Whack the inputs to the benign state.</span>
03884     <span class="comment">//</span>
03885     
03886     *S = *N = 0;
03887 
03888     <span class="comment">//</span>
03889     <span class="comment">//  Try to retrieve the CDROM last session information.</span>
03890     <span class="comment">//</span>
03891 
03892     <span class="keywordflow">try</span> {
03893 
03894         <span class="comment">//</span>
03895         <span class="comment">//  Pull up the TOC.  The information for track AA (start of leadout)</span>
03896         <span class="comment">//  will get us the end of disc within some tolerance dependent on how</span>
03897         <span class="comment">//  much the device manufacturer paid attention to specifications.</span>
03898         <span class="comment">//  (-152, -150, -2, and 0 are possible offsets to the real end).</span>
03899         <span class="comment">//</span>
03900         
03901         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a159">UdfPerformDevIoCtrl</a>( IrpContext,
03902                                       IOCTL_CDROM_READ_TOC,
03903                                       Vcb-&gt;TargetDeviceObject,
03904                                       CdromToc,
03905                                       <span class="keyword">sizeof</span>( CDROM_TOC ),
03906                                       <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
03907                                       <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
03908                                       <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
03909 
03910         <span class="comment">//</span>
03911         <span class="comment">//  Raise an exception if there was an allocation failure.</span>
03912         <span class="comment">//</span>
03913 
03914         <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_INSUFFICIENT_RESOURCES) {
03915 
03916             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfDetermineVolumeBounding, READ_TOC failed INSUFFICIENT_RESOURCES\n"</span> ));
03917             <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
03918         }
03919 
03920         <span class="comment">//</span>
03921         <span class="comment">//  For other errors, just fail.  Perhaps this will turn out to be benign, in any case</span>
03922         <span class="comment">//  the mount will rapidly and correctly fail if it really was dependant on this work.</span>
03923         <span class="comment">//</span>
03924         
03925         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
03926 
03927             <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( NOTHING );
03928         }
03929 
03930         <span class="comment">//</span>
03931         <span class="comment">//  Sanity chck that the TOC is well-bounded.</span>
03932         <span class="comment">//</span>
03933         
03934         <span class="keywordflow">if</span> (CdromToc-&gt;LastTrack - CdromToc-&gt;FirstTrack &gt;= MAXIMUM_NUMBER_TRACKS) {
03935 
03936             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfDetermineVolumeBounding, TOC malf (too many tracks)\n"</span> ));
03937             <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( NOTHING );
03938         }
03939 
03940         TrackData = &amp;CdromToc-&gt;TrackData[(CdromToc-&gt;LastTrack - CdromToc-&gt;FirstTrack + 1)];
03941 
03942 <span class="preprocessor">#if 0</span>
03943 <span class="preprocessor"></span>        <span class="comment">//</span>
03944         <span class="comment">//  Better be AA ...</span>
03945         <span class="comment">//</span>
03946         
03947         <span class="keywordflow">if</span> (TrackData-&gt;TrackNumber != 0xaa) {
03948 
03949             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfDetermineVolumeBounding, TOC malf (aa not last)\n"</span> ));
03950             <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( NOTHING );
03951         }
03952 <span class="preprocessor">#endif</span>
03953 <span class="preprocessor"></span>
03954         <span class="comment">//</span>
03955         <span class="comment">//  Now, find the AA info and convert MSF to a logical block address.  75 frames/sectors</span>
03956         <span class="comment">//  per second, 60 seconds per minute.  The MSF address is stored LSB (the F byte) high</span>
03957         <span class="comment">//  in the word.</span>
03958         <span class="comment">//</span>
03959 
03960         <span class="comment">//</span>
03961         <span class="comment">//  NOTE: MSF is only capable of representing 256*(256+256*60)*75 = 0x11ce20 sectors.</span>
03962         <span class="comment">//  This is 2.3gb, much less than the size of DVD media, which will respond to CDROM_TOC.</span>
03963         <span class="comment">//  Caveat user.</span>
03964         <span class="comment">//</span>
03965 
03966         *N = (TrackData-&gt;Address[3] + (TrackData-&gt;Address[2] + TrackData-&gt;Address[1] * 60) * 75) - 1;
03967 
03968         <span class="comment">//</span>
03969         <span class="comment">//  We must bias back by 0/2/0 MSF since that is the defined location of sector 0.  This</span>
03970         <span class="comment">//  works out to 150 sectors.</span>
03971         <span class="comment">//</span>
03972         
03973         <span class="keywordflow">if</span> (*N &lt;= 150) {
03974 
03975             *N = 0;
03976             <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( NOTHING );
03977         }
03978 
03979         *N -= 150;
03980 
03981         <span class="comment">//</span>
03982         <span class="comment">//  Query the last session information from the driver.</span>
03983         <span class="comment">//</span>
03984 
03985         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d3/d8/udfprocs_8h.html#a159">UdfPerformDevIoCtrl</a>( IrpContext,
03986                                       IOCTL_CDROM_GET_LAST_SESSION,
03987                                       Vcb-&gt;TargetDeviceObject,
03988                                       CdromToc,
03989                                       <span class="keyword">sizeof</span>( CDROM_TOC ),
03990                                       <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
03991                                       <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
03992                                       <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
03993 
03994         <span class="comment">//</span>
03995         <span class="comment">//  Raise an exception if there was an allocation failure.</span>
03996         <span class="comment">//</span>
03997 
03998         <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_INSUFFICIENT_RESOURCES) {
03999 
04000             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfDetermineVolumeBounding, GET_LAST_SESSION failed INSUFFICIENT_RESOURCES\n"</span> ));
04001             <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
04002         }
04003 
04004         <span class="comment">//</span>
04005         <span class="comment">//  Now, if we got anything interesting out of this try, return it.  If this                                                </span>
04006         <span class="comment">//  failed for any other reason, we don't really care - it just means that</span>
04007         <span class="comment">//  if this was CDUDF media, we're gonna fail to figure it out pretty quickly.</span>
04008         <span class="comment">//</span>
04009         <span class="comment">//  Life is tough.</span>
04010         <span class="comment">//</span>
04011 
04012         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ) &amp;&amp;
04013             CdromToc-&gt;FirstTrack != CdromToc-&gt;LastTrack) {
04014 
04015             <span class="comment">//</span>
04016             <span class="comment">//  The 0 entry in TrackData tells us about the start of the session as a</span>
04017             <span class="comment">//  logical block address.</span>
04018             <span class="comment">//</span>
04019 
04020             <a class="code" href="../../d3/d8/udfprocs_8h.html#a60">SwapCopyUchar4</a>( S, &amp;CdromToc-&gt;TrackData[0].Address );
04021 
04022             <span class="comment">//</span>
04023             <span class="comment">//  Save grief if the session info is screwed up.</span>
04024             <span class="comment">//</span>
04025             
04026             <span class="keywordflow">if</span> (*N &lt;= *S) {
04027 
04028                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfDetermineVolumeBounding, N before S, whacking both back!\n"</span> ));
04029                 *S = *N = 0;
04030             }
04031         }
04032 
04033         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfDetermineVolumeBounding, S %08x N %08x\n"</span>, *S, *N ));
04034 
04035     } finally {
04036 
04037         <a class="code" href="../../d8/d3/lfsdata_8h.html#a3">DebugUnwind</a>( <span class="stringliteral">"UdfDetermineVolumeBounding"</span> );
04038         
04039         <span class="keywordflow">if</span> (CdromToc != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04040             
04041             <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>( &amp;CdromToc );
04042         }
04043     }
04044 
04045     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfDetermineVolumeBounding -&gt; VOID\n"</span> ));
04046 
04047     <span class="keywordflow">return</span>;
04048 }
04049 
04050 
04051 <span class="comment">//</span>
04052 <span class="comment">//  Local support routine</span>
04053 <span class="comment">//</span>
04054 
04055 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l04056"></a><a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a20">04056</a> <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a20">UdfUpdateVolumeLabel</a> (
04057     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
04058     IN PWCHAR VolumeLabel,
04059     IN OUT PUSHORT VolumeLabelLength,
04060     IN PUCHAR Dstring,
04061     IN UCHAR FieldLength
04062     )
04063 
04064 <span class="comment">/*++</span>
04065 <span class="comment"></span>
04066 <span class="comment">Routine Description:</span>
04067 <span class="comment"></span>
04068 <span class="comment">    This routine will retrieve an NT volume label from a logical volume descriptor.</span>
04069 <span class="comment"></span>
04070 <span class="comment">Arguments:</span>
04071 <span class="comment"></span>
04072 <span class="comment">    VolumeLabel - a volume label to fill in.</span>
04073 <span class="comment"></span>
04074 <span class="comment">    VolumeLabelLength - returns the length of the returned volume label.</span>
04075 <span class="comment"></span>
04076 <span class="comment">    Dstring - the dstring field containing the volume id.</span>
04077 <span class="comment"></span>
04078 <span class="comment">    FieldLength - the length of the dstring field.</span>
04079 <span class="comment"></span>
04080 <span class="comment">Return Value:</span>
04081 <span class="comment"></span>
04082 <span class="comment">    None.</span>
04083 <span class="comment"></span>
04084 <span class="comment">--*/</span>
04085 
04086 {
04087     BOOLEAN Result;
04088 
04089     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
04090 
04091     <span class="comment">//</span>
04092     <span class="comment">//  Check inputs.</span>
04093     <span class="comment">//</span>
04094 
04095     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
04096 
04097     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
04098                  <span class="stringliteral">"UdfUpdateVolumeLabel, Label %08x, Dstring %08x FieldLength %02x\n"</span>,
04099                  VolumeLabel,
04100                  Dstring,
04101                  FieldLength ));
04102 
04103     <span class="comment">//</span>
04104     <span class="comment">//  Check that the dstring is usable as a volume identification.</span>
04105     <span class="comment">//</span>
04106 
04107     Result = <a class="code" href="../../d3/d8/udfprocs_8h.html#a182">UdfCheckLegalCS0Dstring</a>( IrpContext,
04108                                       Dstring,
04109                                       0,
04110                                       FieldLength,
04111                                       <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
04112 
04113 
04114     <span class="comment">//</span>
04115     <span class="comment">//  Update the label directly if the dstring is good.</span>
04116     <span class="comment">//</span>
04117 
04118     <span class="keywordflow">if</span> (Result) {
04119 
04120         UNICODE_STRING TemporaryUnicodeString;
04121 
04122         TemporaryUnicodeString.Buffer = VolumeLabel;
04123         TemporaryUnicodeString.MaximumLength = <a class="code" href="../../d0/d5/io_8h.html#a121">MAXIMUM_VOLUME_LABEL_LENGTH</a>;
04124         TemporaryUnicodeString.Length = 0;
04125 
04126         <a class="code" href="../../d3/d8/udfprocs_8h.html#a181">UdfConvertCS0DstringToUnicode</a>( IrpContext,
04127                                        Dstring,
04128                                        0,
04129                                        FieldLength,
04130                                        &amp;TemporaryUnicodeString );
04131 
04132         <span class="comment">//</span>
04133         <span class="comment">//  Now retrieve the name for return to the caller.</span>
04134         <span class="comment">//</span>
04135 
04136         RtlCopyMemory( VolumeLabel, TemporaryUnicodeString.Buffer, TemporaryUnicodeString.Length );
04137         *VolumeLabelLength = TemporaryUnicodeString.Length;
04138 
04139         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
04140                      <span class="stringliteral">"UdfUpdateVolumeLabel, Labeled as \"%wZ\"\n"</span>,
04141                      &amp;TemporaryUnicodeString ));
04142 
04143     <span class="comment">//</span>
04144     <span class="comment">//  Treat as label.</span>
04145     <span class="comment">//</span>
04146 
04147     } <span class="keywordflow">else</span> {
04148 
04149         *VolumeLabelLength = 0;
04150 
04151         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
04152                      <span class="stringliteral">"UdfUpdateVolumeLabel, invalid label.\n"</span> ));
04153     }
04154 
04155     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
04156                  <span class="stringliteral">"UdfUpdateVolumeLabel -&gt; VOID\n"</span> ));
04157 }
04158 
04159 
04160 <span class="comment">//</span>
04161 <span class="comment">//  Local support routine</span>
04162 <span class="comment">//</span>
04163 
04164 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l04165"></a><a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a21">04165</a> <a class="code" href="../../d9/d7/udfs_2fsctrl_8c.html#a21">UdfUpdateVolumeSerialNumber</a> (
04166     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
04167     IN OUT PULONG VolumeSerialNumber,
04168     IN <a class="code" href="../../d2/d2/structNSR__FSD.html">PNSR_FSD</a> Fsd
04169     )
04170 
04171 <span class="comment">/*++</span>
04172 <span class="comment"></span>
04173 <span class="comment">Routine Description:</span>
04174 <span class="comment"></span>
04175 <span class="comment">    This routine will compute the volume serial number for a set of descriptors.</span>
04176 <span class="comment"></span>
04177 <span class="comment">Arguments:</span>
04178 <span class="comment"></span>
04179 <span class="comment">    VolumeSerialNumber - returns the volume serial number corresponding to these descriptors.</span>
04180 <span class="comment"></span>
04181 <span class="comment">    Fsd - the fileset descriptor to examine.</span>
04182 <span class="comment"></span>
04183 <span class="comment">Return Value:</span>
04184 <span class="comment"></span>
04185 <span class="comment">    None.</span>
04186 <span class="comment"></span>
04187 <span class="comment">--*/</span>
04188 
04189 {
04190     ULONG VsnLe;
04191     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
04192 
04193     <span class="comment">//</span>
04194     <span class="comment">//  Check input.</span>
04195     <span class="comment">//</span>
04196 
04197     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
04198 
04199     <span class="comment">//</span>
04200     <span class="comment">//  The serial number is just off of the FSD. This matches Win9x.</span>
04201     <span class="comment">//</span>
04202 
04203     VsnLe = <a class="code" href="../../d3/d8/udfprocs_8h.html#a132">UdfSerial32</a>( (PCHAR) Fsd, <span class="keyword">sizeof</span>( <a class="code" href="../../d2/d2/structNSR__FSD.html">NSR_FSD</a> ));
04204     <a class="code" href="../../d3/d8/udfprocs_8h.html#a60">SwapCopyUchar4</a>( VolumeSerialNumber, &amp;VsnLe );
04205 }
04206 
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:04 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
