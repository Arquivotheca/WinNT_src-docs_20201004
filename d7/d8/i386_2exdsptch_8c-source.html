<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: exdsptch.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>exdsptch.c</h1><a href="../../d6/d9/i386_2exdsptch_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1989  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    exdsptch.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module implements the dispatching of exception and the unwinding of</span>
00012 <span class="comment">    procedure call frames.</span>
00013 <span class="comment"></span>
00014 <span class="comment">Author:</span>
00015 <span class="comment"></span>
00016 <span class="comment">    David N. Cutler (davec) 13-Aug-1989</span>
00017 <span class="comment"></span>
00018 <span class="comment">Environment:</span>
00019 <span class="comment"></span>
00020 <span class="comment">    Any mode.</span>
00021 <span class="comment"></span>
00022 <span class="comment">Revision History:</span>
00023 <span class="comment"></span>
00024 <span class="comment">    10 april 90 bryanwi</span>
00025 <span class="comment"></span>
00026 <span class="comment">            Port to the 386.</span>
00027 <span class="comment"></span>
00028 <span class="comment">--*/</span>
00029 
00030 <span class="preprocessor">#include "<a class="code" href="../../d5/d9/ntrtlp_8h.html">ntrtlp.h</a>"</span>
00031 
00032 
00033 <span class="comment">//</span>
00034 <span class="comment">// Dispatcher context structure definition.</span>
00035 <span class="comment">//</span>
00036 
<a name="l00037"></a><a class="code" href="../../d0/d6/struct__DISPATCHER__CONTEXT.html">00037</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d0/d6/struct__DISPATCHER__CONTEXT.html">_DISPATCHER_CONTEXT</a> {
<a name="l00038"></a><a class="code" href="../../d0/d6/struct__DISPATCHER__CONTEXT.html#o0">00038</a>     PEXCEPTION_REGISTRATION_RECORD <a class="code" href="../../d0/d6/struct__DISPATCHER__CONTEXT.html#o0">RegistrationPointer</a>;
00039     } <a class="code" href="../../d0/d6/struct__DISPATCHER__CONTEXT.html">DISPATCHER_CONTEXT</a>;
00040 
00041 <span class="comment">//</span>
00042 <span class="comment">// Execute handler for exception function prototype.</span>
00043 <span class="comment">//</span>
00044 
00045 EXCEPTION_DISPOSITION
00046 <a class="code" href="../../d6/d9/ntrtlppc_8h.html#a0">RtlpExecuteHandlerForException</a> (
00047     IN PEXCEPTION_RECORD ExceptionRecord,
00048     IN PVOID EstablisherFrame,
00049     IN OUT PCONTEXT ContextRecord,
00050     IN OUT PVOID DispatcherContext,
00051     IN PEXCEPTION_ROUTINE ExceptionRoutine
00052     );
00053 
00054 <span class="comment">//</span>
00055 <span class="comment">// Execute handler for unwind function prototype.</span>
00056 <span class="comment">//</span>
00057 
00058 EXCEPTION_DISPOSITION
00059 <a class="code" href="../../d6/d9/ntrtlppc_8h.html#a1">RtlpExecuteHandlerForUnwind</a> (
00060     IN PEXCEPTION_RECORD ExceptionRecord,
00061     IN PVOID EstablisherFrame,
00062     IN OUT PCONTEXT ContextRecord,
00063     IN OUT PVOID DispatcherContext,
00064     IN PEXCEPTION_ROUTINE ExceptionRoutine
00065     );
00066 
00067 
00068 
00069 BOOLEAN
<a name="l00070"></a><a class="code" href="../../d6/d9/i386_2exdsptch_8c.html#a3">00070</a> <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a7">RtlDispatchException</a> (
00071     IN PEXCEPTION_RECORD ExceptionRecord,
00072     IN PCONTEXT ContextRecord
00073     )
00074 
00075 <span class="comment">/*++</span>
00076 <span class="comment"></span>
00077 <span class="comment">Routine Description:</span>
00078 <span class="comment"></span>
00079 <span class="comment">    This function attempts to dispatch an exception to a call frame based</span>
00080 <span class="comment">    handler by searching backwards through the stack based call frames. The</span>
00081 <span class="comment">    search begins with the frame specified in the context record and continues</span>
00082 <span class="comment">    backward until either a handler is found that handles the exception, the</span>
00083 <span class="comment">    stack is found to be invalid (i.e., out of limits or unaligned), or the end</span>
00084 <span class="comment">    of the call hierarchy is reached.</span>
00085 <span class="comment"></span>
00086 <span class="comment">Arguments:</span>
00087 <span class="comment"></span>
00088 <span class="comment">    ExceptionRecord - Supplies a pointer to an exception record.</span>
00089 <span class="comment"></span>
00090 <span class="comment">    ContextRecord - Supplies a pointer to a context record.</span>
00091 <span class="comment"></span>
00092 <span class="comment">Return Value:</span>
00093 <span class="comment"></span>
00094 <span class="comment">    If the exception is handled by one of the frame based handlers, then</span>
00095 <span class="comment">    a value of TRUE is returned. Otherwise a value of FALSE is returned.</span>
00096 <span class="comment"></span>
00097 <span class="comment">--*/</span>
00098 
00099 {
00100 
00101     <a class="code" href="../../d0/d6/struct__DISPATCHER__CONTEXT.html">DISPATCHER_CONTEXT</a> DispatcherContext;
00102     EXCEPTION_DISPOSITION Disposition;
00103     PEXCEPTION_REGISTRATION_RECORD RegistrationPointer;
00104     PEXCEPTION_REGISTRATION_RECORD NestedRegistration;
00105     ULONG HighAddress;
00106     ULONG HighLimit;
00107     ULONG LowLimit;
00108     EXCEPTION_RECORD ExceptionRecord1;
00109 
00110 <span class="preprocessor">#if !defined(WX86_i386)</span>
00111 <span class="preprocessor"></span>
00112     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00113 
00114 <span class="preprocessor">#endif</span>
00115 <span class="preprocessor"></span>
00116     <span class="comment">//</span>
00117     <span class="comment">// Get current stack limits.</span>
00118     <span class="comment">//</span>
00119 
00120     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a30">RtlpGetStackLimits</a>(&amp;LowLimit, &amp;HighLimit);
00121 
00122     <span class="comment">//</span>
00123     <span class="comment">// Start with the frame specified by the context record and search</span>
00124     <span class="comment">// backwards through the call frame hierarchy attempting to find an</span>
00125     <span class="comment">// exception handler that will handler the exception.</span>
00126     <span class="comment">//</span>
00127 
00128     RegistrationPointer = <a class="code" href="../../d3/d9/ntrtli64_8h.html#a3">RtlpGetRegistrationHead</a>();
00129     NestedRegistration = 0;
00130 
00131     <span class="keywordflow">while</span> (RegistrationPointer != EXCEPTION_CHAIN_END) {
00132 
00133         <span class="comment">//</span>
00134         <span class="comment">// If the call frame is not within the specified stack limits or the</span>
00135         <span class="comment">// call frame is unaligned, then set the stack invalid flag in the</span>
00136         <span class="comment">// exception record and return FALSE. Else check to determine if the</span>
00137         <span class="comment">// frame has an exception handler.</span>
00138         <span class="comment">//</span>
00139 
00140         HighAddress = (ULONG)RegistrationPointer +
00141             <span class="keyword">sizeof</span>(EXCEPTION_REGISTRATION_RECORD);
00142 
00143         <span class="keywordflow">if</span> ( ((ULONG)RegistrationPointer &lt; LowLimit) ||
00144              (HighAddress &gt; HighLimit) ||
00145              (((ULONG)RegistrationPointer &amp; 0x3) != 0) ) {
00146 
00147 <span class="preprocessor">#if defined(NTOS_KERNEL_RUNTIME)</span>
00148 <span class="preprocessor"></span>
00149             <span class="comment">//</span>
00150             <span class="comment">// Allow for the possibility that the problem occured on the</span>
00151             <span class="comment">// DPC stack.</span>
00152             <span class="comment">//</span>
00153 
00154             ULONG TestAddress = (ULONG)RegistrationPointer;
00155 
00156             <span class="keywordflow">if</span> (((TestAddress &amp; 0x3) == 0) &amp;&amp;
00157                 KeGetCurrentIrql() &gt;= <a class="code" href="../../d6/d7/halmips_8h.html#a53">DISPATCH_LEVEL</a>) {
00158 
00159                 PKPRCB Prcb = <a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a2">KeGetCurrentPrcb</a>();
00160                 ULONG DpcStack = (ULONG)Prcb-&gt;DpcStack;
00161 
00162                 <span class="keywordflow">if</span> ((Prcb-&gt;DpcRoutineActive) &amp;&amp;
00163                     (HighAddress &lt;= DpcStack) &amp;&amp;
00164                     (TestAddress &gt;= DpcStack - KERNEL_STACK_SIZE)) {
00165 
00166                     <span class="comment">//</span>
00167                     <span class="comment">// This error occured on the DPC stack, switch</span>
00168                     <span class="comment">// stack limits to the DPC stack and restart </span>
00169                     <span class="comment">// the loop.</span>
00170                     <span class="comment">// </span>
00171 
00172                     HighLimit = DpcStack;
00173                     LowLimit = DpcStack - KERNEL_STACK_SIZE;
00174                     <span class="keywordflow">continue</span>;
00175                 }
00176             }
00177 
00178 <span class="preprocessor">#endif</span>
00179 <span class="preprocessor"></span>
00180             ExceptionRecord-&gt;ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a28">EXCEPTION_STACK_INVALID</a>;
00181             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00182         } 
00183 
00184 <span class="preprocessor">#if !defined(WX86_i386)</span>
00185 <span class="preprocessor"></span>
00186         <span class="comment">//</span>
00187         <span class="comment">// The handler must be executed by calling another routine</span>
00188         <span class="comment">// that is written in assembler. This is required because</span>
00189         <span class="comment">// up level addressing of the handler information is required</span>
00190         <span class="comment">// when a nested exception is encountered.</span>
00191         <span class="comment">//</span>
00192 
00193         <span class="keywordflow">if</span> (<a class="code" href="../../d9/d2/ldrp_8h.html#a33">NtGlobalFlag</a> &amp; FLG_ENABLE_EXCEPTION_LOGGING) {
00194             <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = <a class="code" href="../../d5/d9/ntrtlp_8h.html#a48">RtlpLogExceptionHandler</a>(
00195                             ExceptionRecord,
00196                             ContextRecord,
00197                             0,
00198                             (PULONG)RegistrationPointer,
00199                             4 * <span class="keyword">sizeof</span>(ULONG));
00200                     <span class="comment">// can't use sizeof(EXCEPTION_REGISTRATION_RECORD</span>
00201                     <span class="comment">// because we need the 2 dwords above it.</span>
00202         }
00203 <span class="preprocessor">#endif</span>
00204 <span class="preprocessor"></span>
00205         Disposition = <a class="code" href="../../d6/d9/ntrtlppc_8h.html#a0">RtlpExecuteHandlerForException</a>(
00206             ExceptionRecord,
00207             (PVOID)RegistrationPointer,
00208             ContextRecord,
00209             (PVOID)&amp;DispatcherContext,
00210             (PEXCEPTION_ROUTINE)RegistrationPointer-&gt;Handler);
00211 
00212 <span class="preprocessor">#if !defined(WX86_i386)</span>
00213 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (<a class="code" href="../../d9/d2/ldrp_8h.html#a33">NtGlobalFlag</a> &amp; FLG_ENABLE_EXCEPTION_LOGGING) {
00214             <a class="code" href="../../d5/d9/ntrtlp_8h.html#a49">RtlpLogLastExceptionDisposition</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>, Disposition);
00215         }
00216 <span class="preprocessor">#endif</span>
00217 <span class="preprocessor"></span>
00218 
00219         <span class="comment">//</span>
00220         <span class="comment">// If the current scan is within a nested context and the frame</span>
00221         <span class="comment">// just examined is the end of the context region, then clear</span>
00222         <span class="comment">// the nested context frame and the nested exception in the</span>
00223         <span class="comment">// exception flags.</span>
00224         <span class="comment">//</span>
00225 
00226         <span class="keywordflow">if</span> (NestedRegistration == RegistrationPointer) {
00227             ExceptionRecord-&gt;ExceptionFlags &amp;= (~<a class="code" href="../../d6/d7/halmips_8h.html#a29">EXCEPTION_NESTED_CALL</a>);
00228             NestedRegistration = 0;
00229         }
00230 
00231         <span class="comment">//</span>
00232         <span class="comment">// Case on the handler disposition.</span>
00233         <span class="comment">//</span>
00234 
00235         <span class="keywordflow">switch</span> (Disposition) {
00236 
00237             <span class="comment">//</span>
00238             <span class="comment">// The disposition is to continue execution. If the</span>
00239             <span class="comment">// exception is not continuable, then raise the exception</span>
00240             <span class="comment">// STATUS_NONCONTINUABLE_EXCEPTION. Otherwise return</span>
00241             <span class="comment">// TRUE.</span>
00242             <span class="comment">//</span>
00243 
00244         <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a36">ExceptionContinueExecution</a> :
00245             <span class="keywordflow">if</span> ((ExceptionRecord-&gt;ExceptionFlags &amp;
00246                <a class="code" href="../../d6/d7/halmips_8h.html#a25">EXCEPTION_NONCONTINUABLE</a>) != 0) {
00247                 ExceptionRecord1.ExceptionCode =
00248                                         STATUS_NONCONTINUABLE_EXCEPTION;
00249                 ExceptionRecord1.ExceptionFlags = <a class="code" href="../../d6/d7/halmips_8h.html#a25">EXCEPTION_NONCONTINUABLE</a>;
00250                 ExceptionRecord1.ExceptionRecord = ExceptionRecord;
00251                 ExceptionRecord1.NumberParameters = 0;
00252                 <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a9">RtlRaiseException</a>(&amp;ExceptionRecord1);
00253             } <span class="keywordflow">else</span> {
00254                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00255             }
00256 
00257             <span class="comment">//</span>
00258             <span class="comment">// The disposition is to continue the search. Get next</span>
00259             <span class="comment">// frame address and continue the search.</span>
00260             <span class="comment">//</span>
00261 
00262         <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a37">ExceptionContinueSearch</a> :
00263             <span class="keywordflow">break</span>;
00264 
00265             <span class="comment">//</span>
00266             <span class="comment">// The disposition is nested exception. Set the nested</span>
00267             <span class="comment">// context frame to the establisher frame address and set</span>
00268             <span class="comment">// nested exception in the exception flags.</span>
00269             <span class="comment">//</span>
00270 
00271         <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a38">ExceptionNestedException</a> :
00272             ExceptionRecord-&gt;ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a29">EXCEPTION_NESTED_CALL</a>;
00273             <span class="keywordflow">if</span> (DispatcherContext.RegistrationPointer &gt; NestedRegistration) {
00274                 NestedRegistration = DispatcherContext.RegistrationPointer;
00275             }
00276             <span class="keywordflow">break</span>;
00277 
00278             <span class="comment">//</span>
00279             <span class="comment">// All other disposition values are invalid. Raise</span>
00280             <span class="comment">// invalid disposition exception.</span>
00281             <span class="comment">//</span>
00282 
00283         <span class="keywordflow">default</span> :
00284             ExceptionRecord1.ExceptionCode = STATUS_INVALID_DISPOSITION;
00285             ExceptionRecord1.ExceptionFlags = <a class="code" href="../../d6/d7/halmips_8h.html#a25">EXCEPTION_NONCONTINUABLE</a>;
00286             ExceptionRecord1.ExceptionRecord = ExceptionRecord;
00287             ExceptionRecord1.NumberParameters = 0;
00288             <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a9">RtlRaiseException</a>(&amp;ExceptionRecord1);
00289             <span class="keywordflow">break</span>;
00290         }
00291 
00292         <span class="comment">//</span>
00293         <span class="comment">// If chain goes in wrong direction or loops, report an</span>
00294         <span class="comment">// invalid exception stack, otherwise go on to the next one.</span>
00295         <span class="comment">//</span>
00296 
00297         RegistrationPointer = RegistrationPointer-&gt;Next;
00298     }
00299     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00300 }
00301 
00302 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00303"></a><a class="code" href="../../d6/d9/i386_2exdsptch_8c.html#a4">00303</a> <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a11">RtlUnwind</a> (
00304     IN PVOID TargetFrame OPTIONAL,
00305     IN PVOID TargetIp OPTIONAL,
00306     IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
00307     IN PVOID ReturnValue
00308     )
00309 
00310 <span class="comment">/*++</span>
00311 <span class="comment"></span>
00312 <span class="comment">Routine Description:</span>
00313 <span class="comment"></span>
00314 <span class="comment">    This function initiates an unwind of procedure call frames. The machine</span>
00315 <span class="comment">    state at the time of the call to unwind is captured in a context record</span>
00316 <span class="comment">    and the unwinding flag is set in the exception flags of the exception</span>
00317 <span class="comment">    record. If the TargetFrame parameter is not specified, then the exit unwind</span>
00318 <span class="comment">    flag is also set in the exception flags of the exception record. A backward</span>
00319 <span class="comment">    walk through the procedure call frames is then performed to find the target</span>
00320 <span class="comment">    of the unwind operation.</span>
00321 <span class="comment"></span>
00322 <span class="comment">    N.B.    The captured context passed to unwinding handlers will not be</span>
00323 <span class="comment">            a  completely accurate context set for the 386.  This is because</span>
00324 <span class="comment">            there isn't a standard stack frame in which registers are stored.</span>
00325 <span class="comment"></span>
00326 <span class="comment">            Only the integer registers are affected.  The segement and</span>
00327 <span class="comment">            control registers (ebp, esp) will have correct values for</span>
00328 <span class="comment">            the flat 32 bit environment.</span>
00329 <span class="comment"></span>
00330 <span class="comment">    N.B.    If you change the number of arguments, make sure you change the</span>
00331 <span class="comment">            adjustment of ESP after the call to RtlpCaptureContext (for</span>
00332 <span class="comment">            STDCALL calling convention)</span>
00333 <span class="comment"></span>
00334 <span class="comment">Arguments:</span>
00335 <span class="comment"></span>
00336 <span class="comment">    TargetFrame - Supplies an optional pointer to the call frame that is the</span>
00337 <span class="comment">        target of the unwind. If this parameter is not specified, then an exit</span>
00338 <span class="comment">        unwind is performed.</span>
00339 <span class="comment"></span>
00340 <span class="comment">    TargetIp - Supplies an optional instruction address that specifies the</span>
00341 <span class="comment">        continuation address of the unwind. This address is ignored if the</span>
00342 <span class="comment">        target frame parameter is not specified.</span>
00343 <span class="comment"></span>
00344 <span class="comment">    ExceptionRecord - Supplies an optional pointer to an exception record.</span>
00345 <span class="comment"></span>
00346 <span class="comment">    ReturnValue - Supplies a value that is to be placed in the integer</span>
00347 <span class="comment">        function return register just before continuing execution.</span>
00348 <span class="comment"></span>
00349 <span class="comment">Return Value:</span>
00350 <span class="comment"></span>
00351 <span class="comment">    None.</span>
00352 <span class="comment"></span>
00353 <span class="comment">--*/</span>
00354 
00355 {
00356     PCONTEXT ContextRecord;
00357     CONTEXT ContextRecord1;
00358     <a class="code" href="../../d0/d6/struct__DISPATCHER__CONTEXT.html">DISPATCHER_CONTEXT</a> DispatcherContext;
00359     EXCEPTION_DISPOSITION Disposition;
00360     PEXCEPTION_REGISTRATION_RECORD RegistrationPointer;
00361     PEXCEPTION_REGISTRATION_RECORD PriorPointer;
00362     ULONG HighAddress;
00363     ULONG HighLimit;
00364     ULONG LowLimit;
00365     EXCEPTION_RECORD ExceptionRecord1;
00366     EXCEPTION_RECORD ExceptionRecord2;
00367 
00368     <span class="comment">//</span>
00369     <span class="comment">// Get current stack limits.</span>
00370     <span class="comment">//</span>
00371 
00372     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a30">RtlpGetStackLimits</a>(&amp;LowLimit, &amp;HighLimit);
00373 
00374     <span class="comment">//</span>
00375     <span class="comment">// If an exception record is not specified, then build a local exception</span>
00376     <span class="comment">// record for use in calling exception handlers during the unwind operation.</span>
00377     <span class="comment">//</span>
00378 
00379     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(ExceptionRecord) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00380         ExceptionRecord = &amp;ExceptionRecord1;
00381         ExceptionRecord1.ExceptionCode = STATUS_UNWIND;
00382         ExceptionRecord1.ExceptionFlags = 0;
00383         ExceptionRecord1.ExceptionRecord = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00384         ExceptionRecord1.ExceptionAddress = <a class="code" href="../../d1/d9/ntrtl386_8h.html#a3">RtlpGetReturnAddress</a>();
00385         ExceptionRecord1.NumberParameters = 0;
00386     }
00387 
00388     <span class="comment">//</span>
00389     <span class="comment">// If the target frame of the unwind is specified, then set EXCEPTION_UNWINDING</span>
00390     <span class="comment">// flag in the exception flags. Otherwise set both EXCEPTION_EXIT_UNWIND and</span>
00391     <span class="comment">// EXCEPTION_UNWINDING flags in the exception flags.</span>
00392     <span class="comment">//</span>
00393 
00394     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(TargetFrame) == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00395         ExceptionRecord-&gt;ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a26">EXCEPTION_UNWINDING</a>;
00396     } <span class="keywordflow">else</span> {
00397         ExceptionRecord-&gt;ExceptionFlags |= (<a class="code" href="../../d6/d7/halmips_8h.html#a26">EXCEPTION_UNWINDING</a> |
00398                                                         <a class="code" href="../../d6/d7/halmips_8h.html#a27">EXCEPTION_EXIT_UNWIND</a>);
00399     }
00400 
00401     <span class="comment">//</span>
00402     <span class="comment">// Capture the context.</span>
00403     <span class="comment">//</span>
00404 
00405     ContextRecord = &amp;ContextRecord1;
00406     ContextRecord1.ContextFlags = <a class="code" href="../../d6/d7/halmips_8h.html#a155">CONTEXT_INTEGER</a> | <a class="code" href="../../d6/d7/halmips_8h.html#a153">CONTEXT_CONTROL</a> | CONTEXT_SEGMENTS;
00407     <a class="code" href="../../d1/d9/ntrtl386_8h.html#a0">RtlpCaptureContext</a>(ContextRecord);
00408 
00409 <span class="preprocessor">#ifdef STD_CALL</span>
00410 <span class="preprocessor"></span>    <span class="comment">//</span>
00411     <span class="comment">// Adjust captured context to pop our arguments off the stack</span>
00412     <span class="comment">//</span>
00413     ContextRecord-&gt;Esp += <span class="keyword">sizeof</span>(TargetFrame) +
00414                           <span class="keyword">sizeof</span>(TargetIp)    +
00415                           <span class="keyword">sizeof</span>(ExceptionRecord) +
00416                           <span class="keyword">sizeof</span>(ReturnValue);
00417 <span class="preprocessor">#endif</span>
00418 <span class="preprocessor"></span>    ContextRecord-&gt;Eax = (ULONG)ReturnValue;
00419 
00420     <span class="comment">//</span>
00421     <span class="comment">// Scan backward through the call frame hierarchy, calling exception</span>
00422     <span class="comment">// handlers as they are encountered, until the target frame of the unwind</span>
00423     <span class="comment">// is reached.</span>
00424     <span class="comment">//</span>
00425 
00426     RegistrationPointer = <a class="code" href="../../d3/d9/ntrtli64_8h.html#a3">RtlpGetRegistrationHead</a>();
00427     <span class="keywordflow">while</span> (RegistrationPointer != EXCEPTION_CHAIN_END) {
00428 
00429         <span class="comment">//</span>
00430         <span class="comment">// If this is the target of the unwind, then continue execution</span>
00431         <span class="comment">// by calling the continue system service.</span>
00432         <span class="comment">//</span>
00433 
00434         <span class="keywordflow">if</span> ((ULONG)RegistrationPointer == (ULONG)TargetFrame) {
00435             ZwContinue(ContextRecord, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00436 
00437         <span class="comment">//</span>
00438         <span class="comment">// If the target frame is lower in the stack than the current frame,</span>
00439         <span class="comment">// then raise STATUS_INVALID_UNWIND exception.</span>
00440         <span class="comment">//</span>
00441 
00442         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( (ARGUMENT_PRESENT(TargetFrame) == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) &amp;&amp;
00443                     ((ULONG)TargetFrame &lt; (ULONG)RegistrationPointer) ) {
00444             ExceptionRecord2.ExceptionCode = STATUS_INVALID_UNWIND_TARGET;
00445             ExceptionRecord2.ExceptionFlags = <a class="code" href="../../d6/d7/halmips_8h.html#a25">EXCEPTION_NONCONTINUABLE</a>;
00446             ExceptionRecord2.ExceptionRecord = ExceptionRecord;
00447             ExceptionRecord2.NumberParameters = 0;
00448             <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a9">RtlRaiseException</a>(&amp;ExceptionRecord2);
00449         }
00450 
00451         <span class="comment">//</span>
00452         <span class="comment">// If the call frame is not within the specified stack limits or the</span>
00453         <span class="comment">// call frame is unaligned, then raise the exception STATUS_BAD_STACK.</span>
00454         <span class="comment">// Else restore the state from the specified frame to the context</span>
00455         <span class="comment">// record.</span>
00456         <span class="comment">//</span>
00457 
00458         HighAddress = (ULONG)RegistrationPointer +
00459             <span class="keyword">sizeof</span>(EXCEPTION_REGISTRATION_RECORD);
00460 
00461         <span class="keywordflow">if</span> ( ((ULONG)RegistrationPointer &lt; LowLimit) ||
00462              (HighAddress &gt; HighLimit) ||
00463              (((ULONG)RegistrationPointer &amp; 0x3) != 0) ) {
00464 
00465 <span class="preprocessor">#if defined(NTOS_KERNEL_RUNTIME)</span>
00466 <span class="preprocessor"></span>
00467             <span class="comment">//</span>
00468             <span class="comment">// Allow for the possibility that the problem occured on the</span>
00469             <span class="comment">// DPC stack.</span>
00470             <span class="comment">//</span>
00471 
00472             ULONG TestAddress = (ULONG)RegistrationPointer;
00473 
00474             <span class="keywordflow">if</span> (((TestAddress &amp; 0x3) == 0) &amp;&amp;
00475                 KeGetCurrentIrql() &gt;= <a class="code" href="../../d6/d7/halmips_8h.html#a53">DISPATCH_LEVEL</a>) {
00476 
00477                 PKPRCB Prcb = <a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a2">KeGetCurrentPrcb</a>();
00478                 ULONG DpcStack = (ULONG)Prcb-&gt;DpcStack;
00479 
00480                 <span class="keywordflow">if</span> ((Prcb-&gt;DpcRoutineActive) &amp;&amp;
00481                     (HighAddress &lt;= DpcStack) &amp;&amp;
00482                     (TestAddress &gt;= DpcStack - KERNEL_STACK_SIZE)) {
00483 
00484                     <span class="comment">//</span>
00485                     <span class="comment">// This error occured on the DPC stack, switch</span>
00486                     <span class="comment">// stack limits to the DPC stack and restart </span>
00487                     <span class="comment">// the loop.</span>
00488                     <span class="comment">// </span>
00489 
00490                     HighLimit = DpcStack;
00491                     LowLimit = DpcStack - KERNEL_STACK_SIZE;
00492                     <span class="keywordflow">continue</span>;
00493                 }
00494             }
00495 
00496 <span class="preprocessor">#endif</span>
00497 <span class="preprocessor"></span>
00498             ExceptionRecord2.ExceptionCode = STATUS_BAD_STACK;
00499             ExceptionRecord2.ExceptionFlags = <a class="code" href="../../d6/d7/halmips_8h.html#a25">EXCEPTION_NONCONTINUABLE</a>;
00500             ExceptionRecord2.ExceptionRecord = ExceptionRecord;
00501             ExceptionRecord2.NumberParameters = 0;
00502             <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a9">RtlRaiseException</a>(&amp;ExceptionRecord2);
00503         } <span class="keywordflow">else</span> {
00504 
00505             <span class="comment">//</span>
00506             <span class="comment">// The handler must be executed by calling another routine</span>
00507             <span class="comment">// that is written in assembler. This is required because</span>
00508             <span class="comment">// up level addressing of the handler information is required</span>
00509             <span class="comment">// when a collided unwind is encountered.</span>
00510             <span class="comment">//</span>
00511 
00512             Disposition = <a class="code" href="../../d6/d9/ntrtlppc_8h.html#a1">RtlpExecuteHandlerForUnwind</a>(
00513                 ExceptionRecord,
00514                 (PVOID)RegistrationPointer,
00515                 ContextRecord,
00516                 (PVOID)&amp;DispatcherContext,
00517                 RegistrationPointer-&gt;Handler);
00518 
00519             <span class="comment">//</span>
00520             <span class="comment">// Case on the handler disposition.</span>
00521             <span class="comment">//</span>
00522 
00523             <span class="keywordflow">switch</span> (Disposition) {
00524 
00525                 <span class="comment">//</span>
00526                 <span class="comment">// The disposition is to continue the search. Get next</span>
00527                 <span class="comment">// frame address and continue the search.</span>
00528                 <span class="comment">//</span>
00529 
00530             <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a37">ExceptionContinueSearch</a> :
00531                 <span class="keywordflow">break</span>;
00532 
00533                 <span class="comment">//</span>
00534                 <span class="comment">// The disposition is colided unwind. Maximize the target</span>
00535                 <span class="comment">// of the unwind and change the context record pointer.</span>
00536                 <span class="comment">//</span>
00537 
00538             <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a39">ExceptionCollidedUnwind</a> :
00539 
00540                 <span class="comment">//</span>
00541                 <span class="comment">// Pick up the registration pointer that was active at</span>
00542                 <span class="comment">// the time of the unwind, and simply continue.</span>
00543                 <span class="comment">//</span>
00544 
00545                 RegistrationPointer = DispatcherContext.RegistrationPointer;
00546                 <span class="keywordflow">break</span>;
00547 
00548 
00549                 <span class="comment">//</span>
00550                 <span class="comment">// All other disposition values are invalid. Raise</span>
00551                 <span class="comment">// invalid disposition exception.</span>
00552                 <span class="comment">//</span>
00553 
00554             <span class="keywordflow">default</span> :
00555                 ExceptionRecord2.ExceptionCode = STATUS_INVALID_DISPOSITION;
00556                 ExceptionRecord2.ExceptionFlags = <a class="code" href="../../d6/d7/halmips_8h.html#a25">EXCEPTION_NONCONTINUABLE</a>;
00557                 ExceptionRecord2.ExceptionRecord = ExceptionRecord;
00558                 ExceptionRecord2.NumberParameters = 0;
00559                 <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a9">RtlRaiseException</a>(&amp;ExceptionRecord2);
00560                 <span class="keywordflow">break</span>;
00561             }
00562 
00563             <span class="comment">//</span>
00564             <span class="comment">// Step to next registration record</span>
00565             <span class="comment">//</span>
00566 
00567             PriorPointer = RegistrationPointer;
00568             RegistrationPointer = RegistrationPointer-&gt;Next;
00569 
00570             <span class="comment">//</span>
00571             <span class="comment">// Unlink the unwind handler, since it's been called.</span>
00572             <span class="comment">//</span>
00573 
00574             <a class="code" href="../../d3/d9/ntrtli64_8h.html#a2">RtlpUnlinkHandler</a>(PriorPointer);
00575 
00576             <span class="comment">//</span>
00577             <span class="comment">// If chain goes in wrong direction or loops, raise an</span>
00578             <span class="comment">// exception.</span>
00579             <span class="comment">//</span>
00580 
00581         }
00582     }
00583 
00584     <span class="keywordflow">if</span> (TargetFrame == EXCEPTION_CHAIN_END) {
00585 
00586         <span class="comment">//</span>
00587         <span class="comment">//  Caller simply wants to unwind all exception records.</span>
00588         <span class="comment">//  This differs from an exit_unwind in that no "exit" is desired.</span>
00589         <span class="comment">//  Do a normal continue, since we've effectively found the</span>
00590         <span class="comment">//  "target" the caller wanted.</span>
00591         <span class="comment">//</span>
00592 
00593         ZwContinue(ContextRecord, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00594 
00595     } <span class="keywordflow">else</span> {
00596 
00597         <span class="comment">//</span>
00598         <span class="comment">//  Either (1) a real exit unwind was performed, or (2) the</span>
00599         <span class="comment">//  specified TargetFrame is not present in the exception handler</span>
00600         <span class="comment">//  list.  In either case, give debugger and subsystem a chance</span>
00601         <span class="comment">//  to see the unwind.</span>
00602         <span class="comment">//</span>
00603 
00604         ZwRaiseException(ExceptionRecord, ContextRecord, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00605 
00606     }
00607     <span class="keywordflow">return</span>;
00608 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:39:57 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
