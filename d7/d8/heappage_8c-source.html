<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: heappage.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>heappage.c</h1><a href="../../d6/d9/heappage_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1994-2000  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    heappage.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    Implementation of NT RtlHeap family of APIs for debugging</span>
00012 <span class="comment">    applications with heap usage bugs.  Each allocation returned to</span>
00013 <span class="comment">    the calling app is placed at the end of a virtual page such that</span>
00014 <span class="comment">    the following virtual page is protected (ie, NO_ACCESS).</span>
00015 <span class="comment">    So, when the errant app attempts to reference or modify memory</span>
00016 <span class="comment">    beyond the allocated portion of a heap block, an access violation</span>
00017 <span class="comment">    is immediately caused.  This facilitates debugging the app</span>
00018 <span class="comment">    because the access violation occurs at the exact point in the</span>
00019 <span class="comment">    app where the heap corruption or abuse would occur.  Note that</span>
00020 <span class="comment">    significantly more memory (pagefile) is required to run an app</span>
00021 <span class="comment">    using this heap implementation as opposed to the retail heap</span>
00022 <span class="comment">    manager.</span>
00023 <span class="comment"></span>
00024 <span class="comment">Author:</span>
00025 <span class="comment"></span>
00026 <span class="comment">    Tom McGuire (TomMcg) 06-Jan-1995</span>
00027 <span class="comment">    Silviu Calinoiu (SilviuC) 22-Feb-2000</span>
00028 <span class="comment"></span>
00029 <span class="comment">Revision History:</span>
00030 <span class="comment"></span>
00031 <span class="comment">--*/</span>
00032 
00033 <span class="preprocessor">#include "<a class="code" href="../../d5/d9/ntrtlp_8h.html">ntrtlp.h</a>"</span>
00034 <span class="preprocessor">#include "<a class="code" href="../../d7/d9/heappage_8h.html">heappage.h</a>"</span>       <span class="comment">// external interface (hooks) to debug heap manager</span>
00035 <span class="preprocessor">#include "<a class="code" href="../../d8/d9/heappagi_8h.html">heappagi.h</a>"</span>
00036 <span class="preprocessor">#include "<a class="code" href="../../d9/d9/heappriv_8h.html">heappriv.h</a>"</span>
00037 
00038 <span class="keywordtype">int</span> __cdecl <a class="code" href="../../d6/d9/heappage_8c.html#a68">sprintf</a>(<span class="keywordtype">char</span> *, <span class="keyword">const</span> <span class="keywordtype">char</span> *, ...);
00039 
00040 <span class="comment">//</span>
00041 <span class="comment">//  Remainder of entire file is wrapped with #ifdef DEBUG_PAGE_HEAP so that</span>
00042 <span class="comment">//  it will compile away to nothing if DEBUG_PAGE_HEAP is not defined in</span>
00043 <span class="comment">//  heappage.h</span>
00044 <span class="comment">//</span>
00045 
00046 <span class="preprocessor">#ifdef DEBUG_PAGE_HEAP</span>
00047 <span class="preprocessor"></span>
00048 <span class="comment">//</span>
00049 <span class="comment">// Page size</span>
00050 <span class="comment">//</span>
00051 
00052 <span class="preprocessor">#if defined(_X86_)</span>
00053 <span class="preprocessor"></span><span class="preprocessor">    #ifndef PAGE_SIZE</span>
00054 <span class="preprocessor"></span><span class="preprocessor">    #define PAGE_SIZE   0x1000</span>
00055 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
00056 <span class="preprocessor"></span><span class="preprocessor">    #define USER_ALIGNMENT 8</span>
00057 <span class="preprocessor"></span><span class="preprocessor">#elif defined(_MIPS_)</span>
00058 <span class="preprocessor"></span><span class="preprocessor">    #ifndef PAGE_SIZE</span>
00059 <span class="preprocessor"></span><span class="preprocessor">    #define PAGE_SIZE   0x1000</span>
00060 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
00061 <span class="preprocessor"></span><span class="preprocessor">    #define USER_ALIGNMENT 8</span>
00062 <span class="preprocessor"></span><span class="preprocessor">#elif defined(_PPC_)</span>
00063 <span class="preprocessor"></span><span class="preprocessor">    #ifndef PAGE_SIZE</span>
00064 <span class="preprocessor"></span><span class="preprocessor">    #define PAGE_SIZE   0x1000</span>
00065 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
00066 <span class="preprocessor"></span><span class="preprocessor">    #define USER_ALIGNMENT 8</span>
00067 <span class="preprocessor"></span><span class="preprocessor">#elif defined(_IA64_)</span>
00068 <span class="preprocessor"></span><span class="preprocessor">    #ifndef PAGE_SIZE</span>
00069 <span class="preprocessor"></span><span class="preprocessor">    #define PAGE_SIZE   0x2000</span>
00070 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
00071 <span class="preprocessor"></span><span class="preprocessor">    #define USER_ALIGNMENT 16</span>
00072 <span class="preprocessor"></span><span class="preprocessor">#elif defined(_AXP64_)</span>
00073 <span class="preprocessor"></span><span class="preprocessor">    #ifndef PAGE_SIZE</span>
00074 <span class="preprocessor"></span><span class="preprocessor">    #define PAGE_SIZE   0x2000</span>
00075 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
00076 <span class="preprocessor"></span><span class="preprocessor">    #define USER_ALIGNMENT 16</span>
00077 <span class="preprocessor"></span><span class="preprocessor">#elif defined(_ALPHA_)</span>
00078 <span class="preprocessor"></span><span class="preprocessor">    #ifndef PAGE_SIZE</span>
00079 <span class="preprocessor"></span><span class="preprocessor">    #define PAGE_SIZE   0x2000</span>
00080 <span class="preprocessor"></span><span class="preprocessor">    #endif</span>
00081 <span class="preprocessor"></span><span class="preprocessor">    #define USER_ALIGNMENT 8</span>
00082 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00083 <span class="preprocessor"></span><span class="preprocessor">    #error  // platform not defined</span>
00084 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00085 <span class="preprocessor"></span>
00086 <span class="comment">//</span>
00087 <span class="comment">// Few constants</span>
00088 <span class="comment">//</span>
00089 
<a name="l00090"></a><a class="code" href="../../d6/d9/heappage_8c.html#a0">00090</a> <span class="preprocessor">#define DPH_HEAP_SIGNATURE       0xFFEEDDCC</span>
<a name="l00091"></a><a class="code" href="../../d6/d9/heappage_8c.html#a1">00091</a> <span class="preprocessor"></span><span class="preprocessor">#define FILL_BYTE                0xEE</span>
<a name="l00092"></a><a class="code" href="../../d6/d9/heappage_8c.html#a2">00092</a> <span class="preprocessor"></span><span class="preprocessor">#define HEAD_FILL_SIZE           0x10</span>
<a name="l00093"></a><a class="code" href="../../d6/d9/heappage_8c.html#a3">00093</a> <span class="preprocessor"></span><span class="preprocessor">#define RESERVE_SIZE             0x100000</span>
<a name="l00094"></a><a class="code" href="../../d6/d9/heappage_8c.html#a4">00094</a> <span class="preprocessor"></span><span class="preprocessor">#define VM_UNIT_SIZE             0x10000</span>
<a name="l00095"></a><a class="code" href="../../d6/d9/heappage_8c.html#a5">00095</a> <span class="preprocessor"></span><span class="preprocessor">#define POOL_SIZE                0x4000</span>
<a name="l00096"></a><a class="code" href="../../d6/d9/heappage_8c.html#a6">00096</a> <span class="preprocessor"></span><span class="preprocessor">#define INLINE                   __inline</span>
<a name="l00097"></a><a class="code" href="../../d6/d9/heappage_8c.html#a7">00097</a> <span class="preprocessor"></span><span class="preprocessor">#define MIN_FREE_LIST_LENGTH     8</span>
00098 <span class="preprocessor"></span>
00099 <span class="comment">//</span>
00100 <span class="comment">// Few macros</span>
00101 <span class="comment">//</span>
00102 
<a name="l00103"></a><a class="code" href="../../d6/d9/heappage_8c.html#a8">00103</a> <span class="preprocessor">#define ROUNDUP2( x, n ) ((( x ) + (( n ) - 1 )) &amp; ~(( n ) - 1 ))</span>
00104 <span class="preprocessor"></span>
00105 <span class="preprocessor">#if INTERNAL_DEBUG</span>
00106 <span class="preprocessor"></span><span class="preprocessor">#define DEBUG_CODE( a ) a</span>
00107 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00108"></a><a class="code" href="../../d6/d9/heappage_8c.html#a9">00108</a> <span class="preprocessor"></span><span class="preprocessor">#define DEBUG_CODE( a )</span>
00109 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00110 <span class="preprocessor"></span>
<a name="l00111"></a><a class="code" href="../../d6/d9/heappage_8c.html#a10">00111</a> <span class="preprocessor">#define RETAIL_ASSERT( a ) ( (a) ? TRUE : \</span>
00112 <span class="preprocessor">    RtlpDebugPageHeapAssert( "Page heap: assert: (" #a ")\n" ))</span>
00113 <span class="preprocessor"></span>
<a name="l00114"></a><a class="code" href="../../d6/d9/heappage_8c.html#a11">00114</a> <span class="preprocessor">#define DEBUG_ASSERT( a ) DEBUG_CODE( RETAIL_ASSERT( a ))</span>
00115 <span class="preprocessor"></span>
<a name="l00116"></a><a class="code" href="../../d6/d9/heappage_8c.html#a12">00116</a> <span class="preprocessor">#define HEAP_HANDLE_FROM_ROOT( HeapRoot ) \</span>
00117 <span class="preprocessor">    ((PVOID)(((PCHAR)(HeapRoot)) - PAGE_SIZE ))</span>
00118 <span class="preprocessor"></span>
<a name="l00119"></a><a class="code" href="../../d6/d9/heappage_8c.html#a13">00119</a> <span class="preprocessor">#define IF_GENERATE_EXCEPTION( Flags, Status ) {                \</span>
00120 <span class="preprocessor">    if (( Flags ) &amp; HEAP_GENERATE_EXCEPTIONS )                  \</span>
00121 <span class="preprocessor">        RtlpDebugPageHeapException((ULONG)(Status));            \</span>
00122 <span class="preprocessor">    }</span>
00123 <span class="preprocessor"></span>
<a name="l00124"></a><a class="code" href="../../d6/d9/heappage_8c.html#a14">00124</a> <span class="preprocessor">#define OUT_OF_VM_BREAK( Flags, szText ) {                      \</span>
00125 <span class="preprocessor">    if (( Flags ) &amp; HEAP_BREAK_WHEN_OUT_OF_VM )                 \</span>
00126 <span class="preprocessor">        RtlpDebugPageHeapBreak(( szText ));                     \</span>
00127 <span class="preprocessor">    }</span>
00128 <span class="preprocessor"></span>
00129 <span class="comment">//</span>
00130 <span class="comment">// List manipulation macros</span>
00131 <span class="comment">//</span>
00132 
<a name="l00133"></a><a class="code" href="../../d6/d9/heappage_8c.html#a15">00133</a> <span class="preprocessor">#define ENQUEUE_HEAD( Node, Head, Tail ) {          \</span>
00134 <span class="preprocessor">            (Node)-&gt;pNextAlloc = (Head);            \</span>
00135 <span class="preprocessor">            if ((Head) == NULL )                    \</span>
00136 <span class="preprocessor">                (Tail) = (Node);                    \</span>
00137 <span class="preprocessor">            (Head) = (Node);                        \</span>
00138 <span class="preprocessor">            }</span>
00139 <span class="preprocessor"></span>
<a name="l00140"></a><a class="code" href="../../d6/d9/heappage_8c.html#a16">00140</a> <span class="preprocessor">#define ENQUEUE_TAIL( Node, Head, Tail ) {          \</span>
00141 <span class="preprocessor">            if ((Tail) == NULL )                    \</span>
00142 <span class="preprocessor">                (Head) = (Node);                    \</span>
00143 <span class="preprocessor">            else                                    \</span>
00144 <span class="preprocessor">                (Tail)-&gt;pNextAlloc = (Node);        \</span>
00145 <span class="preprocessor">            (Tail) = (Node);                        \</span>
00146 <span class="preprocessor">            }</span>
00147 <span class="preprocessor"></span>
<a name="l00148"></a><a class="code" href="../../d6/d9/heappage_8c.html#a17">00148</a> <span class="preprocessor">#define DEQUEUE_NODE( Node, Prev, Head, Tail ) {    \</span>
00149 <span class="preprocessor">            PVOID Next = (Node)-&gt;pNextAlloc;        \</span>
00150 <span class="preprocessor">            if ((Head) == (Node))                   \</span>
00151 <span class="preprocessor">                (Head) = Next;                      \</span>
00152 <span class="preprocessor">            if ((Tail) == (Node))                   \</span>
00153 <span class="preprocessor">                (Tail) = (Prev);                    \</span>
00154 <span class="preprocessor">            if ((Prev) != (NULL))                   \</span>
00155 <span class="preprocessor">                (Prev)-&gt;pNextAlloc = Next;          \</span>
00156 <span class="preprocessor">            }</span>
00157 <span class="preprocessor"></span>
00158 <span class="comment">//</span>
00159 <span class="comment">// Bias/unbias pointer</span>
00160 <span class="comment">//</span>
00161 
<a name="l00162"></a><a class="code" href="../../d6/d9/heappage_8c.html#a18">00162</a> <span class="preprocessor">#define BIAS_POINTER(p)      ((PVOID)((ULONG_PTR)(p) | (ULONG_PTR)0x01))</span>
<a name="l00163"></a><a class="code" href="../../d6/d9/heappage_8c.html#a19">00163</a> <span class="preprocessor"></span><span class="preprocessor">#define UNBIAS_POINTER(p)    ((PVOID)((ULONG_PTR)(p) &amp; ~((ULONG_PTR)0x01)))</span>
<a name="l00164"></a><a class="code" href="../../d6/d9/heappage_8c.html#a20">00164</a> <span class="preprocessor"></span><span class="preprocessor">#define IS_BIASED_POINTER(p) ((PVOID)((ULONG_PTR)(p) &amp; (ULONG_PTR)0x01))</span>
00165 <span class="preprocessor"></span>
00166 <span class="comment">//</span>
00167 <span class="comment">// Protect/Unprotect heap structures macros</span>
00168 <span class="comment">//</span>
00169 
<a name="l00170"></a><a class="code" href="../../d6/d9/heappage_8c.html#a21">00170</a> <span class="preprocessor">#define PROTECT_HEAP_STRUCTURES( HeapRoot ) {                           \</span>
00171 <span class="preprocessor">            if ((HeapRoot)-&gt;HeapFlags &amp; HEAP_PROTECTION_ENABLED )       \</span>
00172 <span class="preprocessor">                RtlpDebugPageHeapProtectStructures( (HeapRoot) );       \</span>
00173 <span class="preprocessor">            }</span>
00174 <span class="preprocessor"></span>
<a name="l00175"></a><a class="code" href="../../d6/d9/heappage_8c.html#a22">00175</a> <span class="preprocessor">#define UNPROTECT_HEAP_STRUCTURES( HeapRoot ) {                         \</span>
00176 <span class="preprocessor">            if ((HeapRoot)-&gt;HeapFlags &amp; HEAP_PROTECTION_ENABLED )       \</span>
00177 <span class="preprocessor">                RtlpDebugPageHeapUnProtectStructures( (HeapRoot) );     \</span>
00178 <span class="preprocessor">            }</span>
00179 <span class="preprocessor"></span>
00180 <span class="comment">//</span>
00181 <span class="comment">// RtlpDebugPageHeap</span>
00182 <span class="comment">//</span>
00183 <span class="comment">// Global variable that marks that page heap is enabled. It is set</span>
00184 <span class="comment">// in \nt\base\ntdll\ldrinit.c by reading the GlobalFlag registry</span>
00185 <span class="comment">// value (system wide or per process one) and checking if the </span>
00186 <span class="comment">// FLG_HEAP_PAGE_ALLOCS is set.</span>
00187 <span class="comment">//</span>
00188 
<a name="l00189"></a><a class="code" href="../../d6/d9/heappage_8c.html#a36">00189</a> BOOLEAN <a class="code" href="../../d6/d9/heappage_8c.html#a36">RtlpDebugPageHeap</a>;                    
00190 
00191 <span class="comment">//</span>
00192 <span class="comment">// Internal version used to figure out what are people running</span>
00193 <span class="comment">// in various VBLs.</span>
00194 <span class="comment">//</span>
00195 
<a name="l00196"></a><a class="code" href="../../d6/d9/heappage_8c.html#a37">00196</a> PCHAR <a class="code" href="../../d6/d9/heappage_8c.html#a37">RtlpDphVersion</a> = <span class="stringliteral">"03/14/2000"</span>;
00197 
00198 <span class="comment">//</span>
00199 <span class="comment">// Page heaps list manipulation.</span>
00200 <span class="comment">//</span>
00201 <span class="comment">// We maintain a list of all page heaps in the process to support</span>
00202 <span class="comment">// APIs like GetProcessHeaps. The list is also useful for debug</span>
00203 <span class="comment">// extensions that need to iterate the heaps. The list is protected</span>
00204 <span class="comment">// by RtlpDphHeapListCriticalSection lock.</span>
00205 <span class="comment">//</span>
00206 
<a name="l00207"></a><a class="code" href="../../d6/d9/heappage_8c.html#a38">00207</a> BOOLEAN <a class="code" href="../../d6/d9/heappage_8c.html#a38">RtlpDphHeapListHasBeenInitialized</a>;
<a name="l00208"></a><a class="code" href="../../d6/d9/heappage_8c.html#a39">00208</a> RTL_CRITICAL_SECTION <a class="code" href="../../d6/d9/heappage_8c.html#a39">RtlpDphHeapListCriticalSection</a>;
<a name="l00209"></a><a class="code" href="../../d6/d9/heappage_8c.html#a40">00209</a> PDPH_HEAP_ROOT <a class="code" href="../../d6/d9/heappage_8c.html#a40">RtlpDphHeapListHead</a>;
<a name="l00210"></a><a class="code" href="../../d6/d9/heappage_8c.html#a41">00210</a> PDPH_HEAP_ROOT <a class="code" href="../../d6/d9/heappage_8c.html#a41">RtlpDphHeapListTail</a>;
<a name="l00211"></a><a class="code" href="../../d6/d9/heappage_8c.html#a42">00211</a> ULONG <a class="code" href="../../d6/d9/heappage_8c.html#a42">RtlpDphHeapListCount</a>;
00212 
00213 <span class="comment">//</span>
00214 <span class="comment">// `RtlpDebugPageHeapGlobalFlags' stores the global page heap flags.</span>
00215 <span class="comment">// The value of this variable is copied into the per heap</span>
00216 <span class="comment">// flags (ExtraFlags field) during heap creation.</span>
00217 <span class="comment">//</span>
00218 <span class="comment">// The initial value is so that by default we use page heap only with</span>
00219 <span class="comment">// normal allocations. This way if system wide global flag for page</span>
00220 <span class="comment">// heap is set the machine will still boot. After that we can enable</span>
00221 <span class="comment">// page heap with "sudden death" for specific processes. The most useful</span>
00222 <span class="comment">// flags for this case would be:</span>
00223 <span class="comment">//</span>
00224 <span class="comment">//    PAGE_HEAP_ENABLE_PAGE_HEAP       |</span>
00225 <span class="comment">//    PAGE_HEAP_COLLECT_STACK_TRACES   ;</span>
00226 <span class="comment">//</span>
00227 <span class="comment">// If no flags specified the default is page heap light with</span>
00228 <span class="comment">// stack trace collection.</span>
00229 <span class="comment">//</span>
00230 
<a name="l00231"></a><a class="code" href="../../d6/d9/heappage_8c.html#a43">00231</a> ULONG <a class="code" href="../../d6/d9/heappage_8c.html#a43">RtlpDphGlobalFlags</a> = PAGE_HEAP_COLLECT_STACK_TRACES;
00232 
00233 <span class="comment">//</span>
00234 <span class="comment">// Page heap global flags.</span>
00235 <span class="comment">//</span>
00236 <span class="comment">// These values are read from registry in \nt\base\ntdll\ldrinit.c.</span>
00237 <span class="comment">//</span>
00238 
<a name="l00239"></a><a class="code" href="../../d6/d9/heappage_8c.html#a44">00239</a> ULONG <a class="code" href="../../d6/d9/heappage_8c.html#a44">RtlpDphSizeRangeStart</a>;
<a name="l00240"></a><a class="code" href="../../d6/d9/heappage_8c.html#a45">00240</a> ULONG <a class="code" href="../../d6/d9/heappage_8c.html#a45">RtlpDphSizeRangeEnd</a>;
<a name="l00241"></a><a class="code" href="../../d6/d9/heappage_8c.html#a46">00241</a> ULONG <a class="code" href="../../d6/d9/heappage_8c.html#a46">RtlpDphDllRangeStart</a>;
<a name="l00242"></a><a class="code" href="../../d6/d9/heappage_8c.html#a47">00242</a> ULONG <a class="code" href="../../d6/d9/heappage_8c.html#a47">RtlpDphDllRangeEnd</a>;
<a name="l00243"></a><a class="code" href="../../d6/d9/heappage_8c.html#a48">00243</a> ULONG <a class="code" href="../../d6/d9/heappage_8c.html#a48">RtlpDphRandomProbability</a>;
<a name="l00244"></a><a class="code" href="../../d6/d9/heappage_8c.html#a49">00244</a> WCHAR <a class="code" href="../../d6/d9/heappage_8c.html#a49">RtlpDphTargetDlls</a> [512];
<a name="l00245"></a><a class="code" href="../../d6/d9/heappage_8c.html#a50">00245</a> UNICODE_STRING <a class="code" href="../../d6/d9/heappage_8c.html#a50">RtlpDphTargetDllsUnicode</a>;
00246 
00247 <span class="comment">//</span>
00248 <span class="comment">// `RtlpDphDebugLevel' controls debug messages in the code.</span>
00249 <span class="comment">//</span>
00250 <span class="comment">// (SilviuC): The value should always be zero for the retail bits.</span>
00251 <span class="comment">//</span>
00252 
<a name="l00253"></a><a class="code" href="../../d6/d9/heappage_8c.html#a23">00253</a> <span class="preprocessor">#define DPH_DEBUG_INTERNAL_VALIDATION 0x0001</span>
<a name="l00254"></a><a class="code" href="../../d6/d9/heappage_8c.html#a24">00254</a> <span class="preprocessor"></span><span class="preprocessor">#define DPH_DEBUG_RESERVED_2          0x0002</span>
<a name="l00255"></a><a class="code" href="../../d6/d9/heappage_8c.html#a25">00255</a> <span class="preprocessor"></span><span class="preprocessor">#define DPH_DEBUG_RESERVED_4          0x0004</span>
<a name="l00256"></a><a class="code" href="../../d6/d9/heappage_8c.html#a26">00256</a> <span class="preprocessor"></span><span class="preprocessor">#define DPH_DEBUG_RESERVED_8          0x0008</span>
<a name="l00257"></a><a class="code" href="../../d6/d9/heappage_8c.html#a27">00257</a> <span class="preprocessor"></span><span class="preprocessor">#define DPH_DEBUG_DECOMMIT_RANGES     0x0010</span>
<a name="l00258"></a><a class="code" href="../../d6/d9/heappage_8c.html#a28">00258</a> <span class="preprocessor"></span><span class="preprocessor">#define DPH_DEBUG_BREAK_FOR_SIZE_ZERO 0x0020</span>
<a name="l00259"></a><a class="code" href="../../d6/d9/heappage_8c.html#a29">00259</a> <span class="preprocessor"></span><span class="preprocessor">#define DPH_DEBUG_BREAK_FOR_NULL_FREE 0x0040</span>
<a name="l00260"></a><a class="code" href="../../d6/d9/heappage_8c.html#a30">00260</a> <span class="preprocessor"></span><span class="preprocessor">#define DPH_DEBUG_NEVER_FREE          0x0080</span>
<a name="l00261"></a><a class="code" href="../../d6/d9/heappage_8c.html#a31">00261</a> <span class="preprocessor"></span><span class="preprocessor">#define DPH_DEBUG_SLOW_CHECKS         0x0100</span>
00262 <span class="preprocessor"></span>
<a name="l00263"></a><a class="code" href="../../d6/d9/heappage_8c.html#a51">00263</a> ULONG <a class="code" href="../../d6/d9/heappage_8c.html#a51">RtlpDphDebugLevel</a>;
00264 
00265 <span class="comment">//</span>
00266 <span class="comment">// `RtlpDphGlobalCounter' contains process wide counters.</span>
00267 <span class="comment">// The definition of counters is in `rtl\heappagi.h'</span>
00268 <span class="comment">//</span>
00269 <span class="comment">// `RtlpDphSizeCounter' contains size distribution for allocations</span>
00270 <span class="comment">// using 128 bytes granularity.</span>
00271 <span class="comment">//</span>
00272 
<a name="l00273"></a><a class="code" href="../../d6/d9/heappage_8c.html#a32">00273</a> <span class="preprocessor">#define BUMP_GLOBAL_COUNTER(n) InterlockedIncrement(&amp;(RtlpDphGlobalCounter[n]))</span>
00274 <span class="preprocessor"></span>
<a name="l00275"></a><a class="code" href="../../d6/d9/heappage_8c.html#a33">00275</a> <span class="preprocessor">#define BUMP_SIZE_COUNTER(Size) if (Size/128 &lt;= MAX_SIZE_COUNTER_INDEX) {    \</span>
00276 <span class="preprocessor">        InterlockedIncrement(&amp;(RtlpDphSizeCounter[Size/128]));               \</span>
00277 <span class="preprocessor">    }                                                                        \</span>
00278 <span class="preprocessor">    else {                                                                   \</span>
00279 <span class="preprocessor">        InterlockedIncrement(&amp;(RtlpDphSizeCounter[MAX_SIZE_COUNTER_INDEX])); \</span>
00280 <span class="preprocessor">    }</span>
00281 <span class="preprocessor"></span>
<a name="l00282"></a><a class="code" href="../../d6/d9/heappage_8c.html#a34">00282</a> <span class="preprocessor">#define MAX_GLOBAL_COUNTER_INDEX 15</span>
<a name="l00283"></a><a class="code" href="../../d6/d9/heappage_8c.html#a35">00283</a> <span class="preprocessor"></span><span class="preprocessor">#define MAX_SIZE_COUNTER_INDEX 64</span>
00284 <span class="preprocessor"></span>
<a name="l00285"></a><a class="code" href="../../d6/d9/heappage_8c.html#a52">00285</a> ULONG <a class="code" href="../../d6/d9/heappage_8c.html#a52">RtlpDphGlobalCounter</a>[<a class="code" href="../../d6/d9/heappage_8c.html#a34">MAX_GLOBAL_COUNTER_INDEX</a> + 1];
<a name="l00286"></a><a class="code" href="../../d6/d9/heappage_8c.html#a53">00286</a> ULONG <a class="code" href="../../d6/d9/heappage_8c.html#a53">RtlpDphSizeCounter</a>[<a class="code" href="../../d6/d9/heappage_8c.html#a35">MAX_SIZE_COUNTER_INDEX</a> + 1];
00287 
00288 <span class="comment">//</span>
00289 <span class="comment">// Threshold for delaying a free operation in the normal heap.</span>
00290 <span class="comment">// If we get over this limit we start actually freeing blocks.</span>
00291 <span class="comment">//</span>
00292 
<a name="l00293"></a><a class="code" href="../../d6/d9/heappage_8c.html#a54">00293</a> SIZE_T <a class="code" href="../../d6/d9/heappage_8c.html#a54">RtlpDphDelayedFreeCacheSize</a> = 256 * <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
00294 
00295 <span class="comment">//</span>
00296 <span class="comment">// Process wide trace database and the maximum size it can</span>
00297 <span class="comment">// grow to.</span>
00298 <span class="comment">//</span>
00299 
<a name="l00300"></a><a class="code" href="../../d6/d9/heappage_8c.html#a55">00300</a> SIZE_T <a class="code" href="../../d6/d9/heappage_8c.html#a55">RtlpDphTraceDatabaseMaximumSize</a> = 256 * <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
<a name="l00301"></a><a class="code" href="../../d6/d9/heappage_8c.html#a56">00301</a> PRTL_TRACE_DATABASE <a class="code" href="../../d6/d9/heappage_8c.html#a56">RtlpDphTraceDatabase</a>;
00302 
00303 <span class="comment">//</span>
00304 <span class="comment">// Support for normal heap allocations</span>
00305 <span class="comment">//</span>
00306 <span class="comment">// In order to make better use of memory available page heap will</span>
00307 <span class="comment">// allocate some of the block into a normal NT heap that it manages.</span>
00308 <span class="comment">// We will call these blocks "normal blocks" as opposed to "page blocks".</span>
00309 <span class="comment">//</span>
00310 <span class="comment">// All normal blocks have the requested size increased by DPH_BLOCK_INFORMATION.</span>
00311 <span class="comment">// The address returned is of course of the first byte after the block</span>
00312 <span class="comment">// info structure. Upon free, blocks are checked for corruption and</span>
00313 <span class="comment">// then released into the normal heap.</span>
00314 <span class="comment">// </span>
00315 <span class="comment">// All these normal heap functions are called with the page heap</span>
00316 <span class="comment">// lock acquired.</span>
00317 <span class="comment">// </span>
00318 
00319 PVOID
00320 <a class="code" href="../../d6/d9/heappage_8c.html#a69">RtlpDphNormalHeapAllocate</a> (
00321     PDPH_HEAP_ROOT Heap,
00322     ULONG Flags,
00323     SIZE_T Size
00324     );
00325 
00326 BOOLEAN
00327 <a class="code" href="../../d6/d9/heappage_8c.html#a70">RtlpDphNormalHeapFree</a> (
00328     PDPH_HEAP_ROOT Heap,
00329     ULONG Flags,
00330     PVOID Block
00331     );
00332 
00333 PVOID
00334 <a class="code" href="../../d6/d9/heappage_8c.html#a71">RtlpDphNormalHeapReAllocate</a> (
00335     PDPH_HEAP_ROOT Heap,
00336     ULONG Flags,
00337     PVOID OldBlock,
00338     SIZE_T Size
00339     );
00340 
00341 SIZE_T
00342 <a class="code" href="../../d6/d9/heappage_8c.html#a72">RtlpDphNormalHeapSize</a> (
00343     PDPH_HEAP_ROOT Heap,
00344     ULONG Flags,
00345     PVOID Block
00346     );
00347 
00348 BOOLEAN
00349 <a class="code" href="../../d6/d9/heappage_8c.html#a73">RtlpDphNormalHeapSetUserFlags</a>(
00350     IN PDPH_HEAP_ROOT Heap,
00351     IN ULONG Flags,
00352     IN PVOID Address,
00353     IN ULONG UserFlagsReset,
00354     IN ULONG UserFlagsSet
00355     );
00356 
00357 BOOLEAN
00358 <a class="code" href="../../d6/d9/heappage_8c.html#a74">RtlpDphNormalHeapSetUserValue</a>(
00359     IN PDPH_HEAP_ROOT Heap,
00360     IN ULONG Flags,
00361     IN PVOID Address,
00362     IN PVOID UserValue
00363     );
00364 
00365 BOOLEAN
00366 <a class="code" href="../../d6/d9/heappage_8c.html#a75">RtlpDphNormalHeapGetUserInfo</a>(
00367     IN PDPH_HEAP_ROOT Heap,
00368     IN  ULONG  Flags,
00369     IN  PVOID  Address,
00370     OUT PVOID* UserValue,
00371     OUT PULONG UserFlags
00372     );
00373 
00374 BOOLEAN
00375 <a class="code" href="../../d6/d9/heappage_8c.html#a76">RtlpDphNormalHeapValidate</a>(
00376     IN PDPH_HEAP_ROOT Heap,
00377     IN ULONG Flags,
00378     IN PVOID Address
00379     );
00380 
00381 <span class="comment">//</span>
00382 <span class="comment">// Support for DPH_BLOCK_INFORMATION management</span>
00383 <span class="comment">//</span>
00384 <span class="comment">// This header information prefixes both the normal and page heap</span>
00385 <span class="comment">// blocks.</span>
00386 <span class="comment">//</span>
00387 
00388 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00389 <a class="code" href="../../d6/d9/heappage_8c.html#a77">RtlpDphReportCorruptedBlock</a> (
00390     PVOID Block,
00391     ULONG Reason
00392     );
00393 
00394 BOOLEAN
00395 <a class="code" href="../../d6/d9/heappage_8c.html#a78">RtlpDphIsNormalHeapBlock</a> (
00396     PDPH_HEAP_ROOT Heap,
00397     PVOID Block,
00398     PULONG Reason,
00399     BOOLEAN CheckPattern
00400     );
00401 
00402 BOOLEAN
00403 <a class="code" href="../../d6/d9/heappage_8c.html#a79">RtlpDphIsNormalFreeHeapBlock</a> (
00404     PVOID Block,
00405     PULONG Reason,
00406     BOOLEAN CheckPattern
00407     );
00408 
00409 BOOLEAN
00410 <a class="code" href="../../d6/d9/heappage_8c.html#a80">RtlpDphIsPageHeapBlock</a> (
00411     PDPH_HEAP_ROOT Heap,
00412     PVOID Block,
00413     PULONG Reason,
00414     BOOLEAN CheckPattern
00415     );
00416 
00417 BOOLEAN
00418 <a class="code" href="../../d6/d9/heappage_8c.html#a81">RtlpDphWriteNormalHeapBlockInformation</a> (
00419     PDPH_HEAP_ROOT Heap,
00420     PVOID Block,
00421     SIZE_T RequestedSize,
00422     SIZE_T ActualSize
00423     );
00424 
00425 BOOLEAN
00426 <a class="code" href="../../d6/d9/heappage_8c.html#a82">RtlpDphWritePageHeapBlockInformation</a> (
00427     PDPH_HEAP_ROOT Heap,
00428     PVOID Block,
00429     SIZE_T RequestedSize,
00430     SIZE_T ActualSize
00431     );
00432 
00433 <span class="comment">//</span>
00434 <span class="comment">// Delayed free queue (of normal heap allocations) management</span>
00435 <span class="comment">//</span>
00436 
00437 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00438 <a class="code" href="../../d6/d9/heappage_8c.html#a83">RtlpDphInitializeDelayedFreeQueue</a> (
00439     );
00440 
00441 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00442 <a class="code" href="../../d6/d9/heappage_8c.html#a84">RtlpDphAddToDelayedFreeQueue</a> (
00443     PDPH_BLOCK_INFORMATION Info
00444     );
00445 
00446 BOOLEAN
00447 <a class="code" href="../../d6/d9/heappage_8c.html#a85">RtlpDphNeedToTrimDelayedFreeQueue</a> (
00448     PSIZE_T TrimSize
00449     );
00450 
00451 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00452 <a class="code" href="../../d6/d9/heappage_8c.html#a86">RtlpDphTrimDelayedFreeQueue</a> (
00453     SIZE_T TrimSize,
00454     ULONG Flags
00455     );
00456 
00457 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00458 <a class="code" href="../../d6/d9/heappage_8c.html#a87">RtlpDphFreeDelayedBlocksFromHeap</a> (
00459     PVOID PageHeap,
00460     PVOID NormalHeap
00461     );
00462 
00463 <span class="comment">//</span>
00464 <span class="comment">// Decision normal heap vs. page heap</span>
00465 <span class="comment">//</span>
00466 
00467 <a class="code" href="../../d6/d9/heappage_8c.html#a88">RtlpDphShouldAllocateInPageHeap</a> (
00468     PDPH_HEAP_ROOT Heap,
00469     SIZE_T Size
00470     );
00471 
00472 <span class="comment">//</span>
00473 <span class="comment">// Stack trace detection for trace database.</span>
00474 <span class="comment">//</span>
00475 
00476 PRTL_TRACE_BLOCK 
00477 <a class="code" href="../../d6/d9/heappage_8c.html#a89">RtlpDphLogStackTrace</a> (
00478     ULONG FramesToSkip
00479     );
00480 
00481 <span class="comment">//</span>
00482 <span class="comment">//  Page heap general support functions</span>
00483 <span class="comment">//</span>
00484 
00485 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00486 <a class="code" href="../../d7/d9/heappage_8h.html#a30">RtlpDebugPageHeapBreak</a>(
00487     IN PCH Text
00488     );
00489 
00490 BOOLEAN
00491 <a class="code" href="../../d6/d9/heappage_8c.html#a91">RtlpDebugPageHeapAssert</a>(
00492     IN PCH Text
00493     );
00494 
00495 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00496 <a class="code" href="../../d6/d9/heappage_8c.html#a92">RtlpDebugPageHeapEnterCritSect</a>(
00497     IN PDPH_HEAP_ROOT HeapRoot,
00498     IN ULONG          Flags
00499     );
00500 
00501 <a class="code" href="../../d5/d3/filelock_8c.html#a1">INLINE</a>
00502 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00503 <a class="code" href="../../d6/d9/heappage_8c.html#a93">RtlpDebugPageHeapLeaveCritSect</a>(
00504     IN PDPH_HEAP_ROOT HeapRoot
00505     );
00506 
00507 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00508 <a class="code" href="../../d6/d9/heappage_8c.html#a94">RtlpDebugPageHeapException</a>(
00509     IN ULONG ExceptionCode
00510     );
00511 
00512 PVOID
00513 <a class="code" href="../../d6/d9/heappage_8c.html#a95">RtlpDebugPageHeapPointerFromHandle</a>(
00514     IN PVOID HeapHandle
00515     );
00516 
00517 PCCH
00518 <a class="code" href="../../d6/d9/heappage_8c.html#a96">RtlpDebugPageHeapProtectionText</a>(
00519     IN     ULONG Access,
00520     IN OUT PCHAR Buffer
00521     );
00522 
00523 <span class="comment">//</span>
00524 <span class="comment">// Virtual memory manipulation functions</span>
00525 <span class="comment">//</span>
00526 
00527 BOOLEAN
00528 <a class="code" href="../../d6/d9/heappage_8c.html#a97">RtlpDebugPageHeapRobustProtectVM</a>(
00529     IN PVOID   VirtualBase,
00530     IN SIZE_T  VirtualSize,
00531     IN ULONG   NewAccess,
00532     IN BOOLEAN Recursion
00533     );
00534 
00535 <a class="code" href="../../d5/d3/filelock_8c.html#a1">INLINE</a>
00536 BOOLEAN
00537 <a class="code" href="../../d6/d9/heappage_8c.html#a98">RtlpDebugPageHeapProtectVM</a>(
00538     IN PVOID   VirtualBase,
00539     IN SIZE_T  VirtualSize,
00540     IN ULONG   NewAccess
00541     );
00542 
00543 <a class="code" href="../../d5/d3/filelock_8c.html#a1">INLINE</a>
00544 PVOID
00545 <a class="code" href="../../d6/d9/heappage_8c.html#a99">RtlpDebugPageHeapAllocateVM</a>(
00546     IN SIZE_T nSize
00547     );
00548 
00549 <a class="code" href="../../d5/d3/filelock_8c.html#a1">INLINE</a>
00550 BOOLEAN
00551 <a class="code" href="../../d6/d9/heappage_8c.html#a100">RtlpDebugPageHeapReleaseVM</a>(
00552     IN PVOID pVirtual
00553     );
00554 
00555 <a class="code" href="../../d5/d3/filelock_8c.html#a1">INLINE</a>
00556 BOOLEAN
00557 <a class="code" href="../../d6/d9/heappage_8c.html#a101">RtlpDebugPageHeapCommitVM</a>(
00558     IN PVOID pVirtual,
00559     IN SIZE_T nSize
00560     );
00561 
00562 <a class="code" href="../../d5/d3/filelock_8c.html#a1">INLINE</a>
00563 BOOLEAN
00564 <a class="code" href="../../d6/d9/heappage_8c.html#a102">RtlpDebugPageHeapDecommitVM</a>(
00565     IN PVOID pVirtual,
00566     IN SIZE_T nSize
00567     );
00568 
00569 <span class="comment">//</span>
00570 <span class="comment">// Target dlls logic</span>
00571 <span class="comment">//</span>
00572 <span class="comment">// RtlpDphTargetDllsLoadCallBack is called in ntdll\ldrapi.c </span>
00573 <span class="comment">// (LdrpLoadDll) whenever a new dll is loaded in the process</span>
00574 <span class="comment">// space.</span>
00575 <span class="comment">//</span>
00576 
00577 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00578 <a class="code" href="../../d6/d9/heappage_8c.html#a103">RtlpDphTargetDllsLogicInitialize</a> (
00579     );
00580 
00581 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00582 <a class="code" href="../../d6/d9/heappage_8c.html#a104">RtlpDphTargetDllsLoadCallBack</a> (
00583     PUNICODE_STRING Name,
00584     PVOID Address,
00585     ULONG Size
00586     );
00587 
00588 <span class="keyword">const</span> WCHAR *
00589 <a class="code" href="../../d6/d9/heappage_8c.html#a105">RtlpDphIsDllTargeted</a> (
00590     <span class="keyword">const</span> WCHAR * Name
00591     );
00592 
00593 <span class="comment">//</span>
00594 <span class="comment">// Internal heap validation</span>
00595 <span class="comment">//</span>
00596 
00597 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00598 <a class="code" href="../../d6/d9/heappage_8c.html#a106">RtlpDphInternalValidatePageHeap</a> (
00599     PDPH_HEAP_ROOT Heap,
00600     PUCHAR ExemptAddress,
00601     SIZE_T ExemptSize
00602     );
00603 
00607 
00608 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00609"></a><a class="code" href="../../d6/d9/heappage_8c.html#a90">00609</a> <a class="code" href="../../d7/d9/heappage_8h.html#a30">RtlpDebugPageHeapBreak</a>(
00610     IN PCH Text
00611     )
00612 {
00613     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( Text );
00614     DbgBreakPoint();
00615 }
00616 
00617 BOOLEAN
<a name="l00618"></a><a class="code" href="../../d6/d9/heappage_8c.html#a91">00618</a> <a class="code" href="../../d6/d9/heappage_8c.html#a91">RtlpDebugPageHeapAssert</a>(
00619     IN PCH Text
00620     )
00621 {
00622     <a class="code" href="../../d7/d9/heappage_8h.html#a30">RtlpDebugPageHeapBreak</a>( Text );
00623     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00624 }
00625 
00626 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00627"></a><a class="code" href="../../d6/d9/heappage_8c.html#a92">00627</a> <a class="code" href="../../d6/d9/heappage_8c.html#a92">RtlpDebugPageHeapEnterCritSect</a>(
00628     IN PDPH_HEAP_ROOT HeapRoot,
00629     IN ULONG          Flags
00630     )
00631 {
00632     <span class="keywordflow">if</span> (Flags &amp; HEAP_NO_SERIALIZE) {
00633 
00634         <span class="keywordflow">if</span> (! RtlTryEnterCriticalSection( HeapRoot-&gt;HeapCritSect )) {
00635 
00636             <span class="keywordflow">if</span> (HeapRoot-&gt;nRemoteLockAcquired == 0) {
00637 
00638                 <span class="comment">//</span>
00639                 <span class="comment">//  Another thread owns the CritSect.  This is an application</span>
00640                 <span class="comment">//  bug since multithreaded access to heap was attempted with</span>
00641                 <span class="comment">//  the HEAP_NO_SERIALIZE flag specified.</span>
00642                 <span class="comment">//</span>
00643 
00644                 <a class="code" href="../../d7/d9/heappage_8h.html#a30">RtlpDebugPageHeapBreak</a>( <span class="stringliteral">"Page heap: Multithreaded access with HEAP_NO_SERIALIZE\n"</span> );
00645 
00646                 <span class="comment">//</span>
00647                 <span class="comment">//  In the interest of allowing the errant app to continue,</span>
00648                 <span class="comment">//  we'll force serialization and continue.</span>
00649                 <span class="comment">//</span>
00650 
00651                 HeapRoot-&gt;HeapFlags &amp;= ~HEAP_NO_SERIALIZE;
00652 
00653             }
00654 
00655             RtlEnterCriticalSection( HeapRoot-&gt;HeapCritSect );
00656 
00657         }
00658     }
00659     <span class="keywordflow">else</span> {
00660         RtlEnterCriticalSection( HeapRoot-&gt;HeapCritSect );
00661     }
00662 }
00663 
00664 <a class="code" href="../../d5/d3/filelock_8c.html#a1">INLINE</a>
00665 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00666"></a><a class="code" href="../../d6/d9/heappage_8c.html#a93">00666</a> <a class="code" href="../../d6/d9/heappage_8c.html#a93">RtlpDebugPageHeapLeaveCritSect</a>(
00667     IN PDPH_HEAP_ROOT HeapRoot
00668     )
00669 {
00670     RtlLeaveCriticalSection( HeapRoot-&gt;HeapCritSect );
00671 }
00672 
00673 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00674"></a><a class="code" href="../../d6/d9/heappage_8c.html#a94">00674</a> <a class="code" href="../../d6/d9/heappage_8c.html#a94">RtlpDebugPageHeapException</a>(
00675     IN ULONG ExceptionCode
00676     )
00677 {
00678     EXCEPTION_RECORD ER;
00679 
00680     ER.ExceptionCode    = ExceptionCode;
00681     ER.ExceptionFlags   = 0;
00682     ER.ExceptionRecord  = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00683     ER.ExceptionAddress = <a class="code" href="../../d6/d9/heappage_8c.html#a94">RtlpDebugPageHeapException</a>;
00684     ER.NumberParameters = 0;
00685     <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a9">RtlRaiseException</a>( &amp;ER );
00686 }
00687 
00688 PVOID
<a name="l00689"></a><a class="code" href="../../d6/d9/heappage_8c.html#a95">00689</a> <a class="code" href="../../d6/d9/heappage_8c.html#a95">RtlpDebugPageHeapPointerFromHandle</a>(
00690     IN PVOID HeapHandle
00691     )
00692 {
00693     <span class="keywordflow">try</span> {
00694         <span class="keywordflow">if</span> (((<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)(<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>))-&gt;ForceFlags &amp; <a class="code" href="../../d7/d9/heappage_8h.html#a1">HEAP_FLAG_PAGE_ALLOCS</a>) {
00695 
00696             PDPH_HEAP_ROOT HeapRoot = (PVOID)(((PCHAR)(<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>)) + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> );
00697 
00698             <span class="keywordflow">if</span> (HeapRoot-&gt;Signature == <a class="code" href="../../d6/d9/heappage_8c.html#a0">DPH_HEAP_SIGNATURE</a>) {
00699                 <span class="keywordflow">return</span> HeapRoot;
00700             }
00701         }
00702     }
00703     except( <a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a> ) {
00704     }
00705 
00706     <a class="code" href="../../d7/d9/heappage_8h.html#a30">RtlpDebugPageHeapBreak</a>( <span class="stringliteral">"Page heap: Bad heap handle\n"</span> );
00707     <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00708 }
00709 
00710 PCCH
<a name="l00711"></a><a class="code" href="../../d6/d9/heappage_8c.html#a96">00711</a> <a class="code" href="../../d6/d9/heappage_8c.html#a96">RtlpDebugPageHeapProtectionText</a>(
00712     IN     ULONG Access,
00713     IN OUT PCHAR Buffer
00714     )
00715 {
00716     <span class="keywordflow">switch</span> (Access) {
00717     <span class="keywordflow">case</span> PAGE_NOACCESS:          <span class="keywordflow">return</span> <span class="stringliteral">"PAGE_NOACCESS"</span>;
00718     <span class="keywordflow">case</span> PAGE_READONLY:          <span class="keywordflow">return</span> <span class="stringliteral">"PAGE_READONLY"</span>;
00719     <span class="keywordflow">case</span> PAGE_READWRITE:         <span class="keywordflow">return</span> <span class="stringliteral">"PAGE_READWRITE"</span>;
00720     <span class="keywordflow">case</span> PAGE_WRITECOPY:         <span class="keywordflow">return</span> <span class="stringliteral">"PAGE_WRITECOPY"</span>;
00721     <span class="keywordflow">case</span> PAGE_EXECUTE:           <span class="keywordflow">return</span> <span class="stringliteral">"PAGE_EXECUTE"</span>;
00722     <span class="keywordflow">case</span> PAGE_EXECUTE_READ:      <span class="keywordflow">return</span> <span class="stringliteral">"PAGE_EXECUTE_READ"</span>;
00723     <span class="keywordflow">case</span> PAGE_EXECUTE_READWRITE: <span class="keywordflow">return</span> <span class="stringliteral">"PAGE_EXECUTE_READWRITE"</span>;
00724     <span class="keywordflow">case</span> PAGE_EXECUTE_WRITECOPY: <span class="keywordflow">return</span> <span class="stringliteral">"PAGE_EXECUTE_WRITECOPY"</span>;
00725     <span class="keywordflow">case</span> PAGE_GUARD:             <span class="keywordflow">return</span> <span class="stringliteral">"PAGE_GUARD"</span>;
00726     <span class="keywordflow">case</span> 0:                      <span class="keywordflow">return</span> <span class="stringliteral">"UNKNOWN"</span>;
00727     <span class="keywordflow">default</span>:                     <a class="code" href="../../d6/d9/heappage_8c.html#a68">sprintf</a>( <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, <span class="stringliteral">"0x%08X"</span>, Access );
00728         <span class="keywordflow">return</span> <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>;
00729     }
00730 }
00731 
00735 
00736 BOOLEAN
<a name="l00737"></a><a class="code" href="../../d6/d9/heappage_8c.html#a97">00737</a> <a class="code" href="../../d6/d9/heappage_8c.html#a97">RtlpDebugPageHeapRobustProtectVM</a>(
00738     IN PVOID   VirtualBase,
00739     IN SIZE_T  VirtualSize,
00740     IN ULONG   NewAccess,
00741     IN BOOLEAN Recursion
00742     )
00743 {
00744     PVOID  CopyOfVirtualBase = VirtualBase;
00745     SIZE_T CopyOfVirtualSize = VirtualSize;
00746     ULONG  OldAccess;
00747     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00748 
00749     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwProtectVirtualMemory(
00750         NtCurrentProcess(),
00751         &amp;CopyOfVirtualBase,
00752         &amp;CopyOfVirtualSize,
00753         NewAccess,
00754         &amp;OldAccess
00755         );
00756 
00757     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ))
00758         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00759 
00760     <span class="keywordflow">if</span> (! Recursion) {
00761 
00762         <span class="comment">//</span>
00763         <span class="comment">//  We failed to change the protection on a range of memory.</span>
00764         <span class="comment">//  This can happen if if the range of memory spans more than</span>
00765         <span class="comment">//  one adjancent blocks allocated by separate calls to</span>
00766         <span class="comment">//  ZwAllocateVirtualMemory.  It also seems fails occasionally</span>
00767         <span class="comment">//  for reasons unknown to me, but always when attempting to</span>
00768         <span class="comment">//  change the protection on more than one page in a single call.</span>
00769         <span class="comment">//  So, fall back to changing pages individually in this range.</span>
00770         <span class="comment">//  This should be rare, so it should not be a performance problem.</span>
00771         <span class="comment">//</span>
00772 
00773         PCHAR VirtualExtent = (PCHAR)<a class="code" href="../../d6/d9/heappage_8c.html#a8">ROUNDUP2</a>((ULONG_PTR)((PCHAR)VirtualBase + VirtualSize ), <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> );
00774         PCHAR VirtualPage   = (PCHAR)((ULONG_PTR)VirtualBase &amp; ~( <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1 ));
00775         BOOLEAN SuccessAll  = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00776         BOOLEAN SuccessOne;
00777 
00778         <span class="keywordflow">while</span> (VirtualPage &lt; VirtualExtent) {
00779 
00780             SuccessOne = <a class="code" href="../../d6/d9/heappage_8c.html#a97">RtlpDebugPageHeapRobustProtectVM</a>(
00781                 VirtualPage,
00782                 <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>,
00783                 NewAccess,
00784                 <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>
00785                 );
00786 
00787             <span class="keywordflow">if</span> (! SuccessOne) {
00788                 SuccessAll = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00789             }
00790 
00791             VirtualPage += <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
00792 
00793         }
00794 
00795         <span class="keywordflow">return</span> SuccessAll;      <span class="comment">// TRUE if all succeeded, FALSE if any failed</span>
00796     }
00797 
00798     <span class="keywordflow">else</span> {
00799 
00800         MEMORY_BASIC_INFORMATION mbi;
00801         <a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a> OldProtectionText[ 12 ];     <span class="comment">// big enough for "0x12345678"</span>
00802         <a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a> NewProtectionText[ 12 ];     <span class="comment">// big enough for "0x12345678"</span>
00803 
00804         mbi.Protect = 0;    <span class="comment">// in case ZwQueryVirtualMemory fails</span>
00805 
00806         ZwQueryVirtualMemory(
00807             NtCurrentProcess(),
00808             VirtualBase,
00809             MemoryBasicInformation,
00810             &amp;mbi,
00811             <span class="keyword">sizeof</span>( mbi ),
00812             <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
00813             );
00814 
00815         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(
00816             <span class="stringliteral">"Page heap: Failed changing VM at %08X size 0x%X\n"</span>
00817             <span class="stringliteral">"          from %s to %s (Status %08X)\n"</span>,
00818             VirtualBase,
00819             VirtualSize,
00820             <a class="code" href="../../d6/d9/heappage_8c.html#a96">RtlpDebugPageHeapProtectionText</a>( mbi.Protect, OldProtectionText ),
00821             <a class="code" href="../../d6/d9/heappage_8c.html#a96">RtlpDebugPageHeapProtectionText</a>( NewAccess, NewProtectionText ),
00822             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>
00823             );
00824     }
00825 
00826     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00827 }
00828 
00829 <a class="code" href="../../d5/d3/filelock_8c.html#a1">INLINE</a>
00830 BOOLEAN
<a name="l00831"></a><a class="code" href="../../d6/d9/heappage_8c.html#a98">00831</a> <a class="code" href="../../d6/d9/heappage_8c.html#a98">RtlpDebugPageHeapProtectVM</a>(
00832     IN PVOID   VirtualBase,
00833     IN SIZE_T  VirtualSize,
00834     IN ULONG   NewAccess
00835     )
00836 {
00837     <span class="keywordflow">return</span> <a class="code" href="../../d6/d9/heappage_8c.html#a97">RtlpDebugPageHeapRobustProtectVM</a>( VirtualBase, VirtualSize, NewAccess, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00838 }
00839 
00840 <a class="code" href="../../d5/d3/filelock_8c.html#a1">INLINE</a>
00841 PVOID
<a name="l00842"></a><a class="code" href="../../d6/d9/heappage_8c.html#a99">00842</a> <a class="code" href="../../d6/d9/heappage_8c.html#a99">RtlpDebugPageHeapAllocateVM</a>(
00843     IN SIZE_T nSize
00844     )
00845 {
00846     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00847     PVOID pVirtual;
00848 
00849     pVirtual = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00850 
00851     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwAllocateVirtualMemory( NtCurrentProcess(),
00852         &amp;pVirtual,
00853         0,
00854         &amp;nSize,
00855         MEM_COMMIT,
00856         PAGE_NOACCESS );
00857 
00858     <span class="keywordflow">return</span> <a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ) ? pVirtual : <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00859 }
00860 
00861 <a class="code" href="../../d5/d3/filelock_8c.html#a1">INLINE</a>
00862 BOOLEAN
<a name="l00863"></a><a class="code" href="../../d6/d9/heappage_8c.html#a100">00863</a> <a class="code" href="../../d6/d9/heappage_8c.html#a100">RtlpDebugPageHeapReleaseVM</a>(
00864     IN PVOID pVirtual
00865     )
00866 {
00867     SIZE_T nSize = 0;
00868 
00869     <span class="keywordflow">return</span> <a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( ZwFreeVirtualMemory( NtCurrentProcess(),
00870         &amp;pVirtual,
00871         &amp;nSize,
00872         MEM_RELEASE ));
00873 }
00874 
00875 <a class="code" href="../../d5/d3/filelock_8c.html#a1">INLINE</a>
00876 BOOLEAN
<a name="l00877"></a><a class="code" href="../../d6/d9/heappage_8c.html#a101">00877</a> <a class="code" href="../../d6/d9/heappage_8c.html#a101">RtlpDebugPageHeapCommitVM</a>(
00878     IN PVOID pVirtual,
00879     IN SIZE_T nSize
00880     )
00881 {
00882     PCHAR pStart, pEnd, pCurrent;
00883     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00884     SIZE_T CommitSize;
00885     BOOLEAN Failed = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00886 
00887     pStart = (PCHAR)((ULONG_PTR)pVirtual &amp; ~(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1));
00888     pEnd = (PCHAR)(((ULONG_PTR)pVirtual + nSize) &amp; ~(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1));
00889 
00890     <span class="keywordflow">for</span> (pCurrent = pStart; pCurrent &lt; pEnd; pCurrent += <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>) {
00891 
00892         CommitSize = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
00893 
00894         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwAllocateVirtualMemory(
00895             NtCurrentProcess(),
00896             &amp;pCurrent,
00897             0,
00898             &amp;CommitSize,
00899             MEM_COMMIT,
00900             PAGE_NOACCESS);
00901 
00902         <span class="keywordflow">if</span> (! <a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
00903 
00904             <span class="comment">//</span>
00905             <span class="comment">// The call can fail in low memory conditions. In this case we</span>
00906             <span class="comment">// try to recover and will probably fail the original allocation.</span>
00907             <span class="comment">//</span>
00908 
00909             <span class="keywordflow">if</span> ((<a class="code" href="../../d6/d9/heappage_8c.html#a51">RtlpDphDebugLevel</a> &amp; <a class="code" href="../../d6/d9/heappage_8c.html#a27">DPH_DEBUG_DECOMMIT_RANGES</a>)) {
00910                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a> (<span class="stringliteral">"Page heap: Commit (%p) failed with %08X\n"</span>, pCurrent, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>);
00911                 DbgBreakPoint();
00912             }
00913 
00914             Failed = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00915             <span class="keywordflow">break</span>;
00916         }
00917     }
00918 
00919 
00920     <span class="keywordflow">if</span> (Failed) {
00921 
00922         <span class="comment">//</span>
00923         <span class="comment">// We need to roll back whatever succeeded.</span>
00924         <span class="comment">//</span>
00925 
00926         <span class="keywordflow">for</span> (pCurrent -= <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>; pCurrent &gt;= pStart &amp;&amp; pCurrent &lt; pEnd; pCurrent -= <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>) {
00927 
00928             CommitSize = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
00929 
00930             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwFreeVirtualMemory(
00931                 NtCurrentProcess(),
00932                 &amp;pCurrent,
00933                 &amp;CommitSize,
00934                 MEM_DECOMMIT);
00935 
00936             <span class="keywordflow">if</span> (! <a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
00937 
00938                 <span class="comment">//</span>
00939                 <span class="comment">// There is now valid reason known to me for a correct free operation</span>
00940                 <span class="comment">// failure. So, in this case we make a little bit of fuss about it.</span>
00941                 <span class="comment">//</span>
00942 
00943                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a> (<span class="stringliteral">"Page heap: Decommit (%p) failed with %08X\n"</span>, pCurrent, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>);
00944 
00945                 <span class="keywordflow">if</span> ((<a class="code" href="../../d6/d9/heappage_8c.html#a51">RtlpDphDebugLevel</a> &amp; <a class="code" href="../../d6/d9/heappage_8c.html#a27">DPH_DEBUG_DECOMMIT_RANGES</a>)) {
00946                     DbgBreakPoint();
00947                 }
00948             }
00949         }
00950     }
00951 
00952     <span class="keywordflow">if</span> (Failed) {
00953         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00954     }
00955     <span class="keywordflow">else</span> {
00956         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00957     }
00958 }
00959 
00960 <a class="code" href="../../d5/d3/filelock_8c.html#a1">INLINE</a>
00961 BOOLEAN
<a name="l00962"></a><a class="code" href="../../d6/d9/heappage_8c.html#a102">00962</a> <a class="code" href="../../d6/d9/heappage_8c.html#a102">RtlpDebugPageHeapDecommitVM</a>(
00963     IN PVOID pVirtual,
00964     IN SIZE_T nSize
00965     )
00966 {
00967     PCHAR pStart, pEnd, pCurrent;
00968     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00969     SIZE_T DecommitSize;
00970     BOOLEAN Failed = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00971 
00972     pStart = (PCHAR)((ULONG_PTR)pVirtual &amp; ~(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1));
00973     pEnd = (PCHAR)(((ULONG_PTR)pVirtual + nSize) &amp; ~(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1));
00974 
00975     <span class="keywordflow">for</span> (pCurrent = pStart; pCurrent &lt; pEnd; pCurrent += <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>) {
00976 
00977         DecommitSize = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
00978 
00979         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwFreeVirtualMemory(
00980             NtCurrentProcess(),
00981             &amp;pCurrent,
00982             &amp;DecommitSize,
00983             MEM_DECOMMIT);
00984 
00985         <span class="keywordflow">if</span> (! <a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
00986 
00987             <span class="comment">//</span>
00988             <span class="comment">// There is now valid reason known to me for a correct free operation</span>
00989             <span class="comment">// failure. So, in this case we make a little bit of fuss about it.</span>
00990             <span class="comment">//</span>
00991 
00992             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a> (<span class="stringliteral">"Page heap: Decommit (%p) failed with %08X\n"</span>, pCurrent, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>);
00993 
00994             <span class="keywordflow">if</span> ((<a class="code" href="../../d6/d9/heappage_8c.html#a51">RtlpDphDebugLevel</a> &amp; <a class="code" href="../../d6/d9/heappage_8c.html#a27">DPH_DEBUG_DECOMMIT_RANGES</a>)) {
00995                 DbgBreakPoint();
00996             }
00997 
00998             Failed = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00999         }
01000     }
01001 
01002     <span class="keywordflow">if</span> (Failed) {
01003         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01004     }
01005     <span class="keywordflow">else</span> {
01006         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01007     }
01008 }
01009 
01013 
01014 PDPH_HEAP_BLOCK
<a name="l01015"></a><a class="code" href="../../d6/d9/heappage_8c.html#a107">01015</a> <a class="code" href="../../d6/d9/heappage_8c.html#a107">RtlpDebugPageHeapTakeNodeFromUnusedList</a>(
01016     IN PDPH_HEAP_ROOT pHeap
01017     )
01018 {
01019     PDPH_HEAP_BLOCK pNode = pHeap-&gt;pUnusedNodeListHead;
01020     PDPH_HEAP_BLOCK pPrev = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01021 
01022     <span class="comment">//</span>
01023     <span class="comment">//  UnusedNodeList is LIFO with most recent entry at head of list.</span>
01024     <span class="comment">//</span>
01025 
01026     <span class="keywordflow">if</span> (pNode) {
01027 
01028         <a class="code" href="../../d6/d9/heappage_8c.html#a17">DEQUEUE_NODE</a>( pNode, pPrev, pHeap-&gt;pUnusedNodeListHead, pHeap-&gt;pUnusedNodeListTail );
01029 
01030         pHeap-&gt;nUnusedNodes -= 1;
01031 
01032     }
01033 
01034     <span class="keywordflow">return</span> pNode;
01035 }
01036 
01037 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01038"></a><a class="code" href="../../d6/d9/heappage_8c.html#a108">01038</a> <a class="code" href="../../d6/d9/heappage_8c.html#a108">RtlpDebugPageHeapReturnNodeToUnusedList</a>(
01039     IN PDPH_HEAP_ROOT       pHeap,
01040     IN PDPH_HEAP_BLOCK pNode
01041     )
01042 {
01043     <span class="comment">//</span>
01044     <span class="comment">//  UnusedNodeList is LIFO with most recent entry at head of list.</span>
01045     <span class="comment">//</span>
01046 
01047     <a class="code" href="../../d6/d9/heappage_8c.html#a15">ENQUEUE_HEAD</a>( pNode, pHeap-&gt;pUnusedNodeListHead, pHeap-&gt;pUnusedNodeListTail );
01048 
01049     pHeap-&gt;nUnusedNodes += 1;
01050 }
01051 
01052 PDPH_HEAP_BLOCK
<a name="l01053"></a><a class="code" href="../../d6/d9/heappage_8c.html#a109">01053</a> <a class="code" href="../../d6/d9/heappage_8c.html#a109">RtlpDebugPageHeapFindBusyMem</a>(
01054     IN  PDPH_HEAP_ROOT        pHeap,
01055     IN  PVOID                 pUserMem,
01056     OUT PDPH_HEAP_BLOCK *pPrevAlloc
01057     )
01058 {
01059     PDPH_HEAP_BLOCK pNode = pHeap-&gt;pBusyAllocationListHead;
01060     PDPH_HEAP_BLOCK pPrev = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01061 
01062     <span class="keywordflow">while</span> (pNode != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01063 
01064         <span class="keywordflow">if</span> (pNode-&gt;pUserAllocation == pUserMem) {
01065 
01066             <span class="keywordflow">if</span> (pPrevAlloc)
01067                 *pPrevAlloc = pPrev;
01068 
01069             <span class="keywordflow">return</span> pNode;
01070         }
01071 
01072         pPrev = pNode;
01073         pNode = pNode-&gt;pNextAlloc;
01074     }
01075 
01076     <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01077 }
01078 
01079 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01080"></a><a class="code" href="../../d6/d9/heappage_8c.html#a110">01080</a> <a class="code" href="../../d6/d9/heappage_8c.html#a110">RtlpDebugPageHeapRemoveFromAvailableList</a>(
01081     IN PDPH_HEAP_ROOT       pHeap,
01082     IN PDPH_HEAP_BLOCK pNode,
01083     IN PDPH_HEAP_BLOCK pPrev
01084     )
01085 {
01086     <a class="code" href="../../d6/d9/heappage_8c.html#a17">DEQUEUE_NODE</a>( pNode, pPrev, pHeap-&gt;pAvailableAllocationListHead, pHeap-&gt;pAvailableAllocationListTail );
01087 
01088     pHeap-&gt;nAvailableAllocations -= 1;
01089     pHeap-&gt;nAvailableAllocationBytesCommitted -= pNode-&gt;nVirtualBlockSize;
01090 }
01091 
01092 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01093"></a><a class="code" href="../../d6/d9/heappage_8c.html#a111">01093</a> <a class="code" href="../../d6/d9/heappage_8c.html#a111">RtlpDebugPageHeapPlaceOnFreeList</a>(
01094     IN PDPH_HEAP_ROOT       pHeap,
01095     IN PDPH_HEAP_BLOCK pAlloc
01096     )
01097 {
01098     <span class="comment">//</span>
01099     <span class="comment">//  FreeAllocationList is stored FIFO to enhance finding</span>
01100     <span class="comment">//  reference-after-freed bugs by keeping previously freed</span>
01101     <span class="comment">//  allocations on the free list as long as possible.</span>
01102     <span class="comment">//</span>
01103 
01104     pAlloc-&gt;pNextAlloc = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01105 
01106     <a class="code" href="../../d6/d9/heappage_8c.html#a16">ENQUEUE_TAIL</a>( pAlloc, pHeap-&gt;pFreeAllocationListHead, pHeap-&gt;pFreeAllocationListTail );
01107 
01108     pHeap-&gt;nFreeAllocations += 1;
01109     pHeap-&gt;nFreeAllocationBytesCommitted += pAlloc-&gt;nVirtualBlockSize;
01110 }
01111 
01112 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01113"></a><a class="code" href="../../d6/d9/heappage_8c.html#a112">01113</a> <a class="code" href="../../d6/d9/heappage_8c.html#a112">RtlpDebugPageHeapRemoveFromFreeList</a>(
01114     IN PDPH_HEAP_ROOT       pHeap,
01115     IN PDPH_HEAP_BLOCK pNode,
01116     IN PDPH_HEAP_BLOCK pPrev
01117     )
01118 {
01119     <a class="code" href="../../d6/d9/heappage_8c.html#a17">DEQUEUE_NODE</a>( pNode, pPrev, pHeap-&gt;pFreeAllocationListHead, pHeap-&gt;pFreeAllocationListTail );
01120 
01121     pHeap-&gt;nFreeAllocations -= 1;
01122     pHeap-&gt;nFreeAllocationBytesCommitted -= pNode-&gt;nVirtualBlockSize;
01123 
01124     pNode-&gt;StackTrace = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01125 }
01126 
01127 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01128"></a><a class="code" href="../../d6/d9/heappage_8c.html#a113">01128</a> <a class="code" href="../../d6/d9/heappage_8c.html#a113">RtlpDebugPageHeapPlaceOnVirtualList</a>(
01129     IN PDPH_HEAP_ROOT       pHeap,
01130     IN PDPH_HEAP_BLOCK pNode
01131     )
01132 {
01133     <span class="comment">//</span>
01134     <span class="comment">//  VirtualStorageList is LIFO so that releasing VM blocks will</span>
01135     <span class="comment">//  occur in exact reverse order.</span>
01136     <span class="comment">//</span>
01137 
01138     <a class="code" href="../../d6/d9/heappage_8c.html#a15">ENQUEUE_HEAD</a>( pNode, pHeap-&gt;pVirtualStorageListHead, pHeap-&gt;pVirtualStorageListTail );
01139 
01140     pHeap-&gt;nVirtualStorageRanges += 1;
01141     pHeap-&gt;nVirtualStorageBytes += pNode-&gt;nVirtualBlockSize;
01142 }
01143 
01144 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01145"></a><a class="code" href="../../d6/d9/heappage_8c.html#a114">01145</a> <a class="code" href="../../d6/d9/heappage_8c.html#a114">RtlpDebugPageHeapPlaceOnBusyList</a>(
01146     IN PDPH_HEAP_ROOT       pHeap,
01147     IN PDPH_HEAP_BLOCK pNode
01148     )
01149 {
01150     <span class="comment">//</span>
01151     <span class="comment">//  BusyAllocationList is LIFO to achieve better temporal locality</span>
01152     <span class="comment">//  of reference (older allocations are farther down the list).</span>
01153     <span class="comment">//</span>
01154 
01155     <a class="code" href="../../d6/d9/heappage_8c.html#a15">ENQUEUE_HEAD</a>( pNode, pHeap-&gt;pBusyAllocationListHead, pHeap-&gt;pBusyAllocationListTail );
01156 
01157     pHeap-&gt;nBusyAllocations += 1;
01158     pHeap-&gt;nBusyAllocationBytesCommitted  += pNode-&gt;nVirtualBlockSize;
01159     pHeap-&gt;nBusyAllocationBytesAccessible += pNode-&gt;nVirtualAccessSize;
01160 }
01161 
01162 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01163"></a><a class="code" href="../../d6/d9/heappage_8c.html#a115">01163</a> <a class="code" href="../../d6/d9/heappage_8c.html#a115">RtlpDebugPageHeapRemoveFromBusyList</a>(
01164     IN PDPH_HEAP_ROOT       pHeap,
01165     IN PDPH_HEAP_BLOCK pNode,
01166     IN PDPH_HEAP_BLOCK pPrev
01167     )
01168 {
01169     <a class="code" href="../../d6/d9/heappage_8c.html#a17">DEQUEUE_NODE</a>( pNode, pPrev, pHeap-&gt;pBusyAllocationListHead, pHeap-&gt;pBusyAllocationListTail );
01170 
01171     pHeap-&gt;nBusyAllocations -= 1;
01172     pHeap-&gt;nBusyAllocationBytesCommitted  -= pNode-&gt;nVirtualBlockSize;
01173     pHeap-&gt;nBusyAllocationBytesAccessible -= pNode-&gt;nVirtualAccessSize;
01174 }
01175 
01176 PDPH_HEAP_BLOCK
<a name="l01177"></a><a class="code" href="../../d6/d9/heappage_8c.html#a116">01177</a> <a class="code" href="../../d6/d9/heappage_8c.html#a116">RtlpDebugPageHeapSearchAvailableMemListForBestFit</a>(
01178     IN  PDPH_HEAP_ROOT        pHeap,
01179     IN  SIZE_T                nSize,
01180     OUT PDPH_HEAP_BLOCK *pPrevAvailNode
01181     )
01182 {
01183     PDPH_HEAP_BLOCK pAvail, pFound, pAvailPrev, pFoundPrev;
01184     SIZE_T nAvail, nFound;
01185 
01186     nFound     = 0x7FFFFFFF;
01187     pFound     = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01188     pFoundPrev = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01189     pAvailPrev = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01190     pAvail     = pHeap-&gt;pAvailableAllocationListHead;
01191 
01192     <span class="keywordflow">while</span> (( pAvail != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) &amp;&amp; ( nFound &gt; nSize )) {
01193 
01194         nAvail = pAvail-&gt;nVirtualBlockSize;
01195 
01196         <span class="keywordflow">if</span> (( nAvail &gt;= nSize ) &amp;&amp; ( nAvail &lt; nFound )) {
01197             nFound     = nAvail;
01198             pFound     = pAvail;
01199             pFoundPrev = pAvailPrev;
01200         }
01201 
01202         pAvailPrev = pAvail;
01203         pAvail     = pAvail-&gt;pNextAlloc;
01204     }
01205 
01206     *pPrevAvailNode = pFoundPrev;
01207     <span class="keywordflow">return</span> pFound;
01208 }
01209 
01210 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01211"></a><a class="code" href="../../d6/d9/heappage_8c.html#a117">01211</a> <a class="code" href="../../d6/d9/heappage_8c.html#a117">RtlpDebugPageHeapCoalesceNodeIntoAvailable</a>(
01212     IN PDPH_HEAP_ROOT pHeap,
01213     IN PDPH_HEAP_BLOCK pNode
01214     )
01215 {
01216     PDPH_HEAP_BLOCK pPrev;
01217     PDPH_HEAP_BLOCK pNext;
01218     PUCHAR pVirtual;
01219     SIZE_T nVirtual;
01220 
01221     pPrev = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01222     pNext = pHeap-&gt;pAvailableAllocationListHead;
01223 
01224     pVirtual = pNode-&gt;pVirtualBlock;
01225     nVirtual = pNode-&gt;nVirtualBlockSize;
01226     
01227     pHeap-&gt;nAvailableAllocationBytesCommitted += nVirtual;
01228     pHeap-&gt;nAvailableAllocations += 1;
01229 
01230     <span class="comment">//</span>
01231     <span class="comment">//  Walk list to insertion point.</span>
01232     <span class="comment">//</span>
01233 
01234     <span class="keywordflow">while</span> (( pNext ) &amp;&amp; ( pNext-&gt;pVirtualBlock &lt; pVirtual )) {
01235         pPrev = pNext;
01236         pNext = pNext-&gt;pNextAlloc;
01237     }
01238 
01239     <span class="keywordflow">if</span> (pPrev) {
01240 
01241         <span class="keywordflow">if</span> (( pPrev-&gt;pVirtualBlock + pPrev-&gt;nVirtualBlockSize ) == pVirtual) {
01242 
01243             <span class="comment">//</span>
01244             <span class="comment">//  pPrev and pNode are adjacent, so simply add size of</span>
01245             <span class="comment">//  pNode entry to pPrev entry.</span>
01246             <span class="comment">//</span>
01247 
01248             pPrev-&gt;nVirtualBlockSize += nVirtual;
01249 
01250             <a class="code" href="../../d6/d9/heappage_8c.html#a108">RtlpDebugPageHeapReturnNodeToUnusedList</a>( pHeap, pNode );
01251 
01252             pHeap-&gt;nAvailableAllocations--;
01253 
01254             pNode    = pPrev;
01255             pVirtual = pPrev-&gt;pVirtualBlock;
01256             nVirtual = pPrev-&gt;nVirtualBlockSize;
01257 
01258         }
01259 
01260         <span class="keywordflow">else</span> {
01261 
01262             <span class="comment">//</span>
01263             <span class="comment">//  pPrev and pNode are not adjacent, so insert the pNode</span>
01264             <span class="comment">//  block into the list after pPrev.</span>
01265             <span class="comment">//</span>
01266 
01267             pNode-&gt;pNextAlloc = pPrev-&gt;pNextAlloc;
01268             pPrev-&gt;pNextAlloc = pNode;
01269 
01270         }
01271     }
01272 
01273     <span class="keywordflow">else</span> {
01274 
01275         <span class="comment">//</span>
01276         <span class="comment">//  pNode should be inserted at head of list.</span>
01277         <span class="comment">//</span>
01278 
01279         pNode-&gt;pNextAlloc = pHeap-&gt;pAvailableAllocationListHead;
01280         pHeap-&gt;pAvailableAllocationListHead = pNode;
01281 
01282     }
01283 
01284 
01285     <span class="keywordflow">if</span> (pNext) {
01286 
01287         <span class="keywordflow">if</span> (( pVirtual + nVirtual ) == pNext-&gt;pVirtualBlock) {
01288 
01289             <span class="comment">//</span>
01290             <span class="comment">//  pNode and pNext are adjacent, so simply add size of</span>
01291             <span class="comment">//  pNext entry to pNode entry and remove pNext entry</span>
01292             <span class="comment">//  from the list.</span>
01293             <span class="comment">//</span>
01294 
01295             pNode-&gt;nVirtualBlockSize += pNext-&gt;nVirtualBlockSize;
01296 
01297             pNode-&gt;pNextAlloc = pNext-&gt;pNextAlloc;
01298 
01299             <span class="keywordflow">if</span> (pHeap-&gt;pAvailableAllocationListTail == pNext) {
01300                 pHeap-&gt;pAvailableAllocationListTail = pNode;
01301             }
01302 
01303             <a class="code" href="../../d6/d9/heappage_8c.html#a108">RtlpDebugPageHeapReturnNodeToUnusedList</a>( pHeap, pNext );
01304 
01305             pHeap-&gt;nAvailableAllocations--;
01306 
01307         }
01308     }
01309 
01310     <span class="keywordflow">else</span> {
01311 
01312         <span class="comment">//</span>
01313         <span class="comment">//  pNode is tail of list.</span>
01314         <span class="comment">//</span>
01315 
01316         pHeap-&gt;pAvailableAllocationListTail = pNode;
01317 
01318     }
01319 }
01320 
01321 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01322"></a><a class="code" href="../../d6/d9/heappage_8c.html#a118">01322</a> <a class="code" href="../../d6/d9/heappage_8c.html#a118">RtlpDebugPageHeapCoalesceFreeIntoAvailable</a>(
01323     IN PDPH_HEAP_ROOT pHeap,
01324     IN ULONG          nLeaveOnFreeList
01325     )
01326 {
01327     PDPH_HEAP_BLOCK pNode = pHeap-&gt;pFreeAllocationListHead;
01328     SIZE_T               nFree = pHeap-&gt;nFreeAllocations;
01329     PDPH_HEAP_BLOCK pNext;
01330 
01331     <a class="code" href="../../d6/d9/heappage_8c.html#a11">DEBUG_ASSERT</a>( nFree &gt;= nLeaveOnFreeList );
01332 
01333     <span class="keywordflow">while</span> (( pNode ) &amp;&amp; ( nFree-- &gt; nLeaveOnFreeList )) {
01334 
01335         pNext = pNode-&gt;pNextAlloc;  <span class="comment">// preserve next pointer across shuffling</span>
01336 
01337         <a class="code" href="../../d6/d9/heappage_8c.html#a112">RtlpDebugPageHeapRemoveFromFreeList</a>( pHeap, pNode, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01338 
01339         <a class="code" href="../../d6/d9/heappage_8c.html#a117">RtlpDebugPageHeapCoalesceNodeIntoAvailable</a>( pHeap, pNode );
01340 
01341         pNode = pNext;
01342 
01343     }
01344 
01345     <a class="code" href="../../d6/d9/heappage_8c.html#a11">DEBUG_ASSERT</a>(( nFree = (<span class="keyword">volatile</span> SIZE_T)( pHeap-&gt;nFreeAllocations )) &gt;= nLeaveOnFreeList );
01346     <a class="code" href="../../d6/d9/heappage_8c.html#a11">DEBUG_ASSERT</a>(( pNode != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) || ( nFree == 0 ));
01347 
01348 }
01349 
01350 <span class="comment">// forward</span>
01351 BOOLEAN
01352 <a class="code" href="../../d6/d9/heappage_8c.html#a119">RtlpDebugPageHeapGrowVirtual</a>(
01353     IN PDPH_HEAP_ROOT pHeap,
01354     IN SIZE_T         nSize
01355     );
01356 
01357 PDPH_HEAP_BLOCK
<a name="l01358"></a><a class="code" href="../../d6/d9/heappage_8c.html#a120">01358</a> <a class="code" href="../../d6/d9/heappage_8c.html#a120">RtlpDebugPageHeapFindAvailableMem</a>(
01359     IN  PDPH_HEAP_ROOT        pHeap,
01360     IN  SIZE_T                nSize,
01361     OUT PDPH_HEAP_BLOCK *pPrevAvailNode,
01362     IN  BOOLEAN               bGrowVirtual
01363     )
01364 {
01365     PDPH_HEAP_BLOCK pAvail;
01366     ULONG                nLeaveOnFreeList;
01367 
01368     <span class="comment">//</span>
01369     <span class="comment">// If we use uncommitted ranges it is really important to</span>
01370     <span class="comment">// call FindAvailableMemory only with page aligned sizes.</span>
01371     <span class="comment">//</span>
01372 
01373     <span class="keywordflow">if</span> ((pHeap-&gt;ExtraFlags &amp; PAGE_HEAP_SMART_MEMORY_USAGE)) {
01374         <a class="code" href="../../d6/d9/heappage_8c.html#a11">DEBUG_ASSERT</a> ((nSize &amp; ~(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) == nSize);
01375     }
01376 
01377     <span class="comment">//</span>
01378     <span class="comment">//  First search existing AvailableList for a "best-fit" block</span>
01379     <span class="comment">//  (the smallest block that will satisfy the request).</span>
01380     <span class="comment">//</span>
01381 
01382     pAvail = <a class="code" href="../../d6/d9/heappage_8c.html#a116">RtlpDebugPageHeapSearchAvailableMemListForBestFit</a>(
01383         pHeap,
01384         nSize,
01385         pPrevAvailNode
01386         );
01387 
01388     <span class="keywordflow">while</span> (( pAvail == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) &amp;&amp; ( pHeap-&gt;nFreeAllocations &gt; <a class="code" href="../../d6/d9/heappage_8c.html#a7">MIN_FREE_LIST_LENGTH</a> )) {
01389 
01390         <span class="comment">//</span>
01391         <span class="comment">//  Failed to find sufficient memory on AvailableList.  Coalesce</span>
01392         <span class="comment">//  3/4 of the FreeList memory to the AvailableList and try again.</span>
01393         <span class="comment">//  Continue this until we have sufficient memory in AvailableList,</span>
01394         <span class="comment">//  or the FreeList length is reduced to MIN_FREE_LIST_LENGTH entries.</span>
01395         <span class="comment">//  We don't shrink the FreeList length below MIN_FREE_LIST_LENGTH</span>
01396         <span class="comment">//  entries to preserve the most recent MIN_FREE_LIST_LENGTH entries</span>
01397         <span class="comment">//  for reference-after-freed purposes.</span>
01398         <span class="comment">//</span>
01399 
01400         nLeaveOnFreeList = pHeap-&gt;nFreeAllocations / 4;
01401 
01402         <span class="keywordflow">if</span> (nLeaveOnFreeList &lt; <a class="code" href="../../d6/d9/heappage_8c.html#a7">MIN_FREE_LIST_LENGTH</a>)
01403             nLeaveOnFreeList = <a class="code" href="../../d6/d9/heappage_8c.html#a7">MIN_FREE_LIST_LENGTH</a>;
01404 
01405         <a class="code" href="../../d6/d9/heappage_8c.html#a118">RtlpDebugPageHeapCoalesceFreeIntoAvailable</a>( pHeap, nLeaveOnFreeList );
01406 
01407         pAvail = <a class="code" href="../../d6/d9/heappage_8c.html#a116">RtlpDebugPageHeapSearchAvailableMemListForBestFit</a>(
01408             pHeap,
01409             nSize,
01410             pPrevAvailNode
01411             );
01412 
01413     }
01414 
01415 
01416     <span class="keywordflow">if</span> (( pAvail == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) &amp;&amp; ( bGrowVirtual )) {
01417 
01418         <span class="comment">//</span>
01419         <span class="comment">//  After coalescing FreeList into AvailableList, still don't have</span>
01420         <span class="comment">//  enough memory (large enough block) to satisfy request, so we</span>
01421         <span class="comment">//  need to allocate more VM.</span>
01422         <span class="comment">//</span>
01423 
01424         <span class="keywordflow">if</span> (<a class="code" href="../../d6/d9/heappage_8c.html#a119">RtlpDebugPageHeapGrowVirtual</a>( pHeap, nSize )) {
01425 
01426             pAvail = <a class="code" href="../../d6/d9/heappage_8c.html#a116">RtlpDebugPageHeapSearchAvailableMemListForBestFit</a>(
01427                 pHeap,
01428                 nSize,
01429                 pPrevAvailNode
01430                 );
01431 
01432             <span class="keywordflow">if</span> (pAvail == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01433 
01434                 <span class="comment">//</span>
01435                 <span class="comment">//  Failed to satisfy request with more VM.  If remainder</span>
01436                 <span class="comment">//  of free list combined with available list is larger</span>
01437                 <span class="comment">//  than the request, we might still be able to satisfy</span>
01438                 <span class="comment">//  the request by merging all of the free list onto the</span>
01439                 <span class="comment">//  available list.  Note we lose our MIN_FREE_LIST_LENGTH</span>
01440                 <span class="comment">//  reference-after-freed insurance in this case, but it</span>
01441                 <span class="comment">//  is a rare case, and we'd prefer to satisfy the allocation.</span>
01442                 <span class="comment">//</span>
01443 
01444                 <span class="keywordflow">if</span> (( pHeap-&gt;nFreeAllocationBytesCommitted +
01445                     pHeap-&gt;nAvailableAllocationBytesCommitted ) &gt;= nSize) {
01446 
01447                     <a class="code" href="../../d6/d9/heappage_8c.html#a118">RtlpDebugPageHeapCoalesceFreeIntoAvailable</a>( pHeap, 0 );
01448 
01449                     pAvail = <a class="code" href="../../d6/d9/heappage_8c.html#a116">RtlpDebugPageHeapSearchAvailableMemListForBestFit</a>(
01450                         pHeap,
01451                         nSize,
01452                         pPrevAvailNode
01453                         );
01454                 }
01455             }
01456         }
01457     }
01458 
01459     <span class="comment">//</span>
01460     <span class="comment">// If we use uncommitted ranges we need to commit the memory</span>
01461     <span class="comment">// range now. Note that the memory will be committed but</span>
01462     <span class="comment">// the protection on it will be N/A. </span>
01463     <span class="comment">//</span>
01464 
01465     <span class="keywordflow">if</span> (pAvail &amp;&amp; (pHeap-&gt;ExtraFlags &amp; PAGE_HEAP_SMART_MEMORY_USAGE)) {
01466 
01467         BOOLEAN Success;
01468 
01469         <span class="comment">//</span>
01470         <span class="comment">// (SilviuC): The memory here might be already committed if we use</span>
01471         <span class="comment">// it for the first time. Whenever we allocate virtual memory to grow</span>
01472         <span class="comment">// the heap we commit it. This is the reason the consumption does not </span>
01473         <span class="comment">// decrease as spectacular as we expected. We need to fix it.</span>
01474         <span class="comment">// It affects 0x43 flags.</span>
01475         <span class="comment">//</span>
01476 
01477         Success = <a class="code" href="../../d6/d9/heappage_8c.html#a101">RtlpDebugPageHeapCommitVM</a> (pAvail-&gt;pVirtualBlock, nSize);
01478 
01479         <span class="keywordflow">if</span> (!Success) {
01480 
01481             <span class="comment">//</span>
01482             <span class="comment">// We did not manage to commit memory for this block. This</span>
01483             <span class="comment">// can happen in low memory conditions. We need to return</span>
01484             <span class="comment">// the node back into free pool (together with virtual space</span>
01485             <span class="comment">// region taken) and fail the current call.</span>
01486             <span class="comment">//</span>
01487 
01488             <a class="code" href="../../d6/d9/heappage_8c.html#a111">RtlpDebugPageHeapPlaceOnFreeList</a>( pHeap, pAvail );
01489 
01490             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01491         }
01492     }
01493 
01494     <span class="keywordflow">return</span> pAvail;
01495 }
01496 
01497 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01498"></a><a class="code" href="../../d6/d9/heappage_8c.html#a121">01498</a> <a class="code" href="../../d6/d9/heappage_8c.html#a121">RtlpDebugPageHeapPlaceOnPoolList</a>(
01499     IN PDPH_HEAP_ROOT       pHeap,
01500     IN PDPH_HEAP_BLOCK pNode
01501     )
01502 {
01503 
01504     <span class="comment">//</span>
01505     <span class="comment">//  NodePoolList is FIFO.</span>
01506     <span class="comment">//</span>
01507 
01508     pNode-&gt;pNextAlloc = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01509 
01510     <a class="code" href="../../d6/d9/heappage_8c.html#a16">ENQUEUE_TAIL</a>( pNode, pHeap-&gt;pNodePoolListHead, pHeap-&gt;pNodePoolListTail );
01511 
01512     pHeap-&gt;nNodePoolBytes += pNode-&gt;nVirtualBlockSize;
01513     pHeap-&gt;nNodePools     += 1;
01514 
01515 }
01516 
01517 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01518"></a><a class="code" href="../../d6/d9/heappage_8c.html#a122">01518</a> <a class="code" href="../../d6/d9/heappage_8c.html#a122">RtlpDebugPageHeapAddNewPool</a>(
01519     IN PDPH_HEAP_ROOT pHeap,
01520     IN PVOID          pVirtual,
01521     IN SIZE_T         nSize,
01522     IN BOOLEAN        bAddToPoolList
01523     )
01524 {
01525     PDPH_HEAP_BLOCK pNode, pFirst;
01526     ULONG <a class="code" href="../../d7/d0/exts_8h.html#a0">n</a>, nCount;
01527 
01528     <span class="comment">//</span>
01529     <span class="comment">//  Assume pVirtual points to committed block of nSize bytes.</span>
01530     <span class="comment">//</span>
01531 
01532     pFirst = pVirtual;
01533     nCount = (ULONG)(nSize  / <span class="keyword">sizeof</span>( DPH_HEAP_BLOCK ));
01534 
01535     <span class="keywordflow">for</span> (<a class="code" href="../../d7/d0/exts_8h.html#a0">n</a> = nCount - 1, pNode = pFirst; <a class="code" href="../../d7/d0/exts_8h.html#a0">n</a> &gt; 0; pNode++, <a class="code" href="../../d7/d0/exts_8h.html#a0">n</a>--)
01536         pNode-&gt;pNextAlloc = pNode + 1;
01537 
01538     pNode-&gt;pNextAlloc = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01539 
01540     <span class="comment">//</span>
01541     <span class="comment">//  Now link this list into the tail of the UnusedNodeList</span>
01542     <span class="comment">//</span>
01543 
01544     <a class="code" href="../../d6/d9/heappage_8c.html#a16">ENQUEUE_TAIL</a>( pFirst, pHeap-&gt;pUnusedNodeListHead, pHeap-&gt;pUnusedNodeListTail );
01545 
01546     pHeap-&gt;pUnusedNodeListTail = pNode;
01547 
01548     pHeap-&gt;nUnusedNodes += nCount;
01549 
01550     <span class="keywordflow">if</span> (bAddToPoolList) {
01551 
01552         <span class="comment">//</span>
01553         <span class="comment">//  Now add an entry on the PoolList by taking a node from the</span>
01554         <span class="comment">//  UnusedNodeList, which should be guaranteed to be non-empty</span>
01555         <span class="comment">//  since we just added new nodes to it.</span>
01556         <span class="comment">//</span>
01557 
01558         pNode = <a class="code" href="../../d6/d9/heappage_8c.html#a107">RtlpDebugPageHeapTakeNodeFromUnusedList</a>( pHeap );
01559 
01560         <a class="code" href="../../d6/d9/heappage_8c.html#a11">DEBUG_ASSERT</a>( pNode != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01561 
01562         pNode-&gt;pVirtualBlock     = pVirtual;
01563         pNode-&gt;nVirtualBlockSize = nSize;
01564 
01565         <a class="code" href="../../d6/d9/heappage_8c.html#a121">RtlpDebugPageHeapPlaceOnPoolList</a>( pHeap, pNode );
01566 
01567     }
01568 }
01569 
01570 PDPH_HEAP_BLOCK
<a name="l01571"></a><a class="code" href="../../d6/d9/heappage_8c.html#a123">01571</a> <a class="code" href="../../d6/d9/heappage_8c.html#a123">RtlpDebugPageHeapAllocateNode</a>(
01572     IN PDPH_HEAP_ROOT pHeap
01573     )
01574 {
01575     PDPH_HEAP_BLOCK pNode, pPrev, pReturn;
01576     PUCHAR pVirtual;
01577     SIZE_T nVirtual;
01578     SIZE_T nRequest;
01579 
01580     <a class="code" href="../../d6/d9/heappage_8c.html#a11">DEBUG_ASSERT</a>( ! pHeap-&gt;InsideAllocateNode );
01581     <a class="code" href="../../d6/d9/heappage_8c.html#a9">DEBUG_CODE</a>( pHeap-&gt;InsideAllocateNode = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
01582 
01583     pReturn = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01584 
01585     <span class="keywordflow">if</span> (pHeap-&gt;pUnusedNodeListHead == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01586 
01587         <span class="comment">//</span>
01588         <span class="comment">//  We're out of nodes -- allocate new node pool</span>
01589         <span class="comment">//  from AvailableList.  Set bGrowVirtual to FALSE</span>
01590         <span class="comment">//  since growing virtual will require new nodes, causing</span>
01591         <span class="comment">//  recursion.  Note that simply calling FindAvailableMem</span>
01592         <span class="comment">//  might return some nodes to the pUnusedNodeList, even if</span>
01593         <span class="comment">//  the call fails, so we'll check that the UnusedNodeList</span>
01594         <span class="comment">//  is still empty before we try to use or allocate more</span>
01595         <span class="comment">//  memory.</span>
01596         <span class="comment">//</span>
01597 
01598         nRequest = <a class="code" href="../../d6/d9/heappage_8c.html#a5">POOL_SIZE</a>;
01599 
01600         pNode = <a class="code" href="../../d6/d9/heappage_8c.html#a120">RtlpDebugPageHeapFindAvailableMem</a>(
01601             pHeap,
01602             nRequest,
01603             &amp;pPrev,
01604             <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>
01605             );
01606 
01607         <span class="keywordflow">if</span> (( pHeap-&gt;pUnusedNodeListHead == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) &amp;&amp; ( pNode == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> )) {
01608 
01609             <span class="comment">//</span>
01610             <span class="comment">//  Reduce request size to PAGE_SIZE and see if</span>
01611             <span class="comment">//  we can find at least a page on the available</span>
01612             <span class="comment">//  list.</span>
01613             <span class="comment">//</span>
01614 
01615             nRequest = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
01616 
01617             pNode = <a class="code" href="../../d6/d9/heappage_8c.html#a120">RtlpDebugPageHeapFindAvailableMem</a>(
01618                 pHeap,
01619                 nRequest,
01620                 &amp;pPrev,
01621                 <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>
01622                 );
01623 
01624         }
01625 
01626         <span class="keywordflow">if</span> (pHeap-&gt;pUnusedNodeListHead == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01627 
01628             <span class="keywordflow">if</span> (pNode == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01629 
01630                 <span class="comment">//</span>
01631                 <span class="comment">//  Insufficient memory on Available list.  Try allocating a</span>
01632                 <span class="comment">//  new virtual block.</span>
01633                 <span class="comment">//</span>
01634 
01635                 nRequest = <a class="code" href="../../d6/d9/heappage_8c.html#a5">POOL_SIZE</a>;
01636                 nVirtual = <a class="code" href="../../d6/d9/heappage_8c.html#a3">RESERVE_SIZE</a>;
01637                 pVirtual = <a class="code" href="../../d6/d9/heappage_8c.html#a99">RtlpDebugPageHeapAllocateVM</a>( nVirtual );
01638 
01639                 <span class="keywordflow">if</span> (pVirtual == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01640 
01641                     <span class="comment">//</span>
01642                     <span class="comment">//  Unable to allocate full RESERVE_SIZE block,</span>
01643                     <span class="comment">//  so reduce request to single VM unit (64K)</span>
01644                     <span class="comment">//  and try again.</span>
01645                     <span class="comment">//</span>
01646 
01647                     nVirtual = <a class="code" href="../../d6/d9/heappage_8c.html#a4">VM_UNIT_SIZE</a>;
01648                     pVirtual = <a class="code" href="../../d6/d9/heappage_8c.html#a99">RtlpDebugPageHeapAllocateVM</a>( nVirtual );
01649 
01650                     <span class="keywordflow">if</span> (pVirtual == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01651 
01652                         <span class="comment">//</span>
01653                         <span class="comment">//  Can't allocate any VM.</span>
01654                         <span class="comment">//</span>
01655 
01656                         <span class="keywordflow">goto</span> <a class="code" href="../../d3/d9/arcinst_8c.html#a2">EXIT</a>;
01657                     }
01658                 }
01659             }
01660 
01661             <span class="keywordflow">else</span> {
01662 
01663                 <a class="code" href="../../d6/d9/heappage_8c.html#a110">RtlpDebugPageHeapRemoveFromAvailableList</a>( pHeap, pNode, pPrev );
01664 
01665                 pVirtual = pNode-&gt;pVirtualBlock;
01666                 nVirtual = pNode-&gt;nVirtualBlockSize;
01667 
01668             }
01669 
01670             <span class="comment">//</span>
01671             <span class="comment">//  We now have allocated VM referenced by pVirtual,nVirtual.</span>
01672             <span class="comment">//  Make nRequest portion of VM accessible for new node pool.</span>
01673             <span class="comment">//</span>
01674 
01675             <span class="keywordflow">if</span> (! <a class="code" href="../../d6/d9/heappage_8c.html#a98">RtlpDebugPageHeapProtectVM</a>( pVirtual, nRequest, PAGE_READWRITE )) {
01676 
01677                 <span class="keywordflow">if</span> (pNode == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01678                     <a class="code" href="../../d6/d9/heappage_8c.html#a100">RtlpDebugPageHeapReleaseVM</a>( pVirtual );
01679                 }
01680                 <span class="keywordflow">else</span> {
01681                     <a class="code" href="../../d6/d9/heappage_8c.html#a117">RtlpDebugPageHeapCoalesceNodeIntoAvailable</a>( pHeap, pNode );
01682                 }
01683 
01684                 <span class="keywordflow">goto</span> <a class="code" href="../../d3/d9/arcinst_8c.html#a2">EXIT</a>;
01685             }
01686 
01687             <span class="comment">//</span>
01688             <span class="comment">//  Now we have accessible memory for new pool.  Add the</span>
01689             <span class="comment">//  new memory to the pool.  If the new memory came from</span>
01690             <span class="comment">//  AvailableList versus fresh VM, zero the memory first.</span>
01691             <span class="comment">//</span>
01692 
01693             <span class="keywordflow">if</span> (pNode != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01694                 RtlZeroMemory( pVirtual, nRequest );
01695             }
01696 
01697             <a class="code" href="../../d6/d9/heappage_8c.html#a122">RtlpDebugPageHeapAddNewPool</a>( pHeap, pVirtual, nRequest, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
01698 
01699             <span class="comment">//</span>
01700             <span class="comment">//  If any memory remaining, put it on available list.</span>
01701             <span class="comment">//</span>
01702 
01703             <span class="keywordflow">if</span> (pNode == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01704 
01705                 <span class="comment">//</span>
01706                 <span class="comment">//  Memory came from new VM -- add appropriate list entries</span>
01707                 <span class="comment">//  for new VM and add remainder of VM to free list.</span>
01708                 <span class="comment">//</span>
01709 
01710                 pNode = <a class="code" href="../../d6/d9/heappage_8c.html#a107">RtlpDebugPageHeapTakeNodeFromUnusedList</a>( pHeap );
01711                 <a class="code" href="../../d6/d9/heappage_8c.html#a11">DEBUG_ASSERT</a>( pNode != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01712                 pNode-&gt;pVirtualBlock     = pVirtual;
01713                 pNode-&gt;nVirtualBlockSize = nVirtual;
01714                 <a class="code" href="../../d6/d9/heappage_8c.html#a113">RtlpDebugPageHeapPlaceOnVirtualList</a>( pHeap, pNode );
01715 
01716                 pNode = <a class="code" href="../../d6/d9/heappage_8c.html#a107">RtlpDebugPageHeapTakeNodeFromUnusedList</a>( pHeap );
01717                 <a class="code" href="../../d6/d9/heappage_8c.html#a11">DEBUG_ASSERT</a>( pNode != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01718                 pNode-&gt;pVirtualBlock     = pVirtual + nRequest;
01719                 pNode-&gt;nVirtualBlockSize = nVirtual - nRequest;
01720 
01721                 <a class="code" href="../../d6/d9/heappage_8c.html#a117">RtlpDebugPageHeapCoalesceNodeIntoAvailable</a>( pHeap, pNode );
01722 
01723             }
01724 
01725             <span class="keywordflow">else</span> {
01726 
01727                 <span class="keywordflow">if</span> (pNode-&gt;nVirtualBlockSize &gt; nRequest) {
01728 
01729                     pNode-&gt;pVirtualBlock     += nRequest;
01730                     pNode-&gt;nVirtualBlockSize -= nRequest;
01731 
01732                     <a class="code" href="../../d6/d9/heappage_8c.html#a117">RtlpDebugPageHeapCoalesceNodeIntoAvailable</a>( pHeap, pNode );
01733                 }
01734 
01735                 <span class="keywordflow">else</span> {
01736 
01737                     <span class="comment">//</span>
01738                     <span class="comment">//  Used up entire available block -- return node to</span>
01739                     <span class="comment">//  unused list.</span>
01740                     <span class="comment">//</span>
01741 
01742                     <a class="code" href="../../d6/d9/heappage_8c.html#a108">RtlpDebugPageHeapReturnNodeToUnusedList</a>( pHeap, pNode );
01743 
01744                 }
01745             }
01746         }
01747     }
01748 
01749     pReturn = <a class="code" href="../../d6/d9/heappage_8c.html#a107">RtlpDebugPageHeapTakeNodeFromUnusedList</a>( pHeap );
01750     <a class="code" href="../../d6/d9/heappage_8c.html#a11">DEBUG_ASSERT</a>( pReturn != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01751 
01752     <a class="code" href="../../d3/d9/arcinst_8c.html#a2">EXIT</a>:
01753 
01754     <a class="code" href="../../d6/d9/heappage_8c.html#a9">DEBUG_CODE</a>( pHeap-&gt;InsideAllocateNode = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01755     <span class="keywordflow">return</span> pReturn;
01756 }
01757 
01758 BOOLEAN
<a name="l01759"></a><a class="code" href="../../d6/d9/heappage_8c.html#a119">01759</a> <a class="code" href="../../d6/d9/heappage_8c.html#a119">RtlpDebugPageHeapGrowVirtual</a>(
01760     IN PDPH_HEAP_ROOT pHeap,
01761     IN SIZE_T         nSize
01762     )
01763 {
01764     PDPH_HEAP_BLOCK pVirtualNode;
01765     PDPH_HEAP_BLOCK pAvailNode;
01766     PVOID  pVirtual;
01767     SIZE_T nVirtual;
01768 
01769     pVirtualNode = <a class="code" href="../../d6/d9/heappage_8c.html#a123">RtlpDebugPageHeapAllocateNode</a>( pHeap );
01770 
01771     <span class="keywordflow">if</span> (pVirtualNode == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01772         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01773     }
01774 
01775     pAvailNode = <a class="code" href="../../d6/d9/heappage_8c.html#a123">RtlpDebugPageHeapAllocateNode</a>( pHeap );
01776 
01777     <span class="keywordflow">if</span> (pAvailNode == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01778         <a class="code" href="../../d6/d9/heappage_8c.html#a108">RtlpDebugPageHeapReturnNodeToUnusedList</a>( pHeap, pVirtualNode );
01779         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01780     }
01781 
01782     nSize    = <a class="code" href="../../d6/d9/heappage_8c.html#a8">ROUNDUP2</a>( nSize, <a class="code" href="../../d6/d9/heappage_8c.html#a4">VM_UNIT_SIZE</a> );
01783     nVirtual = ( nSize &gt; <a class="code" href="../../d6/d9/heappage_8c.html#a3">RESERVE_SIZE</a> ) ? nSize : <a class="code" href="../../d6/d9/heappage_8c.html#a3">RESERVE_SIZE</a>;
01784     pVirtual = <a class="code" href="../../d6/d9/heappage_8c.html#a99">RtlpDebugPageHeapAllocateVM</a>( nVirtual );
01785 
01786     <span class="keywordflow">if</span> (( pVirtual == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) &amp;&amp; ( nSize &lt; <a class="code" href="../../d6/d9/heappage_8c.html#a3">RESERVE_SIZE</a> )) {
01787         nVirtual = nSize;
01788         pVirtual = <a class="code" href="../../d6/d9/heappage_8c.html#a99">RtlpDebugPageHeapAllocateVM</a>( nVirtual );
01789     }
01790 
01791     <span class="keywordflow">if</span> (pVirtual == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01792         <a class="code" href="../../d6/d9/heappage_8c.html#a108">RtlpDebugPageHeapReturnNodeToUnusedList</a>( pHeap, pVirtualNode );
01793         <a class="code" href="../../d6/d9/heappage_8c.html#a108">RtlpDebugPageHeapReturnNodeToUnusedList</a>( pHeap, pAvailNode );
01794         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01795     }
01796 
01797     pVirtualNode-&gt;pVirtualBlock     = pVirtual;
01798     pVirtualNode-&gt;nVirtualBlockSize = nVirtual;
01799     <a class="code" href="../../d6/d9/heappage_8c.html#a113">RtlpDebugPageHeapPlaceOnVirtualList</a>( pHeap, pVirtualNode );
01800 
01801     pAvailNode-&gt;pVirtualBlock     = pVirtual;
01802     pAvailNode-&gt;nVirtualBlockSize = nVirtual;
01803     <a class="code" href="../../d6/d9/heappage_8c.html#a117">RtlpDebugPageHeapCoalesceNodeIntoAvailable</a>( pHeap, pAvailNode );
01804 
01805     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01806 }
01807 
01808 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01809"></a><a class="code" href="../../d6/d9/heappage_8c.html#a124">01809</a> <a class="code" href="../../d6/d9/heappage_8c.html#a124">RtlpDebugPageHeapProtectStructures</a>(
01810     IN PDPH_HEAP_ROOT pHeap
01811     )
01812 {
01813     PDPH_HEAP_BLOCK pNode;
01814 
01815     <span class="comment">//</span>
01816     <span class="comment">//  Assume CritSect is owned so we're the only thread twiddling</span>
01817     <span class="comment">//  the protection.</span>
01818     <span class="comment">//</span>
01819 
01820     <a class="code" href="../../d6/d9/heappage_8c.html#a11">DEBUG_ASSERT</a>( pHeap-&gt;HeapFlags &amp; <a class="code" href="../../d7/d9/heappage_8h.html#a2">HEAP_PROTECTION_ENABLED</a> );
01821 
01822     <span class="keywordflow">if</span> (--pHeap-&gt;nUnProtectionReferenceCount == 0) {
01823 
01824         pNode = pHeap-&gt;pNodePoolListHead;
01825 
01826         <span class="keywordflow">while</span> (pNode != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01827 
01828             <a class="code" href="../../d6/d9/heappage_8c.html#a98">RtlpDebugPageHeapProtectVM</a>( pNode-&gt;pVirtualBlock,
01829                 pNode-&gt;nVirtualBlockSize,
01830                 PAGE_READONLY );
01831 
01832             pNode = pNode-&gt;pNextAlloc;
01833 
01834         }
01835     }
01836 }
01837 
01838 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01839"></a><a class="code" href="../../d6/d9/heappage_8c.html#a125">01839</a> <a class="code" href="../../d6/d9/heappage_8c.html#a125">RtlpDebugPageHeapUnProtectStructures</a>(
01840     IN PDPH_HEAP_ROOT pHeap
01841     )
01842 {
01843     PDPH_HEAP_BLOCK pNode;
01844 
01845     <a class="code" href="../../d6/d9/heappage_8c.html#a11">DEBUG_ASSERT</a>( pHeap-&gt;HeapFlags &amp; <a class="code" href="../../d7/d9/heappage_8h.html#a2">HEAP_PROTECTION_ENABLED</a> );
01846 
01847     <span class="keywordflow">if</span> (pHeap-&gt;nUnProtectionReferenceCount == 0) {
01848 
01849         pNode = pHeap-&gt;pNodePoolListHead;
01850 
01851         <span class="keywordflow">while</span> (pNode != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01852 
01853             <a class="code" href="../../d6/d9/heappage_8c.html#a98">RtlpDebugPageHeapProtectVM</a>( pNode-&gt;pVirtualBlock,
01854                 pNode-&gt;nVirtualBlockSize,
01855                 PAGE_READWRITE );
01856 
01857             pNode = pNode-&gt;pNextAlloc;
01858 
01859         }
01860     }
01861 
01862     pHeap-&gt;nUnProtectionReferenceCount += 1;
01863 }
01864 
01868 
01869 <span class="preprocessor">#if INTERNAL_DEBUG</span>
01870 <span class="preprocessor"></span>
01871 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01872 RtlpDebugPageHeapVerifyList(
01873     IN PDPH_HEAP_BLOCK pListHead,
01874     IN PDPH_HEAP_BLOCK pListTail,
01875     IN SIZE_T               nExpectedLength,
01876     IN SIZE_T               nExpectedVirtual,
01877     IN PCCH                 pListName
01878     )
01879 {
01880     PDPH_HEAP_BLOCK pPrev = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01881     PDPH_HEAP_BLOCK pNode = pListHead;
01882     PDPH_HEAP_BLOCK pTest = pListHead ? pListHead-&gt;pNextAlloc : <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01883     ULONG                nNode = 0;
01884     SIZE_T               nSize = 0;
01885 
01886     <span class="keywordflow">while</span> (pNode) {
01887 
01888         <span class="keywordflow">if</span> (pNode == pTest) {
01889             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( <span class="stringliteral">"Page heap: Internal %s list is circular\n"</span>, pListName );
01890             <a class="code" href="../../d7/d9/heappage_8h.html#a30">RtlpDebugPageHeapBreak</a>( <span class="stringliteral">""</span> );
01891             <span class="keywordflow">return</span>;
01892         }
01893 
01894         nNode += 1;
01895         nSize += pNode-&gt;nVirtualBlockSize;
01896 
01897         <span class="keywordflow">if</span> (pTest) {
01898             pTest = pTest-&gt;pNextAlloc;
01899             <span class="keywordflow">if</span> (pTest) {
01900                 pTest = pTest-&gt;pNextAlloc;
01901             }
01902         }
01903 
01904         pPrev = pNode;
01905         pNode = pNode-&gt;pNextAlloc;
01906 
01907     }
01908 
01909     <span class="keywordflow">if</span> (pPrev != pListTail) {
01910         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( <span class="stringliteral">"Page heap: Internal %s list has incorrect tail pointer\n"</span>, pListName );
01911         <a class="code" href="../../d7/d9/heappage_8h.html#a30">RtlpDebugPageHeapBreak</a>( <span class="stringliteral">""</span> );
01912     }
01913 
01914     <span class="keywordflow">if</span> (( nExpectedLength != 0xFFFFFFFF ) &amp;&amp; ( nExpectedLength != nNode )) {
01915         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( <span class="stringliteral">"Page heap: Internal %s list has incorrect length\n"</span>, pListName );
01916         <a class="code" href="../../d7/d9/heappage_8h.html#a30">RtlpDebugPageHeapBreak</a>( <span class="stringliteral">""</span> );
01917     }
01918 
01919     <span class="keywordflow">if</span> (( nExpectedVirtual != 0xFFFFFFFF ) &amp;&amp; ( nExpectedVirtual != nSize )) {
01920         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( <span class="stringliteral">"Page heap: Internal %s list has incorrect virtual size\n"</span>, pListName );
01921         <a class="code" href="../../d7/d9/heappage_8h.html#a30">RtlpDebugPageHeapBreak</a>( <span class="stringliteral">""</span> );
01922     }
01923 
01924 }
01925 
01926 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01927 RtlpDebugPageHeapVerifyIntegrity(
01928     IN PDPH_HEAP_ROOT pHeap
01929     )
01930 {
01931 
01932     RtlpDebugPageHeapVerifyList(
01933         pHeap-&gt;pVirtualStorageListHead,
01934         pHeap-&gt;pVirtualStorageListTail,
01935         pHeap-&gt;nVirtualStorageRanges,
01936         pHeap-&gt;nVirtualStorageBytes,
01937         <span class="stringliteral">"VIRTUAL"</span>
01938         );
01939 
01940     RtlpDebugPageHeapVerifyList(
01941         pHeap-&gt;pBusyAllocationListHead,
01942         pHeap-&gt;pBusyAllocationListTail,
01943         pHeap-&gt;nBusyAllocations,
01944         pHeap-&gt;nBusyAllocationBytesCommitted,
01945         <span class="stringliteral">"BUSY"</span>
01946         );
01947 
01948     RtlpDebugPageHeapVerifyList(
01949         pHeap-&gt;pFreeAllocationListHead,
01950         pHeap-&gt;pFreeAllocationListTail,
01951         pHeap-&gt;nFreeAllocations,
01952         pHeap-&gt;nFreeAllocationBytesCommitted,
01953         <span class="stringliteral">"FREE"</span>
01954         );
01955 
01956     RtlpDebugPageHeapVerifyList(
01957         pHeap-&gt;pAvailableAllocationListHead,
01958         pHeap-&gt;pAvailableAllocationListTail,
01959         pHeap-&gt;nAvailableAllocations,
01960         pHeap-&gt;nAvailableAllocationBytesCommitted,
01961         <span class="stringliteral">"AVAILABLE"</span>
01962         );
01963 
01964     RtlpDebugPageHeapVerifyList(
01965         pHeap-&gt;pUnusedNodeListHead,
01966         pHeap-&gt;pUnusedNodeListTail,
01967         pHeap-&gt;nUnusedNodes,
01968         0xFFFFFFFF,
01969         <span class="stringliteral">"FREENODE"</span>
01970         );
01971 
01972     RtlpDebugPageHeapVerifyList(
01973         pHeap-&gt;pNodePoolListHead,
01974         pHeap-&gt;pNodePoolListTail,
01975         pHeap-&gt;nNodePools,
01976         pHeap-&gt;nNodePoolBytes,
01977         <span class="stringliteral">"NODEPOOL"</span>
01978         );
01979 }
01980 
01981 <span class="preprocessor">#endif // #if INTERNAL_DEBUG</span>
01982 <span class="preprocessor"></span>
01986 
01987 <span class="comment">//</span>
01988 <span class="comment">//  Here's where the exported interface functions are defined.</span>
01989 <span class="comment">//</span>
01990 
01991 <span class="comment">//silviuc: i think this pragma works only for the next function defined</span>
01992 <span class="preprocessor">#if (( DPH_CAPTURE_STACK_TRACE ) &amp;&amp; ( i386 ) &amp;&amp; ( FPO ))</span>
01993 <span class="preprocessor"></span><span class="preprocessor">#pragma optimize( "y", off )    // disable FPO for consistent stack traces</span>
01994 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
01995 <span class="preprocessor"></span>
01996 PVOID
<a name="l01997"></a><a class="code" href="../../d7/d9/heappage_8h.html#a9">01997</a> <a class="code" href="../../d7/d9/heappage_8h.html#a9">RtlpDebugPageHeapCreate</a>(
01998     IN ULONG  Flags,
01999     IN PVOID  HeapBase    OPTIONAL,
02000     IN SIZE_T ReserveSize OPTIONAL,
02001     IN SIZE_T CommitSize  OPTIONAL,
02002     IN PVOID  Lock        OPTIONAL,
02003     IN PRTL_HEAP_PARAMETERS Parameters OPTIONAL
02004     )
02005 {
02006     SYSTEM_BASIC_INFORMATION SystemInfo;
02007     PDPH_HEAP_BLOCK     Node;
02008     PDPH_HEAP_ROOT           HeapRoot;
02009     PVOID                    <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
02010     PUCHAR                   pVirtual;
02011     SIZE_T                   nVirtual;
02012     SIZE_T                   <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
02013     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02014 
02015     <span class="comment">//</span>
02016     <span class="comment">// If `Parameters' is -1 then this is a recursive call to</span>
02017     <span class="comment">// RtlpDebugPageHeapCreate and we will return NULL so that</span>
02018     <span class="comment">// the normal heap manager will create a normal heap.</span>
02019     <span class="comment">// I agree this is a hack but we need this so that we maintain</span>
02020     <span class="comment">// a very loose dependency between the normal and page heap</span>
02021     <span class="comment">// manager.</span>
02022     <span class="comment">//</span>
02023 
02024     <span class="keywordflow">if</span> ((SIZE_T)Parameters == (SIZE_T)-1) {
02025         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;                                        
02026     }
02027 
02028     <span class="comment">//</span>
02029     <span class="comment">//  We don't handle heaps where HeapBase is already allocated</span>
02030     <span class="comment">//  from user or where Lock is provided by user.</span>
02031     <span class="comment">//</span>
02032 
02033     <a class="code" href="../../d6/d9/heappage_8c.html#a11">DEBUG_ASSERT</a>( HeapBase == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
02034     <a class="code" href="../../d6/d9/heappage_8c.html#a11">DEBUG_ASSERT</a>( <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
02035 
02036     <span class="keywordflow">if</span> (( HeapBase != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) || ( <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ))
02037         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02038 
02039     <span class="comment">//</span>
02040     <span class="comment">//  Note that we simply ignore ReserveSize, CommitSize, and</span>
02041     <span class="comment">//  Parameters as we always have a growable heap with our</span>
02042     <span class="comment">//  own thresholds, etc.</span>
02043     <span class="comment">//</span>
02044 
02045     ZwQuerySystemInformation( SystemBasicInformation,
02046         &amp;SystemInfo,
02047         <span class="keyword">sizeof</span>( SystemInfo ),
02048         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
02049 
02050     <a class="code" href="../../d6/d9/heappage_8c.html#a10">RETAIL_ASSERT</a>( SystemInfo.PageSize == <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> );
02051     <a class="code" href="../../d6/d9/heappage_8c.html#a10">RETAIL_ASSERT</a>( SystemInfo.AllocationGranularity == <a class="code" href="../../d6/d9/heappage_8c.html#a4">VM_UNIT_SIZE</a> );
02052     <a class="code" href="../../d6/d9/heappage_8c.html#a11">DEBUG_ASSERT</a>(( <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> + <a class="code" href="../../d6/d9/heappage_8c.html#a5">POOL_SIZE</a> + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> ) &lt; <a class="code" href="../../d6/d9/heappage_8c.html#a4">VM_UNIT_SIZE</a> );
02053 
02054     nVirtual = <a class="code" href="../../d6/d9/heappage_8c.html#a3">RESERVE_SIZE</a>;
02055     pVirtual = <a class="code" href="../../d6/d9/heappage_8c.html#a99">RtlpDebugPageHeapAllocateVM</a>( nVirtual );
02056 
02057     <span class="keywordflow">if</span> (pVirtual == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02058 
02059         nVirtual = <a class="code" href="../../d6/d9/heappage_8c.html#a4">VM_UNIT_SIZE</a>;
02060         pVirtual = <a class="code" href="../../d6/d9/heappage_8c.html#a99">RtlpDebugPageHeapAllocateVM</a>( nVirtual );
02061 
02062         <span class="keywordflow">if</span> (pVirtual == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02063             <a class="code" href="../../d6/d9/heappage_8c.html#a14">OUT_OF_VM_BREAK</a>( Flags, <span class="stringliteral">"Page heap: Insufficient memory to create heap\n"</span> );
02064             <a class="code" href="../../d6/d9/heappage_8c.html#a13">IF_GENERATE_EXCEPTION</a>( Flags, STATUS_NO_MEMORY );
02065             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02066         }
02067     }
02068 
02069     <span class="keywordflow">if</span> (! <a class="code" href="../../d6/d9/heappage_8c.html#a98">RtlpDebugPageHeapProtectVM</a>( pVirtual, <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> + <a class="code" href="../../d6/d9/heappage_8c.html#a5">POOL_SIZE</a> + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>, PAGE_READWRITE )) {
02070         <a class="code" href="../../d6/d9/heappage_8c.html#a100">RtlpDebugPageHeapReleaseVM</a>( pVirtual );
02071         <a class="code" href="../../d6/d9/heappage_8c.html#a13">IF_GENERATE_EXCEPTION</a>( Flags, STATUS_NO_MEMORY );
02072         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02073     }
02074 
02075     <span class="comment">//</span>
02076     <span class="comment">//  Out of our initial allocation, the initial page is the fake</span>
02077     <span class="comment">//  retail HEAP structure.  The second page begins our DPH_HEAP</span>
02078     <span class="comment">//  structure followed by (POOL_SIZE-sizeof(DPH_HEAP)) bytes for</span>
02079     <span class="comment">//  the initial pool.  The next page contains out CRIT_SECT</span>
02080     <span class="comment">//  variable, which must always be READWRITE.  Beyond that, the</span>
02081     <span class="comment">//  remainder of the virtual allocation is placed on the available</span>
02082     <span class="comment">//  list.</span>
02083     <span class="comment">//</span>
02084     <span class="comment">//  |_____|___________________|_____|__ _ _ _ _ _ _ _ _ _ _ _ _ __|</span>
02085     <span class="comment">//</span>
02086     <span class="comment">//  ^pVirtual</span>
02087     <span class="comment">//</span>
02088     <span class="comment">//  ^FakeRetailHEAP</span>
02089     <span class="comment">//</span>
02090     <span class="comment">//        ^HeapRoot</span>
02091     <span class="comment">//</span>
02092     <span class="comment">//            ^InitialNodePool</span>
02093     <span class="comment">//</span>
02094     <span class="comment">//                            ^CRITICAL_SECTION</span>
02095     <span class="comment">//</span>
02096     <span class="comment">//                                  ^AvailableSpace</span>
02097     <span class="comment">//</span>
02098     <span class="comment">//</span>
02099     <span class="comment">//</span>
02100     <span class="comment">//  Our DPH_HEAP structure starts at the page following the</span>
02101     <span class="comment">//  fake retail HEAP structure pointed to by the "heap handle".</span>
02102     <span class="comment">//  For the fake HEAP structure, we'll fill it with 0xEEEEEEEE</span>
02103     <span class="comment">//  except for the Heap-&gt;Flags and Heap-&gt;ForceFlags fields,</span>
02104     <span class="comment">//  which we must set to include our HEAP_FLAG_PAGE_ALLOCS flag,</span>
02105     <span class="comment">//  and then we'll make the whole page read-only.</span>
02106     <span class="comment">//</span>
02107 
02108     RtlFillMemory( pVirtual, <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>, <a class="code" href="../../d6/d9/heappage_8c.html#a1">FILL_BYTE</a> );
02109 
02110     ((<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)pVirtual)-&gt;Flags      = Flags | <a class="code" href="../../d7/d9/heappage_8h.html#a1">HEAP_FLAG_PAGE_ALLOCS</a>;
02111     ((<a class="code" href="../../d5/d5/struct__HEAP.html">PHEAP</a>)pVirtual)-&gt;ForceFlags = Flags | <a class="code" href="../../d7/d9/heappage_8h.html#a1">HEAP_FLAG_PAGE_ALLOCS</a>;
02112 
02113     <span class="keywordflow">if</span> (! <a class="code" href="../../d6/d9/heappage_8c.html#a98">RtlpDebugPageHeapProtectVM</a>( pVirtual, <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>, PAGE_READONLY )) {
02114         <a class="code" href="../../d6/d9/heappage_8c.html#a100">RtlpDebugPageHeapReleaseVM</a>( pVirtual );
02115         <a class="code" href="../../d6/d9/heappage_8c.html#a13">IF_GENERATE_EXCEPTION</a>( Flags, STATUS_NO_MEMORY );
02116         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02117     }
02118 
02119     HeapRoot = (PDPH_HEAP_ROOT)( pVirtual + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> );
02120 
02121     HeapRoot-&gt;Signature    = <a class="code" href="../../d6/d9/heappage_8c.html#a0">DPH_HEAP_SIGNATURE</a>;
02122     HeapRoot-&gt;HeapFlags    = Flags;
02123     HeapRoot-&gt;HeapCritSect = (PVOID)((PCHAR)HeapRoot + <a class="code" href="../../d6/d9/heappage_8c.html#a5">POOL_SIZE</a> );
02124 
02125     <span class="comment">//</span>
02126     <span class="comment">// Copy the page heap global flags into per heap flags.</span>
02127     <span class="comment">//</span>
02128 
02129     HeapRoot-&gt;ExtraFlags = <a class="code" href="../../d6/d9/heappage_8c.html#a43">RtlpDphGlobalFlags</a>;
02130 
02131     <span class="comment">//</span>
02132     <span class="comment">// If the PAGE_HEAP_UNALIGNED_ALLOCATIONS bit is set</span>
02133     <span class="comment">// in ExtraFlags we will set the HEAP_NO_ALIGNMENT flag</span>
02134     <span class="comment">// in the HeapFlags. This last bit controls if allocations</span>
02135     <span class="comment">// will be aligned or not. The reason we do this transfer is</span>
02136     <span class="comment">// that ExtraFlags can be set from the registry whereas the</span>
02137     <span class="comment">// normal HeapFlags cannot.</span>
02138     <span class="comment">//</span>
02139 
02140     <span class="keywordflow">if</span> ((HeapRoot-&gt;ExtraFlags &amp; PAGE_HEAP_UNALIGNED_ALLOCATIONS)) {
02141         HeapRoot-&gt;HeapFlags |= <a class="code" href="../../d7/d9/heappage_8h.html#a4">HEAP_NO_ALIGNMENT</a>;
02142     }
02143 
02144     <span class="comment">//</span>
02145     <span class="comment">// Initialize the seed for the random generator used to decide</span>
02146     <span class="comment">// from where should we make allocations if random decision</span>
02147     <span class="comment">// flag is on.</span>
02148     <span class="comment">//</span>
02149 
02150     {
02151         LARGE_INTEGER PerformanceCounter;
02152 
02153         PerformanceCounter.LowPart = 0xABCDDCBA;
02154 
02155         <a class="code" href="../../d9/d6/ex_2profile_8c.html#a14">NtQueryPerformanceCounter</a> (
02156             &amp;PerformanceCounter,
02157             <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
02158 
02159         HeapRoot-&gt;Seed = PerformanceCounter.LowPart;
02160     }
02161 
02162     RtlZeroMemory (HeapRoot-&gt;Counter, <span class="keyword">sizeof</span>(HeapRoot-&gt;Counter));
02163 
02164     <span class="comment">//</span>
02165     <span class="comment">// Create the normal heap associated with the page heap.</span>
02166     <span class="comment">// The last parameter value (-1) is very important because</span>
02167     <span class="comment">// it stops the recursive call into page heap create.</span>
02168     <span class="comment">//</span>
02169 
02170     HeapRoot-&gt;NormalHeap = <a class="code" href="../../d1/d9/rtl_2heap_8c.html#a15">RtlCreateHeap</a>(
02171 
02172         Flags,
02173         HeapBase,
02174         ReserveSize,
02175         CommitSize,
02176         <a class="code" href="../../d6/d0/usercli_8h.html#a41">Lock</a>,
02177         (PRTL_HEAP_PARAMETERS)-1 );
02178 
02179     <span class="comment">//</span>
02180     <span class="comment">// Initialize heap lock.</span>
02181     <span class="comment">//</span>
02182 
02183     <a class="code" href="../../d7/d8/dll_2resource_8c.html#a24">RtlInitializeCriticalSection</a>( HeapRoot-&gt;HeapCritSect );
02184 
02185     <span class="comment">//</span>
02186     <span class="comment">//  On the page that contains our DPH_HEAP structure, use</span>
02187     <span class="comment">//  the remaining memory beyond the DPH_HEAP structure as</span>
02188     <span class="comment">//  pool for allocating heap nodes.</span>
02189     <span class="comment">//</span>
02190 
02191     <a class="code" href="../../d6/d9/heappage_8c.html#a122">RtlpDebugPageHeapAddNewPool</a>( HeapRoot,
02192         HeapRoot + 1,
02193         <a class="code" href="../../d6/d9/heappage_8c.html#a5">POOL_SIZE</a> - <span class="keyword">sizeof</span>( DPH_HEAP_ROOT ),
02194         <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>
02195         );
02196 
02197     <span class="comment">//</span>
02198     <span class="comment">//  Make initial PoolList entry by taking a node from the</span>
02199     <span class="comment">//  UnusedNodeList, which should be guaranteed to be non-empty</span>
02200     <span class="comment">//  since we just added new nodes to it.</span>
02201     <span class="comment">//</span>
02202 
02203     Node = <a class="code" href="../../d6/d9/heappage_8c.html#a123">RtlpDebugPageHeapAllocateNode</a>( HeapRoot );
02204     <a class="code" href="../../d6/d9/heappage_8c.html#a11">DEBUG_ASSERT</a>( Node != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
02205     Node-&gt;pVirtualBlock     = (PVOID)HeapRoot;
02206     Node-&gt;nVirtualBlockSize = <a class="code" href="../../d6/d9/heappage_8c.html#a5">POOL_SIZE</a>;
02207     <a class="code" href="../../d6/d9/heappage_8c.html#a121">RtlpDebugPageHeapPlaceOnPoolList</a>( HeapRoot, Node );
02208 
02209     <span class="comment">//</span>
02210     <span class="comment">//  Make VirtualStorageList entry for initial VM allocation</span>
02211     <span class="comment">//</span>
02212 
02213     Node = <a class="code" href="../../d6/d9/heappage_8c.html#a123">RtlpDebugPageHeapAllocateNode</a>( HeapRoot );
02214     <a class="code" href="../../d6/d9/heappage_8c.html#a11">DEBUG_ASSERT</a>( Node != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
02215     Node-&gt;pVirtualBlock     = pVirtual;
02216     Node-&gt;nVirtualBlockSize = nVirtual;
02217     <a class="code" href="../../d6/d9/heappage_8c.html#a113">RtlpDebugPageHeapPlaceOnVirtualList</a>( HeapRoot, Node );
02218 
02219     <span class="comment">//</span>
02220     <span class="comment">//  Make AvailableList entry containing remainder of initial VM</span>
02221     <span class="comment">//  and add to (create) the AvailableList.</span>
02222     <span class="comment">//</span>
02223 
02224     Node = <a class="code" href="../../d6/d9/heappage_8c.html#a123">RtlpDebugPageHeapAllocateNode</a>( HeapRoot );
02225     <a class="code" href="../../d6/d9/heappage_8c.html#a11">DEBUG_ASSERT</a>( Node != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
02226     Node-&gt;pVirtualBlock     = pVirtual + ( <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> + <a class="code" href="../../d6/d9/heappage_8c.html#a5">POOL_SIZE</a> + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> );
02227     Node-&gt;nVirtualBlockSize = nVirtual - ( <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> + <a class="code" href="../../d6/d9/heappage_8c.html#a5">POOL_SIZE</a> + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> );
02228     <a class="code" href="../../d6/d9/heappage_8c.html#a117">RtlpDebugPageHeapCoalesceNodeIntoAvailable</a>( HeapRoot, Node );
02229 
02230     <span class="comment">//</span>
02231     <span class="comment">// Get heap creation stack trace.</span>
02232     <span class="comment">//</span>
02233 
02234     HeapRoot-&gt;CreateStackTrace = <a class="code" href="../../d6/d9/heappage_8c.html#a89">RtlpDphLogStackTrace</a>(1);
02235 
02236     <span class="comment">//</span>
02237     <span class="comment">//  Initialize heap internal structure protection.</span>
02238     <span class="comment">//</span>
02239 
02240     HeapRoot-&gt;nUnProtectionReferenceCount = 1;          <span class="comment">// initialize</span>
02241 
02242     <span class="comment">//</span>
02243     <span class="comment">//  If this is the first heap creation in this process, then we</span>
02244     <span class="comment">//  need to initialize the process heap list critical section,</span>
02245     <span class="comment">// the global delayed free queue for normal blocks and the</span>
02246     <span class="comment">// trace database.</span>
02247     <span class="comment">//</span>
02248 
02249     <span class="keywordflow">if</span> (! <a class="code" href="../../d6/d9/heappage_8c.html#a38">RtlpDphHeapListHasBeenInitialized</a>) {
02250 
02251         <a class="code" href="../../d6/d9/heappage_8c.html#a38">RtlpDphHeapListHasBeenInitialized</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02252 
02253         <a class="code" href="../../d7/d8/dll_2resource_8c.html#a24">RtlInitializeCriticalSection</a>( &amp;<a class="code" href="../../d6/d9/heappage_8c.html#a39">RtlpDphHeapListCriticalSection</a> );
02254         <a class="code" href="../../d6/d9/heappage_8c.html#a83">RtlpDphInitializeDelayedFreeQueue</a> ();
02255 
02256         <span class="comment">//</span>
02257         <span class="comment">// Do not make fuss if the trace database creation fails.</span>
02258         <span class="comment">// This is something we can live with.</span>
02259         <span class="comment">//</span>
02260         <span class="comment">// The number of buckets is chosen to be a prime not too</span>
02261         <span class="comment">// close to a power of two (Knuth says so). Three possible</span>
02262         <span class="comment">// values are: 1567, 3089, 6263.</span>
02263         <span class="comment">//</span>
02264 
02265         <a class="code" href="../../d6/d9/heappage_8c.html#a56">RtlpDphTraceDatabase</a> = RtlTraceDatabaseCreate (
02266             6263, 
02267             <a class="code" href="../../d6/d9/heappage_8c.html#a55">RtlpDphTraceDatabaseMaximumSize</a>,
02268             0,
02269             0,
02270             <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
02271 
02272 <span class="preprocessor">#if DBG</span>
02273 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (<a class="code" href="../../d6/d9/heappage_8c.html#a56">RtlpDphTraceDatabase</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02274             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a> (<span class="stringliteral">"Page heap: warning: failed to create trace database for %p"</span>,
02275                 HeapRoot);
02276         }
02277 <span class="preprocessor">#endif</span>
02278 <span class="preprocessor"></span>        <span class="comment">//</span>
02279         <span class="comment">// Create the Unicode string containing the target dlls. </span>
02280         <span class="comment">// If no target dlls have been specified the string will</span>
02281         <span class="comment">// be initialized with the empty string.</span>
02282         <span class="comment">//</span>
02283 
02284         <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a> (
02285             &amp;<a class="code" href="../../d6/d9/heappage_8c.html#a50">RtlpDphTargetDllsUnicode</a>,
02286             <a class="code" href="../../d6/d9/heappage_8c.html#a49">RtlpDphTargetDlls</a>);
02287         
02288         <span class="comment">//</span>
02289         <span class="comment">// Initialize the target dlls logic</span>
02290         <span class="comment">//</span>
02291 
02292         <a class="code" href="../../d6/d9/heappage_8c.html#a103">RtlpDphTargetDllsLogicInitialize</a> ();
02293     }
02294 
02295     <span class="comment">//</span>
02296     <span class="comment">//  Add this heap entry to the process heap linked list.</span>
02297     <span class="comment">//</span>
02298 
02299     RtlEnterCriticalSection( &amp;<a class="code" href="../../d6/d9/heappage_8c.html#a39">RtlpDphHeapListCriticalSection</a> );
02300 
02301     <span class="keywordflow">if</span> (<a class="code" href="../../d6/d9/heappage_8c.html#a40">RtlpDphHeapListHead</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02302         <a class="code" href="../../d6/d9/heappage_8c.html#a40">RtlpDphHeapListHead</a> = HeapRoot;
02303         <a class="code" href="../../d6/d9/heappage_8c.html#a41">RtlpDphHeapListTail</a> = HeapRoot;
02304     }
02305     <span class="keywordflow">else</span> {
02306         HeapRoot-&gt;pPrevHeapRoot = <a class="code" href="../../d6/d9/heappage_8c.html#a41">RtlpDphHeapListTail</a>;
02307         <a class="code" href="../../d6/d9/heappage_8c.html#a22">UNPROTECT_HEAP_STRUCTURES</a>(<a class="code" href="../../d6/d9/heappage_8c.html#a41">RtlpDphHeapListTail</a>);
02308         <a class="code" href="../../d6/d9/heappage_8c.html#a41">RtlpDphHeapListTail</a>-&gt;pNextHeapRoot = HeapRoot;
02309         <a class="code" href="../../d6/d9/heappage_8c.html#a21">PROTECT_HEAP_STRUCTURES</a>(<a class="code" href="../../d6/d9/heappage_8c.html#a41">RtlpDphHeapListTail</a>);
02310         <a class="code" href="../../d6/d9/heappage_8c.html#a41">RtlpDphHeapListTail</a>                = HeapRoot;
02311     }
02312 
02313     <a class="code" href="../../d6/d9/heappage_8c.html#a21">PROTECT_HEAP_STRUCTURES</a>( HeapRoot );                <span class="comment">// now protected</span>
02314 
02315     <a class="code" href="../../d6/d9/heappage_8c.html#a42">RtlpDphHeapListCount</a> += 1;
02316 
02317     RtlLeaveCriticalSection( &amp;<a class="code" href="../../d6/d9/heappage_8c.html#a39">RtlpDphHeapListCriticalSection</a> );
02318 
02319     <a class="code" href="../../d6/d9/heappage_8c.html#a9">DEBUG_CODE</a>( RtlpDebugPageHeapVerifyIntegrity( HeapRoot ));
02320 
02321     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( <span class="stringliteral">"Page heap: process 0x%X created heap @ %p (%p, flags 0x%X)\n"</span>,
02322         NtCurrentTeb()-&gt;ClientId.UniqueProcess,
02323         <a class="code" href="../../d6/d9/heappage_8c.html#a12">HEAP_HANDLE_FROM_ROOT</a>( HeapRoot ),
02324         HeapRoot-&gt;NormalHeap,
02325         HeapRoot-&gt;ExtraFlags);
02326 
02327     <span class="keywordflow">if</span> ((<a class="code" href="../../d6/d9/heappage_8c.html#a51">RtlpDphDebugLevel</a> &amp; <a class="code" href="../../d6/d9/heappage_8c.html#a23">DPH_DEBUG_INTERNAL_VALIDATION</a>)) {
02328         <a class="code" href="../../d6/d9/heappage_8c.html#a106">RtlpDphInternalValidatePageHeap</a> (HeapRoot, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, 0);
02329     }
02330 
02331     <span class="keywordflow">return</span> <a class="code" href="../../d6/d9/heappage_8c.html#a12">HEAP_HANDLE_FROM_ROOT</a>( HeapRoot );       <span class="comment">// same as pVirtual</span>
02332 
02333 }
02334 
02335 PVOID
<a name="l02336"></a><a class="code" href="../../d7/d9/heappage_8h.html#a10">02336</a> <a class="code" href="../../d7/d9/heappage_8h.html#a10">RtlpDebugPageHeapAllocate</a>(
02337     IN PVOID  HeapHandle,
02338     IN ULONG  Flags,
02339     IN SIZE_T Size
02340     )
02341 {
02342     PDPH_HEAP_ROOT       HeapRoot;
02343     PDPH_HEAP_BLOCK pAvailNode;
02344     PDPH_HEAP_BLOCK pPrevAvailNode;
02345     PDPH_HEAP_BLOCK pBusyNode;
02346     SIZE_T               nBytesAllocate;
02347     SIZE_T               nBytesAccess;
02348     SIZE_T               nActual;
02349     PVOID                pVirtual;
02350     PVOID                pReturn;
02351     PUCHAR               pBlockHeader;
02352     ULONG Reason;
02353     BOOLEAN ForcePageHeap = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02354 
02355     <span class="keywordflow">if</span> (<a class="code" href="../../d6/d9/heappage_8c.html#a20">IS_BIASED_POINTER</a>(<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>)) {
02356         <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> = <a class="code" href="../../d6/d9/heappage_8c.html#a19">UNBIAS_POINTER</a>(<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>);
02357         ForcePageHeap = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02358     }
02359 
02360     HeapRoot = <a class="code" href="../../d6/d9/heappage_8c.html#a95">RtlpDebugPageHeapPointerFromHandle</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> );
02361     <span class="keywordflow">if</span> (HeapRoot == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)
02362         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02363 
02364     <span class="comment">//</span>
02365     <span class="comment">// Is zero size allocation ?</span>
02366     <span class="comment">//</span>
02367 
02368     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> == 0) {
02369 
02370         <span class="keywordflow">if</span> ((<a class="code" href="../../d6/d9/heappage_8c.html#a51">RtlpDphDebugLevel</a> &amp; <a class="code" href="../../d6/d9/heappage_8c.html#a28">DPH_DEBUG_BREAK_FOR_SIZE_ZERO</a>)) {
02371 
02372             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a> (<span class="stringliteral">"Page heap: request for zero sized block \n"</span>);
02373             DbgBreakPoint();
02374         }
02375     }
02376 
02377     <span class="comment">//</span>
02378     <span class="comment">// Get the heap lock.</span>
02379     <span class="comment">//</span>
02380 
02381     <a class="code" href="../../d6/d9/heappage_8c.html#a92">RtlpDebugPageHeapEnterCritSect</a>( HeapRoot, Flags );
02382     <a class="code" href="../../d6/d9/heappage_8c.html#a22">UNPROTECT_HEAP_STRUCTURES</a>( HeapRoot );
02383 
02384     <span class="comment">//</span>
02385     <span class="comment">// We cannot validate the heap when a forced allocation into page heap</span>
02386     <span class="comment">// is requested due to accounting problems. Allocate is called in this way</span>
02387     <span class="comment">// from ReAllocate while the old node (just about to be freed) is in limbo</span>
02388     <span class="comment">// and is not accounted in any internal structure.</span>
02389     <span class="comment">//</span>
02390 
02391     <span class="keywordflow">if</span> ((<a class="code" href="../../d6/d9/heappage_8c.html#a51">RtlpDphDebugLevel</a> &amp; <a class="code" href="../../d6/d9/heappage_8c.html#a23">DPH_DEBUG_INTERNAL_VALIDATION</a>) &amp;&amp; !ForcePageHeap) {
02392         <a class="code" href="../../d6/d9/heappage_8c.html#a106">RtlpDphInternalValidatePageHeap</a> (HeapRoot, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, 0);
02393     }
02394 
02395     Flags |= HeapRoot-&gt;HeapFlags;
02396 
02397     <span class="comment">//</span>
02398     <span class="comment">// Compute alloc statistics. Note that we need to</span>
02399     <span class="comment">// take the heap lock for this and unprotect the</span>
02400     <span class="comment">// heap structures.</span>
02401     <span class="comment">//</span>
02402 
02403     <a class="code" href="../../d6/d9/heappage_8c.html#a32">BUMP_GLOBAL_COUNTER</a> (DPH_COUNTER_NO_OF_ALLOCS);
02404     <a class="code" href="../../d6/d9/heappage_8c.html#a33">BUMP_SIZE_COUNTER</a> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>);
02405 
02406     HeapRoot-&gt;Counter[DPH_COUNTER_NO_OF_ALLOCS] += 1;
02407 
02408     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> &lt; 1024) {
02409         <a class="code" href="../../d6/d9/heappage_8c.html#a32">BUMP_GLOBAL_COUNTER</a> (DPH_COUNTER_SIZE_BELOW_1K);
02410         HeapRoot-&gt;Counter[DPH_COUNTER_SIZE_BELOW_1K] += 1;
02411     }
02412     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> &lt; 4096) {
02413         <a class="code" href="../../d6/d9/heappage_8c.html#a32">BUMP_GLOBAL_COUNTER</a> (DPH_COUNTER_SIZE_BELOW_4K);
02414         HeapRoot-&gt;Counter[DPH_COUNTER_SIZE_BELOW_4K] += 1;
02415     }
02416     <span class="keywordflow">else</span> {
02417         <a class="code" href="../../d6/d9/heappage_8c.html#a32">BUMP_GLOBAL_COUNTER</a> (DPH_COUNTER_SIZE_ABOVE_4K);
02418         HeapRoot-&gt;Counter[DPH_COUNTER_SIZE_ABOVE_4K] += 1;
02419     }
02420 
02421     <span class="comment">//</span>
02422     <span class="comment">// Figure out if we need to minimize memory impact. This</span>
02423     <span class="comment">// might trigger an allocation in the normal heap.</span>
02424     <span class="comment">//</span>
02425 
02426     <span class="keywordflow">if</span> (! ForcePageHeap) {
02427         
02428         <span class="keywordflow">if</span> (! (<a class="code" href="../../d6/d9/heappage_8c.html#a88">RtlpDphShouldAllocateInPageHeap</a> (HeapRoot, <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>))) {
02429 
02430             pReturn = <a class="code" href="../../d6/d9/heappage_8c.html#a69">RtlpDphNormalHeapAllocate</a> (
02431                 HeapRoot,
02432                 Flags,
02433                 <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>); 
02434 
02435             <span class="keywordflow">goto</span> <a class="code" href="../../d3/d9/arcinst_8c.html#a2">EXIT</a>;
02436         }
02437     }
02438 
02439     <span class="comment">//</span>
02440     <span class="comment">// Check the heap a little bit on checked builds.</span>
02441     <span class="comment">//</span>
02442 
02443     <a class="code" href="../../d6/d9/heappage_8c.html#a9">DEBUG_CODE</a>( RtlpDebugPageHeapVerifyIntegrity( HeapRoot ));
02444 
02445     pReturn = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02446 
02447     <span class="comment">//</span>
02448     <span class="comment">//  Validate requested size so we don't overflow</span>
02449     <span class="comment">//  while rounding up size computations.  We do this</span>
02450     <span class="comment">//  after we've acquired the critsect so we can still</span>
02451     <span class="comment">//  catch serialization problems.</span>
02452     <span class="comment">//</span>
02453 
02454     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> &gt; 0x7FFF0000) {
02455         <a class="code" href="../../d6/d9/heappage_8c.html#a14">OUT_OF_VM_BREAK</a>( Flags, <span class="stringliteral">"Page heap: Invalid allocation size\n"</span> );
02456         <span class="keywordflow">goto</span> <a class="code" href="../../d3/d9/arcinst_8c.html#a2">EXIT</a>;
02457     }
02458 
02459     <span class="comment">//</span>
02460     <span class="comment">//  Determine number of pages needed for READWRITE portion</span>
02461     <span class="comment">//  of allocation and add an extra page for the NO_ACCESS</span>
02462     <span class="comment">//  memory beyond the READWRITE page(s).</span>
02463     <span class="comment">//</span>
02464 
02465     nBytesAccess  = <a class="code" href="../../d6/d9/heappage_8c.html#a8">ROUNDUP2</a>( <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> + <span class="keyword">sizeof</span>(DPH_BLOCK_INFORMATION), <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> );
02466     nBytesAllocate = nBytesAccess + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
02467 
02468     <span class="comment">//</span>
02469     <span class="comment">//  RtlpDebugPageHeapFindAvailableMem will first attempt to satisfy</span>
02470     <span class="comment">//  the request from memory on the Available list.  If that fails,</span>
02471     <span class="comment">//  it will coalesce some of the Free list memory into the Available</span>
02472     <span class="comment">//  list and try again.  If that still fails, new VM is allocated and</span>
02473     <span class="comment">//  added to the Available list.  If that fails, the function will</span>
02474     <span class="comment">//  finally give up and return NULL.</span>
02475     <span class="comment">//</span>
02476 
02477     pAvailNode = <a class="code" href="../../d6/d9/heappage_8c.html#a120">RtlpDebugPageHeapFindAvailableMem</a>(
02478         HeapRoot,
02479         nBytesAllocate,
02480         &amp;pPrevAvailNode,
02481         <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>
02482         );
02483 
02484     <span class="keywordflow">if</span> (pAvailNode == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02485         <a class="code" href="../../d6/d9/heappage_8c.html#a14">OUT_OF_VM_BREAK</a>( Flags, <span class="stringliteral">"Page heap: Unable to allocate virtual memory\n"</span> );
02486         <span class="keywordflow">goto</span> <a class="code" href="../../d3/d9/arcinst_8c.html#a2">EXIT</a>;
02487     }
02488 
02489     <span class="comment">//</span>
02490     <span class="comment">//  Now can't call AllocateNode until pAvailNode is</span>
02491     <span class="comment">//  adjusted and/or removed from Avail list since AllocateNode</span>
02492     <span class="comment">//  might adjust the Avail list.</span>
02493     <span class="comment">//</span>
02494 
02495     pVirtual = pAvailNode-&gt;pVirtualBlock;
02496 
02497     <span class="keywordflow">if</span> (nBytesAccess &gt; 0) {
02498 
02499         <span class="keywordflow">if</span> ((HeapRoot-&gt;ExtraFlags &amp; PAGE_HEAP_CATCH_BACKWARD_OVERRUNS)) {
02500 
02501             <span class="keywordflow">if</span> (! <a class="code" href="../../d6/d9/heappage_8c.html#a98">RtlpDebugPageHeapProtectVM</a>( (PUCHAR)pVirtual + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>, nBytesAccess, PAGE_READWRITE )) {
02502                 <span class="keywordflow">goto</span> <a class="code" href="../../d3/d9/arcinst_8c.html#a2">EXIT</a>;
02503             }
02504         }
02505         <span class="keywordflow">else</span> {
02506 
02507             <span class="keywordflow">if</span> (! <a class="code" href="../../d6/d9/heappage_8c.html#a98">RtlpDebugPageHeapProtectVM</a>( pVirtual, nBytesAccess, PAGE_READWRITE )) {
02508                 <span class="keywordflow">goto</span> <a class="code" href="../../d3/d9/arcinst_8c.html#a2">EXIT</a>;
02509             }
02510         }
02511     }
02512 
02513     <span class="comment">//</span>
02514     <span class="comment">// If we use uncommitted ranges we need to decommit the protection</span>
02515     <span class="comment">// page at the end. BAckward overruns flag disables smart memory </span>
02516     <span class="comment">// usage flag.</span>
02517     <span class="comment">//</span>
02518 
02519     <span class="keywordflow">if</span> ((HeapRoot-&gt;ExtraFlags &amp; PAGE_HEAP_CATCH_BACKWARD_OVERRUNS)) {
02520 
02521         <span class="comment">// nothing            </span>
02522 
02523     }
02524     <span class="keywordflow">else</span> {
02525 
02526         <span class="keywordflow">if</span> ((HeapRoot-&gt;ExtraFlags &amp; PAGE_HEAP_SMART_MEMORY_USAGE)) {
02527 
02528             <a class="code" href="../../d6/d9/heappage_8c.html#a102">RtlpDebugPageHeapDecommitVM</a> (
02529                 (PCHAR)pVirtual + nBytesAccess, 
02530                 <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
02531         }
02532     }
02533 
02534     <span class="comment">//</span>
02535     <span class="comment">//  pAvailNode (still on avail list) points to block large enough</span>
02536     <span class="comment">//  to satisfy request, but it might be large enough to split</span>
02537     <span class="comment">//  into two blocks -- one for request, remainder leave on</span>
02538     <span class="comment">//  avail list.</span>
02539     <span class="comment">//</span>
02540 
02541     <span class="keywordflow">if</span> (pAvailNode-&gt;nVirtualBlockSize &gt; nBytesAllocate) {
02542 
02543         <span class="comment">//</span>
02544         <span class="comment">//  Adjust pVirtualBlock and nVirtualBlock size of existing</span>
02545         <span class="comment">//  node in avail list.  The node will still be in correct</span>
02546         <span class="comment">//  address space order on the avail list.  This saves having</span>
02547         <span class="comment">//  to remove and then re-add node to avail list.  Note since</span>
02548         <span class="comment">//  we're changing sizes directly, we need to adjust the</span>
02549         <span class="comment">//  avail and busy list counters manually.</span>
02550         <span class="comment">//</span>
02551         <span class="comment">//  Note: since we're leaving at least one page on the</span>
02552         <span class="comment">//  available list, we are guaranteed that AllocateNode</span>
02553         <span class="comment">//  will not fail.</span>
02554         <span class="comment">//</span>
02555 
02556         pAvailNode-&gt;pVirtualBlock                    += nBytesAllocate;
02557         pAvailNode-&gt;nVirtualBlockSize                -= nBytesAllocate;
02558         HeapRoot-&gt;nAvailableAllocationBytesCommitted -= nBytesAllocate;
02559 
02560         pBusyNode = <a class="code" href="../../d6/d9/heappage_8c.html#a123">RtlpDebugPageHeapAllocateNode</a>( HeapRoot );
02561 
02562         <a class="code" href="../../d6/d9/heappage_8c.html#a11">DEBUG_ASSERT</a>( pBusyNode != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
02563 
02564         pBusyNode-&gt;pVirtualBlock     = pVirtual;
02565         pBusyNode-&gt;nVirtualBlockSize = nBytesAllocate;
02566 
02567     }
02568 
02569     <span class="keywordflow">else</span> {
02570 
02571         <span class="comment">//</span>
02572         <span class="comment">//  Entire avail block is needed, so simply remove it from avail list.</span>
02573         <span class="comment">//</span>
02574 
02575         <a class="code" href="../../d6/d9/heappage_8c.html#a110">RtlpDebugPageHeapRemoveFromAvailableList</a>( HeapRoot, pAvailNode, pPrevAvailNode );
02576 
02577         pBusyNode = pAvailNode;
02578 
02579     }
02580 
02581     <span class="comment">//</span>
02582     <span class="comment">//  Now pBusyNode points to our committed virtual block.</span>
02583     <span class="comment">//</span>
02584 
02585     <span class="keywordflow">if</span> (HeapRoot-&gt;HeapFlags &amp; <a class="code" href="../../d7/d9/heappage_8h.html#a4">HEAP_NO_ALIGNMENT</a>)
02586         nActual = <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
02587     <span class="keywordflow">else</span>
02588         nActual = <a class="code" href="../../d6/d9/heappage_8c.html#a8">ROUNDUP2</a>( <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>, USER_ALIGNMENT );
02589 
02590     pBusyNode-&gt;nVirtualAccessSize = nBytesAccess;
02591     pBusyNode-&gt;nUserRequestedSize = <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
02592     pBusyNode-&gt;nUserActualSize    = nActual;
02593 
02594     <span class="keywordflow">if</span> ((HeapRoot-&gt;ExtraFlags &amp; PAGE_HEAP_CATCH_BACKWARD_OVERRUNS)) {
02595 
02596         pBusyNode-&gt;pUserAllocation    = pBusyNode-&gt;pVirtualBlock
02597             + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
02598     }
02599     <span class="keywordflow">else</span> {
02600 
02601         pBusyNode-&gt;pUserAllocation    = pBusyNode-&gt;pVirtualBlock
02602             + pBusyNode-&gt;nVirtualAccessSize
02603             - nActual;
02604     }
02605 
02606     pBusyNode-&gt;UserValue          = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02607     pBusyNode-&gt;UserFlags          = Flags &amp; HEAP_SETTABLE_USER_FLAGS;
02608 
02609     <span class="comment">//</span>
02610     <span class="comment">//  RtlpDebugPageHeapAllocate gets called from RtlDebugAllocateHeap,</span>
02611     <span class="comment">//  which gets called from RtlAllocateHeapSlowly, which gets called</span>
02612     <span class="comment">//  from RtlAllocateHeap.  To keep from wasting lots of stack trace</span>
02613     <span class="comment">//  storage, we'll skip the bottom 3 entries, leaving RtlAllocateHeap</span>
02614     <span class="comment">//  as the first recorded entry.</span>
02615     <span class="comment">//</span>
02616 
02617     <span class="keywordflow">if</span> ((HeapRoot-&gt;ExtraFlags &amp; PAGE_HEAP_COLLECT_STACK_TRACES)) {
02618 
02619         pBusyNode-&gt;StackTrace = <a class="code" href="../../d6/d9/heappage_8c.html#a89">RtlpDphLogStackTrace</a>(3);
02620 
02621         <span class="keywordflow">if</span> (pBusyNode-&gt;StackTrace) {
02622 
02623             RtlTraceDatabaseLock (<a class="code" href="../../d6/d9/heappage_8c.html#a56">RtlpDphTraceDatabase</a>);
02624             pBusyNode-&gt;StackTrace-&gt;UserCount += 1;
02625             pBusyNode-&gt;StackTrace-&gt;UserSize += pBusyNode-&gt;nUserRequestedSize;
02626             pBusyNode-&gt;StackTrace-&gt;UserContext = HeapRoot;
02627             RtlTraceDatabaseUnlock (<a class="code" href="../../d6/d9/heappage_8c.html#a56">RtlpDphTraceDatabase</a>);
02628         }
02629     }
02630     <span class="keywordflow">else</span> {
02631         pBusyNode-&gt;StackTrace = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02632     }
02633 
02634     <a class="code" href="../../d6/d9/heappage_8c.html#a114">RtlpDebugPageHeapPlaceOnBusyList</a>( HeapRoot, pBusyNode );
02635 
02636     pReturn = pBusyNode-&gt;pUserAllocation;
02637 
02638     <span class="comment">//</span>
02639     <span class="comment">//  For requests the specify HEAP_ZERO_MEMORY, we'll fill the</span>
02640     <span class="comment">//  user-requested portion of the block with zeros. For requests </span>
02641     <span class="comment">//  that don't specify HEAP_ZERO_MEMORY, we fill the whole user block</span>
02642     <span class="comment">//  with DPH_PAGE_BLOCK_INFIX.</span>
02643     <span class="comment">//</span>
02644 
02645     <span class="keywordflow">if</span> ((Flags &amp; HEAP_ZERO_MEMORY)) {
02646 
02647         <span class="comment">//</span>
02648         <span class="comment">// SilviuC: The call below can be saved if we have a way</span>
02649         <span class="comment">// to figure out if the memory for the block was freshly</span>
02650         <span class="comment">// virtual allocated (this is already zeroed). This has</span>
02651         <span class="comment">// an impact for large allocations.</span>
02652         <span class="comment">//</span>
02653 
02654         RtlZeroMemory( pBusyNode-&gt;pUserAllocation, <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> );
02655     }
02656     <span class="keywordflow">else</span> {
02657 
02658         RtlFillMemory( pBusyNode-&gt;pUserAllocation, <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>, DPH_PAGE_BLOCK_INFIX);
02659     }
02660 
02661     <span class="keywordflow">if</span> ((HeapRoot-&gt;ExtraFlags &amp; PAGE_HEAP_CATCH_BACKWARD_OVERRUNS)) {
02662 
02663         <span class="comment">// nothing</span>
02664 
02665     }
02666     <span class="keywordflow">else</span> {
02667 
02668         <a class="code" href="../../d6/d9/heappage_8c.html#a82">RtlpDphWritePageHeapBlockInformation</a> (
02669             HeapRoot,
02670             pBusyNode-&gt;pUserAllocation,
02671             <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>,
02672             nBytesAccess);
02673     }
02674 
02675     <a class="code" href="../../d3/d9/arcinst_8c.html#a2">EXIT</a>:
02676 
02677     <span class="keywordflow">if</span> ((<a class="code" href="../../d6/d9/heappage_8c.html#a51">RtlpDphDebugLevel</a> &amp; <a class="code" href="../../d6/d9/heappage_8c.html#a23">DPH_DEBUG_INTERNAL_VALIDATION</a>) &amp;&amp; !ForcePageHeap) {
02678         <a class="code" href="../../d6/d9/heappage_8c.html#a106">RtlpDphInternalValidatePageHeap</a> (HeapRoot, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, 0);
02679     }
02680 
02681     <a class="code" href="../../d6/d9/heappage_8c.html#a21">PROTECT_HEAP_STRUCTURES</a>( HeapRoot );
02682     <a class="code" href="../../d6/d9/heappage_8c.html#a9">DEBUG_CODE</a>( RtlpDebugPageHeapVerifyIntegrity( HeapRoot ));
02683     <a class="code" href="../../d6/d9/heappage_8c.html#a93">RtlpDebugPageHeapLeaveCritSect</a>( HeapRoot );
02684 
02685     <span class="keywordflow">if</span> (pReturn == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02686         <a class="code" href="../../d6/d9/heappage_8c.html#a13">IF_GENERATE_EXCEPTION</a>( Flags, STATUS_NO_MEMORY );
02687     }
02688 
02689     <span class="keywordflow">return</span> pReturn;
02690 }
02691 
02692 BOOLEAN
<a name="l02693"></a><a class="code" href="../../d7/d9/heappage_8h.html#a11">02693</a> <a class="code" href="../../d7/d9/heappage_8h.html#a11">RtlpDebugPageHeapFree</a>(
02694     IN PVOID HeapHandle,
02695     IN ULONG Flags,
02696     IN PVOID Address
02697     )
02698 {
02699 
02700     PDPH_HEAP_ROOT       HeapRoot;
02701     PDPH_HEAP_BLOCK Node, Prev;
02702     BOOLEAN              Success;
02703     PCH                  p;
02704     ULONG Reason;
02705 
02706     <span class="comment">//</span>
02707     <span class="comment">// Check if null frees are of any concern.</span>
02708     <span class="comment">//</span>
02709 
02710     <span class="keywordflow">if</span> (Address == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02711 
02712         <span class="keywordflow">if</span> ((<a class="code" href="../../d6/d9/heappage_8c.html#a51">RtlpDphDebugLevel</a> &amp; <a class="code" href="../../d6/d9/heappage_8c.html#a29">DPH_DEBUG_BREAK_FOR_NULL_FREE</a>)) {
02713 
02714             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a> (<span class="stringliteral">"Page heap: attempt to free null pointer \n"</span>);
02715             DbgBreakPoint();
02716         }
02717 
02718         <span class="comment">//</span>
02719         <span class="comment">// For C++ apps that delete NULL this is valid.</span>
02720         <span class="comment">//</span>
02721 
02722         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02723     }
02724 
02725     HeapRoot = <a class="code" href="../../d6/d9/heappage_8c.html#a95">RtlpDebugPageHeapPointerFromHandle</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> );
02726     <span class="keywordflow">if</span> (HeapRoot == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)
02727         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02728 
02729     <span class="comment">//</span>
02730     <span class="comment">// Acquire heap lock and unprotect heap structures.</span>
02731     <span class="comment">//</span>
02732 
02733     <a class="code" href="../../d6/d9/heappage_8c.html#a92">RtlpDebugPageHeapEnterCritSect</a>( HeapRoot, Flags );
02734     <a class="code" href="../../d6/d9/heappage_8c.html#a9">DEBUG_CODE</a>( RtlpDebugPageHeapVerifyIntegrity( HeapRoot ));
02735     <a class="code" href="../../d6/d9/heappage_8c.html#a22">UNPROTECT_HEAP_STRUCTURES</a>( HeapRoot );
02736 
02737     <span class="keywordflow">if</span> ((<a class="code" href="../../d6/d9/heappage_8c.html#a51">RtlpDphDebugLevel</a> &amp; <a class="code" href="../../d6/d9/heappage_8c.html#a23">DPH_DEBUG_INTERNAL_VALIDATION</a>)) {
02738         <a class="code" href="../../d6/d9/heappage_8c.html#a106">RtlpDphInternalValidatePageHeap</a> (HeapRoot, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, 0);
02739     }
02740 
02741     Flags |= HeapRoot-&gt;HeapFlags;
02742 
02743     <span class="comment">//</span>
02744     <span class="comment">// Compute free statistics</span>
02745     <span class="comment">//</span>
02746 
02747     <a class="code" href="../../d6/d9/heappage_8c.html#a32">BUMP_GLOBAL_COUNTER</a> (DPH_COUNTER_NO_OF_FREES);
02748     HeapRoot-&gt;Counter[DPH_COUNTER_NO_OF_FREES] += 1;
02749 
02750 
02751     Success = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02752 
02753     Node = <a class="code" href="../../d6/d9/heappage_8c.html#a109">RtlpDebugPageHeapFindBusyMem</a>( HeapRoot, Address, &amp;Prev );
02754 
02755     <span class="keywordflow">if</span> (Node == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02756 
02757         <span class="comment">//</span>
02758         <span class="comment">// No wonder we did not find the block in the page heap</span>
02759         <span class="comment">// structures because the block was probably allocated</span>
02760         <span class="comment">// from the normal heap. Or there is a real bug.</span>
02761         <span class="comment">// If there is a bug NormalHeapFree will break into debugger.</span>
02762         <span class="comment">//</span>
02763 
02764         Success = <a class="code" href="../../d6/d9/heappage_8c.html#a70">RtlpDphNormalHeapFree</a> (
02765 
02766             HeapRoot,
02767             Flags,
02768             Address);
02769 
02770         <span class="keywordflow">goto</span> <a class="code" href="../../d3/d9/arcinst_8c.html#a2">EXIT</a>;
02771     }
02772 
02773     <span class="comment">//</span>
02774     <span class="comment">//  If tail was allocated, make sure filler not overwritten</span>
02775     <span class="comment">//</span>
02776 
02777     <span class="keywordflow">if</span> ((HeapRoot-&gt;ExtraFlags &amp; PAGE_HEAP_CATCH_BACKWARD_OVERRUNS)) {
02778 
02779         <span class="keywordflow">if</span> (Node-&gt;nVirtualAccessSize &gt; 0) {
02780             <a class="code" href="../../d6/d9/heappage_8c.html#a98">RtlpDebugPageHeapProtectVM</a>( Node-&gt;pVirtualBlock + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>,
02781                 Node-&gt;nVirtualAccessSize,
02782                 PAGE_NOACCESS );
02783         }
02784     }
02785     <span class="keywordflow">else</span> {
02786 
02787         <span class="comment">//</span>
02788         <span class="comment">// (SilviuC): This can be done at the beginning of the function.</span>
02789         <span class="comment">//</span>
02790 
02791         <span class="keywordflow">if</span> (! (<a class="code" href="../../d6/d9/heappage_8c.html#a80">RtlpDphIsPageHeapBlock</a> (HeapRoot, Address, &amp;Reason, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>))) {
02792 
02793             <a class="code" href="../../d6/d9/heappage_8c.html#a77">RtlpDphReportCorruptedBlock</a> (Address, Reason);
02794         }
02795 
02796         <span class="keywordflow">if</span> (Node-&gt;nVirtualAccessSize &gt; 0) {
02797 
02798             <span class="comment">//</span>
02799             <span class="comment">// Mark the block as freed. The information is gone if we</span>
02800             <span class="comment">// will decommit the region but will remain if smart memory</span>
02801             <span class="comment">// flag is not set and can help debug failures.</span>
02802             <span class="comment">//</span>
02803             
02804             {
02805                 PDPH_BLOCK_INFORMATION Info = (PDPH_BLOCK_INFORMATION)(Node-&gt;pUserAllocation);
02806 
02807                 Info -= 1;
02808                 Info-&gt;StartStamp -= 1;
02809                 Info-&gt;EndStamp -= 1;
02810             }
02811 
02812             <a class="code" href="../../d6/d9/heappage_8c.html#a98">RtlpDebugPageHeapProtectVM</a>( Node-&gt;pVirtualBlock,
02813                 Node-&gt;nVirtualAccessSize,
02814                 PAGE_NOACCESS );
02815         }
02816     }
02817 
02818     <a class="code" href="../../d6/d9/heappage_8c.html#a115">RtlpDebugPageHeapRemoveFromBusyList</a>( HeapRoot, Node, Prev );
02819 
02820     <span class="comment">//</span>
02821     <span class="comment">// If we use uncommitted ranges we need to decommit the memory</span>
02822     <span class="comment">// range now for the allocation. Note that the next page (guard) </span>
02823     <span class="comment">// was already decommitted when we allocated the block.</span>
02824     <span class="comment">//</span>
02825 
02826     <span class="keywordflow">if</span> ((HeapRoot-&gt;ExtraFlags &amp; PAGE_HEAP_CATCH_BACKWARD_OVERRUNS)) {
02827 
02828         <span class="comment">// nothing            </span>
02829 
02830     }
02831     <span class="keywordflow">else</span> {
02832 
02833         <span class="keywordflow">if</span> ((HeapRoot-&gt;ExtraFlags &amp; PAGE_HEAP_SMART_MEMORY_USAGE)) {
02834 
02835             <a class="code" href="../../d6/d9/heappage_8c.html#a102">RtlpDebugPageHeapDecommitVM</a> (
02836                 Node-&gt;pVirtualBlock, 
02837                 Node-&gt;nVirtualAccessSize);
02838         }
02839     }
02840 
02841 
02842     <a class="code" href="../../d6/d9/heappage_8c.html#a111">RtlpDebugPageHeapPlaceOnFreeList</a>( HeapRoot, Node );
02843 
02844     <span class="comment">//</span>
02845     <span class="comment">//  RtlpDebugPageHeapFree gets called from RtlDebugFreeHeap, which</span>
02846     <span class="comment">//  gets called from RtlFreeHeapSlowly, which gets called from</span>
02847     <span class="comment">//  RtlFreeHeap.  To keep from wasting lots of stack trace storage,</span>
02848     <span class="comment">//  we'll skip the bottom 3 entries, leaving RtlFreeHeap as the</span>
02849     <span class="comment">//  first recorded entry.</span>
02850     <span class="comment">//</span>
02851 
02852     <span class="keywordflow">if</span> ((HeapRoot-&gt;ExtraFlags &amp; PAGE_HEAP_COLLECT_STACK_TRACES)) {
02853 
02854         <span class="keywordflow">if</span> (Node-&gt;StackTrace) {
02855 
02856             RtlTraceDatabaseLock (<a class="code" href="../../d6/d9/heappage_8c.html#a56">RtlpDphTraceDatabase</a>);
02857 
02858             <span class="keywordflow">if</span> (Node-&gt;StackTrace-&gt;UserCount &gt; 0) {
02859                 Node-&gt;StackTrace-&gt;UserCount -= 1;
02860             }
02861 
02862             <span class="keywordflow">if</span> (Node-&gt;StackTrace-&gt;UserSize &gt;= Node-&gt;nUserRequestedSize) {
02863                 Node-&gt;StackTrace-&gt;UserSize -= Node-&gt;nUserRequestedSize;
02864             }
02865 
02866             RtlTraceDatabaseUnlock (<a class="code" href="../../d6/d9/heappage_8c.html#a56">RtlpDphTraceDatabase</a>);
02867         }
02868 
02869         Node-&gt;StackTrace = <a class="code" href="../../d6/d9/heappage_8c.html#a89">RtlpDphLogStackTrace</a>(3);
02870     }
02871     <span class="keywordflow">else</span> {
02872         Node-&gt;StackTrace = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02873     }
02874 
02875     Success = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02876 
02877     <a class="code" href="../../d3/d9/arcinst_8c.html#a2">EXIT</a>:
02878 
02879     <span class="keywordflow">if</span> ((<a class="code" href="../../d6/d9/heappage_8c.html#a51">RtlpDphDebugLevel</a> &amp; <a class="code" href="../../d6/d9/heappage_8c.html#a23">DPH_DEBUG_INTERNAL_VALIDATION</a>)) {
02880         <a class="code" href="../../d6/d9/heappage_8c.html#a106">RtlpDphInternalValidatePageHeap</a> (HeapRoot, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, 0);
02881     }
02882 
02883     <a class="code" href="../../d6/d9/heappage_8c.html#a21">PROTECT_HEAP_STRUCTURES</a>( HeapRoot );
02884     <a class="code" href="../../d6/d9/heappage_8c.html#a9">DEBUG_CODE</a>( RtlpDebugPageHeapVerifyIntegrity( HeapRoot ));
02885     <a class="code" href="../../d6/d9/heappage_8c.html#a93">RtlpDebugPageHeapLeaveCritSect</a>( HeapRoot );
02886 
02887     <span class="keywordflow">if</span> (! Success) {
02888         <a class="code" href="../../d6/d9/heappage_8c.html#a13">IF_GENERATE_EXCEPTION</a>( Flags, STATUS_ACCESS_VIOLATION );
02889     }
02890 
02891     <span class="keywordflow">return</span> Success;
02892 }
02893 
02894 PVOID
<a name="l02895"></a><a class="code" href="../../d7/d9/heappage_8h.html#a12">02895</a> <a class="code" href="../../d7/d9/heappage_8h.html#a12">RtlpDebugPageHeapReAllocate</a>(
02896     IN PVOID  HeapHandle,
02897     IN ULONG  Flags,
02898     IN PVOID  Address,
02899     IN SIZE_T Size
02900     )
02901 {
02902     PDPH_HEAP_ROOT       HeapRoot;
02903     PDPH_HEAP_BLOCK OldNode, OldPrev, NewNode;
02904     PVOID                NewAddress;
02905     PUCHAR               p;
02906     SIZE_T               CopyDataSize;
02907     ULONG                SaveFlags;
02908     BOOLEAN ReallocInNormalHeap = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02909     ULONG Reason;
02910     BOOLEAN ForcePageHeap = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02911     BOOLEAN OriginalAllocationInPageHeap = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02912 
02913     <span class="keywordflow">if</span> (<a class="code" href="../../d6/d9/heappage_8c.html#a20">IS_BIASED_POINTER</a>(<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>)) {
02914         <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> = <a class="code" href="../../d6/d9/heappage_8c.html#a19">UNBIAS_POINTER</a>(<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>);
02915         ForcePageHeap = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02916     }
02917 
02918     <span class="comment">//</span>
02919     <span class="comment">// Is zero size allocation ?</span>
02920     <span class="comment">//</span>
02921 
02922     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> == 0) {
02923 
02924         <span class="keywordflow">if</span> ((<a class="code" href="../../d6/d9/heappage_8c.html#a51">RtlpDphDebugLevel</a> &amp; <a class="code" href="../../d6/d9/heappage_8c.html#a28">DPH_DEBUG_BREAK_FOR_SIZE_ZERO</a>)) {
02925 
02926             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a> (<span class="stringliteral">"Page heap: request for zero sized block \n"</span>);
02927             DbgBreakPoint();
02928         }
02929     }
02930 
02931     HeapRoot = <a class="code" href="../../d6/d9/heappage_8c.html#a95">RtlpDebugPageHeapPointerFromHandle</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> );
02932     <span class="keywordflow">if</span> (HeapRoot == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)
02933         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02934 
02935     <span class="comment">//</span>
02936     <span class="comment">// Get heap lock and unprotect heap structures.</span>
02937     <span class="comment">//</span>
02938 
02939     <a class="code" href="../../d6/d9/heappage_8c.html#a92">RtlpDebugPageHeapEnterCritSect</a>( HeapRoot, Flags );
02940     <a class="code" href="../../d6/d9/heappage_8c.html#a9">DEBUG_CODE</a>( RtlpDebugPageHeapVerifyIntegrity( HeapRoot ));
02941     <a class="code" href="../../d6/d9/heappage_8c.html#a22">UNPROTECT_HEAP_STRUCTURES</a>( HeapRoot );
02942 
02943     <span class="keywordflow">if</span> ((<a class="code" href="../../d6/d9/heappage_8c.html#a51">RtlpDphDebugLevel</a> &amp; <a class="code" href="../../d6/d9/heappage_8c.html#a23">DPH_DEBUG_INTERNAL_VALIDATION</a>)) {
02944         <a class="code" href="../../d6/d9/heappage_8c.html#a106">RtlpDphInternalValidatePageHeap</a> (HeapRoot, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, 0);
02945     }
02946 
02947     Flags |= HeapRoot-&gt;HeapFlags;
02948 
02949     <span class="comment">//</span>
02950     <span class="comment">// Compute realloc statistics</span>
02951     <span class="comment">//</span>
02952 
02953     <a class="code" href="../../d6/d9/heappage_8c.html#a32">BUMP_GLOBAL_COUNTER</a> (DPH_COUNTER_NO_OF_REALLOCS);
02954     <a class="code" href="../../d6/d9/heappage_8c.html#a33">BUMP_SIZE_COUNTER</a> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>);
02955 
02956     HeapRoot-&gt;Counter[DPH_COUNTER_NO_OF_REALLOCS] += 1;
02957 
02958     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> &lt; 1024) {
02959         <a class="code" href="../../d6/d9/heappage_8c.html#a32">BUMP_GLOBAL_COUNTER</a> (DPH_COUNTER_SIZE_BELOW_1K);
02960         HeapRoot-&gt;Counter[DPH_COUNTER_SIZE_BELOW_1K] += 1;
02961     }
02962     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> &lt; 4096) {
02963         <a class="code" href="../../d6/d9/heappage_8c.html#a32">BUMP_GLOBAL_COUNTER</a> (DPH_COUNTER_SIZE_BELOW_4K);
02964         HeapRoot-&gt;Counter[DPH_COUNTER_SIZE_BELOW_4K] += 1;
02965     }
02966     <span class="keywordflow">else</span> {
02967         <a class="code" href="../../d6/d9/heappage_8c.html#a32">BUMP_GLOBAL_COUNTER</a> (DPH_COUNTER_SIZE_ABOVE_4K);
02968         HeapRoot-&gt;Counter[DPH_COUNTER_SIZE_ABOVE_4K] += 1;
02969     }
02970 
02971 
02972     NewAddress = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02973 
02974     <span class="comment">//</span>
02975     <span class="comment">//  Check Flags for non-moveable reallocation and fail it</span>
02976     <span class="comment">//  unconditionally.  Apps that specify this flag should be</span>
02977     <span class="comment">//  prepared to deal with failure anyway.</span>
02978     <span class="comment">//</span>
02979 
02980     <span class="keywordflow">if</span> (Flags &amp; HEAP_REALLOC_IN_PLACE_ONLY) {
02981         <span class="keywordflow">goto</span> <a class="code" href="../../d3/d9/arcinst_8c.html#a2">EXIT</a>;
02982     }
02983 
02984     <span class="comment">//</span>
02985     <span class="comment">//  Validate requested size so we don't overflow</span>
02986     <span class="comment">//  while rounding up size computations.  We do this</span>
02987     <span class="comment">//  after we've acquired the critsect so we can still</span>
02988     <span class="comment">//  catch serialization problems.</span>
02989     <span class="comment">//</span>
02990 
02991     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> &gt; 0x7FFF0000) {
02992         <a class="code" href="../../d6/d9/heappage_8c.html#a14">OUT_OF_VM_BREAK</a>( Flags, <span class="stringliteral">"Page heap: Invalid allocation size\n"</span> );
02993         <span class="keywordflow">goto</span> <a class="code" href="../../d3/d9/arcinst_8c.html#a2">EXIT</a>;
02994     }
02995 
02996     OldNode = <a class="code" href="../../d6/d9/heappage_8c.html#a109">RtlpDebugPageHeapFindBusyMem</a>( HeapRoot, Address, &amp;OldPrev );
02997 
02998     <span class="keywordflow">if</span> (OldNode) {
02999         OriginalAllocationInPageHeap = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03000     }
03001 
03002     <span class="keywordflow">if</span> (OldNode == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03003 
03004         <span class="comment">//</span>
03005         <span class="comment">// No wonder we did not find the block in the page heap</span>
03006         <span class="comment">// structures because the block was probably allocated</span>
03007         <span class="comment">// from the normal heap. Or there is a real bug. If there </span>
03008         <span class="comment">// is a bug NormalHeapReAllocate will break into debugger.</span>
03009         <span class="comment">//</span>
03010 
03011         NewAddress = <a class="code" href="../../d6/d9/heappage_8c.html#a71">RtlpDphNormalHeapReAllocate</a> (
03012 
03013             HeapRoot,
03014             Flags,
03015             Address,
03016             <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>);
03017 
03018         <span class="keywordflow">goto</span> <a class="code" href="../../d3/d9/arcinst_8c.html#a2">EXIT</a>;
03019     }
03020 
03021     <span class="comment">//</span>
03022     <span class="comment">//  If tail was allocated, make sure filler not overwritten</span>
03023     <span class="comment">//</span>
03024 
03025     <span class="keywordflow">if</span> ((HeapRoot-&gt;ExtraFlags &amp; PAGE_HEAP_CATCH_BACKWARD_OVERRUNS)) {
03026 
03027         <span class="comment">// nothing</span>
03028     }
03029     <span class="keywordflow">else</span> {
03030 
03031         <span class="comment">//</span>
03032         <span class="comment">// (SilviuC): This can be done at the beginning of the function.</span>
03033         <span class="comment">//</span>
03034 
03035         <span class="keywordflow">if</span> (! (<a class="code" href="../../d6/d9/heappage_8c.html#a80">RtlpDphIsPageHeapBlock</a> (HeapRoot, Address, &amp;Reason, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>))) {
03036 
03037             <a class="code" href="../../d6/d9/heappage_8c.html#a77">RtlpDphReportCorruptedBlock</a> (Address, Reason);
03038         }
03039     }
03040 
03041     <span class="comment">//</span>
03042     <span class="comment">//  Before allocating a new block, remove the old block from</span>
03043     <span class="comment">//  the busy list.  When we allocate the new block, the busy</span>
03044     <span class="comment">//  list pointers will change, possibly leaving our acquired</span>
03045     <span class="comment">//  Prev pointer invalid.</span>
03046     <span class="comment">//</span>
03047 
03048     <a class="code" href="../../d6/d9/heappage_8c.html#a115">RtlpDebugPageHeapRemoveFromBusyList</a>( HeapRoot, OldNode, OldPrev );
03049 
03050     <span class="comment">//</span>
03051     <span class="comment">//  Allocate new memory for new requested size.  Use try/except</span>
03052     <span class="comment">//  to trap exception if Flags caused out-of-memory exception.</span>
03053     <span class="comment">//</span>
03054 
03055     <span class="keywordflow">try</span> {
03056 
03057         <span class="keywordflow">if</span> (!ForcePageHeap &amp;&amp; !(<a class="code" href="../../d6/d9/heappage_8c.html#a88">RtlpDphShouldAllocateInPageHeap</a> (HeapRoot, <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>))) {
03058 
03059             NewAddress = <a class="code" href="../../d6/d9/heappage_8c.html#a69">RtlpDphNormalHeapAllocate</a> (
03060                 HeapRoot, 
03061                 Flags, 
03062                 <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>);
03063 
03064             ReallocInNormalHeap = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03065         }
03066         <span class="keywordflow">else</span> {
03067 
03068             <span class="comment">//</span>
03069             <span class="comment">// Force the allocation in page heap by biasing</span>
03070             <span class="comment">// the heap handle. Validate the heap here since when we use</span>
03071             <span class="comment">// biased pointers validation inside Allocate is disabled.</span>
03072             <span class="comment">//</span>
03073 
03074             <span class="keywordflow">if</span> ((<a class="code" href="../../d6/d9/heappage_8c.html#a51">RtlpDphDebugLevel</a> &amp; <a class="code" href="../../d6/d9/heappage_8c.html#a23">DPH_DEBUG_INTERNAL_VALIDATION</a>)) {
03075                 <a class="code" href="../../d6/d9/heappage_8c.html#a106">RtlpDphInternalValidatePageHeap</a> (HeapRoot, OldNode-&gt;pVirtualBlock, OldNode-&gt;nVirtualBlockSize);
03076             }
03077 
03078             NewAddress = <a class="code" href="../../d7/d9/heappage_8h.html#a10">RtlpDebugPageHeapAllocate</a>( 
03079                 <a class="code" href="../../d2/d3/ldrsnap_8c.html#a20">BIAS_POINTER</a>(<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>), 
03080                 Flags, 
03081                 <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>);
03082 
03083             
03084             <span class="keywordflow">if</span> ((<a class="code" href="../../d6/d9/heappage_8c.html#a51">RtlpDphDebugLevel</a> &amp; <a class="code" href="../../d6/d9/heappage_8c.html#a23">DPH_DEBUG_INTERNAL_VALIDATION</a>)) {
03085                 <a class="code" href="../../d6/d9/heappage_8c.html#a106">RtlpDphInternalValidatePageHeap</a> (HeapRoot, OldNode-&gt;pVirtualBlock, OldNode-&gt;nVirtualBlockSize);
03086             }
03087 
03088             ReallocInNormalHeap = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03089         }
03090     }
03091     except( <a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a> ) {
03092     }
03093 
03094     <span class="comment">//</span>
03095     <span class="comment">// We managed to make a new allocation (normal or page heap).</span>
03096     <span class="comment">// Now we need to copy from old to new all sorts of stuff </span>
03097     <span class="comment">// (contents, user flags/values).</span>
03098     <span class="comment">//</span>
03099 
03100     <span class="keywordflow">if</span> (NewAddress) {
03101 
03102         <span class="comment">//</span>
03103         <span class="comment">// Copy old block contents into the new node.</span>
03104         <span class="comment">//</span>
03105 
03106         CopyDataSize = OldNode-&gt;nUserRequestedSize;
03107 
03108         <span class="keywordflow">if</span> (CopyDataSize &gt; <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>) {
03109             CopyDataSize = <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
03110         }
03111 
03112         <span class="keywordflow">if</span> (CopyDataSize &gt; 0) {
03113 
03114             RtlCopyMemory(
03115                 NewAddress,
03116                 Address,
03117                 CopyDataSize
03118                 );
03119         }
03120 
03121         <span class="comment">//</span>
03122         <span class="comment">// If new allocation was done in page heap we need to detect the new node</span>
03123         <span class="comment">// and copy over user flags/values.</span>
03124         <span class="comment">//</span>
03125 
03126         <span class="keywordflow">if</span> (! ReallocInNormalHeap) {
03127 
03128             NewNode = <a class="code" href="../../d6/d9/heappage_8c.html#a109">RtlpDebugPageHeapFindBusyMem</a>( HeapRoot, NewAddress, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
03129 
03130             <span class="comment">//</span>
03131             <span class="comment">// This block could not be in normal heap therefore from this</span>
03132             <span class="comment">// respect the call above should always succeed.</span>
03133             <span class="comment">//</span>
03134 
03135             <a class="code" href="../../d6/d9/heappage_8c.html#a11">DEBUG_ASSERT</a>( NewNode != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
03136 
03137             NewNode-&gt;UserValue = OldNode-&gt;UserValue;
03138             NewNode-&gt;UserFlags = ( Flags &amp; HEAP_SETTABLE_USER_FLAGS ) ?
03139                 ( Flags &amp; HEAP_SETTABLE_USER_FLAGS ) :
03140             OldNode-&gt;UserFlags;
03141 
03142         }
03143         
03144         <span class="comment">//</span>
03145         <span class="comment">// We need to cover the case where old allocation was in page heap.</span>
03146         <span class="comment">// In this case we still need to cleanup the old node and </span>
03147         <span class="comment">// insert it back in free list. Actually the way the code is written</span>
03148         <span class="comment">// we take this code path only if original allocation was in page heap.</span>
03149         <span class="comment">// This is the reason for the assert.</span>
03150         <span class="comment">//</span>
03151 
03152 
03153         <a class="code" href="../../d6/d9/heappage_8c.html#a10">RETAIL_ASSERT</a> (OriginalAllocationInPageHeap);
03154 
03155         <span class="keywordflow">if</span> (OriginalAllocationInPageHeap) {
03156 
03157             <span class="keywordflow">if</span> (OldNode-&gt;nVirtualAccessSize &gt; 0) {
03158                 <a class="code" href="../../d6/d9/heappage_8c.html#a98">RtlpDebugPageHeapProtectVM</a>( OldNode-&gt;pVirtualBlock,
03159                     OldNode-&gt;nVirtualAccessSize,
03160                     PAGE_NOACCESS );
03161             }
03162 
03163             <span class="comment">//</span>
03164             <span class="comment">// If we use uncommitted ranges we need to decommit the memory</span>
03165             <span class="comment">// range now. Note that the next page (guard) was already decommitted</span>
03166             <span class="comment">// when we made the allocation.</span>
03167             <span class="comment">//</span>
03168 
03169             <span class="keywordflow">if</span> ((HeapRoot-&gt;ExtraFlags &amp; PAGE_HEAP_CATCH_BACKWARD_OVERRUNS)) {
03170 
03171                 <span class="comment">// nothing            </span>
03172 
03173             }
03174             <span class="keywordflow">else</span> {
03175 
03176                 <span class="keywordflow">if</span> ((HeapRoot-&gt;ExtraFlags &amp; PAGE_HEAP_SMART_MEMORY_USAGE)) {
03177 
03178                     <a class="code" href="../../d6/d9/heappage_8c.html#a102">RtlpDebugPageHeapDecommitVM</a> (
03179                         OldNode-&gt;pVirtualBlock, 
03180                         OldNode-&gt;nVirtualAccessSize);
03181                 }
03182             }
03183 
03184             <a class="code" href="../../d6/d9/heappage_8c.html#a111">RtlpDebugPageHeapPlaceOnFreeList</a>( HeapRoot, OldNode );
03185 
03186             <span class="comment">//</span>
03187             <span class="comment">// RtlpDebugPageHeapReAllocate gets called from RtlDebugReAllocateHeap,</span>
03188             <span class="comment">// which gets called from RtlReAllocateHeap.  To keep from wasting</span>
03189             <span class="comment">// lots of stack trace storage, we'll skip the bottom 2 entries,</span>
03190             <span class="comment">// leaving RtlReAllocateHeap as the first recorded entry in the</span>
03191             <span class="comment">// freed stack trace.</span>
03192             <span class="comment">//</span>
03193             <span class="comment">// Note. For realloc we need to do the accounting for free in the</span>
03194             <span class="comment">// trace block. The accounting for alloc is done in the real</span>
03195             <span class="comment">// alloc operation which always happens for page heap reallocs.</span>
03196             <span class="comment">//</span>
03197 
03198             <span class="keywordflow">if</span> ((HeapRoot-&gt;ExtraFlags &amp; PAGE_HEAP_COLLECT_STACK_TRACES)) {
03199 
03200                 <span class="keywordflow">if</span> (OldNode-&gt;StackTrace) {
03201 
03202                     RtlTraceDatabaseLock (<a class="code" href="../../d6/d9/heappage_8c.html#a56">RtlpDphTraceDatabase</a>);
03203 
03204                     <span class="keywordflow">if</span> (OldNode-&gt;StackTrace-&gt;UserCount &gt; 0) {
03205                         OldNode-&gt;StackTrace-&gt;UserCount -= 1;
03206                     }
03207 
03208                     <span class="keywordflow">if</span> (OldNode-&gt;StackTrace-&gt;UserSize &gt;= OldNode-&gt;nUserRequestedSize) {
03209                         OldNode-&gt;StackTrace-&gt;UserSize -= OldNode-&gt;nUserRequestedSize;
03210                     }
03211 
03212                     RtlTraceDatabaseUnlock (<a class="code" href="../../d6/d9/heappage_8c.html#a56">RtlpDphTraceDatabase</a>);
03213                 }
03214 
03215                 OldNode-&gt;StackTrace = <a class="code" href="../../d6/d9/heappage_8c.html#a89">RtlpDphLogStackTrace</a>(2);
03216             }
03217             <span class="keywordflow">else</span> {
03218                 OldNode-&gt;StackTrace = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03219             }
03220         }
03221     }
03222 
03223     <span class="keywordflow">else</span> {
03224 
03225         <span class="comment">//</span>
03226         <span class="comment">//  Failed to allocate a new block.  Return old block to busy list.</span>
03227         <span class="comment">//</span>
03228 
03229         <span class="keywordflow">if</span> (OriginalAllocationInPageHeap) {
03230 
03231             <a class="code" href="../../d6/d9/heappage_8c.html#a114">RtlpDebugPageHeapPlaceOnBusyList</a>( HeapRoot, OldNode );
03232         }
03233 
03234     }
03235 
03236     <a class="code" href="../../d3/d9/arcinst_8c.html#a2">EXIT</a>:
03237 
03238     <span class="keywordflow">if</span> ((<a class="code" href="../../d6/d9/heappage_8c.html#a51">RtlpDphDebugLevel</a> &amp; <a class="code" href="../../d6/d9/heappage_8c.html#a23">DPH_DEBUG_INTERNAL_VALIDATION</a>)) {
03239         <a class="code" href="../../d6/d9/heappage_8c.html#a106">RtlpDphInternalValidatePageHeap</a> (HeapRoot, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, 0);
03240     }
03241 
03242     <a class="code" href="../../d6/d9/heappage_8c.html#a21">PROTECT_HEAP_STRUCTURES</a>( HeapRoot );
03243     <a class="code" href="../../d6/d9/heappage_8c.html#a9">DEBUG_CODE</a>( RtlpDebugPageHeapVerifyIntegrity( HeapRoot ));
03244     <a class="code" href="../../d6/d9/heappage_8c.html#a93">RtlpDebugPageHeapLeaveCritSect</a>( HeapRoot );
03245 
03246     <span class="keywordflow">if</span> (NewAddress == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03247         <a class="code" href="../../d6/d9/heappage_8c.html#a13">IF_GENERATE_EXCEPTION</a>( Flags, STATUS_NO_MEMORY );
03248     }
03249 
03250     <span class="keywordflow">return</span> NewAddress;
03251 }
03252 
03253 <span class="comment">//silviuc: does this really work for all functions in between</span>
03254 <span class="preprocessor">#if (( DPH_CAPTURE_STACK_TRACE ) &amp;&amp; ( i386 ) &amp;&amp; ( FPO ))</span>
03255 <span class="preprocessor"></span><span class="preprocessor">#pragma optimize( "", on )      // restore original optimizations</span>
03256 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
03257 <span class="preprocessor"></span>
03258 PVOID
<a name="l03259"></a><a class="code" href="../../d7/d9/heappage_8h.html#a13">03259</a> <a class="code" href="../../d7/d9/heappage_8h.html#a13">RtlpDebugPageHeapDestroy</a>(
03260     IN PVOID HeapHandle
03261     )
03262 {
03263     PDPH_HEAP_ROOT       HeapRoot;
03264     PDPH_HEAP_ROOT       PrevHeapRoot;
03265     PDPH_HEAP_ROOT       NextHeapRoot;
03266     PDPH_HEAP_BLOCK Node;
03267     PDPH_HEAP_BLOCK Next;
03268     ULONG                Flags;
03269     PUCHAR               p;
03270     ULONG Reason;
03271     PVOID NormalHeap;
03272 
03273     <span class="keywordflow">if</span> (<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> == RtlProcessHeap()) {
03274         <a class="code" href="../../d7/d9/heappage_8h.html#a30">RtlpDebugPageHeapBreak</a>( <span class="stringliteral">"Page heap: Attempt to destroy process heap\n"</span> );
03275         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03276     }
03277 
03278     HeapRoot = <a class="code" href="../../d6/d9/heappage_8c.html#a95">RtlpDebugPageHeapPointerFromHandle</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> );
03279     <span class="keywordflow">if</span> (HeapRoot == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)
03280         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03281 
03282     Flags = HeapRoot-&gt;HeapFlags | HEAP_NO_SERIALIZE;
03283 
03284     <a class="code" href="../../d6/d9/heappage_8c.html#a92">RtlpDebugPageHeapEnterCritSect</a>( HeapRoot, Flags );
03285     <a class="code" href="../../d6/d9/heappage_8c.html#a9">DEBUG_CODE</a>( RtlpDebugPageHeapVerifyIntegrity( HeapRoot ));
03286     <a class="code" href="../../d6/d9/heappage_8c.html#a22">UNPROTECT_HEAP_STRUCTURES</a>( HeapRoot );
03287 
03288     <span class="comment">//</span>
03289     <span class="comment">// Save normal heap pointer for later.</span>
03290     <span class="comment">//</span>
03291 
03292     NormalHeap = HeapRoot-&gt;NormalHeap;
03293 
03294     <span class="comment">//</span>
03295     <span class="comment">//  Walk all busy allocations and check for tail fill corruption</span>
03296     <span class="comment">//</span>
03297 
03298     Node = HeapRoot-&gt;pBusyAllocationListHead;
03299 
03300     <span class="keywordflow">while</span> (Node) {
03301 
03302         <span class="keywordflow">if</span> (! (HeapRoot-&gt;ExtraFlags &amp; PAGE_HEAP_CATCH_BACKWARD_OVERRUNS)) {
03303             <span class="keywordflow">if</span> (! (<a class="code" href="../../d6/d9/heappage_8c.html#a80">RtlpDphIsPageHeapBlock</a> (HeapRoot, Node-&gt;pUserAllocation, &amp;Reason, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>))) {
03304                 <a class="code" href="../../d6/d9/heappage_8c.html#a77">RtlpDphReportCorruptedBlock</a> (Node-&gt;pUserAllocation, Reason);
03305             }
03306         }
03307 
03308         Node = Node-&gt;pNextAlloc;
03309     }
03310 
03311     <span class="comment">//</span>
03312     <span class="comment">//  Remove this heap entry from the process heap linked list.</span>
03313     <span class="comment">//</span>
03314 
03315     RtlEnterCriticalSection( &amp;<a class="code" href="../../d6/d9/heappage_8c.html#a39">RtlpDphHeapListCriticalSection</a> );
03316 
03317     <span class="keywordflow">if</span> (HeapRoot-&gt;pPrevHeapRoot) {
03318         HeapRoot-&gt;pPrevHeapRoot-&gt;pNextHeapRoot = HeapRoot-&gt;pNextHeapRoot;
03319     }
03320     <span class="keywordflow">else</span> {
03321         <a class="code" href="../../d6/d9/heappage_8c.html#a40">RtlpDphHeapListHead</a> = HeapRoot-&gt;pNextHeapRoot;
03322     }
03323 
03324     <span class="keywordflow">if</span> (HeapRoot-&gt;pNextHeapRoot) {
03325         HeapRoot-&gt;pNextHeapRoot-&gt;pPrevHeapRoot = HeapRoot-&gt;pPrevHeapRoot;
03326     }
03327     <span class="keywordflow">else</span> {
03328         <a class="code" href="../../d6/d9/heappage_8c.html#a41">RtlpDphHeapListTail</a> = HeapRoot-&gt;pPrevHeapRoot;
03329     }
03330 
03331     <a class="code" href="../../d6/d9/heappage_8c.html#a42">RtlpDphHeapListCount</a>--;
03332 
03333     RtlLeaveCriticalSection( &amp;<a class="code" href="../../d6/d9/heappage_8c.html#a39">RtlpDphHeapListCriticalSection</a> );
03334 
03335 
03336     <span class="comment">//</span>
03337     <span class="comment">//  Must release critical section before deleting it; otherwise,</span>
03338     <span class="comment">//  checked build Teb-&gt;CountOfOwnedCriticalSections gets out of sync.</span>
03339     <span class="comment">//</span>
03340 
03341     RtlLeaveCriticalSection( HeapRoot-&gt;HeapCritSect );
03342     <a class="code" href="../../d7/d8/dll_2resource_8c.html#a29">RtlDeleteCriticalSection</a>( HeapRoot-&gt;HeapCritSect );
03343 
03344     <span class="comment">//</span>
03345     <span class="comment">//  This is weird.  A virtual block might contain storage for</span>
03346     <span class="comment">//  one of the nodes necessary to walk this list.  In fact,</span>
03347     <span class="comment">//  we're guaranteed that the root node contains at least one</span>
03348     <span class="comment">//  virtual alloc node.</span>
03349     <span class="comment">//</span>
03350     <span class="comment">//  Each time we alloc new VM, we make that the head of the</span>
03351     <span class="comment">//  of the VM list, like a LIFO structure.  I think we're ok</span>
03352     <span class="comment">//  because no VM list node should be on a subsequently alloc'd</span>
03353     <span class="comment">//  VM -- only a VM list entry might be on its own memory (as</span>
03354     <span class="comment">//  is the case for the root node).  We read pNode-&gt;pNextAlloc</span>
03355     <span class="comment">//  before releasing the VM in case pNode existed on that VM.</span>
03356     <span class="comment">//  I think this is safe -- as long as the VM list is LIFO and</span>
03357     <span class="comment">//  we don't do any list reorganization.</span>
03358     <span class="comment">//</span>
03359 
03360     Node = HeapRoot-&gt;pVirtualStorageListHead;
03361 
03362     <span class="keywordflow">while</span> (Node) {
03363         Next = Node-&gt;pNextAlloc;
03364         <span class="keywordflow">if</span> (! <a class="code" href="../../d6/d9/heappage_8c.html#a100">RtlpDebugPageHeapReleaseVM</a>( Node-&gt;pVirtualBlock )) {
03365             <a class="code" href="../../d7/d9/heappage_8h.html#a30">RtlpDebugPageHeapBreak</a>( <span class="stringliteral">"Page heap: Unable to release virtual memory\n"</span> );
03366         }
03367         Node = Next;
03368     }
03369 
03370     <span class="comment">//</span>
03371     <span class="comment">// Free all blocks in the delayed free queue that belong to the</span>
03372     <span class="comment">// normal heap just about to be destroyed. Note that this is</span>
03373     <span class="comment">// not a bug. The application freed the blocks correctly but</span>
03374     <span class="comment">// we delayed the free operation.</span>
03375     <span class="comment">//</span>
03376 
03377     <a class="code" href="../../d6/d9/heappage_8c.html#a87">RtlpDphFreeDelayedBlocksFromHeap</a> (HeapRoot, NormalHeap);
03378 
03379     <span class="comment">//</span>
03380     <span class="comment">// Destroy normal heap. Note that this will not make a recursive</span>
03381     <span class="comment">// call into this function because this is not a page heap and</span>
03382     <span class="comment">// code in NT heap manager will detect this.</span>
03383     <span class="comment">//</span>
03384 
03385     <a class="code" href="../../d1/d9/rtl_2heap_8c.html#a16">RtlDestroyHeap</a> (NormalHeap);
03386 
03387     <span class="comment">//</span>
03388     <span class="comment">//  That's it.  All the VM, including the root node, should now</span>
03389     <span class="comment">//  be released.  RtlDestroyHeap always returns NULL.</span>
03390     <span class="comment">//</span>
03391 
03392     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( <span class="stringliteral">"Page heap: process 0x%X destroyed heap @ %p (%p)\n"</span>,
03393         NtCurrentTeb()-&gt;ClientId.UniqueProcess,
03394         HeapRoot,
03395         NormalHeap);
03396 
03397     <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03398 }
03399 
03400 SIZE_T
<a name="l03401"></a><a class="code" href="../../d7/d9/heappage_8h.html#a14">03401</a> <a class="code" href="../../d7/d9/heappage_8h.html#a14">RtlpDebugPageHeapSize</a>(
03402     IN PVOID HeapHandle,
03403     IN ULONG Flags,
03404     IN PVOID Address
03405     )
03406 {
03407     PDPH_HEAP_ROOT       HeapRoot;
03408     PDPH_HEAP_BLOCK Node;
03409     SIZE_T               <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
03410 
03411     <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> = -1;
03412 
03413     HeapRoot = <a class="code" href="../../d6/d9/heappage_8c.html#a95">RtlpDebugPageHeapPointerFromHandle</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> );
03414     <span class="keywordflow">if</span> (HeapRoot == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03415         <span class="keywordflow">return</span> <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
03416     }
03417 
03418     Flags |= HeapRoot-&gt;HeapFlags;
03419 
03420     <a class="code" href="../../d6/d9/heappage_8c.html#a92">RtlpDebugPageHeapEnterCritSect</a>( HeapRoot, Flags );
03421     <a class="code" href="../../d6/d9/heappage_8c.html#a22">UNPROTECT_HEAP_STRUCTURES</a>( HeapRoot );
03422 
03423     Node = <a class="code" href="../../d6/d9/heappage_8c.html#a109">RtlpDebugPageHeapFindBusyMem</a>( HeapRoot, Address, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
03424 
03425     <span class="keywordflow">if</span> (Node == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03426 
03427         <span class="comment">//</span>
03428         <span class="comment">// No wonder we did not find the block in the page heap</span>
03429         <span class="comment">// structures because the block was probably allocated</span>
03430         <span class="comment">// from the normal heap. Or there is a real bug. If there</span>
03431         <span class="comment">// is a bug NormalHeapSize will break into debugger.</span>
03432         <span class="comment">//</span>
03433 
03434         <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> = <a class="code" href="../../d6/d9/heappage_8c.html#a72">RtlpDphNormalHeapSize</a> (
03435 
03436             HeapRoot,
03437             Flags,
03438             Address);
03439 
03440         <span class="keywordflow">goto</span> <a class="code" href="../../d3/d9/arcinst_8c.html#a2">EXIT</a>;
03441     }
03442     <span class="keywordflow">else</span> {
03443         <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> = Node-&gt;nUserRequestedSize;
03444     }
03445 
03446     <a class="code" href="../../d3/d9/arcinst_8c.html#a2">EXIT</a>:
03447     <a class="code" href="../../d6/d9/heappage_8c.html#a21">PROTECT_HEAP_STRUCTURES</a>( HeapRoot );
03448     <a class="code" href="../../d6/d9/heappage_8c.html#a93">RtlpDebugPageHeapLeaveCritSect</a>( HeapRoot );
03449 
03450     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> == -1) {
03451         <a class="code" href="../../d6/d9/heappage_8c.html#a13">IF_GENERATE_EXCEPTION</a>( Flags, STATUS_ACCESS_VIOLATION );
03452     }
03453 
03454     <span class="keywordflow">return</span> <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
03455 }
03456 
03457 ULONG       
<a name="l03458"></a><a class="code" href="../../d7/d9/heappage_8h.html#a15">03458</a> <a class="code" href="../../d7/d9/heappage_8h.html#a15">RtlpDebugPageHeapGetProcessHeaps</a>(
03459     ULONG NumberOfHeaps,
03460     PVOID *ProcessHeaps
03461     )
03462 {
03463     PDPH_HEAP_ROOT HeapRoot;
03464     ULONG          <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>;
03465 
03466     <span class="comment">//</span>
03467     <span class="comment">//  Although we'd expect GetProcessHeaps never to be called</span>
03468     <span class="comment">//  before at least the very first heap creation, we should</span>
03469     <span class="comment">//  still be safe and initialize the critical section if</span>
03470     <span class="comment">//  necessary.</span>
03471     <span class="comment">//</span>
03472 
03473     <span class="keywordflow">if</span> (! <a class="code" href="../../d6/d9/heappage_8c.html#a38">RtlpDphHeapListHasBeenInitialized</a>) {
03474         <a class="code" href="../../d6/d9/heappage_8c.html#a38">RtlpDphHeapListHasBeenInitialized</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03475         <a class="code" href="../../d7/d8/dll_2resource_8c.html#a24">RtlInitializeCriticalSection</a>( &amp;<a class="code" href="../../d6/d9/heappage_8c.html#a39">RtlpDphHeapListCriticalSection</a> );
03476     }
03477 
03478     RtlEnterCriticalSection( &amp;<a class="code" href="../../d6/d9/heappage_8c.html#a39">RtlpDphHeapListCriticalSection</a> );
03479 
03480     <span class="keywordflow">if</span> (<a class="code" href="../../d6/d9/heappage_8c.html#a42">RtlpDphHeapListCount</a> &lt;= NumberOfHeaps) {
03481 
03482         <span class="keywordflow">for</span> (HeapRoot  = <a class="code" href="../../d6/d9/heappage_8c.html#a40">RtlpDphHeapListHead</a>, <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> = 0;
03483             HeapRoot != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03484             HeapRoot  = HeapRoot-&gt;pNextHeapRoot, <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> += 1) {
03485 
03486             *ProcessHeaps++ = <a class="code" href="../../d6/d9/heappage_8c.html#a12">HEAP_HANDLE_FROM_ROOT</a>( HeapRoot );
03487         }
03488 
03489         <span class="keywordflow">if</span> (<a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> != <a class="code" href="../../d6/d9/heappage_8c.html#a42">RtlpDphHeapListCount</a>) {
03490             <a class="code" href="../../d7/d9/heappage_8h.html#a30">RtlpDebugPageHeapBreak</a>( <span class="stringliteral">"Page heap: BUG: process heap list count wrong\n"</span> );
03491         }
03492 
03493     }
03494     <span class="keywordflow">else</span> {
03495 
03496         <span class="comment">//</span>
03497         <span class="comment">//  User's buffer is too small.  Return number of entries</span>
03498         <span class="comment">//  necessary for subsequent call to succeed.  Buffer</span>
03499         <span class="comment">//  remains untouched.</span>
03500         <span class="comment">//</span>
03501 
03502         <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> = <a class="code" href="../../d6/d9/heappage_8c.html#a42">RtlpDphHeapListCount</a>;
03503 
03504     }
03505 
03506     RtlLeaveCriticalSection( &amp;<a class="code" href="../../d6/d9/heappage_8c.html#a39">RtlpDphHeapListCriticalSection</a> );
03507 
03508     <span class="keywordflow">return</span> <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>;
03509 }
03510 
03511 ULONG
<a name="l03512"></a><a class="code" href="../../d7/d9/heappage_8h.html#a16">03512</a> <a class="code" href="../../d7/d9/heappage_8h.html#a16">RtlpDebugPageHeapCompact</a>(
03513     IN PVOID HeapHandle,
03514     IN ULONG Flags
03515     )
03516 {
03517     PDPH_HEAP_ROOT HeapRoot;
03518 
03519     HeapRoot = <a class="code" href="../../d6/d9/heappage_8c.html#a95">RtlpDebugPageHeapPointerFromHandle</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> );
03520     <span class="keywordflow">if</span> (HeapRoot == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)
03521         <span class="keywordflow">return</span> 0;
03522 
03523     Flags |= HeapRoot-&gt;HeapFlags;
03524 
03525     <a class="code" href="../../d6/d9/heappage_8c.html#a92">RtlpDebugPageHeapEnterCritSect</a>( HeapRoot, Flags );
03526 
03527     <span class="comment">//</span>
03528     <span class="comment">//  Don't do anything, but we did want to acquire the critsect</span>
03529     <span class="comment">//  in case this was called with HEAP_NO_SERIALIZE while another</span>
03530     <span class="comment">//  thread is in the heap code.</span>
03531     <span class="comment">//</span>
03532 
03533     <a class="code" href="../../d6/d9/heappage_8c.html#a93">RtlpDebugPageHeapLeaveCritSect</a>( HeapRoot );
03534 
03535     <span class="keywordflow">return</span> 0;
03536 }
03537 
03538 BOOLEAN
<a name="l03539"></a><a class="code" href="../../d7/d9/heappage_8h.html#a17">03539</a> <a class="code" href="../../d7/d9/heappage_8h.html#a17">RtlpDebugPageHeapValidate</a>(
03540     IN PVOID HeapHandle,
03541     IN ULONG Flags,
03542     IN PVOID Address
03543     )
03544 {
03545     PDPH_HEAP_ROOT       HeapRoot;
03546     PDPH_HEAP_BLOCK Node;
03547     BOOLEAN Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03548 
03549     HeapRoot = <a class="code" href="../../d6/d9/heappage_8c.html#a95">RtlpDebugPageHeapPointerFromHandle</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> );
03550     <span class="keywordflow">if</span> (HeapRoot == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)
03551         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03552 
03553     Flags |= HeapRoot-&gt;HeapFlags;
03554 
03555     <a class="code" href="../../d6/d9/heappage_8c.html#a92">RtlpDebugPageHeapEnterCritSect</a>( HeapRoot, Flags );
03556     <a class="code" href="../../d6/d9/heappage_8c.html#a9">DEBUG_CODE</a>( RtlpDebugPageHeapVerifyIntegrity( HeapRoot ));
03557     <a class="code" href="../../d6/d9/heappage_8c.html#a22">UNPROTECT_HEAP_STRUCTURES</a>( HeapRoot );
03558 
03559     Node = Address ? <a class="code" href="../../d6/d9/heappage_8c.html#a109">RtlpDebugPageHeapFindBusyMem</a>( HeapRoot, Address, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) : <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03560 
03561     <span class="keywordflow">if</span> (Node == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03562 
03563         Result = <a class="code" href="../../d6/d9/heappage_8c.html#a76">RtlpDphNormalHeapValidate</a> (
03564             HeapRoot,
03565             Flags,
03566             Address);
03567     }
03568 
03569     <a class="code" href="../../d6/d9/heappage_8c.html#a21">PROTECT_HEAP_STRUCTURES</a>( HeapRoot );
03570     <a class="code" href="../../d6/d9/heappage_8c.html#a93">RtlpDebugPageHeapLeaveCritSect</a>( HeapRoot );
03571 
03572     <span class="keywordflow">if</span> (Address) {
03573         <span class="keywordflow">if</span> (Node) {
03574             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03575         }
03576         <span class="keywordflow">else</span> {
03577             <span class="keywordflow">return</span> Result;
03578         }
03579     }
03580     <span class="keywordflow">else</span> {
03581         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03582     }
03583 }
03584 
03585 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l03586"></a><a class="code" href="../../d7/d9/heappage_8h.html#a18">03586</a> <a class="code" href="../../d7/d9/heappage_8h.html#a18">RtlpDebugPageHeapWalk</a>(
03587     IN PVOID HeapHandle,
03588     IN OUT PRTL_HEAP_WALK_ENTRY Entry
03589     )
03590 {
03591     <span class="keywordflow">return</span> STATUS_NOT_IMPLEMENTED;
03592 }
03593 
03594 BOOLEAN
<a name="l03595"></a><a class="code" href="../../d7/d9/heappage_8h.html#a19">03595</a> <a class="code" href="../../d7/d9/heappage_8h.html#a19">RtlpDebugPageHeapLock</a>(
03596     IN PVOID HeapHandle
03597     )
03598 {
03599     PDPH_HEAP_ROOT HeapRoot;
03600 
03601     HeapRoot = <a class="code" href="../../d6/d9/heappage_8c.html#a95">RtlpDebugPageHeapPointerFromHandle</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> );
03602 
03603     <span class="keywordflow">if</span> (HeapRoot == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03604         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03605     }
03606 
03607     <a class="code" href="../../d6/d9/heappage_8c.html#a92">RtlpDebugPageHeapEnterCritSect</a>( HeapRoot, HeapRoot-&gt;HeapFlags );
03608 
03609     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03610 }
03611 
03612 BOOLEAN
<a name="l03613"></a><a class="code" href="../../d7/d9/heappage_8h.html#a20">03613</a> <a class="code" href="../../d7/d9/heappage_8h.html#a20">RtlpDebugPageHeapUnlock</a>(
03614     IN PVOID HeapHandle
03615     )
03616 {
03617     PDPH_HEAP_ROOT HeapRoot;
03618 
03619     HeapRoot = <a class="code" href="../../d6/d9/heappage_8c.html#a95">RtlpDebugPageHeapPointerFromHandle</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> );
03620 
03621     <span class="keywordflow">if</span> (HeapRoot == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03622         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03623     }
03624 
03625     <a class="code" href="../../d6/d9/heappage_8c.html#a93">RtlpDebugPageHeapLeaveCritSect</a>( HeapRoot );
03626 
03627     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03628 }
03629 
03630 BOOLEAN
<a name="l03631"></a><a class="code" href="../../d7/d9/heappage_8h.html#a21">03631</a> <a class="code" href="../../d7/d9/heappage_8h.html#a21">RtlpDebugPageHeapSetUserValue</a>(
03632     IN PVOID HeapHandle,
03633     IN ULONG Flags,
03634     IN PVOID Address,
03635     IN PVOID UserValue
03636     )
03637 {
03638     PDPH_HEAP_ROOT       HeapRoot;
03639     PDPH_HEAP_BLOCK Node;
03640     BOOLEAN              Success;
03641 
03642     Success = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03643 
03644     HeapRoot = <a class="code" href="../../d6/d9/heappage_8c.html#a95">RtlpDebugPageHeapPointerFromHandle</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> );
03645     <span class="keywordflow">if</span> ( HeapRoot == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> )
03646         <span class="keywordflow">return</span> Success;
03647 
03648     Flags |= HeapRoot-&gt;HeapFlags;
03649 
03650     <a class="code" href="../../d6/d9/heappage_8c.html#a92">RtlpDebugPageHeapEnterCritSect</a>( HeapRoot, Flags );
03651     <a class="code" href="../../d6/d9/heappage_8c.html#a22">UNPROTECT_HEAP_STRUCTURES</a>( HeapRoot );
03652 
03653     Node = <a class="code" href="../../d6/d9/heappage_8c.html#a109">RtlpDebugPageHeapFindBusyMem</a>( HeapRoot, Address, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
03654 
03655     <span class="keywordflow">if</span> ( Node == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
03656 
03657         <span class="comment">//</span>
03658         <span class="comment">// If we cannot find the node in page heap structures it might be</span>
03659         <span class="comment">// because it has been allocated from normal heap.</span>
03660         <span class="comment">//</span>
03661 
03662         Success = <a class="code" href="../../d6/d9/heappage_8c.html#a74">RtlpDphNormalHeapSetUserValue</a> (
03663             HeapRoot,
03664             Flags,
03665             Address,
03666             UserValue);
03667 
03668         <span class="keywordflow">goto</span> <a class="code" href="../../d3/d9/arcinst_8c.html#a2">EXIT</a>;
03669     }
03670     <span class="keywordflow">else</span> {
03671         Node-&gt;UserValue = UserValue;
03672         Success = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03673     }
03674 
03675     <a class="code" href="../../d3/d9/arcinst_8c.html#a2">EXIT</a>:
03676     <a class="code" href="../../d6/d9/heappage_8c.html#a21">PROTECT_HEAP_STRUCTURES</a>( HeapRoot );
03677     <a class="code" href="../../d6/d9/heappage_8c.html#a93">RtlpDebugPageHeapLeaveCritSect</a>( HeapRoot );
03678 
03679     <span class="keywordflow">return</span> Success;
03680 }
03681 
03682 BOOLEAN
<a name="l03683"></a><a class="code" href="../../d7/d9/heappage_8h.html#a22">03683</a> <a class="code" href="../../d7/d9/heappage_8h.html#a22">RtlpDebugPageHeapGetUserInfo</a>(
03684     IN  PVOID  HeapHandle,
03685     IN  ULONG  Flags,
03686     IN  PVOID  Address,
03687     OUT PVOID* UserValue,
03688     OUT PULONG UserFlags
03689     )
03690 {
03691     PDPH_HEAP_ROOT       HeapRoot;
03692     PDPH_HEAP_BLOCK Node;
03693     BOOLEAN              Success;
03694 
03695     Success = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03696 
03697     HeapRoot = <a class="code" href="../../d6/d9/heappage_8c.html#a95">RtlpDebugPageHeapPointerFromHandle</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> );
03698     <span class="keywordflow">if</span> ( HeapRoot == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> )
03699         <span class="keywordflow">return</span> Success;
03700 
03701     Flags |= HeapRoot-&gt;HeapFlags;
03702 
03703     <a class="code" href="../../d6/d9/heappage_8c.html#a92">RtlpDebugPageHeapEnterCritSect</a>( HeapRoot, Flags );
03704     <a class="code" href="../../d6/d9/heappage_8c.html#a22">UNPROTECT_HEAP_STRUCTURES</a>( HeapRoot );
03705 
03706     Node = <a class="code" href="../../d6/d9/heappage_8c.html#a109">RtlpDebugPageHeapFindBusyMem</a>( HeapRoot, Address, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
03707 
03708     <span class="keywordflow">if</span> ( Node == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
03709 
03710         <span class="comment">//</span>
03711         <span class="comment">// If we cannot find the node in page heap structures it might be</span>
03712         <span class="comment">// because it has been allocated from normal heap.</span>
03713         <span class="comment">//</span>
03714 
03715         Success = <a class="code" href="../../d6/d9/heappage_8c.html#a75">RtlpDphNormalHeapGetUserInfo</a> (
03716             HeapRoot,
03717             Flags,
03718             Address,
03719             UserValue,
03720             UserFlags);
03721 
03722         <span class="keywordflow">goto</span> <a class="code" href="../../d3/d9/arcinst_8c.html#a2">EXIT</a>;
03723     }
03724     <span class="keywordflow">else</span> {
03725         <span class="keywordflow">if</span> ( UserValue != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> )
03726             *UserValue = Node-&gt;UserValue;
03727         <span class="keywordflow">if</span> ( UserFlags != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> )
03728             *UserFlags = Node-&gt;UserFlags;
03729         Success = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03730     }
03731 
03732     <a class="code" href="../../d3/d9/arcinst_8c.html#a2">EXIT</a>:
03733     <a class="code" href="../../d6/d9/heappage_8c.html#a21">PROTECT_HEAP_STRUCTURES</a>( HeapRoot );
03734     <a class="code" href="../../d6/d9/heappage_8c.html#a93">RtlpDebugPageHeapLeaveCritSect</a>( HeapRoot );
03735 
03736     <span class="keywordflow">return</span> Success;
03737 }
03738 
03739 BOOLEAN
<a name="l03740"></a><a class="code" href="../../d7/d9/heappage_8h.html#a23">03740</a> <a class="code" href="../../d7/d9/heappage_8h.html#a23">RtlpDebugPageHeapSetUserFlags</a>(
03741     IN PVOID HeapHandle,
03742     IN ULONG Flags,
03743     IN PVOID Address,
03744     IN ULONG UserFlagsReset,
03745     IN ULONG UserFlagsSet
03746     )
03747 {
03748     PDPH_HEAP_ROOT       HeapRoot;
03749     PDPH_HEAP_BLOCK Node;
03750     BOOLEAN              Success;
03751 
03752     Success = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03753 
03754     HeapRoot = <a class="code" href="../../d6/d9/heappage_8c.html#a95">RtlpDebugPageHeapPointerFromHandle</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> );
03755     <span class="keywordflow">if</span> ( HeapRoot == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> )
03756         <span class="keywordflow">return</span> Success;
03757 
03758     Flags |= HeapRoot-&gt;HeapFlags;
03759 
03760     <a class="code" href="../../d6/d9/heappage_8c.html#a92">RtlpDebugPageHeapEnterCritSect</a>( HeapRoot, Flags );
03761     <a class="code" href="../../d6/d9/heappage_8c.html#a22">UNPROTECT_HEAP_STRUCTURES</a>( HeapRoot );
03762 
03763     Node = <a class="code" href="../../d6/d9/heappage_8c.html#a109">RtlpDebugPageHeapFindBusyMem</a>( HeapRoot, Address, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
03764 
03765     <span class="keywordflow">if</span> ( Node == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
03766 
03767         <span class="comment">//</span>
03768         <span class="comment">// If we cannot find the node in page heap structures it might be</span>
03769         <span class="comment">// because it has been allocated from normal heap.</span>
03770         <span class="comment">//</span>
03771 
03772         Success = <a class="code" href="../../d6/d9/heappage_8c.html#a73">RtlpDphNormalHeapSetUserFlags</a> (
03773             HeapRoot,
03774             Flags,
03775             Address,
03776             UserFlagsReset,
03777             UserFlagsSet);
03778 
03779         <span class="keywordflow">goto</span> <a class="code" href="../../d3/d9/arcinst_8c.html#a2">EXIT</a>;
03780     }
03781     <span class="keywordflow">else</span> {
03782         Node-&gt;UserFlags &amp;= ~( UserFlagsReset );
03783         Node-&gt;UserFlags |=    UserFlagsSet;
03784         Success = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03785     }
03786 
03787     <a class="code" href="../../d3/d9/arcinst_8c.html#a2">EXIT</a>:
03788     <a class="code" href="../../d6/d9/heappage_8c.html#a21">PROTECT_HEAP_STRUCTURES</a>( HeapRoot );
03789     <a class="code" href="../../d6/d9/heappage_8c.html#a93">RtlpDebugPageHeapLeaveCritSect</a>( HeapRoot );
03790 
03791     <span class="keywordflow">return</span> Success;
03792 }
03793 
03794 BOOLEAN
<a name="l03795"></a><a class="code" href="../../d7/d9/heappage_8h.html#a24">03795</a> <a class="code" href="../../d7/d9/heappage_8h.html#a24">RtlpDebugPageHeapSerialize</a>(
03796     IN PVOID HeapHandle
03797     )
03798 {
03799     PDPH_HEAP_ROOT HeapRoot;
03800 
03801     HeapRoot = <a class="code" href="../../d6/d9/heappage_8c.html#a95">RtlpDebugPageHeapPointerFromHandle</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> );
03802     <span class="keywordflow">if</span> ( HeapRoot == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> )
03803         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03804 
03805     <a class="code" href="../../d6/d9/heappage_8c.html#a92">RtlpDebugPageHeapEnterCritSect</a>( HeapRoot, 0 );
03806     <a class="code" href="../../d6/d9/heappage_8c.html#a22">UNPROTECT_HEAP_STRUCTURES</a>( HeapRoot );
03807 
03808     HeapRoot-&gt;HeapFlags &amp;= ~HEAP_NO_SERIALIZE;
03809 
03810     <a class="code" href="../../d6/d9/heappage_8c.html#a21">PROTECT_HEAP_STRUCTURES</a>( HeapRoot );
03811     <a class="code" href="../../d6/d9/heappage_8c.html#a93">RtlpDebugPageHeapLeaveCritSect</a>( HeapRoot );
03812 
03813     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03814 }
03815 
03816 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l03817"></a><a class="code" href="../../d7/d9/heappage_8h.html#a25">03817</a> <a class="code" href="../../d7/d9/heappage_8h.html#a25">RtlpDebugPageHeapExtend</a>(
03818     IN PVOID  HeapHandle,
03819     IN ULONG  Flags,
03820     IN PVOID  Base,
03821     IN SIZE_T Size
03822     )
03823 {
03824     <span class="keywordflow">return</span> STATUS_SUCCESS;
03825 }
03826 
03827 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l03828"></a><a class="code" href="../../d7/d9/heappage_8h.html#a26">03828</a> <a class="code" href="../../d7/d9/heappage_8h.html#a26">RtlpDebugPageHeapZero</a>(
03829     IN PVOID HeapHandle,
03830     IN ULONG Flags
03831     )
03832 {
03833     <span class="keywordflow">return</span> STATUS_SUCCESS;
03834 }
03835 
03836 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l03837"></a><a class="code" href="../../d7/d9/heappage_8h.html#a27">03837</a> <a class="code" href="../../d7/d9/heappage_8h.html#a27">RtlpDebugPageHeapReset</a>(
03838     IN PVOID HeapHandle,
03839     IN ULONG Flags
03840     )
03841 {
03842     <span class="keywordflow">return</span> STATUS_SUCCESS;
03843 }
03844 
03845 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l03846"></a><a class="code" href="../../d7/d9/heappage_8h.html#a28">03846</a> <a class="code" href="../../d7/d9/heappage_8h.html#a28">RtlpDebugPageHeapUsage</a>(
03847     IN PVOID HeapHandle,
03848     IN ULONG Flags,
03849     IN OUT PRTL_HEAP_USAGE Usage
03850     )
03851 {
03852     PDPH_HEAP_ROOT HeapRoot;
03853 
03854     <span class="comment">//</span>
03855     <span class="comment">//  Partial implementation since this information is kind of meaningless.</span>
03856     <span class="comment">//</span>
03857 
03858     HeapRoot = <a class="code" href="../../d6/d9/heappage_8c.html#a95">RtlpDebugPageHeapPointerFromHandle</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> );
03859     <span class="keywordflow">if</span> ( HeapRoot == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> )
03860         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
03861 
03862     <span class="keywordflow">if</span> ( <a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;Length != <span class="keyword">sizeof</span>( RTL_HEAP_USAGE ))
03863         <span class="keywordflow">return</span> STATUS_INFO_LENGTH_MISMATCH;
03864 
03865     memset( <a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>, 0, <span class="keyword">sizeof</span>( RTL_HEAP_USAGE ));
03866     <a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;Length = <span class="keyword">sizeof</span>( RTL_HEAP_USAGE );
03867 
03868     <a class="code" href="../../d6/d9/heappage_8c.html#a92">RtlpDebugPageHeapEnterCritSect</a>( HeapRoot, 0 );
03869     <a class="code" href="../../d6/d9/heappage_8c.html#a22">UNPROTECT_HEAP_STRUCTURES</a>( HeapRoot );
03870 
03871     <a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;BytesAllocated       = HeapRoot-&gt;nBusyAllocationBytesAccessible;
03872     <a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;BytesCommitted       = HeapRoot-&gt;nVirtualStorageBytes;
03873     <a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;BytesReserved        = HeapRoot-&gt;nVirtualStorageBytes;
03874     <a class="code" href="../../d1/d1/hivedmp_8c.html#a6">Usage</a>-&gt;BytesReservedMaximum = HeapRoot-&gt;nVirtualStorageBytes;
03875 
03876     <a class="code" href="../../d6/d9/heappage_8c.html#a21">PROTECT_HEAP_STRUCTURES</a>( HeapRoot );
03877     <a class="code" href="../../d6/d9/heappage_8c.html#a93">RtlpDebugPageHeapLeaveCritSect</a>( HeapRoot );
03878 
03879     <span class="keywordflow">return</span> STATUS_SUCCESS;
03880 }
03881 
03882 BOOLEAN
<a name="l03883"></a><a class="code" href="../../d7/d9/heappage_8h.html#a29">03883</a> <a class="code" href="../../d7/d9/heappage_8h.html#a29">RtlpDebugPageHeapIsLocked</a>(
03884     IN PVOID HeapHandle
03885     )
03886 {
03887     PDPH_HEAP_ROOT HeapRoot;
03888 
03889     HeapRoot = <a class="code" href="../../d6/d9/heappage_8c.html#a95">RtlpDebugPageHeapPointerFromHandle</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> );
03890     <span class="keywordflow">if</span> ( HeapRoot == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> )
03891         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03892 
03893     <span class="keywordflow">if</span> ( RtlTryEnterCriticalSection( HeapRoot-&gt;HeapCritSect )) {
03894         RtlLeaveCriticalSection( HeapRoot-&gt;HeapCritSect );
03895         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03896     }
03897     <span class="keywordflow">else</span> {
03898         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03899     }
03900 }
03901 
03905 
<a name="l03906"></a><a class="code" href="../../d6/d9/heappage_8c.html#a88">03906</a> <a class="code" href="../../d6/d9/heappage_8c.html#a88">RtlpDphShouldAllocateInPageHeap</a> (
03907     PDPH_HEAP_ROOT HeapRoot,
03908     SIZE_T Size
03909     )
03910 {
03911     SYSTEM_PERFORMANCE_INFORMATION PerfInfo;
03912     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
03913     ULONG Random;
03914     ULONG Percentage;
03915 
03916     <span class="comment">//</span>
03917     <span class="comment">// If page heap is not enabled =&gt; normal heap.</span>
03918     <span class="comment">//</span>
03919     
03920     <span class="keywordflow">if</span> (! (HeapRoot-&gt;ExtraFlags &amp; PAGE_HEAP_ENABLE_PAGE_HEAP)) {
03921         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03922     }
03923 
03924     <span class="comment">//</span>
03925     <span class="comment">// If in size range =&gt; page heap</span>
03926     <span class="comment">//</span>
03927 
03928     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((HeapRoot-&gt;ExtraFlags &amp; PAGE_HEAP_USE_SIZE_RANGE)) {
03929 
03930         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> &gt;= <a class="code" href="../../d6/d9/heappage_8c.html#a44">RtlpDphSizeRangeStart</a> &amp;&amp; <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> &lt;= <a class="code" href="../../d6/d9/heappage_8c.html#a45">RtlpDphSizeRangeEnd</a>) {
03931             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03932         }
03933         <span class="keywordflow">else</span> {
03934             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03935         }
03936     }
03937     
03938     <span class="comment">//</span>
03939     <span class="comment">// If in dll range =&gt; page heap</span>
03940     <span class="comment">//</span>
03941 
03942     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((HeapRoot-&gt;ExtraFlags &amp; PAGE_HEAP_USE_DLL_RANGE)) {
03943 
03944         PVOID StackTrace[32];
03945         ULONG <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>;
03946         ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
03947         ULONG Hash;
03948 
03949         <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> = <a class="code" href="../../d5/d2/ppc_2getcalr_8c.html#a1">RtlCaptureStackBackTrace</a> (
03950             1,
03951             32,
03952             StackTrace,
03953             &amp;Hash);
03954 
03955         <span class="comment">//</span>
03956         <span class="comment">// (SilviuC): should read DllRange as PVOIDs</span>
03957         <span class="comment">//</span>
03958 
03959         <span class="keywordflow">for</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> += 1) {
03960             <span class="keywordflow">if</span> (PtrToUlong(StackTrace[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>]) &gt;= <a class="code" href="../../d6/d9/heappage_8c.html#a46">RtlpDphDllRangeStart</a> 
03961                 &amp;&amp; PtrToUlong(StackTrace[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>]) &lt;= <a class="code" href="../../d6/d9/heappage_8c.html#a47">RtlpDphDllRangeEnd</a>) {
03962 
03963                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03964             }
03965         }
03966         
03967         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03968     }
03969     
03970     <span class="comment">//</span>
03971     <span class="comment">// If randomly decided =&gt; page heap</span>
03972     <span class="comment">//</span>
03973 
03974     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((HeapRoot-&gt;ExtraFlags &amp; PAGE_HEAP_USE_RANDOM_DECISION)) {
03975 
03976         Random = <a class="code" href="../../d8/d6/ttri_8c.html#a4">RtlRandom</a> (&amp; (HeapRoot-&gt;Seed));
03977 
03978         <span class="keywordflow">if</span> ((Random % 100) &lt; <a class="code" href="../../d6/d9/heappage_8c.html#a48">RtlpDphRandomProbability</a>) {
03979             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03980         }
03981         <span class="keywordflow">else</span> {
03982             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03983         }
03984     }
03985     
03986     <span class="comment">//</span>
03987     <span class="comment">// If call not generated from one of the target dlls =&gt; normal heap</span>
03988     <span class="comment">//</span>
03989 
03990     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((HeapRoot-&gt;ExtraFlags &amp; PAGE_HEAP_USE_DLL_NAMES)) {
03991 
03992         <span class="comment">// We return false. The calls generated from target</span>
03993         <span class="comment">// dlls will never get into this function and therefore</span>
03994         <span class="comment">// we just return false signalling that we do not want</span>
03995         <span class="comment">// page heap verification for the rest of the world.</span>
03996         <span class="comment">//</span>
03997         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03998     }
03999 
04000     <span class="comment">//</span>
04001     <span class="comment">// For all other cases we will allocate in the page heap.</span>
04002     <span class="comment">//</span>
04003 
04004     <span class="keywordflow">else</span> {
04005         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04006     }
04007 }
04008 
04009 
04010 
04014 
04015 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l04016"></a><a class="code" href="../../d6/d9/heappage_8c.html#a77">04016</a> <a class="code" href="../../d6/d9/heappage_8c.html#a77">RtlpDphReportCorruptedBlock</a> (
04017     PVOID Block,
04018     ULONG Reason
04019     )
04020 {
04021     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a> (<span class="stringliteral">"Page heap: block @ %p is corrupted (reason %0X) \n"</span>, Block, Reason);
04022 
04023     <span class="keywordflow">if</span> ((Reason &amp; DPH_ERROR_CORRUPTED_INFIX_PATTERN)) {
04024         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a> (<span class="stringliteral">"Page heap: reason: corrupted infix pattern for freed block \n"</span>);
04025     }
04026     <span class="keywordflow">if</span> ((Reason &amp; DPH_ERROR_CORRUPTED_START_STAMP)) {
04027         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a> (<span class="stringliteral">"Page heap: reason: corrupted start stamp \n"</span>);
04028     }
04029     <span class="keywordflow">if</span> ((Reason &amp; DPH_ERROR_CORRUPTED_END_STAMP)) {
04030         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a> (<span class="stringliteral">"Page heap: reason: corrupted end stamp \n"</span>);
04031     }
04032     <span class="keywordflow">if</span> ((Reason &amp; DPH_ERROR_CORRUPTED_HEAP_POINTER)) {
04033         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a> (<span class="stringliteral">"Page heap: reason: corrupted heap pointer \n"</span>);
04034     }
04035     <span class="keywordflow">if</span> ((Reason &amp; DPH_ERROR_CORRUPTED_PREFIX_PATTERN)) {
04036         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a> (<span class="stringliteral">"Page heap: reason: corrupted prefix pattern \n"</span>);
04037     }
04038     <span class="keywordflow">if</span> ((Reason &amp; DPH_ERROR_CORRUPTED_SUFFIX_PATTERN)) {
04039         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a> (<span class="stringliteral">"Page heap: reason: corrupted suffix pattern \n"</span>);
04040     }
04041     <span class="keywordflow">if</span> ((Reason &amp; DPH_ERROR_RAISED_EXCEPTION)) {
04042         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a> (<span class="stringliteral">"Page heap: reason: raised exception while probing \n"</span>);
04043     }
04044 
04045     DbgBreakPoint ();
04046 }
04047 
04048 BOOLEAN
<a name="l04049"></a><a class="code" href="../../d6/d9/heappage_8c.html#a80">04049</a> <a class="code" href="../../d6/d9/heappage_8c.html#a80">RtlpDphIsPageHeapBlock</a> (
04050     PDPH_HEAP_ROOT Heap,
04051     PVOID Block,
04052     PULONG Reason,
04053     BOOLEAN CheckPattern
04054     )
04055 {
04056     PDPH_BLOCK_INFORMATION Info;
04057     BOOLEAN Corrupted = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04058     PUCHAR Current;
04059     PUCHAR FillStart;
04060     PUCHAR FillEnd;
04061 
04062     <a class="code" href="../../d6/d9/heappage_8c.html#a11">DEBUG_ASSERT</a> (Reason != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
04063     *Reason = 0;
04064 
04065     <span class="keywordflow">try</span> {
04066         
04067         Info = (PDPH_BLOCK_INFORMATION)Block - 1;
04068         
04069         <span class="comment">//</span>
04070         <span class="comment">// Start checking ...</span>
04071         <span class="comment">//</span>
04072 
04073         <span class="keywordflow">if</span> (Info-&gt;StartStamp != DPH_PAGE_BLOCK_START_STAMP_ALLOCATED) {
04074             *Reason |= DPH_ERROR_CORRUPTED_START_STAMP;
04075             Corrupted = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04076         }
04077         
04078         <span class="keywordflow">if</span> (Info-&gt;EndStamp != DPH_PAGE_BLOCK_END_STAMP_ALLOCATED) {
04079             *Reason |= DPH_ERROR_CORRUPTED_END_STAMP;
04080             Corrupted = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04081         }
04082 
04083         <span class="keywordflow">if</span> (Info-&gt;Heap != Heap) {
04084             *Reason |= DPH_ERROR_CORRUPTED_HEAP_POINTER;
04085             Corrupted = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04086         }
04087 
04088         <span class="comment">//</span>
04089         <span class="comment">// Check the block suffix byte pattern.</span>
04090         <span class="comment">//</span>
04091 
04092         <span class="keywordflow">if</span> (CheckPattern) {
04093             
04094             FillStart = (PUCHAR)Block + Info-&gt;RequestedSize;
04095             FillEnd = (PUCHAR)<a class="code" href="../../d6/d9/heappage_8c.html#a8">ROUNDUP2</a>((ULONG_PTR)FillStart, <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
04096 
04097             <span class="keywordflow">for</span> (Current = FillStart; Current &lt; FillEnd; Current++) {
04098 
04099                 <span class="keywordflow">if</span> (*Current != DPH_PAGE_BLOCK_SUFFIX) {
04100 
04101                     *Reason |= DPH_ERROR_CORRUPTED_SUFFIX_PATTERN;
04102                     Corrupted = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04103                     <span class="keywordflow">break</span>;
04104                 }
04105             }
04106         }
04107     }
04108     except (<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
04109 
04110         *Reason |= DPH_ERROR_RAISED_EXCEPTION;
04111         Corrupted = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04112     }
04113 
04114     <span class="keywordflow">if</span> (Corrupted) {
04115         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04116     }
04117     <span class="keywordflow">else</span> {
04118         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04119     }
04120 }
04121 
04122 BOOLEAN
<a name="l04123"></a><a class="code" href="../../d6/d9/heappage_8c.html#a78">04123</a> <a class="code" href="../../d6/d9/heappage_8c.html#a78">RtlpDphIsNormalHeapBlock</a> (
04124     PDPH_HEAP_ROOT Heap,
04125     PVOID Block,
04126     PULONG Reason,
04127     BOOLEAN CheckPattern
04128     )
04129 {
04130     PDPH_BLOCK_INFORMATION Info;
04131     BOOLEAN Corrupted = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04132     PUCHAR Current;
04133     PUCHAR FillStart;
04134     PUCHAR FillEnd;
04135 
04136     <a class="code" href="../../d6/d9/heappage_8c.html#a11">DEBUG_ASSERT</a> (Reason != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
04137     *Reason = 0;
04138 
04139     Info = (PDPH_BLOCK_INFORMATION)Block - 1;
04140 
04141     <span class="keywordflow">try</span> {
04142 
04143         <span class="keywordflow">if</span> (Info-&gt;Heap != Heap) {
04144             *Reason |= DPH_ERROR_CORRUPTED_HEAP_POINTER;
04145             Corrupted = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04146         }
04147 
04148         <span class="keywordflow">if</span> (Info-&gt;StartStamp != DPH_NORMAL_BLOCK_START_STAMP_ALLOCATED) {
04149             *Reason |= DPH_ERROR_CORRUPTED_START_STAMP;
04150             Corrupted = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04151         }
04152         
04153         <span class="keywordflow">if</span> (Info-&gt;EndStamp != DPH_NORMAL_BLOCK_END_STAMP_ALLOCATED) {
04154             *Reason |= DPH_ERROR_CORRUPTED_END_STAMP;
04155             Corrupted = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04156         }
04157 
04158         <span class="comment">//</span>
04159         <span class="comment">// Check the block suffix byte pattern.</span>
04160         <span class="comment">//</span>
04161 
04162         <span class="keywordflow">if</span> (CheckPattern) {
04163         
04164             FillStart = (PUCHAR)Block + Info-&gt;RequestedSize;
04165             FillEnd = FillStart + USER_ALIGNMENT;
04166 
04167             <span class="keywordflow">for</span> (Current = FillStart; Current &lt; FillEnd; Current++) {
04168 
04169                 <span class="keywordflow">if</span> (*Current != DPH_NORMAL_BLOCK_SUFFIX) {
04170 
04171                     *Reason |= DPH_ERROR_CORRUPTED_SUFFIX_PATTERN;
04172                     Corrupted = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04173                     <span class="keywordflow">break</span>;
04174                 }
04175             }
04176         }
04177     }
04178     except (<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
04179 
04180         *Reason |= DPH_ERROR_RAISED_EXCEPTION;
04181         Corrupted = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04182     }
04183 
04184     <span class="keywordflow">if</span> (Corrupted) {
04185         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04186     }
04187     <span class="keywordflow">else</span> {
04188         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04189     }
04190 }
04191 
04192 BOOLEAN
<a name="l04193"></a><a class="code" href="../../d6/d9/heappage_8c.html#a79">04193</a> <a class="code" href="../../d6/d9/heappage_8c.html#a79">RtlpDphIsNormalFreeHeapBlock</a> (
04194     PVOID Block,
04195     PULONG Reason,
04196     BOOLEAN CheckPattern
04197     )
04198 {
04199     PDPH_BLOCK_INFORMATION Info;
04200     BOOLEAN Corrupted = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04201     PUCHAR Current;
04202     PUCHAR FillStart;
04203     PUCHAR FillEnd;
04204 
04205     <a class="code" href="../../d6/d9/heappage_8c.html#a11">DEBUG_ASSERT</a> (Reason != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
04206     *Reason = 0;
04207 
04208     Info = (PDPH_BLOCK_INFORMATION)Block - 1;
04209 
04210     <span class="keywordflow">try</span> {
04211 
04212         <span class="comment">//</span>
04213         <span class="comment">// If heap pointer is null we will just ignore this field.</span>
04214         <span class="comment">// This can happen during heap destroy operations where</span>
04215         <span class="comment">// the page heap got destroyed but the normal heap is still</span>
04216         <span class="comment">// alive.</span>
04217         <span class="comment">//</span>
04218 
04219         <span class="keywordflow">if</span> (Info-&gt;StartStamp != DPH_NORMAL_BLOCK_START_STAMP_FREE) {
04220             *Reason |= DPH_ERROR_CORRUPTED_START_STAMP;
04221             Corrupted = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04222         }
04223         
04224         <span class="keywordflow">if</span> (Info-&gt;EndStamp != DPH_NORMAL_BLOCK_END_STAMP_FREE) {
04225             *Reason |= DPH_ERROR_CORRUPTED_END_STAMP;
04226             Corrupted = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04227         }
04228 
04229         <span class="comment">//</span>
04230         <span class="comment">// Check the block suffix byte pattern.</span>
04231         <span class="comment">//</span>
04232         
04233         <span class="keywordflow">if</span> (CheckPattern) {
04234             
04235             FillStart = (PUCHAR)Block + Info-&gt;RequestedSize;
04236             FillEnd = FillStart + USER_ALIGNMENT;
04237 
04238             <span class="keywordflow">for</span> (Current = FillStart; Current &lt; FillEnd; Current++) {
04239 
04240                 <span class="keywordflow">if</span> (*Current != DPH_NORMAL_BLOCK_SUFFIX) {
04241 
04242                     *Reason |= DPH_ERROR_CORRUPTED_SUFFIX_PATTERN;
04243                     Corrupted = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04244                     <span class="keywordflow">break</span>;
04245                 }
04246             }
04247         }
04248         
04249         <span class="comment">//</span>
04250         <span class="comment">// Check the block infix byte pattern.</span>
04251         <span class="comment">//</span>
04252 
04253         <span class="keywordflow">if</span> (CheckPattern) {
04254             
04255             FillStart = (PUCHAR)Block;
04256             FillEnd = FillStart 
04257                 + ((Info-&gt;RequestedSize &gt; USER_ALIGNMENT) ? USER_ALIGNMENT : Info-&gt;RequestedSize);
04258 
04259             <span class="keywordflow">for</span> (Current = FillStart; Current &lt; FillEnd; Current++) {
04260 
04261                 <span class="keywordflow">if</span> (*Current != DPH_FREE_BLOCK_INFIX) {
04262 
04263                     *Reason |= DPH_ERROR_CORRUPTED_INFIX_PATTERN;
04264                     Corrupted = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04265                     <span class="keywordflow">break</span>;
04266                 }
04267             }
04268         }
04269     }
04270     except (<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
04271 
04272         *Reason |= DPH_ERROR_RAISED_EXCEPTION;
04273         Corrupted = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04274     }
04275 
04276     <span class="keywordflow">if</span> (Corrupted) {
04277         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04278     }
04279     <span class="keywordflow">else</span> {
04280         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04281     }
04282 }
04283 
04284 BOOLEAN
<a name="l04285"></a><a class="code" href="../../d6/d9/heappage_8c.html#a82">04285</a> <a class="code" href="../../d6/d9/heappage_8c.html#a82">RtlpDphWritePageHeapBlockInformation</a> (
04286     PDPH_HEAP_ROOT Heap,
04287     PVOID Block,
04288     SIZE_T RequestedSize,
04289     SIZE_T ActualSize
04290     )
04291 {
04292     PDPH_BLOCK_INFORMATION Info;
04293     PUCHAR FillStart;
04294     PUCHAR FillEnd;
04295     ULONG Hash;
04296     
04297     <span class="comment">//</span>
04298     <span class="comment">// Size and stamp information</span>
04299     <span class="comment">//</span>
04300 
04301     Info = (PDPH_BLOCK_INFORMATION)Block - 1;
04302     
04303     Info-&gt;Heap = Heap;
04304     Info-&gt;RequestedSize = RequestedSize;
04305     Info-&gt;ActualSize = ActualSize;
04306     Info-&gt;StartStamp = DPH_PAGE_BLOCK_START_STAMP_ALLOCATED;
04307     Info-&gt;EndStamp = DPH_PAGE_BLOCK_END_STAMP_ALLOCATED;
04308 
04309     <span class="comment">//</span>
04310     <span class="comment">// Fill the block suffix pattern.</span>
04311     <span class="comment">// We fill up to USER_ALIGNMENT bytes.</span>
04312     <span class="comment">//</span>
04313 
04314     FillStart = (PUCHAR)Block + RequestedSize;
04315     FillEnd = (PUCHAR)<a class="code" href="../../d6/d9/heappage_8c.html#a8">ROUNDUP2</a>((ULONG_PTR)FillStart, <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
04316     
04317     RtlFillMemory (FillStart, FillEnd - FillStart, DPH_PAGE_BLOCK_SUFFIX);
04318 
04319     <span class="comment">//</span>
04320     <span class="comment">// Capture stack trace</span>
04321     <span class="comment">//</span>
04322 
04323     <span class="keywordflow">if</span> ((Heap-&gt;ExtraFlags &amp; PAGE_HEAP_COLLECT_STACK_TRACES)) {
04324         Info-&gt;StackTrace = <a class="code" href="../../d6/d9/heappage_8c.html#a89">RtlpDphLogStackTrace</a> (3);
04325     }
04326     <span class="keywordflow">else</span> {
04327         Info-&gt;StackTrace = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04328     }
04329 
04330     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04331 }
04332 
04333 BOOLEAN
<a name="l04334"></a><a class="code" href="../../d6/d9/heappage_8c.html#a81">04334</a> <a class="code" href="../../d6/d9/heappage_8c.html#a81">RtlpDphWriteNormalHeapBlockInformation</a> (
04335     PDPH_HEAP_ROOT Heap,
04336     PVOID Block,
04337     SIZE_T RequestedSize,
04338     SIZE_T ActualSize
04339     )
04340 {
04341     PDPH_BLOCK_INFORMATION Info;
04342     PUCHAR FillStart;
04343     PUCHAR FillEnd;
04344     ULONG Hash;
04345     ULONG Reason;
04346 
04347     Info = (PDPH_BLOCK_INFORMATION)Block - 1;
04348 
04349     <span class="comment">//</span>
04350     <span class="comment">// Size and stamp information</span>
04351     <span class="comment">//</span>
04352 
04353     Info-&gt;Heap = Heap;
04354     Info-&gt;RequestedSize = RequestedSize;
04355     Info-&gt;ActualSize = ActualSize;
04356     Info-&gt;StartStamp = DPH_NORMAL_BLOCK_START_STAMP_ALLOCATED;
04357     Info-&gt;EndStamp = DPH_NORMAL_BLOCK_END_STAMP_ALLOCATED;
04358 
04359     Info-&gt;FreeQueue.Blink = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04360     Info-&gt;FreeQueue.Flink = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04361 
04362     <span class="comment">//</span>
04363     <span class="comment">// Fill the block suffix pattern.</span>
04364     <span class="comment">// We fill only USER_ALIGNMENT bytes.</span>
04365     <span class="comment">//</span>
04366 
04367     FillStart = (PUCHAR)Block + RequestedSize;
04368     FillEnd = FillStart + USER_ALIGNMENT;
04369     
04370     RtlFillMemory (FillStart, FillEnd - FillStart, DPH_NORMAL_BLOCK_SUFFIX);
04371 
04372     <span class="comment">//</span>
04373     <span class="comment">// Capture stack trace</span>
04374     <span class="comment">//</span>
04375 
04376     <span class="keywordflow">if</span> ((Heap-&gt;ExtraFlags &amp; PAGE_HEAP_COLLECT_STACK_TRACES)) {
04377         
04378         Info-&gt;StackTrace = <a class="code" href="../../d6/d9/heappage_8c.html#a89">RtlpDphLogStackTrace</a> (4);
04379 
04380         <span class="keywordflow">if</span> (Info-&gt;StackTrace) {
04381             
04382             RtlTraceDatabaseLock (<a class="code" href="../../d6/d9/heappage_8c.html#a56">RtlpDphTraceDatabase</a>);
04383             ((PRTL_TRACE_BLOCK)(Info-&gt;StackTrace))-&gt;UserCount += 1;
04384             ((PRTL_TRACE_BLOCK)(Info-&gt;StackTrace))-&gt;UserSize += RequestedSize;
04385             ((PRTL_TRACE_BLOCK)(Info-&gt;StackTrace))-&gt;UserContext = Heap;
04386             RtlTraceDatabaseUnlock (<a class="code" href="../../d6/d9/heappage_8c.html#a56">RtlpDphTraceDatabase</a>);
04387         }
04388 
04389     }
04390     <span class="keywordflow">else</span> {
04391         Info-&gt;StackTrace = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04392     }
04393     
04394     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04395 }
04396 
04397 
04401 
04402 PVOID
<a name="l04403"></a><a class="code" href="../../d6/d9/heappage_8c.html#a69">04403</a> <a class="code" href="../../d6/d9/heappage_8c.html#a69">RtlpDphNormalHeapAllocate</a> (
04404     PDPH_HEAP_ROOT Heap,
04405     ULONG Flags,
04406     SIZE_T Size
04407     )
04408 {
04409     PVOID Block;
04410     PDPH_BLOCK_INFORMATION Info;
04411     ULONG Hash;
04412     SIZE_T ActualSize;
04413     SIZE_T RequestedSize;
04414     ULONG Reason;
04415 
04416     <a class="code" href="../../d6/d9/heappage_8c.html#a32">BUMP_GLOBAL_COUNTER</a> (DPH_COUNTER_NO_OF_NORMAL_ALLOCS);
04417     <a class="code" href="../../d6/d9/heappage_8c.html#a33">BUMP_SIZE_COUNTER</a> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>);
04418 
04419     Heap-&gt;Counter[DPH_COUNTER_NO_OF_NORMAL_ALLOCS] += 1;
04420 
04421     RequestedSize = <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
04422     ActualSize = <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> + <span class="keyword">sizeof</span>(DPH_BLOCK_INFORMATION) + USER_ALIGNMENT;
04423 
04424     Block = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a> (
04425         Heap-&gt;NormalHeap,
04426         Flags,
04427         ActualSize); 
04428 
04429     <span class="keywordflow">if</span> (Block == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04430 
04431         <span class="comment">//</span>
04432         <span class="comment">// (SilviuC): If we have memory pressure we might want </span>
04433         <span class="comment">// to trim the delayed free queues. We do not do this</span>
04434         <span class="comment">// right now because the threshold is kind of small.</span>
04435         <span class="comment">//</span>
04436         
04437         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04438     }
04439 
04440     <a class="code" href="../../d6/d9/heappage_8c.html#a81">RtlpDphWriteNormalHeapBlockInformation</a> (
04441         Heap,
04442         (PDPH_BLOCK_INFORMATION)Block + 1,
04443         RequestedSize,
04444         ActualSize);
04445 
04446     <span class="keywordflow">if</span> (! (Flags &amp; HEAP_ZERO_MEMORY)) {
04447 
04448         RtlFillMemory ((PDPH_BLOCK_INFORMATION)Block + 1, 
04449                        RequestedSize,
04450                        DPH_NORMAL_BLOCK_INFIX);
04451     }
04452 
04453     <span class="keywordflow">return</span> (PVOID)((PDPH_BLOCK_INFORMATION)Block + 1);
04454 }
04455 
04456 
04457 BOOLEAN
<a name="l04458"></a><a class="code" href="../../d6/d9/heappage_8c.html#a70">04458</a> <a class="code" href="../../d6/d9/heappage_8c.html#a70">RtlpDphNormalHeapFree</a> (
04459     PDPH_HEAP_ROOT Heap,
04460     ULONG Flags,
04461     PVOID Block
04462     )
04463 {
04464     PDPH_BLOCK_INFORMATION Info;
04465     BOOLEAN Success;
04466     ULONG Reason;
04467     ULONG Hash;
04468     SIZE_T TrimSize;
04469 
04470     <a class="code" href="../../d6/d9/heappage_8c.html#a32">BUMP_GLOBAL_COUNTER</a> (DPH_COUNTER_NO_OF_NORMAL_FREES);
04471     Heap-&gt;Counter[DPH_COUNTER_NO_OF_NORMAL_FREES] += 1;
04472 
04473     Info = (PDPH_BLOCK_INFORMATION)Block - 1;
04474     
04475     <span class="keywordflow">if</span> (! <a class="code" href="../../d6/d9/heappage_8c.html#a78">RtlpDphIsNormalHeapBlock</a>(Heap, Block, &amp;Reason, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>)) {
04476         
04477         <a class="code" href="../../d6/d9/heappage_8c.html#a77">RtlpDphReportCorruptedBlock</a> (Block, Reason);
04478 
04479         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04480     }
04481 
04482     <span class="comment">//</span>
04483     <span class="comment">// Save the free stack trace.</span>
04484     <span class="comment">//</span>
04485 
04486     <span class="keywordflow">if</span> ((Heap-&gt;ExtraFlags &amp; PAGE_HEAP_COLLECT_STACK_TRACES)) {
04487         
04488         <span class="keywordflow">if</span> (Info-&gt;StackTrace) {
04489             
04490             RtlTraceDatabaseLock (<a class="code" href="../../d6/d9/heappage_8c.html#a56">RtlpDphTraceDatabase</a>);
04491             ((PRTL_TRACE_BLOCK)(Info-&gt;StackTrace))-&gt;UserCount -= 1;
04492             ((PRTL_TRACE_BLOCK)(Info-&gt;StackTrace))-&gt;UserSize -= Info-&gt;RequestedSize;
04493             RtlTraceDatabaseUnlock (<a class="code" href="../../d6/d9/heappage_8c.html#a56">RtlpDphTraceDatabase</a>);
04494         }
04495 
04496         Info-&gt;StackTrace = <a class="code" href="../../d6/d9/heappage_8c.html#a89">RtlpDphLogStackTrace</a> (3);
04497     }
04498     <span class="keywordflow">else</span> {
04499         Info-&gt;StackTrace = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04500     }
04501 
04502     <span class="comment">//</span>
04503     <span class="comment">// Mark the block as freed.</span>
04504     <span class="comment">//</span>
04505 
04506     Info-&gt;StartStamp -= 1;
04507     Info-&gt;EndStamp -= 1;
04508     
04509     <span class="comment">//</span>
04510     <span class="comment">// Wipe out all the information in the block so that it cannot</span>
04511     <span class="comment">// be used while free. The pattern looks like a kernel pointer</span>
04512     <span class="comment">// and if we are lucky enough the buggy code might use a value</span>
04513     <span class="comment">// from the block as a pointer and instantly access violate.</span>
04514     <span class="comment">//</span>
04515 
04516     RtlFillMemory (
04517         Info + 1,
04518         Info-&gt;RequestedSize,
04519         DPH_FREE_BLOCK_INFIX);
04520     
04521     <span class="comment">//</span>
04522     <span class="comment">// It is useful during debugging sessions to not free at</span>
04523     <span class="comment">// all so that you can detect use after free, etc.</span>
04524     <span class="comment">//</span>
04525 
04526     <span class="keywordflow">if</span> ((<a class="code" href="../../d6/d9/heappage_8c.html#a51">RtlpDphDebugLevel</a> &amp; <a class="code" href="../../d6/d9/heappage_8c.html#a30">DPH_DEBUG_NEVER_FREE</a>)) {
04527         
04528         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04529     }
04530     
04531     <span class="comment">//</span>
04532     <span class="comment">// Add block to the delayed free queue.</span>
04533     <span class="comment">//</span>
04534 
04535     <a class="code" href="../../d6/d9/heappage_8c.html#a84">RtlpDphAddToDelayedFreeQueue</a> (Info);
04536     
04537     <span class="comment">//</span>
04538     <span class="comment">// If we are over the threshold we need to really free</span>
04539     <span class="comment">// some of the guys.</span>
04540     <span class="comment">//</span>
04541     <span class="comment">// (SilviuC): should make this threshold more fine tuned.</span>
04542     <span class="comment">//</span>
04543 
04544     Success = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04545 
04546     <span class="keywordflow">if</span> (<a class="code" href="../../d6/d9/heappage_8c.html#a85">RtlpDphNeedToTrimDelayedFreeQueue</a>(&amp;TrimSize)) {
04547 
04548         <a class="code" href="../../d6/d9/heappage_8c.html#a86">RtlpDphTrimDelayedFreeQueue</a> (TrimSize, Flags);
04549     }
04550 
04551     <span class="keywordflow">return</span> Success;
04552 }
04553 
04554 
04555 PVOID
<a name="l04556"></a><a class="code" href="../../d6/d9/heappage_8c.html#a71">04556</a> <a class="code" href="../../d6/d9/heappage_8c.html#a71">RtlpDphNormalHeapReAllocate</a> (
04557     PDPH_HEAP_ROOT Heap,
04558     ULONG Flags,
04559     PVOID OldBlock,
04560     SIZE_T Size
04561     )
04562 {
04563     PVOID Block;
04564     PDPH_BLOCK_INFORMATION Info;
04565     ULONG Hash;
04566     SIZE_T CopySize;
04567     ULONG Reason;
04568 
04569     <a class="code" href="../../d6/d9/heappage_8c.html#a32">BUMP_GLOBAL_COUNTER</a> (DPH_COUNTER_NO_OF_NORMAL_REALLOCS);
04570     <a class="code" href="../../d6/d9/heappage_8c.html#a33">BUMP_SIZE_COUNTER</a> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>);
04571 
04572     Heap-&gt;Counter[DPH_COUNTER_NO_OF_NORMAL_REALLOCS] += 1;
04573     
04574     Info = (PDPH_BLOCK_INFORMATION)OldBlock - 1;
04575 
04576     <span class="keywordflow">if</span> (! <a class="code" href="../../d6/d9/heappage_8c.html#a78">RtlpDphIsNormalHeapBlock</a>(Heap, OldBlock, &amp;Reason, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>)) {
04577         
04578         <a class="code" href="../../d6/d9/heappage_8c.html#a77">RtlpDphReportCorruptedBlock</a> (OldBlock, Reason);
04579 
04580         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04581     }
04582 
04583     <span class="comment">//</span>
04584     <span class="comment">// Note that this operation will bump the counters for</span>
04585     <span class="comment">// normal allocations. Decided to leave this situation</span>
04586     <span class="comment">// as it is. </span>
04587     <span class="comment">//</span>
04588 
04589     Block = <a class="code" href="../../d6/d9/heappage_8c.html#a69">RtlpDphNormalHeapAllocate</a> (Heap, Flags, <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>);
04590 
04591     <span class="keywordflow">if</span> (Block == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04592         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04593     }
04594 
04595     <span class="comment">//</span>
04596     <span class="comment">// Copy old block stuff into the new block and then</span>
04597     <span class="comment">// free old block.</span>
04598     <span class="comment">//</span>
04599 
04600     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> &lt; Info-&gt;RequestedSize) {
04601         CopySize = <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
04602     }
04603     <span class="keywordflow">else</span> {
04604         CopySize = Info-&gt;RequestedSize;
04605     }
04606 
04607     RtlCopyMemory (Block, OldBlock, CopySize);
04608 
04609     <span class="comment">//</span>
04610     <span class="comment">// Free the old guy.</span>
04611     <span class="comment">//</span>
04612 
04613     <a class="code" href="../../d6/d9/heappage_8c.html#a70">RtlpDphNormalHeapFree</a> (Heap, Flags, OldBlock);
04614 
04615     <span class="keywordflow">return</span> Block;
04616 }
04617 
04618 
04619 SIZE_T
<a name="l04620"></a><a class="code" href="../../d6/d9/heappage_8c.html#a72">04620</a> <a class="code" href="../../d6/d9/heappage_8c.html#a72">RtlpDphNormalHeapSize</a> (
04621     PDPH_HEAP_ROOT Heap,
04622     ULONG Flags,
04623     PVOID Block
04624     )
04625 {
04626     PDPH_BLOCK_INFORMATION Info;
04627     SIZE_T Result;
04628     ULONG Reason;
04629 
04630     Info = (PDPH_BLOCK_INFORMATION)Block - 1;
04631 
04632     <span class="keywordflow">if</span> (! <a class="code" href="../../d6/d9/heappage_8c.html#a78">RtlpDphIsNormalHeapBlock</a>(Heap, Block, &amp;Reason, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
04633         
04634         <span class="comment">//</span>
04635         <span class="comment">// We cannot stop here for a wrong block. </span>
04636         <span class="comment">// The users might use this function to validate</span>
04637         <span class="comment">// if a block belongs to the heap or not. However </span>
04638         <span class="comment">// they should use HeapValidate for that.</span>
04639         <span class="comment">//</span>
04640         
04641 <span class="preprocessor">#if DBG</span>
04642 <span class="preprocessor"></span>        <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a> (<span class="stringliteral">"Page heap: warning: HeapSize called with "</span>
04643             <span class="stringliteral">"invalid block @ %p (reason %0X) \n"</span>, Block, Reason);
04644 <span class="preprocessor">#endif</span>
04645 <span class="preprocessor"></span>
04646         <span class="keywordflow">return</span> (SIZE_T)-1;
04647     }
04648 
04649     Result = <a class="code" href="../../d1/d9/rtl_2heap_8c.html#a21">RtlSizeHeap</a> (
04650         Heap-&gt;NormalHeap,
04651         Flags,
04652         Info); 
04653 
04654     <span class="keywordflow">if</span> (Result == (SIZE_T)-1) {
04655         <span class="keywordflow">return</span> Result;
04656     }
04657     <span class="keywordflow">else</span> {
04658         <span class="keywordflow">return</span> Result - <span class="keyword">sizeof</span>(*Info) - USER_ALIGNMENT;
04659     }
04660 }
04661 
04662 
04663 BOOLEAN
<a name="l04664"></a><a class="code" href="../../d6/d9/heappage_8c.html#a73">04664</a> <a class="code" href="../../d6/d9/heappage_8c.html#a73">RtlpDphNormalHeapSetUserFlags</a>(
04665     IN PDPH_HEAP_ROOT Heap,
04666     IN ULONG Flags,
04667     IN PVOID Address,
04668     IN ULONG UserFlagsReset,
04669     IN ULONG UserFlagsSet
04670     )
04671 {
04672     BOOLEAN Success;
04673     ULONG Reason;
04674 
04675     <span class="keywordflow">if</span> (! <a class="code" href="../../d6/d9/heappage_8c.html#a78">RtlpDphIsNormalHeapBlock</a>(Heap, Address, &amp;Reason, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
04676         
04677         <a class="code" href="../../d6/d9/heappage_8c.html#a77">RtlpDphReportCorruptedBlock</a> (Address, Reason);
04678 
04679         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04680     }
04681     
04682     Success = <a class="code" href="../../d5/d9/heapdll_8c.html#a27">RtlSetUserFlagsHeap</a> (
04683         Heap-&gt;NormalHeap,
04684         Flags,
04685         (PDPH_BLOCK_INFORMATION)Address - 1,
04686         UserFlagsReset,
04687         UserFlagsSet);
04688 
04689     <span class="keywordflow">return</span> Success;
04690 }
04691 
04692 
04693 BOOLEAN
<a name="l04694"></a><a class="code" href="../../d6/d9/heappage_8c.html#a74">04694</a> <a class="code" href="../../d6/d9/heappage_8c.html#a74">RtlpDphNormalHeapSetUserValue</a>(
04695     IN PDPH_HEAP_ROOT Heap,
04696     IN ULONG Flags,
04697     IN PVOID Address,
04698     IN PVOID UserValue
04699     )
04700 {
04701     BOOLEAN Success;
04702     ULONG Reason;
04703 
04704     <span class="keywordflow">if</span> (! <a class="code" href="../../d6/d9/heappage_8c.html#a78">RtlpDphIsNormalHeapBlock</a>(Heap, Address, &amp;Reason, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
04705         
04706         <a class="code" href="../../d6/d9/heappage_8c.html#a77">RtlpDphReportCorruptedBlock</a> (Address, Reason);
04707 
04708         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04709     }
04710     
04711     Success = <a class="code" href="../../d5/d9/heapdll_8c.html#a26">RtlSetUserValueHeap</a> (
04712         Heap-&gt;NormalHeap,
04713         Flags,
04714         (PDPH_BLOCK_INFORMATION)Address - 1,
04715         UserValue);
04716 
04717     <span class="keywordflow">return</span> Success;
04718 }
04719 
04720 
04721 BOOLEAN
<a name="l04722"></a><a class="code" href="../../d6/d9/heappage_8c.html#a75">04722</a> <a class="code" href="../../d6/d9/heappage_8c.html#a75">RtlpDphNormalHeapGetUserInfo</a>(
04723     IN PDPH_HEAP_ROOT Heap,
04724     IN  ULONG  Flags,
04725     IN  PVOID  Address,
04726     OUT PVOID* UserValue,
04727     OUT PULONG UserFlags
04728     )
04729 {
04730     BOOLEAN Success;
04731     ULONG Reason;
04732 
04733     <span class="keywordflow">if</span> (! <a class="code" href="../../d6/d9/heappage_8c.html#a78">RtlpDphIsNormalHeapBlock</a>(Heap, Address, &amp;Reason, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
04734         
04735         <a class="code" href="../../d6/d9/heappage_8c.html#a77">RtlpDphReportCorruptedBlock</a> (Address, Reason);
04736 
04737         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04738     }
04739     
04740     Success = <a class="code" href="../../d5/d9/heapdll_8c.html#a25">RtlGetUserInfoHeap</a> (
04741         Heap-&gt;NormalHeap,
04742         Flags,
04743         (PDPH_BLOCK_INFORMATION)Address - 1,
04744         UserValue,
04745         UserFlags);
04746 
04747     <span class="keywordflow">return</span> Success;
04748 }
04749 
04750 
04751 BOOLEAN
<a name="l04752"></a><a class="code" href="../../d6/d9/heappage_8c.html#a76">04752</a> <a class="code" href="../../d6/d9/heappage_8c.html#a76">RtlpDphNormalHeapValidate</a>(
04753     IN PDPH_HEAP_ROOT Heap,
04754     IN ULONG Flags,
04755     IN PVOID Address
04756     )
04757 {
04758     BOOLEAN Success;
04759     ULONG Reason;
04760 
04761     <span class="keywordflow">if</span> (Address == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04762         
04763         <span class="comment">//</span>
04764         <span class="comment">// Validation for the whole heap.</span>
04765         <span class="comment">//</span>
04766 
04767         Success = <a class="code" href="../../d5/d9/heapdll_8c.html#a32">RtlValidateHeap</a> (
04768             Heap-&gt;NormalHeap,
04769             Flags,
04770             Address);
04771     }
04772     <span class="keywordflow">else</span> {
04773 
04774         <span class="comment">//</span>
04775         <span class="comment">// Validation for a heap block.</span>
04776         <span class="comment">//</span>
04777 
04778         <span class="keywordflow">if</span> (! <a class="code" href="../../d6/d9/heappage_8c.html#a78">RtlpDphIsNormalHeapBlock</a>(Heap, Address, &amp;Reason, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>)) {
04779 
04780             <span class="comment">//</span>
04781             <span class="comment">// We cannot break in this case because the function might indeed</span>
04782             <span class="comment">// be called with invalid block. </span>
04783             <span class="comment">//</span>
04784             <span class="comment">// (SilviuC): we  will leave this as a warning and delete it only</span>
04785             <span class="comment">// if it becomes annoying.</span>
04786             <span class="comment">//</span>
04787 
04788 <span class="preprocessor">#if DBG</span>
04789 <span class="preprocessor"></span>            <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a> (<span class="stringliteral">"Page heap: warning: validate called with "</span>
04790                       <span class="stringliteral">"invalid block @ %p (reason %0X) \n"</span>, Address, Reason);
04791 <span class="preprocessor">#endif</span>
04792 <span class="preprocessor"></span>
04793             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04794         }
04795 
04796         Success = <a class="code" href="../../d5/d9/heapdll_8c.html#a32">RtlValidateHeap</a> (
04797             Heap-&gt;NormalHeap,
04798             Flags,
04799             (PDPH_BLOCK_INFORMATION)Address - 1);
04800     }
04801 
04802     <span class="keywordflow">return</span> Success;
04803 }
04804 
04805 
04809 
04810 
<a name="l04811"></a><a class="code" href="../../d6/d9/heappage_8c.html#a57">04811</a> RTL_CRITICAL_SECTION <a class="code" href="../../d6/d9/heappage_8c.html#a57">RtlpDphDelayedFreeQueueLock</a>;
04812 
<a name="l04813"></a><a class="code" href="../../d6/d9/heappage_8c.html#a58">04813</a> SIZE_T <a class="code" href="../../d6/d9/heappage_8c.html#a58">RtlpDphMemoryUsedByDelayedFreeBlocks</a>;
<a name="l04814"></a><a class="code" href="../../d6/d9/heappage_8c.html#a59">04814</a> SIZE_T <a class="code" href="../../d6/d9/heappage_8c.html#a59">RtlpDphNumberOfDelayedFreeBlocks</a>;
04815 
<a name="l04816"></a><a class="code" href="../../d6/d9/heappage_8c.html#a60">04816</a> LIST_ENTRY <a class="code" href="../../d6/d9/heappage_8c.html#a60">RtlpDphDelayedFreeQueue</a>;
04817 
04818 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l04819"></a><a class="code" href="../../d6/d9/heappage_8c.html#a83">04819</a> <a class="code" href="../../d6/d9/heappage_8c.html#a83">RtlpDphInitializeDelayedFreeQueue</a> (
04820     )
04821 {
04822     <a class="code" href="../../d7/d8/dll_2resource_8c.html#a24">RtlInitializeCriticalSection</a> (&amp;<a class="code" href="../../d6/d9/heappage_8c.html#a57">RtlpDphDelayedFreeQueueLock</a>);
04823     InitializeListHead (&amp;<a class="code" href="../../d6/d9/heappage_8c.html#a60">RtlpDphDelayedFreeQueue</a>);
04824 
04825     <a class="code" href="../../d6/d9/heappage_8c.html#a58">RtlpDphMemoryUsedByDelayedFreeBlocks</a> = 0;
04826     <a class="code" href="../../d6/d9/heappage_8c.html#a59">RtlpDphNumberOfDelayedFreeBlocks</a> = 0;
04827 }
04828 
04829 
04830 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l04831"></a><a class="code" href="../../d6/d9/heappage_8c.html#a84">04831</a> <a class="code" href="../../d6/d9/heappage_8c.html#a84">RtlpDphAddToDelayedFreeQueue</a> (
04832     PDPH_BLOCK_INFORMATION Info
04833     )
04834 {
04835     RtlEnterCriticalSection (&amp;<a class="code" href="../../d6/d9/heappage_8c.html#a57">RtlpDphDelayedFreeQueueLock</a>);
04836 
04837     InsertTailList (&amp;(<a class="code" href="../../d6/d9/heappage_8c.html#a60">RtlpDphDelayedFreeQueue</a>), &amp;(Info-&gt;FreeQueue));
04838     
04839     <a class="code" href="../../d6/d9/heappage_8c.html#a58">RtlpDphMemoryUsedByDelayedFreeBlocks</a> += Info-&gt;ActualSize;
04840     <a class="code" href="../../d6/d9/heappage_8c.html#a59">RtlpDphNumberOfDelayedFreeBlocks</a> += 1;
04841     
04842     RtlLeaveCriticalSection (&amp;<a class="code" href="../../d6/d9/heappage_8c.html#a57">RtlpDphDelayedFreeQueueLock</a>);
04843 }
04844 
04845 BOOLEAN
<a name="l04846"></a><a class="code" href="../../d6/d9/heappage_8c.html#a85">04846</a> <a class="code" href="../../d6/d9/heappage_8c.html#a85">RtlpDphNeedToTrimDelayedFreeQueue</a> (
04847     PSIZE_T TrimSize
04848     )
04849 {
04850     BOOLEAN Result;
04851     
04852     RtlEnterCriticalSection (&amp;<a class="code" href="../../d6/d9/heappage_8c.html#a57">RtlpDphDelayedFreeQueueLock</a>);
04853 
04854     <span class="keywordflow">if</span> (<a class="code" href="../../d6/d9/heappage_8c.html#a58">RtlpDphMemoryUsedByDelayedFreeBlocks</a> &gt; <a class="code" href="../../d6/d9/heappage_8c.html#a54">RtlpDphDelayedFreeCacheSize</a>) {
04855         
04856         *TrimSize = <a class="code" href="../../d6/d9/heappage_8c.html#a58">RtlpDphMemoryUsedByDelayedFreeBlocks</a> - <a class="code" href="../../d6/d9/heappage_8c.html#a54">RtlpDphDelayedFreeCacheSize</a>;
04857 
04858         <span class="keywordflow">if</span> (*TrimSize &lt; <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>) {
04859             *TrimSize = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
04860         }
04861 
04862         Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04863     }
04864     <span class="keywordflow">else</span> {
04865 
04866         Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04867     }
04868 
04869     RtlLeaveCriticalSection (&amp;<a class="code" href="../../d6/d9/heappage_8c.html#a57">RtlpDphDelayedFreeQueueLock</a>);
04870     <span class="keywordflow">return</span> Result;
04871 }
04872 
04873 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l04874"></a><a class="code" href="../../d6/d9/heappage_8c.html#a86">04874</a> <a class="code" href="../../d6/d9/heappage_8c.html#a86">RtlpDphTrimDelayedFreeQueue</a> (
04875     SIZE_T TrimSize,
04876     ULONG Flags
04877     )
04878 <span class="comment">/*++</span>
04879 <span class="comment"></span>
04880 <span class="comment">Routine Description:</span>
04881 <span class="comment"></span>
04882 <span class="comment">    This routine trims the delayed free queue (global per process).</span>
04883 <span class="comment">    If trim size is zero it will trim up to a global threshold</span>
04884 <span class="comment">    (RtlpDphDelayedFreeCacheSize) otherwise uses `TrimSize'. </span>
04885 <span class="comment">    </span>
04886 <span class="comment">    Note. This function might become a little bit of a bottleneck</span>
04887 <span class="comment">    because it is called by every free operation. Because of this</span>
04888 <span class="comment">    it is better to always call RtlpDphNeedToTrimDelayedFreeQueue</span>
04889 <span class="comment">    first.</span>
04890 <span class="comment"></span>
04891 <span class="comment">Arguments:</span>
04892 <span class="comment"></span>
04893 <span class="comment">    TrimSize: amount to trim (in bytes). If zero it trims down to</span>
04894 <span class="comment">    a global threshold.</span>
04895 <span class="comment">    </span>
04896 <span class="comment">    Flags: flags for free operation.</span>
04897 <span class="comment"></span>
04898 <span class="comment">Return Value:</span>
04899 <span class="comment"></span>
04900 <span class="comment">    None.</span>
04901 <span class="comment"></span>
04902 <span class="comment">Environment:</span>
04903 <span class="comment"></span>
04904 <span class="comment">    Called from RtlpDphNormalXxx (normal heap management) routines.</span>
04905 <span class="comment"></span>
04906 <span class="comment">--*/</span>
04907 
04908 {
04909     ULONG Reason;
04910     SIZE_T CurrentTrimmed = 0;
04911     PDPH_BLOCK_INFORMATION QueueBlock;
04912     PLIST_ENTRY ListEntry;
04913 
04914     RtlEnterCriticalSection (&amp;<a class="code" href="../../d6/d9/heappage_8c.html#a57">RtlpDphDelayedFreeQueueLock</a>);
04915 
04916     <span class="keywordflow">if</span> (TrimSize == 0) {
04917         <span class="keywordflow">if</span> (<a class="code" href="../../d6/d9/heappage_8c.html#a58">RtlpDphMemoryUsedByDelayedFreeBlocks</a> &gt; <a class="code" href="../../d6/d9/heappage_8c.html#a54">RtlpDphDelayedFreeCacheSize</a>) {
04918 
04919             TrimSize = <a class="code" href="../../d6/d9/heappage_8c.html#a58">RtlpDphMemoryUsedByDelayedFreeBlocks</a> - <a class="code" href="../../d6/d9/heappage_8c.html#a54">RtlpDphDelayedFreeCacheSize</a>;
04920         }
04921     }
04922 
04923     <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
04924         
04925         <span class="comment">//</span>
04926         <span class="comment">// Did we achieve our trimming goal?</span>
04927         <span class="comment">//</span>
04928 
04929         <span class="keywordflow">if</span> (CurrentTrimmed &gt;= TrimSize) {
04930             <span class="keywordflow">break</span>;  
04931         }
04932         
04933         <span class="comment">//</span>
04934         <span class="comment">// The list can get empty since we remove blocks from it.</span>
04935         <span class="comment">//</span>
04936 
04937         <span class="keywordflow">if</span> (IsListEmpty(&amp;<a class="code" href="../../d6/d9/heappage_8c.html#a60">RtlpDphDelayedFreeQueue</a>)) {
04938             <span class="keywordflow">break</span>;
04939         }
04940 
04941         ListEntry = RemoveHeadList (&amp;<a class="code" href="../../d6/d9/heappage_8c.html#a60">RtlpDphDelayedFreeQueue</a>);
04942         QueueBlock = CONTAINING_RECORD (ListEntry, DPH_BLOCK_INFORMATION, <a class="code" href="../../d6/d3/queue_8c.html#a46">FreeQueue</a>);
04943 
04944         <span class="keywordflow">if</span> (! <a class="code" href="../../d6/d9/heappage_8c.html#a79">RtlpDphIsNormalFreeHeapBlock</a>(QueueBlock + 1, &amp;Reason, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>)) {
04945 
04946             <a class="code" href="../../d6/d9/heappage_8c.html#a77">RtlpDphReportCorruptedBlock</a> (QueueBlock + 1, Reason);
04947         }
04948 
04949         <a class="code" href="../../d6/d9/heappage_8c.html#a58">RtlpDphMemoryUsedByDelayedFreeBlocks</a> -= QueueBlock-&gt;ActualSize;
04950         <a class="code" href="../../d6/d9/heappage_8c.html#a59">RtlpDphNumberOfDelayedFreeBlocks</a> -= 1;
04951         CurrentTrimmed += QueueBlock-&gt;ActualSize;
04952 
04953         <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a> (((PDPH_HEAP_ROOT)(QueueBlock-&gt;Heap))-&gt;NormalHeap, Flags, QueueBlock); 
04954     }
04955     
04956     RtlLeaveCriticalSection (&amp;<a class="code" href="../../d6/d9/heappage_8c.html#a57">RtlpDphDelayedFreeQueueLock</a>);
04957 }
04958 
04959 
04960 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l04961"></a><a class="code" href="../../d6/d9/heappage_8c.html#a87">04961</a> <a class="code" href="../../d6/d9/heappage_8c.html#a87">RtlpDphFreeDelayedBlocksFromHeap</a> (
04962     PVOID PageHeap,
04963     PVOID NormalHeap
04964     )
04965 {
04966     ULONG Reason;
04967     PDPH_BLOCK_INFORMATION Block;
04968     PLIST_ENTRY Current;
04969     PLIST_ENTRY Next;
04970 
04971     RtlEnterCriticalSection (&amp;<a class="code" href="../../d6/d9/heappage_8c.html#a57">RtlpDphDelayedFreeQueueLock</a>);
04972 
04973     <span class="keywordflow">for</span> (Current = <a class="code" href="../../d6/d9/heappage_8c.html#a60">RtlpDphDelayedFreeQueue</a>.Flink;
04974          Current != &amp;<a class="code" href="../../d6/d9/heappage_8c.html#a60">RtlpDphDelayedFreeQueue</a>;
04975          Current = Next) {
04976         
04977         Next = Current-&gt;Flink;
04978         
04979         Block = CONTAINING_RECORD (Current, DPH_BLOCK_INFORMATION, <a class="code" href="../../d6/d3/queue_8c.html#a46">FreeQueue</a>);
04980 
04981         <span class="keywordflow">if</span> (Block-&gt;Heap != PageHeap) {
04982             <span class="keywordflow">continue</span>;
04983         }
04984         
04985         <span class="comment">//</span>
04986         <span class="comment">// We need to delete this block;</span>
04987         <span class="comment">//</span>
04988 
04989         RemoveEntryList (Current);
04990         Block = CONTAINING_RECORD (Current, DPH_BLOCK_INFORMATION, <a class="code" href="../../d6/d3/queue_8c.html#a46">FreeQueue</a>);
04991 
04992         <span class="comment">//</span>
04993         <span class="comment">// Prevent probing of this field during RtlpDphIsNormalFreeBlock.</span>
04994         <span class="comment">//</span>
04995 
04996         Block-&gt;Heap = 0;
04997 
04998         <span class="comment">//</span>
04999         <span class="comment">// Check if the block about to be freed was touched.</span>
05000         <span class="comment">//</span>
05001 
05002         <span class="keywordflow">if</span> (! <a class="code" href="../../d6/d9/heappage_8c.html#a79">RtlpDphIsNormalFreeHeapBlock</a>(Block + 1, &amp;Reason, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>)) {
05003 
05004             <a class="code" href="../../d6/d9/heappage_8c.html#a77">RtlpDphReportCorruptedBlock</a> (Block + 1, Reason);
05005         }
05006 
05007         <a class="code" href="../../d6/d9/heappage_8c.html#a58">RtlpDphMemoryUsedByDelayedFreeBlocks</a> -= Block-&gt;ActualSize;
05008         <a class="code" href="../../d6/d9/heappage_8c.html#a59">RtlpDphNumberOfDelayedFreeBlocks</a> -= 1;
05009 
05010         <span class="comment">//</span>
05011         <span class="comment">// (SilviuC): Not sure what flags to use here. Zero should work</span>
05012         <span class="comment">// but I have to investigate.</span>
05013         <span class="comment">//</span>
05014 
05015         <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a> (NormalHeap, 0, Block); 
05016     }
05017     
05018     RtlLeaveCriticalSection (&amp;<a class="code" href="../../d6/d9/heappage_8c.html#a57">RtlpDphDelayedFreeQueueLock</a>);
05019 }
05020 
05024 
05025 PRTL_TRACE_BLOCK 
<a name="l05026"></a><a class="code" href="../../d6/d9/heappage_8c.html#a89">05026</a> <a class="code" href="../../d6/d9/heappage_8c.html#a89">RtlpDphLogStackTrace</a> (
05027     ULONG FramesToSkip
05028     )
05029 {
05030     PVOID Trace [DPH_MAX_STACK_LENGTH];
05031     ULONG Hash;
05032     ULONG <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>;
05033     PRTL_TRACE_BLOCK Block;
05034     BOOLEAN Result;
05035 
05036     <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> = <a class="code" href="../../d5/d2/ppc_2getcalr_8c.html#a1">RtlCaptureStackBackTrace</a> (
05037         1 + FramesToSkip, 
05038         DPH_MAX_STACK_LENGTH, 
05039         Trace, 
05040         &amp;Hash);
05041 
05042     <span class="keywordflow">if</span> (<a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> == 0 || <a class="code" href="../../d6/d9/heappage_8c.html#a56">RtlpDphTraceDatabase</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05043         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05044     }
05045 
05046     Result = RtlTraceDatabaseAdd (
05047         <a class="code" href="../../d6/d9/heappage_8c.html#a56">RtlpDphTraceDatabase</a>,
05048         <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>,
05049         Trace,
05050         &amp;Block);
05051 
05052     <span class="keywordflow">if</span> (Result == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
05053         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05054     }
05055     <span class="keywordflow">else</span> {
05056         <span class="keywordflow">return</span> Block;
05057     }
05058 }
05059 
05063 
<a name="l05064"></a><a class="code" href="../../d6/d9/heappage_8c.html#a61">05064</a> RTL_CRITICAL_SECTION <a class="code" href="../../d6/d9/heappage_8c.html#a61">RtlpDphTargetDllsLock</a>;
<a name="l05065"></a><a class="code" href="../../d6/d9/heappage_8c.html#a62">05065</a> LIST_ENTRY <a class="code" href="../../d6/d9/heappage_8c.html#a62">RtlpDphTargetDllsList</a>;
<a name="l05066"></a><a class="code" href="../../d6/d9/heappage_8c.html#a63">05066</a> BOOLEAN <a class="code" href="../../d6/d9/heappage_8c.html#a63">RtlpDphTargetDllsInitialized</a>;
05067 
<a name="l05068"></a><a class="code" href="../../d8/d8/struct__DPH__TARGET__DLL.html">05068</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d8/d8/struct__DPH__TARGET__DLL.html">_DPH_TARGET_DLL</a> {
05069 
<a name="l05070"></a><a class="code" href="../../d8/d8/struct__DPH__TARGET__DLL.html#o0">05070</a>     LIST_ENTRY <a class="code" href="../../d8/d8/struct__DPH__TARGET__DLL.html#o0">List</a>;
<a name="l05071"></a><a class="code" href="../../d8/d8/struct__DPH__TARGET__DLL.html#o1">05071</a>     UNICODE_STRING <a class="code" href="../../d8/d8/struct__DPH__TARGET__DLL.html#o1">Name</a>;
<a name="l05072"></a><a class="code" href="../../d8/d8/struct__DPH__TARGET__DLL.html#o2">05072</a>     PVOID <a class="code" href="../../d8/d8/struct__DPH__TARGET__DLL.html#o2">StartAddress</a>;
<a name="l05073"></a><a class="code" href="../../d8/d8/struct__DPH__TARGET__DLL.html#o3">05073</a>     PVOID <a class="code" href="../../d8/d8/struct__DPH__TARGET__DLL.html#o3">EndAddress</a>;
05074 
05075 } <a class="code" href="../../d8/d8/struct__DPH__TARGET__DLL.html">DPH_TARGET_DLL</a>, * <a class="code" href="../../d8/d8/struct__DPH__TARGET__DLL.html">PDPH_TARGET_DLL</a>;
05076 
05077 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l05078"></a><a class="code" href="../../d6/d9/heappage_8c.html#a103">05078</a> <a class="code" href="../../d6/d9/heappage_8c.html#a103">RtlpDphTargetDllsLogicInitialize</a> (
05079     )
05080 {
05081     <a class="code" href="../../d7/d8/dll_2resource_8c.html#a24">RtlInitializeCriticalSection</a> (&amp;<a class="code" href="../../d6/d9/heappage_8c.html#a61">RtlpDphTargetDllsLock</a>);
05082     InitializeListHead (&amp;<a class="code" href="../../d6/d9/heappage_8c.html#a62">RtlpDphTargetDllsList</a>);
05083     <a class="code" href="../../d6/d9/heappage_8c.html#a63">RtlpDphTargetDllsInitialized</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
05084 }
05085 
05086 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l05087"></a><a class="code" href="../../d6/d9/heappage_8c.html#a104">05087</a> <a class="code" href="../../d6/d9/heappage_8c.html#a104">RtlpDphTargetDllsLoadCallBack</a> (
05088     PUNICODE_STRING Name,
05089     PVOID Address,
05090     ULONG Size
05091     )
05092 <span class="comment">//</span>
05093 <span class="comment">// This function is not called right now but it will get called</span>
05094 <span class="comment">// from \base\ntdll\ldrapi.c whenever a dll gets loaded. This</span>
05095 <span class="comment">// gives page heap the opportunity to update per dll data structures</span>
05096 <span class="comment">// that are not used right now for anything.</span>
05097 <span class="comment">//</span>
05098 {
05099     <a class="code" href="../../d6/d9/heappage_8c.html#a65">PDPH_TARGET_DLL</a> Descriptor;
05100 
05101     <span class="comment">//</span>
05102     <span class="comment">// Get out if we are in some weird condition.</span>
05103     <span class="comment">//</span>
05104 
05105     <span class="keywordflow">if</span> (! <a class="code" href="../../d6/d9/heappage_8c.html#a63">RtlpDphTargetDllsInitialized</a>) {
05106         <span class="keywordflow">return</span>;
05107     }
05108 
05109     <span class="keywordflow">if</span> (! <a class="code" href="../../d6/d9/heappage_8c.html#a105">RtlpDphIsDllTargeted</a> (<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer)) {
05110         <span class="keywordflow">return</span>;
05111     }
05112 
05113     Descriptor = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a> (RtlProcessHeap(), 0, <span class="keyword">sizeof</span> *Descriptor);
05114 
05115     <span class="keywordflow">if</span> (Descriptor == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05116         <span class="keywordflow">return</span>;
05117     }
05118 
05119     <span class="keywordflow">if</span> (! <a class="code" href="../../d6/d6/nls_8c.html#a47">RtlCreateUnicodeString</a> (&amp;(Descriptor-&gt;Name), <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer)) {
05120         <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a> (RtlProcessHeap(), 0, Descriptor);
05121         <span class="keywordflow">return</span>;
05122     }
05123 
05124     Descriptor-&gt;StartAddress = Address;
05125     Descriptor-&gt;EndAddress = (PUCHAR)Address + <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
05126 
05127     RtlEnterCriticalSection (&amp;<a class="code" href="../../d6/d9/heappage_8c.html#a61">RtlpDphTargetDllsLock</a>);
05128     InsertTailList (&amp;(<a class="code" href="../../d6/d9/heappage_8c.html#a62">RtlpDphTargetDllsList</a>), &amp;(Descriptor-&gt;List));
05129     RtlLeaveCriticalSection (&amp;<a class="code" href="../../d6/d9/heappage_8c.html#a61">RtlpDphTargetDllsLock</a>);
05130 
05131     <span class="comment">//</span>
05132     <span class="comment">// SilviuC: This message should be printed only if a target</span>
05133     <span class="comment">// dll has been identified.</span>
05134     <span class="comment">//</span>
05135 
05136     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"Page heap: loaded target dll %ws [%p - %p]\n"</span>, 
05137              Descriptor-&gt;Name.Buffer,
05138              Descriptor-&gt;StartAddress,
05139              Descriptor-&gt;EndAddress);
05140 }
05141 
05142 <span class="keyword">const</span> WCHAR *
<a name="l05143"></a><a class="code" href="../../d6/d9/heappage_8c.html#a105">05143</a> <a class="code" href="../../d6/d9/heappage_8c.html#a105">RtlpDphIsDllTargeted</a> (
05144     <span class="keyword">const</span> WCHAR * Name
05145     )
05146 {
05147     <span class="keyword">const</span> WCHAR * All;
05148     ULONG I, J;
05149 
05150     All = <a class="code" href="../../d6/d9/heappage_8c.html#a50">RtlpDphTargetDllsUnicode</a>.Buffer;
05151 
05152     <span class="keywordflow">for</span> (I = 0; All[I]; I += 1) {
05153 
05154         <span class="keywordflow">for</span> (J = 0; All[I+J] &amp;&amp; <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>[J]; J += 1) {
05155             <span class="keywordflow">if</span> (<a class="code" href="../../d6/d6/nls_8c.html#a33">RtlUpcaseUnicodeChar</a>(All[I+J]) != <a class="code" href="../../d6/d6/nls_8c.html#a33">RtlUpcaseUnicodeChar</a>(<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>[J])) {
05156                 <span class="keywordflow">break</span>;
05157             }
05158         }
05159 
05160         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>[J]) {
05161             <span class="keywordflow">continue</span>;
05162         }
05163         <span class="keywordflow">else</span> {
05164             <span class="comment">// we got to the end of string</span>
05165             <span class="keywordflow">return</span> &amp;(All[I]);
05166         }
05167     }
05168 
05169     <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05170 }
05171 
05175 
05176 PDPH_HEAP_BLOCK
<a name="l05177"></a><a class="code" href="../../d6/d9/heappage_8c.html#a147">05177</a> <a class="code" href="../../d6/d9/heappage_8c.html#a147">RtlpDphSearchBlockInList</a> (
05178     PDPH_HEAP_BLOCK List,
05179     PUCHAR Address
05180     )
05181 {
05182     PDPH_HEAP_BLOCK Current;
05183 
05184     <span class="keywordflow">for</span> (Current = <a class="code" href="../../d1/d0/cmchek_8c.html#a12">List</a>; Current; Current = Current-&gt;pNextAlloc) {
05185         <span class="keywordflow">if</span> (Current-&gt;pVirtualBlock == Address) {
05186             <span class="keywordflow">return</span> Current;
05187         }
05188     }
05189 
05190     <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05191 }
05192 
<a name="l05193"></a><a class="code" href="../../d6/d9/heappage_8c.html#a66">05193</a> PVOID <a class="code" href="../../d6/d9/heappage_8c.html#a66">RtlpDphLastValidationStack</a>;
<a name="l05194"></a><a class="code" href="../../d6/d9/heappage_8c.html#a67">05194</a> PVOID <a class="code" href="../../d6/d9/heappage_8c.html#a67">RtlpDphCurrentValidationStack</a>;
05195 
05196 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l05197"></a><a class="code" href="../../d6/d9/heappage_8c.html#a106">05197</a> <a class="code" href="../../d6/d9/heappage_8c.html#a106">RtlpDphInternalValidatePageHeap</a> (
05198     PDPH_HEAP_ROOT Heap,
05199     PUCHAR ExemptAddress,
05200     SIZE_T ExemptSize
05201     )
05202 {
05203     PDPH_HEAP_BLOCK Range;
05204     PDPH_HEAP_BLOCK Node;
05205     PUCHAR Address;
05206     BOOLEAN FoundLeak;
05207 
05208     <a class="code" href="../../d6/d9/heappage_8c.html#a66">RtlpDphLastValidationStack</a> = <a class="code" href="../../d6/d9/heappage_8c.html#a67">RtlpDphCurrentValidationStack</a>;
05209     <a class="code" href="../../d6/d9/heappage_8c.html#a67">RtlpDphCurrentValidationStack</a> = <a class="code" href="../../d6/d9/heappage_8c.html#a89">RtlpDphLogStackTrace</a> (0);
05210     FoundLeak = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
05211 
05212     <span class="keywordflow">for</span> (Range = Heap-&gt;pVirtualStorageListHead;
05213          Range != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05214          Range = Range-&gt;pNextAlloc) {
05215 
05216         Address = Range-&gt;pVirtualBlock;
05217 
05218         <span class="keywordflow">while</span> (Address &lt; Range-&gt;pVirtualBlock + Range-&gt;nVirtualBlockSize) {
05219 
05220             <span class="comment">//</span>
05221             <span class="comment">// Ignore DPH_HEAP_ROOT structures.</span>
05222             <span class="comment">//</span>
05223 
05224             <span class="keywordflow">if</span> ((Address &gt;= (PUCHAR)Heap - <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>) &amp;&amp; (Address &lt;  (PUCHAR)Heap + 5 * <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>)) {
05225                 Address += <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
05226                 <span class="keywordflow">continue</span>;
05227             }
05228             
05229             <span class="comment">//</span>
05230             <span class="comment">// Ignore exempt region (temporarily out of all structures).</span>
05231             <span class="comment">//</span>
05232 
05233             <span class="keywordflow">if</span> ((Address &gt;= ExemptAddress) &amp;&amp; (Address &lt; ExemptAddress + ExemptSize)) {
05234                 Address += <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
05235                 <span class="keywordflow">continue</span>;
05236             }
05237 
05238             Node = <a class="code" href="../../d6/d9/heappage_8c.html#a147">RtlpDphSearchBlockInList</a> (Heap-&gt;pBusyAllocationListHead, Address);
05239 
05240             <span class="keywordflow">if</span> (Node) {
05241                 Address += Node-&gt;nVirtualBlockSize;
05242                 <span class="keywordflow">continue</span>;
05243             }
05244             
05245             Node = <a class="code" href="../../d6/d9/heappage_8c.html#a147">RtlpDphSearchBlockInList</a> (Heap-&gt;pFreeAllocationListHead, Address);
05246 
05247             <span class="keywordflow">if</span> (Node) {
05248                 Address += Node-&gt;nVirtualBlockSize;
05249                 <span class="keywordflow">continue</span>;
05250             }
05251             
05252             Node = <a class="code" href="../../d6/d9/heappage_8c.html#a147">RtlpDphSearchBlockInList</a> (Heap-&gt;pAvailableAllocationListHead, Address);
05253 
05254             <span class="keywordflow">if</span> (Node) {
05255                 Address += Node-&gt;nVirtualBlockSize;
05256                 <span class="keywordflow">continue</span>;
05257             }
05258             
05259             Node = <a class="code" href="../../d6/d9/heappage_8c.html#a147">RtlpDphSearchBlockInList</a> (Heap-&gt;pNodePoolListHead, Address);
05260 
05261             <span class="keywordflow">if</span> (Node) {
05262                 Address += Node-&gt;nVirtualBlockSize;
05263                 <span class="keywordflow">continue</span>;
05264             }
05265 
05266             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a> (<span class="stringliteral">"Block @ %p has been leaked \n"</span>, Address);
05267             FoundLeak = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
05268 
05269             Address += <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
05270         }
05271     }
05272 
05273     <span class="keywordflow">if</span> (FoundLeak) {
05274 
05275         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a> (<span class="stringliteral">"Page heap: Last stack @ %p, Current stack @ %p \n"</span>, 
05276             <a class="code" href="../../d6/d9/heappage_8c.html#a66">RtlpDphLastValidationStack</a>,
05277             <a class="code" href="../../d6/d9/heappage_8c.html#a67">RtlpDphCurrentValidationStack</a>);
05278 
05279         DbgBreakPoint ();
05280     }
05281 }
05282 
05283 
05284 <span class="preprocessor">#endif // DEBUG_PAGE_HEAP</span>
05285 <span class="preprocessor"></span>
05286 <span class="comment">//</span>
05287 <span class="comment">// End of module</span>
05288 <span class="comment">//</span>
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:16 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
