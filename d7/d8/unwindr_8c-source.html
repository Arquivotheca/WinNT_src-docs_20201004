<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: unwindr.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>unwindr.c</h1><a href="../../d6/d9/unwindr_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1990  Microsoft Corporation</span>
00004 <span class="comment">Copyright (c) 1993  Digital Equipment Corporation</span>
00005 <span class="comment"></span>
00006 <span class="comment">Module Name:</span>
00007 <span class="comment"></span>
00008 <span class="comment">    unwindr.c</span>
00009 <span class="comment"></span>
00010 <span class="comment">Abstract:</span>
00011 <span class="comment"></span>
00012 <span class="comment">    This module implements two alternate versions of the unwind function</span>
00013 <span class="comment">    required by Alpha AXP during the GEM compiler transition period. The</span>
00014 <span class="comment">    code is adapted from RtlUnwind (exdsptch.c). These functions can be</span>
00015 <span class="comment">    deleted if GEM uses scope table based structured exception handling</span>
00016 <span class="comment">    and can materialize virtual frame pointers.</span>
00017 <span class="comment"></span>
00018 <span class="comment">Author:</span>
00019 <span class="comment"></span>
00020 <span class="comment">    Thomas Van Baak (tvb) 18-Nov-1992</span>
00021 <span class="comment"></span>
00022 <span class="comment">Environment:</span>
00023 <span class="comment"></span>
00024 <span class="comment">    Any mode.</span>
00025 <span class="comment"></span>
00026 <span class="comment">Revision History:</span>
00027 <span class="comment"></span>
00028 <span class="comment">--*/</span>
00029 
00030 <span class="preprocessor">#include "<a class="code" href="../../d5/d9/ntrtlp_8h.html">ntrtlp.h</a>"</span>
00031 
00032 <span class="comment">//</span>
00033 <span class="comment">// Define local macros.</span>
00034 <span class="comment">//</span>
00035 <span class="comment">// Raise noncontinuable exception with associated exception record.</span>
00036 <span class="comment">//</span>
00037 
<a name="l00038"></a><a class="code" href="../../d6/d9/unwindr_8c.html#a0">00038</a> <span class="preprocessor">#define RAISE_EXCEPTION(Status, ExceptionRecordt) { \</span>
00039 <span class="preprocessor">    EXCEPTION_RECORD ExceptionRecordn; \</span>
00040 <span class="preprocessor">                                            \</span>
00041 <span class="preprocessor">    ExceptionRecordn.ExceptionCode = Status; \</span>
00042 <span class="preprocessor">    ExceptionRecordn.ExceptionFlags = EXCEPTION_NONCONTINUABLE; \</span>
00043 <span class="preprocessor">    ExceptionRecordn.ExceptionRecord = ExceptionRecordt; \</span>
00044 <span class="preprocessor">    ExceptionRecordn.NumberParameters = 0; \</span>
00045 <span class="preprocessor">    RtlRaiseException(&amp;ExceptionRecordn); \</span>
00046 <span class="preprocessor">    }</span>
00047 <span class="preprocessor"></span>
00048 <span class="comment">//</span>
00049 <span class="comment">// Determine if ExceptionHandler is defined</span>
00050 <span class="comment">//</span>
00051 
<a name="l00052"></a><a class="code" href="../../d6/d9/unwindr_8c.html#a1">00052</a> <span class="preprocessor">#define IS_HANDLER_DEFINED(FunctionEntry) \</span>
00053 <span class="preprocessor">    (RF_EXCEPTION_HANDLER(FunctionEntry) != 0)</span>
00054 <span class="preprocessor"></span>
00055 <span class="preprocessor">#if DBG</span>
00056 <span class="preprocessor"></span>
00057 <span class="comment">//</span>
00058 <span class="comment">// Maintain a short history of PC's for malformed function table errors.</span>
00059 <span class="comment">//</span>
00060 
00061 <span class="preprocessor">#define PC_HISTORY_DEPTH 4</span>
00062 <span class="preprocessor"></span>
00063 <span class="comment">//</span>
00064 <span class="comment">// Definition of global flag to debug/validate exception handling.</span>
00065 <span class="comment">// See ntrtlalp.h for the bit definitions in this flag word.</span>
00066 <span class="comment">//</span>
00067 
00068 ULONG RtlDebugFlags;
00069 
00070 <span class="preprocessor">#endif</span>
00071 <span class="preprocessor"></span>
<a name="l00072"></a><a class="code" href="../../d6/d9/unwindr_8c.html#a2">00072</a> <span class="preprocessor">#define Virtual VirtualFramePointer</span>
<a name="l00073"></a><a class="code" href="../../d6/d9/unwindr_8c.html#a3">00073</a> <span class="preprocessor"></span><span class="preprocessor">#define Real RealFramePointer</span>
00074 <span class="preprocessor"></span>
00075 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00076"></a><a class="code" href="../../d6/d9/unwindr_8c.html#a4">00076</a> <a class="code" href="../../d6/d9/unwindr_8c.html#a4">RtlUnwindRfp</a> (
00077     IN PVOID TargetRealFrame OPTIONAL,
00078     IN PVOID TargetIp OPTIONAL,
00079     IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
00080     IN PVOID ReturnValue
00081     )
00082 
00083 <span class="comment">/*++</span>
00084 <span class="comment"></span>
00085 <span class="comment">Routine Description:</span>
00086 <span class="comment"></span>
00087 <span class="comment">    This function initiates an unwind of procedure call frames. The machine</span>
00088 <span class="comment">    state at the time of the call to unwind is captured in a context record</span>
00089 <span class="comment">    and the unwinding flag is set in the exception flags of the exception</span>
00090 <span class="comment">    record. If the TargetRealFrame parameter is not specified, then the exit</span>
00091 <span class="comment">    unwind flag is also set in the exception flags of the exception record.</span>
00092 <span class="comment">    A backward scan through the procedure call frames is then performed to</span>
00093 <span class="comment">    find the target of the unwind operation.</span>
00094 <span class="comment"></span>
00095 <span class="comment">    As each frame is encountered, the PC where control left the corresponding</span>
00096 <span class="comment">    function is determined and used to lookup exception handler information</span>
00097 <span class="comment">    in the runtime function table built by the linker. If the respective</span>
00098 <span class="comment">    routine has an exception handler, then the handler is called.</span>
00099 <span class="comment"></span>
00100 <span class="comment">    This function is identical to RtlUnwind except that the TargetRealFrame</span>
00101 <span class="comment">    parameter is the real frame pointer instead of the virtual frame pointer.</span>
00102 <span class="comment"></span>
00103 <span class="comment">Arguments:</span>
00104 <span class="comment"></span>
00105 <span class="comment">    TargetRealFrame - Supplies an optional pointer to the call frame that is</span>
00106 <span class="comment">        the target of the unwind. If this parameter is not specified, then an</span>
00107 <span class="comment">        exit unwind is performed.</span>
00108 <span class="comment"></span>
00109 <span class="comment">    TargetIp - Supplies an optional instruction address that specifies the</span>
00110 <span class="comment">        continuation address of the unwind. This address is ignored if the</span>
00111 <span class="comment">        target frame parameter is not specified.</span>
00112 <span class="comment"></span>
00113 <span class="comment">    ExceptionRecord - Supplies an optional pointer to an exception record.</span>
00114 <span class="comment"></span>
00115 <span class="comment">    ReturnValue - Supplies a value that is to be placed in the integer</span>
00116 <span class="comment">        function return register just before continuing execution.</span>
00117 <span class="comment"></span>
00118 <span class="comment">Return Value:</span>
00119 <span class="comment"></span>
00120 <span class="comment">    None.</span>
00121 <span class="comment"></span>
00122 <span class="comment">--*/</span>
00123 
00124 {
00125 
00126     CONTEXT ContextRecord1;
00127     CONTEXT ContextRecord2;
00128     ULONG_PTR ControlPc;
00129 <span class="preprocessor">#if DBG</span>
00130 <span class="preprocessor"></span>    ULONG_PTR ControlPcHistory[PC_HISTORY_DEPTH];
00131     ULONG ControlPcHistoryIndex = 0;
00132 <span class="preprocessor">#endif</span>
00133 <span class="preprocessor"></span>    <a class="code" href="../../d0/d6/struct__DISPATCHER__CONTEXT.html">DISPATCHER_CONTEXT</a> DispatcherContext;
00134     EXCEPTION_DISPOSITION Disposition;
00135     FRAME_POINTERS EstablisherFrame;
00136     ULONG ExceptionFlags;
00137     EXCEPTION_RECORD ExceptionRecord1;
00138 <span class="preprocessor">#if DBG</span>
00139 <span class="preprocessor"></span>    LONG FrameDepth = 0;
00140 <span class="preprocessor">#endif</span>
00141 <span class="preprocessor"></span>    PRUNTIME_FUNCTION FunctionEntry;
00142     ULONG_PTR HighLimit;
00143     BOOLEAN InFunction;
00144     ULONG_PTR LastPc;
00145     ULONG_PTR LowLimit;
00146 
00147 <span class="preprocessor">#if DBG</span>
00148 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_UNWIND) {
00149         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\nRtlUnwindRfp(TargetRealFrame = %p, TargetIp = %p,, ReturnValue = %lx)\n"</span>,
00150                  TargetRealFrame, TargetIp, ReturnValue);
00151     }
00152 <span class="preprocessor">#endif</span>
00153 <span class="preprocessor"></span>
00154     <span class="comment">//</span>
00155     <span class="comment">// Get current stack limits, capture the current context, virtually</span>
00156     <span class="comment">// unwind to the caller of this routine, get the initial PC value, and</span>
00157     <span class="comment">// set the unwind target address.</span>
00158     <span class="comment">//</span>
00159 
00160     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a30">RtlpGetStackLimits</a>(&amp;LowLimit, &amp;HighLimit);
00161     RtlCaptureContext(&amp;ContextRecord1);
00162     ControlPc = (ULONG_PTR)ContextRecord1.IntRa;
00163     FunctionEntry = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>(ControlPc);
00164     LastPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc,
00165                               FunctionEntry,
00166                               &amp;ContextRecord1,
00167                               &amp;InFunction,
00168                               &amp;EstablisherFrame,
00169                               <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00170 
00171     ControlPc = LastPc;
00172     ContextRecord1.Fir = (ULONGLONG)(LONG_PTR)TargetIp;
00173 
00174     <span class="comment">//</span>
00175     <span class="comment">// If an exception record is not specified, then build a local exception</span>
00176     <span class="comment">// record for use in calling exception handlers during the unwind operation.</span>
00177     <span class="comment">//</span>
00178 
00179     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(ExceptionRecord) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00180         ExceptionRecord = &amp;ExceptionRecord1;
00181         ExceptionRecord1.ExceptionCode = STATUS_UNWIND;
00182         ExceptionRecord1.ExceptionRecord = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00183         ExceptionRecord1.ExceptionAddress = (PVOID)ControlPc;
00184         ExceptionRecord1.NumberParameters = 0;
00185     }
00186 
00187     <span class="comment">//</span>
00188     <span class="comment">// If the target frame of the unwind is specified, then a normal unwind</span>
00189     <span class="comment">// is being performed. Otherwise, an exit unwind is being performed.</span>
00190     <span class="comment">//</span>
00191 
00192     ExceptionFlags = <a class="code" href="../../d6/d7/halmips_8h.html#a26">EXCEPTION_UNWINDING</a>;
00193     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(TargetRealFrame) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00194         ExceptionRecord-&gt;ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a27">EXCEPTION_EXIT_UNWIND</a>;
00195     }
00196 
00197     <span class="comment">//</span>
00198     <span class="comment">// Scan backward through the call frame hierarchy and call exception</span>
00199     <span class="comment">// handlers until the target frame of the unwind is reached.</span>
00200     <span class="comment">//</span>
00201 
00202     <span class="keywordflow">do</span> {
00203 
00204 <span class="preprocessor">#if DBG</span>
00205 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_UNWIND_DETAIL) {
00206         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlUnwindRfp: Loop: FrameDepth = %d, Rfp = %p, sp = %p, ControlPc = %p\n"</span>,
00207                  FrameDepth, EstablisherFrame.Real, (ULONG_PTR)ContextRecord1.IntSp, ControlPc);
00208         FrameDepth -= 1;
00209     }
00210 <span class="preprocessor">#endif</span>
00211 <span class="preprocessor"></span>
00212         <span class="comment">//</span>
00213         <span class="comment">// Lookup the function table entry using the point at which control</span>
00214         <span class="comment">// left the procedure.</span>
00215         <span class="comment">//</span>
00216 
00217         FunctionEntry = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>(ControlPc);
00218 
00219         <span class="comment">//</span>
00220         <span class="comment">// If there is a function table entry for the routine, then copy the</span>
00221         <span class="comment">// context record, virtually unwind to the caller of the current</span>
00222         <span class="comment">// routine to obtain the real frame pointer of the establisher and</span>
00223         <span class="comment">// check if there is an exception handler for the frame.</span>
00224         <span class="comment">//</span>
00225 
00226         <span class="keywordflow">if</span> (FunctionEntry != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00227             RtlMoveMemory(&amp;ContextRecord2, &amp;ContextRecord1, <span class="keyword">sizeof</span>(CONTEXT));
00228             LastPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc,
00229                                       FunctionEntry,
00230                                       &amp;ContextRecord1,
00231                                       &amp;InFunction,
00232                                       &amp;EstablisherFrame,
00233                                       <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00234 
00235             <span class="comment">//</span>
00236             <span class="comment">// If the real and virtual frame pointers are not within the</span>
00237             <span class="comment">// specified stack limits, the frame pointers are unaligned, or</span>
00238             <span class="comment">// the target frame is below the real frame and an exit unwind is</span>
00239             <span class="comment">// not being performed, then raise the exception STATUS_BAD_STACK.</span>
00240             <span class="comment">// Otherwise, check to determine if the current routine has an</span>
00241             <span class="comment">// exception handler.</span>
00242             <span class="comment">//</span>
00243 
00244             <span class="keywordflow">if</span> ((EstablisherFrame.Real &lt; LowLimit) ||
00245                 (EstablisherFrame.Virtual &gt; HighLimit) ||
00246                 (EstablisherFrame.Real &gt; EstablisherFrame.Virtual) ||
00247                 ((ARGUMENT_PRESENT(TargetRealFrame) != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
00248                  ((ULONG_PTR)TargetRealFrame &lt; EstablisherFrame.Real)) ||
00249                 ((EstablisherFrame.Virtual &amp; 0xF) != 0) ||
00250                 ((EstablisherFrame.Real &amp; 0xF) != 0)) {
00251 
00252 <span class="preprocessor">#if DBG</span>
00253 <span class="preprocessor"></span>                <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\n****** Warning - bad stack or target frame (unwind).\n"</span>);
00254                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  EstablisherFrame Virtual = %p, Real = %p\n"</span>,
00255                          EstablisherFrame.Virtual, EstablisherFrame.Real);
00256                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  TargetRealFrame = %p\n"</span>, TargetRealFrame);
00257                 <span class="keywordflow">if</span> ((ARGUMENT_PRESENT(TargetRealFrame) != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
00258                     ((ULONG_PTR)TargetRealFrame &lt; EstablisherFrame.Real)) {
00259                     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  TargetRealFrame is below EstablisherFrame.Real!\n"</span>);
00260                 }
00261                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  Previous EstablisherFrame (sp) = %p\n"</span>,
00262                          (ULONG_PTR)ContextRecord2.IntSp);
00263                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  LowLimit = %p, HighLimit = %p\n"</span>,
00264                          LowLimit, HighLimit);
00265                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  LastPc = %p, ControlPc = %p\n"</span>,
00266                          LastPc, ControlPc);
00267                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  Now raising STATUS_BAD_STACK exception.\n"</span>);
00268 <span class="preprocessor">#endif</span>
00269 <span class="preprocessor"></span>
00270                 <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a0">RAISE_EXCEPTION</a>(STATUS_BAD_STACK, ExceptionRecord);
00271 
00272             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a1">IS_HANDLER_DEFINED</a>(FunctionEntry) &amp;&amp; InFunction) {
00273 
00274 <span class="preprocessor">#if DBG</span>
00275 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_DISPATCH_EXCEPTION_DETAIL) {
00276     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlUnwindRfp: ExceptionHandler = %p, HandlerData = %p\n"</span>,
00277              FunctionEntry-&gt;ExceptionHandler, FunctionEntry-&gt;HandlerData);
00278 }
00279 <span class="preprocessor">#endif</span>
00280 <span class="preprocessor"></span>
00281                 <span class="comment">//</span>
00282                 <span class="comment">// The frame has an exception handler.</span>
00283                 <span class="comment">//</span>
00284                 <span class="comment">// The control PC, establisher frame pointer, the address</span>
00285                 <span class="comment">// of the function table entry, and the address of the</span>
00286                 <span class="comment">// context record are all stored in the dispatcher context.</span>
00287                 <span class="comment">// This information is used by the unwind linkage routine</span>
00288                 <span class="comment">// and can be used by the exception handler itself.</span>
00289                 <span class="comment">//</span>
00290                 <span class="comment">// A linkage routine written in assembler is used to actually</span>
00291                 <span class="comment">// call the actual exception handler. This is required by the</span>
00292                 <span class="comment">// exception handler that is associated with the linkage</span>
00293                 <span class="comment">// routine so it can have access to two sets of dispatcher</span>
00294                 <span class="comment">// context when it is called.</span>
00295                 <span class="comment">//</span>
00296 
00297                 DispatcherContext.ControlPc = ControlPc;
00298                 DispatcherContext.FunctionEntry = FunctionEntry;
00299                 DispatcherContext.EstablisherFrame = EstablisherFrame.Virtual;
00300                 DispatcherContext.ContextRecord = &amp;ContextRecord2;
00301 
00302                 <span class="comment">//</span>
00303                 <span class="comment">// Call the exception handler.</span>
00304                 <span class="comment">//</span>
00305 
00306                 <span class="keywordflow">do</span> {
00307 
00308                     <span class="comment">//</span>
00309                     <span class="comment">// If the establisher frame is the target of the unwind</span>
00310                     <span class="comment">// operation, then set the target unwind flag.</span>
00311                     <span class="comment">//</span>
00312 
00313                     <span class="keywordflow">if</span> ((ULONG_PTR)TargetRealFrame == EstablisherFrame.Real) {
00314                         ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a30">EXCEPTION_TARGET_UNWIND</a>;
00315                     }
00316 
00317                     ExceptionRecord-&gt;ExceptionFlags = ExceptionFlags;
00318 
00319                     <span class="comment">//</span>
00320                     <span class="comment">// Set the specified return value in case the exception</span>
00321                     <span class="comment">// handler directly continues execution.</span>
00322                     <span class="comment">//</span>
00323 
00324                     ContextRecord2.IntV0 = (ULONGLONG)(LONG_PTR)ReturnValue;
00325 
00326 <span class="preprocessor">#if DBG</span>
00327 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_UNWIND_DETAIL) {
00328         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlUnwindRfp: calling RtlpExecuteHandlerForUnwind, ControlPc = %p\n"</span>, ControlPc);
00329     }
00330 <span class="preprocessor">#endif</span>
00331 <span class="preprocessor"></span>
00332                     Disposition =
00333                         <a class="code" href="../../d6/d9/ntrtlppc_8h.html#a1">RtlpExecuteHandlerForUnwind</a>(ExceptionRecord,
00334                                                     EstablisherFrame.Virtual,
00335                                                     &amp;ContextRecord2,
00336                                                     &amp;DispatcherContext,
00337                                                     RF_EXCEPTION_HANDLER(FunctionEntry));
00338 
00339 <span class="preprocessor">#if DBG</span>
00340 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_UNWIND_DETAIL) {
00341         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlUnwindRfp: RtlpExecuteHandlerForUnwind returned Disposition = %lx\n"</span>, Disposition);
00342     }
00343 <span class="preprocessor">#endif</span>
00344 <span class="preprocessor"></span>
00345                     <span class="comment">//</span>
00346                     <span class="comment">// Clear target unwind and collided unwind flags.</span>
00347                     <span class="comment">//</span>
00348 
00349                     ExceptionFlags &amp;= ~(<a class="code" href="../../d6/d7/halmips_8h.html#a31">EXCEPTION_COLLIDED_UNWIND</a> |
00350                                         <a class="code" href="../../d6/d7/halmips_8h.html#a30">EXCEPTION_TARGET_UNWIND</a>);
00351 
00352                     <span class="comment">//</span>
00353                     <span class="comment">// Case on the handler disposition.</span>
00354                     <span class="comment">//</span>
00355 
00356                     <span class="keywordflow">switch</span> (Disposition) {
00357 
00358                         <span class="comment">//</span>
00359                         <span class="comment">// The disposition is to continue the search.</span>
00360                         <span class="comment">//</span>
00361                         <span class="comment">// Continue the search for a handler or continue</span>
00362                         <span class="comment">// execution.</span>
00363                         <span class="comment">//</span>
00364 
00365                     <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a37">ExceptionContinueSearch</a> :
00366                         <span class="keywordflow">break</span>;
00367 
00368                         <span class="comment">//</span>
00369                         <span class="comment">// The disposition is collided unwind.</span>
00370                         <span class="comment">//</span>
00371                         <span class="comment">// Set the target of the current unwind to the context</span>
00372                         <span class="comment">// record of the previous unwind, virtually unwind to</span>
00373                         <span class="comment">// the caller of the old routine, and reexecute the</span>
00374                         <span class="comment">// exception handler from the collided frame with the</span>
00375                         <span class="comment">// collided unwind flag set in the exception record.</span>
00376                         <span class="comment">//</span>
00377 
00378                     <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a39">ExceptionCollidedUnwind</a> :
00379                         ControlPc = DispatcherContext.ControlPc;
00380                         FunctionEntry = DispatcherContext.FunctionEntry;
00381                         RtlMoveMemory(&amp;ContextRecord1,
00382                                       DispatcherContext.ContextRecord,
00383                                       <span class="keyword">sizeof</span>(CONTEXT));
00384 
00385                         ContextRecord1.Fir = (ULONGLONG)(LONG_PTR)TargetIp;
00386                         RtlMoveMemory(&amp;ContextRecord2,
00387                                       &amp;ContextRecord1,
00388                                       <span class="keyword">sizeof</span>(CONTEXT));
00389 
00390                         ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a31">EXCEPTION_COLLIDED_UNWIND</a>;
00391                         LastPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc,
00392                                                   FunctionEntry,
00393                                                   &amp;ContextRecord1,
00394                                                   &amp;InFunction,
00395                                                   &amp;EstablisherFrame,
00396                                                   <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00397                         <span class="keywordflow">break</span>;
00398 
00399                         <span class="comment">//</span>
00400                         <span class="comment">// All other disposition values are invalid.</span>
00401                         <span class="comment">//</span>
00402                         <span class="comment">// Raise invalid disposition exception.</span>
00403                         <span class="comment">//</span>
00404 
00405                     <span class="keywordflow">default</span> :
00406                         <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a0">RAISE_EXCEPTION</a>(STATUS_INVALID_DISPOSITION, ExceptionRecord);
00407                     }
00408 
00409                 } <span class="keywordflow">while</span> ((ExceptionFlags &amp; <a class="code" href="../../d6/d7/halmips_8h.html#a31">EXCEPTION_COLLIDED_UNWIND</a>) != 0);
00410             }
00411 
00412         } <span class="keywordflow">else</span> {
00413 
00414             <span class="comment">//</span>
00415             <span class="comment">// Set point at which control left the previous routine.</span>
00416             <span class="comment">//</span>
00417 
00418             LastPc = (ULONG_PTR)ContextRecord1.IntRa - 4;
00419 
00420             <span class="comment">//</span>
00421             <span class="comment">// If the next control PC is the same as the old control PC, then</span>
00422             <span class="comment">// the function table is not correctly formed.</span>
00423             <span class="comment">//</span>
00424 
00425             <span class="keywordflow">if</span> (LastPc == ControlPc) {
00426 
00427 <span class="preprocessor">#if DBG</span>
00428 <span class="preprocessor"></span>                ULONG <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>;
00429                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\n****** Warning - malformed function table (unwind).\n"</span>);
00430                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"ControlPc = %p, %p"</span>, LastPc, ControlPc);
00431                 <span class="keywordflow">for</span> (<a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> = 0; <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> &lt; PC_HISTORY_DEPTH; <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> += 1) {
00432                     <span class="keywordflow">if</span> (ControlPcHistoryIndex &gt; 0) {
00433                         ControlPcHistoryIndex -= 1;
00434                         ControlPc = ControlPcHistory[ControlPcHistoryIndex % PC_HISTORY_DEPTH];
00435                         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">", %p"</span>, ControlPc);
00436                     }
00437                 }
00438                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(ControlPcHistoryIndex == 0 ? <span class="stringliteral">".\n"</span> : <span class="stringliteral">", ...\n"</span>);
00439                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  Now raising STATUS_BAD_FUNCTION_TABLE exception.\n"</span>);
00440 <span class="preprocessor">#endif</span>
00441 <span class="preprocessor"></span>
00442                 <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a10">RtlRaiseStatus</a>(STATUS_BAD_FUNCTION_TABLE);
00443             }
00444         }
00445 
00446         <span class="comment">//</span>
00447         <span class="comment">// Set point at which control left the previous routine.</span>
00448         <span class="comment">//</span>
00449 
00450 <span class="preprocessor">#if DBG</span>
00451 <span class="preprocessor"></span>        ControlPcHistory[ControlPcHistoryIndex % PC_HISTORY_DEPTH] = ControlPc;
00452         ControlPcHistoryIndex += 1;
00453 <span class="preprocessor">#endif</span>
00454 <span class="preprocessor"></span>
00455         ControlPc = LastPc;
00456 
00457     } <span class="keywordflow">while</span> ((EstablisherFrame.Real &lt; HighLimit) &amp;&amp;
00458              (EstablisherFrame.Real != (ULONG_PTR)TargetRealFrame));
00459 
00460     <span class="comment">//</span>
00461     <span class="comment">// If the establisher stack pointer is equal to the target frame</span>
00462     <span class="comment">// pointer, then continue execution. Otherwise, an exit unwind was</span>
00463     <span class="comment">// performed or the target of the unwind did not exist and the</span>
00464     <span class="comment">// debugger and subsystem are given a second chance to handle the</span>
00465     <span class="comment">// unwind.</span>
00466     <span class="comment">//</span>
00467 
00468     <span class="keywordflow">if</span> (EstablisherFrame.Real == (ULONG_PTR)TargetRealFrame) {
00469         ContextRecord2.IntV0 = (ULONGLONG)(LONG_PTR)ReturnValue;
00470 
00471 <span class="preprocessor">#if DBG</span>
00472 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_UNWIND) {
00473         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlUnwindRfp: finished unwinding, and calling RtlpRestoreContext\n"</span>);
00474     }
00475 <span class="preprocessor">#endif</span>
00476 <span class="preprocessor"></span>
00477         <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a3">RtlpRestoreContext</a>(&amp;ContextRecord2);
00478 
00479     } <span class="keywordflow">else</span> {
00480 
00481 <span class="preprocessor">#if DBG</span>
00482 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_UNWIND) {
00483         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlUnwindRfp: finished unwinding, but calling ZwRaiseException\n"</span>);
00484     }
00485 <span class="preprocessor">#endif</span>
00486 <span class="preprocessor"></span>
00487         ZwRaiseException(ExceptionRecord, &amp;ContextRecord1, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00488     }
00489 }
00490 
00491 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00492"></a><a class="code" href="../../d6/d9/unwindr_8c.html#a5">00492</a> <a class="code" href="../../d6/d9/unwindr_8c.html#a5">RtlUnwindReturn</a> (
00493     IN PVOID TargetFrame,
00494     IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
00495     IN PVOID ReturnValue
00496     )
00497 
00498 <span class="comment">/*++</span>
00499 <span class="comment"></span>
00500 <span class="comment">Routine Description:</span>
00501 <span class="comment"></span>
00502 <span class="comment">    This function initiates an unwind of procedure call frames. The machine</span>
00503 <span class="comment">    state at the time of the call to unwind is captured in a context record</span>
00504 <span class="comment">    and the unwinding flag is set in the exception flags of the exception</span>
00505 <span class="comment">    record. A backward scan through the procedure call frames is then</span>
00506 <span class="comment">    performed to find the target of the unwind operation. When the target</span>
00507 <span class="comment">    frame is reached, a return is made to the caller of the target frame</span>
00508 <span class="comment">    with the return value specified by the return value parameter.</span>
00509 <span class="comment"></span>
00510 <span class="comment">    As each frame is encountered, the PC where control left the corresponding</span>
00511 <span class="comment">    function is determined and used to lookup exception handler information</span>
00512 <span class="comment">    in the runtime function table built by the linker. If the respective</span>
00513 <span class="comment">    routine has an exception handler, then the handler is called.</span>
00514 <span class="comment"></span>
00515 <span class="comment">    This function is identical to RtlUnwind except control resumes in the</span>
00516 <span class="comment">    caller of the target frame, not in the target frame itself.</span>
00517 <span class="comment"></span>
00518 <span class="comment">Arguments:</span>
00519 <span class="comment"></span>
00520 <span class="comment">    TargetFrame - Supplies an optional pointer to the call frame that is the</span>
00521 <span class="comment">        target of the unwind.</span>
00522 <span class="comment"></span>
00523 <span class="comment">    ExceptionRecord - Supplies an optional pointer to an exception record.</span>
00524 <span class="comment"></span>
00525 <span class="comment">    ReturnValue - Supplies a value that is to be placed in the integer</span>
00526 <span class="comment">        function return register just before continuing execution.</span>
00527 <span class="comment"></span>
00528 <span class="comment">Return Value:</span>
00529 <span class="comment"></span>
00530 <span class="comment">    None.</span>
00531 <span class="comment"></span>
00532 <span class="comment">--*/</span>
00533 
00534 {
00535 
00536     CONTEXT ContextRecord1;
00537     CONTEXT ContextRecord2;
00538     ULONG_PTR ControlPc;
00539 <span class="preprocessor">#if DBG</span>
00540 <span class="preprocessor"></span>    ULONG_PTR ControlPcHistory[PC_HISTORY_DEPTH];
00541     ULONG ControlPcHistoryIndex = 0;
00542 <span class="preprocessor">#endif</span>
00543 <span class="preprocessor"></span>    <a class="code" href="../../d0/d6/struct__DISPATCHER__CONTEXT.html">DISPATCHER_CONTEXT</a> DispatcherContext;
00544     EXCEPTION_DISPOSITION Disposition;
00545     FRAME_POINTERS EstablisherFrame;
00546     ULONG ExceptionFlags;
00547     EXCEPTION_RECORD ExceptionRecord1;
00548 <span class="preprocessor">#if DBG</span>
00549 <span class="preprocessor"></span>    LONG FrameDepth = 0;
00550 <span class="preprocessor">#endif</span>
00551 <span class="preprocessor"></span>    PRUNTIME_FUNCTION FunctionEntry;
00552     ULONG_PTR HighLimit;
00553     BOOLEAN InFunction;
00554     ULONG_PTR LastPc;
00555     ULONG_PTR LowLimit;
00556 
00557 <span class="preprocessor">#if DBG</span>
00558 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_UNWIND) {
00559         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\nRtlUnwindReturn(TargetFrame = %p,, ReturnValue = %lx)\n"</span>,
00560                  TargetFrame, ReturnValue);
00561     }
00562 <span class="preprocessor">#endif</span>
00563 <span class="preprocessor"></span>
00564     <span class="comment">//</span>
00565     <span class="comment">// Get current stack limits, capture the current context, virtually</span>
00566     <span class="comment">// unwind to the caller of this routine, get the initial PC value, and</span>
00567     <span class="comment">// set the unwind target address.</span>
00568     <span class="comment">//</span>
00569 
00570     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a30">RtlpGetStackLimits</a>(&amp;LowLimit, &amp;HighLimit);
00571     RtlCaptureContext(&amp;ContextRecord1);
00572     ControlPc = (ULONG_PTR)ContextRecord1.IntRa;
00573     FunctionEntry = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>(ControlPc);
00574     LastPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc,
00575                               FunctionEntry,
00576                               &amp;ContextRecord1,
00577                               &amp;InFunction,
00578                               &amp;EstablisherFrame,
00579                               <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00580 
00581     ControlPc = LastPc;
00582     ContextRecord1.Fir = 0;
00583 
00584     <span class="comment">//</span>
00585     <span class="comment">// If an exception record is not specified, then build a local exception</span>
00586     <span class="comment">// record for use in calling exception handlers during the unwind operation.</span>
00587     <span class="comment">//</span>
00588 
00589     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(ExceptionRecord) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00590         ExceptionRecord = &amp;ExceptionRecord1;
00591         ExceptionRecord1.ExceptionCode = STATUS_UNWIND;
00592         ExceptionRecord1.ExceptionRecord = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00593         ExceptionRecord1.ExceptionAddress = (PVOID)ControlPc;
00594         ExceptionRecord1.NumberParameters = 0;
00595     }
00596 
00597     <span class="comment">//</span>
00598     <span class="comment">// A target frame of the unwind is specified so a normal unwind is</span>
00599     <span class="comment">// being performed.</span>
00600     <span class="comment">//</span>
00601 
00602     ExceptionFlags = <a class="code" href="../../d6/d7/halmips_8h.html#a26">EXCEPTION_UNWINDING</a>;
00603 
00604     <span class="comment">//</span>
00605     <span class="comment">// Scan backward through the call frame hierarchy and call exception</span>
00606     <span class="comment">// handlers until the target frame of the unwind is reached.</span>
00607     <span class="comment">//</span>
00608 
00609     <span class="keywordflow">do</span> {
00610 
00611 <span class="preprocessor">#if DBG</span>
00612 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_UNWIND_DETAIL) {
00613         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlUnwindReturn: Loop: FrameDepth = %d, sp = %p, ControlPc = %p\n"</span>,
00614                  FrameDepth, (ULONG_PTR)ContextRecord1.IntSp, ControlPc);
00615         FrameDepth -= 1;
00616     }
00617 <span class="preprocessor">#endif</span>
00618 <span class="preprocessor"></span>
00619         <span class="comment">//</span>
00620         <span class="comment">// Lookup the function table entry using the point at which control</span>
00621         <span class="comment">// left the procedure.</span>
00622         <span class="comment">//</span>
00623 
00624         FunctionEntry = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>(ControlPc);
00625 
00626         <span class="comment">//</span>
00627         <span class="comment">// If there is a function table entry for the routine, then copy the</span>
00628         <span class="comment">// context record, virtually unwind to the caller of the current</span>
00629         <span class="comment">// routine to obtain the virtual frame pointer of the establisher and</span>
00630         <span class="comment">// check if there is an exception handler for the frame.</span>
00631         <span class="comment">//</span>
00632 
00633         <span class="keywordflow">if</span> (FunctionEntry != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00634             RtlMoveMemory(&amp;ContextRecord2, &amp;ContextRecord1, <span class="keyword">sizeof</span>(CONTEXT));
00635             LastPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc,
00636                                       FunctionEntry,
00637                                       &amp;ContextRecord1,
00638                                       &amp;InFunction,
00639                                       &amp;EstablisherFrame,
00640                                       <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00641 
00642             <span class="comment">//</span>
00643             <span class="comment">// If the virtual frame pointer is not within the specified stack</span>
00644             <span class="comment">// limits, the virtual frame pointer is unaligned, or the target</span>
00645             <span class="comment">// frame is below the virtual frame and an exit unwind is not being</span>
00646             <span class="comment">// performed, then raise the exception STATUS_BAD_STACK. Otherwise,</span>
00647             <span class="comment">// check to determine if the current routine has an exception</span>
00648             <span class="comment">// handler.</span>
00649             <span class="comment">//</span>
00650 
00651             <span class="keywordflow">if</span> ((EstablisherFrame.Virtual &lt; LowLimit) ||
00652                 (EstablisherFrame.Virtual &gt; HighLimit) ||
00653                 ((ULONG_PTR)TargetFrame &lt; EstablisherFrame.Virtual) ||
00654                 ((EstablisherFrame.Virtual &amp; 0xF) != 0)) {
00655 
00656 <span class="preprocessor">#if DBG</span>
00657 <span class="preprocessor"></span>                <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\n****** Warning - bad stack or target frame (unwind).\n"</span>);
00658                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  EstablisherFrame Virtual = %p, Real = %p\n"</span>,
00659                          EstablisherFrame.Virtual, EstablisherFrame.Real);
00660                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  TargetFrame = %p\n"</span>, TargetFrame);
00661                 <span class="keywordflow">if</span> ((ARGUMENT_PRESENT(TargetFrame) != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
00662                     ((ULONG_PTR)TargetFrame &lt; EstablisherFrame.Virtual)) {
00663                     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  TargetFrame is below EstablisherFrame!\n"</span>);
00664                 }
00665                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  Previous EstablisherFrame (sp) = %p\n"</span>,
00666                          (ULONG_PTR)ContextRecord2.IntSp);
00667                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  LowLimit = %p, HighLimit = %p\n"</span>,
00668                          LowLimit, HighLimit);
00669                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  LastPc = %p, ControlPc = %p\n"</span>,
00670                          LastPc, ControlPc);
00671                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  Now raising STATUS_BAD_STACK exception.\n"</span>);
00672 <span class="preprocessor">#endif</span>
00673 <span class="preprocessor"></span>
00674                 <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a0">RAISE_EXCEPTION</a>(STATUS_BAD_STACK, ExceptionRecord);
00675 
00676             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a1">IS_HANDLER_DEFINED</a>(FunctionEntry) &amp;&amp; InFunction) {
00677 
00678 <span class="preprocessor">#if DBG</span>
00679 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_DISPATCH_EXCEPTION_DETAIL) {
00680     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlUnwindReturn: ExceptionHandler = %p, HandlerData = %p\n"</span>,
00681              FunctionEntry-&gt;ExceptionHandler, FunctionEntry-&gt;HandlerData);
00682 }
00683 <span class="preprocessor">#endif</span>
00684 <span class="preprocessor"></span>
00685                 <span class="comment">//</span>
00686                 <span class="comment">// The frame has an exception handler.</span>
00687                 <span class="comment">//</span>
00688                 <span class="comment">// The control PC, establisher frame pointer, the address</span>
00689                 <span class="comment">// of the function table entry, and the address of the</span>
00690                 <span class="comment">// context record are all stored in the dispatcher context.</span>
00691                 <span class="comment">// This information is used by the unwind linkage routine</span>
00692                 <span class="comment">// and can be used by the exception handler itself.</span>
00693                 <span class="comment">//</span>
00694                 <span class="comment">// A linkage routine written in assembler is used to actually</span>
00695                 <span class="comment">// call the actual exception handler. This is required by the</span>
00696                 <span class="comment">// exception handler that is associated with the linkage</span>
00697                 <span class="comment">// routine so it can have access to two sets of dispatcher</span>
00698                 <span class="comment">// context when it is called.</span>
00699                 <span class="comment">//</span>
00700 
00701                 DispatcherContext.ControlPc = ControlPc;
00702                 DispatcherContext.FunctionEntry = FunctionEntry;
00703                 DispatcherContext.EstablisherFrame = EstablisherFrame.Virtual;
00704                 DispatcherContext.ContextRecord = &amp;ContextRecord2;
00705 
00706                 <span class="comment">//</span>
00707                 <span class="comment">// Call the exception handler.</span>
00708                 <span class="comment">//</span>
00709 
00710                 <span class="keywordflow">do</span> {
00711 
00712                     <span class="comment">//</span>
00713                     <span class="comment">// If the establisher frame is the target of the unwind</span>
00714                     <span class="comment">// operation, then set the target unwind flag.</span>
00715                     <span class="comment">//</span>
00716 
00717                     <span class="keywordflow">if</span> ((ULONG_PTR)TargetFrame == EstablisherFrame.Virtual) {
00718                         ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a30">EXCEPTION_TARGET_UNWIND</a>;
00719                     }
00720 
00721                     ExceptionRecord-&gt;ExceptionFlags = ExceptionFlags;
00722 
00723                     <span class="comment">//</span>
00724                     <span class="comment">// Set the specified return value in case the exception</span>
00725                     <span class="comment">// handler directly continues execution.</span>
00726                     <span class="comment">//</span>
00727 
00728                     ContextRecord2.IntV0 = (ULONGLONG)(LONG_PTR)ReturnValue;
00729 
00730 <span class="preprocessor">#if DBG</span>
00731 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_UNWIND_DETAIL) {
00732         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlUnwindReturn: calling RtlpExecuteHandlerForUnwind, ControlPc = %p\n"</span>, ControlPc);
00733     }
00734 <span class="preprocessor">#endif</span>
00735 <span class="preprocessor"></span>
00736                     Disposition =
00737                         <a class="code" href="../../d6/d9/ntrtlppc_8h.html#a1">RtlpExecuteHandlerForUnwind</a>(ExceptionRecord,
00738                                                     EstablisherFrame.Virtual,
00739                                                     &amp;ContextRecord2,
00740                                                     &amp;DispatcherContext,
00741                                                     RF_EXCEPTION_HANDLER(FunctionEntry));
00742 
00743 <span class="preprocessor">#if DBG</span>
00744 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_UNWIND_DETAIL) {
00745         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlUnwindReturn: RtlpExecuteHandlerForUnwind returned Disposition = %lx\n"</span>, Disposition);
00746     }
00747 <span class="preprocessor">#endif</span>
00748 <span class="preprocessor"></span>
00749                     <span class="comment">//</span>
00750                     <span class="comment">// Clear target unwind and collided unwind flags.</span>
00751                     <span class="comment">//</span>
00752 
00753                     ExceptionFlags &amp;= ~(<a class="code" href="../../d6/d7/halmips_8h.html#a31">EXCEPTION_COLLIDED_UNWIND</a> |
00754                                         <a class="code" href="../../d6/d7/halmips_8h.html#a30">EXCEPTION_TARGET_UNWIND</a>);
00755 
00756                     <span class="comment">//</span>
00757                     <span class="comment">// Case on the handler disposition.</span>
00758                     <span class="comment">//</span>
00759 
00760                     <span class="keywordflow">switch</span> (Disposition) {
00761 
00762                         <span class="comment">//</span>
00763                         <span class="comment">// The disposition is to continue the search.</span>
00764                         <span class="comment">//</span>
00765                         <span class="comment">// Continue the search for a handler or continue</span>
00766                         <span class="comment">// execution.</span>
00767                         <span class="comment">//</span>
00768 
00769                     <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a37">ExceptionContinueSearch</a> :
00770                         <span class="keywordflow">break</span>;
00771 
00772                         <span class="comment">//</span>
00773                         <span class="comment">// The disposition is collided unwind.</span>
00774                         <span class="comment">//</span>
00775                         <span class="comment">// Set the target of the current unwind to the context</span>
00776                         <span class="comment">// record of the previous unwind, virtually unwind to</span>
00777                         <span class="comment">// the caller of the old routine, and reexecute the</span>
00778                         <span class="comment">// exception handler from the collided frame with the</span>
00779                         <span class="comment">// collided unwind flag set in the exception record.</span>
00780                         <span class="comment">//</span>
00781 
00782                     <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a39">ExceptionCollidedUnwind</a> :
00783                         ControlPc = DispatcherContext.ControlPc;
00784                         FunctionEntry = DispatcherContext.FunctionEntry;
00785                         RtlMoveMemory(&amp;ContextRecord1,
00786                                       DispatcherContext.ContextRecord,
00787                                       <span class="keyword">sizeof</span>(CONTEXT));
00788 
00789                         ContextRecord1.Fir = 0;
00790                         RtlMoveMemory(&amp;ContextRecord2,
00791                                       &amp;ContextRecord1,
00792                                       <span class="keyword">sizeof</span>(CONTEXT));
00793 
00794                         ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a31">EXCEPTION_COLLIDED_UNWIND</a>;
00795                         LastPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc,
00796                                                   FunctionEntry,
00797                                                   &amp;ContextRecord1,
00798                                                   &amp;InFunction,
00799                                                   &amp;EstablisherFrame,
00800                                                   <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00801                         <span class="keywordflow">break</span>;
00802 
00803                         <span class="comment">//</span>
00804                         <span class="comment">// All other disposition values are invalid.</span>
00805                         <span class="comment">//</span>
00806                         <span class="comment">// Raise invalid disposition exception.</span>
00807                         <span class="comment">//</span>
00808 
00809                     <span class="keywordflow">default</span> :
00810                         <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a0">RAISE_EXCEPTION</a>(STATUS_INVALID_DISPOSITION, ExceptionRecord);
00811                     }
00812 
00813                 } <span class="keywordflow">while</span> ((ExceptionFlags &amp; <a class="code" href="../../d6/d7/halmips_8h.html#a31">EXCEPTION_COLLIDED_UNWIND</a>) != 0);
00814             }
00815 
00816         } <span class="keywordflow">else</span> {
00817 
00818             <span class="comment">//</span>
00819             <span class="comment">// Set point at which control left the previous routine.</span>
00820             <span class="comment">//</span>
00821 
00822             LastPc = (ULONG_PTR)ContextRecord1.IntRa - 4;
00823 
00824             <span class="comment">//</span>
00825             <span class="comment">// If the next control PC is the same as the old control PC, then</span>
00826             <span class="comment">// the function table is not correctly formed.</span>
00827             <span class="comment">//</span>
00828 
00829             <span class="keywordflow">if</span> (LastPc == ControlPc) {
00830 <span class="preprocessor">#if DBG</span>
00831 <span class="preprocessor"></span>                ULONG <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>;
00832                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"\n****** Warning - malformed function table (unwind).\n"</span>);
00833                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"ControlPc = %p, %p"</span>, LastPc, ControlPc);
00834                 <span class="keywordflow">for</span> (<a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> = 0; <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> &lt; PC_HISTORY_DEPTH; <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> += 1) {
00835                     <span class="keywordflow">if</span> (ControlPcHistoryIndex &gt; 0) {
00836                         ControlPcHistoryIndex -= 1;
00837                         ControlPc = ControlPcHistory[ControlPcHistoryIndex % PC_HISTORY_DEPTH];
00838                         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">", %p"</span>, ControlPc);
00839                     }
00840                 }
00841                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(ControlPcHistoryIndex == 0 ? <span class="stringliteral">".\n"</span> : <span class="stringliteral">", ...\n"</span>);
00842                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"  Now raising STATUS_BAD_FUNCTION_TABLE exception.\n"</span>);
00843 <span class="preprocessor">#endif</span>
00844 <span class="preprocessor"></span>
00845                 <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a10">RtlRaiseStatus</a>(STATUS_BAD_FUNCTION_TABLE);
00846             }
00847         }
00848 
00849         <span class="comment">//</span>
00850         <span class="comment">// Set point at which control left the previous routine.</span>
00851         <span class="comment">//</span>
00852 
00853 <span class="preprocessor">#if DBG</span>
00854 <span class="preprocessor"></span>        ControlPcHistory[ControlPcHistoryIndex % PC_HISTORY_DEPTH] = ControlPc;
00855         ControlPcHistoryIndex += 1;
00856 <span class="preprocessor">#endif</span>
00857 <span class="preprocessor"></span>
00858         ControlPc = LastPc;
00859 
00860     } <span class="keywordflow">while</span> ((EstablisherFrame.Virtual &lt; HighLimit) &amp;&amp;
00861              (EstablisherFrame.Virtual != (ULONG_PTR)TargetFrame));
00862 
00863     <span class="comment">//</span>
00864     <span class="comment">// If the establisher stack pointer is equal to the target frame pointer,</span>
00865     <span class="comment">// then continue execution at the point where the call to the target frame</span>
00866     <span class="comment">// was made. Otherwise the target of the unwind did not exist and the</span>
00867     <span class="comment">// debugger and subsystem are given a second chance to handle the unwind.</span>
00868     <span class="comment">//</span>
00869 
00870     <span class="keywordflow">if</span> ((ULONG_PTR)ContextRecord1.IntSp == (ULONG_PTR)TargetFrame) {
00871         ContextRecord1.IntV0 = (ULONGLONG)(LONG_PTR)ReturnValue;
00872 
00873         <span class="comment">//</span>
00874         <span class="comment">// Set the continuation address to the address after the point where</span>
00875         <span class="comment">// control left the previous frame and entered the target frame.</span>
00876         <span class="comment">//</span>
00877 
00878         ContextRecord1.Fir = (ULONGLONG)(LONG_PTR)LastPc + 4;
00879 
00880 <span class="preprocessor">#if DBG</span>
00881 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_UNWIND) {
00882         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlUnwindReturn: finished unwinding, and calling RtlpRestoreContext\n"</span>);
00883     }
00884 <span class="preprocessor">#endif</span>
00885 <span class="preprocessor"></span>
00886         <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a3">RtlpRestoreContext</a>(&amp;ContextRecord1);
00887 
00888     } <span class="keywordflow">else</span> {
00889 
00890 <span class="preprocessor">#if DBG</span>
00891 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (RtlDebugFlags &amp; RTL_DBG_UNWIND) {
00892         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"RtlUnwindReturn: finished unwinding, but calling ZwRaiseException\n"</span>);
00893     }
00894 <span class="preprocessor">#endif</span>
00895 <span class="preprocessor"></span>
00896         ZwRaiseException(ExceptionRecord, &amp;ContextRecord1, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00897     }
00898 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:42:11 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
