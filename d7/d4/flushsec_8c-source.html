<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: flushsec.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>flushsec.c</h1><a href="../../d6/d5/flushsec_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1990  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">   flushsec.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module contains the routines which implement the</span>
00012 <span class="comment">    NtFlushVirtualMemory service.</span>
00013 <span class="comment"></span>
00014 <span class="comment">Author:</span>
00015 <span class="comment"></span>
00016 <span class="comment">    Lou Perazzoli (loup) 8-May-1990</span>
00017 <span class="comment">    Landy Wang (landyw) 02-June-1997</span>
00018 <span class="comment"></span>
00019 <span class="comment">Revision History:</span>
00020 <span class="comment"></span>
00021 <span class="comment">--*/</span>
00022 
00023 <span class="preprocessor">#include "<a class="code" href="../../d4/d8/mi_8h.html">mi.h</a>"</span>
00024 
00025 <a class="code" href="../../d1/d7/struct__SUBSECTION.html">PSUBSECTION</a>
00026 <a class="code" href="../../d6/d5/flushsec_8c.html#a1">MiGetSystemCacheSubsection</a> (
00027     IN PVOID BaseAddress,
00028     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process,
00029     OUT <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> *ProtoPte
00030     );
00031 
00032 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00033 <a class="code" href="../../d6/d5/flushsec_8c.html#a2">MiFlushDirtyBitsToPfn</a> (
00034     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte,
00035     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> LastPte,
00036     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process,
00037     IN BOOLEAN SystemCache
00038     );
00039 
00040 ULONG
00041 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
00042 <a class="code" href="../../d5/d5/sectsup_8c.html#a11">MiCheckProtoPtePageState</a> (
00043     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PrototypePte,
00044     IN ULONG PfnLockHeld
00045     );
00046 
00047 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00048 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,NtFlushVirtualMemory)</span>
00049 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,MmFlushVirtualMemory)</span>
00050 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00051 <span class="preprocessor"></span>
<a name="l00052"></a><a class="code" href="../../d6/d5/flushsec_8c.html#a0">00052</a> <span class="keyword">extern</span> <a class="code" href="../../d3/d6/struct__OBJECT__TYPE.html">POBJECT_TYPE</a> <a class="code" href="../../d5/d8/fssup_8c.html#a3">IoFileObjectType</a>;
00053 
00054 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00055"></a><a class="code" href="../../d6/d5/flushsec_8c.html#a4">00055</a> <a class="code" href="../../d6/d5/flushsec_8c.html#a4">NtFlushVirtualMemory</a> (
00056     IN HANDLE ProcessHandle,
00057     IN OUT PVOID *BaseAddress,
00058     IN OUT PSIZE_T RegionSize,
00059     OUT PIO_STATUS_BLOCK IoStatus
00060     )
00061 
00062 <span class="comment">/*++</span>
00063 <span class="comment"></span>
00064 <span class="comment">Routine Description:</span>
00065 <span class="comment"></span>
00066 <span class="comment">    This function flushes a range of virtual address which map</span>
00067 <span class="comment">    a data file back into the data file if they have been modified.</span>
00068 <span class="comment"></span>
00069 <span class="comment">Arguments:</span>
00070 <span class="comment"></span>
00071 <span class="comment">    ProcessHandle - Supplies an open handle to a process object.</span>
00072 <span class="comment"></span>
00073 <span class="comment">    BaseAddress - Supplies a pointer to a variable that will receive</span>
00074 <span class="comment">         the base address the flushed region.  The initial value</span>
00075 <span class="comment">         of this argument is the base address of the region of the</span>
00076 <span class="comment">         pages to flush.</span>
00077 <span class="comment"></span>
00078 <span class="comment">    RegionSize - Supplies a pointer to a variable that will receive</span>
00079 <span class="comment">         the actual size in bytes of the flushed region of pages.</span>
00080 <span class="comment">         The initial value of this argument is rounded up to the</span>
00081 <span class="comment">         next host-page-size boundary.</span>
00082 <span class="comment"></span>
00083 <span class="comment">         If this value is specified as zero, the mapped range from</span>
00084 <span class="comment">         the base address to the end of the range is flushed.</span>
00085 <span class="comment"></span>
00086 <span class="comment">    IoStatus - Returns the value of the IoStatus for the last attempted</span>
00087 <span class="comment">         I/O operation.</span>
00088 <span class="comment"></span>
00089 <span class="comment">Return Value:</span>
00090 <span class="comment"></span>
00091 <span class="comment">    Returns the status</span>
00092 <span class="comment"></span>
00093 <span class="comment">    TBS</span>
00094 <span class="comment"></span>
00095 <span class="comment"></span>
00096 <span class="comment">--*/</span>
00097 
00098 {
00099     <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process;
00100     <a class="code" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> PreviousMode;
00101     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00102     PVOID CapturedBase;
00103     SIZE_T CapturedRegionSize;
00104     IO_STATUS_BLOCK TemporaryIoStatus;
00105 
00106     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00107 
00108     PreviousMode = KeGetPreviousMode();
00109     <span class="keywordflow">if</span> (PreviousMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
00110 
00111         <span class="comment">//</span>
00112         <span class="comment">// Establish an exception handler, probe the specified addresses</span>
00113         <span class="comment">// for write access and capture the initial values.</span>
00114         <span class="comment">//</span>
00115 
00116         <span class="keywordflow">try</span> {
00117 
00118             <a class="code" href="../../d5/d8/ex_8h.html#a37">ProbeForWritePointer</a> (BaseAddress);
00119             <a class="code" href="../../d5/d8/ex_8h.html#a41">ProbeForWriteUlong_ptr</a> (RegionSize);
00120             <a class="code" href="../../d5/d8/ex_8h.html#a31">ProbeForWriteIoStatus</a> (IoStatus);
00121 
00122             <span class="comment">//</span>
00123             <span class="comment">// Capture the base address.</span>
00124             <span class="comment">//</span>
00125 
00126             CapturedBase = *BaseAddress;
00127 
00128             <span class="comment">//</span>
00129             <span class="comment">// Capture the region size.</span>
00130             <span class="comment">//</span>
00131 
00132             CapturedRegionSize = *RegionSize;
00133 
00134         } except (<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00135 
00136             <span class="comment">//</span>
00137             <span class="comment">// If an exception occurs during the probe or capture</span>
00138             <span class="comment">// of the initial values, then handle the exception and</span>
00139             <span class="comment">// return the exception code as the status value.</span>
00140             <span class="comment">//</span>
00141 
00142             <span class="keywordflow">return</span> GetExceptionCode();
00143         }
00144 
00145     } <span class="keywordflow">else</span> {
00146 
00147         <span class="comment">//</span>
00148         <span class="comment">// Capture the base address.</span>
00149         <span class="comment">//</span>
00150 
00151         CapturedBase = *BaseAddress;
00152 
00153         <span class="comment">//</span>
00154         <span class="comment">// Capture the region size.</span>
00155         <span class="comment">//</span>
00156 
00157         CapturedRegionSize = *RegionSize;
00158 
00159     }
00160 
00161     <span class="comment">//</span>
00162     <span class="comment">// Make sure the specified starting and ending addresses are</span>
00163     <span class="comment">// within the user part of the virtual address space.</span>
00164     <span class="comment">//</span>
00165 
00166     <span class="keywordflow">if</span> (CapturedBase &gt; MM_HIGHEST_USER_ADDRESS) {
00167 
00168         <span class="comment">//</span>
00169         <span class="comment">// Invalid base address.</span>
00170         <span class="comment">//</span>
00171 
00172         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER_2;
00173     }
00174 
00175     <span class="keywordflow">if</span> (((ULONG_PTR)MM_HIGHEST_USER_ADDRESS - (ULONG_PTR)CapturedBase) &lt;
00176                                                         CapturedRegionSize) {
00177 
00178         <span class="comment">//</span>
00179         <span class="comment">// Invalid region size;</span>
00180         <span class="comment">//</span>
00181 
00182         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER_2;
00183 
00184     }
00185 
00186     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a> ( ProcessHandle,
00187                                          PROCESS_VM_OPERATION,
00188                                          <a class="code" href="../../d9/d8/ntos_8h.html#a2">PsProcessType</a>,
00189                                          PreviousMode,
00190                                          (PVOID *)&amp;Process,
00191                                          <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00192     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
00193         <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00194     }
00195 
00196     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d5/flushsec_8c.html#a7">MmFlushVirtualMemory</a> (Process,
00197                                    &amp;CapturedBase,
00198                                    &amp;CapturedRegionSize,
00199                                    &amp;TemporaryIoStatus);
00200 
00201     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a> (Process);
00202 
00203     <span class="comment">//</span>
00204     <span class="comment">// Establish an exception handler and write the size and base</span>
00205     <span class="comment">// address.</span>
00206     <span class="comment">//</span>
00207 
00208     <span class="keywordflow">try</span> {
00209 
00210         *RegionSize = CapturedRegionSize;
00211         *BaseAddress = <a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a> (CapturedBase);
00212         *IoStatus = TemporaryIoStatus;
00213 
00214     } except (<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00215     }
00216 
00217     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00218 
00219 }
00220 
00221 
00222 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00223"></a><a class="code" href="../../d6/d5/flushsec_8c.html#a5">00223</a> <a class="code" href="../../d6/d5/flushsec_8c.html#a5">MiFlushAcquire</a> (
00224     IN <a class="code" href="../../d8/d7/struct__CONTROL__AREA.html">PCONTROL_AREA</a> ControlArea
00225     )
00226 
00227 <span class="comment">/*++</span>
00228 <span class="comment"></span>
00229 <span class="comment">Routine Description:</span>
00230 <span class="comment"></span>
00231 <span class="comment">    This is a helper routine to reference count the control area if needed</span>
00232 <span class="comment">    during a flush section call to prevent the section object from being</span>
00233 <span class="comment">    deleted while the flush is ongoing.</span>
00234 <span class="comment"></span>
00235 <span class="comment">Arguments:</span>
00236 <span class="comment"></span>
00237 <span class="comment">    ControlArea - Supplies a pointer to the control area.</span>
00238 <span class="comment"></span>
00239 <span class="comment">Return Value:</span>
00240 <span class="comment"></span>
00241 <span class="comment">    None.</span>
00242 <span class="comment"></span>
00243 <span class="comment">--*/</span>
00244 
00245 {
00246     KIRQL OldIrql;
00247 
00248     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
00249 
00250     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((LONG)ControlArea-&gt;NumberOfMappedViews &gt;= 1);
00251     ControlArea-&gt;NumberOfMappedViews += 1;
00252 
00253     <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
00254 }
00255 
00256 
00257 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00258"></a><a class="code" href="../../d6/d5/flushsec_8c.html#a6">00258</a> <a class="code" href="../../d6/d5/flushsec_8c.html#a6">MiFlushRelease</a> (
00259     IN <a class="code" href="../../d8/d7/struct__CONTROL__AREA.html">PCONTROL_AREA</a> ControlArea
00260     )
00261 
00262 <span class="comment">/*++</span>
00263 <span class="comment"></span>
00264 <span class="comment">Routine Description:</span>
00265 <span class="comment"></span>
00266 <span class="comment">    This is a helper routine to release the control area reference needed</span>
00267 <span class="comment">    during a flush section call.</span>
00268 <span class="comment"></span>
00269 <span class="comment">Arguments:</span>
00270 <span class="comment"></span>
00271 <span class="comment">    ControlArea - Supplies a pointer to the control area.</span>
00272 <span class="comment"></span>
00273 <span class="comment">Return Value:</span>
00274 <span class="comment"></span>
00275 <span class="comment">    None.</span>
00276 <span class="comment"></span>
00277 <span class="comment">--*/</span>
00278 
00279 {
00280     KIRQL OldIrql;
00281 
00282     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
00283 
00284     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((LONG)ControlArea-&gt;NumberOfMappedViews &gt;= 1);
00285     ControlArea-&gt;NumberOfMappedViews -= 1;
00286 
00287     <span class="comment">//</span>
00288     <span class="comment">// Check to see if the control area should be deleted.  This</span>
00289     <span class="comment">// will release the PFN lock.</span>
00290     <span class="comment">//</span>
00291 
00292     <a class="code" href="../../d5/d5/sectsup_8c.html#a24">MiCheckControlArea</a> (ControlArea, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, OldIrql);
00293 }
00294 
00295 
00296 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00297"></a><a class="code" href="../../d6/d5/flushsec_8c.html#a7">00297</a> <a class="code" href="../../d6/d5/flushsec_8c.html#a7">MmFlushVirtualMemory</a> (
00298     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process,
00299     IN OUT PVOID *BaseAddress,
00300     IN OUT PSIZE_T RegionSize,
00301     OUT PIO_STATUS_BLOCK IoStatus
00302     )
00303 
00304 <span class="comment">/*++</span>
00305 <span class="comment"></span>
00306 <span class="comment">Routine Description:</span>
00307 <span class="comment"></span>
00308 <span class="comment">    This function flushes a range of virtual address which map</span>
00309 <span class="comment">    a data file back into the data file if they have been modified.</span>
00310 <span class="comment"></span>
00311 <span class="comment">    Note that the modification is this process's view of the pages,</span>
00312 <span class="comment">    on certain implementations (like the Intel 386), the modify</span>
00313 <span class="comment">    bit is captured in the PTE and not forced to the PFN database</span>
00314 <span class="comment">    until the page is removed from the working set.  This means</span>
00315 <span class="comment">    that pages which have been modified by another process will</span>
00316 <span class="comment">    not be flushed to the data file.</span>
00317 <span class="comment"></span>
00318 <span class="comment">Arguments:</span>
00319 <span class="comment"></span>
00320 <span class="comment">    Process - Supplies a pointer to a process object.</span>
00321 <span class="comment"></span>
00322 <span class="comment">    BaseAddress - Supplies a pointer to a variable that will receive</span>
00323 <span class="comment">         the base address of the flushed region.  The initial value</span>
00324 <span class="comment">         of this argument is the base address of the region of the</span>
00325 <span class="comment">         pages to flush.</span>
00326 <span class="comment"></span>
00327 <span class="comment">    RegionSize - Supplies a pointer to a variable that will receive</span>
00328 <span class="comment">         the actual size in bytes of the flushed region of pages.</span>
00329 <span class="comment">         The initial value of this argument is rounded up to the</span>
00330 <span class="comment">         next host-page-size boundary.</span>
00331 <span class="comment"></span>
00332 <span class="comment">         If this value is specified as zero, the mapped range from</span>
00333 <span class="comment">         the base address to the end of the range is flushed.</span>
00334 <span class="comment"></span>
00335 <span class="comment">    IoStatus - Returns the value of the IoStatus for the last attempted</span>
00336 <span class="comment">         I/O operation.</span>
00337 <span class="comment"></span>
00338 <span class="comment">Return Value:</span>
00339 <span class="comment"></span>
00340 <span class="comment">    Returns the NT status</span>
00341 <span class="comment"></span>
00342 <span class="comment">--*/</span>
00343 
00344 {
00345     <a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a> Vad;
00346     PVOID EndingAddress;
00347     PVOID Va;
00348     <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> CurrentProcess;
00349     BOOLEAN SystemCache;
00350     <a class="code" href="../../d8/d7/struct__CONTROL__AREA.html">PCONTROL_AREA</a> ControlArea;
00351     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
00352     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPde;
00353     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPpe;
00354     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> LastPte;
00355     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> FinalPte;
00356     <a class="code" href="../../d1/d7/struct__SUBSECTION.html">PSUBSECTION</a> Subsection;
00357     <a class="code" href="../../d1/d7/struct__SUBSECTION.html">PSUBSECTION</a> LastSubsection;
00358     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00359     ULONG ConsecutiveFileLockFailures;
00360     ULONG Waited;
00361     LOGICAL EntireRestOfVad;
00362     LOGICAL Attached;
00363 
00364     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00365 
00366     Attached = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00367 
00368     <span class="comment">//</span>
00369     <span class="comment">// Determine if the specified base address is within the system</span>
00370     <span class="comment">// cache and if so, don't attach, the working set mutex is still</span>
00371     <span class="comment">// required to "lock" paged pool pages (proto PTEs) into the</span>
00372     <span class="comment">// working set.</span>
00373     <span class="comment">//</span>
00374 
00375     EndingAddress = (PVOID)(((ULONG_PTR)*BaseAddress + *RegionSize - 1) |
00376                                                             (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1));
00377     *BaseAddress = <a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a> (*BaseAddress);
00378 
00379     <span class="keywordflow">if</span> (<a class="code" href="../../d4/d8/mi_8h.html#a354">MI_IS_SESSION_ADDRESS</a> (*BaseAddress)) {
00380 
00381         <span class="comment">//</span>
00382         <span class="comment">// Nothing in session space needs flushing.</span>
00383         <span class="comment">//</span>
00384 
00385         <span class="keywordflow">return</span> STATUS_NOT_MAPPED_VIEW;
00386     }
00387 
00388     CurrentProcess = <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a> ();
00389 
00390     <span class="keywordflow">if</span> (!<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a196">MI_IS_SYSTEM_CACHE_ADDRESS</a>(*BaseAddress)) {
00391 
00392         SystemCache = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00393 
00394         <span class="comment">//</span>
00395         <span class="comment">// Attach to the specified process.</span>
00396         <span class="comment">//</span>
00397 
00398         <span class="keywordflow">if</span> (<a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>() != Process) {
00399             <a class="code" href="../../d3/d5/procobj_8c.html#a4">KeAttachProcess</a> (&amp;Process-&gt;Pcb);
00400             Attached = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00401         }
00402 
00403         <a class="code" href="../../d4/d8/mi_8h.html#a161">LOCK_WS_AND_ADDRESS_SPACE</a> (Process);
00404 
00405         <span class="comment">//</span>
00406         <span class="comment">// Make sure the address space was not deleted, if so, return an error.</span>
00407         <span class="comment">//</span>
00408 
00409         <span class="keywordflow">if</span> (Process-&gt;AddressSpaceDeleted != 0) {
00410             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_PROCESS_IS_TERMINATING;
00411             <span class="keywordflow">goto</span> ErrorReturn;
00412         }
00413 
00414         Vad = <a class="code" href="../../d6/d3/vadtree_8c.html#a2">MiLocateAddress</a> (*BaseAddress);
00415 
00416         <span class="keywordflow">if</span> (Vad == (<a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a>)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00417 
00418             <span class="comment">//</span>
00419             <span class="comment">// No Virtual Address Descriptor located for Base Address.</span>
00420             <span class="comment">//</span>
00421 
00422             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_NOT_MAPPED_VIEW;
00423             <span class="keywordflow">goto</span> ErrorReturn;
00424         }
00425 
00426         <span class="keywordflow">if</span> (*RegionSize == 0) {
00427             EndingAddress = <a class="code" href="../../d4/d8/mi_8h.html#a109">MI_VPN_TO_VA_ENDING</a> (Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o1">EndingVpn</a>);
00428             EntireRestOfVad = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00429         }
00430         <span class="keywordflow">else</span> {
00431             EntireRestOfVad = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00432         }
00433 
00434         <span class="keywordflow">if</span> ((Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.VadFlags.PrivateMemory == 1) ||
00435             (<a class="code" href="../../d4/d8/mi_8h.html#a107">MI_VA_TO_VPN</a> (EndingAddress) &gt; Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o1">EndingVpn</a>)) {
00436 
00437             <span class="comment">//</span>
00438             <span class="comment">// This virtual address descriptor does not refer to a Segment</span>
00439             <span class="comment">// object.</span>
00440             <span class="comment">//</span>
00441 
00442             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_NOT_MAPPED_VIEW;
00443             <span class="keywordflow">goto</span> ErrorReturn;
00444         }
00445 
00446         <span class="comment">//</span>
00447         <span class="comment">// Make sure this VAD maps a data file (not an image file).</span>
00448         <span class="comment">//</span>
00449 
00450         ControlArea = Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o8">ControlArea</a>;
00451 
00452         <span class="keywordflow">if</span> ((ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o11">FilePointer</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) ||
00453              (Vad-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.VadFlags.ImageMap == 1)) {
00454 
00455             <span class="comment">//</span>
00456             <span class="comment">// This virtual address descriptor does not refer to a Segment</span>
00457             <span class="comment">// object.</span>
00458             <span class="comment">//</span>
00459 
00460             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_NOT_MAPPED_DATA;
00461             <span class="keywordflow">goto</span> ErrorReturn;
00462         }
00463 
00464     } <span class="keywordflow">else</span> {
00465 
00466         SystemCache = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00467         Process = CurrentProcess;
00468         <a class="code" href="../../d4/d8/mi_8h.html#a154">LOCK_WS</a> (Process);
00469     }
00470 
00471     PointerPpe = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a150">MiGetPpeAddress</a> (*BaseAddress);
00472     PointerPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a151">MiGetPdeAddress</a> (*BaseAddress);
00473     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (*BaseAddress);
00474     LastPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (EndingAddress);
00475     *RegionSize = (PCHAR)EndingAddress - (PCHAR)*BaseAddress + 1;
00476 
00477 retry:
00478 
00479     <span class="keywordflow">while</span> (!<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a168">MiDoesPpeExistAndMakeValid</a> (PointerPpe, Process, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, &amp;Waited)) {
00480 
00481         <span class="comment">//</span>
00482         <span class="comment">// This page directory parent entry is empty, go to the next one.</span>
00483         <span class="comment">//</span>
00484 
00485         PointerPpe += 1;
00486         PointerPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPpe);
00487         PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPde);
00488         Va = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPte);
00489 
00490         <span class="keywordflow">if</span> (PointerPte &gt; LastPte) {
00491             <span class="keywordflow">break</span>;
00492         }
00493     }
00494 
00495     Waited = 0;
00496 
00497     <span class="keywordflow">if</span> (PointerPte &lt;= LastPte) {
00498         <span class="keywordflow">while</span> (!<a class="code" href="../../d0/d2/mmsup_8c.html#a6">MiDoesPdeExistAndMakeValid</a>(PointerPde, Process, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, &amp;Waited)) {
00499 
00500             <span class="comment">//</span>
00501             <span class="comment">// No page table page exists for this address.</span>
00502             <span class="comment">//</span>
00503 
00504             PointerPde += 1;
00505 
00506             PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPde);
00507 
00508             <span class="keywordflow">if</span> (PointerPte &gt; LastPte) {
00509                 <span class="keywordflow">break</span>;
00510             }
00511 
00512 <span class="preprocessor">#if defined (_WIN64)</span>
00513 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a167">MiIsPteOnPdeBoundary</a> (PointerPde)) {
00514                 PointerPpe = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (PointerPde);
00515                 <span class="keywordflow">goto</span> retry;
00516             }
00517 <span class="preprocessor">#endif</span>
00518 <span class="preprocessor"></span>
00519             Va = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPte);
00520         }
00521 
00522         <span class="comment">//</span>
00523         <span class="comment">// If the PFN lock (and accordingly the WS mutex) was</span>
00524         <span class="comment">// released and reacquired we must retry the operation.</span>
00525         <span class="comment">//</span>
00526 
00527         <span class="keywordflow">if</span> (PointerPte &lt;= LastPte &amp;&amp; Waited != 0) {
00528             <span class="keywordflow">goto</span> retry;
00529         }
00530     }
00531 
00532     <a class="code" href="../../d6/d5/flushsec_8c.html#a2">MiFlushDirtyBitsToPfn</a> (PointerPte, LastPte, Process, SystemCache);
00533 
00534     <span class="keywordflow">if</span> (SystemCache) {
00535 
00536         <span class="comment">//</span>
00537         <span class="comment">// No VADs exist for the system cache.</span>
00538         <span class="comment">//</span>
00539 
00540         Subsection = <a class="code" href="../../d6/d5/flushsec_8c.html#a1">MiGetSystemCacheSubsection</a> (*BaseAddress,
00541                                                  Process,
00542                                                  &amp;PointerPte);
00543         LastSubsection = <a class="code" href="../../d6/d5/flushsec_8c.html#a1">MiGetSystemCacheSubsection</a> (EndingAddress,
00544                                                      Process,
00545                                                      &amp;FinalPte);
00546         <a class="code" href="../../d4/d8/mi_8h.html#a158">UNLOCK_WS</a> (Process);
00547 
00548         <span class="comment">//</span>
00549         <span class="comment">// Flush the PTEs from the specified section.</span>
00550         <span class="comment">//</span>
00551 
00552         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d4/d8/mi_8h.html#a935">MiFlushSectionInternal</a> (PointerPte,
00553                                          FinalPte,
00554                                          Subsection,
00555                                          LastSubsection,
00556                                          <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00557                                          <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00558                                          IoStatus);
00559     }
00560     <span class="keywordflow">else</span> {
00561 
00562         <span class="comment">//</span>
00563         <span class="comment">// Protect against the section being prematurely deleted.</span>
00564         <span class="comment">//</span>
00565 
00566         <a class="code" href="../../d6/d5/flushsec_8c.html#a5">MiFlushAcquire</a> (ControlArea);
00567 
00568         PointerPte = <a class="code" href="../../d4/d8/mi_8h.html#a246">MiGetProtoPteAddress</a> (Vad, <a class="code" href="../../d4/d8/mi_8h.html#a107">MI_VA_TO_VPN</a> (*BaseAddress));
00569         Subsection = <a class="code" href="../../d4/d8/mi_8h.html#a909">MiLocateSubsection</a> (Vad, <a class="code" href="../../d4/d8/mi_8h.html#a107">MI_VA_TO_VPN</a>(*BaseAddress));
00570         LastSubsection = <a class="code" href="../../d4/d8/mi_8h.html#a909">MiLocateSubsection</a> (Vad, <a class="code" href="../../d4/d8/mi_8h.html#a107">MI_VA_TO_VPN</a>(EndingAddress));
00571 
00572         <span class="comment">//</span>
00573         <span class="comment">// The last subsection is NULL if the section is not fully </span>
00574         <span class="comment">// committed.  Only allow the flush if the caller said do the whole</span>
00575         <span class="comment">// thing, otherwise it's an error.</span>
00576         <span class="comment">//</span>
00577 
00578         <span class="keywordflow">if</span> (LastSubsection == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00579 
00580             <span class="keywordflow">if</span> (EntireRestOfVad == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00581 
00582                 <span class="comment">//</span>
00583                 <span class="comment">// Caller can only specify the range that is committed or zero</span>
00584                 <span class="comment">// to indicate the entire range.</span>
00585                 <span class="comment">//</span>
00586 
00587                 <a class="code" href="../../d4/d8/mi_8h.html#a162">UNLOCK_WS_AND_ADDRESS_SPACE</a> (Process);
00588                 <span class="keywordflow">if</span> (Attached == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00589                     <a class="code" href="../../d3/d5/procobj_8c.html#a7">KeDetachProcess</a>();
00590                 }
00591                 <a class="code" href="../../d6/d5/flushsec_8c.html#a6">MiFlushRelease</a> (ControlArea);
00592                 <span class="keywordflow">return</span> STATUS_NOT_MAPPED_VIEW;
00593             }
00594 
00595             LastSubsection = Subsection;
00596             <span class="keywordflow">while</span> (LastSubsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o9">NextSubsection</a>) {
00597                 LastSubsection = LastSubsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o9">NextSubsection</a>;
00598             }
00599             FinalPte = LastSubsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o6">SubsectionBase</a> + LastSubsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o8">PtesInSubsection</a> - 1;
00600         }
00601         <span class="keywordflow">else</span> {
00602             FinalPte = <a class="code" href="../../d4/d8/mi_8h.html#a246">MiGetProtoPteAddress</a> (Vad, <a class="code" href="../../d4/d8/mi_8h.html#a107">MI_VA_TO_VPN</a> (EndingAddress));
00603         }
00604 
00605         <a class="code" href="../../d4/d8/mi_8h.html#a162">UNLOCK_WS_AND_ADDRESS_SPACE</a> (Process);
00606         <span class="keywordflow">if</span> (Attached == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00607             <a class="code" href="../../d3/d5/procobj_8c.html#a7">KeDetachProcess</a>();
00608         }
00609 
00610         <span class="comment">//</span>
00611         <span class="comment">// Preacquire the file to synchronize the flush.</span>
00612         <span class="comment">//</span>
00613 
00614         ConsecutiveFileLockFailures = 0;
00615 
00616         <span class="keywordflow">do</span> {
00617 
00618             <a class="code" href="../../d1/d8/fsrtl_8h.html#a105">FsRtlAcquireFileForCcFlush</a> (ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o11">FilePointer</a>);
00619 
00620             <span class="comment">//</span>
00621             <span class="comment">// Flush the PTEs from the specified section.</span>
00622             <span class="comment">//</span>
00623 
00624             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d4/d8/mi_8h.html#a935">MiFlushSectionInternal</a> (PointerPte,
00625                                              FinalPte,
00626                                              Subsection,
00627                                              LastSubsection,
00628                                              <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00629                                              <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00630                                              IoStatus);
00631 
00632             <span class="comment">//</span>
00633             <span class="comment">// Release the file we acquired.</span>
00634             <span class="comment">//</span>
00635 
00636             <a class="code" href="../../d1/d8/fsrtl_8h.html#a106">FsRtlReleaseFileForCcFlush</a> (ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o11">FilePointer</a>);
00637 
00638             <span class="comment">//</span>
00639             <span class="comment">// Only try the request more than once if the filesystem told us</span>
00640             <span class="comment">// it had a deadlock.</span>
00641             <span class="comment">//</span>
00642 
00643             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> != STATUS_FILE_LOCK_CONFLICT) {
00644                 <span class="keywordflow">break</span>;
00645             }
00646 
00647             ConsecutiveFileLockFailures += 1;
00648             <a class="code" href="../../d1/d7/wait_8c.html#a2">KeDelayExecutionThread</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, &amp;<a class="code" href="../../d4/d8/mi_8h.html#a420">MmShortTime</a>);
00649 
00650         } <span class="keywordflow">while</span> (ConsecutiveFileLockFailures &lt; 5);
00651 
00652         <a class="code" href="../../d6/d5/flushsec_8c.html#a6">MiFlushRelease</a> (ControlArea);
00653     }
00654 
00655     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00656 
00657 ErrorReturn:
00658     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (SystemCache == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00659     <a class="code" href="../../d4/d8/mi_8h.html#a162">UNLOCK_WS_AND_ADDRESS_SPACE</a> (Process);
00660     <span class="keywordflow">if</span> (Attached == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00661         <a class="code" href="../../d3/d5/procobj_8c.html#a7">KeDetachProcess</a>();
00662     }
00663     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00664 
00665 }
00666 
00667 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00668"></a><a class="code" href="../../d6/d5/flushsec_8c.html#a8">00668</a> <a class="code" href="../../d6/d5/flushsec_8c.html#a8">MmFlushSection</a> (
00669     IN <a class="code" href="../../d7/d0/struct__SECTION__OBJECT__POINTERS.html">PSECTION_OBJECT_POINTERS</a> SectionObjectPointer,
00670     IN PLARGE_INTEGER Offset,
00671     IN SIZE_T RegionSize,
00672     OUT PIO_STATUS_BLOCK IoStatus,
00673     IN ULONG AcquireFile
00674     )
00675 
00676 <span class="comment">/*++</span>
00677 <span class="comment"></span>
00678 <span class="comment">Routine Description:</span>
00679 <span class="comment"></span>
00680 <span class="comment">    This function flushes to the backing file any modified pages within</span>
00681 <span class="comment">    the specified range of the section.</span>
00682 <span class="comment"></span>
00683 <span class="comment">Arguments:</span>
00684 <span class="comment"></span>
00685 <span class="comment">    SectionObjectPointer - Supplies a pointer to the section objects.</span>
00686 <span class="comment"></span>
00687 <span class="comment">    Offset - Supplies the offset into the section in which to begin</span>
00688 <span class="comment">             flushing pages.  If this argument is not present, then the</span>
00689 <span class="comment">             whole section is flushed without regard to the region size</span>
00690 <span class="comment">             argument.</span>
00691 <span class="comment"></span>
00692 <span class="comment">    RegionSize - Supplies the size in bytes to flush.  This is rounded</span>
00693 <span class="comment">                 to a page multiple.</span>
00694 <span class="comment"></span>
00695 <span class="comment">    IoStatus - Returns the value of the IoStatus for the last attempted</span>
00696 <span class="comment">         I/O operation.</span>
00697 <span class="comment"></span>
00698 <span class="comment">    AcquireFile - Nonzero if the callback should be used to acquire the file</span>
00699 <span class="comment"></span>
00700 <span class="comment">Return Value:</span>
00701 <span class="comment"></span>
00702 <span class="comment">    Returns status of the operation.</span>
00703 <span class="comment"></span>
00704 <span class="comment">--*/</span>
00705 
00706 {
00707     <a class="code" href="../../d8/d7/struct__CONTROL__AREA.html">PCONTROL_AREA</a> ControlArea;
00708     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
00709     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> LastPte;
00710     KIRQL OldIrql;
00711     ULONG PteOffset;
00712     <a class="code" href="../../d1/d7/struct__SUBSECTION.html">PSUBSECTION</a> Subsection;
00713     <a class="code" href="../../d1/d7/struct__SUBSECTION.html">PSUBSECTION</a> LastSubsection;
00714     BOOLEAN DeleteSegment = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00715     <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a> CurrentThread;
00716     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
00717     BOOLEAN OldClusterState;
00718     ULONG ConsecutiveFileLockFailures;
00719 
00720     <span class="comment">//</span>
00721     <span class="comment">// Initialize IoStatus for success, in case we take an early exit.</span>
00722     <span class="comment">//</span>
00723 
00724     IoStatus-&gt;Status = STATUS_SUCCESS;
00725     IoStatus-&gt;Information = RegionSize;
00726 
00727     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
00728 
00729     ControlArea = ((<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html">PCONTROL_AREA</a>)(SectionObjectPointer-&gt;DataSectionObject));
00730 
00731     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((ControlArea == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) || (ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o10">u</a>.Flags.Image == 0));
00732 
00733     <span class="keywordflow">if</span> ((ControlArea == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) ||
00734         (ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o10">u</a>.Flags.BeingDeleted) ||
00735         (ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o10">u</a>.Flags.BeingCreated) ||
00736         (ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o3">NumberOfPfnReferences</a> == 0)) {
00737 
00738         <span class="comment">//</span>
00739         <span class="comment">// This file no longer has an associated segment or is in the</span>
00740         <span class="comment">// process of coming or going.</span>
00741         <span class="comment">// If the number of PFN references is zero, then this control</span>
00742         <span class="comment">// area does not have any valid or transition pages that need</span>
00743         <span class="comment">// to be flushed.</span>
00744         <span class="comment">//</span>
00745 
00746         <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
00747         <span class="keywordflow">return</span> STATUS_SUCCESS;
00748     }
00749 
00750     <span class="comment">//</span>
00751     <span class="comment">// Locate the subsection.</span>
00752     <span class="comment">//</span>
00753 
00754     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o10">u</a>.Flags.GlobalOnlyPerSession == 0);
00755 
00756     Subsection = (<a class="code" href="../../d1/d7/struct__SUBSECTION.html">PSUBSECTION</a>)(ControlArea + 1);
00757 
00758     <span class="keywordflow">if</span> (!ARGUMENT_PRESENT (<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>)) {
00759 
00760         <span class="comment">//</span>
00761         <span class="comment">// If the offset is not specified, flush the complete file ignoring</span>
00762         <span class="comment">// the region size.</span>
00763         <span class="comment">//</span>
00764 
00765         PointerPte = &amp;Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o6">SubsectionBase</a>[0];
00766         LastSubsection = Subsection;
00767         <span class="keywordflow">while</span> (LastSubsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o9">NextSubsection</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00768             LastSubsection = LastSubsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o9">NextSubsection</a>;
00769         }
00770         LastPte = &amp;LastSubsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o6">SubsectionBase</a>
00771                             [LastSubsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o8">PtesInSubsection</a> - 1];
00772     } <span class="keywordflow">else</span> {
00773 
00774         PteOffset = (ULONG)(<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>-&gt;QuadPart &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
00775 
00776         <span class="comment">//</span>
00777         <span class="comment">// Make sure the PTEs are not in the extended part of the</span>
00778         <span class="comment">// segment.</span>
00779         <span class="comment">//</span>
00780 
00781         <span class="keywordflow">while</span> (PteOffset &gt;= Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o8">PtesInSubsection</a>) {
00782             PteOffset -= Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o8">PtesInSubsection</a>;
00783             <span class="keywordflow">if</span> (Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o9">NextSubsection</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00784 
00785                 <span class="comment">//</span>
00786                 <span class="comment">// Past end of mapping, just return success.</span>
00787                 <span class="comment">//</span>
00788 
00789                 <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
00790                 <span class="keywordflow">return</span> STATUS_SUCCESS;
00791             }
00792             Subsection = Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o9">NextSubsection</a>;
00793         }
00794 
00795         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PteOffset &lt; Subsection-&gt;PtesInSubsection);
00796         PointerPte = &amp;Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o6">SubsectionBase</a>[PteOffset];
00797 
00798         <span class="comment">//</span>
00799         <span class="comment">// Locate the address of the last prototype PTE to be flushed.</span>
00800         <span class="comment">//</span>
00801 
00802         PteOffset += (ULONG)(((RegionSize + <a class="code" href="../../d2/d1/mm_8h.html#a6">BYTE_OFFSET</a>(<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>-&gt;LowPart)) - 1) &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
00803 
00804         LastSubsection = Subsection;
00805 
00806         <span class="keywordflow">while</span> (PteOffset &gt;= LastSubsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o8">PtesInSubsection</a>) {
00807             PteOffset -= LastSubsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o8">PtesInSubsection</a>;
00808             <span class="keywordflow">if</span> (LastSubsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o9">NextSubsection</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00809                 PteOffset = LastSubsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o8">PtesInSubsection</a> - 1;
00810                 <span class="keywordflow">break</span>;
00811             }
00812             LastSubsection = LastSubsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o9">NextSubsection</a>;
00813         }
00814 
00815         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PteOffset &lt; LastSubsection-&gt;PtesInSubsection);
00816         LastPte = &amp;LastSubsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o6">SubsectionBase</a>[PteOffset];
00817     }
00818 
00819     <span class="comment">//</span>
00820     <span class="comment">// Up the map view count so the control area cannot be deleted</span>
00821     <span class="comment">// out from under the call.</span>
00822     <span class="comment">//</span>
00823 
00824     ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o4">NumberOfMappedViews</a> += 1;
00825 
00826     <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
00827 
00828     CurrentThread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
00829 
00830     <span class="comment">//</span>
00831     <span class="comment">// Indicate that disk verify errors should be returned as exceptions.</span>
00832     <span class="comment">//</span>
00833 
00834     OldClusterState = CurrentThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o22">ForwardClusterOnly</a>;
00835     CurrentThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o22">ForwardClusterOnly</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00836 
00837     <span class="comment">//</span>
00838     <span class="comment">// Preacquire the file if we are going to synchronize the flush.</span>
00839     <span class="comment">//</span>
00840 
00841     <span class="keywordflow">if</span> (AcquireFile == 0) {
00842 
00843         <span class="comment">//</span>
00844         <span class="comment">// Flush the PTEs from the specified section.</span>
00845         <span class="comment">//</span>
00846 
00847         status = <a class="code" href="../../d4/d8/mi_8h.html#a935">MiFlushSectionInternal</a> (PointerPte,
00848                                          LastPte,
00849                                          Subsection,
00850                                          LastSubsection,
00851                                          <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00852                                          <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00853                                          IoStatus);
00854     }
00855     <span class="keywordflow">else</span> {
00856 
00857         ConsecutiveFileLockFailures = 0;
00858 
00859         <span class="keywordflow">do</span> {
00860 
00861             <a class="code" href="../../d1/d8/fsrtl_8h.html#a105">FsRtlAcquireFileForCcFlush</a> (ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o11">FilePointer</a>);
00862 
00863             <span class="comment">//</span>
00864             <span class="comment">// Flush the PTEs from the specified section.</span>
00865             <span class="comment">//</span>
00866 
00867             status = <a class="code" href="../../d4/d8/mi_8h.html#a935">MiFlushSectionInternal</a> (PointerPte,
00868                                              LastPte,
00869                                              Subsection,
00870                                              LastSubsection,
00871                                              <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00872                                              <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00873                                              IoStatus);
00874 
00875             <span class="comment">//</span>
00876             <span class="comment">// Release the file we acquired.</span>
00877             <span class="comment">//</span>
00878 
00879             <a class="code" href="../../d1/d8/fsrtl_8h.html#a106">FsRtlReleaseFileForCcFlush</a> (ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o11">FilePointer</a>);
00880 
00881             <span class="comment">//</span>
00882             <span class="comment">// Only try the request more than once if the filesystem told us</span>
00883             <span class="comment">// it had a deadlock.</span>
00884             <span class="comment">//</span>
00885 
00886             <span class="keywordflow">if</span> (status != STATUS_FILE_LOCK_CONFLICT) {
00887                 <span class="keywordflow">break</span>;
00888             }
00889 
00890             ConsecutiveFileLockFailures += 1;
00891             <a class="code" href="../../d1/d7/wait_8c.html#a2">KeDelayExecutionThread</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, &amp;<a class="code" href="../../d4/d8/mi_8h.html#a420">MmShortTime</a>);
00892 
00893         } <span class="keywordflow">while</span> (ConsecutiveFileLockFailures &lt; 5);
00894     }
00895 
00896     CurrentThread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o22">ForwardClusterOnly</a> = OldClusterState;
00897 
00898     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
00899 
00900     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((LONG)ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o4">NumberOfMappedViews</a> &gt;= 1);
00901     ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o4">NumberOfMappedViews</a> -= 1;
00902 
00903     <span class="comment">//</span>
00904     <span class="comment">// Check to see if the control area should be deleted.  This</span>
00905     <span class="comment">// will release the PFN lock.</span>
00906     <span class="comment">//</span>
00907 
00908     <a class="code" href="../../d5/d5/sectsup_8c.html#a24">MiCheckControlArea</a> (ControlArea, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, OldIrql);
00909 
00910     <span class="keywordflow">return</span> status;
00911 
00912 }
00913 
00914 
00915 LONGLONG
<a name="l00916"></a><a class="code" href="../../d4/d8/mi_8h.html#a952">00916</a> <a class="code" href="../../d4/d8/mi_8h.html#a952">MiStartingOffset</a>(
00917     IN <a class="code" href="../../d1/d7/struct__SUBSECTION.html">PSUBSECTION</a> Subsection,
00918     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PteAddress
00919     )
00920 
00921 <span class="comment">/*++</span>
00922 <span class="comment"></span>
00923 <span class="comment">Routine Description:</span>
00924 <span class="comment"></span>
00925 <span class="comment">    This function calculates the file offset given a subsection and a PTE</span>
00926 <span class="comment">    offset.  Note that images are stored in 512-byte units whereas data is</span>
00927 <span class="comment">    stored in 4K units.</span>
00928 <span class="comment"></span>
00929 <span class="comment">    When this is all debugged, this should be made into a macro.</span>
00930 <span class="comment"></span>
00931 <span class="comment">Arguments:</span>
00932 <span class="comment"></span>
00933 <span class="comment">    Subsection - Supplies a subsection to reference for the file address.</span>
00934 <span class="comment"></span>
00935 <span class="comment">    PteAddress - Supplies a PTE within the subsection</span>
00936 <span class="comment"></span>
00937 <span class="comment">Return Value:</span>
00938 <span class="comment"></span>
00939 <span class="comment">    Returns the file offset to obtain the backing data from.</span>
00940 <span class="comment"></span>
00941 <span class="comment">--*/</span>
00942 
00943 {
00944     LONGLONG PteByteOffset;
00945     LARGE_INTEGER StartAddress;
00946 
00947     <span class="keywordflow">if</span> (Subsection-&gt;ControlArea-&gt;u.Flags.Image == 1) {
00948             <span class="keywordflow">return</span> <a class="code" href="../../d4/d8/mi_8h.html#a93">MI_STARTING_OFFSET</a> ( Subsection,
00949                                         PteAddress);
00950     }
00951 
00952     PteByteOffset = (LONGLONG)((PteAddress - Subsection-&gt;SubsectionBase))
00953                             &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
00954 
00955     <a class="code" href="../../d4/d8/mi_8h.html#a220">Mi4KStartFromSubsection</a> (&amp;StartAddress, Subsection);
00956 
00957     StartAddress.QuadPart = StartAddress.QuadPart &lt;&lt; <a class="code" href="../../d4/d8/mi_8h.html#a25">MM4K_SHIFT</a>;
00958 
00959     PteByteOffset += StartAddress.QuadPart;
00960 
00961     <span class="keywordflow">return</span> PteByteOffset;
00962 }
00963 
00964 LARGE_INTEGER
<a name="l00965"></a><a class="code" href="../../d4/d8/mi_8h.html#a953">00965</a> <a class="code" href="../../d4/d8/mi_8h.html#a953">MiEndingOffset</a>(
00966     IN <a class="code" href="../../d1/d7/struct__SUBSECTION.html">PSUBSECTION</a> Subsection
00967     )
00968 
00969 <span class="comment">/*++</span>
00970 <span class="comment"></span>
00971 <span class="comment">Routine Description:</span>
00972 <span class="comment"></span>
00973 <span class="comment">    This function calculates the last valid file offset in a given subsection.</span>
00974 <span class="comment">    offset.  Note that images are stored in 512-byte units whereas data is</span>
00975 <span class="comment">    stored in 4K units.</span>
00976 <span class="comment"></span>
00977 <span class="comment">    When this is all debugged, this should be made into a macro.</span>
00978 <span class="comment"></span>
00979 <span class="comment">Arguments:</span>
00980 <span class="comment"></span>
00981 <span class="comment">    Subsection - Supplies a subsection to reference for the file address.</span>
00982 <span class="comment"></span>
00983 <span class="comment">    PteAddress - Supplies a PTE within the subsection</span>
00984 <span class="comment"></span>
00985 <span class="comment">Return Value:</span>
00986 <span class="comment"></span>
00987 <span class="comment">    Returns the file offset to obtain the backing data from.</span>
00988 <span class="comment"></span>
00989 <span class="comment">--*/</span>
00990 
00991 {
00992     LARGE_INTEGER FileByteOffset;
00993 
00994     <span class="keywordflow">if</span> (Subsection-&gt;ControlArea-&gt;u.Flags.Image == 1) {
00995         FileByteOffset.QuadPart =
00996             (Subsection-&gt;StartingSector + Subsection-&gt;NumberOfFullSectors) &lt;&lt;
00997                 <a class="code" href="../../d4/d8/mi_8h.html#a27">MMSECTOR_SHIFT</a>;
00998     }
00999     <span class="keywordflow">else</span> {
01000         <a class="code" href="../../d4/d8/mi_8h.html#a220">Mi4KStartFromSubsection</a> (&amp;FileByteOffset, Subsection);
01001 
01002         FileByteOffset.QuadPart += Subsection-&gt;NumberOfFullSectors;
01003 
01004         FileByteOffset.QuadPart = FileByteOffset.QuadPart &lt;&lt; <a class="code" href="../../d4/d8/mi_8h.html#a25">MM4K_SHIFT</a>;
01005     }
01006 
01007     FileByteOffset.QuadPart += Subsection-&gt;u.SubsectionFlags.SectorEndOffset;
01008 
01009     <span class="keywordflow">return</span> FileByteOffset;
01010 }
01011 
01012 
01013 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01014"></a><a class="code" href="../../d4/d8/mi_8h.html#a935">01014</a> <a class="code" href="../../d4/d8/mi_8h.html#a935">MiFlushSectionInternal</a> (
01015     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> StartingPte,
01016     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> FinalPte,
01017     IN <a class="code" href="../../d1/d7/struct__SUBSECTION.html">PSUBSECTION</a> FirstSubsection,
01018     IN <a class="code" href="../../d1/d7/struct__SUBSECTION.html">PSUBSECTION</a> LastSubsection,
01019     IN ULONG Synchronize,
01020     IN LOGICAL WriteInProgressOk,
01021     OUT PIO_STATUS_BLOCK IoStatus
01022     )
01023 
01024 <span class="comment">/*++</span>
01025 <span class="comment"></span>
01026 <span class="comment">Routine Description:</span>
01027 <span class="comment"></span>
01028 <span class="comment">    This function flushes to the backing file any modified pages within</span>
01029 <span class="comment">    the specified range of the section.  The parameters describe the</span>
01030 <span class="comment">    section's prototype PTEs (start and end) and the subsections</span>
01031 <span class="comment">    which correspond to the starting and ending PTE.</span>
01032 <span class="comment"></span>
01033 <span class="comment">    Each PTE in the subsection between the specified start and end</span>
01034 <span class="comment">    is examined and if the page is either valid or transition AND</span>
01035 <span class="comment">    the page has been modified, the modify bit is cleared in the PFN</span>
01036 <span class="comment">    database and the page is flushed to its backing file.</span>
01037 <span class="comment"></span>
01038 <span class="comment">Arguments:</span>
01039 <span class="comment"></span>
01040 <span class="comment">    StartingPte - Supplies a pointer to the first prototype PTE to</span>
01041 <span class="comment">                  be examined for flushing.</span>
01042 <span class="comment"></span>
01043 <span class="comment">    FinalPte - Supplies a pointer to the last prototype PTE to be</span>
01044 <span class="comment">               examined for flushing.</span>
01045 <span class="comment"></span>
01046 <span class="comment">    FirstSubsection - Supplies the subsection that contains the</span>
01047 <span class="comment">                      StartingPte.</span>
01048 <span class="comment"></span>
01049 <span class="comment">    LastSubsection - Supplies the subsection that contains the</span>
01050 <span class="comment">                     FinalPte.</span>
01051 <span class="comment"></span>
01052 <span class="comment">    Synchronize - Supplies TRUE if synchronization with all threads</span>
01053 <span class="comment">                  doing flush operations to this section should occur.</span>
01054 <span class="comment"></span>
01055 <span class="comment">    WriteInProgressOk - Supplies TRUE if the caller can tolerate a write</span>
01056 <span class="comment">                        already in progress for any dirty pages.</span>
01057 <span class="comment"></span>
01058 <span class="comment">    IoStatus - Returns the value of the IoStatus for the last attempted</span>
01059 <span class="comment">               I/O operation.</span>
01060 <span class="comment"></span>
01061 <span class="comment">Return Value:</span>
01062 <span class="comment"></span>
01063 <span class="comment">    Returns status of the operation.</span>
01064 <span class="comment"></span>
01065 <span class="comment">--*/</span>
01066 
01067 {
01068     <a class="code" href="../../d8/d7/struct__CONTROL__AREA.html">PCONTROL_AREA</a> ControlArea;
01069     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
01070     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> LastPte;
01071     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> LastWritten;
01072     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> PteContents;
01073     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
01074     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn2;
01075     KIRQL OldIrql;
01076     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> Mdl;
01077     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> IoEvent;
01078     <a class="code" href="../../d1/d7/struct__SUBSECTION.html">PSUBSECTION</a> Subsection;
01079     PPFN_NUMBER Page;
01080     PFN_NUMBER PageFrameIndex;
01081     PPFN_NUMBER LastPage;
01082     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01083     UINT64 StartingOffset;
01084     UINT64 TempOffset;
01085     BOOLEAN WriteNow;
01086     LOGICAL Bail;
01087     PFN_NUMBER MdlHack[(<span class="keyword">sizeof</span>(<a class="code" href="../../d6/d7/struct__MDL.html">MDL</a>)/<span class="keyword">sizeof</span>(PFN_NUMBER)) + (<a class="code" href="../../d2/d1/mm_8h.html#a3">MM_MAXIMUM_DISK_IO_SIZE</a> / <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>) + 1];
01088     ULONG ReflushCount;
01089 
01090     WriteNow = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01091     Bail = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01092 
01093     IoStatus-&gt;Status = STATUS_SUCCESS;
01094     IoStatus-&gt;Information = 0;
01095     Mdl = (<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>)&amp;MdlHack[0];
01096 
01097     <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a> (&amp;IoEvent, NotificationEvent, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
01098 
01099     FinalPte += 1;  <span class="comment">// Point to 1 past the last one.</span>
01100 
01101     LastWritten = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01102     LastPage = 0;
01103     Subsection = FirstSubsection;
01104     PointerPte = StartingPte;
01105     ControlArea = FirstSubsection-&gt;ControlArea;
01106 
01107     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
01108 
01109     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o10">u</a>.Flags.Image == 0);
01110 
01111     <span class="keywordflow">if</span> (ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o3">NumberOfPfnReferences</a> == 0) {
01112 
01113         <span class="comment">//</span>
01114         <span class="comment">// No transition or valid prototype PTEs present, hence</span>
01115         <span class="comment">// no need to flush anything.</span>
01116         <span class="comment">//</span>
01117 
01118         <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
01119         <span class="keywordflow">return</span> STATUS_SUCCESS;
01120     }
01121 
01122     <span class="keywordflow">while</span> ((Synchronize) &amp;&amp; (ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o6">FlushInProgressCount</a> != 0)) {
01123 
01124         <span class="comment">//</span>
01125         <span class="comment">// Another thread is currently performing a flush operation on</span>
01126         <span class="comment">// this file.  Wait for that flush to complete.</span>
01127         <span class="comment">//</span>
01128 
01129         <a class="code" href="../../d4/d9/ke_8h.html#a28">KeEnterCriticalRegion</a>();
01130         ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o10">u</a>.Flags.CollidedFlush = 1;
01131         <a class="code" href="../../d4/d8/mi_8h.html#a132">UNLOCK_PFN_AND_THEN_WAIT</a>(OldIrql);
01132 
01133         <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a> (&amp;<a class="code" href="../../d4/d8/mi_8h.html#a720">MmCollidedFlushEvent</a>,
01134                                <a class="code" href="../../d4/d9/ke_8h.html#a407a217">WrPageOut</a>,
01135                                <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
01136                                <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01137                                &amp;<a class="code" href="../../d4/d8/mi_8h.html#a418">MmOneSecond</a>);
01138         <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
01139         <a class="code" href="../../d4/d9/ke_8h.html#a29">KeLeaveCriticalRegion</a>();
01140     }
01141 
01142     ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o6">FlushInProgressCount</a> += 1;
01143 
01144     <span class="keywordflow">for</span> (;;) {
01145 
01146         <span class="keywordflow">if</span> (LastSubsection != Subsection) {
01147 
01148             <span class="comment">//</span>
01149             <span class="comment">// Flush to the last PTE in this subsection.</span>
01150             <span class="comment">//</span>
01151 
01152             LastPte = &amp;Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o6">SubsectionBase</a>[Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o8">PtesInSubsection</a>];
01153         } <span class="keywordflow">else</span> {
01154 
01155             <span class="comment">//</span>
01156             <span class="comment">// Flush to the end of the range.</span>
01157             <span class="comment">//</span>
01158 
01159             LastPte = FinalPte;
01160         }
01161 
01162         <span class="comment">//</span>
01163         <span class="comment">// If the prototype PTEs are paged out or have a share count</span>
01164         <span class="comment">// of 1, they cannot contain any transition or valid PTEs.</span>
01165         <span class="comment">//</span>
01166 
01167         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/sectsup_8c.html#a11">MiCheckProtoPtePageState</a>(PointerPte, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>)) {
01168             PointerPte = (<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)(((ULONG_PTR)PointerPte | (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) + 1);
01169         }
01170 
01171         <span class="keywordflow">while</span> (PointerPte &lt; LastPte) {
01172 
01173             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a167">MiIsPteOnPdeBoundary</a>(PointerPte)) {
01174 
01175                 <span class="comment">//</span>
01176                 <span class="comment">// We are on a page boundary, make sure this PTE is resident.</span>
01177                 <span class="comment">//</span>
01178 
01179                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/sectsup_8c.html#a11">MiCheckProtoPtePageState</a>(PointerPte, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>)) {
01180                     PointerPte = (<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)((PCHAR)PointerPte + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
01181 
01182                     <span class="comment">//</span>
01183                     <span class="comment">// If there are dirty pages to be written, write them</span>
01184                     <span class="comment">// now as we are skipping over PTEs.</span>
01185                     <span class="comment">//</span>
01186 
01187                     <span class="keywordflow">if</span> (LastWritten != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01188                         WriteNow = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01189                         <span class="keywordflow">goto</span> CheckForWrite;
01190                     }
01191                     <span class="keywordflow">continue</span>;
01192                 }
01193             }
01194 
01195             PteContents = *PointerPte;
01196 
01197             <span class="keywordflow">if</span> ((PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1) ||
01198                    ((PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Prototype == 0) &amp;&amp;
01199                      (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Transition == 1))) {
01200 
01201                 <span class="comment">//</span>
01202                 <span class="comment">// Prototype PTE in transition, there are 3 possible cases:</span>
01203                 <span class="comment">//  1. The page is part of an image which is sharable and</span>
01204                 <span class="comment">//     refers to the paging file - dereference page file</span>
01205                 <span class="comment">//     space and free the physical page.</span>
01206                 <span class="comment">//  2. The page refers to the segment but is not modified -</span>
01207                 <span class="comment">//     free the physical page.</span>
01208                 <span class="comment">//  3. The page refers to the segment and is modified -</span>
01209                 <span class="comment">//     write the page to the file and free the physical page.</span>
01210                 <span class="comment">//</span>
01211 
01212                 <span class="keywordflow">if</span> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1) {
01213                     PageFrameIndex = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a> (&amp;PteContents);
01214                 } <span class="keywordflow">else</span> {
01215                     PageFrameIndex = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a183">MI_GET_PAGE_FRAME_FROM_TRANSITION_PTE</a> (&amp;PteContents);
01216                 }
01217 
01218                 Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PageFrameIndex);
01219                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Prototype == 1);
01220                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 0);
01221 
01222                 <span class="comment">//</span>
01223                 <span class="comment">// If the page is modified OR a write is in progress</span>
01224                 <span class="comment">// flush it.  The write in progress case catches problems</span>
01225                 <span class="comment">// where the modified page write continually writes a</span>
01226                 <span class="comment">// page and gets errors writing it, by writing pages</span>
01227                 <span class="comment">// in this state, the error will be propagated back to</span>
01228                 <span class="comment">// the caller.</span>
01229                 <span class="comment">//</span>
01230 
01231                 <span class="keywordflow">if</span> ((Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.Modified == 1) ||
01232                     (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.WriteInProgress)) {
01233 
01234                     <span class="keywordflow">if</span> ((WriteInProgressOk == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
01235                         (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.WriteInProgress)) {
01236 
01237                             PointerPte = LastPte;
01238                             Bail = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01239 
01240                             <span class="keywordflow">if</span> (LastWritten != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01241                                 WriteNow = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01242                             }
01243                             <span class="keywordflow">goto</span> CheckForWrite;
01244                     }
01245 
01246                     <span class="keywordflow">if</span> (LastWritten == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01247 
01248                         <span class="comment">//</span>
01249                         <span class="comment">// This is the first page of a cluster, initialize</span>
01250                         <span class="comment">// the MDL, etc.</span>
01251                         <span class="comment">//</span>
01252 
01253                         LastPage = (PPFN_NUMBER)(Mdl + 1);
01254 
01255                         <span class="comment">//</span>
01256                         <span class="comment">// Calculate the offset to read into the file.</span>
01257                         <span class="comment">//  offset = base + ((thispte - basepte) &lt;&lt; PAGE_SHIFT)</span>
01258                         <span class="comment">//</span>
01259 
01260                         StartingOffset = (UINT64) <a class="code" href="../../d4/d8/mi_8h.html#a952">MiStartingOffset</a> (
01261                                                              Subsection,
01262                                                              Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a>);
01263 
01264                         <a class="code" href="../../d4/d8/mi_8h.html#a235">MI_INITIALIZE_ZERO_MDL</a> (Mdl);
01265 
01266                         Mdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o2">MdlFlags</a> |= <a class="code" href="../../d0/d9/ntosdef_8h.html#a13">MDL_PAGES_LOCKED</a>;
01267                         Mdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o5">StartVa</a> =
01268                                   (PVOID)ULongToPtr(Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageColor &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
01269                         Mdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o1">Size</a> = (CSHORT)(<span class="keyword">sizeof</span>(<a class="code" href="../../d6/d7/struct__MDL.html">MDL</a>) +
01270                                    (<span class="keyword">sizeof</span>(PFN_NUMBER) * <a class="code" href="../../d4/d8/mi_8h.html#a730">MmModifiedWriteClusterSize</a>));
01271                     }
01272 
01273                     LastWritten = PointerPte;
01274                     Mdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o6">ByteCount</a> += <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
01275                     <span class="keywordflow">if</span> (Mdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o6">ByteCount</a> == (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> * <a class="code" href="../../d4/d8/mi_8h.html#a730">MmModifiedWriteClusterSize</a>)) {
01276                         WriteNow = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01277                     }
01278 
01279                     <span class="keywordflow">if</span> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 0) {
01280 
01281                         <span class="comment">//</span>
01282                         <span class="comment">// The page is in transition.</span>
01283                         <span class="comment">//</span>
01284 
01285                         <a class="code" href="../../d7/d5/pfnlist_8c.html#a11">MiUnlinkPageFromList</a> (Pfn1);
01286                         <a class="code" href="../../d4/d8/mi_8h.html#a187">MI_ADD_LOCKED_PAGE_CHARGE_FOR_MODIFIED_PAGE</a>(Pfn1, 18);
01287                     }
01288                     <span class="keywordflow">else</span> {
01289                         <a class="code" href="../../d4/d8/mi_8h.html#a186">MI_ADD_LOCKED_PAGE_CHARGE</a>(Pfn1, 20);
01290                     }
01291 
01292                     <span class="comment">//</span>
01293                     <span class="comment">// Clear the modified bit for this page.</span>
01294                     <span class="comment">//</span>
01295 
01296                     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.Modified = 0;
01297 
01298                     <span class="comment">//</span>
01299                     <span class="comment">// Up the reference count for the physical page as there</span>
01300                     <span class="comment">// is I/O in progress.</span>
01301                     <span class="comment">//</span>
01302 
01303                     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount += 1;
01304 
01305                     *LastPage = PageFrameIndex;
01306                     LastPage += 1;
01307                 } <span class="keywordflow">else</span> {
01308 
01309                     <span class="comment">//</span>
01310                     <span class="comment">// This page was not modified and therefore ends the</span>
01311                     <span class="comment">// current write cluster if any.  Set WriteNow to TRUE</span>
01312                     <span class="comment">// if there is a cluster being built.</span>
01313                     <span class="comment">//</span>
01314 
01315                     <span class="keywordflow">if</span> (LastWritten != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01316                         WriteNow = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01317                     }
01318                 }
01319             } <span class="keywordflow">else</span> {
01320 
01321                 <span class="comment">//</span>
01322                 <span class="comment">// This page was not modified and therefore ends the</span>
01323                 <span class="comment">// current write cluster if any.  Set WriteNow to TRUE</span>
01324                 <span class="comment">// if there is a cluster being built.</span>
01325                 <span class="comment">//</span>
01326 
01327                 <span class="keywordflow">if</span> (LastWritten != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01328                     WriteNow = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01329                 }
01330             }
01331 
01332             PointerPte += 1;
01333 
01334 CheckForWrite:
01335 
01336             <span class="comment">//</span>
01337             <span class="comment">// Write the current cluster if it is complete,</span>
01338             <span class="comment">// full, or the loop is now complete.</span>
01339             <span class="comment">//</span>
01340 
01341             <span class="keywordflow">if</span> ((WriteNow) ||
01342                 ((PointerPte == LastPte) &amp;&amp; (LastWritten != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>))) {
01343 
01344                 LARGE_INTEGER EndOfFile;
01345 
01346                 <span class="comment">//</span>
01347                 <span class="comment">// Issue the write request.</span>
01348                 <span class="comment">//</span>
01349 
01350                 <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
01351 
01352                 WriteNow = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01353 
01354                 <span class="comment">//</span>
01355                 <span class="comment">// Make sure the write does not go past the</span>
01356                 <span class="comment">// end of file. (segment size).</span>
01357                 <span class="comment">//</span>
01358 
01359                 EndOfFile = <a class="code" href="../../d4/d8/mi_8h.html#a953">MiEndingOffset</a>(Subsection);
01360                 TempOffset = (UINT64) EndOfFile.QuadPart;
01361 
01362                 <span class="keywordflow">if</span> (StartingOffset + Mdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o6">ByteCount</a> &gt; TempOffset) {
01363 
01364                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((ULONG_PTR)(TempOffset - StartingOffset) &gt;
01365                              (Mdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o6">ByteCount</a> - <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>));
01366 
01367                     Mdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o6">ByteCount</a> = (ULONG)(TempOffset-
01368                                              StartingOffset);
01369                 }
01370 
01371                 ReflushCount = <a class="code" href="../../d4/d8/mi_8h.html#a428">MiIoRetryLevel</a>;
01372                 
01373                 <span class="keywordflow">while</span> ( <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> ) {
01374 
01375                     <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a> (&amp;IoEvent);
01376 
01377 <span class="preprocessor">#if DBG</span>
01378 <span class="preprocessor"></span>                    <span class="keywordflow">if</span> (MmDebug &amp; <a class="code" href="../../d4/d8/mi_8h.html#a71">MM_DBG_FLUSH_SECTION</a>) {
01379                         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"flush page write begun %lx\n"</span>,
01380                                 Mdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o6">ByteCount</a>);
01381                     }
01382 <span class="preprocessor">#endif //DBG</span>
01383 <span class="preprocessor"></span>
01384                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d4/d6/iosubs_8c.html#a116">IoSynchronousPageWrite</a> (ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o11">FilePointer</a>,
01385                                                      Mdl,
01386                                                      (PLARGE_INTEGER)&amp;StartingOffset,
01387                                                      &amp;IoEvent,
01388                                                      IoStatus );
01389 
01390                     <span class="comment">//</span>
01391                     <span class="comment">// If success is returned, wait for the i/o event to be set.</span>
01392                     <span class="comment">//</span>
01393 
01394                     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
01395                         <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;IoEvent,
01396                                                <a class="code" href="../../d4/d9/ke_8h.html#a407a217">WrPageOut</a>,
01397                                                <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
01398                                                <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01399                                                (PLARGE_INTEGER)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
01400                     <span class="comment">//</span>
01401                     <span class="comment">//  Otherwise, copy the error to the IoStatus, for error</span>
01402                     <span class="comment">//  handling below.</span>
01403                     <span class="comment">//</span>
01404 
01405                     } <span class="keywordflow">else</span> {
01406                         IoStatus-&gt;Status = <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01407                     }
01408 
01409                     <span class="keywordflow">if</span> (Mdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o2">MdlFlags</a> &amp; <a class="code" href="../../d0/d9/ntosdef_8h.html#a12">MDL_MAPPED_TO_SYSTEM_VA</a>) {
01410                         <a class="code" href="../../d5/d6/iosup_8c.html#a56">MmUnmapLockedPages</a> (Mdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o4">MappedSystemVa</a>, Mdl);
01411                     }
01412 
01413                     Page = (PPFN_NUMBER)(Mdl + 1);
01414 
01415                     <span class="keywordflow">if</span> (<a class="code" href="../../d4/d8/mi_8h.html#a85">MmIsRetryIoStatus</a>(IoStatus-&gt;Status)) {
01416                         
01417                         ReflushCount -= 1;
01418                         <span class="keywordflow">if</span> (ReflushCount != 0) {
01419                             <a class="code" href="../../d1/d7/wait_8c.html#a2">KeDelayExecutionThread</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, &amp;<a class="code" href="../../d4/d8/mi_8h.html#a422">Mm30Milliseconds</a>);
01420                             <span class="keywordflow">continue</span>;
01421                         }
01422                     }
01423 
01424                     <span class="keywordflow">break</span>;
01425                 }
01426 
01427                 <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
01428 
01429                 <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a167">MiIsPteOnPdeBoundary</a>(PointerPte) == 0) {
01430 
01431                     <span class="comment">//</span>
01432                     <span class="comment">// The next PTE is not in a different page, make</span>
01433                     <span class="comment">// sure this page did not leave memory when the</span>
01434                     <span class="comment">// I/O was in progress.</span>
01435                     <span class="comment">//</span>
01436 
01437                     <a class="code" href="../../d0/d2/mmsup_8c.html#a11">MiMakeSystemAddressValidPfn</a> (PointerPte);
01438                 }
01439 
01440                 <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(IoStatus-&gt;Status)) {
01441 
01442                     <span class="comment">//</span>
01443                     <span class="comment">// The I/O completed successfully, unlock the pages.</span>
01444                     <span class="comment">//</span>
01445 
01446                     <span class="keywordflow">while</span> (Page &lt; LastPage) {
01447 
01448                         Pfn2 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (*Page);
01449                         <a class="code" href="../../d4/d8/mi_8h.html#a189">MI_REMOVE_LOCKED_PAGE_CHARGE</a>(Pfn2, 19);
01450                         <a class="code" href="../../d6/d5/pfndec_8c.html#a2">MiDecrementReferenceCount</a> (*Page);
01451                         Page += 1;
01452                     }
01453                 } <span class="keywordflow">else</span> {
01454 
01455                     <span class="comment">//</span>
01456                     <span class="comment">//  Don't count on the file system to convey anything on errors</span>
01457                     <span class="comment">//  in the information field.</span>
01458                     <span class="comment">//</span>
01459 
01460                     IoStatus-&gt;Information = 0;
01461 
01462                     <span class="comment">//</span>
01463                     <span class="comment">// The I/O completed unsuccessfully, unlock the pages</span>
01464                     <span class="comment">// and return an error status.</span>
01465                     <span class="comment">//</span>
01466 
01467                     <span class="keywordflow">while</span> (Page &lt; LastPage) {
01468 
01469                         Pfn2 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (*Page);
01470 
01471                         <span class="comment">//</span>
01472                         <span class="comment">// Mark the page dirty again so it can be rewritten.</span>
01473                         <span class="comment">//</span>
01474 
01475                         Pfn2-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.Modified = 1;
01476 
01477                         <a class="code" href="../../d4/d8/mi_8h.html#a189">MI_REMOVE_LOCKED_PAGE_CHARGE</a>(Pfn2, 21);
01478                         <a class="code" href="../../d6/d5/pfndec_8c.html#a2">MiDecrementReferenceCount</a> (*Page);
01479                         Page += 1;
01480                     }
01481 
01482                     <span class="comment">//</span>
01483                     <span class="comment">// Calculate how much was written thus far</span>
01484                     <span class="comment">// and add that to the information field</span>
01485                     <span class="comment">// of the IOSB.</span>
01486                     <span class="comment">//</span>
01487 
01488                     IoStatus-&gt;Information +=
01489                         (((LastWritten - StartingPte) &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>) -
01490                                                         Mdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o6">ByteCount</a>);
01491 
01492                     <span class="keywordflow">goto</span> ErrorReturn;
01493                 }
01494 
01495                 <span class="comment">//</span>
01496                 <span class="comment">// As the PFN lock has been released and</span>
01497                 <span class="comment">// reacquired, do this loop again as the</span>
01498                 <span class="comment">// PTE may have changed state.</span>
01499                 <span class="comment">//</span>
01500 
01501                 LastWritten = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01502             }
01503 
01504         } <span class="comment">//end while</span>
01505 
01506         <span class="keywordflow">if</span> ((Bail == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) || (Subsection == LastSubsection)) {
01507 
01508             <span class="comment">//</span>
01509             <span class="comment">// The last range has been flushed or we have collided with the</span>
01510             <span class="comment">// mapped page writer.  Regardless, exit the top FOR loop</span>
01511             <span class="comment">// and return.</span>
01512             <span class="comment">//</span>
01513 
01514             <span class="keywordflow">break</span>;
01515         }
01516 
01517         Subsection = Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o9">NextSubsection</a>;
01518         PointerPte = Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o6">SubsectionBase</a>;
01519 
01520     }  <span class="comment">//end for</span>
01521 
01522     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (LastWritten == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
01523 
01524 ErrorReturn:
01525 
01526     ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o6">FlushInProgressCount</a> -= 1;
01527     <span class="keywordflow">if</span> ((ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o10">u</a>.Flags.CollidedFlush == 1) &amp;&amp;
01528         (ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o6">FlushInProgressCount</a> == 0)) {
01529         ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o10">u</a>.Flags.CollidedFlush = 0;
01530         <a class="code" href="../../d2/d8/eventobj_8c.html#a5">KePulseEvent</a> (&amp;<a class="code" href="../../d4/d8/mi_8h.html#a720">MmCollidedFlushEvent</a>, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
01531     }
01532     <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
01533 
01534     <span class="keywordflow">if</span> (Bail == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01535 
01536         <span class="comment">//</span>
01537         <span class="comment">// This routine collided with the mapped page writer and the caller</span>
01538         <span class="comment">// expects an error for this.  Give it to him.</span>
01539         <span class="comment">//</span>
01540 
01541         <span class="keywordflow">return</span> <a class="code" href="../../d4/d8/mi_8h.html#a247">STATUS_MAPPED_WRITER_COLLISION</a>;
01542     }
01543 
01544     <span class="keywordflow">return</span> IoStatus-&gt;Status;
01545 }
01546 
01547 BOOLEAN
<a name="l01548"></a><a class="code" href="../../d6/d5/flushsec_8c.html#a12">01548</a> <a class="code" href="../../d6/d5/flushsec_8c.html#a12">MmPurgeSection</a> (
01549     IN <a class="code" href="../../d7/d0/struct__SECTION__OBJECT__POINTERS.html">PSECTION_OBJECT_POINTERS</a> SectionObjectPointer,
01550     IN PLARGE_INTEGER Offset,
01551     IN SIZE_T RegionSize,
01552     IN ULONG IgnoreCacheViews
01553     )
01554 
01555 <span class="comment">/*++</span>
01556 <span class="comment"></span>
01557 <span class="comment">Routine Description:</span>
01558 <span class="comment"></span>
01559 <span class="comment">    This function determines if any views of the specified section</span>
01560 <span class="comment">    are mapped, and if not, purges valid pages (even modified ones)</span>
01561 <span class="comment">    from the specified section and returns any used pages to the free</span>
01562 <span class="comment">    list.  This is accomplished by examining the prototype PTEs</span>
01563 <span class="comment">    from the specified offset to the end of the section, and if</span>
01564 <span class="comment">    any prototype PTEs are in the transition state, putting the</span>
01565 <span class="comment">    prototype PTE back into its original state and putting the</span>
01566 <span class="comment">    physical page on the free list.</span>
01567 <span class="comment"></span>
01568 <span class="comment">    NOTE:</span>
01569 <span class="comment"></span>
01570 <span class="comment">    If there is an I/O operation ongoing for one of the pages,</span>
01571 <span class="comment">    that page is eliminated from the segment and allowed to "float"</span>
01572 <span class="comment">    until the i/o is complete.  Once the share count goes to zero</span>
01573 <span class="comment">    the page will be added to the free page list.</span>
01574 <span class="comment"></span>
01575 <span class="comment">Arguments:</span>
01576 <span class="comment"></span>
01577 <span class="comment">    SectionObjectPointer - Supplies a pointer to the section objects.</span>
01578 <span class="comment"></span>
01579 <span class="comment">    Offset - Supplies the offset into the section in which to begin</span>
01580 <span class="comment">             purging pages.  If this argument is not present, then the</span>
01581 <span class="comment">             whole section is purged without regard to the region size</span>
01582 <span class="comment">             argument.</span>
01583 <span class="comment"></span>
01584 <span class="comment"></span>
01585 <span class="comment">    RegionSize - Supplies the size of the region to purge.  If this</span>
01586 <span class="comment">                 is specified as zero and Offset is specified, the</span>
01587 <span class="comment">                 region from Offset to the end of the file is purged.</span>
01588 <span class="comment"></span>
01589 <span class="comment">                 Note: The largest value acceptable for RegionSize is</span>
01590 <span class="comment">                 0xFFFF0000;</span>
01591 <span class="comment"></span>
01592 <span class="comment">    IgnoreCacheViews - Supplies FALSE if mapped views in the system</span>
01593 <span class="comment">                 cache should cause the function to return FALSE.</span>
01594 <span class="comment">                 This is the normal case.</span>
01595 <span class="comment">                 Supplies TRUE if mapped views should be ignored</span>
01596 <span class="comment">                 and the flush should occur.  NOTE THAT IF TRUE</span>
01597 <span class="comment">                 IS SPECIFIED AND ANY DATA PURGED IS CURRENTLY MAPPED</span>
01598 <span class="comment">                 AND VALID A BUGCHECK WILL OCCUR!!</span>
01599 <span class="comment"></span>
01600 <span class="comment">Return Value:</span>
01601 <span class="comment"></span>
01602 <span class="comment">    Returns TRUE if either no section exists for the file object or</span>
01603 <span class="comment">    the section is not mapped and the purge was done, FALSE otherwise.</span>
01604 <span class="comment"></span>
01605 <span class="comment">    Note that FALSE is returned if during the purge operation, a page</span>
01606 <span class="comment">    could not be purged due to a non-zero reference count.</span>
01607 <span class="comment"></span>
01608 <span class="comment">--*/</span>
01609 
01610 {
01611     <a class="code" href="../../d8/d7/struct__CONTROL__AREA.html">PCONTROL_AREA</a> ControlArea;
01612     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
01613     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> LastPte;
01614     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> FinalPte;
01615     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> PteContents;
01616     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
01617     KIRQL OldIrql;
01618     ULONG PteOffset;
01619     <a class="code" href="../../d1/d7/struct__SUBSECTION.html">PSUBSECTION</a> Subsection;
01620     <a class="code" href="../../d1/d7/struct__SUBSECTION.html">PSUBSECTION</a> LastSubsection;
01621     LARGE_INTEGER LocalOffset;
01622     BOOLEAN DeleteSegment = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01623     BOOLEAN LockHeld;
01624     BOOLEAN ReturnValue;
01625     PFN_NUMBER PageFrameIndex;
01626 <span class="preprocessor">#if DBG</span>
01627 <span class="preprocessor"></span>    PFN_NUMBER LastLocked = 0;
01628 <span class="preprocessor">#endif //DBG</span>
01629 <span class="preprocessor"></span>
01630     <span class="comment">//</span>
01631     <span class="comment">// This is needed in case a page is on the mapped page writer list -</span>
01632     <span class="comment">// the PFN lock will need to be released and APCs disabled.</span>
01633     <span class="comment">//</span>
01634 
01635     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (KeGetCurrentIrql() &lt; <a class="code" href="../../d6/d7/halmips_8h.html#a53">DISPATCH_LEVEL</a>);
01636 
01637     <span class="comment">//</span>
01638     <span class="comment">//  Capture caller's file size, since we may modify it.</span>
01639     <span class="comment">//</span>
01640 
01641     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>)) {
01642 
01643         LocalOffset = *<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
01644         <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> = &amp;LocalOffset;
01645     }
01646 
01647     <span class="comment">//</span>
01648     <span class="comment">//  See if we can truncate this file to where the caller wants</span>
01649     <span class="comment">//  us to.</span>
01650     <span class="comment">//</span>
01651 
01652     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/sectsup_8c.html#a31">MiCanFileBeTruncatedInternal</a>(SectionObjectPointer, <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, &amp;OldIrql)) {
01653         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01654     }
01655 
01656     <span class="comment">//</span>
01657     <span class="comment">// PFN LOCK IS NOW HELD!</span>
01658     <span class="comment">//</span>
01659 
01660     ControlArea = (<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html">PCONTROL_AREA</a>)(SectionObjectPointer-&gt;DataSectionObject);
01661     <span class="keywordflow">if</span> (ControlArea == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01662         <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
01663         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01664 
01665     <span class="comment">//</span>
01666     <span class="comment">//  Even though MiCanFileBeTruncatedInternal returned TRUE, there could</span>
01667     <span class="comment">//  still be a system cache mapped view.  We cannot truncate if</span>
01668     <span class="comment">//  the Cache Manager has a view mapped.</span>
01669     <span class="comment">//</span>
01670 
01671     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((IgnoreCacheViews == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
01672             (ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o14">NumberOfSystemCacheViews</a> != 0)) {
01673         <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
01674         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01675     }
01676 
01677     <span class="comment">//</span>
01678     <span class="comment">// Prevent races when the control area is being deleted as the clean</span>
01679     <span class="comment">// path releases the PFN lock midway through.  File objects may still have</span>
01680     <span class="comment">// section object pointers and data section objects that point at this</span>
01681     <span class="comment">// control area, hence the purge can be issued.</span>
01682     <span class="comment">//</span>
01683     <span class="comment">// Check for this and fail the purge as the control area (and the section</span>
01684     <span class="comment">// object pointers/data section objects) will be going away momentarily.</span>
01685     <span class="comment">// Note that even though drivers have these data section objects, no one</span>
01686     <span class="comment">// currently has an open section for this control area and no one is</span>
01687     <span class="comment">// allowed to open one until the clean path finishes.</span>
01688     <span class="comment">//</span>
01689 
01690     <span class="keywordflow">if</span> (ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o10">u</a>.Flags.BeingDeleted == 1) {
01691         <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
01692         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01693     }
01694 
01695     <span class="comment">//</span>
01696     <span class="comment">// Purge the section - locate the subsection which</span>
01697     <span class="comment">// contains the PTEs.</span>
01698     <span class="comment">//</span>
01699 
01700     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o10">u</a>.Flags.GlobalOnlyPerSession == 0);
01701 
01702     Subsection = (<a class="code" href="../../d1/d7/struct__SUBSECTION.html">PSUBSECTION</a>)(ControlArea + 1);
01703 
01704     <span class="keywordflow">if</span> (!ARGUMENT_PRESENT (<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>)) {
01705 
01706         <span class="comment">//</span>
01707         <span class="comment">// If the offset is not specified, flush the complete file ignoring</span>
01708         <span class="comment">// the region size.</span>
01709         <span class="comment">//</span>
01710 
01711         PointerPte = &amp;Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o6">SubsectionBase</a>[0];
01712         RegionSize = 0;
01713 
01714     } <span class="keywordflow">else</span> {
01715 
01716         PteOffset = (ULONG)(<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>-&gt;QuadPart &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
01717 
01718         <span class="comment">//</span>
01719         <span class="comment">// Make sure the PTEs are not in the extended part of the</span>
01720         <span class="comment">// segment.</span>
01721         <span class="comment">//</span>
01722 
01723         <span class="keywordflow">while</span> (PteOffset &gt;= Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o8">PtesInSubsection</a>) {
01724             PteOffset -= Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o8">PtesInSubsection</a>;
01725             Subsection = Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o9">NextSubsection</a>;
01726             <span class="keywordflow">if</span> (Subsection == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01727 
01728                 <span class="comment">//</span>
01729                 <span class="comment">// The offset must be equal to the size of</span>
01730                 <span class="comment">// the section, don't purge anything just return.</span>
01731                 <span class="comment">//</span>
01732 
01733                 <span class="comment">//ASSERT (PteOffset == 0);</span>
01734                 <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
01735                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01736             }
01737         }
01738 
01739         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PteOffset &lt; Subsection-&gt;PtesInSubsection);
01740         PointerPte = &amp;Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o6">SubsectionBase</a>[PteOffset];
01741     }
01742 
01743 
01744     <span class="comment">//</span>
01745     <span class="comment">// Locate the address of the last prototype PTE to be flushed.</span>
01746     <span class="comment">//</span>
01747 
01748     <span class="keywordflow">if</span> (RegionSize == 0) {
01749 
01750         <span class="comment">//</span>
01751         <span class="comment">// Flush to end of section.</span>
01752         <span class="comment">//</span>
01753 
01754         LastSubsection = Subsection;
01755         <span class="keywordflow">while</span> (LastSubsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o9">NextSubsection</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01756             LastSubsection = LastSubsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o9">NextSubsection</a>;
01757         }
01758 
01759         <span class="comment">//</span>
01760         <span class="comment">// Set the final PTE to 1 beyond the last page.</span>
01761         <span class="comment">//</span>
01762 
01763         FinalPte = &amp;LastSubsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o6">SubsectionBase</a>
01764                             [LastSubsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o8">PtesInSubsection</a>];
01765     } <span class="keywordflow">else</span> {
01766 
01767         <span class="comment">//</span>
01768         <span class="comment">// Calculate the end of the region.</span>
01769         <span class="comment">//</span>
01770 
01771         PteOffset +=
01772             (ULONG) (((RegionSize + <a class="code" href="../../d2/d1/mm_8h.html#a6">BYTE_OFFSET</a>(<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>-&gt;LowPart)) - 1) &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
01773 
01774         LastSubsection = Subsection;
01775 
01776         <span class="keywordflow">while</span> (PteOffset &gt;= LastSubsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o8">PtesInSubsection</a>) {
01777             PteOffset -= LastSubsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o8">PtesInSubsection</a>;
01778             <span class="keywordflow">if</span> (LastSubsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o9">NextSubsection</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01779                 PteOffset = LastSubsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o8">PtesInSubsection</a> - 1;
01780                 <span class="keywordflow">break</span>;
01781             }
01782             LastSubsection = LastSubsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o9">NextSubsection</a>;
01783         }
01784 
01785         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PteOffset &lt; LastSubsection-&gt;PtesInSubsection);
01786 
01787         <span class="comment">//</span>
01788         <span class="comment">// Point final PTE to 1 beyond the end.</span>
01789         <span class="comment">//</span>
01790 
01791         FinalPte = &amp;LastSubsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o6">SubsectionBase</a>[PteOffset + 1];
01792     }
01793 
01794     <span class="comment">//</span>
01795     <span class="comment">// Increment the number of mapped views to</span>
01796     <span class="comment">// prevent the section from being deleted while the purge is</span>
01797     <span class="comment">// in progress.</span>
01798     <span class="comment">//</span>
01799 
01800     ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o4">NumberOfMappedViews</a> += 1;
01801 
01802     <span class="comment">//</span>
01803     <span class="comment">// Set being purged so no one can map a view</span>
01804     <span class="comment">// while the purge is going on.</span>
01805     <span class="comment">//</span>
01806 
01807     ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o10">u</a>.Flags.BeingPurged = 1;
01808     ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o10">u</a>.Flags.WasPurged = 1;
01809 
01810     <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
01811     LockHeld = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01812     ReturnValue = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01813 
01814     <span class="keywordflow">for</span> (;;) {
01815 
01816         <span class="keywordflow">if</span> (LastSubsection != Subsection) {
01817 
01818             <span class="comment">//</span>
01819             <span class="comment">// Flush to the last PTE in this subsection.</span>
01820             <span class="comment">//</span>
01821 
01822             LastPte = &amp;Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o6">SubsectionBase</a>[Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o8">PtesInSubsection</a>];
01823         } <span class="keywordflow">else</span> {
01824 
01825             <span class="comment">//</span>
01826             <span class="comment">// Flush to the end of the range.</span>
01827             <span class="comment">//</span>
01828 
01829             LastPte = FinalPte;
01830         }
01831 
01832         <span class="comment">//</span>
01833         <span class="comment">// If the page table page containing the PTEs is not</span>
01834         <span class="comment">// resident, then no PTEs can be in the valid or transition</span>
01835         <span class="comment">// state!  Skip over the PTEs.</span>
01836         <span class="comment">//</span>
01837 
01838         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/sectsup_8c.html#a11">MiCheckProtoPtePageState</a>(PointerPte, LockHeld)) {
01839             PointerPte = (<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)(((ULONG_PTR)PointerPte | (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) + 1);
01840         }
01841 
01842         <span class="keywordflow">while</span> (PointerPte &lt; LastPte) {
01843 
01844             <span class="comment">//</span>
01845             <span class="comment">// If the page table page containing the PTEs is not</span>
01846             <span class="comment">// resident, then no PTEs can be in the valid or transition</span>
01847             <span class="comment">// state!  Skip over the PTEs.</span>
01848             <span class="comment">//</span>
01849 
01850             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a167">MiIsPteOnPdeBoundary</a>(PointerPte)) {
01851                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/sectsup_8c.html#a11">MiCheckProtoPtePageState</a>(PointerPte, LockHeld)) {
01852                     PointerPte = (<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)((PCHAR)PointerPte + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
01853                     <span class="keywordflow">continue</span>;
01854                 }
01855             }
01856 
01857             PteContents = *PointerPte;
01858 
01859             <span class="keywordflow">if</span> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1) {
01860 
01861                 <span class="comment">//</span>
01862                 <span class="comment">// A valid PTE was found, it must be mapped in the</span>
01863                 <span class="comment">// system cache.  Just exit the loop and return FALSE</span>
01864                 <span class="comment">// and let the caller fix this.</span>
01865                 <span class="comment">//</span>
01866 
01867                 ReturnValue = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01868                 <span class="keywordflow">break</span>;
01869             }
01870 
01871             <span class="keywordflow">if</span> ((PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Prototype == 0) &amp;&amp;
01872                      (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Transition == 1)) {
01873 
01874                 <span class="keywordflow">if</span> (!LockHeld) {
01875                     LockHeld = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01876                     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
01877                     <a class="code" href="../../d0/d2/mmsup_8c.html#a11">MiMakeSystemAddressValidPfn</a> (PointerPte);
01878                     <span class="keywordflow">continue</span>;
01879                 }
01880 
01881                 PageFrameIndex = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a183">MI_GET_PAGE_FRAME_FROM_TRANSITION_PTE</a>(&amp;PteContents);
01882                 Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PageFrameIndex);
01883 
01884                 <span class="keywordflow">if</span> ((Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Prototype != 1) ||
01885                     (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid != 0) ||
01886                     (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> != PointerPte)) {
01887 
01888                     <span class="comment">//</span>
01889                     <span class="comment">// The pool containing the prototype PTEs has been</span>
01890                     <span class="comment">// corrupted.  Pool corruption like this is fatal.</span>
01891                     <span class="comment">//</span>
01892 
01893                     <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a> (POOL_CORRUPTION_IN_FILE_AREA,
01894                                   0x2,
01895                                   (ULONG_PTR)PointerPte,
01896                                   (ULONG_PTR)Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a>,
01897                                   (ULONG_PTR)PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long);
01898                 }
01899 
01900 <span class="preprocessor">#if DBG</span>
01901 <span class="preprocessor"></span>                <span class="keywordflow">if</span> ((Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount != 0) &amp;&amp;
01902                     (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.WriteInProgress == 0)) {
01903 
01904                     <span class="comment">//</span>
01905                     <span class="comment">// There must be an I/O in progress on this</span>
01906                     <span class="comment">// page.</span>
01907                     <span class="comment">//</span>
01908 
01909                     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a183">MI_GET_PAGE_FRAME_FROM_TRANSITION_PTE</a>(&amp;PteContents) != LastLocked) {
01910                         <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
01911 
01912 <span class="preprocessor">#if DBG</span>
01913 <span class="preprocessor"></span>                        <span class="keywordflow">if</span> (MmDebug &amp; <a class="code" href="../../d4/d8/mi_8h.html#a71">MM_DBG_FLUSH_SECTION</a>) {
01914                             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"MM:PURGE - page %lx locked, file:%Z\n"</span>,
01915                                     PageFrameIndex,
01916                                     &amp;ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o11">FilePointer</a>-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>
01917                                 );
01918                         }
01919 <span class="preprocessor">#endif</span>
01920 <span class="preprocessor"></span>                        LastLocked = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a183">MI_GET_PAGE_FRAME_FROM_TRANSITION_PTE</a> (&amp;PteContents);
01921                         <span class="comment">//DbgBreakPoint();</span>
01922                         <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
01923                         <a class="code" href="../../d0/d2/mmsup_8c.html#a11">MiMakeSystemAddressValidPfn</a> (PointerPte);
01924                         <span class="keywordflow">continue</span>;
01925                     }
01926                 }
01927 <span class="preprocessor">#endif //DBG</span>
01928 <span class="preprocessor"></span>
01929                 <span class="comment">//</span>
01930                 <span class="comment">// If the modified page writer has page locked for I/O</span>
01931                 <span class="comment">// wait for the I/O's to be completed and the pages</span>
01932                 <span class="comment">// to be unlocked.  The eliminates a race condition</span>
01933                 <span class="comment">// when the modified page writer locks the pages, then</span>
01934                 <span class="comment">// a purge occurs and completes before the mapped</span>
01935                 <span class="comment">// writer thread runs.</span>
01936                 <span class="comment">//</span>
01937 
01938                 <span class="keywordflow">if</span> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.WriteInProgress == 1) {
01939 
01940                     <span class="comment">//</span>
01941                     <span class="comment">// A 3 or more thread deadlock can occur where:</span>
01942                     <span class="comment">//</span>
01943                     <span class="comment">// 1.  The mapped page writer thread has issued a write</span>
01944                     <span class="comment">//     and is in the filesystem code waiting for a resource.</span>
01945                     <span class="comment">//</span>
01946                     <span class="comment">// 2.  Thread 2 owns the resource above but is waiting for</span>
01947                     <span class="comment">//     the filesystem's quota mutex.</span>
01948                     <span class="comment">//</span>
01949                     <span class="comment">// 3.  Thread 3 owns the quota mutex and is right here</span>
01950                     <span class="comment">//     doing a purge from the cache manager when he notices</span>
01951                     <span class="comment">//     the page to be purged is either already being written</span>
01952                     <span class="comment">//     or is in the mapped page writer list.  If it is</span>
01953                     <span class="comment">//     already being written everything will unjam.  If it</span>
01954                     <span class="comment">//     is still on the mapped page writer list awaiting</span>
01955                     <span class="comment">//     processing, then it must be cancelled - otherwise</span>
01956                     <span class="comment">//     if this thread were to wait, deadlock can occur.</span>
01957                     <span class="comment">//</span>
01958                     <span class="comment">// The alternative to all this is for the filesystems to</span>
01959                     <span class="comment">// always release the quota mutex before purging but the</span>
01960                     <span class="comment">// filesystem overhead to do this is substantial.</span>
01961                     <span class="comment">//</span>
01962 
01963                     <span class="keywordflow">if</span> (<a class="code" href="../../d6/d3/modwrite_8c.html#a50">MiCancelWriteOfMappedPfn</a> (PageFrameIndex) == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01964 
01965                         <span class="comment">//</span>
01966                         <span class="comment">// Stopping any failed writes (even deliberately</span>
01967                         <span class="comment">// cancelled ones) automatically cause a delay.  A</span>
01968                         <span class="comment">// successful stop also results in the PFN lock</span>
01969                         <span class="comment">// being released and reacquired.  So loop back to</span>
01970                         <span class="comment">// the top now as the world may have changed.</span>
01971                         <span class="comment">//</span>
01972 
01973                         <a class="code" href="../../d0/d2/mmsup_8c.html#a11">MiMakeSystemAddressValidPfn</a> (PointerPte);
01974                         <span class="keywordflow">continue</span>;
01975                     }
01976 
01977                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o13">ModifiedWriteCount</a> != 0);
01978                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount != 0);
01979 
01980                     ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o10">u</a>.Flags.SetMappedFileIoComplete = 1;
01981 
01982                     <a class="code" href="../../d4/d9/ke_8h.html#a28">KeEnterCriticalRegion</a>();
01983                     <a class="code" href="../../d4/d8/mi_8h.html#a132">UNLOCK_PFN_AND_THEN_WAIT</a>(OldIrql);
01984 
01985                     <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>(&amp;<a class="code" href="../../d4/d8/mi_8h.html#a614">MmMappedFileIoComplete</a>,
01986                                           <a class="code" href="../../d4/d9/ke_8h.html#a407a217">WrPageOut</a>,
01987                                           <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
01988                                           <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01989                                           (PLARGE_INTEGER)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
01990                     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
01991                     <a class="code" href="../../d4/d9/ke_8h.html#a29">KeLeaveCriticalRegion</a>();
01992                     <a class="code" href="../../d0/d2/mmsup_8c.html#a11">MiMakeSystemAddressValidPfn</a> (PointerPte);
01993                     <span class="keywordflow">continue</span>;
01994                 }
01995 
01996                 <span class="keywordflow">if</span> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.ReadInProgress == 1) {
01997 
01998                     <span class="comment">//</span>
01999                     <span class="comment">// The page currently is being read in from the</span>
02000                     <span class="comment">// disk.  Treat this just like a valid PTE and</span>
02001                     <span class="comment">// return false.</span>
02002                     <span class="comment">//</span>
02003 
02004                     ReturnValue = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02005                     <span class="keywordflow">break</span>;
02006                 }
02007 
02008                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (!((Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Prototype == 0) &amp;&amp;
02009                     (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Transition == 1)));
02010 
02011                 <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a187">MI_WRITE_INVALID_PTE</a> (PointerPte, Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>);
02012 
02013                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 0);
02014 
02015                 ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o3">NumberOfPfnReferences</a> -= 1;
02016                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((LONG)ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o3">NumberOfPfnReferences</a> &gt;= 0);
02017 
02018                 <a class="code" href="../../d7/d5/pfnlist_8c.html#a11">MiUnlinkPageFromList</a> (Pfn1);
02019 
02020                 <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a120">MI_SET_PFN_DELETED</a> (Pfn1);
02021 
02022                 <a class="code" href="../../d6/d5/pfndec_8c.html#a1">MiDecrementShareCount</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o17">PteFrame</a>);
02023 
02024                 <span class="comment">//</span>
02025                 <span class="comment">// If the reference count for the page is zero, insert</span>
02026                 <span class="comment">// it into the free page list, otherwise leave it alone</span>
02027                 <span class="comment">// and when the reference count is decremented to zero</span>
02028                 <span class="comment">// the page will go to the free list.</span>
02029                 <span class="comment">//</span>
02030 
02031                 <span class="keywordflow">if</span> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount == 0) {
02032                     <a class="code" href="../../d4/d8/mi_8h.html#a889">MiReleasePageFileSpace</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o16">OriginalPte</a>);
02033                     <a class="code" href="../../d7/d5/pfnlist_8c.html#a8">MiInsertPageInList</a> (<a class="code" href="../../d4/d8/mi_8h.html#a606">MmPageLocationList</a>[<a class="code" href="../../d2/d1/mm_8h.html#a345a172">FreePageList</a>],
02034                                         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a183">MI_GET_PAGE_FRAME_FROM_TRANSITION_PTE</a> (&amp;PteContents));
02035                 }
02036             }
02037             PointerPte += 1;
02038 
02039             <span class="keywordflow">if</span> ((<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a167">MiIsPteOnPdeBoundary</a>(PointerPte)) &amp;&amp; (LockHeld)) {
02040 
02041                 <span class="comment">//</span>
02042                 <span class="comment">// Unlock PFN so large requests will not block other</span>
02043                 <span class="comment">// threads on MP systems.</span>
02044                 <span class="comment">//</span>
02045 
02046                 <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
02047                 LockHeld = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02048             }
02049 
02050         } <span class="comment">//end while</span>
02051 
02052         <span class="keywordflow">if</span> (LockHeld) {
02053             <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
02054             LockHeld = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02055         }
02056 
02057         <span class="keywordflow">if</span> ((LastSubsection != Subsection) &amp;&amp; (ReturnValue)) {
02058 
02059             <span class="comment">//</span>
02060             <span class="comment">// Get the next subsection in the list.</span>
02061             <span class="comment">//</span>
02062 
02063             Subsection = Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o9">NextSubsection</a>;
02064             PointerPte = Subsection-&gt;<a class="code" href="../../d1/d7/struct__SUBSECTION.html#o6">SubsectionBase</a>;
02065 
02066         } <span class="keywordflow">else</span> {
02067 
02068             <span class="comment">//</span>
02069             <span class="comment">// The last range has been flushed, exit the top FOR loop</span>
02070             <span class="comment">// and return.</span>
02071             <span class="comment">//</span>
02072 
02073             <span class="keywordflow">break</span>;
02074         }
02075     }  <span class="comment">//end for</span>
02076 
02077     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
02078 
02079     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((LONG)ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o4">NumberOfMappedViews</a> &gt;= 1);
02080     ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o4">NumberOfMappedViews</a> -= 1;
02081 
02082     ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o10">u</a>.Flags.BeingPurged = 0;
02083 
02084     <span class="comment">//</span>
02085     <span class="comment">// Check to see if the control area should be deleted.  This</span>
02086     <span class="comment">// will release the PFN lock.</span>
02087     <span class="comment">//</span>
02088 
02089     <a class="code" href="../../d5/d5/sectsup_8c.html#a24">MiCheckControlArea</a> (ControlArea, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, OldIrql);
02090     <span class="keywordflow">return</span> ReturnValue;
02091 }
02092 
02093 BOOLEAN
<a name="l02094"></a><a class="code" href="../../d6/d5/flushsec_8c.html#a13">02094</a> <a class="code" href="../../d6/d5/flushsec_8c.html#a13">MmFlushImageSection</a> (
02095     IN <a class="code" href="../../d7/d0/struct__SECTION__OBJECT__POINTERS.html">PSECTION_OBJECT_POINTERS</a> SectionPointer,
02096     IN <a class="code" href="../../d2/d1/mm_8h.html#a153">MMFLUSH_TYPE</a> FlushType
02097     )
02098 
02099 <span class="comment">/*++</span>
02100 <span class="comment"></span>
02101 <span class="comment">Routine Description:</span>
02102 <span class="comment"></span>
02103 <span class="comment">    This function determines if any views of the specified image section</span>
02104 <span class="comment">    are mapped, and if not, flushes valid pages (even modified ones)</span>
02105 <span class="comment">    from the specified section and returns any used pages to the free</span>
02106 <span class="comment">    list.  This is accomplished by examining the prototype PTEs</span>
02107 <span class="comment">    from the specified offset to the end of the section, and if</span>
02108 <span class="comment">    any prototype PTEs are in the transition state, putting the</span>
02109 <span class="comment">    prototype PTE back into its original state and putting the</span>
02110 <span class="comment">    physical page on the free list.</span>
02111 <span class="comment"></span>
02112 <span class="comment">Arguments:</span>
02113 <span class="comment"></span>
02114 <span class="comment">    SectionPointer - Supplies a pointer to a section object pointers</span>
02115 <span class="comment">                     within the FCB.</span>
02116 <span class="comment"></span>
02117 <span class="comment">    FlushType - Supplies the type of flush to check for.  One of</span>
02118 <span class="comment">                MmFlushForDelete or MmFlushForWrite.</span>
02119 <span class="comment"></span>
02120 <span class="comment">Return Value:</span>
02121 <span class="comment"></span>
02122 <span class="comment">    Returns TRUE if either no section exists for the file object or</span>
02123 <span class="comment">    the section is not mapped and the purge was done, FALSE otherwise.</span>
02124 <span class="comment"></span>
02125 <span class="comment">--*/</span>
02126 
02127 {
02128     PLIST_ENTRY Next;
02129     <a class="code" href="../../d8/d7/struct__CONTROL__AREA.html">PCONTROL_AREA</a> ControlArea;
02130     <a class="code" href="../../d6/d8/struct__LARGE__CONTROL__AREA.html">PLARGE_CONTROL_AREA</a> LargeControlArea;
02131     KIRQL OldIrql;
02132     BOOLEAN state;
02133     BOOLEAN FinalControlArea;
02134 
02135 
02136     <span class="keywordflow">if</span> (FlushType == <a class="code" href="../../d2/d1/mm_8h.html#a346a179">MmFlushForDelete</a>) {
02137 
02138         <span class="comment">//</span>
02139         <span class="comment">// Do a quick check to see if there are any mapped views for</span>
02140         <span class="comment">// the data section.  If so, just return FALSE.</span>
02141         <span class="comment">//</span>
02142 
02143         <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
02144         ControlArea = (<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html">PCONTROL_AREA</a>)(SectionPointer-&gt;DataSectionObject);
02145         <span class="keywordflow">if</span> (ControlArea != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02146             <span class="keywordflow">if</span> ((ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o7">NumberOfUserReferences</a> != 0) ||
02147                 (ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o10">u</a>.Flags.BeingCreated)) {
02148                 <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
02149                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02150             }
02151         }
02152         <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
02153     }
02154 
02155     <span class="comment">//</span>
02156     <span class="comment">// Check the status of the control area.  If the control area is in use</span>
02157     <span class="comment">// or the control area is being deleted, this operation cannot continue.</span>
02158     <span class="comment">//</span>
02159 
02160     state = <a class="code" href="../../d5/d5/sectsup_8c.html#a26">MiCheckControlAreaStatus</a> (<a class="code" href="../../d4/d8/mi_8h.html#a1002a766">CheckImageSection</a>,
02161                                       SectionPointer,
02162                                       <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
02163                                       &amp;ControlArea,
02164                                       &amp;OldIrql);
02165 
02166     <span class="keywordflow">if</span> (ControlArea == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02167         <span class="keywordflow">return</span> state;
02168     }
02169 
02170     <span class="comment">//</span>
02171     <span class="comment">// PFN LOCK IS NOW HELD!</span>
02172     <span class="comment">//</span>
02173 
02174     <span class="comment">//</span>
02175     <span class="comment">// Repeat until there are no more control areas - multiple control areas</span>
02176     <span class="comment">// for the same image section occur to support user global DLLs - these DLLs</span>
02177     <span class="comment">// require data that is shared within a session but not across sessions.</span>
02178     <span class="comment">// Note this can only happen for Hydra.</span>
02179     <span class="comment">//</span>
02180 
02181     <span class="keywordflow">do</span> {
02182 
02183         <span class="comment">//</span>
02184         <span class="comment">// Set the being deleted flag and up the number of mapped views</span>
02185         <span class="comment">// for the segment.  Upping the number of mapped views prevents</span>
02186         <span class="comment">// the segment from being deleted and passed to the deletion thread</span>
02187         <span class="comment">// while we are forcing a delete.</span>
02188         <span class="comment">//</span>
02189 
02190         ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o10">u</a>.Flags.BeingDeleted = 1;
02191         ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o4">NumberOfMappedViews</a> = 1;
02192         FinalControlArea = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02193 
02194         <span class="keywordflow">if</span> (<a class="code" href="../../d4/d8/mi_8h.html#a581">MiHydra</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
02195             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (ControlArea ==
02196                     (<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html">PCONTROL_AREA</a>)SectionPointer-&gt;ImageSectionObject);
02197         }
02198 
02199         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ControlArea-&gt;<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html#o10">u</a>.Flags.GlobalOnlyPerSession == 0) {
02200         }
02201         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (IsListEmpty(&amp;((<a class="code" href="../../d6/d8/struct__LARGE__CONTROL__AREA.html">PLARGE_CONTROL_AREA</a>)ControlArea)-&gt;UserGlobalList)) {
02202             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (ControlArea ==
02203                     (<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html">PCONTROL_AREA</a>)SectionPointer-&gt;ImageSectionObject);
02204         }
02205         <span class="keywordflow">else</span> {
02206 
02207             <span class="comment">//</span>
02208             <span class="comment">// Check if there's only one image section in this control area, so</span>
02209             <span class="comment">// we don't reference the section object pointers as the</span>
02210             <span class="comment">// MiCleanSection call may result in its deletion.</span>
02211             <span class="comment">//</span>
02212 
02213             FinalControlArea = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02214 
02215             <span class="comment">//</span>
02216             <span class="comment">// There are multiple control areas, bump the reference count</span>
02217             <span class="comment">// on one of them (doesn't matter which one) so that it can't</span>
02218             <span class="comment">// go away.  This ensures the section object pointers will stick</span>
02219             <span class="comment">// around even after the calls below so we can safely reloop to</span>
02220             <span class="comment">// flush any other remaining control areas.</span>
02221             <span class="comment">//</span>
02222 
02223             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (ControlArea-&gt;<a class="code" href="../../d6/d8/struct__LARGE__CONTROL__AREA.html#o10">u</a>.Flags.GlobalOnlyPerSession == 1);
02224 
02225             Next = ((<a class="code" href="../../d6/d8/struct__LARGE__CONTROL__AREA.html">PLARGE_CONTROL_AREA</a>)ControlArea)-&gt;UserGlobalList.Flink;
02226 
02227             LargeControlArea = CONTAINING_RECORD (Next,
02228                                                   <a class="code" href="../../d6/d8/struct__LARGE__CONTROL__AREA.html">LARGE_CONTROL_AREA</a>,
02229                                                   UserGlobalList);
02230         
02231             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (LargeControlArea-&gt;<a class="code" href="../../d6/d8/struct__LARGE__CONTROL__AREA.html#o10">u</a>.Flags.GlobalOnlyPerSession == 1);
02232 
02233             LargeControlArea-&gt;<a class="code" href="../../d6/d8/struct__LARGE__CONTROL__AREA.html#o2">NumberOfSectionReferences</a> += 1;
02234         }
02235 
02236         <span class="comment">//</span>
02237         <span class="comment">// This is a page file backed or image segment.  The segment is being</span>
02238         <span class="comment">// deleted, remove all references to the paging file and physical</span>
02239         <span class="comment">// memory.</span>
02240         <span class="comment">//</span>
02241 
02242         <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
02243 
02244         <a class="code" href="../../d5/d5/sectsup_8c.html#a22">MiCleanSection</a> (ControlArea, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
02245 
02246         <span class="comment">//</span>
02247         <span class="comment">// Get the next Hydra control area.</span>
02248         <span class="comment">//</span>
02249 
02250         <span class="keywordflow">if</span> (FinalControlArea == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
02251             state = <a class="code" href="../../d5/d5/sectsup_8c.html#a26">MiCheckControlAreaStatus</a> (<a class="code" href="../../d4/d8/mi_8h.html#a1002a766">CheckImageSection</a>,
02252                                               SectionPointer,
02253                                               <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
02254                                               &amp;ControlArea,
02255                                               &amp;OldIrql);
02256             <span class="keywordflow">if</span> (!ControlArea) {
02257                 <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
02258                 LargeControlArea-&gt;<a class="code" href="../../d6/d8/struct__LARGE__CONTROL__AREA.html#o2">NumberOfSectionReferences</a> -= 1;
02259                 <a class="code" href="../../d5/d5/sectsup_8c.html#a24">MiCheckControlArea</a> ((<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html">PCONTROL_AREA</a>)LargeControlArea,
02260                                     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
02261                                     OldIrql);
02262             }
02263             <span class="keywordflow">else</span> {
02264                 LargeControlArea-&gt;<a class="code" href="../../d6/d8/struct__LARGE__CONTROL__AREA.html#o2">NumberOfSectionReferences</a> -= 1;
02265                 <a class="code" href="../../d5/d5/sectsup_8c.html#a24">MiCheckControlArea</a> ((<a class="code" href="../../d8/d7/struct__CONTROL__AREA.html">PCONTROL_AREA</a>)LargeControlArea,
02266                                     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
02267                                     OldIrql);
02268                 <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
02269             }
02270         } <span class="keywordflow">else</span> {
02271             state = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02272             <span class="keywordflow">break</span>;
02273         }
02274 
02275     } <span class="keywordflow">while</span> (ControlArea);
02276 
02277     <span class="keywordflow">return</span> state;
02278 }
02279 
02280 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02281"></a><a class="code" href="../../d6/d5/flushsec_8c.html#a2">02281</a> <a class="code" href="../../d6/d5/flushsec_8c.html#a2">MiFlushDirtyBitsToPfn</a> (
02282     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte,
02283     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> LastPte,
02284     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process,
02285     IN BOOLEAN SystemCache
02286     )
02287 
02288 {
02289     KIRQL OldIrql;
02290     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> PteContents;
02291     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
02292     PVOID Va;
02293     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPde;
02294     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPpe;
02295     ULONG Waited;
02296 
02297     Va = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPte);
02298     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
02299 
02300     <span class="keywordflow">while</span> (PointerPte &lt;= LastPte) {
02301 
02302         PteContents = *PointerPte;
02303 
02304         <span class="keywordflow">if</span> ((PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1) &amp;&amp;
02305             (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a114">MI_IS_PTE_DIRTY</a> (PteContents))) {
02306 
02307             <span class="comment">//</span>
02308             <span class="comment">// Flush the modify bit to the PFN database.</span>
02309             <span class="comment">//</span>
02310 
02311             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
02312             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.Modified = 1;
02313 
02314             <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a113">MI_SET_PTE_CLEAN</a> (PteContents);
02315 
02316             <span class="comment">//</span>
02317             <span class="comment">// No need to capture the PTE contents as we are going to</span>
02318             <span class="comment">// write the page anyway and the Modify bit will be cleared</span>
02319             <span class="comment">// before the write is done.</span>
02320             <span class="comment">//</span>
02321 
02322             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d0/d6/ppc_2flushtb_8c.html#a2">KeFlushSingleTb</a> (Va,
02323                                    <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
02324                                    SystemCache,
02325                                    (PHARDWARE_PTE)PointerPte,
02326                                    PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Flush);
02327         }
02328 
02329         Va = (PVOID)((PCHAR)Va + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
02330         PointerPte += 1;
02331 
02332         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a167">MiIsPteOnPdeBoundary</a> (PointerPte)) {
02333 
02334             PointerPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (PointerPte);
02335 
02336             <span class="keywordflow">while</span> (PointerPte &lt;= LastPte) {
02337 
02338                 PointerPpe = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (PointerPde);
02339 
02340                 <span class="keywordflow">if</span> (!<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a168">MiDoesPpeExistAndMakeValid</a> (PointerPpe,
02341                                                  Process,
02342                                                  <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
02343                                                  &amp;Waited)) {
02344 
02345                     <span class="comment">//</span>
02346                     <span class="comment">// No page directory page exists for this address.</span>
02347                     <span class="comment">//</span>
02348 
02349                     PointerPpe += 1;
02350 
02351                     PointerPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPpe);
02352                     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPde);
02353                 }
02354                 <span class="keywordflow">else</span> {
02355 
02356                     Waited = 0;
02357 
02358                     <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d2/mmsup_8c.html#a6">MiDoesPdeExistAndMakeValid</a> (PointerPde,
02359                                                      Process,
02360                                                      <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
02361                                                      &amp;Waited)) {
02362 
02363                         <span class="comment">//</span>
02364                         <span class="comment">// No page table page exists for this address.</span>
02365                         <span class="comment">//</span>
02366 
02367                         PointerPde += 1;
02368 
02369                         PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPde);
02370                     }
02371                     <span class="keywordflow">else</span> {
02372 
02373                         <span class="comment">//</span>
02374                         <span class="comment">// If the PFN lock (and accordingly the WS mutex) was</span>
02375                         <span class="comment">// released and reacquired we must retry the operation.</span>
02376                         <span class="comment">//</span>
02377 
02378                         <span class="keywordflow">if</span> (Waited != 0) {
02379                             <span class="keywordflow">continue</span>;
02380                         }
02381 
02382                         <span class="comment">//</span>
02383                         <span class="comment">// The PFN lock has been held since we acquired the</span>
02384                         <span class="comment">// page directory parent, ie: this PTE we can operate on</span>
02385                         <span class="comment">// immediately.</span>
02386                         <span class="comment">//</span>
02387 
02388                         <span class="keywordflow">break</span>;
02389                     }
02390                 }
02391             }
02392 
02393             Va = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPte);
02394         }
02395     }
02396 
02397     <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
02398     <span class="keywordflow">return</span>;
02399 }
02400 
02401 <a class="code" href="../../d1/d7/struct__SUBSECTION.html">PSUBSECTION</a>
<a name="l02402"></a><a class="code" href="../../d6/d5/flushsec_8c.html#a1">02402</a> <a class="code" href="../../d6/d5/flushsec_8c.html#a1">MiGetSystemCacheSubsection</a> (
02403     IN PVOID BaseAddress,
02404     IN <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process,
02405     OUT <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> *ProtoPte
02406     )
02407 
02408 {
02409     KIRQL OldIrql;
02410     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
02411     <a class="code" href="../../d1/d7/struct__SUBSECTION.html">PSUBSECTION</a> Subsection;
02412 
02413     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
02414 
02415     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (BaseAddress);
02416 
02417     Subsection = <a class="code" href="../../d0/d2/mmsup_8c.html#a16">MiGetSubsectionAndProtoFromPte</a> (PointerPte,
02418                                                  ProtoPte,
02419                                                  Process);
02420     <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
02421     <span class="keywordflow">return</span> Subsection;
02422 }
02423 
02424 
02425 ULONG
02426 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l02427"></a><a class="code" href="../../d6/d5/flushsec_8c.html#a3">02427</a> <a class="code" href="../../d5/d5/sectsup_8c.html#a11">MiCheckProtoPtePageState</a> (
02428     IN <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PrototypePte,
02429     IN ULONG PfnLockHeld
02430     )
02431 
02432 <span class="comment">/*++</span>
02433 <span class="comment"></span>
02434 <span class="comment">Routine Description:</span>
02435 <span class="comment"></span>
02436 <span class="comment">    Checks the state of the page containing the specified</span>
02437 <span class="comment">    prototype PTE.</span>
02438 <span class="comment"></span>
02439 <span class="comment">    If the page is valid or transition and has transition or valid prototype</span>
02440 <span class="comment">    PTEs contained with it, TRUE is returned and the page is made valid</span>
02441 <span class="comment">    (if transition).  Otherwise return FALSE indicating no prototype</span>
02442 <span class="comment">    PTEs within this page are of interest.</span>
02443 <span class="comment"></span>
02444 <span class="comment">Arguments:</span>
02445 <span class="comment"></span>
02446 <span class="comment">    PrototypePte - Supplies a pointer to a prototype PTE within the page.</span>
02447 <span class="comment"></span>
02448 <span class="comment">Return Value:</span>
02449 <span class="comment"></span>
02450 <span class="comment">    TRUE if the page containing the proto PTE was made resident.</span>
02451 <span class="comment">    FALSE if otherwise.</span>
02452 <span class="comment"></span>
02453 <span class="comment">--*/</span>
02454 
02455 {
02456     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
02457     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> PteContents;
02458     PFN_NUMBER PageFrameIndex;
02459     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn;
02460 
02461 <span class="preprocessor">#if defined (_WIN64)</span>
02462 <span class="preprocessor"></span>    <span class="comment">//</span>
02463     <span class="comment">// First check whether the page directory page is present.  Since there</span>
02464     <span class="comment">// is no lazy loading of PPEs, the validity check alone is sufficient.</span>
02465     <span class="comment">//</span>
02466 
02467     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a151">MiGetPdeAddress</a>(<a class="code" href="../../d4/d2/datalpha_8c.html#a12">PrototypePte</a>);
02468     PteContents = *PointerPte;
02469 
02470     <span class="keywordflow">if</span> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 0) {
02471         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02472     }
02473 <span class="preprocessor">#endif</span>
02474 <span class="preprocessor"></span>
02475     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(<a class="code" href="../../d4/d2/datalpha_8c.html#a12">PrototypePte</a>);
02476 <span class="preprocessor">#if !defined (_WIN64)</span>
02477 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (PointerPte-&gt;u.Hard.Valid == 0) {
02478         <a class="code" href="../../d8/d2/pagfault_8c.html#a20">MiCheckPdeForPagedPool</a> (<a class="code" href="../../d4/d2/datalpha_8c.html#a12">PrototypePte</a>);
02479     }
02480 <span class="preprocessor">#endif</span>
02481 <span class="preprocessor"></span>    PteContents = *PointerPte;
02482 
02483     <span class="keywordflow">if</span> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1) {
02484         PageFrameIndex = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a> (&amp;PteContents);
02485         Pfn = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PageFrameIndex);
02486         <span class="keywordflow">if</span> (Pfn-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount != 1) {
02487             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02488         }
02489     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Prototype == 0) &amp;&amp;
02490                (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Soft.Transition == 1)) {
02491 
02492         <span class="comment">//</span>
02493         <span class="comment">// Transition, if on standby or modified, return false.</span>
02494         <span class="comment">//</span>
02495 
02496         PageFrameIndex = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a183">MI_GET_PAGE_FRAME_FROM_TRANSITION_PTE</a> (&amp;PteContents);
02497         Pfn = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PageFrameIndex);
02498         <span class="keywordflow">if</span> (Pfn-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageLocation &gt;= <a class="code" href="../../d2/d1/mm_8h.html#a345a177">ActiveAndValid</a>) {
02499             <span class="keywordflow">if</span> (PfnLockHeld) {
02500                 <a class="code" href="../../d0/d2/mmsup_8c.html#a11">MiMakeSystemAddressValidPfn</a> (<a class="code" href="../../d4/d2/datalpha_8c.html#a12">PrototypePte</a>);
02501             }
02502             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02503         }
02504     }
02505 
02506     <span class="comment">//</span>
02507     <span class="comment">// Page is not resident or is on standby / modified list.</span>
02508     <span class="comment">//</span>
02509 
02510     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02511 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:02 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
