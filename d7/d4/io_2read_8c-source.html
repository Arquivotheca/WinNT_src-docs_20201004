<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: read.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>read.c</h1><a href="../../d6/d5/io_2read_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1989-1993  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    read.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module contains the code to implement the NtReadFile system service.</span>
00012 <span class="comment"></span>
00013 <span class="comment">Author:</span>
00014 <span class="comment"></span>
00015 <span class="comment">    Darryl E. Havens (darrylh) 14-Apr-1989</span>
00016 <span class="comment"></span>
00017 <span class="comment">Environment:</span>
00018 <span class="comment"></span>
00019 <span class="comment">    Kernel mode</span>
00020 <span class="comment"></span>
00021 <span class="comment">Revision History:</span>
00022 <span class="comment"></span>
00023 <span class="comment"></span>
00024 <span class="comment">--*/</span>
00025 
00026 <span class="preprocessor">#include "<a class="code" href="../../d0/d6/iop_8h.html">iop.h</a>"</span>
00027 
<a name="l00028"></a><a class="code" href="../../d6/d5/io_2read_8c.html#a0">00028</a> ULONG <a class="code" href="../../d6/d5/io_2read_8c.html#a0">IopCacheHitIncrement</a> = 0;
00029 
00030 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00031 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, NtReadFile)</span>
00032 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, NtReadFileScatter)</span>
00033 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00034 <span class="preprocessor"></span>
00035 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00036"></a><a class="code" href="../../d6/d5/io_2read_8c.html#a1">00036</a> <a class="code" href="../../d6/d5/io_2read_8c.html#a1">NtReadFile</a>(
00037     IN HANDLE FileHandle,
00038     IN HANDLE Event OPTIONAL,
00039     IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
00040     IN PVOID ApcContext OPTIONAL,
00041     OUT PIO_STATUS_BLOCK IoStatusBlock,
00042     OUT PVOID Buffer,
00043     IN ULONG Length,
00044     IN PLARGE_INTEGER ByteOffset OPTIONAL,
00045     IN PULONG Key OPTIONAL
00046     )
00047 
00048 <span class="comment">/*++</span>
00049 <span class="comment"></span>
00050 <span class="comment">Routine Description:</span>
00051 <span class="comment"></span>
00052 <span class="comment">    This service reads Length bytes of data from the file associated with</span>
00053 <span class="comment">    FileHandle starting at ByteOffset and puts the data into the caller's</span>
00054 <span class="comment">    Buffer.  If the end of the file is reached before Length bytes have</span>
00055 <span class="comment">    been read, then the operation will terminate.  The actual length of</span>
00056 <span class="comment">    the data read from the file will be returned in the second longword</span>
00057 <span class="comment">    of the IoStatusBlock.</span>
00058 <span class="comment"></span>
00059 <span class="comment">Arguments:</span>
00060 <span class="comment"></span>
00061 <span class="comment">    FileHandle - Supplies a handle to the file to be read.</span>
00062 <span class="comment"></span>
00063 <span class="comment">    Event - Optionally supplies an event to be signaled when the read operation</span>
00064 <span class="comment">        is complete.</span>
00065 <span class="comment"></span>
00066 <span class="comment">    ApcRoutine - Optionally supplies an APC routine to be executed when the read</span>
00067 <span class="comment">        operation is complete.</span>
00068 <span class="comment"></span>
00069 <span class="comment">    ApcContext - Supplies a context parameter to be passed to the ApcRoutine, if</span>
00070 <span class="comment">        an ApcRoutine was specified.</span>
00071 <span class="comment"></span>
00072 <span class="comment">    IoStatusBlock - Address of the caller's I/O status block.</span>
00073 <span class="comment"></span>
00074 <span class="comment">    Buffer - Address of buffer to receive the data read from the file.</span>
00075 <span class="comment"></span>
00076 <span class="comment">    Length - Supplies the length, in bytes, of the data to read from the file.</span>
00077 <span class="comment"></span>
00078 <span class="comment">    ByteOffset - Optionally specifies the starting byte offset within the file</span>
00079 <span class="comment">        to begin the read operation.  If not specified and the file is open</span>
00080 <span class="comment">        for synchronous I/O, then the current file position is used.  If the</span>
00081 <span class="comment">        file is not opened for synchronous I/O and the parameter is not</span>
00082 <span class="comment">        specified, then it is an error.</span>
00083 <span class="comment"></span>
00084 <span class="comment">    Key - Optionally specifies a key to be used if there are locks associated</span>
00085 <span class="comment">        with the file.</span>
00086 <span class="comment"></span>
00087 <span class="comment">Return Value:</span>
00088 <span class="comment"></span>
00089 <span class="comment">    The status returned is success if the read operation was properly queued</span>
00090 <span class="comment">    to the I/O system.  Once the read completes the status of the operation</span>
00091 <span class="comment">    can be determined by examining the Status field of the I/O status block.</span>
00092 <span class="comment"></span>
00093 <span class="comment">--*/</span>
00094 
00095 {
00096     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
00097     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
00098     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> fileObject;
00099     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
00100     <a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html">PFAST_IO_DISPATCH</a> fastIoDispatch;
00101     <a class="code" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> requestorMode;
00102     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
00103     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> exceptionCode;
00104     BOOLEAN synchronousIo;
00105     <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> eventObject = (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00106     ULONG keyValue = 0;
00107     LARGE_INTEGER fileOffset = {0,0};
00108     PULONG majorFunction;
00109 
00110     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00111 
00112     <span class="comment">//</span>
00113     <span class="comment">// Get the previous mode;  i.e., the mode of the caller.</span>
00114     <span class="comment">//</span>
00115 
00116     requestorMode = KeGetPreviousMode();
00117 
00118     <span class="comment">//</span>
00119     <span class="comment">// Reference the file object so the target device can be found.  Note</span>
00120     <span class="comment">// that if the caller does not have read access to the file, the operation</span>
00121     <span class="comment">// will fail.</span>
00122     <span class="comment">//</span>
00123 
00124     status = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a>( FileHandle,
00125                                         FILE_READ_DATA,
00126                                         <a class="code" href="../../d5/d8/fssup_8c.html#a3">IoFileObjectType</a>,
00127                                         requestorMode,
00128                                         (PVOID *) &amp;fileObject,
00129                                         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00130     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
00131         <span class="keywordflow">return</span> status;
00132     }
00133 
00134     <span class="comment">//</span>
00135     <span class="comment">// Get the address of the target device object.</span>
00136     <span class="comment">//</span>
00137 
00138     deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( fileObject );
00139 
00140     <span class="keywordflow">if</span> (requestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
00141 
00142         <span class="comment">//</span>
00143         <span class="comment">// The caller's access mode is not kernel so probe each of the arguments</span>
00144         <span class="comment">// and capture them as necessary.  If any failures occur, the condition</span>
00145         <span class="comment">// handler will be invoked to handle them.  It will simply cleanup and</span>
00146         <span class="comment">// return an access violation status code back to the system service</span>
00147         <span class="comment">// dispatcher.</span>
00148         <span class="comment">//</span>
00149 
00150         <span class="keywordflow">try</span> {
00151 
00152             <span class="comment">//</span>
00153             <span class="comment">// The IoStatusBlock parameter must be writeable by the caller.</span>
00154             <span class="comment">//</span>
00155 
00156             <a class="code" href="../../d5/d8/ex_8h.html#a32">ProbeForWriteIoStatusEx</a>(IoStatusBlock , ApcRoutine);
00157 
00158             <span class="comment">//</span>
00159             <span class="comment">// The caller's data buffer must be writable from the caller's</span>
00160             <span class="comment">// mode.  This check ensures that this is the case.  Since the</span>
00161             <span class="comment">// buffer address is captured, the caller cannot change it,</span>
00162             <span class="comment">// even though he/she can change the protection from another</span>
00163             <span class="comment">// thread.  This error will be caught by the probe/lock or</span>
00164             <span class="comment">// buffer copy operations later.</span>
00165             <span class="comment">//</span>
00166 
00167             <a class="code" href="../../d5/d8/ex_8h.html#a259">ProbeForWrite</a>( <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, Length, <span class="keyword">sizeof</span>( UCHAR ) );
00168 
00169             <span class="comment">//</span>
00170             <span class="comment">// If this file has an I/O completion port associated w/it, then</span>
00171             <span class="comment">// ensure that the caller did not supply an APC routine, as the</span>
00172             <span class="comment">// two are mutually exclusive methods for I/O completion</span>
00173             <span class="comment">// notification.</span>
00174             <span class="comment">//</span>
00175 
00176             <span class="keywordflow">if</span> (fileObject-&gt;CompletionContext &amp;&amp; <a class="code" href="../../d0/d6/iop_8h.html#a19">IopApcRoutinePresent</a>( ApcRoutine )) {
00177                 <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00178                 <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
00179             }
00180 
00181             <span class="comment">//</span>
00182             <span class="comment">// Also ensure that the ByteOffset parameter is readable from</span>
00183             <span class="comment">// the caller's mode and capture it if it is present.</span>
00184             <span class="comment">//</span>
00185 
00186             <span class="keywordflow">if</span> (ARGUMENT_PRESENT( ByteOffset )) {
00187                 <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( ByteOffset,
00188                               <span class="keyword">sizeof</span>( LARGE_INTEGER ),
00189                               <span class="keyword">sizeof</span>( ULONG ) );
00190                 fileOffset = *ByteOffset;
00191             }
00192 
00193             <span class="comment">//</span>
00194             <span class="comment">// Check to see whether the caller has opened the file without</span>
00195             <span class="comment">// intermediate buffering.  If so, perform the following Buffer</span>
00196             <span class="comment">// and ByteOffset parameter checks differently.</span>
00197             <span class="comment">//</span>
00198 
00199             <span class="keywordflow">if</span> (fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a153">FO_NO_INTERMEDIATE_BUFFERING</a>) {
00200 
00201                 <span class="comment">//</span>
00202                 <span class="comment">// The file was opened without intermediate buffering enabled.</span>
00203                 <span class="comment">// Check that the Buffer is properly aligned, and that the</span>
00204                 <span class="comment">// length is an integral number of 512-byte blocks.</span>
00205                 <span class="comment">//</span>
00206 
00207                 <span class="keywordflow">if</span> ((deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> &amp;&amp;
00208                     (Length &amp; (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> - 1))) ||
00209                     (ULONG_PTR) <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> &amp; deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o17">AlignmentRequirement</a>) {
00210 
00211                     <span class="comment">//</span>
00212                     <span class="comment">// Check for sector sizes that are not a power of two.</span>
00213                     <span class="comment">//</span>
00214 
00215                     <span class="keywordflow">if</span> ((deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> &amp;&amp;
00216                         Length % deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a>) ||
00217                         (ULONG_PTR) <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> &amp; deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o17">AlignmentRequirement</a>) {
00218                         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00219                         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
00220                     }
00221                 }
00222 
00223                 <span class="comment">//</span>
00224                 <span class="comment">// If a ByteOffset parameter was specified, ensure that it</span>
00225                 <span class="comment">// is a valid argument.</span>
00226                 <span class="comment">//</span>
00227 
00228                 <span class="keywordflow">if</span> (ARGUMENT_PRESENT( ByteOffset )) {
00229                     <span class="keywordflow">if</span> (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> &amp;&amp;
00230                         (fileOffset.LowPart &amp; (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> - 1))) {
00231                         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00232                         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
00233                     }
00234                 }
00235             }
00236 
00237             <span class="comment">//</span>
00238             <span class="comment">// Finally, ensure that if there is a key parameter specified it</span>
00239             <span class="comment">// is readable by the caller.</span>
00240             <span class="comment">//</span>
00241 
00242             <span class="keywordflow">if</span> (ARGUMENT_PRESENT( <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a> )) {
00243                 keyValue = <a class="code" href="../../d5/d8/ex_8h.html#a20">ProbeAndReadUlong</a>( <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a> );
00244             }
00245 
00246         } except(<a class="code" href="../../d0/d6/iop_8h.html#a169">IopExceptionFilter</a>( GetExceptionInformation(), &amp;exceptionCode )) {
00247 
00248             <span class="comment">//</span>
00249             <span class="comment">// An exception was incurred while attempting to probe the</span>
00250             <span class="comment">// caller's parameters.  Dereference the file object and return</span>
00251             <span class="comment">// an appropriate error status code.</span>
00252             <span class="comment">//</span>
00253 
00254             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00255             <span class="keywordflow">return</span> exceptionCode;
00256 
00257         }
00258 
00259     } <span class="keywordflow">else</span> {
00260 
00261         <span class="comment">//</span>
00262         <span class="comment">// The caller's mode is kernel.  Get the same parameters that are</span>
00263         <span class="comment">// required from any other mode.</span>
00264         <span class="comment">//</span>
00265 
00266         <span class="keywordflow">if</span> (ARGUMENT_PRESENT( ByteOffset )) {
00267             fileOffset = *ByteOffset;
00268         }
00269 
00270         <span class="keywordflow">if</span> (ARGUMENT_PRESENT( <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a> )) {
00271             keyValue = *<a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>;
00272         }
00273 
00274 <span class="preprocessor">#if DBG</span>
00275 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a153">FO_NO_INTERMEDIATE_BUFFERING</a>) {
00276 
00277             <span class="comment">//</span>
00278             <span class="comment">// The file was opened without intermediate buffering enabled.</span>
00279             <span class="comment">// Check that the Buffer is properly aligned, and that the</span>
00280             <span class="comment">// length is an integral number of the block size.</span>
00281             <span class="comment">//</span>
00282 
00283             <span class="keywordflow">if</span> ((deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> &amp;&amp;
00284                 (Length &amp; (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> - 1))) ||
00285                 (ULONG_PTR) <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> &amp; deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o17">AlignmentRequirement</a>) {
00286 
00287                 <span class="comment">//</span>
00288                 <span class="comment">// Check for sector sizes that are not a power of two.</span>
00289                 <span class="comment">//</span>
00290 
00291                 <span class="keywordflow">if</span> ((deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> &amp;&amp;
00292                     Length % deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a>) ||
00293                     (ULONG_PTR) <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> &amp; deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o17">AlignmentRequirement</a>) {
00294                     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00295                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00296                     <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
00297                 }
00298             }
00299 
00300             <span class="comment">//</span>
00301             <span class="comment">// If a ByteOffset parameter was specified, ensure that it</span>
00302             <span class="comment">// is a valid argument.</span>
00303             <span class="comment">//</span>
00304 
00305             <span class="keywordflow">if</span> (ARGUMENT_PRESENT( ByteOffset )) {
00306                 <span class="keywordflow">if</span> (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> &amp;&amp;
00307                     (fileOffset.LowPart &amp; (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> - 1))) {
00308                     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00309                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00310                     <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
00311                 }
00312             }
00313         }
00314 <span class="preprocessor">#endif // DBG</span>
00315 <span class="preprocessor"></span>    }
00316 
00317     <span class="comment">//</span>
00318     <span class="comment">// Get the address of the event object and set the event to the Not-</span>
00319     <span class="comment">// Signaled state, if an one was specified.  Note here too, that if</span>
00320     <span class="comment">// the handle does not refer to an event, then the reference will fail.</span>
00321     <span class="comment">//</span>
00322 
00323     <span class="keywordflow">if</span> (ARGUMENT_PRESENT( <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a> )) {
00324         status = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a>( <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>,
00325                                             EVENT_MODIFY_STATE,
00326                                             <a class="code" href="../../d7/d7/ntapi_8c.html#a3">ExEventObjectType</a>,
00327                                             requestorMode,
00328                                             (PVOID *) &amp;eventObject,
00329                                             <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00330         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
00331             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00332             <span class="keywordflow">return</span> status;
00333         } <span class="keywordflow">else</span> {
00334             <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a>( eventObject );
00335         }
00336     }
00337 
00338     <span class="comment">//</span>
00339     <span class="comment">// Get the address of the driver object's Fast I/O dispatch structure.</span>
00340     <span class="comment">//</span>
00341 
00342     fastIoDispatch = deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o3">DriverObject</a>-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o10">FastIoDispatch</a>;
00343 
00344     <span class="comment">//</span>
00345     <span class="comment">// Make a special check here to determine whether this is a synchronous</span>
00346     <span class="comment">// I/O operation.  If it is, then wait here until the file is owned by</span>
00347     <span class="comment">// the current thread.</span>
00348     <span class="comment">//</span>
00349 
00350     <span class="keywordflow">if</span> (fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>) {
00351 
00352         BOOLEAN interrupted;
00353 
00354         <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d6/iop_8h.html#a13">IopAcquireFastLock</a>( fileObject )) {
00355             status = <a class="code" href="../../d0/d6/iop_8h.html#a147">IopAcquireFileObjectLock</a>( fileObject,
00356                                                requestorMode,
00357                                                (BOOLEAN) ((fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a152">FO_ALERTABLE_IO</a>) != 0),
00358                                                &amp;interrupted );
00359             <span class="keywordflow">if</span> (interrupted) {
00360                 <span class="keywordflow">if</span> (eventObject) {
00361                     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( eventObject );
00362                 }
00363                 <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00364                 <span class="keywordflow">return</span> status;
00365             }
00366         }
00367 
00368         <span class="keywordflow">if</span> (!ARGUMENT_PRESENT( ByteOffset ) ||
00369             (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &amp;&amp;
00370             fileOffset.HighPart == -1)) {
00371             fileOffset = fileObject-&gt;CurrentByteOffset;
00372         }
00373 
00374         <span class="comment">//</span>
00375         <span class="comment">// Turbo read support.  If the file is currently cached on this</span>
00376         <span class="comment">// file object, then call the Cache Manager directly via FastIoRead</span>
00377         <span class="comment">// and try to successfully complete the request here.  Note if</span>
00378         <span class="comment">// FastIoRead returns FALSE or we get an I/O error, we simply</span>
00379         <span class="comment">// fall through and go the "long way" and create an Irp.</span>
00380         <span class="comment">//</span>
00381 
00382         <span class="keywordflow">if</span> (fileObject-&gt;PrivateCacheMap) {
00383 
00384             IO_STATUS_BLOCK localIoStatus;
00385 
00386             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(fastIoDispatch &amp;&amp; fastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o2">FastIoRead</a>);
00387 
00388             <span class="comment">//</span>
00389             <span class="comment">//  Negative file offsets are illegal.</span>
00390             <span class="comment">//</span>
00391 
00392             <span class="keywordflow">if</span> (fileOffset.HighPart &lt; 0) {
00393                 <span class="keywordflow">if</span> (eventObject) {
00394                     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( eventObject );
00395                 }
00396                 <a class="code" href="../../d0/d6/iop_8h.html#a22">IopReleaseFileObjectLock</a>( fileObject );
00397                 <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00398                 <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
00399             }
00400 
00401             <span class="keywordflow">if</span> (fastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o2">FastIoRead</a>( fileObject,
00402                                             &amp;fileOffset,
00403                                             Length,
00404                                             <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00405                                             keyValue,
00406                                             <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>,
00407                                             &amp;localIoStatus,
00408                                             deviceObject )
00409 
00410                     &amp;&amp;
00411 
00412                 ((localIoStatus.Status == STATUS_SUCCESS) ||
00413                  (localIoStatus.Status == STATUS_BUFFER_OVERFLOW) ||
00414                  (localIoStatus.Status == STATUS_END_OF_FILE))) {
00415 
00416                 <span class="comment">//</span>
00417                 <span class="comment">// Boost the priority of the current thread so that it appears</span>
00418                 <span class="comment">// as if it just did I/O.  This causes background jobs that</span>
00419                 <span class="comment">// get cache hits to be more responsive in terms of getting</span>
00420                 <span class="comment">// more CPU time.</span>
00421                 <span class="comment">//</span>
00422 
00423                 <span class="keywordflow">if</span> (<a class="code" href="../../d6/d5/io_2read_8c.html#a0">IopCacheHitIncrement</a>) {
00424                     <a class="code" href="../../d9/d1/thredobj_8c.html#a4">KeBoostPriorityThread</a>( &amp;<a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>()-&gt;Tcb,
00425                                            (KPRIORITY) <a class="code" href="../../d6/d5/io_2read_8c.html#a0">IopCacheHitIncrement</a> );
00426                 }
00427 
00428                 <span class="comment">//</span>
00429                 <span class="comment">// Carefully return the I/O status.</span>
00430                 <span class="comment">//</span>
00431 
00432                 <a class="code" href="../../d4/d6/iosubs_8c.html#a130">IopUpdateReadOperationCount</a>( );
00433                 <a class="code" href="../../d4/d6/iosubs_8c.html#a133">IopUpdateReadTransferCount</a>( (ULONG)localIoStatus.Information );
00434 
00435                 <span class="keywordflow">try</span> {
00436                     *IoStatusBlock = localIoStatus;
00437                 } except( <a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a> ) {
00438                     localIoStatus.Status = GetExceptionCode();
00439                     localIoStatus.Information = 0;
00440                 }
00441 
00442                 <span class="comment">//</span>
00443                 <span class="comment">// If an event was specified, set it.</span>
00444                 <span class="comment">//</span>
00445 
00446                 <span class="keywordflow">if</span> (ARGUMENT_PRESENT( <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a> )) {
00447                     <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>( eventObject, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00448                     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( eventObject );
00449                 }
00450 
00451                 <span class="comment">//</span>
00452                 <span class="comment">// Note that the file object event need not be set to the</span>
00453                 <span class="comment">// Signaled state, as it is already set.</span>
00454                 <span class="comment">//</span>
00455 
00456                 <span class="comment">//</span>
00457                 <span class="comment">// Cleanup and return.</span>
00458                 <span class="comment">//</span>
00459 
00460                 <a class="code" href="../../d0/d6/iop_8h.html#a22">IopReleaseFileObjectLock</a>( fileObject );
00461                 <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00462 
00463                 <span class="keywordflow">return</span> localIoStatus.Status;
00464             }
00465         }
00466         synchronousIo = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00467 
00468     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!ARGUMENT_PRESENT( ByteOffset ) &amp;&amp; !(fileObject-&gt;Flags &amp; (<a class="code" href="../../d0/d5/io_8h.html#a157">FO_NAMED_PIPE</a> | <a class="code" href="../../d0/d5/io_8h.html#a159">FO_MAILSLOT</a>))) {
00469 
00470         <span class="comment">//</span>
00471         <span class="comment">// The file is not open for synchronous I/O operations, but the</span>
00472         <span class="comment">// caller did not specify a ByteOffset parameter.</span>
00473         <span class="comment">//</span>
00474 
00475         <span class="keywordflow">if</span> (eventObject) {
00476             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( eventObject );
00477         }
00478         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00479         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
00480     } <span class="keywordflow">else</span> {
00481         synchronousIo = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00482     }
00483 
00484     <span class="comment">//</span>
00485     <span class="comment">//  Negative file offsets are illegal.</span>
00486     <span class="comment">//</span>
00487 
00488     <span class="keywordflow">if</span> (fileOffset.HighPart &lt; 0) {
00489         <span class="keywordflow">if</span> (eventObject) {
00490             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( eventObject );
00491         }
00492         <span class="keywordflow">if</span> (synchronousIo) {
00493             <a class="code" href="../../d0/d6/iop_8h.html#a22">IopReleaseFileObjectLock</a>( fileObject );
00494         }
00495         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00496         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
00497     }
00498 
00499     <span class="comment">//</span>
00500     <span class="comment">// Set the file object to the Not-Signaled state.</span>
00501     <span class="comment">//</span>
00502 
00503     <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a>( &amp;fileObject-&gt;Event );
00504 
00505     <span class="comment">//</span>
00506     <span class="comment">// Allocate and initialize the I/O Request Packet (IRP) for this operation.</span>
00507     <span class="comment">// The allocation is performed with an exception handler in case the</span>
00508     <span class="comment">// caller does not have enough quota to allocate the packet.</span>
00509 
00510     irp = <a class="code" href="../../d0/d6/iop_8h.html#a16">IopAllocateIrp</a>( deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o13">StackSize</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00511     <span class="keywordflow">if</span> (!irp) {
00512 
00513         <span class="comment">//</span>
00514         <span class="comment">// An IRP could not be allocated.  Cleanup and return an appropriate</span>
00515         <span class="comment">// error status code.</span>
00516         <span class="comment">//</span>
00517 
00518         <a class="code" href="../../d0/d6/iop_8h.html#a148">IopAllocateIrpCleanup</a>( fileObject, eventObject );
00519 
00520         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
00521     }
00522     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.OriginalFileObject = fileObject;
00523     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
00524     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.AuxiliaryBuffer = (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00525     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o10">RequestorMode</a> = requestorMode;
00526     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o11">PendingReturned</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00527     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o14">Cancel</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00528     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o25">CancelRoutine</a> = (<a class="code" href="../../d0/d5/io_8h.html#a286">PDRIVER_CANCEL</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00529 
00530     <span class="comment">//</span>
00531     <span class="comment">// Fill in the service independent parameters in the IRP.</span>
00532     <span class="comment">//</span>
00533 
00534     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = eventObject;
00535     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = IoStatusBlock;
00536     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcRoutine = ApcRoutine;
00537     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcContext = ApcContext;
00538 
00539     <span class="comment">//</span>
00540     <span class="comment">// Get a pointer to the stack location for the first driver.  This will be</span>
00541     <span class="comment">// used to pass the original function codes and parameters.  Note that</span>
00542     <span class="comment">// setting the major function here also sets:</span>
00543     <span class="comment">//</span>
00544     <span class="comment">//      MinorFunction = 0;</span>
00545     <span class="comment">//      Flags = 0;</span>
00546     <span class="comment">//      Control = 0;</span>
00547     <span class="comment">//</span>
00548 
00549     irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
00550     majorFunction = (PULONG) (&amp;irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a>);
00551     *majorFunction = <a class="code" href="../../d0/d5/io_8h.html#a16">IRP_MJ_READ</a>;
00552     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> = fileObject;
00553 
00554     <span class="comment">//</span>
00555     <span class="comment">// Now determine whether this device expects to have data buffered to it</span>
00556     <span class="comment">// or whether it performs direct I/O.  This is based on the DO_BUFFERED_IO</span>
00557     <span class="comment">// flag in the device object.  If the flag is set, then a system buffer is</span>
00558     <span class="comment">// allocated and the driver's data will be copied into it.  Otherwise, a</span>
00559     <span class="comment">// Memory Descriptor List (MDL) is allocated and the caller's buffer is</span>
00560     <span class="comment">// locked down using it.</span>
00561     <span class="comment">//</span>
00562 
00563     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer = (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00564     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a> = (<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00565 
00566     <span class="keywordflow">if</span> (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o8">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a123">DO_BUFFERED_IO</a>) {
00567 
00568         <span class="comment">//</span>
00569         <span class="comment">// The device does not support direct I/O.  Allocate a system buffer</span>
00570         <span class="comment">// and specify that it should be deallocated on completion.  Also</span>
00571         <span class="comment">// indicate that this is an input operation so the data will be copied</span>
00572         <span class="comment">// into the caller's buffer.  This is done using an exception handler</span>
00573         <span class="comment">// that will perform cleanup if the operation fails.  Note that this</span>
00574         <span class="comment">// is only done if the operation has a non-zero length.</span>
00575         <span class="comment">//</span>
00576 
00577         <span class="keywordflow">if</span> (Length) {
00578 
00579             <span class="keywordflow">try</span> {
00580 
00581                 <span class="comment">//</span>
00582                 <span class="comment">// Allocate the intermediary system buffer from nonpaged pool</span>
00583                 <span class="comment">// and charge quota for it.</span>
00584                 <span class="comment">//</span>
00585 
00586                 irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer =
00587                     <a class="code" href="../../d5/d5/cc_8h.html#a11">ExAllocatePoolWithQuota</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a177">NonPagedPoolCacheAligned</a>, Length );
00588 
00589             } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00590 
00591                 <span class="comment">//</span>
00592                 <span class="comment">// An exception was incurred while either probing the caller's</span>
00593                 <span class="comment">// buffer or allocating the system buffer.  Determine what</span>
00594                 <span class="comment">// actually happened, clean everything up, and return an</span>
00595                 <span class="comment">// appropriate error status code.</span>
00596                 <span class="comment">//</span>
00597 
00598                 <a class="code" href="../../d0/d6/iop_8h.html#a170">IopExceptionCleanup</a>( fileObject,
00599                                      irp,
00600                                      eventObject,
00601                                      (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00602 
00603                 <span class="keywordflow">return</span> GetExceptionCode();
00604 
00605             }
00606 
00607             <span class="comment">//</span>
00608             <span class="comment">// Remember the address of the caller's buffer so the copy can take</span>
00609             <span class="comment">// place during I/O completion.  Also, set the flags so that the</span>
00610             <span class="comment">// completion code knows to do the copy and to deallocate the buffer.</span>
00611             <span class="comment">//</span>
00612 
00613             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o26">UserBuffer</a> = <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>;
00614             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a178">IRP_BUFFERED_IO</a> |
00615                          <a class="code" href="../../d0/d5/io_8h.html#a179">IRP_DEALLOCATE_BUFFER</a> |
00616                          <a class="code" href="../../d0/d5/io_8h.html#a180">IRP_INPUT_OPERATION</a>;
00617 
00618         } <span class="keywordflow">else</span> {
00619 
00620             <span class="comment">//</span>
00621             <span class="comment">// This is a zero-length read.  Simply indicate that this is</span>
00622             <span class="comment">// buffered I/O, and pass along the request.  The buffer will</span>
00623             <span class="comment">// not be set to deallocate so the completion path does not</span>
00624             <span class="comment">// have to special-case the length.</span>
00625             <span class="comment">//</span>
00626 
00627             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a178">IRP_BUFFERED_IO</a> | <a class="code" href="../../d0/d5/io_8h.html#a180">IRP_INPUT_OPERATION</a>;
00628 
00629         }
00630 
00631     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o8">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a125">DO_DIRECT_IO</a>) {
00632 
00633         <span class="comment">//</span>
00634         <span class="comment">// This is a direct I/O operation.  Allocate an MDL and invoke the</span>
00635         <span class="comment">// memory management routine to lock the buffer into memory.  This</span>
00636         <span class="comment">// is done using an exception handler that will perform cleanup if</span>
00637         <span class="comment">// the operation fails.  Note that no MDL is allocated, nor is any</span>
00638         <span class="comment">// memory probed or locked if the length of the request was zero.</span>
00639         <span class="comment">//</span>
00640 
00641         <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> mdl;
00642 
00643         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = 0;
00644 
00645         <span class="keywordflow">if</span> (Length) {
00646 
00647             <span class="keywordflow">try</span> {
00648 
00649                 <span class="comment">//</span>
00650                 <span class="comment">// Allocate an MDL, charging quota for it, and hang it off of</span>
00651                 <span class="comment">// the IRP.  Probe and lock the pages associated with the</span>
00652                 <span class="comment">// caller's buffer for write access and fill in the MDL with</span>
00653                 <span class="comment">// the PFNs of those pages.</span>
00654                 <span class="comment">//</span>
00655 
00656                 mdl = <a class="code" href="../../d4/d6/iosubs_8c.html#a19">IoAllocateMdl</a>( <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, Length, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, irp );
00657                 <span class="keywordflow">if</span> (mdl == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00658                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INSUFFICIENT_RESOURCES );
00659                 }
00660                 <a class="code" href="../../d5/d6/iosup_8c.html#a41">MmProbeAndLockPages</a>( mdl, requestorMode, <a class="code" href="../../d2/d1/mm_8h.html#a344a169">IoWriteAccess</a> );
00661 
00662             } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00663 
00664                 <span class="comment">//</span>
00665                 <span class="comment">// An exception was incurred while either probing the caller's</span>
00666                 <span class="comment">// buffer or allocating the MDL.  Determine what actually</span>
00667                 <span class="comment">// happened, clean everything up, and return an appropriate</span>
00668                 <span class="comment">// error status code.</span>
00669                 <span class="comment">//</span>
00670 
00671                 <a class="code" href="../../d0/d6/iop_8h.html#a170">IopExceptionCleanup</a>( fileObject,
00672                                      irp,
00673                                      eventObject,
00674                                      (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00675 
00676                 <span class="keywordflow">return</span> GetExceptionCode();
00677 
00678             }
00679 
00680         }
00681 
00682     } <span class="keywordflow">else</span> {
00683 
00684         <span class="comment">//</span>
00685         <span class="comment">// Pass the address of the user's buffer so the driver has access to</span>
00686         <span class="comment">// it.  It is now the driver's responsibility to do everything.</span>
00687         <span class="comment">//</span>
00688 
00689         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = 0;
00690         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o26">UserBuffer</a> = <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>;
00691     }
00692 
00693     <span class="comment">//</span>
00694     <span class="comment">// If this read operation is supposed to be performed with caching disabled</span>
00695     <span class="comment">// set the disable flag in the IRP so no caching is performed.</span>
00696     <span class="comment">//</span>
00697 
00698     <span class="keywordflow">if</span> (fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a153">FO_NO_INTERMEDIATE_BUFFERING</a>) {
00699         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a173">IRP_NOCACHE</a> | <a class="code" href="../../d0/d5/io_8h.html#a183">IRP_READ_OPERATION</a> | <a class="code" href="../../d0/d5/io_8h.html#a186">IRP_DEFER_IO_COMPLETION</a>;
00700     } <span class="keywordflow">else</span> {
00701         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a183">IRP_READ_OPERATION</a> | <a class="code" href="../../d0/d5/io_8h.html#a186">IRP_DEFER_IO_COMPLETION</a>;
00702     }
00703 
00704     <span class="comment">//</span>
00705     <span class="comment">// Copy the caller's parameters to the service-specific portion of the</span>
00706     <span class="comment">// IRP.</span>
00707     <span class="comment">//</span>
00708 
00709     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Read.Length = Length;
00710     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Read.Key = keyValue;
00711     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Read.ByteOffset = fileOffset;
00712 
00713     <span class="comment">//</span>
00714     <span class="comment">// Queue the packet, call the driver, and synchronize appopriately with</span>
00715     <span class="comment">// I/O completion.</span>
00716     <span class="comment">//</span>
00717 
00718     status =  <a class="code" href="../../d0/d6/iop_8h.html#a212">IopSynchronousServiceTail</a>( deviceObject,
00719                                          irp,
00720                                          fileObject,
00721                                          <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00722                                          requestorMode,
00723                                          synchronousIo,
00724                                          <a class="code" href="../../d0/d6/iop_8h.html#a240a138">ReadTransfer</a> );
00725 
00726     <span class="keywordflow">return</span> status;
00727 }
00728 
00729 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00730"></a><a class="code" href="../../d6/d5/io_2read_8c.html#a2">00730</a> <a class="code" href="../../d6/d5/io_2read_8c.html#a2">NtReadFileScatter</a>(
00731     IN HANDLE FileHandle,
00732     IN HANDLE Event OPTIONAL,
00733     IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
00734     IN PVOID ApcContext OPTIONAL,
00735     OUT PIO_STATUS_BLOCK IoStatusBlock,
00736     IN PFILE_SEGMENT_ELEMENT SegmentArray,
00737     IN ULONG Length,
00738     IN PLARGE_INTEGER ByteOffset OPTIONAL,
00739     IN PULONG Key OPTIONAL
00740     )
00741 
00742 <span class="comment">/*++</span>
00743 <span class="comment"></span>
00744 <span class="comment">Routine Description:</span>
00745 <span class="comment"></span>
00746 <span class="comment">    This service reads Length bytes of data from the file associated with</span>
00747 <span class="comment">    FileHandle starting at ByteOffset and puts the data into the caller's</span>
00748 <span class="comment">    buffer segments.  The buffer segments are not virtually contiguous,</span>
00749 <span class="comment">    but are 8 KB in length and alignment. If the end of the file is reached</span>
00750 <span class="comment">    before Length bytes have been read, then the operation will terminate.</span>
00751 <span class="comment">    The actual length of the data read from the file will be returned in</span>
00752 <span class="comment">    the second longword of the IoStatusBlock.</span>
00753 <span class="comment"></span>
00754 <span class="comment">Arguments:</span>
00755 <span class="comment"></span>
00756 <span class="comment">    FileHandle - Supplies a handle to the file to be read.</span>
00757 <span class="comment"></span>
00758 <span class="comment">    Event - Unused the I/O must use a completion port.</span>
00759 <span class="comment"></span>
00760 <span class="comment">    ApcRoutine - Optionally supplies an APC routine to be executed when the read</span>
00761 <span class="comment">        operation is complete.</span>
00762 <span class="comment"></span>
00763 <span class="comment">    ApcContext - Supplies a context parameter to be passed to the ApcRoutine, if</span>
00764 <span class="comment">        an ApcRoutine was specified.</span>
00765 <span class="comment"></span>
00766 <span class="comment">    IoStatusBlock - Address of the caller's I/O status block.</span>
00767 <span class="comment"></span>
00768 <span class="comment">    SegmentArray - An array of buffer segment pointers that specify</span>
00769 <span class="comment">        where the data should be placed.</span>
00770 <span class="comment"></span>
00771 <span class="comment">    Length - Supplies the length, in bytes, of the data to read from the file.</span>
00772 <span class="comment"></span>
00773 <span class="comment">    ByteOffset - Optionally specifies the starting byte offset within the file</span>
00774 <span class="comment">        to begin the read operation.  If not specified and the file is open</span>
00775 <span class="comment">        for synchronous I/O, then the current file position is used.  If the</span>
00776 <span class="comment">        file is not opened for synchronous I/O and the parameter is not</span>
00777 <span class="comment">        specified, then it is an error.</span>
00778 <span class="comment"></span>
00779 <span class="comment">    Key - Unused.</span>
00780 <span class="comment"></span>
00781 <span class="comment">Return Value:</span>
00782 <span class="comment"></span>
00783 <span class="comment">    The status returned is success if the read operation was properly queued</span>
00784 <span class="comment">    to the I/O system.  Once the read completes the status of the operation</span>
00785 <span class="comment">    can be determined by examining the Status field of the I/O status block.</span>
00786 <span class="comment"></span>
00787 <span class="comment">Notes:</span>
00788 <span class="comment"></span>
00789 <span class="comment">    This interface is only supported for no buffering and asynchronous I/O.</span>
00790 <span class="comment"></span>
00791 <span class="comment">--*/</span>
00792 
00793 {
00794     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
00795     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
00796     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> fileObject;
00797     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
00798     <a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html">PFAST_IO_DISPATCH</a> fastIoDispatch;
00799     PFILE_SEGMENT_ELEMENT capturedArray = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00800     <a class="code" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> requestorMode;
00801     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
00802     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> exceptionCode;
00803     <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> eventObject = (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00804     ULONG keyValue = 0;
00805     ULONG elementCount;
00806     LARGE_INTEGER fileOffset = {0,0};
00807     PULONG majorFunction;
00808     ULONG i;
00809     BOOLEAN synchronousIo;
00810 
00811     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00812 
00813     <span class="comment">//</span>
00814     <span class="comment">// Get the previous mode;  i.e., the mode of the caller.</span>
00815     <span class="comment">//</span>
00816 
00817     requestorMode = KeGetPreviousMode();
00818 
00819     <span class="comment">//</span>
00820     <span class="comment">// Reference the file object so the target device can be found.  Note</span>
00821     <span class="comment">// that if the caller does not have read access to the file, the operation</span>
00822     <span class="comment">// will fail.</span>
00823     <span class="comment">//</span>
00824 
00825     status = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a>( FileHandle,
00826                                         FILE_READ_DATA,
00827                                         <a class="code" href="../../d5/d8/fssup_8c.html#a3">IoFileObjectType</a>,
00828                                         requestorMode,
00829                                         (PVOID *) &amp;fileObject,
00830                                         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00831     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
00832         <span class="keywordflow">return</span> status;
00833     }
00834 
00835     <span class="comment">//</span>
00836     <span class="comment">// Get the address of the target device object.</span>
00837     <span class="comment">//</span>
00838 
00839     deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( fileObject );
00840 
00841     <span class="comment">//</span>
00842     <span class="comment">// Verify this is a valid scatter read request.  In particular it must be</span>
00843     <span class="comment">// non cached, asynchronous, use completion ports, non buffer I/O device</span>
00844     <span class="comment">// and directed at a file system device.</span>
00845     <span class="comment">//</span>
00846 
00847     <span class="keywordflow">if</span> (!(fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a153">FO_NO_INTERMEDIATE_BUFFERING</a>) ||
00848         (fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>) ||
00849         deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o8">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a123">DO_BUFFERED_IO</a> ||
00850         (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o12">DeviceType</a> != FILE_DEVICE_DISK_FILE_SYSTEM &amp;&amp;
00851          deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o12">DeviceType</a> != FILE_DEVICE_DFS &amp;&amp;
00852          deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o12">DeviceType</a> != FILE_DEVICE_TAPE_FILE_SYSTEM &amp;&amp;
00853          deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o12">DeviceType</a> != FILE_DEVICE_CD_ROM_FILE_SYSTEM &amp;&amp;
00854          deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o12">DeviceType</a> != FILE_DEVICE_NETWORK_FILE_SYSTEM &amp;&amp;
00855          deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o12">DeviceType</a> != FILE_DEVICE_FILE_SYSTEM &amp;&amp;
00856          deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o12">DeviceType</a> != FILE_DEVICE_DFS_VOLUME )) {
00857 
00858         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00859         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
00860     }
00861 
00862     elementCount = <a class="code" href="../../d2/d1/mm_8h.html#a5">BYTES_TO_PAGES</a>(Length);
00863 
00864     <span class="keywordflow">if</span> (requestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
00865 
00866         <span class="comment">//</span>
00867         <span class="comment">// The caller's access mode is not kernel so probe each of the arguments</span>
00868         <span class="comment">// and capture them as necessary.  If any failures occur, the condition</span>
00869         <span class="comment">// handler will be invoked to handle them.  It will simply cleanup and</span>
00870         <span class="comment">// return an access violation status code back to the system service</span>
00871         <span class="comment">// dispatcher.</span>
00872         <span class="comment">//</span>
00873 
00874         <span class="keywordflow">try</span> {
00875 
00876             <span class="comment">//</span>
00877             <span class="comment">// The IoStatusBlock parameter must be writeable by the caller.</span>
00878             <span class="comment">//</span>
00879 
00880             <a class="code" href="../../d5/d8/ex_8h.html#a32">ProbeForWriteIoStatusEx</a>( IoStatusBlock , ApcRoutine);
00881 
00882             <span class="comment">//</span>
00883             <span class="comment">// If this file has an I/O completion port associated w/it, then</span>
00884             <span class="comment">// ensure that the caller did not supply an APC routine, as the</span>
00885             <span class="comment">// two are mutually exclusive methods for I/O completion</span>
00886             <span class="comment">// notification.</span>
00887             <span class="comment">//</span>
00888 
00889             <span class="keywordflow">if</span> (fileObject-&gt;CompletionContext &amp;&amp; <a class="code" href="../../d0/d6/iop_8h.html#a19">IopApcRoutinePresent</a>( ApcRoutine )) {
00890                 <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00891                 <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
00892             }
00893 
00894             <span class="comment">//</span>
00895             <span class="comment">// Also ensure that the ByteOffset parameter is readable from</span>
00896             <span class="comment">// the caller's mode and capture it if it is present.</span>
00897             <span class="comment">//</span>
00898 
00899             <span class="keywordflow">if</span> (ARGUMENT_PRESENT( ByteOffset )) {
00900                 <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( ByteOffset,
00901                               <span class="keyword">sizeof</span>( LARGE_INTEGER ),
00902                               <span class="keyword">sizeof</span>( ULONG ) );
00903                 fileOffset = *ByteOffset;
00904             }
00905 
00906             <span class="comment">//</span>
00907             <span class="comment">// Check to see whether the caller has opened the file without</span>
00908             <span class="comment">// intermediate buffering.  If so, perform the following ByteOffset</span>
00909             <span class="comment">// parameter check differently.</span>
00910             <span class="comment">//</span>
00911 
00912             <span class="keywordflow">if</span> (fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a153">FO_NO_INTERMEDIATE_BUFFERING</a>) {
00913 
00914                 <span class="comment">//</span>
00915                 <span class="comment">// The file was opened without intermediate buffering enabled.</span>
00916                 <span class="comment">// Check that the Buffer is properly aligned, and that the</span>
00917                 <span class="comment">// length is an integral number of 512-byte blocks.</span>
00918                 <span class="comment">//</span>
00919 
00920                 <span class="keywordflow">if</span> ((deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> &amp;&amp;
00921                     (Length &amp; (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> - 1)))) {
00922 
00923                     <span class="comment">//</span>
00924                     <span class="comment">// Check for sector sizes that are not a power of two.</span>
00925                     <span class="comment">//</span>
00926 
00927                     <span class="keywordflow">if</span> ((deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> &amp;&amp;
00928                         Length % deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a>)) {
00929                         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00930                         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
00931                     }
00932                 }
00933 
00934                 <span class="comment">//</span>
00935                 <span class="comment">// If a ByteOffset parameter was specified, ensure that it</span>
00936                 <span class="comment">// is a valid argument.</span>
00937                 <span class="comment">//</span>
00938 
00939                 <span class="keywordflow">if</span> (ARGUMENT_PRESENT( ByteOffset )) {
00940                     <span class="keywordflow">if</span> (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> &amp;&amp;
00941                         (fileOffset.LowPart &amp; (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> - 1))) {
00942                         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00943                         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
00944                     }
00945                 }
00946             }
00947 
00948             <span class="comment">//</span>
00949             <span class="comment">// The SegmentArray paramter must be accessible.</span>
00950             <span class="comment">//</span>
00951 
00952 <span class="preprocessor">#ifdef _X86_</span>
00953 <span class="preprocessor"></span>            <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( SegmentArray,
00954                           elementCount * <span class="keyword">sizeof</span>( FILE_SEGMENT_ELEMENT ),
00955                           <span class="keyword">sizeof</span>( ULONG )
00956                           );
00957 <span class="preprocessor">#elif defined(_WIN64)</span>
00958 <span class="preprocessor"></span>
00959             <span class="comment">//</span>
00960             <span class="comment">// If we are a wow64 process, follow the X86 rules</span>
00961             <span class="comment">//</span>
00962 
00963             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>()-&gt;Wow64Process) {
00964                 <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( SegmentArray,
00965                               elementCount * <span class="keyword">sizeof</span>( FILE_SEGMENT_ELEMENT ),
00966                               <span class="keyword">sizeof</span>( ULONG )
00967                               );
00968             } <span class="keywordflow">else</span> {
00969                 <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( SegmentArray,
00970                               elementCount * <span class="keyword">sizeof</span>( FILE_SEGMENT_ELEMENT ),
00971                               TYPE_ALIGNMENT( FILE_SEGMENT_ELEMENT )
00972                               );
00973             }
00974 <span class="preprocessor">#else</span>
00975 <span class="preprocessor"></span>            <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( SegmentArray,
00976                           elementCount * <span class="keyword">sizeof</span>( FILE_SEGMENT_ELEMENT ),
00977                           TYPE_ALIGNMENT( FILE_SEGMENT_ELEMENT )
00978                           );
00979 <span class="preprocessor">#endif</span>
00980 <span class="preprocessor"></span>
00981             <span class="keywordflow">if</span> (Length != 0) {
00982 
00983                 <span class="comment">//</span>
00984                 <span class="comment">// Capture the segment array so it cannot be changed after</span>
00985                 <span class="comment">// it has been looked at.</span>
00986                 <span class="comment">//</span>
00987 
00988                 capturedArray = <a class="code" href="../../d5/d5/cc_8h.html#a11">ExAllocatePoolWithQuota</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>,
00989                                                 elementCount * <span class="keyword">sizeof</span>( FILE_SEGMENT_ELEMENT )
00990                                                 );
00991 
00992                 RtlCopyMemory( capturedArray,
00993                                SegmentArray,
00994                                elementCount * <span class="keyword">sizeof</span>( FILE_SEGMENT_ELEMENT )
00995                                );
00996 
00997                 SegmentArray = capturedArray;
00998 
00999                 <span class="comment">//</span>
01000                 <span class="comment">// Verify that all the addresses are page aligned.</span>
01001                 <span class="comment">//</span>
01002 
01003                 <span class="keywordflow">for</span> (i = 0; i &lt; elementCount; i++) {
01004 
01005                     <span class="keywordflow">if</span> ( SegmentArray[i].Alignment &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) {
01006                         <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INVALID_PARAMETER );
01007                     }
01008                 }
01009             }
01010 
01011             <span class="comment">//</span>
01012             <span class="comment">// Finally, ensure that if there is a key parameter specified it</span>
01013             <span class="comment">// is readable by the caller.</span>
01014             <span class="comment">//</span>
01015 
01016             <span class="keywordflow">if</span> (ARGUMENT_PRESENT( <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a> )) {
01017                 keyValue = <a class="code" href="../../d5/d8/ex_8h.html#a20">ProbeAndReadUlong</a>( <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a> );
01018             }
01019 
01020         } except(<a class="code" href="../../d0/d6/iop_8h.html#a169">IopExceptionFilter</a>( GetExceptionInformation(), &amp;exceptionCode )) {
01021 
01022             <span class="comment">//</span>
01023             <span class="comment">// An exception was incurred while attempting to probe the</span>
01024             <span class="comment">// caller's parameters.  Dereference the file object and return</span>
01025             <span class="comment">// an appropriate error status code.</span>
01026             <span class="comment">//</span>
01027 
01028             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
01029             <span class="keywordflow">if</span> (capturedArray != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01030                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( capturedArray );
01031             }
01032             <span class="keywordflow">return</span> exceptionCode;
01033 
01034         }
01035 
01036     } <span class="keywordflow">else</span> {
01037 
01038         <span class="comment">//</span>
01039         <span class="comment">// The caller's mode is kernel.  Get the same parameters that are</span>
01040         <span class="comment">// required from any other mode.</span>
01041         <span class="comment">//</span>
01042 
01043         <span class="keywordflow">if</span> (ARGUMENT_PRESENT( ByteOffset )) {
01044             fileOffset = *ByteOffset;
01045         }
01046 
01047         <span class="keywordflow">if</span> (ARGUMENT_PRESENT( <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a> )) {
01048             keyValue = *<a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>;
01049         }
01050 
01051 <span class="preprocessor">#if DBG</span>
01052 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a153">FO_NO_INTERMEDIATE_BUFFERING</a>) {
01053 
01054             <span class="comment">//</span>
01055             <span class="comment">// The file was opened without intermediate buffering enabled.</span>
01056             <span class="comment">// Check that the the length is an integral number of the block</span>
01057             <span class="comment">//  size.</span>
01058             <span class="comment">//</span>
01059 
01060             <span class="keywordflow">if</span> ((deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> &amp;&amp;
01061                 (Length &amp; (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> - 1)))) {
01062 
01063                 <span class="comment">//</span>
01064                 <span class="comment">// Check for sector sizes that are not a power of two.</span>
01065                 <span class="comment">//</span>
01066 
01067                 <span class="keywordflow">if</span> ((deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> &amp;&amp;
01068                     Length % deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a>)) {
01069                     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
01070                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01071                     <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
01072                 }
01073             }
01074 
01075             <span class="comment">//</span>
01076             <span class="comment">// If a ByteOffset parameter was specified, ensure that it</span>
01077             <span class="comment">// is a valid argument.</span>
01078             <span class="comment">//</span>
01079 
01080             <span class="keywordflow">if</span> (ARGUMENT_PRESENT( ByteOffset )) {
01081                 <span class="keywordflow">if</span> (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> &amp;&amp;
01082                     (fileOffset.LowPart &amp; (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> - 1))) {
01083                     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
01084                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01085                     <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
01086                 }
01087             }
01088         }
01089 
01090         <span class="keywordflow">if</span> (Length != 0) {
01091 
01092             <span class="comment">//</span>
01093             <span class="comment">// Verify that all the addresses are page aligned.</span>
01094             <span class="comment">//</span>
01095 
01096             <span class="keywordflow">for</span> (i = 0; i &lt; elementCount; i++) {
01097 
01098                 <span class="keywordflow">if</span> ( SegmentArray[i].Alignment &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) {
01099 
01100                     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
01101                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
01102                     <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
01103                 }
01104             }
01105         }
01106 <span class="preprocessor">#endif // DBG</span>
01107 <span class="preprocessor"></span>    }
01108 
01109     <span class="comment">//</span>
01110     <span class="comment">// Get the address of the event object and set the event to the Not-</span>
01111     <span class="comment">// Signaled state, if an one was specified.  Note here too, that if</span>
01112     <span class="comment">// the handle does not refer to an event, then the reference will fail.</span>
01113     <span class="comment">//</span>
01114 
01115     <span class="keywordflow">if</span> (ARGUMENT_PRESENT( <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a> )) {
01116         status = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a>( <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>,
01117                                             EVENT_MODIFY_STATE,
01118                                             <a class="code" href="../../d7/d7/ntapi_8c.html#a3">ExEventObjectType</a>,
01119                                             requestorMode,
01120                                             (PVOID *) &amp;eventObject,
01121                                             <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01122         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
01123             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
01124             <span class="keywordflow">if</span> (capturedArray != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01125                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( capturedArray );
01126             }
01127             <span class="keywordflow">return</span> status;
01128         } <span class="keywordflow">else</span> {
01129             <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a>( eventObject );
01130         }
01131     }
01132 
01133     <span class="comment">//</span>
01134     <span class="comment">// Get the address of the driver object's Fast I/O dispatch structure.</span>
01135     <span class="comment">//</span>
01136 
01137     fastIoDispatch = deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o3">DriverObject</a>-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o10">FastIoDispatch</a>;
01138 
01139     <span class="comment">//</span>
01140     <span class="comment">// Make a special check here to determine whether this is a synchronous</span>
01141     <span class="comment">// I/O operation.  If it is, then wait here until the file is owned by</span>
01142     <span class="comment">// the current thread.</span>
01143     <span class="comment">//</span>
01144 
01145     <span class="keywordflow">if</span> (fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>) {
01146 
01147         BOOLEAN interrupted;
01148 
01149         <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d6/iop_8h.html#a13">IopAcquireFastLock</a>( fileObject )) {
01150             status = <a class="code" href="../../d0/d6/iop_8h.html#a147">IopAcquireFileObjectLock</a>( fileObject,
01151                                                requestorMode,
01152                                                (BOOLEAN) ((fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a152">FO_ALERTABLE_IO</a>) != 0),
01153                                                &amp;interrupted );
01154             <span class="keywordflow">if</span> (interrupted) {
01155                 <span class="keywordflow">if</span> (eventObject) {
01156                     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( eventObject );
01157                 }
01158                 <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
01159                 <span class="keywordflow">if</span> (capturedArray != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01160                     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( capturedArray );
01161                 }
01162                 <span class="keywordflow">return</span> status;
01163             }
01164         }
01165 
01166         <span class="keywordflow">if</span> (!ARGUMENT_PRESENT( ByteOffset ) ||
01167             (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &amp;&amp;
01168             fileOffset.HighPart == -1)) {
01169             fileOffset = fileObject-&gt;CurrentByteOffset;
01170         }
01171 
01172         synchronousIo = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01173 
01174     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!ARGUMENT_PRESENT( ByteOffset ) &amp;&amp; !(fileObject-&gt;Flags &amp; (<a class="code" href="../../d0/d5/io_8h.html#a157">FO_NAMED_PIPE</a> | <a class="code" href="../../d0/d5/io_8h.html#a159">FO_MAILSLOT</a>))) {
01175 
01176         <span class="comment">//</span>
01177         <span class="comment">// The file is not open for synchronous I/O operations, but the</span>
01178         <span class="comment">// caller did not specify a ByteOffset parameter.</span>
01179         <span class="comment">//</span>
01180 
01181         <span class="keywordflow">if</span> (eventObject) {
01182             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( eventObject );
01183         }
01184         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
01185         <span class="keywordflow">if</span> (capturedArray != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01186             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( capturedArray );
01187         }
01188         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
01189     } <span class="keywordflow">else</span> {
01190         synchronousIo = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01191     }
01192 
01193     <span class="comment">//</span>
01194     <span class="comment">//  Negative file offsets are illegal.</span>
01195     <span class="comment">//</span>
01196 
01197     <span class="keywordflow">if</span> (fileOffset.HighPart &lt; 0) {
01198         <span class="keywordflow">if</span> (eventObject) {
01199             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( eventObject );
01200         }
01201         <span class="keywordflow">if</span> (synchronousIo) {
01202             <a class="code" href="../../d0/d6/iop_8h.html#a22">IopReleaseFileObjectLock</a>( fileObject );
01203         }
01204         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
01205         <span class="keywordflow">if</span> (capturedArray != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01206             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( capturedArray );
01207         }
01208         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
01209     }
01210 
01211     <span class="comment">//</span>
01212     <span class="comment">// Set the file object to the Not-Signaled state.</span>
01213     <span class="comment">//</span>
01214 
01215     <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a>( &amp;fileObject-&gt;Event );
01216 
01217     <span class="comment">//</span>
01218     <span class="comment">// Allocate and initialize the I/O Request Packet (IRP) for this operation.</span>
01219     <span class="comment">// The allocation is performed with an exception handler in case the</span>
01220     <span class="comment">// caller does not have enough quota to allocate the packet.</span>
01221 
01222     irp = <a class="code" href="../../d0/d6/iop_8h.html#a16">IopAllocateIrp</a>( deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o13">StackSize</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
01223     <span class="keywordflow">if</span> (!irp) {
01224 
01225         <span class="comment">//</span>
01226         <span class="comment">// An IRP could not be allocated.  Cleanup and return an appropriate</span>
01227         <span class="comment">// error status code.</span>
01228         <span class="comment">//</span>
01229 
01230         <a class="code" href="../../d0/d6/iop_8h.html#a148">IopAllocateIrpCleanup</a>( fileObject, eventObject );
01231 
01232         <span class="keywordflow">if</span> (capturedArray != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01233             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( capturedArray );
01234         }
01235         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
01236     }
01237     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.OriginalFileObject = fileObject;
01238     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
01239     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.AuxiliaryBuffer = (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01240     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o10">RequestorMode</a> = requestorMode;
01241     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o11">PendingReturned</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01242     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o14">Cancel</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01243     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o25">CancelRoutine</a> = (<a class="code" href="../../d0/d5/io_8h.html#a286">PDRIVER_CANCEL</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01244 
01245     <span class="comment">//</span>
01246     <span class="comment">// Fill in the service independent parameters in the IRP.</span>
01247     <span class="comment">//</span>
01248 
01249     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = eventObject;
01250     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = IoStatusBlock;
01251     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcRoutine = ApcRoutine;
01252     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcContext = ApcContext;
01253 
01254     <span class="comment">//</span>
01255     <span class="comment">// Get a pointer to the stack location for the first driver.  This will be</span>
01256     <span class="comment">// used to pass the original function codes and parameters.  Note that</span>
01257     <span class="comment">// setting the major function here also sets:</span>
01258     <span class="comment">//</span>
01259     <span class="comment">//      MinorFunction = 0;</span>
01260     <span class="comment">//      Flags = 0;</span>
01261     <span class="comment">//      Control = 0;</span>
01262     <span class="comment">//</span>
01263 
01264     irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
01265     majorFunction = (PULONG) (&amp;irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a>);
01266     *majorFunction = <a class="code" href="../../d0/d5/io_8h.html#a16">IRP_MJ_READ</a>;
01267     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> = fileObject;
01268 
01269     <span class="comment">//</span>
01270     <span class="comment">// Always allocate a Memory Descriptor List (MDL) and lock down the</span>
01271     <span class="comment">// caller's buffer. This way the file system do not have change to</span>
01272     <span class="comment">// build a scatter MDL. Note buffered I/O is not supported for this</span>
01273     <span class="comment">// routine.</span>
01274     <span class="comment">//</span>
01275 
01276     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer = (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01277     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a> = (<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01278 
01279 
01280     <span class="comment">//</span>
01281     <span class="comment">// This is a direct I/O operation.  Allocate an MDL and invoke the</span>
01282     <span class="comment">// memory management routine to lock the buffer into memory.  This</span>
01283     <span class="comment">// is done using an exception handler that will perform cleanup if</span>
01284     <span class="comment">// the operation fails.  Note that no MDL is allocated, nor is any</span>
01285     <span class="comment">// memory probed or locked if the length of the request was zero.</span>
01286     <span class="comment">//</span>
01287 
01288     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = 0;
01289 
01290     <span class="keywordflow">if</span> (Length) {
01291 
01292         <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> mdl;
01293 
01294         <span class="keywordflow">try</span> {
01295 
01296             <span class="comment">//</span>
01297             <span class="comment">// Allocate an MDL, charging quota for it, and hang it off of</span>
01298             <span class="comment">// the IRP.  Probe and lock the pages associated with the</span>
01299             <span class="comment">// caller's buffer for write access and fill in the MDL with</span>
01300             <span class="comment">// the PFNs of those pages.</span>
01301             <span class="comment">//</span>
01302 
01303             mdl = <a class="code" href="../../d4/d6/iosubs_8c.html#a19">IoAllocateMdl</a>( (PVOID)(ULONG_PTR) SegmentArray[0].<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, Length, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, irp );
01304             <span class="keywordflow">if</span> (mdl == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01305                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INSUFFICIENT_RESOURCES );
01306             }
01307 
01308             <span class="comment">//</span>
01309             <span class="comment">// The address of the first file segment is used as a base</span>
01310             <span class="comment">// address.</span>
01311             <span class="comment">//</span>
01312 
01313             <a class="code" href="../../d5/d6/iosup_8c.html#a44">MmProbeAndLockSelectedPages</a>( mdl,
01314                                          SegmentArray,
01315                                          requestorMode,
01316                                          <a class="code" href="../../d2/d1/mm_8h.html#a344a169">IoWriteAccess</a> );
01317 
01318             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o26">UserBuffer</a> = (PVOID)(ULONG_PTR) SegmentArray[0].Buffer;
01319 
01320         } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
01321 
01322             <span class="comment">//</span>
01323             <span class="comment">// An exception was incurred while either probing the caller's</span>
01324             <span class="comment">// buffer or allocating the MDL.  Determine what actually</span>
01325             <span class="comment">// happened, clean everything up, and return an appropriate</span>
01326             <span class="comment">// error status code.</span>
01327             <span class="comment">//</span>
01328 
01329             <a class="code" href="../../d0/d6/iop_8h.html#a170">IopExceptionCleanup</a>( fileObject,
01330                                  irp,
01331                                  eventObject,
01332                                  (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01333 
01334             <span class="keywordflow">if</span> (capturedArray != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01335                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( capturedArray );
01336             }
01337             <span class="keywordflow">return</span> GetExceptionCode();
01338 
01339         }
01340 
01341     }
01342 
01343     <span class="comment">//</span>
01344     <span class="comment">// We are done with the captured buffer.</span>
01345     <span class="comment">//</span>
01346 
01347     <span class="keywordflow">if</span> (capturedArray != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01348         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( capturedArray );
01349     }
01350 
01351     <span class="comment">//</span>
01352     <span class="comment">// If this read operation is supposed to be performed with caching disabled</span>
01353     <span class="comment">// set the disable flag in the IRP so no caching is performed.</span>
01354     <span class="comment">//</span>
01355 
01356     <span class="keywordflow">if</span> (fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a153">FO_NO_INTERMEDIATE_BUFFERING</a>) {
01357         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a173">IRP_NOCACHE</a> | <a class="code" href="../../d0/d5/io_8h.html#a183">IRP_READ_OPERATION</a> | <a class="code" href="../../d0/d5/io_8h.html#a186">IRP_DEFER_IO_COMPLETION</a>;
01358     } <span class="keywordflow">else</span> {
01359         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a183">IRP_READ_OPERATION</a> | <a class="code" href="../../d0/d5/io_8h.html#a186">IRP_DEFER_IO_COMPLETION</a>;
01360     }
01361 
01362     <span class="comment">//</span>
01363     <span class="comment">// Copy the caller's parameters to the service-specific portion of the</span>
01364     <span class="comment">// IRP.</span>
01365     <span class="comment">//</span>
01366 
01367     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Read.Length = Length;
01368     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Read.Key = keyValue;
01369     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Read.ByteOffset = fileOffset;
01370 
01371     <span class="comment">//</span>
01372     <span class="comment">// Queue the packet, call the driver, and synchronize appopriately with</span>
01373     <span class="comment">// I/O completion.</span>
01374     <span class="comment">//</span>
01375 
01376     status =  <a class="code" href="../../d0/d6/iop_8h.html#a212">IopSynchronousServiceTail</a>( deviceObject,
01377                                          irp,
01378                                          fileObject,
01379                                          <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
01380                                          requestorMode,
01381                                          synchronousIo,
01382                                          <a class="code" href="../../d0/d6/iop_8h.html#a240a138">ReadTransfer</a> );
01383 
01384     <span class="keywordflow">return</span> status;
01385 
01386 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:41:37 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
