<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: kdcpuapi.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>kdcpuapi.c</h1><a href="../../d6/d5/4_2i386_2kdcpuapi_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1990  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    kdcpuapi.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module implements CPU specific remote debug APIs.</span>
00012 <span class="comment"></span>
00013 <span class="comment">Author:</span>
00014 <span class="comment"></span>
00015 <span class="comment">    Mark Lucovsky (markl) 04-Sep-1990</span>
00016 <span class="comment"></span>
00017 <span class="comment">Revision History:</span>
00018 <span class="comment"></span>
00019 <span class="comment">    24-sep-90   bryanwi</span>
00020 <span class="comment"></span>
00021 <span class="comment">        Port to the x86.</span>
00022 <span class="comment"></span>
00023 <span class="comment">--*/</span>
00024 
00025 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00026 
00027 <span class="preprocessor">#include "<a class="code" href="../../d1/d7/4_2kdp_8h.html">kdp.h</a>"</span>
<a name="l00028"></a><a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a0">00028</a> <span class="preprocessor">#define END_OF_CONTROL_SPACE</span>
00029 <span class="preprocessor"></span>
<a name="l00030"></a><a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a1">00030</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a1">KdpCurrentSymbolStart</a>, <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a2">KdpCurrentSymbolEnd</a>;
<a name="l00031"></a><a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a3">00031</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a3">KdSpecialCalls</a>[];
<a name="l00032"></a><a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a4">00032</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a4">KdNumberOfSpecialCalls</a>;
00033 
00034 LONG
00035 <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a5">KdpLevelChange</a> (
00036     ULONG Pc,
00037     PCONTEXT ContextRecord,
00038     PBOOLEAN SpecialCall
00039     );
00040 
00041 LONG
00042 <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a6">regValue</a>(
00043     UCHAR reg,
00044     PCONTEXT ContextRecord
00045     );
00046 
00047 BOOLEAN
00048 <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a7">KdpIsSpecialCall</a> (
00049     ULONG Pc,
00050     PCONTEXT ContextRecord,
00051     UCHAR opcode,
00052     UCHAR ModRM
00053     );
00054 
00055 ULONG
00056 <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a8">KdpGetReturnAddress</a> (
00057     PCONTEXT ContextRecord
00058     );
00059 
00060 ULONG
00061 <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a9">KdpGetCallNextOffset</a> (
00062     ULONG Pc,
00063     PCONTEXT ContextRecord
00064     );
00065 
00066 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00067 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpLevelChange)</span>
00068 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, regValue)</span>
00069 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpIsSpecialCall)</span>
00070 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpGetReturnAddress)</span>
00071 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpSetLoadState)</span>
00072 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpSetStateChange)</span>
00073 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpGetStateChange)</span>
00074 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpReadControlSpace)</span>
00075 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpWriteControlSpace)</span>
00076 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpReadIoSpace)</span>
00077 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpWriteIoSpace)</span>
00078 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpReadMachineSpecificRegister)</span>
00079 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpWriteMachineSpecificRegister)</span>
00080 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpGetCallNextOffset)</span>
00081 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00082 <span class="preprocessor"></span>
00083 <span class="comment">/**** KdpIsTryFinallyReturn - detect finally optimization</span>
00084 <span class="comment">*</span>
00085 <span class="comment">*  Input:</span>
00086 <span class="comment">*       pc - program counter of instruction to check</span>
00087 <span class="comment">*       ContextRecord - machine specific context</span>
00088 <span class="comment">*</span>
00089 <span class="comment">*  Output:</span>
00090 <span class="comment">*       returns TRUE if this is a try-finally returning to the same</span>
00091 <span class="comment">*       scope</span>
00092 <span class="comment">***************************************************************************/</span>
00093 
00094 
00095 BOOLEAN
<a name="l00096"></a><a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a10">00096</a> <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a10">KdpIsTryFinallyReturn</a> (
00097     ULONG Pc,
00098     PCONTEXT ContextRecord
00099     )
00100 {
00101     ULONG retaddr;
00102     ULONG calldisp;
00103     UCHAR inst;
00104 
00105     <span class="comment">//</span>
00106     <span class="comment">//  The complier generates code for a try-finally that involves having</span>
00107     <span class="comment">//  a ret instruction that does not match with a call instruction.</span>
00108     <span class="comment">//  This ret never returns a value (ie, it's a c3 return and not a</span>
00109     <span class="comment">//  c2).  It always returns into the current symbol scope.  It is never</span>
00110     <span class="comment">//  preceeded by a leave, which (hopefully) should differentiate it</span>
00111     <span class="comment">//  from recursive returns.  Check for this, and if we find it count</span>
00112     <span class="comment">//  it as *0* level change.</span>
00113     <span class="comment">//</span>
00114     <span class="comment">//  As an optimization, the compiler will often change:</span>
00115     <span class="comment">//      CALL</span>
00116     <span class="comment">//      RET</span>
00117     <span class="comment">//  into:</span>
00118     <span class="comment">//      JMP</span>
00119     <span class="comment">//  In either case, we figure out the return address.  It's the first 4 bytes</span>
00120     <span class="comment">//  on the stack.</span>
00121     <span class="comment">//</span>
00122 
00123     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>( (PCHAR)&amp;retaddr, (PCHAR)ContextRecord-&gt;Esp, 4 );
00124 
00125 <span class="comment">//  DPRINT(( "Start %x return %x end %x\n", KdpCurrentSymbolStart, retaddr, KdpCurrentSymbolEnd ));</span>
00126 
00127     <span class="keywordflow">if</span> ( (<a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a1">KdpCurrentSymbolStart</a> &lt; retaddr) &amp;&amp; (retaddr &lt; <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a2">KdpCurrentSymbolEnd</a>) ) {
00128 
00129         <span class="comment">//</span>
00130         <span class="comment">//  Well, things aren't this nice.  We may have transferred but not yet</span>
00131         <span class="comment">//  updated the start/end.  This case occurs in a call to a thunk.  We</span>
00132         <span class="comment">//  look to see if the instruction before the return address is a call.</span>
00133         <span class="comment">//  Gross and not 100% reliable.</span>
00134         <span class="comment">//</span>
00135 
00136         <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>( (PCHAR)&amp;inst, (PCHAR)retaddr - 5, 1 );
00137         <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>( (PCHAR)&amp;calldisp, (PCHAR)retaddr - 4, 4 );
00138 
00139         <span class="keywordflow">if</span> (inst == 0xe8 &amp;&amp; calldisp + retaddr == Pc) {
00140 <span class="comment">//  DPRINT(( "call to thunk @ %x\n", Pc ));</span>
00141             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00142         }
00143 
00144         <span class="comment">//</span>
00145         <span class="comment">//  returning to the current function.  Either a finally</span>
00146         <span class="comment">//  or a recursive return.  Check for a leave.  This is not 100%</span>
00147         <span class="comment">//  reliable since we are betting on an instruction longer than a byte</span>
00148         <span class="comment">//  and not ending with 0xc9.</span>
00149         <span class="comment">//</span>
00150 
00151         <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>( (PCHAR)&amp;inst, (PCHAR)Pc-1, 1 );
00152 
00153         <span class="keywordflow">if</span> ( inst != 0xc9 ) {
00154             <span class="comment">// not a leave.  Assume a try-finally.</span>
00155 <span class="comment">//  DPRINT(( "transfer at %x is try-finally\n", Pc ));</span>
00156             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00157         }
00158     }
00159 
00160     <span class="comment">//</span>
00161     <span class="comment">//  This appears to be a true RET instruction</span>
00162     <span class="comment">//</span>
00163 
00164     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00165 }
00166 
00167 <span class="comment">/**** KdpLevelChange - say how the instruction affects the call level</span>
00168 <span class="comment">*</span>
00169 <span class="comment">*  Input:</span>
00170 <span class="comment">*       pc - program counter of instruction to check</span>
00171 <span class="comment">*       ContextRecord - machine specific context</span>
00172 <span class="comment">*       SpecialCall - pointer to returned boolean indicating if the</span>
00173 <span class="comment">*           instruction is a transfer to a special routine</span>
00174 <span class="comment">*</span>
00175 <span class="comment">*  Output:</span>
00176 <span class="comment">*       returns -1 for a level pop, 1 for a push and 0 if it is</span>
00177 <span class="comment">*       unchanged.</span>
00178 <span class="comment">*  NOTE: This function belongs in some other file.  I should move it.</span>
00179 <span class="comment">***************************************************************************/</span>
00180 
00181 
00182 LONG
00183 <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a5">KdpLevelChange</a> (
00184     ULONG Pc,
00185     PCONTEXT ContextRecord,
00186     PBOOLEAN SpecialCall
00187     )
00188 {
00189     UCHAR membuf[2];
00190     ULONG Addr;
00191 
00192     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>( (PCHAR)membuf, (PCHAR)Pc, 2 );
00193 
00194     <span class="keywordflow">switch</span> (membuf[0]) {
00195     <span class="keywordflow">case</span> 0xe8:  <span class="comment">//  CALL direct w/32 bit displacement</span>
00196         <span class="comment">//</span>
00197         <span class="comment">//  For try/finally, the compiler may, in addition to the push/ret trick</span>
00198         <span class="comment">//  below, use a call to the finally thunk.  Since we treat a RET to</span>
00199         <span class="comment">//  within the same symbol scope as not changing levels, we will also</span>
00200         <span class="comment">//  treat such a call as not changing levels either</span>
00201         <span class="comment">//</span>
00202 
00203         <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>( (PCHAR)&amp;Addr, (PCHAR)Pc+1, 4 );
00204         Addr += Pc + 5;
00205 
00206         <span class="keywordflow">if</span> ((<a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a1">KdpCurrentSymbolStart</a> &lt;= Addr) &amp;&amp; (Addr &lt; <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a2">KdpCurrentSymbolEnd</a>)) {
00207             *SpecialCall = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00208             <span class="keywordflow">return</span> 0;
00209         }
00210 
00211 
00212     <span class="keywordflow">case</span> 0x9a:  <span class="comment">//  CALL segmented 16:32</span>
00213 
00214         *SpecialCall = <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a7">KdpIsSpecialCall</a>( Pc, ContextRecord, membuf[0], membuf[1] );
00215         <span class="keywordflow">return</span> 1;
00216 
00217     <span class="keywordflow">case</span> 0xff:
00218         <span class="comment">//</span>
00219         <span class="comment">//  This is a compound instruction.  Dispatch on operation</span>
00220         <span class="comment">//</span>
00221         <span class="keywordflow">switch</span> (membuf[1] &amp; 0x38) {
00222         <span class="keywordflow">case</span> 0x10:  <span class="comment">//  CALL with mod r/m</span>
00223             *SpecialCall = <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a7">KdpIsSpecialCall</a>( Pc, ContextRecord, membuf[0], membuf[1] );
00224             <span class="keywordflow">return</span> 1;
00225         <span class="keywordflow">case</span> 0x20:  <span class="comment">//  JMP with mod r/m</span>
00226             *SpecialCall = <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a7">KdpIsSpecialCall</a>( Pc, ContextRecord, membuf[0], membuf[1] );
00227 
00228             <span class="comment">//</span>
00229             <span class="comment">//  If this is a try/finally, we'd like to treat it as call since the</span>
00230             <span class="comment">//  return inside the destination will bring us back to this context.</span>
00231             <span class="comment">//  However, if it is a jmp to a special routine, we must treat it</span>
00232             <span class="comment">//  as a no-level change operation since we won't see the special</span>
00233             <span class="comment">//  routines's return.</span>
00234             <span class="comment">//</span>
00235             <span class="comment">//  If it is not a try/finally, we'd like to treat it as a no-level</span>
00236             <span class="comment">//  change, unless again, it is a transfer to a special call which</span>
00237             <span class="comment">//  views this as a level up.</span>
00238             <span class="comment">//</span>
00239 
00240             <span class="keywordflow">if</span> (<a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a10">KdpIsTryFinallyReturn</a>( Pc, ContextRecord )) {
00241                 <span class="keywordflow">if</span> (*SpecialCall) {
00242                     <span class="comment">//</span>
00243                     <span class="comment">//  We won't see the return, so pretend it is just</span>
00244                     <span class="comment">//  inline code</span>
00245                     <span class="comment">//</span>
00246 
00247                     <span class="keywordflow">return</span> 0;
00248 
00249                 } <span class="keywordflow">else</span> {
00250                     <span class="comment">//</span>
00251                     <span class="comment">//  The destinations return will bring us back to this</span>
00252                     <span class="comment">//  context</span>
00253                     <span class="comment">//</span>
00254 
00255                     <span class="keywordflow">return</span> 1;
00256                 }
00257             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*SpecialCall) {
00258                 <span class="comment">//</span>
00259                 <span class="comment">//  We won't see the return but we are, indeed, doing one.</span>
00260                 <span class="comment">//</span>
00261                 <span class="keywordflow">return</span> -1;
00262             } <span class="keywordflow">else</span> {
00263                 <span class="keywordflow">return</span> 0;
00264             }
00265 
00266         <span class="keywordflow">default</span>:
00267             *SpecialCall = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00268             <span class="keywordflow">return</span> 0;
00269         }
00270 
00271     <span class="keywordflow">case</span> 0xc3:  <span class="comment">//  RET</span>
00272 
00273         <span class="comment">//</span>
00274         <span class="comment">//  If we are a try/finally ret, then we indicate that it is NOT a level</span>
00275         <span class="comment">//  change</span>
00276         <span class="comment">//</span>
00277 
00278         <span class="keywordflow">if</span> (<a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a10">KdpIsTryFinallyReturn</a>( Pc, ContextRecord )) {
00279             *SpecialCall = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00280             <span class="keywordflow">return</span> 0;
00281         }
00282 
00283     <span class="keywordflow">case</span> 0xc2:  <span class="comment">//  RET  w/16 bit esp change</span>
00284     <span class="keywordflow">case</span> 0xca:  <span class="comment">//  RETF w/16 bit esp change</span>
00285     <span class="keywordflow">case</span> 0xcb:  <span class="comment">//  RETF</span>
00286         *SpecialCall = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00287         <span class="keywordflow">return</span> -1;
00288 
00289     <span class="keywordflow">default</span>:
00290         *SpecialCall = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00291         <span class="keywordflow">return</span> 0;
00292     }
00293 
00294 } <span class="comment">// KdpLevelChange</span>
00295 
00296 LONG
00297 <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a6">regValue</a>(
00298     UCHAR reg,
00299     PCONTEXT ContextRecord
00300     )
00301 {
00302     <span class="keywordflow">switch</span> (reg) {
00303     <span class="keywordflow">case</span> 0x0:
00304         <span class="keywordflow">return</span>(ContextRecord-&gt;Eax);
00305         <span class="keywordflow">break</span>;
00306     <span class="keywordflow">case</span> 0x1:
00307         <span class="keywordflow">return</span>(ContextRecord-&gt;Ecx);
00308         <span class="keywordflow">break</span>;
00309     <span class="keywordflow">case</span> 0x2:
00310         <span class="keywordflow">return</span>(ContextRecord-&gt;Edx);
00311         <span class="keywordflow">break</span>;
00312     <span class="keywordflow">case</span> 0x3:
00313         <span class="keywordflow">return</span>(ContextRecord-&gt;Ebx);
00314         <span class="keywordflow">break</span>;
00315     <span class="keywordflow">case</span> 0x4:
00316         <span class="keywordflow">return</span>(ContextRecord-&gt;Esp);
00317         <span class="keywordflow">break</span>;
00318     <span class="keywordflow">case</span> 0x5:
00319         <span class="keywordflow">return</span>(ContextRecord-&gt;Ebp);
00320         <span class="keywordflow">break</span>;
00321     <span class="keywordflow">case</span> 0x6:
00322         <span class="keywordflow">return</span>(ContextRecord-&gt;Esi);
00323         <span class="keywordflow">break</span>;
00324     <span class="keywordflow">case</span> 0x7:
00325         <span class="keywordflow">return</span>(ContextRecord-&gt;Edi);
00326         <span class="keywordflow">break</span>;
00327     }
00328 }
00329 
00330 BOOLEAN
00331 <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a7">KdpIsSpecialCall</a> (
00332     ULONG Pc,
00333     PCONTEXT ContextRecord,
00334     UCHAR opcode,
00335     UCHAR modRM
00336     )
00337 
00338 <span class="comment">/*++</span>
00339 <span class="comment"></span>
00340 <span class="comment">Routine Description:</span>
00341 <span class="comment"></span>
00342 <span class="comment">    Check to see if the instruction at pc is a call to one of the</span>
00343 <span class="comment">    SpecialCall routines.</span>
00344 <span class="comment"></span>
00345 <span class="comment">Argument:</span>
00346 <span class="comment"></span>
00347 <span class="comment">    Pc - program counter of instruction in question.</span>
00348 <span class="comment"></span>
00349 <span class="comment">--*/</span>
00350 {
00351     UCHAR sib;
00352     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> twoBytes;
00353     ULONG callAddr;
00354     ULONG addrAddr;
00355     LONG offset;
00356     ULONG i;
00357     <span class="keywordtype">char</span> d8;
00358 
00359     <span class="keywordflow">if</span> ( opcode == 0xe8 ) {
00360 
00361         <span class="comment">//</span>
00362         <span class="comment">// Signed offset from pc</span>
00363         <span class="comment">//</span>
00364 
00365         <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>( (PCHAR)&amp;offset, (PCHAR)Pc+1, 4 );
00366 
00367         callAddr = Pc + offset + 5; <span class="comment">// +5 for instr len.</span>
00368 
00369     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( opcode == 0xff ) {
00370 
00371         <span class="keywordflow">if</span> ( ((modRM &amp; 0x38) != 0x10) &amp;&amp; ((modRM &amp; 0x38) != 0x20) ) {
00372             <span class="comment">// not call or jump</span>
00373             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00374         }
00375         <span class="keywordflow">if</span> ( (modRM &amp; 0x08) == 0x08 ) {
00376             <span class="comment">// m16:16 or m16:32 -- we don't handle this</span>
00377             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00378         }
00379 
00380         <span class="keywordflow">if</span> ( (modRM &amp; 0xc0) == 0xc0 ) {
00381 
00382             <span class="comment">/* Direct register addressing */</span>
00383             callAddr = <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a6">regValue</a>( (UCHAR)(modRM&amp;0x7), ContextRecord );
00384 
00385         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( (modRM &amp; 0xc7) == 0x05 ) {
00386             <span class="comment">//</span>
00387             <span class="comment">// Calls across dll boundaries involve a call into a jump table,</span>
00388             <span class="comment">// wherein the jump address is set to the real called routine at DLL</span>
00389             <span class="comment">// load time.  Check to see if we're calling such an instruction,</span>
00390             <span class="comment">// and if so, compute its target address and set callAddr there.</span>
00391             <span class="comment">//</span>
00392             <span class="comment">//  ff15 or ff25 -- call or jump indirect with disp32.  Get</span>
00393             <span class="comment">//  address of address</span>
00394             <span class="comment">//</span>
00395             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>( (PCHAR)&amp;addrAddr, (PCHAR)Pc+2, 4 );
00396 
00397             <span class="comment">//</span>
00398             <span class="comment">//  Get real destination address</span>
00399             <span class="comment">//</span>
00400             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>( (PCHAR)&amp;callAddr, (PCHAR)addrAddr, 4 );
00401 <span class="comment">//  DPRINT(( "Indirect call/jmp @ %x\n", Pc ));</span>
00402         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( (modRM &amp; 0x7) == 0x4 ) {
00403 
00404             LONG indexValue;
00405 
00406             <span class="comment">/* sib byte present */</span>
00407             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>( (PCHAR)&amp;sib, (PCHAR)Pc+2, 1 );
00408             indexValue = <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a6">regValue</a>( (UCHAR)((sib &amp; 0x31) &gt;&gt; 3), ContextRecord );
00409             <span class="keywordflow">switch</span> ( sib&amp;0xc0 ) {
00410             <span class="keywordflow">case</span> 0x0:  <span class="comment">/* x1 */</span>
00411                 <span class="keywordflow">break</span>;
00412             <span class="keywordflow">case</span> 0x40:
00413                 indexValue *= 2;
00414                 <span class="keywordflow">break</span>;
00415             <span class="keywordflow">case</span> 0x80:
00416                 indexValue *= 4;
00417                 <span class="keywordflow">break</span>;
00418             <span class="keywordflow">case</span> 0xc0:
00419                 indexValue *= 8;
00420                 <span class="keywordflow">break</span>;
00421             } <span class="comment">/* switch */</span>
00422 
00423             <span class="keywordflow">switch</span> ( modRM &amp; 0xc0 ) {
00424 
00425             <span class="keywordflow">case</span> 0x0: <span class="comment">/* no displacement */</span>
00426                 <span class="keywordflow">if</span> ( (sib &amp; 0x7) == 0x5 ) {
00427 <span class="comment">//                  DPRINT(("funny call #1 at %x\n", Pc));</span>
00428                     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00429                 }
00430                 callAddr = indexValue + <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a6">regValue</a>((UCHAR)(sib&amp;0x7), ContextRecord );
00431                 <span class="keywordflow">break</span>;
00432 
00433             <span class="keywordflow">case</span> 0x40:
00434                 <span class="keywordflow">if</span> ( (sib &amp; 0x6) == 0x4 ) {
00435 <span class="comment">//                  DPRINT(("Funny call #2\n")); /* calling into the stack */</span>
00436                     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00437                 }
00438                 <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>( &amp;d8, (PCHAR)Pc+3,1 );
00439                 callAddr = indexValue + d8 +
00440                                     <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a6">regValue</a>((UCHAR)(sib&amp;0x7), ContextRecord );
00441                 <span class="keywordflow">break</span>;
00442 
00443             <span class="keywordflow">case</span> 0x80:
00444                 <span class="keywordflow">if</span> ( (sib &amp; 0x6) == 0x4 ) {
00445 <span class="comment">//                  DPRINT(("Funny call #3\n")); /* calling into the stack */</span>
00446                     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00447                 }
00448                 <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>( (PCHAR)&amp;offset, (PCHAR)Pc+3, 4 );
00449                 callAddr = indexValue + offset +
00450                                     <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a6">regValue</a>((UCHAR)(sib&amp;0x7), ContextRecord );
00451                 <span class="keywordflow">break</span>;
00452 
00453             <span class="keywordflow">case</span> 0xc0:
00454                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( FALSE );
00455                 <span class="keywordflow">break</span>;
00456 
00457             }
00458 
00459         } <span class="keywordflow">else</span> {
00460             <span class="comment">//KdPrint(( "undecoded call at %x\n",</span>
00461             <span class="comment">//            CONTEXT_TO_PROGRAM_COUNTER(ContextRecord) ));</span>
00462             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00463         }
00464 
00465     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( opcode == 0x9a ) {
00466 
00467         <span class="comment">/* Absolute address call (best I can tell, cc doesn't generate this) */</span>
00468         <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>( (PCHAR)&amp;callAddr, (PCHAR)Pc+1, 4 );
00469 
00470     } <span class="keywordflow">else</span> {
00471         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00472     }
00473 
00474     <span class="comment">//</span>
00475     <span class="comment">// Calls across dll boundaries involve a call into a jump table,</span>
00476     <span class="comment">// wherein the jump address is set to the real called routine at DLL</span>
00477     <span class="comment">// load time.  Check to see if we're calling such an instruction,</span>
00478     <span class="comment">// and if so, compute its target address and set callAddr there.</span>
00479     <span class="comment">//</span>
00480 
00481 <span class="preprocessor">#if 0</span>
00482 <span class="preprocessor"></span>    <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>( (PCHAR)&amp;twoBytes, (PCHAR)callAddr, 2 );
00483     <span class="keywordflow">if</span> ( twoBytes == 0x25ff ) { <span class="comment">/* i386 is little-Endian; really 0xff25 */</span>
00484 
00485         <span class="comment">//</span>
00486         <span class="comment">// This is a 'jmp dword ptr [mem]' instruction, which is the sort of</span>
00487         <span class="comment">// jump used for a dll-boundary crossing call.  Fixup callAddr.</span>
00488         <span class="comment">//</span>
00489 
00490         <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>( (PCHAR)&amp;addrAddr, (PCHAR)callAddr+2, 4 );
00491         <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>( (PCHAR)&amp;callAddr, (PCHAR)addrAddr, 4 );
00492     }
00493 <span class="preprocessor">#endif</span>
00494 <span class="preprocessor"></span>
00495     <span class="keywordflow">for</span> ( i = 0; i &lt; <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a4">KdNumberOfSpecialCalls</a>; i++ ) {
00496         <span class="keywordflow">if</span> ( <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a3">KdSpecialCalls</a>[i] == callAddr ) {
00497             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00498         }
00499     }
00500     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00501 
00502 }
00503 
00504 <span class="comment">/*</span>
00505 <span class="comment"> * Find the return address of the current function.  Only works when</span>
00506 <span class="comment"> * locals haven't yet been pushed (ie, on the first instruction of the</span>
00507 <span class="comment"> * function).</span>
00508 <span class="comment"> */</span>
00509 
00510 ULONG
00511 <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a8">KdpGetReturnAddress</a> (
00512     PCONTEXT ContextRecord
00513     )
00514 {
00515     ULONG retaddr;
00516 
00517     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>((PCHAR)(&amp;retaddr), (PCHAR)(ContextRecord-&gt;Esp), 4 );
00518     <span class="keywordflow">return</span> retaddr;
00519 
00520 } <span class="comment">// KdpGetReturnAddress</span>
00521 
00522 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00523"></a><a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a11">00523</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a113">KdpSetLoadState</a>(
00524     IN PDBGKD_WAIT_STATE_CHANGE64 WaitStateChange,
00525     IN PCONTEXT ContextRecord
00526     )
00527 
00528 <span class="comment">/*++</span>
00529 <span class="comment"></span>
00530 <span class="comment">Routine Description:</span>
00531 <span class="comment"></span>
00532 <span class="comment">    Fill in the Wait_State_Change message record for the load symbol case.</span>
00533 <span class="comment"></span>
00534 <span class="comment">Arguments:</span>
00535 <span class="comment"></span>
00536 <span class="comment">    WaitStateChange - Supplies pointer to record to fill in</span>
00537 <span class="comment"></span>
00538 <span class="comment">    ContextRecord - Supplies a pointer to a context record.</span>
00539 <span class="comment"></span>
00540 <span class="comment">Return Value:</span>
00541 <span class="comment"></span>
00542 <span class="comment">    None.</span>
00543 <span class="comment"></span>
00544 <span class="comment">--*/</span>
00545 
00546 {
00547 
00548     ULONG <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>;
00549     PVOID <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a>;
00550     PKPRCB Prcb;
00551 
00552     <span class="comment">//</span>
00553     <span class="comment">// Store the special x86 register into the control report structure.</span>
00554     <span class="comment">//</span>
00555 
00556     Prcb = <a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a2">KeGetCurrentPrcb</a>();
00557     WaitStateChange-&gt;ControlReport.Dr6 = Prcb-&gt;ProcessorState.SpecialRegisters.KernelDr6;
00558     WaitStateChange-&gt;ControlReport.Dr7 = Prcb-&gt;ProcessorState.SpecialRegisters.KernelDr7;
00559 
00560     <span class="comment">//</span>
00561     <span class="comment">// Copy the immediate instruction stream into the control report structure.</span>
00562     <span class="comment">//</span>
00563 
00564     <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> = <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>((PCHAR)(&amp;(WaitStateChange-&gt;ControlReport.InstructionStream[0])),
00565                           (PCHAR)(WaitStateChange-&gt;ProgramCounter),
00566                           DBGKD_MAXSTREAM);
00567 
00568     WaitStateChange-&gt;ControlReport.InstructionCount = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>;
00569 
00570     <span class="comment">//</span>
00571     <span class="comment">// Clear breakpoints in the copied instruction stream. If any breakpoints</span>
00572     <span class="comment">// are cleared, then recopy the instruction stream.</span>
00573     <span class="comment">//</span>
00574 
00575     <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a> = (PVOID)((PUCHAR)(WaitStateChange-&gt;ProgramCounter) + <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> - 1);
00576     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d7/4_2kdp_8h.html#a106">KdpDeleteBreakpointRange</a>((PVOID)WaitStateChange-&gt;ProgramCounter, <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a>) != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00577         <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>(&amp;WaitStateChange-&gt;ControlReport.InstructionStream[0],
00578                       (PVOID)WaitStateChange-&gt;ProgramCounter,
00579                       <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>);
00580     }
00581 
00582     <span class="comment">//</span>
00583     <span class="comment">// Store the segment registers into the control report structure and set the</span>
00584     <span class="comment">// control flags.</span>
00585     <span class="comment">//</span>
00586 
00587     WaitStateChange-&gt;ControlReport.SegCs = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(ContextRecord-&gt;SegCs);
00588     WaitStateChange-&gt;ControlReport.SegDs = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(ContextRecord-&gt;SegDs);
00589     WaitStateChange-&gt;ControlReport.SegEs = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(ContextRecord-&gt;SegEs);
00590     WaitStateChange-&gt;ControlReport.SegFs = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(ContextRecord-&gt;SegFs);
00591     WaitStateChange-&gt;ControlReport.EFlags = ContextRecord-&gt;EFlags;
00592     WaitStateChange-&gt;ControlReport.ReportFlags = REPORT_INCLUDES_SEGS;
00593 
00594     <span class="comment">//</span>
00595     <span class="comment">//  Copy context record into wait state change structure.</span>
00596     <span class="comment">//</span>
00597 
00598     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>((PCHAR)(&amp;WaitStateChange-&gt;Context),
00599                   (PCHAR)ContextRecord,
00600                   <span class="keyword">sizeof</span>(CONTEXT));
00601 
00602     <span class="keywordflow">return</span>;
00603 }
00604 
00605 
00606 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00607"></a><a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a12">00607</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a114">KdpSetStateChange</a>(
00608     IN PDBGKD_WAIT_STATE_CHANGE64 WaitStateChange,
00609     IN PEXCEPTION_RECORD ExceptionRecord,
00610     IN PCONTEXT ContextRecord,
00611     IN BOOLEAN SecondChance
00612     )
00613 
00614 <span class="comment">/*++</span>
00615 <span class="comment"></span>
00616 <span class="comment">Routine Description:</span>
00617 <span class="comment"></span>
00618 <span class="comment">    Fill in the Wait_State_Change message record.</span>
00619 <span class="comment"></span>
00620 <span class="comment">Arguments:</span>
00621 <span class="comment"></span>
00622 <span class="comment">    WaitStateChange - Supplies pointer to record to fill in</span>
00623 <span class="comment"></span>
00624 <span class="comment">    ExceptionRecord - Supplies a pointer to an exception record.</span>
00625 <span class="comment"></span>
00626 <span class="comment">    ContextRecord - Supplies a pointer to a context record.</span>
00627 <span class="comment"></span>
00628 <span class="comment">    SecondChance - Supplies a boolean value that determines whether this is</span>
00629 <span class="comment">        the first or second chance for the exception.</span>
00630 <span class="comment"></span>
00631 <span class="comment">Return Value:</span>
00632 <span class="comment"></span>
00633 <span class="comment">    None.</span>
00634 <span class="comment"></span>
00635 <span class="comment">--*/</span>
00636 
00637 {
00638     PKPRCB Prcb;
00639     BOOLEAN status;
00640 
00641     <span class="comment">//</span>
00642     <span class="comment">//  Set up description of event, including exception record</span>
00643     <span class="comment">//</span>
00644 
00645     WaitStateChange-&gt;NewState = DbgKdExceptionStateChange;
00646     WaitStateChange-&gt;ProcessorLevel = <a class="code" href="../../d4/d9/ke_8h.html#a135">KeProcessorLevel</a>;
00647     WaitStateChange-&gt;Processor = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a2">KeGetCurrentPrcb</a>()-&gt;Number;
00648     WaitStateChange-&gt;NumberProcessors = (ULONG)<a class="code" href="../../d4/d9/ke_8h.html#a133">KeNumberProcessors</a>;
00649     WaitStateChange-&gt;Thread = (ULONG64)(LONG64)(LONG_PTR) <a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>();
00650     WaitStateChange-&gt;ProgramCounter = (ULONG64)(LONG64)(LONG_PTR) CONTEXT_TO_PROGRAM_COUNTER(ContextRecord);
00651     <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(EXCEPTION_RECORD) == <span class="keyword">sizeof</span>(WaitStateChange-&gt;u.Exception.ExceptionRecord)) {
00652         <a class="code" href="../../d1/d7/4_2kdp_8h.html#a111">KdpQuickMoveMemory</a>((PCHAR)&amp;WaitStateChange-&gt;u.Exception.ExceptionRecord,
00653                            (PCHAR)ExceptionRecord,
00654                            <span class="keyword">sizeof</span>(EXCEPTION_RECORD));
00655     } <span class="keywordflow">else</span> {
00656         ExceptionRecord32To64((PEXCEPTION_RECORD32)ExceptionRecord,
00657                               &amp;WaitStateChange-&gt;u.Exception.ExceptionRecord
00658                               );
00659     }
00660     WaitStateChange-&gt;u.Exception.FirstChance = !SecondChance;
00661 
00662     <span class="comment">//</span>
00663     <span class="comment">//  Copy instruction stream immediately following location of event</span>
00664     <span class="comment">//</span>
00665 
00666     WaitStateChange-&gt;ControlReport.InstructionCount =
00667         (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>(
00668             (PCHAR)(&amp;(WaitStateChange-&gt;ControlReport.InstructionStream[0])),
00669             (PCHAR)(WaitStateChange-&gt;ProgramCounter),
00670             DBGKD_MAXSTREAM
00671             );
00672 
00673     <span class="comment">//</span>
00674     <span class="comment">//  Copy context record immediately following instruction stream</span>
00675     <span class="comment">//</span>
00676 
00677     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>(
00678         (PCHAR)(&amp;WaitStateChange-&gt;Context),
00679         (PCHAR)ContextRecord,
00680         <span class="keyword">sizeof</span>(*ContextRecord)
00681         );
00682 
00683     <span class="comment">//</span>
00684     <span class="comment">//  Clear breakpoints in copied area</span>
00685     <span class="comment">//</span>
00686 
00687     status = <a class="code" href="../../d1/d7/4_2kdp_8h.html#a106">KdpDeleteBreakpointRange</a>(
00688         (PVOID)WaitStateChange-&gt;ProgramCounter,
00689         (PVOID)((PUCHAR)WaitStateChange-&gt;ProgramCounter +
00690             WaitStateChange-&gt;ControlReport.InstructionCount - 1)
00691         );
00692 
00693     <span class="comment">//</span>
00694     <span class="comment">//  If there were any breakpoints cleared, recopy the area without them</span>
00695     <span class="comment">//</span>
00696 
00697     <span class="keywordflow">if</span> (status == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00698         <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>(
00699             (PUCHAR) &amp;(WaitStateChange-&gt;ControlReport.InstructionStream[0]),
00700             (PUCHAR) WaitStateChange-&gt;ProgramCounter,
00701             WaitStateChange-&gt;ControlReport.InstructionCount
00702             );
00703     }
00704 
00705 
00706     <span class="comment">//</span>
00707     <span class="comment">//  Special registers for the x86</span>
00708     <span class="comment">//</span>
00709     Prcb = <a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a2">KeGetCurrentPrcb</a>();
00710 
00711     WaitStateChange-&gt;ControlReport.Dr6 =
00712         Prcb-&gt;ProcessorState.SpecialRegisters.KernelDr6;
00713 
00714     WaitStateChange-&gt;ControlReport.Dr7 =
00715         Prcb-&gt;ProcessorState.SpecialRegisters.KernelDr7;
00716 
00717     WaitStateChange-&gt;ControlReport.SegCs  = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(ContextRecord-&gt;SegCs);
00718     WaitStateChange-&gt;ControlReport.SegDs  = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(ContextRecord-&gt;SegDs);
00719     WaitStateChange-&gt;ControlReport.SegEs  = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(ContextRecord-&gt;SegEs);
00720     WaitStateChange-&gt;ControlReport.SegFs  = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(ContextRecord-&gt;SegFs);
00721     WaitStateChange-&gt;ControlReport.EFlags = ContextRecord-&gt;EFlags;
00722 
00723     WaitStateChange-&gt;ControlReport.ReportFlags = REPORT_INCLUDES_SEGS;
00724 
00725 }
00726 
00727 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00728"></a><a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a13">00728</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a115">KdpGetStateChange</a>(
00729     IN PDBGKD_MANIPULATE_STATE64 ManipulateState,
00730     IN PCONTEXT ContextRecord
00731     )
00732 
00733 <span class="comment">/*++</span>
00734 <span class="comment"></span>
00735 <span class="comment">Routine Description:</span>
00736 <span class="comment"></span>
00737 <span class="comment">    Extract continuation control data from Manipulate_State message</span>
00738 <span class="comment"></span>
00739 <span class="comment">Arguments:</span>
00740 <span class="comment"></span>
00741 <span class="comment">    ManipulateState - supplies pointer to Manipulate_State packet</span>
00742 <span class="comment"></span>
00743 <span class="comment">    ContextRecord - Supplies a pointer to a context record.</span>
00744 <span class="comment"></span>
00745 <span class="comment">Return Value:</span>
00746 <span class="comment"></span>
00747 <span class="comment">    None.</span>
00748 <span class="comment"></span>
00749 <span class="comment">--*/</span>
00750 
00751 {
00752     PKPRCB Prcb;
00753     ULONG  Processor;
00754 
00755     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(ManipulateState-&gt;u.Continue2.ContinueStatus) == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00756 
00757         <span class="comment">//</span>
00758         <span class="comment">// If NT_SUCCESS returns TRUE, then the debugger is doing a</span>
00759         <span class="comment">// continue, and it makes sense to apply control changes.</span>
00760         <span class="comment">// Otherwise the debugger is saying that it doesn't know what</span>
00761         <span class="comment">// to do with this exception, so control values are ignored.</span>
00762         <span class="comment">//</span>
00763 
00764         <span class="keywordflow">if</span> (ManipulateState-&gt;u.Continue2.ControlSet.TraceFlag == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00765             ContextRecord-&gt;EFlags |= 0x100<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>;
00766 
00767         } <span class="keywordflow">else</span> {
00768             ContextRecord-&gt;EFlags &amp;= ~0x100<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>;
00769 
00770         }
00771 
00772         <span class="keywordflow">for</span> (Processor = 0; Processor &lt; (ULONG)<a class="code" href="../../d4/d9/ke_8h.html#a133">KeNumberProcessors</a>; Processor++) {
00773             Prcb = <a class="code" href="../../d4/d9/ke_8h.html#a139">KiProcessorBlock</a>[Processor];
00774 
00775             Prcb-&gt;ProcessorState.SpecialRegisters.KernelDr7 =
00776                 ManipulateState-&gt;u.Continue2.ControlSet.Dr7;
00777 
00778             Prcb-&gt;ProcessorState.SpecialRegisters.KernelDr6 = 0<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>;
00779         }
00780         <span class="keywordflow">if</span> (ManipulateState-&gt;u.Continue2.ControlSet.CurrentSymbolStart != 1) {
00781             <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a1">KdpCurrentSymbolStart</a> = ManipulateState-&gt;u.Continue2.ControlSet.CurrentSymbolStart;
00782             <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a2">KdpCurrentSymbolEnd</a> = ManipulateState-&gt;u.Continue2.ControlSet.CurrentSymbolEnd;
00783         }
00784     }
00785 }
00786 
00787 
00788 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00789"></a><a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a14">00789</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a132">KdpReadControlSpace</a>(
00790     IN PDBGKD_MANIPULATE_STATE64 m,
00791     IN PSTRING AdditionalData,
00792     IN PCONTEXT Context
00793     )
00794 
00795 <span class="comment">/*++</span>
00796 <span class="comment"></span>
00797 <span class="comment">Routine Description:</span>
00798 <span class="comment"></span>
00799 <span class="comment">    This function is called in response of a read control space state</span>
00800 <span class="comment">    manipulation message.  Its function is to read implementation</span>
00801 <span class="comment">    specific system data.</span>
00802 <span class="comment"></span>
00803 <span class="comment">    IMPLEMENTATION NOTE:</span>
00804 <span class="comment"></span>
00805 <span class="comment">        On the X86, control space is defined as follows:</span>
00806 <span class="comment"></span>
00807 <span class="comment">            0:  Base of KPROCESSOR_STATE structure. (KPRCB.ProcessorState)</span>
00808 <span class="comment">                    This includes CONTEXT record,</span>
00809 <span class="comment">                    followed by a SPECIAL_REGISTERs record</span>
00810 <span class="comment"></span>
00811 <span class="comment">Arguments:</span>
00812 <span class="comment"></span>
00813 <span class="comment">    m - Supplies the state manipulation message.</span>
00814 <span class="comment"></span>
00815 <span class="comment">    AdditionalData - Supplies any additional data for the message.</span>
00816 <span class="comment"></span>
00817 <span class="comment">    Context - Supplies the current context.</span>
00818 <span class="comment"></span>
00819 <span class="comment">Return Value:</span>
00820 <span class="comment"></span>
00821 <span class="comment">    None.</span>
00822 <span class="comment"></span>
00823 <span class="comment">--*/</span>
00824 
00825 {
00826     PDBGKD_READ_MEMORY64 a = &amp;m-&gt;u.ReadMemory;
00827     STRING MessageHeader;
00828     ULONG Length, <a class="code" href="../../d4/d1/genmips_8c.html#a17">t</a>;
00829     PVOID StartAddr;
00830 
00831     MessageHeader.Length = <span class="keyword">sizeof</span>(*m);
00832     MessageHeader.Buffer = (PCHAR)m;
00833 
00834     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(AdditionalData-&gt;Length == 0);
00835 
00836     <span class="keywordflow">if</span> (a-&gt;TransferCount &gt; (PACKET_MAX_SIZE - <span class="keyword">sizeof</span>(DBGKD_MANIPULATE_STATE64))) {
00837         Length = PACKET_MAX_SIZE - <span class="keyword">sizeof</span>(DBGKD_MANIPULATE_STATE64);
00838     } <span class="keywordflow">else</span> {
00839         Length = a-&gt;TransferCount;
00840     }
00841     <span class="keywordflow">if</span> ((a-&gt;TargetBaseAddress &lt; (ULONG64)(<span class="keyword">sizeof</span>(KPROCESSOR_STATE))) &amp;&amp;
00842         (m-&gt;Processor &lt; (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d4/d9/ke_8h.html#a133">KeNumberProcessors</a>)) {
00843         <a class="code" href="../../d4/d1/genmips_8c.html#a17">t</a> = (ULONG)(<span class="keyword">sizeof</span>(KPROCESSOR_STATE)) - (ULONG)(a-&gt;TargetBaseAddress);
00844         <span class="keywordflow">if</span> (<a class="code" href="../../d4/d1/genmips_8c.html#a17">t</a> &lt; Length) {
00845             Length = <a class="code" href="../../d4/d1/genmips_8c.html#a17">t</a>;
00846         }
00847         StartAddr = (PVOID)((ULONG)a-&gt;TargetBaseAddress +
00848                             (ULONG)&amp;(<a class="code" href="../../d4/d9/ke_8h.html#a139">KiProcessorBlock</a>[m-&gt;Processor]-&gt;ProcessorState));
00849         AdditionalData-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>(
00850                                     AdditionalData-&gt;Buffer,
00851                                     StartAddr,
00852                                     Length
00853                                     );
00854 
00855         <span class="keywordflow">if</span> (Length == AdditionalData-&gt;Length) {
00856             m-&gt;ReturnStatus = STATUS_SUCCESS;
00857         } <span class="keywordflow">else</span> {
00858             m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
00859         }
00860         a-&gt;ActualBytesRead = AdditionalData-&gt;Length;
00861 
00862     } <span class="keywordflow">else</span> {
00863         AdditionalData-&gt;Length = 0;
00864         m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
00865         a-&gt;ActualBytesRead = 0;
00866     }
00867 
00868     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(
00869         PACKET_TYPE_KD_STATE_MANIPULATE,
00870         &amp;MessageHeader,
00871         AdditionalData
00872         );
00873     UNREFERENCED_PARAMETER(Context);
00874 }
00875 
00876 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00877"></a><a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a15">00877</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a133">KdpWriteControlSpace</a>(
00878     IN PDBGKD_MANIPULATE_STATE64 m,
00879     IN PSTRING AdditionalData,
00880     IN PCONTEXT Context
00881     )
00882 
00883 <span class="comment">/*++</span>
00884 <span class="comment"></span>
00885 <span class="comment">Routine Description:</span>
00886 <span class="comment"></span>
00887 <span class="comment">    This function is called in response of a write control space state</span>
00888 <span class="comment">    manipulation message.  Its function is to write implementation</span>
00889 <span class="comment">    specific system data.</span>
00890 <span class="comment"></span>
00891 <span class="comment">    Control space for x86 is as defined above.</span>
00892 <span class="comment"></span>
00893 <span class="comment">Arguments:</span>
00894 <span class="comment"></span>
00895 <span class="comment">    m - Supplies the state manipulation message.</span>
00896 <span class="comment"></span>
00897 <span class="comment">    AdditionalData - Supplies any additional data for the message.</span>
00898 <span class="comment"></span>
00899 <span class="comment">    Context - Supplies the current context.</span>
00900 <span class="comment"></span>
00901 <span class="comment">Return Value:</span>
00902 <span class="comment"></span>
00903 <span class="comment">    None.</span>
00904 <span class="comment"></span>
00905 <span class="comment">--*/</span>
00906 
00907 {
00908     PDBGKD_WRITE_MEMORY64 a = &amp;m-&gt;u.WriteMemory;
00909     ULONG Length;
00910     STRING MessageHeader;
00911     PVOID StartAddr;
00912 
00913     MessageHeader.Length = <span class="keyword">sizeof</span>(*m);
00914     MessageHeader.Buffer = (PCHAR)m;
00915 
00916     <span class="keywordflow">if</span> ((((PUCHAR)a-&gt;TargetBaseAddress + a-&gt;TransferCount) &lt;=
00917         (PUCHAR)(<span class="keyword">sizeof</span>(KPROCESSOR_STATE))) &amp;&amp; (m-&gt;Processor &lt; (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d4/d9/ke_8h.html#a133">KeNumberProcessors</a>)) {
00918 
00919         StartAddr = (PVOID)((ULONG)a-&gt;TargetBaseAddress +
00920                             (ULONG)&amp;(<a class="code" href="../../d4/d9/ke_8h.html#a139">KiProcessorBlock</a>[m-&gt;Processor]-&gt;ProcessorState));
00921 
00922         Length = <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>(
00923                             StartAddr,
00924                             AdditionalData-&gt;Buffer,
00925                             AdditionalData-&gt;Length
00926                             );
00927 
00928         <span class="keywordflow">if</span> (Length == AdditionalData-&gt;Length) {
00929             m-&gt;ReturnStatus = STATUS_SUCCESS;
00930         } <span class="keywordflow">else</span> {
00931             m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
00932         }
00933         a-&gt;ActualBytesWritten = Length;
00934 
00935     } <span class="keywordflow">else</span> {
00936         AdditionalData-&gt;Length = 0;
00937         m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
00938         a-&gt;ActualBytesWritten = 0;
00939     }
00940 
00941     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(
00942         PACKET_TYPE_KD_STATE_MANIPULATE,
00943         &amp;MessageHeader,
00944         AdditionalData
00945         );
00946     UNREFERENCED_PARAMETER(Context);
00947 }
00948 
00949 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00950"></a><a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a16">00950</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a134">KdpReadIoSpace</a>(
00951     IN PDBGKD_MANIPULATE_STATE64 m,
00952     IN PSTRING AdditionalData,
00953     IN PCONTEXT Context
00954     )
00955 
00956 <span class="comment">/*++</span>
00957 <span class="comment"></span>
00958 <span class="comment">Routine Description:</span>
00959 <span class="comment"></span>
00960 <span class="comment">    This function is called in response of a read io space state</span>
00961 <span class="comment">    manipulation message.  Its function is to read system io</span>
00962 <span class="comment">    locations.</span>
00963 <span class="comment"></span>
00964 <span class="comment">Arguments:</span>
00965 <span class="comment"></span>
00966 <span class="comment">    m - Supplies the state manipulation message.</span>
00967 <span class="comment"></span>
00968 <span class="comment">    AdditionalData - Supplies any additional data for the message.</span>
00969 <span class="comment"></span>
00970 <span class="comment">    Context - Supplies the current context.</span>
00971 <span class="comment"></span>
00972 <span class="comment">Return Value:</span>
00973 <span class="comment"></span>
00974 <span class="comment">    None.</span>
00975 <span class="comment"></span>
00976 <span class="comment">--*/</span>
00977 
00978 {
00979     PDBGKD_READ_WRITE_IO64 a = &amp;m-&gt;u.ReadWriteIo;
00980     STRING MessageHeader;
00981 
00982     MessageHeader.Length = <span class="keyword">sizeof</span>(*m);
00983     MessageHeader.Buffer = (PCHAR)m;
00984 
00985     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(AdditionalData-&gt;Length == 0);
00986 
00987     m-&gt;ReturnStatus = STATUS_SUCCESS;
00988 
00989     <span class="comment">//</span>
00990     <span class="comment">// Check Size and Alignment</span>
00991     <span class="comment">//</span>
00992 
00993     <span class="keywordflow">switch</span> ( a-&gt;DataSize ) {
00994         <span class="keywordflow">case</span> 1:
00995             a-&gt;DataValue = (ULONG)READ_PORT_UCHAR((PUCHAR)a-&gt;IoAddress);
00996             <span class="keywordflow">break</span>;
00997         <span class="keywordflow">case</span> 2:
00998             <span class="keywordflow">if</span> ((ULONG)a-&gt;IoAddress &amp; 1 ) {
00999                 m-&gt;ReturnStatus = STATUS_DATATYPE_MISALIGNMENT;
01000             } <span class="keywordflow">else</span> {
01001                 a-&gt;DataValue = (ULONG)READ_PORT_USHORT((<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>)a-&gt;IoAddress);
01002             }
01003             <span class="keywordflow">break</span>;
01004         <span class="keywordflow">case</span> 4:
01005             <span class="keywordflow">if</span> ((ULONG)a-&gt;IoAddress &amp; 3 ) {
01006                 m-&gt;ReturnStatus = STATUS_DATATYPE_MISALIGNMENT;
01007             } <span class="keywordflow">else</span> {
01008                 a-&gt;DataValue = READ_PORT_ULONG((PULONG)a-&gt;IoAddress);
01009             }
01010             <span class="keywordflow">break</span>;
01011         <span class="keywordflow">default</span>:
01012             m-&gt;ReturnStatus = STATUS_INVALID_PARAMETER;
01013     }
01014 
01015     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(
01016         PACKET_TYPE_KD_STATE_MANIPULATE,
01017         &amp;MessageHeader,
01018         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
01019         );
01020     UNREFERENCED_PARAMETER(Context);
01021 }
01022 
01023 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01024"></a><a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a17">01024</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a136">KdpWriteIoSpace</a>(
01025     IN PDBGKD_MANIPULATE_STATE64 m,
01026     IN PSTRING AdditionalData,
01027     IN PCONTEXT Context
01028     )
01029 
01030 <span class="comment">/*++</span>
01031 <span class="comment"></span>
01032 <span class="comment">Routine Description:</span>
01033 <span class="comment"></span>
01034 <span class="comment">    This function is called in response of a write io space state</span>
01035 <span class="comment">    manipulation message.  Its function is to write to system io</span>
01036 <span class="comment">    locations.</span>
01037 <span class="comment"></span>
01038 <span class="comment">Arguments:</span>
01039 <span class="comment"></span>
01040 <span class="comment">    m - Supplies the state manipulation message.</span>
01041 <span class="comment"></span>
01042 <span class="comment">    AdditionalData - Supplies any additional data for the message.</span>
01043 <span class="comment"></span>
01044 <span class="comment">    Context - Supplies the current context.</span>
01045 <span class="comment"></span>
01046 <span class="comment">Return Value:</span>
01047 <span class="comment"></span>
01048 <span class="comment">    None.</span>
01049 <span class="comment"></span>
01050 <span class="comment">--*/</span>
01051 
01052 {
01053     PDBGKD_READ_WRITE_IO64 a = &amp;m-&gt;u.ReadWriteIo;
01054     STRING MessageHeader;
01055 
01056     MessageHeader.Length = <span class="keyword">sizeof</span>(*m);
01057     MessageHeader.Buffer = (PCHAR)m;
01058 
01059     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(AdditionalData-&gt;Length == 0);
01060 
01061     m-&gt;ReturnStatus = STATUS_SUCCESS;
01062 
01063     <span class="comment">//</span>
01064     <span class="comment">// Check Size and Alignment</span>
01065     <span class="comment">//</span>
01066 
01067     <span class="keywordflow">switch</span> ( a-&gt;DataSize ) {
01068         <span class="keywordflow">case</span> 1:
01069             WRITE_PORT_UCHAR((PUCHAR)a-&gt;IoAddress, (UCHAR)a-&gt;DataValue);
01070             <span class="keywordflow">break</span>;
01071         <span class="keywordflow">case</span> 2:
01072             <span class="keywordflow">if</span> ((ULONG)a-&gt;IoAddress &amp; 1 ) {
01073                 m-&gt;ReturnStatus = STATUS_DATATYPE_MISALIGNMENT;
01074             } <span class="keywordflow">else</span> {
01075                 WRITE_PORT_USHORT((<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>)a-&gt;IoAddress, (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)a-&gt;DataValue);
01076             }
01077             <span class="keywordflow">break</span>;
01078         <span class="keywordflow">case</span> 4:
01079             <span class="keywordflow">if</span> ((ULONG)a-&gt;IoAddress &amp; 3 ) {
01080                 m-&gt;ReturnStatus = STATUS_DATATYPE_MISALIGNMENT;
01081             } <span class="keywordflow">else</span> {
01082                 WRITE_PORT_ULONG((PULONG)a-&gt;IoAddress, a-&gt;DataValue);
01083             }
01084             <span class="keywordflow">break</span>;
01085         <span class="keywordflow">default</span>:
01086             m-&gt;ReturnStatus = STATUS_INVALID_PARAMETER;
01087     }
01088 
01089     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(
01090         PACKET_TYPE_KD_STATE_MANIPULATE,
01091         &amp;MessageHeader,
01092         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
01093         );
01094     UNREFERENCED_PARAMETER(Context);
01095 }
01096 
01097 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01098"></a><a class="code" href="../../d1/d7/4_2kdp_8h.html#a135">01098</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a135">KdpReadMachineSpecificRegister</a>(
01099     IN PDBGKD_MANIPULATE_STATE64 m,
01100     IN PSTRING AdditionalData,
01101     IN PCONTEXT Context
01102     )
01103 
01104 <span class="comment">/*++</span>
01105 <span class="comment"></span>
01106 <span class="comment">Routine Description:</span>
01107 <span class="comment"></span>
01108 <span class="comment">    This function is called in response of a read MSR</span>
01109 <span class="comment">    manipulation message.  Its function is to read the MSR.</span>
01110 <span class="comment"></span>
01111 <span class="comment">Arguments:</span>
01112 <span class="comment"></span>
01113 <span class="comment">    m - Supplies the state manipulation message.</span>
01114 <span class="comment"></span>
01115 <span class="comment">    AdditionalData - Supplies any additional data for the message.</span>
01116 <span class="comment"></span>
01117 <span class="comment">    Context - Supplies the current context.</span>
01118 <span class="comment"></span>
01119 <span class="comment">Return Value:</span>
01120 <span class="comment"></span>
01121 <span class="comment">    None.</span>
01122 <span class="comment"></span>
01123 <span class="comment">--*/</span>
01124 
01125 {
01126     PDBGKD_READ_WRITE_MSR a = &amp;m-&gt;u.ReadWriteMsr;
01127     STRING MessageHeader;
01128     LARGE_INTEGER l;
01129 
01130     MessageHeader.Length = <span class="keyword">sizeof</span>(*m);
01131     MessageHeader.Buffer = (PCHAR)m;
01132 
01133     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(AdditionalData-&gt;Length == 0);
01134 
01135     m-&gt;ReturnStatus = STATUS_SUCCESS;
01136 
01137     <span class="keywordflow">try</span> {
01138         l.QuadPart = <a class="code" href="../../d5/d3/i386_8h.html#a52">RDMSR</a>(a-&gt;Msr);
01139     } except (<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
01140         l.QuadPart = 0;
01141         m-&gt;ReturnStatus = STATUS_NO_SUCH_DEVICE;
01142     }
01143 
01144     a-&gt;DataValueLow  = l.LowPart;
01145     a-&gt;DataValueHigh = l.HighPart;
01146 
01147     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(
01148         PACKET_TYPE_KD_STATE_MANIPULATE,
01149         &amp;MessageHeader,
01150         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
01151         );
01152     UNREFERENCED_PARAMETER(Context);
01153 }
01154 
01155 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01156"></a><a class="code" href="../../d1/d7/4_2kdp_8h.html#a137">01156</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a137">KdpWriteMachineSpecificRegister</a>(
01157     IN PDBGKD_MANIPULATE_STATE64 m,
01158     IN PSTRING AdditionalData,
01159     IN PCONTEXT Context
01160     )
01161 
01162 <span class="comment">/*++</span>
01163 <span class="comment"></span>
01164 <span class="comment">Routine Description:</span>
01165 <span class="comment"></span>
01166 <span class="comment">    This function is called in response of a write of a MSR</span>
01167 <span class="comment">    manipulation message.  Its function is to write to the MSR</span>
01168 <span class="comment"></span>
01169 <span class="comment">Arguments:</span>
01170 <span class="comment"></span>
01171 <span class="comment">    m - Supplies the state manipulation message.</span>
01172 <span class="comment"></span>
01173 <span class="comment">    AdditionalData - Supplies any additional data for the message.</span>
01174 <span class="comment"></span>
01175 <span class="comment">    Context - Supplies the current context.</span>
01176 <span class="comment"></span>
01177 <span class="comment">Return Value:</span>
01178 <span class="comment"></span>
01179 <span class="comment">    None.</span>
01180 <span class="comment"></span>
01181 <span class="comment">--*/</span>
01182 
01183 {
01184     PDBGKD_READ_WRITE_MSR a = &amp;m-&gt;u.ReadWriteMsr;
01185     STRING MessageHeader;
01186     LARGE_INTEGER l;
01187 
01188     MessageHeader.Length = <span class="keyword">sizeof</span>(*m);
01189     MessageHeader.Buffer = (PCHAR)m;
01190 
01191     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(AdditionalData-&gt;Length == 0);
01192 
01193     m-&gt;ReturnStatus = STATUS_SUCCESS;
01194 
01195     l.HighPart = a-&gt;DataValueHigh;
01196     l.LowPart = a-&gt;DataValueLow;
01197 
01198     <span class="keywordflow">try</span> {
01199         <a class="code" href="../../d5/d3/i386_8h.html#a53">WRMSR</a> (a-&gt;Msr, l.QuadPart);
01200     } except (<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
01201         m-&gt;ReturnStatus = STATUS_NO_SUCH_DEVICE;
01202     }
01203 
01204     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(
01205         PACKET_TYPE_KD_STATE_MANIPULATE,
01206         &amp;MessageHeader,
01207         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
01208         );
01209     UNREFERENCED_PARAMETER(Context);
01210 }
01211 
01212 <span class="comment">/*** KdpGetCallNextOffset - compute "next" instruction on a call-like instruction</span>
01213 <span class="comment">*</span>
01214 <span class="comment">*   Purpose:</span>
01215 <span class="comment">*       Compute how many bytes are in a call-type instruction</span>
01216 <span class="comment">*       so that a breakpoint can be set upon this instruction's</span>
01217 <span class="comment">*       return.  Treat indirect jmps as if they were call/ret/ret</span>
01218 <span class="comment">*</span>
01219 <span class="comment">*   Returns:</span>
01220 <span class="comment">*       offset to "next" instruction, or 0 if it wasn't a call instruction.</span>
01221 <span class="comment">*</span>
01222 <span class="comment">*************************************************************************/</span>
01223 
01224 ULONG
01225 <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a9">KdpGetCallNextOffset</a> (
01226     ULONG Pc,
01227     PCONTEXT ContextRecord
01228     )
01229 {
01230     UCHAR membuf[2];
01231     UCHAR opcode;
01232     ULONG sib;
01233     ULONG disp;
01234 
01235     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>( membuf, (PVOID)Pc, 2 );
01236     opcode = membuf[0];
01237 
01238     <span class="keywordflow">if</span> ( opcode == 0xe8 ) {         <span class="comment">//  CALL 32 bit disp</span>
01239         <span class="keywordflow">return</span> Pc+5;
01240     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( opcode == 0x9a ) {  <span class="comment">//  CALL 16:32</span>
01241         <span class="keywordflow">return</span> Pc+7;
01242     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( opcode == 0xff ) {
01243         <span class="keywordflow">if</span> ( membuf[1] == 0x25) {   <span class="comment">//  JMP indirect</span>
01244             <span class="keywordflow">return</span> <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a8">KdpGetReturnAddress</a>( ContextRecord );
01245         }
01246         sib = ((membuf[1] &amp; 0x07) == 0x04) ? 1 : 0;
01247         disp = (membuf[1] &amp; 0xc0) &gt;&gt; 6;
01248         <span class="keywordflow">switch</span> (disp) {
01249         <span class="keywordflow">case</span> 0:
01250             <span class="keywordflow">if</span> ( (membuf[1] &amp; 0x07) == 0x05 ) {
01251                 disp = 4; <span class="comment">// disp32 alone</span>
01252             } <span class="keywordflow">else</span> {
01253                 <span class="comment">// disp = 0; // no displacement with reg or sib</span>
01254             }
01255             <span class="keywordflow">break</span>;
01256         <span class="keywordflow">case</span> 1:
01257             <span class="comment">// disp = 1; // disp8 with reg or sib</span>
01258             <span class="keywordflow">break</span>;
01259         <span class="keywordflow">case</span> 2:
01260             disp = 4; <span class="comment">// disp32 with reg or sib</span>
01261             <span class="keywordflow">break</span>;
01262         <span class="keywordflow">case</span> 3:
01263             disp = 0; <span class="comment">// direct register addressing (e.g., call esi)</span>
01264             <span class="keywordflow">break</span>;
01265         }
01266         <span class="keywordflow">return</span> Pc + 2 + sib + disp;
01267     }
01268 
01269     <span class="keywordflow">return</span> 0;
01270 
01271 } <span class="comment">// KdpGetCallNextOffset</span>
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:34 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
