<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: vmcbsup.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>vmcbsup.c</h1><a href="../../d6/d6/vmcbsup_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1989  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    VmcbSup.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    Historical note: this package was originally written for HPFS (pinball)</span>
00012 <span class="comment">    and is now resurrected for UDFS.  Since UDFS is readonly in initial</span>
00013 <span class="comment">    versions we will snip by #ifdef the write support, leaving it visible</span>
00014 <span class="comment">    for the future - this code has not been changed (nearly) whatsoever and</span>
00015 <span class="comment">    is left named as Pb (pinball) code.</span>
00016 <span class="comment"></span>
00017 <span class="comment">    The VMCB routines provide support for maintaining a mapping between</span>
00018 <span class="comment">    LBNs and VBNs for a virtual volume file.  The volume file is all</span>
00019 <span class="comment">    of the sectors that make up the on-disk structures.  A file system</span>
00020 <span class="comment">    uses this package to map LBNs for on-disk structure to VBNs in a volume</span>
00021 <span class="comment">    file.  This when used in conjunction with Memory Management and the</span>
00022 <span class="comment">    Cache Manager will treat the volume file as a simple mapped file.  A</span>
00023 <span class="comment">    variable of type VMCB is used to store the mapping information and one</span>
00024 <span class="comment">    is needed for every mounted volume.</span>
00025 <span class="comment"></span>
00026 <span class="comment">    The main idea behind this package is to allow the user to dynamically</span>
00027 <span class="comment">    read in new disk structure sectors (e.g., File Entries).  The user assigns</span>
00028 <span class="comment">    the new sector a VBN in the Volume file and has memory management fault</span>
00029 <span class="comment">    the page containing the sector into memory.  To do this Memory management</span>
00030 <span class="comment">    will call back into the file system to read the page from the volume file</span>
00031 <span class="comment">    passing in the appropriate VBN.  Now the file system takes the VBN and</span>
00032 <span class="comment">    maps it back to its LBN and does the read.</span>
00033 <span class="comment"></span>
00034 <span class="comment">    The granularity of mapping is one a per page basis.  That is if</span>
00035 <span class="comment">    a mapping for LBN 8 is added to the VMCB structure and the page size</span>
00036 <span class="comment">    is 8 sectors then the VMCB routines will actually assign a mapping for</span>
00037 <span class="comment">    LBNS 8 through 15, and they will be assigned to a page aligned set of</span>
00038 <span class="comment">    VBNS.  This function is needed to allow us to work efficiently with</span>
00039 <span class="comment">    memory management.  This means that some sectors in some pages might</span>
00040 <span class="comment">    actually contain regular file data and not volume information, and so</span>
00041 <span class="comment">    when writing the page out we must only write the sectors that are really</span>
00042 <span class="comment">    in use by the volume file.  To help with this we provide a set</span>
00043 <span class="comment">    of routines to keep track of dirty volume file sectors.</span>
00044 <span class="comment">    That way, when the file system is called to write a page to the volume</span>
00045 <span class="comment">    file, it will only write the sectors that are dirty.</span>
00046 <span class="comment"></span>
00047 <span class="comment">    Concurrent access the VMCB structure is control by this package.</span>
00048 <span class="comment"></span>
00049 <span class="comment">    The functions provided in this package are as follows:</span>
00050 <span class="comment"></span>
00051 <span class="comment">      o  UdfInitializeVmcb - Initialize a new VMCB structure.</span>
00052 <span class="comment"></span>
00053 <span class="comment">      o  UdfUninitializeVmcb - Uninitialize an existing VMCB structure.</span>
00054 <span class="comment"></span>
00055 <span class="comment">      o  UdfSetMaximumLbnVmcb - Sets/Resets the maximum allowed LBN</span>
00056 <span class="comment">         for the specified VMCB structure.</span>
00057 <span class="comment"></span>
00058 <span class="comment">      o  UdfAddVmcbMapping - This routine takes an LBN and assigns to it</span>
00059 <span class="comment">         a VBN.  If the LBN already was assigned to an VBN it simply returns</span>
00060 <span class="comment">         the old VBN and does not do a new assignemnt.</span>
00061 <span class="comment"></span>
00062 <span class="comment">      o  UdfRemoveVmcbMapping - This routine takes an LBN and removes its</span>
00063 <span class="comment">         mapping from the VMCB structure.</span>
00064 <span class="comment"></span>
00065 <span class="comment">      o  UdfVmcbVbnToLbn - This routine takes a VBN and returns the</span>
00066 <span class="comment">         LBN it maps to.</span>
00067 <span class="comment"></span>
00068 <span class="comment">      o  UdfVmcbLbnToVbn - This routine takes an LBN and returns the</span>
00069 <span class="comment">         VBN its maps to.</span>
00070 <span class="comment"></span>
00071 <span class="comment">#if VMCB_WRITE_SUPPORT</span>
00072 <span class="comment"></span>
00073 <span class="comment">      o  PbSetDirtyVmcb - This routine is used to mark sectors dirty</span>
00074 <span class="comment">         in the volume file.</span>
00075 <span class="comment"></span>
00076 <span class="comment">      o  PbSetCleanVmcb - This routine is used to mark sectors clean</span>
00077 <span class="comment">         in the volume file.</span>
00078 <span class="comment"></span>
00079 <span class="comment">      o  PbGetDirtySectorsVmcb - This routine is used to retrieve the</span>
00080 <span class="comment">         dirty sectors for a page in the volume file.</span>
00081 <span class="comment"></span>
00082 <span class="comment">      o  PbGetAndCleanDirtyVmcb - This routine is used to retrieve the</span>
00083 <span class="comment">         dirty sectors for a page in the volume file and atomically clear</span>
00084 <span class="comment">         the dirty sectors.</span>
00085 <span class="comment"></span>
00086 <span class="comment">#endif // VMCB_WRITE_SUPPORT</span>
00087 <span class="comment"></span>
00088 <span class="comment">Authors:</span>
00089 <span class="comment"></span>
00090 <span class="comment">    Gary Kimura     [GaryKi]    4-Apr-1990</span>
00091 <span class="comment">    Dan Lovinger    [DanLo]     10-Sep-1996</span>
00092 <span class="comment"></span>
00093 <span class="comment">Revision History:</span>
00094 <span class="comment"></span>
00095 <span class="comment">--*/</span>
00096 
00097 <span class="preprocessor">#include "UdfProcs.h"</span>
00098 
00099 <span class="comment">//</span>
00100 <span class="comment">//  The Bug check file id for this module</span>
00101 <span class="comment">//</span>
00102 
<a name="l00103"></a><a class="code" href="../../d6/d6/vmcbsup_8c.html#a0">00103</a> <span class="preprocessor">#define BugCheckFileId                   (UDFS_BUG_CHECK_VMCBSUP)</span>
00104 <span class="preprocessor"></span>
00105 <span class="comment">//</span>
00106 <span class="comment">//  The local debug trace level</span>
00107 <span class="comment">//</span>
00108 
<a name="l00109"></a><a class="code" href="../../d6/d6/vmcbsup_8c.html#a1">00109</a> <span class="preprocessor">#define Dbg                              (UDFS_DEBUG_LEVEL_VMCBSUP)</span>
00110 <span class="preprocessor"></span>
00111 <span class="comment">//</span>
00112 <span class="comment">//  Turn off write/dirty/clean sector support</span>
00113 <span class="comment">//</span>
00114 
<a name="l00115"></a><a class="code" href="../../d6/d6/vmcbsup_8c.html#a2">00115</a> <span class="preprocessor">#define VMCB_WRITE_SUPPORT 0</span>
00116 <span class="preprocessor"></span>
00117 
00118 <span class="comment">//</span>
00119 <span class="comment">//  The following macro is used to calculate the number of pages (in terms of</span>
00120 <span class="comment">//  sectors) needed to contain a given sector count.  For example,</span>
00121 <span class="comment">//</span>
00122 <span class="comment">//      PageAlign( 0 Sectors ) = 0 Pages = 0 Sectors</span>
00123 <span class="comment">//      PageAlign( 1 Sectors ) = 1 Page  = 8 Sectors</span>
00124 <span class="comment">//      PageAlign( 2 Sectors ) = 1 Page  = 8 Sectors</span>
00125 <span class="comment">//</span>
00126 
<a name="l00127"></a><a class="code" href="../../d6/d6/vmcbsup_8c.html#a3">00127</a> <span class="preprocessor">#define PageAlign(V, L) ((((L)+((PAGE_SIZE/(V)-&gt;SectorSize)-1))/(PAGE_SIZE/(V)-&gt;SectorSize))*(PAGE_SIZE/(V)-&gt;SectorSize))</span>
00128 <span class="preprocessor"></span>
00129 
00130 <span class="preprocessor">#if VMCB_WRITE_SUPPORT</span>
00131 <span class="preprocessor"></span>
00132 <span class="comment">//</span>
00133 <span class="comment">//  The following constant is a bit mask, with one bit set for each sector</span>
00134 <span class="comment">//  that'll fit in a page (4K page, 8 bits; 8K page, 16 bits, etc)</span>
00135 <span class="comment">//</span>
00136 
00137 <span class="preprocessor">#define SECTOR_MASK ((1 &lt;&lt; (PAGE_SIZE / sizeof (SECTOR))) - 1)</span>
00138 <span class="preprocessor"></span>
00139 <span class="comment">//</span>
00140 <span class="comment">//  The Dirty Page structure are elements in the dirty table generic table.</span>
00141 <span class="comment">//  This is followed by the procedure prototypes for the local generic table</span>
00142 <span class="comment">//  routines</span>
00143 <span class="comment">//</span>
00144 
00145 <span class="keyword">typedef</span> <span class="keyword">struct </span>_DIRTY_PAGE {
00146     ULONG LbnPageNumber;
00147     ULONG DirtyMask;
00148 } DIRTY_PAGE;
00149 <span class="keyword">typedef</span> DIRTY_PAGE *PDIRTY_PAGE;
00150 
00151 RTL_GENERIC_COMPARE_RESULTS
00152 PbCompareDirtyVmcb (
00153     IN PRTL_GENERIC_TABLE DirtyTable,
00154     IN PVOID FirstStruct,
00155     IN PVOID SecondStruct
00156     );
00157 
00158 PVOID
00159 PbAllocateDirtyVmcb (
00160     IN PRTL_GENERIC_TABLE DirtyTable,
00161     IN CLONG ByteSize
00162     );
00163 
00164 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00165 PbDeallocateDirtyVmcb (
00166     IN PRTL_GENERIC_TABLE DirtyTable,
00167     IN PVOID Buffer
00168     );
00169 
00170 ULONG
00171 PbDumpDirtyVmcb (
00172     IN <a class="code" href="../../d1/d7/struct__VMCB.html">PVMCB</a> Vmcb
00173     );
00174 
00175 <span class="preprocessor">#endif // VMCB_WRITE_SUPPORT</span>
00176 <span class="preprocessor"></span>
00177 <span class="comment">//</span>
00178 <span class="comment">//  Local Routines.</span>
00179 <span class="comment">//</span>
00180 
00181 BOOLEAN
00182 <a class="code" href="../../d6/d6/vmcbsup_8c.html#a4">UdfVmcbLookupMcbEntry</a> (
00183     IN <a class="code" href="../../d2/d7/struct__MCB.html">PMCB</a> Mcb,
00184     IN VBN Vbn,
00185     OUT PLBN Lbn,
00186     OUT PULONG SectorCount OPTIONAL,
00187     OUT PULONG Index OPTIONAL
00188     );
00189 
00190 
00191 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00192 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfAddVmcbMapping)</span>
00193 <span class="preprocessor"></span>
00194 <span class="preprocessor">#if VMCB_WRITE_SUPPORT</span>
00195 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, PbAllocateDirtyVmcb)</span>
00196 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, PbDeallocateDirtyVmcb)</span>
00197 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, PbDumpDirtyVmcb)</span>
00198 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, PbGetAndCleanDirtyVmcb)</span>
00199 <span class="preprocessor"></span><span class="preprocessor">#endif // VMCB_WRITE_SUPPORT</span>
00200 <span class="preprocessor"></span>
00201 <span class="preprocessor">#pragma alloc_text(PAGE, UdfInitializeVmcb)</span>
00202 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfRemoveVmcbMapping)</span>
00203 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfResetVmcb)</span>
00204 <span class="preprocessor"></span>
00205 <span class="preprocessor">#if VMCB_WRITE_SUPPORT</span>
00206 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, PbSetCleanVmcb)</span>
00207 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, PbSetDirtyVmcb)</span>
00208 <span class="preprocessor"></span><span class="preprocessor">#endif // VMCB_WRITE_SUPPORT</span>
00209 <span class="preprocessor"></span>
00210 <span class="preprocessor">#pragma alloc_text(PAGE, UdfSetMaximumLbnVmcb)</span>
00211 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfUninitializeVmcb)</span>
00212 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfVmcbLbnToVbn)</span>
00213 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfVmcbLookupMcbEntry)</span>
00214 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfVmcbVbnToLbn)</span>
00215 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00216 <span class="preprocessor"></span>
00217 
00218 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00219"></a><a class="code" href="../../d6/d6/vmcbsup_8c.html#a5">00219</a> <a class="code" href="../../d6/d6/vmcbsup_8c.html#a5">UdfInitializeVmcb</a> (
00220     IN <a class="code" href="../../d1/d7/struct__VMCB.html">PVMCB</a> Vmcb,
00221     IN POOL_TYPE PoolType,
00222     IN ULONG MaximumLbn,
00223     IN ULONG SectorSize
00224     )
00225 
00226 <span class="comment">/*++</span>
00227 <span class="comment"></span>
00228 <span class="comment">Routine Description:</span>
00229 <span class="comment"></span>
00230 <span class="comment">    This routine initializes a new Vmcb Structure.  The caller must</span>
00231 <span class="comment">    supply the memory for the structure.  This must precede all other calls</span>
00232 <span class="comment">    that set/query the volume file mapping.</span>
00233 <span class="comment"></span>
00234 <span class="comment">    If pool is not available this routine will raise a status value</span>
00235 <span class="comment">    indicating insufficient resources.</span>
00236 <span class="comment"></span>
00237 <span class="comment">Arguments:</span>
00238 <span class="comment"></span>
00239 <span class="comment">    Vmcb - Supplies a pointer to the volume file structure to initialize.</span>
00240 <span class="comment"></span>
00241 <span class="comment">    PoolType - Supplies the pool type to use when allocating additional</span>
00242 <span class="comment">        internal structures.</span>
00243 <span class="comment"></span>
00244 <span class="comment">    MaximumLbn - Supplies the maximum Lbn value that is valid for this</span>
00245 <span class="comment">        volume.</span>
00246 <span class="comment"></span>
00247 <span class="comment">    LbSize - Size of a sector on this volume</span>
00248 <span class="comment"></span>
00249 <span class="comment">Return Value:</span>
00250 <span class="comment"></span>
00251 <span class="comment">    None</span>
00252 <span class="comment"></span>
00253 <span class="comment">--*/</span>
00254 
00255 {
00256     BOOLEAN VbnInitialized;
00257     BOOLEAN LbnInitialized;
00258 
00259     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00260 
00261     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfInitializeVmcb, Vmcb = %08x\n"</span>, Vmcb ));
00262 
00263     VbnInitialized = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00264     LbnInitialized = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00265 
00266     <span class="keywordflow">try</span> {
00267 
00268         <span class="comment">//</span>
00269         <span class="comment">//  Initialize the fields in the vmcb structure</span>
00270         <span class="comment">//</span>
00271 
00272         <a class="code" href="../../d3/d5/mutntobj_8c.html#a2">KeInitializeMutex</a>( &amp;Vmcb-&gt;Mutex, 0 );
00273 
00274         <a class="code" href="../../d1/d8/fsrtl_8h.html#a151">FsRtlInitializeMcb</a>( &amp;Vmcb-&gt;VbnIndexed, PoolType );
00275         VbnInitialized = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00276 
00277         <a class="code" href="../../d1/d8/fsrtl_8h.html#a151">FsRtlInitializeMcb</a>( &amp;Vmcb-&gt;LbnIndexed, PoolType );
00278         LbnInitialized = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00279 
00280         Vmcb-&gt;MaximumLbn = MaximumLbn;
00281 
00282         Vmcb-&gt;SectorSize = <a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a>;
00283 
00284 <span class="preprocessor">#if VMCB_WRITE_SUPPORT</span>
00285 <span class="preprocessor"></span>
00286         <span class="comment">//</span>
00287         <span class="comment">//  For the dirty table we store in the table context field the pool</span>
00288         <span class="comment">//  type to use for allocating additional structures</span>
00289         <span class="comment">//</span>
00290 
00291         <a class="code" href="../../d6/d1/gentable_8c.html#a3">RtlInitializeGenericTable</a>( &amp;Vmcb-&gt;DirtyTable,
00292                                    PbCompareDirtyVmcb,
00293                                    PbAllocateDirtyVmcb,
00294                                    PbDeallocateDirtyVmcb,
00295                                    (PVOID)PoolType );
00296 
00297 <span class="preprocessor">#endif // VMCB_WRITE_SUPPORT</span>
00298 <span class="preprocessor"></span>
00299     } finally {
00300 
00301         <span class="comment">//</span>
00302         <span class="comment">//  If this is an abnormal termination then check if we need to</span>
00303         <span class="comment">//  uninitialize the mcb structures</span>
00304         <span class="comment">//</span>
00305 
00306         <span class="keywordflow">if</span> (AbnormalTermination()) {
00307 
00308             <span class="keywordflow">if</span> (VbnInitialized) { <a class="code" href="../../d1/d8/fsrtl_8h.html#a152">FsRtlUninitializeMcb</a>( &amp;Vmcb-&gt;VbnIndexed ); }
00309             <span class="keywordflow">if</span> (LbnInitialized) { <a class="code" href="../../d1/d8/fsrtl_8h.html#a152">FsRtlUninitializeMcb</a>( &amp;Vmcb-&gt;LbnIndexed ); }
00310         }
00311 
00312         <a class="code" href="../../d8/d3/lfsdata_8h.html#a3">DebugUnwind</a>(<span class="stringliteral">"UdfInitializeVmcb"</span>);
00313         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfInitializeVmcb -&gt; VOID\n"</span> ));
00314     }
00315 
00316     <span class="comment">//</span>
00317     <span class="comment">//  And return to our caller</span>
00318     <span class="comment">//</span>
00319 
00320     <span class="keywordflow">return</span>;
00321 }
00322 
00323 
00324 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00325"></a><a class="code" href="../../d6/d6/vmcbsup_8c.html#a6">00325</a> <a class="code" href="../../d6/d6/vmcbsup_8c.html#a6">UdfUninitializeVmcb</a> (
00326     IN <a class="code" href="../../d1/d7/struct__VMCB.html">PVMCB</a> Vmcb
00327     )
00328 
00329 <span class="comment">/*++</span>
00330 <span class="comment"></span>
00331 <span class="comment">Routine Description:</span>
00332 <span class="comment"></span>
00333 <span class="comment">    This routine uninitializes an existing VMCB structure.  After calling</span>
00334 <span class="comment">    this routine the input VMCB structure must be re-initialized before</span>
00335 <span class="comment">    being used again.</span>
00336 <span class="comment"></span>
00337 <span class="comment">Arguments:</span>
00338 <span class="comment"></span>
00339 <span class="comment">    Vmcb - Supplies a pointer to the VMCB structure to uninitialize.</span>
00340 <span class="comment"></span>
00341 <span class="comment">Return Value:</span>
00342 <span class="comment"></span>
00343 <span class="comment">    None.</span>
00344 <span class="comment"></span>
00345 <span class="comment">--*/</span>
00346 
00347 {
00348     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00349 
00350     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfUninitializeVmcb, Vmcb = %08x\n"</span>, Vmcb ));
00351 
00352     <span class="comment">//</span>
00353     <span class="comment">//  Unitialize the fields in the Vmcb structure</span>
00354     <span class="comment">//</span>
00355 
00356     <a class="code" href="../../d1/d8/fsrtl_8h.html#a152">FsRtlUninitializeMcb</a>( &amp;Vmcb-&gt;VbnIndexed );
00357     <a class="code" href="../../d1/d8/fsrtl_8h.html#a152">FsRtlUninitializeMcb</a>( &amp;Vmcb-&gt;LbnIndexed );
00358 
00359     <span class="comment">//</span>
00360     <span class="comment">//  And return to our caller</span>
00361     <span class="comment">//</span>
00362 
00363     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfUninitializeVmcb -&gt; VOID\n"</span> ));
00364 
00365     <span class="keywordflow">return</span>;
00366 }
00367 
00368 
00369 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00370"></a><a class="code" href="../../d6/d6/vmcbsup_8c.html#a7">00370</a> <a class="code" href="../../d6/d6/vmcbsup_8c.html#a7">UdfResetVmcb</a> (
00371     IN <a class="code" href="../../d1/d7/struct__VMCB.html">PVMCB</a> Vmcb
00372     )
00373 
00374 <span class="comment">/*++</span>
00375 <span class="comment"></span>
00376 <span class="comment">Routine Description:</span>
00377 <span class="comment"></span>
00378 <span class="comment">    This routine resets the mappings in an existing VMCB structure.</span>
00379 <span class="comment"></span>
00380 <span class="comment">Arguments:</span>
00381 <span class="comment"></span>
00382 <span class="comment">    Vmcb - Supplies a pointer to the VMCB structure to reset.</span>
00383 <span class="comment"></span>
00384 <span class="comment">Return Value:</span>
00385 <span class="comment"></span>
00386 <span class="comment">    None.</span>
00387 <span class="comment"></span>
00388 <span class="comment">--*/</span>
00389 
00390 {
00391     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00392 
00393     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfResetVmcb, Vmcb = %08x\n"</span>, Vmcb ));
00394 
00395     <span class="comment">//</span>
00396     <span class="comment">//  Unitialize the fields in the Vmcb structure</span>
00397     <span class="comment">//</span>
00398 
00399     <a class="code" href="../../d1/d8/fsrtl_8h.html#a141">FsRtlResetLargeMcb</a>( (<a class="code" href="../../d0/d9/struct__LARGE__MCB.html">PLARGE_MCB</a>) &amp;Vmcb-&gt;VbnIndexed, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00400     <a class="code" href="../../d1/d8/fsrtl_8h.html#a141">FsRtlResetLargeMcb</a>( (<a class="code" href="../../d0/d9/struct__LARGE__MCB.html">PLARGE_MCB</a>) &amp;Vmcb-&gt;LbnIndexed, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00401 
00402     <span class="comment">//</span>
00403     <span class="comment">//  And return to our caller</span>
00404     <span class="comment">//</span>
00405 
00406     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfResetVmcb -&gt; VOID\n"</span> ));
00407 
00408     <span class="keywordflow">return</span>;
00409 }
00410 
00411 
00412 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00413"></a><a class="code" href="../../d6/d6/vmcbsup_8c.html#a8">00413</a> <a class="code" href="../../d6/d6/vmcbsup_8c.html#a8">UdfSetMaximumLbnVmcb</a> (
00414     IN <a class="code" href="../../d1/d7/struct__VMCB.html">PVMCB</a> Vmcb,
00415     IN ULONG MaximumLbn
00416     )
00417 
00418 <span class="comment">/*++</span>
00419 <span class="comment"></span>
00420 <span class="comment">Routine Description:</span>
00421 <span class="comment"></span>
00422 <span class="comment">    This routine sets/resets the maximum allowed LBN for the specified</span>
00423 <span class="comment">    Vmcb structure.  The Vmcb structure must already have been initialized</span>
00424 <span class="comment">    by calling UdfInitializeVmcb.</span>
00425 <span class="comment"></span>
00426 <span class="comment">Arguments:</span>
00427 <span class="comment"></span>
00428 <span class="comment">    Vmcb - Supplies a pointer to the volume file structure to initialize.</span>
00429 <span class="comment"></span>
00430 <span class="comment">    MaximumLbn - Supplies the maximum Lbn value that is valid for this</span>
00431 <span class="comment">        volume.</span>
00432 <span class="comment"></span>
00433 <span class="comment">Return Value:</span>
00434 <span class="comment"></span>
00435 <span class="comment">    None</span>
00436 <span class="comment"></span>
00437 <span class="comment">--*/</span>
00438 
00439 {
00440     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00441 
00442     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfSetMaximumLbnVmcb, Vmcb = %08x\n"</span>, Vmcb ));
00443 
00444     <span class="comment">//</span>
00445     <span class="comment">//  Set the field</span>
00446     <span class="comment">//</span>
00447 
00448     Vmcb-&gt;MaximumLbn = MaximumLbn;
00449 
00450     <span class="comment">//</span>
00451     <span class="comment">//  And return to our caller</span>
00452     <span class="comment">//</span>
00453 
00454     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfSetMaximumLbnVmcb -&gt; VOID\n"</span> ));
00455 
00456     <span class="keywordflow">return</span>;
00457 }
00458 
00459 
00460 BOOLEAN
<a name="l00461"></a><a class="code" href="../../d6/d6/vmcbsup_8c.html#a9">00461</a> <a class="code" href="../../d6/d6/vmcbsup_8c.html#a9">UdfVmcbVbnToLbn</a> (
00462     IN <a class="code" href="../../d1/d7/struct__VMCB.html">PVMCB</a> Vmcb,
00463     IN VBN Vbn,
00464     IN PLBN Lbn,
00465     OUT PULONG SectorCount OPTIONAL
00466     )
00467 
00468 <span class="comment">/*++</span>
00469 <span class="comment"></span>
00470 <span class="comment">Routine Description:</span>
00471 <span class="comment"></span>
00472 <span class="comment">    This routine translates a VBN to an LBN.</span>
00473 <span class="comment"></span>
00474 <span class="comment">Arguments:</span>
00475 <span class="comment"></span>
00476 <span class="comment">    Vmcb - Supplies the VMCB structure being queried.</span>
00477 <span class="comment"></span>
00478 <span class="comment">    Vbn - Supplies the VBN to translate from.</span>
00479 <span class="comment"></span>
00480 <span class="comment">    Lbn - Receives the LBN mapped by the input Vbn.  This value is only valid</span>
00481 <span class="comment">        if the function result is TRUE.</span>
00482 <span class="comment"></span>
00483 <span class="comment">    SectorCount - Optionally receives the number of sectors corresponding</span>
00484 <span class="comment">        to the run.</span>
00485 <span class="comment"></span>
00486 <span class="comment">Return Value:</span>
00487 <span class="comment"></span>
00488 <span class="comment">    BOOLEAN - TRUE if he Vbn has a valid mapping and FALSE otherwise.</span>
00489 <span class="comment"></span>
00490 <span class="comment">--*/</span>
00491 
00492 {
00493     BOOLEAN Result;
00494 
00495     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfVmcbVbnToLbn, Vbn = %08x\n"</span>, Vbn ));
00496 
00497     <span class="comment">//</span>
00498     <span class="comment">//  Now grab the mutex for the vmcb</span>
00499     <span class="comment">//</span>
00500 
00501     (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;Vmcb-&gt;Mutex,
00502                                  <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
00503                                  <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
00504                                  <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00505                                  (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00506 
00507     <span class="keywordflow">try</span> {
00508 
00509         Result = <a class="code" href="../../d6/d6/vmcbsup_8c.html#a4">UdfVmcbLookupMcbEntry</a>( &amp;Vmcb-&gt;VbnIndexed,
00510                                         Vbn,
00511                                         Lbn,
00512                                         SectorCount,
00513                                         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00514 
00515         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"*Lbn = %08x\n"</span>, *Lbn ));
00516 
00517         <span class="comment">//</span>
00518         <span class="comment">//  If the returned Lbn is greater than the maximum allowed Lbn</span>
00519         <span class="comment">//  then return FALSE</span>
00520         <span class="comment">//</span>
00521 
00522         <span class="keywordflow">if</span> (Result &amp;&amp; (*Lbn &gt; Vmcb-&gt;MaximumLbn)) {
00523 
00524             <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00525         }
00526 
00527         <span class="comment">//</span>
00528         <span class="comment">//  If the last returned Lbn is greater than the maximum allowed Lbn</span>
00529         <span class="comment">//  then bring in the sector count</span>
00530         <span class="comment">//</span>
00531 
00532         <span class="keywordflow">if</span> (Result &amp;&amp;
00533             ARGUMENT_PRESENT(SectorCount) &amp;&amp;
00534             (*Lbn+*SectorCount-1 &gt; Vmcb-&gt;MaximumLbn)) {
00535 
00536             *SectorCount = (Vmcb-&gt;MaximumLbn - *Lbn + 1);
00537         }
00538 
00539     } finally {
00540 
00541         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d3/d5/mutntobj_8c.html#a5">KeReleaseMutex</a>( &amp;Vmcb-&gt;Mutex, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00542 
00543         <a class="code" href="../../d8/d3/lfsdata_8h.html#a3">DebugUnwind</a>(<span class="stringliteral">"UdfVmcbVbnToLbn"</span>);
00544         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfVmcbVbnToLbn -&gt; Result = %08x\n"</span>, Result ));
00545     }
00546 
00547 
00548     <span class="keywordflow">return</span> Result;
00549 }
00550 
00551 
00552 BOOLEAN
<a name="l00553"></a><a class="code" href="../../d6/d6/vmcbsup_8c.html#a10">00553</a> <a class="code" href="../../d6/d6/vmcbsup_8c.html#a10">UdfVmcbLbnToVbn</a> (
00554     IN <a class="code" href="../../d1/d7/struct__VMCB.html">PVMCB</a> Vmcb,
00555     IN LBN Lbn,
00556     OUT PVBN Vbn,
00557     OUT PULONG SectorCount OPTIONAL
00558     )
00559 
00560 <span class="comment">/*++</span>
00561 <span class="comment"></span>
00562 <span class="comment">Routine Description:</span>
00563 <span class="comment"></span>
00564 <span class="comment">    This routine translates an LBN to a VBN.</span>
00565 <span class="comment"></span>
00566 <span class="comment">Arguments:</span>
00567 <span class="comment"></span>
00568 <span class="comment">    Vmcb - Supplies the VMCB structure being queried.</span>
00569 <span class="comment"></span>
00570 <span class="comment">    Lbn - Supplies the LBN to translate from.</span>
00571 <span class="comment"></span>
00572 <span class="comment">    Vbn - Recieves the VBN mapped by the input LBN.  This value is</span>
00573 <span class="comment">        only valid if the function result is TRUE.</span>
00574 <span class="comment"></span>
00575 <span class="comment">    SectorCount - Optionally receives the number of sectors corresponding</span>
00576 <span class="comment">        to the run.</span>
00577 <span class="comment"></span>
00578 <span class="comment">Return Value:</span>
00579 <span class="comment"></span>
00580 <span class="comment">    BOOLEAN - TRUE if the mapping is valid and FALSE otherwise.</span>
00581 <span class="comment"></span>
00582 <span class="comment">--*/</span>
00583 
00584 {
00585     BOOLEAN Result;
00586 
00587     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00588 
00589     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfVmcbLbnToVbn, Lbn = %08x\n"</span>, Lbn ));
00590 
00591     <span class="comment">//</span>
00592     <span class="comment">//  If the requested Lbn is greater than the maximum allowed Lbn</span>
00593     <span class="comment">//  then the result is FALSE</span>
00594     <span class="comment">//</span>
00595 
00596     <span class="keywordflow">if</span> (Lbn &gt; Vmcb-&gt;MaximumLbn) {
00597 
00598         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"Lbn too large, UdfVmcbLbnToVbn -&gt; FALSE\n"</span> ));
00599 
00600         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00601     }
00602 
00603     <span class="comment">//</span>
00604     <span class="comment">//  Now grab the mutex for the vmcb</span>
00605     <span class="comment">//</span>
00606 
00607     (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;Vmcb-&gt;Mutex,
00608                                  <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
00609                                  <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
00610                                  <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00611                                  (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00612 
00613     <span class="keywordflow">try</span> {
00614 
00615         Result = <a class="code" href="../../d6/d6/vmcbsup_8c.html#a4">UdfVmcbLookupMcbEntry</a>( &amp;Vmcb-&gt;LbnIndexed,
00616                                         Lbn,
00617                                         Vbn,
00618                                         SectorCount,
00619                                         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00620 
00621         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"*Vbn = %08x\n"</span>, *Vbn ));
00622 
00623     } finally {
00624 
00625         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d3/d5/mutntobj_8c.html#a5">KeReleaseMutex</a>( &amp;Vmcb-&gt;Mutex, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00626 
00627 
00628         <a class="code" href="../../d8/d3/lfsdata_8h.html#a3">DebugUnwind</a>(<span class="stringliteral">"UdfVmcbLbnToVbn"</span>);
00629         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfVmcbLbnToVbn -&gt; Result = %08x\n"</span>, Result ));
00630     }
00631 
00632     <span class="keywordflow">return</span> Result;
00633 }
00634 
00635 
00636 BOOLEAN
<a name="l00637"></a><a class="code" href="../../d6/d6/vmcbsup_8c.html#a11">00637</a> <a class="code" href="../../d6/d6/vmcbsup_8c.html#a11">UdfAddVmcbMapping</a> (
00638     IN <a class="code" href="../../d1/d7/struct__VMCB.html">PVMCB</a> Vmcb,
00639     IN LBN Lbn,
00640     IN ULONG SectorCount,
00641     IN BOOLEAN ExactEnd,
00642     OUT PVBN Vbn,
00643     OUT PULONG AlignedSectorCount
00644     )
00645 
00646 <span class="comment">/*++</span>
00647 <span class="comment"></span>
00648 <span class="comment">Routine Description:</span>
00649 <span class="comment"></span>
00650 <span class="comment">    This routine adds a new LBN to VBN mapping to the VMCB structure.  When</span>
00651 <span class="comment">    a new LBN is added to the structure it does it only on page aligned</span>
00652 <span class="comment">    boundaries.</span>
00653 <span class="comment"></span>
00654 <span class="comment">    If pool is not available to store the information this routine will</span>
00655 <span class="comment">    raise a status value indicating insufficient resources.</span>
00656 <span class="comment"></span>
00657 <span class="comment">Arguments:</span>
00658 <span class="comment"></span>
00659 <span class="comment">    Vmcb - Supplies the VMCB being updated.</span>
00660 <span class="comment"></span>
00661 <span class="comment">    Lbn - Supplies the starting LBN to add to VMCB.</span>
00662 <span class="comment"></span>
00663 <span class="comment">    SectorCount - Supplies the number of Sectors in the run</span>
00664 <span class="comment">    </span>
00665 <span class="comment">    ExactEnd - Indicates that instead of aligning to map sectors beyond</span>
00666 <span class="comment">        the end of the request, use a hole.  Implies trying to look at </span>
00667 <span class="comment">        these sectors could be undesireable.</span>
00668 <span class="comment"></span>
00669 <span class="comment">    Vbn - Receives the assigned VBN</span>
00670 <span class="comment">    </span>
00671 <span class="comment">    AlignedSectorCount - Receives the actual sector count created in the</span>
00672 <span class="comment">        Vmcb for page alignment purposes. Vbn+AlignedSectorCount-1 == LastVbn.</span>
00673 <span class="comment"></span>
00674 <span class="comment">Return Value:</span>
00675 <span class="comment"></span>
00676 <span class="comment">    BOOLEAN - TRUE if this is a new mapping and FALSE if the mapping</span>
00677 <span class="comment">        for the LBN already exists.  If it already exists then the</span>
00678 <span class="comment">        sector count for this new addition must already be in the</span>
00679 <span class="comment">        VMCB structure</span>
00680 <span class="comment"></span>
00681 <span class="comment">--*/</span>
00682 
00683 {
00684 
00685     BOOLEAN Result;
00686 
00687     BOOLEAN VbnMcbAdded;
00688     BOOLEAN LbnMcbAdded;
00689 
00690     <a class="code" href="../../d1/d8/fsrtl_8h.html#a50">LBN</a> LocalLbn;
00691     <a class="code" href="../../d1/d8/fsrtl_8h.html#a52">VBN</a> LocalVbn;
00692     ULONG LocalCount;
00693 
00694     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00695 
00696     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfAddVmcbMapping, Lbn = %08x\n"</span>, Lbn ));
00697     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">" SectorCount = %08x\n"</span>, SectorCount ));
00698 
00699     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( SectorCount != 0 );
00700 
00701     VbnMcbAdded = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00702     LbnMcbAdded = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00703 
00704     <span class="comment">//</span>
00705     <span class="comment">//  Now grab the mutex for the vmcb</span>
00706     <span class="comment">//</span>
00707 
00708     (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;Vmcb-&gt;Mutex,
00709                                  <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
00710                                  <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
00711                                  <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00712                                  (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00713 
00714     <span class="keywordflow">try</span> {
00715 
00716         <span class="comment">//</span>
00717         <span class="comment">//  Check if the Lbn is already mapped, which means we find an entry</span>
00718         <span class="comment">//  with a non zero mapping Vbn value.</span>
00719         <span class="comment">//</span>
00720 
00721         <span class="keywordflow">if</span> (<a class="code" href="../../d6/d6/vmcbsup_8c.html#a4">UdfVmcbLookupMcbEntry</a>( &amp;Vmcb-&gt;LbnIndexed,
00722                                    Lbn,
00723                                    Vbn,
00724                                    &amp;LocalCount,
00725                                    <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> )) {
00726 
00727             <span class="comment">//</span>
00728             <span class="comment">//  It is already mapped so now the sector count must not exceed</span>
00729             <span class="comment">//  the count already in the run</span>
00730             <span class="comment">//</span>
00731 
00732             <span class="keywordflow">if</span> (SectorCount &lt;= LocalCount) {
00733 
00734                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00735             }
00736         }
00737 
00738         <span class="comment">//</span>
00739         <span class="comment">//  At this point, we did not find a full existing mapping for the</span>
00740         <span class="comment">//  Lbn and count.  But there might be some overlapping runs that we'll</span>
00741         <span class="comment">//  need to now remove from the vmcb structure.  So for each Lbn in</span>
00742         <span class="comment">//  the range we're after, check to see if it is mapped and remove the</span>
00743         <span class="comment">//  mapping.  We only need to do this test if the sector count is less</span>
00744         <span class="comment">//  than or equal to a page size.  Because those are the only</span>
00745         <span class="comment">//  structures that we know we'll try an remove/overwrite.</span>
00746         <span class="comment">//</span>
00747 
00748         <span class="keywordflow">if</span> (SectorCount &lt;= <a class="code" href="../../d6/d6/vmcbsup_8c.html#a3">PageAlign</a>(Vmcb, 1)) {
00749 
00750             <span class="keywordflow">if</span> (<a class="code" href="../../d6/d6/vmcbsup_8c.html#a4">UdfVmcbLookupMcbEntry</a>( &amp;Vmcb-&gt;LbnIndexed,
00751                                        Lbn,
00752                                        Vbn,
00753                                        &amp;LocalCount,
00754                                        <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> )) {
00755 
00756                 <a class="code" href="../../d6/d6/vmcbsup_8c.html#a12">UdfRemoveVmcbMapping</a>( Vmcb, *Vbn, <a class="code" href="../../d6/d6/vmcbsup_8c.html#a3">PageAlign</a>(Vmcb, 1) );
00757             }
00758         }
00759 
00760         <span class="comment">//</span>
00761         <span class="comment">//  We need to add this new run at the end of the Vbns.  To do this we</span>
00762         <span class="comment">//  need to look up the last mcb entry or use a vbn for the second</span>
00763         <span class="comment">//  page, if the mcb is empty.  We'll also special case the situation</span>
00764         <span class="comment">//  where the last lbn of the mapping and the mapping we're adding</span>
00765         <span class="comment">//  simply flow into each other in which case we'll not bother bumping</span>
00766         <span class="comment">//  the vbn to a page alignment</span>
00767         <span class="comment">//</span>
00768 
00769         <span class="keywordflow">if</span> (<a class="code" href="../../d1/d8/fsrtl_8h.html#a157">FsRtlLookupLastMcbEntry</a>( &amp;Vmcb-&gt;VbnIndexed, &amp;LocalVbn, &amp;LocalLbn )) {
00770 
00771             <span class="keywordflow">if</span> (LocalLbn + 1 == Lbn) {
00772 
00773                 LocalVbn = LocalVbn + 1;
00774                 LocalLbn = LocalLbn + 1;
00775 
00776             } <span class="keywordflow">else</span> {
00777 
00778                 <span class="comment">//</span>
00779                 <span class="comment">//  Get the next available Vbn Page, and calculate the</span>
00780                 <span class="comment">//  Lbn for the page containing the Lbn</span>
00781                 <span class="comment">//</span>
00782 
00783                 LocalVbn = <a class="code" href="../../d6/d6/vmcbsup_8c.html#a3">PageAlign</a>( Vmcb, LocalVbn + 1 );
00784                 LocalLbn = <a class="code" href="../../d6/d6/vmcbsup_8c.html#a3">PageAlign</a>( Vmcb, Lbn + 1 ) - <a class="code" href="../../d6/d6/vmcbsup_8c.html#a3">PageAlign</a>( Vmcb, 1 );
00785             }
00786 
00787         } <span class="keywordflow">else</span> {
00788 
00789             <span class="comment">//</span>
00790             <span class="comment">//  Get the first available Vbn page, and calculate the</span>
00791             <span class="comment">//  Lbn for the page containing the Lbn.</span>
00792             <span class="comment">//</span>
00793 
00794 
00795             LocalVbn = 0;
00796             LocalLbn = <a class="code" href="../../d6/d6/vmcbsup_8c.html#a3">PageAlign</a>( Vmcb, Lbn + 1 ) - <a class="code" href="../../d6/d6/vmcbsup_8c.html#a3">PageAlign</a>( Vmcb, 1 );
00797         }
00798 
00799         <span class="comment">//</span>
00800         <span class="comment">//  Calculate the number of sectors that we need to map to keep</span>
00801         <span class="comment">//  everything on a page granularity.</span>
00802         <span class="comment">//</span>
00803 
00804         LocalCount = <a class="code" href="../../d6/d6/vmcbsup_8c.html#a3">PageAlign</a>( Vmcb, SectorCount + (Lbn - LocalLbn) );
00805 
00806         <span class="comment">//</span>
00807         <span class="comment">//  See if we should use a hole to map the alignment at the end of the request.</span>
00808         <span class="comment">//</span>
00809         
00810         <span class="keywordflow">if</span> (ExactEnd &amp;&amp; Lbn + SectorCount &lt; LocalLbn + LocalCount) {
00811 
00812             LocalCount = SectorCount + (Lbn - LocalLbn);
00813         }
00814         
00815         <span class="comment">//</span>
00816         <span class="comment">//  Add the double mapping</span>
00817         <span class="comment">//</span>
00818 
00819         <a class="code" href="../../d1/d8/fsrtl_8h.html#a154">FsRtlAddMcbEntry</a>( &amp;Vmcb-&gt;VbnIndexed,
00820                           LocalVbn,
00821                           LocalLbn,
00822                           LocalCount );
00823 
00824         VbnMcbAdded = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00825 
00826         <a class="code" href="../../d1/d8/fsrtl_8h.html#a154">FsRtlAddMcbEntry</a>( &amp;Vmcb-&gt;LbnIndexed,
00827                           LocalLbn,
00828                           LocalVbn,
00829                           LocalCount );
00830 
00831         LbnMcbAdded = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00832 
00833         *Vbn = LocalVbn + (Lbn - LocalLbn);
00834         *AlignedSectorCount = LocalCount - (Lbn - LocalLbn);
00835 
00836         <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00837 
00838     } finally {
00839 
00840         <span class="comment">//</span>
00841         <span class="comment">//  If this is an abnormal termination then clean up any mcb's that we</span>
00842         <span class="comment">//  might have modified.</span>
00843         <span class="comment">//</span>
00844 
00845         <span class="keywordflow">if</span> (AbnormalTermination()) {
00846 
00847             <span class="keywordflow">if</span> (VbnMcbAdded) { <a class="code" href="../../d1/d8/fsrtl_8h.html#a155">FsRtlRemoveMcbEntry</a>( &amp;Vmcb-&gt;VbnIndexed, LocalVbn, LocalCount ); }
00848             <span class="keywordflow">if</span> (LbnMcbAdded) { <a class="code" href="../../d1/d8/fsrtl_8h.html#a155">FsRtlRemoveMcbEntry</a>( &amp;Vmcb-&gt;LbnIndexed, LocalLbn, LocalCount ); }
00849         }
00850 
00851         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d3/d5/mutntobj_8c.html#a5">KeReleaseMutex</a>( &amp;Vmcb-&gt;Mutex, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00852 
00853         <a class="code" href="../../d8/d3/lfsdata_8h.html#a3">DebugUnwind</a>(<span class="stringliteral">"UdfAddVmcbMapping"</span>);
00854         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">" LocalVbn   = %08x\n"</span>, LocalVbn ));
00855         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">" LocalLbn   = %08x\n"</span>, LocalLbn ));
00856         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">" LocalCount = %08x\n"</span>, LocalCount ));
00857         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">" *Vbn                = %08x\n"</span>, *Vbn ));
00858         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">" *AlignedSectorCount = %08x\n"</span>, *AlignedSectorCount ));
00859         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>((-1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfAddVmcbMapping -&gt; %08x\n"</span>, Result ));
00860     }
00861 
00862     <span class="keywordflow">return</span> Result;
00863 }
00864 
00865 
00866 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00867"></a><a class="code" href="../../d6/d6/vmcbsup_8c.html#a12">00867</a> <a class="code" href="../../d6/d6/vmcbsup_8c.html#a12">UdfRemoveVmcbMapping</a> (
00868     IN <a class="code" href="../../d1/d7/struct__VMCB.html">PVMCB</a> Vmcb,
00869     IN VBN Vbn,
00870     IN ULONG SectorCount
00871     )
00872 
00873 <span class="comment">/*++</span>
00874 <span class="comment"></span>
00875 <span class="comment">Routine Description:</span>
00876 <span class="comment"></span>
00877 <span class="comment">    This routine removes a Vmcb mapping.</span>
00878 <span class="comment"></span>
00879 <span class="comment">    If pool is not available to store the information this routine will</span>
00880 <span class="comment">    raise a status value indicating insufficient resources.</span>
00881 <span class="comment"></span>
00882 <span class="comment">Arguments:</span>
00883 <span class="comment"></span>
00884 <span class="comment">    Vmcb - Supplies the Vmcb being updated.</span>
00885 <span class="comment"></span>
00886 <span class="comment">    Vbn - Supplies the VBN to remove</span>
00887 <span class="comment"></span>
00888 <span class="comment">    SectorCount - Supplies the number of sectors to remove.</span>
00889 <span class="comment"></span>
00890 <span class="comment">Return Value:</span>
00891 <span class="comment"></span>
00892 <span class="comment">    None.</span>
00893 <span class="comment"></span>
00894 <span class="comment">--*/</span>
00895 
00896 {
00897     <a class="code" href="../../d1/d8/fsrtl_8h.html#a50">LBN</a> Lbn;
00898     ULONG LocalCount;
00899     ULONG i;
00900 
00901     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00902 
00903     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>((+1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfRemoveVmcbMapping, Vbn = %08x\n"</span>, Vbn ));
00904     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">" SectorCount = %08x\n"</span>, SectorCount ));
00905 
00906     <span class="comment">//</span>
00907     <span class="comment">//  Now grab the mutex for the vmcb</span>
00908     <span class="comment">//</span>
00909 
00910     (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;Vmcb-&gt;Mutex,
00911                                  <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
00912                                  <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
00913                                  <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00914                                  (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00915 
00916     <span class="keywordflow">try</span> {
00917 
00918         <span class="keywordflow">for</span> (i = 0; i &lt; SectorCount; i += 1) {
00919 
00920             <span class="comment">//</span>
00921             <span class="comment">//  Lookup the Vbn so we can get its current Lbn mapping</span>
00922             <span class="comment">//</span>
00923 
00924             <span class="keywordflow">if</span> (!<a class="code" href="../../d6/d6/vmcbsup_8c.html#a4">UdfVmcbLookupMcbEntry</a>( &amp;Vmcb-&gt;VbnIndexed,
00925                                         Vbn + i,
00926                                         &amp;Lbn,
00927                                         &amp;LocalCount,
00928                                         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> )) {
00929 
00930                 <a class="code" href="../../d1/d7/udfs_2nodetype_8h.html#a66">UdfBugCheck</a>( 0, 0, 0 );
00931             }
00932 
00933             <a class="code" href="../../d1/d8/fsrtl_8h.html#a155">FsRtlRemoveMcbEntry</a>( &amp;Vmcb-&gt;VbnIndexed,
00934                                  Vbn + i,
00935                                  1 );
00936 
00937             <a class="code" href="../../d1/d8/fsrtl_8h.html#a155">FsRtlRemoveMcbEntry</a>( &amp;Vmcb-&gt;LbnIndexed,
00938                                  Lbn,
00939                                  1 );
00940         }
00941 
00942         {
00943             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"VbnIndex:\n"</span>, 0 ));
00944             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"LbnIndex:\n"</span>, 0 ));
00945         }
00946 
00947     } finally {
00948 
00949         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d3/d5/mutntobj_8c.html#a5">KeReleaseMutex</a>( &amp;Vmcb-&gt;Mutex, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00950 
00951         <a class="code" href="../../d8/d3/lfsdata_8h.html#a3">DebugUnwind</a>( <span class="stringliteral">"UdfRemoveVmcbMapping"</span> );
00952         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfRemoveVmcbMapping -&gt; VOID\n"</span> ));
00953     }
00954 
00955     <span class="keywordflow">return</span>;
00956 }
00957 
00958 
00959 <span class="comment">//</span>
00960 <span class="comment">//  Local support routine</span>
00961 <span class="comment">//</span>
00962 
00963 BOOLEAN
<a name="l00964"></a><a class="code" href="../../d6/d6/vmcbsup_8c.html#a4">00964</a> <a class="code" href="../../d6/d6/vmcbsup_8c.html#a4">UdfVmcbLookupMcbEntry</a> (
00965     IN <a class="code" href="../../d2/d7/struct__MCB.html">PMCB</a> Mcb,
00966     IN VBN Vbn,
00967     OUT PLBN Lbn,
00968     OUT PULONG SectorCount OPTIONAL,
00969     OUT PULONG Index OPTIONAL
00970     )
00971 
00972 <span class="comment">/*++</span>
00973 <span class="comment"></span>
00974 <span class="comment">Routine Description:</span>
00975 <span class="comment"></span>
00976 <span class="comment">    This routine retrieves the mapping of a Vbn to an Lbn from an Mcb.</span>
00977 <span class="comment">    It indicates if the mapping exists and the size of the run.</span>
00978 <span class="comment">    </span>
00979 <span class="comment">    The only difference betweent this and the regular FsRtlLookupMcbEntry</span>
00980 <span class="comment">    is that we undo the behavior of returning TRUE in holes in the allocation.</span>
00981 <span class="comment">    This is because we don't want to avoid mapping at Lbn 0, which is how the</span>
00982 <span class="comment">    emulated behavior of the small Mcb package tells callers that there is no</span>
00983 <span class="comment">    mapping at that location in a hole.  We have holes all over our Vbn space</span>
00984 <span class="comment">    in the VbnIndexed map.</span>
00985 <span class="comment">    </span>
00986 <span class="comment">    The small Mcb package was able to get away with this because Lbn 0 was the</span>
00987 <span class="comment">    boot sector (or similar magic location) on the disc.  In our metadata stream,</span>
00988 <span class="comment">    we wish to use Vbn 0 (remember this is a double map).</span>
00989 <span class="comment"></span>
00990 <span class="comment">Arguments:</span>
00991 <span class="comment"></span>
00992 <span class="comment">    Mcb - Supplies the Mcb being examined.</span>
00993 <span class="comment"></span>
00994 <span class="comment">    Vbn - Supplies the Vbn to lookup.</span>
00995 <span class="comment"></span>
00996 <span class="comment">    Lbn - Receives the Lbn corresponding to the Vbn.  A value of -1 is</span>
00997 <span class="comment">        returned if the Vbn does not have a corresponding Lbn.</span>
00998 <span class="comment"></span>
00999 <span class="comment">    SectorCount - Receives the number of sectors that map from the Vbn to</span>
01000 <span class="comment">        contiguous Lbn values beginning with the input Vbn.</span>
01001 <span class="comment"></span>
01002 <span class="comment">    Index - Receives the index of the run found.</span>
01003 <span class="comment"></span>
01004 <span class="comment">Return Value:</span>
01005 <span class="comment"></span>
01006 <span class="comment">    BOOLEAN - TRUE if the Vbn is within the range of VBNs mapped by the</span>
01007 <span class="comment">        MCB (not if it corresponds to a hole in the mapping), and FALSE</span>
01008 <span class="comment">        if the Vbn is beyond the range of the MCB's mapping.</span>
01009 <span class="comment"></span>
01010 <span class="comment">        For example, if an MCB has a mapping for VBNs 5 and 7 but not for</span>
01011 <span class="comment">        6, then a lookup on Vbn 5 or 7 will yield a non zero Lbn and a sector</span>
01012 <span class="comment">        count of 1.  A lookup for Vbn 6 will return FALSE with an Lbn value of</span>
01013 <span class="comment">        0, and lookup for Vbn 8 or above will return FALSE.</span>
01014 <span class="comment"></span>
01015 <span class="comment">--*/</span>
01016 
01017 {
01018     BOOLEAN Results;
01019     LONGLONG LiLbn;
01020     LONGLONG LiSectorCount;
01021 
01022     Results = <a class="code" href="../../d1/d8/fsrtl_8h.html#a145">FsRtlLookupLargeMcbEntry</a>( (<a class="code" href="../../d0/d9/struct__LARGE__MCB.html">PLARGE_MCB</a>)Mcb,
01023                                         (LONGLONG)(Vbn),
01024                                         &amp;LiLbn,
01025                                         ARGUMENT_PRESENT(SectorCount) ? &amp;LiSectorCount : <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
01026                                         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
01027                                         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
01028                                         <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> );
01029 
01030     <span class="keywordflow">if</span> ((ULONG)LiLbn == -1) {
01031 
01032         *Lbn = 0;
01033         Results = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01034     
01035     } <span class="keywordflow">else</span> {
01036 
01037         *Lbn = (ULONG)LiLbn;
01038     }
01039 
01040     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(SectorCount)) { *SectorCount = ((ULONG)LiSectorCount); }
01041 
01042     <span class="keywordflow">return</span> Results;
01043 }
01044 
01045 
01046 <span class="preprocessor">#if VMCB_WRITE_SUPPORT</span>
01047 <span class="preprocessor"></span><a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01048 PbSetDirtyVmcb (
01049     IN <a class="code" href="../../d1/d7/struct__VMCB.html">PVMCB</a> Vmcb,
01050     IN ULONG LbnPageNumber,
01051     IN ULONG Mask
01052     )
01053 
01054 <span class="comment">/*++</span>
01055 <span class="comment"></span>
01056 <span class="comment">Routine Description:</span>
01057 <span class="comment"></span>
01058 <span class="comment">    This routine sets the sectors within a page as dirty based on the input</span>
01059 <span class="comment">    mask.</span>
01060 <span class="comment"></span>
01061 <span class="comment">    If pool is not available to store the information this routine will</span>
01062 <span class="comment">    raise a status value indicating insufficient resources.</span>
01063 <span class="comment"></span>
01064 <span class="comment">Arguments:</span>
01065 <span class="comment"></span>
01066 <span class="comment">    Vmcb - Supplies the Vmcb being manipulated.</span>
01067 <span class="comment"></span>
01068 <span class="comment">    LbnPageNumber - Supplies the Page Number (LBN based) of the page being</span>
01069 <span class="comment">        modified.  For example, with a page size of 8 a page number of 0</span>
01070 <span class="comment">        corresponds to LBN values 0 through 7, a page number of 1 corresponds</span>
01071 <span class="comment">        to 8 through 15, and so on.</span>
01072 <span class="comment"></span>
01073 <span class="comment">    Mask - Supplies the mask of dirty sectors to set for the Page (a 1 bit</span>
01074 <span class="comment">        means to set it dirty).  For example to set LBN 9 dirty on a system</span>
01075 <span class="comment">        with a page size of 8 the LbnPageNumber will be 1, and the mask will</span>
01076 <span class="comment">        be 0x00000002.</span>
01077 <span class="comment"></span>
01078 <span class="comment">Return Value:</span>
01079 <span class="comment"></span>
01080 <span class="comment">    None.</span>
01081 <span class="comment"></span>
01082 <span class="comment">--*/</span>
01083 
01084 {
01085     DIRTY_PAGE <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>;
01086     PDIRTY_PAGE Entry;
01087 
01088     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01089 
01090     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, Dbg, ( <span class="stringliteral">"UdfSetDirtyVmcb\n"</span>, 0 ) );
01091     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, Dbg, ( <span class="stringliteral">" LbnPageNumber = %08x\n"</span>, LbnPageNumber ) );
01092     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, Dbg, ( <span class="stringliteral">" Mask          = %08x\n"</span>, Mask ) );
01093 
01094     <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>.LbnPageNumber = LbnPageNumber;
01095     <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>.DirtyMask = 0;
01096 
01097     <span class="comment">//</span>
01098     <span class="comment">//  Now grab the mutex for the vmcb</span>
01099     <span class="comment">//</span>
01100 
01101     (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;Vmcb-&gt;Mutex,
01102                                  Executive,
01103                                  KernelMode,
01104                                  FALSE,
01105                                  (PLARGE_INTEGER) NULL );
01106 
01107     <span class="keywordflow">try</span> {
01108 
01109         Entry = <a class="code" href="../../d6/d1/gentable_8c.html#a4">RtlInsertElementGenericTable</a>( &amp;Vmcb-&gt;DirtyTable,
01110                                               &amp;Key,
01111                                               <span class="keyword">sizeof</span>(DIRTY_PAGE),
01112                                               NULL );
01113 
01114         Entry-&gt;DirtyMask = (Entry-&gt;DirtyMask | Mask) &amp; (SECTOR_MASK); <span class="comment">//**** change to manifest constant</span>
01115 
01116         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(0, Dbg, ( <span class="stringliteral">"DirtyMask = %08x\n"</span>, Entry-&gt;DirtyMask ) );
01117 
01118         {
01119             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(0, Dbg, ( <span class="stringliteral">""</span>, PbDumpDirtyVmcb(Vmcb) ) );
01120         }
01121 
01122     } finally {
01123 
01124         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d3/d5/mutntobj_8c.html#a5">KeReleaseMutex</a>( &amp;Vmcb-&gt;Mutex, FALSE );
01125 
01126         <a class="code" href="../../d8/d3/lfsdata_8h.html#a3">DebugUnwind</a>(<span class="stringliteral">"UdfSetDirtyVmcb"</span>);
01127         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, Dbg, ( <span class="stringliteral">"UdfSetDirtyVmcb -&gt; VOID\n"</span>, 0 ) );
01128     }
01129 
01130     <span class="keywordflow">return</span>;
01131 }
01132 <span class="preprocessor">#endif // VMCB_WRITE_SUPPORT</span>
01133 <span class="preprocessor"></span>
01134 
01135 <span class="preprocessor">#if VMCB_WRITE_SUPPORT</span>
01136 <span class="preprocessor"></span><a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01137 PbSetCleanVmcb (
01138     IN <a class="code" href="../../d1/d7/struct__VMCB.html">PVMCB</a> Vmcb,
01139     IN ULONG LbnPageNumber,
01140     IN ULONG Mask
01141     )
01142 
01143 <span class="comment">/*++</span>
01144 <span class="comment"></span>
01145 <span class="comment">Routine Description:</span>
01146 <span class="comment"></span>
01147 <span class="comment">    This routine sets all of the sectors within a page as clean.  All</span>
01148 <span class="comment">    of the sectors in a page whether they are dirty or not are set clean</span>
01149 <span class="comment">    by this procedure.</span>
01150 <span class="comment"></span>
01151 <span class="comment">Arguments:</span>
01152 <span class="comment"></span>
01153 <span class="comment">    Vmcb - Supplies the Vmcb being manipulated.</span>
01154 <span class="comment"></span>
01155 <span class="comment">    LbnPageNumber - Supplies the Page Number (Lbn based) of page being</span>
01156 <span class="comment">        modified.  For example, with a page size of 8 a page number of 0</span>
01157 <span class="comment">        corresponds to LBN values 0 through 7, a page number of 1 corresponds</span>
01158 <span class="comment">        to 8 through 15, and so on.</span>
01159 <span class="comment"></span>
01160 <span class="comment">    Mask - Supplies the mask of clean sectors to set for the Page (a 1 bit</span>
01161 <span class="comment">        means to set it clean).  For example to set LBN 9 clean on a system</span>
01162 <span class="comment">        with a page size of 8 the LbnPageNumber will be 1, and the mask will</span>
01163 <span class="comment">        be 0x00000002.</span>
01164 <span class="comment"></span>
01165 <span class="comment">Return Value:</span>
01166 <span class="comment"></span>
01167 <span class="comment">    None.</span>
01168 <span class="comment"></span>
01169 <span class="comment">--*/</span>
01170 
01171 {
01172     DIRTY_PAGE <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>;
01173     PDIRTY_PAGE Entry;
01174 
01175     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01176 
01177     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, Dbg, ( <span class="stringliteral">"UdfSetCleanVmcb\n"</span>, 0 ) );
01178     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, Dbg, ( <span class="stringliteral">" LbnPageNumber = %08x\n"</span>, LbnPageNumber ) );
01179     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, Dbg, ( <span class="stringliteral">" Mask          = %08x\n"</span>, Mask ) );
01180 
01181     <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>.LbnPageNumber = LbnPageNumber;
01182 
01183     <span class="comment">//</span>
01184     <span class="comment">//  Now grab the mutex for the vmcb</span>
01185     <span class="comment">//</span>
01186 
01187     (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;Vmcb-&gt;Mutex,
01188                                  Executive,
01189                                  KernelMode,
01190                                  FALSE,
01191                                  (PLARGE_INTEGER) NULL );
01192 
01193     <span class="keywordflow">try</span> {
01194 
01195         <span class="comment">//</span>
01196         <span class="comment">// If the page is not in the table, it is already all clean</span>
01197         <span class="comment">//</span>
01198 
01199         <span class="keywordflow">if</span> (Entry = <a class="code" href="../../d6/d1/gentable_8c.html#a7">RtlLookupElementGenericTable</a>( &amp;Vmcb-&gt;DirtyTable, &amp;Key )) {
01200 
01201             Entry-&gt;DirtyMask &amp;= ~Mask;
01202 
01203             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(0, Dbg, ( <span class="stringliteral">"DirtyMask = %08x\n"</span>, Entry-&gt;DirtyMask ) );
01204 
01205             <span class="comment">//</span>
01206             <span class="comment">// If the mask is all clean now, delete the entry</span>
01207             <span class="comment">//</span>
01208 
01209             <span class="keywordflow">if</span> (Entry-&gt;DirtyMask == 0) {
01210 
01211                 (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d6/d1/gentable_8c.html#a6">RtlDeleteElementGenericTable</a>( &amp;Vmcb-&gt;DirtyTable, &amp;Key );
01212             }
01213         }
01214 
01215         {
01216             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(0, Dbg, ( <span class="stringliteral">""</span>, PbDumpDirtyVmcb(Vmcb) ) );
01217         }
01218 
01219     } finally {
01220 
01221         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d3/d5/mutntobj_8c.html#a5">KeReleaseMutex</a>( &amp;Vmcb-&gt;Mutex, FALSE );
01222 
01223         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, Dbg, ( <span class="stringliteral">"UdfSetCleanVcmb -&gt; VOID\n"</span>, 0 ) );
01224     }
01225 
01226     <span class="keywordflow">return</span>;
01227 }
01228 <span class="preprocessor">#endif // VMCB_WRITE_SUPPORT</span>
01229 <span class="preprocessor"></span>
01230 
01231 <span class="preprocessor">#if VMCB_WRITE_SUPPORT</span>
01232 <span class="preprocessor"></span>ULONG
01233 PbGetDirtySectorsVmcb (
01234     IN <a class="code" href="../../d1/d7/struct__VMCB.html">PVMCB</a> Vmcb,
01235     IN ULONG LbnPageNumber
01236     )
01237 
01238 <span class="comment">/*++</span>
01239 <span class="comment"></span>
01240 <span class="comment">Routine Description:</span>
01241 <span class="comment"></span>
01242 <span class="comment">    This routine returns to its caller a mask of dirty sectors within a page.</span>
01243 <span class="comment"></span>
01244 <span class="comment">Arguments:</span>
01245 <span class="comment"></span>
01246 <span class="comment">    Vmcb - Supplies the Vmcb being manipulated</span>
01247 <span class="comment"></span>
01248 <span class="comment">    LbnPageNumber - Supplies the Page Number (Lbn based) of page being</span>
01249 <span class="comment">        modified.  For example, with a page size of 8 a page number of 0</span>
01250 <span class="comment">        corresponds to LBN values 0 through 7, a page number of 1 corresponds</span>
01251 <span class="comment">        to 8 through 15, and so on.</span>
01252 <span class="comment"></span>
01253 <span class="comment">Return Value:</span>
01254 <span class="comment"></span>
01255 <span class="comment">    ULONG - Receives a mask of dirty sectors within the specified page.</span>
01256 <span class="comment">        (a 1 bit indicates that the sector is dirty).</span>
01257 <span class="comment"></span>
01258 <span class="comment">--*/</span>
01259 
01260 {
01261     DIRTY_PAGE <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>;
01262     PDIRTY_PAGE Entry;
01263     ULONG Mask;
01264 
01265     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, Dbg, ( <span class="stringliteral">"UdfGetDirtySectorsVmcb\n"</span>, 0 ) );
01266     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, Dbg, ( <span class="stringliteral">" LbnPageNumber = %08x\n"</span>, LbnPageNumber ) );
01267 
01268     <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>.LbnPageNumber = LbnPageNumber;
01269 
01270     <span class="comment">//</span>
01271     <span class="comment">//  Now grab the mutex for the vmcb</span>
01272     <span class="comment">//</span>
01273 
01274     (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;Vmcb-&gt;Mutex,
01275                                  Executive,
01276                                  KernelMode,
01277                                  FALSE,
01278                                  (PLARGE_INTEGER) NULL );
01279 
01280     <span class="keywordflow">try</span> {
01281 
01282         <span class="keywordflow">if</span> ((Entry = <a class="code" href="../../d6/d1/gentable_8c.html#a7">RtlLookupElementGenericTable</a>( &amp;Vmcb-&gt;DirtyTable,
01283                                                    &amp;Key )) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01284 
01285             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(0, Dbg, ( <span class="stringliteral">"Entry not found\n"</span>, 0 ) );
01286 
01287             <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( Mask = 0 );
01288         }
01289 
01290         Mask = Entry-&gt;DirtyMask &amp; (SECTOR_MASK); <span class="comment">//**** change to manifest constant</span>
01291 
01292     } finally {
01293 
01294         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d3/d5/mutntobj_8c.html#a5">KeReleaseMutex</a>( &amp;Vmcb-&gt;Mutex, FALSE );
01295 
01296         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, Dbg, ( <span class="stringliteral">"UdfGetDirtySectorsVmcb -&gt; %08x\n"</span>, Mask ) );
01297     }
01298 
01299     <span class="keywordflow">return</span> Mask;
01300 }
01301 <span class="preprocessor">#endif // VMCB_WRITE_SUPPORT</span>
01302 <span class="preprocessor"></span>
01303 
01304 <span class="preprocessor">#if VMCB_WRITE_SUPPORT</span>
01305 <span class="preprocessor"></span>ULONG
01306 PbGetAndCleanDirtyVmcb (
01307     IN <a class="code" href="../../d1/d7/struct__VMCB.html">PVMCB</a> Vmcb,
01308     IN ULONG LbnPageNumber
01309     )
01310 
01311 <span class="comment">/*++</span>
01312 <span class="comment"></span>
01313 <span class="comment">Routine Description:</span>
01314 <span class="comment"></span>
01315 <span class="comment">    This routine returns to its caller a mask of dirty sectors within a page,</span>
01316 <span class="comment">    and atomically clear the bits.</span>
01317 <span class="comment"></span>
01318 <span class="comment">Arguments:</span>
01319 <span class="comment"></span>
01320 <span class="comment">    Vmcb - Supplies the Vmcb being manipulated</span>
01321 <span class="comment"></span>
01322 <span class="comment">    LbnPageNumber - Supplies the Page Number (Lbn based) of page being</span>
01323 <span class="comment">        modified.  For example, with a page size of 8 a page number of 0</span>
01324 <span class="comment">        corresponds to LBN values 0 through 7, a page number of 1 corresponds</span>
01325 <span class="comment">        to 8 through 15, and so on.</span>
01326 <span class="comment"></span>
01327 <span class="comment">Return Value:</span>
01328 <span class="comment"></span>
01329 <span class="comment">    ULONG - Receives a mask of dirty sectors within the specified page.</span>
01330 <span class="comment">        (a 1 bit indicates that the sector is dirty).</span>
01331 <span class="comment"></span>
01332 <span class="comment">--*/</span>
01333 
01334 {
01335     DIRTY_PAGE <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>;
01336     PDIRTY_PAGE Entry;
01337     ULONG Mask;
01338 
01339     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01340 
01341     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, Dbg, ( <span class="stringliteral">"UdfGetAndCleanDirtyVmcb\n"</span>, 0 ) );
01342     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, Dbg, ( <span class="stringliteral">" LbnPageNumber = %08x\n"</span>, LbnPageNumber ) );
01343 
01344     <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>.LbnPageNumber = LbnPageNumber;
01345 
01346     <span class="comment">//</span>
01347     <span class="comment">//  Now grab the mutex for the vmcb</span>
01348     <span class="comment">//</span>
01349 
01350     (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;Vmcb-&gt;Mutex,
01351                                  Executive,
01352                                  KernelMode,
01353                                  FALSE,
01354                                  (PLARGE_INTEGER) NULL );
01355 
01356     <span class="keywordflow">try</span> {
01357 
01358         <span class="comment">//</span>
01359         <span class="comment">//  Locate the dirty page within the dirty table</span>
01360         <span class="comment">//</span>
01361 
01362         <span class="keywordflow">if</span> ((Entry = <a class="code" href="../../d6/d1/gentable_8c.html#a7">RtlLookupElementGenericTable</a>( &amp;Vmcb-&gt;DirtyTable,
01363                                                    &amp;Key )) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01364 
01365             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(0, Dbg, ( <span class="stringliteral">"Entry not found\n"</span>, 0 ) );
01366 
01367             <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( Mask = 0 );
01368         }
01369 
01370         <span class="comment">//</span>
01371         <span class="comment">//  We found a page so generate a proper mask and then</span>
01372         <span class="comment">//  delete the dirty page</span>
01373         <span class="comment">//</span>
01374 
01375         Mask = Entry-&gt;DirtyMask &amp; (SECTOR_MASK); <span class="comment">//**** change to manifest constant</span>
01376 
01377         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d6/d1/gentable_8c.html#a6">RtlDeleteElementGenericTable</a>( &amp;Vmcb-&gt;DirtyTable, &amp;Key );
01378 
01379     } finally {
01380 
01381         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d3/d5/mutntobj_8c.html#a5">KeReleaseMutex</a>( &amp;Vmcb-&gt;Mutex, FALSE );
01382 
01383         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, Dbg, ( <span class="stringliteral">"UdfGetAndCleanDirtyVmcb -&gt; %08x\n"</span>, Mask ) );
01384     }
01385 
01386     <span class="keywordflow">return</span> Mask;
01387 }
01388 <span class="preprocessor">#endif // VMCB_WRITE_SUPPORT</span>
01389 <span class="preprocessor"></span>
01390 
01391 <span class="comment">//</span>
01392 <span class="comment">//  Local support routines</span>
01393 <span class="comment">//</span>
01394 
01395 <span class="preprocessor">#if VMCB_WRITE_SUPPORT</span>
01396 <span class="preprocessor"></span>RTL_GENERIC_COMPARE_RESULTS
01397 PbCompareDirtyVmcb (
01398     IN PRTL_GENERIC_TABLE DirtyTable,
01399     IN PVOID FirstStruct,
01400     IN PVOID SecondStruct
01401     )
01402 
01403 <span class="comment">/*++</span>
01404 <span class="comment"></span>
01405 <span class="comment">Routine Description:</span>
01406 <span class="comment"></span>
01407 <span class="comment">    This generic table support routine compares two dirty page structures</span>
01408 <span class="comment"></span>
01409 <span class="comment">Arguments:</span>
01410 <span class="comment"></span>
01411 <span class="comment">    DirtyTable - Supplies the generic table being queried</span>
01412 <span class="comment"></span>
01413 <span class="comment">    FirstStruct - Really supplies the first structure to compare</span>
01414 <span class="comment"></span>
01415 <span class="comment">    SecondStruct - Really supplies the second structure to compare</span>
01416 <span class="comment"></span>
01417 <span class="comment">Return Value:</span>
01418 <span class="comment"></span>
01419 <span class="comment">    RTL_GENERIDC_COMPARE_RESULTS - The results of comparing the two</span>
01420 <span class="comment">        input structures</span>
01421 <span class="comment"></span>
01422 <span class="comment">--*/</span>
01423 
01424 {
01425 
01426     PDIRTY_PAGE DirtyPage1 = FirstStruct;
01427     PDIRTY_PAGE DirtyPage2 = SecondStruct;
01428 
01429     UNREFERENCED_PARAMETER( DirtyTable );
01430 
01431     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01432 
01433     <span class="keywordflow">if</span> (DirtyPage1-&gt;LbnPageNumber &lt; DirtyPage2-&gt;LbnPageNumber) {
01434 
01435         <span class="keywordflow">return</span> GenericLessThan;
01436 
01437     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (DirtyPage1-&gt;LbnPageNumber &gt; DirtyPage2-&gt;LbnPageNumber) {
01438 
01439         <span class="keywordflow">return</span> GenericGreaterThan;
01440 
01441     } <span class="keywordflow">else</span> {
01442 
01443         <span class="keywordflow">return</span> GenericEqual;
01444     }
01445 }
01446 <span class="preprocessor">#endif // VMCB_WRITE_SUPPORT</span>
01447 <span class="preprocessor"></span>
01448 
01449 <span class="comment">//</span>
01450 <span class="comment">//  Local support routines</span>
01451 <span class="comment">//</span>
01452 
01453 <span class="preprocessor">#if VMCB_WRITE_SUPPORT</span>
01454 <span class="preprocessor"></span>PVOID
01455 PbAllocateDirtyVmcb (
01456     IN PRTL_GENERIC_TABLE DirtyTable,
01457     IN CLONG ByteSize
01458     )
01459 
01460 <span class="comment">/*++</span>
01461 <span class="comment"></span>
01462 <span class="comment">Routine Description:</span>
01463 <span class="comment"></span>
01464 <span class="comment">    This generic table support routine allocates memory</span>
01465 <span class="comment"></span>
01466 <span class="comment">Arguments:</span>
01467 <span class="comment"></span>
01468 <span class="comment">    DirtyTable - Supplies the generic table being modified</span>
01469 <span class="comment"></span>
01470 <span class="comment">    ByteSize - Supplies the size, in bytes, to allocate</span>
01471 <span class="comment"></span>
01472 <span class="comment">Return Value:</span>
01473 <span class="comment"></span>
01474 <span class="comment">    PVOID - Returns a pointer to the allocated data</span>
01475 <span class="comment"></span>
01476 <span class="comment">--*/</span>
01477 
01478 {
01479     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01480 
01481     <span class="keywordflow">return</span> <a class="code" href="../../d1/d8/fsrtl_8h.html#a37">FsRtlAllocatePoolWithTag</a>( (POOL_TYPE)DirtyTable-&gt;TableContext, ByteSize, 'bcmV' );
01482 }
01483 <span class="preprocessor">#endif // VMCB_WRITE_SUPPORT</span>
01484 <span class="preprocessor"></span>
01485 
01486 <span class="comment">//</span>
01487 <span class="comment">//  Local support routines</span>
01488 <span class="comment">//</span>
01489 
01490 <span class="preprocessor">#if VMCB_WRITE_SUPPORT</span>
01491 <span class="preprocessor"></span><a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01492 PbDeallocateDirtyVmcb (
01493     IN PRTL_GENERIC_TABLE DirtyTable,
01494     IN PVOID Buffer
01495     )
01496 
01497 <span class="comment">/*++</span>
01498 <span class="comment"></span>
01499 <span class="comment">Routine Description:</span>
01500 <span class="comment"></span>
01501 <span class="comment">    This generic table support routine deallocates memory</span>
01502 <span class="comment"></span>
01503 <span class="comment">Arguments:</span>
01504 <span class="comment"></span>
01505 <span class="comment">    DirtyTable - Supplies the generic table being modified</span>
01506 <span class="comment"></span>
01507 <span class="comment">    Buffer - Supplies the buffer being deallocated</span>
01508 <span class="comment"></span>
01509 <span class="comment">Return Value:</span>
01510 <span class="comment"></span>
01511 <span class="comment">    None.</span>
01512 <span class="comment"></span>
01513 <span class="comment">--*/</span>
01514 
01515 {
01516     UNREFERENCED_PARAMETER( DirtyTable );
01517 
01518     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01519 
01520     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( Buffer );
01521 
01522     <span class="keywordflow">return</span>;
01523 }
01524 <span class="preprocessor">#endif // VMCB_WRITE_SUPPORT</span>
01525 <span class="preprocessor"></span>
01526 
01527 <span class="comment">//</span>
01528 <span class="comment">//  Local support routines</span>
01529 <span class="comment">//</span>
01530 
01531 <span class="preprocessor">#if VMCB_WRITE_SUPPORT</span>
01532 <span class="preprocessor"></span>ULONG
01533 PbDumpDirtyVmcb (
01534     IN <a class="code" href="../../d1/d7/struct__VMCB.html">PVMCB</a> Vmcb
01535     )
01536 
01537 <span class="comment">/*++</span>
01538 <span class="comment"></span>
01539 <span class="comment">Routine Description:</span>
01540 <span class="comment"></span>
01541 <span class="comment">Arguments:</span>
01542 <span class="comment"></span>
01543 <span class="comment">Return Value:</span>
01544 <span class="comment"></span>
01545 <span class="comment">--*/</span>
01546 
01547 {
01548     PDIRTY_PAGE <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a28">Ptr</a>;
01549 
01550     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01551 
01552     KdPrint((<span class="stringliteral">" Dump Dirty Vmcb\n"</span>));
01553 
01554     <span class="keywordflow">for</span> (<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a28">Ptr</a> = <a class="code" href="../../d6/d1/gentable_8c.html#a9">RtlEnumerateGenericTable</a>( &amp;Vmcb-&gt;DirtyTable, TRUE );
01555          <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a28">Ptr</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01556          <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a28">Ptr</a> = <a class="code" href="../../d6/d1/gentable_8c.html#a9">RtlEnumerateGenericTable</a>( &amp;Vmcb-&gt;DirtyTable, FALSE )) {
01557 
01558         KdPrint((<span class="stringliteral">"        LbnPageNumber = %08x, "</span>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a28">Ptr</a>-&gt;LbnPageNumber ));
01559         KdPrint((<span class="stringliteral">"DirtyMask = %08x\n"</span>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a28">Ptr</a>-&gt;DirtyMask ));
01560     }
01561 
01562     <span class="keywordflow">return</span> 0;
01563 }
01564 <span class="preprocessor">#endif // VMCB_WRITE_SUPPORT</span>
01565 <span class="preprocessor"></span>
01566 
01567 <span class="preprocessor">#if VMCB_WRITE_SUPPORT</span>
01568 <span class="preprocessor"></span><a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01569 PbFlushVolumeFile (
01570     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01571     IN <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb
01572     )
01573 
01574 <span class="comment">/*++</span>
01575 <span class="comment"></span>
01576 <span class="comment">Routine Description:</span>
01577 <span class="comment"></span>
01578 <span class="comment">    The function carefully flushes the entire volume file.  It is nessecary</span>
01579 <span class="comment">    to dance around a bit because of complicated synchronization reasons.</span>
01580 <span class="comment"></span>
01581 <span class="comment">Arguments:</span>
01582 <span class="comment"></span>
01583 <span class="comment">    Vcb - Supplies the Vcb being flushed</span>
01584 <span class="comment"></span>
01585 <span class="comment">Return Value:</span>
01586 <span class="comment"></span>
01587 <span class="comment">    NTSTATUS - The status of the flush operation</span>
01588 <span class="comment"></span>
01589 <span class="comment">--*/</span>
01590 
01591 {
01592     ULONG ElementNumber;
01593     ULONG NumberOfDirtyPages;
01594     PULONG VbnsToFlush;
01595 
01596     <a class="code" href="../../d1/d8/fsrtl_8h.html#a50">LBN</a> Lbn;
01597     PDIRTY_PAGE <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a28">Ptr</a>;
01598 
01599     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> ReturnStatus = STATUS_SUCCESS;
01600 
01601     <a class="code" href="../../d1/d7/struct__VMCB.html">PVMCB</a> Vmcb = (PNONOPAQUE_VMCB)&amp;Vcb-&gt;Vmcb;
01602 
01603     <span class="comment">//</span>
01604     <span class="comment">//  The only way we have to correctly synchronize things is to</span>
01605     <span class="comment">//  repin stuff, and then unpin repin it with WriteThrough as TRUE.</span>
01606     <span class="comment">//</span>
01607     <span class="comment">//  Grab the mutex for the vmcb</span>
01608     <span class="comment">//</span>
01609 
01610     (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;Vmcb-&gt;<a class="code" href="../../d1/d7/struct__VMCB.html#o0">Mutex</a>,
01611                                  Executive,
01612                                  KernelMode,
01613                                  FALSE,
01614                                  (PLARGE_INTEGER) NULL );
01615 
01616     NumberOfDirtyPages = <a class="code" href="../../d6/d1/gentable_8c.html#a12">RtlNumberGenericTableElements</a>(&amp;Vmcb-&gt;DirtyTable);
01617 
01618     <span class="comment">//</span>
01619     <span class="comment">//  If there are no dirty sectors, no need to flush.</span>
01620     <span class="comment">//</span>
01621 
01622     <span class="keywordflow">if</span> (NumberOfDirtyPages == 0) {
01623 
01624         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d3/d5/mutntobj_8c.html#a5">KeReleaseMutex</a>( &amp;Vmcb-&gt;<a class="code" href="../../d1/d7/struct__VMCB.html#o0">Mutex</a>, FALSE );
01625         <span class="keywordflow">return</span> STATUS_SUCCESS;
01626     }
01627 
01628     <span class="keywordflow">try</span> {
01629 
01630         VbnsToFlush = <a class="code" href="../../d1/d8/fsrtl_8h.html#a37">FsRtlAllocatePoolWithTag</a>( PagedPool, NumberOfDirtyPages * <span class="keyword">sizeof</span>(ULONG), 'bcmV' );
01631 
01632     } finally {
01633 
01634         <span class="keywordflow">if</span> (AbnormalTermination()) {
01635 
01636             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d3/d5/mutntobj_8c.html#a5">KeReleaseMutex</a>( &amp;Vmcb-&gt;<a class="code" href="../../d1/d7/struct__VMCB.html#o0">Mutex</a>, FALSE );
01637         }
01638     }
01639 
01640     <span class="keywordflow">for</span> (<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a28">Ptr</a> = <a class="code" href="../../d6/d1/gentable_8c.html#a9">RtlEnumerateGenericTable</a>( &amp;Vmcb-&gt;DirtyTable, TRUE ),
01641          ElementNumber = 0;
01642          <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a28">Ptr</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01643          <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a28">Ptr</a> = <a class="code" href="../../d6/d1/gentable_8c.html#a9">RtlEnumerateGenericTable</a>( &amp;Vmcb-&gt;DirtyTable, FALSE ),
01644          ElementNumber += 1) {
01645 
01646         <a class="code" href="../../d1/d8/fsrtl_8h.html#a52">VBN</a> Vbn;
01647         BOOLEAN Result;
01648 
01649         <span class="comment">//</span>
01650         <span class="comment">//  Lbn pages always map to Vbn pages.  Thus any sector in an Lbn</span>
01651         <span class="comment">//  page will map to the same Vbn page.  So it suffices to map the</span>
01652         <span class="comment">//  first Lbn in the page to a Vbn and flush that page.</span>
01653         <span class="comment">//</span>
01654 
01655         Lbn = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a28">Ptr</a>-&gt;LbnPageNumber * (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> / 512);
01656 
01657         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a28">Ptr</a>-&gt;DirtyMask != 0);
01658 
01659         Result = PbVmcbLbnToVbn( &amp;Vcb-&gt;Vmcb, Lbn, &amp;Vbn, NULL );
01660 
01661         <span class="comment">//</span>
01662         <span class="comment">//  This lookup must work as the LBN page was dirty.</span>
01663         <span class="comment">//</span>
01664 
01665         <span class="keywordflow">if</span> (!Result) {
01666 
01667             PbBugCheck( 0, 0, 0 );
01668         }
01669 
01670         <span class="comment">//</span>
01671         <span class="comment">//  Bring store this Vbn away for flushing later.</span>
01672         <span class="comment">//</span>
01673 
01674         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( ElementNumber &lt; NumberOfDirtyPages );
01675         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( (Vbn &amp; (PAGE_SIZE/512 - 1)) == 0 );
01676 
01677         VbnsToFlush[ElementNumber] = Vbn;
01678     }
01679 
01680     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( ElementNumber == NumberOfDirtyPages );
01681 
01682     <span class="comment">//</span>
01683     <span class="comment">//  Now drop the mutex and walk through the dirty Vbn list generated</span>
01684     <span class="comment">//  above.  We cannot hold the mutex while doing IO as this will cause</span>
01685     <span class="comment">//  a deadlock with the cache manager.</span>
01686     <span class="comment">//</span>
01687 
01688     (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d3/d5/mutntobj_8c.html#a5">KeReleaseMutex</a>( &amp;Vmcb-&gt;<a class="code" href="../../d1/d7/struct__VMCB.html#o0">Mutex</a>, FALSE );
01689 
01690     <span class="keywordflow">for</span> ( ElementNumber = 0;
01691           ElementNumber &lt; NumberOfDirtyPages;
01692           ElementNumber += 1) {
01693 
01694         <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> Bcb;
01695         PVOID DontCare;
01696         LARGE_INTEGER <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
01697         IO_STATUS_BLOCK Iosb;
01698 
01699         <span class="comment">//</span>
01700         <span class="comment">//  This page is dirty.  Flush it by writing it though.</span>
01701         <span class="comment">//</span>
01702 
01703         <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.QuadPart = VbnsToFlush[ElementNumber] &lt;&lt; 9;
01704 
01705         <span class="keywordflow">try</span> {
01706 
01707             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d4/d2/cache_8h.html#a87">CcPinRead</a>( Vcb-&gt;VirtualVolumeFile,
01708                              &amp;Offset,
01709                              PAGE_SIZE,
01710                              TRUE,
01711                              &amp;Bcb,
01712                              &amp;DontCare );
01713 
01714             <a class="code" href="../../d4/d2/cache_8h.html#a91">CcSetDirtyPinnedData</a>( Bcb, NULL );
01715             <a class="code" href="../../d4/d2/cache_8h.html#a68">CcRepinBcb</a>( Bcb );
01716             <a class="code" href="../../d4/d2/cache_8h.html#a92">CcUnpinData</a>( Bcb );
01717             <a class="code" href="../../d4/d2/cache_8h.html#a69">CcUnpinRepinnedBcb</a>( Bcb, TRUE, &amp;Iosb );
01718 
01719             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Iosb.Status)) {
01720 
01721                 ReturnStatus = Iosb.Status;
01722             }
01723 
01724         } except(PbExceptionFilter(IrpContext, GetExceptionInformation())) {
01725 
01726             ReturnStatus = IrpContext-&gt;ExceptionStatus;
01727         }
01728     }
01729 
01730     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( VbnsToFlush );
01731 
01732     <span class="keywordflow">return</span> ReturnStatus;
01733 }
01734 <span class="preprocessor">#endif // VMCB_WRITE_SUPPORT</span>
01735 <span class="preprocessor"></span>
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:42:24 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
