<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: nls.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>nls.c</h1><a href="../../d6/d6/nls_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1990  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    nls.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module implements NLS support functions for NT.</span>
00012 <span class="comment"></span>
00013 <span class="comment">Author:</span>
00014 <span class="comment"></span>
00015 <span class="comment">    Mark Lucovsky (markl) 16-Apr-1991</span>
00016 <span class="comment"></span>
00017 <span class="comment">Environment:</span>
00018 <span class="comment"></span>
00019 <span class="comment">    Kernel or user-mode</span>
00020 <span class="comment"></span>
00021 <span class="comment">Revision History:</span>
00022 <span class="comment"></span>
00023 <span class="comment">    16-Feb-1993    JulieB    Added Upcase Rtl Routines.</span>
00024 <span class="comment">    08-Mar-1993    JulieB    Moved Upcase Macro to ntrtlp.h.</span>
00025 <span class="comment">    02-Apr-1993    JulieB    Fixed RtlAnsiCharToUnicodeChar to use transl. tbls.</span>
00026 <span class="comment">    02-Apr-1993    JulieB    Fixed BUFFER_TOO_SMALL check.</span>
00027 <span class="comment">    28-May-1993    JulieB    Fixed code to properly handle DBCS.</span>
00028 <span class="comment"></span>
00029 <span class="comment">--*/</span>
00030 
00031 <span class="preprocessor">#include "<a class="code" href="../../d5/d9/ntrtlp_8h.html">ntrtlp.h</a>"</span>
00032 
00033 <span class="preprocessor">#if defined(ALLOC_PRAGMA) &amp;&amp; defined(NTOS_KERNEL_RUNTIME)</span>
00034 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlAnsiStringToUnicodeString)</span>
00035 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlAnsiCharToUnicodeChar)</span>
00036 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlOemStringToUnicodeString)</span>
00037 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlUnicodeStringToAnsiString)</span>
00038 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlUpcaseUnicodeStringToAnsiString)</span>
00039 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlUnicodeStringToOemString)</span>
00040 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlUpcaseUnicodeStringToOemString)</span>
00041 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlOemStringToCountedUnicodeString)</span>
00042 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlUnicodeStringToCountedOemString)</span>
00043 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlUpcaseUnicodeStringToCountedOemString)</span>
00044 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlUpcaseUnicodeString)</span>
00045 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlDowncaseUnicodeString)</span>
00046 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlUpcaseUnicodeChar)</span>
00047 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlFreeUnicodeString)</span>
00048 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlFreeAnsiString)</span>
00049 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlFreeOemString)</span>
00050 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlCreateUnicodeString)</span>
00051 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlEqualDomainName)</span>
00052 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlEqualComputerName)</span>
00053 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlEqualUnicodeString)</span>
00054 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlxUnicodeStringToOemSize)</span>
00055 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlxAnsiStringToUnicodeSize)</span>
00056 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlxUnicodeStringToAnsiSize)</span>
00057 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlxOemStringToUnicodeSize)</span>
00058 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlIsTextUnicode)</span>
00059 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00060 <span class="preprocessor"></span>
00061 
00062 
00063 
00064 <span class="comment">//</span>
00065 <span class="comment">// Global data used for translations.</span>
00066 <span class="comment">//</span>
00067 
<a name="l00068"></a><a class="code" href="../../d6/d6/nls_8c.html#a19">00068</a> <span class="keyword">extern</span> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>  <a class="code" href="../../d6/d6/nls_8c.html#a19">NlsAnsiToUnicodeData</a>;    <span class="comment">// Ansi CP to Unicode translation table</span>
<a name="l00069"></a><a class="code" href="../../d6/d6/nls_8c.html#a20">00069</a> <span class="keyword">extern</span> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>  <a class="code" href="../../d6/d6/nls_8c.html#a20">NlsLeadByteInfo</a>;         <span class="comment">// Lead byte info for ACP</span>
00070 
00071 <span class="comment">//</span>
00072 <span class="comment">// Pulled from lmcons.h:</span>
00073 <span class="comment">//</span>
00074 
00075 <span class="preprocessor">#ifndef NETBIOS_NAME_LEN</span>
<a name="l00076"></a><a class="code" href="../../d6/d6/nls_8c.html#a0">00076</a> <span class="preprocessor"></span><span class="preprocessor">#define NETBIOS_NAME_LEN  16            // NetBIOS net name (bytes)</span>
00077 <span class="preprocessor"></span><span class="preprocessor">#endif // NETBIOS_NAME_LEN</span>
00078 <span class="preprocessor"></span>
00079 
00080 
00081 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00082"></a><a class="code" href="../../d6/d6/nls_8c.html#a21">00082</a> <a class="code" href="../../d6/d6/nls_8c.html#a21">RtlAnsiStringToUnicodeString</a>(
00083     OUT PUNICODE_STRING DestinationString,
00084     IN PANSI_STRING SourceString,
00085     IN BOOLEAN AllocateDestinationString
00086     )
00087 
00088 <span class="comment">/*++</span>
00089 <span class="comment"></span>
00090 <span class="comment">Routine Description:</span>
00091 <span class="comment"></span>
00092 <span class="comment">    This functions converts the specified ansi source string into a</span>
00093 <span class="comment">    Unicode string. The translation is done with respect to the</span>
00094 <span class="comment">    current system locale information.</span>
00095 <span class="comment"></span>
00096 <span class="comment">Arguments:</span>
00097 <span class="comment"></span>
00098 <span class="comment">    DestinationString - Returns a unicode string that is equivalent to</span>
00099 <span class="comment">        the ansi source string. The maximum length field is only</span>
00100 <span class="comment">        set if AllocateDestinationString is TRUE.</span>
00101 <span class="comment"></span>
00102 <span class="comment">    SourceString - Supplies the ansi source string that is to be</span>
00103 <span class="comment">        converted to unicode.</span>
00104 <span class="comment"></span>
00105 <span class="comment">    AllocateDestinationString - Supplies a flag that controls whether or</span>
00106 <span class="comment">        not this API allocates the buffer space for the destination</span>
00107 <span class="comment">        string.  If it does, then the buffer must be deallocated using</span>
00108 <span class="comment">        RtlFreeUnicodeString (note that only storage for</span>
00109 <span class="comment">        DestinationString-&gt;Buffer is allocated by this API).</span>
00110 <span class="comment"></span>
00111 <span class="comment">Return Value:</span>
00112 <span class="comment"></span>
00113 <span class="comment">    SUCCESS - The conversion was successful</span>
00114 <span class="comment"></span>
00115 <span class="comment">    !SUCCESS - The operation failed.  No storage was allocated and no</span>
00116 <span class="comment">        conversion was done.  None.</span>
00117 <span class="comment"></span>
00118 <span class="comment">--*/</span>
00119 
00120 {
00121     ULONG UnicodeLength;
00122     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00123     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> st;
00124 
00125     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00126 
00127     UnicodeLength = RtlAnsiStringToUnicodeSize(<a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>);
00128     <span class="keywordflow">if</span> ( UnicodeLength &gt; MAXUSHORT ) {
00129         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER_2;
00130         }
00131 
00132     DestinationString-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(UnicodeLength - <span class="keyword">sizeof</span>(UNICODE_NULL));
00133     <span class="keywordflow">if</span> ( AllocateDestinationString ) {
00134         DestinationString-&gt;MaximumLength = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)UnicodeLength;
00135         DestinationString-&gt;Buffer = (<a class="code" href="../../d8/d2/ldrinit_8c.html#a7">RtlAllocateStringRoutine</a>)(UnicodeLength);
00136         <span class="keywordflow">if</span> ( !DestinationString-&gt;Buffer ) {
00137             <span class="keywordflow">return</span> STATUS_NO_MEMORY;
00138             }
00139         }
00140     <span class="keywordflow">else</span> {
00141         <span class="keywordflow">if</span> ( DestinationString-&gt;Length &gt;= DestinationString-&gt;MaximumLength ) {
00142             <span class="keywordflow">return</span> STATUS_BUFFER_OVERFLOW;
00143             }
00144         }
00145 
00146     st = <a class="code" href="../../d9/d6/nlsxlat_8c.html#a33">RtlMultiByteToUnicodeN</a>(
00147              DestinationString-&gt;Buffer,
00148              DestinationString-&gt;Length,
00149              &amp;<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>,
00150              <a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>-&gt;Buffer,
00151              <a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>-&gt;Length
00152              );
00153 
00154     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st)) {
00155         <span class="keywordflow">if</span> ( AllocateDestinationString ) {
00156             (<a class="code" href="../../d8/d2/ldrinit_8c.html#a8">RtlFreeStringRoutine</a>)(DestinationString-&gt;Buffer);
00157             DestinationString-&gt;Buffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00158         }
00159 
00160         <span class="keywordflow">return</span> st;
00161     }
00162 
00163     DestinationString-&gt;Buffer[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> / <span class="keyword">sizeof</span>(WCHAR)] = UNICODE_NULL;
00164 
00165     <span class="keywordflow">return</span> STATUS_SUCCESS;
00166 
00167 }
00168 
00169 
00170 WCHAR
<a name="l00171"></a><a class="code" href="../../d6/d6/nls_8c.html#a22">00171</a> <a class="code" href="../../d6/d6/nls_8c.html#a22">RtlAnsiCharToUnicodeChar</a>(
00172     IN OUT PUCHAR *SourceCharacter
00173     )
00174 
00175 <span class="comment">/*++</span>
00176 <span class="comment"></span>
00177 <span class="comment">Routine Description:</span>
00178 <span class="comment"></span>
00179 <span class="comment">    This function translates the specified ansi character to unicode and</span>
00180 <span class="comment">    returns the unicode value.  The purpose for this routine is to allow</span>
00181 <span class="comment">    for character by character ansi to unicode translation.  The</span>
00182 <span class="comment">    translation is done with respect to the current system locale</span>
00183 <span class="comment">    information.</span>
00184 <span class="comment"></span>
00185 <span class="comment"></span>
00186 <span class="comment">Arguments:</span>
00187 <span class="comment"></span>
00188 <span class="comment">    SourceCharacter - Supplies a pointer to an ansi character pointer.</span>
00189 <span class="comment">        Through two levels of indirection, this supplies an ansi</span>
00190 <span class="comment">        character that is to be translated to unicode.  After</span>
00191 <span class="comment">        translation, the ansi character pointer is modified to point to</span>
00192 <span class="comment">        the next character to be converted.  This is done to allow for</span>
00193 <span class="comment">        dbcs ansi characters.</span>
00194 <span class="comment"></span>
00195 <span class="comment">Return Value:</span>
00196 <span class="comment"></span>
00197 <span class="comment">    Returns the unicode equivalent of the specified ansi character.</span>
00198 <span class="comment"></span>
00199 <span class="comment">--*/</span>
00200 
00201 {
00202     WCHAR UnicodeCharacter;
00203     ULONG cbCharSize;
00204     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> st;
00205 
00206 
00207     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00208 
00209 
00210 <span class="preprocessor">#if 0</span>
00211 <span class="preprocessor"></span>    UnicodeCharacter = <a class="code" href="../../d6/d6/nls_8c.html#a19">NlsAnsiToUnicodeData</a>[(UCHAR)(**SourceCharacter)];
00212     (*SourceCharacter)++;
00213     <span class="keywordflow">return</span> UnicodeCharacter;
00214 <span class="preprocessor">#endif</span>
00215 <span class="preprocessor"></span>
00216 
00217     <span class="comment">//</span>
00218     <span class="comment">// Translate the ansi character to unicode - this handles DBCS.</span>
00219     <span class="comment">//</span>
00220     cbCharSize = <a class="code" href="../../d6/d6/nls_8c.html#a20">NlsLeadByteInfo</a>[ **SourceCharacter ] ? 2 : 1;
00221     st = <a class="code" href="../../d9/d6/nlsxlat_8c.html#a33">RtlMultiByteToUnicodeN</a> ( &amp;UnicodeCharacter,
00222                                   <span class="keyword">sizeof</span> ( WCHAR ),
00223                                   <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00224                                   *SourceCharacter,
00225                                   cbCharSize );
00226 
00227     <span class="comment">//</span>
00228     <span class="comment">// Check for error - The only time this will happen is if there is</span>
00229     <span class="comment">// a leadbyte without a trail byte.</span>
00230     <span class="comment">//</span>
00231     <span class="keywordflow">if</span> ( ! <a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( st ) )
00232     {
00233         <span class="comment">// Use space as default.</span>
00234         UnicodeCharacter = 0x0020;
00235     }
00236 
00237     <span class="comment">//</span>
00238     <span class="comment">// Advance the source pointer and return the Unicode character.</span>
00239     <span class="comment">//</span>
00240     (*SourceCharacter) += cbCharSize;
00241     <span class="keywordflow">return</span> UnicodeCharacter;
00242 }
00243 
00244 
00245 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00246"></a><a class="code" href="../../d6/d6/nls_8c.html#a23">00246</a> <a class="code" href="../../d6/d6/nls_8c.html#a23">RtlUnicodeStringToAnsiString</a>(
00247     OUT PANSI_STRING DestinationString,
00248     IN PUNICODE_STRING SourceString,
00249     IN BOOLEAN AllocateDestinationString
00250     )
00251 
00252 <span class="comment">/*++</span>
00253 <span class="comment"></span>
00254 <span class="comment">Routine Description:</span>
00255 <span class="comment"></span>
00256 <span class="comment">    This functions converts the specified unicode source string into an</span>
00257 <span class="comment">    ansi string. The translation is done with respect to the</span>
00258 <span class="comment">    current system locale information.</span>
00259 <span class="comment"></span>
00260 <span class="comment">Arguments:</span>
00261 <span class="comment"></span>
00262 <span class="comment">    DestinationString - Returns an ansi string that is equivalent to the</span>
00263 <span class="comment">        unicode source string.  If the translation can not be done,</span>
00264 <span class="comment">        an error is returned.  The maximum length field is only set if</span>
00265 <span class="comment">        AllocateDestinationString is TRUE.</span>
00266 <span class="comment"></span>
00267 <span class="comment">    SourceString - Supplies the unicode source string that is to be</span>
00268 <span class="comment">        converted to ansi.</span>
00269 <span class="comment"></span>
00270 <span class="comment">    AllocateDestinationString - Supplies a flag that controls whether or</span>
00271 <span class="comment">        not this API allocates the buffer space for the destination</span>
00272 <span class="comment">        string.  If it does, then the buffer must be deallocated using</span>
00273 <span class="comment">        RtlFreeAnsiString (note that only storage for</span>
00274 <span class="comment">        DestinationString-&gt;Buffer is allocated by this API).</span>
00275 <span class="comment"></span>
00276 <span class="comment">Return Value:</span>
00277 <span class="comment"></span>
00278 <span class="comment">    SUCCESS - The conversion was successful</span>
00279 <span class="comment"></span>
00280 <span class="comment">    !SUCCESS - The operation failed.  No storage was allocated and no</span>
00281 <span class="comment">        conversion was done.  None.</span>
00282 <span class="comment"></span>
00283 <span class="comment">--*/</span>
00284 
00285 {
00286     ULONG AnsiLength;
00287     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00288     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> st;
00289     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> ReturnStatus = STATUS_SUCCESS;
00290 
00291     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00292 
00293     AnsiLength = RtlUnicodeStringToAnsiSize(<a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>);
00294     <span class="keywordflow">if</span> ( AnsiLength &gt; MAXUSHORT ) {
00295         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER_2;
00296         }
00297 
00298     DestinationString-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(AnsiLength - 1);
00299     <span class="keywordflow">if</span> ( AllocateDestinationString ) {
00300         DestinationString-&gt;MaximumLength = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)AnsiLength;
00301         DestinationString-&gt;Buffer = (<a class="code" href="../../d8/d2/ldrinit_8c.html#a7">RtlAllocateStringRoutine</a>)(AnsiLength);
00302         <span class="keywordflow">if</span> ( !DestinationString-&gt;Buffer ) {
00303             <span class="keywordflow">return</span> STATUS_NO_MEMORY;
00304             }
00305         }
00306     <span class="keywordflow">else</span> {
00307         <span class="keywordflow">if</span> ( DestinationString-&gt;Length &gt;= DestinationString-&gt;MaximumLength ) {
00308             <span class="comment">/*</span>
00309 <span class="comment">             * Return STATUS_BUFFER_OVERFLOW, but translate as much as</span>
00310 <span class="comment">             * will fit into the buffer first.  This is the expected</span>
00311 <span class="comment">             * behavior for routines such as GetProfileStringA.</span>
00312 <span class="comment">             * Set the length of the buffer to one less than the maximum</span>
00313 <span class="comment">             * (so that the trail byte of a double byte char is not</span>
00314 <span class="comment">             * overwritten by doing DestinationString-&gt;Buffer[Index] = '\0').</span>
00315 <span class="comment">             * RtlUnicodeToMultiByteN is careful not to truncate a</span>
00316 <span class="comment">             * multibyte character.</span>
00317 <span class="comment">             */</span>
00318             <span class="keywordflow">if</span> (!DestinationString-&gt;MaximumLength) {
00319                 <span class="keywordflow">return</span> STATUS_BUFFER_OVERFLOW;
00320             }
00321             ReturnStatus = STATUS_BUFFER_OVERFLOW;
00322             DestinationString-&gt;Length = DestinationString-&gt;MaximumLength - 1;
00323             }
00324         }
00325 
00326     st = <a class="code" href="../../d9/d6/nlsxlat_8c.html#a37">RtlUnicodeToMultiByteN</a>(
00327              DestinationString-&gt;Buffer,
00328              DestinationString-&gt;Length,
00329              &amp;<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>,
00330              <a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>-&gt;Buffer,
00331              <a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>-&gt;Length
00332              );
00333 
00334     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st)) {
00335         <span class="keywordflow">if</span> ( AllocateDestinationString ) {
00336             (<a class="code" href="../../d8/d2/ldrinit_8c.html#a8">RtlFreeStringRoutine</a>)(DestinationString-&gt;Buffer);
00337             DestinationString-&gt;Buffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00338         }
00339 
00340         <span class="keywordflow">return</span> st;
00341     }
00342 
00343     DestinationString-&gt;Buffer[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>] = <span class="charliteral">'\0'</span>;
00344 
00345     <span class="keywordflow">return</span> ReturnStatus;
00346 }
00347 
00348 
00349 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00350"></a><a class="code" href="../../d6/d6/nls_8c.html#a24">00350</a> <a class="code" href="../../d6/d6/nls_8c.html#a24">RtlUpcaseUnicodeStringToAnsiString</a>(
00351     OUT PANSI_STRING DestinationString,
00352     IN PUNICODE_STRING SourceString,
00353     IN BOOLEAN AllocateDestinationString
00354     )
00355 
00356 <span class="comment">/*++</span>
00357 <span class="comment"></span>
00358 <span class="comment">Routine Description:</span>
00359 <span class="comment"></span>
00360 <span class="comment">    This functions upper cases the specified unicode source string and then</span>
00361 <span class="comment">    converts it into an ansi string. The translation is done with respect</span>
00362 <span class="comment">    to the current system locale information.</span>
00363 <span class="comment"></span>
00364 <span class="comment">Arguments:</span>
00365 <span class="comment"></span>
00366 <span class="comment">    DestinationString - Returns an ansi string that is equivalent to the</span>
00367 <span class="comment">        unicode source string.  If the translation can not be done,</span>
00368 <span class="comment">        an error is returned.  The maximum length field is only set</span>
00369 <span class="comment">        if AllocateDestinationString is TRUE.</span>
00370 <span class="comment"></span>
00371 <span class="comment">    SourceString - Supplies the unicode source string that is to be</span>
00372 <span class="comment">        converted to upper case ansi.</span>
00373 <span class="comment"></span>
00374 <span class="comment">    AllocateDestinationString - Supplies a flag that controls whether or</span>
00375 <span class="comment">        not this API allocates the buffer space for the destination</span>
00376 <span class="comment">        string.  If it does, then the buffer must be deallocated using</span>
00377 <span class="comment">        RtlFreeAnsiString (note that only storage for</span>
00378 <span class="comment">        DestinationString-&gt;Buffer is allocated by this API).</span>
00379 <span class="comment"></span>
00380 <span class="comment">Return Value:</span>
00381 <span class="comment"></span>
00382 <span class="comment">    SUCCESS - The conversion was successful</span>
00383 <span class="comment"></span>
00384 <span class="comment">    !SUCCESS - The operation failed.  No storage was allocated and no</span>
00385 <span class="comment">        conversion was done.  None.</span>
00386 <span class="comment"></span>
00387 <span class="comment">--*/</span>
00388 
00389 {
00390     ULONG AnsiLength;
00391     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00392     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> st;
00393 
00394     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00395 
00396     AnsiLength = RtlUnicodeStringToAnsiSize(<a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>);
00397     <span class="keywordflow">if</span> ( AnsiLength &gt; MAXUSHORT ) {
00398         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER_2;
00399         }
00400 
00401     DestinationString-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(AnsiLength - 1);
00402     <span class="keywordflow">if</span> ( AllocateDestinationString ) {
00403         DestinationString-&gt;MaximumLength = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)AnsiLength;
00404         DestinationString-&gt;Buffer = (<a class="code" href="../../d8/d2/ldrinit_8c.html#a7">RtlAllocateStringRoutine</a>)(AnsiLength);
00405         <span class="keywordflow">if</span> ( !DestinationString-&gt;Buffer ) {
00406             <span class="keywordflow">return</span> STATUS_NO_MEMORY;
00407             }
00408         }
00409     <span class="keywordflow">else</span> {
00410         <span class="keywordflow">if</span> ( DestinationString-&gt;Length &gt;= DestinationString-&gt;MaximumLength ) {
00411             <span class="keywordflow">return</span> STATUS_BUFFER_OVERFLOW;
00412             }
00413         }
00414 
00415     st = <a class="code" href="../../d9/d6/nlsxlat_8c.html#a38">RtlUpcaseUnicodeToMultiByteN</a>(
00416              DestinationString-&gt;Buffer,
00417              DestinationString-&gt;Length,
00418              &amp;<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>,
00419              <a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>-&gt;Buffer,
00420              <a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>-&gt;Length
00421              );
00422 
00423     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st)) {
00424         <span class="keywordflow">if</span> ( AllocateDestinationString ) {
00425             (<a class="code" href="../../d8/d2/ldrinit_8c.html#a8">RtlFreeStringRoutine</a>)(DestinationString-&gt;Buffer);
00426             DestinationString-&gt;Buffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00427         }
00428 
00429         <span class="keywordflow">return</span> st;
00430     }
00431 
00432     DestinationString-&gt;Buffer[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>] = <span class="charliteral">'\0'</span>;
00433 
00434     <span class="keywordflow">return</span> STATUS_SUCCESS;
00435 }
00436 
00437 
00438 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00439"></a><a class="code" href="../../d6/d6/nls_8c.html#a25">00439</a> <a class="code" href="../../d6/d6/nls_8c.html#a25">RtlOemStringToUnicodeString</a>(
00440     OUT PUNICODE_STRING DestinationString,
00441     IN POEM_STRING SourceString,
00442     IN BOOLEAN AllocateDestinationString
00443     )
00444 
00445 <span class="comment">/*++</span>
00446 <span class="comment"></span>
00447 <span class="comment">Routine Description:</span>
00448 <span class="comment"></span>
00449 <span class="comment">    This functions converts the specified oem source string into a</span>
00450 <span class="comment">    Unicode string. The translation is done with respect to the</span>
00451 <span class="comment">    installed OEM code page (OCP).</span>
00452 <span class="comment"></span>
00453 <span class="comment">Arguments:</span>
00454 <span class="comment"></span>
00455 <span class="comment">    DestinationString - Returns a unicode string that is equivalent to</span>
00456 <span class="comment">        the oem source string. The maximum length field is only</span>
00457 <span class="comment">        set if AllocateDestinationString is TRUE.</span>
00458 <span class="comment"></span>
00459 <span class="comment">    SourceString - Supplies the oem source string that is to be</span>
00460 <span class="comment">        converted to unicode.</span>
00461 <span class="comment"></span>
00462 <span class="comment">    AllocateDestinationString - Supplies a flag that controls whether or</span>
00463 <span class="comment">        not this API allocates the buffer space for the destination</span>
00464 <span class="comment">        string.  If it does, then the buffer must be deallocated using</span>
00465 <span class="comment">        RtlFreeUnicodeString (note that only storage for</span>
00466 <span class="comment">        DestinationString-&gt;Buffer is allocated by this API).</span>
00467 <span class="comment"></span>
00468 <span class="comment">Return Value:</span>
00469 <span class="comment"></span>
00470 <span class="comment">    SUCCESS - The conversion was successful</span>
00471 <span class="comment"></span>
00472 <span class="comment">    !SUCCESS - The operation failed.  No storage was allocated and no</span>
00473 <span class="comment">        conversion was done.  None.</span>
00474 <span class="comment"></span>
00475 <span class="comment">--*/</span>
00476 
00477 {
00478     ULONG UnicodeLength;
00479     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00480     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> st;
00481 
00482     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00483 
00484     UnicodeLength = RtlOemStringToUnicodeSize(<a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>);
00485     <span class="keywordflow">if</span> ( UnicodeLength &gt; MAXUSHORT ) {
00486         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER_2;
00487         }
00488 
00489     DestinationString-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(UnicodeLength - <span class="keyword">sizeof</span>(UNICODE_NULL));
00490     <span class="keywordflow">if</span> ( AllocateDestinationString ) {
00491         DestinationString-&gt;MaximumLength = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)UnicodeLength;
00492         DestinationString-&gt;Buffer = (<a class="code" href="../../d8/d2/ldrinit_8c.html#a7">RtlAllocateStringRoutine</a>)(UnicodeLength);
00493         <span class="keywordflow">if</span> ( !DestinationString-&gt;Buffer ) {
00494             <span class="keywordflow">return</span> STATUS_NO_MEMORY;
00495             }
00496         }
00497     <span class="keywordflow">else</span> {
00498         <span class="keywordflow">if</span> ( DestinationString-&gt;Length &gt;= DestinationString-&gt;MaximumLength ) {
00499             <span class="keywordflow">return</span> STATUS_BUFFER_OVERFLOW;
00500             }
00501         }
00502 
00503     st = <a class="code" href="../../d9/d6/nlsxlat_8c.html#a34">RtlOemToUnicodeN</a>(
00504              DestinationString-&gt;Buffer,
00505              DestinationString-&gt;Length,
00506              &amp;<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>,
00507              <a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>-&gt;Buffer,
00508              <a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>-&gt;Length
00509              );
00510 
00511     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st)) {
00512         <span class="keywordflow">if</span> ( AllocateDestinationString ) {
00513             (<a class="code" href="../../d8/d2/ldrinit_8c.html#a8">RtlFreeStringRoutine</a>)(DestinationString-&gt;Buffer);
00514             DestinationString-&gt;Buffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00515         }
00516 
00517         <span class="keywordflow">return</span> st;
00518     }
00519 
00520     DestinationString-&gt;Buffer[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> / <span class="keyword">sizeof</span>(WCHAR)] = UNICODE_NULL;
00521 
00522     <span class="keywordflow">return</span> STATUS_SUCCESS;
00523 
00524 }
00525 
00526 
00527 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00528"></a><a class="code" href="../../d6/d6/nls_8c.html#a26">00528</a> <a class="code" href="../../d6/d6/nls_8c.html#a26">RtlUnicodeStringToOemString</a>(
00529     OUT POEM_STRING DestinationString,
00530     IN PUNICODE_STRING SourceString,
00531     IN BOOLEAN AllocateDestinationString
00532     )
00533 
00534 <span class="comment">/*++</span>
00535 <span class="comment"></span>
00536 <span class="comment">Routine Description:</span>
00537 <span class="comment"></span>
00538 <span class="comment">    This functions converts the specified unicode source string into an</span>
00539 <span class="comment">    oem string. The translation is done with respect to the OEM code</span>
00540 <span class="comment">    page (OCP).</span>
00541 <span class="comment"></span>
00542 <span class="comment">Arguments:</span>
00543 <span class="comment"></span>
00544 <span class="comment">    DestinationString - Returns an oem string that is equivalent to the</span>
00545 <span class="comment">        unicode source string.  If the translation can not be done,</span>
00546 <span class="comment">        an error is returned.  The maximum length field is only set if</span>
00547 <span class="comment">        AllocateDestinationString is TRUE.</span>
00548 <span class="comment"></span>
00549 <span class="comment">    SourceString - Supplies the unicode source string that is to be</span>
00550 <span class="comment">        converted to oem.</span>
00551 <span class="comment"></span>
00552 <span class="comment">    AllocateDestinationString - Supplies a flag that controls whether or</span>
00553 <span class="comment">        not this API allocates the buffer space for the destination</span>
00554 <span class="comment">        string.  If it does, then the buffer must be deallocated using</span>
00555 <span class="comment">        RtlFreeAnsiString (note that only storage for</span>
00556 <span class="comment">        DestinationString-&gt;Buffer is allocated by this API).</span>
00557 <span class="comment"></span>
00558 <span class="comment">Return Value:</span>
00559 <span class="comment"></span>
00560 <span class="comment">    SUCCESS - The conversion was successful</span>
00561 <span class="comment"></span>
00562 <span class="comment">    !SUCCESS - The operation failed.  No storage was allocated and no</span>
00563 <span class="comment">        conversion was done.  None.</span>
00564 <span class="comment"></span>
00565 <span class="comment">--*/</span>
00566 
00567 {
00568     ULONG OemLength;
00569     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00570     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> st;
00571 
00572     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00573 
00574     OemLength = RtlUnicodeStringToOemSize(<a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>);
00575     <span class="keywordflow">if</span> ( OemLength &gt; MAXUSHORT ) {
00576         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER_2;
00577         }
00578 
00579     DestinationString-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(OemLength - 1);
00580     <span class="keywordflow">if</span> ( AllocateDestinationString ) {
00581         DestinationString-&gt;MaximumLength = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)OemLength;
00582         DestinationString-&gt;Buffer = (<a class="code" href="../../d8/d2/ldrinit_8c.html#a7">RtlAllocateStringRoutine</a>)(OemLength);
00583         <span class="keywordflow">if</span> ( !DestinationString-&gt;Buffer ) {
00584             <span class="keywordflow">return</span> STATUS_NO_MEMORY;
00585             }
00586         }
00587     <span class="keywordflow">else</span> {
00588         <span class="keywordflow">if</span> ( DestinationString-&gt;Length &gt;= DestinationString-&gt;MaximumLength ) {
00589             <span class="keywordflow">return</span> STATUS_BUFFER_OVERFLOW;
00590             }
00591         }
00592 
00593     st = <a class="code" href="../../d9/d6/nlsxlat_8c.html#a39">RtlUnicodeToOemN</a>(
00594              DestinationString-&gt;Buffer,
00595              DestinationString-&gt;Length,
00596              &amp;<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>,
00597              <a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>-&gt;Buffer,
00598              <a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>-&gt;Length
00599              );
00600 
00601     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st)) {
00602         <span class="keywordflow">if</span> ( AllocateDestinationString ) {
00603             (<a class="code" href="../../d8/d2/ldrinit_8c.html#a8">RtlFreeStringRoutine</a>)(DestinationString-&gt;Buffer);
00604             DestinationString-&gt;Buffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00605         }
00606 
00607         <span class="keywordflow">return</span> st;
00608     }
00609 
00610     DestinationString-&gt;Buffer[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>] = <span class="charliteral">'\0'</span>;
00611 
00612     <span class="keywordflow">return</span> STATUS_SUCCESS;
00613 }
00614 
00615 
00616 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00617"></a><a class="code" href="../../d6/d6/nls_8c.html#a27">00617</a> <a class="code" href="../../d6/d6/nls_8c.html#a27">RtlUpcaseUnicodeStringToOemString</a>(
00618     OUT POEM_STRING DestinationString,
00619     IN PUNICODE_STRING SourceString,
00620     IN BOOLEAN AllocateDestinationString
00621     )
00622 
00623 <span class="comment">/*++</span>
00624 <span class="comment"></span>
00625 <span class="comment">Routine Description:</span>
00626 <span class="comment"></span>
00627 <span class="comment">    This function upper cases the specified unicode source string and then</span>
00628 <span class="comment">    converts it into an oem string. The translation is done with respect</span>
00629 <span class="comment">    to the OEM code page (OCP).</span>
00630 <span class="comment"></span>
00631 <span class="comment">Arguments:</span>
00632 <span class="comment"></span>
00633 <span class="comment">    DestinationString - Returns an oem string that is equivalent to the</span>
00634 <span class="comment">        unicode source string.  The maximum length field is only set if</span>
00635 <span class="comment">        AllocateDestinationString is TRUE.</span>
00636 <span class="comment"></span>
00637 <span class="comment">    SourceString - Supplies the unicode source string that is to be</span>
00638 <span class="comment">        converted to oem.</span>
00639 <span class="comment"></span>
00640 <span class="comment">    AllocateDestinationString - Supplies a flag that controls whether or</span>
00641 <span class="comment">        not this API allocates the buffer space for the destination</span>
00642 <span class="comment">        string.  If it does, then the buffer must be deallocated using</span>
00643 <span class="comment">        RtlFreeAnsiString (note that only storage for</span>
00644 <span class="comment">        DestinationString-&gt;Buffer is allocated by this API).</span>
00645 <span class="comment"></span>
00646 <span class="comment">Return Value:</span>
00647 <span class="comment"></span>
00648 <span class="comment">    SUCCESS - The conversion was successful</span>
00649 <span class="comment"></span>
00650 <span class="comment">    !SUCCESS - The operation failed.  No storage was allocated and no</span>
00651 <span class="comment">        conversion was done.  None.</span>
00652 <span class="comment"></span>
00653 <span class="comment">--*/</span>
00654 
00655 {
00656     ULONG OemLength;
00657     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00658     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> st;
00659 
00660     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00661 
00662     OemLength = RtlUnicodeStringToOemSize(<a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>);
00663     <span class="keywordflow">if</span> ( OemLength &gt; MAXUSHORT ) {
00664         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER_2;
00665         }
00666 
00667     DestinationString-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(OemLength - 1);
00668     <span class="keywordflow">if</span> ( AllocateDestinationString ) {
00669         DestinationString-&gt;MaximumLength = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)OemLength;
00670         DestinationString-&gt;Buffer = (<a class="code" href="../../d8/d2/ldrinit_8c.html#a7">RtlAllocateStringRoutine</a>)(OemLength);
00671         <span class="keywordflow">if</span> ( !DestinationString-&gt;Buffer ) {
00672             <span class="keywordflow">return</span> STATUS_NO_MEMORY;
00673             }
00674         }
00675     <span class="keywordflow">else</span> {
00676         <span class="keywordflow">if</span> ( DestinationString-&gt;Length &gt;= DestinationString-&gt;MaximumLength ) {
00677             <span class="keywordflow">return</span> STATUS_BUFFER_OVERFLOW;
00678             }
00679         }
00680 
00681     st = <a class="code" href="../../d9/d6/nlsxlat_8c.html#a40">RtlUpcaseUnicodeToOemN</a>(
00682              DestinationString-&gt;Buffer,
00683              DestinationString-&gt;Length,
00684              &amp;<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>,
00685              <a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>-&gt;Buffer,
00686              <a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>-&gt;Length
00687              );
00688 
00689     <span class="comment">//</span>
00690     <span class="comment">//  Now do a check here to see if there was really a mapping for all</span>
00691     <span class="comment">//  characters converted.</span>
00692     <span class="comment">//</span>
00693 
00694     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st) &amp;&amp;
00695         !<a class="code" href="../../d5/d9/ntrtlp_8h.html#a37">RtlpDidUnicodeToOemWork</a>( DestinationString, <a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a> )) {
00696 
00697         st = STATUS_UNMAPPABLE_CHARACTER;
00698     }
00699 
00700     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st)) {
00701         <span class="keywordflow">if</span> ( AllocateDestinationString ) {
00702             (<a class="code" href="../../d8/d2/ldrinit_8c.html#a8">RtlFreeStringRoutine</a>)(DestinationString-&gt;Buffer);
00703             DestinationString-&gt;Buffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00704         }
00705 
00706         <span class="keywordflow">return</span> st;
00707     }
00708 
00709     DestinationString-&gt;Buffer[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>] = <span class="charliteral">'\0'</span>;
00710 
00711     <span class="keywordflow">return</span> STATUS_SUCCESS;
00712 }
00713 
00714 
00715 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00716"></a><a class="code" href="../../d6/d6/nls_8c.html#a28">00716</a> <a class="code" href="../../d6/d6/nls_8c.html#a28">RtlOemStringToCountedUnicodeString</a>(
00717     OUT PUNICODE_STRING DestinationString,
00718     IN POEM_STRING SourceString,
00719     IN BOOLEAN AllocateDestinationString
00720     )
00721 
00722 <span class="comment">/*++</span>
00723 <span class="comment"></span>
00724 <span class="comment">Routine Description:</span>
00725 <span class="comment"></span>
00726 <span class="comment">    This functions converts the specified oem source string into a</span>
00727 <span class="comment">    Unicode string. The translation is done with respect to the</span>
00728 <span class="comment">    installed OEM code page (OCP).</span>
00729 <span class="comment"></span>
00730 <span class="comment">    The destination string is NOT unnaturally null terminated.  It is a</span>
00731 <span class="comment">    counted string as counted strings are meant to be.</span>
00732 <span class="comment"></span>
00733 <span class="comment">Arguments:</span>
00734 <span class="comment"></span>
00735 <span class="comment">    DestinationString - Returns a unicode string that is equivalent to</span>
00736 <span class="comment">        the oem source string. The maximum length field is only</span>
00737 <span class="comment">        set if AllocateDestinationString is TRUE.</span>
00738 <span class="comment"></span>
00739 <span class="comment">    SourceString - Supplies the oem source string that is to be</span>
00740 <span class="comment">        converted to unicode.</span>
00741 <span class="comment"></span>
00742 <span class="comment">    AllocateDestinationString - Supplies a flag that controls whether or</span>
00743 <span class="comment">        not this API allocates the buffer space for the destination</span>
00744 <span class="comment">        string.  If it does, then the buffer must be deallocated using</span>
00745 <span class="comment">        RtlFreeUnicodeString (note that only storage for</span>
00746 <span class="comment">        DestinationString-&gt;Buffer is allocated by this API).</span>
00747 <span class="comment"></span>
00748 <span class="comment">Return Value:</span>
00749 <span class="comment"></span>
00750 <span class="comment">    SUCCESS - The conversion was successful</span>
00751 <span class="comment"></span>
00752 <span class="comment">    !SUCCESS - The operation failed.  No storage was allocated and no</span>
00753 <span class="comment">        conversion was done.  None.</span>
00754 <span class="comment"></span>
00755 <span class="comment">--*/</span>
00756 
00757 {
00758     ULONG UnicodeLength;
00759     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00760     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> st;
00761 
00762     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00763 
00764     UnicodeLength = RtlOemStringToCountedUnicodeSize(<a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>);
00765 
00766     <span class="keywordflow">if</span> ( UnicodeLength == 0 ) {
00767 
00768         DestinationString-&gt;Length = 0;
00769         DestinationString-&gt;MaximumLength = 0;
00770         DestinationString-&gt;Buffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00771 
00772         <span class="keywordflow">return</span> STATUS_SUCCESS;
00773     }
00774 
00775     <span class="keywordflow">if</span> ( UnicodeLength &gt; MAXUSHORT ) {
00776         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER_2;
00777         }
00778 
00779     DestinationString-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(UnicodeLength);
00780     <span class="keywordflow">if</span> ( AllocateDestinationString ) {
00781         DestinationString-&gt;MaximumLength = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)UnicodeLength;
00782         DestinationString-&gt;Buffer = (<a class="code" href="../../d8/d2/ldrinit_8c.html#a7">RtlAllocateStringRoutine</a>)(UnicodeLength);
00783         <span class="keywordflow">if</span> ( !DestinationString-&gt;Buffer ) {
00784             <span class="keywordflow">return</span> STATUS_NO_MEMORY;
00785             }
00786         }
00787     <span class="keywordflow">else</span> {
00788         <span class="keywordflow">if</span> ( DestinationString-&gt;Length &gt; DestinationString-&gt;MaximumLength ) {
00789             <span class="keywordflow">return</span> STATUS_BUFFER_OVERFLOW;
00790             }
00791         }
00792 
00793     st = <a class="code" href="../../d9/d6/nlsxlat_8c.html#a34">RtlOemToUnicodeN</a>(
00794              DestinationString-&gt;Buffer,
00795              DestinationString-&gt;Length,
00796              &amp;<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>,
00797              <a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>-&gt;Buffer,
00798              <a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>-&gt;Length
00799              );
00800 
00801     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st)) {
00802         <span class="keywordflow">if</span> ( AllocateDestinationString ) {
00803             (<a class="code" href="../../d8/d2/ldrinit_8c.html#a8">RtlFreeStringRoutine</a>)(DestinationString-&gt;Buffer);
00804             DestinationString-&gt;Buffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00805         }
00806 
00807         <span class="keywordflow">return</span> st;
00808     }
00809 
00810     <span class="keywordflow">return</span> STATUS_SUCCESS;
00811 
00812 }
00813 
00814 
00815 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00816"></a><a class="code" href="../../d6/d6/nls_8c.html#a29">00816</a> <a class="code" href="../../d6/d6/nls_8c.html#a29">RtlUnicodeStringToCountedOemString</a>(
00817     OUT POEM_STRING DestinationString,
00818     IN PUNICODE_STRING SourceString,
00819     IN BOOLEAN AllocateDestinationString
00820     )
00821 
00822 <span class="comment">/*++</span>
00823 <span class="comment"></span>
00824 <span class="comment">Routine Description:</span>
00825 <span class="comment"></span>
00826 <span class="comment">    This functions converts the specified unicode source string into an</span>
00827 <span class="comment">    oem string. The translation is done with respect to the OEM code</span>
00828 <span class="comment">    page (OCP).</span>
00829 <span class="comment"></span>
00830 <span class="comment">    The destination string is NOT unnaturally null terminated.  It is a</span>
00831 <span class="comment">    counted string as counted strings are meant to be.</span>
00832 <span class="comment"></span>
00833 <span class="comment">Arguments:</span>
00834 <span class="comment"></span>
00835 <span class="comment">    DestinationString - Returns an oem string that is equivalent to the</span>
00836 <span class="comment">        unicode source string.  If the translation can not be done,</span>
00837 <span class="comment">        an error is returned.  The maximum length field is only set if</span>
00838 <span class="comment">        AllocateDestinationString is TRUE.</span>
00839 <span class="comment"></span>
00840 <span class="comment">    SourceString - Supplies the unicode source string that is to be</span>
00841 <span class="comment">        converted to oem.</span>
00842 <span class="comment"></span>
00843 <span class="comment">    AllocateDestinationString - Supplies a flag that controls whether or</span>
00844 <span class="comment">        not this API allocates the buffer space for the destination</span>
00845 <span class="comment">        string.  If it does, then the buffer must be deallocated using</span>
00846 <span class="comment">        RtlFreeAnsiString (note that only storage for</span>
00847 <span class="comment">        DestinationString-&gt;Buffer is allocated by this API).</span>
00848 <span class="comment"></span>
00849 <span class="comment">Return Value:</span>
00850 <span class="comment"></span>
00851 <span class="comment">    SUCCESS - The conversion was successful</span>
00852 <span class="comment"></span>
00853 <span class="comment">    !SUCCESS - The operation failed.  No storage was allocated and no</span>
00854 <span class="comment">        conversion was done.  None.</span>
00855 <span class="comment"></span>
00856 <span class="comment">--*/</span>
00857 
00858 {
00859     ULONG OemLength;
00860     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00861     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> st;
00862 
00863     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00864 
00865     OemLength = RtlUnicodeStringToCountedOemSize(<a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>);
00866 
00867     <span class="keywordflow">if</span> ( OemLength == 0 ) {
00868 
00869         DestinationString-&gt;Length = 0;
00870         DestinationString-&gt;MaximumLength = 0;
00871         DestinationString-&gt;Buffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00872 
00873         <span class="keywordflow">return</span> STATUS_SUCCESS;
00874     }
00875 
00876     <span class="keywordflow">if</span> ( OemLength &gt; MAXUSHORT ) {
00877         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER_2;
00878         }
00879 
00880     DestinationString-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(OemLength);
00881     <span class="keywordflow">if</span> ( AllocateDestinationString ) {
00882         DestinationString-&gt;MaximumLength = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)OemLength;
00883         DestinationString-&gt;Buffer = (<a class="code" href="../../d8/d2/ldrinit_8c.html#a7">RtlAllocateStringRoutine</a>)(OemLength);
00884         <span class="keywordflow">if</span> ( !DestinationString-&gt;Buffer ) {
00885             <span class="keywordflow">return</span> STATUS_NO_MEMORY;
00886             }
00887         }
00888     <span class="keywordflow">else</span> {
00889         <span class="keywordflow">if</span> ( DestinationString-&gt;Length &gt; DestinationString-&gt;MaximumLength ) {
00890             <span class="keywordflow">return</span> STATUS_BUFFER_OVERFLOW;
00891             }
00892         }
00893 
00894     st = <a class="code" href="../../d9/d6/nlsxlat_8c.html#a39">RtlUnicodeToOemN</a>(
00895              DestinationString-&gt;Buffer,
00896              DestinationString-&gt;Length,
00897              &amp;<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>,
00898              <a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>-&gt;Buffer,
00899              <a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>-&gt;Length
00900              );
00901 
00902     <span class="comment">//</span>
00903     <span class="comment">//  Now do a check here to see if there was really a mapping for all</span>
00904     <span class="comment">//  characters converted.</span>
00905     <span class="comment">//</span>
00906 
00907     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st) &amp;&amp;
00908         !<a class="code" href="../../d5/d9/ntrtlp_8h.html#a37">RtlpDidUnicodeToOemWork</a>( DestinationString, <a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a> )) {
00909 
00910         st = STATUS_UNMAPPABLE_CHARACTER;
00911     }
00912 
00913     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st)) {
00914         <span class="keywordflow">if</span> ( AllocateDestinationString ) {
00915             (<a class="code" href="../../d8/d2/ldrinit_8c.html#a8">RtlFreeStringRoutine</a>)(DestinationString-&gt;Buffer);
00916             DestinationString-&gt;Buffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00917         }
00918 
00919         <span class="keywordflow">return</span> st;
00920     }
00921 
00922     <span class="keywordflow">return</span> STATUS_SUCCESS;
00923 }
00924 
00925 
00926 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00927"></a><a class="code" href="../../d6/d6/nls_8c.html#a30">00927</a> <a class="code" href="../../d6/d6/nls_8c.html#a30">RtlUpcaseUnicodeStringToCountedOemString</a>(
00928     OUT POEM_STRING DestinationString,
00929     IN PUNICODE_STRING SourceString,
00930     IN BOOLEAN AllocateDestinationString
00931     )
00932 
00933 <span class="comment">/*++</span>
00934 <span class="comment"></span>
00935 <span class="comment">Routine Description:</span>
00936 <span class="comment"></span>
00937 <span class="comment">    This functions upper cases the specified unicode source string and</span>
00938 <span class="comment">    then converts it into an oem string. The translation is done with</span>
00939 <span class="comment">    respect to the OEM code page (OCP).</span>
00940 <span class="comment"></span>
00941 <span class="comment">    The destination string is NOT unnaturally null terminated.  It is a</span>
00942 <span class="comment">    counted string as counted strings are meant to be.</span>
00943 <span class="comment"></span>
00944 <span class="comment">Arguments:</span>
00945 <span class="comment"></span>
00946 <span class="comment">    DestinationString - Returns an oem string that is equivalent to the</span>
00947 <span class="comment">        unicode source string.  If the translation can not be done,</span>
00948 <span class="comment">        an error is returned.  The maximum length field is only set</span>
00949 <span class="comment">        if AllocateDestinationString is TRUE.</span>
00950 <span class="comment"></span>
00951 <span class="comment">    SourceString - Supplies the unicode source string that is to be</span>
00952 <span class="comment">        converted to oem.</span>
00953 <span class="comment"></span>
00954 <span class="comment">    AllocateDestinationString - Supplies a flag that controls whether or</span>
00955 <span class="comment">        not this API allocates the buffer space for the destination</span>
00956 <span class="comment">        string.  If it does, then the buffer must be deallocated using</span>
00957 <span class="comment">        RtlFreeAnsiString (note that only storage for</span>
00958 <span class="comment">        DestinationString-&gt;Buffer is allocated by this API).</span>
00959 <span class="comment"></span>
00960 <span class="comment">Return Value:</span>
00961 <span class="comment"></span>
00962 <span class="comment">    SUCCESS - The conversion was successful</span>
00963 <span class="comment"></span>
00964 <span class="comment">    !SUCCESS - The operation failed.  No storage was allocated and no</span>
00965 <span class="comment">        conversion was done.  None.</span>
00966 <span class="comment"></span>
00967 <span class="comment">--*/</span>
00968 
00969 {
00970     ULONG OemLength;
00971     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00972     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> st;
00973 
00974     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00975 
00976     OemLength = RtlUnicodeStringToCountedOemSize(<a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>);
00977 
00978     <span class="keywordflow">if</span> ( OemLength == 0 ) {
00979 
00980         DestinationString-&gt;Length = 0;
00981         DestinationString-&gt;MaximumLength = 0;
00982         DestinationString-&gt;Buffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00983 
00984         <span class="keywordflow">return</span> STATUS_SUCCESS;
00985     }
00986 
00987     <span class="keywordflow">if</span> ( OemLength &gt; MAXUSHORT ) {
00988         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER_2;
00989         }
00990 
00991     DestinationString-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(OemLength);
00992     <span class="keywordflow">if</span> ( AllocateDestinationString ) {
00993         DestinationString-&gt;MaximumLength = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)OemLength;
00994         DestinationString-&gt;Buffer = (<a class="code" href="../../d8/d2/ldrinit_8c.html#a7">RtlAllocateStringRoutine</a>)(OemLength);
00995         <span class="keywordflow">if</span> ( !DestinationString-&gt;Buffer ) {
00996             <span class="keywordflow">return</span> STATUS_NO_MEMORY;
00997             }
00998         }
00999     <span class="keywordflow">else</span> {
01000         <span class="keywordflow">if</span> ( DestinationString-&gt;Length &gt; DestinationString-&gt;MaximumLength ) {
01001             <span class="keywordflow">return</span> STATUS_BUFFER_OVERFLOW;
01002             }
01003         }
01004 
01005     st = <a class="code" href="../../d9/d6/nlsxlat_8c.html#a40">RtlUpcaseUnicodeToOemN</a>(
01006              DestinationString-&gt;Buffer,
01007              DestinationString-&gt;Length,
01008              &amp;<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>,
01009              <a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>-&gt;Buffer,
01010              <a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>-&gt;Length
01011              );
01012 
01013     <span class="comment">//</span>
01014     <span class="comment">//  Now do a check here to see if there was really a mapping for all</span>
01015     <span class="comment">//  characters converted.</span>
01016     <span class="comment">//</span>
01017 
01018     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st) &amp;&amp;
01019         !<a class="code" href="../../d5/d9/ntrtlp_8h.html#a37">RtlpDidUnicodeToOemWork</a>( DestinationString, <a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a> )) {
01020 
01021         st = STATUS_UNMAPPABLE_CHARACTER;
01022     }
01023 
01024     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(st)) {
01025         <span class="keywordflow">if</span> ( AllocateDestinationString ) {
01026             (<a class="code" href="../../d8/d2/ldrinit_8c.html#a8">RtlFreeStringRoutine</a>)(DestinationString-&gt;Buffer);
01027             DestinationString-&gt;Buffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01028         }
01029 
01030         <span class="keywordflow">return</span> st;
01031     }
01032 
01033     <span class="keywordflow">return</span> STATUS_SUCCESS;
01034 }
01035 
01036 
01037 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01038"></a><a class="code" href="../../d6/d6/nls_8c.html#a31">01038</a> <a class="code" href="../../d6/d6/nls_8c.html#a31">RtlUpcaseUnicodeString</a>(
01039     OUT PUNICODE_STRING DestinationString,
01040     IN PCUNICODE_STRING SourceString,
01041     IN BOOLEAN AllocateDestinationString
01042     )
01043 
01044 <span class="comment">/*++</span>
01045 <span class="comment"></span>
01046 <span class="comment">Routine Description:</span>
01047 <span class="comment"></span>
01048 <span class="comment">    This functions converts the specified unicode source string into an</span>
01049 <span class="comment">    upcased unicode string. The translation is done with respect to the</span>
01050 <span class="comment">    current system locale information.</span>
01051 <span class="comment"></span>
01052 <span class="comment">Arguments:</span>
01053 <span class="comment"></span>
01054 <span class="comment">    DestinationString - Returns a unicode string that is the upcased equivalent</span>
01055 <span class="comment">        to the unicode source string.  The maximum length field is only set if</span>
01056 <span class="comment">        AllocateDestinationString is TRUE.</span>
01057 <span class="comment"></span>
01058 <span class="comment">    SourceString - Supplies the unicode source string that is to being</span>
01059 <span class="comment">        upcased.</span>
01060 <span class="comment"></span>
01061 <span class="comment">    AllocateDestinationString - Supplies a flag that controls whether or</span>
01062 <span class="comment">        not this API allocates the buffer space for the destination</span>
01063 <span class="comment">        string.  If it does, then the buffer must be deallocated using</span>
01064 <span class="comment">        RtlFreeUnicodeString (note that only storage for</span>
01065 <span class="comment">        DestinationString-&gt;Buffer is allocated by this API).</span>
01066 <span class="comment"></span>
01067 <span class="comment">Return Value:</span>
01068 <span class="comment"></span>
01069 <span class="comment">    SUCCESS - The conversion was successful</span>
01070 <span class="comment"></span>
01071 <span class="comment">    !SUCCESS - The operation failed.  No storage was allocated and no</span>
01072 <span class="comment">        conversion was done.  None.</span>
01073 <span class="comment"></span>
01074 <span class="comment">--*/</span>
01075 
01076 {
01077     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
01078     ULONG StopIndex;
01079 
01080     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01081 
01082     <span class="keywordflow">if</span> ( AllocateDestinationString ) {
01083         DestinationString-&gt;MaximumLength = <a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>-&gt;Length;
01084         DestinationString-&gt;Buffer = (<a class="code" href="../../d8/d2/ldrinit_8c.html#a7">RtlAllocateStringRoutine</a>)((ULONG)DestinationString-&gt;MaximumLength);
01085         <span class="keywordflow">if</span> ( !DestinationString-&gt;Buffer ) {
01086             <span class="keywordflow">return</span> STATUS_NO_MEMORY;
01087             }
01088         }
01089     <span class="keywordflow">else</span> {
01090         <span class="keywordflow">if</span> ( <a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>-&gt;Length &gt; DestinationString-&gt;MaximumLength ) {
01091             <span class="keywordflow">return</span> STATUS_BUFFER_OVERFLOW;
01092             }
01093         }
01094 
01095     StopIndex = ((ULONG)<a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>-&gt;Length) / <span class="keyword">sizeof</span>( WCHAR );
01096 
01097     <span class="keywordflow">for</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; StopIndex; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>++) {
01098         DestinationString-&gt;Buffer[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>] = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(<a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>-&gt;Buffer[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>]);
01099     }
01100 
01101     DestinationString-&gt;Length = <a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>-&gt;Length;
01102 
01103     <span class="keywordflow">return</span> STATUS_SUCCESS;
01104 }
01105 
01106 
01107 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01108"></a><a class="code" href="../../d6/d6/nls_8c.html#a32">01108</a> <a class="code" href="../../d6/d6/nls_8c.html#a32">RtlDowncaseUnicodeString</a>(
01109     OUT PUNICODE_STRING DestinationString,
01110     IN PUNICODE_STRING SourceString,
01111     IN BOOLEAN AllocateDestinationString
01112     )
01113 
01114 <span class="comment">/*++</span>
01115 <span class="comment"></span>
01116 <span class="comment">Routine Description:</span>
01117 <span class="comment"></span>
01118 <span class="comment">    This functions converts the specified unicode source string into a</span>
01119 <span class="comment">    downcased unicode string. The translation is done with respect to the</span>
01120 <span class="comment">    current system locale information.</span>
01121 <span class="comment"></span>
01122 <span class="comment">Arguments:</span>
01123 <span class="comment"></span>
01124 <span class="comment">    DestinationString - Returns a unicode string that is the downcased</span>
01125 <span class="comment">        equivalent to the unicode source string.  The maximum length field</span>
01126 <span class="comment">        is only set if AllocateDestinationString is TRUE.</span>
01127 <span class="comment"></span>
01128 <span class="comment">    SourceString - Supplies the unicode source string that is to being</span>
01129 <span class="comment">        downcased.</span>
01130 <span class="comment"></span>
01131 <span class="comment">    AllocateDestinationString - Supplies a flag that controls whether or</span>
01132 <span class="comment">        not this API allocates the buffer space for the destination</span>
01133 <span class="comment">        string.  If it does, then the buffer must be deallocated using</span>
01134 <span class="comment">        RtlFreeUnicodeString (note that only storage for</span>
01135 <span class="comment">        DestinationString-&gt;Buffer is allocated by this API).</span>
01136 <span class="comment"></span>
01137 <span class="comment">Return Value:</span>
01138 <span class="comment"></span>
01139 <span class="comment">    SUCCESS - The conversion was successful</span>
01140 <span class="comment"></span>
01141 <span class="comment">    !SUCCESS - The operation failed.  No storage was allocated and no</span>
01142 <span class="comment">        conversion was done.  None.</span>
01143 <span class="comment"></span>
01144 <span class="comment">--*/</span>
01145 
01146 {
01147     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
01148     ULONG StopIndex;
01149 
01150     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01151 
01152     <span class="keywordflow">if</span> ( AllocateDestinationString ) {
01153         DestinationString-&gt;MaximumLength = <a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>-&gt;Length;
01154         DestinationString-&gt;Buffer = (<a class="code" href="../../d8/d2/ldrinit_8c.html#a7">RtlAllocateStringRoutine</a>)((ULONG)DestinationString-&gt;MaximumLength);
01155         <span class="keywordflow">if</span> ( !DestinationString-&gt;Buffer ) {
01156             <span class="keywordflow">return</span> STATUS_NO_MEMORY;
01157             }
01158         }
01159     <span class="keywordflow">else</span> {
01160         <span class="keywordflow">if</span> ( <a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>-&gt;Length &gt; DestinationString-&gt;MaximumLength ) {
01161             <span class="keywordflow">return</span> STATUS_BUFFER_OVERFLOW;
01162             }
01163         }
01164 
01165     StopIndex = ((ULONG)<a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>-&gt;Length) / <span class="keyword">sizeof</span>( WCHAR );
01166 
01167     <span class="keywordflow">for</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; StopIndex; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>++) {
01168         DestinationString-&gt;Buffer[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>] = (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a11">NLS_DOWNCASE</a>(<a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>-&gt;Buffer[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>]);
01169     }
01170 
01171     DestinationString-&gt;Length = <a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>-&gt;Length;
01172 
01173     <span class="keywordflow">return</span> STATUS_SUCCESS;
01174 }
01175 
01176 
01177 WCHAR
<a name="l01178"></a><a class="code" href="../../d6/d6/nls_8c.html#a33">01178</a> <a class="code" href="../../d6/d6/nls_8c.html#a33">RtlUpcaseUnicodeChar</a>(
01179     IN WCHAR SourceCharacter
01180     )
01181 
01182 <span class="comment">/*++</span>
01183 <span class="comment"></span>
01184 <span class="comment">Routine Description:</span>
01185 <span class="comment"></span>
01186 <span class="comment">    This function translates the specified unicode character to its</span>
01187 <span class="comment">    equivalent upcased unicode chararacter.  The purpose for this routine</span>
01188 <span class="comment">    is to allow for character by character upcase translation.  The</span>
01189 <span class="comment">    translation is done with respect to the current system locale</span>
01190 <span class="comment">    information.</span>
01191 <span class="comment"></span>
01192 <span class="comment"></span>
01193 <span class="comment">Arguments:</span>
01194 <span class="comment"></span>
01195 <span class="comment">    SourceCharacter - Supplies the unicode character to be upcased.</span>
01196 <span class="comment"></span>
01197 <span class="comment">Return Value:</span>
01198 <span class="comment"></span>
01199 <span class="comment">    Returns the upcased unicode equivalent of the specified input character.</span>
01200 <span class="comment"></span>
01201 <span class="comment">--*/</span>
01202 
01203 {
01204     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01205 
01206     <span class="comment">//</span>
01207     <span class="comment">// Note that this needs to reference the translation table !</span>
01208     <span class="comment">//</span>
01209 
01210     <span class="keywordflow">return</span> (WCHAR)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(SourceCharacter);
01211 }
01212 
01213 
01214 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01215"></a><a class="code" href="../../d6/d6/nls_8c.html#a34">01215</a> <a class="code" href="../../d6/d6/nls_8c.html#a34">RtlFreeUnicodeString</a>(
01216     IN OUT PUNICODE_STRING UnicodeString
01217     )
01218 
01219 <span class="comment">/*++</span>
01220 <span class="comment"></span>
01221 <span class="comment">Routine Description:</span>
01222 <span class="comment"></span>
01223 <span class="comment">    This API is used to free storage allocated by</span>
01224 <span class="comment">    RtlAnsiStringToUnicodeString.  Note that only UnicodeString-&gt;Buffer</span>
01225 <span class="comment">    is free'd by this routine.</span>
01226 <span class="comment"></span>
01227 <span class="comment">Arguments:</span>
01228 <span class="comment"></span>
01229 <span class="comment">    UnicodeString - Supplies the address of the unicode string whose</span>
01230 <span class="comment">        buffer was previously allocated by RtlAnsiStringToUnicodeString.</span>
01231 <span class="comment"></span>
01232 <span class="comment">Return Value:</span>
01233 <span class="comment"></span>
01234 <span class="comment">    None.</span>
01235 <span class="comment"></span>
01236 <span class="comment">--*/</span>
01237 
01238 {
01239     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01240 
01241     <span class="keywordflow">if</span> (UnicodeString-&gt;Buffer) {
01242         (<a class="code" href="../../d8/d2/ldrinit_8c.html#a8">RtlFreeStringRoutine</a>)(UnicodeString-&gt;Buffer);
01243         memset( UnicodeString, 0, <span class="keyword">sizeof</span>( *UnicodeString ) );
01244         }
01245 }
01246 
01247 
01248 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01249"></a><a class="code" href="../../d6/d6/nls_8c.html#a35">01249</a> <a class="code" href="../../d6/d6/nls_8c.html#a35">RtlFreeAnsiString</a>(
01250     IN OUT PANSI_STRING AnsiString
01251     )
01252 
01253 <span class="comment">/*++</span>
01254 <span class="comment"></span>
01255 <span class="comment">Routine Description:</span>
01256 <span class="comment"></span>
01257 <span class="comment">    This API is used to free storage allocated by</span>
01258 <span class="comment">    RtlUnicodeStringToAnsiString.  Note that only AnsiString-&gt;Buffer</span>
01259 <span class="comment">    is free'd by this routine.</span>
01260 <span class="comment"></span>
01261 <span class="comment">Arguments:</span>
01262 <span class="comment"></span>
01263 <span class="comment">    AnsiString - Supplies the address of the ansi string whose buffer</span>
01264 <span class="comment">        was previously allocated by RtlUnicodeStringToAnsiString.</span>
01265 <span class="comment"></span>
01266 <span class="comment">Return Value:</span>
01267 <span class="comment"></span>
01268 <span class="comment">    None.</span>
01269 <span class="comment"></span>
01270 <span class="comment">--*/</span>
01271 
01272 {
01273     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01274 
01275     <span class="keywordflow">if</span> (AnsiString-&gt;Buffer) {
01276         (<a class="code" href="../../d8/d2/ldrinit_8c.html#a8">RtlFreeStringRoutine</a>)(AnsiString-&gt;Buffer);
01277         memset( AnsiString, 0, <span class="keyword">sizeof</span>( *AnsiString ) );
01278         }
01279 }
01280 
01281 
01282 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01283"></a><a class="code" href="../../d6/d6/nls_8c.html#a36">01283</a> <a class="code" href="../../d6/d6/nls_8c.html#a36">RtlFreeOemString</a>(
01284     IN OUT POEM_STRING OemString
01285     )
01286 
01287 <span class="comment">/*++</span>
01288 <span class="comment"></span>
01289 <span class="comment">Routine Description:</span>
01290 <span class="comment"></span>
01291 <span class="comment">    This API is used to free storage allocated by</span>
01292 <span class="comment">    RtlUnicodeStringToOemString.  Note that only OemString-&gt;Buffer</span>
01293 <span class="comment">    is free'd by this routine.</span>
01294 <span class="comment"></span>
01295 <span class="comment">Arguments:</span>
01296 <span class="comment"></span>
01297 <span class="comment">    OemString - Supplies the address of the oem string whose buffer</span>
01298 <span class="comment">        was previously allocated by RtlUnicodeStringToOemString.</span>
01299 <span class="comment"></span>
01300 <span class="comment">Return Value:</span>
01301 <span class="comment"></span>
01302 <span class="comment">    None.</span>
01303 <span class="comment"></span>
01304 <span class="comment">--*/</span>
01305 
01306 {
01307     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01308 
01309     <span class="keywordflow">if</span> (OemString-&gt;Buffer) {(<a class="code" href="../../d8/d2/ldrinit_8c.html#a8">RtlFreeStringRoutine</a>)(OemString-&gt;Buffer);}
01310 }
01311 
01312 
01313 ULONG
<a name="l01314"></a><a class="code" href="../../d6/d6/nls_8c.html#a37">01314</a> <a class="code" href="../../d6/d6/nls_8c.html#a37">RtlxUnicodeStringToAnsiSize</a>(
01315     IN PUNICODE_STRING UnicodeString
01316     )
01317 
01318 <span class="comment">/*++</span>
01319 <span class="comment"></span>
01320 <span class="comment">Routine Description:</span>
01321 <span class="comment"></span>
01322 <span class="comment">    This function computes the number of bytes required to store</span>
01323 <span class="comment">    a NULL terminated ansi string that is equivalent to the specified</span>
01324 <span class="comment">    unicode string. If an ansi string can not be formed, the return value</span>
01325 <span class="comment">    is 0.</span>
01326 <span class="comment"></span>
01327 <span class="comment">Arguments:</span>
01328 <span class="comment"></span>
01329 <span class="comment">    UnicodeString - Supplies a unicode string whose equivalent size as</span>
01330 <span class="comment">        an ansi string is to be calculated.</span>
01331 <span class="comment"></span>
01332 <span class="comment">Return Value:</span>
01333 <span class="comment"></span>
01334 <span class="comment">    0 - The operation failed, the unicode string can not be translated</span>
01335 <span class="comment">        into ansi using the current system locale therefore no storage</span>
01336 <span class="comment">        is needed for the ansi string.</span>
01337 <span class="comment"></span>
01338 <span class="comment">    !0 - The operation was successful.  The return value specifies the</span>
01339 <span class="comment">        number of bytes required to hold an NULL terminated ansi string</span>
01340 <span class="comment">        equivalent to the specified unicode string.</span>
01341 <span class="comment"></span>
01342 <span class="comment">--*/</span>
01343 
01344 {
01345     ULONG  cbMultiByteString;
01346 
01347     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01348 
01349     <span class="comment">//</span>
01350     <span class="comment">// Get the size of the string - this call handles DBCS.</span>
01351     <span class="comment">//</span>
01352     <a class="code" href="../../d9/d6/nlsxlat_8c.html#a36">RtlUnicodeToMultiByteSize</a>( &amp;cbMultiByteString,
01353                                UnicodeString-&gt;Buffer,
01354                                UnicodeString-&gt;Length );
01355 
01356     <span class="comment">//</span>
01357     <span class="comment">// Return the size in bytes.</span>
01358     <span class="comment">//</span>
01359     <span class="keywordflow">return</span> (cbMultiByteString + 1);
01360 }
01361 
01362 
01363 ULONG
<a name="l01364"></a><a class="code" href="../../d6/d6/nls_8c.html#a38">01364</a> <a class="code" href="../../d6/d6/nls_8c.html#a38">RtlxUnicodeStringToOemSize</a>(
01365     IN PUNICODE_STRING UnicodeString
01366     )
01367 
01368 <span class="comment">/*++</span>
01369 <span class="comment"></span>
01370 <span class="comment">Routine Description:</span>
01371 <span class="comment"></span>
01372 <span class="comment">    This function computes the number of bytes required to store</span>
01373 <span class="comment">    a NULL terminated oem string that is equivalent to the specified</span>
01374 <span class="comment">    unicode string. If an oem string can not be formed, the return value</span>
01375 <span class="comment">    is 0.</span>
01376 <span class="comment"></span>
01377 <span class="comment">Arguments:</span>
01378 <span class="comment"></span>
01379 <span class="comment">    UnicodeString - Supplies a unicode string whose equivalent size as</span>
01380 <span class="comment">        an oem string is to be calculated.</span>
01381 <span class="comment"></span>
01382 <span class="comment">Return Value:</span>
01383 <span class="comment"></span>
01384 <span class="comment">    0 - The operation failed, the unicode string can not be translated</span>
01385 <span class="comment">        into oem using the OEM code page therefore no storage is</span>
01386 <span class="comment">        needed for the oem string.</span>
01387 <span class="comment"></span>
01388 <span class="comment">    !0 - The operation was successful.  The return value specifies the</span>
01389 <span class="comment">        number of bytes required to hold an NULL terminated oem string</span>
01390 <span class="comment">        equivalent to the specified unicode string.</span>
01391 <span class="comment"></span>
01392 <span class="comment">--*/</span>
01393 
01394 {
01395     ULONG  cbMultiByteString;
01396 
01397     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01398 
01399     <span class="comment">//</span>
01400     <span class="comment">// LATER:  Define an RtlUnicodeToOemSize.</span>
01401     <span class="comment">//         In the Japanese version, it's safe to call</span>
01402     <span class="comment">//         RtlUnicodeToMultiByteSize because the Ansi code page</span>
01403     <span class="comment">//         and the OEM code page are the same.</span>
01404     <span class="comment">//</span>
01405 
01406     <span class="comment">//</span>
01407     <span class="comment">// Get the size of the string - this call handles DBCS.</span>
01408     <span class="comment">//</span>
01409     <a class="code" href="../../d9/d6/nlsxlat_8c.html#a36">RtlUnicodeToMultiByteSize</a>( &amp;cbMultiByteString,
01410                                UnicodeString-&gt;Buffer,
01411                                UnicodeString-&gt;Length );
01412 
01413     <span class="comment">//</span>
01414     <span class="comment">// Return the size in bytes.</span>
01415     <span class="comment">//</span>
01416     <span class="keywordflow">return</span> (cbMultiByteString + 1);
01417 }
01418 
01419 
01420 ULONG
<a name="l01421"></a><a class="code" href="../../d6/d6/nls_8c.html#a39">01421</a> <a class="code" href="../../d6/d6/nls_8c.html#a39">RtlxAnsiStringToUnicodeSize</a>(
01422     IN PANSI_STRING AnsiString
01423     )
01424 
01425 <span class="comment">/*++</span>
01426 <span class="comment"></span>
01427 <span class="comment">Routine Description:</span>
01428 <span class="comment"></span>
01429 <span class="comment">    This function computes the number of bytes required to store a NULL</span>
01430 <span class="comment">    terminated unicode string that is equivalent to the specified ansi</span>
01431 <span class="comment">    string.</span>
01432 <span class="comment"></span>
01433 <span class="comment">Arguments:</span>
01434 <span class="comment"></span>
01435 <span class="comment">    AnsiString - Supplies an ansi string whose equivalent size as a</span>
01436 <span class="comment">        unicode string is to be calculated.  The ansi string is</span>
01437 <span class="comment">        interpreted relative to the current system locale.</span>
01438 <span class="comment"></span>
01439 <span class="comment">Return Value:</span>
01440 <span class="comment"></span>
01441 <span class="comment">    The return value specifies the number of bytes required to hold a</span>
01442 <span class="comment">    NULL terminated unicode string equivalent to the specified ansi</span>
01443 <span class="comment">    string.</span>
01444 <span class="comment"></span>
01445 <span class="comment">--*/</span>
01446 
01447 {
01448     ULONG cbConverted;
01449 
01450     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01451 
01452     <span class="comment">//</span>
01453     <span class="comment">// Get the size of the string - this call handles DBCS.</span>
01454     <span class="comment">//</span>
01455     <a class="code" href="../../d9/d6/nlsxlat_8c.html#a35">RtlMultiByteToUnicodeSize</a>( &amp;cbConverted ,
01456                                AnsiString-&gt;Buffer,
01457                                AnsiString-&gt;Length );
01458 
01459     <span class="comment">//</span>
01460     <span class="comment">// Return the size in bytes.</span>
01461     <span class="comment">//</span>
01462     <span class="keywordflow">return</span> ( cbConverted + <span class="keyword">sizeof</span>(UNICODE_NULL) );
01463 }
01464 
01465 
01466 ULONG
<a name="l01467"></a><a class="code" href="../../d6/d6/nls_8c.html#a40">01467</a> <a class="code" href="../../d6/d6/nls_8c.html#a40">RtlxOemStringToUnicodeSize</a>(
01468     IN POEM_STRING OemString
01469     )
01470 
01471 <span class="comment">/*++</span>
01472 <span class="comment"></span>
01473 <span class="comment">Routine Description:</span>
01474 <span class="comment"></span>
01475 <span class="comment">    This function computes the number of bytes required to store a NULL</span>
01476 <span class="comment">    terminated unicode string that is equivalent to the specified oem</span>
01477 <span class="comment">    string.</span>
01478 <span class="comment"></span>
01479 <span class="comment">Arguments:</span>
01480 <span class="comment"></span>
01481 <span class="comment">    OemString - Supplies an oem string whose equivalent size as a</span>
01482 <span class="comment">        unicode string is to be calculated.  The oem string is</span>
01483 <span class="comment">        interpreted relative to the current oem code page (OCP).</span>
01484 <span class="comment"></span>
01485 <span class="comment">Return Value:</span>
01486 <span class="comment"></span>
01487 <span class="comment">    The return value specifies the number of bytes required to hold a</span>
01488 <span class="comment">    NULL terminated unicode string equivalent to the specified oem</span>
01489 <span class="comment">    string.</span>
01490 <span class="comment"></span>
01491 <span class="comment">--*/</span>
01492 
01493 {
01494     ULONG cbConverted;
01495 
01496     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01497 
01498     <span class="comment">//</span>
01499     <span class="comment">// LATER:  Define an RtlOemToUnicodeSize.</span>
01500     <span class="comment">//         In the Japanese version, it's safe to call</span>
01501     <span class="comment">//         RtlMultiByteToUnicodeSize because the Ansi code page</span>
01502     <span class="comment">//         and the OEM code page are the same.</span>
01503     <span class="comment">//</span>
01504 
01505     <span class="comment">//</span>
01506     <span class="comment">// Get the size of the string - this call handles DBCS.</span>
01507     <span class="comment">//</span>
01508     <a class="code" href="../../d9/d6/nlsxlat_8c.html#a35">RtlMultiByteToUnicodeSize</a>( &amp;cbConverted,
01509                                OemString-&gt;Buffer,
01510                                OemString-&gt;Length );
01511 
01512     <span class="comment">//</span>
01513     <span class="comment">// Return the size in bytes.</span>
01514     <span class="comment">//</span>
01515     <span class="keywordflow">return</span> ( cbConverted + <span class="keyword">sizeof</span>(UNICODE_NULL) );
01516 }
01517 
01518 
01519 LONG
<a name="l01520"></a><a class="code" href="../../d6/d6/nls_8c.html#a41">01520</a> <a class="code" href="../../d6/d6/nls_8c.html#a41">RtlCompareUnicodeString</a>(
01521     IN PUNICODE_STRING String1,
01522     IN PUNICODE_STRING String2,
01523     IN BOOLEAN CaseInSensitive
01524     )
01525 
01526 <span class="comment">/*++</span>
01527 <span class="comment"></span>
01528 <span class="comment">Routine Description:</span>
01529 <span class="comment"></span>
01530 <span class="comment">    The RtlCompareUnicodeString function compares two counted strings.  The</span>
01531 <span class="comment">    return value indicates if the strings are equal or String1 is less than</span>
01532 <span class="comment">    String2 or String1 is greater than String2.</span>
01533 <span class="comment"></span>
01534 <span class="comment">    The CaseInSensitive parameter specifies if case is to be ignored when</span>
01535 <span class="comment">    doing the comparison.</span>
01536 <span class="comment"></span>
01537 <span class="comment">Arguments:</span>
01538 <span class="comment"></span>
01539 <span class="comment">    String1 - Pointer to the first string.</span>
01540 <span class="comment"></span>
01541 <span class="comment">    String2 - Pointer to the second string.</span>
01542 <span class="comment"></span>
01543 <span class="comment">    CaseInsensitive - TRUE if case should be ignored when doing the</span>
01544 <span class="comment">        comparison.</span>
01545 <span class="comment"></span>
01546 <span class="comment">Return Value:</span>
01547 <span class="comment"></span>
01548 <span class="comment">    Signed value that gives the results of the comparison:</span>
01549 <span class="comment"></span>
01550 <span class="comment">        Zero - String1 equals String2</span>
01551 <span class="comment"></span>
01552 <span class="comment">        &lt; Zero - String1 less than String2</span>
01553 <span class="comment"></span>
01554 <span class="comment">        &gt; Zero - String1 greater than String2</span>
01555 <span class="comment"></span>
01556 <span class="comment"></span>
01557 <span class="comment">--*/</span>
01558 
01559 {
01560 
01561     PWCHAR s1, s2, Limit;
01562     LONG n1, n2;
01563     WCHAR c1, c2;
01564 
01565     s1 = <a class="code" href="../../d9/d9/tcmpmem_8c.html#a1">String1</a>-&gt;Buffer;
01566     s2 = <a class="code" href="../../d9/d9/tcmpmem_8c.html#a2">String2</a>-&gt;Buffer;
01567     n1 = <a class="code" href="../../d9/d9/tcmpmem_8c.html#a1">String1</a>-&gt;Length;
01568     n2 = <a class="code" href="../../d9/d9/tcmpmem_8c.html#a2">String2</a>-&gt;Length;
01569 
01570     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((n1 &amp; 1) == 0);
01571     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((n2 &amp; 1) == 0);
01572     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(!(((((ULONG_PTR)s1 &amp; 1) != 0) || (((ULONG_PTR)s2 &amp; 1) != 0)) &amp;&amp; (n1 != 0) &amp;&amp; (n2 != 0)));
01573 
01574     Limit = (PWCHAR)((PCHAR)s1 + (n1 &lt;= n2 ? n1 : n2));
01575     <span class="keywordflow">if</span> (CaseInSensitive) {
01576         <span class="keywordflow">while</span> (s1 &lt; Limit) {
01577             c1 = *s1++;
01578             c2 = *s2++;
01579             <span class="keywordflow">if</span> (c1 != c2) {
01580 
01581                 <span class="comment">//</span>
01582                 <span class="comment">// Note that this needs to reference the translation table!</span>
01583                 <span class="comment">//</span>
01584 
01585                 c1 = <a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(c1);
01586                 c2 = <a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(c2);
01587                 <span class="keywordflow">if</span> (c1 != c2) {
01588                     <span class="keywordflow">return</span> (LONG)(c1) - (LONG)(c2);
01589                 }
01590             }
01591         }
01592 
01593     } <span class="keywordflow">else</span> {
01594         <span class="keywordflow">while</span> (s1 &lt; Limit) {
01595             c1 = *s1++;
01596             c2 = *s2++;
01597             <span class="keywordflow">if</span> (c1 != c2) {
01598                 <span class="keywordflow">return</span> (LONG)(c1) - (LONG)(c2);
01599             }
01600         }
01601     }
01602 
01603     <span class="keywordflow">return</span> n1 - n2;
01604 }
01605 
01606 
01607 BOOLEAN
<a name="l01608"></a><a class="code" href="../../d6/d6/nls_8c.html#a42">01608</a> <a class="code" href="../../d6/d6/nls_8c.html#a42">RtlEqualUnicodeString</a>(
01609     IN PCUNICODE_STRING String1,
01610     IN PCUNICODE_STRING String2,
01611     IN BOOLEAN CaseInSensitive
01612     )
01613 
01614 <span class="comment">/*++</span>
01615 <span class="comment"></span>
01616 <span class="comment">Routine Description:</span>
01617 <span class="comment"></span>
01618 <span class="comment">    The RtlEqualUnicodeString function compares two counted unicode strings for</span>
01619 <span class="comment">    equality.</span>
01620 <span class="comment"></span>
01621 <span class="comment">    The CaseInSensitive parameter specifies if case is to be ignored when</span>
01622 <span class="comment">    doing the comparison.</span>
01623 <span class="comment"></span>
01624 <span class="comment">Arguments:</span>
01625 <span class="comment"></span>
01626 <span class="comment">    String1 - Pointer to the first string.</span>
01627 <span class="comment"></span>
01628 <span class="comment">    String2 - Pointer to the second string.</span>
01629 <span class="comment"></span>
01630 <span class="comment">    CaseInsensitive - TRUE if case should be ignored when doing the</span>
01631 <span class="comment">        comparison.</span>
01632 <span class="comment"></span>
01633 <span class="comment">Return Value:</span>
01634 <span class="comment"></span>
01635 <span class="comment">    Boolean value that is TRUE if String1 equals String2 and FALSE otherwise.</span>
01636 <span class="comment"></span>
01637 <span class="comment">--*/</span>
01638 
01639 {
01640 
01641     PWCHAR s1, s2, Limit;
01642     LONG n1, n2;
01643     WCHAR c1, c2;
01644 
01645     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01646 
01647     n1 = <a class="code" href="../../d9/d9/tcmpmem_8c.html#a1">String1</a>-&gt;Length;
01648     n2 = <a class="code" href="../../d9/d9/tcmpmem_8c.html#a2">String2</a>-&gt;Length;
01649 
01650     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((n1 &amp; 1) == 0);
01651     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((n2 &amp; 1) == 0);
01652 
01653     <span class="keywordflow">if</span> (n1 == n2) {
01654         s1 = <a class="code" href="../../d9/d9/tcmpmem_8c.html#a1">String1</a>-&gt;Buffer;
01655         s2 = <a class="code" href="../../d9/d9/tcmpmem_8c.html#a2">String2</a>-&gt;Buffer;
01656 
01657         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(!(((((ULONG_PTR)s1 &amp; 1) != 0) || (((ULONG_PTR)s2 &amp; 1) != 0)) &amp;&amp; (n1 != 0) &amp;&amp; (n2 != 0)));
01658 
01659         Limit = (PWCHAR)((PCHAR)s1 + n1);
01660         <span class="keywordflow">if</span> (CaseInSensitive) {
01661             <span class="keywordflow">while</span> (s1 &lt; Limit) {
01662                 c1 = *s1++;
01663                 c2 = *s2++;
01664                 <span class="keywordflow">if</span> ((c1 != c2) &amp;&amp; (<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(c1) != <a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(c2))) {
01665                     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01666                 }
01667             }
01668 
01669             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01670 
01671         } <span class="keywordflow">else</span> {
01672             <span class="keywordflow">while</span> (s1 &lt; Limit) {
01673                 c1 = *s1++;
01674                 c2 = *s2++;
01675                 <span class="keywordflow">if</span> (c1 != c2) {
01676                     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01677                 }
01678             }
01679 
01680             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01681         }
01682 
01683     } <span class="keywordflow">else</span> {
01684         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01685     }
01686 }
01687 
01688 
01689 BOOLEAN
<a name="l01690"></a><a class="code" href="../../d6/d6/nls_8c.html#a43">01690</a> <a class="code" href="../../d6/d6/nls_8c.html#a43">RtlPrefixUnicodeString</a>(
01691     IN PUNICODE_STRING String1,
01692     IN PUNICODE_STRING String2,
01693     IN BOOLEAN CaseInSensitive
01694     )
01695 
01696 <span class="comment">/*++</span>
01697 <span class="comment"></span>
01698 <span class="comment">Routine Description:</span>
01699 <span class="comment"></span>
01700 <span class="comment">    The RtlPrefixUnicodeString function determines if the String1</span>
01701 <span class="comment">    counted string parameter is a prefix of the String2 counted string</span>
01702 <span class="comment">    parameter.</span>
01703 <span class="comment"></span>
01704 <span class="comment">    The CaseInSensitive parameter specifies if case is to be ignored when</span>
01705 <span class="comment">    doing the comparison.</span>
01706 <span class="comment"></span>
01707 <span class="comment">Arguments:</span>
01708 <span class="comment"></span>
01709 <span class="comment">    String1 - Pointer to the first unicode string.</span>
01710 <span class="comment"></span>
01711 <span class="comment">    String2 - Pointer to the second unicode string.</span>
01712 <span class="comment"></span>
01713 <span class="comment">    CaseInsensitive - TRUE if case should be ignored when doing the</span>
01714 <span class="comment">        comparison.</span>
01715 <span class="comment"></span>
01716 <span class="comment">Return Value:</span>
01717 <span class="comment"></span>
01718 <span class="comment">    Boolean value that is TRUE if String1 equals a prefix of String2 and</span>
01719 <span class="comment">    FALSE otherwise.</span>
01720 <span class="comment"></span>
01721 <span class="comment">--*/</span>
01722 
01723 {
01724     PWSTR s1, s2;
01725     ULONG <a class="code" href="../../d7/d0/exts_8h.html#a0">n</a>;
01726     WCHAR c1, c2;
01727 
01728     s1 = <a class="code" href="../../d9/d9/tcmpmem_8c.html#a1">String1</a>-&gt;Buffer;
01729     s2 = <a class="code" href="../../d9/d9/tcmpmem_8c.html#a2">String2</a>-&gt;Buffer;
01730     <a class="code" href="../../d7/d0/exts_8h.html#a0">n</a> = <a class="code" href="../../d9/d9/tcmpmem_8c.html#a1">String1</a>-&gt;Length;
01731     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d9/tcmpmem_8c.html#a2">String2</a>-&gt;Length &lt; <a class="code" href="../../d7/d0/exts_8h.html#a0">n</a>) {
01732         <span class="keywordflow">return</span>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01733         }
01734 
01735     <a class="code" href="../../d7/d0/exts_8h.html#a0">n</a> = <a class="code" href="../../d7/d0/exts_8h.html#a0">n</a> / <span class="keyword">sizeof</span>(c1);
01736     <span class="keywordflow">if</span> (CaseInSensitive) {
01737         <span class="keywordflow">while</span> (<a class="code" href="../../d7/d0/exts_8h.html#a0">n</a>) {
01738             c1 = *s1++;
01739             c2 = *s2++;
01740 
01741             <span class="keywordflow">if</span> ((c1 != c2) &amp;&amp; (<a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(c1) != <a class="code" href="../../d5/d9/ntrtlp_8h.html#a10">NLS_UPCASE</a>(c2))) {
01742                 <span class="keywordflow">return</span>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01743                 }
01744 
01745             <a class="code" href="../../d7/d0/exts_8h.html#a0">n</a>--;
01746             }
01747         }
01748     <span class="keywordflow">else</span> {
01749         <span class="keywordflow">while</span> (<a class="code" href="../../d7/d0/exts_8h.html#a0">n</a>) {
01750             <span class="keywordflow">if</span> (*s1++ != *s2++) {
01751                 <span class="keywordflow">return</span>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01752                 }
01753 
01754             <a class="code" href="../../d7/d0/exts_8h.html#a0">n</a>--;
01755             }
01756         }
01757 
01758     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01759 }
01760 
01761 
01762 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01763"></a><a class="code" href="../../d6/d6/nls_8c.html#a44">01763</a> <a class="code" href="../../d6/d6/nls_8c.html#a44">RtlCopyUnicodeString</a>(
01764     OUT PUNICODE_STRING DestinationString,
01765     IN PUNICODE_STRING SourceString OPTIONAL
01766     )
01767 
01768 <span class="comment">/*++</span>
01769 <span class="comment"></span>
01770 <span class="comment">Routine Description:</span>
01771 <span class="comment"></span>
01772 <span class="comment">    The RtlCopyString function copies the SourceString to the</span>
01773 <span class="comment">    DestinationString.  If SourceString is not specified, then</span>
01774 <span class="comment">    the Length field of DestinationString is set to zero.  The</span>
01775 <span class="comment">    MaximumLength and Buffer fields of DestinationString are not</span>
01776 <span class="comment">    modified by this function.</span>
01777 <span class="comment"></span>
01778 <span class="comment">    The number of bytes copied from the SourceString is either the</span>
01779 <span class="comment">    Length of SourceString or the MaximumLength of DestinationString,</span>
01780 <span class="comment">    whichever is smaller.</span>
01781 <span class="comment"></span>
01782 <span class="comment">Arguments:</span>
01783 <span class="comment"></span>
01784 <span class="comment">    DestinationString - Pointer to the destination string.</span>
01785 <span class="comment"></span>
01786 <span class="comment">    SourceString - Optional pointer to the source string.</span>
01787 <span class="comment"></span>
01788 <span class="comment">Return Value:</span>
01789 <span class="comment"></span>
01790 <span class="comment">    None.</span>
01791 <span class="comment"></span>
01792 <span class="comment">--*/</span>
01793 
01794 {
01795     UNALIGNED WCHAR *src, *dst;
01796     ULONG <a class="code" href="../../d7/d0/exts_8h.html#a0">n</a>;
01797 
01798     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(<a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>)) {
01799         dst = DestinationString-&gt;Buffer;
01800         src = <a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>-&gt;Buffer;
01801         <a class="code" href="../../d7/d0/exts_8h.html#a0">n</a> = <a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>-&gt;Length;
01802         <span class="keywordflow">if</span> ((<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d7/d0/exts_8h.html#a0">n</a> &gt; DestinationString-&gt;MaximumLength) {
01803             <a class="code" href="../../d7/d0/exts_8h.html#a0">n</a> = DestinationString-&gt;MaximumLength;
01804         }
01805 
01806         DestinationString-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d7/d0/exts_8h.html#a0">n</a>;
01807         RtlCopyMemory(dst, src, <a class="code" href="../../d7/d0/exts_8h.html#a0">n</a>);
01808         <span class="keywordflow">if</span> (DestinationString-&gt;Length &lt; DestinationString-&gt;MaximumLength) {
01809             dst[<a class="code" href="../../d7/d0/exts_8h.html#a0">n</a> / <span class="keyword">sizeof</span>(WCHAR)] = UNICODE_NULL;
01810         }
01811 
01812     } <span class="keywordflow">else</span> {
01813         DestinationString-&gt;Length = 0;
01814     }
01815 
01816     <span class="keywordflow">return</span>;
01817 }
01818 
01819 
01820 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01821"></a><a class="code" href="../../d6/d6/nls_8c.html#a45">01821</a> <a class="code" href="../../d6/d6/nls_8c.html#a45">RtlAppendUnicodeToString</a> (
01822     IN PUNICODE_STRING Destination,
01823     IN PCWSTR Source OPTIONAL
01824     )
01825 
01826 <span class="comment">/*++</span>
01827 <span class="comment"></span>
01828 <span class="comment">Routine Description:</span>
01829 <span class="comment"></span>
01830 <span class="comment">    This routine appends the supplied UNICODE string to an existing</span>
01831 <span class="comment">    PUNICODE_STRING.</span>
01832 <span class="comment"></span>
01833 <span class="comment">    It will copy bytes from the Source PSZ to the destination PSTRING up to</span>
01834 <span class="comment">    the destinations PUNICODE_STRING-&gt;MaximumLength field.</span>
01835 <span class="comment"></span>
01836 <span class="comment">Arguments:</span>
01837 <span class="comment"></span>
01838 <span class="comment">    IN PUNICODE_STRING Destination, - Supplies a pointer to the destination</span>
01839 <span class="comment">                            string</span>
01840 <span class="comment">    IN PWSTR Source - Supplies the string to append to the destination</span>
01841 <span class="comment"></span>
01842 <span class="comment">Return Value:</span>
01843 <span class="comment"></span>
01844 <span class="comment">    STATUS_SUCCESS - The source string was successfully appended to the</span>
01845 <span class="comment">        destination counted string.</span>
01846 <span class="comment"></span>
01847 <span class="comment">    STATUS_BUFFER_TOO_SMALL - The destination string length was not big</span>
01848 <span class="comment">        enough to allow the source string to be appended.  The Destination</span>
01849 <span class="comment">        string length is not updated.</span>
01850 <span class="comment"></span>
01851 <span class="comment">--*/</span>
01852 
01853 {
01854     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> <a class="code" href="../../d7/d0/exts_8h.html#a0">n</a>;
01855     UNALIGNED WCHAR *dst;
01856 
01857     <span class="keywordflow">if</span> (ARGUMENT_PRESENT( Source )) {
01858         UNICODE_STRING UniSource;
01859 
01860         <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;UniSource, Source);
01861 
01862         <a class="code" href="../../d7/d0/exts_8h.html#a0">n</a> = UniSource.Length;
01863 
01864         <span class="keywordflow">if</span> ((<a class="code" href="../../d7/d0/exts_8h.html#a0">n</a> + Destination-&gt;Length) &gt; Destination-&gt;MaximumLength) {
01865             <span class="keywordflow">return</span>( STATUS_BUFFER_TOO_SMALL );
01866             }
01867 
01868         dst = &amp;Destination-&gt;Buffer[ (Destination-&gt;Length / <span class="keyword">sizeof</span>( WCHAR )) ];
01869         RtlMoveMemory( dst, Source, <a class="code" href="../../d7/d0/exts_8h.html#a0">n</a> );
01870 
01871         Destination-&gt;Length += <a class="code" href="../../d7/d0/exts_8h.html#a0">n</a>;
01872 
01873         <span class="keywordflow">if</span> (Destination-&gt;Length &lt; Destination-&gt;MaximumLength) {
01874             dst[ <a class="code" href="../../d7/d0/exts_8h.html#a0">n</a> / <span class="keyword">sizeof</span>( WCHAR ) ] = UNICODE_NULL;
01875             }
01876         }
01877 
01878     <span class="keywordflow">return</span>( STATUS_SUCCESS );
01879 }
01880 
01881 
01882 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01883"></a><a class="code" href="../../d6/d6/nls_8c.html#a46">01883</a> <a class="code" href="../../d6/d6/nls_8c.html#a46">RtlAppendUnicodeStringToString</a> (
01884     IN PUNICODE_STRING Destination,
01885     IN PUNICODE_STRING Source
01886     )
01887 
01888 <span class="comment">/*++</span>
01889 <span class="comment"></span>
01890 <span class="comment">Routine Description:</span>
01891 <span class="comment"></span>
01892 <span class="comment">    This routine will concatinate two PSTRINGs together.  It will copy</span>
01893 <span class="comment">    bytes from the source up to the MaximumLength of the destination.</span>
01894 <span class="comment"></span>
01895 <span class="comment">Arguments:</span>
01896 <span class="comment"></span>
01897 <span class="comment">    IN PSTRING Destination, - Supplies the destination string</span>
01898 <span class="comment">    IN PSTRING Source - Supplies the source for the string copy</span>
01899 <span class="comment"></span>
01900 <span class="comment">Return Value:</span>
01901 <span class="comment"></span>
01902 <span class="comment">    STATUS_SUCCESS - The source string was successfully appended to the</span>
01903 <span class="comment">        destination counted string.</span>
01904 <span class="comment"></span>
01905 <span class="comment">    STATUS_BUFFER_TOO_SMALL - The destination string length was not big</span>
01906 <span class="comment">        enough to allow the source string to be appended.  The Destination</span>
01907 <span class="comment">        string length is not updated.</span>
01908 <span class="comment"></span>
01909 <span class="comment">--*/</span>
01910 
01911 {
01912     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> <a class="code" href="../../d7/d0/exts_8h.html#a0">n</a> = Source-&gt;Length;
01913     UNALIGNED WCHAR *dst;
01914 
01915     <span class="keywordflow">if</span> (<a class="code" href="../../d7/d0/exts_8h.html#a0">n</a>) {
01916         <span class="keywordflow">if</span> ((<a class="code" href="../../d7/d0/exts_8h.html#a0">n</a> + Destination-&gt;Length) &gt; Destination-&gt;MaximumLength) {
01917             <span class="keywordflow">return</span>( STATUS_BUFFER_TOO_SMALL );
01918             }
01919 
01920         dst = &amp;Destination-&gt;Buffer[ (Destination-&gt;Length / <span class="keyword">sizeof</span>( WCHAR )) ];
01921         RtlMoveMemory( dst, Source-&gt;Buffer, <a class="code" href="../../d7/d0/exts_8h.html#a0">n</a> );
01922 
01923         Destination-&gt;Length += <a class="code" href="../../d7/d0/exts_8h.html#a0">n</a>;
01924 
01925         <span class="keywordflow">if</span> (Destination-&gt;Length &lt; Destination-&gt;MaximumLength) {
01926             dst[ <a class="code" href="../../d7/d0/exts_8h.html#a0">n</a> / <span class="keyword">sizeof</span>( WCHAR ) ] = UNICODE_NULL;
01927             }
01928         }
01929 
01930     <span class="keywordflow">return</span>( STATUS_SUCCESS );
01931 }
01932 
01933 
01934 BOOLEAN
<a name="l01935"></a><a class="code" href="../../d6/d6/nls_8c.html#a47">01935</a> <a class="code" href="../../d6/d6/nls_8c.html#a47">RtlCreateUnicodeString</a>(
01936     OUT PUNICODE_STRING DestinationString,
01937     IN PCWSTR SourceString
01938     )
01939 {
01940     ULONG cb;
01941 
01942     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01943 
01944     cb = (wcslen( <a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a> ) + 1) * <span class="keyword">sizeof</span>( WCHAR );
01945     DestinationString-&gt;Buffer = (<a class="code" href="../../d8/d2/ldrinit_8c.html#a7">RtlAllocateStringRoutine</a>)( cb );
01946     <span class="keywordflow">if</span> (DestinationString-&gt;Buffer) {
01947         RtlMoveMemory( DestinationString-&gt;Buffer, <a class="code" href="../../d0/d2/usrbench_8h.html#a33">SourceString</a>, cb );
01948         DestinationString-&gt;MaximumLength = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)cb;
01949         DestinationString-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(cb - <span class="keyword">sizeof</span>( UNICODE_NULL ));
01950         <span class="keywordflow">return</span>( <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
01951         }
01952     <span class="keywordflow">else</span> {
01953         <span class="keywordflow">return</span>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01954         }
01955 }
01956 
01957 
01958 BOOLEAN
<a name="l01959"></a><a class="code" href="../../d6/d6/nls_8c.html#a48">01959</a> <a class="code" href="../../d6/d6/nls_8c.html#a48">RtlEqualDomainName</a>(
01960     IN PUNICODE_STRING String1,
01961     IN PUNICODE_STRING String2
01962     )
01963 
01964 <span class="comment">/*++</span>
01965 <span class="comment"></span>
01966 <span class="comment">Routine Description:</span>
01967 <span class="comment"></span>
01968 <span class="comment">    The RtlEqualDomainName function compares two domain names for equality.</span>
01969 <span class="comment"></span>
01970 <span class="comment">    The comparison is a case insensitive comparison of the OEM equivalent</span>
01971 <span class="comment">    strings.</span>
01972 <span class="comment"></span>
01973 <span class="comment">    The domain name is not validated for length nor invalid characters.</span>
01974 <span class="comment"></span>
01975 <span class="comment">Arguments:</span>
01976 <span class="comment"></span>
01977 <span class="comment">    String1 - Pointer to the first string.</span>
01978 <span class="comment"></span>
01979 <span class="comment">    String2 - Pointer to the second string.</span>
01980 <span class="comment"></span>
01981 <span class="comment">Return Value:</span>
01982 <span class="comment"></span>
01983 <span class="comment">    Boolean value that is TRUE if String1 equals String2 and FALSE otherwise.</span>
01984 <span class="comment"></span>
01985 <span class="comment">--*/</span>
01986 
01987 {
01988     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01989     BOOLEAN ReturnValue = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01990     OEM_STRING OemString1;
01991     OEM_STRING OemString2;
01992 
01993     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
01994 
01995     <span class="comment">//</span>
01996     <span class="comment">// Upper case and convert the first string to OEM</span>
01997     <span class="comment">//</span>
01998 
01999     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d6/nls_8c.html#a27">RtlUpcaseUnicodeStringToOemString</a>( &amp;OemString1,
02000                                                 <a class="code" href="../../d9/d9/tcmpmem_8c.html#a1">String1</a>,
02001                                                 <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );   <span class="comment">// Allocate Dest</span>
02002 
02003     <span class="keywordflow">if</span> ( <a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ) ) {
02004 
02005         <span class="comment">//</span>
02006         <span class="comment">// Upper case and convert the second string to OEM</span>
02007         <span class="comment">//</span>
02008 
02009         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d6/nls_8c.html#a27">RtlUpcaseUnicodeStringToOemString</a>( &amp;OemString2,
02010                                                     <a class="code" href="../../d9/d9/tcmpmem_8c.html#a2">String2</a>,
02011                                                     <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );   <span class="comment">// Allocate Dest</span>
02012 
02013         <span class="keywordflow">if</span> ( <a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ) ) {
02014 
02015             <span class="comment">//</span>
02016             <span class="comment">// Do a case insensitive comparison.</span>
02017             <span class="comment">//</span>
02018 
02019             ReturnValue = <a class="code" href="../../d2/d7/string_8c.html#a11">RtlEqualString</a>( &amp;OemString1,
02020                                           &amp;OemString2,
02021                                           <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
02022 
02023             <a class="code" href="../../d6/d6/nls_8c.html#a36">RtlFreeOemString</a>( &amp;OemString2 );
02024         }
02025 
02026         <a class="code" href="../../d6/d6/nls_8c.html#a36">RtlFreeOemString</a>( &amp;OemString1 );
02027     }
02028 
02029     <span class="keywordflow">return</span> ReturnValue;
02030 }
02031 
02032 
02033 
02034 BOOLEAN
<a name="l02035"></a><a class="code" href="../../d6/d6/nls_8c.html#a49">02035</a> <a class="code" href="../../d6/d6/nls_8c.html#a49">RtlEqualComputerName</a>(
02036     IN PUNICODE_STRING String1,
02037     IN PUNICODE_STRING String2
02038     )
02039 
02040 <span class="comment">/*++</span>
02041 <span class="comment"></span>
02042 <span class="comment">Routine Description:</span>
02043 <span class="comment"></span>
02044 <span class="comment">    The RtlEqualComputerName function compares two computer names for equality.</span>
02045 <span class="comment"></span>
02046 <span class="comment">    The comparison is a case insensitive comparison of the OEM equivalent</span>
02047 <span class="comment">    strings.</span>
02048 <span class="comment"></span>
02049 <span class="comment">    The domain name is not validated for length nor invalid characters.</span>
02050 <span class="comment"></span>
02051 <span class="comment">Arguments:</span>
02052 <span class="comment"></span>
02053 <span class="comment">    String1 - Pointer to the first string.</span>
02054 <span class="comment"></span>
02055 <span class="comment">    String2 - Pointer to the second string.</span>
02056 <span class="comment"></span>
02057 <span class="comment">Return Value:</span>
02058 <span class="comment"></span>
02059 <span class="comment">    Boolean value that is TRUE if String1 equals String2 and FALSE otherwise.</span>
02060 <span class="comment"></span>
02061 <span class="comment">--*/</span>
02062 
02063 {
02064     <span class="keywordflow">return</span> <a class="code" href="../../d6/d6/nls_8c.html#a48">RtlEqualDomainName</a>( <a class="code" href="../../d9/d9/tcmpmem_8c.html#a1">String1</a>, <a class="code" href="../../d9/d9/tcmpmem_8c.html#a2">String2</a> );
02065 }
02066 
<a name="l02072"></a><a class="code" href="../../d6/d6/nls_8c.html#a1">02072</a> <span class="preprocessor">#define UNICODE_FFFF              0xFFFF</span>
<a name="l02073"></a><a class="code" href="../../d6/d6/nls_8c.html#a2">02073</a> <span class="preprocessor"></span><span class="preprocessor">#define REVERSE_BYTE_ORDER_MARK   0xFFFE</span>
<a name="l02074"></a><a class="code" href="../../d6/d6/nls_8c.html#a3">02074</a> <span class="preprocessor"></span><span class="preprocessor">#define BYTE_ORDER_MARK           0xFEFF</span>
02075 <span class="preprocessor"></span>
<a name="l02076"></a><a class="code" href="../../d6/d6/nls_8c.html#a4">02076</a> <span class="preprocessor">#define PARAGRAPH_SEPARATOR       0x2029</span>
<a name="l02077"></a><a class="code" href="../../d6/d6/nls_8c.html#a5">02077</a> <span class="preprocessor"></span><span class="preprocessor">#define LINE_SEPARATOR            0x2028</span>
02078 <span class="preprocessor"></span>
<a name="l02079"></a><a class="code" href="../../d6/d6/nls_8c.html#a6">02079</a> <span class="preprocessor">#define UNICODE_TAB               0x0009</span>
<a name="l02080"></a><a class="code" href="../../d6/d6/nls_8c.html#a7">02080</a> <span class="preprocessor"></span><span class="preprocessor">#define UNICODE_LF                0x000A</span>
<a name="l02081"></a><a class="code" href="../../d6/d6/nls_8c.html#a8">02081</a> <span class="preprocessor"></span><span class="preprocessor">#define UNICODE_CR                0x000D</span>
<a name="l02082"></a><a class="code" href="../../d6/d6/nls_8c.html#a9">02082</a> <span class="preprocessor"></span><span class="preprocessor">#define UNICODE_SPACE             0x0020</span>
<a name="l02083"></a><a class="code" href="../../d6/d6/nls_8c.html#a10">02083</a> <span class="preprocessor"></span><span class="preprocessor">#define UNICODE_CJK_SPACE         0x3000</span>
02084 <span class="preprocessor"></span>
<a name="l02085"></a><a class="code" href="../../d6/d6/nls_8c.html#a11">02085</a> <span class="preprocessor">#define UNICODE_R_TAB             0x0900</span>
<a name="l02086"></a><a class="code" href="../../d6/d6/nls_8c.html#a12">02086</a> <span class="preprocessor"></span><span class="preprocessor">#define UNICODE_R_LF              0x0A00</span>
<a name="l02087"></a><a class="code" href="../../d6/d6/nls_8c.html#a13">02087</a> <span class="preprocessor"></span><span class="preprocessor">#define UNICODE_R_CR              0x0D00</span>
<a name="l02088"></a><a class="code" href="../../d6/d6/nls_8c.html#a14">02088</a> <span class="preprocessor"></span><span class="preprocessor">#define UNICODE_R_SPACE           0x2000</span>
<a name="l02089"></a><a class="code" href="../../d6/d6/nls_8c.html#a15">02089</a> <span class="preprocessor"></span><span class="preprocessor">#define UNICODE_R_CJK_SPACE       0x0030  </span><span class="comment">/* Ambiguous - same as ASCII '0' */</span>
02090 
<a name="l02091"></a><a class="code" href="../../d6/d6/nls_8c.html#a16">02091</a> <span class="preprocessor">#define ASCII_CRLF                0x0A0D</span>
02092 <span class="preprocessor"></span>
<a name="l02093"></a><a class="code" href="../../d6/d6/nls_8c.html#a17">02093</a> <span class="preprocessor">#define __max(a,b)  (((a) &gt; (b)) ? (a) : (b))</span>
<a name="l02094"></a><a class="code" href="../../d6/d6/nls_8c.html#a18">02094</a> <span class="preprocessor"></span><span class="preprocessor">#define __min(a,b)  (((a) &lt; (b)) ? (a) : (b))</span>
02095 <span class="preprocessor"></span>
02096 
02097 BOOLEAN
<a name="l02098"></a><a class="code" href="../../d6/d6/nls_8c.html#a50">02098</a> <a class="code" href="../../d6/d6/nls_8c.html#a50">RtlIsTextUnicode</a>(
02099     IN PVOID Buffer,
02100     IN ULONG Size,
02101     IN OUT PULONG Result OPTIONAL
02102     )
02103 
02104 <span class="comment">/*++</span>
02105 <span class="comment"></span>
02106 <span class="comment">Routine Description:</span>
02107 <span class="comment"></span>
02108 <span class="comment">    IsTextUnicode performs a series of inexpensive heuristic checks</span>
02109 <span class="comment">    on a buffer in order to verify that it contains Unicode data.</span>
02110 <span class="comment"></span>
02111 <span class="comment"></span>
02112 <span class="comment">    [[ need to fix this section, see at the end ]]</span>
02113 <span class="comment"></span>
02114 <span class="comment">    Found            Return Result</span>
02115 <span class="comment"></span>
02116 <span class="comment">    BOM              TRUE   BOM</span>
02117 <span class="comment">    RBOM             FALSE  RBOM</span>
02118 <span class="comment">    FFFF             FALSE  Binary</span>
02119 <span class="comment">    NULL             FALSE  Binary</span>
02120 <span class="comment">    null             TRUE   null bytes</span>
02121 <span class="comment">    ASCII_CRLF       FALSE  CRLF</span>
02122 <span class="comment">    UNICODE_TAB etc. TRUE   Zero Ext Controls</span>
02123 <span class="comment">    UNICODE_TAB_R    FALSE  Reversed Controls</span>
02124 <span class="comment">    UNICODE_ZW  etc. TRUE   Unicode specials</span>
02125 <span class="comment"></span>
02126 <span class="comment">    1/3 as little variation in hi-byte as in lo byte: TRUE   Correl</span>
02127 <span class="comment">    3/1 or worse   "                                  FALSE  AntiCorrel</span>
02128 <span class="comment"></span>
02129 <span class="comment">Arguments:</span>
02130 <span class="comment"></span>
02131 <span class="comment">    Buffer - pointer to buffer containing text to examine.</span>
02132 <span class="comment"></span>
02133 <span class="comment">    Size - size of buffer in bytes.  At most 256 characters in this will</span>
02134 <span class="comment">           be examined.  If the size is less than the size of a unicode</span>
02135 <span class="comment">           character, then this function returns FALSE.</span>
02136 <span class="comment"></span>
02137 <span class="comment">    Result - optional pointer to a flag word that contains additional information</span>
02138 <span class="comment">             about the reason for the return value.  If specified, this value on</span>
02139 <span class="comment">             input is a mask that is used to limit the factors this routine uses</span>
02140 <span class="comment">             to make it decision.  On output, this flag word is set to contain</span>
02141 <span class="comment">             those flags that were used to make its decision.</span>
02142 <span class="comment"></span>
02143 <span class="comment">Return Value:</span>
02144 <span class="comment"></span>
02145 <span class="comment">    Boolean value that is TRUE if Buffer contains unicode characters.</span>
02146 <span class="comment"></span>
02147 <span class="comment">--*/</span>
02148 {
02149     UNALIGNED WCHAR *lpBuff = <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>;
02150     PCHAR lpb = <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>;
02151     ULONG iBOM = 0;
02152     ULONG iCR = 0;
02153     ULONG iLF = 0;
02154     ULONG iTAB = 0;
02155     ULONG iSPACE = 0;
02156     ULONG iCJK_SPACE = 0;
02157     ULONG iFFFF = 0;
02158     ULONG iPS = 0;
02159     ULONG iLS = 0;
02160 
02161     ULONG iRBOM = 0;
02162     ULONG iR_CR = 0;
02163     ULONG iR_LF = 0;
02164     ULONG iR_TAB = 0;
02165     ULONG iR_SPACE = 0;
02166 
02167     ULONG iNull = 0;
02168     ULONG iUNULL = 0;
02169     ULONG iCRLF = 0;
02170     ULONG iTmp;
02171     ULONG LastLo = 0;
02172     ULONG LastHi = 0;
02173     ULONG iHi, iLo;
02174     ULONG HiDiff = 0;
02175     ULONG LoDiff = 0;
02176     ULONG cLeadByte = 0;
02177     ULONG cWeird = 0;
02178 
02179     ULONG iResult = 0;
02180 
02181     ULONG iMaxTmp = <a class="code" href="../../d6/d6/nls_8c.html#a18">__min</a>(256, <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> / <span class="keyword">sizeof</span>(WCHAR));
02182 
02183     <span class="comment">//</span>
02184     <span class="comment">//  Special case when the size is less than or equal to 2.</span>
02185     <span class="comment">//  Make sure we don't have a character followed by a null byte.</span>
02186     <span class="comment">//</span>
02187     <span class="keywordflow">if</span> ((<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> &lt; 2) ||
02188         ((<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> == 2) &amp;&amp; (lpBuff[0] != 0) &amp;&amp; (lpb[1] == 0)))
02189     {
02190         <span class="keywordflow">if</span> (ARGUMENT_PRESENT(Result))
02191         {
02192             *Result = IS_TEXT_UNICODE_ASCII16 | IS_TEXT_UNICODE_CONTROLS;
02193         }
02194 
02195         <span class="keywordflow">return</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
02196     }
02197     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> &gt; 2) &amp;&amp; ((<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> / <span class="keyword">sizeof</span>(WCHAR)) &lt;= 256))
02198     {
02199         <span class="comment">//</span>
02200         <span class="comment">//  If the Size passed in is an even number, we don't want to</span>
02201         <span class="comment">//  use the last WCHAR because it will contain the final null</span>
02202         <span class="comment">//  byte.</span>
02203         <span class="comment">//</span>
02204         <span class="keywordflow">if</span> (((<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> % <span class="keyword">sizeof</span>(WCHAR)) == 0) &amp;&amp;
02205             ((lpBuff[iMaxTmp - 1] &amp; 0xff00) == 0))
02206         {
02207             iMaxTmp--;
02208         }
02209     }
02210 
02211     <span class="comment">//</span>
02212     <span class="comment">//  Check at most 256 wide characters, collect various statistics.</span>
02213     <span class="comment">//</span>
02214     <span class="keywordflow">for</span> (iTmp = 0; iTmp &lt; iMaxTmp; iTmp++)
02215     {
02216         <span class="keywordflow">switch</span> (lpBuff[iTmp])
02217         {
02218             <span class="keywordflow">case</span> <a class="code" href="../../d6/d6/nls_8c.html#a3">BYTE_ORDER_MARK</a>:
02219                 iBOM++;
02220                 <span class="keywordflow">break</span>;
02221             <span class="keywordflow">case</span> <a class="code" href="../../d6/d6/nls_8c.html#a4">PARAGRAPH_SEPARATOR</a>:
02222                 iPS++;
02223                 <span class="keywordflow">break</span>;
02224             <span class="keywordflow">case</span> <a class="code" href="../../d6/d6/nls_8c.html#a5">LINE_SEPARATOR</a>:
02225                 iLS++;
02226                 <span class="keywordflow">break</span>;
02227             <span class="keywordflow">case</span> <a class="code" href="../../d9/d5/verifier_8c.html#a4">UNICODE_LF</a>:
02228                 iLF++;
02229                 <span class="keywordflow">break</span>;
02230             <span class="keywordflow">case</span> <a class="code" href="../../d9/d5/verifier_8c.html#a3">UNICODE_TAB</a>:
02231                 iTAB++;
02232                 <span class="keywordflow">break</span>;
02233             <span class="keywordflow">case</span> <a class="code" href="../../d9/d5/verifier_8c.html#a6">UNICODE_SPACE</a>:
02234                 iSPACE++;
02235                 <span class="keywordflow">break</span>;
02236             <span class="keywordflow">case</span> <a class="code" href="../../d9/d5/verifier_8c.html#a7">UNICODE_CJK_SPACE</a>:
02237                 iCJK_SPACE++;
02238                 <span class="keywordflow">break</span>;
02239             <span class="keywordflow">case</span> <a class="code" href="../../d9/d5/verifier_8c.html#a5">UNICODE_CR</a>:
02240                 iCR++;
02241                 <span class="keywordflow">break</span>;
02242 
02243             <span class="comment">//</span>
02244             <span class="comment">//  The following codes are expected to show up in</span>
02245             <span class="comment">//  byte reversed files.</span>
02246             <span class="comment">//</span>
02247             <span class="keywordflow">case</span> <a class="code" href="../../d6/d6/nls_8c.html#a2">REVERSE_BYTE_ORDER_MARK</a>:
02248                 iRBOM++;
02249                 <span class="keywordflow">break</span>;
02250             <span class="keywordflow">case</span> <a class="code" href="../../d6/d6/nls_8c.html#a12">UNICODE_R_LF</a>:
02251                 iR_LF++;
02252                 <span class="keywordflow">break</span>;
02253             <span class="keywordflow">case</span> <a class="code" href="../../d6/d6/nls_8c.html#a11">UNICODE_R_TAB</a>:
02254                 iR_TAB++;
02255                 <span class="keywordflow">break</span>;
02256             <span class="keywordflow">case</span> <a class="code" href="../../d6/d6/nls_8c.html#a13">UNICODE_R_CR</a>:
02257                 iR_CR++;
02258                 <span class="keywordflow">break</span>;
02259             <span class="keywordflow">case</span> <a class="code" href="../../d6/d6/nls_8c.html#a14">UNICODE_R_SPACE</a>:
02260                 iR_SPACE++;
02261                 <span class="keywordflow">break</span>;
02262 
02263             <span class="comment">//</span>
02264             <span class="comment">//  The following codes are illegal and should never occur.</span>
02265             <span class="comment">//</span>
02266             <span class="keywordflow">case</span> <a class="code" href="../../d6/d6/nls_8c.html#a1">UNICODE_FFFF</a>:
02267                 iFFFF++;
02268                 <span class="keywordflow">break</span>;
02269             <span class="keywordflow">case</span> UNICODE_NULL:
02270                 iUNULL++;
02271                 <span class="keywordflow">break</span>;
02272 
02273             <span class="comment">//</span>
02274             <span class="comment">//  The following is not currently a Unicode character</span>
02275             <span class="comment">//  but is expected to show up accidentally when reading</span>
02276             <span class="comment">//  in ASCII files which use CRLF on a little endian machine.</span>
02277             <span class="comment">//</span>
02278             <span class="keywordflow">case</span> <a class="code" href="../../d6/d6/nls_8c.html#a16">ASCII_CRLF</a>:
02279                 iCRLF++;
02280                 <span class="keywordflow">break</span>;       <span class="comment">/* little endian */</span>
02281         }
02282 
02283         <span class="comment">//</span>
02284         <span class="comment">//  Collect statistics on the fluctuations of high bytes</span>
02285         <span class="comment">//  versus low bytes.</span>
02286         <span class="comment">//</span>
02287         iHi = <a class="code" href="../../d5/d9/ntrtlp_8h.html#a5">HIBYTE</a>(lpBuff[iTmp]);
02288         iLo = <a class="code" href="../../d5/d9/ntrtlp_8h.html#a4">LOBYTE</a>(lpBuff[iTmp]);
02289 
02290         <span class="comment">//</span>
02291         <span class="comment">//  Count cr/lf and lf/cr that cross two words.</span>
02292         <span class="comment">//</span>
02293         <span class="keywordflow">if</span> ((iLo == <span class="charliteral">'\r'</span> &amp;&amp; LastHi == <span class="charliteral">'\n'</span>) ||
02294             (iLo == <span class="charliteral">'\n'</span> &amp;&amp; LastHi == <span class="charliteral">'\r'</span>))
02295         {
02296             cWeird++;
02297         }
02298 
02299         iNull += (iHi ? 0 : 1) + (iLo ? 0 : 1);   <span class="comment">/* count Null bytes */</span>
02300 
02301         HiDiff += <a class="code" href="../../d6/d6/nls_8c.html#a17">__max</a>(iHi, LastHi) - <a class="code" href="../../d6/d6/nls_8c.html#a18">__min</a>(LastHi, iHi);
02302         LoDiff += <a class="code" href="../../d6/d6/nls_8c.html#a17">__max</a>(iLo, LastLo) - <a class="code" href="../../d6/d6/nls_8c.html#a18">__min</a>(LastLo, iLo);
02303 
02304         LastLo = iLo;
02305         LastHi = iHi;
02306     }
02307 
02308     <span class="comment">//</span>
02309     <span class="comment">//  Count cr/lf and lf/cr that cross two words.</span>
02310     <span class="comment">//</span>
02311     <span class="keywordflow">if</span> ((iLo == <span class="charliteral">'\r'</span> &amp;&amp; LastHi == <span class="charliteral">'\n'</span>) ||
02312         (iLo == <span class="charliteral">'\n'</span> &amp;&amp; LastHi == <span class="charliteral">'\r'</span>))
02313     {
02314         cWeird++;
02315     }
02316 
02317     <span class="keywordflow">if</span> (iHi == <span class="charliteral">'\0'</span>)     <span class="comment">/* don't count the last null */</span>
02318         iNull--;
02319     <span class="keywordflow">if</span> (iHi == 26)       <span class="comment">/* count ^Z at end as weird */</span>
02320         cWeird++;
02321 
02322     iMaxTmp = <a class="code" href="../../d6/d6/nls_8c.html#a18">__min</a>(256 * <span class="keyword">sizeof</span>(WCHAR), <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>);
02323     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d6/nlsxlat_8c.html#a19">NlsMbCodePageTag</a>)
02324     {
02325         <span class="keywordflow">for</span> (iTmp = 0; iTmp &lt; iMaxTmp; iTmp++)
02326         {
02327             <span class="keywordflow">if</span> (<a class="code" href="../../d6/d6/nls_8c.html#a20">NlsLeadByteInfo</a>[lpb[iTmp]])
02328             {
02329                 cLeadByte++;
02330                 iTmp++;         <span class="comment">/* should check for trailing-byte range */</span>
02331             }
02332         }
02333     }
02334 
02335     <span class="comment">//</span>
02336     <span class="comment">//  Sift through the statistical evidence.</span>
02337     <span class="comment">//</span>
02338     <span class="keywordflow">if</span> (LoDiff &lt; 127 &amp;&amp; HiDiff == 0)
02339     {
02340         iResult |= IS_TEXT_UNICODE_ASCII16;         <span class="comment">/* likely 16-bit ASCII */</span>
02341     }
02342 
02343     <span class="keywordflow">if</span> (HiDiff &amp;&amp; LoDiff == 0)
02344     {
02345         iResult |= IS_TEXT_UNICODE_REVERSE_ASCII16; <span class="comment">/* reverse 16-bit ASCII */</span>
02346     }
02347 
02348     <span class="comment">//</span>
02349     <span class="comment">//  Use leadbyte info to weight statistics.</span>
02350     <span class="comment">//</span>
02351     <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d6/nlsxlat_8c.html#a19">NlsMbCodePageTag</a> || cLeadByte == 0 ||
02352         !ARGUMENT_PRESENT(Result) || !(*Result &amp; IS_TEXT_UNICODE_DBCS_LEADBYTE))
02353     {
02354         iHi = 3;
02355     }
02356     <span class="keywordflow">else</span>
02357     {
02358         <span class="comment">//</span>
02359         <span class="comment">//  A ratio of cLeadByte:cb of 1:2 ==&gt; dbcs</span>
02360         <span class="comment">//  Very crude - should have a nice eq.</span>
02361         <span class="comment">//</span>
02362         iHi = <a class="code" href="../../d6/d6/nls_8c.html#a18">__min</a>(256, <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> / <span class="keyword">sizeof</span>(WCHAR)) / 2;
02363         <span class="keywordflow">if</span> (cLeadByte &lt; (iHi - 1) / 3)
02364         {
02365             iHi = 3;
02366         }
02367         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cLeadByte &lt; (2 * (iHi - 1)) / 3)
02368         {
02369             iHi = 2;
02370         }
02371         <span class="keywordflow">else</span>
02372         {
02373             iHi = 1;
02374         }
02375         iResult |= IS_TEXT_UNICODE_DBCS_LEADBYTE;
02376     }
02377 
02378     <span class="keywordflow">if</span> (iHi * HiDiff &lt; LoDiff)
02379     {
02380         iResult |= IS_TEXT_UNICODE_STATISTICS;
02381     }
02382 
02383     <span class="keywordflow">if</span> (iHi * LoDiff &lt; HiDiff)
02384     {
02385         iResult |= IS_TEXT_UNICODE_REVERSE_STATISTICS;
02386     }
02387 
02388     <span class="comment">//</span>
02389     <span class="comment">//  Any control codes widened to 16 bits? Any Unicode character</span>
02390     <span class="comment">//  which contain one byte in the control code range?</span>
02391     <span class="comment">//</span>
02392     <span class="keywordflow">if</span> (iCR + iLF + iTAB + iSPACE + iCJK_SPACE <span class="comment">/*+iPS+iLS*/</span>)
02393     {
02394         iResult |= IS_TEXT_UNICODE_CONTROLS;
02395     }
02396 
02397     <span class="keywordflow">if</span> (iR_LF + iR_CR + iR_TAB + iR_SPACE)
02398     {
02399         iResult |= IS_TEXT_UNICODE_REVERSE_CONTROLS;
02400     }
02401 
02402     <span class="comment">//</span>
02403     <span class="comment">//  Any characters that are illegal for Unicode?</span>
02404     <span class="comment">//</span>
02405     <span class="keywordflow">if</span> ((iRBOM + iFFFF + iUNULL + iCRLF) != 0 ||
02406          (cWeird != 0 &amp;&amp; cWeird &gt;= iMaxTmp/40))
02407     {
02408         iResult |= IS_TEXT_UNICODE_ILLEGAL_CHARS;
02409     }
02410 
02411     <span class="comment">//</span>
02412     <span class="comment">//  Odd buffer length cannot be Unicode.</span>
02413     <span class="comment">//</span>
02414     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> &amp; 1)
02415     {
02416         iResult |= IS_TEXT_UNICODE_ODD_LENGTH;
02417     }
02418 
02419     <span class="comment">//</span>
02420     <span class="comment">//  Any NULL bytes? (Illegal in ANSI)</span>
02421     <span class="comment">//</span>
02422     <span class="keywordflow">if</span> (iNull)
02423     {
02424         iResult |= IS_TEXT_UNICODE_NULL_BYTES;
02425     }
02426 
02427     <span class="comment">//</span>
02428     <span class="comment">//  POSITIVE evidence, BOM or RBOM used as signature.</span>
02429     <span class="comment">//</span>
02430     <span class="keywordflow">if</span> (*lpBuff == <a class="code" href="../../d6/d6/nls_8c.html#a3">BYTE_ORDER_MARK</a>)
02431     {
02432         iResult |= IS_TEXT_UNICODE_SIGNATURE;
02433     }
02434     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*lpBuff == <a class="code" href="../../d6/d6/nls_8c.html#a2">REVERSE_BYTE_ORDER_MARK</a>)
02435     {
02436         iResult |= IS_TEXT_UNICODE_REVERSE_SIGNATURE;
02437     }
02438 
02439     <span class="comment">//</span>
02440     <span class="comment">//  Limit to desired categories if requested.</span>
02441     <span class="comment">//</span>
02442     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(Result))
02443     {
02444         iResult &amp;= *Result;
02445         *Result = iResult;
02446     }
02447 
02448     <span class="comment">//</span>
02449     <span class="comment">//  There are four separate conclusions:</span>
02450     <span class="comment">//</span>
02451     <span class="comment">//  1: The file APPEARS to be Unicode     AU</span>
02452     <span class="comment">//  2: The file CANNOT be Unicode         CU</span>
02453     <span class="comment">//  3: The file CANNOT be ANSI            CA</span>
02454     <span class="comment">//</span>
02455     <span class="comment">//</span>
02456     <span class="comment">//  This gives the following possible results</span>
02457     <span class="comment">//</span>
02458     <span class="comment">//      CU</span>
02459     <span class="comment">//      +        -</span>
02460     <span class="comment">//</span>
02461     <span class="comment">//      AU       AU</span>
02462     <span class="comment">//      +   -    +   -</span>
02463     <span class="comment">//      --------  --------</span>
02464     <span class="comment">//      CA +| 0   0    2   3</span>
02465     <span class="comment">//      |</span>
02466     <span class="comment">//      -| 1   1    4   5</span>
02467     <span class="comment">//</span>
02468     <span class="comment">//</span>
02469     <span class="comment">//  Note that there are only 6 really different cases, not 8.</span>
02470     <span class="comment">//</span>
02471     <span class="comment">//  0 - This must be a binary file</span>
02472     <span class="comment">//  1 - ANSI file</span>
02473     <span class="comment">//  2 - Unicode file (High probability)</span>
02474     <span class="comment">//  3 - Unicode file (more than 50% chance)</span>
02475     <span class="comment">//  5 - No evidence for Unicode (ANSI is default)</span>
02476     <span class="comment">//</span>
02477     <span class="comment">//  The whole thing is more complicated if we allow the assumption</span>
02478     <span class="comment">//  of reverse polarity input. At this point we have a simplistic</span>
02479     <span class="comment">//  model: some of the reverse Unicode evidence is very strong,</span>
02480     <span class="comment">//  we ignore most weak evidence except statistics. If this kind of</span>
02481     <span class="comment">//  strong evidence is found together with Unicode evidence, it means</span>
02482     <span class="comment">//  its likely NOT Text at all. Furthermore if a REVERSE_BYTE_ORDER_MARK</span>
02483     <span class="comment">//  is found, it precludes normal Unicode. If both byte order marks are</span>
02484     <span class="comment">//  found it's not Unicode.</span>
02485     <span class="comment">//</span>
02486 
02487     <span class="comment">//</span>
02488     <span class="comment">//  Unicode signature : uncontested signature outweighs reverse evidence.</span>
02489     <span class="comment">//</span>
02490     <span class="keywordflow">if</span> ((iResult &amp; IS_TEXT_UNICODE_SIGNATURE) &amp;&amp;
02491         !(iResult &amp; (IS_TEXT_UNICODE_NOT_UNICODE_MASK&amp;(~IS_TEXT_UNICODE_DBCS_LEADBYTE))))
02492     {
02493         <span class="keywordflow">return</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
02494     }
02495 
02496     <span class="comment">//</span>
02497     <span class="comment">//  If we have conflicting evidence, it's not Unicode.</span>
02498     <span class="comment">//</span>
02499     <span class="keywordflow">if</span> (iResult &amp; IS_TEXT_UNICODE_REVERSE_MASK)
02500     {
02501         <span class="keywordflow">return</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
02502     }
02503 
02504     <span class="comment">//</span>
02505     <span class="comment">//  Statistical and other results (cases 2 and 3).</span>
02506     <span class="comment">//</span>
02507     <span class="keywordflow">if</span> (!(iResult &amp; IS_TEXT_UNICODE_NOT_UNICODE_MASK) &amp;&amp;
02508          ((iResult &amp; IS_TEXT_UNICODE_NOT_ASCII_MASK) ||
02509           (iResult &amp; IS_TEXT_UNICODE_UNICODE_MASK)))
02510     {
02511         <span class="keywordflow">return</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
02512     }
02513 
02514     <span class="keywordflow">return</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
02515 }
02516 
02517 
02518 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l02519"></a><a class="code" href="../../d6/d6/nls_8c.html#a51">02519</a> <a class="code" href="../../d6/d6/nls_8c.html#a51">RtlDnsHostNameToComputerName</a>(
02520     OUT PUNICODE_STRING ComputerNameString,
02521     IN PUNICODE_STRING DnsHostNameString,
02522     IN BOOLEAN AllocateComputerNameString
02523     )
02524 
02525 <span class="comment">/*++</span>
02526 <span class="comment"></span>
02527 <span class="comment">Routine Description:</span>
02528 <span class="comment"></span>
02529 <span class="comment">    The RtlDnsHostNameToComputerName API converts a DNS-style host name to a</span>
02530 <span class="comment">    Netbios-style computer name.</span>
02531 <span class="comment"></span>
02532 <span class="comment">    This API does a syntactical mapping of the name.  As such, it should not</span>
02533 <span class="comment">    be used to convert a DNS domain name to a Netbios domain name.</span>
02534 <span class="comment">    There is no syntactical mapping for domain names.</span>
02535 <span class="comment"></span>
02536 <span class="comment">    DNS-style names consist of one or more "labels" separated by a period</span>
02537 <span class="comment">    (e.g., xxx.nt.microsoft.com).  Each label can be up to 63 bytes of</span>
02538 <span class="comment">    UTF-8 characters and must consist only of characters specified</span>
02539 <span class="comment">    by the DnsValidateDnsName API.  Upper and lower case characters are treated</span>
02540 <span class="comment">    as the same character.  DNS names are represented in the UTF-8 character set</span>
02541 <span class="comment">    or UNICODE.</span>
02542 <span class="comment"></span>
02543 <span class="comment">    Netbios computer names consist of up to 15 bytes of OEM characters</span>
02544 <span class="comment">    including letters, digits, hyphens, periods and various other characters.</span>
02545 <span class="comment">    Some of these characters are specific to the character set. Netbios names</span>
02546 <span class="comment">    are typically represented in the OEM character set.  The OEM character</span>
02547 <span class="comment">    set is different depending on the locale of the particular version of the OS</span>
02548 <span class="comment">    (e.g., the German version has a different character set than the US version).</span>
02549 <span class="comment">    Some OEM character sets represent certain characters as 2 bytes</span>
02550 <span class="comment">    (e.g., Japanese).  Netbios names, by convention, are represented in</span>
02551 <span class="comment">    uppercase where the translation algorithm from lowercase to uppercase</span>
02552 <span class="comment">    is OEM character set dependent.</span>
02553 <span class="comment"></span>
02554 <span class="comment">    These characteristics make translating between DNS name and Netbios name</span>
02555 <span class="comment">    difficult.</span>
02556 <span class="comment"></span>
02557 <span class="comment">    RtlDnsHostNameToComputerName enforces a textual convention for</span>
02558 <span class="comment">    mapping between the two names.  This convention limits the names of</span>
02559 <span class="comment">    computers to be the common subset of the names.  Specifically, the leftmost</span>
02560 <span class="comment">    label of the DNS name is truncated to 15-bytes of OEM characters.</span>
02561 <span class="comment">    As such, RtlDnsHostNameToComputerName simply interprets the leftmost label</span>
02562 <span class="comment">    of the DNS name as the Netbios name.  If the DNS name doesn't meet the</span>
02563 <span class="comment">    criteria of a valid translatable name, a distinct error code is returned.</span>
02564 <span class="comment"></span>
02565 <span class="comment">Arguments:</span>
02566 <span class="comment"></span>
02567 <span class="comment">    ComputerNameString - Returns a unicode string that is equivalent to</span>
02568 <span class="comment">        the DNS source string. The maximum length field is only</span>
02569 <span class="comment">        set if AllocateComputerNameString is TRUE.</span>
02570 <span class="comment"></span>
02571 <span class="comment">    DnsHostNameString - Supplies the DNS host name source string that is to be</span>
02572 <span class="comment">        converted to a netbios computer name.</span>
02573 <span class="comment"></span>
02574 <span class="comment">        This routine does NOT attempt to validate that the passed in DnsHostNameString</span>
02575 <span class="comment">        is a valid DNS host a DNS host name.  Rather it assumes that the passed in</span>
02576 <span class="comment">        name is valid and converts it on a best effort basis.</span>
02577 <span class="comment"></span>
02578 <span class="comment">    AllocateComputerNameString - Supplies a flag that controls whether or</span>
02579 <span class="comment">        not this API allocates the buffer space for the destination</span>
02580 <span class="comment">        string.  If it does, then the buffer must be deallocated using</span>
02581 <span class="comment">        RtlFreeUnicodeString (note that only storage for</span>
02582 <span class="comment">        DestinationString-&gt;Buffer is allocated by this API).</span>
02583 <span class="comment"></span>
02584 <span class="comment">Return Value:</span>
02585 <span class="comment"></span>
02586 <span class="comment">    SUCCESS - The conversion was successful</span>
02587 <span class="comment"></span>
02588 <span class="comment">    STATUS_NO_MEMORY - There is not enough memory to allocate the return buffer.</span>
02589 <span class="comment"></span>
02590 <span class="comment">    STATUS_INVALID_COMPUTER_NAME - The DnsHostName has no first label or</span>
02591 <span class="comment">        one or more characters of the DnsHostName could not be converted to</span>
02592 <span class="comment">        the OEM character set.</span>
02593 <span class="comment"></span>
02594 <span class="comment">--*/</span>
02595 
02596 {
02597     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02598 
02599 
02600     UNICODE_STRING LocalDnsHostNameString;
02601 
02602     OEM_STRING OemString;
02603     ULONG ActualOemLength;
02604     <a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a> OemStringBuffer[16];
02605 
02606     ULONG i;
02607 
02608     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
02609 
02610     <span class="comment">//</span>
02611     <span class="comment">// Truncate the dns name to the first label</span>
02612     <span class="comment">//</span>
02613 
02614     LocalDnsHostNameString = *DnsHostNameString;
02615 
02616     <span class="keywordflow">for</span> ( i=0; i&lt;LocalDnsHostNameString.Length/<span class="keyword">sizeof</span>(WCHAR); i++ ) {
02617 
02618         <span class="keywordflow">if</span> ( LocalDnsHostNameString.Buffer[i] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'.'</span> ) {
02619             LocalDnsHostNameString.Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(i * <span class="keyword">sizeof</span>(WCHAR));
02620             <span class="keywordflow">break</span>;
02621         }
02622     }
02623 
02624     <span class="keywordflow">if</span> ( LocalDnsHostNameString.Length &lt; <span class="keyword">sizeof</span>(WCHAR) ) {
02625         <span class="keywordflow">return</span> STATUS_INVALID_COMPUTER_NAME;
02626     }
02627 
02628     <span class="comment">//</span>
02629     <span class="comment">// Convert the DNS name to OEM truncating at 15 OEM bytes.</span>
02630     <span class="comment">//</span>
02631 
02632     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d6/nlsxlat_8c.html#a40">RtlUpcaseUnicodeToOemN</a>(
02633                 OemStringBuffer,
02634                 <a class="code" href="../../d6/d6/nls_8c.html#a0">NETBIOS_NAME_LEN</a>-1,         <span class="comment">// truncate to 15 bytes</span>
02635                 &amp;ActualOemLength,
02636                 LocalDnsHostNameString.Buffer,
02637                 LocalDnsHostNameString.Length );
02638 
02639     <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>) &amp;&amp; <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> != STATUS_BUFFER_OVERFLOW ) {
02640         <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02641     }
02642 
02643 
02644     <span class="comment">//</span>
02645     <span class="comment">// Check to see if any characters are not valid OEM characters.</span>
02646     <span class="comment">//</span>
02647 
02648     OemString.Buffer = OemStringBuffer;
02649     OemString.MaximumLength = OemString.Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) ActualOemLength;
02650 
02651     <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d9/ntrtlp_8h.html#a37">RtlpDidUnicodeToOemWork</a>( &amp;OemString, &amp;LocalDnsHostNameString )) {
02652         <span class="keywordflow">return</span> STATUS_INVALID_COMPUTER_NAME;
02653     }
02654 
02655 
02656     <span class="comment">//</span>
02657     <span class="comment">// Convert the OEM string back to UNICODE</span>
02658     <span class="comment">//</span>
02659 
02660     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d6/nls_8c.html#a25">RtlOemStringToUnicodeString</a>(
02661                 ComputerNameString,
02662                 &amp;OemString,
02663                 AllocateComputerNameString );
02664 
02665     <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>) ) {
02666         <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02667     }
02668 
02669     <span class="keywordflow">return</span> STATUS_SUCCESS;
02670 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:57 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
