<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: ioverifier.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>ioverifier.c</h1><a href="../../d6/d6/ioverifier_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="preprocessor">#include "<a class="code" href="../../d0/d6/iop_8h.html">iop.h</a>"</span>
00002 
00003 <span class="comment">/*++</span>
00004 <span class="comment"></span>
00005 <span class="comment">Copyright (c) 1989  Microsoft Corporation</span>
00006 <span class="comment"></span>
00007 <span class="comment">Module Name:</span>
00008 <span class="comment"></span>
00009 <span class="comment">   ioverifier.c</span>
00010 <span class="comment"></span>
00011 <span class="comment">Abstract:</span>
00012 <span class="comment"></span>
00013 <span class="comment">    This module contains the routines to verify suspect drivers.</span>
00014 <span class="comment"></span>
00015 <span class="comment">Author:</span>
00016 <span class="comment"></span>
00017 <span class="comment">    Narayanan Ganapathy (narg) 8-Jan-1999</span>
00018 <span class="comment"></span>
00019 <span class="comment">Revision History:</span>
00020 <span class="comment"></span>
00021 <span class="comment">    Adrian J. Oney (AdriaO) 28-Feb-1999</span>
00022 <span class="comment">        - merge in special irp code.</span>
00023 <span class="comment"></span>
00024 <span class="comment">--*/</span>
00025 
00026 <span class="preprocessor">#if (( defined(_X86_) ) &amp;&amp; ( FPO ))</span>
00027 <span class="preprocessor"></span><span class="preprocessor">#pragma optimize( "y", off )    // disable FPO for consistent stack traces</span>
00028 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00029 <span class="preprocessor"></span>
00030 
<a name="l00031"></a><a class="code" href="../../d6/d6/ioverifier_8c.html#a0">00031</a> <span class="preprocessor">#define IO_FREE_IRP_TYPE_INVALID                1</span>
<a name="l00032"></a><a class="code" href="../../d6/d6/ioverifier_8c.html#a1">00032</a> <span class="preprocessor"></span><span class="preprocessor">#define IO_FREE_IRP_NOT_ASSOCIATED_WITH_THREAD  2</span>
<a name="l00033"></a><a class="code" href="../../d6/d6/ioverifier_8c.html#a2">00033</a> <span class="preprocessor"></span><span class="preprocessor">#define IO_CALL_DRIVER_IRP_TYPE_INVALID         3</span>
<a name="l00034"></a><a class="code" href="../../d6/d6/ioverifier_8c.html#a3">00034</a> <span class="preprocessor"></span><span class="preprocessor">#define IO_CALL_DRIVER_INVALID_DEVICE_OBJECT    4</span>
<a name="l00035"></a><a class="code" href="../../d6/d6/ioverifier_8c.html#a4">00035</a> <span class="preprocessor"></span><span class="preprocessor">#define IO_CALL_DRIVER_IRQL_NOT_EQUAL           5</span>
<a name="l00036"></a><a class="code" href="../../d6/d6/ioverifier_8c.html#a5">00036</a> <span class="preprocessor"></span><span class="preprocessor">#define IO_COMPLETE_REQUEST_INVALID_STATUS      6</span>
<a name="l00037"></a><a class="code" href="../../d6/d6/ioverifier_8c.html#a6">00037</a> <span class="preprocessor"></span><span class="preprocessor">#define IO_COMPLETE_REQUEST_CANCEL_ROUTINE_SET  7</span>
<a name="l00038"></a><a class="code" href="../../d6/d6/ioverifier_8c.html#a7">00038</a> <span class="preprocessor"></span><span class="preprocessor">#define IO_BUILD_FSD_REQUEST_EXCEPTION          8</span>
<a name="l00039"></a><a class="code" href="../../d6/d6/ioverifier_8c.html#a8">00039</a> <span class="preprocessor"></span><span class="preprocessor">#define IO_BUILD_IOCTL_REQUEST_EXCEPTION        9</span>
<a name="l00040"></a><a class="code" href="../../d6/d6/ioverifier_8c.html#a9">00040</a> <span class="preprocessor"></span><span class="preprocessor">#define IO_REINITIALIZING_TIMER_OBJECT          10</span>
<a name="l00041"></a><a class="code" href="../../d6/d6/ioverifier_8c.html#a10">00041</a> <span class="preprocessor"></span><span class="preprocessor">#define IO_INVALID_HANDLE                       11</span>
<a name="l00042"></a><a class="code" href="../../d6/d6/ioverifier_8c.html#a11">00042</a> <span class="preprocessor"></span><span class="preprocessor">#define IO_INVALID_STACK_IOSB                   12</span>
<a name="l00043"></a><a class="code" href="../../d6/d6/ioverifier_8c.html#a12">00043</a> <span class="preprocessor"></span><span class="preprocessor">#define IO_INVALID_STACK_EVENT                  13</span>
<a name="l00044"></a><a class="code" href="../../d6/d6/ioverifier_8c.html#a13">00044</a> <span class="preprocessor"></span><span class="preprocessor">#define IO_COMPLETE_REQUEST_INVALID_IRQL        14</span>
00045 <span class="preprocessor"></span>
00046 <span class="comment">//</span>
00047 <span class="comment">// 0x200 and up are defined in ioassert.c</span>
00048 <span class="comment">//</span>
00049 
00050 PVOID
00051 <a class="code" href="../../d9/d5/verifier_8c.html#a56">VerifierAllocatePoolWithQuotaTag</a>(
00052     IN POOL_TYPE PoolType,
00053     IN SIZE_T NumberOfBytes,
00054     IN ULONG Tag
00055     );
00056 
<a name="l00057"></a><a class="code" href="../../d6/d6/ioverifier_8c.html#a14">00057</a> <span class="preprocessor">#define IsKernelHandle(H,M) (((LONG_PTR)(H) &lt; 0) &amp;&amp; ((M) == KernelMode) &amp;&amp; ((H) != NtCurrentThread()) &amp;&amp; ((H) != NtCurrentProcess()))</span>
00058 <span class="preprocessor"></span>
00059 BOOLEAN
00060 <a class="code" href="../../d6/d6/ioverifier_8c.html#a24">IovpValidateDeviceObject</a>(
00061     IN  <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>  DeviceObject
00062     );
00063 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00064 <a class="code" href="../../d6/d6/ioverifier_8c.html#a25">IovFreeIrpPrivate</a>(
00065     IN  <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>    Irp
00066     );
00067 
00068 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00069 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(INIT, IoVerifierInit)</span>
00070 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY,IovAllocateIrp)</span>
00071 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY,IovFreeIrp)</span>
00072 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY,IovCallDriver)</span>
00073 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY,IovCompleteRequest)</span>
00074 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY,IovCallDriver)</span>
00075 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY,IovCompleteRequest)</span>
00076 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY,IovpValidateDeviceObject)</span>
00077 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY,IovSpecialIrpCallDriver)</span>
00078 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY,IovSpecialIrpCompleteRequest)</span>
00079 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEVRFY,IovFreeIrpPrivate)</span>
00080 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00081 <span class="preprocessor"></span>
<a name="l00082"></a><a class="code" href="../../d6/d6/ioverifier_8c.html#a16">00082</a> BOOLEAN         <a class="code" href="../../d0/d6/iop_8h.html#a132">IopVerifierOn</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
<a name="l00083"></a><a class="code" href="../../d6/d6/ioverifier_8c.html#a17">00083</a> ULONG           <a class="code" href="../../d2/d5/ioassert_8h.html#a27">IovpEnforcementLevel</a> = (ULONG) -1;
<a name="l00084"></a><a class="code" href="../../d6/d6/ioverifier_8c.html#a18">00084</a> ULONG           <a class="code" href="../../d8/d0/cmdat3_8c.html#a57">IovpVerifierLevel</a> = (ULONG)0;
<a name="l00085"></a><a class="code" href="../../d6/d6/ioverifier_8c.html#a19">00085</a> BOOLEAN         <a class="code" href="../../d6/d6/ioverifier_8c.html#a19">IoVerifierOnByDefault</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
<a name="l00086"></a><a class="code" href="../../d6/d6/ioverifier_8c.html#a20">00086</a> LONG            <a class="code" href="../../d2/d5/ioassert_8h.html#a25">IovpInitCalled</a> = 0;
<a name="l00087"></a><a class="code" href="../../d6/d6/ioverifier_8c.html#a21">00087</a> ULONG           <a class="code" href="../../d6/d6/ioverifier_8c.html#a21">IovpMaxSupportedVerifierLevel</a> = 3;
<a name="l00088"></a><a class="code" href="../../d6/d6/ioverifier_8c.html#a22">00088</a> ULONG           <a class="code" href="../../d6/d6/ioverifier_8c.html#a22">IovpVerifierFlags</a> = 0;               <span class="comment">// Stashes the verifier flags passed at init.</span>
00089 
00090 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00091"></a><a class="code" href="../../d6/d6/ioverifier_8c.html#a26">00091</a> <a class="code" href="../../d6/d6/ioverifier_8c.html#a26">IoVerifierInit</a>(
00092     IN ULONG VerifierFlags,
00093     IN ULONG InitFlags
00094     )
00095 {
00096     PVOID   sectionHeaderHandle;
00097     ULONG   verifierLevel;
00098 
00099     <span class="keywordflow">if</span> (<a class="code" href="../../d6/d6/ioverifier_8c.html#a19">IoVerifierOnByDefault</a>) {
00100         VerifierFlags |= DRIVER_VERIFIER_IO_CHECKING;
00101     }
00102 
00103     <span class="keywordflow">if</span> (!VerifierFlags) {
00104         <span class="keywordflow">return</span>;
00105     }
00106     <a class="code" href="../../d3/d5/iodata_8c.html#a57">pIoAllocateIrp</a> = <a class="code" href="../../d0/d5/io_8h.html#a590">IovAllocateIrp</a>;
00107 
00108 <span class="preprocessor">#ifndef NO_SPECIAL_IRP</span>
00109 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (!(InitFlags &amp; <a class="code" href="../../d0/d5/io_8h.html#a260">IOVERIFIERINIT_PHASE0</a>)) {
00110 
00111         <span class="comment">//</span>
00112         <span class="comment">// Lock it down.</span>
00113         <span class="comment">//</span>
00114         sectionHeaderHandle = MmLockPagableCodeSection(<a class="code" href="../../d1/d5/ioassert_8c.html#a27">IopDriverCorrectnessTakeLock</a>);
00115 
00116         <span class="keywordflow">if</span> (!sectionHeaderHandle) {
00117 
00118             <span class="keywordflow">return</span>;
00119         }
00120     }
00121 
00122     <span class="comment">//</span>
00123     <span class="comment">// Various initialization</span>
00124     <span class="comment">//</span>
00125     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d5/ioassert_8c.html#a9">IopDcControlOverride</a> == (ULONG) -1) {
00126 
00127         <a class="code" href="../../d1/d5/ioassert_8c.html#a9">IopDcControlOverride</a> = 0;
00128     }
00129 
00130     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d5/ioassert_8c.html#a8">IopDcControlInitial</a> == (ULONG) -1) {
00131 
00132         <a class="code" href="../../d1/d5/ioassert_8c.html#a8">IopDcControlInitial</a> = 0;
00133         <span class="keywordflow">if</span> (!(InitFlags &amp; <a class="code" href="../../d0/d5/io_8h.html#a264">IOVERIFIERINIT_VERIFIER_DRIVER_LIST</a>)) {
00134 
00135             <a class="code" href="../../d1/d5/ioassert_8c.html#a8">IopDcControlInitial</a> |= <a class="code" href="../../d2/d5/ioassert_8h.html#a6">DIAG_IGNORE_DRIVER_LIST</a>;
00136         }
00137     }
00138 
00139     <a class="code" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock</a>(&amp;<a class="code" href="../../d1/d5/ioassert_8c.html#a7">IopDcControlLock</a>) ;
00140 
00141 <span class="preprocessor">#endif // NO_SPECIAL_IRP</span>
00142 <span class="preprocessor"></span>
00143     <span class="keywordflow">if</span> (!(VerifierFlags &amp; DRIVER_VERIFIER_IO_CHECKING)) {
00144 
00145         <span class="keywordflow">return</span>;
00146     }
00147 
00148     <span class="comment">//</span>
00149     <span class="comment">// Determine the level of verification. Later we will modify the driver</span>
00150     <span class="comment">// verifier applet to pass in a level directly.</span>
00151     <span class="comment">//</span>
00152 
00153 <span class="preprocessor">#if !DBG</span>
00154 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a57">IovpVerifierLevel</a> &gt; <a class="code" href="../../d6/d6/ioverifier_8c.html#a21">IovpMaxSupportedVerifierLevel</a>) {
00155         <a class="code" href="../../d8/d0/cmdat3_8c.html#a57">IovpVerifierLevel</a>  = <a class="code" href="../../d6/d6/ioverifier_8c.html#a21">IovpMaxSupportedVerifierLevel</a>;
00156     }
00157 <span class="preprocessor">#endif</span>
00158 <span class="preprocessor"></span>
00159     verifierLevel = <a class="code" href="../../d8/d0/cmdat3_8c.html#a57">IovpVerifierLevel</a>;
00160 
00161     <span class="comment">//</span>
00162     <span class="comment">// Enable and hook in the verifier.</span>
00163     <span class="comment">//</span>
00164     <a class="code" href="../../d0/d6/iop_8h.html#a132">IopVerifierOn</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00165     <a class="code" href="../../d2/d5/ioassert_8h.html#a25">IovpInitCalled</a> = 1;
00166     <a class="code" href="../../d6/d6/ioverifier_8c.html#a22">IovpVerifierFlags</a> = VerifierFlags;
00167 
00168     <span class="keywordflow">if</span> (verifierLevel &gt; 1) {
00169         <span class="comment">//</span>
00170         <span class="comment">// Initialize the special IRP code as appropriate.</span>
00171         <span class="comment">//</span>
00172 <span class="preprocessor">#ifndef NO_SPECIAL_IRP</span>
00173 <span class="preprocessor"></span>        <a class="code" href="../../d9/d4/trackirp_8h.html#a107">IovpInitIrpTracking</a>(verifierLevel, InitFlags);
00174 <span class="preprocessor">#endif // NO_SPECIAL_IRP</span>
00175 <span class="preprocessor"></span>        InterlockedExchangePointer((PVOID *)&amp;<a class="code" href="../../d3/d5/iodata_8c.html#a55">pIofCallDriver</a>, (PVOID) <a class="code" href="../../d6/d6/ioverifier_8c.html#a36">IovSpecialIrpCallDriver</a>);
00176         InterlockedExchangePointer((PVOID *)&amp;<a class="code" href="../../d3/d5/iodata_8c.html#a56">pIofCompleteRequest</a>, (PVOID) <a class="code" href="../../d6/d6/ioverifier_8c.html#a35">IovSpecialIrpCompleteRequest</a>);
00177         InterlockedExchangePointer((PVOID *)&amp;<a class="code" href="../../d3/d5/iodata_8c.html#a58">pIoFreeIrp</a>, (PVOID) <a class="code" href="../../d6/d6/ioverifier_8c.html#a25">IovFreeIrpPrivate</a>);
00178     }
00179     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(KeGetCurrentIrql() &lt;= <a class="code" href="../../d6/d7/halmips_8h.html#a52">APC_LEVEL</a>);
00180 }
00181 
00182 
00183 BOOLEAN
<a name="l00184"></a><a class="code" href="../../d6/d6/ioverifier_8c.html#a24">00184</a> <a class="code" href="../../d6/d6/ioverifier_8c.html#a24">IovpValidateDeviceObject</a>(
00185     IN  <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>  DeviceObject
00186     )
00187 {
00188     <span class="keywordflow">if</span> ((DeviceObject-&gt;Type != <a class="code" href="../../d0/d5/io_8h.html#a2">IO_TYPE_DEVICE</a>) ||
00189         (DeviceObject-&gt;DriverObject == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) ||
00190         (DeviceObject-&gt;ReferenceCount &lt; 0 )) {
00191         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00192     } <span class="keywordflow">else</span> {
00193         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00194     }
00195 }
00196 
00197 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00198"></a><a class="code" href="../../d6/d6/ioverifier_8c.html#a27">00198</a> <a class="code" href="../../d6/d6/ioverifier_8c.html#a27">IovFreeIrp</a>(
00199     IN  <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>    Irp
00200     )
00201 {
00202     <a class="code" href="../../d6/d6/ioverifier_8c.html#a25">IovFreeIrpPrivate</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>);
00203 }
00204 
00205 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00206"></a><a class="code" href="../../d6/d6/ioverifier_8c.html#a25">00206</a> <a class="code" href="../../d6/d6/ioverifier_8c.html#a25">IovFreeIrpPrivate</a>(
00207     IN  <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>    Irp
00208     )
00209 {
00210 
00211 
00212 <span class="preprocessor">#ifndef NO_SPECIAL_IRP</span>
00213 <span class="preprocessor"></span>    BOOLEAN freeHandled ;
00214 <span class="preprocessor">#endif</span>
00215 <span class="preprocessor"></span>
00216 
00217     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a132">IopVerifierOn</a>) {
00218         <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o0">Type</a> != <a class="code" href="../../d0/d5/io_8h.html#a5">IO_TYPE_IRP</a>) {
00219             <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a>(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
00220                          <a class="code" href="../../d6/d6/ioverifier_8c.html#a0">IO_FREE_IRP_TYPE_INVALID</a>,
00221                          (ULONG_PTR)<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>,
00222                          0,
00223                          0);
00224         }
00225         <span class="keywordflow">if</span> (!IsListEmpty(&amp;(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>)-&gt;ThreadListEntry)) {
00226             <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a>(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
00227                          <a class="code" href="../../d6/d6/ioverifier_8c.html#a1">IO_FREE_IRP_NOT_ASSOCIATED_WITH_THREAD</a>,
00228                          (ULONG_PTR)<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>,
00229                          0,
00230                          0);
00231         }
00232     }
00233 
00234 <span class="preprocessor">#ifndef NO_SPECIAL_IRP</span>
00235 <span class="preprocessor"></span>    <a class="code" href="../../d9/d4/trackirp_8h.html#a79">SPECIALIRP_IO_FREE_IRP</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, &amp;freeHandled) ;
00236 
00237     <span class="keywordflow">if</span> (freeHandled) {
00238 
00239        <span class="keywordflow">return</span> ;
00240     }
00241 <span class="preprocessor">#endif</span>
00242 <span class="preprocessor"></span>
00243     <a class="code" href="../../d4/d6/iosubs_8c.html#a64">IopFreeIrp</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>);
00244 }
00245 
00246 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00247 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l00248"></a><a class="code" href="../../d6/d6/ioverifier_8c.html#a28">00248</a> <a class="code" href="../../d6/d6/ioverifier_8c.html#a28">IovCallDriver</a>(
00249     IN  <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>  DeviceObject,
00250     IN  OUT <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>    Irp
00251     )
00252 {
00253     KIRQL    saveIrql;
00254     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
00255 
00256 
00257     <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d6/iop_8h.html#a132">IopVerifierOn</a>) {
00258         status = <a class="code" href="../../d4/d6/iosubs_8c.html#a28">IopfCallDriver</a>(DeviceObject, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>);
00259         <span class="keywordflow">return</span> status;
00260     }
00261 
00262     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a57">IovpVerifierLevel</a> &gt; 1) {
00263         status = <a class="code" href="../../d7/d6/ioverifier_8h.html#a8">IovSpecialIrpCallDriver</a>(DeviceObject, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>);
00264         <span class="keywordflow">return</span> status;
00265     }
00266     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o0">Type</a> != <a class="code" href="../../d0/d5/io_8h.html#a5">IO_TYPE_IRP</a>) {
00267         <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a>(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
00268                      <a class="code" href="../../d6/d6/ioverifier_8c.html#a2">IO_CALL_DRIVER_IRP_TYPE_INVALID</a>,
00269                      (ULONG_PTR)<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>,
00270                      0,
00271                      0);
00272     }
00273     <span class="keywordflow">if</span> (!<a class="code" href="../../d6/d6/ioverifier_8c.html#a24">IovpValidateDeviceObject</a>(DeviceObject)) {
00274         <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a>(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
00275                      <a class="code" href="../../d6/d6/ioverifier_8c.html#a3">IO_CALL_DRIVER_INVALID_DEVICE_OBJECT</a>,
00276                      (ULONG_PTR)DeviceObject,
00277                      0,
00278                      0);
00279     }
00280 
00281     saveIrql = KeGetCurrentIrql();
00282     status = <a class="code" href="../../d4/d6/iosubs_8c.html#a28">IopfCallDriver</a>(DeviceObject, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>);
00283     <span class="keywordflow">if</span> (saveIrql != KeGetCurrentIrql()) {
00284         <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a>(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
00285                      <a class="code" href="../../d6/d6/ioverifier_8c.html#a4">IO_CALL_DRIVER_IRQL_NOT_EQUAL</a>,
00286                      (ULONG_PTR)DeviceObject,
00287                      saveIrql,
00288                      KeGetCurrentIrql());
00289 
00290     }
00291     <span class="keywordflow">return</span> status;
00292 }
00293 
00294 
00295 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00296 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l00297"></a><a class="code" href="../../d6/d6/ioverifier_8c.html#a29">00297</a> <a class="code" href="../../d6/d6/ioverifier_8c.html#a29">IovCompleteRequest</a>(
00298     IN  <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>    Irp,
00299     IN  CCHAR   PriorityBoost
00300     )
00301 {
00302 
00303     <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d6/iop_8h.html#a132">IopVerifierOn</a>) {
00304         <a class="code" href="../../d4/d6/iosubs_8c.html#a40">IopfCompleteRequest</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, <a class="code" href="../../d0/d6/iop_8h.html#a36">PriorityBoost</a>);
00305         <span class="keywordflow">return</span>;
00306     }
00307 
00308     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a57">IovpVerifierLevel</a> &gt; 1) {
00309         <a class="code" href="../../d7/d6/ioverifier_8h.html#a9">IovSpecialIrpCompleteRequest</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, <a class="code" href="../../d0/d6/iop_8h.html#a36">PriorityBoost</a>);
00310         <span class="keywordflow">return</span>;
00311     }
00312 
00313     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a> &gt; (CCHAR) (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o12">StackCount</a> + 1) ||
00314         <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o0">Type</a> != <a class="code" href="../../d0/d5/io_8h.html#a5">IO_TYPE_IRP</a>) {
00315         <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a>( MULTIPLE_IRP_COMPLETE_REQUESTS,
00316                       (ULONG_PTR) <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>,
00317                       __LINE__,
00318                       0,
00319                       0);
00320     }
00321 
00322     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o25">CancelRoutine</a>) {
00323         <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a>(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
00324                      <a class="code" href="../../d6/d6/ioverifier_8c.html#a6">IO_COMPLETE_REQUEST_CANCEL_ROUTINE_SET</a>,
00325                      (ULONG_PTR)<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o25">CancelRoutine</a>,
00326                      (ULONG_PTR)<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>,
00327                      0);
00328     }
00329     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status == STATUS_PENDING || <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status == 0xffffffff) {
00330          <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a>(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
00331                       <a class="code" href="../../d6/d6/ioverifier_8c.html#a5">IO_COMPLETE_REQUEST_INVALID_STATUS</a>,
00332                       <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status,
00333                       (ULONG_PTR)<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>,
00334                       0);
00335     }
00336     <span class="keywordflow">if</span> (KeGetCurrentIrql() &gt; <a class="code" href="../../d6/d7/halmips_8h.html#a53">DISPATCH_LEVEL</a>) {
00337         <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a>(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
00338                      <a class="code" href="../../d6/d6/ioverifier_8c.html#a13">IO_COMPLETE_REQUEST_INVALID_IRQL</a>,
00339                      KeGetCurrentIrql(),
00340                      (ULONG_PTR)<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>,
00341                      0);
00342 
00343     }
00344     <a class="code" href="../../d4/d6/iosubs_8c.html#a40">IopfCompleteRequest</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, <a class="code" href="../../d0/d6/iop_8h.html#a36">PriorityBoost</a>);
00345 }
00346 
00347 
00348 <span class="comment">//</span>
00349 <span class="comment">// Wrapper for IovAllocateIrp. Use special pool to allocate the IRP.</span>
00350 <span class="comment">// This is directly called from IoAllocateIrp.</span>
00351 <span class="comment">//</span>
00352 <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>
<a name="l00353"></a><a class="code" href="../../d6/d6/ioverifier_8c.html#a30">00353</a> <a class="code" href="../../d6/d6/ioverifier_8c.html#a30">IovAllocateIrp</a>(
00354     IN CCHAR StackSize,
00355     IN BOOLEAN ChargeQuota
00356     )
00357 {
00358     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> allocateSize;
00359     UCHAR fixedSize;
00360     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
00361     UCHAR mustSucceed;
00362     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> packetSize;
00363 
00364 <span class="preprocessor">#ifndef NO_SPECIAL_IRP</span>
00365 <span class="preprocessor"></span>    <span class="comment">//</span>
00366     <span class="comment">// Should we override normal lookaside caching so that we may catch</span>
00367     <span class="comment">// more bugs?</span>
00368     <span class="comment">//</span>
00369     <a class="code" href="../../d9/d4/trackirp_8h.html#a80">SPECIALIRP_IO_ALLOCATE_IRP_1</a>(StackSize, ChargeQuota, &amp;irp) ;
00370 
00371     <span class="keywordflow">if</span> (irp) {
00372        <span class="keywordflow">return</span> irp ;
00373     }
00374 <span class="preprocessor">#endif</span>
00375 <span class="preprocessor"></span>
00376     <span class="comment">//</span>
00377     <span class="comment">// If special pool is not turned on lets just call the standard</span>
00378     <span class="comment">// irp allocator.</span>
00379     <span class="comment">//</span>
00380 
00381     <span class="keywordflow">if</span> (!(<a class="code" href="../../d6/d6/ioverifier_8c.html#a22">IovpVerifierFlags</a> &amp; DRIVER_VERIFIER_SPECIAL_POOLING )) {
00382         irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a18">IopAllocateIrpPrivate</a>(StackSize, ChargeQuota);
00383         <span class="keywordflow">return</span> irp;
00384     }
00385 
00386 
00387     irp = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00388     fixedSize = 0;
00389     mustSucceed = 0;
00390     packetSize = <a class="code" href="../../d0/d5/io_8h.html#a245">IoSizeOfIrp</a>(StackSize);
00391     allocateSize = packetSize;
00392 
00393     <span class="comment">//</span>
00394     <span class="comment">// There are no free packets on the lookaside list, or the packet is</span>
00395     <span class="comment">// too large to be allocated from one of the lists, so it must be</span>
00396     <span class="comment">// allocated from nonpaged pool. If quota is to be charged, charge it</span>
00397     <span class="comment">// against the current process. Otherwise, allocate the pool normally.</span>
00398     <span class="comment">//</span>
00399 
00400     <span class="keywordflow">if</span> (ChargeQuota) {
00401         <span class="keywordflow">try</span> {
00402             irp = <a class="code" href="../../d5/d8/ex_8h.html#a222">ExAllocatePoolWithTagPriority</a>(
00403                     <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
00404                     allocateSize,
00405                     ' prI',
00406                     <a class="code" href="../../d5/d8/ex_8h.html#a330a195">HighPoolPrioritySpecialPoolOverrun</a>);
00407         } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00408             NOTHING;
00409         }
00410 
00411     } <span class="keywordflow">else</span> {
00412 
00413         <span class="comment">//</span>
00414         <span class="comment">// Attempt to allocate the pool from non-paged pool.  If this</span>
00415         <span class="comment">// fails, and the caller's previous mode was kernel then allocate</span>
00416         <span class="comment">// the pool as must succeed.</span>
00417         <span class="comment">//</span>
00418 
00419         irp = <a class="code" href="../../d5/d8/ex_8h.html#a222">ExAllocatePoolWithTagPriority</a>(
00420                 <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
00421                 allocateSize,
00422                 ' prI',
00423                 <a class="code" href="../../d5/d8/ex_8h.html#a330a195">HighPoolPrioritySpecialPoolOverrun</a>);
00424         <span class="keywordflow">if</span> (!irp) {
00425             mustSucceed = <a class="code" href="../../d0/d5/io_8h.html#a191">IRP_ALLOCATED_MUST_SUCCEED</a>;
00426             <span class="keywordflow">if</span> (KeGetPreviousMode() == <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a> ) {
00427                 irp = <a class="code" href="../../d5/d8/ex_8h.html#a222">ExAllocatePoolWithTagPriority</a>(
00428                         <a class="code" href="../../d5/d8/ex_8h.html#a329a175">NonPagedPoolMustSucceed</a>,
00429                         allocateSize,
00430                         ' prI',
00431                         <a class="code" href="../../d5/d8/ex_8h.html#a330a195">HighPoolPrioritySpecialPoolOverrun</a>);
00432             }
00433         }
00434     }
00435 
00436     <span class="keywordflow">if</span> (!irp) {
00437         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00438     }
00439 
00440     <span class="comment">//</span>
00441     <span class="comment">// Initialize the packet.</span>
00442     <span class="comment">//</span>
00443 
00444     <a class="code" href="../../d0/d6/iop_8h.html#a20">IopInitializeIrp</a>(irp, packetSize, StackSize);
00445     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o17">AllocationFlags</a> = mustSucceed;
00446     <span class="keywordflow">if</span> (ChargeQuota) {
00447         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o17">AllocationFlags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a190">IRP_QUOTA_CHARGED</a>;
00448     }
00449 
00450     <a class="code" href="../../d9/d4/trackirp_8h.html#a81">SPECIALIRP_IO_ALLOCATE_IRP_2</a>(irp) ;
00451     <span class="keywordflow">return</span> irp;
00452 }
00453 
00454 
<a name="l00455"></a><a class="code" href="../../d6/d6/ioverifier_8c.html#a31">00455</a> <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>
00456 <a class="code" href="../../d6/d6/ioverifier_8c.html#a31">IovBuildAsynchronousFsdRequest</a>(
00457     IN ULONG MajorFunction,
00458     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
00459     IN OUT PVOID Buffer OPTIONAL,
00460     IN ULONG Length OPTIONAL,
00461     IN PLARGE_INTEGER StartingOffset OPTIONAL,
00462     IN PIO_STATUS_BLOCK IoStatusBlock OPTIONAL
00463     )
00464 {
00465     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>    <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>;
00466 
00467     <span class="keywordflow">try</span> {
00468         <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> = <a class="code" href="../../d4/d6/iosubs_8c.html#a24">IoBuildAsynchronousFsdRequest</a>(
00469             MajorFunction,
00470             DeviceObject,
00471             <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>,
00472             Length,
00473             StartingOffset,
00474             IoStatusBlock
00475             );
00476     } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00477          <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a>(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
00478                       <a class="code" href="../../d6/d6/ioverifier_8c.html#a7">IO_BUILD_FSD_REQUEST_EXCEPTION</a>,
00479                       (ULONG_PTR)DeviceObject,
00480                       (ULONG_PTR)MajorFunction,
00481                       GetExceptionCode());
00482     }
00483     <span class="keywordflow">return</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>);
00484 }
00485 
<a name="l00486"></a><a class="code" href="../../d6/d6/ioverifier_8c.html#a32">00486</a> <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>
00487 <a class="code" href="../../d6/d6/ioverifier_8c.html#a32">IovBuildDeviceIoControlRequest</a>(
00488     IN ULONG IoControlCode,
00489     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
00490     IN PVOID InputBuffer OPTIONAL,
00491     IN ULONG InputBufferLength,
00492     OUT PVOID OutputBuffer OPTIONAL,
00493     IN ULONG OutputBufferLength,
00494     IN BOOLEAN InternalDeviceIoControl,
00495     IN <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> Event,
00496     OUT PIO_STATUS_BLOCK IoStatusBlock
00497     )
00498 {
00499     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>    <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>;
00500 
00501     <span class="keywordflow">try</span> {
00502         <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> = <a class="code" href="../../d4/d6/iosubs_8c.html#a25">IoBuildDeviceIoControlRequest</a>(
00503             IoControlCode,
00504             DeviceObject,
00505             InputBuffer,
00506             InputBufferLength,
00507             OutputBuffer,
00508             OutputBufferLength,
00509             InternalDeviceIoControl,
00510             <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>,
00511             IoStatusBlock
00512             );
00513     } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00514          <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a>(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
00515                       <a class="code" href="../../d6/d6/ioverifier_8c.html#a8">IO_BUILD_IOCTL_REQUEST_EXCEPTION</a>,
00516                       (ULONG_PTR)DeviceObject,
00517                       (ULONG_PTR)IoControlCode,
00518                       GetExceptionCode());
00519     }
00520 
00521     <span class="keywordflow">return</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>);
00522 }
00523 
<a name="l00524"></a><a class="code" href="../../d6/d6/ioverifier_8c.html#a33">00524</a> <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00525 <a class="code" href="../../d6/d6/ioverifier_8c.html#a33">IovInitializeTimer</a>(
00526     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
00527     IN PIO_TIMER_ROUTINE TimerRoutine,
00528     IN PVOID Context
00529     )
00530 {
00531     <span class="keywordflow">if</span> (DeviceObject-&gt;Timer) {
00532         <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a>(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
00533                      <a class="code" href="../../d6/d6/ioverifier_8c.html#a9">IO_REINITIALIZING_TIMER_OBJECT</a>,
00534                      (ULONG_PTR)DeviceObject,
00535                      0,
00536                      0);
00537    }
00538    <span class="keywordflow">return</span> (<a class="code" href="../../d4/d6/iosubs_8c.html#a82">IoInitializeTimer</a>(DeviceObject, TimerRoutine, Context));
00539 }
00540 
00541 
<a name="l00542"></a><a class="code" href="../../d7/d6/ioverifier_8h.html#a11">00542</a> <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00543 <a class="code" href="../../d7/d6/ioverifier_8h.html#a11">IovpCompleteRequest</a>(
00544     IN <a class="code" href="../../d1/d5/struct__KAPC.html">PKAPC</a> Apc,
00545     IN PVOID *SystemArgument1,
00546     IN PVOID *SystemArgument2
00547     )
00548 {
00549     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>    irp;
00550     PUCHAR addr;
00551     ULONG   BestStackOffset;
00552 
00553     irp = CONTAINING_RECORD( Apc, <a class="code" href="../../d0/d2/struct__IRP.html">IRP</a>, Tail.Apc );
00554 
00555 <span class="preprocessor">#if defined(_X86_)</span>
00556 <span class="preprocessor"></span>
00557 
00558     addr = (PUCHAR)irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a>;
00559     <span class="keywordflow">if</span> ((addr &gt; (PUCHAR)<a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>()-&gt;StackLimit) &amp;&amp;
00560         (addr &lt;= (PUCHAR)&amp;BestStackOffset)) {
00561         <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a>(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
00562                      <a class="code" href="../../d6/d6/ioverifier_8c.html#a11">IO_INVALID_STACK_IOSB</a>,
00563                      (ULONG_PTR)addr,
00564                      0,
00565                      0);
00566 
00567     }
00568 
00569     addr = (PUCHAR)irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a>;
00570     <span class="keywordflow">if</span> ((addr &gt; (PUCHAR)<a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>()-&gt;StackLimit) &amp;&amp;
00571         (addr &lt;= (PUCHAR)&amp;BestStackOffset)) {
00572         <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a>(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
00573                      <a class="code" href="../../d6/d6/ioverifier_8c.html#a12">IO_INVALID_STACK_EVENT</a>,
00574                      (ULONG_PTR)addr,
00575                      0,
00576                      0);
00577 
00578     }
00579 <span class="preprocessor">#endif</span>
00580 <span class="preprocessor"></span>}
00581 
00582 
00583 <span class="comment">/*-------------------------- SPECIALIRP HOOKS -------------------------------*/</span>
00584 
00585 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00586"></a><a class="code" href="../../d7/d6/ioverifier_8h.html#a9">00586</a> <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
00587 <a class="code" href="../../d7/d6/ioverifier_8h.html#a9">IovSpecialIrpCompleteRequest</a>(
00588     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
00589     IN CCHAR PriorityBoost
00590     )
00591 <span class="comment">/*++</span>
00592 <span class="comment"></span>
00593 <span class="comment">Routine Description:</span>
00594 <span class="comment"></span>
00595 <span class="comment">    The following code is called only when doing IRP tracking. It duplicates code</span>
00596 <span class="comment">    in iosubs.c.</span>
00597 <span class="comment">    This routine is invoked to complete an I/O request.  It is invoked by the</span>
00598 <span class="comment">    driver in its DPC routine to perform the final completion of the IRP.  The</span>
00599 <span class="comment">    functions performed by this routine are as follows.</span>
00600 <span class="comment"></span>
00601 <span class="comment">        1.  A check is made to determine whether the packet's stack locations</span>
00602 <span class="comment">            have been exhausted.  If not, then the stack location pointer is set</span>
00603 <span class="comment">            to the next location and if there is a routine to be invoked, then</span>
00604 <span class="comment">            it will be invoked.  This continues until there are either no more</span>
00605 <span class="comment">            routines which are interested or the packet runs out of stack.</span>
00606 <span class="comment"></span>
00607 <span class="comment">            If a routine is invoked to complete the packet for a specific driver</span>
00608 <span class="comment">            which needs to perform work a lot of work or the work needs to be</span>
00609 <span class="comment">            performed in the context of another process, then the routine will</span>
00610 <span class="comment">            return an alternate success code of STATUS_MORE_PROCESSING_REQUIRED.</span>
00611 <span class="comment">            This indicates that this completion routine should simply return to</span>
00612 <span class="comment">            its caller because the operation will be "completed" by this routine</span>
00613 <span class="comment">            again sometime in the future.</span>
00614 <span class="comment"></span>
00615 <span class="comment">        2.  A check is made to determine whether this IRP is an associated IRP.</span>
00616 <span class="comment">            If it is, then the count on the master IRP is decremented.  If the</span>
00617 <span class="comment">            count for the master becomes zero, then the master IRP will be</span>
00618 <span class="comment">            completed according to the steps below taken for a normal IRP being</span>
00619 <span class="comment">            completed.  If the count is still non-zero, then this IRP (the one</span>
00620 <span class="comment">            being completed) will simply be deallocated.</span>
00621 <span class="comment"></span>
00622 <span class="comment">        3.  If this is paging I/O or a close operation, then simply write the</span>
00623 <span class="comment">            I/O status block and set the event to the signaled state, and</span>
00624 <span class="comment">            dereference the event.  If this is paging I/O, deallocate the IRP</span>
00625 <span class="comment">            as well.</span>
00626 <span class="comment"></span>
00627 <span class="comment">        4.  Unlock the pages, if any, specified by the MDL by calling</span>
00628 <span class="comment">            MmUnlockPages.</span>
00629 <span class="comment"></span>
00630 <span class="comment">        5.  A check is made to determine whether or not completion of the</span>
00631 <span class="comment">            request can be deferred until later.  If it can be, then this</span>
00632 <span class="comment">            routine simply exits and leaves it up to the originator of the</span>
00633 <span class="comment">            request to fully complete the IRP.  By not initializing and queueing</span>
00634 <span class="comment">            the special kernel APC to the calling thread (which is the current</span>
00635 <span class="comment">            thread by definition), a lot of interrupt and queueing processing</span>
00636 <span class="comment">            can be avoided.</span>
00637 <span class="comment"></span>
00638 <span class="comment"></span>
00639 <span class="comment">        6.  The final rundown routine is invoked to queue the request packet to</span>
00640 <span class="comment">            the target (requesting) thread as a special kernel mode APC.</span>
00641 <span class="comment"></span>
00642 <span class="comment">Arguments:</span>
00643 <span class="comment"></span>
00644 <span class="comment">    Irp - Pointer to the I/O Request Packet to complete.</span>
00645 <span class="comment"></span>
00646 <span class="comment">    PriorityBoost - Supplies the amount of priority boost that is to be given</span>
00647 <span class="comment">        to the target thread when the special kernel APC is queued.</span>
00648 <span class="comment"></span>
00649 <span class="comment">Return Value:</span>
00650 <span class="comment"></span>
00651 <span class="comment">    None.</span>
00652 <span class="comment"></span>
00653 <span class="comment">--*/</span>
00654 
00655 #define <a class="code" href="../../d6/d6/ioverifier_8c.html#a15">ZeroAndDopeIrpStackLocation</a>( IrpSp ) {  \
00656     (IrpSp)-&gt;MinorFunction = 0;                 \
00657     (IrpSp)-&gt;Flags = 0;                         \
00658     (IrpSp)-&gt;Control = <a class="code" href="../../d9/d4/trackirp_8h.html#a60">SL_NOTCOPIED</a>;            \
00659     (IrpSp)-&gt;Parameters.Others.Argument1 = 0;   \
00660     (IrpSp)-&gt;Parameters.Others.Argument2 = 0;   \
00661     (IrpSp)-&gt;Parameters.Others.Argument3 = 0;   \
00662     (IrpSp)-&gt;Parameters.Others.Argument4 = 0;   \
00663     (IrpSp)-&gt;FileObject = (<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>; }
00664 
00665 {
00666     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> masterIrp;
00667     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
00668     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> stackPointer;
00669     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> mdl;
00670     <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a> thread;
00671     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> fileObject;
00672     KIRQL irql;
00673     PVOID saveAuxiliaryPointer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00674 
00675 <span class="preprocessor">#ifndef NO_SPECIAL_IRP</span>
00676 <span class="preprocessor"></span>    PVOID routine ;
00677     <a class="code" href="../../d4/d0/struct__IOFCOMPLETEREQUEST__STACKDATA.html">IOFCOMPLETEREQUEST_STACKDATA</a> completionPacket;
00678 <span class="preprocessor">#endif</span>
00679 <span class="preprocessor"></span>
00680     <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d6/iop_8h.html#a132">IopVerifierOn</a>) {
00681         <a class="code" href="../../d4/d6/iosubs_8c.html#a40">IopfCompleteRequest</a>(Irp, PriorityBoost);
00682         <span class="keywordflow">return</span>;
00683     }
00684 
00685 <span class="preprocessor">#if DBG</span>
00686 <span class="preprocessor"></span>
00687     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a> &lt;= (CCHAR) <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o12">StackCount</a>) {
00688 
00689         stackPointer = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>(Irp);
00690         <span class="keywordflow">if</span> (stackPointer-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> == <a class="code" href="../../d0/d5/io_8h.html#a35">IRP_MJ_POWER</a>) {
00691             <a class="code" href="../../d1/d2/po_8h.html#a0">PoPowerTrace</a>(
00692                 POWERTRACE_COMPLETE,
00693                 <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>(Irp)-&gt;DeviceObject,
00694                 Irp,
00695                 <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>(Irp)
00696                 );
00697         }
00698     }
00699 
00700 <span class="preprocessor">#endif</span>
00701 <span class="preprocessor"></span>
00702     <a class="code" href="../../d9/d4/trackirp_8h.html#a72">SPECIALIRP_IOF_COMPLETE_1</a>(Irp, PriorityBoost, &amp;completionPacket);
00703 
00704     <span class="comment">//</span>
00705     <span class="comment">// Begin by ensuring that this packet has not already been completed</span>
00706     <span class="comment">// by someone.</span>
00707     <span class="comment">//</span>
00708 
00709     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a> &gt; (CCHAR) (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o12">StackCount</a> + 1) ||
00710         <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o0">Type</a> != <a class="code" href="../../d0/d5/io_8h.html#a5">IO_TYPE_IRP</a>) {
00711         <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a>( MULTIPLE_IRP_COMPLETE_REQUESTS, (ULONG_PTR) Irp, __LINE__, 0, 0 );
00712     }
00713 
00714     <span class="comment">//</span>
00715     <span class="comment">// Ensure that the packet being completed really is still an IRP.</span>
00716     <span class="comment">//</span>
00717 
00718     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o0">Type</a> != <a class="code" href="../../d0/d5/io_8h.html#a5">IO_TYPE_IRP</a>) {
00719 
00720         <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a>(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
00721                      IO_CALL_DRIVER_IRP_TYPE_INVALID,
00722                      (ULONG_PTR)Irp,
00723                      0,
00724                      0);
00725     }
00726 
00727     <span class="comment">//</span>
00728     <span class="comment">// Ensure that no one believes that this request is still in a cancellable</span>
00729     <span class="comment">// state.</span>
00730     <span class="comment">//</span>
00731 
00732     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o25">CancelRoutine</a>) {
00733 
00734         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o25">CancelRoutine</a> == NULL);
00735 
00736         <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a>(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
00737                      IO_COMPLETE_REQUEST_CANCEL_ROUTINE_SET,
00738                      (ULONG_PTR)<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o25">CancelRoutine</a>,
00739                      (ULONG_PTR)Irp,
00740                      0);
00741     }
00742 
00743     <span class="comment">//</span>
00744     <span class="comment">// Ensure that the packet is not being completed with a thoroughly</span>
00745     <span class="comment">// confusing status code.  Actually completing a packet with a pending</span>
00746     <span class="comment">// status probably means that someone forgot to set the real status in</span>
00747     <span class="comment">// the packet.</span>
00748 
00749     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status == STATUS_PENDING) {
00750 
00751 
00752          <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a>(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
00753                       IO_COMPLETE_REQUEST_INVALID_STATUS,
00754                       <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status,
00755                       (ULONG_PTR)Irp,
00756                       0);
00757     }
00758 
00759     <span class="comment">//</span>
00760     <span class="comment">// Ensure that the packet is not being completed with a minus one.  This is</span>
00761     <span class="comment">// apparently a common problem in some drivers, and has no meaning as a</span>
00762     <span class="comment">// status code.</span>
00763     <span class="comment">//</span>
00764 
00765     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status == 0xffffffff) {
00766 
00767 
00768          <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a>(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
00769                       IO_COMPLETE_REQUEST_INVALID_STATUS,
00770                       <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status,
00771                       (ULONG_PTR)Irp,
00772                       0);
00773     }
00774 
00775     <span class="comment">//</span>
00776     <span class="comment">// Ensure that if this is a paging I/O operation, and it failed, that the</span>
00777     <span class="comment">// reason for the failure isn't because quota was exceeded.</span>
00778     <span class="comment">//</span>
00779 
00780     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( !(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; IRP_PAGING_IO &amp;&amp; <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status == STATUS_QUOTA_EXCEEDED ) );
00781 
00782 <span class="preprocessor">#ifndef NO_SPECIAL_IRP</span>
00783 <span class="preprocessor"></span>
00784     <span class="keywordflow">if</span> (!<a class="code" href="../../d8/d4/trackirp_8c.html#a7">IovpTrackingFlags</a>) {
00785 
00786         <a class="code" href="../../d4/d6/iosubs_8c.html#a40">IopfCompleteRequest</a>(Irp, PriorityBoost);
00787         <span class="keywordflow">return</span>;
00788     }
00789 
00790     <span class="comment">//</span>
00791     <span class="comment">// Now check to see whether this is the last driver that needs to be</span>
00792     <span class="comment">// invoked for this packet.  If not, then bump the stack and check to</span>
00793     <span class="comment">// see whether the driver wishes to see the completion.  As each stack</span>
00794     <span class="comment">// location is examined, invoke any routine which needs to be invoked.</span>
00795     <span class="comment">// If the routine returns STATUS_MORE_PROCESSING_REQUIRED, then stop the</span>
00796     <span class="comment">// processing of this packet.</span>
00797     <span class="comment">//</span>
00798 
00799     <span class="keywordflow">for</span> (stackPointer = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( Irp ),
00800          <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a>++,
00801          <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.CurrentStackLocation++;
00802          <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a> &lt;= (CCHAR) (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o12">StackCount</a> + 1);
00803          stackPointer++,
00804          <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a>++,
00805          <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.CurrentStackLocation++) {
00806 
00807         <span class="comment">//</span>
00808         <span class="comment">// A stack location was located.  Check to see whether or not it</span>
00809         <span class="comment">// has a completion routine and if so, whether or not it should be</span>
00810         <span class="comment">// invoked.</span>
00811         <span class="comment">//</span>
00812         <span class="comment">// Begin by saving the pending returned flag in the current stack</span>
00813         <span class="comment">// location in the fixed part of the IRP.</span>
00814         <span class="comment">//</span>
00815 
00816         <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o11">PendingReturned</a> = stackPointer-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o3">Control</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a194">SL_PENDING_RETURNED</a>;
00817 
00818         <a class="code" href="../../d9/d4/trackirp_8h.html#a73">SPECIALIRP_IOF_COMPLETE_2</a>(Irp, &amp;completionPacket);
00819 
00820         <span class="keywordflow">if</span> ( (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status ) &amp;&amp;
00821              stackPointer-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o3">Control</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a196">SL_INVOKE_ON_SUCCESS</a>) ||
00822              (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status ) &amp;&amp;
00823              stackPointer-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o3">Control</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a197">SL_INVOKE_ON_ERROR</a>) ||
00824              (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o14">Cancel</a> &amp;&amp;
00825              stackPointer-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o3">Control</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a195">SL_INVOKE_ON_CANCEL</a>)
00826            ) {
00827 
00828             <span class="comment">//</span>
00829             <span class="comment">// This driver has specified a completion routine.  Invoke the</span>
00830             <span class="comment">// routine passing it a pointer to its device object and the</span>
00831             <span class="comment">// IRP that is being completed.</span>
00832             <span class="comment">//</span>
00833 
00834             <a class="code" href="../../d6/d6/ioverifier_8c.html#a15">ZeroAndDopeIrpStackLocation</a>( stackPointer );
00835 
00836 <span class="preprocessor">#ifndef NO_SPECIAL_IRP</span>
00837 <span class="preprocessor"></span>            routine = stackPointer-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o116">CompletionRoutine</a> ;
00838             <a class="code" href="../../d9/d4/trackirp_8h.html#a74">SPECIALIRP_IOF_COMPLETE_3</a>(Irp, routine, &amp;completionPacket);
00839 <span class="preprocessor">#endif</span>
00840 <span class="preprocessor"></span>
00841             <a class="code" href="../../d2/d1/mm_8h.html#a43">PERFINFO_DRIVER_COMPLETIONROUTINE_CALL</a>(Irp, stackPointer);
00842 
00843             status = stackPointer-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o116">CompletionRoutine</a>( (<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>) (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a> == (CCHAR) (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o12">StackCount</a> + 1) ?
00844                                                       (<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>) NULL :
00845                                                       <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( Irp )-&gt;DeviceObject),
00846                                                       Irp,
00847                                                       stackPointer-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o117">Context</a> );
00848 
00849             <a class="code" href="../../d2/d1/mm_8h.html#a44">PERFINFO_DRIVER_COMPLETIONROUTINE_RETURN</a>(Irp, stackPointer);
00850 
00851             <a class="code" href="../../d9/d4/trackirp_8h.html#a75">SPECIALIRP_IOF_COMPLETE_4</a>(Irp, status, &amp;completionPacket);
00852 
00853             <span class="keywordflow">if</span> (status == STATUS_MORE_PROCESSING_REQUIRED) {
00854 
00855                 <span class="comment">//</span>
00856                 <span class="comment">// Note:  Notice that if the driver has returned the above</span>
00857                 <span class="comment">//        status value, it may have already DEALLOCATED the</span>
00858                 <span class="comment">//        packet!  Therefore, do NOT touch any part of the</span>
00859                 <span class="comment">//        IRP in the following code.</span>
00860                 <span class="comment">//</span>
00861 
00862                 <a class="code" href="../../d9/d4/trackirp_8h.html#a76">SPECIALIRP_IOF_COMPLETE_5</a>(Irp, &amp;completionPacket);
00863                 <span class="keywordflow">return</span>;
00864             }
00865 
00866         } <span class="keywordflow">else</span> {
00867             <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o11">PendingReturned</a> &amp;&amp; <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a> &lt;= <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o12">StackCount</a>) {
00868                 <a class="code" href="../../d0/d5/io_8h.html#a234">IoMarkIrpPending</a>( Irp );
00869             }
00870             <a class="code" href="../../d6/d6/ioverifier_8c.html#a15">ZeroAndDopeIrpStackLocation</a>( stackPointer );
00871         }
00872 
00873         <a class="code" href="../../d9/d4/trackirp_8h.html#a76">SPECIALIRP_IOF_COMPLETE_5</a>(Irp, &amp;completionPacket);
00874     }
00875 
00876     <span class="comment">//</span>
00877     <span class="comment">// Check to see whether this is an associated IRP.  If so, then decrement</span>
00878     <span class="comment">// the count in the master IRP.  If the count is decremented to zero,</span>
00879     <span class="comment">// then complete the master packet as well.</span>
00880     <span class="comment">//</span>
00881 
00882     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a177">IRP_ASSOCIATED_IRP</a>) {
00883         ULONG count;
00884         masterIrp = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.MasterIrp;
00885         count = <a class="code" href="../../d5/d8/ex_8h.html#a235">ExInterlockedAddUlong</a>( (PULONG) &amp;masterIrp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.IrpCount,
00886                                        0xffffffff,
00887                                        &amp;IopDatabaseLock );
00888 
00889         <span class="comment">//</span>
00890         <span class="comment">// Deallocate this packet and any MDLs that are associated with it</span>
00891         <span class="comment">// by either doing direct deallocations if they were allocated from</span>
00892         <span class="comment">// a zone or by queueing the packet to a thread to perform the</span>
00893         <span class="comment">// deallocation.</span>
00894         <span class="comment">//</span>
00895         <span class="comment">// Also, check the count of the master IRP to determine whether or not</span>
00896         <span class="comment">// the count has gone to zero.  If not, then simply get out of here.</span>
00897         <span class="comment">// Otherwise, complete the master packet.</span>
00898         <span class="comment">//</span>
00899 
00900         <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread = masterIrp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread;
00901         <a class="code" href="../../d0/d6/iop_8h.html#a172">IopFreeIrpAndMdls</a>( Irp );
00902         <span class="keywordflow">if</span> (count == 1) {
00903             <a class="code" href="../../d0/d5/io_8h.html#a224">IoCompleteRequest</a>( masterIrp, PriorityBoost );
00904         }
00905         <span class="keywordflow">return</span>;
00906     }
00907 
00908     <span class="comment">//</span>
00909     <span class="comment">// Check to see if we have a name junction. If so set the stage to</span>
00910     <span class="comment">// transmogrify the reparse point data in IopCompleteRequest.</span>
00911     <span class="comment">//</span>
00912 
00913     <span class="keywordflow">if</span> ((<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status == STATUS_REPARSE )  &amp;&amp;
00914         (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information &gt; IO_REPARSE_TAG_RESERVED_RANGE)) {
00915 
00916         <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information == IO_REPARSE_TAG_MOUNT_POINT) {
00917 
00918             <span class="comment">//</span>
00919             <span class="comment">// For name junctions, we save the pointer to the auxiliary</span>
00920             <span class="comment">// buffer and use it below.</span>
00921             <span class="comment">//</span>
00922 
00923             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.AuxiliaryBuffer != NULL );
00924 
00925             saveAuxiliaryPointer = (PVOID) <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.AuxiliaryBuffer;
00926 
00927             <span class="comment">//</span>
00928             <span class="comment">// We NULL the entry to avoid its de-allocation at this time.</span>
00929             <span class="comment">// This buffer get deallocated in IopDoNameTransmogrify</span>
00930             <span class="comment">//</span>
00931 
00932             <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.AuxiliaryBuffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00933         } <span class="keywordflow">else</span> {
00934 
00935             <span class="comment">//</span>
00936             <span class="comment">// Fail the request. A driver needed to act on this IRP prior</span>
00937             <span class="comment">// to getting to this point.</span>
00938             <span class="comment">//</span>
00939 
00940             <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status = STATUS_IO_REPARSE_TAG_NOT_HANDLED;
00941         }
00942     }
00943 
00944     <span class="comment">//</span>
00945     <span class="comment">// Check the auxiliary buffer pointer in the packet and if a buffer was</span>
00946     <span class="comment">// allocated, deallocate it now.  Note that this buffer must be freed</span>
00947     <span class="comment">// here since the pointer is overlayed with the APC that will be used</span>
00948     <span class="comment">// to get to the requesting thread's context.</span>
00949     <span class="comment">//</span>
00950 
00951     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.AuxiliaryBuffer) {
00952         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.AuxiliaryBuffer );
00953         <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.AuxiliaryBuffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00954     }
00955 
00956     <span class="comment">//</span>
00957     <span class="comment">// Check to see if this is paging I/O or a close operation.  If either,</span>
00958     <span class="comment">// then special processing must be performed.  The reasons that special</span>
00959     <span class="comment">// processing must be performed is different based on the type of</span>
00960     <span class="comment">// operation being performed.  The biggest reasons for special processing</span>
00961     <span class="comment">// on paging operations are that using a special kernel APC for an in-</span>
00962     <span class="comment">// page operation cannot work since the special kernel APC can incur</span>
00963     <span class="comment">// another pagefault.  Likewise, all paging I/O uses MDLs that belong</span>
00964     <span class="comment">// to the memory manager, not the I/O system.</span>
00965     <span class="comment">//</span>
00966     <span class="comment">// Close operations are special because the close may have been invoked</span>
00967     <span class="comment">// because of a special kernel APC (some IRP was completed which caused</span>
00968     <span class="comment">// the reference count on the object to become zero while in the I/O</span>
00969     <span class="comment">// system's special kernel APC routine).  Therefore, a special kernel APC</span>
00970     <span class="comment">// cannot be used since it cannot execute until the close APC finishes.</span>
00971     <span class="comment">//</span>
00972     <span class="comment">// The special steps are as follows for a synchronous paging operation</span>
00973     <span class="comment">// and close are:</span>
00974     <span class="comment">//</span>
00975     <span class="comment">//     1.  Copy the I/O status block (it is in SVAS, nonpaged).</span>
00976     <span class="comment">//     2.  Signal the event</span>
00977     <span class="comment">//     3.  If paging I/O, deallocate the IRP</span>
00978     <span class="comment">//</span>
00979     <span class="comment">// The special steps taken for asynchronous paging operations (out-pages)</span>
00980     <span class="comment">// are as follows:</span>
00981     <span class="comment">//</span>
00982     <span class="comment">//     1.  Initialize a special kernel APC just for page writes.</span>
00983     <span class="comment">//     1.  Queue the special kernel APC.</span>
00984     <span class="comment">//</span>
00985     <span class="comment">// It should also be noted that the logic for completing a Mount request</span>
00986     <span class="comment">// operation is exactly the same as a Page Read.  No assumptions should be</span>
00987     <span class="comment">// made here about this being a Page Read operation w/o carefully checking</span>
00988     <span class="comment">// to ensure that they are also true for a Mount.  That is:</span>
00989     <span class="comment">//</span>
00990     <span class="comment">//     IRP_PAGING_IO  and  IRP_MOUNT_COMPLETION</span>
00991     <span class="comment">//</span>
00992     <span class="comment">// are the same flag in the IRP.</span>
00993     <span class="comment">//</span>
00994     <span class="comment">// Also note that the last time the IRP is touched for a close operation</span>
00995     <span class="comment">// must be just before the event is set to the signaled state.  Once this</span>
00996     <span class="comment">// occurs, the IRP can be deallocated by the thread waiting for the event.</span>
00997     <span class="comment">//</span>
00998 
00999     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; (<a class="code" href="../../d0/d5/io_8h.html#a174">IRP_PAGING_IO</a> | <a class="code" href="../../d0/d5/io_8h.html#a185">IRP_CLOSE_OPERATION</a>)) {
01000         <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; (<a class="code" href="../../d0/d5/io_8h.html#a181">IRP_SYNCHRONOUS_PAGING_IO</a> | <a class="code" href="../../d0/d5/io_8h.html#a185">IRP_CLOSE_OPERATION</a>)) {
01001             ULONG flags;
01002 
01003             flags = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a181">IRP_SYNCHRONOUS_PAGING_IO</a>;
01004             *<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>;
01005             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a>, PriorityBoost, FALSE );
01006             <span class="keywordflow">if</span> (flags) {
01007                 <a class="code" href="../../d4/d6/iosubs_8c.html#a63">IoFreeIrp</a>( Irp );
01008             }
01009         } <span class="keywordflow">else</span> {
01010             thread = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread;
01011             <a class="code" href="../../d5/d7/apcobj_8c.html#a1">KeInitializeApc</a>( &amp;<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Apc,
01012                              &amp;thread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o0">Tcb</a>,
01013                              <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o16">ApcEnvironment</a>,
01014                              IopCompletePageWrite,
01015                              (PKRUNDOWN_ROUTINE) NULL,
01016                              (PKNORMAL_ROUTINE) NULL,
01017                              KernelMode,
01018                              (PVOID) NULL );
01019             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d5/d7/apcobj_8c.html#a3">KeInsertQueueApc</a>( &amp;<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Apc,
01020                                      (PVOID) NULL,
01021                                      (PVOID) NULL,
01022                                      PriorityBoost );
01023         }
01024         <span class="keywordflow">return</span>;
01025     }
01026 
01027     <span class="comment">//</span>
01028     <span class="comment">// Check to see whether any pages need to be unlocked.</span>
01029     <span class="comment">//</span>
01030 
01031     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01032 
01033         <span class="comment">//</span>
01034         <span class="comment">// Unlock any pages that may be described by MDLs.</span>
01035         <span class="comment">//</span>
01036 
01037         mdl = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a>;
01038         <span class="keywordflow">while</span> (mdl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01039             <a class="code" href="../../d5/d6/iosup_8c.html#a45">MmUnlockPages</a>( mdl );
01040             mdl = mdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o0">Next</a>;
01041         }
01042     }
01043 
01044     <span class="comment">//</span>
01045     <span class="comment">// Make a final check here to determine whether or not this is a</span>
01046     <span class="comment">// synchronous I/O operation that is being completed in the context</span>
01047     <span class="comment">// of the original requestor.  If so, then an optimal path through</span>
01048     <span class="comment">// I/O completion can be taken.</span>
01049     <span class="comment">//</span>
01050 
01051     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a186">IRP_DEFER_IO_COMPLETION</a> &amp;&amp; !<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o11">PendingReturned</a>) {
01052 
01053         <span class="keywordflow">if</span> ((<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status == STATUS_REPARSE )  &amp;&amp;
01054             (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information == IO_REPARSE_TAG_MOUNT_POINT)) {
01055 
01056             <span class="comment">//</span>
01057             <span class="comment">// For name junctions we reinstate the address of the appropriate</span>
01058             <span class="comment">// buffer. It is freed in parse.c</span>
01059             <span class="comment">//</span>
01060 
01061             <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.AuxiliaryBuffer = saveAuxiliaryPointer;
01062         }
01063 
01064         <span class="keywordflow">return</span>;
01065     }
01066 
01067     <span class="comment">//</span>
01068     <span class="comment">// Finally, initialize the IRP as an APC structure and queue the special</span>
01069     <span class="comment">// kernel APC to the target thread.</span>
01070     <span class="comment">//</span>
01071 
01072     thread = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread;
01073     fileObject = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.OriginalFileObject;
01074 
01075     <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o14">Cancel</a>) {
01076 
01077         <a class="code" href="../../d5/d7/apcobj_8c.html#a1">KeInitializeApc</a>( &amp;<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Apc,
01078                          &amp;thread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o0">Tcb</a>,
01079                          <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o16">ApcEnvironment</a>,
01080                          IopCompleteRequest,
01081                          IopAbortRequest,
01082                          (PKNORMAL_ROUTINE) NULL,
01083                          KernelMode,
01084                          (PVOID) NULL );
01085 
01086         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d5/d7/apcobj_8c.html#a3">KeInsertQueueApc</a>( &amp;<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Apc,
01087                                  fileObject,
01088                                  (PVOID) saveAuxiliaryPointer,
01089                                  PriorityBoost );
01090     } <span class="keywordflow">else</span> {
01091 
01092         <span class="comment">//</span>
01093         <span class="comment">// This request has been cancelled.  Ensure that access to the thread</span>
01094         <span class="comment">// is synchronized, otherwise it may go away while attempting to get</span>
01095         <span class="comment">// through the remainder of completion for this request.  This happens</span>
01096         <span class="comment">// when the thread times out waiting for the request to be completed</span>
01097         <span class="comment">// once it has been cancelled.</span>
01098         <span class="comment">//</span>
01099         <span class="comment">// Note that it is safe to capture the thread pointer above, w/o having</span>
01100         <span class="comment">// the lock because the cancel flag was not set at that point, and</span>
01101         <span class="comment">// the code that disassociates IRPs must set the flag before looking to</span>
01102         <span class="comment">// see whether or not the packet has been completed, and this packet</span>
01103         <span class="comment">// will appear to be completed because it no longer belongs to a driver.</span>
01104         <span class="comment">//</span>
01105 
01106         ExAcquireSpinLock( &amp;IopCompletionLock, &amp;irql );
01107 
01108         thread = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread;
01109 
01110         <span class="keywordflow">if</span> (thread) {
01111 
01112             <a class="code" href="../../d5/d7/apcobj_8c.html#a1">KeInitializeApc</a>( &amp;<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Apc,
01113                              &amp;thread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o0">Tcb</a>,
01114                              <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o16">ApcEnvironment</a>,
01115                              IopCompleteRequest,
01116                              IopAbortRequest,
01117                              (PKNORMAL_ROUTINE) NULL,
01118                              KernelMode,
01119                              (PVOID) NULL );
01120 
01121             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d5/d7/apcobj_8c.html#a3">KeInsertQueueApc</a>( &amp;<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Apc,
01122                                      fileObject,
01123                                      (PVOID) saveAuxiliaryPointer,
01124                                      PriorityBoost );
01125 
01126             ExReleaseSpinLock( &amp;IopCompletionLock, irql );
01127 
01128         } <span class="keywordflow">else</span> {
01129 
01130             <span class="comment">//</span>
01131             <span class="comment">// This request has been aborted from completing in the caller's</span>
01132             <span class="comment">// thread.  This can only occur if the packet was cancelled, and</span>
01133             <span class="comment">// the driver did not complete the request, so it was timed out.</span>
01134             <span class="comment">// Attempt to drop things on the floor, since the originating thread</span>
01135             <span class="comment">// has probably exited at this point.</span>
01136             <span class="comment">//</span>
01137 
01138             ExReleaseSpinLock( &amp;IopCompletionLock, irql );
01139 
01140             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o14">Cancel</a> );
01141 
01142             <span class="comment">//</span>
01143             <span class="comment">// Drop the IRP on the floor.</span>
01144             <span class="comment">//</span>
01145 
01146             <a class="code" href="../../d0/d6/iop_8h.html#a168">IopDropIrp</a>( Irp, fileObject );
01147 
01148         }
01149     }
01150 <span class="preprocessor">#else</span>
01151 <span class="preprocessor"></span>
01152     <a class="code" href="../../d4/d6/iosubs_8c.html#a40">IopfCompleteRequest</a>(Irp, PriorityBoost);
01153     <span class="keywordflow">return</span>;
01154 
01155 <span class="preprocessor">#endif</span>
01156 <span class="preprocessor"></span>}
01157 
01158 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01159"></a><a class="code" href="../../d7/d6/ioverifier_8h.html#a8">01159</a> <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
01160 <a class="code" href="../../d7/d6/ioverifier_8h.html#a8">IovSpecialIrpCallDriver</a>(
01161     IN  <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>  DeviceObject,
01162     IN  OUT <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>    Irp
01163     )
01164 <span class="comment">/*++</span>
01165 <span class="comment"></span>
01166 <span class="comment">Routine Description:</span>
01167 <span class="comment"></span>
01168 <span class="comment">    This routine is invoked to pass an I/O Request Packet (IRP) to another</span>
01169 <span class="comment">    driver at its dispatch routine. This routine is called only for IRP tracking</span>
01170 <span class="comment">    It duplicates the code in iosubs.c.</span>
01171 <span class="comment"></span>
01172 <span class="comment">Arguments:</span>
01173 <span class="comment"></span>
01174 <span class="comment">    DeviceObject - Pointer to device object to which the IRP should be passed.</span>
01175 <span class="comment"></span>
01176 <span class="comment">    Irp - Pointer to IRP for request.</span>
01177 <span class="comment"></span>
01178 <span class="comment">Return Value:</span>
01179 <span class="comment"></span>
01180 <span class="comment">    Return status from driver's dispatch routine.</span>
01181 <span class="comment"></span>
01182 <span class="comment">--*/</span>
01183 
01184 {
01185     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
01186     <a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html">PDRIVER_OBJECT</a> driverObject;
01187     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
01188     KIRQL saveIrql;
01189     <a class="code" href="../../d0/d5/io_8h.html#a287">PDRIVER_DISPATCH</a> dispatchRoutine;
01190     <a class="code" href="../../d3/d0/struct__IOFCALLDRIVER__STACKDATA.html">IOFCALLDRIVER_STACKDATA</a> iofCallDriverStackData ;
01191 
01192     <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d6/iop_8h.html#a132">IopVerifierOn</a>) {
01193         status = <a class="code" href="../../d4/d6/iosubs_8c.html#a28">IopfCallDriver</a>(DeviceObject, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>);
01194         <span class="keywordflow">return</span> status;
01195     }
01196 
01197     <span class="comment">//</span>
01198     <span class="comment">// Ensure that this is really an I/O Request Packet.</span>
01199     <span class="comment">//</span>
01200 
01201     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o0">Type</a> != <a class="code" href="../../d0/d5/io_8h.html#a5">IO_TYPE_IRP</a>) {
01202 
01203         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o0">Type</a> == <a class="code" href="../../d0/d5/io_8h.html#a5">IO_TYPE_IRP</a>);
01204         <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a>(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
01205                      <a class="code" href="../../d6/d6/ioverifier_8c.html#a2">IO_CALL_DRIVER_IRP_TYPE_INVALID</a>,
01206                      (ULONG_PTR)<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>,
01207                      0,
01208                      0);
01209     }
01210 
01211     <span class="keywordflow">if</span> (!<a class="code" href="../../d6/d6/ioverifier_8c.html#a24">IovpValidateDeviceObject</a>(DeviceObject)) {
01212         <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a>(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
01213                      <a class="code" href="../../d6/d6/ioverifier_8c.html#a3">IO_CALL_DRIVER_INVALID_DEVICE_OBJECT</a>,
01214                      (ULONG_PTR)DeviceObject,
01215                      0,
01216                      0);
01217     }
01218 
01219     <a class="code" href="../../d9/d4/trackirp_8h.html#a70">SPECIALIRP_IOF_CALL_1</a>(&amp;<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, DeviceObject, &amp;iofCallDriverStackData) ;
01220 
01221     <span class="comment">//</span>
01222     <span class="comment">// Update the IRP stack to point to the next location.</span>
01223     <span class="comment">//</span>
01224     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a>--;
01225 
01226     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a> &lt;= 0) {
01227         <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a>( NO_MORE_IRP_STACK_LOCATIONS, (ULONG_PTR) <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, 0, 0, 0 );
01228     }
01229 
01230     irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
01231     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.CurrentStackLocation = irpSp;
01232 
01233     <span class="comment">//</span>
01234     <span class="comment">// Save a pointer to the device object for this request so that it can</span>
01235     <span class="comment">// be used later in completion.</span>
01236     <span class="comment">//</span>
01237 
01238     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o57">DeviceObject</a> = DeviceObject;
01239 
01240     <span class="comment">//</span>
01241     <span class="comment">// Invoke the driver at its dispatch routine entry point.</span>
01242     <span class="comment">//</span>
01243 
01244     driverObject = DeviceObject-&gt;DriverObject;
01245 
01246     dispatchRoutine = driverObject-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o14">MajorFunction</a>[irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a>] ;
01247 
01248     saveIrql = KeGetCurrentIrql();
01249 
01250     <a class="code" href="../../d2/d1/mm_8h.html#a47">PERFINFO_DRIVER_MAJORFUNCTION_CALL</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, irpSp, driverObject);
01251 
01252     status = dispatchRoutine( DeviceObject, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
01253 
01254     <a class="code" href="../../d2/d1/mm_8h.html#a48">PERFINFO_DRIVER_MAJORFUNCTION_RETURN</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, irpSp, driverObject);
01255 
01256     <span class="keywordflow">if</span> (saveIrql != KeGetCurrentIrql()) {
01257 
01258         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( <span class="stringliteral">"IO: IoCallDriver( Driver object: %p  Device object: %p  Irp: %p )\n"</span>,
01259                   driverObject,
01260                   DeviceObject,
01261                   <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>
01262                 );
01263         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( <span class="stringliteral">"    Irql before: %x  != After: %x\n"</span>, saveIrql, KeGetCurrentIrql() );
01264 
01265         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(saveIrql == KeGetCurrentIrql());
01266 
01267         <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a>(DRIVER_VERIFIER_IOMANAGER_VIOLATION,
01268                      <a class="code" href="../../d6/d6/ioverifier_8c.html#a4">IO_CALL_DRIVER_IRQL_NOT_EQUAL</a>,
01269                      saveIrql,
01270                      KeGetCurrentIrql(),
01271                      0);
01272     }
01273 
01274     <a class="code" href="../../d9/d4/trackirp_8h.html#a71">SPECIALIRP_IOF_CALL_2</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, DeviceObject, dispatchRoutine, &amp;status, &amp;iofCallDriverStackData) ;
01275 
01276     <span class="keywordflow">return</span> status;
01277 }
01278 
<a name="l01279"></a><a class="code" href="../../d7/d6/ioverifier_8h.html#a12">01279</a> <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01280 <a class="code" href="../../d7/d6/ioverifier_8h.html#a12">IovInitializeIrp</a>(
01281     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>    Irp,
01282     USHORT  PacketSize,
01283     CCHAR   StackSize
01284     )
01285 {
01286     BOOLEAN initializeHandled ;
01287 
01288     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a57">IovpVerifierLevel</a> &lt; 2) {
01289         <span class="keywordflow">return</span>;
01290     }
01291 
01292     <a class="code" href="../../d9/d4/trackirp_8h.html#a82">SPECIALIRP_IO_INITIALIZE_IRP</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, PacketSize, StackSize, &amp;initializeHandled) ;
01293 
01294 }
01295 
<a name="l01296"></a><a class="code" href="../../d7/d6/ioverifier_8h.html#a13">01296</a> <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01297 <a class="code" href="../../d7/d6/ioverifier_8h.html#a13">IovAttachDeviceToDeviceStack</a>(
01298     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>  SourceDevice,
01299     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>  TargetDevice
01300     )
01301 {
01302     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a57">IovpVerifierLevel</a> &lt; 2) {
01303         <span class="keywordflow">return</span>;
01304     }
01305 
01306     <a class="code" href="../../d9/d4/trackirp_8h.html#a84">SPECIALIRP_IO_ATTACH_DEVICE_TO_DEVICE_STACK</a>(SourceDevice, TargetDevice);
01307 }
01308 
<a name="l01309"></a><a class="code" href="../../d7/d6/ioverifier_8h.html#a14">01309</a> <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01310 <a class="code" href="../../d7/d6/ioverifier_8h.html#a14">IovDeleteDevice</a>(
01311     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>  DeleteDevice
01312     )
01313 {
01314     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a57">IovpVerifierLevel</a> &lt; 2) {
01315         <span class="keywordflow">return</span>;
01316     }
01317 
01318     <a class="code" href="../../d9/d4/trackirp_8h.html#a83">SPECIALIRP_IO_DELETE_DEVICE</a>(DeleteDevice);
01319 }
01320 
<a name="l01321"></a><a class="code" href="../../d7/d6/ioverifier_8h.html#a15">01321</a> <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01322 <a class="code" href="../../d7/d6/ioverifier_8h.html#a15">IovDetachDevice</a>(
01323     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>  TargetDevice
01324     )
01325 {
01326     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a57">IovpVerifierLevel</a> &lt; 2) {
01327         <span class="keywordflow">return</span>;
01328     }
01329     <a class="code" href="../../d9/d4/trackirp_8h.html#a85">SPECIALIRP_IO_DETACH_DEVICE</a>(TargetDevice);
01330 }
01331 
<a name="l01332"></a><a class="code" href="../../d7/d6/ioverifier_8h.html#a16">01332</a> BOOLEAN
01333 <a class="code" href="../../d7/d6/ioverifier_8h.html#a16">IovCancelIrp</a>(
01334     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>    Irp,
01335     BOOLEAN *returnValue
01336     )
01337 {
01338 <span class="preprocessor">#ifndef NO_SPECIAL_IRP</span>
01339 <span class="preprocessor"></span>    BOOLEAN cancelHandled ;
01340 
01341     <a class="code" href="../../d9/d4/trackirp_8h.html#a77">SPECIALIRP_IO_CANCEL_IRP</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, &amp;cancelHandled, returnValue) ;
01342 
01343     <span class="keywordflow">if</span> (cancelHandled) {
01344 
01345        <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> ;
01346     }
01347 <span class="preprocessor">#endif</span>
01348 <span class="preprocessor"></span>    <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01349 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:32 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
