<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: gentable.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>gentable.c</h1><a href="../../d6/d1/gentable_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1990  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    Gentable.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module implements the generic table package.</span>
00012 <span class="comment"></span>
00013 <span class="comment">Author:</span>
00014 <span class="comment"></span>
00015 <span class="comment">    Gary Kimura     [GaryKi]    23-May-1989</span>
00016 <span class="comment"></span>
00017 <span class="comment">Environment:</span>
00018 <span class="comment"></span>
00019 <span class="comment">    Pure Utility Routines</span>
00020 <span class="comment"></span>
00021 <span class="comment">Revision History:</span>
00022 <span class="comment"></span>
00023 <span class="comment">    Anthony V. Ercolano [tonye] 23-May-1990</span>
00024 <span class="comment"></span>
00025 <span class="comment">    Implement package.</span>
00026 <span class="comment"></span>
00027 <span class="comment">    Anthony V. Ercolano [tonye] 1-Jun-1990</span>
00028 <span class="comment"></span>
00029 <span class="comment">    Added ability to get elements out in the order</span>
00030 <span class="comment">    inserted.  *NOTE* *NOTE* This depends on the implicit</span>
00031 <span class="comment">    ordering of record fields:</span>
00032 <span class="comment"></span>
00033 <span class="comment">        SPLAY_LINKS,</span>
00034 <span class="comment">        LIST_ENTRY,</span>
00035 <span class="comment">        USER_DATA</span>
00036 <span class="comment"></span>
00037 <span class="comment">--*/</span>
00038 
00039 <span class="preprocessor">#include &lt;nt.h&gt;</span>
00040 
00041 <span class="preprocessor">#include &lt;ntrtl.h&gt;</span>
00042 
00043 <span class="preprocessor">#pragma pack(8)</span>
00044 <span class="preprocessor"></span>
00045 <span class="comment">//</span>
00046 <span class="comment">// This structure is the header for a generic table entry.</span>
00047 <span class="comment">// Align this structure on a 8 byte boundary so the user</span>
00048 <span class="comment">// data is correctly aligned.</span>
00049 <span class="comment">//</span>
00050 
<a name="l00051"></a><a class="code" href="../../d3/d8/struct__TABLE__ENTRY__HEADER.html">00051</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d3/d8/struct__TABLE__ENTRY__HEADER.html">_TABLE_ENTRY_HEADER</a> {
00052 
<a name="l00053"></a><a class="code" href="../../d3/d8/struct__TABLE__ENTRY__HEADER.html#o0">00053</a>     RTL_SPLAY_LINKS <a class="code" href="../../d3/d8/struct__TABLE__ENTRY__HEADER.html#o0">SplayLinks</a>;
<a name="l00054"></a><a class="code" href="../../d3/d8/struct__TABLE__ENTRY__HEADER.html#o1">00054</a>     LIST_ENTRY <a class="code" href="../../d3/d8/struct__TABLE__ENTRY__HEADER.html#o1">ListEntry</a>;
<a name="l00055"></a><a class="code" href="../../d3/d8/struct__TABLE__ENTRY__HEADER.html#o2">00055</a>     LONGLONG <a class="code" href="../../d3/d8/struct__TABLE__ENTRY__HEADER.html#o2">UserData</a>;
00056 
00057 } <a class="code" href="../../d3/d8/struct__TABLE__ENTRY__HEADER.html">TABLE_ENTRY_HEADER</a>, *<a class="code" href="../../d3/d8/struct__TABLE__ENTRY__HEADER.html">PTABLE_ENTRY_HEADER</a>;
00058 
00059 <span class="preprocessor">#pragma pack()</span>
00060 <span class="preprocessor"></span>
00061 
00062 <span class="keyword">static</span>
00063 TABLE_SEARCH_RESULT
<a name="l00064"></a><a class="code" href="../../d6/d1/gentable_8c.html#a2">00064</a> <a class="code" href="../../d6/d1/gentable_8c.html#a2">FindNodeOrParent</a>(
00065     IN PRTL_GENERIC_TABLE Table,
00066     IN PVOID Buffer,
00067     OUT PRTL_SPLAY_LINKS *NodeOrParent
00068     )
00069 
00070 <span class="comment">/*++</span>
00071 <span class="comment"></span>
00072 <span class="comment">Routine Description:</span>
00073 <span class="comment"></span>
00074 <span class="comment">    This routine is used by all of the routines of the generic</span>
00075 <span class="comment">    table package to locate the a node in the tree.  It will</span>
00076 <span class="comment">    find and return (via the NodeOrParent parameter) the node</span>
00077 <span class="comment">    with the given key, or if that node is not in the tree it</span>
00078 <span class="comment">    will return (via the NodeOrParent parameter) a pointer to</span>
00079 <span class="comment">    the parent.</span>
00080 <span class="comment"></span>
00081 <span class="comment">Arguments:</span>
00082 <span class="comment"></span>
00083 <span class="comment">    Table - The generic table to search for the key.</span>
00084 <span class="comment"></span>
00085 <span class="comment">    Buffer - Pointer to a buffer holding the key.  The table</span>
00086 <span class="comment">             package doesn't examine the key itself.  It leaves</span>
00087 <span class="comment">             this up to the user supplied compare routine.</span>
00088 <span class="comment"></span>
00089 <span class="comment">    NodeOrParent - Will be set to point to the node containing the</span>
00090 <span class="comment">                   the key or what should be the parent of the node</span>
00091 <span class="comment">                   if it were in the tree.  Note that this will *NOT*</span>
00092 <span class="comment">                   be set if the search result is TableEmptyTree.</span>
00093 <span class="comment"></span>
00094 <span class="comment">Return Value:</span>
00095 <span class="comment"></span>
00096 <span class="comment">    TABLE_SEARCH_RESULT - TableEmptyTree: The tree was empty.  NodeOrParent</span>
00097 <span class="comment">                                          is *not* altered.</span>
00098 <span class="comment"></span>
00099 <span class="comment">                          TableFoundNode: A node with the key is in the tree.</span>
00100 <span class="comment">                                          NodeOrParent points to that node.</span>
00101 <span class="comment"></span>
00102 <span class="comment">                          TableInsertAsLeft: Node with key was not found.</span>
00103 <span class="comment">                                             NodeOrParent points to what would be</span>
00104 <span class="comment">                                             parent.  The node would be the left</span>
00105 <span class="comment">                                             child.</span>
00106 <span class="comment"></span>
00107 <span class="comment">                          TableInsertAsRight: Node with key was not found.</span>
00108 <span class="comment">                                              NodeOrParent points to what would be</span>
00109 <span class="comment">                                              parent.  The node would be the right</span>
00110 <span class="comment">                                              child.</span>
00111 <span class="comment"></span>
00112 <span class="comment">--*/</span>
00113 
00114 
00115 
00116 {
00117 
00118     <span class="keywordflow">if</span> (<a class="code" href="../../d6/d1/gentable_8c.html#a10">RtlIsGenericTableEmpty</a>(Table)) {
00119 
00120         <span class="keywordflow">return</span> TableEmptyTree;
00121 
00122     } <span class="keywordflow">else</span> {
00123 
00124         <span class="comment">//</span>
00125         <span class="comment">// Used as the iteration variable while stepping through</span>
00126         <span class="comment">// the generic table.</span>
00127         <span class="comment">//</span>
00128         PRTL_SPLAY_LINKS NodeToExamine = Table-&gt;TableRoot;
00129 
00130         <span class="comment">//</span>
00131         <span class="comment">// Just a temporary.  Hopefully a good compiler will get</span>
00132         <span class="comment">// rid of it.</span>
00133         <span class="comment">//</span>
00134         PRTL_SPLAY_LINKS Child;
00135 
00136         <span class="comment">//</span>
00137         <span class="comment">// Holds the value of the comparasion.</span>
00138         <span class="comment">//</span>
00139         RTL_GENERIC_COMPARE_RESULTS Result;
00140 
00141         <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00142 
00143             <span class="comment">//</span>
00144             <span class="comment">// Compare the buffer with the key in the tree element.</span>
00145             <span class="comment">//</span>
00146 
00147             Result = Table-&gt;CompareRoutine(
00148                          Table,
00149                          <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>,
00150                          &amp;((<a class="code" href="../../d6/d1/gentable_8c.html#a1">PTABLE_ENTRY_HEADER</a>) NodeToExamine)-&gt;UserData
00151                          );
00152 
00153             <span class="keywordflow">if</span> (Result == GenericLessThan) {
00154 
00155                 <span class="keywordflow">if</span> (Child = RtlLeftChild(NodeToExamine)) {
00156 
00157                     NodeToExamine = Child;
00158 
00159                 } <span class="keywordflow">else</span> {
00160 
00161                     <span class="comment">//</span>
00162                     <span class="comment">// Node is not in the tree.  Set the output</span>
00163                     <span class="comment">// parameter to point to what would be its</span>
00164                     <span class="comment">// parent and return which child it would be.</span>
00165                     <span class="comment">//</span>
00166 
00167                     *NodeOrParent = NodeToExamine;
00168                     <span class="keywordflow">return</span> TableInsertAsLeft;
00169 
00170                 }
00171 
00172             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Result == GenericGreaterThan) {
00173 
00174                 <span class="keywordflow">if</span> (Child = RtlRightChild(NodeToExamine)) {
00175 
00176                     NodeToExamine = Child;
00177 
00178                 } <span class="keywordflow">else</span> {
00179 
00180                     <span class="comment">//</span>
00181                     <span class="comment">// Node is not in the tree.  Set the output</span>
00182                     <span class="comment">// parameter to point to what would be its</span>
00183                     <span class="comment">// parent and return which child it would be.</span>
00184                     <span class="comment">//</span>
00185 
00186                     *NodeOrParent = NodeToExamine;
00187                     <span class="keywordflow">return</span> TableInsertAsRight;
00188 
00189                 }
00190 
00191 
00192             } <span class="keywordflow">else</span> {
00193 
00194                 <span class="comment">//</span>
00195                 <span class="comment">// Node is in the tree (or it better be because of the</span>
00196                 <span class="comment">// assert).  Set the output parameter to point to</span>
00197                 <span class="comment">// the node and tell the caller that we found the node.</span>
00198                 <span class="comment">//</span>
00199 
00200                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Result == GenericEqual);
00201                 *NodeOrParent = NodeToExamine;
00202                 <span class="keywordflow">return</span> TableFoundNode;
00203 
00204             }
00205 
00206         }
00207 
00208     }
00209 
00210 }
00211 
00212 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00213"></a><a class="code" href="../../d6/d1/gentable_8c.html#a3">00213</a> <a class="code" href="../../d6/d1/gentable_8c.html#a3">RtlInitializeGenericTable</a> (
00214     IN PRTL_GENERIC_TABLE Table,
00215     IN PRTL_GENERIC_COMPARE_ROUTINE CompareRoutine,
00216     IN PRTL_GENERIC_ALLOCATE_ROUTINE AllocateRoutine,
00217     IN PRTL_GENERIC_FREE_ROUTINE FreeRoutine,
00218     IN PVOID TableContext
00219     )
00220 
00221 <span class="comment">/*++</span>
00222 <span class="comment"></span>
00223 <span class="comment">Routine Description:</span>
00224 <span class="comment"></span>
00225 <span class="comment">    The procedure InitializeGenericTable takes as input an uninitialized</span>
00226 <span class="comment">    generic table variable and pointers to the three user supplied routines.</span>
00227 <span class="comment">    This must be called for every individual generic table variable before</span>
00228 <span class="comment">    it can be used.</span>
00229 <span class="comment"></span>
00230 <span class="comment">Arguments:</span>
00231 <span class="comment"></span>
00232 <span class="comment">    Table - Pointer to the generic table to be initialized.</span>
00233 <span class="comment"></span>
00234 <span class="comment">    CompareRoutine - User routine to be used to compare to keys in the</span>
00235 <span class="comment">                     table.</span>
00236 <span class="comment"></span>
00237 <span class="comment">    AllocateRoutine - User routine to call to allocate memory for a new</span>
00238 <span class="comment">                      node in the generic table.</span>
00239 <span class="comment"></span>
00240 <span class="comment">    FreeRoutine - User routine to call to deallocate memory for</span>
00241 <span class="comment">                        a node in the generic table.</span>
00242 <span class="comment"></span>
00243 <span class="comment">    TableContext - Supplies user supplied context for the table.</span>
00244 <span class="comment"></span>
00245 <span class="comment">Return Value:</span>
00246 <span class="comment"></span>
00247 <span class="comment">    None.</span>
00248 <span class="comment"></span>
00249 <span class="comment">--*/</span>
00250 
00251 {
00252 
00253     <span class="comment">//</span>
00254     <span class="comment">// Initialize each field of the Table parameter.</span>
00255     <span class="comment">//</span>
00256 
00257     Table-&gt;TableRoot = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00258     InitializeListHead(&amp;Table-&gt;InsertOrderList);
00259     Table-&gt;NumberGenericTableElements = 0;
00260     Table-&gt;OrderedPointer = &amp;Table-&gt;InsertOrderList;
00261     Table-&gt;WhichOrderedElement = 0;
00262     Table-&gt;CompareRoutine = CompareRoutine;
00263     Table-&gt;AllocateRoutine = AllocateRoutine;
00264     Table-&gt;FreeRoutine = FreeRoutine;
00265     Table-&gt;TableContext = TableContext;
00266 
00267 }
00268 
00269 
00270 PVOID
<a name="l00271"></a><a class="code" href="../../d6/d1/gentable_8c.html#a4">00271</a> <a class="code" href="../../d6/d1/gentable_8c.html#a4">RtlInsertElementGenericTable</a> (
00272     IN PRTL_GENERIC_TABLE Table,
00273     IN PVOID Buffer,
00274     IN CLONG BufferSize,
00275     OUT PBOOLEAN NewElement OPTIONAL
00276     )
00277 
00278 <span class="comment">/*++</span>
00279 <span class="comment"></span>
00280 <span class="comment">Routine Description:</span>
00281 <span class="comment"></span>
00282 <span class="comment">    The function InsertElementGenericTable will insert a new element</span>
00283 <span class="comment">    in a table.  It does this by allocating space for the new element</span>
00284 <span class="comment">    (this includes splay links), inserting the element in the table, and</span>
00285 <span class="comment">    then returning to the user a pointer to the new element (which is</span>
00286 <span class="comment">    the first available space after the splay links).  If an element</span>
00287 <span class="comment">    with the same key already exists in the table the return value is a pointer</span>
00288 <span class="comment">    to the old element.  The optional output parameter NewElement is used</span>
00289 <span class="comment">    to indicate if the element previously existed in the table.  Note: the user</span>
00290 <span class="comment">    supplied Buffer is only used for searching the table, upon insertion its</span>
00291 <span class="comment">    contents are copied to the newly created element.  This means that</span>
00292 <span class="comment">    pointer to the input buffer will not point to the new element.</span>
00293 <span class="comment"></span>
00294 <span class="comment">Arguments:</span>
00295 <span class="comment"></span>
00296 <span class="comment">    Table - Pointer to the table in which to (possibly) insert the</span>
00297 <span class="comment">            key buffer.</span>
00298 <span class="comment"></span>
00299 <span class="comment">    Buffer - Passed to the user comparasion routine.  Its contents are</span>
00300 <span class="comment">             up to the user but one could imagine that it contains some</span>
00301 <span class="comment">             sort of key value.</span>
00302 <span class="comment"></span>
00303 <span class="comment">    BufferSize - The amount of space to allocate when the (possible)</span>
00304 <span class="comment">                 insertion is made.  Note that if we actually do</span>
00305 <span class="comment">                 not find the node and we do allocate space then we</span>
00306 <span class="comment">                 will add the size of the SPLAY_LINKS to this buffer</span>
00307 <span class="comment">                 size.  The user should really take care not to depend</span>
00308 <span class="comment">                 on anything in the first sizeof(SPLAY_LINKS) bytes</span>
00309 <span class="comment">                 of the memory allocated via the memory allocation</span>
00310 <span class="comment">                 routine.</span>
00311 <span class="comment"></span>
00312 <span class="comment">    NewElement - Optional Flag.  If present then it will be set to</span>
00313 <span class="comment">                 TRUE if the buffer was not "found" in the generic</span>
00314 <span class="comment">                 table.</span>
00315 <span class="comment"></span>
00316 <span class="comment">Return Value:</span>
00317 <span class="comment"></span>
00318 <span class="comment">    PVOID - Pointer to the user defined data.</span>
00319 <span class="comment"></span>
00320 <span class="comment">--*/</span>
00321 
00322 {
00323 
00324     <span class="comment">//</span>
00325     <span class="comment">// Holds a pointer to the node in the table or what would be the</span>
00326     <span class="comment">// parent of the node.</span>
00327     <span class="comment">//</span>
00328     PRTL_SPLAY_LINKS NodeOrParent;
00329 
00330     <span class="comment">//</span>
00331     <span class="comment">// Holds the result of the table lookup.</span>
00332     <span class="comment">//</span>
00333     TABLE_SEARCH_RESULT Lookup;
00334 
00335     Lookup = <a class="code" href="../../d6/d1/gentable_8c.html#a2">FindNodeOrParent</a>(
00336                  Table,
00337                  <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>,
00338                  &amp;NodeOrParent
00339                  );
00340 
00341     <span class="comment">//</span>
00342     <span class="comment">//  Call the full routine to do the real work.</span>
00343     <span class="comment">//</span>
00344 
00345     <span class="keywordflow">return</span> <a class="code" href="../../d6/d1/gentable_8c.html#a5">RtlInsertElementGenericTableFull</a>(
00346                 Table,
00347                 <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>,
00348                 <a class="code" href="../../d6/d2/rtqkey_8c.html#a5">BufferSize</a>,
00349                 NewElement,
00350                 NodeOrParent,
00351                 Lookup
00352                 );
00353 }
00354 
00355 
00356 PVOID
<a name="l00357"></a><a class="code" href="../../d6/d1/gentable_8c.html#a5">00357</a> <a class="code" href="../../d6/d1/gentable_8c.html#a5">RtlInsertElementGenericTableFull</a> (
00358     IN PRTL_GENERIC_TABLE Table,
00359     IN PVOID Buffer,
00360     IN CLONG BufferSize,
00361     OUT PBOOLEAN NewElement OPTIONAL,
00362     PVOID NodeOrParent,
00363     TABLE_SEARCH_RESULT SearchResult
00364     )
00365 
00366 <span class="comment">/*++</span>
00367 <span class="comment"></span>
00368 <span class="comment">Routine Description:</span>
00369 <span class="comment"></span>
00370 <span class="comment">    The function InsertElementGenericTableFull will insert a new element</span>
00371 <span class="comment">    in a table.  It does this by allocating space for the new element</span>
00372 <span class="comment">    (this includes splay links), inserting the element in the table, and</span>
00373 <span class="comment">    then returning to the user a pointer to the new element.  If an element</span>
00374 <span class="comment">    with the same key already exists in the table the return value is a pointer</span>
00375 <span class="comment">    to the old element.  The optional output parameter NewElement is used</span>
00376 <span class="comment">    to indicate if the element previously existed in the table.  Note: the user</span>
00377 <span class="comment">    supplied Buffer is only used for searching the table, upon insertion its</span>
00378 <span class="comment">    contents are copied to the newly created element.  This means that</span>
00379 <span class="comment">    pointer to the input buffer will not point to the new element.</span>
00380 <span class="comment">    This routine is passed the NodeOrParent and SearchResult from a</span>
00381 <span class="comment">    previous RtlLookupElementGenericTableFull.</span>
00382 <span class="comment"></span>
00383 <span class="comment">Arguments:</span>
00384 <span class="comment"></span>
00385 <span class="comment">    Table - Pointer to the table in which to (possibly) insert the</span>
00386 <span class="comment">            key buffer.</span>
00387 <span class="comment"></span>
00388 <span class="comment">    Buffer - Passed to the user comparasion routine.  Its contents are</span>
00389 <span class="comment">             up to the user but one could imagine that it contains some</span>
00390 <span class="comment">             sort of key value.</span>
00391 <span class="comment"></span>
00392 <span class="comment">    BufferSize - The amount of space to allocate when the (possible)</span>
00393 <span class="comment">                 insertion is made.  Note that if we actually do</span>
00394 <span class="comment">                 not find the node and we do allocate space then we</span>
00395 <span class="comment">                 will add the size of the SPLAY_LINKS to this buffer</span>
00396 <span class="comment">                 size.  The user should really take care not to depend</span>
00397 <span class="comment">                 on anything in the first sizeof(SPLAY_LINKS) bytes</span>
00398 <span class="comment">                 of the memory allocated via the memory allocation</span>
00399 <span class="comment">                 routine.</span>
00400 <span class="comment"></span>
00401 <span class="comment">    NewElement - Optional Flag.  If present then it will be set to</span>
00402 <span class="comment">                 TRUE if the buffer was not "found" in the generic</span>
00403 <span class="comment">                 table.</span>
00404 <span class="comment"></span>
00405 <span class="comment">   NodeOrParent - Result of prior RtlLookupElementGenericTableFull.</span>
00406 <span class="comment"></span>
00407 <span class="comment">   SearchResult - Result of prior RtlLookupElementGenericTableFull.</span>
00408 <span class="comment"></span>
00409 <span class="comment">Return Value:</span>
00410 <span class="comment"></span>
00411 <span class="comment">    PVOID - Pointer to the user defined data.</span>
00412 <span class="comment"></span>
00413 <span class="comment">--*/</span>
00414 
00415 {
00416     <span class="comment">//</span>
00417     <span class="comment">// Node will point to the splay links of what</span>
00418     <span class="comment">// will be returned to the user.</span>
00419     <span class="comment">//</span>
00420 
00421     PRTL_SPLAY_LINKS NodeToReturn;
00422 
00423     <span class="keywordflow">if</span> (SearchResult != TableFoundNode) {
00424 
00425         <span class="comment">//</span>
00426         <span class="comment">// We just check that the table isn't getting</span>
00427         <span class="comment">// too big.</span>
00428         <span class="comment">//</span>
00429 
00430         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Table-&gt;NumberGenericTableElements != (MAXULONG-1));
00431 
00432         <span class="comment">//</span>
00433         <span class="comment">// The node wasn't in the (possibly empty) tree.</span>
00434         <span class="comment">// Call the user allocation routine to get space</span>
00435         <span class="comment">// for the new node.</span>
00436         <span class="comment">//</span>
00437 
00438         NodeToReturn = Table-&gt;AllocateRoutine(
00439                            Table,
00440                            <a class="code" href="../../d6/d2/rtqkey_8c.html#a5">BufferSize</a>+FIELD_OFFSET( <a class="code" href="../../d3/d8/struct__TABLE__ENTRY__HEADER.html">TABLE_ENTRY_HEADER</a>, UserData )
00441                            );
00442 
00443         <span class="comment">//</span>
00444         <span class="comment">// If the return is NULL, return NULL from here to indicate that</span>
00445         <span class="comment">// the entry could not be added.</span>
00446         <span class="comment">//</span>
00447 
00448         <span class="keywordflow">if</span> (NodeToReturn == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00449 
00450             <span class="keywordflow">if</span> (ARGUMENT_PRESENT(NewElement)) {
00451 
00452                 *NewElement = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00453             }
00454 
00455             <span class="keywordflow">return</span>(<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00456         }
00457 
00458         RtlInitializeSplayLinks(NodeToReturn);
00459 
00460         <span class="comment">//</span>
00461         <span class="comment">// Insert the new node at the end of the ordered linked list.</span>
00462         <span class="comment">//</span>
00463 
00464         InsertTailList(
00465             &amp;Table-&gt;InsertOrderList,
00466             &amp;((<a class="code" href="../../d6/d1/gentable_8c.html#a1">PTABLE_ENTRY_HEADER</a>) NodeToReturn)-&gt;ListEntry
00467             );
00468 
00469         Table-&gt;NumberGenericTableElements++;
00470 
00471         <span class="comment">//</span>
00472         <span class="comment">// Insert the new node in the tree.</span>
00473         <span class="comment">//</span>
00474 
00475         <span class="keywordflow">if</span> (SearchResult == TableEmptyTree) {
00476 
00477             Table-&gt;TableRoot = NodeToReturn;
00478 
00479         } <span class="keywordflow">else</span> {
00480 
00481             <span class="keywordflow">if</span> (SearchResult == TableInsertAsLeft) {
00482 
00483                 RtlInsertAsLeftChild(
00484                     NodeOrParent,
00485                     NodeToReturn
00486                     );
00487 
00488             } <span class="keywordflow">else</span> {
00489 
00490                 RtlInsertAsRightChild(
00491                     NodeOrParent,
00492                     NodeToReturn
00493                     );
00494             }
00495         }
00496 
00497         <span class="comment">//</span>
00498         <span class="comment">// Copy the users buffer into the user data area of the table.</span>
00499         <span class="comment">//</span>
00500 
00501         RtlCopyMemory(
00502             &amp;((<a class="code" href="../../d6/d1/gentable_8c.html#a1">PTABLE_ENTRY_HEADER</a>) NodeToReturn)-&gt;UserData,
00503             <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>,
00504             <a class="code" href="../../d6/d2/rtqkey_8c.html#a5">BufferSize</a>
00505             );
00506 
00507     } <span class="keywordflow">else</span> {
00508 
00509         NodeToReturn = NodeOrParent;
00510     }
00511 
00512     <span class="comment">//</span>
00513     <span class="comment">// Always splay the (possibly) new node.</span>
00514     <span class="comment">//</span>
00515 
00516     Table-&gt;TableRoot = <a class="code" href="../../d3/d4/splay_8c.html#a3">RtlSplay</a>(NodeToReturn);
00517 
00518     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(NewElement)) {
00519 
00520         *NewElement = ((SearchResult == TableFoundNode)?(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>):(<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>));
00521     }
00522 
00523     <span class="comment">//</span>
00524     <span class="comment">// Insert the element on the ordered list;</span>
00525     <span class="comment">//</span>
00526 
00527     <span class="keywordflow">return</span> &amp;((<a class="code" href="../../d6/d1/gentable_8c.html#a1">PTABLE_ENTRY_HEADER</a>) NodeToReturn)-&gt;UserData;
00528 }
00529 
00530 
00531 BOOLEAN
<a name="l00532"></a><a class="code" href="../../d6/d1/gentable_8c.html#a6">00532</a> <a class="code" href="../../d6/d1/gentable_8c.html#a6">RtlDeleteElementGenericTable</a> (
00533     IN PRTL_GENERIC_TABLE Table,
00534     IN PVOID Buffer
00535     )
00536 
00537 <span class="comment">/*++</span>
00538 <span class="comment"></span>
00539 <span class="comment">Routine Description:</span>
00540 <span class="comment"></span>
00541 <span class="comment">    The function DeleteElementGenericTable will find and delete an element</span>
00542 <span class="comment">    from a generic table.  If the element is located and deleted the return</span>
00543 <span class="comment">    value is TRUE, otherwise if the element is not located the return value</span>
00544 <span class="comment">    is FALSE.  The user supplied input buffer is only used as a key in</span>
00545 <span class="comment">    locating the element in the table.</span>
00546 <span class="comment"></span>
00547 <span class="comment">Arguments:</span>
00548 <span class="comment"></span>
00549 <span class="comment">    Table - Pointer to the table in which to (possibly) delete the</span>
00550 <span class="comment">            memory accessed by the key buffer.</span>
00551 <span class="comment"></span>
00552 <span class="comment">    Buffer - Passed to the user comparasion routine.  Its contents are</span>
00553 <span class="comment">             up to the user but one could imagine that it contains some</span>
00554 <span class="comment">             sort of key value.</span>
00555 <span class="comment"></span>
00556 <span class="comment">Return Value:</span>
00557 <span class="comment"></span>
00558 <span class="comment">    BOOLEAN - If the table contained the key then true, otherwise false.</span>
00559 <span class="comment"></span>
00560 <span class="comment">--*/</span>
00561 
00562 {
00563 
00564     <span class="comment">//</span>
00565     <span class="comment">// Holds a pointer to the node in the table or what would be the</span>
00566     <span class="comment">// parent of the node.</span>
00567     <span class="comment">//</span>
00568     PRTL_SPLAY_LINKS NodeOrParent;
00569 
00570     <span class="comment">//</span>
00571     <span class="comment">// Holds the result of the table lookup.</span>
00572     <span class="comment">//</span>
00573     TABLE_SEARCH_RESULT Lookup;
00574 
00575     Lookup = <a class="code" href="../../d6/d1/gentable_8c.html#a2">FindNodeOrParent</a>(
00576                  Table,
00577                  <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>,
00578                  &amp;NodeOrParent
00579                  );
00580 
00581     <span class="keywordflow">if</span> ((Lookup == TableEmptyTree) || (Lookup != TableFoundNode)) {
00582 
00583         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00584 
00585     } <span class="keywordflow">else</span> {
00586 
00587         <span class="comment">//</span>
00588         <span class="comment">// Delete the node from the splay tree.</span>
00589         <span class="comment">//</span>
00590 
00591         Table-&gt;TableRoot = <a class="code" href="../../d3/d4/splay_8c.html#a4">RtlDelete</a>(NodeOrParent);
00592 
00593         <span class="comment">//</span>
00594         <span class="comment">// Delete the element from the linked list.</span>
00595         <span class="comment">//</span>
00596 
00597         RemoveEntryList(&amp;((<a class="code" href="../../d6/d1/gentable_8c.html#a1">PTABLE_ENTRY_HEADER</a>) NodeOrParent)-&gt;ListEntry);
00598         Table-&gt;NumberGenericTableElements--;
00599         Table-&gt;WhichOrderedElement = 0;
00600         Table-&gt;OrderedPointer = &amp;Table-&gt;InsertOrderList;
00601 
00602         <span class="comment">//</span>
00603         <span class="comment">// The node has been deleted from the splay table.</span>
00604         <span class="comment">// Now give the node to the user deletion routine.</span>
00605         <span class="comment">// NOTE: We are giving the deletion routine a pointer</span>
00606         <span class="comment">// to the splay links rather then the user data.  It</span>
00607         <span class="comment">// is assumed that the deallocation is rather stupid.</span>
00608         <span class="comment">//</span>
00609 
00610         Table-&gt;FreeRoutine(Table,NodeOrParent);
00611         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00612 
00613     }
00614 
00615 }
00616 
00617 
00618 PVOID
<a name="l00619"></a><a class="code" href="../../d6/d1/gentable_8c.html#a7">00619</a> <a class="code" href="../../d6/d1/gentable_8c.html#a7">RtlLookupElementGenericTable</a> (
00620     IN PRTL_GENERIC_TABLE Table,
00621     IN PVOID Buffer
00622     )
00623 
00624 <span class="comment">/*++</span>
00625 <span class="comment"></span>
00626 <span class="comment">Routine Description:</span>
00627 <span class="comment"></span>
00628 <span class="comment">    The function LookupElementGenericTable will find an element in a generic</span>
00629 <span class="comment">    table.  If the element is located the return value is a pointer to</span>
00630 <span class="comment">    the user defined structure associated with the element, otherwise if</span>
00631 <span class="comment">    the element is not located the return value is NULL.  The user supplied</span>
00632 <span class="comment">    input buffer is only used as a key in locating the element in the table.</span>
00633 <span class="comment"></span>
00634 <span class="comment">Arguments:</span>
00635 <span class="comment"></span>
00636 <span class="comment">    Table - Pointer to the users Generic table to search for the key.</span>
00637 <span class="comment"></span>
00638 <span class="comment">    Buffer - Used for the comparasion.</span>
00639 <span class="comment"></span>
00640 <span class="comment">Return Value:</span>
00641 <span class="comment"></span>
00642 <span class="comment">    PVOID - returns a pointer to the user data.</span>
00643 <span class="comment"></span>
00644 <span class="comment">--*/</span>
00645 
00646 {
00647     <span class="comment">//</span>
00648     <span class="comment">// Holds a pointer to the node in the table or what would be the</span>
00649     <span class="comment">// parent of the node.</span>
00650     <span class="comment">//</span>
00651     PRTL_SPLAY_LINKS NodeOrParent;
00652 
00653     <span class="comment">//</span>
00654     <span class="comment">// Holds the result of the table lookup.</span>
00655     <span class="comment">//</span>
00656     TABLE_SEARCH_RESULT Lookup;
00657 
00658     <span class="keywordflow">return</span> <a class="code" href="../../d6/d1/gentable_8c.html#a8">RtlLookupElementGenericTableFull</a>(
00659                 Table,
00660                 <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>,
00661                 &amp;NodeOrParent,
00662                 &amp;Lookup
00663                 );
00664 }
00665 
00666 
00667 PVOID
00668 NTAPI
<a name="l00669"></a><a class="code" href="../../d6/d1/gentable_8c.html#a8">00669</a> <a class="code" href="../../d6/d1/gentable_8c.html#a8">RtlLookupElementGenericTableFull</a> (
00670     PRTL_GENERIC_TABLE Table,
00671     PVOID Buffer,
00672     OUT PVOID *NodeOrParent,
00673     OUT TABLE_SEARCH_RESULT *SearchResult
00674     )
00675 
00676 <span class="comment">/*++</span>
00677 <span class="comment"></span>
00678 <span class="comment">Routine Description:</span>
00679 <span class="comment"></span>
00680 <span class="comment">    The function LookupElementGenericTableFull will find an element in a generic</span>
00681 <span class="comment">    table.  If the element is located the return value is a pointer to</span>
00682 <span class="comment">    the user defined structure associated with the element.  If the element is not</span>
00683 <span class="comment">    located then a pointer to the parent for the insert location is returned.  The</span>
00684 <span class="comment">    user must look at the SearchResult value to determine which is being returned.</span>
00685 <span class="comment">    The user can use the SearchResult and parent for a subsequent FullInsertElement</span>
00686 <span class="comment">    call to optimize the insert.</span>
00687 <span class="comment"></span>
00688 <span class="comment">Arguments:</span>
00689 <span class="comment"></span>
00690 <span class="comment">    Table - Pointer to the users Generic table to search for the key.</span>
00691 <span class="comment"></span>
00692 <span class="comment">    Buffer - Used for the comparasion.</span>
00693 <span class="comment"></span>
00694 <span class="comment">    NodeOrParent - Address to store the desired Node or parent of the desired node.</span>
00695 <span class="comment"></span>
00696 <span class="comment">    SearchResult - Describes the relationship of the NodeOrParent with the desired Node.</span>
00697 <span class="comment"></span>
00698 <span class="comment">Return Value:</span>
00699 <span class="comment"></span>
00700 <span class="comment">    PVOID - returns a pointer to the user data.</span>
00701 <span class="comment"></span>
00702 <span class="comment">--*/</span>
00703 
00704 {
00705 
00706     <span class="comment">//</span>
00707     <span class="comment">//  Lookup the element and save the result.</span>
00708     <span class="comment">//</span>
00709 
00710     *SearchResult = <a class="code" href="../../d6/d1/gentable_8c.html#a2">FindNodeOrParent</a>(
00711                         Table,
00712                         <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>,
00713                         (PRTL_SPLAY_LINKS *)NodeOrParent
00714                         );
00715 
00716     <span class="keywordflow">if</span> ((*SearchResult == TableEmptyTree) || (*SearchResult != TableFoundNode)) {
00717 
00718         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00719 
00720     } <span class="keywordflow">else</span> {
00721 
00722         <span class="comment">//</span>
00723         <span class="comment">// Splay the tree with this node.</span>
00724         <span class="comment">//</span>
00725 
00726         Table-&gt;TableRoot = <a class="code" href="../../d3/d4/splay_8c.html#a3">RtlSplay</a>(*NodeOrParent);
00727 
00728         <span class="comment">//</span>
00729         <span class="comment">// Return a pointer to the user data.</span>
00730         <span class="comment">//</span>
00731 
00732         <span class="keywordflow">return</span> &amp;((<a class="code" href="../../d6/d1/gentable_8c.html#a1">PTABLE_ENTRY_HEADER</a>)*NodeOrParent)-&gt;UserData;
00733     }
00734 }
00735 
00736 
00737 PVOID
<a name="l00738"></a><a class="code" href="../../d6/d1/gentable_8c.html#a9">00738</a> <a class="code" href="../../d6/d1/gentable_8c.html#a9">RtlEnumerateGenericTable</a> (
00739     IN PRTL_GENERIC_TABLE Table,
00740     IN BOOLEAN Restart
00741     )
00742 
00743 <span class="comment">/*++</span>
00744 <span class="comment"></span>
00745 <span class="comment">Routine Description:</span>
00746 <span class="comment"></span>
00747 <span class="comment">    The function EnumerateGenericTable will return to the caller one-by-one</span>
00748 <span class="comment">    the elements of of a table.  The return value is a pointer to the user</span>
00749 <span class="comment">    defined structure associated with the element.  The input parameter</span>
00750 <span class="comment">    Restart indicates if the enumeration should start from the beginning</span>
00751 <span class="comment">    or should return the next element.  If the are no more new elements to</span>
00752 <span class="comment">    return the return value is NULL.  As an example of its use, to enumerate</span>
00753 <span class="comment">    all of the elements in a table the user would write:</span>
00754 <span class="comment"></span>
00755 <span class="comment">        for (ptr = EnumerateGenericTable(Table,TRUE);</span>
00756 <span class="comment">             ptr != NULL;</span>
00757 <span class="comment">             ptr = EnumerateGenericTable(Table, FALSE)) {</span>
00758 <span class="comment">                :</span>
00759 <span class="comment">        }</span>
00760 <span class="comment"></span>
00761 <span class="comment">Arguments:</span>
00762 <span class="comment"></span>
00763 <span class="comment">    Table - Pointer to the generic table to enumerate.</span>
00764 <span class="comment"></span>
00765 <span class="comment">    Restart - Flag that if true we should start with the least</span>
00766 <span class="comment">              element in the tree otherwise, return we return</span>
00767 <span class="comment">              a pointer to the user data for the root and make</span>
00768 <span class="comment">              the real successor to the root the new root.</span>
00769 <span class="comment"></span>
00770 <span class="comment">Return Value:</span>
00771 <span class="comment"></span>
00772 <span class="comment">    PVOID - Pointer to the user data.</span>
00773 <span class="comment"></span>
00774 <span class="comment">--*/</span>
00775 
00776 {
00777 
00778     <span class="keywordflow">if</span> (<a class="code" href="../../d6/d1/gentable_8c.html#a10">RtlIsGenericTableEmpty</a>(Table)) {
00779 
00780         <span class="comment">//</span>
00781         <span class="comment">// Nothing to do if the table is empty.</span>
00782         <span class="comment">//</span>
00783 
00784         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00785 
00786     } <span class="keywordflow">else</span> {
00787 
00788         <span class="comment">//</span>
00789         <span class="comment">// Will be used as the "iteration" through the tree.</span>
00790         <span class="comment">//</span>
00791         PRTL_SPLAY_LINKS NodeToReturn;
00792 
00793         <span class="comment">//</span>
00794         <span class="comment">// If the restart flag is true then go to the least element</span>
00795         <span class="comment">// in the tree.</span>
00796         <span class="comment">//</span>
00797 
00798         <span class="keywordflow">if</span> (Restart) {
00799 
00800             <span class="comment">//</span>
00801             <span class="comment">// We just loop until we find the leftmost child of the root.</span>
00802             <span class="comment">//</span>
00803 
00804             <span class="keywordflow">for</span> (
00805                 NodeToReturn = Table-&gt;TableRoot;
00806                 RtlLeftChild(NodeToReturn);
00807                 NodeToReturn = RtlLeftChild(NodeToReturn)
00808                 ) {
00809                 ;
00810             }
00811 
00812             Table-&gt;TableRoot = <a class="code" href="../../d3/d4/splay_8c.html#a3">RtlSplay</a>(NodeToReturn);
00813 
00814         } <span class="keywordflow">else</span> {
00815 
00816             <span class="comment">//</span>
00817             <span class="comment">// The assumption here is that the root of the</span>
00818             <span class="comment">// tree is the last node that we returned.  We</span>
00819             <span class="comment">// find the real successor to the root and return</span>
00820             <span class="comment">// it as next element of the enumeration.  The</span>
00821             <span class="comment">// node that is to be returned is splayed (thereby</span>
00822             <span class="comment">// making it the root of the tree).  Note that we</span>
00823             <span class="comment">// need to take care when there are no more elements.</span>
00824             <span class="comment">//</span>
00825 
00826             NodeToReturn = <a class="code" href="../../d3/d4/splay_8c.html#a8">RtlRealSuccessor</a>(Table-&gt;TableRoot);
00827 
00828             <span class="keywordflow">if</span> (NodeToReturn) {
00829 
00830                 Table-&gt;TableRoot = <a class="code" href="../../d3/d4/splay_8c.html#a3">RtlSplay</a>(NodeToReturn);
00831 
00832             }
00833 
00834         }
00835 
00836         <span class="comment">//</span>
00837         <span class="comment">// If there actually is a next element in the enumeration</span>
00838         <span class="comment">// then the pointer to return is right after the list links.</span>
00839         <span class="comment">//</span>
00840 
00841         <span class="keywordflow">return</span> ((NodeToReturn)?
00842                    ((PVOID)&amp;((<a class="code" href="../../d6/d1/gentable_8c.html#a1">PTABLE_ENTRY_HEADER</a>)NodeToReturn)-&gt;UserData)
00843                   :((PVOID)(<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)));
00844 
00845     }
00846 
00847 }
00848 
00849 
00850 BOOLEAN
<a name="l00851"></a><a class="code" href="../../d6/d1/gentable_8c.html#a10">00851</a> <a class="code" href="../../d6/d1/gentable_8c.html#a10">RtlIsGenericTableEmpty</a> (
00852     IN PRTL_GENERIC_TABLE Table
00853     )
00854 
00855 <span class="comment">/*++</span>
00856 <span class="comment"></span>
00857 <span class="comment">Routine Description:</span>
00858 <span class="comment"></span>
00859 <span class="comment">    The function IsGenericTableEmpty will return to the caller TRUE if</span>
00860 <span class="comment">    the input table is empty (i.e., does not contain any elements) and</span>
00861 <span class="comment">    FALSE otherwise.</span>
00862 <span class="comment"></span>
00863 <span class="comment">Arguments:</span>
00864 <span class="comment"></span>
00865 <span class="comment">    Table - Supplies a pointer to the Generic Table.</span>
00866 <span class="comment"></span>
00867 <span class="comment">Return Value:</span>
00868 <span class="comment"></span>
00869 <span class="comment">    BOOLEAN - if enabled the tree is empty.</span>
00870 <span class="comment"></span>
00871 <span class="comment">--*/</span>
00872 
00873 {
00874 
00875     <span class="comment">//</span>
00876     <span class="comment">// Table is empty if the root pointer is null.</span>
00877     <span class="comment">//</span>
00878 
00879     <span class="keywordflow">return</span> ((Table-&gt;TableRoot)?(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>):(<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>));
00880 
00881 }
00882 
00883 PVOID
<a name="l00884"></a><a class="code" href="../../d6/d1/gentable_8c.html#a11">00884</a> <a class="code" href="../../d6/d1/gentable_8c.html#a11">RtlGetElementGenericTable</a> (
00885     IN PRTL_GENERIC_TABLE Table,
00886     IN ULONG I
00887     )
00888 
00889 <span class="comment">/*++</span>
00890 <span class="comment"></span>
00891 <span class="comment">Routine Description:</span>
00892 <span class="comment"></span>
00893 <span class="comment"></span>
00894 <span class="comment">    The function GetElementGenericTable will return the i'th element</span>
00895 <span class="comment">    inserted in the generic table.  I = 0 implies the first element,</span>
00896 <span class="comment">    I = (RtlNumberGenericTableElements(Table)-1) will return the last element</span>
00897 <span class="comment">    inserted into the generic table.  The type of I is ULONG.  Values</span>
00898 <span class="comment">    of I &gt; than (NumberGenericTableElements(Table)-1) will return NULL.  If</span>
00899 <span class="comment">    an arbitrary element is deleted from the generic table it will cause</span>
00900 <span class="comment">    all elements inserted after the deleted element to "move up".</span>
00901 <span class="comment"></span>
00902 <span class="comment">Arguments:</span>
00903 <span class="comment"></span>
00904 <span class="comment">    Table - Pointer to the generic table from which to get the ith element.</span>
00905 <span class="comment"></span>
00906 <span class="comment">    I - Which element to get.</span>
00907 <span class="comment"></span>
00908 <span class="comment"></span>
00909 <span class="comment">Return Value:</span>
00910 <span class="comment"></span>
00911 <span class="comment">    PVOID - Pointer to the user data.</span>
00912 <span class="comment"></span>
00913 <span class="comment">--*/</span>
00914 
00915 {
00916 
00917     <span class="comment">//</span>
00918     <span class="comment">// Current location in the table.</span>
00919     <span class="comment">//</span>
00920     ULONG CurrentLocation = Table-&gt;WhichOrderedElement;
00921 
00922     <span class="comment">//</span>
00923     <span class="comment">// Hold the number of elements in the table.</span>
00924     <span class="comment">//</span>
00925     ULONG NumberInTable = Table-&gt;NumberGenericTableElements;
00926 
00927     <span class="comment">//</span>
00928     <span class="comment">// Holds the value of I+1.</span>
00929     <span class="comment">//</span>
00930     <span class="comment">// Note that we don't care if this value overflows.</span>
00931     <span class="comment">// If we end up accessing it we know that it didn't.</span>
00932     <span class="comment">//</span>
00933     ULONG NormalizedI = I + 1;
00934 
00935     <span class="comment">//</span>
00936     <span class="comment">// Will hold distances to travel to the desired node;</span>
00937     <span class="comment">//</span>
00938     ULONG ForwardDistance,BackwardDistance;
00939 
00940     <span class="comment">//</span>
00941     <span class="comment">// Will point to the current element in the linked list.</span>
00942     <span class="comment">//</span>
00943     PLIST_ENTRY CurrentNode = Table-&gt;OrderedPointer;
00944 
00945 
00946     <span class="comment">//</span>
00947     <span class="comment">// If it's out of bounds get out quick.</span>
00948     <span class="comment">//</span>
00949 
00950     <span class="keywordflow">if</span> ((I == MAXULONG) || (NormalizedI &gt; NumberInTable)) <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00951 
00952     <span class="comment">//</span>
00953     <span class="comment">// If we're already at the node then return it.</span>
00954     <span class="comment">//</span>
00955 
00956     <span class="keywordflow">if</span> (NormalizedI == CurrentLocation) {
00957 
00958         <span class="keywordflow">return</span> &amp;((<a class="code" href="../../d6/d1/gentable_8c.html#a1">PTABLE_ENTRY_HEADER</a>) CONTAINING_RECORD(CurrentNode, <a class="code" href="../../d3/d8/struct__TABLE__ENTRY__HEADER.html">TABLE_ENTRY_HEADER</a>, ListEntry))-&gt;UserData;
00959     }
00960 
00961     <span class="comment">//</span>
00962     <span class="comment">// Calculate the forward and backward distance to the node.</span>
00963     <span class="comment">//</span>
00964 
00965     <span class="keywordflow">if</span> (CurrentLocation &gt; NormalizedI) {
00966 
00967         <span class="comment">//</span>
00968         <span class="comment">// When CurrentLocation is greater than where we want to go,</span>
00969         <span class="comment">// if moving forward gets us there quicker than moving backward</span>
00970         <span class="comment">// then it follows that moving forward from the listhead is</span>
00971         <span class="comment">// going to take fewer steps. (This is because, moving forward</span>
00972         <span class="comment">// in this case must move *through* the listhead.)</span>
00973         <span class="comment">//</span>
00974         <span class="comment">// The work here is to figure out if moving backward would be quicker.</span>
00975         <span class="comment">//</span>
00976         <span class="comment">// Moving backward would be quicker only if the location we wish  to</span>
00977         <span class="comment">// go to is more than half way between the listhead and where we</span>
00978         <span class="comment">// currently are.</span>
00979         <span class="comment">//</span>
00980 
00981         <span class="keywordflow">if</span> (NormalizedI &gt; (CurrentLocation/2)) {
00982 
00983             <span class="comment">//</span>
00984             <span class="comment">// Where we want to go is more than half way from the listhead</span>
00985             <span class="comment">// We can traval backwards from our current location.</span>
00986             <span class="comment">//</span>
00987 
00988             <span class="keywordflow">for</span> (
00989                 BackwardDistance = CurrentLocation - NormalizedI;
00990                 BackwardDistance;
00991                 BackwardDistance--
00992                 ) {
00993 
00994                 CurrentNode = CurrentNode-&gt;Blink;
00995 
00996             }
00997         } <span class="keywordflow">else</span> {
00998 
00999             <span class="comment">//</span>
01000             <span class="comment">// Where we want to go is less than halfway between the start</span>
01001             <span class="comment">// and where we currently are.  Start from the listhead.</span>
01002             <span class="comment">//</span>
01003 
01004             <span class="keywordflow">for</span> (
01005                 CurrentNode = &amp;Table-&gt;InsertOrderList;
01006                 NormalizedI;
01007                 NormalizedI--
01008                 ) {
01009 
01010                 CurrentNode = CurrentNode-&gt;Flink;
01011 
01012             }
01013 
01014         }
01015 
01016     } <span class="keywordflow">else</span> {
01017 
01018 
01019         <span class="comment">//</span>
01020         <span class="comment">// When CurrentLocation is less than where we want to go,</span>
01021         <span class="comment">// if moving backwards gets us there quicker than moving forwards</span>
01022         <span class="comment">// then it follows that moving backwards from the listhead is</span>
01023         <span class="comment">// going to take fewer steps. (This is because, moving backwards</span>
01024         <span class="comment">// in this case must move *through* the listhead.)</span>
01025         <span class="comment">//</span>
01026 
01027         ForwardDistance = NormalizedI - CurrentLocation;
01028 
01029         <span class="comment">//</span>
01030         <span class="comment">// Do the backwards calculation as if we are starting from the</span>
01031         <span class="comment">// listhead.</span>
01032         <span class="comment">//</span>
01033 
01034         BackwardDistance = (NumberInTable - NormalizedI) + 1;
01035 
01036         <span class="keywordflow">if</span> (ForwardDistance &lt;= BackwardDistance) {
01037 
01038             <span class="keywordflow">for</span> (
01039                 ;
01040                 ForwardDistance;
01041                 ForwardDistance--
01042                 ) {
01043 
01044                 CurrentNode = CurrentNode-&gt;Flink;
01045 
01046             }
01047 
01048 
01049         } <span class="keywordflow">else</span> {
01050 
01051             <span class="keywordflow">for</span> (
01052                 CurrentNode = &amp;Table-&gt;InsertOrderList;
01053                 BackwardDistance;
01054                 BackwardDistance--
01055                 ) {
01056 
01057                 CurrentNode = CurrentNode-&gt;Blink;
01058 
01059             }
01060 
01061         }
01062 
01063     }
01064 
01065     <span class="comment">//</span>
01066     <span class="comment">// We're where we want to be.  Save our current location and return</span>
01067     <span class="comment">// a pointer to the data to the user.</span>
01068     <span class="comment">//</span>
01069 
01070     Table-&gt;OrderedPointer = CurrentNode;
01071     Table-&gt;WhichOrderedElement = I+1;
01072 
01073     <span class="keywordflow">return</span> &amp;((<a class="code" href="../../d6/d1/gentable_8c.html#a1">PTABLE_ENTRY_HEADER</a>) CONTAINING_RECORD(CurrentNode, <a class="code" href="../../d3/d8/struct__TABLE__ENTRY__HEADER.html">TABLE_ENTRY_HEADER</a>, ListEntry))-&gt;UserData;
01074 
01075 }
01076 
01077 
01078 ULONG
<a name="l01079"></a><a class="code" href="../../d6/d1/gentable_8c.html#a12">01079</a> <a class="code" href="../../d6/d1/gentable_8c.html#a12">RtlNumberGenericTableElements</a>(
01080     IN PRTL_GENERIC_TABLE Table
01081     )
01082 
01083 <span class="comment">/*++</span>
01084 <span class="comment"></span>
01085 <span class="comment">Routine Description:</span>
01086 <span class="comment"></span>
01087 <span class="comment">    The function NumberGenericTableElements returns a ULONG value</span>
01088 <span class="comment">    which is the number of generic table elements currently inserted</span>
01089 <span class="comment">    in the generic table.</span>
01090 <span class="comment"></span>
01091 <span class="comment">Arguments:</span>
01092 <span class="comment"></span>
01093 <span class="comment">    Table - Pointer to the generic table from which to find out the number</span>
01094 <span class="comment">    of elements.</span>
01095 <span class="comment"></span>
01096 <span class="comment"></span>
01097 <span class="comment">Return Value:</span>
01098 <span class="comment"></span>
01099 <span class="comment">    ULONG - The number of elements in the generic table.</span>
01100 <span class="comment"></span>
01101 <span class="comment">--*/</span>
01102 {
01103 
01104     <span class="keywordflow">return</span> Table-&gt;NumberGenericTableElements;
01105 
01106 }
01107 
01108 
01109 PVOID
<a name="l01110"></a><a class="code" href="../../d6/d1/gentable_8c.html#a13">01110</a> <a class="code" href="../../d6/d1/gentable_8c.html#a13">RtlEnumerateGenericTableWithoutSplaying</a> (
01111     IN PRTL_GENERIC_TABLE Table,
01112     IN PVOID *RestartKey
01113     )
01114 
01115 <span class="comment">/*++</span>
01116 <span class="comment"></span>
01117 <span class="comment">Routine Description:</span>
01118 <span class="comment"></span>
01119 <span class="comment">    The function EnumerateGenericTableWithoutSplaying will return to the</span>
01120 <span class="comment">    caller one-by-one the elements of of a table.  The return value is a</span>
01121 <span class="comment">    pointer to the user defined structure associated with the element.</span>
01122 <span class="comment">    The input parameter RestartKey indicates if the enumeration should</span>
01123 <span class="comment">    start from the beginning or should return the next element.  If the</span>
01124 <span class="comment">    are no more new elements to return the return value is NULL.  As an</span>
01125 <span class="comment">    example of its use, to enumerate all of the elements in a table the</span>
01126 <span class="comment">    user would write:</span>
01127 <span class="comment"></span>
01128 <span class="comment">        *RestartKey = NULL;</span>
01129 <span class="comment"></span>
01130 <span class="comment">        for (ptr = EnumerateGenericTableWithoutSplaying(Table, &amp;RestartKey);</span>
01131 <span class="comment">             ptr != NULL;</span>
01132 <span class="comment">             ptr = EnumerateGenericTableWithoutSplaying(Table, &amp;RestartKey)) {</span>
01133 <span class="comment">                :</span>
01134 <span class="comment">        }</span>
01135 <span class="comment"></span>
01136 <span class="comment">Arguments:</span>
01137 <span class="comment"></span>
01138 <span class="comment">    Table - Pointer to the generic table to enumerate.</span>
01139 <span class="comment"></span>
01140 <span class="comment">    RestartKey - Pointer that indicates if we should restart or return the next</span>
01141 <span class="comment">                element.  If the contents of RestartKey is NULL, the search</span>
01142 <span class="comment">                will be started from the beginning.</span>
01143 <span class="comment"></span>
01144 <span class="comment">Return Value:</span>
01145 <span class="comment"></span>
01146 <span class="comment">    PVOID - Pointer to the user data.</span>
01147 <span class="comment"></span>
01148 <span class="comment">--*/</span>
01149 
01150 {
01151 
01152     <span class="keywordflow">if</span> (<a class="code" href="../../d6/d1/gentable_8c.html#a10">RtlIsGenericTableEmpty</a>(Table)) {
01153 
01154         <span class="comment">//</span>
01155         <span class="comment">// Nothing to do if the table is empty.</span>
01156         <span class="comment">//</span>
01157 
01158         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01159 
01160     } <span class="keywordflow">else</span> {
01161 
01162         <span class="comment">//</span>
01163         <span class="comment">// Will be used as the "iteration" through the tree.</span>
01164         <span class="comment">//</span>
01165         PRTL_SPLAY_LINKS NodeToReturn;
01166 
01167         <span class="comment">//</span>
01168         <span class="comment">// If the restart flag is true then go to the least element</span>
01169         <span class="comment">// in the tree.</span>
01170         <span class="comment">//</span>
01171 
01172         <span class="keywordflow">if</span> (*RestartKey == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01173 
01174             <span class="comment">//</span>
01175             <span class="comment">// We just loop until we find the leftmost child of the root.</span>
01176             <span class="comment">//</span>
01177 
01178             <span class="keywordflow">for</span> (
01179                 NodeToReturn = Table-&gt;TableRoot;
01180                 RtlLeftChild(NodeToReturn);
01181                 NodeToReturn = RtlLeftChild(NodeToReturn)
01182                 ) {
01183                 ;
01184             }
01185 
01186             *RestartKey = NodeToReturn;
01187 
01188         } <span class="keywordflow">else</span> {
01189 
01190             <span class="comment">//</span>
01191             <span class="comment">// The caller has passed in the previous entry found</span>
01192             <span class="comment">// in the table to enable us to continue the search.  We call</span>
01193             <span class="comment">// RtlRealSuccessor to step to the next element in the tree.</span>
01194             <span class="comment">//</span>
01195 
01196             NodeToReturn = <a class="code" href="../../d3/d4/splay_8c.html#a8">RtlRealSuccessor</a>(*RestartKey);
01197 
01198             <span class="keywordflow">if</span> (NodeToReturn) {
01199 
01200                 *RestartKey = NodeToReturn;
01201 
01202             }
01203 
01204         }
01205 
01206         <span class="comment">//</span>
01207         <span class="comment">// If there actually is a next element in the enumeration</span>
01208         <span class="comment">// then the pointer to return is right after the list links.</span>
01209         <span class="comment">//</span>
01210 
01211         <span class="keywordflow">return</span> ((NodeToReturn)?
01212                    ((PVOID)&amp;((<a class="code" href="../../d6/d1/gentable_8c.html#a1">PTABLE_ENTRY_HEADER</a>)NodeToReturn)-&gt;UserData)
01213                   :((PVOID)(<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)));
01214 
01215     }
01216 
01217 }
01218 
01219 
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:10 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
