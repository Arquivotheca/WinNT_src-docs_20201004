<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: udfstruc.h Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>udfstruc.h</h1><a href="../../d6/d8/udfstruc_8h.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1989  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    UdfStruc.h</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module defines the data structures that make up the major internal</span>
00012 <span class="comment">    parts of the Udfs file system.</span>
00013 <span class="comment"></span>
00014 <span class="comment">    In-Memory structures:</span>
00015 <span class="comment"></span>
00016 <span class="comment">        The global data structures with the UdfDataRecord.  It contains a pointer</span>
00017 <span class="comment">        to a File System Device object and a queue of Vcb's.  There is a Vcb for</span>
00018 <span class="comment">        every currently or previously mounted volumes.  We may be in the process</span>
00019 <span class="comment">        of tearing down the Vcb's which have been dismounted.  The Vcb's are</span>
00020 <span class="comment">        allocated as an extension to a volume device object.</span>
00021 <span class="comment"></span>
00022 <span class="comment">            +---------+</span>
00023 <span class="comment">            | UdfData |     +--------+</span>
00024 <span class="comment">            |         | --&gt; |FilSysDo|</span>
00025 <span class="comment">            |         |     |        |</span>
00026 <span class="comment">            |         | &lt;+  +--------+</span>
00027 <span class="comment">            +---------+  |</span>
00028 <span class="comment">                         |</span>
00029 <span class="comment">                         |  +--------+     +--------+</span>
00030 <span class="comment">                         |  |VolDo   |     |VolDo   |</span>
00031 <span class="comment">                         |  |        |     |        |</span>
00032 <span class="comment">                         |  +--------+     +--------+</span>
00033 <span class="comment">                         +&gt; |Vcb     | &lt;-&gt; |Vcb     | &lt;-&gt; ...</span>
00034 <span class="comment">                            |        |     |        |</span>
00035 <span class="comment">                            +--------+     +--------+</span>
00036 <span class="comment"></span>
00037 <span class="comment"></span>
00038 <span class="comment">        Each Vcb contains a table of all the Fcbs for the volume indexed by</span>
00039 <span class="comment">        their FileId.  Each Vcb contains a pointer to the root directory of</span>
00040 <span class="comment">        the volume.  Each directory Fcb contains a queue of child Lcb's for</span>
00041 <span class="comment">        its children.  Each Lcb is queued onto both its parent and child Fcb.</span>
00042 <span class="comment">        There can also be detached subtrees due to open operations by Id where</span>
00043 <span class="comment">        the Fcb's are not connected to the root.</span>
00044 <span class="comment"></span>
00045 <span class="comment">        The following diagram shows the root structure.</span>
00046 <span class="comment"></span>
00047 <span class="comment">            +--------+     +--------+</span>
00048 <span class="comment">            |  Vcb   |----&gt;| Fcb    |-------------------------------------------------------------------+</span>
00049 <span class="comment">            |        |     |  Table |----------------------------------------------------------------+  |</span>
00050 <span class="comment">            |        |--+  |        |-------------------------------------------------------------+  |  |</span>
00051 <span class="comment">            +--------+  |  +--------+                                                             |  |  |</span>
00052 <span class="comment">                        |    |  |  |                                                              |  |  |</span>
00053 <span class="comment">                        |    |  |  +---------------------------------------------+                |  |  |</span>
00054 <span class="comment">                        |    V  +-----------------------+                        |                |  |  |</span>
00055 <span class="comment">                        |  +--------+                   |                        |                |  |  |</span>
00056 <span class="comment">                        |  |RootFcb |                   V                        V                |  |  |</span>
00057 <span class="comment">                        +-&gt;|        |    +-----+    +--------+               +--------+           |  |  |</span>
00058 <span class="comment">                           |        |&lt;--&gt;| Lcb |&lt;--&gt;|Child   |    +-----+    |Child   |           |  |  |</span>
00059 <span class="comment">                           +--------+    +-----+    | Fcb    |&lt;--&gt;| Lcb |&lt;--&gt;| Fcb    |&lt;--&gt; ...   |  |  |</span>
00060 <span class="comment">                                                    |        |    +-----+    |        |           |  |  |</span>
00061 <span class="comment">                                                    +--------+               +--------+           |  |  |</span>
00062 <span class="comment">                                                                                                  |  |  |</span>
00063 <span class="comment">                          (Freestanding sub-tree)                                                 |  |  |</span>
00064 <span class="comment">                          +--------+                                                              |  |  |</span>
00065 <span class="comment">                          |OpenById|&lt;-------------------------------------------------------------+  |  |</span>
00066 <span class="comment">                          | Dir    |    +--------+                                                   |  |</span>
00067 <span class="comment">                          |        |---&gt;|OpenById|&lt;--------------------------------------------------+  |</span>
00068 <span class="comment">                          +--------+    | Child  |    +--------+                                        |</span>
00069 <span class="comment">                                        |  Dir   |---&gt;|OpenById|&lt;---------------------------------------+</span>
00070 <span class="comment">                                        +--------+    | Child  |</span>
00071 <span class="comment">                                                      |  File  |</span>
00072 <span class="comment">                                                      +--------+</span>
00073 <span class="comment"></span>
00074 <span class="comment">        Attached to each Directory Fcb is an prefix table containing the</span>
00075 <span class="comment">        Lcbs pointing to children of this directory for which there is an Fcb.</span>
00076 <span class="comment"></span>
00077 <span class="comment">            +--------+      +--------+</span>
00078 <span class="comment">            |  Dir   |      | Prefix |</span>
00079 <span class="comment">            |   Fcb  |-----&gt;|  Table |--------------------+</span>
00080 <span class="comment">            |        |      |        |-------+            |</span>
00081 <span class="comment">            +--------+      +--------+       |            |</span>
00082 <span class="comment">                ^              |             |            |</span>
00083 <span class="comment">                |              |             |            |</span>
00084 <span class="comment">                |              V             V            V</span>
00085 <span class="comment">                |           +--------+    +--------+    +--------+</span>
00086 <span class="comment">                |           |  Lcb   |    |  Lcb   |    |  Lcb   |</span>
00087 <span class="comment">                +----------&gt;|        |&lt;--&gt;|        |&lt;--&gt;|        |</span>
00088 <span class="comment">                            +--------+    +--------+    +--------+</span>
00089 <span class="comment"></span>
00090 <span class="comment">        Each file object open on a UDF volume contains two context pointers.  The</span>
00091 <span class="comment">        first will point back to the Fcb for the file object.  The second, if present,</span>
00092 <span class="comment">        points to a Ccb (ContextControlBlock) which contains the per-handle information.</span>
00093 <span class="comment">        This includes the state of any directory enumeration and the Lcb used to open</span>
00094 <span class="comment">        this file object.</span>
00095 <span class="comment"></span>
00096 <span class="comment">          +--------+       +--------+    +--------+</span>
00097 <span class="comment">          |  Fcb   |&lt;------| File   |    |  Ccb   |</span>
00098 <span class="comment">          |        |       |  Object|---&gt;|        |</span>
00099 <span class="comment">          |        |       |        |    |        |</span>
00100 <span class="comment">          +--------+       +--------+    +--------+</span>
00101 <span class="comment">            ^    ^</span>
00102 <span class="comment">            |    |         +--------+    +--------+</span>
00103 <span class="comment">            |    |         | File   |    |  Ccb   |</span>
00104 <span class="comment">            |    +---------|  Object|---&gt;|        |</span>
00105 <span class="comment">            |              |        |    |        |</span>
00106 <span class="comment">            |              +--------+    +--------+</span>
00107 <span class="comment">            |</span>
00108 <span class="comment">            |              +--------+</span>
00109 <span class="comment">            |              |Stream  |</span>
00110 <span class="comment">            +--------------| File   |</span>
00111 <span class="comment">                           |  Object|</span>
00112 <span class="comment">                           +--------+</span>
00113 <span class="comment"></span>
00114 <span class="comment"></span>
00115 <span class="comment">    Synchronization:</span>
00116 <span class="comment"></span>
00117 <span class="comment">        1. A resource in the UdfData synchronizes access to the Vcb queue.  This</span>
00118 <span class="comment">            is used during mount/verify/dismount operations.</span>
00119 <span class="comment"></span>
00120 <span class="comment">        2. A resource in the Vcb is used to synchronize access to Vcb for</span>
00121 <span class="comment">            open/close operations.  Typically acquired shared, it</span>
00122 <span class="comment">            is acquired exclusively to lock out these operations.</span>
00123 <span class="comment"></span>
00124 <span class="comment">        3. A second resource in the Vcb is used to synchronize all file operations.</span>
00125 <span class="comment">            Typically acquired shared, it is acquired exclusively to lock</span>
00126 <span class="comment">            out all file operations.  Acquiring both Vcb resources will lock</span>
00127 <span class="comment">            the entire volume.</span>
00128 <span class="comment"></span>
00129 <span class="comment">        4. A resource in the nonpaged Fcb will synchronize open/close operations</span>
00130 <span class="comment">            on an Fcb.</span>
00131 <span class="comment"></span>
00132 <span class="comment">        5. A fast mutex in the Vcb will protect access to the Fcb table and</span>
00133 <span class="comment">            the open counts in the Vcb.  It is also used to modify the reference</span>
00134 <span class="comment">            counts in all Fcbs/Lcbs.  This mutex cannot be acquired</span>
00135 <span class="comment">            exclusely and is an end resource.</span>
00136 <span class="comment"></span>
00137 <span class="comment">        6. A fast mutex in the Fcb will synchronize access to all Fcb fields</span>
00138 <span class="comment">            which aren't synchronized in some other way.  A thread may acquire</span>
00139 <span class="comment">            mutexes for multiple Fcb's as long as it works it way toward the</span>
00140 <span class="comment">            root of the tree.  This mutex can also be acquired recursively.</span>
00141 <span class="comment"></span>
00142 <span class="comment">        7. Normal locking order is UdfData/Vcb/Fcb starting at any point in this</span>
00143 <span class="comment">            chain.  The Vcb is required prior to acquiring resources for multiple</span>
00144 <span class="comment">            files.  Shared ownership of the Vcb is sufficient in this case.</span>
00145 <span class="comment"></span>
00146 <span class="comment">        8. Normal locking order when acquiring multiple Fcb's is from some</span>
00147 <span class="comment">            starting Fcb and walking towards the root of tree.  Create typically</span>
00148 <span class="comment">            walks down the tree.  In this case we will attempt to acquire the</span>
00149 <span class="comment">            next node optimistically and if that fails we will reference</span>
00150 <span class="comment">            the current node in the tree, release it and acquire the next node.</span>
00151 <span class="comment">            At that point it will be safe to reacquire the parent node.</span>
00152 <span class="comment"></span>
00153 <span class="comment">        9. Locking order for the Fcb (via the fast mutex) will be from leaf of</span>
00154 <span class="comment">            tree back towards the root.  No other resource may be acquired</span>
00155 <span class="comment">            after locking the Vcb (other than in-page reads).</span>
00156 <span class="comment"></span>
00157 <span class="comment">       10. Cleanup operations only lock the Vcb and Fcb long enough to change the</span>
00158 <span class="comment">            critical counts and share access fields.  No reason to synchronize</span>
00159 <span class="comment">            otherwise.  None of the structures can go away from beneath us</span>
00160 <span class="comment">            in this case.</span>
00161 <span class="comment"></span>
00162 <span class="comment">Author:</span>
00163 <span class="comment"></span>
00164 <span class="comment">    Dan Lovinger    [DanLo]   31-May-1996</span>
00165 <span class="comment"></span>
00166 <span class="comment">Revision History:</span>
00167 <span class="comment"></span>
00168 <span class="comment">--*/</span>
00169 
00170 <span class="preprocessor">#ifndef _UDFSTRUC_</span>
00171 <span class="preprocessor"></span><span class="preprocessor">#define _UDFSTRUC_</span>
00172 <span class="preprocessor"></span>
<a name="l00173"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a55">00173</a> <span class="keyword">typedef</span> PVOID <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>;
00174 
00175 
00176 <span class="comment">//</span>
00177 <span class="comment">//  The following structure is used to encapsulate the converted timestamps for</span>
00178 <span class="comment">//  straightforward referencing.</span>
00179 <span class="comment">//</span>
00180 
<a name="l00181"></a><a class="code" href="../../d4/d1/struct__TIMESTAMP__BUNDLE.html">00181</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d4/d1/struct__TIMESTAMP__BUNDLE.html">_TIMESTAMP_BUNDLE</a> {
00182 
<a name="l00183"></a><a class="code" href="../../d4/d1/struct__TIMESTAMP__BUNDLE.html#o0">00183</a>     LARGE_INTEGER   <a class="code" href="../../d4/d1/struct__TIMESTAMP__BUNDLE.html#o0">CreationTime</a>;
<a name="l00184"></a><a class="code" href="../../d4/d1/struct__TIMESTAMP__BUNDLE.html#o1">00184</a>     LARGE_INTEGER   <a class="code" href="../../d4/d1/struct__TIMESTAMP__BUNDLE.html#o1">AccessTime</a>;
<a name="l00185"></a><a class="code" href="../../d4/d1/struct__TIMESTAMP__BUNDLE.html#o2">00185</a>     LARGE_INTEGER   <a class="code" href="../../d4/d1/struct__TIMESTAMP__BUNDLE.html#o2">ModificationTime</a>;
00186 
00187 } <a class="code" href="../../d4/d1/struct__TIMESTAMP__BUNDLE.html">TIMESTAMP_BUNDLE</a>, *<a class="code" href="../../d4/d1/struct__TIMESTAMP__BUNDLE.html">PTIMESTAMP_BUNDLE</a>;
00188 
00189 
00190 <span class="comment">//</span>
00191 <span class="comment">//  The UDF_DATA record is the top record in the UDF file system in-memory</span>
00192 <span class="comment">//  data structure.  This structure must be allocated from non-paged pool.</span>
00193 <span class="comment">//</span>
00194 
<a name="l00195"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a0">00195</a> <span class="preprocessor">#define NUMBER_OF_FS_OBJECTS    2</span>
00196 <span class="preprocessor"></span>
<a name="l00197"></a><a class="code" href="../../d2/d3/struct__UDF__DATA.html">00197</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d2/d3/struct__UDF__DATA.html">_UDF_DATA</a> {
00198 
00199     <span class="comment">//</span>
00200     <span class="comment">//  The type and size of this record (must be UDFS_NTC_DATA_HEADER)</span>
00201     <span class="comment">//</span>
00202 
<a name="l00203"></a><a class="code" href="../../d2/d3/struct__UDF__DATA.html#o0">00203</a>     <a class="code" href="../../d0/d7/lfs_2nodetype_8h.html#a7">NODE_TYPE_CODE</a> <a class="code" href="../../d2/d3/struct__UDF__DATA.html#o0">NodeTypeCode</a>;
<a name="l00204"></a><a class="code" href="../../d2/d3/struct__UDF__DATA.html#o1">00204</a>     <a class="code" href="../../d0/d7/lfs_2nodetype_8h.html#a9">NODE_BYTE_SIZE</a> <a class="code" href="../../d2/d3/struct__UDF__DATA.html#o1">NodeByteSize</a>;
00205 
00206     <span class="comment">//</span>
00207     <span class="comment">//  A pointer to the Driver object we were initialized with</span>
00208     <span class="comment">//</span>
00209 
<a name="l00210"></a><a class="code" href="../../d2/d3/struct__UDF__DATA.html#o2">00210</a>     <a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html">PDRIVER_OBJECT</a> <a class="code" href="../../d2/d3/struct__UDF__DATA.html#o2">DriverObject</a>;
00211 
00212     <span class="comment">//</span>
00213     <span class="comment">//  Vcb queue.</span>
00214     <span class="comment">//</span>
00215 
<a name="l00216"></a><a class="code" href="../../d2/d3/struct__UDF__DATA.html#o3">00216</a>     LIST_ENTRY <a class="code" href="../../d2/d3/struct__UDF__DATA.html#o3">VcbQueue</a>;
00217 
00218     <span class="comment">//</span>
00219     <span class="comment">//  The following fields are used to allocate IRP context structures</span>
00220     <span class="comment">//  using a lookaside list, and other fixed sized structures from a</span>
00221     <span class="comment">//  small cache.  We use the CdData mutex to protext these structures.</span>
00222     <span class="comment">//</span>
00223 
<a name="l00224"></a><a class="code" href="../../d2/d3/struct__UDF__DATA.html#o4">00224</a>     ULONG <a class="code" href="../../d2/d3/struct__UDF__DATA.html#o4">IrpContextDepth</a>;
<a name="l00225"></a><a class="code" href="../../d2/d3/struct__UDF__DATA.html#o5">00225</a>     ULONG <a class="code" href="../../d2/d3/struct__UDF__DATA.html#o5">IrpContextMaxDepth</a>;
<a name="l00226"></a><a class="code" href="../../d2/d3/struct__UDF__DATA.html#o6">00226</a>     SINGLE_LIST_ENTRY <a class="code" href="../../d2/d3/struct__UDF__DATA.html#o6">IrpContextList</a>;
00227 
00228     <span class="comment">//</span>
00229     <span class="comment">//  Filesystem device objects for UDFS.</span>
00230     <span class="comment">//</span>
00231 
<a name="l00232"></a><a class="code" href="../../d2/d3/struct__UDF__DATA.html#o7">00232</a>     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> <a class="code" href="../../d2/d3/struct__UDF__DATA.html#o7">FileSystemDeviceObjects</a>[<a class="code" href="../../d6/d8/udfstruc_8h.html#a0">NUMBER_OF_FS_OBJECTS</a>];
00233 
00234     <span class="comment">//</span>
00235     <span class="comment">//  Following are used to manage the async and delayed close queue.</span>
00236     <span class="comment">//</span>
00237     <span class="comment">//  FspCloseActive - Indicates whether there is a thread processing the</span>
00238     <span class="comment">//      two close queues.</span>
00239     <span class="comment">//  ReduceDelayedClose - Indicates that we have hit the upper threshold</span>
00240     <span class="comment">//      for the delayed close queue and need to reduce it to lower threshold.</span>
00241     <span class="comment">//</span>
00242     <span class="comment">//  AsyncCloseQueue - Queue of IrpContext waiting for async close operation.</span>
00243     <span class="comment">//  AsyncCloseCount - Number of entries on the async close queue.</span>
00244     <span class="comment">//</span>
00245     <span class="comment">//  DelayedCloseQueue - Queue of IrpContextLite waiting for delayed close</span>
00246     <span class="comment">//      operation.</span>
00247     <span class="comment">//  MaxDelayedCloseCount - Trigger delay close work at this threshold.</span>
00248     <span class="comment">//  MinDelayedCloseCount - Turn off delay close work at this threshold.</span>
00249     <span class="comment">//  DelayedCloseCount - Number of entries on the delayted close queue.</span>
00250     <span class="comment">//</span>
00251     <span class="comment">//  CloseItem - Workqueue item used to start FspClose thread.</span>
00252     <span class="comment">//</span>
00253 
<a name="l00254"></a><a class="code" href="../../d2/d3/struct__UDF__DATA.html#o8">00254</a>     LIST_ENTRY <a class="code" href="../../d2/d3/struct__UDF__DATA.html#o8">AsyncCloseQueue</a>;
<a name="l00255"></a><a class="code" href="../../d2/d3/struct__UDF__DATA.html#o9">00255</a>     ULONG <a class="code" href="../../d2/d3/struct__UDF__DATA.html#o9">AsyncCloseCount</a>;
<a name="l00256"></a><a class="code" href="../../d2/d3/struct__UDF__DATA.html#o10">00256</a>     BOOLEAN <a class="code" href="../../d2/d3/struct__UDF__DATA.html#o10">FspCloseActive</a>;
<a name="l00257"></a><a class="code" href="../../d2/d3/struct__UDF__DATA.html#o11">00257</a>     BOOLEAN <a class="code" href="../../d2/d3/struct__UDF__DATA.html#o11">ReduceDelayedClose</a>;
<a name="l00258"></a><a class="code" href="../../d2/d3/struct__UDF__DATA.html#o12">00258</a>     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> <a class="code" href="../../d2/d3/struct__UDF__DATA.html#o12">PadUshort</a>;
00259 
00260     <span class="comment">//</span>
00261     <span class="comment">//  The following fields describe the deferred close file objects.</span>
00262     <span class="comment">//</span>
00263 
<a name="l00264"></a><a class="code" href="../../d2/d3/struct__UDF__DATA.html#o13">00264</a>     LIST_ENTRY <a class="code" href="../../d2/d3/struct__UDF__DATA.html#o13">DelayedCloseQueue</a>;
<a name="l00265"></a><a class="code" href="../../d2/d3/struct__UDF__DATA.html#o14">00265</a>     ULONG <a class="code" href="../../d2/d3/struct__UDF__DATA.html#o14">DelayedCloseCount</a>;
<a name="l00266"></a><a class="code" href="../../d2/d3/struct__UDF__DATA.html#o15">00266</a>     ULONG <a class="code" href="../../d2/d3/struct__UDF__DATA.html#o15">MaxDelayedCloseCount</a>;
<a name="l00267"></a><a class="code" href="../../d2/d3/struct__UDF__DATA.html#o16">00267</a>     ULONG <a class="code" href="../../d2/d3/struct__UDF__DATA.html#o16">MinDelayedCloseCount</a>;
00268 
00269     <span class="comment">//</span>
00270     <span class="comment">//  Fast mutex used to lock the fields of this structure.</span>
00271     <span class="comment">//</span>
00272 
<a name="l00273"></a><a class="code" href="../../d2/d3/struct__UDF__DATA.html#o17">00273</a>     PVOID <a class="code" href="../../d2/d3/struct__UDF__DATA.html#o17">UdfDataLockThread</a>;
<a name="l00274"></a><a class="code" href="../../d2/d3/struct__UDF__DATA.html#o18">00274</a>     <a class="code" href="../../d6/d9/struct__FAST__MUTEX.html">FAST_MUTEX</a> <a class="code" href="../../d2/d3/struct__UDF__DATA.html#o18">UdfDataMutex</a>;
00275 
00276     <span class="comment">//</span>
00277     <span class="comment">//  A resource variable to control access to the global UDFS data record</span>
00278     <span class="comment">//</span>
00279 
<a name="l00280"></a><a class="code" href="../../d2/d3/struct__UDF__DATA.html#o19">00280</a>     <a class="code" href="../../d6/d4/struct__ERESOURCE.html">ERESOURCE</a> <a class="code" href="../../d2/d3/struct__UDF__DATA.html#o19">DataResource</a>;
00281 
00282     <span class="comment">//</span>
00283     <span class="comment">//  Cache manager call back structure, which must be passed on each call</span>
00284     <span class="comment">//  to CcInitializeCacheMap.</span>
00285     <span class="comment">//</span>
00286 
<a name="l00287"></a><a class="code" href="../../d2/d3/struct__UDF__DATA.html#o20">00287</a>     <a class="code" href="../../d3/d6/struct__CACHE__MANAGER__CALLBACKS.html">CACHE_MANAGER_CALLBACKS</a> <a class="code" href="../../d2/d3/struct__UDF__DATA.html#o20">CacheManagerCallbacks</a>;
<a name="l00288"></a><a class="code" href="../../d2/d3/struct__UDF__DATA.html#o21">00288</a>     <a class="code" href="../../d3/d6/struct__CACHE__MANAGER__CALLBACKS.html">CACHE_MANAGER_CALLBACKS</a> <a class="code" href="../../d2/d3/struct__UDF__DATA.html#o21">CacheManagerVolumeCallbacks</a>;
00289 
00290     <span class="comment">//</span>
00291     <span class="comment">//  This is the ExWorkerItem that does both kinds of deferred closes.</span>
00292     <span class="comment">//</span>
00293 
<a name="l00294"></a><a class="code" href="../../d2/d3/struct__UDF__DATA.html#o22">00294</a>     <a class="code" href="../../d7/d9/struct__WORK__QUEUE__ITEM.html">WORK_QUEUE_ITEM</a> <a class="code" href="../../d2/d3/struct__UDF__DATA.html#o22">CloseItem</a>;
00295 
00296 } <a class="code" href="../../d2/d3/struct__UDF__DATA.html">UDF_DATA</a>, *<a class="code" href="../../d2/d3/struct__UDF__DATA.html">PUDF_DATA</a>;
00297 
00298 
00299 <span class="comment">//</span>
00300 <span class="comment">//  A PARTITION will record the VSN/LSN -&gt; PSN retrieval information for a</span>
00301 <span class="comment">//  partition reference.  Since we do not support multi-volume 13346/UDF,</span>
00302 <span class="comment">//  we will omit noting the volume sequence number that would tell us which</span>
00303 <span class="comment">//  piece of media contained the partition.</span>
00304 <span class="comment">//</span>
00305 <span class="comment">//  There are currently three types of partitions used during operation: physical,</span>
00306 <span class="comment">//  sparable and virtual.  However, since sparing merely adds another last layer</span>
00307 <span class="comment">//  of quick indirection, we consider them as a minor extension of a physical</span>
00308 <span class="comment">//  partition.</span>
00309 <span class="comment">//</span>
00310 
<a name="l00311"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a129">00311</a> <span class="keyword">typedef</span> <span class="keyword">enum</span> <a class="code" href="../../d6/d8/udfstruc_8h.html#a129">_PARTITION_TYPE</a> {
00312     <a class="code" href="../../d6/d8/udfstruc_8h.html#a129a114">Uninitialized</a>,
00313     <a class="code" href="../../d6/d8/udfstruc_8h.html#a129a115">Physical</a>,
00314     <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a2">Virtual</a>
00315 } <a class="code" href="../../d6/d8/udfstruc_8h.html#a60">PARTITION_TYPE</a>, *<a class="code" href="../../d6/d8/udfstruc_8h.html#a61">PPARTITION_TYPE</a>;
00316 
00317 <span class="comment">//</span>
00318 <span class="comment">//  A Physical partition corresponds to a single extent of the volume.</span>
00319 <span class="comment">//</span>
00320 
<a name="l00321"></a><a class="code" href="../../d7/d8/struct__PARTITION__PHYSICAL.html">00321</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d7/d8/struct__PARTITION__PHYSICAL.html">_PARTITION_PHYSICAL</a> {
00322 
00323     <span class="comment">//</span>
00324     <span class="comment">//  Starting Psn and length in sectors</span>
00325     <span class="comment">//</span>
00326 
<a name="l00327"></a><a class="code" href="../../d7/d8/struct__PARTITION__PHYSICAL.html#o0">00327</a>     ULONG <a class="code" href="../../d7/d8/struct__PARTITION__PHYSICAL.html#o0">Start</a>;
<a name="l00328"></a><a class="code" href="../../d7/d8/struct__PARTITION__PHYSICAL.html#o1">00328</a>     ULONG <a class="code" href="../../d7/d8/struct__PARTITION__PHYSICAL.html#o1">Length</a>;
00329 
00330     <span class="comment">//</span>
00331     <span class="comment">//  The partition number is specified by the LVD, and refers to</span>
00332     <span class="comment">//  a specific partition descriptor on the media.  We use this</span>
00333     <span class="comment">//  in the second pass of partition discovery.</span>
00334     <span class="comment">//</span>
00335 
<a name="l00336"></a><a class="code" href="../../d7/d8/struct__PARTITION__PHYSICAL.html#o2">00336</a>     ULONG <a class="code" href="../../d7/d8/struct__PARTITION__PHYSICAL.html#o2">PartitionNumber</a>;
<a name="l00337"></a><a class="code" href="../../d7/d8/struct__PARTITION__PHYSICAL.html#o3">00337</a>     <a class="code" href="../../d7/d2/structNSR__PART.html">PNSR_PART</a> <a class="code" href="../../d7/d8/struct__PARTITION__PHYSICAL.html#o3">PartitionDescriptor</a>;
00338 
00339     <span class="comment">//</span>
00340     <span class="comment">//  Spared partition map, saved temporarily between</span>
00341     <span class="comment">//  logical volume descriptor analysis and partition</span>
00342     <span class="comment">//  descriptor discover/pcb completion.</span>
00343     <span class="comment">//</span>
00344 
<a name="l00345"></a><a class="code" href="../../d7/d8/struct__PARTITION__PHYSICAL.html#o4">00345</a>     <a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html">PPARTMAP_SPARABLE</a> <a class="code" href="../../d7/d8/struct__PARTITION__PHYSICAL.html#o4">SparingMap</a>;
00346 
00347 } <a class="code" href="../../d7/d8/struct__PARTITION__PHYSICAL.html">PARTITION_PHYSICAL</a>, *<a class="code" href="../../d7/d8/struct__PARTITION__PHYSICAL.html">PPARTITION_PHYSICAL</a>;
00348 
00349 <span class="comment">//</span>
00350 <span class="comment">//  A Virtual partition is a remapping from VSN to LSN on a given Physical</span>
00351 <span class="comment">//  partition.  The remapping is done through the VAT FCB.</span>
00352 <span class="comment">//</span>
00353 
<a name="l00354"></a><a class="code" href="../../d8/d8/struct__PARTITION__VIRTUAL.html">00354</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d8/d8/struct__PARTITION__VIRTUAL.html">_PARTITION_VIRTUAL</a>{
00355 
00356     <span class="comment">//</span>
00357     <span class="comment">//  The maximum Vbn in the virtual partition.</span>
00358     <span class="comment">//</span>
00359 
<a name="l00360"></a><a class="code" href="../../d8/d8/struct__PARTITION__VIRTUAL.html#o0">00360</a>     ULONG <a class="code" href="../../d8/d8/struct__PARTITION__VIRTUAL.html#o0">Length</a>;
00361     
00362     <span class="comment">//</span>
00363     <span class="comment">//  A virtual partition refers to its "host" physical partition by partition</span>
00364     <span class="comment">//  number, which we translate to a partition reference during the second pass</span>
00365     <span class="comment">//  of partition discovery.</span>
00366     <span class="comment">//</span>
00367     <span class="comment">//  Example: if the virtual partition is reference 1, hosted on partition 156</span>
00368     <span class="comment">//  (which is reference 0 for this logical volume), then NSRLBA 100/1 would</span>
00369     <span class="comment">//  refer to the block on partition ref 0 as mapped in the VAT at entry 100.</span>
00370     <span class="comment">//</span>
00371 
<a name="l00372"></a><a class="code" href="../../d8/d8/struct__PARTITION__VIRTUAL.html#o1">00372</a>     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> <a class="code" href="../../d8/d8/struct__PARTITION__VIRTUAL.html#o1">RelatedReference</a>;
00373 
00374 } <a class="code" href="../../d8/d8/struct__PARTITION__VIRTUAL.html">PARTITION_VIRTUAL</a>, *<a class="code" href="../../d8/d8/struct__PARTITION__VIRTUAL.html">PPARTITION_VIRTUAL</a>;
00375         
00376 <span class="comment">//</span>
00377 <span class="comment">//  There is exactly one PARTITION per partition.  It is responsible for mapping</span>
00378 <span class="comment">//  from some form of logical sector to a physical sector.</span>
00379 <span class="comment">//</span>
00380 
<a name="l00381"></a><a class="code" href="../../d3/d8/struct__PARTITION.html">00381</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d3/d8/struct__PARTITION.html">_PARTITION</a> {
00382 
00383     <span class="comment">//</span>
00384     <span class="comment">//  This is the type of partition.</span>
00385     <span class="comment">//</span>
00386 
<a name="l00387"></a><a class="code" href="../../d3/d8/struct__PARTITION.html#o0">00387</a>     <a class="code" href="../../d6/d8/udfstruc_8h.html#a60">PARTITION_TYPE</a> <a class="code" href="../../d3/d8/struct__PARTITION.html#o0">Type</a>;
00388 
00389     <span class="keyword">union </span>{
00390 
<a name="l00391"></a><a class="code" href="../../d3/d8/struct__PARTITION.html#o1">00391</a>         <a class="code" href="../../d7/d8/struct__PARTITION__PHYSICAL.html">PARTITION_PHYSICAL</a> <a class="code" href="../../d3/d8/struct__PARTITION.html#o1">Physical</a>;
<a name="l00392"></a><a class="code" href="../../d3/d8/struct__PARTITION.html#o2">00392</a>         <a class="code" href="../../d8/d8/struct__PARTITION__VIRTUAL.html">PARTITION_VIRTUAL</a> <a class="code" href="../../d3/d8/struct__PARTITION.html#o2">Virtual</a>;
00393     };
00394 
00395 } <a class="code" href="../../d2/d9/struct__tagPARTITION.html">PARTITION</a>, *<a class="code" href="../../d2/d9/struct__tagPARTITION.html">PPARTITION</a>;
00396 
00397 <span class="comment">//</span>
00398 <span class="comment">//  The Pcb (Partition control block) record corresponds to the partitions</span>
00399 <span class="comment">//  which collectively form the mounted volume.  Exactly one of these is</span>
00400 <span class="comment">//  linked off of the Vcb.</span>
00401 <span class="comment">//</span>
00402 
<a name="l00403"></a><a class="code" href="../../d4/d9/struct__PCB.html">00403</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d4/d9/struct__PCB.html">_PCB</a> {
00404 
00405     <span class="comment">//</span>
00406     <span class="comment">//  The type and size of this record (must be UDFS_NTC_PCB)</span>
00407     <span class="comment">//</span>
00408 
<a name="l00409"></a><a class="code" href="../../d4/d9/struct__PCB.html#o0">00409</a>     <a class="code" href="../../d0/d7/lfs_2nodetype_8h.html#a7">NODE_TYPE_CODE</a> <a class="code" href="../../d4/d9/struct__PCB.html#o0">NodeTypeCode</a>;
<a name="l00410"></a><a class="code" href="../../d4/d9/struct__PCB.html#o1">00410</a>     <a class="code" href="../../d0/d7/lfs_2nodetype_8h.html#a9">NODE_BYTE_SIZE</a> <a class="code" href="../../d4/d9/struct__PCB.html#o1">NodeByteSize</a>;
00411 
00412     <span class="comment">//</span>
00413     <span class="comment">//  This is the number of partitions in the map</span>
00414     <span class="comment">//</span>
00415 
<a name="l00416"></a><a class="code" href="../../d4/d9/struct__PCB.html#o2">00416</a>     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> <a class="code" href="../../d4/d9/struct__PCB.html#o2">Partitions</a>;
00417 
00418     <span class="comment">//</span>
00419     <span class="comment">//  A bitmask of flags.</span>
00420     <span class="comment">//</span>
00421 
<a name="l00422"></a><a class="code" href="../../d4/d9/struct__PCB.html#o3">00422</a>     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> <a class="code" href="../../d4/d9/struct__PCB.html#o3">Flags</a>;
00423 
00424     <span class="comment">//</span>
00425     <span class="comment">//  Sparing Mcb, if this volume has sparing.</span>
00426     <span class="comment">//</span>
00427 
<a name="l00428"></a><a class="code" href="../../d4/d9/struct__PCB.html#o4">00428</a>     <a class="code" href="../../d0/d9/struct__LARGE__MCB.html">PLARGE_MCB</a> <a class="code" href="../../d4/d9/struct__PCB.html#o4">SparingMcb</a>;
00429 
00430     <span class="comment">//</span>
00431     <span class="comment">//  This is the mapping table.  A PCB will be dynamically sized</span>
00432     <span class="comment">//  according to the number of partitions forming the volume.</span>
00433     <span class="comment">//</span>
00434 
<a name="l00435"></a><a class="code" href="../../d4/d9/struct__PCB.html#o5">00435</a>     <a class="code" href="../../d2/d9/struct__tagPARTITION.html">PARTITION</a> <a class="code" href="../../d4/d9/struct__PCB.html#o5">Partition</a>[0];
00436 
00437 } <a class="code" href="../../d4/d9/struct__PCB.html">PCB</a>, *<a class="code" href="../../d4/d9/struct__PCB.html">PPCB</a>;
00438 
00439 <span class="comment">//</span>
00440 <span class="comment">//  Indicate what kinds of partitions are contained for quick checks.</span>
00441 <span class="comment">//</span>
00442 
<a name="l00443"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a1">00443</a> <span class="preprocessor">#define PCB_FLAG_PHYSICAL_PARTITION     0x0001</span>
<a name="l00444"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a2">00444</a> <span class="preprocessor"></span><span class="preprocessor">#define PCB_FLAG_VIRTUAL_PARTITION      0x0002</span>
<a name="l00445"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a3">00445</a> <span class="preprocessor"></span><span class="preprocessor">#define PCB_FLAG_SPARABLE_PARTITION     0x0004</span>
00446 <span class="preprocessor"></span>
00447 
00448 <span class="comment">//</span>
00449 <span class="comment">//  The Vmcb structure is a double mapped structure for mapping</span>
00450 <span class="comment">//  between VBNs and LBNs using the MCB structures.  The whole structure</span>
00451 <span class="comment">//  is also protected by a private mutex.  This record must be allocated</span>
00452 <span class="comment">//  from non-paged pool.</span>
00453 <span class="comment">//</span>
00454 
00455 <span class="comment">//</span>
00456 <span class="comment">//  We use an #if to snip out historical code in the Vmcb package that</span>
00457 <span class="comment">//  dealt with write issues, leaving it for the future.</span>
00458 <span class="comment">//</span>
00459 
<a name="l00460"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a4">00460</a> <span class="preprocessor">#define VMCB_WRITE_SUPPORT 0</span>
00461 <span class="preprocessor"></span>
<a name="l00462"></a><a class="code" href="../../d1/d7/struct__VMCB.html">00462</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d1/d7/struct__VMCB.html">_VMCB</a> {
00463 
<a name="l00464"></a><a class="code" href="../../d1/d7/struct__VMCB.html#o0">00464</a>     <a class="code" href="../../d3/d7/struct__KMUTANT.html">KMUTEX</a> <a class="code" href="../../d1/d7/struct__VMCB.html#o0">Mutex</a>;
00465 
<a name="l00466"></a><a class="code" href="../../d1/d7/struct__VMCB.html#o1">00466</a>     <a class="code" href="../../d2/d7/struct__MCB.html">MCB</a> <a class="code" href="../../d1/d7/struct__VMCB.html#o1">VbnIndexed</a>;     <span class="comment">// maps VBNs to LBNs</span>
<a name="l00467"></a><a class="code" href="../../d1/d7/struct__VMCB.html#o2">00467</a>     <a class="code" href="../../d2/d7/struct__MCB.html">MCB</a> <a class="code" href="../../d1/d7/struct__VMCB.html#o2">LbnIndexed</a>;     <span class="comment">// maps LBNs to VBNs</span>
00468 
<a name="l00469"></a><a class="code" href="../../d1/d7/struct__VMCB.html#o3">00469</a>     ULONG <a class="code" href="../../d1/d7/struct__VMCB.html#o3">MaximumLbn</a>;
00470 
<a name="l00471"></a><a class="code" href="../../d1/d7/struct__VMCB.html#o4">00471</a>     ULONG <a class="code" href="../../d1/d7/struct__VMCB.html#o4">SectorSize</a>;
00472 
00473 <span class="preprocessor">#if VMCB_WRITE_SUPPORT</span>
00474 <span class="preprocessor"></span>
00475     RTL_GENERIC_TABLE DirtyTable;
00476 
00477 <span class="preprocessor">#endif // VMCB_WRITE_SUPPORT</span>
00478 <span class="preprocessor"></span>
00479 } <a class="code" href="../../d1/d7/struct__VMCB.html">VMCB</a>, *<a class="code" href="../../d1/d7/struct__VMCB.html">PVMCB</a>;
00480 
00481 <span class="comment">//</span>
00482 <span class="comment">//  The Vcb (Volume control block) record corresponds to every</span>
00483 <span class="comment">//  volume mounted by the file system.  They are ordered in a queue off</span>
00484 <span class="comment">//  of UdfData.VcbQueue.</span>
00485 <span class="comment">//</span>
00486 <span class="comment">//  The Vcb will be in several conditions during its lifespan.</span>
00487 <span class="comment">//</span>
00488 <span class="comment">//      NotMounted - Disk is not currently mounted (i.e. removed</span>
00489 <span class="comment">//          from system) but cleanup and close operations are</span>
00490 <span class="comment">//          supported.</span>
00491 <span class="comment">//</span>
00492 <span class="comment">//      MountInProgress - State of the Vcb from the time it is</span>
00493 <span class="comment">//          created until it is successfully mounted or the mount</span>
00494 <span class="comment">//          fails.</span>
00495 <span class="comment">//</span>
00496 <span class="comment">//      Mounted - Volume is currently in the mounted state.</span>
00497 <span class="comment">//</span>
00498 <span class="comment">//      Invalid - User has invalidated the volume.  Only legal operations</span>
00499 <span class="comment">//          are cleanup and close.</span>
00500 <span class="comment">//</span>
00501 <span class="comment">//      DismountInProgress - We have begun the process of tearing down the</span>
00502 <span class="comment">//          Vcb.  It can be deleted when all the references to it</span>
00503 <span class="comment">//          have gone away.</span>
00504 <span class="comment">//</span>
00505 
<a name="l00506"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a130">00506</a> <span class="keyword">typedef</span> <span class="keyword">enum</span> <a class="code" href="../../d6/d8/udfstruc_8h.html#a130">_VCB_CONDITION</a> {
00507 
00508     <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a117">VcbNotMounted</a> = 0,
00509     <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a118">VcbMountInProgress</a>,
00510     <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a119">VcbMounted</a>,
00511     <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a120">VcbInvalid</a>,
00512     <a class="code" href="../../d6/d8/udfstruc_8h.html#a130a121">VcbDismountInProgress</a>
00513 
00514 } <a class="code" href="../../d6/d8/udfstruc_8h.html#a72">VCB_CONDITION</a>;
00515 
<a name="l00516"></a><a class="code" href="../../d7/d5/struct__VCB.html">00516</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d7/d5/struct__VCB.html">_VCB</a> {
00517 
00518     <span class="comment">//</span>
00519     <span class="comment">//  The type and size of this record (must be UDFS_NTC_VCB)</span>
00520     <span class="comment">//</span>
00521 
<a name="l00522"></a><a class="code" href="../../d7/d5/struct__VCB.html#o0">00522</a>     <a class="code" href="../../d0/d7/lfs_2nodetype_8h.html#a7">NODE_TYPE_CODE</a> <a class="code" href="../../d7/d5/struct__VCB.html#o0">NodeTypeCode</a>;
<a name="l00523"></a><a class="code" href="../../d7/d5/struct__VCB.html#o1">00523</a>     <a class="code" href="../../d0/d7/lfs_2nodetype_8h.html#a9">NODE_BYTE_SIZE</a> <a class="code" href="../../d7/d5/struct__VCB.html#o1">NodeByteSize</a>;
00524 
00525     <span class="comment">//</span>
00526     <span class="comment">//  Vpb for this volume.</span>
00527     <span class="comment">//</span>
00528 
<a name="l00529"></a><a class="code" href="../../d7/d5/struct__VCB.html#o2">00529</a>     <a class="code" href="../../d7/d7/struct__VPB.html">PVPB</a> <a class="code" href="../../d7/d5/struct__VCB.html#o2">Vpb</a>;
00530 
00531     <span class="comment">//</span>
00532     <span class="comment">//  Pcb for this volume.</span>
00533     <span class="comment">//</span>
00534 
<a name="l00535"></a><a class="code" href="../../d7/d5/struct__VCB.html#o3">00535</a>     <a class="code" href="../../d6/d8/udfstruc_8h.html#a69">PPCB</a> <a class="code" href="../../d7/d5/struct__VCB.html#o3">Pcb</a>;
00536 
00537     <span class="comment">//</span>
00538     <span class="comment">//  Device object for the driver below us.</span>
00539     <span class="comment">//</span>
00540 
<a name="l00541"></a><a class="code" href="../../d7/d5/struct__VCB.html#o4">00541</a>     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> <a class="code" href="../../d7/d5/struct__VCB.html#o4">TargetDeviceObject</a>;
00542 
00543     <span class="comment">//</span>
00544     <span class="comment">//  Link into queue of Vcb's in the UdfData structure.  We will create a union with</span>
00545     <span class="comment">//  a LONGLONG to force the Vcb to be quad-aligned.</span>
00546     <span class="comment">//</span>
00547 
00548     <span class="keyword">union </span>{
00549 
<a name="l00550"></a><a class="code" href="../../d7/d5/struct__VCB.html#o5">00550</a>         LIST_ENTRY <a class="code" href="../../d7/d5/struct__VCB.html#o5">VcbLinks</a>;
<a name="l00551"></a><a class="code" href="../../d7/d5/struct__VCB.html#o6">00551</a>         LONGLONG <a class="code" href="../../d7/d5/struct__VCB.html#o6">Alignment</a>;
00552     };
00553 
00554     <span class="comment">//</span>
00555     <span class="comment">//  State flags and condition for the Vcb.</span>
00556     <span class="comment">//</span>
00557 
<a name="l00558"></a><a class="code" href="../../d7/d5/struct__VCB.html#o7">00558</a>     ULONG <a class="code" href="../../d7/d5/struct__VCB.html#o7">VcbState</a>;
<a name="l00559"></a><a class="code" href="../../d7/d5/struct__VCB.html#o8">00559</a>     <a class="code" href="../../d6/d8/udfstruc_8h.html#a72">VCB_CONDITION</a> <a class="code" href="../../d7/d5/struct__VCB.html#o8">VcbCondition</a>;
00560 
00561     <span class="comment">//</span>
00562     <span class="comment">//  File object used to lock the volume.</span>
00563     <span class="comment">//</span>
00564 
<a name="l00565"></a><a class="code" href="../../d7/d5/struct__VCB.html#o9">00565</a>     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> <a class="code" href="../../d7/d5/struct__VCB.html#o9">VolumeLockFileObject</a>;
00566 
00567     <span class="comment">//</span>
00568     <span class="comment">//  Media change count from device driver for bulletproof detection</span>
00569     <span class="comment">//  of media movement</span>
00570     <span class="comment">//</span>
00571 
<a name="l00572"></a><a class="code" href="../../d7/d5/struct__VCB.html#o10">00572</a>     ULONG <a class="code" href="../../d7/d5/struct__VCB.html#o10">MediaChangeCount</a>;
00573 
00574     <span class="comment">//</span>
00575     <span class="comment">//  Logical block size for this volume.</span>
00576     <span class="comment">//</span>
00577 
<a name="l00578"></a><a class="code" href="../../d7/d5/struct__VCB.html#o11">00578</a>     ULONG <a class="code" href="../../d7/d5/struct__VCB.html#o11">SectorSize</a>;
00579 
00580     <span class="comment">//</span>
00581     <span class="comment">//  Associated shift size</span>
00582     <span class="comment">//</span>
00583 
<a name="l00584"></a><a class="code" href="../../d7/d5/struct__VCB.html#o12">00584</a>     ULONG <a class="code" href="../../d7/d5/struct__VCB.html#o12">SectorShift</a>;
00585 
00586     <span class="comment">//</span>
00587     <span class="comment">//  LSN of the bounds that CD-UDF defines.</span>
00588     <span class="comment">//</span>
00589     <span class="comment">//  S - start of the session that contains the AVD @ +256</span>
00590     <span class="comment">//  N - end of the disc, another chance to find AVD @ -256,</span>
00591     <span class="comment">//      and discovery of the VAT ICB.</span>
00592     <span class="comment">//</span>
00593     <span class="comment">//  N may be unset until late in the mount sequence for a volume, since</span>
00594     <span class="comment">//  the device may not respond to CD-style TOC requests, and only then</span>
00595     <span class="comment">//  be a guess based on the partitons we find. S will be zero except in</span>
00596     <span class="comment">//  the case of CD-UDF.  In a mounted system, S will correspond to where</span>
00597     <span class="comment">//  we started finding the volume descriptors that let us proceed.</span>
00598     <span class="comment">//</span>
00599 
<a name="l00600"></a><a class="code" href="../../d7/d5/struct__VCB.html#o13">00600</a>     ULONG <a class="code" href="../../d7/d5/struct__VCB.html#o13">BoundS</a>;
<a name="l00601"></a><a class="code" href="../../d7/d5/struct__VCB.html#o14">00601</a>     ULONG <a class="code" href="../../d7/d5/struct__VCB.html#o14">BoundN</a>;
00602 
00603     <span class="comment">//</span>
00604     <span class="comment">//  Various counts for this Vcb.</span>
00605     <span class="comment">//</span>
00606     <span class="comment">//      VcbCleanup - Open handles left on this system.</span>
00607     <span class="comment">//      VcbReference - Number of reasons this Vcb is still present.</span>
00608     <span class="comment">//      VcbUserReference - Number of user file objects still present.</span>
00609     <span class="comment">//</span>
00610 
<a name="l00611"></a><a class="code" href="../../d7/d5/struct__VCB.html#o15">00611</a>     ULONG <a class="code" href="../../d7/d5/struct__VCB.html#o15">VcbCleanup</a>;
<a name="l00612"></a><a class="code" href="../../d7/d5/struct__VCB.html#o16">00612</a>     ULONG <a class="code" href="../../d7/d5/struct__VCB.html#o16">VcbReference</a>;
<a name="l00613"></a><a class="code" href="../../d7/d5/struct__VCB.html#o17">00613</a>     ULONG <a class="code" href="../../d7/d5/struct__VCB.html#o17">VcbUserReference</a>;
00614 
00615     <span class="comment">//</span>
00616     <span class="comment">//  These are the number of times a mounted Vcb will be referenced on behalf</span>
00617     <span class="comment">//  of the system.  See commentary in udfdata.h.</span>
00618     <span class="comment">//</span>
00619 
<a name="l00620"></a><a class="code" href="../../d7/d5/struct__VCB.html#o18">00620</a>     ULONG <a class="code" href="../../d7/d5/struct__VCB.html#o18">VcbResidualReference</a>;
<a name="l00621"></a><a class="code" href="../../d7/d5/struct__VCB.html#o19">00621</a>     ULONG <a class="code" href="../../d7/d5/struct__VCB.html#o19">VcbResidualUserReference</a>;
00622 
00623     <span class="comment">//</span>
00624     <span class="comment">//  Fcb for the Volume Dasd file, root directory and the Vmcb-mapped Metadata stream.</span>
00625     <span class="comment">//  The VAT Fcb is only created on CD UDF media, for the Virtual Allocation Table.</span>
00626     <span class="comment">//</span>
00627 
<a name="l00628"></a><a class="code" href="../../d7/d5/struct__VCB.html#o20">00628</a>     <span class="keyword">struct </span><a class="code" href="../../d7/d9/struct__FCB.html">_FCB</a> *<a class="code" href="../../d7/d5/struct__VCB.html#o20">VolumeDasdFcb</a>;
<a name="l00629"></a><a class="code" href="../../d7/d5/struct__VCB.html#o21">00629</a>     <span class="keyword">struct </span><a class="code" href="../../d7/d9/struct__FCB.html">_FCB</a> *<a class="code" href="../../d7/d5/struct__VCB.html#o21">RootIndexFcb</a>;
<a name="l00630"></a><a class="code" href="../../d7/d5/struct__VCB.html#o22">00630</a>     <span class="keyword">struct </span><a class="code" href="../../d7/d9/struct__FCB.html">_FCB</a> *<a class="code" href="../../d7/d5/struct__VCB.html#o22">MetadataFcb</a>;
<a name="l00631"></a><a class="code" href="../../d7/d5/struct__VCB.html#o23">00631</a>     <span class="keyword">struct </span><a class="code" href="../../d7/d9/struct__FCB.html">_FCB</a> *<a class="code" href="../../d7/d5/struct__VCB.html#o23">VatFcb</a>;
00632 
00633     <span class="comment">//</span>
00634     <span class="comment">//  Vmcb for the metadata stream</span>
00635     <span class="comment">//</span>
00636 
<a name="l00637"></a><a class="code" href="../../d7/d5/struct__VCB.html#o24">00637</a>     <a class="code" href="../../d1/d7/struct__VMCB.html">VMCB</a> <a class="code" href="../../d7/d5/struct__VCB.html#o24">Vmcb</a>;
00638     
00639     <span class="comment">//</span>
00640     <span class="comment">//  Vcb resource.  This is used to synchronize open/cleanup/close operations.</span>
00641     <span class="comment">//</span>
00642 
<a name="l00643"></a><a class="code" href="../../d7/d5/struct__VCB.html#o25">00643</a>     <a class="code" href="../../d6/d4/struct__ERESOURCE.html">ERESOURCE</a> <a class="code" href="../../d7/d5/struct__VCB.html#o25">VcbResource</a>;
00644 
00645     <span class="comment">//</span>
00646     <span class="comment">//  File resource.  This is used to synchronize all file operations except</span>
00647     <span class="comment">//  open/cleanup/close.</span>
00648     <span class="comment">//</span>
00649 
<a name="l00650"></a><a class="code" href="../../d7/d5/struct__VCB.html#o26">00650</a>     <a class="code" href="../../d6/d4/struct__ERESOURCE.html">ERESOURCE</a> <a class="code" href="../../d7/d5/struct__VCB.html#o26">FileResource</a>;
00651 
00652     <span class="comment">//</span>
00653     <span class="comment">//  Vcb fast mutex.  This is used to synchronize the fields in the Vcb</span>
00654     <span class="comment">//  when modified when the Vcb is not held exclusively.  Included here</span>
00655     <span class="comment">//  are the count fields and Fcb table.</span>
00656     <span class="comment">//</span>
00657     <span class="comment">//  We also use this to synchronize changes to the Fcb reference field.</span>
00658     <span class="comment">//</span>
00659 
<a name="l00660"></a><a class="code" href="../../d7/d5/struct__VCB.html#o27">00660</a>     <a class="code" href="../../d6/d9/struct__FAST__MUTEX.html">FAST_MUTEX</a> <a class="code" href="../../d7/d5/struct__VCB.html#o27">VcbMutex</a>;
<a name="l00661"></a><a class="code" href="../../d7/d5/struct__VCB.html#o28">00661</a>     PVOID <a class="code" href="../../d7/d5/struct__VCB.html#o28">VcbLockThread</a>;
00662 
00663     <span class="comment">//</span>
00664     <span class="comment">//  The following is used to synchronize the dir notify package.</span>
00665     <span class="comment">//</span>
00666 
<a name="l00667"></a><a class="code" href="../../d7/d5/struct__VCB.html#o29">00667</a>     <a class="code" href="../../d1/d8/fsrtl_8h.html#a81">PNOTIFY_SYNC</a> <a class="code" href="../../d7/d5/struct__VCB.html#o29">NotifySync</a>;
00668 
00669     <span class="comment">//</span>
00670     <span class="comment">//  The following is the head of a list of notify Irps.</span>
00671     <span class="comment">//</span>
00672 
<a name="l00673"></a><a class="code" href="../../d7/d5/struct__VCB.html#o30">00673</a>     LIST_ENTRY <a class="code" href="../../d7/d5/struct__VCB.html#o30">DirNotifyList</a>;
00674 
00675     <span class="comment">//</span>
00676     <span class="comment">//  Fcb table.  Synchronized with the Vcb fast mutex.</span>
00677     <span class="comment">//</span>
00678 
<a name="l00679"></a><a class="code" href="../../d7/d5/struct__VCB.html#o31">00679</a>     RTL_GENERIC_TABLE <a class="code" href="../../d7/d5/struct__VCB.html#o31">FcbTable</a>;
00680 
00681 } <a class="code" href="../../d7/d5/struct__VCB.html">VCB</a>, *<a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a>;
00682 
<a name="l00683"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a5">00683</a> <span class="preprocessor">#define VCB_STATE_LOCKED                            (0x00000001)</span>
<a name="l00684"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a6">00684</a> <span class="preprocessor"></span><span class="preprocessor">#define VCB_STATE_REMOVABLE_MEDIA                   (0x00000002)</span>
<a name="l00685"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a7">00685</a> <span class="preprocessor"></span><span class="preprocessor">#define VCB_STATE_NOTIFY_REMOUNT                    (0x00000004)</span>
<a name="l00686"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a8">00686</a> <span class="preprocessor"></span><span class="preprocessor">#define VCB_STATE_METHOD_2_FIXUP                    (0x00000008)</span>
00687 <span class="preprocessor"></span>
00688 
00689 <span class="comment">//</span>
00690 <span class="comment">//  The Volume Device Object is an I/O system device object with a</span>
00691 <span class="comment">//  workqueue and an VCB record appended to the end.  There are multiple</span>
00692 <span class="comment">//  of these records, one for every mounted volume, and are created during</span>
00693 <span class="comment">//  a volume mount operation.  The work queue is for handling an overload</span>
00694 <span class="comment">//  of work requests to the volume.</span>
00695 <span class="comment">//</span>
00696 
<a name="l00697"></a><a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html">00697</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html">_VOLUME_DEVICE_OBJECT</a> {
00698 
<a name="l00699"></a><a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html#o0">00699</a>     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">DEVICE_OBJECT</a> <a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html#o0">DeviceObject</a>;
00700 
00701     <span class="comment">//</span>
00702     <span class="comment">//  The following field tells how many requests for this volume have</span>
00703     <span class="comment">//  either been enqueued to ExWorker threads or are currently being</span>
00704     <span class="comment">//  serviced by ExWorker threads.  If the number goes above</span>
00705     <span class="comment">//  a certain threshold, put the request on the overflow queue to be</span>
00706     <span class="comment">//  executed later.</span>
00707     <span class="comment">//</span>
00708 
<a name="l00709"></a><a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html#o1">00709</a>     ULONG <a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html#o1">PostedRequestCount</a>;
00710 
00711     <span class="comment">//</span>
00712     <span class="comment">//  The following field indicates the number of IRP's waiting</span>
00713     <span class="comment">//  to be serviced in the overflow queue.</span>
00714     <span class="comment">//</span>
00715 
<a name="l00716"></a><a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html#o2">00716</a>     ULONG <a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html#o2">OverflowQueueCount</a>;
00717 
00718     <span class="comment">//</span>
00719     <span class="comment">//  The following field contains the queue header of the overflow queue.</span>
00720     <span class="comment">//  The Overflow queue is a list of IRP's linked via the IRP's ListEntry</span>
00721     <span class="comment">//  field.</span>
00722     <span class="comment">//</span>
00723 
<a name="l00724"></a><a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html#o3">00724</a>     LIST_ENTRY <a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html#o3">OverflowQueue</a>;
00725 
00726     <span class="comment">//</span>
00727     <span class="comment">//  The following spinlock protects access to all the above fields.</span>
00728     <span class="comment">//</span>
00729 
<a name="l00730"></a><a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html#o4">00730</a>     KSPIN_LOCK <a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html#o4">OverflowQueueSpinLock</a>;
00731 
00732     <span class="comment">//</span>
00733     <span class="comment">//  This is the file system specific volume control block.</span>
00734     <span class="comment">//</span>
00735 
<a name="l00736"></a><a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html#o5">00736</a>     <a class="code" href="../../d7/d5/struct__VCB.html">VCB</a> <a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html#o5">Vcb</a>;
00737 
00738 } <a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html">VOLUME_DEVICE_OBJECT</a>, *<a class="code" href="../../d6/d7/struct__VOLUME__DEVICE__OBJECT.html">PVOLUME_DEVICE_OBJECT</a>;
00739 
00740 
00741 <span class="comment">//</span>
00742 <span class="comment">//  Udfs file id is a large integer. This corresponds to the FileInternalInformation</span>
00743 <span class="comment">//  query type and is used for internal FCB indexing.</span>
00744 <span class="comment">//</span>
00745 
<a name="l00746"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a78">00746</a> <span class="keyword">typedef</span> LARGE_INTEGER                   <a class="code" href="../../d6/d8/udfstruc_8h.html#a77">FILE_ID</a>, *<a class="code" href="../../d6/d8/udfstruc_8h.html#a78">PFILE_ID</a>;
00747 
00748 
00749 <span class="comment">//</span>
00750 <span class="comment">//  Lcb (Link Control Block), which corresponds to a link from a directory (or in</span>
00751 <span class="comment">//  the future, other container objects) to a file (UDF File Identifier).  There is</span>
00752 <span class="comment">//  one of these for each name tuple in a prefix table.</span>
00753 <span class="comment">//</span>
00754 
00755 <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d5/d9/struct__LCB.html">_LCB</a> {
00756 
00757     <span class="comment">//</span>
00758     <span class="comment">//  Type and size of this record (must be UDFS_NTC_LCB)</span>
00759     <span class="comment">//</span>
00760 
<a name="l00761"></a><a class="code" href="../../d5/d9/struct__LCB.html#o0">00761</a>     <a class="code" href="../../d0/d7/lfs_2nodetype_8h.html#a7">NODE_TYPE_CODE</a> <a class="code" href="../../d5/d9/struct__LCB.html#o0">NodeTypeCode</a>;
<a name="l00762"></a><a class="code" href="../../d5/d9/struct__LCB.html#o1">00762</a>     <a class="code" href="../../d0/d7/lfs_2nodetype_8h.html#a9">NODE_BYTE_SIZE</a> <a class="code" href="../../d5/d9/struct__LCB.html#o1">NodeByteSize</a>;
00763 
00764     <span class="comment">//</span>
00765     <span class="comment">//  Pointer to the Parent Fcb for this entry and queue for Parent to</span>
00766     <span class="comment">//  find all referencing Lcbs.  Corresponds to Fcb-&gt;ChildLcbQueue.</span>
00767     <span class="comment">//</span>
00768 
<a name="l00769"></a><a class="code" href="../../d5/d9/struct__LCB.html#o8">00769</a>     LIST_ENTRY <a class="code" href="../../d5/d9/struct__LCB.html#o8">ParentFcbLinks</a>;
<a name="l00770"></a><a class="code" href="../../d5/d9/struct__LCB.html#o9">00770</a>     <span class="keyword">struct </span><a class="code" href="../../d7/d9/struct__FCB.html">_FCB</a> *<a class="code" href="../../d5/d9/struct__LCB.html#o9">ParentFcb</a>;
00771 
00772     <span class="comment">//</span>
00773     <span class="comment">//  Pointer to Child (referenced) Fcb for this entry and queue for Child</span>
00774     <span class="comment">//  to find all referencing Lcbs.  Corresponds to Fcb-&gt;ParentLcbQueue.</span>
00775     <span class="comment">//</span>
00776 
<a name="l00777"></a><a class="code" href="../../d5/d9/struct__LCB.html#o10">00777</a>     LIST_ENTRY <a class="code" href="../../d5/d9/struct__LCB.html#o10">ChildFcbLinks</a>;
<a name="l00778"></a><a class="code" href="../../d5/d9/struct__LCB.html#o11">00778</a>     <span class="keyword">struct </span><a class="code" href="../../d7/d9/struct__FCB.html">_FCB</a> *<a class="code" href="../../d5/d9/struct__LCB.html#o11">ChildFcb</a>;
00779 
00780     <span class="comment">//</span>
00781     <span class="comment">//  Number of extra realtime references made to this Lcb.</span>
00782     <span class="comment">//</span>
00783 
<a name="l00784"></a><a class="code" href="../../d5/d9/struct__LCB.html#o12">00784</a>     ULONG <a class="code" href="../../d5/d9/struct__LCB.html#o12">Reference</a>;
00785 
00786     <span class="comment">//</span>
00787     <span class="comment">//  Flags indicating the state of this Lcb.</span>
00788     <span class="comment">//</span>
00789 
<a name="l00790"></a><a class="code" href="../../d5/d9/struct__LCB.html#o13">00790</a>     ULONG <a class="code" href="../../d5/d9/struct__LCB.html#o13">Flags</a>;
00791 
00792     <span class="comment">//</span>
00793     <span class="comment">//  File attributes to be merged with the child Fcb.  UDF seperates interesting</span>
00794     <span class="comment">//  information into the FID and FE so, properly, the name link (corresponding to</span>
00795     <span class="comment">//  a FID) must record some extra information.</span>
00796     <span class="comment">//</span>
00797 
<a name="l00798"></a><a class="code" href="../../d5/d9/struct__LCB.html#o14">00798</a>     ULONG <a class="code" href="../../d5/d9/struct__LCB.html#o14">FileAttributes</a>;
00799 
00800     <span class="comment">//</span>
00801     <span class="comment">//  Splay links in the prefix tree.</span>
00802     <span class="comment">//</span>
00803     
<a name="l00804"></a><a class="code" href="../../d5/d9/struct__LCB.html#o15">00804</a>     RTL_SPLAY_LINKS <a class="code" href="../../d5/d9/struct__LCB.html#o15">Links</a>;
00805 
00806     <span class="comment">//</span>
00807     <span class="comment">//  The name of this link.</span>
00808     <span class="comment">//</span>
00809 
<a name="l00810"></a><a class="code" href="../../d5/d9/struct__LCB.html#o16">00810</a>     UNICODE_STRING <a class="code" href="../../d5/d9/struct__LCB.html#o16">FileName</a>;
00811 
00812 } <a class="code" href="../../d5/d9/struct__LCB.html">LCB</a>, *<a class="code" href="../../d5/d9/struct__LCB.html">PLCB</a>;
00813 
<a name="l00814"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a9">00814</a> <span class="preprocessor">#define LCB_FLAG_IGNORE_CASE        0x00000001</span>
<a name="l00815"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a10">00815</a> <span class="preprocessor"></span><span class="preprocessor">#define LCB_FLAG_SHORT_NAME         0x00000002</span>
<a name="l00816"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a11">00816</a> <span class="preprocessor"></span><span class="preprocessor">#define LCB_FLAG_POOL_ALLOCATED     0x00000004</span>
00817 <span class="preprocessor"></span>
00818 <span class="comment">//</span>
00819 <span class="comment">//  We build a lookaside of Lcb capable of holding a reasonably sized name.</span>
00820 <span class="comment">//</span>
00821 
<a name="l00822"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a12">00822</a> <span class="preprocessor">#define SIZEOF_LOOKASIDE_LCB        ( sizeof( LCB ) + ( sizeof( WCHAR ) * 16 ))</span>
00823 <span class="preprocessor"></span>
00824 
00825 <span class="comment">//</span>
00826 <span class="comment">//  The following two structures are the separate union structures for</span>
00827 <span class="comment">//  data and index Fcb's.</span>
00828 <span class="comment">//</span>
00829 
<a name="l00830"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a131">00830</a> <span class="keyword">typedef</span> <span class="keyword">enum</span> <a class="code" href="../../d6/d8/udfstruc_8h.html#a131">_FCB_CONDITION</a> {
00831     <a class="code" href="../../d6/d8/udfstruc_8h.html#a131a122">FcbGood</a> = 1,
00832     <a class="code" href="../../d6/d8/udfstruc_8h.html#a131a123">FcbBad</a>,
00833     <a class="code" href="../../d6/d8/udfstruc_8h.html#a131a124">FcbNeedsToBeVerified</a>
00834 } <a class="code" href="../../d6/d8/udfstruc_8h.html#a81">FCB_CONDITION</a>;
00835 
<a name="l00836"></a><a class="code" href="../../d4/d0/struct__FCB__NONPAGED.html">00836</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d4/d0/struct__FCB__NONPAGED.html">_FCB_NONPAGED</a> {
00837 
00838     <span class="comment">//</span>
00839     <span class="comment">//  Type and size of this record must be UDFS_NTC_FCB_NONPAGED</span>
00840     <span class="comment">//</span>
00841 
<a name="l00842"></a><a class="code" href="../../d4/d0/struct__FCB__NONPAGED.html#o0">00842</a>     <a class="code" href="../../d0/d7/lfs_2nodetype_8h.html#a7">NODE_TYPE_CODE</a> <a class="code" href="../../d4/d0/struct__FCB__NONPAGED.html#o0">NodeTypeCode</a>;
<a name="l00843"></a><a class="code" href="../../d4/d0/struct__FCB__NONPAGED.html#o1">00843</a>     <a class="code" href="../../d0/d7/lfs_2nodetype_8h.html#a9">NODE_BYTE_SIZE</a> <a class="code" href="../../d4/d0/struct__FCB__NONPAGED.html#o1">NodeByteSize</a>;
00844 
00845     <span class="comment">//</span>
00846     <span class="comment">//  The following field contains a record of special pointers used by</span>
00847     <span class="comment">//  MM and Cache to manipluate section objects.  Note that the values</span>
00848     <span class="comment">//  are set outside of the file system.  However the file system on an</span>
00849     <span class="comment">//  open/create will set the file object's SectionObject field to</span>
00850     <span class="comment">//  point to this field</span>
00851     <span class="comment">//</span>
00852 
<a name="l00853"></a><a class="code" href="../../d4/d0/struct__FCB__NONPAGED.html#o2">00853</a>     <a class="code" href="../../d7/d0/struct__SECTION__OBJECT__POINTERS.html">SECTION_OBJECT_POINTERS</a> <a class="code" href="../../d4/d0/struct__FCB__NONPAGED.html#o2">SegmentObject</a>;
00854 
00855     <span class="comment">//</span>
00856     <span class="comment">//  This is the resource structure for this Fcb.</span>
00857     <span class="comment">//</span>
00858 
<a name="l00859"></a><a class="code" href="../../d4/d0/struct__FCB__NONPAGED.html#o3">00859</a>     <a class="code" href="../../d6/d4/struct__ERESOURCE.html">ERESOURCE</a> <a class="code" href="../../d4/d0/struct__FCB__NONPAGED.html#o3">FcbResource</a>;
00860 
00861     <span class="comment">//</span>
00862     <span class="comment">//  This is the FastMutex for this Fcb.</span>
00863     <span class="comment">//</span>
00864 
<a name="l00865"></a><a class="code" href="../../d4/d0/struct__FCB__NONPAGED.html#o4">00865</a>     <a class="code" href="../../d6/d9/struct__FAST__MUTEX.html">FAST_MUTEX</a> <a class="code" href="../../d4/d0/struct__FCB__NONPAGED.html#o4">FcbMutex</a>;
00866 
00867 } <a class="code" href="../../d4/d0/struct__FCB__NONPAGED.html">FCB_NONPAGED</a>;
<a name="l00868"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a83">00868</a> <span class="keyword">typedef</span> <a class="code" href="../../d4/d0/struct__FCB__NONPAGED.html">FCB_NONPAGED</a> *<a class="code" href="../../d4/d0/struct__FCB__NONPAGED.html">PFCB_NONPAGED</a>;
00869 
<a name="l00870"></a><a class="code" href="../../d2/d0/struct__FCB__DATA.html">00870</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d2/d0/struct__FCB__DATA.html">_FCB_DATA</a> {
00871 
00872     <span class="comment">//</span>
00873     <span class="comment">//  The following field is used by the oplock module</span>
00874     <span class="comment">//  to maintain current oplock information.</span>
00875     <span class="comment">//</span>
00876 
<a name="l00877"></a><a class="code" href="../../d2/d0/struct__FCB__DATA.html#o0">00877</a>     <a class="code" href="../../d1/d8/fsrtl_8h.html#a77">OPLOCK</a> <a class="code" href="../../d2/d0/struct__FCB__DATA.html#o0">Oplock</a>;
00878 
00879     <span class="comment">//</span>
00880     <span class="comment">//  The following field is used by the filelock module</span>
00881     <span class="comment">//  to maintain current byte range locking information.</span>
00882     <span class="comment">//  A file lock is allocated as needed.</span>
00883     <span class="comment">//</span>
00884 
<a name="l00885"></a><a class="code" href="../../d2/d0/struct__FCB__DATA.html#o1">00885</a>     <a class="code" href="../../d7/d1/struct__FILE__LOCK.html">PFILE_LOCK</a> <a class="code" href="../../d2/d0/struct__FCB__DATA.html#o1">FileLock</a>;
00886 
00887 } <a class="code" href="../../d2/d0/struct__FCB__DATA.html">FCB_DATA</a>, *<a class="code" href="../../d2/d0/struct__FCB__DATA.html">PFCB_DATA</a>;
00888 
<a name="l00889"></a><a class="code" href="../../d3/d0/struct__FCB__INDEX.html">00889</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d3/d0/struct__FCB__INDEX.html">_FCB_INDEX</a> {
00890 
00891     <span class="comment">//</span>
00892     <span class="comment">//  Internal stream file for the directory.</span>
00893     <span class="comment">//</span>
00894 
<a name="l00895"></a><a class="code" href="../../d3/d0/struct__FCB__INDEX.html#o0">00895</a>     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> <a class="code" href="../../d3/d0/struct__FCB__INDEX.html#o0">FileObject</a>;
00896 
00897     <span class="comment">//</span>
00898     <span class="comment">//  Root of splay trees for exact and ignore case prefix trees.</span>
00899     <span class="comment">//</span>
00900 
<a name="l00901"></a><a class="code" href="../../d3/d0/struct__FCB__INDEX.html#o1">00901</a>     PRTL_SPLAY_LINKS <a class="code" href="../../d3/d0/struct__FCB__INDEX.html#o1">ExactCaseRoot</a>;
<a name="l00902"></a><a class="code" href="../../d3/d0/struct__FCB__INDEX.html#o2">00902</a>     PRTL_SPLAY_LINKS <a class="code" href="../../d3/d0/struct__FCB__INDEX.html#o2">IgnoreCaseRoot</a>;
00903 
00904 } <a class="code" href="../../d3/d0/struct__FCB__INDEX.html">FCB_INDEX</a>, *<a class="code" href="../../d3/d0/struct__FCB__INDEX.html">PFCB_INDEX</a>;
00905 
00906 <span class="comment">//</span>
00907 <span class="comment">//  The Fcb/Dcb record corresponds to every open file and directory, and to</span>
00908 <span class="comment">//  every directory on an opened path.</span>
00909 <span class="comment">//</span>
00910 
<a name="l00911"></a><a class="code" href="../../d7/d9/struct__FCB.html">00911</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d7/d9/struct__FCB.html">_FCB</a> {
00912 
00913     <span class="comment">//</span>
00914     <span class="comment">//  The following field is used for fast I/O.  It contains the node</span>
00915     <span class="comment">//  type code and size, indicates if fast I/O is possible, contains</span>
00916     <span class="comment">//  allocation, file, and valid data size, a resource, and call back</span>
00917     <span class="comment">//  pointers for FastIoRead and FastMdlRead.</span>
00918     <span class="comment">//</span>
00919     <span class="comment">//</span>
00920     <span class="comment">//  Node type codes for the Fcb must be one of the following.</span>
00921     <span class="comment">//</span>
00922     <span class="comment">//      UDFS_NTC_FCB_INDEX</span>
00923     <span class="comment">//      UDFS_NTC_FCB_DATA</span>
00924     <span class="comment">//</span>
00925 
00926     <span class="comment">//</span>
00927     <span class="comment">//  Common Fsrtl Header.  The named header is for the fieldoff.c output.  We</span>
00928     <span class="comment">//  use the unnamed header internally.</span>
00929     <span class="comment">//</span>
00930 
00931     <span class="keyword">union </span>{
00932 
<a name="l00933"></a><a class="code" href="../../d7/d9/struct__FCB.html#o0">00933</a>         <a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">FSRTL_COMMON_FCB_HEADER</a> <a class="code" href="../../d7/d9/struct__FCB.html#o0">Header</a>;
<a name="l00934"></a><a class="code" href="../../d7/d9/struct__FCB.html#o1">00934</a>         <a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">FSRTL_COMMON_FCB_HEADER</a>;
00935     };
00936 
00937     <span class="comment">//</span>
00938     <span class="comment">//  Vcb for this Fcb.</span>
00939     <span class="comment">//</span>
00940 
<a name="l00941"></a><a class="code" href="../../d7/d9/struct__FCB.html#o2">00941</a>     <a class="code" href="../../d6/d8/udfstruc_8h.html#a74">PVCB</a> <a class="code" href="../../d7/d9/struct__FCB.html#o2">Vcb</a>;
00942 
00943     <span class="comment">//</span>
00944     <span class="comment">//  Queues of Lcbs that are on this Fcb: Parent - edges that lead in</span>
00945     <span class="comment">//                                       Child  - edges that lead out</span>
00946     <span class="comment">//</span>
00947     <span class="comment">//  We anticipate supporting the streaming extension to UDF 2.0, so we</span>
00948     <span class="comment">//  leave the ChildLcbQueue here which in the case of a stream-rich file</span>
00949     <span class="comment">//  will contain a solitary Lcb leading to the stream directory.</span>
00950     <span class="comment">//</span>
00951 
<a name="l00952"></a><a class="code" href="../../d7/d9/struct__FCB.html#o3">00952</a>     LIST_ENTRY <a class="code" href="../../d7/d9/struct__FCB.html#o3">ParentLcbQueue</a>;
<a name="l00953"></a><a class="code" href="../../d7/d9/struct__FCB.html#o4">00953</a>     LIST_ENTRY <a class="code" href="../../d7/d9/struct__FCB.html#o4">ChildLcbQueue</a>;
00954 
00955     <span class="comment">//</span>
00956     <span class="comment">//  Length of Root ICB Extent for this object.  Coupled with the information</span>
00957     <span class="comment">//  in the FileId, this will allow discovery of the active File Entry for this</span>
00958     <span class="comment">//  Fcb at any time.</span>
00959     <span class="comment">//</span>
00960 
<a name="l00961"></a><a class="code" href="../../d7/d9/struct__FCB.html#o5">00961</a>     ULONG <a class="code" href="../../d7/d9/struct__FCB.html#o5">RootExtentLength</a>;
00962 
00963     <span class="comment">//</span>
00964     <span class="comment">//  FileId for this file.</span>
00965     <span class="comment">//</span>
00966 
<a name="l00967"></a><a class="code" href="../../d7/d9/struct__FCB.html#o6">00967</a>     <a class="code" href="../../d6/d8/udfstruc_8h.html#a77">FILE_ID</a> <a class="code" href="../../d7/d9/struct__FCB.html#o6">FileId</a>;
00968 
00969     <span class="comment">//</span>
00970     <span class="comment">//  Counts on this Fcb.  Cleanup count represents the number of open handles</span>
00971     <span class="comment">//  on this Fcb.  Reference count represents the number of reasons this Fcb</span>
00972     <span class="comment">//  is still present.  It includes file objects, children Fcb and anyone</span>
00973     <span class="comment">//  who wants to prevent this Fcb from going away.  Cleanup count is synchronized</span>
00974     <span class="comment">//  with the FcbResource.  The reference count is synchronized with the</span>
00975     <span class="comment">//  FcbMutex.</span>
00976     <span class="comment">//</span>
00977 
<a name="l00978"></a><a class="code" href="../../d7/d9/struct__FCB.html#o7">00978</a>     ULONG <a class="code" href="../../d7/d9/struct__FCB.html#o7">FcbCleanup</a>;
<a name="l00979"></a><a class="code" href="../../d7/d9/struct__FCB.html#o8">00979</a>     ULONG <a class="code" href="../../d7/d9/struct__FCB.html#o8">FcbReference</a>;
<a name="l00980"></a><a class="code" href="../../d7/d9/struct__FCB.html#o9">00980</a>     ULONG <a class="code" href="../../d7/d9/struct__FCB.html#o9">FcbUserReference</a>;
00981 
00982     <span class="comment">//</span>
00983     <span class="comment">//  State flags for this Fcb.</span>
00984     <span class="comment">//</span>
00985 
<a name="l00986"></a><a class="code" href="../../d7/d9/struct__FCB.html#o10">00986</a>     ULONG <a class="code" href="../../d7/d9/struct__FCB.html#o10">FcbState</a>;
00987 
00988     <span class="comment">//</span>
00989     <span class="comment">//  NT style attributes for the Fcb.</span>
00990     <span class="comment">//</span>
00991 
<a name="l00992"></a><a class="code" href="../../d7/d9/struct__FCB.html#o11">00992</a>     ULONG <a class="code" href="../../d7/d9/struct__FCB.html#o11">FileAttributes</a>;
00993 
00994     <span class="comment">//</span>
00995     <span class="comment">//  This is the thread and count for the thread which has locked this</span>
00996     <span class="comment">//  Fcb.</span>
00997     <span class="comment">//</span>
00998 
<a name="l00999"></a><a class="code" href="../../d7/d9/struct__FCB.html#o12">00999</a>     PVOID <a class="code" href="../../d7/d9/struct__FCB.html#o12">FcbLockThread</a>;
<a name="l01000"></a><a class="code" href="../../d7/d9/struct__FCB.html#o13">01000</a>     ULONG <a class="code" href="../../d7/d9/struct__FCB.html#o13">FcbLockCount</a>;
01001 
01002     <span class="comment">//</span>
01003     <span class="comment">//  Information for Lsn-&gt;Psn mapping.  If the file data is embedded, we have a</span>
01004     <span class="comment">//  lookup into the metadata stream for the single logical block and an offset</span>
01005     <span class="comment">//  of the data within that block.  If the file data is is external, we have a</span>
01006     <span class="comment">//  regular Mapping Control Block.</span>
01007     <span class="comment">//</span>
01008     <span class="comment">//  Metadata structures are mapped through the volume-level Metadata Fcb which</span>
01009     <span class="comment">//  uses the volume's VMCB.</span>
01010     <span class="comment">//</span>
01011 
01012     <span class="keyword">union </span>{
01013         
<a name="l01014"></a><a class="code" href="../../d7/d9/struct__FCB.html#o14">01014</a>         <a class="code" href="../../d0/d9/struct__LARGE__MCB.html">LARGE_MCB</a> <a class="code" href="../../d7/d9/struct__FCB.html#o14">Mcb</a>;
01015 
01016         <span class="keyword">struct </span>EMBEDDED_MAPPING {
01017             
<a name="l01018"></a><a class="code" href="../../d7/d9/struct__FCB.html#o15">01018</a>             ULONG EmbeddedVsn;
<a name="l01019"></a><a class="code" href="../../d7/d9/struct__FCB.html#o16">01019</a>             ULONG EmbeddedOffset;
01020         };
01021     };
01022 
01023     <span class="comment">//</span>
01024     <span class="comment">//  This is the nonpaged data for the Fcb</span>
01025     <span class="comment">//</span>
01026 
<a name="l01027"></a><a class="code" href="../../d7/d9/struct__FCB.html#o17">01027</a>     <a class="code" href="../../d6/d8/udfstruc_8h.html#a83">PFCB_NONPAGED</a> <a class="code" href="../../d7/d9/struct__FCB.html#o17">FcbNonpaged</a>;
01028 
01029     <span class="comment">//</span>
01030     <span class="comment">//  Share access structure.</span>
01031     <span class="comment">//</span>
01032 
<a name="l01033"></a><a class="code" href="../../d7/d9/struct__FCB.html#o18">01033</a>     <a class="code" href="../../d9/d2/struct__SHARE__ACCESS.html">SHARE_ACCESS</a> <a class="code" href="../../d7/d9/struct__FCB.html#o18">ShareAccess</a>;
01034 
01035     <span class="comment">//</span>
01036     <span class="comment">//  We cache a few fields from the FE so that various operations do not have to</span>
01037     <span class="comment">//  hit the disk (query, etc.).</span>
01038     <span class="comment">//</span>
01039     
01040     <span class="comment">//</span>
01041     <span class="comment">//  Time stamps for this file.</span>
01042     <span class="comment">//</span>
01043 
<a name="l01044"></a><a class="code" href="../../d7/d9/struct__FCB.html#o19">01044</a>     <a class="code" href="../../d4/d1/struct__TIMESTAMP__BUNDLE.html">TIMESTAMP_BUNDLE</a> <a class="code" href="../../d7/d9/struct__FCB.html#o19">Timestamps</a>;
01045 
01046     <span class="comment">//</span>
01047     <span class="comment">//  Link count on this file.</span>
01048     <span class="comment">//</span>
01049 
<a name="l01050"></a><a class="code" href="../../d7/d9/struct__FCB.html#o20">01050</a>     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> <a class="code" href="../../d7/d9/struct__FCB.html#o20">LinkCount</a>;
01051 
01052     <span class="keyword">union </span>{
01053 
<a name="l01054"></a><a class="code" href="../../d7/d9/struct__FCB.html#o21">01054</a>         ULONG <a class="code" href="../../d7/d9/struct__FCB.html#o21">FcbType</a>;
<a name="l01055"></a><a class="code" href="../../d7/d9/struct__FCB.html#o22">01055</a>         <a class="code" href="../../d3/d0/struct__FCB__INDEX.html">FCB_INDEX</a>;
<a name="l01056"></a><a class="code" href="../../d7/d9/struct__FCB.html#o23">01056</a>         <a class="code" href="../../d2/d0/struct__FCB__DATA.html">FCB_DATA</a>;
01057     };
01058 
01059 } <a class="code" href="../../d7/d9/struct__FCB.html">FCB</a>, *<a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a>;
01060 
<a name="l01061"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a13">01061</a> <span class="preprocessor">#define FCB_STATE_INITIALIZED                   (0x00000001)</span>
<a name="l01062"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a14">01062</a> <span class="preprocessor"></span><span class="preprocessor">#define FCB_STATE_IN_FCB_TABLE                  (0x00000002)</span>
<a name="l01063"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a15">01063</a> <span class="preprocessor"></span><span class="preprocessor">#define FCB_STATE_VMCB_MAPPING                  (0x00000004)</span>
<a name="l01064"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a16">01064</a> <span class="preprocessor"></span><span class="preprocessor">#define FCB_STATE_EMBEDDED_DATA                 (0x00000008)</span>
<a name="l01065"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a17">01065</a> <span class="preprocessor"></span><span class="preprocessor">#define FCB_STATE_MCB_INITIALIZED               (0x00000010)</span>
01066 <span class="preprocessor"></span>
<a name="l01067"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a18">01067</a> <span class="preprocessor">#define SIZEOF_FCB_DATA              \</span>
01068 <span class="preprocessor">    (FIELD_OFFSET( FCB, FcbType ) + sizeof( FCB_DATA ))</span>
01069 <span class="preprocessor"></span>
<a name="l01070"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a19">01070</a> <span class="preprocessor">#define SIZEOF_FCB_INDEX             \</span>
01071 <span class="preprocessor">    (FIELD_OFFSET( FCB, FcbType ) + sizeof( FCB_INDEX ))</span>
01072 <span class="preprocessor"></span>
01073 
01074 <span class="comment">//</span>
01075 <span class="comment">//  The Ccb record is allocated for every user file object</span>
01076 <span class="comment">//</span>
01077 
<a name="l01078"></a><a class="code" href="../../d2/d9/struct__CCB.html">01078</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d2/d9/struct__CCB.html">_CCB</a> {
01079 
01080     <span class="comment">//</span>
01081     <span class="comment">//  Type and size of this record (must be UDFS_NTC_CCB)</span>
01082     <span class="comment">//</span>
01083 
<a name="l01084"></a><a class="code" href="../../d2/d9/struct__CCB.html#o0">01084</a>     <a class="code" href="../../d0/d7/lfs_2nodetype_8h.html#a7">NODE_TYPE_CODE</a> <a class="code" href="../../d2/d9/struct__CCB.html#o0">NodeTypeCode</a>;
<a name="l01085"></a><a class="code" href="../../d2/d9/struct__CCB.html#o1">01085</a>     <a class="code" href="../../d0/d7/lfs_2nodetype_8h.html#a9">NODE_BYTE_SIZE</a> <a class="code" href="../../d2/d9/struct__CCB.html#o1">NodeByteSize</a>;
01086 
01087     <span class="comment">//</span>
01088     <span class="comment">//  Flags.  Indicates flags to apply for the current open.</span>
01089     <span class="comment">//</span>
01090 
<a name="l01091"></a><a class="code" href="../../d2/d9/struct__CCB.html#o2">01091</a>     ULONG <a class="code" href="../../d2/d9/struct__CCB.html#o2">Flags</a>;
01092 
01093     <span class="comment">//</span>
01094     <span class="comment">//  Fcb for the file being opened.</span>
01095     <span class="comment">//</span>
01096 
<a name="l01097"></a><a class="code" href="../../d2/d9/struct__CCB.html#o3">01097</a>     <a class="code" href="../../d6/d8/udfstruc_8h.html#a89">PFCB</a> <a class="code" href="../../d2/d9/struct__CCB.html#o3">Fcb</a>;
01098 
01099     <span class="comment">//</span>
01100     <span class="comment">//  Lcb for the file being opened.</span>
01101     <span class="comment">//</span>
01102 
<a name="l01103"></a><a class="code" href="../../d2/d9/struct__CCB.html#o4">01103</a>     <a class="code" href="../../d1/d4/lfsstruc_8h.html#a26">PLCB</a> <a class="code" href="../../d2/d9/struct__CCB.html#o4">Lcb</a>;
01104 
01105     <span class="comment">//</span>
01106     <span class="comment">//  We store state information in the Ccb for a directory</span>
01107     <span class="comment">//  enumeration on this handle.</span>
01108     <span class="comment">//</span>
01109 
01110     <span class="comment">//</span>
01111     <span class="comment">//  Offset in the virtual directory stream to base the next enumeration.</span>
01112     <span class="comment">//</span>
01113     <span class="comment">//  A small number (in fact, possibly one) of file indices are reserved for</span>
01114     <span class="comment">//  synthesized directory entries (like '.'). Past that point, CurrentFileIndex -</span>
01115     <span class="comment">//  UDF_MAX_SYNTHESIZED_FILEINDEX is a byte offset in the stream.</span>
01116     <span class="comment">//</span>
01117 
<a name="l01118"></a><a class="code" href="../../d2/d9/struct__CCB.html#o5">01118</a>     LONGLONG <a class="code" href="../../d2/d9/struct__CCB.html#o5">CurrentFileIndex</a>;
<a name="l01119"></a><a class="code" href="../../d2/d9/struct__CCB.html#o6">01119</a>     UNICODE_STRING <a class="code" href="../../d2/d9/struct__CCB.html#o6">SearchExpression</a>;
01120 
01121     <span class="comment">//</span>
01122     <span class="comment">//  Highest ULONG-representable FileIndex so far found in the directory stream.</span>
01123     <span class="comment">//  This corresponds to the highest FileIndex returnable in a query structure.</span>
01124     <span class="comment">//</span>
01125 
<a name="l01126"></a><a class="code" href="../../d2/d9/struct__CCB.html#o7">01126</a>     ULONG <a class="code" href="../../d2/d9/struct__CCB.html#o7">HighestReturnableFileIndex</a>;
01127 
01128 } <a class="code" href="../../d2/d9/struct__CCB.html">CCB</a>, *<a class="code" href="../../d2/d9/struct__CCB.html">PCCB</a>;
01129 
<a name="l01130"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a20">01130</a> <span class="preprocessor">#define CCB_FLAG_OPEN_BY_ID                     (0x00000001)</span>
<a name="l01131"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a21">01131</a> <span class="preprocessor"></span><span class="preprocessor">#define CCB_FLAG_OPEN_RELATIVE_BY_ID            (0x00000002)</span>
<a name="l01132"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a22">01132</a> <span class="preprocessor"></span><span class="preprocessor">#define CCB_FLAG_IGNORE_CASE                    (0x00000004)</span>
01133 <span class="preprocessor"></span>
01134 <span class="comment">//</span>
01135 <span class="comment">//  Following flags refer to index enumeration.</span>
01136 <span class="comment">//</span>
01137 
<a name="l01138"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a23">01138</a> <span class="preprocessor">#define CCB_FLAG_ENUM_NAME_EXP_HAS_WILD         (0x00010000)</span>
<a name="l01139"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a24">01139</a> <span class="preprocessor"></span><span class="preprocessor">#define CCB_FLAG_ENUM_MATCH_ALL                 (0x00020000)</span>
<a name="l01140"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a25">01140</a> <span class="preprocessor"></span><span class="preprocessor">#define CCB_FLAG_ENUM_RETURN_NEXT               (0x00040000)</span>
<a name="l01141"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a26">01141</a> <span class="preprocessor"></span><span class="preprocessor">#define CCB_FLAG_ENUM_INITIALIZED               (0x00080000)</span>
<a name="l01142"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a27">01142</a> <span class="preprocessor"></span><span class="preprocessor">#define CCB_FLAG_ENUM_NOMATCH_CONSTANT_ENTRY    (0x00100000)</span>
01143 <span class="preprocessor"></span>
01144 
01145 <span class="comment">//</span>
01146 <span class="comment">//  The Irp Context record is allocated for every orginating Irp.  It is</span>
01147 <span class="comment">//  created by the Fsd dispatch routines, and deallocated by the UdfComplete</span>
01148 <span class="comment">//  request routine</span>
01149 <span class="comment">//</span>
01150 
<a name="l01151"></a><a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">01151</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">_IRP_CONTEXT</a> {
01152 
01153     <span class="comment">//</span>
01154     <span class="comment">//  Type and size of this record (must be UDFS_NTC_IRP_CONTEXT)</span>
01155     <span class="comment">//</span>
01156 
<a name="l01157"></a><a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html#o0">01157</a>     <a class="code" href="../../d0/d7/lfs_2nodetype_8h.html#a7">NODE_TYPE_CODE</a> <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html#o0">NodeTypeCode</a>;
<a name="l01158"></a><a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html#o1">01158</a>     <a class="code" href="../../d0/d7/lfs_2nodetype_8h.html#a9">NODE_BYTE_SIZE</a> <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html#o1">NodeByteSize</a>;
01159 
01160     <span class="comment">//</span>
01161     <span class="comment">//  Originating Irp for the request.</span>
01162     <span class="comment">//</span>
01163 
<a name="l01164"></a><a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html#o2">01164</a>     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>;
01165 
01166     <span class="comment">//</span>
01167     <span class="comment">//  Vcb for this operation.  When this is NULL it means we were called</span>
01168     <span class="comment">//  with our filesystem device object instead of a volume device object.</span>
01169     <span class="comment">//  (Mount will fill this in once the Vcb is created)</span>
01170     <span class="comment">//</span>
01171 
<a name="l01172"></a><a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html#o3">01172</a>     <a class="code" href="../../d6/d8/udfstruc_8h.html#a74">PVCB</a> <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html#o3">Vcb</a>;
01173 
01174     <span class="comment">//</span>
01175     <span class="comment">//  Exception encountered during the request.  Any error raised explicitly by</span>
01176     <span class="comment">//  the file system will be stored here.  Any other error raised by the system</span>
01177     <span class="comment">//  is stored here after normalizing it.</span>
01178     <span class="comment">//</span>
01179 
<a name="l01180"></a><a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html#o4">01180</a>     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html#o4">ExceptionStatus</a>;
01181 
01182     <span class="comment">//</span>
01183     <span class="comment">//  Flags for this request.</span>
01184     <span class="comment">//</span>
01185 
<a name="l01186"></a><a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html#o5">01186</a>     ULONG <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html#o5">Flags</a>;
01187 
01188     <span class="comment">//</span>
01189     <span class="comment">//  Real device object.  This represents the physical device closest to the media.</span>
01190     <span class="comment">//</span>
01191 
<a name="l01192"></a><a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html#o6">01192</a>     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html#o6">RealDevice</a>;
01193 
01194     <span class="comment">//</span>
01195     <span class="comment">//  Io context for a read request.</span>
01196     <span class="comment">//  Address of Fcb for teardown oplock in create case.</span>
01197     <span class="comment">//</span>
01198 
01199     <span class="keyword">union </span>{
01200 
<a name="l01201"></a><a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html#o7">01201</a>         <span class="keyword">struct </span><a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html">_UDF_IO_CONTEXT</a> *<a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html#o7">IoContext</a>;
<a name="l01202"></a><a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html#o8">01202</a>         <a class="code" href="../../d6/d8/udfstruc_8h.html#a89">PFCB</a> *<a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html#o8">TeardownFcb</a>;
01203     };
01204 
01205     <span class="comment">//</span>
01206     <span class="comment">//  Top level irp context for this thread.</span>
01207     <span class="comment">//</span>
01208 
<a name="l01209"></a><a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html#o9">01209</a>     <span class="keyword">struct </span><a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">_IRP_CONTEXT</a> *<a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html#o9">TopLevel</a>;
01210 
01211     <span class="comment">//</span>
01212     <span class="comment">//  Major and minor function codes.</span>
01213     <span class="comment">//</span>
01214 
<a name="l01215"></a><a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html#o10">01215</a>     UCHAR <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html#o10">MajorFunction</a>;
<a name="l01216"></a><a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html#o11">01216</a>     UCHAR <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html#o11">MinorFunction</a>;
01217 
01218     <span class="comment">//</span>
01219     <span class="comment">//  Pointer to the top-level context if this IrpContext is responsible</span>
01220     <span class="comment">//  for cleaning it up.</span>
01221     <span class="comment">//</span>
01222 
<a name="l01223"></a><a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html#o12">01223</a>     <span class="keyword">struct </span><a class="code" href="../../d0/d1/struct__THREAD__CONTEXT.html">_THREAD_CONTEXT</a> *<a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html#o12">ThreadContext</a>;
01224 
01225     <span class="comment">//</span>
01226     <span class="comment">//  This structure is used for posting to the Ex worker threads.</span>
01227     <span class="comment">//</span>
01228 
<a name="l01229"></a><a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html#o13">01229</a>     <a class="code" href="../../d7/d9/struct__WORK__QUEUE__ITEM.html">WORK_QUEUE_ITEM</a> <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html#o13">WorkQueueItem</a>;
01230 
01231 } <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">IRP_CONTEXT</a>, *<a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a>;
01232 
<a name="l01233"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a28">01233</a> <span class="preprocessor">#define IRP_CONTEXT_FLAG_ON_STACK               (0x00000001)</span>
<a name="l01234"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a29">01234</a> <span class="preprocessor"></span><span class="preprocessor">#define IRP_CONTEXT_FLAG_MORE_PROCESSING        (0x00000002)</span>
<a name="l01235"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a30">01235</a> <span class="preprocessor"></span><span class="preprocessor">#define IRP_CONTEXT_FLAG_WAIT                   (0x00000004)</span>
<a name="l01236"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a31">01236</a> <span class="preprocessor"></span><span class="preprocessor">#define IRP_CONTEXT_FLAG_FORCE_POST             (0x00000008)</span>
<a name="l01237"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a32">01237</a> <span class="preprocessor"></span><span class="preprocessor">#define IRP_CONTEXT_FLAG_TOP_LEVEL              (0x00000010)</span>
<a name="l01238"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a33">01238</a> <span class="preprocessor"></span><span class="preprocessor">#define IRP_CONTEXT_FLAG_TOP_LEVEL_UDFS         (0x00000020)</span>
<a name="l01239"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a34">01239</a> <span class="preprocessor"></span><span class="preprocessor">#define IRP_CONTEXT_FLAG_IN_FSP                 (0x00000040)</span>
<a name="l01240"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a35">01240</a> <span class="preprocessor"></span><span class="preprocessor">#define IRP_CONTEXT_FLAG_IN_TEARDOWN            (0x00000080)</span>
<a name="l01241"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a36">01241</a> <span class="preprocessor"></span><span class="preprocessor">#define IRP_CONTEXT_FLAG_ALLOC_IO               (0x00000100)</span>
<a name="l01242"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a37">01242</a> <span class="preprocessor"></span><span class="preprocessor">#define IRP_CONTEXT_FLAG_DISABLE_POPUPS         (0x00000200)</span>
01243 <span class="preprocessor"></span>
01244 <span class="comment">//</span>
01245 <span class="comment">//  Flags used for create.</span>
01246 <span class="comment">//</span>
01247 
<a name="l01248"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a38">01248</a> <span class="preprocessor">#define IRP_CONTEXT_FLAG_FULL_NAME              (0x10000000)</span>
<a name="l01249"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a39">01249</a> <span class="preprocessor"></span><span class="preprocessor">#define IRP_CONTEXT_FLAG_TRAIL_BACKSLASH        (0x20000000)</span>
01250 <span class="preprocessor"></span>
01251 <span class="comment">//</span>
01252 <span class="comment">//  The following flags need to be cleared when a request is posted.</span>
01253 <span class="comment">//</span>
01254 
<a name="l01255"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a40">01255</a> <span class="preprocessor">#define IRP_CONTEXT_FLAGS_CLEAR_ON_POST (   \</span>
01256 <span class="preprocessor">    IRP_CONTEXT_FLAG_MORE_PROCESSING    |   \</span>
01257 <span class="preprocessor">    IRP_CONTEXT_FLAG_WAIT               |   \</span>
01258 <span class="preprocessor">    IRP_CONTEXT_FLAG_FORCE_POST         |   \</span>
01259 <span class="preprocessor">    IRP_CONTEXT_FLAG_TOP_LEVEL          |   \</span>
01260 <span class="preprocessor">    IRP_CONTEXT_FLAG_TOP_LEVEL_UDFS     |   \</span>
01261 <span class="preprocessor">    IRP_CONTEXT_FLAG_IN_FSP             |   \</span>
01262 <span class="preprocessor">    IRP_CONTEXT_FLAG_IN_TEARDOWN        |   \</span>
01263 <span class="preprocessor">    IRP_CONTEXT_FLAG_DISABLE_POPUPS         \</span>
01264 <span class="preprocessor">)</span>
01265 <span class="preprocessor"></span>
01266 <span class="comment">//</span>
01267 <span class="comment">//  The following flags need to be cleared when a request is retried.</span>
01268 <span class="comment">//</span>
01269 
<a name="l01270"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a41">01270</a> <span class="preprocessor">#define IRP_CONTEXT_FLAGS_CLEAR_ON_RETRY (  \</span>
01271 <span class="preprocessor">    IRP_CONTEXT_FLAG_MORE_PROCESSING    |   \</span>
01272 <span class="preprocessor">    IRP_CONTEXT_FLAG_IN_TEARDOWN        |   \</span>
01273 <span class="preprocessor">    IRP_CONTEXT_FLAG_DISABLE_POPUPS         \</span>
01274 <span class="preprocessor">)</span>
01275 <span class="preprocessor"></span>
01276 <span class="comment">//</span>
01277 <span class="comment">//  The following flags are set each time through the Fsp loop.</span>
01278 <span class="comment">//</span>
01279 
<a name="l01280"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a42">01280</a> <span class="preprocessor">#define IRP_CONTEXT_FSP_FLAGS (             \</span>
01281 <span class="preprocessor">    IRP_CONTEXT_FLAG_WAIT               |   \</span>
01282 <span class="preprocessor">    IRP_CONTEXT_FLAG_TOP_LEVEL          |   \</span>
01283 <span class="preprocessor">    IRP_CONTEXT_FLAG_TOP_LEVEL_UDFS     |   \</span>
01284 <span class="preprocessor">    IRP_CONTEXT_FLAG_IN_FSP                 \</span>
01285 <span class="preprocessor">)</span>
01286 <span class="preprocessor"></span>
01287 
01288 <span class="comment">//</span>
01289 <span class="comment">//  Following structure is used to queue a request to the delayed close queue.</span>
01290 <span class="comment">//  This structure should be the minimum block allocation size.</span>
01291 <span class="comment">//</span>
01292 
<a name="l01293"></a><a class="code" href="../../d2/d3/struct__IRP__CONTEXT__LITE.html">01293</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d2/d3/struct__IRP__CONTEXT__LITE.html">_IRP_CONTEXT_LITE</a> {
01294 
01295     <span class="comment">//</span>
01296     <span class="comment">//  Type and size of this record (must be UDFS_NTC_IRP_CONTEXT_LITE)</span>
01297     <span class="comment">//</span>
01298 
<a name="l01299"></a><a class="code" href="../../d2/d3/struct__IRP__CONTEXT__LITE.html#o0">01299</a>     <a class="code" href="../../d0/d7/lfs_2nodetype_8h.html#a7">NODE_TYPE_CODE</a> <a class="code" href="../../d2/d3/struct__IRP__CONTEXT__LITE.html#o0">NodeTypeCode</a>;
<a name="l01300"></a><a class="code" href="../../d2/d3/struct__IRP__CONTEXT__LITE.html#o1">01300</a>     <a class="code" href="../../d0/d7/lfs_2nodetype_8h.html#a9">NODE_BYTE_SIZE</a> <a class="code" href="../../d2/d3/struct__IRP__CONTEXT__LITE.html#o1">NodeByteSize</a>;
01301 
01302     <span class="comment">//</span>
01303     <span class="comment">//  Fcb for the file object being closed.</span>
01304     <span class="comment">//</span>
01305 
<a name="l01306"></a><a class="code" href="../../d2/d3/struct__IRP__CONTEXT__LITE.html#o2">01306</a>     <a class="code" href="../../d6/d8/udfstruc_8h.html#a89">PFCB</a> <a class="code" href="../../d2/d3/struct__IRP__CONTEXT__LITE.html#o2">Fcb</a>;
01307 
01308     <span class="comment">//</span>
01309     <span class="comment">//  List entry to attach to delayed close queue.</span>
01310     <span class="comment">//</span>
01311 
<a name="l01312"></a><a class="code" href="../../d2/d3/struct__IRP__CONTEXT__LITE.html#o3">01312</a>     LIST_ENTRY <a class="code" href="../../d2/d3/struct__IRP__CONTEXT__LITE.html#o3">DelayedCloseLinks</a>;
01313 
01314     <span class="comment">//</span>
01315     <span class="comment">//  User reference count for the file object being closed.</span>
01316     <span class="comment">//</span>
01317 
<a name="l01318"></a><a class="code" href="../../d2/d3/struct__IRP__CONTEXT__LITE.html#o4">01318</a>     ULONG <a class="code" href="../../d2/d3/struct__IRP__CONTEXT__LITE.html#o4">UserReference</a>;
01319 
01320     <span class="comment">//</span>
01321     <span class="comment">//  Real device object.  This represents the physical device closest to the media.</span>
01322     <span class="comment">//</span>
01323 
<a name="l01324"></a><a class="code" href="../../d2/d3/struct__IRP__CONTEXT__LITE.html#o5">01324</a>     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> <a class="code" href="../../d2/d3/struct__IRP__CONTEXT__LITE.html#o5">RealDevice</a>;
01325 
01326 } <a class="code" href="../../d2/d3/struct__IRP__CONTEXT__LITE.html">IRP_CONTEXT_LITE</a>, *<a class="code" href="../../d2/d3/struct__IRP__CONTEXT__LITE.html">PIRP_CONTEXT_LITE</a>;
01327 
01328 
01329 <span class="comment">//</span>
01330 <span class="comment">//  Context structure for asynchronous I/O calls.  Most of these fields</span>
01331 <span class="comment">//  are actually only required for the ReadMultiple routines, but</span>
01332 <span class="comment">//  the caller must allocate one as a local variable anyway before knowing</span>
01333 <span class="comment">//  whether there are multiple requests are not.  Therefore, a single</span>
01334 <span class="comment">//  structure is used for simplicity.</span>
01335 <span class="comment">//</span>
01336 
<a name="l01337"></a><a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html">01337</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html">_UDF_IO_CONTEXT</a> {
01338 
01339     <span class="comment">//</span>
01340     <span class="comment">//  These two fields are used for multiple run Io</span>
01341     <span class="comment">//</span>
01342 
<a name="l01343"></a><a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html#o0">01343</a>     LONG <a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html#o0">IrpCount</a>;
<a name="l01344"></a><a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html#o1">01344</a>     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> <a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html#o1">MasterIrp</a>;
<a name="l01345"></a><a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html#o2">01345</a>     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html#o2">Status</a>;
<a name="l01346"></a><a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html#o3">01346</a>     BOOLEAN <a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html#o3">AllocatedContext</a>;
01347 
01348     <span class="keyword">union </span>{
01349 
01350         <span class="comment">//</span>
01351         <span class="comment">//  This element handles the asynchronous non-cached Io</span>
01352         <span class="comment">//</span>
01353 
01354         <span class="keyword">struct </span>{
01355 
<a name="l01356"></a><a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html#o4">01356</a>             <a class="code" href="../../d6/d4/struct__ERESOURCE.html">PERESOURCE</a> <a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html#o4">Resource</a>;
<a name="l01357"></a><a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html#o5">01357</a>             <a class="code" href="../../d5/d8/ex_8h.html#a121">ERESOURCE_THREAD</a> <a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html#o5">ResourceThreadId</a>;
<a name="l01358"></a><a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html#o6">01358</a>             ULONG <a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html#o6">RequestedByteCount</a>;
01359         };
01360 
01361         <span class="comment">//</span>
01362         <span class="comment">//  and this element handles the synchronous non-cached Io.</span>
01363         <span class="comment">//</span>
01364 
<a name="l01365"></a><a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html#o7">01365</a>         <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> <a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html#o7">SyncEvent</a>;
01366     };
01367 
01368 } <a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html">UDF_IO_CONTEXT</a>, *<a class="code" href="../../d3/d3/struct__UDF__IO__CONTEXT.html">PUDF_IO_CONTEXT</a>;
01369 
01370 
01371 <span class="comment">//</span>
01372 <span class="comment">//  Following structure is used to track the top level request.  Each Udfs</span>
01373 <span class="comment">//  Fsd and Fsp entry point will examine the top level irp location in the</span>
01374 <span class="comment">//  thread local storage to determine if this request is top level and/or</span>
01375 <span class="comment">//  top level Udfs.  The top level Udfs request will remember the previous</span>
01376 <span class="comment">//  value and update that location with a stack location.  This location</span>
01377 <span class="comment">//  can be accessed by recursive Udfs entry points.</span>
01378 <span class="comment">//</span>
01379 
<a name="l01380"></a><a class="code" href="../../d0/d1/struct__THREAD__CONTEXT.html">01380</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d0/d1/struct__THREAD__CONTEXT.html">_THREAD_CONTEXT</a> {
01381 
01382     <span class="comment">//</span>
01383     <span class="comment">//  UDFS signature.  Used to confirm structure on stack is valid.</span>
01384     <span class="comment">//</span>
01385 
<a name="l01386"></a><a class="code" href="../../d0/d1/struct__THREAD__CONTEXT.html#o0">01386</a>     ULONG <a class="code" href="../../d0/d1/struct__THREAD__CONTEXT.html#o0">Udfs</a>;
01387 
01388     <span class="comment">//</span>
01389     <span class="comment">//  Previous value in top-level thread location.  We restore this</span>
01390     <span class="comment">//  when done.</span>
01391     <span class="comment">//</span>
01392 
<a name="l01393"></a><a class="code" href="../../d0/d1/struct__THREAD__CONTEXT.html#o1">01393</a>     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> <a class="code" href="../../d0/d1/struct__THREAD__CONTEXT.html#o1">SavedTopLevelIrp</a>;
01394 
01395     <span class="comment">//</span>
01396     <span class="comment">//  Top level Udfs IrpContext.  Initial Udfs entry point on stack</span>
01397     <span class="comment">//  will store the IrpContext for the request in this stack location.</span>
01398     <span class="comment">//</span>
01399 
<a name="l01400"></a><a class="code" href="../../d0/d1/struct__THREAD__CONTEXT.html#o2">01400</a>     <a class="code" href="../../d4/d8/ntfsexp_8h.html#a37">PIRP_CONTEXT</a> <a class="code" href="../../d0/d1/struct__THREAD__CONTEXT.html#o2">TopLevelIrpContext</a>;
01401 
01402 } <a class="code" href="../../d0/d1/struct__THREAD__CONTEXT.html">THREAD_CONTEXT</a>, *<a class="code" href="../../d0/d1/struct__THREAD__CONTEXT.html">PTHREAD_CONTEXT</a>;
01403 
01404 
01405 <span class="comment">//</span>
01406 <span class="comment">//  Following structure is used to build up static data for parse tables</span>
01407 <span class="comment">//</span>
01408 
01409 <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d2/d8/struct__PARSE__KEYVALUE.html">_PARSE_KEYVALUE</a> {
<a name="l01410"></a><a class="code" href="../../d2/d8/struct__PARSE__KEYVALUE.html#o0">01410</a>     PCHAR <a class="code" href="../../d2/d8/struct__PARSE__KEYVALUE.html#o0">Key</a>;
<a name="l01411"></a><a class="code" href="../../d2/d8/struct__PARSE__KEYVALUE.html#o1">01411</a>     ULONG <a class="code" href="../../d2/d8/struct__PARSE__KEYVALUE.html#o1">Value</a>;
01412 } <a class="code" href="../../d2/d8/struct__PARSE__KEYVALUE.html">PARSE_KEYVALUE</a>, *<a class="code" href="../../d2/d8/struct__PARSE__KEYVALUE.html">PPARSE_KEYVALUE</a>;
01413 
01414 
01415 <span class="comment">//</span>
01416 <span class="comment">//  Some macros for supporting the use of a Generic Table</span>
01417 <span class="comment">//  containing all the FCB and indexed by their FileId.</span>
01418 <span class="comment">//</span>
01419 <span class="comment">//  The ISO 13346 lb_addr of the ICB hierarchy of the object</span>
01420 <span class="comment">//</span>
01421 <span class="comment">//      { ULONG BlockNo; USHORT PartitionId }</span>
01422 <span class="comment">//</span>
01423 <span class="comment">//  is encoded in the LowPart (BlockNo) and low 16 bits of the</span>
01424 <span class="comment">//  HighPart (PartitionId). The top 16 bits are reserved and are</span>
01425 <span class="comment">//  currently used to indicate the type of the object being referenced</span>
01426 <span class="comment">//  (file or directory).</span>
01427 <span class="comment">//</span>
01428 <span class="comment">//  NOTE: this FileId prevents us from being able crack the name of</span>
01429 <span class="comment">//  object since an ICB hierarchy's contained direct File Entrys do</span>
01430 <span class="comment">//  not (and cannot) contain backpointers to the containing directory.</span>
01431 <span class="comment">//  In order to be able to crack paths, we need to be able to do a</span>
01432 <span class="comment">//  directory/dirent offset, which cannot fit in 64bits of FileId.</span>
01433 <span class="comment">//  A FileId must be 64bits since we export this in the FileInternalInforation</span>
01434 <span class="comment">//  query.</span>
01435 <span class="comment">//</span>
01436 <span class="comment">//  Also, even through we are restricted to a single partition in this</span>
01437 <span class="comment">//  implementation, getting those "spare" 16bits isn't good enough to let us</span>
01438 <span class="comment">//  point directly into a directory's File Identifier. Files and by extension</span>
01439 <span class="comment">//  directories can exceed 2^32 bytes/entries.  Once we have pointed at the</span>
01440 <span class="comment">//  parent dir, we are out of bits.</span>
01441 <span class="comment">//</span>
01442 <span class="comment">//  The Id field is a LARGE_INTEGER where the High and Low parts can be</span>
01443 <span class="comment">//  accessed separately.</span>
01444 <span class="comment">//</span>
01445 <span class="comment">//  The following macros are used to access the Fid fields.</span>
01446 <span class="comment">//</span>
01447 <span class="comment">//      CdQueryFidDirentOffset      - Accesses the Dirent offset field</span>
01448 <span class="comment">//      CdQueryFidPathTableNumber   - Accesses the PathTable offset field</span>
01449 <span class="comment">//      CdSetFidDirentOffset        - Sets the Dirent offset field</span>
01450 <span class="comment">//      CdSetFidPathTableNumber     - Sets the PathTable ordinal field</span>
01451 <span class="comment">//      CdFidIsDirectory            - Queries if directory bit is set</span>
01452 <span class="comment">//      CdFidSetDirectory           - Sets directory bit</span>
01453 <span class="comment">//</span>
01454 
<a name="l01455"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a43">01455</a> <span class="preprocessor">#define FID_DIR_MASK  0x80000000        // high order bit means directory.</span>
01456 <span class="preprocessor"></span>
<a name="l01457"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a44">01457</a> <span class="preprocessor">#define UdfSetFidFromLbAddr(I, LBA)     { (I).LowPart = (LBA).Lbn; \</span>
01458 <span class="preprocessor">                                          (I).HighPart = (ULONG) (LBA).Partition; }</span>
01459 <span class="preprocessor"></span>
<a name="l01460"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a45">01460</a> <span class="preprocessor">#define UdfGetFidLbn(I)                 ((I).LowPart)</span>
<a name="l01461"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a46">01461</a> <span class="preprocessor"></span><span class="preprocessor">#define UdfGetFidPartition(I)           ((USHORT) (((I).HighPart &amp; ~FID_DIR_MASK) &amp; MAXUSHORT))</span>
<a name="l01462"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a47">01462</a> <span class="preprocessor"></span><span class="preprocessor">#define UdfGetFidReservedZero(I)        ((I).HighPart &amp; ~(FID_DIR_MASK|MAXUSHORT))</span>
01463 <span class="preprocessor"></span>
<a name="l01464"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a48">01464</a> <span class="preprocessor">#define UdfSetFidFile(I)                ClearFlag( (I).HighPart, FID_DIR_MASK )</span>
<a name="l01465"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a49">01465</a> <span class="preprocessor"></span><span class="preprocessor">#define UdfSetFidDirectory(I)           SetFlag( (I).HighPart, FID_DIR_MASK )</span>
01466 <span class="preprocessor"></span>
<a name="l01467"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a50">01467</a> <span class="preprocessor">#define UdfIsFidFile(I)                 BooleanFlagOff( (I).HighPart, FID_DIR_MASK )</span>
<a name="l01468"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a51">01468</a> <span class="preprocessor"></span><span class="preprocessor">#define UdfIsFidDirectory(I)            BooleanFlagOn( (I).HighPart, FID_DIR_MASK )</span>
01469 <span class="preprocessor"></span>
01470 
01471 <span class="comment">//</span>
01472 <span class="comment">//  Context structures for browsing through structures</span>
01473 <span class="comment">//</span>
01474 
01475 <span class="comment">//</span>
01476 <span class="comment">//  A mapped view is a useful bundle to hold information about a physical</span>
01477 <span class="comment">//  view of the disk.</span>
01478 <span class="comment">//</span>
01479 
<a name="l01480"></a><a class="code" href="../../d6/d6/struct__MAPPED__PVIEW.html">01480</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d6/d6/struct__MAPPED__PVIEW.html">_MAPPED_PVIEW</a> {
01481 
01482     <span class="comment">//</span>
01483     <span class="comment">//  A mapped extent and CC control block</span>
01484     <span class="comment">//</span>
01485 
<a name="l01486"></a><a class="code" href="../../d6/d6/struct__MAPPED__PVIEW.html#o0">01486</a>     PVOID <a class="code" href="../../d6/d6/struct__MAPPED__PVIEW.html#o0">View</a>;
<a name="l01487"></a><a class="code" href="../../d6/d6/struct__MAPPED__PVIEW.html#o1">01487</a>     <a class="code" href="../../d5/d5/cc_8h.html#a110">PBCB</a> <a class="code" href="../../d6/d6/struct__MAPPED__PVIEW.html#o1">Bcb</a>;
01488 
01489     <span class="comment">//</span>
01490     <span class="comment">//  Extent location</span>
01491     <span class="comment">//</span>
01492 
<a name="l01493"></a><a class="code" href="../../d6/d6/struct__MAPPED__PVIEW.html#o2">01493</a>     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> <a class="code" href="../../d6/d6/struct__MAPPED__PVIEW.html#o2">Partition</a>;
<a name="l01494"></a><a class="code" href="../../d6/d6/struct__MAPPED__PVIEW.html#o3">01494</a>     ULONG <a class="code" href="../../d6/d6/struct__MAPPED__PVIEW.html#o3">Lbn</a>;
<a name="l01495"></a><a class="code" href="../../d6/d6/struct__MAPPED__PVIEW.html#o4">01495</a>     ULONG <a class="code" href="../../d6/d6/struct__MAPPED__PVIEW.html#o4">Length</a>;
01496 
01497 } <a class="code" href="../../d6/d6/struct__MAPPED__PVIEW.html">MAPPED_PVIEW</a>, *<a class="code" href="../../d6/d6/struct__MAPPED__PVIEW.html">PMAPPED_PVIEW</a>;
01498 
01499 
01500 <span class="comment">//</span>
01501 <span class="comment">//  Enumeration contexts for various operations.</span>
01502 <span class="comment">//</span>
01503 
01504 <span class="comment">//</span>
01505 <span class="comment">//  The following is used for crawling ICB hierarchies searching</span>
01506 <span class="comment">//  for some notion of an active entry.</span>
01507 <span class="comment">//</span>
01508 
<a name="l01509"></a><a class="code" href="../../d9/d9/struct__ICB__SEARCH__CONTEXT.html">01509</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d9/d9/struct__ICB__SEARCH__CONTEXT.html">_ICB_SEARCH_CONTEXT</a> {
01510 
01511     <span class="comment">//</span>
01512     <span class="comment">//  Vcb the search is occuring on.</span>
01513     <span class="comment">//</span>
01514 
<a name="l01515"></a><a class="code" href="../../d9/d9/struct__ICB__SEARCH__CONTEXT.html#o0">01515</a>     <a class="code" href="../../d6/d8/udfstruc_8h.html#a74">PVCB</a> <a class="code" href="../../d9/d9/struct__ICB__SEARCH__CONTEXT.html#o0">Vcb</a>;
01516 
01517     <span class="comment">//</span>
01518     <span class="comment">//  Type of Icb being searched for.</span>
01519     <span class="comment">//</span>
01520 
<a name="l01521"></a><a class="code" href="../../d9/d9/struct__ICB__SEARCH__CONTEXT.html#o1">01521</a>     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> <a class="code" href="../../d9/d9/struct__ICB__SEARCH__CONTEXT.html#o1">IcbType</a>;
01522 
01523     <span class="comment">//</span>
01524     <span class="comment">//  The Active is most prevailing ICB so far found.</span>
01525     <span class="comment">//</span>
01526 
<a name="l01527"></a><a class="code" href="../../d9/d9/struct__ICB__SEARCH__CONTEXT.html#o2">01527</a>     <a class="code" href="../../d6/d6/struct__MAPPED__PVIEW.html">MAPPED_PVIEW</a> <a class="code" href="../../d9/d9/struct__ICB__SEARCH__CONTEXT.html#o2">Active</a>;
01528     
01529     <span class="comment">//</span>
01530     <span class="comment">//  The current logical block extent being read from the disk.</span>
01531     <span class="comment">//</span>
01532 
<a name="l01533"></a><a class="code" href="../../d9/d9/struct__ICB__SEARCH__CONTEXT.html#o3">01533</a>     <a class="code" href="../../d6/d6/struct__MAPPED__PVIEW.html">MAPPED_PVIEW</a> <a class="code" href="../../d9/d9/struct__ICB__SEARCH__CONTEXT.html#o3">Current</a>;
01534 
01535 } <a class="code" href="../../d9/d9/struct__ICB__SEARCH__CONTEXT.html">ICB_SEARCH_CONTEXT</a>, *<a class="code" href="../../d9/d9/struct__ICB__SEARCH__CONTEXT.html">PICB_SEARCH_CONTEXT</a>;
01536 
01537 <span class="comment">//</span>
01538 <span class="comment">//  The following is used for crawling Extended Attributes extending off of</span>
01539 <span class="comment">//  a direct ICB</span>
01540 <span class="comment">//</span>
01541 
<a name="l01542"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a132">01542</a> <span class="keyword">typedef</span> <span class="keyword">enum</span> <a class="code" href="../../d6/d8/udfstruc_8h.html#a132">_EA_SEARCH_TYPE</a> {
01543 
01544     <a class="code" href="../../d6/d8/udfstruc_8h.html#a132a125">EaEnumBad</a> = 0,
01545     <a class="code" href="../../d6/d8/udfstruc_8h.html#a132a126">EaEnumISO</a>,
01546     <a class="code" href="../../d6/d8/udfstruc_8h.html#a132a127">EaEnumImplementation</a>,
01547     <a class="code" href="../../d6/d8/udfstruc_8h.html#a132a128">EaEnumApplication</a>
01548 
01549 } <a class="code" href="../../d6/d8/udfstruc_8h.html#a106">EA_SEARCH_TYPE</a>, *<a class="code" href="../../d6/d8/udfstruc_8h.html#a107">PEA_SEARCH_TYPE</a>;
01550 
<a name="l01551"></a><a class="code" href="../../d6/d1/struct__EA__SEARCH__CONTEXT.html">01551</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d6/d1/struct__EA__SEARCH__CONTEXT.html">_EA_SEARCH_CONTEXT</a> {
01552 
01553     <span class="comment">//</span>
01554     <span class="comment">//  Reference to an elaborated ICB_SEARCH_CONTEXT which gives us a handle</span>
01555     <span class="comment">//  onto a direct ICB to crawl.</span>
01556     <span class="comment">//</span>
01557 
<a name="l01558"></a><a class="code" href="../../d6/d1/struct__EA__SEARCH__CONTEXT.html#o0">01558</a>     <a class="code" href="../../d6/d8/udfstruc_8h.html#a105">PICB_SEARCH_CONTEXT</a> <a class="code" href="../../d6/d1/struct__EA__SEARCH__CONTEXT.html#o0">IcbContext</a>;
01559 
01560     <span class="comment">//</span>
01561     <span class="comment">//  The current Ea being looked at.</span>
01562     <span class="comment">//</span>
01563 
<a name="l01564"></a><a class="code" href="../../d6/d1/struct__EA__SEARCH__CONTEXT.html#o1">01564</a>     PVOID <a class="code" href="../../d6/d1/struct__EA__SEARCH__CONTEXT.html#o1">Ea</a>;
01565 
01566     <span class="comment">//</span>
01567     <span class="comment">//  Bytes remaining in the EA view</span>
01568     <span class="comment">//</span>
01569 
<a name="l01570"></a><a class="code" href="../../d6/d1/struct__EA__SEARCH__CONTEXT.html#o2">01570</a>     ULONG <a class="code" href="../../d6/d1/struct__EA__SEARCH__CONTEXT.html#o2">Remaining</a>;
01571 
01572     <span class="comment">//</span>
01573     <span class="comment">//  EA being searched for.  We only support looking for ISO at this time.</span>
01574     <span class="comment">//</span>
01575 
<a name="l01576"></a><a class="code" href="../../d6/d1/struct__EA__SEARCH__CONTEXT.html#o3">01576</a>     ULONG <a class="code" href="../../d6/d1/struct__EA__SEARCH__CONTEXT.html#o3">EAType</a>;
<a name="l01577"></a><a class="code" href="../../d6/d1/struct__EA__SEARCH__CONTEXT.html#o4">01577</a>     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> <a class="code" href="../../d6/d1/struct__EA__SEARCH__CONTEXT.html#o4">EASubType</a>;
01578 
01579 } <a class="code" href="../../d6/d1/struct__EA__SEARCH__CONTEXT.html">EA_SEARCH_CONTEXT</a>, *<a class="code" href="../../d6/d1/struct__EA__SEARCH__CONTEXT.html">PEA_SEARCH_CONTEXT</a>;
01580 
01581 <span class="comment">//</span>
01582 <span class="comment">//  The following is used to crawl the list of allocation extent descriptors attached</span>
01583 <span class="comment">//  to an ICB.</span>
01584 <span class="comment">//</span>
01585 
<a name="l01586"></a><a class="code" href="../../d2/d6/struct__ALLOC__ENUM__CONTEXT.html">01586</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d2/d6/struct__ALLOC__ENUM__CONTEXT.html">_ALLOC_ENUM_CONTEXT</a> {
01587 
01588     <span class="comment">//</span>
01589     <span class="comment">//  Reference to an elaborated ICB_ENUM_CONTEXT which gives us a handle</span>
01590     <span class="comment">//  onto a direct ICB to crawl.</span>
01591     <span class="comment">//</span>
01592 
<a name="l01593"></a><a class="code" href="../../d2/d6/struct__ALLOC__ENUM__CONTEXT.html#o0">01593</a>     <a class="code" href="../../d6/d8/udfstruc_8h.html#a105">PICB_SEARCH_CONTEXT</a> <a class="code" href="../../d2/d6/struct__ALLOC__ENUM__CONTEXT.html#o0">IcbContext</a>;
01594 
01595     <span class="comment">//</span>
01596     <span class="comment">//  The current allocation descriptor being looked at.</span>
01597     <span class="comment">//</span>
01598 
<a name="l01599"></a><a class="code" href="../../d2/d6/struct__ALLOC__ENUM__CONTEXT.html#o1">01599</a>     PVOID <a class="code" href="../../d2/d6/struct__ALLOC__ENUM__CONTEXT.html#o1">Alloc</a>;
01600 
01601     <span class="comment">//</span>
01602     <span class="comment">//  Type of allocation descriptors in this enumeration</span>
01603     <span class="comment">//</span>
01604 
<a name="l01605"></a><a class="code" href="../../d2/d6/struct__ALLOC__ENUM__CONTEXT.html#o2">01605</a>     ULONG <a class="code" href="../../d2/d6/struct__ALLOC__ENUM__CONTEXT.html#o2">AllocType</a>;
01606 
01607     <span class="comment">//</span>
01608     <span class="comment">//  Bytes remaining in this view.</span>
01609     <span class="comment">//</span>
01610 
<a name="l01611"></a><a class="code" href="../../d2/d6/struct__ALLOC__ENUM__CONTEXT.html#o3">01611</a>     ULONG <a class="code" href="../../d2/d6/struct__ALLOC__ENUM__CONTEXT.html#o3">Remaining</a>;
01612 
01613 } <a class="code" href="../../d2/d6/struct__ALLOC__ENUM__CONTEXT.html">ALLOC_ENUM_CONTEXT</a>, *<a class="code" href="../../d2/d6/struct__ALLOC__ENUM__CONTEXT.html">PALLOC_ENUM_CONTEXT</a>;
01614 
01615 <span class="comment">//</span>
01616 <span class="comment">//  The following is used to crawl a logical directory.</span>
01617 <span class="comment">//</span>
01618 
<a name="l01619"></a><a class="code" href="../../d5/d5/struct__DIR__ENUM__CONTEXT.html">01619</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d5/d5/struct__DIR__ENUM__CONTEXT.html">_DIR_ENUM_CONTEXT</a> {
01620 
01621     <span class="comment">//</span>
01622     <span class="comment">//  The current view in the enumeration.</span>
01623     <span class="comment">//</span>
01624 
<a name="l01625"></a><a class="code" href="../../d5/d5/struct__DIR__ENUM__CONTEXT.html#o0">01625</a>     PVOID <a class="code" href="../../d5/d5/struct__DIR__ENUM__CONTEXT.html#o0">View</a>;
<a name="l01626"></a><a class="code" href="../../d5/d5/struct__DIR__ENUM__CONTEXT.html#o1">01626</a>     <a class="code" href="../../d5/d5/cc_8h.html#a110">PBCB</a> <a class="code" href="../../d5/d5/struct__DIR__ENUM__CONTEXT.html#o1">Bcb</a>;
01627 
01628     <span class="comment">//</span>
01629     <span class="comment">//  Offset of the view from the beginning of the directory.</span>
01630     <span class="comment">//</span>
01631     
<a name="l01632"></a><a class="code" href="../../d5/d5/struct__DIR__ENUM__CONTEXT.html#o2">01632</a>     LARGE_INTEGER <a class="code" href="../../d5/d5/struct__DIR__ENUM__CONTEXT.html#o2">BaseOffset</a>;
01633 
01634     <span class="comment">//</span>
01635     <span class="comment">//  Length of the view which is valid and the current</span>
01636     <span class="comment">//  offset in it.</span>
01637     <span class="comment">//</span>
01638 
<a name="l01639"></a><a class="code" href="../../d5/d5/struct__DIR__ENUM__CONTEXT.html#o3">01639</a>     ULONG <a class="code" href="../../d5/d5/struct__DIR__ENUM__CONTEXT.html#o3">ViewLength</a>;
<a name="l01640"></a><a class="code" href="../../d5/d5/struct__DIR__ENUM__CONTEXT.html#o4">01640</a>     ULONG <a class="code" href="../../d5/d5/struct__DIR__ENUM__CONTEXT.html#o4">ViewOffset</a>;
01641 
01642     <span class="comment">//</span>
01643     <span class="comment">//  Pointer to the current FID.</span>
01644     <span class="comment">//</span>
01645 
<a name="l01646"></a><a class="code" href="../../d5/d5/struct__DIR__ENUM__CONTEXT.html#o5">01646</a>     <a class="code" href="../../d1/d2/structNSR__FID.html">PNSR_FID</a> <a class="code" href="../../d5/d5/struct__DIR__ENUM__CONTEXT.html#o5">Fid</a>;
01647 
01648     <span class="comment">//</span>
01649     <span class="comment">//  Offset to the next fid from the beginning of the view.</span>
01650     <span class="comment">//</span>
01651     
<a name="l01652"></a><a class="code" href="../../d5/d5/struct__DIR__ENUM__CONTEXT.html#o6">01652</a>     ULONG <a class="code" href="../../d5/d5/struct__DIR__ENUM__CONTEXT.html#o6">NextFidOffset</a>;
01653 
01654     <span class="comment">//</span>
01655     <span class="comment">//  Flags indicating the state of the enumeration.</span>
01656     <span class="comment">//</span>
01657 
<a name="l01658"></a><a class="code" href="../../d5/d5/struct__DIR__ENUM__CONTEXT.html#o7">01658</a>     ULONG <a class="code" href="../../d5/d5/struct__DIR__ENUM__CONTEXT.html#o7">Flags</a>;
01659 
01660     <span class="comment">//</span>
01661     <span class="comment">//  Converted names from the FID. Case name is "case appropriate" for</span>
01662     <span class="comment">//  the operation.</span>
01663     <span class="comment">//</span>
01664 
<a name="l01665"></a><a class="code" href="../../d5/d5/struct__DIR__ENUM__CONTEXT.html#o8">01665</a>     UNICODE_STRING <a class="code" href="../../d5/d5/struct__DIR__ENUM__CONTEXT.html#o8">ObjectName</a>;
<a name="l01666"></a><a class="code" href="../../d5/d5/struct__DIR__ENUM__CONTEXT.html#o9">01666</a>     UNICODE_STRING <a class="code" href="../../d5/d5/struct__DIR__ENUM__CONTEXT.html#o9">CaseObjectName</a>;
01667 
01668     <span class="comment">//</span>
01669     <span class="comment">//  Real object name in pure form (not rendered to NT legal form)</span>
01670     <span class="comment">//</span>
01671 
<a name="l01672"></a><a class="code" href="../../d5/d5/struct__DIR__ENUM__CONTEXT.html#o10">01672</a>     UNICODE_STRING <a class="code" href="../../d5/d5/struct__DIR__ENUM__CONTEXT.html#o10">PureObjectName</a>;
01673 
01674     <span class="comment">//</span>
01675     <span class="comment">//  Short name for the object.</span>
01676     <span class="comment">//</span>
01677 
<a name="l01678"></a><a class="code" href="../../d5/d5/struct__DIR__ENUM__CONTEXT.html#o11">01678</a>     UNICODE_STRING <a class="code" href="../../d5/d5/struct__DIR__ENUM__CONTEXT.html#o11">ShortObjectName</a>;
01679 
01680     <span class="comment">//</span>
01681     <span class="comment">//  Currently allocated space for the name.  The previous strings are</span>
01682     <span class="comment">//  carved out of this single buffer.</span>
01683     <span class="comment">//</span>
01684 
<a name="l01685"></a><a class="code" href="../../d5/d5/struct__DIR__ENUM__CONTEXT.html#o12">01685</a>     PVOID <a class="code" href="../../d5/d5/struct__DIR__ENUM__CONTEXT.html#o12">NameBuffer</a>;
01686 
01687     <span class="comment">//</span>
01688     <span class="comment">//  Size of currently allocated name buffer for the lfn names.</span>
01689     <span class="comment">//</span>
01690 
<a name="l01691"></a><a class="code" href="../../d5/d5/struct__DIR__ENUM__CONTEXT.html#o13">01691</a>     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> <a class="code" href="../../d5/d5/struct__DIR__ENUM__CONTEXT.html#o13">AllocLength</a>;
01692 
01693 } <a class="code" href="../../d5/d5/struct__DIR__ENUM__CONTEXT.html">DIR_ENUM_CONTEXT</a>, *<a class="code" href="../../d5/d5/struct__DIR__ENUM__CONTEXT.html">PDIR_ENUM_CONTEXT</a>;
01694 
01695 <span class="comment">//</span>
01696 <span class="comment">//  Flags for noting where in the enumeration we are.</span>
01697 <span class="comment">//</span>
01698 
<a name="l01699"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a52">01699</a> <span class="preprocessor">#define DIR_CONTEXT_FLAG_SEEN_NONCONSTANT       0x0001</span>
<a name="l01700"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a53">01700</a> <span class="preprocessor"></span><span class="preprocessor">#define DIR_CONTEXT_FLAG_SEEN_PARENT            0x0002</span>
01701 <span class="preprocessor"></span>
01702 <span class="comment">//</span>
01703 <span class="comment">//  Flag indicating current Fid was buffered into pool.</span>
01704 <span class="comment">//</span>
01705 
<a name="l01706"></a><a class="code" href="../../d6/d8/udfstruc_8h.html#a54">01706</a> <span class="preprocessor">#define DIR_CONTEXT_FLAG_FID_BUFFERED           0x0004</span>
01707 <span class="preprocessor"></span>
01708 <span class="preprocessor">#endif // _CDSTRUC_</span>
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:42:10 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
