<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: cachesub.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>cachesub.c</h1><a href="../../d6/d2/cachesub_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1990  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    cachesub.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module implements the common subroutines for the Cache subsystem.</span>
00012 <span class="comment"></span>
00013 <span class="comment">Author:</span>
00014 <span class="comment"></span>
00015 <span class="comment">    Tom Miller      [TomM]      4-May-1990</span>
00016 <span class="comment"></span>
00017 <span class="comment">Revision History:</span>
00018 <span class="comment"></span>
00019 <span class="comment">--*/</span>
00020 
00021 <span class="preprocessor">#include "<a class="code" href="../../d5/d5/cc_8h.html">cc.h</a>"</span>
00022 
00023 <span class="comment">//</span>
00024 <span class="comment">//  The Bug check file id for this module</span>
00025 <span class="comment">//</span>
00026 
<a name="l00027"></a><a class="code" href="../../d6/d2/cachesub_8c.html#a0">00027</a> <span class="preprocessor">#define BugCheckFileId                   (CACHE_BUG_CHECK_CACHESUB)</span>
00028 <span class="preprocessor"></span>
00029 <span class="comment">//</span>
00030 <span class="comment">//  Define our debug constant</span>
00031 <span class="comment">//</span>
00032 
<a name="l00033"></a><a class="code" href="../../d6/d2/cachesub_8c.html#a1">00033</a> <span class="preprocessor">#define me 0x00000002</span>
00034 <span class="preprocessor"></span>
00035 <span class="comment">//</span>
00036 <span class="comment">//  Define those errors which should be retried</span>
00037 <span class="comment">//</span>
00038 
<a name="l00039"></a><a class="code" href="../../d6/d2/cachesub_8c.html#a2">00039</a> <span class="preprocessor">#define RetryError(STS) (((STS) == STATUS_VERIFY_REQUIRED) || ((STS) == STATUS_FILE_LOCK_CONFLICT))</span>
00040 <span class="preprocessor"></span>
<a name="l00041"></a><a class="code" href="../../d6/d2/cachesub_8c.html#a3">00041</a> ULONG <a class="code" href="../../d6/d2/cachesub_8c.html#a3">CcMaxDirtyWrite</a> = 0x10000;
00042 
00043 <span class="comment">//</span>
00044 <span class="comment">//  Local support routines</span>
00045 <span class="comment">//</span>
00046 
00047 BOOLEAN
00048 <a class="code" href="../../d6/d2/cachesub_8c.html#a4">CcFindBcb</a> (
00049     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap,
00050     IN PLARGE_INTEGER FileOffset,
00051     IN OUT PLARGE_INTEGER BeyondLastByte,
00052     OUT <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> *Bcb
00053     );
00054 
00055 <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>
00056 <a class="code" href="../../d6/d2/cachesub_8c.html#a5">CcAllocateInitializeBcb</a> (
00057     IN OUT <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap OPTIONAL,
00058     IN OUT <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> AfterBcb,
00059     IN PLARGE_INTEGER FileOffset,
00060     IN PLARGE_INTEGER Length
00061     );
00062 
00063 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00064 <a class="code" href="../../d6/d2/cachesub_8c.html#a6">CcSetValidData</a> (
00065     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00066     IN PLARGE_INTEGER ValidDataLength
00067     );
00068 
00069 BOOLEAN
00070 <a class="code" href="../../d6/d2/cachesub_8c.html#a7">CcAcquireByteRangeForWrite</a> (
00071     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap,
00072     IN PLARGE_INTEGER TargetOffset OPTIONAL,
00073     IN ULONG TargetLength,
00074     OUT PLARGE_INTEGER FileOffset,
00075     OUT PULONG Length,
00076     OUT <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> *FirstBcb
00077     );
00078 
00079 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00080 <a class="code" href="../../d6/d2/cachesub_8c.html#a8">CcReleaseByteRangeFromWrite</a> (
00081     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap,
00082     IN PLARGE_INTEGER FileOffset,
00083     IN ULONG Length,
00084     IN <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> FirstBcb,
00085     IN BOOLEAN VerifyRequired
00086     );
00087 
00088 <a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html">PBITMAP_RANGE</a>
00089 <a class="code" href="../../d6/d2/cachesub_8c.html#a9">CcFindBitmapRangeToDirty</a> (
00090     IN <a class="code" href="../../d9/d6/struct__MBCB.html">PMBCB</a> Mbcb,
00091     IN LONGLONG Page,
00092     IN PULONG *FreePageForSetting
00093     );
00094 
00095 <a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html">PBITMAP_RANGE</a>
00096 <a class="code" href="../../d6/d2/cachesub_8c.html#a10">CcFindBitmapRangeToClean</a> (
00097     IN <a class="code" href="../../d9/d6/struct__MBCB.html">PMBCB</a> Mbcb,
00098     IN LONGLONG Page
00099     );
00100 
00101 BOOLEAN
00102 <a class="code" href="../../d6/d2/cachesub_8c.html#a11">CcLogError</a>(
00103     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> Device,
00104     IN NTSTATUS Error,
00105     IN NTSTATUS DeviceError,
00106     IN PUNICODE_STRING FileName
00107     );
00108 
00109 
00110 
00111 <span class="comment">//</span>
00112 <span class="comment">//  Internal support routine</span>
00113 <span class="comment">//</span>
00114 
00115 BOOLEAN
<a name="l00116"></a><a class="code" href="../../d5/d5/cc_8h.html#a175">00116</a> <a class="code" href="../../d5/d5/cc_8h.html#a175">CcPinFileData</a> (
00117     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00118     IN PLARGE_INTEGER FileOffset,
00119     IN ULONG Length,
00120     IN BOOLEAN ReadOnly,
00121     IN BOOLEAN WriteOnly,
00122     IN ULONG Flags,
00123     OUT <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> *Bcb,
00124     OUT PVOID *BaseAddress,
00125     OUT PLARGE_INTEGER BeyondLastByte
00126     )
00127 
00128 <span class="comment">/*++</span>
00129 <span class="comment"></span>
00130 <span class="comment">Routine Description:</span>
00131 <span class="comment"></span>
00132 <span class="comment">    This routine locks the specified range of file data into memory.</span>
00133 <span class="comment"></span>
00134 <span class="comment">    Note that the data desired by the caller (or the first part of it)</span>
00135 <span class="comment">    may be in one of three states:</span>
00136 <span class="comment"></span>
00137 <span class="comment">        No Bcb exists which describes the data</span>
00138 <span class="comment"></span>
00139 <span class="comment">        A Bcb exists describing the data, but it is not mapped</span>
00140 <span class="comment">        (BcbOut-&gt;BaseAddress == NULL)</span>
00141 <span class="comment"></span>
00142 <span class="comment">        A Bcb exists describing the data, and it is mapped</span>
00143 <span class="comment"></span>
00144 <span class="comment">    Given the above three states, and given that the caller may call</span>
00145 <span class="comment">    with either Wait == FALSE or Wait == TRUE, this routine has basically</span>
00146 <span class="comment">    six cases.  What has to be done, and the order in which things must be</span>
00147 <span class="comment">    done varies quite a bit with each of these six cases.  The most</span>
00148 <span class="comment">    straight-forward implementation of this routine, with the least amount</span>
00149 <span class="comment">    of branching, is achieved by determining which of the six cases applies,</span>
00150 <span class="comment">    and dispatching fairly directly to that case.  The handling of the</span>
00151 <span class="comment">    cases is summarized in the following table:</span>
00152 <span class="comment"></span>
00153 <span class="comment">                Wait == TRUE                Wait == FALSE</span>
00154 <span class="comment">                ------------                -------------</span>
00155 <span class="comment"></span>
00156 <span class="comment">    no Bcb      Case 1:                     Case 2:</span>
00157 <span class="comment"></span>
00158 <span class="comment">                CcAllocateInitializeBcb     CcMapAndRead (exit if FALSE)</span>
00159 <span class="comment">                Acquire Bcb Exclusive       CcAllocateInitializeBcb</span>
00160 <span class="comment">                Release BcbList SpinLock    Acquire Bcb Shared if not ReadOnly</span>
00161 <span class="comment">                CcMapAndRead w/ Wait        Release BcbList SpinLock</span>
00162 <span class="comment">                Convert/Release Bcb Resource</span>
00163 <span class="comment"></span>
00164 <span class="comment">    Bcb not     Case 3:                     Case 4:</span>
00165 <span class="comment">    mapped</span>
00166 <span class="comment">                Increment PinCount          Acquire Bcb Exclusive (exit if FALSE)</span>
00167 <span class="comment">                Release BcbList SpinLock    CcMapAndRead (exit if FALSE)</span>
00168 <span class="comment">                Acquire Bcb Excl. w/ Wait   Increment PinCount</span>
00169 <span class="comment">                if still not mapped         Convert/Release Bcb Resource</span>
00170 <span class="comment">                    CcMapAndRead w/ Wait    Release BcbList SpinLock</span>
00171 <span class="comment">                Convert/Release Bcb Resource</span>
00172 <span class="comment"></span>
00173 <span class="comment">    Bcb mapped  Case 5:                     Case 6:</span>
00174 <span class="comment"></span>
00175 <span class="comment">                Increment PinCount          if not ReadOnly</span>
00176 <span class="comment">                Release BcbList SpinLock        Acquire Bcb shared (exit if FALSE)</span>
00177 <span class="comment">                if not ReadOnly             Increment PinCount</span>
00178 <span class="comment">                    Acquire Bcb Shared      Release BcbList SpinLock</span>
00179 <span class="comment"></span>
00180 <span class="comment">    It is important to note that most changes to this routine will affect</span>
00181 <span class="comment">    multiple cases from above.</span>
00182 <span class="comment"></span>
00183 <span class="comment">Arguments:</span>
00184 <span class="comment"></span>
00185 <span class="comment">    FileObject - Pointer to File Object for file</span>
00186 <span class="comment"></span>
00187 <span class="comment">    FileOffset - Offset in file at which map should begin</span>
00188 <span class="comment"></span>
00189 <span class="comment">    Length - Length of desired map in bytes</span>
00190 <span class="comment"></span>
00191 <span class="comment">    ReadOnly - Supplies TRUE if caller will only read the mapped data (i.e.,</span>
00192 <span class="comment">               TRUE for CcCopyRead, CcMapData and CcMdlRead and FALSE for</span>
00193 <span class="comment">               everyone else)</span>
00194 <span class="comment"></span>
00195 <span class="comment">    WriteOnly - The specified range of bytes will only be written.</span>
00196 <span class="comment"></span>
00197 <span class="comment">    Flags - (PIN_WAIT, PIN_EXCLUSIVE, PIN_NO_READ, etc. as defined in cache.h)</span>
00198 <span class="comment"></span>
00199 <span class="comment">    Bcb - Returns a pointer to the Bcb representing the pinned data.</span>
00200 <span class="comment"></span>
00201 <span class="comment">    BaseAddress - Returns base address of desired data</span>
00202 <span class="comment"></span>
00203 <span class="comment">    BeyondLastByte - Returns the File Offset of the first byte beyond the</span>
00204 <span class="comment">                     last accessible byte.</span>
00205 <span class="comment"></span>
00206 <span class="comment">Return Value:</span>
00207 <span class="comment"></span>
00208 <span class="comment">    FALSE - if PIN_WAIT was set, and it was impossible to lock all</span>
00209 <span class="comment">            of the data without blocking</span>
00210 <span class="comment">    TRUE - if the desired data, is being returned</span>
00211 <span class="comment"></span>
00212 <span class="comment">Raises:</span>
00213 <span class="comment"></span>
00214 <span class="comment">    STATUS_INSUFFICIENT_RESOURCES - If a pool allocation failure occurs.</span>
00215 <span class="comment">        This can only occur if Wait was specified as TRUE.  (If Wait is</span>
00216 <span class="comment">        specified as FALSE, and an allocation failure occurs, this</span>
00217 <span class="comment">        routine simply returns FALSE.)</span>
00218 <span class="comment"></span>
00219 <span class="comment">--*/</span>
00220 
00221 {
00222     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
00223     LARGE_INTEGER TrialBound;
00224     KIRQL OldIrql;
00225     <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> BcbOut = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00226     ULONG ZeroFlags = 0;
00227     BOOLEAN SpinLockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00228     BOOLEAN Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00229 
00230     ULONG ReceivedLength;
00231     ULONG ActivePage;
00232     ULONG PageIsDirty;
00233     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> Vacb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00234 
00235     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcPinFileData:\n"</span>, 0 );
00236     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    FileObject = %08lx\n"</span>, FileObject );
00237     <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>(0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    FileOffset = %08lx, %08lx\n"</span>, FileOffset-&gt;LowPart,
00238                                                           FileOffset-&gt;HighPart );
00239     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    Length = %08lx\n"</span>, Length );
00240     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    Flags = %02lx\n"</span>, Flags );
00241 
00242     <span class="comment">//</span>
00243     <span class="comment">//  Get pointer to SharedCacheMap via File Object.</span>
00244     <span class="comment">//</span>
00245 
00246     SharedCacheMap = *(<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> *)((PCHAR)FileObject-&gt;SectionObjectPointer
00247                                             + <span class="keyword">sizeof</span>(PVOID));
00248 
00249     <span class="comment">//</span>
00250     <span class="comment">//  See if we have an active Vacb, that we need to free.</span>
00251     <span class="comment">//</span>
00252 
00253     <a class="code" href="../../d5/d5/cc_8h.html#a82">GetActiveVacb</a>( SharedCacheMap, OldIrql, Vacb, ActivePage, PageIsDirty );
00254 
00255     <span class="comment">//</span>
00256     <span class="comment">//  If there is an end of a page to be zeroed, then free that page now,</span>
00257     <span class="comment">//  so it does not cause our data to get zeroed.  If there is an active</span>
00258     <span class="comment">//  page, free it so we have the correct ValidDataGoal.</span>
00259     <span class="comment">//</span>
00260 
00261     <span class="keywordflow">if</span> ((Vacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) || (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
00262 
00263         <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, Vacb, ActivePage, PageIsDirty );
00264         Vacb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00265     }
00266 
00267     <span class="comment">//</span>
00268     <span class="comment">//  Make sure the calling file system is not asking to map beyond the</span>
00269     <span class="comment">//  end of the section, for example, that it did not forget to do</span>
00270     <span class="comment">//  CcExtendCacheSection.</span>
00271     <span class="comment">//</span>
00272 
00273     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( ( FileOffset-&gt;QuadPart + (LONGLONG)Length ) &lt;=
00274                      SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o5">SectionSize</a>.QuadPart );
00275 
00276     <span class="comment">//</span>
00277     <span class="comment">//  Initially clear output</span>
00278     <span class="comment">//</span>
00279 
00280     *Bcb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00281     *BaseAddress = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00282 
00283     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(Flags, <a class="code" href="../../d4/d2/cache_8h.html#a8">PIN_NO_READ</a>)) {
00284 
00285         *BaseAddress = <a class="code" href="../../d5/d3/vacbsup_8c.html#a15">CcGetVirtualAddress</a>( SharedCacheMap,
00286                                             *FileOffset,
00287                                             &amp;Vacb,
00288                                             &amp;ReceivedLength );
00289 
00290     } <span class="keywordflow">else</span> {
00291 
00292         <span class="comment">//</span>
00293         <span class="comment">//  In the PIN_NO_READ case, we simply need to make sure that the</span>
00294         <span class="comment">//  sparse structure containing the Bcb listheads is expanded in the</span>
00295         <span class="comment">//  region of the file we are interested in.</span>
00296         <span class="comment">//</span>
00297         <span class="comment">//  Fake a ReceivedLength that matches the remaining bytes in the view.</span>
00298         <span class="comment">//</span>
00299 
00300         ReceivedLength = <a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> -
00301                          (ULONG)(FileOffset-&gt;QuadPart &amp; (<a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - 1));
00302 
00303         <span class="comment">//</span>
00304         <span class="comment">//  Now simply cause a reference that will expand a multilevel Vacb.</span>
00305         <span class="comment">//</span>
00306 
00307         <a class="code" href="../../d5/d3/vacbsup_8c.html#a17">CcReferenceFileOffset</a>( SharedCacheMap, *FileOffset );
00308     }
00309 
00310     <span class="comment">//</span>
00311     <span class="comment">//  Acquire Bcb List Exclusive to look for Bcb</span>
00312     <span class="comment">//</span>
00313 
00314     ExAcquireSpinLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, &amp;OldIrql );
00315     SpinLockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00316 
00317     <span class="comment">//</span>
00318     <span class="comment">//  Use try to guarantee cleanup on the way out.</span>
00319     <span class="comment">//</span>
00320 
00321     <span class="keywordflow">try</span> {
00322 
00323         BOOLEAN Found;
00324         LARGE_INTEGER FOffset;
00325         LARGE_INTEGER TLength;
00326 
00327         <span class="comment">//</span>
00328         <span class="comment">//  Search for Bcb describing the largest matching "prefix" byte range,</span>
00329         <span class="comment">//  or where to insert it.</span>
00330         <span class="comment">//</span>
00331 
00332         TrialBound.QuadPart = FileOffset-&gt;QuadPart + (LONGLONG)Length;
00333         Found = <a class="code" href="../../d6/d2/cachesub_8c.html#a4">CcFindBcb</a>( SharedCacheMap, FileOffset, &amp;TrialBound, &amp;BcbOut );
00334 
00335 
00336         <span class="comment">//</span>
00337         <span class="comment">//  Cases 1 and 2 - Bcb was not found.</span>
00338         <span class="comment">//</span>
00339         <span class="comment">//  First caculate data to pin down.</span>
00340         <span class="comment">//</span>
00341 
00342         <span class="keywordflow">if</span> (!Found) {
00343 
00344             <span class="comment">//</span>
00345             <span class="comment">//  Get out if the user specified PIN_IF_BCB.</span>
00346             <span class="comment">//</span>
00347 
00348             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(Flags, <a class="code" href="../../d4/d2/cache_8h.html#a9">PIN_IF_BCB</a>)) {
00349 
00350                 <span class="comment">//</span>
00351                 <span class="comment">//  We need to zap BcbOut since this is a hint to the cleanup code</span>
00352                 <span class="comment">//  to remove the Bcb if we are returning FALSE.</span>
00353                 <span class="comment">//</span>
00354 
00355                 BcbOut = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00356                 <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>( Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00357             }
00358 
00359             <span class="comment">//</span>
00360             <span class="comment">//  Not found, calculate data to pin down.</span>
00361             <span class="comment">//</span>
00362             <span class="comment">//  Round local copy of FileOffset down to page boundary, and</span>
00363             <span class="comment">//  round copies of size and minimum size up.  Also make sure that</span>
00364             <span class="comment">//  we keep the length from crossing the end of the SharedCacheMap.</span>
00365             <span class="comment">//</span>
00366 
00367             FOffset = *FileOffset;
00368             TLength.QuadPart = TrialBound.QuadPart - FOffset.QuadPart;
00369 
00370             TLength.LowPart += FOffset.LowPart &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1);
00371             ReceivedLength += FOffset.LowPart &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1);
00372 
00373             <span class="comment">//</span>
00374             <span class="comment">//  At this point we can calculate the ReadOnly flag for</span>
00375             <span class="comment">//  the purposes of whether to use the Bcb resource, and</span>
00376             <span class="comment">//  we can calculate the ZeroFlags.</span>
00377             <span class="comment">//</span>
00378 
00379             <span class="keywordflow">if</span> ((!ReadOnly  &amp;&amp; !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a72">PIN_ACCESS</a>)) || WriteOnly) {
00380 
00381                 <span class="comment">//</span>
00382                 <span class="comment">//  We can always zero middle pages, if any.</span>
00383                 <span class="comment">//</span>
00384 
00385                 ZeroFlags = <a class="code" href="../../d5/d5/cc_8h.html#a86">ZERO_MIDDLE_PAGES</a>;
00386 
00387                 <span class="keywordflow">if</span> (((FOffset.LowPart &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) == 0) &amp;&amp;
00388                     (Length &gt;= <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>)) {
00389                     ZeroFlags |= <a class="code" href="../../d5/d5/cc_8h.html#a85">ZERO_FIRST_PAGE</a>;
00390                 }
00391 
00392                 <span class="keywordflow">if</span> ((TLength.LowPart &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) == 0) {
00393                     ZeroFlags |= <a class="code" href="../../d5/d5/cc_8h.html#a87">ZERO_LAST_PAGE</a>;
00394                 }
00395             }
00396 
00397             <span class="comment">//</span>
00398             <span class="comment">//  We treat Bcbs as ReadOnly (do not acquire resource) if they</span>
00399             <span class="comment">//  are in sections for which we have not disabled modified writing.</span>
00400             <span class="comment">//</span>
00401 
00402             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a78">MODIFIED_WRITE_DISABLED</a>)) {
00403                 ReadOnly = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00404             }
00405 
00406             TLength.LowPart = (ULONG) <a class="code" href="../../d2/d1/mm_8h.html#a4">ROUND_TO_PAGES</a>( TLength.LowPart );
00407 
00408             <span class="comment">//</span>
00409             <span class="comment">//  Round BaseAddress and FOffset down to the bottom of a page.</span>
00410             <span class="comment">//</span>
00411 
00412             *BaseAddress = ((PCHAR)*BaseAddress - (FileOffset-&gt;LowPart &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)));
00413             FOffset.LowPart &amp;= ~(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1);
00414 
00415             <span class="comment">//</span>
00416             <span class="comment">//  Even if we are readonly, we can still zero pages entirely</span>
00417             <span class="comment">//  beyond valid data length.</span>
00418             <span class="comment">//</span>
00419 
00420             <span class="keywordflow">if</span> (FOffset.QuadPart &gt;= SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o7">ValidDataGoal</a>.QuadPart) {
00421 
00422                 ZeroFlags |= <a class="code" href="../../d5/d5/cc_8h.html#a85">ZERO_FIRST_PAGE</a> | <a class="code" href="../../d5/d5/cc_8h.html#a86">ZERO_MIDDLE_PAGES</a> | <a class="code" href="../../d5/d5/cc_8h.html#a87">ZERO_LAST_PAGE</a>;
00423 
00424             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((FOffset.QuadPart + (LONGLONG)<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>) &gt;=
00425                                 SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o7">ValidDataGoal</a>.QuadPart) {
00426 
00427                 ZeroFlags |= <a class="code" href="../../d5/d5/cc_8h.html#a86">ZERO_MIDDLE_PAGES</a> | <a class="code" href="../../d5/d5/cc_8h.html#a87">ZERO_LAST_PAGE</a>;
00428             }
00429 
00430             <span class="comment">//</span>
00431             <span class="comment">//  We will get into trouble if we try to read more than we</span>
00432             <span class="comment">//  can map by one Vacb.  So make sure that our lengths stay</span>
00433             <span class="comment">//  within a Vacb.</span>
00434             <span class="comment">//</span>
00435 
00436             <span class="keywordflow">if</span> (TLength.LowPart &gt; ReceivedLength) {
00437                 TLength.LowPart = ReceivedLength;
00438             }
00439 
00440 
00441             <span class="comment">//</span>
00442             <span class="comment">//  Case 1 - Bcb was not found and Wait is TRUE.</span>
00443             <span class="comment">//</span>
00444             <span class="comment">//  Note that it is important to minimize the time that the Bcb</span>
00445             <span class="comment">//  List spin lock is held, as well as guarantee we do not take</span>
00446             <span class="comment">//  any faults while holding this lock.</span>
00447             <span class="comment">//</span>
00448             <span class="comment">//  If we can (and perhaps will) wait, then it is important to</span>
00449             <span class="comment">//  allocate the Bcb acquire it exclusive and free the Bcb List.</span>
00450             <span class="comment">//  We then procede to read in the data, and anyone else finding</span>
00451             <span class="comment">//  our Bcb will have to wait shared to insure that the data is</span>
00452             <span class="comment">//  in.</span>
00453             <span class="comment">//</span>
00454 
00455             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(Flags, <a class="code" href="../../d4/d2/cache_8h.html#a6">PIN_WAIT</a>)) {
00456 
00457                 BcbOut = <a class="code" href="../../d6/d2/cachesub_8c.html#a5">CcAllocateInitializeBcb</a>( SharedCacheMap,
00458                                                   BcbOut,
00459                                                   &amp;FOffset,
00460                                                   &amp;TLength );
00461 
00462                 <span class="keywordflow">if</span> (BcbOut == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00463                     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, 0, <span class="stringliteral">"Bcb allocation failure\n"</span>, 0 );
00464                     ExReleaseSpinLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, OldIrql );
00465                     SpinLockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00466                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INSUFFICIENT_RESOURCES );
00467                 }
00468 
00469                 <span class="comment">//</span>
00470                 <span class="comment">//  Now just acquire the newly-allocated Bcb shared, and</span>
00471                 <span class="comment">//  release the spin lock.</span>
00472                 <span class="comment">//</span>
00473 
00474                 <span class="keywordflow">if</span> (!ReadOnly) {
00475                     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(Flags, <a class="code" href="../../d4/d2/cache_8h.html#a7">PIN_EXCLUSIVE</a>)) {
00476                         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d5/d8/ex_8h.html#a70">ExAcquireResourceExclusive</a>( &amp;BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o10">Resource</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00477                     } <span class="keywordflow">else</span> {
00478                         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d5/d8/ex_8h.html#a270">ExAcquireSharedStarveExclusive</a>( &amp;BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o10">Resource</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00479                     }
00480                 }
00481                 ExReleaseSpinLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, OldIrql );
00482                 SpinLockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00483 
00484                 <span class="comment">//</span>
00485                 <span class="comment">//  Now read in the data.</span>
00486                 <span class="comment">//</span>
00487 
00488                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(Flags, <a class="code" href="../../d4/d2/cache_8h.html#a8">PIN_NO_READ</a>)) {
00489 
00490                     (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d5/d5/cc_8h.html#a181">CcMapAndRead</a>( SharedCacheMap,
00491                                         &amp;FOffset,
00492                                         TLength.LowPart,
00493                                         ZeroFlags,
00494                                         <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00495                                         *BaseAddress );
00496 
00497                     <span class="comment">//</span>
00498                     <span class="comment">//  Now we have to reacquire the Bcb List spinlock to load</span>
00499                     <span class="comment">//  up the mapping if we are the first one, else we collided</span>
00500                     <span class="comment">//  with someone else who loaded the mapping first, and we</span>
00501                     <span class="comment">//  will just free our mapping.  It is guaranteed that the</span>
00502                     <span class="comment">//  data will be mapped to the same place.</span>
00503                     <span class="comment">//</span>
00504 
00505                     ExAcquireSpinLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, &amp;OldIrql );
00506 
00507                     <span class="keywordflow">if</span> (BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o12">BaseAddress</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00508 
00509                         BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o12">BaseAddress</a> = *BaseAddress;
00510                         BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o8">Vacb</a> = Vacb;
00511                         Vacb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00512                     }
00513 
00514                     ExReleaseSpinLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, OldIrql );
00515 
00516                     <span class="comment">//</span>
00517                     <span class="comment">//  Calculate Base Address of the data we want.</span>
00518                     <span class="comment">//</span>
00519 
00520                     *BaseAddress = (PCHAR)BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o12">BaseAddress</a> +
00521                                    (ULONG)( FileOffset-&gt;QuadPart - BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o3">FileOffset</a>.QuadPart );
00522                 }
00523 
00524                 <span class="comment">//</span>
00525                 <span class="comment">//  Success!</span>
00526                 <span class="comment">//</span>
00527 
00528                 <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>( Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00529             }
00530 
00531 
00532             <span class="comment">//</span>
00533             <span class="comment">//  Case 2 - Bcb was not found and Wait is FALSE</span>
00534             <span class="comment">//</span>
00535             <span class="comment">//  If we cannot wait, then we go immediately see if the data is</span>
00536             <span class="comment">//  there (CcMapAndRead), and then only set up the Bcb and release</span>
00537             <span class="comment">//  the spin lock if the data is there.  Note here we call</span>
00538             <span class="comment">//  CcMapAndRead while holding the spin lock, because we know we</span>
00539             <span class="comment">//  will not fault and not block before returning.</span>
00540             <span class="comment">//</span>
00541 
00542             <span class="keywordflow">else</span> {
00543 
00544                 <span class="comment">//</span>
00545                 <span class="comment">//  Now try to allocate and initialize the Bcb.  If we</span>
00546                 <span class="comment">//  fail to allocate one, then return FALSE, since we know that</span>
00547                 <span class="comment">//  Wait = FALSE.  The caller may get lucky if he calls</span>
00548                 <span class="comment">//  us back with Wait = TRUE.</span>
00549                 <span class="comment">//</span>
00550 
00551                 BcbOut = <a class="code" href="../../d6/d2/cachesub_8c.html#a5">CcAllocateInitializeBcb</a>( SharedCacheMap,
00552                                                   BcbOut,
00553                                                   &amp;FOffset,
00554                                                   &amp;TLength );
00555 
00556                 <span class="keywordflow">if</span> (BcbOut == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00557 
00558                     <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>( Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00559                 }
00560 
00561                 <span class="comment">//</span>
00562                 <span class="comment">//  If we are not ReadOnly, we must acquire the newly-allocated</span>
00563                 <span class="comment">//  resource shared, and then we can free the spin lock.</span>
00564                 <span class="comment">//</span>
00565 
00566                 <span class="keywordflow">if</span> (!ReadOnly) {
00567                     <a class="code" href="../../d5/d8/ex_8h.html#a270">ExAcquireSharedStarveExclusive</a>( &amp;BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o10">Resource</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00568                 }
00569                 ExReleaseSpinLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, OldIrql );
00570                 SpinLockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00571 
00572                 <span class="comment">//</span>
00573                 <span class="comment">//  Note that since this call has Wait = FALSE, it cannot</span>
00574                 <span class="comment">//  get an exception (see procedure header).</span>
00575                 <span class="comment">//</span>
00576 
00577                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(Flags, <a class="code" href="../../d4/d2/cache_8h.html#a8">PIN_NO_READ</a>) );
00578                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a181">CcMapAndRead</a>( SharedCacheMap,
00579                                    &amp;FOffset,
00580                                    TLength.LowPart,
00581                                    ZeroFlags,
00582                                    <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00583                                    *BaseAddress )) {
00584 
00585                     <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>( Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00586                 }
00587 
00588                 <span class="comment">//</span>
00589                 <span class="comment">//  Now we have to reacquire the Bcb List spinlock to load</span>
00590                 <span class="comment">//  up the mapping if we are the first one, else we collided</span>
00591                 <span class="comment">//  with someone else who loaded the mapping first, and we</span>
00592                 <span class="comment">//  will just free our mapping.  It is guaranteed that the</span>
00593                 <span class="comment">//  data will be mapped to the same place.</span>
00594                 <span class="comment">//</span>
00595 
00596                 ExAcquireSpinLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, &amp;OldIrql );
00597 
00598                 <span class="keywordflow">if</span> (BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o12">BaseAddress</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00599 
00600                     BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o12">BaseAddress</a> = *BaseAddress;
00601                     BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o8">Vacb</a> = Vacb;
00602                     Vacb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00603                 }
00604 
00605                 ExReleaseSpinLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, OldIrql );
00606 
00607                 <span class="comment">//</span>
00608                 <span class="comment">//  Calculate Base Address of the data we want.</span>
00609                 <span class="comment">//</span>
00610 
00611                 *BaseAddress = (PCHAR)BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o12">BaseAddress</a> +
00612                                (ULONG)( FileOffset-&gt;QuadPart - BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o3">FileOffset</a>.QuadPart );
00613 
00614                 <span class="comment">//</span>
00615                 <span class="comment">//  Success!</span>
00616                 <span class="comment">//</span>
00617 
00618                 <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>( Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00619             }
00620 
00621         } <span class="keywordflow">else</span> {
00622 
00623             <span class="comment">//</span>
00624             <span class="comment">//  We treat Bcbs as ReadOnly (do not acquire resource) if they</span>
00625             <span class="comment">//  are in sections for which we have not disabled modified writing.</span>
00626             <span class="comment">//</span>
00627 
00628             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a78">MODIFIED_WRITE_DISABLED</a>)) {
00629                 ReadOnly = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00630             }
00631         }
00632 
00633 
00634         <span class="comment">//</span>
00635         <span class="comment">//  Cases 3 and 4 - Bcb is there but not mapped</span>
00636         <span class="comment">//</span>
00637 
00638         <span class="keywordflow">if</span> (BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o12">BaseAddress</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00639 
00640             <span class="comment">//</span>
00641             <span class="comment">//  It is too complicated to attempt to calculate any ZeroFlags in this</span>
00642             <span class="comment">//  case, because we have to not only do the tests above, but also</span>
00643             <span class="comment">//  compare to the byte range in the Bcb since we will be passing</span>
00644             <span class="comment">//  those parameters to CcMapAndRead.  Also, the probability of hitting</span>
00645             <span class="comment">//  some window where zeroing is of any advantage is quite small.</span>
00646             <span class="comment">//</span>
00647 
00648             <span class="comment">//</span>
00649             <span class="comment">//  Set up to just reread the Bcb exactly as the data in it is</span>
00650             <span class="comment">//  described.</span>
00651             <span class="comment">//</span>
00652 
00653             *BaseAddress = ((PCHAR)*BaseAddress - (FileOffset-&gt;LowPart - BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o3">FileOffset</a>.LowPart));
00654             FOffset = BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o3">FileOffset</a>;
00655             TLength.QuadPart = (LONGLONG)BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o2">ByteLength</a>;
00656 
00657             <span class="comment">//</span>
00658             <span class="comment">//  Case 3 - Bcb is there but not mapped and Wait is TRUE</span>
00659             <span class="comment">//</span>
00660             <span class="comment">//  Increment the PinCount, and then release the BcbList</span>
00661             <span class="comment">//  SpinLock so that we can wait to acquire the Bcb exclusive.</span>
00662             <span class="comment">//  Once we have the Bcb exclusive, map and read it in if no</span>
00663             <span class="comment">//  one beats us to it.  Someone may have beat us to it since</span>
00664             <span class="comment">//  we had to release the SpinLock above.</span>
00665             <span class="comment">//</span>
00666 
00667             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(Flags, <a class="code" href="../../d4/d2/cache_8h.html#a6">PIN_WAIT</a>)) {
00668 
00669                 BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o9">PinCount</a> += 1;
00670 
00671                 <span class="comment">//</span>
00672                 <span class="comment">//  Now we have to release the BcbList SpinLock in order to</span>
00673                 <span class="comment">//  acquire the Bcb shared.</span>
00674                 <span class="comment">//</span>
00675 
00676                 ExReleaseSpinLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, OldIrql );
00677                 SpinLockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00678                 <span class="keywordflow">if</span> (!ReadOnly) {
00679                     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(Flags, <a class="code" href="../../d4/d2/cache_8h.html#a7">PIN_EXCLUSIVE</a>)) {
00680                         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d5/d8/ex_8h.html#a70">ExAcquireResourceExclusive</a>( &amp;BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o10">Resource</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00681                     } <span class="keywordflow">else</span> {
00682                         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d5/d8/ex_8h.html#a270">ExAcquireSharedStarveExclusive</a>( &amp;BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o10">Resource</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00683                     }
00684                 }
00685 
00686                 <span class="comment">//</span>
00687                 <span class="comment">//  Now procede to map and read the data in.</span>
00688                 <span class="comment">//</span>
00689                 <span class="comment">//  Now read in the data.</span>
00690                 <span class="comment">//</span>
00691 
00692                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(Flags, <a class="code" href="../../d4/d2/cache_8h.html#a8">PIN_NO_READ</a>)) {
00693 
00694                     (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d5/d5/cc_8h.html#a181">CcMapAndRead</a>( SharedCacheMap,
00695                                         &amp;FOffset,
00696                                         TLength.LowPart,
00697                                         ZeroFlags,
00698                                         <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00699                                         *BaseAddress );
00700 
00701                     <span class="comment">//</span>
00702                     <span class="comment">//  Now we have to reacquire the Bcb List spinlock to load</span>
00703                     <span class="comment">//  up the mapping if we are the first one, else we collided</span>
00704                     <span class="comment">//  with someone else who loaded the mapping first, and we</span>
00705                     <span class="comment">//  will just free our mapping.  It is guaranteed that the</span>
00706                     <span class="comment">//  data will be mapped to the same place.</span>
00707                     <span class="comment">//</span>
00708 
00709                     ExAcquireSpinLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, &amp;OldIrql );
00710 
00711                     <span class="keywordflow">if</span> (BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o12">BaseAddress</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00712 
00713                         BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o12">BaseAddress</a> = *BaseAddress;
00714                         BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o8">Vacb</a> = Vacb;
00715                         Vacb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00716                     }
00717 
00718                     ExReleaseSpinLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, OldIrql );
00719 
00720                     <span class="comment">//</span>
00721                     <span class="comment">//</span>
00722                     <span class="comment">//  Calculate Base Address of the data we want.</span>
00723                     <span class="comment">//</span>
00724 
00725                     *BaseAddress = (PCHAR)BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o12">BaseAddress</a> +
00726                                    (ULONG)( FileOffset-&gt;QuadPart - BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o3">FileOffset</a>.QuadPart );
00727                 }
00728 
00729                 <span class="comment">//</span>
00730                 <span class="comment">//  Success!</span>
00731                 <span class="comment">//</span>
00732 
00733                 <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>( Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00734             }
00735 
00736 
00737             <span class="comment">//</span>
00738             <span class="comment">//  Case 4 - Bcb is there but not mapped, and Wait is FALSE</span>
00739             <span class="comment">//</span>
00740             <span class="comment">//  Since we cannot wait, we go immediately see if the data is</span>
00741             <span class="comment">//  there (CcMapAndRead), and then only set up the Bcb and release</span>
00742             <span class="comment">//  the spin lock if the data is there.  Note here we call</span>
00743             <span class="comment">//  CcMapAndRead while holding the spin lock, because we know we</span>
00744             <span class="comment">//  will not fault and not block before returning.</span>
00745             <span class="comment">//</span>
00746 
00747             <span class="keywordflow">else</span> {
00748 
00749                 <span class="keywordflow">if</span> (!ReadOnly &amp;&amp; !<a class="code" href="../../d5/d8/ex_8h.html#a270">ExAcquireSharedStarveExclusive</a>( &amp;BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o10">Resource</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> )) {
00750 
00751                     <span class="comment">//</span>
00752                     <span class="comment">//  If we cannot get the resource and have not incremented PinCount, then</span>
00753                     <span class="comment">//  suppress the unpin on cleanup.</span>
00754                     <span class="comment">//</span>
00755 
00756                     BcbOut = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00757                     <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>( Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00758                 }
00759 
00760                 BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o9">PinCount</a> += 1;
00761 
00762                 ExReleaseSpinLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, OldIrql );
00763                 SpinLockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00764 
00765                 <span class="comment">//</span>
00766                 <span class="comment">//  Note that since this call has Wait = FALSE, it cannot</span>
00767                 <span class="comment">//  get an exception (see procedure header).</span>
00768                 <span class="comment">//</span>
00769 
00770                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(Flags, <a class="code" href="../../d4/d2/cache_8h.html#a8">PIN_NO_READ</a>) );
00771                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a181">CcMapAndRead</a>( SharedCacheMap,
00772                                    &amp;BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o3">FileOffset</a>,
00773                                    BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o2">ByteLength</a>,
00774                                    ZeroFlags,
00775                                    <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00776                                    *BaseAddress )) {
00777 
00778                     <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>( Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00779                 }
00780 
00781                 <span class="comment">//</span>
00782                 <span class="comment">//  Now we have to reacquire the Bcb List spinlock to load</span>
00783                 <span class="comment">//  up the mapping if we are the first one, else we collided</span>
00784                 <span class="comment">//  with someone else who loaded the mapping first, and we</span>
00785                 <span class="comment">//  will just free our mapping.  It is guaranteed that the</span>
00786                 <span class="comment">//  data will be mapped to the same place.</span>
00787                 <span class="comment">//</span>
00788 
00789                 ExAcquireSpinLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, &amp;OldIrql );
00790 
00791                 <span class="keywordflow">if</span> (BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o12">BaseAddress</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00792 
00793                     BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o12">BaseAddress</a> = *BaseAddress;
00794                     BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o8">Vacb</a> = Vacb;
00795                     Vacb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00796                 }
00797 
00798                 ExReleaseSpinLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, OldIrql );
00799 
00800                 <span class="comment">//</span>
00801                 <span class="comment">//  Calculate Base Address of the data we want.</span>
00802                 <span class="comment">//</span>
00803 
00804                 *BaseAddress = (PCHAR)BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o12">BaseAddress</a> +
00805                                (ULONG)( FileOffset-&gt;QuadPart - BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o3">FileOffset</a>.QuadPart );
00806 
00807                 <span class="comment">//</span>
00808                 <span class="comment">//  Success!</span>
00809                 <span class="comment">//</span>
00810 
00811                 <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>( Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00812             }
00813         }
00814 
00815 
00816         <span class="comment">//</span>
00817         <span class="comment">//  Cases 5 and 6 - Bcb is there and it is mapped</span>
00818         <span class="comment">//</span>
00819 
00820         <span class="keywordflow">else</span> {
00821 
00822             <span class="comment">//</span>
00823             <span class="comment">//  Case 5 - Bcb is there and mapped, and Wait is TRUE</span>
00824             <span class="comment">//</span>
00825             <span class="comment">//  We can just increment the PinCount, release the SpinLock</span>
00826             <span class="comment">//  and then acquire the Bcb Shared if we are not ReadOnly.</span>
00827             <span class="comment">//</span>
00828 
00829             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(Flags, <a class="code" href="../../d4/d2/cache_8h.html#a6">PIN_WAIT</a>)) {
00830 
00831                 BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o9">PinCount</a> += 1;
00832                 ExReleaseSpinLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, OldIrql );
00833                 SpinLockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00834 
00835                 <span class="comment">//</span>
00836                 <span class="comment">//  Acquire Bcb Resource shared to insure that it is in memory.</span>
00837                 <span class="comment">//</span>
00838 
00839                 <span class="keywordflow">if</span> (!ReadOnly) {
00840                     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(Flags, <a class="code" href="../../d4/d2/cache_8h.html#a7">PIN_EXCLUSIVE</a>)) {
00841                         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d5/d8/ex_8h.html#a70">ExAcquireResourceExclusive</a>( &amp;BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o10">Resource</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00842                     } <span class="keywordflow">else</span> {
00843                         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d5/d8/ex_8h.html#a270">ExAcquireSharedStarveExclusive</a>( &amp;BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o10">Resource</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00844                     }
00845                 }
00846             }
00847 
00848             <span class="comment">//</span>
00849             <span class="comment">//  Case 6 - Bcb is there and mapped, and Wait is FALSE</span>
00850             <span class="comment">//</span>
00851             <span class="comment">//  If we are not ReadOnly, we have to first see if we can</span>
00852             <span class="comment">//  acquire the Bcb shared before incrmenting the PinCount,</span>
00853             <span class="comment">//  since we will have to return FALSE if we cannot acquire the</span>
00854             <span class="comment">//  resource.</span>
00855             <span class="comment">//</span>
00856 
00857             <span class="keywordflow">else</span> {
00858 
00859                 <span class="comment">//</span>
00860                 <span class="comment">//  Acquire Bcb Resource shared to insure that it is in memory.</span>
00861                 <span class="comment">//</span>
00862 
00863                 <span class="keywordflow">if</span> (!ReadOnly &amp;&amp; !<a class="code" href="../../d5/d8/ex_8h.html#a270">ExAcquireSharedStarveExclusive</a>( &amp;BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o10">Resource</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> )) {
00864 
00865                     <span class="comment">//</span>
00866                     <span class="comment">//  If we cannot get the resource and have not incremented PinCount, then</span>
00867                     <span class="comment">//  suppress the unpin on cleanup.</span>
00868                     <span class="comment">//</span>
00869 
00870                     BcbOut = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00871                     <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>( Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00872                 }
00873 
00874                 BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o9">PinCount</a> += 1;
00875                 ExReleaseSpinLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, OldIrql );
00876                 SpinLockAcquired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00877             }
00878 
00879             <span class="comment">//</span>
00880             <span class="comment">//  Calculate Base Address of the data we want.</span>
00881             <span class="comment">//</span>
00882 
00883             *BaseAddress = (PCHAR)BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o12">BaseAddress</a> +
00884                            (ULONG)( FileOffset-&gt;QuadPart - BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o3">FileOffset</a>.QuadPart );
00885 
00886             <span class="comment">//</span>
00887             <span class="comment">//  Success!</span>
00888             <span class="comment">//</span>
00889 
00890             <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>( Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00891         }
00892 
00893 
00894     try_exit: NOTHING;
00895 
00896         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(Flags, <a class="code" href="../../d4/d2/cache_8h.html#a8">PIN_NO_READ</a>) &amp;&amp;
00897             <a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(Flags, <a class="code" href="../../d4/d2/cache_8h.html#a7">PIN_EXCLUSIVE</a>) &amp;&amp;
00898             (BcbOut != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
00899             (BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o12">BaseAddress</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
00900 
00901             <span class="comment">//</span>
00902             <span class="comment">//  Unmap the Vacb and free the resource if the Bcb is still</span>
00903             <span class="comment">//  dirty.  We have to free the resource before dropping the</span>
00904             <span class="comment">//  spinlock, and we want to hold the resource until the</span>
00905             <span class="comment">//  virtual address is freed.</span>
00906             <span class="comment">//</span>
00907 
00908             <a class="code" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a>( BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o8">Vacb</a> );
00909 
00910             BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o12">BaseAddress</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00911             BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o8">Vacb</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00912         }
00913 
00914     } finally {
00915 
00916         <span class="comment">//</span>
00917         <span class="comment">//  Release the spinlock if it is acquired.</span>
00918         <span class="comment">//</span>
00919 
00920         <span class="keywordflow">if</span> (SpinLockAcquired) {
00921             ExReleaseSpinLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, OldIrql );
00922         }
00923 
00924         <span class="comment">//</span>
00925         <span class="comment">//  If the Vacb was not used for any reason (error or not needed), then free it here.</span>
00926         <span class="comment">//</span>
00927 
00928         <span class="keywordflow">if</span> (Vacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00929             <a class="code" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a>( Vacb );
00930         }
00931 
00932         <span class="comment">//</span>
00933         <span class="comment">//  If we referenced a piece of a multilevel structure, release here.</span>
00934         <span class="comment">//</span>
00935 
00936         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(Flags, <a class="code" href="../../d4/d2/cache_8h.html#a8">PIN_NO_READ</a>)) {
00937 
00938             <a class="code" href="../../d5/d3/vacbsup_8c.html#a18">CcDereferenceFileOffset</a>( SharedCacheMap, *FileOffset );
00939         }
00940 
00941         <span class="keywordflow">if</span> (Result) {
00942 
00943             *Bcb = BcbOut;
00944             *BeyondLastByte = BcbOut-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o5">BeyondLastByte</a>;
00945 
00946         <span class="comment">//</span>
00947         <span class="comment">//  An abnormal termination can occur on an allocation failure,</span>
00948         <span class="comment">//  or on a failure to map and read the buffer.</span>
00949         <span class="comment">//</span>
00950 
00951         } <span class="keywordflow">else</span> {
00952 
00953             *BaseAddress = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00954             <span class="keywordflow">if</span> (BcbOut != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00955                 <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( BcbOut, ReadOnly, <a class="code" href="../../d5/d5/cc_8h.html#a211a171">UNPIN</a> );
00956             }
00957         }
00958 
00959         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    &lt;Bcb = %08lx\n"</span>, *Bcb );
00960         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    &lt;BaseAddress = %08lx\n"</span>, *BaseAddress );
00961         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcPinFileData -&gt; %02lx\n"</span>, Result );
00962     }
00963 
00964     <span class="keywordflow">return</span> Result;
00965 }
00966 
00967 
00968 <span class="comment">//</span>
00969 <span class="comment">//  Internal Support Routine</span>
00970 <span class="comment">//</span>
00971 
00972 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00973 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l00974"></a><a class="code" href="../../d5/d5/cc_8h.html#a176">00974</a> <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a> (
00975     IN OUT <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> Bcb,
00976     IN BOOLEAN ReadOnly,
00977     IN UNMAP_ACTIONS UnmapAction
00978     )
00979 
00980 <span class="comment">/*++</span>
00981 <span class="comment"></span>
00982 <span class="comment">Routine Description:</span>
00983 <span class="comment"></span>
00984 <span class="comment">    This routine umaps and unlocks the specified buffer, which was previously</span>
00985 <span class="comment">    locked and mapped by calling CcPinFileData.</span>
00986 <span class="comment"></span>
00987 <span class="comment">Arguments:</span>
00988 <span class="comment"></span>
00989 <span class="comment">    Bcb - Pointer previously returned from CcPinFileData.  As may be</span>
00990 <span class="comment">          seen above, this pointer may be either a Bcb or a Vacb.</span>
00991 <span class="comment"></span>
00992 <span class="comment">    ReadOnly - must specify same value as when data was mapped</span>
00993 <span class="comment"></span>
00994 <span class="comment">    UnmapAction - UNPIN or SET_CLEAN</span>
00995 <span class="comment"></span>
00996 <span class="comment">Return Value:</span>
00997 <span class="comment"></span>
00998 <span class="comment">    None</span>
00999 <span class="comment"></span>
01000 <span class="comment">--*/</span>
01001 
01002 {
01003     KIRQL OldIrql;
01004     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
01005 
01006     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcUnpinFileData &gt;Bcb = %08lx\n"</span>, Bcb );
01007 
01008     <span class="comment">//</span>
01009     <span class="comment">//  Note, since we have to allocate so many Vacbs, we do not use</span>
01010     <span class="comment">//  a node type code.  However, the Vacb starts with a BaseAddress,</span>
01011     <span class="comment">//  so we assume that the low byte of the Bcb node type code has</span>
01012     <span class="comment">//  some bits set, which a page-aligned Base Address cannot.</span>
01013     <span class="comment">//</span>
01014 
01015     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( (<a class="code" href="../../d5/d5/cc_8h.html#a14">CACHE_NTC_BCB</a> &amp; 0xFF) != 0 );
01016 
01017     <span class="keywordflow">if</span> (Bcb-&gt;NodeTypeCode != <a class="code" href="../../d5/d5/cc_8h.html#a14">CACHE_NTC_BCB</a>) {
01018 
01019         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(((<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a>)Bcb &gt;= <a class="code" href="../../d5/d2/cachedat_8c.html#a20">CcVacbs</a>) &amp;&amp; ((<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a>)Bcb &lt; <a class="code" href="../../d5/d2/cachedat_8c.html#a21">CcBeyondVacbs</a>));
01020         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(((<a class="code" href="../../d5/d5/cc_8h.html#a98">PVACB</a>)Bcb)-&gt;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o0">NodeTypeCode</a> == <a class="code" href="../../d5/d5/cc_8h.html#a12">CACHE_NTC_SHARED_CACHE_MAP</a>);
01021 
01022         <a class="code" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a>( (<a class="code" href="../../d5/d5/cc_8h.html#a98">PVACB</a>)Bcb );
01023 
01024         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcUnpinFileData -&gt; VOID (simple release)\n"</span>, 0 );
01025 
01026         <span class="keywordflow">return</span>;
01027     }
01028 
01029     SharedCacheMap = Bcb-&gt;SharedCacheMap;
01030 
01031     <span class="comment">//</span>
01032     <span class="comment">//  We treat Bcbs as ReadOnly (do not acquire resource) if they</span>
01033     <span class="comment">//  are in sections for which we have not disabled modified writing.</span>
01034     <span class="comment">//</span>
01035 
01036     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a78">MODIFIED_WRITE_DISABLED</a>) ||
01037         UnmapAction == <a class="code" href="../../d5/d5/cc_8h.html#a211a172">UNREF</a>) {
01038         ReadOnly = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01039     }
01040 
01041     <span class="comment">//</span>
01042     <span class="comment">//  Synchronize</span>
01043     <span class="comment">//</span>
01044 
01045     ExAcquireSpinLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, &amp;OldIrql );
01046 
01047     <span class="keywordflow">switch</span> (UnmapAction) {
01048 
01049     <span class="keywordflow">case</span> <a class="code" href="../../d5/d5/cc_8h.html#a211a171">UNPIN</a>:
01050     <span class="keywordflow">case</span> <a class="code" href="../../d5/d5/cc_8h.html#a211a172">UNREF</a>:
01051 
01052         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( Bcb-&gt;PinCount &gt; 0 );
01053 
01054         Bcb-&gt;PinCount -= 1;
01055         <span class="keywordflow">break</span>;
01056 
01057     <span class="keywordflow">case</span> <a class="code" href="../../d5/d5/cc_8h.html#a211a173">SET_CLEAN</a>:
01058 
01059         <span class="keywordflow">if</span> (Bcb-&gt;Dirty) {
01060 
01061             ULONG Pages = Bcb-&gt;ByteLength &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
01062 
01063             <span class="comment">//</span>
01064             <span class="comment">//  Reverse the rest of the actions taken when the Bcb was set dirty.</span>
01065             <span class="comment">//</span>
01066 
01067             Bcb-&gt;Dirty = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01068 
01069             <a class="code" href="../../d5/d5/cc_8h.html#a2">CcAcquireMasterLockAtDpcLevel</a>();
01070 
01071             SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> -= Pages;
01072             <a class="code" href="../../d5/d2/cachedat_8c.html#a36">CcTotalDirtyPages</a> -= Pages;
01073 
01074             <span class="comment">//</span>
01075             <span class="comment">//  Normally we need to reduce CcPagesYetToWrite appropriately.</span>
01076             <span class="comment">//</span>
01077 
01078             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d2/cachedat_8c.html#a32">CcPagesYetToWrite</a> &gt; Pages) {
01079                 <a class="code" href="../../d5/d2/cachedat_8c.html#a32">CcPagesYetToWrite</a> -= Pages;
01080             } <span class="keywordflow">else</span> {
01081                 <a class="code" href="../../d5/d2/cachedat_8c.html#a32">CcPagesYetToWrite</a> = 0;
01082             }
01083 
01084             <span class="comment">//</span>
01085             <span class="comment">//  Remove SharedCacheMap from dirty list if nothing more dirty,</span>
01086             <span class="comment">//  and someone still has the cache map opened.</span>
01087             <span class="comment">//</span>
01088 
01089             <span class="keywordflow">if</span> ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> == 0) &amp;&amp;
01090                 (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o2">OpenCount</a> != 0)) {
01091 
01092                 RemoveEntryList( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
01093                 InsertTailList( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a1">CcCleanSharedCacheMapList</a>,
01094                                 &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
01095             }
01096 
01097             <a class="code" href="../../d5/d5/cc_8h.html#a3">CcReleaseMasterLockFromDpcLevel</a>();
01098         }
01099 
01100         <span class="keywordflow">break</span>;
01101 
01102     <span class="keywordflow">default</span>:
01103         <a class="code" href="../../d5/d5/cc_8h.html#a28">CcBugCheck</a>( UnmapAction, 0, 0 );
01104     }
01105 
01106     <span class="comment">//</span>
01107     <span class="comment">//  If we brought it to 0, then we have to kill it.</span>
01108     <span class="comment">//</span>
01109 
01110     <span class="keywordflow">if</span> (Bcb-&gt;PinCount == 0) {
01111 
01112         <span class="comment">//</span>
01113         <span class="comment">//  If the Bcb is Dirty, we only release the resource and unmap now.</span>
01114         <span class="comment">//</span>
01115 
01116         <span class="keywordflow">if</span> (Bcb-&gt;Dirty) {
01117 
01118             <span class="keywordflow">if</span> (Bcb-&gt;BaseAddress != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01119 
01120                 <span class="comment">//</span>
01121                 <span class="comment">//  Unmap the Vacb and free the resource if the Bcb is still</span>
01122                 <span class="comment">//  dirty.  We have to free the resource before dropping the</span>
01123                 <span class="comment">//  spinlock, and we want to hold the resource until the</span>
01124                 <span class="comment">//  virtual address is freed.</span>
01125                 <span class="comment">//</span>
01126 
01127                 <a class="code" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a>( Bcb-&gt;Vacb );
01128 
01129                 Bcb-&gt;BaseAddress = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01130                 Bcb-&gt;Vacb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01131             }
01132 
01133             <span class="keywordflow">if</span> (!ReadOnly) {
01134                 <a class="code" href="../../d5/d8/ex_8h.html#a66">ExReleaseResource</a>( &amp;Bcb-&gt;Resource );
01135             }
01136 
01137             ExReleaseSpinLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, OldIrql );
01138         }
01139 
01140         <span class="comment">//</span>
01141         <span class="comment">//  Otherwise, we also delete the Bcb.</span>
01142         <span class="comment">//</span>
01143 
01144         <span class="keywordflow">else</span> {
01145 
01146             <span class="comment">//</span>
01147             <span class="comment">//  Since CcCalculateVacbLockCount has to be able to walk</span>
01148             <span class="comment">//  the BcbList with only the VacbSpinLock, we take that one</span>
01149             <span class="comment">//  out to change the list and decrement the level.</span>
01150             <span class="comment">//</span>
01151 
01152             <a class="code" href="../../d5/d5/cc_8h.html#a6">CcAcquireVacbLockAtDpcLevel</a>();
01153             RemoveEntryList( &amp;Bcb-&gt;BcbLinks );
01154 
01155             <span class="comment">//</span>
01156             <span class="comment">//  For large metadata streams we unlock the Vacb level.</span>
01157             <span class="comment">//</span>
01158 
01159             <a class="code" href="../../d5/d5/cc_8h.html#a51">CcUnlockVacbLevel</a>( SharedCacheMap, Bcb-&gt;FileOffset.QuadPart );
01160             <a class="code" href="../../d5/d5/cc_8h.html#a7">CcReleaseVacbLockFromDpcLevel</a>();
01161 
01162             <span class="comment">//</span>
01163             <span class="comment">//  Debug routines used to remove Bcbs from the global list</span>
01164             <span class="comment">//</span>
01165 
01166 <span class="preprocessor">#if LIST_DBG</span>
01167 <span class="preprocessor"></span>
01168             ExAcquireSpinLockAtDpcLevel( &amp;<a class="code" href="../../d5/d5/cc_8h.html#a122">CcBcbSpinLock</a> );
01169 
01170             <span class="keywordflow">if</span> (Bcb-&gt;CcBcbLinks.Flink != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01171 
01172                 RemoveEntryList( &amp;Bcb-&gt;CcBcbLinks );
01173                 CcBcbCount -= 1;
01174             }
01175 
01176             ExReleaseSpinLockFromDpcLevel( &amp;<a class="code" href="../../d5/d5/cc_8h.html#a122">CcBcbSpinLock</a> );
01177 
01178 <span class="preprocessor">#endif</span>
01179 <span class="preprocessor"></span>
01180             <span class="keywordflow">if</span> (Bcb-&gt;BaseAddress != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01181 
01182                 <a class="code" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a>( Bcb-&gt;Vacb );
01183             }
01184 <span class="preprocessor">#if DBG</span>
01185 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (!ReadOnly) {
01186                 <a class="code" href="../../d5/d8/ex_8h.html#a66">ExReleaseResource</a>( &amp;Bcb-&gt;Resource );
01187             }
01188 
01189             <span class="comment">//</span>
01190             <span class="comment">//  ASSERT that the resource is unowned.</span>
01191             <span class="comment">//</span>
01192 
01193             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( Bcb-&gt;Resource.ActiveCount == 0 );
01194 <span class="preprocessor">#endif</span>
01195 <span class="preprocessor"></span>            ExReleaseSpinLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, OldIrql );
01196             <a class="code" href="../../d5/d5/cc_8h.html#a177">CcDeallocateBcb</a>( Bcb );
01197         }
01198     }
01199 
01200     <span class="comment">//</span>
01201     <span class="comment">//  Else we just have to release our Shared access, if we are not</span>
01202     <span class="comment">//  readonly.  We don't need to do this above, since we deallocate</span>
01203     <span class="comment">//  the entire Bcb there.</span>
01204     <span class="comment">//</span>
01205 
01206     <span class="keywordflow">else</span> {
01207 
01208         <span class="keywordflow">if</span> (!ReadOnly) {
01209             <a class="code" href="../../d5/d8/ex_8h.html#a66">ExReleaseResource</a>( &amp;Bcb-&gt;Resource );
01210         }
01211 
01212         ExReleaseSpinLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, OldIrql );
01213     }
01214 
01215     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcUnpinFileData -&gt; VOID\n"</span>, 0 );
01216 
01217     <span class="keywordflow">return</span>;
01218 }
01219 
01220 
01221 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01222"></a><a class="code" href="../../d4/d2/cache_8h.html#a86">01222</a> <a class="code" href="../../d4/d2/cache_8h.html#a86">CcSetReadAheadGranularity</a> (
01223     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
01224     IN ULONG Granularity
01225     )
01226 
01227 <span class="comment">/*++</span>
01228 <span class="comment"></span>
01229 <span class="comment">Routine Description:</span>
01230 <span class="comment"></span>
01231 <span class="comment">    This routine may be called to set the read ahead granularity used by</span>
01232 <span class="comment">    the Cache Manager.  The default is PAGE_SIZE.  The number is decremented</span>
01233 <span class="comment">    and stored as a mask.</span>
01234 <span class="comment"></span>
01235 <span class="comment">Arguments:</span>
01236 <span class="comment"></span>
01237 <span class="comment">    FileObject - File Object for which granularity shall be set</span>
01238 <span class="comment"></span>
01239 <span class="comment">    Granularity - new granularity, which must be an even power of 2 and</span>
01240 <span class="comment">                  &gt;= PAGE_SIZE</span>
01241 <span class="comment"></span>
01242 <span class="comment">Return Value:</span>
01243 <span class="comment"></span>
01244 <span class="comment">    None</span>
01245 <span class="comment">--*/</span>
01246 
01247 {
01248     ((<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html">PPRIVATE_CACHE_MAP</a>)FileObject-&gt;PrivateCacheMap)-&gt;ReadAheadMask = Granularity - 1;
01249 }
01250 
01251 
01252 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01253"></a><a class="code" href="../../d4/d2/cache_8h.html#a84">01253</a> <a class="code" href="../../d4/d2/cache_8h.html#a84">CcScheduleReadAhead</a> (
01254     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
01255     IN PLARGE_INTEGER FileOffset,
01256     IN ULONG Length
01257     )
01258 
01259 <span class="comment">/*++</span>
01260 <span class="comment"></span>
01261 <span class="comment">Routine Description:</span>
01262 <span class="comment"></span>
01263 <span class="comment">    This routine is called by Copy Read and Mdl Read file system routines to</span>
01264 <span class="comment">    perform common Read Ahead processing.  The input parameters describe</span>
01265 <span class="comment">    the current read which has just been completed, or perhaps only started</span>
01266 <span class="comment">    in the case of Mdl Reads.  Based on these parameters, an</span>
01267 <span class="comment">    assessment is made on how much data should be read ahead, and whether</span>
01268 <span class="comment">    that data has already been read ahead.</span>
01269 <span class="comment"></span>
01270 <span class="comment">    The processing is divided into two parts:</span>
01271 <span class="comment"></span>
01272 <span class="comment">        CALCULATE READ AHEAD REQUIREMENTS   (CcScheduleReadAhead)</span>
01273 <span class="comment"></span>
01274 <span class="comment">        PERFORM READ AHEAD                  (CcPerformReadAhead)</span>
01275 <span class="comment"></span>
01276 <span class="comment">    File systems should always call CcReadAhead, which will conditionally</span>
01277 <span class="comment">    call CcScheduleReadAhead (if the read is large enough).  If such a call</span>
01278 <span class="comment">    determines that there is read ahead work to do, and no read ahead is</span>
01279 <span class="comment">    currently active, then it will set ReadAheadActive and schedule read</span>
01280 <span class="comment">    ahead to be peformed by the Lazy Writer, who will call CcPeformReadAhead.</span>
01281 <span class="comment"></span>
01282 <span class="comment">Arguments:</span>
01283 <span class="comment"></span>
01284 <span class="comment">    FileObject - supplies pointer to FileObject on which readahead should be</span>
01285 <span class="comment">                 considered.</span>
01286 <span class="comment"></span>
01287 <span class="comment">    FileOffset - supplies the FileOffset at which the last read just occurred.</span>
01288 <span class="comment"></span>
01289 <span class="comment">    Length - supplies the length of the last read.</span>
01290 <span class="comment"></span>
01291 <span class="comment">Return Value:</span>
01292 <span class="comment"></span>
01293 <span class="comment">    None</span>
01294 <span class="comment">--*/</span>
01295 
01296 {
01297     LARGE_INTEGER NewOffset;
01298     LARGE_INTEGER NewBeyond;
01299     LARGE_INTEGER FileOffset1, FileOffset2;
01300     KIRQL OldIrql;
01301     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
01302     <a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html">PPRIVATE_CACHE_MAP</a> PrivateCacheMap;
01303     <a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html">PWORK_QUEUE_ENTRY</a> WorkQueueEntry;
01304     ULONG ReadAheadSize;
01305     BOOLEAN Changed = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01306 
01307     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcScheduleReadAhead:\n"</span>, 0 );
01308     <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>(0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    FileOffset = %08lx, %08lx\n"</span>, FileOffset-&gt;LowPart,
01309                                                           FileOffset-&gt;HighPart );
01310     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    Length = %08lx\n"</span>, Length );
01311 
01312     SharedCacheMap = *(<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> *)((PCHAR)FileObject-&gt;SectionObjectPointer
01313                                             + <span class="keyword">sizeof</span>(PVOID));
01314     PrivateCacheMap = FileObject-&gt;PrivateCacheMap;
01315 
01316     <span class="keywordflow">if</span> ((PrivateCacheMap == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) ||
01317         (SharedCacheMap == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) ||
01318         <a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a70">DISABLE_READ_AHEAD</a>)) {
01319 
01320         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcScheduleReadAhead -&gt; VOID (Nooped)\n"</span>, 0 );
01321 
01322         <span class="keywordflow">return</span>;
01323     }
01324 
01325     <span class="comment">//</span>
01326     <span class="comment">//  Round boundaries of transfer up to some greater granularity, so that</span>
01327     <span class="comment">//  sequential reads will be recognized even if a few bytes are skipped</span>
01328     <span class="comment">//  between records.</span>
01329     <span class="comment">//</span>
01330 
01331     NewOffset = *FileOffset;
01332     NewBeyond.QuadPart = FileOffset-&gt;QuadPart + (LONGLONG)Length;
01333 
01334     <span class="comment">//</span>
01335     <span class="comment">//  Find the next read ahead boundary beyond the current read.</span>
01336     <span class="comment">//</span>
01337 
01338     ReadAheadSize = (Length + PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o10">ReadAheadMask</a>) &amp; ~PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o10">ReadAheadMask</a>;
01339     FileOffset2.QuadPart = NewBeyond.QuadPart + (LONGLONG)ReadAheadSize;
01340     FileOffset2.LowPart &amp;= ~PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o10">ReadAheadMask</a>;
01341 
01342     <span class="comment">//</span>
01343     <span class="comment">//  CALCULATE READ AHEAD REQUIREMENTS</span>
01344     <span class="comment">//</span>
01345 
01346     <span class="comment">//</span>
01347     <span class="comment">//  Take out the ReadAhead spinlock to synchronize our read ahead decision.</span>
01348     <span class="comment">//</span>
01349 
01350     ExAcquireSpinLock( &amp;PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o9">ReadAheadSpinLock</a>, &amp;OldIrql );
01351 
01352     <span class="comment">//</span>
01353     <span class="comment">//  Read Ahead Case 0.</span>
01354     <span class="comment">//</span>
01355     <span class="comment">//  Sequential-only hint in the file object.  For this case we will</span>
01356     <span class="comment">//  try and always keep two read ahead granularities read ahead from</span>
01357     <span class="comment">//  and including the end of the current transfer.  This case has the</span>
01358     <span class="comment">//  lowest overhead, and the code is completely immune to how the</span>
01359     <span class="comment">//  caller skips around.  Sequential files use ReadAheadOffset[1] in</span>
01360     <span class="comment">//  the PrivateCacheMap as their "high water mark".</span>
01361     <span class="comment">//</span>
01362 
01363     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(FileObject-&gt;Flags, <a class="code" href="../../d0/d5/io_8h.html#a155">FO_SEQUENTIAL_ONLY</a>)) {
01364 
01365         <span class="comment">//</span>
01366         <span class="comment">//  If the next boundary is greater than or equal to the high-water mark,</span>
01367         <span class="comment">//  then read ahead.</span>
01368         <span class="comment">//</span>
01369 
01370         <span class="keywordflow">if</span> (FileOffset2.QuadPart &gt;= PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o7">ReadAheadOffset</a>[1].QuadPart) {
01371 
01372             <span class="comment">//</span>
01373             <span class="comment">//  On the first read if we are using a large read ahead granularity,</span>
01374             <span class="comment">//  and the read did not get it all, we will just get the rest of the</span>
01375             <span class="comment">//  first data we want.</span>
01376             <span class="comment">//</span>
01377 
01378             <span class="keywordflow">if</span> ((FileOffset-&gt;QuadPart == 0)
01379 
01380                     &amp;&amp;
01381 
01382                 (PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o10">ReadAheadMask</a> &gt; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1))
01383 
01384                     &amp;&amp;
01385 
01386                 ((Length + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1) &lt;= PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o10">ReadAheadMask</a>)) {
01387 
01388                 FileOffset1.QuadPart = (LONGLONG)( <a class="code" href="../../d2/d1/mm_8h.html#a4">ROUND_TO_PAGES</a>(Length) );
01389                 PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o8">ReadAheadLength</a>[0] = ReadAheadSize - FileOffset1.LowPart;
01390                 FileOffset2.QuadPart = (LONGLONG)ReadAheadSize;
01391 
01392             <span class="comment">//</span>
01393             <span class="comment">//  Calculate the next read ahead boundary.</span>
01394             <span class="comment">//</span>
01395 
01396             } <span class="keywordflow">else</span> {
01397 
01398                 FileOffset1.QuadPart = PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o7">ReadAheadOffset</a>[1].QuadPart +
01399                                        (LONGLONG)ReadAheadSize;
01400 
01401                 <span class="comment">//</span>
01402                 <span class="comment">//  If the end of the current read is actually beyond where we would</span>
01403                 <span class="comment">//  normally do our read ahead, then we have fallen behind, and we must</span>
01404                 <span class="comment">//  advance to that spot.</span>
01405                 <span class="comment">//</span>
01406 
01407                 <span class="keywordflow">if</span> (FileOffset2.QuadPart &gt; FileOffset1.QuadPart) {
01408                     FileOffset1 = FileOffset2;
01409                 }
01410                 PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o8">ReadAheadLength</a>[0] = ReadAheadSize;
01411                 FileOffset2.QuadPart = FileOffset1.QuadPart + (LONGLONG)ReadAheadSize;
01412             }
01413 
01414             <span class="comment">//</span>
01415             <span class="comment">//  Now issue the next two read aheads.</span>
01416             <span class="comment">//</span>
01417 
01418             PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o7">ReadAheadOffset</a>[0] = FileOffset1;
01419 
01420             PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o7">ReadAheadOffset</a>[1] = FileOffset2;
01421             PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o8">ReadAheadLength</a>[1] = ReadAheadSize;
01422 
01423             Changed = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01424         }
01425 
01426     <span class="comment">//</span>
01427     <span class="comment">//  Read Ahead Case 1.</span>
01428     <span class="comment">//</span>
01429     <span class="comment">//  If this is the third of three sequential reads, then we will see if</span>
01430     <span class="comment">//  we can read ahead.  Note that if the first read to a file is to</span>
01431     <span class="comment">//  offset 0, it passes this test.</span>
01432     <span class="comment">//</span>
01433 
01434     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((NewOffset.HighPart == PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o6">BeyondLastByte2</a>.HighPart)
01435 
01436             &amp;&amp;
01437 
01438         ((NewOffset.LowPart &amp; ~<a class="code" href="../../d5/d5/cc_8h.html#a52">NOISE_BITS</a>)
01439            == (PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o6">BeyondLastByte2</a>.LowPart &amp; ~<a class="code" href="../../d5/d5/cc_8h.html#a52">NOISE_BITS</a>))
01440 
01441             &amp;&amp;
01442 
01443         (PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o5">FileOffset2</a>.HighPart
01444            == PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o4">BeyondLastByte1</a>.HighPart)
01445 
01446             &amp;&amp;
01447 
01448         ((PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o5">FileOffset2</a>.LowPart &amp; ~<a class="code" href="../../d5/d5/cc_8h.html#a52">NOISE_BITS</a>)
01449            == (PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o4">BeyondLastByte1</a>.LowPart &amp; ~<a class="code" href="../../d5/d5/cc_8h.html#a52">NOISE_BITS</a>))) {
01450 
01451         <span class="comment">//</span>
01452         <span class="comment">//  On the first read if we are using a large read ahead granularity,</span>
01453         <span class="comment">//  and the read did not get it all, we will just get the rest of the</span>
01454         <span class="comment">//  first data we want.</span>
01455         <span class="comment">//</span>
01456 
01457         <span class="keywordflow">if</span> ((FileOffset-&gt;QuadPart == 0)
01458 
01459                 &amp;&amp;
01460 
01461             (PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o10">ReadAheadMask</a> &gt; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1))
01462 
01463                 &amp;&amp;
01464 
01465             ((Length + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1) &lt;= PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o10">ReadAheadMask</a>)) {
01466 
01467             FileOffset2.QuadPart = (LONGLONG)( <a class="code" href="../../d2/d1/mm_8h.html#a4">ROUND_TO_PAGES</a>(Length) );
01468         }
01469 
01470         <span class="comment">//</span>
01471         <span class="comment">//  Round read offset to next read ahead boundary.</span>
01472         <span class="comment">//</span>
01473 
01474         <span class="keywordflow">else</span> {
01475             FileOffset2.QuadPart = NewBeyond.QuadPart + (LONGLONG)ReadAheadSize;
01476 
01477             FileOffset2.LowPart &amp;= ~PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o10">ReadAheadMask</a>;
01478         }
01479 
01480         <span class="comment">//</span>
01481         <span class="comment">//  Set read ahead length to be the same as for the most recent read,</span>
01482         <span class="comment">//  up to our max.</span>
01483         <span class="comment">//</span>
01484 
01485         <span class="keywordflow">if</span> (FileOffset2.QuadPart != PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o7">ReadAheadOffset</a>[1].QuadPart) {
01486 
01487             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( FileOffset2.HighPart &gt;= 0 );
01488 
01489             Changed = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01490             PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o7">ReadAheadOffset</a>[1] = FileOffset2;
01491             PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o8">ReadAheadLength</a>[1] = ReadAheadSize;
01492         }
01493     }
01494 
01495     <span class="comment">//</span>
01496     <span class="comment">//  Read Ahead Case 2.</span>
01497     <span class="comment">//</span>
01498     <span class="comment">//  If this is the third read following a particular stride, then we</span>
01499     <span class="comment">//  will see if we can read ahead.  One example of an application that</span>
01500     <span class="comment">//  might do this is a spreadsheet.  Note that this code even works</span>
01501     <span class="comment">//  for negative strides.</span>
01502     <span class="comment">//</span>
01503 
01504     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ( NewOffset.QuadPart -
01505                 PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o5">FileOffset2</a>.QuadPart ) ==
01506               ( PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o5">FileOffset2</a>.QuadPart -
01507                 PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o3">FileOffset1</a>.QuadPart )) {
01508 
01509         <span class="comment">//</span>
01510         <span class="comment">//  According to the current stride, the next offset will be:</span>
01511         <span class="comment">//</span>
01512         <span class="comment">//      NewOffset + (NewOffset - FileOffset2)</span>
01513         <span class="comment">//</span>
01514         <span class="comment">//  which is the same as:</span>
01515         <span class="comment">//</span>
01516         <span class="comment">//      (NewOffset * 2) - FileOffset2</span>
01517         <span class="comment">//</span>
01518 
01519         FileOffset2.QuadPart = ( NewOffset.QuadPart &lt;&lt; 1 ) - PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o5">FileOffset2</a>.QuadPart;
01520 
01521         <span class="comment">//</span>
01522         <span class="comment">//  If our stride is going backwards through the file, we</span>
01523         <span class="comment">//  have to detect the case where the next step would wrap.</span>
01524         <span class="comment">//</span>
01525 
01526         <span class="keywordflow">if</span> (FileOffset2.HighPart &gt;= 0) {
01527 
01528             <span class="comment">//</span>
01529             <span class="comment">//  The read ahead length must be extended by the same amount that</span>
01530             <span class="comment">//  we will round the PrivateCacheMap-&gt;ReadAheadOffset down.</span>
01531             <span class="comment">//</span>
01532 
01533             Length += FileOffset2.LowPart &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1);
01534 
01535             <span class="comment">//</span>
01536             <span class="comment">//  Now round the PrivateCacheMap-&gt;ReadAheadOffset down.</span>
01537             <span class="comment">//</span>
01538 
01539             FileOffset2.LowPart &amp;= ~(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1);
01540             PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o7">ReadAheadOffset</a>[1] = FileOffset2;
01541 
01542             <span class="comment">//</span>
01543             <span class="comment">//  Round to page boundary.</span>
01544             <span class="comment">//</span>
01545 
01546             PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o8">ReadAheadLength</a>[1] = (ULONG) <a class="code" href="../../d2/d1/mm_8h.html#a4">ROUND_TO_PAGES</a>(Length);
01547             Changed = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01548         }
01549     }
01550 
01551     <span class="comment">//</span>
01552     <span class="comment">//  Get out if the ReadAhead requirements did not change.</span>
01553     <span class="comment">//</span>
01554 
01555     <span class="keywordflow">if</span> (!Changed || PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o12">ReadAheadActive</a>) {
01556 
01557         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"Read ahead already in progress or no change\n"</span>, 0 );
01558 
01559         ExReleaseSpinLock( &amp;PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o9">ReadAheadSpinLock</a>, OldIrql );
01560         <span class="keywordflow">return</span>;
01561     }
01562 
01563     <span class="comment">//</span>
01564     <span class="comment">//  Otherwise, we will proceed and try to schedule the read ahead</span>
01565     <span class="comment">//  ourselves.</span>
01566     <span class="comment">//</span>
01567 
01568     PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o12">ReadAheadActive</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01569 
01570     <span class="comment">//</span>
01571     <span class="comment">//  Release spin lock on way out</span>
01572     <span class="comment">//</span>
01573 
01574     ExReleaseSpinLock( &amp;PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o9">ReadAheadSpinLock</a>, OldIrql );
01575 
01576     <span class="comment">//</span>
01577     <span class="comment">//  Queue the read ahead request to the Lazy Writer's work queue.</span>
01578     <span class="comment">//</span>
01579 
01580     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"Queueing read ahead to worker thread\n"</span>, 0 );
01581 
01582     WorkQueueEntry = <a class="code" href="../../d5/d5/cc_8h.html#a88">CcAllocateWorkQueueEntry</a>();
01583 
01584     <span class="comment">//</span>
01585     <span class="comment">//  If we failed to allocate a work queue entry, then, we will</span>
01586     <span class="comment">//  quietly bag it.  Read ahead is only an optimization, and</span>
01587     <span class="comment">//  no one ever requires that it occur.</span>
01588     <span class="comment">//</span>
01589 
01590     <span class="keywordflow">if</span> (WorkQueueEntry != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01591 
01592         <span class="comment">//</span>
01593         <span class="comment">//  We must reference this file object so that it cannot go away</span>
01594         <span class="comment">//  until we finish Read Ahead processing in the Worker Thread.</span>
01595         <span class="comment">//</span>
01596 
01597         <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a> ( FileObject );
01598 
01599         <span class="comment">//</span>
01600         <span class="comment">//  Increment open count to make sure the SharedCacheMap stays around.</span>
01601         <span class="comment">//</span>
01602 
01603         <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
01604         <a class="code" href="../../d5/d5/cc_8h.html#a68">CcIncrementOpenCount</a>( SharedCacheMap, 'adRQ' );
01605         <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
01606 
01607         WorkQueueEntry-&gt;<a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html#o8">Function</a> = (UCHAR)<a class="code" href="../../d5/d5/cc_8h.html#a210a167">ReadAhead</a>;
01608         WorkQueueEntry-&gt;<a class="code" href="../../d2/d9/struct__WORK__QUEUE__ENTRY.html#o7">Parameters</a>.Read.FileObject = FileObject;
01609 
01610         <a class="code" href="../../d5/d1/lazyrite_8c.html#a8">CcPostWorkQueue</a>( WorkQueueEntry, &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a8">CcExpressWorkQueue</a> );
01611     }
01612 
01613     <span class="comment">//</span>
01614     <span class="comment">//  If we failed to allocate a Work Queue Entry, or all of the pages</span>
01615     <span class="comment">//  are resident we must set the active flag false.</span>
01616     <span class="comment">//</span>
01617 
01618     <span class="keywordflow">else</span> {
01619 
01620         ExAcquireFastLock( &amp;PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o9">ReadAheadSpinLock</a>, &amp;OldIrql );
01621         PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o12">ReadAheadActive</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01622         ExReleaseFastLock( &amp;PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o9">ReadAheadSpinLock</a>, OldIrql );
01623     }
01624 
01625     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcScheduleReadAhead -&gt; VOID\n"</span>, 0 );
01626 
01627     <span class="keywordflow">return</span>;
01628 }
01629 
01630 
01631 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01632 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l01633"></a><a class="code" href="../../d5/d5/cc_8h.html#a178">01633</a> <a class="code" href="../../d5/d5/cc_8h.html#a178">CcPerformReadAhead</a> (
01634     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject
01635     )
01636 
01637 <span class="comment">/*++</span>
01638 <span class="comment"></span>
01639 <span class="comment">Routine Description:</span>
01640 <span class="comment"></span>
01641 <span class="comment">    This routine is called by the Lazy Writer to perform read ahead which</span>
01642 <span class="comment">    has been scheduled for this file by CcScheduleReadAhead.</span>
01643 <span class="comment"></span>
01644 <span class="comment">Arguments:</span>
01645 <span class="comment"></span>
01646 <span class="comment">    FileObject - supplies pointer to FileObject on which readahead should be</span>
01647 <span class="comment">                 considered.</span>
01648 <span class="comment"></span>
01649 <span class="comment">Return Value:</span>
01650 <span class="comment"></span>
01651 <span class="comment">    None</span>
01652 <span class="comment">--*/</span>
01653 
01654 {
01655     KIRQL OldIrql;
01656     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
01657     <a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html">PPRIVATE_CACHE_MAP</a> PrivateCacheMap;
01658     ULONG i;
01659     LARGE_INTEGER ReadAheadOffset[2];
01660     ULONG ReadAheadLength[2];
01661     <a class="code" href="../../d3/d6/struct__CACHE__MANAGER__CALLBACKS.html">PCACHE_MANAGER_CALLBACKS</a> Callbacks;
01662     PVOID Context;
01663     ULONG SavedState;
01664     BOOLEAN Done;
01665     BOOLEAN HitEof = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01666     BOOLEAN ReadAheadPerformed = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01667     ULONG FaultOccurred = 0;
01668     <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a> Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
01669     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> Vacb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01670 
01671     BOOLEAN ResourceHeld = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01672 
01673     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcPerformReadAhead:\n"</span>, 0 );
01674     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    FileObject = %08lx\n"</span>, FileObject );
01675 
01676     <a class="code" href="../../d2/d1/mm_8h.html#a19">MmSavePageFaultReadAhead</a>( Thread, &amp;SavedState );
01677 
01678     <span class="keywordflow">try</span> {
01679 
01680         <span class="comment">//</span>
01681         <span class="comment">//  Since we have the open count biased, we can safely access the</span>
01682         <span class="comment">//  SharedCacheMap.</span>
01683         <span class="comment">//</span>
01684 
01685         SharedCacheMap = FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap;
01686 
01687         Callbacks = SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o27">Callbacks</a>;
01688         Context = SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o28">LazyWriteContext</a>;
01689 
01690         <span class="comment">//</span>
01691         <span class="comment">//  After the first time, keep looping as long as there are new</span>
01692         <span class="comment">//  read ahead requirements.  (We will skip out below.)</span>
01693         <span class="comment">//</span>
01694 
01695         <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01696 
01697             <span class="comment">//</span>
01698             <span class="comment">//  Get SharedCacheMap and PrivateCacheMap.  If either are now NULL, get</span>
01699             <span class="comment">//  out.</span>
01700             <span class="comment">//</span>
01701 
01702             <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
01703 
01704             PrivateCacheMap = FileObject-&gt;PrivateCacheMap;
01705 
01706             <span class="comment">//</span>
01707             <span class="comment">//  Now capture the information that we need, so that we can drop the</span>
01708             <span class="comment">//  SharedList Resource.  This information is advisory only anyway, and</span>
01709             <span class="comment">//  the caller must guarantee that the FileObject is referenced.</span>
01710             <span class="comment">//</span>
01711 
01712             <span class="keywordflow">if</span> (PrivateCacheMap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01713 
01714                 ExAcquireSpinLockAtDpcLevel( &amp;PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o9">ReadAheadSpinLock</a> );
01715 
01716                 <span class="comment">//</span>
01717                 <span class="comment">//  We are done when the lengths are 0</span>
01718                 <span class="comment">//</span>
01719 
01720                 Done = ((PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o8">ReadAheadLength</a>[0] |
01721                          PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o8">ReadAheadLength</a>[1]) == 0);
01722 
01723                 ReadAheadOffset[0] = PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o7">ReadAheadOffset</a>[0];
01724                 ReadAheadOffset[1] = PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o7">ReadAheadOffset</a>[1];
01725                 ReadAheadLength[0] = PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o8">ReadAheadLength</a>[0];
01726                 ReadAheadLength[1] = PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o8">ReadAheadLength</a>[1];
01727                 PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o8">ReadAheadLength</a>[0] = 0;
01728                 PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o8">ReadAheadLength</a>[1] = 0;
01729 
01730                 ExReleaseSpinLockFromDpcLevel( &amp;PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o9">ReadAheadSpinLock</a> );
01731             }
01732 
01733             <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
01734 
01735             <span class="comment">//</span>
01736             <span class="comment">//  Acquire the file shared.</span>
01737             <span class="comment">//</span>
01738 
01739             (*Callbacks-&gt;<a class="code" href="../../d3/d6/struct__CACHE__MANAGER__CALLBACKS.html#o2">AcquireForReadAhead</a>)( Context, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
01740             ResourceHeld = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01741 
01742             <span class="keywordflow">if</span> ((PrivateCacheMap == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) || Done) {
01743 
01744                 <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>( NOTHING );
01745             }
01746 
01747             <span class="comment">//</span>
01748             <span class="comment">//  PERFORM READ AHEAD</span>
01749             <span class="comment">//</span>
01750             <span class="comment">//</span>
01751             <span class="comment">//  Now loop until everything is read in.  The Read ahead is accomplished</span>
01752             <span class="comment">//  by touching the pages with an appropriate ReadAhead parameter in MM.</span>
01753             <span class="comment">//</span>
01754 
01755             i = 0;
01756 
01757             <span class="keywordflow">do</span> {
01758 
01759                 LARGE_INTEGER <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>, SavedOffset;
01760                 ULONG Length, SavedLength;
01761 
01762                 <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> = ReadAheadOffset[i];
01763                 Length = ReadAheadLength[i];
01764                 SavedOffset = <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
01765                 SavedLength = Length;
01766 
01767                 <span class="keywordflow">if</span> ((Length != 0)
01768 
01769                         &amp;&amp;
01770 
01771                     ( <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.QuadPart &lt;= SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o3">FileSize</a>.QuadPart )) {
01772 
01773                     ReadAheadPerformed = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01774 
01775                     <span class="comment">//</span>
01776                     <span class="comment">//  Keep length within file and MAX_READ_AHEAD</span>
01777                     <span class="comment">//</span>
01778 
01779                     <span class="keywordflow">if</span> ( ( <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.QuadPart + (LONGLONG)Length ) &gt;= SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o3">FileSize</a>.QuadPart ) {
01780 
01781                         Length = (ULONG)( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o3">FileSize</a>.QuadPart - <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.QuadPart );
01782                         HitEof = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01783 
01784                     }
01785                     <span class="keywordflow">if</span> (Length &gt; <a class="code" href="../../d5/d5/cc_8h.html#a32">MAX_READ_AHEAD</a>) {
01786                         Length = <a class="code" href="../../d5/d5/cc_8h.html#a32">MAX_READ_AHEAD</a>;
01787                     }
01788 
01789                     <span class="comment">//</span>
01790                     <span class="comment">//  Now loop to read all of the desired data in.  This loop</span>
01791                     <span class="comment">//  is more or less like the same loop to read data in</span>
01792                     <span class="comment">//  CcCopyRead, except that we do not copy anything, just</span>
01793                     <span class="comment">//  unmap as soon as it is in.</span>
01794                     <span class="comment">//</span>
01795 
01796                     <span class="keywordflow">while</span> (Length != 0) {
01797 
01798                         ULONG ReceivedLength;
01799                         PVOID CacheBuffer;
01800                         ULONG PagesToGo;
01801 
01802                         <span class="comment">//</span>
01803                         <span class="comment">//  Call local routine to Map or Access the file data.</span>
01804                         <span class="comment">//  If we cannot map the data because of a Wait condition,</span>
01805                         <span class="comment">//  return FALSE.</span>
01806                         <span class="comment">//</span>
01807                         <span class="comment">//  Since this routine is intended to be called from</span>
01808                         <span class="comment">//  the finally handler from file system read modules,</span>
01809                         <span class="comment">//  it is imperative that it not raise any exceptions.</span>
01810                         <span class="comment">//  Therefore, if any expected exception is raised, we</span>
01811                         <span class="comment">//  will simply get out.</span>
01812                         <span class="comment">//</span>
01813 
01814                         CacheBuffer = <a class="code" href="../../d5/d3/vacbsup_8c.html#a15">CcGetVirtualAddress</a>( SharedCacheMap,
01815                                                            <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>,
01816                                                            &amp;Vacb,
01817                                                            &amp;ReceivedLength );
01818 
01819                         <span class="comment">//</span>
01820                         <span class="comment">//  If we got more than we need, make sure to only transfer</span>
01821                         <span class="comment">//  the right amount.</span>
01822                         <span class="comment">//</span>
01823 
01824                         <span class="keywordflow">if</span> (ReceivedLength &gt; Length) {
01825                             ReceivedLength = Length;
01826                         }
01827 
01828                         <span class="comment">//</span>
01829                         <span class="comment">//  Now loop to touch all of the pages, calling MM to insure</span>
01830                         <span class="comment">//  that if we fault, we take in exactly the number of pages</span>
01831                         <span class="comment">//  we need.</span>
01832                         <span class="comment">//</span>
01833 
01834                         PagesToGo = <a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a>( CacheBuffer,
01835                                                            ReceivedLength );
01836 
01837                         <a class="code" href="../../d5/d2/cachedat_8c.html#a75">CcMissCounter</a> = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a69">CcReadAheadIos</a>;
01838 
01839                         <span class="keywordflow">while</span> (PagesToGo) {
01840 
01841                             <a class="code" href="../../d2/d1/mm_8h.html#a20">MmSetPageFaultReadAhead</a>( Thread, (PagesToGo - 1) );
01842                             FaultOccurred |= !<a class="code" href="../../d1/d5/mapcache_8c.html#a13">MmCheckCachedPageState</a>(CacheBuffer, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
01843 
01844                             CacheBuffer = (PCHAR)CacheBuffer + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
01845                             PagesToGo -= 1;
01846                         }
01847                         <a class="code" href="../../d5/d2/cachedat_8c.html#a75">CcMissCounter</a> = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a43">CcThrowAway</a>;
01848 
01849                         <span class="comment">//</span>
01850                         <span class="comment">//  Calculate how much data we have left to go.</span>
01851                         <span class="comment">//</span>
01852 
01853                         Length -= ReceivedLength;
01854 
01855                         <span class="comment">//</span>
01856                         <span class="comment">//  Assume we did not get all the data we wanted, and set</span>
01857                         <span class="comment">//  Offset to the end of the returned data.</span>
01858                         <span class="comment">//</span>
01859 
01860                         <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.QuadPart = <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.QuadPart + (LONGLONG)ReceivedLength;
01861 
01862                         <span class="comment">//</span>
01863                         <span class="comment">//  It was only a page, so we can just leave this loop</span>
01864                         <span class="comment">//  After freeing the address.</span>
01865                         <span class="comment">//</span>
01866 
01867                         <a class="code" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a>( Vacb );
01868                         Vacb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01869                     }
01870                 }
01871                 i += 1;
01872             } <span class="keywordflow">while</span> (i &lt;= 1);
01873 
01874             <span class="comment">//</span>
01875             <span class="comment">//  Release the file</span>
01876             <span class="comment">//</span>
01877 
01878             (*Callbacks-&gt;<a class="code" href="../../d3/d6/struct__CACHE__MANAGER__CALLBACKS.html#o3">ReleaseFromReadAhead</a>)( Context );
01879             ResourceHeld = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01880         }
01881 
01882     try_exit: NOTHING;
01883     }
01884     finally {
01885 
01886         <a class="code" href="../../d2/d1/mm_8h.html#a21">MmResetPageFaultReadAhead</a>(Thread, SavedState);
01887         <a class="code" href="../../d5/d2/cachedat_8c.html#a75">CcMissCounter</a> = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a43">CcThrowAway</a>;
01888 
01889         <span class="comment">//</span>
01890         <span class="comment">//  If we got an error faulting a single page in, release the Vacb</span>
01891         <span class="comment">//  here.  It is important to free any mapping before dropping the</span>
01892         <span class="comment">//  resource to prevent purge problems.</span>
01893         <span class="comment">//</span>
01894 
01895         <span class="keywordflow">if</span> (Vacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01896             <a class="code" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a>( Vacb );
01897         }
01898 
01899         <span class="comment">//</span>
01900         <span class="comment">//  Release the file</span>
01901         <span class="comment">//</span>
01902 
01903         <span class="keywordflow">if</span> (ResourceHeld) {
01904             (*Callbacks-&gt;<a class="code" href="../../d3/d6/struct__CACHE__MANAGER__CALLBACKS.html#o3">ReleaseFromReadAhead</a>)( Context );
01905         }
01906 
01907         <span class="comment">//</span>
01908         <span class="comment">//  To show we are done, we must make sure the PrivateCacheMap is</span>
01909         <span class="comment">//  still there.</span>
01910         <span class="comment">//</span>
01911 
01912         <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
01913 
01914         PrivateCacheMap = FileObject-&gt;PrivateCacheMap;
01915 
01916         <span class="comment">//</span>
01917         <span class="comment">//  Show readahead is going inactive.</span>
01918         <span class="comment">//</span>
01919 
01920         <span class="keywordflow">if</span> (PrivateCacheMap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01921 
01922             ExAcquireSpinLockAtDpcLevel( &amp;PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o9">ReadAheadSpinLock</a> );
01923             PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o12">ReadAheadActive</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01924 
01925             <span class="comment">//</span>
01926             <span class="comment">//  If he said sequential only and we smashed into Eof, then</span>
01927             <span class="comment">//  let's reset the highwater mark in case he wants to read the</span>
01928             <span class="comment">//  file sequentially again.</span>
01929             <span class="comment">//</span>
01930 
01931             <span class="keywordflow">if</span> (HitEof &amp;&amp; <a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(FileObject-&gt;Flags, <a class="code" href="../../d0/d5/io_8h.html#a155">FO_SEQUENTIAL_ONLY</a>)) {
01932                 PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o7">ReadAheadOffset</a>[1].LowPart =
01933                 PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o7">ReadAheadOffset</a>[1].HighPart = 0;
01934             }
01935 
01936             <span class="comment">//</span>
01937             <span class="comment">//  If no faults occurred, turn read ahead off.</span>
01938             <span class="comment">//</span>
01939 
01940             <span class="keywordflow">if</span> (ReadAheadPerformed &amp;&amp; !FaultOccurred) {
01941                 PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o13">ReadAheadEnabled</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01942             }
01943 
01944             ExReleaseSpinLockFromDpcLevel( &amp;PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o9">ReadAheadSpinLock</a> );
01945         }
01946 
01947         <span class="comment">//</span>
01948         <span class="comment">//  Free SharedCacheMap list</span>
01949         <span class="comment">//</span>
01950 
01951         <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
01952 
01953         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( FileObject );
01954 
01955         <span class="comment">//</span>
01956         <span class="comment">//  Serialize again to decrement the open count.</span>
01957         <span class="comment">//</span>
01958 
01959         <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
01960 
01961         <a class="code" href="../../d5/d5/cc_8h.html#a69">CcDecrementOpenCount</a>( SharedCacheMap, 'adRP' );
01962 
01963         <span class="keywordflow">if</span> ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o2">OpenCount</a> == 0) &amp;&amp;
01964             !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a74">WRITE_QUEUED</a>) &amp;&amp;
01965             (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> == 0)) {
01966 
01967             <span class="comment">//</span>
01968             <span class="comment">//  Move to the dirty list.</span>
01969             <span class="comment">//</span>
01970 
01971             RemoveEntryList( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
01972             InsertTailList( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a2">CcDirtySharedCacheMapList</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a>,
01973                             &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
01974 
01975             <span class="comment">//</span>
01976             <span class="comment">//  Make sure the Lazy Writer will wake up, because we</span>
01977             <span class="comment">//  want him to delete this SharedCacheMap.</span>
01978             <span class="comment">//</span>
01979 
01980             <a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o6">OtherWork</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01981             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o5">ScanActive</a>) {
01982                 <a class="code" href="../../d5/d5/cc_8h.html#a185">CcScheduleLazyWriteScan</a>();
01983             }
01984         }
01985 
01986         <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
01987     }
01988 
01989     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcPerformReadAhead -&gt; VOID\n"</span>, 0 );
01990 
01991     <span class="keywordflow">return</span>;
01992 }
01993 
01994 
01995 <a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html">PBITMAP_RANGE</a>
<a name="l01996"></a><a class="code" href="../../d6/d2/cachesub_8c.html#a9">01996</a> <a class="code" href="../../d6/d2/cachesub_8c.html#a9">CcFindBitmapRangeToDirty</a> (
01997     IN <a class="code" href="../../d9/d6/struct__MBCB.html">PMBCB</a> Mbcb,
01998     IN LONGLONG Page,
01999     IN PULONG *FreePageForSetting
02000     )
02001 
02002 <span class="comment">/*++</span>
02003 <span class="comment"></span>
02004 <span class="comment">Routine Description:</span>
02005 <span class="comment"></span>
02006 <span class="comment">    This routine looks for the bitmap range containing the specified page.</span>
02007 <span class="comment">    If it is found it is returned so the caller can set some dirty bits.</span>
02008 <span class="comment">    If it is not found, then an attempt is made to come up with a free range</span>
02009 <span class="comment">    and set it up to describe the desired range.  To come up with a free range,</span>
02010 <span class="comment">    first we attempt to recycle the lowest range that does not currently contain</span>
02011 <span class="comment">    any dirty pages.  If there is no such range, then we allocate one.</span>
02012 <span class="comment"></span>
02013 <span class="comment">Arguments:</span>
02014 <span class="comment"></span>
02015 <span class="comment">    Mbcb - Supplies the Mbcb in which to find the range.</span>
02016 <span class="comment"></span>
02017 <span class="comment">    Page - Supplies the page number for the first page to be set dirty.</span>
02018 <span class="comment"></span>
02019 <span class="comment">    FreePageForSetting - Supplies a free bitmap page of zeros from the zone; the</span>
02020 <span class="comment">                         caller's pointer is cleared on return if this page is used.</span>
02021 <span class="comment"></span>
02022 <span class="comment">Return Value:</span>
02023 <span class="comment"></span>
02024 <span class="comment">    The desired bitmap range, or NULL if one could not be allocated.</span>
02025 <span class="comment"></span>
02026 <span class="comment">Environment:</span>
02027 <span class="comment"></span>
02028 <span class="comment">    The BcbSpinLock must be held on entry.</span>
02029 <span class="comment"></span>
02030 <span class="comment">--*/</span>
02031 
02032 {
02033     <a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html">PBITMAP_RANGE</a> BitmapRange, FreeRange;
02034     PLIST_ENTRY InsertPoint;
02035     LONGLONG BasePage;
02036 
02037     <span class="comment">//</span>
02038     <span class="comment">//  Initialize FreeRange and InsertPoint for the case we have</span>
02039     <span class="comment">//  to initialize a range.</span>
02040     <span class="comment">//</span>
02041 
02042     FreeRange = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02043     InsertPoint = &amp;Mbcb-&gt;BitmapRanges;
02044 
02045     <span class="comment">//</span>
02046     <span class="comment">//  Point to the first bitmap range.</span>
02047     <span class="comment">//</span>
02048 
02049     BitmapRange = (<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html">PBITMAP_RANGE</a>)InsertPoint-&gt;Flink;
02050 
02051     <span class="comment">//</span>
02052     <span class="comment">//  Calculate the desired BasePage from the caller's page.</span>
02053     <span class="comment">//</span>
02054 
02055     BasePage = (Page &amp; ~(LONGLONG)((<a class="code" href="../../d5/d5/cc_8h.html#a43">MBCB_BITMAP_BLOCK_SIZE</a> * 8) - 1));
02056 
02057     <span class="comment">//</span>
02058     <span class="comment">//  Loop through the list until we find the range or we have a free range</span>
02059     <span class="comment">//  and correct insertion point.</span>
02060     <span class="comment">//</span>
02061 
02062     <span class="keywordflow">do</span> {
02063 
02064         <span class="comment">//</span>
02065         <span class="comment">//  If we get an exact match, then we must have hit a fully-initialized</span>
02066         <span class="comment">//  range which we can return.</span>
02067         <span class="comment">//</span>
02068 
02069         <span class="keywordflow">if</span> (BasePage == BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o1">BasePage</a>) {
02070             <span class="keywordflow">return</span> BitmapRange;
02071 
02072         <span class="comment">//</span>
02073         <span class="comment">//  Otherwise, see if the range is free and we have not captured a</span>
02074         <span class="comment">//  free range yet.</span>
02075         <span class="comment">//</span>
02076 
02077         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o4">DirtyPages</a> == 0) &amp;&amp; (FreeRange == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
02078             FreeRange = BitmapRange;
02079 
02080         <span class="comment">//</span>
02081         <span class="comment">//  If we did not capture a free range, see if we need to update our</span>
02082         <span class="comment">//  insertion point.</span>
02083         <span class="comment">//</span>
02084 
02085         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (BasePage &gt; BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o1">BasePage</a>) {
02086             InsertPoint = &amp;BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o0">Links</a>;
02087         }
02088 
02089         <span class="comment">//</span>
02090         <span class="comment">//  Advance to the next range (or possibly back to the listhead).</span>
02091         <span class="comment">//</span>
02092 
02093         BitmapRange = (<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html">PBITMAP_RANGE</a>)BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o0">Links</a>.Flink;
02094 
02095     <span class="comment">//</span>
02096     <span class="comment">//  Loop until we hit the end, or we know we are done updating both InsertPoint</span>
02097     <span class="comment">//  and FreeRange.</span>
02098     <span class="comment">//</span>
02099 
02100     } <span class="keywordflow">while</span> ((BitmapRange != (<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html">PBITMAP_RANGE</a>)&amp;Mbcb-&gt;BitmapRanges) &amp;&amp;
02101              ((BasePage &gt;= BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o1">BasePage</a>) ||
02102               (FreeRange == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)));
02103 
02104     <span class="comment">//</span>
02105     <span class="comment">//  If we found a FreeRange we can use, then remove it from the list.</span>
02106     <span class="comment">//</span>
02107 
02108     <span class="keywordflow">if</span> (FreeRange != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02109         RemoveEntryList( &amp;FreeRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o0">Links</a> );
02110 
02111     <span class="comment">//</span>
02112     <span class="comment">//  Otherwise we have to allocate the small bitmap range structure.  We usually</span>
02113     <span class="comment">//  try to avoid calling the pool package while owning a spin lock, but note the</span>
02114     <span class="comment">//  following things which must be true if we hit this point:</span>
02115     <span class="comment">//</span>
02116     <span class="comment">//      The file is larger than 3 bitmap ranges (normally 384MB on Intel).</span>
02117     <span class="comment">//      Three ranges plus all previously allocated ranges are simultaneously dirty.</span>
02118     <span class="comment">//</span>
02119     <span class="comment">//  The second point is fairly unlikely, especially for a sequential writer.  It</span>
02120     <span class="comment">//  can occur for a random writer in a large file, but eventually we will allocate</span>
02121     <span class="comment">//  enough ranges to always describe how many ranges he can keep dirty at once!</span>
02122     <span class="comment">//</span>
02123 
02124     } <span class="keywordflow">else</span> {
02125         FreeRange = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, <span class="keyword">sizeof</span>(<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html">BITMAP_RANGE</a>), 'rBcC' );
02126         <span class="keywordflow">if</span> (FreeRange == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02127             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02128         }
02129         RtlZeroMemory( FreeRange, <span class="keyword">sizeof</span>(<a class="code" href="../../d5/d5/cc_8h.html#a105">BITMAP_RANGE</a>) );
02130     }
02131 
02132     <span class="comment">//</span>
02133     <span class="comment">//  Insert and initialize.</span>
02134     <span class="comment">//</span>
02135 
02136     InsertHeadList( InsertPoint, &amp;FreeRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o0">Links</a> );
02137     FreeRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o1">BasePage</a> = BasePage;
02138     FreeRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o2">FirstDirtyPage</a> = MAXULONG;
02139     FreeRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o3">LastDirtyPage</a> = 0;
02140 
02141     <span class="comment">//</span>
02142     <span class="comment">//  If the range does not have a bitmap yet, then consume the one we were passed</span>
02143     <span class="comment">//  in.</span>
02144     <span class="comment">//</span>
02145 
02146     <span class="keywordflow">if</span> (FreeRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o5">Bitmap</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02147         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(*FreePageForSetting != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
02148         FreeRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o5">Bitmap</a> = *FreePageForSetting;
02149         *FreePageForSetting = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02150     }
02151 
02152     <span class="keywordflow">return</span> FreeRange;
02153 }
02154 
02155 
02156 <a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html">PBITMAP_RANGE</a>
<a name="l02157"></a><a class="code" href="../../d6/d2/cachesub_8c.html#a10">02157</a> <a class="code" href="../../d6/d2/cachesub_8c.html#a10">CcFindBitmapRangeToClean</a> (
02158     IN <a class="code" href="../../d9/d6/struct__MBCB.html">PMBCB</a> Mbcb,
02159     IN LONGLONG Page
02160     )
02161 
02162 <span class="comment">/*++</span>
02163 <span class="comment"></span>
02164 <span class="comment">Routine Description:</span>
02165 <span class="comment"></span>
02166 <span class="comment">    This routine starts from the specified page, and looks for a range with dirty</span>
02167 <span class="comment">    pages.  The caller must guarantee that some range exists with dirty pages.  If</span>
02168 <span class="comment">    the end of the ranges is hit before finding any dirty ranges, then this routine</span>
02169 <span class="comment">    loops back to the start of the range list.</span>
02170 <span class="comment"></span>
02171 <span class="comment">Arguments:</span>
02172 <span class="comment"></span>
02173 <span class="comment">    Mbcb - Supplies the Mbcb in which to find the range.</span>
02174 <span class="comment"></span>
02175 <span class="comment">    Page - Supplies the page number for the first page to scan from.</span>
02176 <span class="comment"></span>
02177 <span class="comment">Return Value:</span>
02178 <span class="comment"></span>
02179 <span class="comment">    The desired bitmap range with dirty pages.</span>
02180 <span class="comment"></span>
02181 <span class="comment">Environment:</span>
02182 <span class="comment"></span>
02183 <span class="comment">    The BcbSpinLock must be held on entry.</span>
02184 <span class="comment"></span>
02185 <span class="comment">--*/</span>
02186 
02187 {
02188     <a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html">PBITMAP_RANGE</a> BitmapRange;
02189 
02190     <span class="comment">//</span>
02191     <span class="comment">//  Point to the first bitmap range.</span>
02192     <span class="comment">//</span>
02193 
02194     BitmapRange = (<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html">PBITMAP_RANGE</a>)Mbcb-&gt;BitmapRanges.Flink;
02195 
02196     <span class="comment">//</span>
02197     <span class="comment">//  Loop through the list until we find the range to return.</span>
02198     <span class="comment">//</span>
02199 
02200     <span class="keywordflow">do</span> {
02201 
02202         <span class="comment">//</span>
02203         <span class="comment">//  If we hit the listhead, then wrap to find the first dirty range.</span>
02204         <span class="comment">//</span>
02205 
02206         <span class="keywordflow">if</span> (BitmapRange == (<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html">PBITMAP_RANGE</a>)&amp;Mbcb-&gt;BitmapRanges) {
02207 
02208             <span class="comment">//</span>
02209             <span class="comment">//  If Page is already 0, we are in an infinite loop.</span>
02210             <span class="comment">//</span>
02211 
02212             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Page != 0);
02213 
02214             <span class="comment">//</span>
02215             <span class="comment">//  Clear Page and fall through to advance to first range.</span>
02216             <span class="comment">//</span>
02217 
02218             Page = 0;
02219 
02220 
02221         <span class="comment">//</span>
02222         <span class="comment">//  Otherwise, if we are in range, return the first range</span>
02223         <span class="comment">//  with dirty pages.</span>
02224         <span class="comment">//</span>
02225 
02226         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Page &lt;= (BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o1">BasePage</a> + BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o3">LastDirtyPage</a>)) &amp;&amp;
02227             (BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o4">DirtyPages</a> != 0)) {
02228             <span class="keywordflow">return</span> BitmapRange;
02229         }
02230 
02231         <span class="comment">//</span>
02232         <span class="comment">//  Advance to the next range (or possibly back to the listhead).</span>
02233         <span class="comment">//</span>
02234 
02235         BitmapRange = (<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html">PBITMAP_RANGE</a>)BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o0">Links</a>.Flink;
02236 
02237     } <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
02238 }
02239 
02240 
02241 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02242"></a><a class="code" href="../../d5/d5/cc_8h.html#a179">02242</a> <a class="code" href="../../d5/d5/cc_8h.html#a179">CcSetDirtyInMask</a> (
02243     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap,
02244     IN PLARGE_INTEGER FileOffset,
02245     IN ULONG Length
02246     )
02247 
02248 <span class="comment">/*++</span>
02249 <span class="comment"></span>
02250 <span class="comment">Routine Description:</span>
02251 <span class="comment"></span>
02252 <span class="comment">    This routine may be called to set a range of pages dirty in a user data</span>
02253 <span class="comment">    file, by just setting the corresponding bits in the mask bcb.</span>
02254 <span class="comment"></span>
02255 <span class="comment">    IMPORTANT NOTE:</span>
02256 <span class="comment"></span>
02257 <span class="comment">        If this routine fails to set any bits due to an allocation failure,</span>
02258 <span class="comment">        it just returns quietly without informing the caller.  (Note that this</span>
02259 <span class="comment">        routine is never called for no modified write sections.)  The reason</span>
02260 <span class="comment">        for this behavior is that this routine is sometimes called as part of</span>
02261 <span class="comment">        error recovery (CcFreeActiveVacb, CcMdlWriteComplete, etc.) when it is</span>
02262 <span class="comment">        essential to just keep on moving.  Note that if an allocation failure does</span>
02263 <span class="comment">        occur, this only means that MM will have to flush the modified page in</span>
02264 <span class="comment">        time, since the Lazy Writer will not do it.</span>
02265 <span class="comment"></span>
02266 <span class="comment">Arguments:</span>
02267 <span class="comment"></span>
02268 <span class="comment">    SharedCacheMap - SharedCacheMap where the pages are to be set dirty.</span>
02269 <span class="comment"></span>
02270 <span class="comment">    FileOffset - FileOffset of first page to set dirty</span>
02271 <span class="comment"></span>
02272 <span class="comment">    Length - Used in conjunction with FileOffset to determine how many pages</span>
02273 <span class="comment">             to set dirty.</span>
02274 <span class="comment"></span>
02275 <span class="comment">Return Value:</span>
02276 <span class="comment"></span>
02277 <span class="comment">    None</span>
02278 <span class="comment"></span>
02279 <span class="comment">--*/</span>
02280 
02281 {
02282     KIRQL OldIrql;
02283     <a class="code" href="../../d9/d6/struct__MBCB.html">PMBCB</a> Mbcb;
02284     <a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html">PBITMAP_RANGE</a> BitmapRange;
02285     LONGLONG FirstPage;
02286     LONGLONG LastPage;
02287     PULONG MaskPtr;
02288     ULONG Mask = 0;
02289     PULONG Bitmap = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02290     ULONG AllocationError = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02291 
02292     <span class="comment">//</span>
02293     <span class="comment">//  We assume no caller can cross a bitmap range boundary (currently not even</span>
02294     <span class="comment">//  a view boundary!), so we do not want to loop through bitmap ranges.</span>
02295     <span class="comment">//</span>
02296 
02297     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((FileOffset-&gt;QuadPart / <a class="code" href="../../d5/d5/cc_8h.html#a44">MBCB_BITMAP_RANGE</a>) ==
02298            ((FileOffset-&gt;QuadPart + Length - 1) / <a class="code" href="../../d5/d5/cc_8h.html#a44">MBCB_BITMAP_RANGE</a>));
02299 
02300     <span class="comment">//</span>
02301     <span class="comment">//  Initialize our locals.</span>
02302     <span class="comment">//</span>
02303 
02304     FirstPage = FileOffset-&gt;QuadPart &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
02305     LastPage = ((FileOffset-&gt;QuadPart + Length - 1) &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
02306 
02307     <span class="comment">//</span>
02308     <span class="comment">//  If we have to convert to an Mbcb grande, we will loop back here to</span>
02309     <span class="comment">//  preallocate another buffer.</span>
02310     <span class="comment">//</span>
02311 
02312     <span class="keywordflow">do</span> {
02313 
02314         <span class="comment">//</span>
02315         <span class="comment">//  For large streams, we need to preallocate a block we use for</span>
02316         <span class="comment">//  we use for bitmaps.  We allocate one, then loop back in the rare</span>
02317         <span class="comment">//  case where we will need another.  We free it at the bottom if we</span>
02318         <span class="comment">//  don't need one.</span>
02319         <span class="comment">//</span>
02320 
02321         <span class="keywordflow">if</span> (SharedCacheMap-&gt;SectionSize.QuadPart &gt; (<a class="code" href="../../d5/d5/cc_8h.html#a45">MBCB_BITMAP_INITIAL_SIZE</a> * 8 * <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>)) {
02322 
02323             <span class="comment">//</span>
02324             <span class="comment">//  If we could not preallocate, break out into common cleanup code and</span>
02325             <span class="comment">//  return quietly.</span>
02326             <span class="comment">//</span>
02327 
02328             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d3/vacbsup_8c.html#a23">CcPrefillVacbLevelZone</a>( 1, &amp;OldIrql, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> )) {
02329                 <span class="keywordflow">return</span>;
02330             }
02331 
02332             Bitmap = (PULONG)<a class="code" href="../../d5/d5/cc_8h.html#a206">CcAllocateVacbLevel</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
02333             <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( OldIrql );
02334         }
02335 
02336         <span class="comment">//</span>
02337         <span class="comment">//  Acquire the Mbcb spinlock.</span>
02338         <span class="comment">//</span>
02339 
02340         ExAcquireSpinLock( &amp;SharedCacheMap-&gt;BcbSpinLock, &amp;OldIrql );
02341 
02342         <span class="comment">//</span>
02343         <span class="comment">//  If there is no Mbcb, we will have to allocate one.</span>
02344         <span class="comment">//</span>
02345 
02346         Mbcb = SharedCacheMap-&gt;Mbcb;
02347         <span class="keywordflow">if</span> (Mbcb == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02348 
02349             <span class="comment">//</span>
02350             <span class="comment">//  Since we use the Bcb zone, we must assume that Bcbs are big enough.</span>
02351             <span class="comment">//</span>
02352 
02353             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d5/d5/cc_8h.html#a62">QuadAlign</a>(<span class="keyword">sizeof</span>(<a class="code" href="../../d9/d6/struct__MBCB.html">MBCB</a>)) &lt;= <a class="code" href="../../d5/d5/cc_8h.html#a62">QuadAlign</a>(<span class="keyword">sizeof</span>(<a class="code" href="../../d4/d3/struct__BCB.html">BCB</a>)));
02354 
02355             <span class="comment">//</span>
02356             <span class="comment">//  Allocate the Mbcb from the Bcb zone.</span>
02357             <span class="comment">//</span>
02358 
02359             Mbcb = (<a class="code" href="../../d9/d6/struct__MBCB.html">PMBCB</a>)<a class="code" href="../../d6/d2/cachesub_8c.html#a5">CcAllocateInitializeBcb</a>( <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
02360 
02361             <span class="comment">//</span>
02362             <span class="comment">//  If we could not allocate an Mbcb, break out to clean up and return</span>
02363             <span class="comment">//</span>
02364 
02365             <span class="keywordflow">if</span> (Mbcb == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02366                 <span class="keywordflow">break</span>;
02367             }
02368 
02369             <span class="comment">//</span>
02370             <span class="comment">//  Set in the node type, and initialize the listhead of ranges.</span>
02371             <span class="comment">//</span>
02372 
02373             Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o0">NodeTypeCode</a> = <a class="code" href="../../d5/d5/cc_8h.html#a16">CACHE_NTC_MBCB</a>;
02374             InitializeListHead( &amp;Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o5">BitmapRanges</a> );
02375 
02376             <span class="comment">//</span>
02377             <span class="comment">//  Insert and initialize the first range.</span>
02378             <span class="comment">//</span>
02379 
02380             InsertTailList( &amp;Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o5">BitmapRanges</a>, &amp;Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o7">BitmapRange1</a>.<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o0">Links</a> );
02381             Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o7">BitmapRange1</a>.<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o2">FirstDirtyPage</a> = MAXULONG;
02382 
02383             <span class="comment">//</span>
02384             <span class="comment">//  Use the rest of the Mbcb as the initial bitmap.</span>
02385             <span class="comment">//</span>
02386 
02387             Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o7">BitmapRange1</a>.<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o5">Bitmap</a> = (PULONG)&amp;Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o8">BitmapRange2</a>;
02388 
02389             <span class="comment">//</span>
02390             <span class="comment">//  Now set to use our new Mbcb.</span>
02391             <span class="comment">//</span>
02392 
02393             SharedCacheMap-&gt;Mbcb = Mbcb;
02394         }
02395 
02396         <span class="comment">//</span>
02397         <span class="comment">//  Now see if we need to switch to the Mbcb grande format.</span>
02398         <span class="comment">//</span>
02399 
02400         <span class="keywordflow">if</span> ((LastPage &gt;= (<a class="code" href="../../d5/d5/cc_8h.html#a45">MBCB_BITMAP_INITIAL_SIZE</a> * 8)) &amp;&amp;
02401             (Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o0">NodeTypeCode</a> != <a class="code" href="../../d5/d5/cc_8h.html#a18">CACHE_NTC_MBCB_GRANDE</a>)) {
02402 
02403             <span class="comment">//</span>
02404             <span class="comment">//  If there are any dirty pages, copy the initial bitmap over, and zero</span>
02405             <span class="comment">//  out the original end of the Mbcb for reuse.</span>
02406             <span class="comment">//</span>
02407 
02408             <span class="keywordflow">if</span> (Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o7">BitmapRange1</a>.<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o4">DirtyPages</a> != 0) {
02409                 RtlCopyMemory( Bitmap, Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o7">BitmapRange1</a>.<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o5">Bitmap</a>, <a class="code" href="../../d5/d5/cc_8h.html#a45">MBCB_BITMAP_INITIAL_SIZE</a> );
02410                 RtlZeroMemory( Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o7">BitmapRange1</a>.<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o5">Bitmap</a>, <a class="code" href="../../d5/d5/cc_8h.html#a45">MBCB_BITMAP_INITIAL_SIZE</a> );
02411             }
02412 
02413             <span class="comment">//</span>
02414             <span class="comment">//  Store the new bitmap pointer and show we have consumed this one.</span>
02415             <span class="comment">//</span>
02416 
02417             Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o7">BitmapRange1</a>.<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o5">Bitmap</a> = Bitmap;
02418             Bitmap = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02419 
02420             <span class="comment">//</span>
02421             <span class="comment">//  Insert and initialize the first range.</span>
02422             <span class="comment">//</span>
02423 
02424             InsertTailList( &amp;Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o5">BitmapRanges</a>, &amp;Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o8">BitmapRange2</a>.<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o0">Links</a> );
02425             Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o8">BitmapRange2</a>.<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o1">BasePage</a> = MAXLONGLONG;
02426             Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o8">BitmapRange2</a>.<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o2">FirstDirtyPage</a> = MAXULONG;
02427             InsertTailList( &amp;Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o5">BitmapRanges</a>, &amp;Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o9">BitmapRange3</a>.<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o0">Links</a> );
02428             Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o9">BitmapRange3</a>.<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o1">BasePage</a> = MAXLONGLONG;
02429             Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o9">BitmapRange3</a>.<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o2">FirstDirtyPage</a> = MAXULONG;
02430             Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o0">NodeTypeCode</a> = <a class="code" href="../../d5/d5/cc_8h.html#a18">CACHE_NTC_MBCB_GRANDE</a>;
02431 
02432             <span class="comment">//</span>
02433             <span class="comment">//  This is a one-time event - converting to the large Mbcb.  Continue back</span>
02434             <span class="comment">//  to preallocate another buffer for CcFindBitmapRangeToDirty.</span>
02435             <span class="comment">//</span>
02436 
02437             ExReleaseSpinLock( &amp;SharedCacheMap-&gt;BcbSpinLock, OldIrql );
02438             <span class="keywordflow">continue</span>;
02439         }
02440 
02441         <span class="comment">//</span>
02442         <span class="comment">//  Now find the Bitmap range we are setting bits in.</span>
02443         <span class="comment">//</span>
02444 
02445         BitmapRange = <a class="code" href="../../d6/d2/cachesub_8c.html#a9">CcFindBitmapRangeToDirty</a>( Mbcb, FirstPage, &amp;Bitmap );
02446 
02447         <span class="comment">//</span>
02448         <span class="comment">//  If we could not allocate this dinky structure, break out quietly.</span>
02449         <span class="comment">//</span>
02450 
02451         <span class="keywordflow">if</span> (BitmapRange == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02452             <span class="keywordflow">break</span>;
02453         }
02454 
02455         <span class="comment">//</span>
02456         <span class="comment">//  Now update the first and last dirty page indices and the bitmap.</span>
02457         <span class="comment">//</span>
02458 
02459         <span class="keywordflow">if</span> (FirstPage &lt; (BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o1">BasePage</a> + BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o2">FirstDirtyPage</a>)) {
02460             BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o2">FirstDirtyPage</a> = (ULONG)(FirstPage - BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o1">BasePage</a>);
02461         }
02462 
02463         <span class="keywordflow">if</span> (LastPage &gt; (BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o1">BasePage</a> + BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o3">LastDirtyPage</a>)) {
02464             BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o3">LastDirtyPage</a> = (ULONG)(LastPage - BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o1">BasePage</a>);
02465         }
02466 
02467         <span class="comment">//</span>
02468         <span class="comment">//  We have to acquire the shared cache map list, because we</span>
02469         <span class="comment">//  may be changing lists.</span>
02470         <span class="comment">//</span>
02471 
02472         <a class="code" href="../../d5/d5/cc_8h.html#a2">CcAcquireMasterLockAtDpcLevel</a>();
02473 
02474         <span class="comment">//</span>
02475         <span class="comment">//  If this is the first dirty page for this cache map, there is some work</span>
02476         <span class="comment">//  to do.</span>
02477         <span class="comment">//</span>
02478 
02479         <span class="keywordflow">if</span> (SharedCacheMap-&gt;DirtyPages == 0) {
02480 
02481             <span class="comment">//</span>
02482             <span class="comment">//  If the lazy write scan is not active, then start it.</span>
02483             <span class="comment">//</span>
02484 
02485             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o5">ScanActive</a>) {
02486                 <a class="code" href="../../d5/d5/cc_8h.html#a185">CcScheduleLazyWriteScan</a>();
02487             }
02488 
02489             <span class="comment">//</span>
02490             <span class="comment">//  Move to the dirty list.</span>
02491             <span class="comment">//</span>
02492 
02493             RemoveEntryList( &amp;SharedCacheMap-&gt;SharedCacheMapLinks );
02494             InsertTailList( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a2">CcDirtySharedCacheMapList</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a>,
02495                             &amp;SharedCacheMap-&gt;SharedCacheMapLinks );
02496 
02497             Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o6">ResumeWritePage</a> = FirstPage;
02498         }
02499 
02500         MaskPtr = &amp;BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o5">Bitmap</a>[(ULONG)(FirstPage - BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o1">BasePage</a>) / 32];
02501         Mask = 1 &lt;&lt; ((ULONG)FirstPage % 32);
02502 
02503         <span class="comment">//</span>
02504         <span class="comment">//  Loop to set all of the bits and adjust the DirtyPage totals.</span>
02505         <span class="comment">//</span>
02506 
02507         <span class="keywordflow">for</span> ( ; FirstPage &lt;= LastPage; FirstPage++) {
02508 
02509             <span class="keywordflow">if</span> ((*MaskPtr &amp; Mask) == 0) {
02510 
02511                 <a class="code" href="../../d5/d2/cachedat_8c.html#a36">CcTotalDirtyPages</a> += 1;
02512                 SharedCacheMap-&gt;DirtyPages += 1;
02513                 Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o3">DirtyPages</a> += 1;
02514                 BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o4">DirtyPages</a> += 1;
02515                 *MaskPtr |= Mask;
02516             }
02517 
02518             Mask &lt;&lt;= 1;
02519 
02520             <span class="keywordflow">if</span> (Mask == 0) {
02521 
02522                 MaskPtr += 1;
02523                 Mask = 1;
02524             }
02525         }
02526 
02527         <span class="comment">//</span>
02528         <span class="comment">//  See if we need to advance our goal for ValidDataLength.</span>
02529         <span class="comment">//</span>
02530 
02531         LastPage = FileOffset-&gt;QuadPart + Length;
02532 
02533         <span class="keywordflow">if</span> (LastPage &gt; SharedCacheMap-&gt;ValidDataGoal.QuadPart) {
02534             SharedCacheMap-&gt;ValidDataGoal.QuadPart = (LONGLONG)LastPage;
02535         }
02536 
02537         <a class="code" href="../../d5/d5/cc_8h.html#a3">CcReleaseMasterLockFromDpcLevel</a>();
02538 
02539     <span class="comment">//</span>
02540     <span class="comment">//  Continue until we have actually set the bits (there is a continue</span>
02541     <span class="comment">//  which just wants to loop back and allocate another buffer).</span>
02542     <span class="comment">//</span>
02543 
02544     } <span class="keywordflow">while</span> (Mask == 0);
02545 
02546     <span class="comment">//</span>
02547     <span class="comment">//  Now if we preallocated a bitmap buffer, free it on the way out.</span>
02548     <span class="comment">//</span>
02549 
02550     <span class="keywordflow">if</span> (Bitmap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02551         <a class="code" href="../../d5/d5/cc_8h.html#a6">CcAcquireVacbLockAtDpcLevel</a>();
02552         <a class="code" href="../../d5/d5/cc_8h.html#a207">CcDeallocateVacbLevel</a>( (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *)Bitmap, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
02553         <a class="code" href="../../d5/d5/cc_8h.html#a7">CcReleaseVacbLockFromDpcLevel</a>();
02554     }
02555     ExReleaseSpinLock( &amp;SharedCacheMap-&gt;BcbSpinLock, OldIrql );
02556 }
02557 
02558 
02559 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02560"></a><a class="code" href="../../d4/d2/cache_8h.html#a91">02560</a> <a class="code" href="../../d4/d2/cache_8h.html#a91">CcSetDirtyPinnedData</a> (
02561     IN PVOID BcbVoid,
02562     IN PLARGE_INTEGER Lsn OPTIONAL
02563     )
02564 
02565 <span class="comment">/*++</span>
02566 <span class="comment"></span>
02567 <span class="comment">Routine Description:</span>
02568 <span class="comment"></span>
02569 <span class="comment">    This routine may be called to set a Bcb (returned by CcPinFileData)</span>
02570 <span class="comment">    dirty, and a candidate for the Lazy Writer.  All Bcbs should be set</span>
02571 <span class="comment">    dirty by calling this routine, even if they are to be flushed</span>
02572 <span class="comment">    another way.</span>
02573 <span class="comment"></span>
02574 <span class="comment">Arguments:</span>
02575 <span class="comment"></span>
02576 <span class="comment">    Bcb - Supplies a pointer to a pinned (by CcPinFileData) Bcb, to</span>
02577 <span class="comment">          be set dirty.</span>
02578 <span class="comment"></span>
02579 <span class="comment">    Lsn - Lsn to be remembered with page.</span>
02580 <span class="comment"></span>
02581 <span class="comment">Return Value:</span>
02582 <span class="comment"></span>
02583 <span class="comment">    None</span>
02584 <span class="comment"></span>
02585 <span class="comment">--*/</span>
02586 
02587 {
02588     <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> Bcbs[2];
02589     <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> *BcbPtrPtr;
02590     KIRQL OldIrql;
02591     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
02592 
02593     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcSetDirtyPinnedData: Bcb = %08lx\n"</span>, BcbVoid );
02594 
02595     <span class="comment">//</span>
02596     <span class="comment">//  Assume this is a normal Bcb, and set up for loop below.</span>
02597     <span class="comment">//</span>
02598 
02599     Bcbs[0] = (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)BcbVoid;
02600     Bcbs[1] = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02601     BcbPtrPtr = &amp;Bcbs[0];
02602 
02603     <span class="comment">//</span>
02604     <span class="comment">//  If it is an overlap Bcb, then point into the Bcb vector</span>
02605     <span class="comment">//  for the loop.</span>
02606     <span class="comment">//</span>
02607 
02608     <span class="keywordflow">if</span> (Bcbs[0]-&gt;NodeTypeCode == <a class="code" href="../../d5/d5/cc_8h.html#a17">CACHE_NTC_OBCB</a>) {
02609         BcbPtrPtr = &amp;((<a class="code" href="../../d6/d4/struct__OBCB.html">POBCB</a>)Bcbs[0])-&gt;Bcbs[0];
02610     }
02611 
02612     <span class="comment">//</span>
02613     <span class="comment">//  Loop to set all Bcbs dirty</span>
02614     <span class="comment">//</span>
02615 
02616     <span class="keywordflow">while</span> (*BcbPtrPtr != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02617 
02618         Bcbs[0] = *(BcbPtrPtr++);
02619 
02620         <span class="comment">//</span>
02621         <span class="comment">//  Should be no ReadOnly Bcbs</span>
02622         <span class="comment">//</span>
02623 
02624         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(((ULONG_PTR)Bcbs[0] &amp; 1) != 1);
02625 
02626         SharedCacheMap = Bcbs[0]-&gt;SharedCacheMap;
02627 
02628         <span class="comment">//</span>
02629         <span class="comment">//  We have to acquire the shared cache map list, because we</span>
02630         <span class="comment">//  may be changing lists.</span>
02631         <span class="comment">//</span>
02632 
02633         ExAcquireSpinLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, &amp;OldIrql );
02634 
02635         <span class="keywordflow">if</span> (!Bcbs[0]-&gt;Dirty) {
02636 
02637             ULONG Pages = Bcbs[0]-&gt;ByteLength &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
02638 
02639             <span class="comment">//</span>
02640             <span class="comment">//  Set dirty to keep the Bcb from going away until</span>
02641             <span class="comment">//  it is set Undirty, and assign the next modification time stamp.</span>
02642             <span class="comment">//</span>
02643 
02644             Bcbs[0]-&gt;Dirty = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02645 
02646             <span class="comment">//</span>
02647             <span class="comment">//  Initialize the OldestLsn field.</span>
02648             <span class="comment">//</span>
02649 
02650             <span class="keywordflow">if</span> (ARGUMENT_PRESENT(Lsn)) {
02651                 Bcbs[0]-&gt;OldestLsn = *Lsn;
02652                 Bcbs[0]-&gt;NewestLsn = *Lsn;
02653             }
02654 
02655             <span class="comment">//</span>
02656             <span class="comment">//  Move it to the dirty list if these are the first dirty pages,</span>
02657             <span class="comment">//  and this is not disabled for write behind.</span>
02658             <span class="comment">//</span>
02659             <span class="comment">//  Increase the count of dirty bytes in the shared cache map.</span>
02660             <span class="comment">//</span>
02661 
02662             <a class="code" href="../../d5/d5/cc_8h.html#a2">CcAcquireMasterLockAtDpcLevel</a>();
02663             <span class="keywordflow">if</span> ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> == 0) &amp;&amp;
02664                 !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a71">DISABLE_WRITE_BEHIND</a>)) {
02665 
02666                 <span class="comment">//</span>
02667                 <span class="comment">//  If the lazy write scan is not active, then start it.</span>
02668                 <span class="comment">//</span>
02669 
02670                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o5">ScanActive</a>) {
02671                     <a class="code" href="../../d5/d5/cc_8h.html#a185">CcScheduleLazyWriteScan</a>();
02672                 }
02673 
02674                 RemoveEntryList( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
02675                 InsertTailList( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a2">CcDirtySharedCacheMapList</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a>,
02676                                 &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
02677             }
02678 
02679             SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> += Pages;
02680             <a class="code" href="../../d5/d2/cachedat_8c.html#a36">CcTotalDirtyPages</a> += Pages;
02681             <a class="code" href="../../d5/d5/cc_8h.html#a3">CcReleaseMasterLockFromDpcLevel</a>();
02682         }
02683 
02684         <span class="comment">//</span>
02685         <span class="comment">//  If this Lsn happens to be older/newer than the ones we have stored, then</span>
02686         <span class="comment">//  change it.</span>
02687         <span class="comment">//</span>
02688 
02689         <span class="keywordflow">if</span> (ARGUMENT_PRESENT(Lsn)) {
02690 
02691             <span class="keywordflow">if</span> ((Bcbs[0]-&gt;OldestLsn.QuadPart == 0) || (Lsn-&gt;QuadPart &lt; Bcbs[0]-&gt;OldestLsn.QuadPart)) {
02692                 Bcbs[0]-&gt;OldestLsn = *Lsn;
02693             }
02694 
02695             <span class="keywordflow">if</span> (Lsn-&gt;QuadPart &gt; Bcbs[0]-&gt;NewestLsn.QuadPart) {
02696                 Bcbs[0]-&gt;NewestLsn = *Lsn;
02697             }
02698         }
02699 
02700         <span class="comment">//</span>
02701         <span class="comment">//  See if we need to advance our goal for ValidDataLength.</span>
02702         <span class="comment">//</span>
02703 
02704         <span class="keywordflow">if</span> ( Bcbs[0]-&gt;BeyondLastByte.QuadPart &gt; SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o7">ValidDataGoal</a>.QuadPart ) {
02705 
02706             SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o7">ValidDataGoal</a> = Bcbs[0]-&gt;BeyondLastByte;
02707         }
02708 
02709         ExReleaseSpinLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, OldIrql );
02710     }
02711 
02712     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcSetDirtyPinnedData -&gt; VOID\n"</span>, 0 );
02713 }
02714 
02715 
02716 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l02717"></a><a class="code" href="../../d6/d2/cachesub_8c.html#a6">02717</a> <a class="code" href="../../d6/d2/cachesub_8c.html#a6">CcSetValidData</a> (
02718     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
02719     IN PLARGE_INTEGER ValidDataLength
02720     )
02721 
02722 <span class="comment">/*++</span>
02723 <span class="comment"></span>
02724 <span class="comment">Routine Description:</span>
02725 <span class="comment"></span>
02726 <span class="comment">    This routine is used to call the File System to update ValidDataLength</span>
02727 <span class="comment">    for a file.</span>
02728 <span class="comment"></span>
02729 <span class="comment">Arguments:</span>
02730 <span class="comment"></span>
02731 <span class="comment">    FileObject - A pointer to a referenced file object describing which file</span>
02732 <span class="comment">        the read should be performed from.</span>
02733 <span class="comment"></span>
02734 <span class="comment">    ValidDataLength - Pointer to new ValidDataLength.</span>
02735 <span class="comment"></span>
02736 <span class="comment">Return Value:</span>
02737 <span class="comment"></span>
02738 <span class="comment">    Status of operation.</span>
02739 <span class="comment"></span>
02740 <span class="comment">--*/</span>
02741 
02742 {
02743     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> IrpSp;
02744     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject;
02745     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02746     FILE_END_OF_FILE_INFORMATION <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>;
02747     IO_STATUS_BLOCK IoStatus;
02748     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>;
02749     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>;
02750 
02751     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcSetValidData:\n"</span>, 0 );
02752     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    FileObject = %08lx\n"</span>, FileObject );
02753     <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>(0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    ValidDataLength = %08lx, %08lx\n"</span>,
02754                 ValidDataLength-&gt;LowPart, ValidDataLength-&gt;HighPart );
02755 
02756     <span class="comment">//</span>
02757     <span class="comment">//  Copy ValidDataLength to our buffer.</span>
02758     <span class="comment">//</span>
02759 
02760     <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>.EndOfFile = *ValidDataLength;
02761 
02762     <span class="comment">//</span>
02763     <span class="comment">//  Initialize the event.</span>
02764     <span class="comment">//</span>
02765 
02766     <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>, NotificationEvent, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
02767 
02768     <span class="comment">//</span>
02769     <span class="comment">//  Begin by getting a pointer to the device object that the file resides</span>
02770     <span class="comment">//  on.</span>
02771     <span class="comment">//</span>
02772 
02773     DeviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( FileObject );
02774 
02775     <span class="comment">//</span>
02776     <span class="comment">//  Allocate an I/O Request Packet (IRP) for this in-page operation.</span>
02777     <span class="comment">//</span>
02778 
02779     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> = <a class="code" href="../../d4/d6/iosubs_8c.html#a17">IoAllocateIrp</a>( DeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o13">StackSize</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
02780     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02781 
02782         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcSetValidData-&gt; STATUS_INSUFFICIENT_RESOURCES\n"</span>, 0 );
02783 
02784         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
02785     }
02786 
02787     <span class="comment">//</span>
02788     <span class="comment">//  Get a pointer to the first stack location in the packet.  This location</span>
02789     <span class="comment">//  will be used to pass the function codes and parameters to the first</span>
02790     <span class="comment">//  driver.</span>
02791     <span class="comment">//</span>
02792 
02793     IrpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
02794 
02795     <span class="comment">//</span>
02796     <span class="comment">//  Fill in the IRP according to this request, setting the flags to</span>
02797     <span class="comment">//  just cause IO to set the event and deallocate the Irp.</span>
02798     <span class="comment">//</span>
02799 
02800     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a174">IRP_PAGING_IO</a> | <a class="code" href="../../d0/d5/io_8h.html#a181">IRP_SYNCHRONOUS_PAGING_IO</a>;
02801     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o10">RequestorMode</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>;
02802     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = &amp;IoStatus;
02803     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = &amp;<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>;
02804     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.OriginalFileObject = FileObject;
02805     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
02806     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer = &amp;<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>;
02807 
02808     <span class="comment">//</span>
02809     <span class="comment">//  Fill in the normal read parameters.</span>
02810     <span class="comment">//</span>
02811 
02812     IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a19">IRP_MJ_SET_INFORMATION</a>;
02813     IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> = FileObject;
02814     IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o57">DeviceObject</a> = DeviceObject;
02815     IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.SetFile.Length = <span class="keyword">sizeof</span>(FILE_END_OF_FILE_INFORMATION);
02816     IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.SetFile.FileInformationClass = FileEndOfFileInformation;
02817     IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.SetFile.FileObject = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02818     IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.SetFile.AdvanceOnly = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02819 
02820     <span class="comment">//</span>
02821     <span class="comment">//  Queue the packet to the appropriate driver based on whether or not there</span>
02822     <span class="comment">//  is a VPB associated with the device.  This routine should not raise.</span>
02823     <span class="comment">//</span>
02824 
02825     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( DeviceObject, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
02826 
02827     <span class="comment">//</span>
02828     <span class="comment">//  If pending is returned (which is a successful status),</span>
02829     <span class="comment">//  we must wait for the request to complete.</span>
02830     <span class="comment">//</span>
02831 
02832     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_PENDING) {
02833         <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;<a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>,
02834                                <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
02835                                <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
02836                                <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
02837                                (PLARGE_INTEGER)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
02838     }
02839 
02840     <span class="comment">//</span>
02841     <span class="comment">//  If we got an error back in Status, then the Iosb</span>
02842     <span class="comment">//  was not written, so we will just copy the status</span>
02843     <span class="comment">//  there, then test the final status after that.</span>
02844     <span class="comment">//</span>
02845 
02846     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
02847         IoStatus.Status = <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02848     }
02849 
02850     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcSetValidData-&gt; %08lx\n"</span>, IoStatus.Status );
02851 
02852     <span class="keywordflow">return</span> IoStatus.Status;
02853 }
02854 
02855 
02856 <span class="comment">//</span>
02857 <span class="comment">//  Internal Support Routine</span>
02858 <span class="comment">//</span>
02859 
02860 BOOLEAN
<a name="l02861"></a><a class="code" href="../../d6/d2/cachesub_8c.html#a7">02861</a> <a class="code" href="../../d6/d2/cachesub_8c.html#a7">CcAcquireByteRangeForWrite</a> (
02862     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap,
02863     IN PLARGE_INTEGER TargetOffset OPTIONAL,
02864     IN ULONG TargetLength,
02865     OUT PLARGE_INTEGER FileOffset,
02866     OUT PULONG Length,
02867     OUT <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> *FirstBcb
02868     )
02869 
02870 <span class="comment">/*++</span>
02871 <span class="comment"></span>
02872 <span class="comment">Routine Description:</span>
02873 <span class="comment"></span>
02874 <span class="comment">    This routine is called by the Lazy Writer to try to find a contiguous</span>
02875 <span class="comment">    range of bytes from the specified SharedCacheMap that are dirty and</span>
02876 <span class="comment">    should be flushed.  After flushing, these bytes should be released</span>
02877 <span class="comment">    by calling CcReleaseByteRangeFromWrite.</span>
02878 <span class="comment"></span>
02879 <span class="comment">    Dirty ranges are returned in strictly increasing order.</span>
02880 <span class="comment"></span>
02881 <span class="comment">Arguments:</span>
02882 <span class="comment"></span>
02883 <span class="comment">    SharedCacheMap - for the file for which the dirty byte range is sought</span>
02884 <span class="comment"></span>
02885 <span class="comment">    TargetOffset - If specified, then only the specified range is</span>
02886 <span class="comment">                   to be flushed.</span>
02887 <span class="comment"></span>
02888 <span class="comment">    TargetLength - If target offset specified, this completes the range.</span>
02889 <span class="comment">                   In any case, this field is zero for the Lazy Writer,</span>
02890 <span class="comment">                   and nonzero for explicit flush calls.</span>
02891 <span class="comment"></span>
02892 <span class="comment">    FileOffset - Returns the offset for the beginning of the dirty byte</span>
02893 <span class="comment">                 range to flush</span>
02894 <span class="comment"></span>
02895 <span class="comment">    Length - Returns the length of bytes in the range.</span>
02896 <span class="comment"></span>
02897 <span class="comment">    FirstBcb - Returns the first Bcb in the list for the range, to be used</span>
02898 <span class="comment">               when calling CcReleaseByteRangeFromWrite, or NULL if dirty</span>
02899 <span class="comment">               pages were found in the mask Bcb.</span>
02900 <span class="comment"></span>
02901 <span class="comment">Return Value:</span>
02902 <span class="comment"></span>
02903 <span class="comment">    FALSE - if no dirty byte range could be found to match the necessary</span>
02904 <span class="comment">            criteria.</span>
02905 <span class="comment"></span>
02906 <span class="comment">    TRUE - if a dirty byte range is being returned.</span>
02907 <span class="comment"></span>
02908 <span class="comment">--*/</span>
02909 
02910 {
02911     KIRQL OldIrql;
02912     <a class="code" href="../../d9/d6/struct__MBCB.html">PMBCB</a> Mbcb;
02913     <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> Bcb;
02914     LARGE_INTEGER LsnToFlushTo = {0, 0};
02915 
02916     BOOLEAN BcbLookasideCheck = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02917 
02918     <a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html">PBITMAP_RANGE</a> BitmapRange;
02919     PULONG EndPtr;
02920     PULONG MaskPtr;
02921     ULONG Mask;
02922     LONGLONG FirstDirtyPage;
02923     ULONG OriginalFirstDirtyPage;
02924     LONGLONG LastDirtyPage = MAXLONGLONG;
02925 
02926     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcAcquireByteRangeForWrite:\n"</span>, 0);
02927     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    SharedCacheMap = %08lx\n"</span>, SharedCacheMap);
02928 
02929     <span class="comment">//</span>
02930     <span class="comment">//  Initially clear outputs.</span>
02931     <span class="comment">//</span>
02932 
02933     FileOffset-&gt;QuadPart = 0;
02934     *Length = 0;
02935 
02936     <span class="comment">//</span>
02937     <span class="comment">//  We must acquire the SharedCacheMap-&gt;BcbSpinLock.</span>
02938     <span class="comment">//</span>
02939 
02940     ExAcquireSpinLock( &amp;SharedCacheMap-&gt;BcbSpinLock, &amp;OldIrql );
02941 
02942     <span class="comment">//</span>
02943     <span class="comment">//  See if there is a simple Mask Bcb, and if there is anything dirty in</span>
02944     <span class="comment">//  it.  If so we will simply handle that case here by processing the bitmap.</span>
02945     <span class="comment">//</span>
02946 
02947     Mbcb = SharedCacheMap-&gt;Mbcb;
02948 
02949     <span class="keywordflow">if</span> ((Mbcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
02950         (Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o3">DirtyPages</a> != 0) &amp;&amp;
02951         ((Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o2">PagesToWrite</a> != 0) || (TargetLength != 0))) {
02952 
02953         <span class="comment">//</span>
02954         <span class="comment">//  If a target range was specified (outside call to CcFlush for a range),</span>
02955         <span class="comment">//  then calculate FirstPage and EndPtr based on these inputs.</span>
02956         <span class="comment">//</span>
02957 
02958         <span class="keywordflow">if</span> (ARGUMENT_PRESENT(TargetOffset)) {
02959 
02960             FirstDirtyPage = TargetOffset-&gt;QuadPart &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
02961             LastDirtyPage = (TargetOffset-&gt;QuadPart + TargetLength - 1) &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
02962 
02963             <span class="comment">//</span>
02964             <span class="comment">//  Find the bitmap range containing the first dirty page.</span>
02965             <span class="comment">//</span>
02966 
02967             BitmapRange = <a class="code" href="../../d6/d2/cachesub_8c.html#a10">CcFindBitmapRangeToClean</a>( Mbcb, FirstDirtyPage );
02968 
02969             <span class="comment">//</span>
02970             <span class="comment">//  If the target range is not dirty, get out.  We may have even</span>
02971             <span class="comment">//  gotten back a nonoverlapping bitmap range.</span>
02972             <span class="comment">//</span>
02973 
02974             <span class="keywordflow">if</span> ((LastDirtyPage &lt; (BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o1">BasePage</a> + BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o2">FirstDirtyPage</a>)) ||
02975                 (FirstDirtyPage &gt; (BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o1">BasePage</a> + BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o3">LastDirtyPage</a>))) {
02976 
02977                 <span class="keywordflow">goto</span> Scan_Bcbs;
02978             }
02979 
02980             <span class="keywordflow">if</span> (LastDirtyPage &lt; (BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o1">BasePage</a> + BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o3">LastDirtyPage</a>)) {
02981                 EndPtr = &amp;BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o5">Bitmap</a>[(ULONG)(LastDirtyPage - BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o1">BasePage</a>) / 32];
02982             } <span class="keywordflow">else</span> {
02983                 EndPtr = &amp;BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o5">Bitmap</a>[BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o3">LastDirtyPage</a> / 32];
02984             }
02985 
02986 
02987         <span class="comment">//</span>
02988         <span class="comment">//  Otherwise, for the Lazy Writer pick up where we left off.</span>
02989         <span class="comment">//</span>
02990 
02991         } <span class="keywordflow">else</span> {
02992 
02993             <span class="comment">//</span>
02994             <span class="comment">//  If a length was specified, then it is an explicit flush, and</span>
02995             <span class="comment">//  we want to start with the first dirty page, else the Lazy Writer</span>
02996             <span class="comment">//  starts from the ResumeWritePage.</span>
02997             <span class="comment">//</span>
02998 
02999             FirstDirtyPage = 0;
03000             <span class="keywordflow">if</span> (TargetLength == 0) {
03001                 FirstDirtyPage = Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o6">ResumeWritePage</a>;
03002             }
03003 
03004             <span class="comment">//</span>
03005             <span class="comment">//  Now find the next (cyclic) dirty page from this point.</span>
03006             <span class="comment">//</span>
03007 
03008             BitmapRange = <a class="code" href="../../d6/d2/cachesub_8c.html#a10">CcFindBitmapRangeToClean</a>( Mbcb, FirstDirtyPage );
03009 
03010             <span class="comment">//</span>
03011             <span class="comment">//  If the page we thought we were looking for is beyond the last dirty page</span>
03012             <span class="comment">//  of this range, then CcFindBitmapRangeToClean must have wrapped back to</span>
03013             <span class="comment">//  the start of the file, and we should resume on the first dirty page of</span>
03014             <span class="comment">//  this range.</span>
03015             <span class="comment">//</span>
03016 
03017             <span class="keywordflow">if</span> (FirstDirtyPage &gt; (BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o1">BasePage</a> + BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o3">LastDirtyPage</a>)) {
03018                 FirstDirtyPage = BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o1">BasePage</a> + BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o2">FirstDirtyPage</a>;
03019             }
03020 
03021             EndPtr = &amp;BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o5">Bitmap</a>[BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o3">LastDirtyPage</a> / 32];
03022         }
03023 
03024         <span class="comment">//</span>
03025         <span class="comment">//  Now we can skip over any clean pages.</span>
03026         <span class="comment">//</span>
03027 
03028         <span class="keywordflow">if</span> (FirstDirtyPage &lt; (BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o1">BasePage</a> + BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o2">FirstDirtyPage</a>)) {
03029             FirstDirtyPage = BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o1">BasePage</a> + BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o2">FirstDirtyPage</a>;
03030         }
03031 
03032         <span class="comment">//</span>
03033         <span class="comment">//  Form a few other inputs for our dirty page scan.</span>
03034         <span class="comment">//</span>
03035 
03036         MaskPtr = &amp;BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o5">Bitmap</a>[(ULONG)(FirstDirtyPage - BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o1">BasePage</a>) / 32];
03037         Mask = (ULONG)(-1 &lt;&lt; (FirstDirtyPage % 32));
03038         OriginalFirstDirtyPage = (ULONG)(FirstDirtyPage - BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o1">BasePage</a>);
03039 
03040         <span class="comment">//</span>
03041         <span class="comment">//  Because of the possibility of getting stuck on a "hot spot" which gets</span>
03042         <span class="comment">//  modified over and over, we want to be very careful to resume exactly</span>
03043         <span class="comment">//  at the recorded resume point.  If there is nothing there, then we</span>
03044         <span class="comment">//  fall into the loop below to scan for nozero long words in the bitmap,</span>
03045         <span class="comment">//  starting at the next longword.</span>
03046         <span class="comment">//</span>
03047 
03048         <span class="keywordflow">if</span> ((*MaskPtr &amp; Mask) == 0) {
03049 
03050             <span class="comment">//</span>
03051             <span class="comment">//  Before entering loop, set all mask bits and insure we increment from</span>
03052             <span class="comment">//  an even Ulong boundary.</span>
03053             <span class="comment">//</span>
03054 
03055             Mask = MAXULONG;
03056             FirstDirtyPage &amp;= ~31;
03057 
03058             <span class="comment">//</span>
03059             <span class="comment">//  To scan the bitmap faster, we scan for entire long words which are</span>
03060             <span class="comment">//  nonzero.</span>
03061             <span class="comment">//</span>
03062 
03063             <span class="keywordflow">do</span> {
03064 
03065                 MaskPtr += 1;
03066                 FirstDirtyPage += 32;
03067 
03068                 <span class="comment">//</span>
03069                 <span class="comment">//  If we go beyond the end, then we must wrap back to the first</span>
03070                 <span class="comment">//  dirty page.  We will just go back to the start of the first</span>
03071                 <span class="comment">//  longword.</span>
03072                 <span class="comment">//</span>
03073 
03074                 <span class="keywordflow">if</span> (MaskPtr &gt; EndPtr) {
03075 
03076                     <span class="comment">//</span>
03077                     <span class="comment">//  We can backup the last dirty page hint to where we</span>
03078                     <span class="comment">//  started scanning, if we are the lazy writer.</span>
03079                     <span class="comment">//</span>
03080 
03081                     <span class="keywordflow">if</span> (TargetLength == 0) {
03082                         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(OriginalFirstDirtyPage &gt;= BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o2">FirstDirtyPage</a>);
03083                         BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o3">LastDirtyPage</a> = OriginalFirstDirtyPage - 1;
03084                     }
03085 
03086                     <span class="comment">//</span>
03087                     <span class="comment">//  We hit the end of our scan.  Let's assume we are supposed</span>
03088                     <span class="comment">//  to move on to the next range with dirty pages.</span>
03089                     <span class="comment">//</span>
03090 
03091                     <span class="keywordflow">do</span> {
03092 
03093                         <span class="comment">//</span>
03094                         <span class="comment">//  Go to the next range.</span>
03095                         <span class="comment">//</span>
03096 
03097                         BitmapRange = (<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html">PBITMAP_RANGE</a>)BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o0">Links</a>.Flink;
03098 
03099                         <span class="comment">//</span>
03100                         <span class="comment">//  Did we hit the listhead?</span>
03101                         <span class="comment">//</span>
03102 
03103                         <span class="keywordflow">if</span> (BitmapRange == (<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html">PBITMAP_RANGE</a>)&amp;Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o5">BitmapRanges</a>) {
03104 
03105                             <span class="comment">//</span>
03106                             <span class="comment">//  If this is an explicit flush, then it is time to</span>
03107                             <span class="comment">//  get out.</span>
03108                             <span class="comment">//</span>
03109 
03110                             <span class="keywordflow">if</span> (TargetLength != 0) {
03111                                 <span class="keywordflow">goto</span> Scan_Bcbs;
03112                             }
03113 
03114                             <span class="comment">//</span>
03115                             <span class="comment">//  Otherwise, we must wrap back to the first range in the</span>
03116                             <span class="comment">//  Lazy Writer Scan.</span>
03117                             <span class="comment">//</span>
03118 
03119                             BitmapRange = (<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html">PBITMAP_RANGE</a>)BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o0">Links</a>.Flink;
03120                         }
03121 
03122                     } <span class="keywordflow">while</span> (BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o4">DirtyPages</a> == 0);
03123 
03124                     <span class="comment">//</span>
03125                     <span class="comment">//  Now we have a new range with dirty pages, but if this is</span>
03126                     <span class="comment">//  an explicit flush of a specified range, we may be done.</span>
03127                     <span class="comment">//</span>
03128 
03129                     <span class="keywordflow">if</span> ((LastDirtyPage &lt; (BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o1">BasePage</a> + BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o2">FirstDirtyPage</a>)) ||
03130                         (FirstDirtyPage &gt; (BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o1">BasePage</a> + BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o3">LastDirtyPage</a>))) {
03131 
03132                         <span class="keywordflow">goto</span> Scan_Bcbs;
03133                     }
03134 
03135                     <span class="comment">//</span>
03136                     <span class="comment">//  Otherwise, we need to set up our context to resume scanning in this</span>
03137                     <span class="comment">//  range.</span>
03138                     <span class="comment">//</span>
03139 
03140                     MaskPtr = &amp;BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o5">Bitmap</a>[BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o2">FirstDirtyPage</a> / 32];
03141                     EndPtr = &amp;BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o5">Bitmap</a>[BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o3">LastDirtyPage</a> / 32];
03142                     FirstDirtyPage = BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o1">BasePage</a> + (BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o2">FirstDirtyPage</a> &amp; ~31);
03143                     OriginalFirstDirtyPage = BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o2">FirstDirtyPage</a>;
03144                 }
03145             } <span class="keywordflow">while</span> (*MaskPtr == 0);
03146         }
03147 
03148         <span class="comment">//</span>
03149         <span class="comment">//  Calculate the first set bit in the mask that we hit on.</span>
03150         <span class="comment">//</span>
03151 
03152         Mask = ~Mask + 1;
03153 
03154         <span class="comment">//</span>
03155         <span class="comment">//  Now loop to find the first set bit.</span>
03156         <span class="comment">//</span>
03157 
03158         <span class="keywordflow">while</span> ((*MaskPtr &amp; Mask) == 0) {
03159 
03160             Mask &lt;&lt;= 1;
03161             FirstDirtyPage += 1;
03162         }
03163 
03164         <span class="comment">//</span>
03165         <span class="comment">//  If a TargetOffset was specified, then make sure we do not start</span>
03166         <span class="comment">//  beyond the specified range or a dirty Bcb in the range.</span>
03167         <span class="comment">//</span>
03168 
03169         <span class="keywordflow">if</span> (ARGUMENT_PRESENT(TargetOffset)) {
03170 
03171             <span class="keywordflow">if</span> (FirstDirtyPage &gt;= ((TargetOffset-&gt;QuadPart + TargetLength + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1) &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>)) {
03172 
03173                 <span class="keywordflow">goto</span> Scan_Bcbs;
03174             }
03175 
03176             <span class="comment">//</span>
03177             <span class="comment">//  If Bcbs are present on this file, we must go scan to see if they</span>
03178             <span class="comment">//  describe a range that must be written first.  If this is not the</span>
03179             <span class="comment">//  case, we'll hop back and continue building the range from the mask Bcb.</span>
03180             <span class="comment">//</span>
03181             <span class="comment">//  Note that this case will be very rare.  Bcbs are introduced into user</span>
03182             <span class="comment">//  files in limited situations (CcZero) and the reverse is never allowed</span>
03183             <span class="comment">//  to happen.</span>
03184             <span class="comment">//</span>
03185 
03186             <span class="keywordflow">if</span> (!IsListEmpty(&amp;SharedCacheMap-&gt;BcbList)) {
03187 
03188                 BcbLookasideCheck = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03189                 <span class="keywordflow">goto</span> Scan_Bcbs;
03190             }
03191         }
03192 
03193 Accept_Page:
03194 
03195         <span class="comment">//</span>
03196         <span class="comment">//  Now loop to count the set bits at that point, clearing them as we</span>
03197         <span class="comment">//  go because we plan to write the corresponding pages.  Stop as soon</span>
03198         <span class="comment">//  as we find a clean page, or we reach our maximum write size.  Of</span>
03199         <span class="comment">//  course we want to ignore long word boundaries and keep trying to</span>
03200         <span class="comment">//  extend the write.  We do not check for wrapping around the end of</span>
03201         <span class="comment">//  the bitmap here, because we guarantee some zero bits at the end</span>
03202         <span class="comment">//  in CcSetDirtyInMask.</span>
03203         <span class="comment">//</span>
03204 
03205         <span class="keywordflow">while</span> (((*MaskPtr &amp; Mask) != 0) &amp;&amp; (*Length &lt; (<a class="code" href="../../d5/d5/cc_8h.html#a33">MAX_WRITE_BEHIND</a> / <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>)) &amp;&amp;
03206                (!ARGUMENT_PRESENT(TargetOffset) || ((FirstDirtyPage + *Length) &lt;
03207                                                     (ULONG)((TargetOffset-&gt;QuadPart + TargetLength + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1) &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>)))) {
03208 
03209             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(MaskPtr &lt;= (&amp;BitmapRange-&gt;Bitmap[BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o3">LastDirtyPage</a> / 32]));
03210 
03211             *MaskPtr -= Mask;
03212             *Length += 1;
03213             Mask &lt;&lt;= 1;
03214 
03215             <span class="keywordflow">if</span> (Mask == 0) {
03216 
03217                 MaskPtr += 1;
03218                 Mask = 1;
03219 
03220                 <span class="keywordflow">if</span> (MaskPtr &gt; EndPtr) {
03221                     <span class="keywordflow">break</span>;
03222                 }
03223             }
03224         }
03225 
03226         <span class="comment">//</span>
03227         <span class="comment">//  Now reduce the count of pages we were supposed to write this time,</span>
03228         <span class="comment">//  possibly clearing this count.</span>
03229         <span class="comment">//</span>
03230 
03231         <span class="keywordflow">if</span> (*Length &lt; Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o2">PagesToWrite</a>) {
03232 
03233             Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o2">PagesToWrite</a> -= *Length;
03234 
03235         } <span class="keywordflow">else</span> {
03236 
03237             Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o2">PagesToWrite</a> = 0;
03238         }
03239 
03240         <span class="comment">//</span>
03241         <span class="comment">//  Reduce the dirty page counts by the number of pages we just cleared.</span>
03242         <span class="comment">//</span>
03243 
03244         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o3">DirtyPages</a> &gt;= *Length);
03245         Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o3">DirtyPages</a> -= *Length;
03246         BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o4">DirtyPages</a> -= *Length;
03247 
03248         <a class="code" href="../../d5/d5/cc_8h.html#a2">CcAcquireMasterLockAtDpcLevel</a>();
03249         <a class="code" href="../../d5/d2/cachedat_8c.html#a36">CcTotalDirtyPages</a> -= *Length;
03250         SharedCacheMap-&gt;DirtyPages -= *Length;
03251 
03252         <span class="comment">//</span>
03253         <span class="comment">//  Normally we need to reduce CcPagesYetToWrite appropriately.</span>
03254         <span class="comment">//</span>
03255 
03256         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d2/cachedat_8c.html#a32">CcPagesYetToWrite</a> &gt; *Length) {
03257             <a class="code" href="../../d5/d2/cachedat_8c.html#a32">CcPagesYetToWrite</a> -= *Length;
03258         } <span class="keywordflow">else</span> {
03259             <a class="code" href="../../d5/d2/cachedat_8c.html#a32">CcPagesYetToWrite</a> = 0;
03260         }
03261 
03262         <span class="comment">//</span>
03263         <span class="comment">//  If we took out the last dirty page, then move the SharedCacheMap</span>
03264         <span class="comment">//  back to the clean list.</span>
03265         <span class="comment">//</span>
03266 
03267         <span class="keywordflow">if</span> (SharedCacheMap-&gt;DirtyPages == 0) {
03268 
03269             RemoveEntryList( &amp;SharedCacheMap-&gt;SharedCacheMapLinks );
03270             InsertTailList( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a1">CcCleanSharedCacheMapList</a>,
03271                             &amp;SharedCacheMap-&gt;SharedCacheMapLinks );
03272         }
03273         <a class="code" href="../../d5/d5/cc_8h.html#a3">CcReleaseMasterLockFromDpcLevel</a>();
03274 
03275         <span class="comment">//</span>
03276         <span class="comment">//  If the number of dirty pages for the Mbcb went to zero, we can reset</span>
03277         <span class="comment">//  our hint fields now.</span>
03278         <span class="comment">//</span>
03279 
03280         <span class="keywordflow">if</span> (BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o4">DirtyPages</a> == 0) {
03281 
03282             BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o2">FirstDirtyPage</a> = MAXULONG;
03283             BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o3">LastDirtyPage</a> = 0;
03284 
03285             <span class="comment">//</span>
03286             <span class="comment">//  Assume this is a large file and that the resume point should</span>
03287             <span class="comment">//  be at the beginning of the next range.  In all cases if the resume</span>
03288             <span class="comment">//  point is set too high, the next resume will just wrap back to 0 anyway.</span>
03289             <span class="comment">//</span>
03290 
03291             Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o6">ResumeWritePage</a> = BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o1">BasePage</a> + (<a class="code" href="../../d5/d5/cc_8h.html#a43">MBCB_BITMAP_BLOCK_SIZE</a> * 8);
03292 
03293         <span class="comment">//</span>
03294         <span class="comment">//  Otherwise we have to update the hint fields.</span>
03295         <span class="comment">//</span>
03296 
03297         } <span class="keywordflow">else</span> {
03298 
03299             <span class="comment">//</span>
03300             <span class="comment">//  Advance the first dirty page hint if we can.</span>
03301             <span class="comment">//</span>
03302 
03303             <span class="keywordflow">if</span> (BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o2">FirstDirtyPage</a> == OriginalFirstDirtyPage) {
03304 
03305                 BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o2">FirstDirtyPage</a> = (ULONG)(FirstDirtyPage - BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o1">BasePage</a>) + *Length;
03306             }
03307 
03308             <span class="comment">//</span>
03309             <span class="comment">//  Set to resume the next scan at the next bit for</span>
03310             <span class="comment">//  the Lazy Writer.</span>
03311             <span class="comment">//</span>
03312 
03313             <span class="keywordflow">if</span> (TargetLength == 0) {
03314 
03315                 Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o6">ResumeWritePage</a> = FirstDirtyPage + *Length;
03316             }
03317         }
03318 
03319         <span class="comment">//</span>
03320         <span class="comment">//  We can save a callback by letting our caller know when</span>
03321         <span class="comment">//  we have no more pages to write.</span>
03322         <span class="comment">//</span>
03323 
03324         <span class="keywordflow">if</span> (IsListEmpty(&amp;SharedCacheMap-&gt;BcbList)) {
03325             SharedCacheMap-&gt;PagesToWrite = Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o2">PagesToWrite</a>;
03326         }
03327 
03328         ExReleaseSpinLock( &amp;SharedCacheMap-&gt;BcbSpinLock, OldIrql );
03329 
03330         <span class="comment">//</span>
03331         <span class="comment">//  Now form all of our outputs.  We calculated *Length as a page count,</span>
03332         <span class="comment">//  but our caller wants it in bytes.</span>
03333         <span class="comment">//</span>
03334 
03335         *Length &lt;&lt;= <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
03336         FileOffset-&gt;QuadPart = (LONGLONG)FirstDirtyPage &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
03337         *FirstBcb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03338 
03339         <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>(0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    &lt;FileOffset = %08lx, %08lx\n"</span>, FileOffset-&gt;LowPart,
03340                                                                FileOffset-&gt;HighPart );
03341         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    &lt;Length = %08lx\n"</span>, *Length );
03342         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcAcquireByteRangeForWrite -&gt; TRUE\n"</span>, 0 );
03343 
03344         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03345     }
03346 
03347     <span class="comment">//</span>
03348     <span class="comment">//  We get here if there is no Mbcb or no dirty pages in it.  Note that we</span>
03349     <span class="comment">//  wouldn't even be here if there were no dirty pages in this SharedCacheMap.</span>
03350     <span class="comment">//</span>
03351 
03352     <span class="comment">//</span>
03353     <span class="comment">//  Now point to last Bcb in List, and loop until we hit one of the</span>
03354     <span class="comment">//  breaks below or the beginning of the list.</span>
03355     <span class="comment">//</span>
03356 
03357 Scan_Bcbs:
03358 
03359     <span class="comment">//</span>
03360     <span class="comment">//  Use while TRUE to handle case where the current target range wraps</span>
03361     <span class="comment">//  (escape is at the bottom).</span>
03362     <span class="comment">//</span>
03363 
03364     <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
03365 
03366         Bcb = CONTAINING_RECORD( SharedCacheMap-&gt;BcbList.Blink, <a class="code" href="../../d4/d3/struct__BCB.html">BCB</a>, BcbLinks );
03367 
03368         <span class="comment">//</span>
03369         <span class="comment">//  If we are to resume from a nonzero FileOffset, call CcFindBcb</span>
03370         <span class="comment">//  to get a quicker start.  This is only useful on files that make</span>
03371         <span class="comment">//  use of significant pinned access, of course.</span>
03372         <span class="comment">//</span>
03373 
03374         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;Flags, <a class="code" href="../../d5/d5/cc_8h.html#a78">MODIFIED_WRITE_DISABLED</a>)) {
03375 
03376             PLARGE_INTEGER StartingOffset;
03377 
03378             <span class="keywordflow">if</span> (ARGUMENT_PRESENT(TargetOffset)) {
03379                 StartingOffset = TargetOffset;
03380             } <span class="keywordflow">else</span> {
03381                 StartingOffset = (PLARGE_INTEGER)&amp;SharedCacheMap-&gt;BeyondLastFlush;
03382             }
03383 
03384             <span class="keywordflow">if</span> (StartingOffset-&gt;QuadPart != 0) {
03385 
03386                 LARGE_INTEGER StartingOffsetBias;
03387 
03388                 StartingOffsetBias.QuadPart = StartingOffset-&gt;QuadPart + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
03389 
03390                 <span class="comment">//</span>
03391                 <span class="comment">//  Position ourselves.  If we did not find a Bcb for the page, then</span>
03392                 <span class="comment">//  a lower FileOffset was returned, so we want to move forward one.</span>
03393                 <span class="comment">//</span>
03394 
03395                 <span class="keywordflow">if</span> (!<a class="code" href="../../d6/d2/cachesub_8c.html#a4">CcFindBcb</a>( SharedCacheMap,
03396                                 StartingOffset,
03397                                 &amp;StartingOffsetBias,
03398                                 &amp;Bcb )) {
03399                     Bcb = CONTAINING_RECORD( Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o4">BcbLinks</a>.Blink, <a class="code" href="../../d4/d3/struct__BCB.html">BCB</a>, BcbLinks );
03400                 }
03401             }
03402         }
03403 
03404         <span class="keywordflow">while</span> (&amp;Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o4">BcbLinks</a> != &amp;SharedCacheMap-&gt;BcbList) {
03405 
03406             <span class="comment">//</span>
03407             <span class="comment">//  Skip over this item if it is a listhead.</span>
03408             <span class="comment">//</span>
03409 
03410             <span class="keywordflow">if</span> (Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o0">NodeTypeCode</a> != <a class="code" href="../../d5/d5/cc_8h.html#a14">CACHE_NTC_BCB</a>) {
03411 
03412                 Bcb = CONTAINING_RECORD( Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o4">BcbLinks</a>.Blink, <a class="code" href="../../d4/d3/struct__BCB.html">BCB</a>, BcbLinks );
03413                 <span class="keywordflow">continue</span>;
03414             }
03415 
03416             <span class="comment">//</span>
03417             <span class="comment">//  If we are doing a specified range, then get out if we hit a</span>
03418             <span class="comment">//  higher Bcb.</span>
03419             <span class="comment">//</span>
03420 
03421             <span class="keywordflow">if</span> (ARGUMENT_PRESENT(TargetOffset) &amp;&amp;
03422                 ((TargetOffset-&gt;QuadPart + TargetLength) &lt;= Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o3">FileOffset</a>.QuadPart)) {
03423 
03424                 <span class="keywordflow">break</span>;
03425             }
03426 
03427             <span class="comment">//</span>
03428             <span class="comment">//  If we have not started a run, then see if this Bcb is a candidate</span>
03429             <span class="comment">//  to start one.</span>
03430             <span class="comment">//</span>
03431 
03432             <span class="keywordflow">if</span> (*Length == 0) {
03433 
03434                 <span class="comment">//</span>
03435                 <span class="comment">//  Else see if the Bcb is dirty, and is in our specified range, if</span>
03436                 <span class="comment">//  there is one.</span>
03437                 <span class="comment">//</span>
03438 
03439                 <span class="keywordflow">if</span> (!Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o13">Dirty</a> ||
03440                     (ARGUMENT_PRESENT(TargetOffset) &amp;&amp; (TargetOffset-&gt;QuadPart &gt;= Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o5">BeyondLastByte</a>.QuadPart)) ||
03441                     (!ARGUMENT_PRESENT(TargetOffset) &amp;&amp; (Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o3">FileOffset</a>.QuadPart &lt; SharedCacheMap-&gt;BeyondLastFlush))) {
03442 
03443                     Bcb = CONTAINING_RECORD( Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o4">BcbLinks</a>.Blink, <a class="code" href="../../d4/d3/struct__BCB.html">BCB</a>, BcbLinks );
03444                     <span class="keywordflow">continue</span>;
03445 
03446                 }
03447 
03448                 <span class="comment">//</span>
03449                 <span class="comment">//  If we have a candidate dirty page from the mask Bcb, see</span>
03450                 <span class="comment">//  if it describes a prior range.  We must decide to return</span>
03451                 <span class="comment">//  the first dirty range.</span>
03452                 <span class="comment">//</span>
03453 
03454                 <span class="keywordflow">if</span> (BcbLookasideCheck &amp;&amp; FirstDirtyPage &lt;= (ULONG)(Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o3">FileOffset</a>.QuadPart &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>)) {
03455                     <span class="keywordflow">goto</span> Accept_Page;
03456                 }
03457             }
03458 
03459             <span class="comment">//</span>
03460             <span class="comment">//  Else, if we have started a run, then if this guy cannot be</span>
03461             <span class="comment">//  appended to the run, then break.  Note that we ignore the</span>
03462             <span class="comment">//  Bcb's modification time stamp here to simplify the test.</span>
03463             <span class="comment">//</span>
03464             <span class="comment">//  If the Bcb is currently pinned, then there is no sense in causing</span>
03465             <span class="comment">//  contention, so we will skip over this guy as well.</span>
03466             <span class="comment">//</span>
03467             <span class="comment">//  Finally, if the new Bcb is in the next Vacb level, we will skip it</span>
03468             <span class="comment">//  to avoid problems with Bcb listheads going away in the middle of</span>
03469             <span class="comment">//  CcReleaseByteRangeFromWrite.</span>
03470             <span class="comment">//</span>
03471 
03472             <span class="keywordflow">else</span> {
03473                 <span class="keywordflow">if</span> (!Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o13">Dirty</a> || ( Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o3">FileOffset</a>.QuadPart != ( FileOffset-&gt;QuadPart + (LONGLONG)*Length)) ||
03474                     (*Length + Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o2">ByteLength</a> &gt; <a class="code" href="../../d5/d5/cc_8h.html#a33">MAX_WRITE_BEHIND</a>) ||
03475                     (Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o9">PinCount</a> != 0) ||
03476                     ((Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o3">FileOffset</a>.QuadPart &amp; (<a class="code" href="../../d5/d5/cc_8h.html#a41">VACB_SIZE_OF_FIRST_LEVEL</a> - 1)) == 0)) {
03477 
03478                     <span class="keywordflow">break</span>;
03479                 }
03480             }
03481 
03482             <span class="comment">//</span>
03483             <span class="comment">//  Increment PinCount to prevent Bcb from going away once the</span>
03484             <span class="comment">//  SpinLock is released, or we set it clean for the case where</span>
03485             <span class="comment">//  modified write is allowed.</span>
03486             <span class="comment">//</span>
03487 
03488             Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o9">PinCount</a> += 1;
03489 
03490             <span class="comment">//</span>
03491             <span class="comment">//  Release the SpinLock before waiting on the resource.</span>
03492             <span class="comment">//</span>
03493 
03494             ExReleaseSpinLock( &amp;SharedCacheMap-&gt;BcbSpinLock, OldIrql );
03495 
03496             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;Flags, <a class="code" href="../../d5/d5/cc_8h.html#a78">MODIFIED_WRITE_DISABLED</a>) &amp;&amp;
03497                 !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;Flags, <a class="code" href="../../d5/d5/cc_8h.html#a71">DISABLE_WRITE_BEHIND</a>)) {
03498 
03499                 <span class="comment">//</span>
03500                 <span class="comment">//  Now acquire the Bcb exclusive, so that we know that nobody</span>
03501                 <span class="comment">//  has it pinned and thus no one can be modifying the described</span>
03502                 <span class="comment">//  buffer.  To acquire the first Bcb in a run, we can afford</span>
03503                 <span class="comment">//  to wait, because we are not holding any resources.  However</span>
03504                 <span class="comment">//  if we already have a Bcb, then we better not wait, because</span>
03505                 <span class="comment">//  someone could have this Bcb pinned, and then wait for the</span>
03506                 <span class="comment">//  Bcb we already have exclusive.</span>
03507                 <span class="comment">//</span>
03508                 <span class="comment">//  For streams for which we have not disabled modified page</span>
03509                 <span class="comment">//  writing, we do not need to acquire this resource, and the</span>
03510                 <span class="comment">//  foreground processing will not be acquiring the Bcb either.</span>
03511                 <span class="comment">//</span>
03512 
03513                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d8/ex_8h.html#a70">ExAcquireResourceExclusive</a>( &amp;Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o10">Resource</a>,
03514                                                  (BOOLEAN)(*Length == 0) )) {
03515 
03516                     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"Could not acquire 2nd Bcb\n"</span>, 0 );
03517 
03518                     <span class="comment">//</span>
03519                     <span class="comment">//  Release the Bcb count we took out above.  We say</span>
03520                     <span class="comment">//  ReadOnly = TRUE since we do not own the resource,</span>
03521                     <span class="comment">//  and SetClean = FALSE because we just want to decement</span>
03522                     <span class="comment">//  the count.</span>
03523                     <span class="comment">//</span>
03524 
03525                     <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( Bcb, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, <a class="code" href="../../d5/d5/cc_8h.html#a211a171">UNPIN</a> );
03526 
03527                     <span class="comment">//</span>
03528                     <span class="comment">//  When we leave the loop, we have to have the spin lock</span>
03529                     <span class="comment">//</span>
03530 
03531                     ExAcquireSpinLock( &amp;SharedCacheMap-&gt;BcbSpinLock, &amp;OldIrql );
03532                     <span class="keywordflow">break</span>;
03533                 }
03534 
03535                 ExAcquireSpinLock( &amp;SharedCacheMap-&gt;BcbSpinLock, &amp;OldIrql );
03536 
03537                 <span class="comment">//</span>
03538                 <span class="comment">//  If someone has the file open WriteThrough, then the Bcb may no</span>
03539                 <span class="comment">//  longer be dirty.  If so, call CcUnpinFileData to decrement the</span>
03540                 <span class="comment">//  PinCount we incremented and free the resource.</span>
03541                 <span class="comment">//</span>
03542 
03543                 <span class="keywordflow">if</span> (!Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o13">Dirty</a>) {
03544 
03545                     <span class="comment">//</span>
03546                     <span class="comment">//  Release the spinlock so that we can call CcUnpinFileData</span>
03547                     <span class="comment">//</span>
03548 
03549                     ExReleaseSpinLock( &amp;SharedCacheMap-&gt;BcbSpinLock, OldIrql );
03550 
03551                     <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( Bcb, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, <a class="code" href="../../d5/d5/cc_8h.html#a211a171">UNPIN</a> );
03552 
03553                     ExAcquireSpinLock( &amp;SharedCacheMap-&gt;BcbSpinLock, &amp;OldIrql );
03554 
03555                     <span class="comment">//</span>
03556                     <span class="comment">//  Now if we already have some data we can just break to return</span>
03557                     <span class="comment">//  it, otherwise we have to restart the scan, since our Bcb</span>
03558                     <span class="comment">//  may have gone away.</span>
03559                     <span class="comment">//</span>
03560 
03561                     <span class="keywordflow">if</span> (*Length != 0) {
03562                         <span class="keywordflow">break</span>;
03563                     }
03564                     <span class="keywordflow">else</span> {
03565 
03566                         Bcb = CONTAINING_RECORD( SharedCacheMap-&gt;BcbList.Blink, <a class="code" href="../../d4/d3/struct__BCB.html">BCB</a>, BcbLinks );
03567                         <span class="keywordflow">continue</span>;
03568                     }
03569                 }
03570 
03571             <span class="comment">//</span>
03572             <span class="comment">//  If we are not in the disable modified write mode (normal user data)</span>
03573             <span class="comment">//  then we must set the buffer clean before doing the write, since we</span>
03574             <span class="comment">//  are unsynchronized with anyone producing dirty data.  That way if we,</span>
03575             <span class="comment">//  for example, are writing data out while it is actively being changed,</span>
03576             <span class="comment">//  at least the changer will mark the buffer dirty afterwards and cause</span>
03577             <span class="comment">//  us to write it again later.</span>
03578             <span class="comment">//</span>
03579 
03580             } <span class="keywordflow">else</span> {
03581 
03582                 <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( Bcb, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, <a class="code" href="../../d5/d5/cc_8h.html#a211a173">SET_CLEAN</a> );
03583 
03584                 ExAcquireSpinLock( &amp;SharedCacheMap-&gt;BcbSpinLock, &amp;OldIrql );
03585             }
03586 
03587             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"Adding Bcb = %08lx to run\n"</span>, Bcb );
03588 
03589             <span class="comment">//</span>
03590             <span class="comment">//  No matter what, once we've reached this point we are returning</span>
03591             <span class="comment">//  a range from the Bcbs.</span>
03592             <span class="comment">//</span>
03593 
03594             BcbLookasideCheck = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03595 
03596             <span class="comment">//</span>
03597             <span class="comment">//  Update all of our return values.  Note that FirstBcb refers to the</span>
03598             <span class="comment">//  FirstBcb in terms of how the Bcb list is ordered.  Since the Bcb list</span>
03599             <span class="comment">//  is ordered by descending file offsets, FirstBcb will actually return</span>
03600             <span class="comment">//  the Bcb with the highest FileOffset.</span>
03601             <span class="comment">//</span>
03602 
03603             <span class="keywordflow">if</span> (*Length == 0) {
03604                 *FileOffset = Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o3">FileOffset</a>;
03605             }
03606             *FirstBcb = Bcb;
03607             *Length += Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o2">ByteLength</a>;
03608 
03609             <span class="comment">//</span>
03610             <span class="comment">//  If there is a log file flush callback for this stream, then we must</span>
03611             <span class="comment">//  remember the largest Lsn we are about to flush.</span>
03612             <span class="comment">//</span>
03613 
03614             <span class="keywordflow">if</span> ((SharedCacheMap-&gt;FlushToLsnRoutine != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
03615                 (Bcb-&gt;NewestLsn.QuadPart &gt; LsnToFlushTo.QuadPart)) {
03616 
03617                 LsnToFlushTo = Bcb-&gt;NewestLsn;
03618             }
03619 
03620             Bcb = CONTAINING_RECORD( Bcb-&gt;BcbLinks.Blink, <a class="code" href="../../d4/d3/struct__BCB.html">BCB</a>, BcbLinks );
03621         }
03622 
03623         <span class="comment">//</span>
03624         <span class="comment">//  If we have a candidate dirty page from the mask Bcb, accept it</span>
03625         <span class="comment">//  since no Bcb has been found.</span>
03626         <span class="comment">//</span>
03627 
03628         <span class="keywordflow">if</span> (BcbLookasideCheck) {
03629 
03630             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( *Length == 0 );
03631             <span class="keywordflow">goto</span> Accept_Page;
03632         }
03633 
03634         <span class="comment">//</span>
03635         <span class="comment">//  If we found something, update our last flush range and reduce</span>
03636         <span class="comment">//  PagesToWrite.</span>
03637         <span class="comment">//</span>
03638 
03639         <span class="keywordflow">if</span> (*Length != 0) {
03640 
03641             <span class="comment">//</span>
03642             <span class="comment">//  If this is the Lazy Writer, then update BeyondLastFlush and</span>
03643             <span class="comment">//  the PagesToWrite target.</span>
03644             <span class="comment">//</span>
03645 
03646             <span class="keywordflow">if</span> (!ARGUMENT_PRESENT(TargetOffset)) {
03647 
03648                 SharedCacheMap-&gt;BeyondLastFlush = FileOffset-&gt;QuadPart + *Length;
03649 
03650                 <span class="keywordflow">if</span> (SharedCacheMap-&gt;PagesToWrite &gt; (*Length &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>)) {
03651                     SharedCacheMap-&gt;PagesToWrite -= (*Length &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
03652                 } <span class="keywordflow">else</span> {
03653                     SharedCacheMap-&gt;PagesToWrite = 0;
03654                 }
03655             }
03656 
03657             <span class="keywordflow">break</span>;
03658 
03659         <span class="comment">//</span>
03660         <span class="comment">//  Else, if we scanned the entire file, get out - nothing to write now.</span>
03661         <span class="comment">//</span>
03662 
03663         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((SharedCacheMap-&gt;BeyondLastFlush == 0) || ARGUMENT_PRESENT(TargetOffset)) {
03664             <span class="keywordflow">break</span>;
03665         }
03666 
03667         <span class="comment">//</span>
03668         <span class="comment">//  Otherwise, we may have not found anything because there is nothing</span>
03669         <span class="comment">//  beyond the last flush.  In that case it is time to wrap back to 0</span>
03670         <span class="comment">//  and keep scanning.</span>
03671         <span class="comment">//</span>
03672 
03673         SharedCacheMap-&gt;BeyondLastFlush = 0;
03674     }
03675 
03676 
03677 
03678     <span class="comment">//</span>
03679     <span class="comment">//  Now release the spinlock file while we go off and do the I/O</span>
03680     <span class="comment">//</span>
03681 
03682     ExReleaseSpinLock( &amp;SharedCacheMap-&gt;BcbSpinLock, OldIrql );
03683 
03684     <span class="comment">//</span>
03685     <span class="comment">//  If we need to flush to some Lsn, this is the time to do it now</span>
03686     <span class="comment">//  that we have found the largest Lsn and freed the spin lock.</span>
03687     <span class="comment">//</span>
03688 
03689     <span class="keywordflow">if</span> (LsnToFlushTo.QuadPart != 0) {
03690 
03691         <span class="keywordflow">try</span> {
03692 
03693             (*SharedCacheMap-&gt;FlushToLsnRoutine) ( SharedCacheMap-&gt;LogHandle,
03694                                                    LsnToFlushTo );
03695         } except( <a class="code" href="../../d5/d1/lazyrite_8c.html#a7">CcExceptionFilter</a>( GetExceptionCode() )) {
03696 
03697             <span class="comment">//</span>
03698             <span class="comment">//  If there was an error, it will be raised.  We cannot</span>
03699             <span class="comment">//  write anything until we successfully flush the log</span>
03700             <span class="comment">//  file, so we will release everything here and just</span>
03701             <span class="comment">//  return with 0 bytes.</span>
03702             <span class="comment">//</span>
03703 
03704             LARGE_INTEGER LastOffset;
03705             <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> NextBcb;
03706 
03707             <span class="comment">//</span>
03708             <span class="comment">//  Now loop to free up all of the Bcbs.  Set the time</span>
03709             <span class="comment">//  stamps to 0, so that we are guaranteed to try to</span>
03710             <span class="comment">//  flush them again on the next sweep.</span>
03711             <span class="comment">//</span>
03712 
03713             <span class="keywordflow">do</span> {
03714                 NextBcb = CONTAINING_RECORD( (*FirstBcb)-&gt;BcbLinks.Flink, <a class="code" href="../../d4/d3/struct__BCB.html">BCB</a>, BcbLinks );
03715 
03716                 <span class="comment">//</span>
03717                 <span class="comment">//  Skip over any listheads.</span>
03718                 <span class="comment">//</span>
03719 
03720                 <span class="keywordflow">if</span> ((*FirstBcb)-&gt;NodeTypeCode == <a class="code" href="../../d5/d5/cc_8h.html#a14">CACHE_NTC_BCB</a>) {
03721 
03722                     LastOffset = (*FirstBcb)-&gt;FileOffset;
03723 
03724                     <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( *FirstBcb,
03725                                      <a class="code" href="../../d5/d5/cc_8h.html#a59">BooleanFlagOn</a>(SharedCacheMap-&gt;Flags, <a class="code" href="../../d5/d5/cc_8h.html#a71">DISABLE_WRITE_BEHIND</a>),
03726                                      <a class="code" href="../../d5/d5/cc_8h.html#a211a171">UNPIN</a> );
03727                 }
03728 
03729                 *FirstBcb = NextBcb;
03730             } <span class="keywordflow">while</span> (FileOffset-&gt;QuadPart != LastOffset.QuadPart);
03731 
03732             <span class="comment">//</span>
03733             <span class="comment">//  Show we did not acquire anything.</span>
03734             <span class="comment">//</span>
03735 
03736             *Length = 0;
03737         }
03738     }
03739 
03740     <span class="comment">//</span>
03741     <span class="comment">//  If we got anything, return TRUE.</span>
03742     <span class="comment">//</span>
03743 
03744     <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>(0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    &lt;FileOffset = %08lx, %08lx\n"</span>, FileOffset-&gt;LowPart,
03745                                                            FileOffset-&gt;HighPart );
03746     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    &lt;Length = %08lx\n"</span>, *Length );
03747     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcAcquireByteRangeForWrite -&gt; %02lx\n"</span>, *Length != 0 );
03748 
03749     <span class="keywordflow">return</span> ((BOOLEAN)(*Length != 0));
03750 }
03751 
03752 
03753 <span class="comment">//</span>
03754 <span class="comment">//  Internal Support Routine</span>
03755 <span class="comment">//</span>
03756 
03757 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l03758"></a><a class="code" href="../../d6/d2/cachesub_8c.html#a8">03758</a> <a class="code" href="../../d6/d2/cachesub_8c.html#a8">CcReleaseByteRangeFromWrite</a> (
03759     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap,
03760     IN PLARGE_INTEGER FileOffset,
03761     IN ULONG Length,
03762     IN <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> FirstBcb,
03763     IN BOOLEAN VerifyRequired
03764     )
03765 
03766 <span class="comment">/*++</span>
03767 <span class="comment"></span>
03768 <span class="comment">Routine Description:</span>
03769 <span class="comment"></span>
03770 <span class="comment">    This routine is called by the Lazy Writer to free a range of bytes and</span>
03771 <span class="comment">    clear all dirty bits, for a byte range returned by CcAcquireByteRangeForWrite.</span>
03772 <span class="comment"></span>
03773 <span class="comment">Arguments:</span>
03774 <span class="comment"></span>
03775 <span class="comment">    SharedCacheMap - As supplied to CcAcquireByteRangeForWrite</span>
03776 <span class="comment"></span>
03777 <span class="comment">    FileOffset - As returned from CcAcquireByteRangeForWrite</span>
03778 <span class="comment"></span>
03779 <span class="comment">    Length - As returned from CcAcquirebyteRangeForWrite</span>
03780 <span class="comment"></span>
03781 <span class="comment">    FirstBcb - As returned from CcAcquireByteRangeForWrite</span>
03782 <span class="comment"></span>
03783 <span class="comment">    VerifyRequired - supplied as TRUE if a verify required error was received.</span>
03784 <span class="comment">                     In this case we must mark/leave the data dirty so that</span>
03785 <span class="comment">                     we will try to write it again.</span>
03786 <span class="comment"></span>
03787 <span class="comment">Return Value:</span>
03788 <span class="comment"></span>
03789 <span class="comment">    None</span>
03790 <span class="comment"></span>
03791 <span class="comment">--*/</span>
03792 
03793 {
03794     LARGE_INTEGER LastOffset;
03795     <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> NextBcb;
03796 
03797     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcReleaseByteRangeFromWrite:\n"</span>, 0);
03798     <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>(0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    FileOffset = %08lx, %08lx\n"</span>, FileOffset-&gt;LowPart,
03799                                                           FileOffset-&gt;HighPart );
03800 
03801     <span class="comment">//</span>
03802     <span class="comment">//  If it is a mask Mbcb we are getting, then we only have to check</span>
03803     <span class="comment">//  for VerifyRequired.</span>
03804     <span class="comment">//</span>
03805 
03806     <span class="keywordflow">if</span> (FirstBcb == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03807 
03808         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Length != 0);
03809 
03810         <span class="keywordflow">if</span> (VerifyRequired) {
03811             <a class="code" href="../../d5/d5/cc_8h.html#a179">CcSetDirtyInMask</a>( SharedCacheMap, FileOffset, Length );
03812         }
03813 
03814         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcReleaseByteRangeFromWrite -&gt; VOID\n"</span>, 0);
03815 
03816         <span class="keywordflow">return</span>;
03817     }
03818 
03819     <span class="comment">//</span>
03820     <span class="comment">//  Now loop to free up all of the Bcbs.  If modified writing is disabled</span>
03821     <span class="comment">//  for each Bcb, then we are to set it clean here, since we are synchronized</span>
03822     <span class="comment">//  with callers who set the data dirty.  Otherwise we only have the Bcb pinned</span>
03823     <span class="comment">//  so it will not go away, and we only unpin it here.</span>
03824     <span class="comment">//</span>
03825 
03826     <span class="keywordflow">do</span> {
03827         NextBcb = CONTAINING_RECORD( FirstBcb-&gt;BcbLinks.Flink, <a class="code" href="../../d4/d3/struct__BCB.html">BCB</a>, BcbLinks );
03828 
03829         <span class="comment">//</span>
03830         <span class="comment">//  Skip over any listheads.</span>
03831         <span class="comment">//</span>
03832 
03833         <span class="keywordflow">if</span> (FirstBcb-&gt;NodeTypeCode == <a class="code" href="../../d5/d5/cc_8h.html#a14">CACHE_NTC_BCB</a>) {
03834 
03835             LastOffset = FirstBcb-&gt;FileOffset;
03836 
03837             <span class="comment">//</span>
03838             <span class="comment">//  If this is file system metadata (we disabled modified writing),</span>
03839             <span class="comment">//  then this is the time to mark the buffer clean, so long as we</span>
03840             <span class="comment">//  did not get verify required.</span>
03841             <span class="comment">//</span>
03842 
03843             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;Flags, <a class="code" href="../../d5/d5/cc_8h.html#a78">MODIFIED_WRITE_DISABLED</a>)) {
03844 
03845                 <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( FirstBcb,
03846                                  <a class="code" href="../../d5/d5/cc_8h.html#a59">BooleanFlagOn</a>(SharedCacheMap-&gt;Flags, <a class="code" href="../../d5/d5/cc_8h.html#a71">DISABLE_WRITE_BEHIND</a>),
03847                                  <a class="code" href="../../d5/d5/cc_8h.html#a211a173">SET_CLEAN</a> );
03848             }
03849 
03850             <span class="comment">//</span>
03851             <span class="comment">//  If we got verify required, we have to mark the buffer dirty again</span>
03852             <span class="comment">//  so we will try again later.  Note we have to make this call again</span>
03853             <span class="comment">//  to make sure the right thing happens with time stamps.</span>
03854             <span class="comment">//</span>
03855 
03856             <span class="keywordflow">if</span> (VerifyRequired) {
03857                 <a class="code" href="../../d4/d2/cache_8h.html#a91">CcSetDirtyPinnedData</a>( FirstBcb, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
03858             }
03859 
03860             <span class="comment">//</span>
03861             <span class="comment">//  Finally remove a pin count left over from CcAcquireByteRangeForWrite.</span>
03862             <span class="comment">//</span>
03863 
03864             <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( FirstBcb, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, <a class="code" href="../../d5/d5/cc_8h.html#a211a171">UNPIN</a> );
03865         }
03866 
03867         FirstBcb = NextBcb;
03868     } <span class="keywordflow">while</span> (FileOffset-&gt;QuadPart != LastOffset.QuadPart);
03869 
03870     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcReleaseByteRangeFromWrite -&gt; VOID\n"</span>, 0);
03871 }
03872 
03873 
03874 <span class="comment">//</span>
03875 <span class="comment">//  Internal Support Routine</span>
03876 <span class="comment">//</span>
03877 
03878 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
03879 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l03880"></a><a class="code" href="../../d5/d5/cc_8h.html#a180">03880</a> <a class="code" href="../../d5/d5/cc_8h.html#a180">CcWriteBehind</a> (
03881     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap,
03882     IN PIO_STATUS_BLOCK IoStatus
03883     )
03884 
03885 <span class="comment">/*++</span>
03886 <span class="comment"></span>
03887 <span class="comment">Routine Description:</span>
03888 <span class="comment"></span>
03889 <span class="comment">    This routine may be called with Wait = FALSE to see if write behind</span>
03890 <span class="comment">    is required, or with Wait = TRUE to perform write behind as required.</span>
03891 <span class="comment"></span>
03892 <span class="comment">    The code is very similar to the the code that the Lazy Writer performs</span>
03893 <span class="comment">    for each SharedCacheMap.  The main difference is in the call to</span>
03894 <span class="comment">    CcAcquireByteRangeForWrite.  Write Behind does not care about time</span>
03895 <span class="comment">    stamps (passing ULONG to accept all time stamps), but it will never</span>
03896 <span class="comment">    dump the first (highest byte offset) buffer in the list if the last</span>
03897 <span class="comment">    byte of that buffer is not yet written.  The Lazy Writer does exactly</span>
03898 <span class="comment">    the opposite, in the sense that it is totally time-driven, and will</span>
03899 <span class="comment">    even dump a partially modified buffer if it sits around long enough.</span>
03900 <span class="comment"></span>
03901 <span class="comment">Arguments:</span>
03902 <span class="comment"></span>
03903 <span class="comment">    SharedCacheMap - Pointer to SharedCacheMap to be written</span>
03904 <span class="comment"></span>
03905 <span class="comment">Return Value:</span>
03906 <span class="comment"></span>
03907 <span class="comment">    FALSE - if write behind is required, but the caller supplied</span>
03908 <span class="comment">            Wait = FALSE</span>
03909 <span class="comment"></span>
03910 <span class="comment">    TRUE - if write behind is complete or not required</span>
03911 <span class="comment"></span>
03912 <span class="comment">--*/</span>
03913 
03914 {
03915     KIRQL OldIrql;
03916     ULONG ActivePage;
03917     ULONG PageIsDirty;
03918     <a class="code" href="../../d9/d6/struct__MBCB.html">PMBCB</a> Mbcb;
03919     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
03920     ULONG FileExclusive = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03921     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> ActiveVacb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03922 
03923     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcWriteBehind\n"</span>, 0 );
03924     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    SharedCacheMap = %08lx\n"</span>, SharedCacheMap );
03925 
03926     <span class="comment">//</span>
03927     <span class="comment">//  First we have to acquire the file for LazyWrite, to avoid</span>
03928     <span class="comment">//  deadlocking with writers to the file.  We do this via the</span>
03929     <span class="comment">//  CallBack procedure specified to CcInitializeCacheMap.</span>
03930     <span class="comment">//</span>
03931 
03932     <span class="keywordflow">if</span> (!(*SharedCacheMap-&gt;Callbacks-&gt;AcquireForLazyWrite)
03933                             ( SharedCacheMap-&gt;LazyWriteContext, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> )) {
03934 
03935         <span class="comment">//</span>
03936         <span class="comment">//  The filesystem is hinting that it doesn't think that it can</span>
03937         <span class="comment">//  service the write without significant delay so we will defer</span>
03938         <span class="comment">//  and come back later.  Simply drop the queued flag ... note that</span>
03939         <span class="comment">//  we do not modify CcPagesYetToWrite, in the hope that we can make</span>
03940         <span class="comment">//  up the difference in some other cache map on this pass.</span>
03941         <span class="comment">//</span>
03942 
03943         <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
03944         <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>(SharedCacheMap-&gt;Flags, <a class="code" href="../../d5/d5/cc_8h.html#a74">WRITE_QUEUED</a>);
03945         <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
03946 
03947         IoStatus-&gt;Status = STATUS_FILE_LOCK_CONFLICT;
03948         <span class="keywordflow">return</span>;
03949     }
03950 
03951     <span class="comment">//</span>
03952     <span class="comment">//  See if there is a previous active page to clean up, but only</span>
03953     <span class="comment">//  do so now if it is the last dirty page or no users have the</span>
03954     <span class="comment">//  file open.  We will free it below after dropping the spinlock.</span>
03955     <span class="comment">//</span>
03956 
03957     ExAcquireFastLock( &amp;SharedCacheMap-&gt;BcbSpinLock, &amp;OldIrql );
03958     <a class="code" href="../../d5/d5/cc_8h.html#a2">CcAcquireMasterLockAtDpcLevel</a>();
03959 
03960     <span class="keywordflow">if</span> ((SharedCacheMap-&gt;DirtyPages &lt;= 1) || (SharedCacheMap-&gt;OpenCount == 0)) {
03961         <a class="code" href="../../d5/d5/cc_8h.html#a83">GetActiveVacbAtDpcLevel</a>( SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );
03962     }
03963 
03964     <span class="comment">//</span>
03965     <span class="comment">//  Increment open count so that our caller's views stay available</span>
03966     <span class="comment">//  for CcGetVacbMiss.  We could be tying up all of the views, and</span>
03967     <span class="comment">//  still need to write file sizes.</span>
03968     <span class="comment">//</span>
03969 
03970     <a class="code" href="../../d5/d5/cc_8h.html#a68">CcIncrementOpenCount</a>( SharedCacheMap, 'brWS' );
03971 
03972     <span class="comment">//</span>
03973     <span class="comment">//  If there is a mask bcb, then we need to establish a target for</span>
03974     <span class="comment">//  it to flush.</span>
03975     <span class="comment">//</span>
03976 
03977     <span class="keywordflow">if</span> ((Mbcb = SharedCacheMap-&gt;Mbcb) != 0) {
03978 
03979         <span class="comment">//</span>
03980         <span class="comment">//  Set a target of pages to write, assuming that any Active</span>
03981         <span class="comment">//  Vacb will increase the number.</span>
03982         <span class="comment">//</span>
03983 
03984         Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o2">PagesToWrite</a> = Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o3">DirtyPages</a> + ((ActiveVacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) ? 1 : 0);
03985 
03986         <span class="keywordflow">if</span> (Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o2">PagesToWrite</a> &gt; <a class="code" href="../../d5/d2/cachedat_8c.html#a32">CcPagesYetToWrite</a>) {
03987 
03988             Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o2">PagesToWrite</a> = <a class="code" href="../../d5/d2/cachedat_8c.html#a32">CcPagesYetToWrite</a>;
03989         }
03990     }
03991 
03992     <a class="code" href="../../d5/d5/cc_8h.html#a3">CcReleaseMasterLockFromDpcLevel</a>();
03993     ExReleaseFastLock( &amp;SharedCacheMap-&gt;BcbSpinLock, OldIrql );
03994 
03995     <span class="comment">//</span>
03996     <span class="comment">//  Now free the active Vacb, if we found one.</span>
03997     <span class="comment">//</span>
03998 
03999     <span class="keywordflow">if</span> (ActiveVacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04000 
04001         <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );
04002     }
04003 
04004     <span class="comment">//</span>
04005     <span class="comment">//  Now perform the lazy writing for this file via a special call</span>
04006     <span class="comment">//  to CcFlushCache.  He recognizes us by the &amp;CcNoDelay input to</span>
04007     <span class="comment">//  FileOffset, which signifies a Lazy Write, but is subsequently</span>
04008     <span class="comment">//  ignored.</span>
04009     <span class="comment">//</span>
04010 
04011     <a class="code" href="../../d4/d2/cache_8h.html#a63">CcFlushCache</a>( SharedCacheMap-&gt;FileObject-&gt;SectionObjectPointer,
04012                   &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a13">CcNoDelay</a>,
04013                   1,
04014                   IoStatus );
04015 
04016     <span class="comment">//</span>
04017     <span class="comment">//  No need for the Lazy Write resource now.</span>
04018     <span class="comment">//</span>
04019 
04020     (*SharedCacheMap-&gt;Callbacks-&gt;ReleaseFromLazyWrite)
04021                         ( SharedCacheMap-&gt;LazyWriteContext );
04022 
04023     <span class="comment">//</span>
04024     <span class="comment">//  Check if we need to put up a popup.</span>
04025     <span class="comment">//</span>
04026 
04027     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(IoStatus-&gt;Status) &amp;&amp; !<a class="code" href="../../d6/d2/cachesub_8c.html#a2">RetryError</a>(IoStatus-&gt;Status)) {
04028 
04029         <span class="comment">//</span>
04030         <span class="comment">//  We lost writebehind data. Try to get the filename. If we can't,</span>
04031         <span class="comment">//  then just raise the error returned by the failing write</span>
04032         <span class="comment">//</span>
04033 
04034         POBJECT_NAME_INFORMATION FileNameInfo;
04035         <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> QueryStatus;
04036         ULONG whocares;
04037 
04038         FileNameInfo = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>, 1024, 'nFcC' );
04039 
04040         <span class="keywordflow">if</span> ( FileNameInfo ) {
04041             QueryStatus = <a class="code" href="../../d6/d1/obquery_8c.html#a7">ObQueryNameString</a>( SharedCacheMap-&gt;FileObject,
04042                                              FileNameInfo,
04043                                              1024,
04044                                              &amp;whocares );
04045 
04046             <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(QueryStatus) ) {
04047                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(FileNameInfo);
04048                 FileNameInfo = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04049             }
04050         }
04051 
04052         <span class="comment">//</span>
04053         <span class="comment">//  Give checked builds something to look at.  This should also be event</span>
04054         <span class="comment">//  logged for after-the-fact analysis.</span>
04055         <span class="comment">//</span>
04056 
04057         KdPrint((<span class="stringliteral">"CACHE MANAGER: Lost delayed write FileOb %08x status %08x\n"</span>, SharedCacheMap-&gt;FileObject, IoStatus-&gt;Status));
04058 
04059         <span class="keywordflow">if</span> ( FileNameInfo ) {
04060             <a class="code" href="../../d4/d6/iosubs_8c.html#a94">IoRaiseInformationalHardError</a>( STATUS_LOST_WRITEBEHIND_DATA,&amp;FileNameInfo-&gt;Name, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
04061             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(FileNameInfo);
04062         } <span class="keywordflow">else</span> {
04063             <span class="keywordflow">if</span> ( SharedCacheMap-&gt;FileObject-&gt;FileName.Length &amp;&amp;
04064                  SharedCacheMap-&gt;FileObject-&gt;FileName.MaximumLength &amp;&amp;
04065                  SharedCacheMap-&gt;FileObject-&gt;FileName.Buffer ) {
04066 
04067                 <a class="code" href="../../d4/d6/iosubs_8c.html#a94">IoRaiseInformationalHardError</a>( STATUS_LOST_WRITEBEHIND_DATA,&amp;SharedCacheMap-&gt;FileObject-&gt;FileName, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
04068             }
04069         }
04070 
04071         <a class="code" href="../../d6/d2/cachesub_8c.html#a11">CcLogError</a>( SharedCacheMap-&gt;FileObject-&gt;DeviceObject,
04072                     IO_LOST_DELAYED_WRITE,
04073                     IoStatus-&gt;Status,
04074                     &amp;(SharedCacheMap-&gt;FileObject-&gt;FileName) );
04075     <span class="comment">//</span>
04076     <span class="comment">//  See if there is any deferred writes we can post.</span>
04077     <span class="comment">//</span>
04078 
04079     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!IsListEmpty(&amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a29">CcDeferredWrites</a>)) {
04080         <a class="code" href="../../d5/d5/cc_8h.html#a174">CcPostDeferredWrites</a>();
04081     }
04082 
04083     <span class="comment">//</span>
04084     <span class="comment">//  Now acquire BcbSpinLock again to check for ValidData updates.</span>
04085     <span class="comment">//</span>
04086 
04087     ExAcquireSpinLock( &amp;SharedCacheMap-&gt;BcbSpinLock, &amp;OldIrql );
04088 
04089     <span class="comment">//</span>
04090     <span class="comment">//  If the the current ValidDataGoal is greater (or equal) than ValidDataLength,</span>
04091     <span class="comment">//  then we must see if we have advanced beyond the current ValidDataLength.</span>
04092     <span class="comment">//</span>
04093     <span class="comment">//  If we have NEVER written anything out from this shared cache map, then</span>
04094     <span class="comment">//  there is no need to check anything associtated with valid data length</span>
04095     <span class="comment">//  here.  We will come by here again when, and if, anybody actually</span>
04096     <span class="comment">//  modifies the file and we lazy write some data.</span>
04097     <span class="comment">//</span>
04098 
04099     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
04100     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;Flags, <a class="code" href="../../d5/d5/cc_8h.html#a79">LAZY_WRITE_OCCURRED</a>) &amp;&amp;
04101         (SharedCacheMap-&gt;ValidDataGoal.QuadPart &gt;= SharedCacheMap-&gt;ValidDataLength.QuadPart) &amp;&amp;
04102         (SharedCacheMap-&gt;ValidDataLength.QuadPart != MAXLONGLONG) &amp;&amp;
04103         (SharedCacheMap-&gt;FileSize.QuadPart != 0)) {
04104 
04105         LARGE_INTEGER NewValidDataLength;
04106 
04107         NewValidDataLength = <a class="code" href="../../d4/d2/cache_8h.html#a64">CcGetFlushedValidData</a>( SharedCacheMap-&gt;FileObject-&gt;SectionObjectPointer,
04108                                                     <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
04109 
04110         <span class="comment">//</span>
04111         <span class="comment">//  If New ValidDataLength has been written, then we have to</span>
04112         <span class="comment">//  call the file system back to update it.  We must temporarily</span>
04113         <span class="comment">//  drop our global list while we do this, which is safe to do since</span>
04114         <span class="comment">//  we have not cleared WRITE_QUEUED.</span>
04115         <span class="comment">//</span>
04116         <span class="comment">//  Note we keep calling any time we wrote the last page of the file,</span>
04117         <span class="comment">//  to solve the "famous" AFS Server problem.  The file system will</span>
04118         <span class="comment">//  truncate our valid data call to whatever is currently valid.  But</span>
04119         <span class="comment">//  then if he writes a little more, we do not want to stop calling</span>
04120         <span class="comment">//  back.</span>
04121         <span class="comment">//</span>
04122 
04123         <span class="keywordflow">if</span> ( NewValidDataLength.QuadPart &gt;= SharedCacheMap-&gt;ValidDataLength.QuadPart ) {
04124 
04125             ExReleaseSpinLock( &amp;SharedCacheMap-&gt;BcbSpinLock, OldIrql );
04126 
04127             <span class="comment">//</span>
04128             <span class="comment">//  Call file system to set new valid data.  We have no</span>
04129             <span class="comment">//  one to tell if this doesn't work.</span>
04130             <span class="comment">//</span>
04131 
04132             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d2/cachesub_8c.html#a6">CcSetValidData</a>( SharedCacheMap-&gt;FileObject,
04133                                      &amp;NewValidDataLength );
04134 
04135             ExAcquireSpinLock( &amp;SharedCacheMap-&gt;BcbSpinLock, &amp;OldIrql );
04136             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
04137                 SharedCacheMap-&gt;ValidDataLength = NewValidDataLength;
04138 <span class="preprocessor">#ifdef TOMM</span>
04139 <span class="preprocessor"></span>            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> != STATUS_INSUFFICIENT_RESOURCES) &amp;&amp; !<a class="code" href="../../d6/d2/cachesub_8c.html#a2">RetryError</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
04140                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"Unexpected status from CcSetValidData: %08lx, FileObject: %08lx\n"</span>,
04141                          <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>,
04142                          SharedCacheMap-&gt;FileObject);
04143                 DbgBreakPoint();
04144 <span class="preprocessor">#endif TOMM</span>
04145 <span class="preprocessor"></span>            }
04146         }
04147     }
04148 
04149     ExReleaseSpinLock( &amp;SharedCacheMap-&gt;BcbSpinLock, OldIrql );
04150 
04151     <span class="comment">//</span>
04152     <span class="comment">//  Show we are done.</span>
04153     <span class="comment">//</span>
04154 
04155     <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
04156     <a class="code" href="../../d5/d5/cc_8h.html#a69">CcDecrementOpenCount</a>( SharedCacheMap, 'brWF' );
04157 
04158     <span class="comment">//</span>
04159     <span class="comment">//  Make an approximate guess about whether we will call CcDeleteSharedCacheMap or not</span>
04160     <span class="comment">//  to truncate the file.</span>
04161     <span class="comment">//</span>
04162     <span class="comment">//  Also do not delete the SharedCacheMap if we got an error on the ValidDataLength</span>
04163     <span class="comment">//  callback.  If we get a resource allocation failure or a retryable error (due to</span>
04164     <span class="comment">//  log file full?), we have no one to tell, so we must just loop back and try again.</span>
04165     <span class="comment">//  Of course all I/O errors are just too bad.</span>
04166     <span class="comment">//</span>
04167 
04168     <span class="keywordflow">if</span> ((SharedCacheMap-&gt;OpenCount == 0)
04169         
04170             &amp;&amp;
04171         
04172         (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>) || ((<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> != STATUS_INSUFFICIENT_RESOURCES) &amp;&amp; !<a class="code" href="../../d6/d2/cachesub_8c.html#a2">RetryError</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)))) {
04173 
04174         <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
04175         <a class="code" href="../../d1/d8/fsrtl_8h.html#a107">FsRtlAcquireFileExclusive</a>( SharedCacheMap-&gt;FileObject );
04176         <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
04177         
04178         <span class="comment">//</span>
04179         <span class="comment">//  Now really see if we are to delete this SharedCacheMap. By having released</span>
04180         <span class="comment">//  first we avoid a deadlock with the file system when the FileObject is</span>
04181         <span class="comment">//  dereferenced.  Note that CcDeleteSharedCacheMap requires that the</span>
04182         <span class="comment">//  CcMasterSpinLock already be acquired, and it releases it.</span>
04183         <span class="comment">//</span>
04184         <span class="comment">//  Note that we must retest since we dropped and reacquired the master</span>
04185         <span class="comment">//  lock.</span>
04186         <span class="comment">//</span>
04187 
04188         <span class="keywordflow">if</span> ((SharedCacheMap-&gt;OpenCount == 0)
04189 
04190                 &amp;&amp;
04191 
04192             ((SharedCacheMap-&gt;DirtyPages == 0) || ((SharedCacheMap-&gt;FileSize.QuadPart == 0) &amp;&amp;
04193                                                    !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;Flags, <a class="code" href="../../d5/d5/cc_8h.html#a72">PIN_ACCESS</a>)))) {
04194 
04195             <span class="comment">//</span>
04196             <span class="comment">//  Make sure to drop the requeue flag in case the write hit the timeout at</span>
04197             <span class="comment">//  the same time it finished everything up.</span>
04198             <span class="comment">//</span>
04199             
04200             <a class="code" href="../../d5/d8/fssup_8c.html#a11">CcDeleteSharedCacheMap</a>( SharedCacheMap, OldIrql, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
04201             IoStatus-&gt;Information = 0;
04202             SharedCacheMap = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04203         
04204         } <span class="keywordflow">else</span> {
04205 
04206             <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
04207             <a class="code" href="../../d1/d8/fsrtl_8h.html#a108">FsRtlReleaseFile</a>( SharedCacheMap-&gt;FileObject );
04208             <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
04209         }
04210     }
04211 
04212     <span class="comment">//</span>
04213     <span class="comment">//  In the normal case, we just clear the flag on the way out if</span>
04214     <span class="comment">//  we will not requeue the workitem.</span>
04215     <span class="comment">//</span>
04216 
04217     <span class="keywordflow">if</span> (SharedCacheMap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04218 
04219         <span class="keywordflow">if</span> (IoStatus-&gt;Information != <a class="code" href="../../d5/d5/cc_8h.html#a56">CC_REQUEUE</a>) {
04220             <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>(SharedCacheMap-&gt;Flags, <a class="code" href="../../d5/d5/cc_8h.html#a74">WRITE_QUEUED</a>);
04221         }
04222         <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
04223     }
04224 
04225     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcWriteBehind-&gt;VOID\n"</span>, 0 );
04226 
04227     <span class="keywordflow">return</span>;
04228 }
04229 
04230 
04231 LARGE_INTEGER
<a name="l04232"></a><a class="code" href="../../d4/d2/cache_8h.html#a64">04232</a> <a class="code" href="../../d4/d2/cache_8h.html#a64">CcGetFlushedValidData</a> (
04233     IN <a class="code" href="../../d7/d0/struct__SECTION__OBJECT__POINTERS.html">PSECTION_OBJECT_POINTERS</a> SectionObjectPointer,
04234     IN BOOLEAN CcInternalCaller
04235     )
04236 
04237 <span class="comment">/*++</span>
04238 <span class="comment"></span>
04239 <span class="comment">Routine Description:</span>
04240 <span class="comment"></span>
04241 <span class="comment">    This routine may be called by a file system to find out how far the Cache Manager</span>
04242 <span class="comment">    has flushed in the stream.  More accurately, this routine returns either the FileOffset</span>
04243 <span class="comment">    of the lowest dirty page currently in the file.</span>
04244 <span class="comment"></span>
04245 <span class="comment">    NOTE that even though the routine takes SectionObjectPointer, the caller must insure</span>
04246 <span class="comment">    that the stream is cached and stays cached for the duration of this routine, much like</span>
04247 <span class="comment">    for the copy routines, etc.</span>
04248 <span class="comment"></span>
04249 <span class="comment">Arguments:</span>
04250 <span class="comment"></span>
04251 <span class="comment">    SectionObjectPointer - A pointer to the Section Object Pointers</span>
04252 <span class="comment">                           structure in the nonpaged Fcb.</span>
04253 <span class="comment"></span>
04254 <span class="comment">    CcInternalCaller - must be TRUE if the caller is coming from Cc, FALSE otherwise.</span>
04255 <span class="comment">        TRUE imples the need for self-synchronization.</span>
04256 <span class="comment"></span>
04257 <span class="comment">Return Value:</span>
04258 <span class="comment"></span>
04259 <span class="comment">    The derived number for flushed ValidData, or MAXLONGLONG in the quad part if</span>
04260 <span class="comment">    the Section is not cached.  (Naturally the caller can guarantee that this case</span>
04261 <span class="comment">    does not occur, and internal callers do.)</span>
04262 <span class="comment"></span>
04263 <span class="comment">--*/</span>
04264 
04265 {
04266     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
04267     KIRQL OldIrql;
04268     LARGE_INTEGER NewValidDataLength;
04269 
04270     <span class="comment">//</span>
04271     <span class="comment">//  External callers may be unsynchronized with this shared cache map</span>
04272     <span class="comment">//  perhaps going away underneath this call.  NTFS and his</span>
04273     <span class="comment">//  pair of streams for compression-on-the-wire is a good example of</span>
04274     <span class="comment">//  someone who may be synchronized in one stream but needs to peek at</span>
04275     <span class="comment">//  the other.</span>
04276     <span class="comment">//</span>
04277 
04278     <span class="keywordflow">if</span> (!CcInternalCaller) {
04279 
04280         <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
04281 
04282         SharedCacheMap = SectionObjectPointer-&gt;SharedCacheMap;
04283 
04284         <span class="keywordflow">if</span> (SharedCacheMap == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04285             <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
04286             NewValidDataLength.QuadPart = MAXLONGLONG;
04287             <span class="keywordflow">return</span> NewValidDataLength;
04288         }
04289 
04290         <a class="code" href="../../d5/d5/cc_8h.html#a68">CcIncrementOpenCount</a>( SharedCacheMap, 'dfGS' );
04291         <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
04292         ExAcquireSpinLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, &amp;OldIrql );
04293 
04294     } <span class="keywordflow">else</span> {
04295 
04296         SharedCacheMap = SectionObjectPointer-&gt;SharedCacheMap;
04297     }
04298 
04299     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( SharedCacheMap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
04300 
04301     <span class="comment">//</span>
04302     <span class="comment">//  If the file is entirely clean, then we wish to return</span>
04303     <span class="comment">//  the new ValidDataLength as equal to ValidDataGoal.</span>
04304     <span class="comment">//</span>
04305 
04306     NewValidDataLength = SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o7">ValidDataGoal</a>;
04307 
04308     <span class="comment">//</span>
04309     <span class="comment">//  If there may be dirty pages we will look at the last Bcb in the</span>
04310     <span class="comment">//  descending-order Bcb list, and see if it describes data beyond</span>
04311     <span class="comment">//  ValidDataGoal.</span>
04312     <span class="comment">//</span>
04313     <span class="comment">//  It is important to note that since we use DirtyPages as a faux</span>
04314     <span class="comment">//  reference count over some short windows (+1, -1) the simple</span>
04315     <span class="comment">//  fact it is nonzero does *not* mean the file is dirty.</span>
04316     <span class="comment">//</span>
04317     <span class="comment">//  (This test is logically too conservative.  For example, the last Bcb</span>
04318     <span class="comment">//  may not even be dirty (in which case we should look at its</span>
04319     <span class="comment">//  predecessor), or we may have earlier written valid data to this</span>
04320     <span class="comment">//  byte range (which also means if we knew this we could look at</span>
04321     <span class="comment">//  the predessor).  This simply means that the Lazy Writer may not</span>
04322     <span class="comment">//  successfully get ValidDataLength updated in a file being randomly</span>
04323     <span class="comment">//  accessed until the level of file access dies down, or at the latest</span>
04324     <span class="comment">//  until the file is closed.  However, security will never be</span>
04325     <span class="comment">//  compromised.)</span>
04326     <span class="comment">//</span>
04327 
04328     <span class="keywordflow">if</span> (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a>) {
04329 
04330         <a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html">PBITMAP_RANGE</a> BitmapRange;
04331         <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> LastBcb;
04332         <a class="code" href="../../d9/d6/struct__MBCB.html">PMBCB</a> Mbcb = SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o19">Mbcb</a>;
04333 
04334         <span class="keywordflow">if</span> ((Mbcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp; (Mbcb-&gt;<a class="code" href="../../d9/d6/struct__MBCB.html#o3">DirtyPages</a> != 0)) {
04335 
04336             BitmapRange = <a class="code" href="../../d6/d2/cachesub_8c.html#a10">CcFindBitmapRangeToClean</a>( Mbcb, 0 );
04337 
04338             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o2">FirstDirtyPage</a> != MAXULONG);
04339 
04340             NewValidDataLength.QuadPart = (BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o1">BasePage</a> + BitmapRange-&gt;<a class="code" href="../../d8/d3/struct__BITMAP__RANGE.html#o2">FirstDirtyPage</a>)
04341                                             &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
04342         }
04343 
04344         LastBcb = CONTAINING_RECORD( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o4">BcbList</a>.Flink,
04345                                      <a class="code" href="../../d4/d3/struct__BCB.html">BCB</a>,
04346                                      BcbLinks );
04347 
04348         <span class="keywordflow">while</span> (&amp;LastBcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o4">BcbLinks</a> != &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o4">BcbList</a>) {
04349 
04350             <span class="keywordflow">if</span> ((LastBcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o0">NodeTypeCode</a> == <a class="code" href="../../d5/d5/cc_8h.html#a14">CACHE_NTC_BCB</a>) &amp;&amp; LastBcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o13">Dirty</a>) {
04351                 <span class="keywordflow">break</span>;
04352             }
04353 
04354             LastBcb = CONTAINING_RECORD( LastBcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o4">BcbLinks</a>.Flink,
04355                                          <a class="code" href="../../d4/d3/struct__BCB.html">BCB</a>,
04356                                          BcbLinks );
04357         }
04358 
04359         <span class="comment">//</span>
04360         <span class="comment">//  Check the Base of the last entry.</span>
04361         <span class="comment">//</span>
04362 
04363         <span class="keywordflow">if</span> ((&amp;LastBcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o4">BcbLinks</a> != &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o4">BcbList</a>) &amp;&amp;
04364             (LastBcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o3">FileOffset</a>.QuadPart &lt; NewValidDataLength.QuadPart )) {
04365 
04366             NewValidDataLength = LastBcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o3">FileOffset</a>;
04367         }
04368     }
04369 
04370     <span class="keywordflow">if</span> (!CcInternalCaller) {
04371 
04372         <span class="comment">//</span>
04373         <span class="comment">//  Remove our reference.</span>
04374         <span class="comment">//</span>
04375 
04376         <a class="code" href="../../d5/d5/cc_8h.html#a2">CcAcquireMasterLockAtDpcLevel</a>();
04377         <a class="code" href="../../d5/d5/cc_8h.html#a69">CcDecrementOpenCount</a>( SharedCacheMap, 'dfGF' );
04378 
04379         <span class="keywordflow">if</span> ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o2">OpenCount</a> == 0) &amp;&amp;
04380             !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a74">WRITE_QUEUED</a>) &amp;&amp;
04381             (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> == 0)) {
04382 
04383             <span class="comment">//</span>
04384             <span class="comment">//  Move to the dirty list.</span>
04385             <span class="comment">//</span>
04386 
04387             RemoveEntryList( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
04388             InsertTailList( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a2">CcDirtySharedCacheMapList</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a>,
04389                         &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
04390 
04391             <span class="comment">//</span>
04392             <span class="comment">//  Make sure the Lazy Writer will wake up, because we</span>
04393             <span class="comment">//  want him to delete this SharedCacheMap.</span>
04394             <span class="comment">//</span>
04395 
04396             <a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o6">OtherWork</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04397             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o5">ScanActive</a>) {
04398                 <a class="code" href="../../d5/d5/cc_8h.html#a185">CcScheduleLazyWriteScan</a>();
04399             }
04400         }
04401 
04402         ExReleaseSpinLockFromDpcLevel( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a> );
04403         <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
04404     }
04405 
04406     <span class="keywordflow">return</span> NewValidDataLength;
04407 }
04408 
04409 
04410 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l04411"></a><a class="code" href="../../d4/d2/cache_8h.html#a63">04411</a> <a class="code" href="../../d4/d2/cache_8h.html#a63">CcFlushCache</a> (
04412     IN <a class="code" href="../../d7/d0/struct__SECTION__OBJECT__POINTERS.html">PSECTION_OBJECT_POINTERS</a> SectionObjectPointer,
04413     IN PLARGE_INTEGER FileOffset OPTIONAL,
04414     IN ULONG Length,
04415     OUT PIO_STATUS_BLOCK IoStatus OPTIONAL
04416     )
04417 
04418 <span class="comment">/*++</span>
04419 <span class="comment"></span>
04420 <span class="comment">Routine Description:</span>
04421 <span class="comment"></span>
04422 <span class="comment">    This routine may be called to flush dirty data from the cache to the</span>
04423 <span class="comment">    cached file on disk.  Any byte range within the file may be flushed,</span>
04424 <span class="comment">    or the entire file may be flushed by omitting the FileOffset parameter.</span>
04425 <span class="comment"></span>
04426 <span class="comment">    This routine does not take a Wait parameter; the caller should assume</span>
04427 <span class="comment">    that it will always block.</span>
04428 <span class="comment"></span>
04429 <span class="comment">Arguments:</span>
04430 <span class="comment"></span>
04431 <span class="comment">    SectionObjectPointer - A pointer to the Section Object Pointers</span>
04432 <span class="comment">                           structure in the nonpaged Fcb.</span>
04433 <span class="comment"></span>
04434 <span class="comment">    FileOffset - If this parameter is supplied (not NULL), then only the</span>
04435 <span class="comment">                 byte range specified by FileOffset and Length are flushed.</span>
04436 <span class="comment">                 If &amp;CcNoDelay is specified, then this signifies the call</span>
04437 <span class="comment">                 from the Lazy Writer, and the lazy write scan should resume</span>
04438 <span class="comment">                 as normal from the last spot where it left off in the file.</span>
04439 <span class="comment"></span>
04440 <span class="comment">    Length - Defines the length of the byte range to flush, starting at</span>
04441 <span class="comment">             FileOffset.  This parameter is ignored if FileOffset is</span>
04442 <span class="comment">             specified as NULL.</span>
04443 <span class="comment"></span>
04444 <span class="comment">    IoStatus - The I/O status resulting from the flush operation.</span>
04445 <span class="comment"></span>
04446 <span class="comment">Return Value:</span>
04447 <span class="comment"></span>
04448 <span class="comment">    None.</span>
04449 <span class="comment"></span>
04450 <span class="comment">--*/</span>
04451 
04452 {
04453     LARGE_INTEGER NextFileOffset, TargetOffset;
04454     ULONG NextLength;
04455     <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> FirstBcb;
04456     KIRQL OldIrql;
04457     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
04458     IO_STATUS_BLOCK TrashStatus;
04459     PVOID TempVa;
04460     ULONG RemainingLength, TempLength;
04461     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> PopupStatus;
04462     BOOLEAN HotSpot;
04463     ULONG BytesWritten = 0;
04464     BOOLEAN PopupRequired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04465     BOOLEAN VerifyRequired = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04466     BOOLEAN IsLazyWriter = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04467     BOOLEAN FreeActiveVacb = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04468     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> ActiveVacb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04469     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
04470     LARGE_INTEGER EndTick, CurrentTick;
04471 
04472     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcFlushCache:\n"</span>, 0 );
04473     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"    SectionObjectPointer = %08lx\n"</span>, SectionObjectPointer );
04474     <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>(0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    FileOffset = %08lx, %08lx\n"</span>,
04475                             ARGUMENT_PRESENT(FileOffset) ? FileOffset-&gt;LowPart
04476                                                          : 0,
04477                             ARGUMENT_PRESENT(FileOffset) ? FileOffset-&gt;HighPart
04478                                                          : 0 );
04479     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    Length = %08lx\n"</span>, Length );
04480 
04481     <span class="comment">//</span>
04482     <span class="comment">//  If IoStatus passed a Null pointer, set up to through status away.</span>
04483     <span class="comment">//</span>
04484 
04485     <span class="keywordflow">if</span> (!ARGUMENT_PRESENT(IoStatus)) {
04486         IoStatus = &amp;TrashStatus;
04487     }
04488     IoStatus-&gt;Status = STATUS_SUCCESS;
04489     IoStatus-&gt;Information = 0;
04490 
04491     <span class="comment">//</span>
04492     <span class="comment">//  See if this is the Lazy Writer.  Since he wants to use this common</span>
04493     <span class="comment">//  routine, which is also a public routine callable by file systems,</span>
04494     <span class="comment">//  the Lazy Writer shows his call by specifying CcNoDelay as the file offset!</span>
04495     <span class="comment">//</span>
04496     <span class="comment">//  Also, in case we do not write anything because we see only HotSpot(s),</span>
04497     <span class="comment">//  initialize the Status to indicate a retryable error, so CcWorkerThread</span>
04498     <span class="comment">//  knows we did not make any progress.  Of course any actual flush will</span>
04499     <span class="comment">//  overwrite this code.</span>
04500     <span class="comment">//</span>
04501 
04502     <span class="keywordflow">if</span> (FileOffset == &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a13">CcNoDelay</a>) {
04503         IoStatus-&gt;Status = STATUS_VERIFY_REQUIRED;
04504         IsLazyWriter = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04505         FileOffset = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04506     }
04507 
04508     <span class="comment">//</span>
04509     <span class="comment">//  If there is nothing to do, return here.</span>
04510     <span class="comment">//</span>
04511 
04512     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(FileOffset) &amp;&amp; (Length == 0)) {
04513 
04514         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcFlushCache -&gt; VOID\n"</span>, 0 );
04515         <span class="keywordflow">return</span>;
04516     }
04517 
04518     <span class="comment">//</span>
04519     <span class="comment">//  See if the file is cached.</span>
04520     <span class="comment">//</span>
04521 
04522     <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
04523 
04524     SharedCacheMap = SectionObjectPointer-&gt;SharedCacheMap;
04525 
04526     <span class="keywordflow">if</span> (SharedCacheMap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04527 
04528         <span class="comment">//</span>
04529         <span class="comment">//  Increment the open count to keep it from going away.</span>
04530         <span class="comment">//</span>
04531 
04532         <a class="code" href="../../d5/d5/cc_8h.html#a68">CcIncrementOpenCount</a>( SharedCacheMap, 'fcCS' );
04533 
04534         <span class="keywordflow">if</span> ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) || (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o11">ActiveVacb</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
04535 
04536             ULONG FirstPage = 0;
04537             ULONG LastPage = MAXULONG;
04538 
04539             <span class="keywordflow">if</span> (ARGUMENT_PRESENT(FileOffset)) {
04540 
04541                 FirstPage = (ULONG)(FileOffset-&gt;QuadPart &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
04542                 LastPage = (ULONG)((FileOffset-&gt;QuadPart + Length - 1) &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
04543             }
04544 
04545             <span class="comment">//</span>
04546             <span class="comment">//  Make sure we do not flush the active page without zeroing any</span>
04547             <span class="comment">//  uninitialized data.  Also, it is very important to free the active</span>
04548             <span class="comment">//  page if it is the one to be flushed, so that we get the dirty</span>
04549             <span class="comment">//  bit out to the Pfn.</span>
04550             <span class="comment">//</span>
04551 
04552             <span class="keywordflow">if</span> (((((LONGLONG)LastPage + 1) &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>) &gt; SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o7">ValidDataGoal</a>.QuadPart) ||
04553 
04554                 ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
04555                  (FirstPage &lt;= SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o14">NeedToZeroPage</a>) &amp;&amp;
04556                  (LastPage &gt;= SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o14">NeedToZeroPage</a>)) ||
04557 
04558                 ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o11">ActiveVacb</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
04559                  (FirstPage &lt;= SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o12">ActivePage</a>) &amp;&amp;
04560                  (LastPage &gt;= SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o12">ActivePage</a>))) {
04561 
04562                 <a class="code" href="../../d5/d5/cc_8h.html#a83">GetActiveVacbAtDpcLevel</a>( SharedCacheMap, ActiveVacb, RemainingLength, TempLength );
04563                 FreeActiveVacb = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04564             }
04565         }
04566     }
04567 
04568     <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
04569 
04570     <span class="keywordflow">if</span> (FreeActiveVacb) {
04571         <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, ActiveVacb, RemainingLength, TempLength );
04572     }
04573 
04574     <span class="comment">//</span>
04575     <span class="comment">//  If there is a user-mapped file, then we perform the "service" of</span>
04576     <span class="comment">//  flushing even data not written via the file system.  Note that this</span>
04577     <span class="comment">//  is pretty important for folks provoking the flush/purge of a coherency</span>
04578     <span class="comment">//  operation.</span>
04579     <span class="comment">//</span>
04580     <span class="comment">//  It is critical this happen before we examine our own hints.  In the course</span>
04581     <span class="comment">//  of this flush it is possible valid data length will be advanced by the</span>
04582     <span class="comment">//  underlying filesystem, with CcZero'ing behind - which will cause us to</span>
04583     <span class="comment">//  make some dirty zeroes in the cache.  Syscache bug!  Note how coherency</span>
04584     <span class="comment">//  flushing works ...</span>
04585     <span class="comment">//</span>
04586 
04587     <span class="keywordflow">if</span> ((SharedCacheMap == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)
04588 
04589             ||
04590 
04591         <a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(((<a class="code" href="../../d1/d1/struct__FSRTL__COMMON__FCB__HEADER.html">PFSRTL_COMMON_FCB_HEADER</a>)(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o10">FileObject</a>-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o4">FsContext</a>))-&gt;Flags,
04592                <a class="code" href="../../d1/d8/fsrtl_8h.html#a5">FSRTL_FLAG_USER_MAPPED_FILE</a>) &amp;&amp; !IsLazyWriter) {
04593 
04594         <span class="comment">//</span>
04595         <span class="comment">//  Call MM to flush the section through our view.</span>
04596         <span class="comment">//</span>
04597 
04598         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"MmFlushSection:\n"</span>, 0 );
04599         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"    SectionObjectPointer = %08lx\n"</span>, SectionObjectPointer );
04600         <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>(0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    FileOffset = %08lx, %08lx\n"</span>,
04601                                 ARGUMENT_PRESENT(FileOffset) ? FileOffset-&gt;LowPart
04602                                                              : 0,
04603                                 ARGUMENT_PRESENT(FileOffset) ? FileOffset-&gt;HighPart
04604                                                              : 0 );
04605         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"    RegionSize = %08lx\n"</span>, Length );
04606 
04607         <span class="keywordflow">try</span> {
04608 
04609             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d5/flushsec_8c.html#a8">MmFlushSection</a>( SectionObjectPointer,
04610                                      FileOffset,
04611                                      Length,
04612                                      IoStatus,
04613                                      <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
04614 
04615         } except( <a class="code" href="../../d5/d1/lazyrite_8c.html#a7">CcExceptionFilter</a>( IoStatus-&gt;Status = GetExceptionCode() )) {
04616 
04617             KdPrint((<span class="stringliteral">"CACHE MANAGER: MmFlushSection raised %08lx\n"</span>, IoStatus-&gt;Status));
04618         }
04619 
04620         <span class="keywordflow">if</span> ((!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(IoStatus-&gt;Status)) &amp;&amp; !<a class="code" href="../../d6/d2/cachesub_8c.html#a2">RetryError</a>(IoStatus-&gt;Status)) {
04621 
04622             PopupRequired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04623             PopupStatus = IoStatus-&gt;Status;
04624         }
04625 
04626         <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>(0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"    &lt;IoStatus = %08lx, %08lx\n"</span>,
04627                     IoStatus-&gt;Status, IoStatus-&gt;Information );
04628     }
04629 
04630     <span class="comment">//</span>
04631     <span class="comment">//  Scan for dirty pages if there is a shared cache map.</span>
04632     <span class="comment">//</span>
04633 
04634     <span class="keywordflow">if</span> (SharedCacheMap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04635 
04636         <span class="comment">//</span>
04637         <span class="comment">//  If FileOffset was not specified then set to flush entire region</span>
04638         <span class="comment">//  and set valid data length to the goal so that we will not get</span>
04639         <span class="comment">//  any more call backs.</span>
04640         <span class="comment">//</span>
04641 
04642         <span class="keywordflow">if</span> (!IsLazyWriter &amp;&amp; !ARGUMENT_PRESENT(FileOffset)) {
04643 
04644             SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o6">ValidDataLength</a> = SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o7">ValidDataGoal</a>;
04645         }
04646 
04647         <span class="comment">//</span>
04648         <span class="comment">//  If this is an explicit flush, initialize our offset to scan for.</span>
04649         <span class="comment">//</span>
04650 
04651         <span class="keywordflow">if</span> (ARGUMENT_PRESENT(FileOffset)) {
04652             TargetOffset = *FileOffset;
04653         }
04654 
04655         <span class="comment">//</span>
04656         <span class="comment">//  Assume we want to pass the explicit flush flag in Length.</span>
04657         <span class="comment">//  But overwrite it if a length really was specified.  On</span>
04658         <span class="comment">//  subsequent loops, NextLength will have some nonzero value.</span>
04659         <span class="comment">//</span>
04660 
04661         NextLength = 1;
04662         <span class="keywordflow">if</span> (Length != 0) {
04663             NextLength = Length;
04664         }
04665 
04666         <span class="comment">//</span>
04667         <span class="comment">//  Now calculate the tick that will signal the expiration of a</span>
04668         <span class="comment">//  lazy writer tick interval.</span>
04669         <span class="comment">//</span>
04670 
04671         <span class="keywordflow">if</span> (IsLazyWriter) {
04672 
04673             <a class="code" href="../../d7/d0/ke_2miscc_8c.html#a4">KeQueryTickCount</a>( &amp;EndTick );
04674             EndTick.QuadPart += <a class="code" href="../../d5/d2/cachedat_8c.html#a12">CcIdleDelayTick</a>;
04675         }
04676 
04677         <span class="comment">//</span>
04678         <span class="comment">//  Loop as long as we find buffers to flush for this</span>
04679         <span class="comment">//  SharedCacheMap, and we are not trying to delete the guy.</span>
04680         <span class="comment">//</span>
04681 
04682         <span class="keywordflow">while</span> (((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o25">PagesToWrite</a> != 0) || !IsLazyWriter)
04683 
04684                     &amp;&amp;
04685                ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o3">FileSize</a>.QuadPart != 0) ||
04686                 <a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a72">PIN_ACCESS</a>))
04687 
04688                     &amp;&amp;
04689 
04690                !VerifyRequired
04691 
04692                     &amp;&amp;
04693 
04694                <a class="code" href="../../d6/d2/cachesub_8c.html#a7">CcAcquireByteRangeForWrite</a> ( SharedCacheMap,
04695                                             IsLazyWriter ? <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> : (ARGUMENT_PRESENT(FileOffset) ?
04696                                                                     &amp;TargetOffset : <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>),
04697                                             IsLazyWriter ? 0: NextLength,
04698                                             &amp;NextFileOffset,
04699                                             &amp;NextLength,
04700                                             &amp;FirstBcb )) {
04701 
04702             <span class="comment">//</span>
04703             <span class="comment">//  Assume this range is not a hot spot.</span>
04704             <span class="comment">//</span>
04705 
04706             HotSpot = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04707 
04708             <span class="comment">//</span>
04709             <span class="comment">//  We defer calling Mm to set address range modified until here, to take</span>
04710             <span class="comment">//  overhead out of the main line path, and to reduce the number of TBIS</span>
04711             <span class="comment">//  on a multiprocessor.</span>
04712             <span class="comment">//</span>
04713 
04714             RemainingLength = NextLength;
04715 
04716             <span class="keywordflow">do</span> {
04717 
04718                 <span class="comment">//</span>
04719                 <span class="comment">//  See if the next file offset is mapped.  (If not, the dirty bit</span>
04720                 <span class="comment">//  was propagated on the unmap.)</span>
04721                 <span class="comment">//</span>
04722 
04723                 <span class="keywordflow">if</span> ((TempVa = <a class="code" href="../../d5/d3/vacbsup_8c.html#a14">CcGetVirtualAddressIfMapped</a>( SharedCacheMap,
04724                                                            NextFileOffset.QuadPart + NextLength - RemainingLength,
04725                                                            &amp;ActiveVacb,
04726                                                            &amp;TempLength)) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04727 
04728                     <span class="comment">//</span>
04729                     <span class="comment">//  Reduce TempLength to RemainingLength if necessary, and</span>
04730                     <span class="comment">//  call MM.</span>
04731                     <span class="comment">//</span>
04732 
04733                     <span class="keywordflow">if</span> (TempLength &gt; RemainingLength) {
04734                         TempLength = RemainingLength;
04735                     }
04736 
04737                     <span class="comment">//</span>
04738                     <span class="comment">//  Clear the Dirty bit (if set) in the PTE and set the</span>
04739                     <span class="comment">//  Pfn modified.  Assume if the Pte was dirty, that this may</span>
04740                     <span class="comment">//  be a hot spot.  Do not do hot spots for metadata, and unless</span>
04741                     <span class="comment">//  they are within ValidDataLength as reported to the file system</span>
04742                     <span class="comment">//  via CcSetValidData.</span>
04743                     <span class="comment">//</span>
04744 
04745                     HotSpot = (BOOLEAN)((<a class="code" href="../../d5/d6/iosup_8c.html#a74">MmSetAddressRangeModified</a>(TempVa, TempLength) || HotSpot) &amp;&amp;
04746                                         ((NextFileOffset.QuadPart + NextLength) &lt;
04747                                          (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o6">ValidDataLength</a>.QuadPart)) &amp;&amp;
04748                                         ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o33">LazyWritePassCount</a> &amp; 0xF) != 0) &amp;&amp; IsLazyWriter) &amp;&amp;
04749                                         !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a78">MODIFIED_WRITE_DISABLED</a>);
04750 
04751                     <a class="code" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a>( ActiveVacb );
04752 
04753                 } <span class="keywordflow">else</span> {
04754 
04755                     <span class="comment">//</span>
04756                     <span class="comment">//  Reduce TempLength to RemainingLength if necessary.</span>
04757                     <span class="comment">//</span>
04758 
04759                     <span class="keywordflow">if</span> (TempLength &gt; RemainingLength) {
04760                         TempLength = RemainingLength;
04761                     }
04762                 }
04763 
04764                 <span class="comment">//</span>
04765                 <span class="comment">//  Reduce RemainingLength by what we processed.</span>
04766                 <span class="comment">//</span>
04767 
04768                 RemainingLength -= TempLength;
04769 
04770             <span class="comment">//</span>
04771             <span class="comment">//  Loop until done.</span>
04772             <span class="comment">//</span>
04773 
04774             } <span class="keywordflow">while</span> (RemainingLength != 0);
04775 
04776             <a class="code" href="../../d5/d2/cachedat_8c.html#a70">CcLazyWriteHotSpots</a> += HotSpot;
04777 
04778             <span class="comment">//</span>
04779             <span class="comment">//  Now flush, now flush if we do not think it is a hot spot.</span>
04780             <span class="comment">//</span>
04781 
04782             <span class="keywordflow">if</span> (!HotSpot) {
04783 
04784                 <a class="code" href="../../d6/d5/flushsec_8c.html#a8">MmFlushSection</a>( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o10">FileObject</a>-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o6">SectionObjectPointer</a>,
04785                                 &amp;NextFileOffset,
04786                                 NextLength,
04787                                 IoStatus,
04788                                 !IsLazyWriter );
04789 
04790                 <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(IoStatus-&gt;Status)) {
04791 
04792                     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a79">LAZY_WRITE_OCCURRED</a>)) {
04793 
04794                         <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
04795                         <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a79">LAZY_WRITE_OCCURRED</a>);
04796                         <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
04797                     }
04798 
04799                     <span class="comment">//</span>
04800                     <span class="comment">//  Increment performance counters</span>
04801                     <span class="comment">//</span>
04802 
04803                     <span class="keywordflow">if</span> (IsLazyWriter) {
04804 
04805                         <a class="code" href="../../d5/d2/cachedat_8c.html#a71">CcLazyWriteIos</a> += 1;
04806                         <a class="code" href="../../d5/d2/cachedat_8c.html#a72">CcLazyWritePages</a> += (NextLength + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1) &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
04807                     }
04808 
04809                 } <span class="keywordflow">else</span> {
04810 
04811                     LARGE_INTEGER <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> = NextFileOffset;
04812                     ULONG RetryLength = NextLength;
04813 
04814                     <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>( 0, 0, <span class="stringliteral">"I/O Error on Cache Flush: %08lx, %08lx\n"</span>,
04815                                  IoStatus-&gt;Status, IoStatus-&gt;Information );
04816 
04817                     <span class="keywordflow">if</span> (<a class="code" href="../../d6/d2/cachesub_8c.html#a2">RetryError</a>(IoStatus-&gt;Status)) {
04818 
04819                         VerifyRequired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04820 
04821                     <span class="comment">//</span>
04822                     <span class="comment">//  Loop to write each page individually, starting with one</span>
04823                     <span class="comment">//  more try on the page that got the error, in case that page</span>
04824                     <span class="comment">//  or any page beyond it can be successfully written</span>
04825                     <span class="comment">//  individually.  Note that Offset and RetryLength are</span>
04826                     <span class="comment">//  guaranteed to be in integral pages, but the Information</span>
04827                     <span class="comment">//  field from the failed request is not.</span>
04828                     <span class="comment">//</span>
04829                     <span class="comment">//  We ignore errors now, and give it one last shot, before</span>
04830                     <span class="comment">//  setting the pages clean (see below).</span>
04831                     <span class="comment">//</span>
04832 
04833                     } <span class="keywordflow">else</span> {
04834 
04835                         <span class="keywordflow">do</span> {
04836 
04837                             <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>( 0, 0, <span class="stringliteral">"Trying page at offset %08lx, %08lx\n"</span>,
04838                                          <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.LowPart, <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.HighPart );
04839 
04840                             <a class="code" href="../../d6/d5/flushsec_8c.html#a8">MmFlushSection</a> ( SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o10">FileObject</a>-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o6">SectionObjectPointer</a>,
04841                                              &amp;<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>,
04842                                              <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>,
04843                                              IoStatus,
04844                                              !IsLazyWriter );
04845 
04846                             <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>( 0, 0, <span class="stringliteral">"I/O status = %08lx, %08lx\n"</span>,
04847                                          IoStatus-&gt;Status, IoStatus-&gt;Information );
04848 
04849                             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(IoStatus-&gt;Status)) {
04850                                 <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
04851                                 <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a79">LAZY_WRITE_OCCURRED</a>);
04852                                 <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
04853                             }
04854 
04855                             <span class="keywordflow">if</span> ((!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(IoStatus-&gt;Status)) &amp;&amp; !<a class="code" href="../../d6/d2/cachesub_8c.html#a2">RetryError</a>(IoStatus-&gt;Status)) {
04856 
04857                                 PopupRequired = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04858                                 PopupStatus = IoStatus-&gt;Status;
04859                             }
04860 
04861                             VerifyRequired = VerifyRequired || <a class="code" href="../../d6/d2/cachesub_8c.html#a2">RetryError</a>(IoStatus-&gt;Status);
04862 
04863                             <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.QuadPart = <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.QuadPart + (LONGLONG)<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
04864                             RetryLength -= <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
04865 
04866                         } <span class="keywordflow">while</span>(RetryLength &gt; 0);
04867                     }
04868                 }
04869             }
04870 
04871             <span class="comment">//</span>
04872             <span class="comment">//  Now release the Bcb resources and set them clean.  Note we do not check</span>
04873             <span class="comment">//  here for errors, and just returned in the I/O status.  Errors on writes</span>
04874             <span class="comment">//  are rare to begin with.  Nonetheless, our strategy is to rely on</span>
04875             <span class="comment">//  one or more of the following (depending on the file system) to prevent</span>
04876             <span class="comment">//  errors from getting to us.</span>
04877             <span class="comment">//</span>
04878             <span class="comment">//      - Retries and/or other forms of error recovery in the disk driver</span>
04879             <span class="comment">//      - Mirroring driver</span>
04880             <span class="comment">//      - Hot fixing in the noncached path of the file system</span>
04881             <span class="comment">//</span>
04882             <span class="comment">//  In the unexpected case that a write error does get through, we</span>
04883             <span class="comment">//  *currently* just set the Bcbs clean anyway, rather than let</span>
04884             <span class="comment">//  Bcbs and pages accumulate which cannot be written.  Note we did</span>
04885             <span class="comment">//  a popup above to at least notify the guy.</span>
04886             <span class="comment">//</span>
04887             <span class="comment">//  Set the pages dirty again if we either saw a HotSpot or got</span>
04888             <span class="comment">//  verify required.</span>
04889             <span class="comment">//</span>
04890 
04891             <a class="code" href="../../d6/d2/cachesub_8c.html#a8">CcReleaseByteRangeFromWrite</a> ( SharedCacheMap,
04892                                           &amp;NextFileOffset,
04893                                           NextLength,
04894                                           FirstBcb,
04895                                           (BOOLEAN)(HotSpot || VerifyRequired) );
04896 
04897             <span class="comment">//</span>
04898             <span class="comment">//  See if there is any deferred writes we should post.</span>
04899             <span class="comment">//</span>
04900 
04901             BytesWritten += NextLength;
04902             <span class="keywordflow">if</span> ((BytesWritten &gt;= 0x40000) &amp;&amp; !IsListEmpty(&amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a29">CcDeferredWrites</a>)) {
04903                 <a class="code" href="../../d5/d5/cc_8h.html#a174">CcPostDeferredWrites</a>();
04904                 BytesWritten = 0;
04905             }
04906 
04907             <span class="comment">//</span>
04908             <span class="comment">//  If we're the lazy writer and have spent more than the active tick</span>
04909             <span class="comment">//  length in this loop, break out for a requeue so we share the</span>
04910             <span class="comment">//  file resources.</span>
04911             <span class="comment">//</span>
04912             
04913             <span class="keywordflow">if</span> (IsLazyWriter) {
04914 
04915                 <a class="code" href="../../d7/d0/ke_2miscc_8c.html#a4">KeQueryTickCount</a>( &amp;CurrentTick );
04916 
04917                 <span class="comment">//</span>
04918                 <span class="comment">//  Note that CcIdleDelay is a relative (negative) timestamp.</span>
04919                 <span class="comment">//</span>
04920 
04921                 <span class="keywordflow">if</span> (CurrentTick.QuadPart &gt; EndTick.QuadPart) {
04922 
04923                     IoStatus-&gt;Information = <a class="code" href="../../d5/d5/cc_8h.html#a56">CC_REQUEUE</a>;
04924                     <span class="keywordflow">break</span>;
04925                 }
04926             }
04927 
04928             <span class="comment">//</span>
04929             <span class="comment">//  Now for explicit flushes, we should advance our range.</span>
04930             <span class="comment">//</span>
04931 
04932             <span class="keywordflow">if</span> (ARGUMENT_PRESENT(FileOffset)) {
04933 
04934                 NextFileOffset.QuadPart += NextLength;
04935 
04936                 <span class="comment">//</span>
04937                 <span class="comment">//  Done yet?</span>
04938                 <span class="comment">//</span>
04939 
04940                 <span class="keywordflow">if</span> ((FileOffset-&gt;QuadPart + Length) &lt;= NextFileOffset.QuadPart) {
04941                     <span class="keywordflow">break</span>;
04942                 }
04943 
04944                 <span class="comment">//</span>
04945                 <span class="comment">//  Calculate new target range</span>
04946                 <span class="comment">//</span>
04947 
04948                 NextLength = (ULONG)((FileOffset-&gt;QuadPart + Length) - NextFileOffset.QuadPart);
04949                 TargetOffset = NextFileOffset;
04950             }
04951         }
04952     }
04953 
04954     <span class="comment">//</span>
04955     <span class="comment">//  See if there are any deferred writes we should post if</span>
04956     <span class="comment">//  we escaped the loop without checking after a series of</span>
04957     <span class="comment">//  flushes.</span>
04958     <span class="comment">//</span>
04959 
04960     <span class="keywordflow">if</span> (BytesWritten != 0 &amp;&amp; !IsListEmpty(&amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a29">CcDeferredWrites</a>)) {
04961 
04962         <a class="code" href="../../d5/d5/cc_8h.html#a174">CcPostDeferredWrites</a>();
04963     }
04964 
04965     <span class="comment">//</span>
04966     <span class="comment">//  Now we can get rid of the open count, and clean up as required.</span>
04967     <span class="comment">//</span>
04968 
04969     <span class="keywordflow">if</span> (SharedCacheMap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04970 
04971         <span class="comment">//</span>
04972         <span class="comment">//  Serialize again to decrement the open count.</span>
04973         <span class="comment">//</span>
04974 
04975         <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
04976 
04977         <a class="code" href="../../d5/d5/cc_8h.html#a69">CcDecrementOpenCount</a>( SharedCacheMap, 'fcCF' );
04978 
04979         <span class="keywordflow">if</span> ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o2">OpenCount</a> == 0) &amp;&amp;
04980             !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a74">WRITE_QUEUED</a>) &amp;&amp;
04981             (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> == 0)) {
04982 
04983             <span class="comment">//</span>
04984             <span class="comment">//  Move to the dirty list.</span>
04985             <span class="comment">//</span>
04986 
04987             RemoveEntryList( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
04988             InsertTailList( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a2">CcDirtySharedCacheMapList</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a>,
04989                             &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
04990 
04991             <span class="comment">//</span>
04992             <span class="comment">//  Make sure the Lazy Writer will wake up, because we</span>
04993             <span class="comment">//  want him to delete this SharedCacheMap.</span>
04994             <span class="comment">//</span>
04995 
04996             <a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o6">OtherWork</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04997             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o5">ScanActive</a>) {
04998                 <a class="code" href="../../d5/d5/cc_8h.html#a185">CcScheduleLazyWriteScan</a>();
04999             }
05000         }
05001 
05002         <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
05003     }
05004 
05005     <span class="comment">//</span>
05006     <span class="comment">//  Make sure and return the first error to our caller.  In the</span>
05007     <span class="comment">//  case of the Lazy Writer, a popup will be issued.</span>
05008     <span class="comment">//</span>
05009 
05010     <span class="keywordflow">if</span> (PopupRequired) {
05011         IoStatus-&gt;Status = PopupStatus;
05012     }
05013 
05014     <span class="comment">//</span>
05015     <span class="comment">//  Let the Lazy writer know if we did anything, so he can</span>
05016 
05017     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcFlushCache -&gt; VOID\n"</span>, 0 );
05018 
05019     <span class="keywordflow">return</span>;
05020 }
05021 
05022 
05023 PVOID
<a name="l05024"></a><a class="code" href="../../d4/d2/cache_8h.html#a67">05024</a> <a class="code" href="../../d4/d2/cache_8h.html#a67">CcRemapBcb</a> (
05025     IN PVOID Bcb
05026     )
05027 
05028 <span class="comment">/*++</span>
05029 <span class="comment"></span>
05030 <span class="comment">Routine Description:</span>
05031 <span class="comment"></span>
05032 <span class="comment">    This routine may be called by a file system to map a Bcb an additional</span>
05033 <span class="comment">    time in order to preserve it through several calls that perform additional</span>
05034 <span class="comment">    maps and unpins.</span>
05035 <span class="comment"></span>
05036 <span class="comment"></span>
05037 <span class="comment">Arguments:</span>
05038 <span class="comment"></span>
05039 <span class="comment">    Bcb - Supplies a pointer to a previously returned Bcb.</span>
05040 <span class="comment"></span>
05041 <span class="comment">Return Value:</span>
05042 <span class="comment"></span>
05043 <span class="comment">    Bcb with read-only indicator.</span>
05044 <span class="comment"></span>
05045 <span class="comment">--*/</span>
05046 
05047 {
05048     KIRQL OldIrql;
05049     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> Vacb;
05050 
05051     <span class="comment">//</span>
05052     <span class="comment">//  Remove read-only bit</span>
05053     <span class="comment">//</span>
05054 
05055     Bcb = (PVOID) ((ULONG_PTR)Bcb &amp; ~1);
05056 
05057     <span class="keywordflow">if</span> (((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb)-&gt;NodeTypeCode == <a class="code" href="../../d5/d5/cc_8h.html#a17">CACHE_NTC_OBCB</a>) {
05058 
05059         <span class="comment">//</span>
05060         <span class="comment">//  If this is an overlapped BCB, use the first Vacb in the</span>
05061         <span class="comment">//  array</span>
05062         <span class="comment">//</span>
05063 
05064         Vacb = ((<a class="code" href="../../d6/d4/struct__OBCB.html">POBCB</a>)Bcb)-&gt;Bcbs[0]-&gt;Vacb;
05065 
05066     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb)-&gt;NodeTypeCode == <a class="code" href="../../d5/d5/cc_8h.html#a14">CACHE_NTC_BCB</a>) {
05067 
05068         <span class="comment">//</span>
05069         <span class="comment">//  If this is a BCB, extract the Vcb from it</span>
05070         <span class="comment">//</span>
05071 
05072         Vacb = ((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb)-&gt;Vacb;
05073 
05074     } <span class="keywordflow">else</span> {
05075 
05076         <span class="comment">//</span>
05077         <span class="comment">//  Otherwise, there is no signature to match. Assume</span>
05078         <span class="comment">//  it is a Vacb.</span>
05079         <span class="comment">//</span>
05080 
05081         Vacb = (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a>) Bcb;
05082     }
05083 
05084     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((Vacb &gt;= <a class="code" href="../../d5/d2/cachedat_8c.html#a20">CcVacbs</a>) &amp;&amp; (Vacb &lt; <a class="code" href="../../d5/d2/cachedat_8c.html#a21">CcBeyondVacbs</a>));
05085 
05086     <span class="comment">//</span>
05087     <span class="comment">//  Safely bump the active count</span>
05088     <span class="comment">//</span>
05089 
05090     <a class="code" href="../../d5/d5/cc_8h.html#a4">CcAcquireVacbLock</a>( &amp;OldIrql );
05091 
05092     Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o4">Overlay</a>.ActiveCount += 1;
05093 
05094     <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( OldIrql );
05095 
05096     <span class="keywordflow">return</span> (PVOID) ((ULONG_PTR)Vacb | 1);
05097 }
05098 
05099 
05100 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l05101"></a><a class="code" href="../../d4/d2/cache_8h.html#a68">05101</a> <a class="code" href="../../d4/d2/cache_8h.html#a68">CcRepinBcb</a> (
05102     IN PVOID Bcb
05103     )
05104 
05105 <span class="comment">/*++</span>
05106 <span class="comment"></span>
05107 <span class="comment">Routine Description:</span>
05108 <span class="comment"></span>
05109 <span class="comment">    This routine may be called by a file system to pin a Bcb an additional</span>
05110 <span class="comment">    time in order to reserve it for Write Through or error recovery.</span>
05111 <span class="comment">    Typically the file system would do this the first time that it sets a</span>
05112 <span class="comment">    pinned buffer dirty while processing a WriteThrough request, or any</span>
05113 <span class="comment">    time that it determines that a buffer will be required for WriteThrough.</span>
05114 <span class="comment"></span>
05115 <span class="comment">    The call to this routine must be followed by a call to CcUnpinRepinnedBcb.</span>
05116 <span class="comment">    CcUnpinRepinnedBcb should normally be called during request completion</span>
05117 <span class="comment">    after all other resources have been released.  CcUnpinRepinnedBcb</span>
05118 <span class="comment">    synchronously writes the buffer (for WriteThrough requests) and performs</span>
05119 <span class="comment">    the matching unpin for this call.</span>
05120 <span class="comment"></span>
05121 <span class="comment">Arguments:</span>
05122 <span class="comment"></span>
05123 <span class="comment">    Bcb - Supplies a pointer to a previously pinned Bcb</span>
05124 <span class="comment"></span>
05125 <span class="comment">Return Value:</span>
05126 <span class="comment"></span>
05127 <span class="comment">    None.</span>
05128 <span class="comment"></span>
05129 <span class="comment">--*/</span>
05130 
05131 {
05132     KIRQL OldIrql;
05133 
05134     ExAcquireFastLock( &amp;((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb)-&gt;SharedCacheMap-&gt;BcbSpinLock, &amp;OldIrql );
05135 
05136     ((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb)-&gt;PinCount += 1;
05137 
05138     ExReleaseFastLock( &amp;((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb)-&gt;SharedCacheMap-&gt;BcbSpinLock, OldIrql );
05139 }
05140 
05141 
05142 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l05143"></a><a class="code" href="../../d4/d2/cache_8h.html#a69">05143</a> <a class="code" href="../../d4/d2/cache_8h.html#a69">CcUnpinRepinnedBcb</a> (
05144     IN PVOID Bcb,
05145     IN BOOLEAN WriteThrough,
05146     OUT PIO_STATUS_BLOCK IoStatus
05147     )
05148 
05149 <span class="comment">/*++</span>
05150 <span class="comment"></span>
05151 <span class="comment">Routine Description:</span>
05152 <span class="comment"></span>
05153 <span class="comment">    This routine may be called to Write a previously pinned buffer</span>
05154 <span class="comment">    through to the file.  It must have been preceded by a call to</span>
05155 <span class="comment">    CcRepinBcb.  As this routine must acquire the Bcb</span>
05156 <span class="comment">    resource exclusive, the caller must be extremely careful to avoid</span>
05157 <span class="comment">    deadlocks.  Ideally the caller owns no resources at all when it</span>
05158 <span class="comment">    calls this routine, or else the caller should guarantee that it</span>
05159 <span class="comment">    has nothing else pinned in this same file.  (The latter rule is</span>
05160 <span class="comment">    the one used to avoid deadlocks in calls from CcCopyWrite and</span>
05161 <span class="comment">    CcMdlWrite.)</span>
05162 <span class="comment"></span>
05163 <span class="comment">Arguments:</span>
05164 <span class="comment"></span>
05165 <span class="comment">    Bcb - Pointer to a Bcb which was previously specified in a call</span>
05166 <span class="comment">          to CcRepinBcb.</span>
05167 <span class="comment"></span>
05168 <span class="comment">    WriteThrough - TRUE if the Bcb should be written through.</span>
05169 <span class="comment"></span>
05170 <span class="comment">    IoStatus - Returns the I/O status for the operation.</span>
05171 <span class="comment"></span>
05172 <span class="comment">Return Value:</span>
05173 <span class="comment"></span>
05174 <span class="comment">    None.</span>
05175 <span class="comment"></span>
05176 <span class="comment">--*/</span>
05177 
05178 {
05179     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap = ((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb)-&gt;SharedCacheMap;
05180 
05181     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcUnpinRepinnedBcb\n"</span>, 0 );
05182     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    Bcb = %08lx\n"</span>, Bcb );
05183     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    WriteThrough = %02lx\n"</span>, WriteThrough );
05184 
05185     <span class="comment">//</span>
05186     <span class="comment">//  Set status to success for non write through case.</span>
05187     <span class="comment">//</span>
05188 
05189     IoStatus-&gt;Status = STATUS_SUCCESS;
05190 
05191     <span class="keywordflow">if</span> (WriteThrough) {
05192 
05193         <span class="comment">//</span>
05194         <span class="comment">//  Acquire Bcb exclusive to eliminate possible modifiers of the buffer,</span>
05195         <span class="comment">//  since we are about to write its buffer.</span>
05196         <span class="comment">//</span>
05197 
05198         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a78">MODIFIED_WRITE_DISABLED</a>)) {
05199             <a class="code" href="../../d5/d8/ex_8h.html#a70">ExAcquireResourceExclusive</a>( &amp;((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb)-&gt;<a class="code" href="../../d4/d0/tex_8c.html#a21">Resource</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
05200         }
05201 
05202         <span class="comment">//</span>
05203         <span class="comment">//  Now, there is a chance that the LazyWriter has already written</span>
05204         <span class="comment">//  it, since the resource was free.  We will only write it if it</span>
05205         <span class="comment">//  is still dirty.</span>
05206         <span class="comment">//</span>
05207 
05208         <span class="keywordflow">if</span> (((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb)-&gt;Dirty) {
05209 
05210             <span class="comment">//</span>
05211             <span class="comment">//  First we make sure that the dirty bit in the PFN database is set.</span>
05212             <span class="comment">//</span>
05213 
05214             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( ((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb)-&gt;BaseAddress != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
05215             <a class="code" href="../../d5/d6/iosup_8c.html#a74">MmSetAddressRangeModified</a>( ((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb)-&gt;BaseAddress,
05216                                        ((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb)-&gt;ByteLength );
05217 
05218             <span class="comment">//</span>
05219             <span class="comment">//  Now release the Bcb resource and set it clean.  Note we do not check</span>
05220             <span class="comment">//  here for errors, and just return the I/O status.  Errors on writes</span>
05221             <span class="comment">//  are rare to begin with.  Nonetheless, our strategy is to rely on</span>
05222             <span class="comment">//  one or more of the following (depending on the file system) to prevent</span>
05223             <span class="comment">//  errors from getting to us.</span>
05224             <span class="comment">//</span>
05225             <span class="comment">//      - Retries and/or other forms of error recovery in the disk driver</span>
05226             <span class="comment">//      - Mirroring driver</span>
05227             <span class="comment">//      - Hot fixing in the noncached path of the file system</span>
05228             <span class="comment">//</span>
05229             <span class="comment">//  In the unexpected case that a write error does get through, we</span>
05230             <span class="comment">//  report it to our caller, but go ahead and set the Bcb clean.  There</span>
05231             <span class="comment">//  seems to be no point in letting Bcbs (and pages in physical memory)</span>
05232             <span class="comment">//  accumulate which can never go away because we get an unrecoverable I/O</span>
05233             <span class="comment">//  error.</span>
05234             <span class="comment">//</span>
05235 
05236             <span class="comment">//</span>
05237             <span class="comment">//  We specify TRUE here for ReadOnly so that we will keep the</span>
05238             <span class="comment">//  resource during the flush.</span>
05239             <span class="comment">//</span>
05240 
05241             <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, <a class="code" href="../../d5/d5/cc_8h.html#a211a173">SET_CLEAN</a> );
05242 
05243             <span class="comment">//</span>
05244             <span class="comment">//  Write it out.</span>
05245             <span class="comment">//</span>
05246 
05247             <a class="code" href="../../d6/d5/flushsec_8c.html#a8">MmFlushSection</a>( ((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb)-&gt;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o10">FileObject</a>-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o6">SectionObjectPointer</a>,
05248                             &amp;((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb)-&gt;FileOffset,
05249                             ((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb)-&gt;ByteLength,
05250                             IoStatus,
05251                             <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
05252 
05253             <span class="comment">//</span>
05254             <span class="comment">//  If we got verify required, we have to mark the buffer dirty again</span>
05255             <span class="comment">//  so we will try again later.</span>
05256             <span class="comment">//</span>
05257 
05258             <span class="keywordflow">if</span> (<a class="code" href="../../d6/d2/cachesub_8c.html#a2">RetryError</a>(IoStatus-&gt;Status)) {
05259                 <a class="code" href="../../d4/d2/cache_8h.html#a91">CcSetDirtyPinnedData</a>( (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
05260             }
05261 
05262             <span class="comment">//</span>
05263             <span class="comment">//  Now remove the final pin count now that we have set it clean.</span>
05264             <span class="comment">//</span>
05265 
05266             <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, <a class="code" href="../../d5/d5/cc_8h.html#a211a171">UNPIN</a> );
05267 
05268             <span class="comment">//</span>
05269             <span class="comment">//  See if there is any deferred writes we can post.</span>
05270             <span class="comment">//</span>
05271 
05272             <span class="keywordflow">if</span> (!IsListEmpty(&amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a29">CcDeferredWrites</a>)) {
05273                 <a class="code" href="../../d5/d5/cc_8h.html#a174">CcPostDeferredWrites</a>();
05274             }
05275         }
05276         <span class="keywordflow">else</span> {
05277 
05278             <span class="comment">//</span>
05279             <span class="comment">//  Lazy Writer got there first, just free the resource and unpin.</span>
05280             <span class="comment">//</span>
05281 
05282             <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, <a class="code" href="../../d5/d5/cc_8h.html#a211a171">UNPIN</a> );
05283 
05284         }
05285 
05286         <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>(0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    &lt;IoStatus = %08lx, %08lx\n"</span>, IoStatus-&gt;Status,
05287                                                              IoStatus-&gt;Information );
05288     }
05289 
05290     <span class="comment">//</span>
05291     <span class="comment">//  Non-WriteThrough case</span>
05292     <span class="comment">//</span>
05293 
05294     <span class="keywordflow">else</span> {
05295 
05296         <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, <a class="code" href="../../d5/d5/cc_8h.html#a211a171">UNPIN</a> );
05297 
05298         <span class="comment">//</span>
05299         <span class="comment">//  Set status to success for non write through case.</span>
05300         <span class="comment">//</span>
05301 
05302         IoStatus-&gt;Status = STATUS_SUCCESS;
05303     }
05304 
05305     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcUnpinRepinnedBcb -&gt; VOID\n"</span>, 0 );
05306 }
05307 
05308 
05309 <span class="comment">//</span>
05310 <span class="comment">//  Internal Support Routine</span>
05311 <span class="comment">//</span>
05312 
05313 BOOLEAN
<a name="l05314"></a><a class="code" href="../../d6/d2/cachesub_8c.html#a4">05314</a> <a class="code" href="../../d6/d2/cachesub_8c.html#a4">CcFindBcb</a> (
05315     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap,
05316     IN PLARGE_INTEGER FileOffset,
05317     IN OUT PLARGE_INTEGER BeyondLastByte,
05318     OUT <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> *Bcb
05319     )
05320 
05321 <span class="comment">/*++</span>
05322 <span class="comment"></span>
05323 <span class="comment">Routine Description:</span>
05324 <span class="comment"></span>
05325 <span class="comment">    This routine is called to find a Bcb describing the specified byte range</span>
05326 <span class="comment">    of a file.  It returns TRUE if it could at least find a Bcb which describes</span>
05327 <span class="comment">    the beginning of the specified byte range, or else FALSE if the first</span>
05328 <span class="comment">    part of the byte range is not present.  In the latter case, the requested</span>
05329 <span class="comment">    byte range (TrialLength) is truncated if there is currently a Bcb which</span>
05330 <span class="comment">    describes bytes beyond the beginning of the byte range.</span>
05331 <span class="comment"></span>
05332 <span class="comment">    The caller may see if the entire byte range is being returned by examining</span>
05333 <span class="comment">    the Bcb, and the caller (or caller's caller) may then make subsequent</span>
05334 <span class="comment">    calls if the data is not all returned.</span>
05335 <span class="comment"></span>
05336 <span class="comment">    The BcbSpinLock must be currently acquired.</span>
05337 <span class="comment"></span>
05338 <span class="comment">Arguments:</span>
05339 <span class="comment"></span>
05340 <span class="comment">    SharedCacheMap - Supplies a pointer to the SharedCacheMap for the file</span>
05341 <span class="comment">                     in which the byte range is desired.</span>
05342 <span class="comment"></span>
05343 <span class="comment">    FileOffset - Supplies the file offset for the beginning of the desired</span>
05344 <span class="comment">                 byte range.</span>
05345 <span class="comment"></span>
05346 <span class="comment">    BeyondLastByte - Supplies the file offset of the ending of the desired</span>
05347 <span class="comment">                  byte range + 1.  Note that this offset will be truncated</span>
05348 <span class="comment">                  on return if the Bcb was not found, but bytes beyond the</span>
05349 <span class="comment">                  beginning of the Bcb are contained in another Bcb.</span>
05350 <span class="comment"></span>
05351 <span class="comment">    Bcb - returns a Bcb describing the beginning of the byte range if also</span>
05352 <span class="comment">          returning TRUE, or else the point in the Bcb list to insert after.</span>
05353 <span class="comment"></span>
05354 <span class="comment">Return Value:</span>
05355 <span class="comment"></span>
05356 <span class="comment">    FALSE - if no Bcb describes the beginning of the desired byte range</span>
05357 <span class="comment"></span>
05358 <span class="comment">    TRUE - if a Bcb is being returned describing at least an initial</span>
05359 <span class="comment">           part of the byte range.</span>
05360 <span class="comment"></span>
05361 <span class="comment">--*/</span>
05362 
05363 {
05364     PLIST_ENTRY BcbList;
05365     <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> Bcbt;
05366     BOOLEAN Found = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
05367 
05368     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcFindBcb:\n"</span>, 0 );
05369     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    SharedCacheMap = %08lx\n"</span>, SharedCacheMap );
05370     <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>(0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    FileOffset = %08lx, %08lx\n"</span>, FileOffset-&gt;LowPart,
05371                                                           FileOffset-&gt;HighPart );
05372     <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>(0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    TrialLength = %08lx, %08lx\n"</span>, TrialLength-&gt;LowPart,
05373                                                            TrialLength-&gt;HighPart );
05374 
05375     <span class="comment">//</span>
05376     <span class="comment">//  We want to terminate scans by testing the NodeTypeCode field from the</span>
05377     <span class="comment">//  BcbLinks, so we want to see the SharedCacheMap signature from the same</span>
05378     <span class="comment">//  offset.</span>
05379     <span class="comment">//</span>
05380 
05381     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(FIELD_OFFSET(<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">SHARED_CACHE_MAP</a>, BcbList) == FIELD_OFFSET(<a class="code" href="../../d4/d3/struct__BCB.html">BCB</a>, BcbLinks));
05382 
05383     <span class="comment">//</span>
05384     <span class="comment">//  Similarly, when we hit one of the BcbListHeads in the array, small negative</span>
05385     <span class="comment">//  offsets are all structure pointers, so we are counting on the Bcb signature</span>
05386     <span class="comment">//  to have some non-Ulong address bits set.</span>
05387     <span class="comment">//</span>
05388 
05389     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((<a class="code" href="../../d5/d5/cc_8h.html#a14">CACHE_NTC_BCB</a> &amp; 3) != 0);
05390 
05391     <span class="comment">//</span>
05392     <span class="comment">//  Get address of Bcb listhead that is *after* the Bcb we are looking for,</span>
05393     <span class="comment">//  for backwards scan.  It is important that we fail in the forward</span>
05394     <span class="comment">//  direction so that we are looking in the right segment of the Bcb list.</span>
05395     <span class="comment">//</span>
05396 
05397     BcbList = <a class="code" href="../../d5/d5/cc_8h.html#a49">GetBcbListHead</a>( SharedCacheMap, FileOffset-&gt;QuadPart + <a class="code" href="../../d5/d5/cc_8h.html#a47">SIZE_PER_BCB_LIST</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
05398 
05399     <span class="comment">//</span>
05400     <span class="comment">//  Search for an entry that overlaps the specified range, or until we hit</span>
05401     <span class="comment">//  a listhead.</span>
05402     <span class="comment">//</span>
05403 
05404     Bcbt = CONTAINING_RECORD(BcbList-&gt;Flink, <a class="code" href="../../d5/d5/cc_8h.html#a109">BCB</a>, BcbLinks);
05405 
05406     <span class="comment">//</span>
05407     <span class="comment">//  First see if we really have to do Large arithmetic or not, and</span>
05408     <span class="comment">//  then use either a 32-bit loop or a 64-bit loop to search for</span>
05409     <span class="comment">//  the Bcb.</span>
05410     <span class="comment">//</span>
05411 
05412     <span class="keywordflow">if</span> (FileOffset-&gt;HighPart == 0 &amp;&amp;
05413         Bcbt-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o0">NodeTypeCode</a> == <a class="code" href="../../d5/d5/cc_8h.html#a14">CACHE_NTC_BCB</a> &amp;&amp;
05414         Bcbt-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o5">BeyondLastByte</a>.HighPart == 0) {
05415 
05416         <span class="comment">//</span>
05417         <span class="comment">//  32-bit - loop until we get back to a listhead.</span>
05418         <span class="comment">//</span>
05419 
05420         <span class="keywordflow">while</span> (Bcbt-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o0">NodeTypeCode</a> == <a class="code" href="../../d5/d5/cc_8h.html#a14">CACHE_NTC_BCB</a>) {
05421 
05422             <span class="comment">//</span>
05423             <span class="comment">//  Since the Bcb list is in descending order, we first check</span>
05424             <span class="comment">//  if we are completely beyond the current entry, and if so</span>
05425             <span class="comment">//  get out.</span>
05426             <span class="comment">//</span>
05427 
05428             <span class="keywordflow">if</span> (FileOffset-&gt;LowPart &gt;= Bcbt-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o5">BeyondLastByte</a>.LowPart) {
05429                 <span class="keywordflow">break</span>;
05430             }
05431 
05432             <span class="comment">//</span>
05433             <span class="comment">//  Next check if the first byte we are looking for is</span>
05434             <span class="comment">//  contained in the current Bcb.  If so, we either have</span>
05435             <span class="comment">//  a partial hit and must truncate to the exact amount</span>
05436             <span class="comment">//  we have found, or we may have a complete hit.  In</span>
05437             <span class="comment">//  either case we break with Found == TRUE.</span>
05438             <span class="comment">//</span>
05439 
05440             <span class="keywordflow">if</span> (FileOffset-&gt;LowPart &gt;= Bcbt-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o3">FileOffset</a>.LowPart) {
05441                 Found = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
05442                 <span class="keywordflow">break</span>;
05443             }
05444 
05445             <span class="comment">//</span>
05446             <span class="comment">//  Now we know we must loop back and keep looking, but we</span>
05447             <span class="comment">//  still must check for the case where the tail end of the</span>
05448             <span class="comment">//  bytes we are looking for are described by the current</span>
05449             <span class="comment">//  Bcb.  If so we must truncate what we are looking for,</span>
05450             <span class="comment">//  because this routine is only supposed to return bytes</span>
05451             <span class="comment">//  from the start of the desired range.</span>
05452             <span class="comment">//</span>
05453 
05454             <span class="keywordflow">if</span> (BeyondLastByte-&gt;LowPart &gt;= Bcbt-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o3">FileOffset</a>.LowPart) {
05455                 BeyondLastByte-&gt;LowPart = Bcbt-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o3">FileOffset</a>.LowPart;
05456             }
05457 
05458             <span class="comment">//</span>
05459             <span class="comment">//  Advance to next entry in list (which is possibly back to</span>
05460             <span class="comment">//  the listhead) and loop back.</span>
05461             <span class="comment">//</span>
05462 
05463             Bcbt = CONTAINING_RECORD( Bcbt-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o4">BcbLinks</a>.Flink,
05464                                       <a class="code" href="../../d5/d5/cc_8h.html#a109">BCB</a>,
05465                                       BcbLinks );
05466 
05467         }
05468 
05469     } <span class="keywordflow">else</span> {
05470 
05471         <span class="comment">//</span>
05472         <span class="comment">//  64-bit - Loop until we get back to a listhead.</span>
05473         <span class="comment">//</span>
05474 
05475         <span class="keywordflow">while</span> (Bcbt-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o0">NodeTypeCode</a> == <a class="code" href="../../d5/d5/cc_8h.html#a14">CACHE_NTC_BCB</a>) {
05476 
05477             <span class="comment">//</span>
05478             <span class="comment">//  Since the Bcb list is in descending order, we first check</span>
05479             <span class="comment">//  if we are completely beyond the current entry, and if so</span>
05480             <span class="comment">//  get out.</span>
05481             <span class="comment">//</span>
05482 
05483             <span class="keywordflow">if</span> (FileOffset-&gt;QuadPart &gt;= Bcbt-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o5">BeyondLastByte</a>.QuadPart) {
05484                 <span class="keywordflow">break</span>;
05485             }
05486 
05487             <span class="comment">//</span>
05488             <span class="comment">//  Next check if the first byte we are looking for is</span>
05489             <span class="comment">//  contained in the current Bcb.  If so, we either have</span>
05490             <span class="comment">//  a partial hit and must truncate to the exact amount</span>
05491             <span class="comment">//  we have found, or we may have a complete hit.  In</span>
05492             <span class="comment">//  either case we break with Found == TRUE.</span>
05493             <span class="comment">//</span>
05494 
05495             <span class="keywordflow">if</span> (FileOffset-&gt;QuadPart &gt;= Bcbt-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o3">FileOffset</a>.QuadPart) {
05496                 Found = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
05497                 <span class="keywordflow">break</span>;
05498             }
05499 
05500             <span class="comment">//</span>
05501             <span class="comment">//  Now we know we must loop back and keep looking, but we</span>
05502             <span class="comment">//  still must check for the case where the tail end of the</span>
05503             <span class="comment">//  bytes we are looking for are described by the current</span>
05504             <span class="comment">//  Bcb.  If so we must truncate what we are looking for,</span>
05505             <span class="comment">//  because this routine is only supposed to return bytes</span>
05506             <span class="comment">//  from the start of the desired range.</span>
05507             <span class="comment">//</span>
05508 
05509             <span class="keywordflow">if</span> (BeyondLastByte-&gt;QuadPart &gt;= Bcbt-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o3">FileOffset</a>.QuadPart) {
05510                 BeyondLastByte-&gt;QuadPart = Bcbt-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o3">FileOffset</a>.QuadPart;
05511             }
05512 
05513             <span class="comment">//</span>
05514             <span class="comment">//  Advance to next entry in list (which is possibly back to</span>
05515             <span class="comment">//  the listhead) and loop back.</span>
05516             <span class="comment">//</span>
05517 
05518             Bcbt = CONTAINING_RECORD( Bcbt-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o4">BcbLinks</a>.Flink,
05519                                       <a class="code" href="../../d5/d5/cc_8h.html#a109">BCB</a>,
05520                                       BcbLinks );
05521 
05522         }
05523     }
05524 
05525     *Bcb = Bcbt;
05526 
05527     <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>(0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    &lt;TrialLength = %08lx, %08lx\n"</span>, TrialLength-&gt;LowPart,
05528                                                             TrialLength-&gt;HighPart );
05529     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    &lt;Bcb = %08lx\n"</span>, *Bcb );
05530     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcFindBcb -&gt; %02lx\n"</span>, Found );
05531 
05532     <span class="keywordflow">return</span> Found;
05533 }
05534 
05535 
05536 <span class="comment">//</span>
05537 <span class="comment">//  Internal Support Routine</span>
05538 <span class="comment">//</span>
05539 
05540 <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>
<a name="l05541"></a><a class="code" href="../../d6/d2/cachesub_8c.html#a5">05541</a> <a class="code" href="../../d6/d2/cachesub_8c.html#a5">CcAllocateInitializeBcb</a> (
05542     IN OUT <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap OPTIONAL,
05543     IN OUT <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> AfterBcb,
05544     IN PLARGE_INTEGER FileOffset,
05545     IN PLARGE_INTEGER TrialLength
05546     )
05547 
05548 <span class="comment">/*++</span>
05549 <span class="comment"></span>
05550 <span class="comment">Routine Description:</span>
05551 <span class="comment"></span>
05552 <span class="comment">    This routine allocates and initializes a Bcb to describe the specified</span>
05553 <span class="comment">    byte range, and inserts it into the Bcb List of the specified Shared</span>
05554 <span class="comment">    Cache Map.  The Bcb List spin lock must currently be acquired.</span>
05555 <span class="comment"></span>
05556 <span class="comment">    BcbSpinLock must be acquired on entry.</span>
05557 <span class="comment"></span>
05558 <span class="comment">Arguments:</span>
05559 <span class="comment"></span>
05560 <span class="comment">    SharedCacheMap - Supplies the SharedCacheMap for the new Bcb.</span>
05561 <span class="comment"></span>
05562 <span class="comment">    AfterBcb - Supplies where in the descending-order BcbList the new Bcb</span>
05563 <span class="comment">               should be inserted: either the ListHead (masquerading as</span>
05564 <span class="comment">               a Bcb) or a Bcb.</span>
05565 <span class="comment"></span>
05566 <span class="comment">    FileOffset - Supplies File Offset for the desired data.</span>
05567 <span class="comment"></span>
05568 <span class="comment">    TrialLength - Supplies length of desired data.</span>
05569 <span class="comment"></span>
05570 <span class="comment">Return Value:</span>
05571 <span class="comment"></span>
05572 <span class="comment">    Address of the allocated and initialized Bcb</span>
05573 <span class="comment"></span>
05574 <span class="comment">--*/</span>
05575 
05576 {
05577     <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> Bcb;
05578     CSHORT NodeIsInZone;
05579     ULONG RoundedBcbSize = (<span class="keyword">sizeof</span>(<a class="code" href="../../d4/d3/struct__BCB.html">BCB</a>) + 7) &amp; ~7;
05580 
05581     <span class="comment">//</span>
05582     <span class="comment">//  Loop until we have a new Work Queue Entry</span>
05583     <span class="comment">//</span>
05584 
05585     <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
05586 
05587         PVOID Segment;
05588         ULONG SegmentSize;
05589 
05590         ExAcquireSpinLockAtDpcLevel( &amp;<a class="code" href="../../d5/d5/cc_8h.html#a122">CcBcbSpinLock</a> );
05591         Bcb = <a class="code" href="../../d5/d8/ex_8h.html#a56">ExAllocateFromZone</a>( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o2">BcbZone</a> );
05592         ExReleaseSpinLockFromDpcLevel( &amp;<a class="code" href="../../d5/d5/cc_8h.html#a122">CcBcbSpinLock</a> );
05593 
05594         <span class="keywordflow">if</span> (Bcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05595             NodeIsInZone = 1;
05596             <span class="keywordflow">break</span>;
05597         }
05598 
05599         <span class="comment">//</span>
05600         <span class="comment">//  Allocation failure - on large systems, extend zone by a page.</span>
05601         <span class="comment">//</span>
05602 
05603         <span class="keywordflow">if</span> ( <a class="code" href="../../d5/d1/mminit_8c.html#a57">MmQuerySystemSize</a>() == <a class="code" href="../../d2/d1/mm_8h.html#a343a167">MmLargeSystem</a> ) {
05604 
05605             SegmentSize = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
05606 
05607             <span class="keywordflow">if</span> ((Segment = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, SegmentSize, 'zBcC')) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05608                 <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05609             }
05610 
05611             ExAcquireSpinLockAtDpcLevel( &amp;<a class="code" href="../../d5/d5/cc_8h.html#a122">CcBcbSpinLock</a> );
05612             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d5/d8/ex_8h.html#a264">ExExtendZone</a>( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o2">BcbZone</a>, Segment, SegmentSize ))) {
05613                 <a class="code" href="../../d5/d5/cc_8h.html#a28">CcBugCheck</a>( 0, 0, 0 );
05614             }
05615             ExReleaseSpinLockFromDpcLevel( &amp;<a class="code" href="../../d5/d5/cc_8h.html#a122">CcBcbSpinLock</a> );
05616         } <span class="keywordflow">else</span> {
05617             <span class="keywordflow">if</span> ((Bcb = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d3/struct__BCB.html">BCB</a>), 'cBcC')) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05618                 <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05619             }
05620             NodeIsInZone = 0;
05621             <span class="keywordflow">break</span>;
05622         }
05623     }
05624 
05625     <span class="comment">//</span>
05626     <span class="comment">//  Initialize the newly allocated Bcb.  First zero it, then fill in</span>
05627     <span class="comment">//  nonzero fields.</span>
05628     <span class="comment">//</span>
05629 
05630     RtlZeroMemory( Bcb, RoundedBcbSize );
05631 
05632     Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o1">NodeIsInZone</a> = NodeIsInZone;
05633 
05634     <span class="comment">//</span>
05635     <span class="comment">//  For Mbcb's, SharedCacheMap is NULL, and the rest of this initialization</span>
05636     <span class="comment">//  is not desired.</span>
05637     <span class="comment">//</span>
05638 
05639     <span class="keywordflow">if</span> (SharedCacheMap != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05640 
05641         Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o0">NodeTypeCode</a> = <a class="code" href="../../d5/d5/cc_8h.html#a14">CACHE_NTC_BCB</a>;
05642         Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o3">FileOffset</a> = *FileOffset;
05643         Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o2">ByteLength</a> = TrialLength-&gt;LowPart;
05644         Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o5">BeyondLastByte</a>.QuadPart = FileOffset-&gt;QuadPart + TrialLength-&gt;QuadPart;
05645         Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o9">PinCount</a> += 1;
05646         <a class="code" href="../../d5/d8/ex_8h.html#a68">ExInitializeResource</a>( &amp;Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o10">Resource</a> );
05647         Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o11">SharedCacheMap</a> = SharedCacheMap;
05648 
05649         <span class="comment">//</span>
05650         <span class="comment">//  Since CcCalculateVacbLockCount has to be able to walk</span>
05651         <span class="comment">//  the BcbList with only the VacbSpinLock, we take that one</span>
05652         <span class="comment">//  out to change the list and set the count.</span>
05653         <span class="comment">//</span>
05654 
05655         <a class="code" href="../../d5/d5/cc_8h.html#a6">CcAcquireVacbLockAtDpcLevel</a>();
05656         InsertTailList( &amp;AfterBcb-&gt;BcbLinks, &amp;Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o4">BcbLinks</a> );
05657 
05658         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( (SharedCacheMap-&gt;SectionSize.QuadPart &lt; <a class="code" href="../../d5/d5/cc_8h.html#a41">VACB_SIZE_OF_FIRST_LEVEL</a>) ||
05659                 (<a class="code" href="../../d6/d2/cachesub_8c.html#a4">CcFindBcb</a>(SharedCacheMap, FileOffset, &amp;Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o5">BeyondLastByte</a>, &amp;AfterBcb) &amp;&amp;
05660                  (Bcb == AfterBcb)) );
05661 
05662         <span class="comment">//</span>
05663         <span class="comment">//  Now for large metadata streams we lock the Vacb level.</span>
05664         <span class="comment">//</span>
05665 
05666         <a class="code" href="../../d5/d5/cc_8h.html#a50">CcLockVacbLevel</a>( SharedCacheMap, FileOffset-&gt;QuadPart );
05667         <a class="code" href="../../d5/d5/cc_8h.html#a7">CcReleaseVacbLockFromDpcLevel</a>();
05668 
05669         <span class="comment">//</span>
05670         <span class="comment">//  If this resource was no write behind, let Ex know that the</span>
05671         <span class="comment">//  resource will never be acquired exclusive.  Also disable</span>
05672         <span class="comment">//  boost (I know this is useless, but KenR said I had to do it).</span>
05673         <span class="comment">//</span>
05674 
05675         <span class="keywordflow">if</span> (SharedCacheMap &amp;&amp;
05676             <a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;Flags, <a class="code" href="../../d5/d5/cc_8h.html#a71">DISABLE_WRITE_BEHIND</a>)) {
05677 <span class="preprocessor">#if DBG</span>
05678 <span class="preprocessor"></span>            <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>(Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o10">Resource</a>.<a class="code" href="../../d6/d4/struct__ERESOURCE.html#o3">Flag</a>, <a class="code" href="../../d5/d8/ex_8h.html#a62">ResourceNeverExclusive</a>);
05679 <span class="preprocessor">#endif</span>
05680 <span class="preprocessor"></span>            <a class="code" href="../../d5/d8/ex_8h.html#a76">ExDisableResourceBoost</a>( &amp;Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o10">Resource</a> );
05681         }
05682     }
05683 
05684     <span class="keywordflow">return</span> Bcb;
05685 }
05686 
05687 
05688 <span class="comment">//</span>
05689 <span class="comment">//  Internal support routine</span>
05690 <span class="comment">//</span>
05691 
05692 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
05693 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l05694"></a><a class="code" href="../../d5/d5/cc_8h.html#a177">05694</a> <a class="code" href="../../d5/d5/cc_8h.html#a177">CcDeallocateBcb</a> (
05695     IN <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> Bcb
05696     )
05697 
05698 <span class="comment">/*++</span>
05699 <span class="comment"></span>
05700 <span class="comment">Routine Description:</span>
05701 <span class="comment"></span>
05702 <span class="comment">    This routine deallocates a Bcb to the BcbZone.  It must</span>
05703 <span class="comment">    already be removed from the BcbList.</span>
05704 <span class="comment"></span>
05705 <span class="comment">Arguments:</span>
05706 <span class="comment"></span>
05707 <span class="comment">    Bcb - the Bcb to deallocate</span>
05708 <span class="comment"></span>
05709 <span class="comment">Return Value:</span>
05710 <span class="comment"></span>
05711 <span class="comment">    None</span>
05712 <span class="comment"></span>
05713 <span class="comment">--*/</span>
05714 
05715 {
05716     KIRQL OldIrql;
05717 
05718     <span class="comment">//</span>
05719     <span class="comment">//  Deallocate Resource structures</span>
05720     <span class="comment">//</span>
05721 
05722     <span class="keywordflow">if</span> (Bcb-&gt;NodeTypeCode == <a class="code" href="../../d5/d5/cc_8h.html#a14">CACHE_NTC_BCB</a>) {
05723 
05724         <a class="code" href="../../d5/d8/ex_8h.html#a73">ExDeleteResource</a>( &amp;Bcb-&gt;Resource );
05725     }
05726 
05727     <span class="keywordflow">if</span> ( Bcb-&gt;NodeIsInZone ) {
05728 
05729         <span class="comment">//</span>
05730         <span class="comment">//  Synchronize access to the BcbZone</span>
05731         <span class="comment">//</span>
05732 
05733         ExAcquireSpinLock( &amp;<a class="code" href="../../d5/d5/cc_8h.html#a122">CcBcbSpinLock</a>, &amp;OldIrql );
05734         <a class="code" href="../../d5/d8/ex_8h.html#a57">ExFreeToZone</a>( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o2">BcbZone</a>, Bcb );
05735         ExReleaseSpinLock( &amp;<a class="code" href="../../d5/d5/cc_8h.html#a122">CcBcbSpinLock</a>, OldIrql );
05736 
05737     } <span class="keywordflow">else</span> {
05738         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(Bcb);
05739     }
05740     <span class="keywordflow">return</span>;
05741 }
05742 
05743 
05744 <span class="comment">//</span>
05745 <span class="comment">//  Internal Support Routine</span>
05746 <span class="comment">//</span>
05747 
05748 BOOLEAN
<a name="l05749"></a><a class="code" href="../../d5/d5/cc_8h.html#a181">05749</a> <a class="code" href="../../d5/d5/cc_8h.html#a181">CcMapAndRead</a>(
05750     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap,
05751     IN PLARGE_INTEGER FileOffset,
05752     IN ULONG Length,
05753     IN ULONG ZeroFlags,
05754     IN BOOLEAN Wait,
05755     IN PVOID BaseAddress
05756     )
05757 
05758 <span class="comment">/*++</span>
05759 <span class="comment"></span>
05760 <span class="comment">Routine Description:</span>
05761 <span class="comment"></span>
05762 <span class="comment">    This routine may be called to insure that the specified data is mapped,</span>
05763 <span class="comment">    read into memory and locked.  If TRUE is returned, then the</span>
05764 <span class="comment">    correct I/O status for the transfer is also returned, along with</span>
05765 <span class="comment">    a system-space address for the data.</span>
05766 <span class="comment"></span>
05767 <span class="comment">Arguments:</span>
05768 <span class="comment"></span>
05769 <span class="comment">    SharedCacheMap - Supplies the address of the SharedCacheMap for the</span>
05770 <span class="comment">                     data.</span>
05771 <span class="comment"></span>
05772 <span class="comment">    FileOffset - Supplies the file offset of the desired data.</span>
05773 <span class="comment"></span>
05774 <span class="comment">    Length - Supplies the total amount of data desired.</span>
05775 <span class="comment"></span>
05776 <span class="comment">    ZeroFlags - Defines which pages may be zeroed if not resident.</span>
05777 <span class="comment"></span>
05778 <span class="comment">    Wait - Supplies FALSE if the caller is not willing to block for the</span>
05779 <span class="comment">           data, or TRUE if the caller is willing to block.</span>
05780 <span class="comment"></span>
05781 <span class="comment">    BaseAddress - Supplies the system base address at which the data may</span>
05782 <span class="comment">                  be accessed.</span>
05783 <span class="comment"></span>
05784 <span class="comment">Return Value:</span>
05785 <span class="comment"></span>
05786 <span class="comment">    FALSE - if the caller supplied Wait = FALSE and the data could not</span>
05787 <span class="comment">            be returned without blocking.</span>
05788 <span class="comment"></span>
05789 <span class="comment">    TRUE - if the data is being returned.</span>
05790 <span class="comment"></span>
05791 <span class="comment">    Note: this routine may raise an exception due to a map or read failure,</span>
05792 <span class="comment">          however, this can only happen if Wait was specified as TRUE, since</span>
05793 <span class="comment">          mapping and reading will not be performed if the caller cannot wait.</span>
05794 <span class="comment"></span>
05795 <span class="comment">--*/</span>
05796 
05797 {
05798     ULONG ZeroCase;
05799     ULONG SavedState;
05800     BOOLEAN Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
05801     <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a> Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
05802 
05803     <a class="code" href="../../d2/d1/mm_8h.html#a19">MmSavePageFaultReadAhead</a>( Thread, &amp;SavedState );
05804 
05805     <span class="comment">//</span>
05806     <span class="comment">//  try around everything for cleanup.</span>
05807     <span class="comment">//</span>
05808 
05809     <span class="keywordflow">try</span> {
05810 
05811         ULONG PagesToGo;
05812 
05813         <span class="comment">//</span>
05814         <span class="comment">//  Now loop to touch all of the pages, calling MM to insure</span>
05815         <span class="comment">//  that if we fault, we take in exactly the number of pages</span>
05816         <span class="comment">//  we need.</span>
05817         <span class="comment">//</span>
05818 
05819         PagesToGo = <a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a>( BaseAddress, Length );
05820 
05821         <span class="comment">//</span>
05822         <span class="comment">//  Loop to touch or zero the pages.</span>
05823         <span class="comment">//</span>
05824 
05825         ZeroCase = <a class="code" href="../../d5/d5/cc_8h.html#a85">ZERO_FIRST_PAGE</a>;
05826 
05827         <span class="keywordflow">while</span> (PagesToGo) {
05828 
05829             <span class="comment">//</span>
05830             <span class="comment">//  If we cannot zero this page, or Mm failed to return</span>
05831             <span class="comment">//  a zeroed page, then just fault it in.</span>
05832             <span class="comment">//</span>
05833 
05834             <a class="code" href="../../d2/d1/mm_8h.html#a20">MmSetPageFaultReadAhead</a>( Thread, (PagesToGo - 1) );
05835 
05836             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(ZeroFlags, ZeroCase) ||
05837                 !<a class="code" href="../../d1/d5/mapcache_8c.html#a13">MmCheckCachedPageState</a>(BaseAddress, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>)) {
05838 
05839                 <span class="comment">//</span>
05840                 <span class="comment">//  If we get here, it is almost certainly due to the fact</span>
05841                 <span class="comment">//  that we can not take a zero page.  MmCheckCachedPageState</span>
05842                 <span class="comment">//  will so rarely return FALSE, that we will not worry</span>
05843                 <span class="comment">//  about it.  We will only check if the page is there if</span>
05844                 <span class="comment">//  Wait is FALSE, so that we can do the right thing.</span>
05845                 <span class="comment">//</span>
05846 
05847                 <span class="keywordflow">if</span> (!<a class="code" href="../../d1/d5/mapcache_8c.html#a13">MmCheckCachedPageState</a>(BaseAddress, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp; !Wait) {
05848                     <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>( Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
05849                 }
05850             }
05851 
05852             BaseAddress = (PCHAR)BaseAddress + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
05853             PagesToGo -= 1;
05854 
05855             <span class="keywordflow">if</span> (PagesToGo == 1) {
05856                 ZeroCase = <a class="code" href="../../d5/d5/cc_8h.html#a87">ZERO_LAST_PAGE</a>;
05857             } <span class="keywordflow">else</span> {
05858                 ZeroCase = <a class="code" href="../../d5/d5/cc_8h.html#a86">ZERO_MIDDLE_PAGES</a>;
05859             }
05860         }
05861 
05862         <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>( Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
05863 
05864     try_exit: NOTHING;
05865     }
05866 
05867     <span class="comment">//</span>
05868     <span class="comment">//  Cleanup on the way out.</span>
05869     <span class="comment">//</span>
05870 
05871     finally {
05872 
05873         <a class="code" href="../../d2/d1/mm_8h.html#a21">MmResetPageFaultReadAhead</a>(Thread, SavedState);
05874     }
05875 
05876     <span class="keywordflow">return</span> Result;
05877 }
05878 
05879 
05880 <span class="comment">//</span>
05881 <span class="comment">//  Internal Support Routine</span>
05882 <span class="comment">//</span>
05883 
05884 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l05885"></a><a class="code" href="../../d5/d5/cc_8h.html#a182">05885</a> <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a> (
05886     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap,
05887     IN <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> ActiveVacb OPTIONAL,
05888     IN ULONG ActivePage,
05889     IN ULONG PageIsDirty
05890     )
05891 
05892 <span class="comment">/*++</span>
05893 <span class="comment"></span>
05894 <span class="comment">Routine Description:</span>
05895 <span class="comment"></span>
05896 <span class="comment">    This routine may be called to zero the end of a locked page or</span>
05897 <span class="comment">    free the ActiveVacb for a Shared Cache Map, if there is one.</span>
05898 <span class="comment">    Note that some callers are not synchronized with foreground</span>
05899 <span class="comment">    activity, and may therefore not have an ActiveVacb.  Examples</span>
05900 <span class="comment">    of unsynchronized callers are CcZeroEndOfLastPage (which is</span>
05901 <span class="comment">    called by MM) and any flushing done by CcWriteBehind.</span>
05902 <span class="comment"></span>
05903 <span class="comment">Arguments:</span>
05904 <span class="comment"></span>
05905 <span class="comment">    SharedCacheMap - SharedCacheMap to examine for page to be zeroed.</span>
05906 <span class="comment"></span>
05907 <span class="comment">    ActiveVacb - Vacb to free</span>
05908 <span class="comment"></span>
05909 <span class="comment">    ActivePage - Page that was used</span>
05910 <span class="comment"></span>
05911 <span class="comment">    PageIsDirty - ACTIVE_PAGE_IS_DIRTY if the active page is dirty</span>
05912 <span class="comment"></span>
05913 <span class="comment">Return Value:</span>
05914 <span class="comment"></span>
05915 <span class="comment">    None</span>
05916 <span class="comment"></span>
05917 <span class="comment">--*/</span>
05918 
05919 {
05920     LARGE_INTEGER ActiveOffset;
05921     PVOID ActiveAddress;
05922     ULONG BytesLeftInPage;
05923     KIRQL OldIrql;
05924 
05925     <span class="comment">//</span>
05926     <span class="comment">//  If the page was locked, then unlock it.</span>
05927     <span class="comment">//</span>
05928 
05929     <span class="keywordflow">if</span> (SharedCacheMap-&gt;NeedToZero != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05930 
05931         <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> NeedToZeroVacb;
05932 
05933         <span class="comment">//</span>
05934         <span class="comment">//  Zero the rest of the page under spinlock control,</span>
05935         <span class="comment">//  and then clear the address field.  This field makes</span>
05936         <span class="comment">//  zero-&gt;nonzero transitions only when the file is exclusive,</span>
05937         <span class="comment">//  but it can make nonzero-&gt;zero transitions any time the</span>
05938         <span class="comment">//  spinlock is not held.</span>
05939         <span class="comment">//</span>
05940 
05941         ExAcquireFastLock( &amp;SharedCacheMap-&gt;ActiveVacbSpinLock, &amp;OldIrql );
05942 
05943         <span class="comment">//</span>
05944         <span class="comment">//  The address could already be gone.</span>
05945         <span class="comment">//</span>
05946 
05947         ActiveAddress = SharedCacheMap-&gt;NeedToZero;
05948         <span class="keywordflow">if</span> (ActiveAddress != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05949 
05950             BytesLeftInPage = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - ((((ULONG)((ULONG_PTR)ActiveAddress) - 1) &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) + 1);
05951 
05952             RtlZeroBytes( ActiveAddress, BytesLeftInPage );
05953             SharedCacheMap-&gt;NeedToZero = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05954             NeedToZeroVacb = SharedCacheMap-&gt;NeedToZeroVacb;
05955         }
05956         ExReleaseFastLock( &amp;SharedCacheMap-&gt;ActiveVacbSpinLock, OldIrql );
05957 
05958         <span class="comment">//</span>
05959         <span class="comment">//  Now call MM to unlock the address.  Note we will never store the</span>
05960         <span class="comment">//  address at the start of the page, but we can sometimes store</span>
05961         <span class="comment">//  the start of the next page when we have exactly filled the page.</span>
05962         <span class="comment">//</span>
05963 
05964         <span class="keywordflow">if</span> (ActiveAddress != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05965             <a class="code" href="../../d1/d5/mapcache_8c.html#a15">MmUnlockCachedPage</a>( (PVOID)((PCHAR)ActiveAddress - 1) );
05966             <a class="code" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a>( NeedToZeroVacb );
05967         }
05968     }
05969 
05970     <span class="comment">//</span>
05971     <span class="comment">//  See if caller actually has an ActiveVacb</span>
05972     <span class="comment">//</span>
05973 
05974     <span class="keywordflow">if</span> (ActiveVacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05975 
05976         <span class="comment">//</span>
05977         <span class="comment">//  See if the page is dirty</span>
05978         <span class="comment">//</span>
05979 
05980         <span class="keywordflow">if</span> (PageIsDirty) {
05981 
05982             ActiveOffset.QuadPart = (LONGLONG)ActivePage &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
05983             ActiveAddress = (PVOID)((PCHAR)ActiveVacb-&gt;BaseAddress +
05984                                     (ActiveOffset.LowPart  &amp; (<a class="code" href="../../d4/d2/cache_8h.html#a0">VACB_MAPPING_GRANULARITY</a> - 1)));
05985 
05986             <span class="comment">//</span>
05987             <span class="comment">//  Tell the Lazy Writer to write the page.</span>
05988             <span class="comment">//</span>
05989 
05990             <a class="code" href="../../d5/d5/cc_8h.html#a179">CcSetDirtyInMask</a>( SharedCacheMap, &amp;ActiveOffset, <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> );
05991 
05992             <span class="comment">//</span>
05993             <span class="comment">//  Now we need to clear the flag and decrement some counts if there is</span>
05994             <span class="comment">//  no other active Vacb which snuck in.</span>
05995             <span class="comment">//</span>
05996 
05997             <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
05998             ExAcquireSpinLockAtDpcLevel( &amp;SharedCacheMap-&gt;ActiveVacbSpinLock );
05999             <span class="keywordflow">if</span> ((SharedCacheMap-&gt;ActiveVacb == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
06000                 <a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;Flags, <a class="code" href="../../d5/d5/cc_8h.html#a76">ACTIVE_PAGE_IS_DIRTY</a>)) {
06001 
06002                 <a class="code" href="../../d5/d5/cc_8h.html#a61">ClearFlag</a>(SharedCacheMap-&gt;Flags, <a class="code" href="../../d5/d5/cc_8h.html#a76">ACTIVE_PAGE_IS_DIRTY</a>);
06003                 SharedCacheMap-&gt;DirtyPages -= 1;
06004                 <a class="code" href="../../d5/d2/cachedat_8c.html#a36">CcTotalDirtyPages</a> -= 1;
06005             }
06006             ExReleaseSpinLockFromDpcLevel( &amp;SharedCacheMap-&gt;ActiveVacbSpinLock );
06007             <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
06008         }
06009 
06010         <span class="comment">//</span>
06011         <span class="comment">//  Now free the Vacb.</span>
06012         <span class="comment">//</span>
06013 
06014         <a class="code" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a>( ActiveVacb );
06015     }
06016 }
06017 
06018 
06019 <span class="comment">//</span>
06020 <span class="comment">//  Internal Support Routine</span>
06021 <span class="comment">//</span>
06022 
06023 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l06024"></a><a class="code" href="../../d5/d5/cc_8h.html#a183">06024</a> <a class="code" href="../../d5/d5/cc_8h.html#a183">CcMapAndCopy</a>(
06025     IN <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap,
06026     IN PVOID UserBuffer,
06027     IN PLARGE_INTEGER FileOffset,
06028     IN ULONG Length,
06029     IN ULONG ZeroFlags,
06030     IN BOOLEAN WriteThrough
06031     )
06032 
06033 <span class="comment">/*++</span>
06034 <span class="comment"></span>
06035 <span class="comment">Routine Description:</span>
06036 <span class="comment"></span>
06037 <span class="comment">    This routine may be called to copy the specified user data to the</span>
06038 <span class="comment">    cache via a special Mm routine which copies the data to uninitialized</span>
06039 <span class="comment">    pages and returns.</span>
06040 <span class="comment"></span>
06041 <span class="comment">Arguments:</span>
06042 <span class="comment"></span>
06043 <span class="comment">    SharedCacheMap - Supplies the address of the SharedCacheMap for the</span>
06044 <span class="comment">                     data.</span>
06045 <span class="comment"></span>
06046 <span class="comment">    UserBuffer - unsafe buffer supplying the user's data to be written</span>
06047 <span class="comment"></span>
06048 <span class="comment">    FileOffset - Supplies the file offset to be modified</span>
06049 <span class="comment"></span>
06050 <span class="comment">    Length - Supplies the total amount of data</span>
06051 <span class="comment"></span>
06052 <span class="comment">    ZeroFlags - Defines which pages may be zeroed if not resident.</span>
06053 <span class="comment"></span>
06054 <span class="comment">    WriteThrough - Supplies whether the data is to be written through or not</span>
06055 <span class="comment"></span>
06056 <span class="comment">Return Value:</span>
06057 <span class="comment"></span>
06058 <span class="comment">    None</span>
06059 <span class="comment"></span>
06060 <span class="comment">--*/</span>
06061 
06062 {
06063     ULONG ReceivedLength;
06064     ULONG ZeroCase;
06065     PVOID CacheBuffer;
06066     PVOID SavedMappedBuffer;
06067     ULONG SavedMappedLength;
06068     ULONG ActivePage;
06069     KIRQL OldIrql;
06070     LARGE_INTEGER PFileOffset;
06071     IO_STATUS_BLOCK IoStatus;
06072     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
06073     ULONG SavedState;
06074     BOOLEAN MorePages;
06075     ULONG SavedTotalLength = Length;
06076     LARGE_INTEGER LocalOffset = *FileOffset;
06077     ULONG PageOffset = FileOffset-&gt;LowPart &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1);
06078     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> Vacb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
06079     <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a> Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
06080 
06081     <span class="comment">//</span>
06082     <span class="comment">//  Initialize SavePage to TRUE to skip the finally clause on zero-length</span>
06083     <span class="comment">//  writes.</span>
06084     <span class="comment">//</span>
06085 
06086     BOOLEAN SavePage = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
06087 
06088     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcMapAndCopy:\n"</span>, 0 );
06089     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    SharedCacheMap = %08lx\n"</span>, SharedCacheMap );
06090     <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>(0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    FileOffset = %08lx, %08lx\n"</span>, FileOffset-&gt;LowPart,
06091                                                           FileOffset-&gt;HighPart );
06092     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    Length = %08lx\n"</span>, Length );
06093 
06094     <a class="code" href="../../d2/d1/mm_8h.html#a19">MmSavePageFaultReadAhead</a>( Thread, &amp;SavedState );
06095 
06096     <span class="comment">//</span>
06097     <span class="comment">//  try around everything for cleanup.</span>
06098     <span class="comment">//</span>
06099 
06100     <span class="keywordflow">try</span> {
06101 
06102         <span class="keywordflow">while</span> (Length != 0) {
06103 
06104             CacheBuffer = <a class="code" href="../../d5/d3/vacbsup_8c.html#a15">CcGetVirtualAddress</a>( SharedCacheMap,
06105                                                LocalOffset,
06106                                                &amp;Vacb,
06107                                                &amp;ReceivedLength );
06108 
06109             <span class="comment">//</span>
06110             <span class="comment">//  If we got more than we need, make sure to only use</span>
06111             <span class="comment">//  the right amount.</span>
06112             <span class="comment">//</span>
06113 
06114             <span class="keywordflow">if</span> (ReceivedLength &gt; Length) {
06115                 ReceivedLength = Length;
06116             }
06117             SavedMappedBuffer = CacheBuffer;
06118             SavedMappedLength = ReceivedLength;
06119             Length -= ReceivedLength;
06120 
06121             <span class="comment">//</span>
06122             <span class="comment">//  Now loop to touch all of the pages, calling MM to insure</span>
06123             <span class="comment">//  that if we fault, we take in exactly the number of pages</span>
06124             <span class="comment">//  we need.</span>
06125             <span class="comment">//</span>
06126 
06127             CacheBuffer = (PVOID)((PCHAR)CacheBuffer - PageOffset);
06128             ReceivedLength += PageOffset;
06129 
06130             <span class="comment">//</span>
06131             <span class="comment">//  Loop to touch or zero the pages.</span>
06132             <span class="comment">//</span>
06133 
06134             ZeroCase = <a class="code" href="../../d5/d5/cc_8h.html#a85">ZERO_FIRST_PAGE</a>;
06135 
06136             <span class="comment">//</span>
06137             <span class="comment">//  Set up offset to page for use below.</span>
06138             <span class="comment">//</span>
06139 
06140             PFileOffset = LocalOffset;
06141             PFileOffset.LowPart -= PageOffset;
06142 
06143             <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
06144 
06145                 <span class="comment">//</span>
06146                 <span class="comment">//  Calculate whether we wish to save an active page</span>
06147                 <span class="comment">//  or not.</span>
06148                 <span class="comment">//</span>
06149 
06150                 SavePage = ((Length == 0) &amp;&amp;
06151                             (ReceivedLength &lt; <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>) &amp;&amp;
06152                             (SavedTotalLength &lt;= (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> / 2)) &amp;&amp;
06153                             !WriteThrough);
06154 
06155                 MorePages = (ReceivedLength &gt; <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
06156 
06157                 <span class="comment">//</span>
06158                 <span class="comment">//  Copy the data to the user buffer.</span>
06159                 <span class="comment">//</span>
06160 
06161                 <span class="keywordflow">try</span> {
06162 
06163                     <span class="comment">//</span>
06164                     <span class="comment">//  It is possible that there is a locked page</span>
06165                     <span class="comment">//  hanging around, and so we need to nuke it here.</span>
06166                     <span class="comment">//</span>
06167 
06168                     <span class="keywordflow">if</span> (SharedCacheMap-&gt;NeedToZero != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
06169                         <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, 0, 0 );
06170                     }
06171 
06172                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
06173                     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(ZeroFlags, ZeroCase)) {
06174 
06175                         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d1/d5/mapcache_8c.html#a14">MmCopyToCachedPage</a>( CacheBuffer,
06176                                                      UserBuffer,
06177                                                      PageOffset,
06178                                                      MorePages ?
06179                                                        (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - PageOffset) :
06180                                                        (ReceivedLength - PageOffset),
06181                                                      SavePage );
06182 
06183                         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
06184 
06185                             <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( <a class="code" href="../../d1/d8/fsrtl_8h.html#a136">FsRtlNormalizeNtstatus</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>,
06186                                                                    STATUS_INVALID_USER_BUFFER ));
06187                         }
06188 
06189                     <span class="comment">//</span>
06190                     <span class="comment">//  Otherwise, we have to actually copy the data ourselves.</span>
06191                     <span class="comment">//</span>
06192 
06193                     } <span class="keywordflow">else</span> {
06194 
06195                         <a class="code" href="../../d2/d1/mm_8h.html#a20">MmSetPageFaultReadAhead</a>( Thread,
06196                                                  (MorePages &amp;&amp; <a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(ZeroFlags, <a class="code" href="../../d5/d5/cc_8h.html#a87">ZERO_LAST_PAGE</a>)) ? 1 : 0);
06197 
06198                         RtlCopyBytes( (PVOID)((PCHAR)CacheBuffer + PageOffset),
06199                                       UserBuffer,
06200                                       MorePages ?
06201                                         (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - PageOffset) :
06202                                         (ReceivedLength - PageOffset) );
06203 
06204                         <a class="code" href="../../d2/d1/mm_8h.html#a21">MmResetPageFaultReadAhead</a>( Thread, SavedState );
06205 
06206                     }
06207 
06208                 } except( <a class="code" href="../../d5/d7/copysup_8c.html#a5">CcCopyReadExceptionFilter</a>( GetExceptionInformation(),
06209                                                      &amp;<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ) ) {
06210 
06211                     <span class="comment">//</span>
06212                     <span class="comment">//  If we got an access violation, then the user buffer went</span>
06213                     <span class="comment">//  away.  Otherwise we must have gotten an I/O error trying</span>
06214                     <span class="comment">//  to bring the data in.</span>
06215                     <span class="comment">//</span>
06216 
06217                     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_ACCESS_VIOLATION) {
06218                         <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INVALID_USER_BUFFER );
06219                     }
06220                     <span class="keywordflow">else</span> {
06221                         <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( <a class="code" href="../../d1/d8/fsrtl_8h.html#a136">FsRtlNormalizeNtstatus</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>,
06222                                                                STATUS_UNEXPECTED_IO_ERROR ));
06223                     }
06224                 }
06225 
06226                 <span class="comment">//</span>
06227                 <span class="comment">//  Now get out quickly if it is a small write and we want</span>
06228                 <span class="comment">//  to save the page.</span>
06229                 <span class="comment">//</span>
06230 
06231                 <span class="keywordflow">if</span> (SavePage) {
06232 
06233                     ActivePage = (ULONG)( Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o4">Overlay</a>.FileOffset.QuadPart &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a> ) +
06234                                  (ULONG)(((PCHAR)CacheBuffer - (PCHAR)Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o0">BaseAddress</a>) &gt;&gt;
06235                                    <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
06236 
06237                     PFileOffset.LowPart += ReceivedLength;
06238 
06239                     <span class="comment">//</span>
06240                     <span class="comment">//  If the cache page was not locked, then clear the address</span>
06241                     <span class="comment">//  to zero from.</span>
06242                     <span class="comment">//</span>
06243 
06244                     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_CACHE_PAGE_LOCKED) {
06245 
06246                         <span class="comment">//</span>
06247                         <span class="comment">//  We need to guarantee this Vacb for zeroing and calling</span>
06248                         <span class="comment">//  MmUnlockCachedPage, so we increment the active count here</span>
06249                         <span class="comment">//  and remember it for CcFreeActiveVacb.</span>
06250                         <span class="comment">//</span>
06251 
06252                         <a class="code" href="../../d5/d5/cc_8h.html#a4">CcAcquireVacbLock</a>( &amp;OldIrql );
06253                         Vacb-&gt;<a class="code" href="../../d2/d5/struct__VACB.html#o4">Overlay</a>.ActiveCount += 1;
06254                         
06255                         ExAcquireSpinLockAtDpcLevel( &amp;SharedCacheMap-&gt;ActiveVacbSpinLock );
06256 
06257                         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(SharedCacheMap-&gt;NeedToZero == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
06258 
06259                         SharedCacheMap-&gt;NeedToZero = (PVOID)((PCHAR)CacheBuffer +
06260                                                              (PFileOffset.LowPart &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)));
06261                         SharedCacheMap-&gt;NeedToZeroPage = ActivePage;
06262                         SharedCacheMap-&gt;NeedToZeroVacb = Vacb;
06263 
06264                         ExReleaseSpinLockFromDpcLevel( &amp;SharedCacheMap-&gt;ActiveVacbSpinLock );
06265                         <a class="code" href="../../d5/d5/cc_8h.html#a5">CcReleaseVacbLock</a>( OldIrql );
06266                         
06267                     }
06268 
06269                     <a class="code" href="../../d5/d5/cc_8h.html#a84">SetActiveVacb</a>( SharedCacheMap,
06270                                    OldIrql,
06271                                    Vacb,
06272                                    ActivePage,
06273                                    <a class="code" href="../../d5/d5/cc_8h.html#a76">ACTIVE_PAGE_IS_DIRTY</a> );
06274 
06275                     <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>( NOTHING );
06276                 }
06277 
06278                 <span class="comment">//</span>
06279                 <span class="comment">//  If it looks like we may save a page and exit on the next loop,</span>
06280                 <span class="comment">//  then we must make sure to mark the current page dirty.  Note</span>
06281                 <span class="comment">//  that Cc[Fast]CopyWrite will finish the last part of any page</span>
06282                 <span class="comment">//  before allowing us to free the Active Vacb above, therefore</span>
06283                 <span class="comment">//  this case only occurs for a small random write.</span>
06284                 <span class="comment">//</span>
06285 
06286                 <span class="keywordflow">if</span> ((SavedTotalLength &lt;= (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> / 2)) &amp;&amp; !WriteThrough) {
06287 
06288                     <a class="code" href="../../d5/d5/cc_8h.html#a179">CcSetDirtyInMask</a>( SharedCacheMap, &amp;PFileOffset, ReceivedLength );
06289                 }
06290 
06291                 UserBuffer = (PVOID)((PCHAR)UserBuffer + (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - PageOffset));
06292                 PageOffset = 0;
06293 
06294                 <span class="comment">//</span>
06295                 <span class="comment">//  If there is more than a page to go (including what we just</span>
06296                 <span class="comment">//  copied), then adjust our buffer pointer and counts, and</span>
06297                 <span class="comment">//  determine if we are to the last page yet.</span>
06298                 <span class="comment">//</span>
06299 
06300                 <span class="keywordflow">if</span> (MorePages) {
06301 
06302                     CacheBuffer = (PCHAR)CacheBuffer + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
06303                     ReceivedLength -= <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
06304 
06305                     <span class="comment">//</span>
06306                     <span class="comment">//  Update our offset to the page.  Note that 32-bit</span>
06307                     <span class="comment">//  add is ok since we cannot cross a Vacb boundary</span>
06308                     <span class="comment">//  and we reinitialize this offset before entering</span>
06309                     <span class="comment">//  this loop again.</span>
06310                     <span class="comment">//</span>
06311 
06312                     PFileOffset.LowPart += <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
06313 
06314                     <span class="keywordflow">if</span> (ReceivedLength &gt; <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>) {
06315                         ZeroCase = <a class="code" href="../../d5/d5/cc_8h.html#a86">ZERO_MIDDLE_PAGES</a>;
06316                     } <span class="keywordflow">else</span> {
06317                         ZeroCase = <a class="code" href="../../d5/d5/cc_8h.html#a87">ZERO_LAST_PAGE</a>;
06318                     }
06319 
06320                 } <span class="keywordflow">else</span> {
06321 
06322                     <span class="keywordflow">break</span>;
06323                 }
06324             }
06325 
06326             <span class="comment">//</span>
06327             <span class="comment">//  If there is still more to write (ie. we are going to step</span>
06328             <span class="comment">//  onto the next vacb) AND we just dirtied more than 64K, then</span>
06329             <span class="comment">//  do a vicarious MmFlushSection here.  This prevents us from</span>
06330             <span class="comment">//  creating unlimited dirty pages while holding the file</span>
06331             <span class="comment">//  resource exclusive.  We also do not need to set the pages</span>
06332             <span class="comment">//  dirty in the mask in this case.</span>
06333             <span class="comment">//</span>
06334 
06335             <span class="keywordflow">if</span> (Length &gt; <a class="code" href="../../d6/d2/cachesub_8c.html#a3">CcMaxDirtyWrite</a>) {
06336 
06337                 <a class="code" href="../../d5/d6/iosup_8c.html#a74">MmSetAddressRangeModified</a>( SavedMappedBuffer, SavedMappedLength );
06338                 <a class="code" href="../../d6/d5/flushsec_8c.html#a8">MmFlushSection</a>( SharedCacheMap-&gt;FileObject-&gt;SectionObjectPointer,
06339                                 &amp;LocalOffset,
06340                                 SavedMappedLength,
06341                                 &amp;IoStatus,
06342                                 <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
06343 
06344                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(IoStatus.Status)) {
06345                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( <a class="code" href="../../d1/d8/fsrtl_8h.html#a136">FsRtlNormalizeNtstatus</a>( IoStatus.Status,
06346                                                            STATUS_UNEXPECTED_IO_ERROR ));
06347                 }
06348 
06349             <span class="comment">//</span>
06350             <span class="comment">//  For write through files, call Mm to propagate the dirty bits</span>
06351             <span class="comment">//  here while we have the view mapped, so we know the flush will</span>
06352             <span class="comment">//  work below.  Again - do not set dirty in the mask.</span>
06353             <span class="comment">//</span>
06354 
06355             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (WriteThrough) {
06356 
06357                 <a class="code" href="../../d5/d6/iosup_8c.html#a74">MmSetAddressRangeModified</a>( SavedMappedBuffer, SavedMappedLength );
06358 
06359             <span class="comment">//</span>
06360             <span class="comment">//  For the normal case, just set the pages dirty for the Lazy Writer</span>
06361             <span class="comment">//  now.</span>
06362             <span class="comment">//</span>
06363 
06364             } <span class="keywordflow">else</span> {
06365 
06366                 <a class="code" href="../../d5/d5/cc_8h.html#a179">CcSetDirtyInMask</a>( SharedCacheMap, &amp;LocalOffset, SavedMappedLength );
06367             }
06368 
06369             <a class="code" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a>( Vacb );
06370             Vacb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
06371 
06372             <span class="comment">//</span>
06373             <span class="comment">//  If we have to loop back to get at least a page, it will be ok to</span>
06374             <span class="comment">//  zero the first page.  If we are not getting at least a page, we</span>
06375             <span class="comment">//  must make sure we clear the ZeroFlags if we cannot zero the last</span>
06376             <span class="comment">//  page.</span>
06377             <span class="comment">//</span>
06378 
06379             <span class="keywordflow">if</span> (Length &gt;= <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>) {
06380                 ZeroFlags |= <a class="code" href="../../d5/d5/cc_8h.html#a85">ZERO_FIRST_PAGE</a>;
06381             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((ZeroFlags &amp; <a class="code" href="../../d5/d5/cc_8h.html#a87">ZERO_LAST_PAGE</a>) == 0) {
06382                 ZeroFlags = 0;
06383             }
06384 
06385             <span class="comment">//</span>
06386             <span class="comment">//  Note that if ReceivedLength (and therefore SavedMappedLength)</span>
06387             <span class="comment">//  was truncated to the transfer size then the new LocalOffset</span>
06388             <span class="comment">//  computed below is not correct.  This is not an issue since</span>
06389             <span class="comment">//  in that case (Length == 0) and we would never get here.</span>
06390             <span class="comment">//</span>
06391 
06392             LocalOffset.QuadPart = LocalOffset.QuadPart + (LONGLONG)SavedMappedLength;
06393         }
06394     try_exit: NOTHING;
06395     }
06396 
06397     <span class="comment">//</span>
06398     <span class="comment">//  Cleanup on the way out.</span>
06399     <span class="comment">//</span>
06400 
06401     finally {
06402 
06403         <a class="code" href="../../d2/d1/mm_8h.html#a21">MmResetPageFaultReadAhead</a>( Thread, SavedState );
06404 
06405         <span class="comment">//</span>
06406         <span class="comment">//  We have no work to do if we have squirreled away the Vacb.</span>
06407         <span class="comment">//</span>
06408 
06409         <span class="keywordflow">if</span> (!SavePage || AbnormalTermination()) {
06410 
06411             <span class="comment">//</span>
06412             <span class="comment">//  Make sure we do not leave anything mapped or dirty in the PTE</span>
06413             <span class="comment">//  on the way out.</span>
06414             <span class="comment">//</span>
06415 
06416             <span class="keywordflow">if</span> (Vacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
06417 
06418                 <a class="code" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a>( Vacb );
06419             }
06420 
06421             <span class="comment">//</span>
06422             <span class="comment">//  Either flush the whole range because of write through, or</span>
06423             <span class="comment">//  mark it dirty for the lazy writer.</span>
06424             <span class="comment">//</span>
06425 
06426             <span class="keywordflow">if</span> (WriteThrough) {
06427 
06428                 <a class="code" href="../../d6/d5/flushsec_8c.html#a8">MmFlushSection</a> ( SharedCacheMap-&gt;FileObject-&gt;SectionObjectPointer,
06429                                  FileOffset,
06430                                  SavedTotalLength,
06431                                  &amp;IoStatus,
06432                                  <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
06433 
06434                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(IoStatus.Status)) {
06435                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( <a class="code" href="../../d1/d8/fsrtl_8h.html#a136">FsRtlNormalizeNtstatus</a>( IoStatus.Status,
06436                                                            STATUS_UNEXPECTED_IO_ERROR ));
06437                 }
06438 
06439                 <span class="comment">//</span>
06440                 <span class="comment">//  Advance ValidDataGoal</span>
06441                 <span class="comment">//</span>
06442 
06443                 LocalOffset.QuadPart = FileOffset-&gt;QuadPart + (LONGLONG)SavedTotalLength;
06444                 <span class="keywordflow">if</span> (LocalOffset.QuadPart &gt; SharedCacheMap-&gt;ValidDataGoal.QuadPart) {
06445                     SharedCacheMap-&gt;ValidDataGoal = LocalOffset;
06446                 }
06447             }
06448         }
06449     }
06450 
06451     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcMapAndCopy -&gt; %02lx\n"</span>, Result );
06452 
06453     <span class="keywordflow">return</span>;
06454 }
06455 
06456 
06457 BOOLEAN
<a name="l06458"></a><a class="code" href="../../d6/d2/cachesub_8c.html#a11">06458</a> <a class="code" href="../../d6/d2/cachesub_8c.html#a11">CcLogError</a>(
06459     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> Device,
06460     IN NTSTATUS Error,
06461     IN NTSTATUS DeviceError,
06462     IN PUNICODE_STRING FileName
06463     )
06464 
06465 <span class="comment">/*++</span>
06466 <span class="comment"></span>
06467 <span class="comment">Routine Description:</span>
06468 <span class="comment"></span>
06469 <span class="comment">    This routine writes an eventlog entry to the eventlog.</span>
06470 <span class="comment"></span>
06471 <span class="comment">Arguments:</span>
06472 <span class="comment"></span>
06473 <span class="comment">    Device -  The device the error occured on, i.e if a file write dropped the</span>
06474 <span class="comment">              device for the file</span>
06475 <span class="comment"></span>
06476 <span class="comment">    Error - The error to log in the eventlog record</span>
06477 <span class="comment"></span>
06478 <span class="comment">    DeviceError - The actual error that occured in the device - will be logged</span>
06479 <span class="comment">                  as user data</span>
06480 <span class="comment"></span>
06481 <span class="comment">    FileName -  A ptr to the filename if any involved - will be truncated if</span>
06482 <span class="comment">                too long to fit</span>
06483 <span class="comment"></span>
06484 <span class="comment">Return Value:</span>
06485 <span class="comment"></span>
06486 <span class="comment">    True if successful, false if internal memory allocation failed</span>
06487 <span class="comment"></span>
06488 <span class="comment">--*/</span>
06489 
06490 {
06491     UCHAR ErrorPacketLength;
06492     PIO_ERROR_LOG_PACKET ErrorLogEntry = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
06493     BOOLEAN RetVal = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
06494     PWCHAR <a class="code" href="../../d4/d9/talloc_8c.html#a0">String</a>;
06495     ULONG  StringSpace;
06496 
06497     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( KeGetCurrentIrql() &lt;= <a class="code" href="../../d6/d7/halmips_8h.html#a53">DISPATCH_LEVEL</a> );
06498 
06499     ErrorPacketLength = <span class="keyword">sizeof</span>(IO_ERROR_LOG_PACKET) + <span class="keyword">sizeof</span>(<a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>);
06500     <span class="keywordflow">if</span> (<a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a>) {
06501         <span class="keywordflow">if</span> ((<a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a>-&gt;Length + <span class="keyword">sizeof</span>(WCHAR) + ErrorPacketLength) &gt;= ERROR_LOG_MAXIMUM_SIZE) {
06502              ErrorPacketLength = ERROR_LOG_MAXIMUM_SIZE - 1;
06503         } <span class="keywordflow">else</span> {
06504             ErrorPacketLength += (UCHAR)(<a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a>-&gt;Length + <span class="keyword">sizeof</span>(WCHAR));
06505         }
06506     }
06507 
06508     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( ErrorPacketLength &lt; UCHAR_MAX );
06509 
06510     ErrorLogEntry = (PIO_ERROR_LOG_PACKET)
06511                     <a class="code" href="../../d4/d6/iosubs_8c.html#a14">IoAllocateErrorLogEntry</a>( Device,
06512                                              ErrorPacketLength );
06513     <span class="keywordflow">if</span> (ErrorLogEntry) {
06514         ErrorLogEntry-&gt;ErrorCode = <a class="code" href="../../d7/d0/ctlnpqos_8c.html#a1">Error</a>;
06515         ErrorLogEntry-&gt;DumpDataSize = <span class="keyword">sizeof</span>(<a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>);
06516         ErrorLogEntry-&gt;DumpData[0] = DeviceError;
06517 
06518         <span class="keywordflow">if</span> (<a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a> &amp;&amp; <a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a>-&gt;Length) {
06519 
06520             <span class="comment">//</span>
06521             <span class="comment">//  The filename string at the end of the error log entry. We may have</span>
06522             <span class="comment">//  to truncate to fit in the limited space if the name is too long</span>
06523             <span class="comment">//</span>
06524 
06525             StringSpace = ErrorPacketLength - <span class="keyword">sizeof</span>( IO_ERROR_LOG_PACKET ) - <span class="keyword">sizeof</span>( WCHAR );
06526             <a class="code" href="../../d4/d9/talloc_8c.html#a0">String</a> = (PWCHAR) (ErrorLogEntry + 1);
06527             ErrorLogEntry-&gt;NumberOfStrings = 1;
06528             ErrorLogEntry-&gt;StringOffset = <span class="keyword">sizeof</span>( IO_ERROR_LOG_PACKET );
06529             RtlCopyMemory( <a class="code" href="../../d4/d9/talloc_8c.html#a0">String</a>,
06530                            <a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a>-&gt;Buffer,
06531                            <a class="code" href="../../d5/d4/acpitabl_8h.html#a69">min</a>( <a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a>-&gt;Length, StringSpace ) );
06532 
06533             <span class="comment">//</span>
06534             <span class="comment">//  Make sure the string is null terminated.</span>
06535             <span class="comment">//</span>
06536 
06537             <a class="code" href="../../d4/d9/talloc_8c.html#a0">String</a> += <a class="code" href="../../d5/d4/acpitabl_8h.html#a69">min</a>( (<a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a>-&gt;Length / <span class="keyword">sizeof</span>( WCHAR )), (StringSpace / <span class="keyword">sizeof</span>( WCHAR )) );
06538             *<a class="code" href="../../d4/d9/talloc_8c.html#a0">String</a> = <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\0'</span>;
06539         }
06540 
06541         <a class="code" href="../../d4/d6/iosubs_8c.html#a123">IoWriteErrorLogEntry</a>( ErrorLogEntry );
06542         RetVal = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
06543     }
06544 
06545     <span class="keywordflow">return</span> RetVal;
06546 }
06547 
06548 
06549 
06550 <span class="preprocessor">#ifdef CCDBG</span>
06551 <span class="preprocessor"></span><a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
06552 CcDump (
06553     IN PVOID Ptr
06554     )
06555 
06556 {
06557     PVOID Junk = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a28">Ptr</a>;
06558 }
06559 <span class="preprocessor">#endif</span>
06560 <span class="preprocessor"></span>
06561 
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:39:19 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
