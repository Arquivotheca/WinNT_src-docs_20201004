<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: drivesup.c File Reference</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>drivesup.c File Reference</h1><code>#include "<a class="el" href="../../d0/d8/ntos_8h-source.html">ntos.h</a>"</code><br>
<code>#include "zwapi.h"</code><br>
<code>#include "<a class="el" href="../../d3/d6/hal_8h-source.html">hal.h</a>"</code><br>
<code>#include "ntdddisk.h"</code><br>
<code>#include "<a class="el" href="../../d5/d6/haldisp_8h-source.html">haldisp.h</a>"</code><br>
<code>#include "ntddft.h"</code><br>
<code>#include "mountmgr.h"</code><br>
<code>#include "stdio.h"</code><br>
<code>#include &lt;<a class="el" href="../../d4/d7/setupblk_8h-source.html">setupblk.h</a>&gt;</code><br>
<code>#include "<a class="el" href="../../d9/d1/drivesup_8h-source.html">drivesup.h</a>"</code><br>

<p>
<a href="../../d8/d1/drivesup_8c-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d7/d4/struct__BOOT__SECTOR__INFO.html">_BOOT_SECTOR_INFO</a></td></tr>

<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d7/d2/drivesup_8c.html#a0">DebugPrint</a>(x)&nbsp;&nbsp;&nbsp;DrivesupDebugPrint x</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d7/d2/drivesup_8c.html#a1">GET_STARTING_SECTOR</a>(p)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d7/d2/drivesup_8c.html#a2">GET_PARTITION_LENGTH</a>(p)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d7/d2/drivesup_8c.html#a3">BOOTABLE_PARTITION</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d7/d2/drivesup_8c.html#a4">PRIMARY_PARTITION</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d7/d2/drivesup_8c.html#a5">LOGICAL_PARTITION</a>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d7/d2/drivesup_8c.html#a6">FT_PARTITION</a>&nbsp;&nbsp;&nbsp;3</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d7/d2/drivesup_8c.html#a7">OTHER_PARTITION</a>&nbsp;&nbsp;&nbsp;4</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d7/d2/drivesup_8c.html#a8">GET_STARTING_SECTOR</a>(p)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d7/d2/drivesup_8c.html#a9">WHICH_BIT</a>(Data, Bit)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d7/d2/drivesup_8c.html#a10">WHICH_BIT</a>(Data, Bit)</td></tr>

<tr><td colspan=2><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="../../d7/d4/struct__BOOT__SECTOR__INFO.html">_BOOT_SECTOR_INFO</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d7/d2/drivesup_8c.html#a13">BOOT_SECTOR_INFO</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="../../d7/d4/struct__BOOT__SECTOR__INFO.html">_BOOT_SECTOR_INFO</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d7/d2/drivesup_8c.html#a14">PBOOT_SECTOR_INFO</a></td></tr>

<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d7/d2/drivesup_8c.html#a17">DrivesupDebugPrint</a> (ULONG DebugPrintLevel, PCCHAR DebugMessage,...)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d7/d2/drivesup_8c.html#a18">HalpCalculateChsValues</a> (IN PLARGE_INTEGER PartitionOffset, IN PLARGE_INTEGER PartitionLength, IN CCHAR ShiftCount, IN ULONG SectorsPerTrack, IN ULONG NumberOfTracks, IN ULONG ConventionalCylinders, OUT <a class="el" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html">PPARTITION_DESCRIPTOR</a> PartitionDescriptor)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d7/d2/drivesup_8c.html#a19">HalpQueryPartitionType</a> (IN PUNICODE_STRING DeviceName, IN PDRIVE_LAYOUT_INFORMATION DriveLayout, OUT PULONG PartitionType)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d7/d2/drivesup_8c.html#a20">HalpQueryDriveLayout</a> (IN PUNICODE_STRING DeviceName, OUT PDRIVE_LAYOUT_INFORMATION *DriveLayout)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID FASTCALL&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d7/d2/drivesup_8c.html#a21">xHalGetPartialGeometry</a> (IN <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject, IN PULONG ConventionalCylinders, IN PLONGLONG DiskSize)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d7/d2/drivesup_8c.html#a22">HalpGetFullGeometry</a> (IN <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject, IN PDISK_GEOMETRY Geometry, OUT PULONGLONG RealSectorCount)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d7/d2/drivesup_8c.html#a23">HalpIsValidPartitionEntry</a> (<a class="el" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html">PPARTITION_DESCRIPTOR</a> Entry, ULONGLONG MaxOffset, ULONGLONG MaxSector)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d7/d2/drivesup_8c.html#a24">HalpNextMountLetter</a> (IN PUNICODE_STRING DeviceName, OUT PUCHAR DriveLetter)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>UCHAR&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d7/d2/drivesup_8c.html#a25">HalpNextDriveLetter</a> (IN PUNICODE_STRING DeviceName, IN PSTRING NtDeviceName, OUT PUCHAR NtSystemPath, IN BOOLEAN UseHardLinksIfNecessary)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d7/d2/drivesup_8c.html#a26">HalpEnableAutomaticDriveLetterAssignment</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d7/d2/drivesup_8c.html#a27">HalpSetMountLetter</a> (IN PUNICODE_STRING DeviceName, IN UCHAR DriveLetter)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d7/d2/drivesup_8c.html#a28">HalpIsOldStyleFloppy</a> (IN PUNICODE_STRING DeviceName)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID FASTCALL&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d7/d2/drivesup_8c.html#a29">xHalExamineMBR</a> (IN <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject, IN ULONG SectorSize, IN ULONG MBRTypeIdentifier, OUT PVOID *<a class="el" href="../../d8/d6/ttri_8c.html#a3">Buffer</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID FASTCALL&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d7/d2/drivesup_8c.html#a30">xHalIoAssignDriveLetters</a> (IN struct <a class="el" href="../../d1/d2/struct__LOADER__PARAMETER__BLOCK.html">_LOADER_PARAMETER_BLOCK</a> *LoaderBlock, IN PSTRING NtDeviceName, OUT PUCHAR NtSystemPath, OUT PSTRING NtSystemPathString)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS FASTCALL&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d7/d2/drivesup_8c.html#a31">xHalIoReadPartitionTable</a> (IN <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject, IN ULONG SectorSize, IN BOOLEAN ReturnRecognizedPartitions, OUT struct _DRIVE_LAYOUT_INFORMATION **PartitionBuffer)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS FASTCALL&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d7/d2/drivesup_8c.html#a32">xHalIoSetPartitionInformation</a> (IN <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject, IN ULONG SectorSize, IN ULONG PartitionNumber, IN ULONG PartitionType)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS FASTCALL&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d7/d2/drivesup_8c.html#a33">xHalIoWritePartitionTable</a> (IN <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject, IN ULONG SectorSize, IN ULONG SectorsPerTrack, IN ULONG NumberOfHeads, IN struct _DRIVE_LAYOUT_INFORMATION *PartitionBuffer)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS FASTCALL&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d7/d2/drivesup_8c.html#a34">xHalIoClearPartitionTable</a> (IN <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject, IN ULONG SectorSize, IN ULONG SectorsPerTrack, IN ULONG NumberOfHeads)</td></tr>

<tr><td colspan=2><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d7/d2/drivesup_8c.html#a11">DrivesupDebug</a> = 0</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d7/d2/drivesup_8c.html#a12">DrivesupBreakIn</a> = FALSE</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>PUCHAR&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d7/d2/drivesup_8c.html#a15">DiskPartitionName</a> = "\\Device\\Harddisk%d\\Partition%d"</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>PUCHAR&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d7/d2/drivesup_8c.html#a16">RegistryKeyName</a> = DISK_REGISTRY_KEY</td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="a3" doxytag="drivesup.c::BOOTABLE_PARTITION" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define BOOTABLE_PARTITION&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00699">699</a> of file <a class="el" href="../../d8/d1/drivesup_8c-source.html">drivesup.c</a>.
<p>
Referenced by <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00706">HalpQueryPartitionType()</a>, and <a class="el" href="../../d8/d1/drivesup_8c-source.html#l01243">xHalIoAssignDriveLetters()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a0" doxytag="drivesup.c::DebugPrint" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define DebugPrint          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">x&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;DrivesupDebugPrint x</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00052">52</a> of file <a class="el" href="../../d8/d1/drivesup_8c-source.html">drivesup.c</a>.
<p>
Referenced by <a class="el" href="../../d7/d2/lh__core_2calcnd3_8c-source.html#l00049">Calc323Dim_Data8To8_Lut16()</a>, <a class="el" href="../../d7/d2/lh__core_2calcnd3_8c-source.html#l00972">Calc324Dim_Data8To8_Lut16()</a>, <a class="el" href="../../d7/d2/lh__core_2calcnd3_8c-source.html#l01895">Calc423Dim_Data8To8_Lut16()</a>, <a class="el" href="../../d7/d2/lh__core_2calcnd3_8c-source.html#l02818">Calc424Dim_Data8To8_Lut16()</a>, <a class="el" href="../../d9/d2/lh__core_2calcndim_8c-source.html#l00062">CalcNDim_Data8To8_Lut16()</a>, <a class="el" href="../../d7/d5/lh__open_2pi__cmm_8c-source.html#l00197">CMMConcatInitPrivate()</a>, <a class="el" href="../../d7/d5/lh__open_2pi__cmm_8c-source.html#l00060">CMMInitPrivate()</a>, <a class="el" href="../../d0/d6/lh__core_2fragment_8c-source.html#l00317">CombiMatrix()</a>, <a class="el" href="../../d1/d0/lh__core_2genluts_8c-source.html#l02423">CreateCombi()</a>, <a class="el" href="../../d1/d0/lh__core_2dondim_8c-source.html#l00130">DoMatrixForCube16()</a>, <a class="el" href="../../d1/d0/lh__core_2dondim_8c-source.html#l00058">DoOnlyMatrixForCube()</a>, <a class="el" href="../../d1/d0/lh__core_2dondim_8c-source.html#l00362">DoOnlyMatrixForCube16()</a>, <a class="el" href="../../d1/d0/lh__core_2genluts_8c-source.html#l00673">Extract_MFT_Xlut()</a>, <a class="el" href="../../d1/d0/lh__core_2genluts_8c-source.html#l01057">Extract_TRC_Alut()</a>, <a class="el" href="../../d1/d0/lh__core_2genluts_8c-source.html#l01762">ExtractAllLuts()</a>, <a class="el" href="../../d0/d6/lh__core_2fragment_8c-source.html#l00692">Fill_inverse_byte_ALUT_from_CurveTag()</a>, <a class="el" href="../../d5/d6/lh__core_2frgmnt16_8c-source.html#l00070">Fill_inverse_ushort_ALUT_from_CurveTag()</a>, <a class="el" href="../../d2/d3/lh__core_2runtime_8c-source.html#l02767">FindCalcRoutine()</a>, <a class="el" href="../../d8/d1/drivesup_8c-source.html#l03425">HalpIsValidPartitionEntry()</a>, <a class="el" href="../../d7/d9/pnpenum_8c-source.html#l02525">IopCallDriverAddDevice()</a>, <a class="el" href="../../d7/d9/pnpenum_8c-source.html#l03165">IopCallDriverAddDeviceQueryRoutine()</a>, <a class="el" href="../../d7/d9/pnpenum_8c-source.html#l04759">IopChangeDeviceObjectFromRegistryProperties()</a>, <a class="el" href="../../d7/d9/pnpenum_8c-source.html#l03762">IopProcessCriticalDevice()</a>, <a class="el" href="../../d7/d9/pnpenum_8c-source.html#l04000">IopProcessCriticalDeviceRoutine()</a>, <a class="el" href="../../d7/d9/pnpenum_8c-source.html#l01538">IopProcessNewDeviceNode()</a>, <a class="el" href="../../d3/d4/mapper_8c-source.html#l00658">MapperCallback()</a>, <a class="el" href="../../d3/d4/mapper_8c-source.html#l01600">MapperConstructRootEnumTree()</a>, <a class="el" href="../../d3/d4/mapper_8c-source.html#l01091">MapperMarkKey()</a>, <a class="el" href="../../d3/d4/mapper_8c-source.html#l00535">MapperPeripheralCallback()</a>, <a class="el" href="../../d3/d4/mapper_8c-source.html#l02060">MapperPhantomizeDetectedComPorts()</a>, <a class="el" href="../../d3/d4/mapper_8c-source.html#l01009">MapperProcessFirmwareTree()</a>, <a class="el" href="../../d3/d4/mapper_8c-source.html#l01298">MapperSeedKey()</a>, <a class="el" href="../../d3/d4/mapper_8c-source.html#l00402">MapperTranslatePnPId()</a>, <a class="el" href="../../d1/d5/lh__core_2memlink_8c-source.html#l00521">MyAdd_NL_AToB0Tag_mft1()</a>, <a class="el" href="../../d1/d5/lh__core_2memlink_8c-source.html#l00619">MyAdd_NL_AToB0Tag_mft2()</a>, <a class="el" href="../../d1/d5/lh__core_2memlink_8c-source.html#l00245">MyAdd_NL_CopyrightTag()</a>, <a class="el" href="../../d3/d0/pnpmap_8c-source.html#l02852">PnPBiosCheckForHardwareDisabled()</a>, <a class="el" href="../../d3/d0/pnpmap_8c-source.html#l02089">PnPBiosCopyDeviceParamKey()</a>, <a class="el" href="../../d3/d0/pnpmap_8c-source.html#l02663">PnPBiosCopyIoDecode()</a>, <a class="el" href="../../d3/d0/pnpmap_8c-source.html#l01725">PnPBiosEliminateDupes()</a>, <a class="el" href="../../d3/d0/pnpmap_8c-source.html#l01410">PnPBiosFindMatchingDevNode()</a>, <a class="el" href="../../d3/d0/pnpmap_8c-source.html#l00399">PnPBiosGetBiosInfo()</a>, <a class="el" href="../../d3/d0/pnpmap_8c-source.html#l00890">PnPBiosIoResourceListToCmResourceList()</a>, <a class="el" href="../../d3/d0/pnpmap_8c-source.html#l01126">PnPBiosTranslateInfo()</a>, <a class="el" href="../../d3/d0/pnpmap_8c-source.html#l02289">PnPBiosWriteInfo()</a>, <a class="el" href="../../d1/d0/lh__core_2genluts_8c-source.html#l03432">PrepareCombiLUTs()</a>, and <a class="el" href="../../d8/d1/drivesup_8c-source.html#l01739">xHalIoReadPartitionTable()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="drivesup.c::FT_PARTITION" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define FT_PARTITION&nbsp;&nbsp;&nbsp;3          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00702">702</a> of file <a class="el" href="../../d8/d1/drivesup_8c-source.html">drivesup.c</a>.
<p>
Referenced by <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00706">HalpQueryPartitionType()</a>, and <a class="el" href="../../d8/d1/drivesup_8c-source.html#l01243">xHalIoAssignDriveLetters()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="drivesup.c::GET_PARTITION_LENGTH" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define GET_PARTITION_LENGTH          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">p&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><pre class="fragment"><div>(                 \
        (ULONG) (p-&gt;PartitionLengthLsb0) +          \
        (ULONG) (p-&gt;PartitionLengthLsb1 &lt;&lt; 8) +     \
        (ULONG) (p-&gt;PartitionLengthMsb0 &lt;&lt; 16) +    \
        (ULONG) (p-&gt;PartitionLengthMsb1 &lt;&lt; 24) )
</div></pre>
<p>
Definition at line <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00064">64</a> of file <a class="el" href="../../d8/d1/drivesup_8c-source.html">drivesup.c</a>.
<p>
Referenced by <a class="el" href="../../d8/d1/drivesup_8c-source.html#l03425">HalpIsValidPartitionEntry()</a>, and <a class="el" href="../../d8/d1/drivesup_8c-source.html#l01739">xHalIoReadPartitionTable()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="drivesup.c::GET_STARTING_SECTOR" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define GET_STARTING_SECTOR          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">p&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><pre class="fragment"><div>(                  \
        (ULONG) (p-&gt;StartingSectorLsb0) +           \
        (ULONG) (p-&gt;StartingSectorLsb1 &lt;&lt; 8) +      \
        (ULONG) (p-&gt;StartingSectorMsb0 &lt;&lt; 16) +     \
        (ULONG) (p-&gt;StartingSectorMsb1 &lt;&lt; 24) )
</div></pre>
<p>
Definition at line <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00058">58</a> of file <a class="el" href="../../d8/d1/drivesup_8c-source.html">drivesup.c</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="drivesup.c::GET_STARTING_SECTOR" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define GET_STARTING_SECTOR          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">p&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><pre class="fragment"><div>(                  \
        (ULONG) (p-&gt;StartingSectorLsb0) +           \
        (ULONG) (p-&gt;StartingSectorLsb1 &lt;&lt; 8) +      \
        (ULONG) (p-&gt;StartingSectorMsb0 &lt;&lt; 16) +     \
        (ULONG) (p-&gt;StartingSectorMsb1 &lt;&lt; 24) )
</div></pre>
<p>
Definition at line <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00058">58</a> of file <a class="el" href="../../d8/d1/drivesup_8c-source.html">drivesup.c</a>.
<p>
Referenced by <a class="el" href="../../d8/d1/drivesup_8c-source.html#l03425">HalpIsValidPartitionEntry()</a>, <a class="el" href="../../d8/d1/drivesup_8c-source.html#l01739">xHalIoReadPartitionTable()</a>, and <a class="el" href="../../d8/d1/drivesup_8c-source.html#l02485">xHalIoSetPartitionInformation()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="drivesup.c::LOGICAL_PARTITION" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define LOGICAL_PARTITION&nbsp;&nbsp;&nbsp;2          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00701">701</a> of file <a class="el" href="../../d8/d1/drivesup_8c-source.html">drivesup.c</a>.
<p>
Referenced by <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00706">HalpQueryPartitionType()</a>, and <a class="el" href="../../d8/d1/drivesup_8c-source.html#l01243">xHalIoAssignDriveLetters()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="drivesup.c::OTHER_PARTITION" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define OTHER_PARTITION&nbsp;&nbsp;&nbsp;4          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00703">703</a> of file <a class="el" href="../../d8/d1/drivesup_8c-source.html">drivesup.c</a>.
<p>
Referenced by <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00706">HalpQueryPartitionType()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="drivesup.c::PRIMARY_PARTITION" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define PRIMARY_PARTITION&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00700">700</a> of file <a class="el" href="../../d8/d1/drivesup_8c-source.html">drivesup.c</a>.
<p>
Referenced by <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00706">HalpQueryPartitionType()</a>, and <a class="el" href="../../d8/d1/drivesup_8c-source.html#l01243">xHalIoAssignDriveLetters()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="drivesup.c::WHICH_BIT" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define WHICH_BIT          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Data,         <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>Bit&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><pre class="fragment"><div>{                      \
    <span class="keywordflow">for</span> (Bit = 0; Bit &lt; 32; Bit++) {                \
        <span class="keywordflow">if</span> ((Data &gt;&gt; Bit) == 1) {                   \
            <span class="keywordflow">break</span>;                                  \
        }                                           \
    }                                               \
}
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="drivesup.c::WHICH_BIT" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define WHICH_BIT          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Data,         <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>Bit&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><pre class="fragment"><div>{                      \
    <span class="keywordflow">for</span> (Bit = 0; Bit &lt; 32; Bit++) {                \
        <span class="keywordflow">if</span> ((Data &gt;&gt; Bit) == 1) {                   \
            <span class="keywordflow">break</span>;                                  \
        }                                           \
    }                                               \
}
</div></pre>
<p>
Referenced by <a class="el" href="../../d8/d1/drivesup_8c-source.html#l03486">xHalIoClearPartitionTable()</a>, and <a class="el" href="../../d8/d1/drivesup_8c-source.html#l02879">xHalIoWritePartitionTable()</a>.    </td>
  </tr>
</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="a13" doxytag="drivesup.c::BOOT_SECTOR_INFO" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef struct <a class="el" href="../../d7/d4/struct__BOOT__SECTOR__INFO.html">_BOOT_SECTOR_INFO</a>  <a class="el" href="../../d7/d4/struct__BOOT__SECTOR__INFO.html">BOOT_SECTOR_INFO</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="drivesup.c::PBOOT_SECTOR_INFO" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef struct <a class="el" href="../../d7/d4/struct__BOOT__SECTOR__INFO.html">_BOOT_SECTOR_INFO</a> * <a class="el" href="../../d7/d4/struct__BOOT__SECTOR__INFO.html">PBOOT_SECTOR_INFO</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Referenced by <a class="el" href="../../d8/d1/drivesup_8c-source.html#l01739">xHalIoReadPartitionTable()</a>.    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a17" doxytag="drivesup.c::DrivesupDebugPrint" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID DrivesupDebugPrint           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>DebugPrintLevel</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>PCCHAR&nbsp;</td>
          <td class="mdname" nowrap> <em>DebugMessage</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>...</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d1/drivesup_8c-source.html#l03882">3882</a> of file <a class="el" href="../../d8/d1/drivesup_8c-source.html">drivesup.c</a>.
<p>
References <a class="el" href="../../d7/d5/memprint_8h-source.html#l00079">DbgPrint</a>, <a class="el" href="../../d6/d0/pnpres_8c-source.html#l00275">DebugMessage</a>, and <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00042">DrivesupDebug</a>.
<p>
<pre class="fragment"><div>03889                    :
03890 
03891     <a class="code" href="../../d2/d5/editreg_8c.html#a51">Debug</a> <a class="code" href="../../d0/d1/rtdeltre_8c.html#a5">print</a> <span class="keywordflow">for</span> all SCSI drivers
03892 
03893 Arguments:
03894 
03895     <a class="code" href="../../d2/d5/editreg_8c.html#a51">Debug</a> <a class="code" href="../../d0/d1/rtdeltre_8c.html#a5">print</a> level between 0 and 3, with 3 being <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> most <a class="code" href="../../d2/d1/userexts_8c.html#a135">verbose</a>.
03896 
03897 Return Value:
03898 
03899     None
03900 
03901 --*/
03902 
03903 {
03904     UCHAR DrivesupBuffer[256];
03905 
03906     va_list ap;
03907 
03908     va_start(ap, DebugMessage);
03909 
03910 
03911     <span class="keywordflow">if</span> (DebugPrintLevel &lt;= <a class="code" href="../../d7/d2/drivesup_8c.html#a11">DrivesupDebug</a>) {
03912 
03913         _vsnprintf(DrivesupBuffer, 256, DebugMessage, ap);
03914 
03915         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(DrivesupBuffer);
03916     }
03917 
03918     va_end(ap);
03919 
03920 } <span class="comment">// end DrivesupDebugPrint()</span>
} <span class="comment">// end DrivesupDebugPrint()</span>
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a18" doxytag="drivesup.c::HalpCalculateChsValues" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID HalpCalculateChsValues           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PLARGE_INTEGER&nbsp;</td>
          <td class="mdname" nowrap> <em>PartitionOffset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PLARGE_INTEGER&nbsp;</td>
          <td class="mdname" nowrap> <em>PartitionLength</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN CCHAR&nbsp;</td>
          <td class="mdname" nowrap> <em>ShiftCount</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>SectorsPerTrack</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>NumberOfTracks</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>ConventionalCylinders</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT <a class="el" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html">PPARTITION_DESCRIPTOR</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>PartitionDescriptor</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00546">546</a> of file <a class="el" href="../../d8/d1/drivesup_8c-source.html">drivesup.c</a>.
<p>
References <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>.
<p>
Referenced by <a class="el" href="../../d8/d1/drivesup_8c-source.html#l02879">xHalIoWritePartitionTable()</a>.
<p>
<pre class="fragment"><div>00558                    :
00559 
00560     This routine will determine <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> cylinder, head, and sector (<a class="code" href="../../d4/d8/struct__tagCHS.html">CHS</a>) values
00561     that should be placed in a partition table entry, given the partition's
00562     location on the disk and its size.  The values calculated are packed into
00563     int13 format -- the high two bits of the sector byte contain bits 8 and 9
00564     of the 10 bit cylinder value, the low 6 bits of the sector byte contain
00565     the 6 bit sector value;  the cylinder byte contains the low 8 bits
00566     of the cylinder value; and the head byte contains the 8-bit head value.
00567     Both the start and end <a class="code" href="../../d4/d8/struct__tagCHS.html">CHS</a> values are calculated.
00568 
00569 Arguments:
00570 
00571     PartitionOffset - Byte offset of the partition, relative to the entire
00572         physical disk.
00573 
00574     PartitionLength - Size in bytes of the partition.
00575 
00576     ShiftCount - Shift count to convert from byte counts to sector counts.
00577 
00578     SectorsPerTrack - Number of sectors in a track on the media on which
00579         the partition resides.
00580 
00581     NumberOfTracks - Number of tracks in a cylinder on the media on which
00582         the partition resides.
00583 
00584     ConventionalCylinders - The "normalized" disk cylinders.  We will never
00585         set the cylinders greater than this.
00586 
00587     PartitionDescriptor - Structure to be filled in with the start and
00588         end <a class="code" href="../../d4/d8/struct__tagCHS.html">CHS</a> values.  Other fields in the structure are not referenced
00589         or modified.
00590 
00591 Return Value:
00592 
00593     None.
00594 
00595 Note:
00596 
00597     The Cylinder and Head values are 0-based but the Sector value is 1-based.
00598 
00599     If the start or end cylinder overflows 10 bits (ie, &gt; 1023), <a class="code" href="../../d4/d8/struct__tagCHS.html">CHS</a> values
00600     will be set to all 1's.
00601 
00602     No checking is done on the SectorsPerTrack and NumberOfTrack values.
00603 
00604 --*/
00605 
00606 {
00607     ULONG startSector, sectorCount, endSector;
00608     ULONG sectorsPerCylinder;
00609     ULONG remainder;
00610     ULONG startC, startH, startS, endC, endH, endS;
00611     LARGE_INTEGER tempInt;
00612 
00613     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00614 
00615     <span class="comment">//</span>
00616     <span class="comment">// Calculate the number of sectors in a cylinder.  This is the</span>
00617     <span class="comment">// number of heads multiplied by the number of sectors per track.</span>
00618     <span class="comment">//</span>
00619 
00620     sectorsPerCylinder = SectorsPerTrack * NumberOfTracks;
00621 
00622     <span class="comment">//</span>
00623     <span class="comment">// Convert byte offset/count to sector offset/count.</span>
00624     <span class="comment">//</span>
00625 
00626     tempInt.QuadPart = PartitionOffset-&gt;QuadPart &gt;&gt; ShiftCount;
00627     startSector = tempInt.LowPart;
00628 
00629     tempInt.QuadPart = PartitionLength-&gt;QuadPart &gt;&gt; ShiftCount;
00630     sectorCount = tempInt.LowPart;
00631 
00632     endSector = startSector + sectorCount - 1;
00633 
00634     startC = startSector / sectorsPerCylinder;
00635     endC   = endSector   / sectorsPerCylinder;
00636 
00637     <span class="keywordflow">if</span> (!ConventionalCylinders) {
00638 
00639         ConventionalCylinders = 1024;
00640 
00641     }
00642 
00643     <span class="comment">//</span>
00644     <span class="comment">// Set these values so that win95 is happy.</span>
00645     <span class="comment">//</span>
00646 
00647     <span class="keywordflow">if</span> (startC &gt;= ConventionalCylinders) {
00648 
00649         startC = ConventionalCylinders - 1;
00650 
00651     }
00652 
00653     <span class="keywordflow">if</span> (endC &gt;= ConventionalCylinders) {
00654 
00655         endC = ConventionalCylinders - 1;
00656 
00657     }
00658 
00659     <span class="comment">//</span>
00660     <span class="comment">// Calculate the starting track and sector.</span>
00661     <span class="comment">//</span>
00662 
00663     remainder = startSector % sectorsPerCylinder;
00664     startH = remainder / SectorsPerTrack;
00665     startS = remainder % SectorsPerTrack;
00666 
00667     <span class="comment">//</span>
00668     <span class="comment">// Calculate the ending track and sector.</span>
00669     <span class="comment">//</span>
00670 
00671     remainder = endSector % sectorsPerCylinder;
00672     endH = remainder / SectorsPerTrack;
00673     endS = remainder % SectorsPerTrack;
00674 
00675     <span class="comment">//</span>
00676     <span class="comment">// Pack the result into the caller's structure.</span>
00677     <span class="comment">//</span>
00678 
00679     <span class="comment">// low 8 bits of the cylinder =&gt; C value</span>
00680 
00681     PartitionDescriptor-&gt;StartingCylinderMsb = (UCHAR) startC;
00682     PartitionDescriptor-&gt;EndingCylinderMsb   = (UCHAR) endC;
00683 
00684     <span class="comment">// 8 bits of head value =&gt; H value</span>
00685 
00686     PartitionDescriptor-&gt;StartingTrack = (UCHAR) startH;
00687     PartitionDescriptor-&gt;EndingTrack   = (UCHAR) endH;
00688 
00689     <span class="comment">// bits 8-9 of cylinder and 6 bits of the sector =&gt; S value</span>
00690 
00691     PartitionDescriptor-&gt;StartingCylinderLsb = (UCHAR) (((startS + 1) &amp; 0x3f)
00692                                                         | ((startC &gt;&gt; 2) &amp; 0xc0));
00693 
00694     PartitionDescriptor-&gt;EndingCylinderLsb = (UCHAR) (((endS + 1) &amp; 0x3f)
00695                                                         | ((endC &gt;&gt; 2) &amp; 0xc0));
00696 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a26" doxytag="drivesup.c::HalpEnableAutomaticDriveLetterAssignment" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID HalpEnableAutomaticDriveLetterAssignment           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d1/drivesup_8c-source.html#l01022">1022</a> of file <a class="el" href="../../d8/d1/drivesup_8c-source.html">drivesup.c</a>.
<p>
References <a class="el" href="../../d7/d6/halmips_8h-source.html#l00623">Executive</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l01552">IoBuildDeviceIoControlRequest()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02865">IoCallDriver</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l06998">IoGetDeviceObjectPointer()</a>, <a class="el" href="../../d5/d8/ke_8h-source.html#l01066">KeInitializeEvent</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00624">KernelMode</a>, <a class="el" href="../../d2/d6/wait_8c-source.html#l00810">KeWaitForSingleObject()</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00494">ObDereferenceObject</a>, and <a class="el" href="../../d3/d6/string_8c-source.html#l00148">RtlInitUnicodeString()</a>.
<p>
Referenced by <a class="el" href="../../d8/d1/drivesup_8c-source.html#l01243">xHalIoAssignDriveLetters()</a>.
<p>
<pre class="fragment"><div>01027                    :
01028 
01029     This routine enables automatic drive letter assignment by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> mount
01030     point manager.
01031 
01032 Arguments:
01033 
01034     None.
01035 
01036 Return Value:
01037 
01038     None.
01039 
01040 --*/
01041 
01042 {
01043     UNICODE_STRING  name;
01044     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>    fileObject;
01045     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>  deviceObject;
01046     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a>          event;
01047     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>            irp;
01048     IO_STATUS_BLOCK ioStatus;
01049     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>        status;
01050 
01051     <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;name, MOUNTMGR_DEVICE_NAME);
01052     status = <a class="code" href="../../d4/d6/iosubs_8c.html#a71">IoGetDeviceObjectPointer</a>(&amp;name, FILE_READ_ATTRIBUTES, &amp;fileObject,
01053                                       &amp;deviceObject);
01054     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
01055         <span class="keywordflow">return</span>;
01056     }
01057 
01058     <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>(&amp;event, NotificationEvent, FALSE);
01059     irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a25">IoBuildDeviceIoControlRequest</a>(IOCTL_MOUNTMGR_AUTO_DL_ASSIGNMENTS,
01060                                         deviceObject, NULL, 0, NULL, 0, FALSE,
01061                                         &amp;event, &amp;ioStatus);
01062     <span class="keywordflow">if</span> (!irp) {
01063         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>(fileObject);
01064         <span class="keywordflow">return</span>;
01065     }
01066 
01067     status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>(deviceObject, irp);
01068     <span class="keywordflow">if</span> (status == STATUS_PENDING) {
01069         <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>(&amp;event, Executive, KernelMode, FALSE, NULL);
01070         status = ioStatus.Status;
01071     }
01072 
01073     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>(fileObject);
01074 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a22" doxytag="drivesup.c::HalpGetFullGeometry" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS HalpGetFullGeometry           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>DeviceObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PDISK_GEOMETRY&nbsp;</td>
          <td class="mdname" nowrap> <em>Geometry</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PULONGLONG&nbsp;</td>
          <td class="mdname" nowrap> <em>RealSectorCount</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d1/drivesup_8c-source.html#l03735">3735</a> of file <a class="el" href="../../d8/d1/drivesup_8c-source.html">drivesup.c</a>.
<p>
References <a class="el" href="../../d6/d7/ex_8h-source.html#l00253">ExAllocatePoolWithTag</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00623">Executive</a>, <a class="el" href="../../d7/d2/cmwraper_8c-source.html#l00304">ExFreePool()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l01552">IoBuildDeviceIoControlRequest()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02865">IoCallDriver</a>, <a class="el" href="../../d5/d8/ke_8h-source.html#l01066">KeInitializeEvent</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00624">KernelMode</a>, <a class="el" href="../../d2/d6/wait_8c-source.html#l00810">KeWaitForSingleObject()</a>, <a class="el" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, and <a class="el" href="../../d2/d7/hal_8h.html#a212">VOID()</a>.
<p>
Referenced by <a class="el" href="../../d8/d1/drivesup_8c-source.html#l01739">xHalIoReadPartitionTable()</a>.
<p>
<pre class="fragment"><div>03743                    :
03744 
03745     We need <span class="keyword">this</span> routine to get <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> number of cylinders that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> disk driver
03746     thinks <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> on <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> drive.  We will need <span class="keyword">this</span> to calculate <a class="code" href="../../d4/d8/struct__tagCHS.html">CHS</a> values
03747     when we fill in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partition table entries.
03748 
03749 Arguments:
03750 
03751     DeviceObject - The device object describing <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> entire drive.
03752 
03753     Geometry - The geometry of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> drive
03754     
03755     RealSectorCount - <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> actual number of sectors reported by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> drive (
03756                       <span class="keyword">this</span> may be less than the size computed by the geometry)
03757 
03758 Return Value:
03759 
03760     None.
03761 
03762 --*/
03763 
03764 {
03765     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> localIrp;
03766     IO_STATUS_BLOCK iosb;
03767     <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> eventPtr;
03768     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
03769 
03770     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
03771 
03772     eventPtr = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(
03773                    NonPagedPool,
03774                    <span class="keyword">sizeof</span>(<a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a>),
03775                    'btsF'
03776                    );
03777 
03778     <span class="keywordflow">if</span> (!eventPtr) {
03779         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
03780     }
03781 
03782     <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>(
03783         eventPtr,
03784         NotificationEvent,
03785         FALSE
03786         );
03787 
03788     localIrp = <a class="code" href="../../d4/d6/iosubs_8c.html#a25">IoBuildDeviceIoControlRequest</a>(
03789                    IOCTL_DISK_GET_DRIVE_GEOMETRY,
03790                    DeviceObject,
03791                    NULL,
03792                    0UL,
03793                    Geometry,
03794                    <span class="keyword">sizeof</span>(DISK_GEOMETRY),
03795                    FALSE,
03796                    eventPtr,
03797                    &amp;iosb
03798                    );
03799 
03800     <span class="keywordflow">if</span> (!localIrp) {
03801         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(eventPtr);
03802         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
03803     }
03804 
03805 
03806     <span class="comment">//</span>
03807     <span class="comment">// Call the lower level driver, wait for the opertion</span>
03808     <span class="comment">// to finish.</span>
03809     <span class="comment">//</span>
03810 
03811     status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>(
03812                  DeviceObject,
03813                  localIrp
03814                  );
03815 
03816     <span class="keywordflow">if</span> (status == STATUS_PENDING) {
03817         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>(
03818                    eventPtr,
03819                    Executive,
03820                    KernelMode,
03821                    FALSE,
03822                    (PLARGE_INTEGER) NULL
03823                    );
03824         status = iosb.Status;
03825     }
03826 
03827     <span class="keywordflow">if</span>(<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
03828 
03829         PARTITION_INFORMATION partitionInfo;
03830     
03831         localIrp = <a class="code" href="../../d4/d6/iosubs_8c.html#a25">IoBuildDeviceIoControlRequest</a>(
03832                        IOCTL_DISK_GET_PARTITION_INFO,
03833                        DeviceObject,
03834                        NULL,
03835                        0UL,
03836                        &amp;partitionInfo,
03837                        <span class="keyword">sizeof</span>(PARTITION_INFORMATION),
03838                        FALSE,
03839                        eventPtr,
03840                        &amp;iosb
03841                        );
03842     
03843         <span class="keywordflow">if</span> (!localIrp) {
03844             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(eventPtr);
03845             <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
03846         }
03847     
03848     
03849         <span class="comment">//</span>
03850         <span class="comment">// Call the lower level driver, wait for the opertion</span>
03851         <span class="comment">// to finish.</span>
03852         <span class="comment">//</span>
03853     
03854         status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>(
03855                      DeviceObject,
03856                      localIrp
03857                      );
03858     
03859         <span class="keywordflow">if</span> (status == STATUS_PENDING) {
03860             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>(
03861                        eventPtr,
03862                        Executive,
03863                        KernelMode,
03864                        FALSE,
03865                        (PLARGE_INTEGER) NULL
03866                        );
03867             status = iosb.Status;
03868         }
03869 
03870         <span class="keywordflow">if</span>(<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
03871             *RealSectorCount = (partitionInfo.PartitionLength.QuadPart / 
03872                                 Geometry-&gt;BytesPerSector);
03873         }
03874     }
03875 
03876     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(eventPtr);
03877     <span class="keywordflow">return</span> status;
03878 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a28" doxytag="drivesup.c::HalpIsOldStyleFloppy" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN HalpIsOldStyleFloppy           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PUNICODE_STRING&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>DeviceName</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d1/drivesup_8c-source.html#l01171">1171</a> of file <a class="el" href="../../d8/d1/drivesup_8c-source.html">drivesup.c</a>.
<p>
References <a class="el" href="../../d1/d4/io_8h-source.html#l01517">_FILE_OBJECT::DeviceObject</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00623">Executive</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l01552">IoBuildDeviceIoControlRequest()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02865">IoCallDriver</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l06829">IoGetAttachedDeviceReference()</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l06998">IoGetDeviceObjectPointer()</a>, <a class="el" href="../../d5/d8/ke_8h-source.html#l01066">KeInitializeEvent</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00624">KernelMode</a>, <a class="el" href="../../d2/d6/wait_8c-source.html#l00810">KeWaitForSingleObject()</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00494">ObDereferenceObject</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
Referenced by <a class="el" href="../../d8/d1/drivesup_8c-source.html#l01243">xHalIoAssignDriveLetters()</a>.
<p>
<pre class="fragment"><div>01177                    :
01178 
01179     This routine determines whether or not <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> given device <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> an old style
01180     floppy.  That <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>, a floppy controlled by a traditional floppy controller.
01181     These floppies have precedent in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> drive letter ordering.
01182 
01183 Arguments:
01184 
01185     DeviceName  - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> device name.
01186 
01187 Return Value:
01188 
01189     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>   - The given device <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not an old style floppy.
01190 
01191     <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>    - The given device <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> an old style floppy.
01192 
01193 --*/
01194 
01195 {
01196     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>    fileObject;
01197     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>  deviceObject;
01198     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a>          event;
01199     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>            irp;
01200     MOUNTDEV_NAME   name;
01201     IO_STATUS_BLOCK ioStatus;
01202     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>        status;
01203     
01204     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01205 
01206     status = <a class="code" href="../../d4/d6/iosubs_8c.html#a71">IoGetDeviceObjectPointer</a>(DeviceName, FILE_READ_ATTRIBUTES,
01207                                       &amp;fileObject, &amp;deviceObject);
01208     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
01209         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01210     }
01211     deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a67">IoGetAttachedDeviceReference</a>(fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o2">DeviceObject</a>);
01212     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>(fileObject);
01213 
01214 
01215     <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>(&amp;event, NotificationEvent, FALSE);
01216     irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a25">IoBuildDeviceIoControlRequest</a>(IOCTL_MOUNTDEV_QUERY_DEVICE_NAME,
01217                                         deviceObject, NULL, 0, &amp;name,
01218                                         <span class="keyword">sizeof</span>(name), FALSE, &amp;event,
01219                                         &amp;ioStatus);
01220     <span class="keywordflow">if</span> (!irp) {
01221         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>(deviceObject);
01222         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01223     }
01224 
01225     status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>(deviceObject, irp);
01226     <span class="keywordflow">if</span> (status == STATUS_PENDING) {
01227         <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>(&amp;event, Executive, KernelMode, FALSE, NULL);
01228         status = ioStatus.Status;
01229     }
01230 
01231     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>(deviceObject);
01232 
01233     <span class="keywordflow">if</span> (status == STATUS_BUFFER_OVERFLOW) {
01234         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01235     }
01236 
01237     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01238 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a23" doxytag="drivesup.c::HalpIsValidPartitionEntry" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN HalpIsValidPartitionEntry           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html">PPARTITION_DESCRIPTOR</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Entry</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>ULONGLONG&nbsp;</td>
          <td class="mdname" nowrap> <em>MaxOffset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>ULONGLONG&nbsp;</td>
          <td class="mdname" nowrap> <em>MaxSector</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d1/drivesup_8c-source.html#l03425">3425</a> of file <a class="el" href="../../d8/d1/drivesup_8c-source.html">drivesup.c</a>.
<p>
References <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00052">DebugPrint</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00064">GET_PARTITION_LENGTH</a>, <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00058">GET_STARTING_SECTOR</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d3/d6/hal_8h-source.html#l00126">_PARTITION_DESCRIPTOR::PartitionType</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
Referenced by <a class="el" href="../../d8/d1/drivesup_8c-source.html#l01739">xHalIoReadPartitionTable()</a>.
<p>
<pre class="fragment"><div>03430 {
03431     ULONGLONG endingSector;
03432 
03433     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
03434 
03435     <span class="keywordflow">if</span>(Entry-&gt;<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html#o4">PartitionType</a> == PARTITION_ENTRY_UNUSED) {
03436 
03437         <span class="comment">//</span>
03438         <span class="comment">// Unused partition entries are always valid.</span>
03439         <span class="comment">//</span>
03440 
03441         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03442 
03443     }
03444 
03445     <span class="comment">//</span>
03446     <span class="comment">// Container partition entries and normal partition entries are valid iff </span>
03447     <span class="comment">// the partition they describe can possibly fit on the disk.  We add </span>
03448     <span class="comment">// the base sector, the sector offset of the partition and the partition </span>
03449     <span class="comment">// length.  If they exceed the sector count then this partition entry </span>
03450     <span class="comment">// is considered invalid.</span>
03451     <span class="comment">//</span>
03452 
03453     endingSector = <a class="code" href="../../d7/d2/drivesup_8c.html#a1">GET_STARTING_SECTOR</a>(Entry) + 
03454                    <a class="code" href="../../d7/d2/drivesup_8c.html#a2">GET_PARTITION_LENGTH</a>(Entry);
03455 
03456     <span class="keywordflow">if</span>(endingSector &gt; MaxSector) {
03457 
03458         <a class="code" href="../../d7/d2/drivesup_8c.html#a0">DebugPrint</a>((1, <span class="stringliteral">"HalpIsValidPartitionEntry: entry is invalid\n"</span>));
03459         <a class="code" href="../../d7/d2/drivesup_8c.html#a0">DebugPrint</a>((1, <span class="stringliteral">"\tHalpIsValidPartitionEntry: offset %#08lx\n"</span>, 
03460                     <a class="code" href="../../d7/d2/drivesup_8c.html#a1">GET_STARTING_SECTOR</a>(Entry)));
03461         <a class="code" href="../../d7/d2/drivesup_8c.html#a0">DebugPrint</a>((1, <span class="stringliteral">"\tHalpIsValidPartitionEntry: length %#08lx\n"</span>, 
03462                     <a class="code" href="../../d7/d2/drivesup_8c.html#a2">GET_PARTITION_LENGTH</a>(Entry)));
03463         <a class="code" href="../../d7/d2/drivesup_8c.html#a0">DebugPrint</a>((1, <span class="stringliteral">"\tHalpIsValidPartitionEntry: end %#I64x\n"</span>, endingSector));
03464         <a class="code" href="../../d7/d2/drivesup_8c.html#a0">DebugPrint</a>((1, <span class="stringliteral">"\tHalpIsValidPartitionEntry: max %#I64x\n"</span>, MaxSector));
03465 
03466         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03467     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="../../d7/d2/drivesup_8c.html#a1">GET_STARTING_SECTOR</a>(Entry) &gt; MaxOffset) {
03468 
03469         <a class="code" href="../../d7/d2/drivesup_8c.html#a0">DebugPrint</a>((1, <span class="stringliteral">"HalpIsValidPartitionEntry: entry is invalid\n"</span>));
03470         <a class="code" href="../../d7/d2/drivesup_8c.html#a0">DebugPrint</a>((1, <span class="stringliteral">"\tHalpIsValidPartitionEntry: offset %#08lx\n"</span>, 
03471                     <a class="code" href="../../d7/d2/drivesup_8c.html#a1">GET_STARTING_SECTOR</a>(Entry)));
03472         <a class="code" href="../../d7/d2/drivesup_8c.html#a0">DebugPrint</a>((1, <span class="stringliteral">"\tHalpIsValidPartitionEntry: length %#08lx\n"</span>, 
03473                     <a class="code" href="../../d7/d2/drivesup_8c.html#a2">GET_PARTITION_LENGTH</a>(Entry)));
03474         <a class="code" href="../../d7/d2/drivesup_8c.html#a0">DebugPrint</a>((1, <span class="stringliteral">"\tHalpIsValidPartitionEntry: end %#I64x\n"</span>, endingSector));
03475         <a class="code" href="../../d7/d2/drivesup_8c.html#a0">DebugPrint</a>((1, <span class="stringliteral">"\tHalpIsValidPartitionEntry: maxOffset %#I64x\n"</span>, MaxOffset));
03476         
03477         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03478     }
03479 
03480     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03481 }
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a25" doxytag="drivesup.c::HalpNextDriveLetter" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> UCHAR HalpNextDriveLetter           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PUNICODE_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>DeviceName</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PSTRING&nbsp;</td>
          <td class="mdname" nowrap> <em>NtDeviceName</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PUCHAR&nbsp;</td>
          <td class="mdname" nowrap> <em>NtSystemPath</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>UseHardLinksIfNecessary</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00934">934</a> of file <a class="el" href="../../d8/d1/drivesup_8c-source.html">drivesup.c</a>.
<p>
References <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00851">HalpNextMountLetter()</a>, <a class="el" href="../../d8/d1/drivesup_8c-source.html#l01078">HalpSetMountLetter()</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l05675">IoCreateSymbolicLink()</a>, <a class="el" href="../../d3/d9/aw_8h-source.html#l00031">L</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d7/d5/nls_8c-source.html#l00082">RtlAnsiStringToUnicodeString()</a>, <a class="el" href="../../d7/d5/nls_8c-source.html#l01608">RtlEqualUnicodeString()</a>, <a class="el" href="../../d7/d5/nls_8c-source.html#l01215">RtlFreeUnicodeString()</a>, <a class="el" href="../../d3/d6/string_8c-source.html#l00148">RtlInitUnicodeString()</a>, <a class="el" href="../../d7/d5/nls_8c-source.html#l01690">RtlPrefixUnicodeString()</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
Referenced by <a class="el" href="../../d8/d1/drivesup_8c-source.html#l01243">xHalIoAssignDriveLetters()</a>.
<p>
<pre class="fragment"><div>00943                    :
00944 
00945     This routine gives <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> device <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> next available drive letter.
00946 
00947 Arguments:
00948 
00949     DeviceName      - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> device name.
00950 
00951     NtDeviceName    - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> NT device name.
00952 
00953     NtSystemPath    - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> NT system <a class="code" href="../../d3/d3/dumpuser_8c.html#a14">path</a>.
00954 
00955 Return Value:
00956 
00957     The drive letter assigned or 0.
00958 
00959 --*/
00960 
00961 {
00962     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>        status;
00963     UCHAR           firstDriveLetter, driveLetter;
00964     WCHAR           name[40];
00965     UNICODE_STRING  symName;
00966     UNICODE_STRING  unicodeString, floppyPrefix, cdromPrefix;
00967 
00968     status = <a class="code" href="../../d7/d2/drivesup_8c.html#a24">HalpNextMountLetter</a>(DeviceName, &amp;driveLetter);
00969     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
00970         <span class="keywordflow">return</span> driveLetter;
00971     }
00972 
00973     <span class="keywordflow">if</span> (!NtDeviceName || !NtSystemPath) {
00974         <span class="keywordflow">return</span> 0xFF;
00975     }
00976 
00977     <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;floppyPrefix, L<span class="stringliteral">"\\Device\\Floppy"</span>);
00978     <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;cdromPrefix, L<span class="stringliteral">"\\Device\\CdRom"</span>);
00979     <span class="keywordflow">if</span> (<a class="code" href="../../d6/d6/nls_8c.html#a43">RtlPrefixUnicodeString</a>(&amp;floppyPrefix, DeviceName, TRUE)) {
00980         firstDriveLetter = <span class="charliteral">'A'</span>;
00981     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d6/d6/nls_8c.html#a43">RtlPrefixUnicodeString</a>(&amp;cdromPrefix, DeviceName, TRUE)) {
00982         firstDriveLetter = <span class="charliteral">'D'</span>;
00983     } <span class="keywordflow">else</span> {
00984         firstDriveLetter = <span class="charliteral">'C'</span>;
00985     }
00986 
00987     <span class="keywordflow">for</span> (driveLetter = firstDriveLetter; driveLetter &lt;= <span class="charliteral">'Z'</span>; driveLetter++) {
00988         status = <a class="code" href="../../d7/d2/drivesup_8c.html#a27">HalpSetMountLetter</a>(DeviceName, driveLetter);
00989         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
00990             <a class="code" href="../../d6/d6/nls_8c.html#a21">RtlAnsiStringToUnicodeString</a>(&amp;unicodeString, NtDeviceName, TRUE);
00991             <span class="keywordflow">if</span> (<a class="code" href="../../d6/d6/nls_8c.html#a42">RtlEqualUnicodeString</a>(&amp;unicodeString, DeviceName, TRUE)) {
00992                 NtSystemPath[0] = driveLetter;
00993             }
00994             <a class="code" href="../../d6/d6/nls_8c.html#a34">RtlFreeUnicodeString</a>(&amp;unicodeString);
00995             <span class="keywordflow">return</span> driveLetter;
00996         }
00997     }
00998 
00999     <span class="keywordflow">if</span> (!UseHardLinksIfNecessary) {
01000         <span class="keywordflow">return</span> 0;
01001     }
01002 
01003     <span class="keywordflow">for</span> (driveLetter = firstDriveLetter; driveLetter &lt;= <span class="charliteral">'Z'</span>; driveLetter++) {
01004         swprintf(name, L<span class="stringliteral">"\\DosDevices\\%c:"</span>, driveLetter);
01005         <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;symName, name);
01006         status = <a class="code" href="../../d4/d6/iosubs_8c.html#a50">IoCreateSymbolicLink</a>(&amp;symName, DeviceName);
01007         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
01008             <a class="code" href="../../d6/d6/nls_8c.html#a21">RtlAnsiStringToUnicodeString</a>(&amp;unicodeString, NtDeviceName, TRUE);
01009             <span class="keywordflow">if</span> (<a class="code" href="../../d6/d6/nls_8c.html#a42">RtlEqualUnicodeString</a>(&amp;unicodeString, DeviceName, TRUE)) {
01010                 NtSystemPath[0] = driveLetter;
01011             }
01012             <a class="code" href="../../d6/d6/nls_8c.html#a34">RtlFreeUnicodeString</a>(&amp;unicodeString);
01013             <span class="keywordflow">return</span> driveLetter;
01014         }
01015     }
01016 
01017     <span class="keywordflow">return</span> 0;
01018 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a24" doxytag="drivesup.c::HalpNextMountLetter" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS HalpNextMountLetter           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PUNICODE_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>DeviceName</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PUCHAR&nbsp;</td>
          <td class="mdname" nowrap> <em>DriveLetter</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00851">851</a> of file <a class="el" href="../../d8/d1/drivesup_8c-source.html">drivesup.c</a>.
<p>
References <a class="el" href="../../d6/d7/ex_8h-source.html#l00253">ExAllocatePoolWithTag</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00623">Executive</a>, <a class="el" href="../../d7/d2/cmwraper_8c-source.html#l00304">ExFreePool()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l01552">IoBuildDeviceIoControlRequest()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02865">IoCallDriver</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l06998">IoGetDeviceObjectPointer()</a>, <a class="el" href="../../d5/d8/ke_8h-source.html#l01066">KeInitializeEvent</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00624">KernelMode</a>, <a class="el" href="../../d2/d6/wait_8c-source.html#l00810">KeWaitForSingleObject()</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00494">ObDereferenceObject</a>, <a class="el" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>, and <a class="el" href="../../d3/d6/string_8c-source.html#l00148">RtlInitUnicodeString()</a>.
<p>
Referenced by <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00934">HalpNextDriveLetter()</a>.
<p>
<pre class="fragment"><div>00858                    :
00859 
00860     This routine gives <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> device <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> next available drive letter.
00861 
00862 Arguments:
00863 
00864     DeviceName  - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> device name.
00865 
00866     DriveLetter - Returns <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> drive letter assigned or 0.
00867 
00868 Return Value:
00869 
00870     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00871 
00872 --*/
00873 
00874 {
00875     UNICODE_STRING                      name;
00876     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>                        fileObject;
00877     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>                      deviceObject;
00878     PMOUNTMGR_DRIVE_LETTER_TARGET       input;
00879     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a>                              event;
00880     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>                                irp;
00881     MOUNTMGR_DRIVE_LETTER_INFORMATION   output;
00882     IO_STATUS_BLOCK                     ioStatus;
00883     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>                            status;
00884 
00885     <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;name, MOUNTMGR_DEVICE_NAME);
00886     status = <a class="code" href="../../d4/d6/iosubs_8c.html#a71">IoGetDeviceObjectPointer</a>(&amp;name, FILE_READ_ATTRIBUTES, &amp;fileObject,
00887                                       &amp;deviceObject);
00888     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
00889         <span class="keywordflow">return</span> status;
00890     }
00891 
00892     input = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(PagedPool,
00893                                   (<span class="keyword">sizeof</span>(MOUNTMGR_DRIVE_LETTER_TARGET) +
00894                                    DeviceName-&gt;Length),
00895                                   'btsF'
00896                                  );
00897 
00898     <span class="keywordflow">if</span> (!input) {
00899         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>(fileObject);
00900         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
00901     }
00902 
00903     input-&gt;DeviceNameLength = DeviceName-&gt;Length;
00904     RtlCopyMemory(input-&gt;DeviceName, DeviceName-&gt;Buffer, DeviceName-&gt;Length);
00905 
00906     <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>(&amp;event, NotificationEvent, FALSE);
00907     irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a25">IoBuildDeviceIoControlRequest</a>(IOCTL_MOUNTMGR_NEXT_DRIVE_LETTER,
00908                                         deviceObject, input,
00909                                         <span class="keyword">sizeof</span>(MOUNTMGR_DRIVE_LETTER_TARGET) +
00910                                         DeviceName-&gt;Length, &amp;output,
00911                                         <span class="keyword">sizeof</span>(output), FALSE, &amp;event,
00912                                         &amp;ioStatus);
00913     <span class="keywordflow">if</span> (!irp) {
00914         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(input);
00915         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>(fileObject);
00916         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
00917     }
00918 
00919     status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>(deviceObject, irp);
00920     <span class="keywordflow">if</span> (status == STATUS_PENDING) {
00921         <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>(&amp;event, Executive, KernelMode, FALSE, NULL);
00922         status = ioStatus.Status;
00923     }
00924 
00925     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(input);
00926     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>(fileObject);
00927 
00928     *DriveLetter = output.CurrentDriveLetter;
00929 
00930     <span class="keywordflow">return</span> status;
00931 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a20" doxytag="drivesup.c::HalpQueryDriveLayout" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS HalpQueryDriveLayout           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PUNICODE_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>DeviceName</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PDRIVE_LAYOUT_INFORMATION *&nbsp;</td>
          <td class="mdname" nowrap> <em>DriveLayout</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00792">792</a> of file <a class="el" href="../../d8/d1/drivesup_8c-source.html">drivesup.c</a>.
<p>
References <a class="el" href="../../d1/d4/io_8h-source.html#l01185">_DEVICE_OBJECT::Characteristics</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01517">_FILE_OBJECT::DeviceObject</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00623">Executive</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l01552">IoBuildDeviceIoControlRequest()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02865">IoCallDriver</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l06829">IoGetAttachedDeviceReference()</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l06998">IoGetDeviceObjectPointer()</a>, <a class="el" href="../../d2/d7/hal_8h.html#a192">IoReadPartitionTable()</a>, <a class="el" href="../../d5/d8/ke_8h-source.html#l01066">KeInitializeEvent</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00624">KernelMode</a>, <a class="el" href="../../d2/d6/wait_8c-source.html#l00810">KeWaitForSingleObject()</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, and <a class="el" href="../../d5/d9/ob_8h-source.html#l00494">ObDereferenceObject</a>.
<p>
Referenced by <a class="el" href="../../d8/d1/drivesup_8c-source.html#l01243">xHalIoAssignDriveLetters()</a>.
<p>
<pre class="fragment"><div>00797 {
00798     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>        status;
00799     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>    fileObject;
00800     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>  deviceObject;
00801     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a>          event;
00802     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>            irp;
00803     DISK_GEOMETRY   geometry;
00804     IO_STATUS_BLOCK ioStatus;
00805 
00806     status = <a class="code" href="../../d4/d6/iosubs_8c.html#a71">IoGetDeviceObjectPointer</a>(DeviceName, FILE_READ_ATTRIBUTES,
00807                                       &amp;fileObject, &amp;deviceObject);
00808     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
00809         <span class="keywordflow">return</span> status;
00810     }
00811     deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a67">IoGetAttachedDeviceReference</a>(fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o2">DeviceObject</a>);
00812     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>(fileObject);
00813 
00814     <span class="keywordflow">if</span> (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o9">Characteristics</a>&amp;FILE_REMOVABLE_MEDIA) {
00815         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>(deviceObject);
00816         <span class="keywordflow">return</span> STATUS_NO_MEDIA;
00817     }
00818 
00819     <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>(&amp;event, NotificationEvent, FALSE);
00820 
00821     irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a25">IoBuildDeviceIoControlRequest</a>(IOCTL_DISK_GET_DRIVE_GEOMETRY,
00822                                         deviceObject, NULL, 0, &amp;geometry,
00823                                         <span class="keyword">sizeof</span>(geometry), FALSE, &amp;event,
00824                                         &amp;ioStatus);
00825     <span class="keywordflow">if</span> (!irp) {
00826         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>(deviceObject);
00827         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
00828     }
00829 
00830     status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>(deviceObject, irp);
00831     <span class="keywordflow">if</span> (status == STATUS_PENDING) {
00832         <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>(&amp;event, Executive, KernelMode, FALSE, NULL);
00833         status = ioStatus.Status;
00834     }
00835 
00836     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
00837         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>(deviceObject);
00838         <span class="keywordflow">return</span> status;
00839     }
00840 
00841     status = <a class="code" href="../../d2/d7/hal_8h.html#a192">IoReadPartitionTable</a>(deviceObject, geometry.BytesPerSector,
00842                                   FALSE, DriveLayout);
00843 
00844     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>(deviceObject);
00845 
00846     <span class="keywordflow">return</span> status;
00847 }
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a19" doxytag="drivesup.c::HalpQueryPartitionType" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS HalpQueryPartitionType           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PUNICODE_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>DeviceName</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PDRIVE_LAYOUT_INFORMATION&nbsp;</td>
          <td class="mdname" nowrap> <em>DriveLayout</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>PartitionType</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00706">706</a> of file <a class="el" href="../../d8/d1/drivesup_8c-source.html">drivesup.c</a>.
<p>
References <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00699">BOOTABLE_PARTITION</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01185">_DEVICE_OBJECT::Characteristics</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01517">_FILE_OBJECT::DeviceObject</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00623">Executive</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00702">FT_PARTITION</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l01552">IoBuildDeviceIoControlRequest()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02865">IoCallDriver</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l06829">IoGetAttachedDeviceReference()</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l06998">IoGetDeviceObjectPointer()</a>, <a class="el" href="../../d5/d8/ke_8h-source.html#l01066">KeInitializeEvent</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00624">KernelMode</a>, <a class="el" href="../../d2/d6/wait_8c-source.html#l00810">KeWaitForSingleObject()</a>, <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00701">LOGICAL_PARTITION</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00494">ObDereferenceObject</a>, <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00703">OTHER_PARTITION</a>, and <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00700">PRIMARY_PARTITION</a>.
<p>
Referenced by <a class="el" href="../../d8/d1/drivesup_8c-source.html#l01243">xHalIoAssignDriveLetters()</a>.
<p>
<pre class="fragment"><div>00712 {
00713     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>                status;
00714     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>            fileObject;
00715     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>          deviceObject;
00716     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a>                  event;
00717     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>                    irp;
00718     PARTITION_INFORMATION   partInfo;
00719     IO_STATUS_BLOCK         ioStatus;
00720     ULONG                   i;
00721 
00722     status = <a class="code" href="../../d4/d6/iosubs_8c.html#a71">IoGetDeviceObjectPointer</a>(DeviceName,
00723                                       FILE_READ_ATTRIBUTES,
00724                                       &amp;fileObject, &amp;deviceObject);
00725     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
00726         <span class="keywordflow">return</span> status;
00727     }
00728     deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a67">IoGetAttachedDeviceReference</a>(fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o2">DeviceObject</a>);
00729     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>(fileObject);
00730 
00731     <span class="keywordflow">if</span> ((deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o9">Characteristics</a>&amp;FILE_REMOVABLE_MEDIA) ||
00732         !DriveLayout) {
00733 
00734         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>(deviceObject);
00735         *PartitionType = <a class="code" href="../../d7/d2/drivesup_8c.html#a5">LOGICAL_PARTITION</a>;
00736         <span class="keywordflow">return</span> STATUS_SUCCESS;
00737     }
00738 
00739     <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>(&amp;event, NotificationEvent, FALSE);
00740 
00741     irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a25">IoBuildDeviceIoControlRequest</a>(IOCTL_DISK_GET_PARTITION_INFO,
00742                                         deviceObject, NULL, 0, &amp;partInfo,
00743                                         <span class="keyword">sizeof</span>(partInfo), FALSE, &amp;event,
00744                                         &amp;ioStatus);
00745     <span class="keywordflow">if</span> (!irp) {
00746         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>(deviceObject);
00747         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
00748     }
00749 
00750     status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>(deviceObject, irp);
00751     <span class="keywordflow">if</span> (status == STATUS_PENDING) {
00752         <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>(&amp;event, Executive, KernelMode, FALSE, NULL);
00753         status = ioStatus.Status;
00754     }
00755 
00756     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>(deviceObject);
00757 
00758     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
00759         <span class="keywordflow">return</span> status;
00760     }
00761 
00762     <span class="keywordflow">if</span> (!IsRecognizedPartition(partInfo.PartitionType)) {
00763         *PartitionType = <a class="code" href="../../d7/d2/drivesup_8c.html#a7">OTHER_PARTITION</a>;
00764         <span class="keywordflow">return</span> STATUS_SUCCESS;
00765     }
00766 
00767     <span class="keywordflow">if</span> (partInfo.PartitionType&amp;0x80) {
00768         *PartitionType = <a class="code" href="../../d7/d2/drivesup_8c.html#a6">FT_PARTITION</a>;
00769         <span class="keywordflow">return</span> STATUS_SUCCESS;
00770     }
00771 
00772     <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++) {
00773         <span class="keywordflow">if</span> (partInfo.StartingOffset.QuadPart ==
00774             DriveLayout-&gt;PartitionEntry[i].StartingOffset.QuadPart) {
00775 
00776             <span class="keywordflow">if</span> (partInfo.BootIndicator) {
00777                 *PartitionType = <a class="code" href="../../d7/d2/drivesup_8c.html#a3">BOOTABLE_PARTITION</a>;
00778             } <span class="keywordflow">else</span> {
00779                 *PartitionType = <a class="code" href="../../d7/d2/drivesup_8c.html#a4">PRIMARY_PARTITION</a>;
00780             }
00781 
00782             <span class="keywordflow">return</span> STATUS_SUCCESS;
00783         }
00784     }
00785 
00786     *PartitionType = <a class="code" href="../../d7/d2/drivesup_8c.html#a5">LOGICAL_PARTITION</a>;
00787     <span class="keywordflow">return</span> STATUS_SUCCESS;
00788 }
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a27" doxytag="drivesup.c::HalpSetMountLetter" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS HalpSetMountLetter           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PUNICODE_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>DeviceName</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN UCHAR&nbsp;</td>
          <td class="mdname" nowrap> <em>DriveLetter</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d1/drivesup_8c-source.html#l01078">1078</a> of file <a class="el" href="../../d8/d1/drivesup_8c-source.html">drivesup.c</a>.
<p>
References <a class="el" href="../../d6/d7/ex_8h-source.html#l00253">ExAllocatePoolWithTag</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00623">Executive</a>, <a class="el" href="../../d7/d2/cmwraper_8c-source.html#l00304">ExFreePool()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l01552">IoBuildDeviceIoControlRequest()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02865">IoCallDriver</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l06998">IoGetDeviceObjectPointer()</a>, <a class="el" href="../../d5/d8/ke_8h-source.html#l01066">KeInitializeEvent</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00624">KernelMode</a>, <a class="el" href="../../d2/d6/wait_8c-source.html#l00810">KeWaitForSingleObject()</a>, <a class="el" href="../../d3/d9/aw_8h-source.html#l00031">L</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00494">ObDereferenceObject</a>, <a class="el" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>, and <a class="el" href="../../d3/d6/string_8c-source.html#l00148">RtlInitUnicodeString()</a>.
<p>
Referenced by <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00934">HalpNextDriveLetter()</a>, and <a class="el" href="../../d8/d1/drivesup_8c-source.html#l01243">xHalIoAssignDriveLetters()</a>.
<p>
<pre class="fragment"><div>01085                    :
01086 
01087     This routine sets <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> drive letter <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> given device.
01088 
01089 Arguments:
01090 
01091     DeviceName  - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> device name.
01092 
01093     DriveLetter - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> drive letter.
01094 
01095 Return Value:
01096 
01097     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01098 
01099 --*/
01100 
01101 {
01102     WCHAR                           dosBuffer[30];
01103     UNICODE_STRING                  dosName;
01104     ULONG                           createPointSize;
01105     PMOUNTMGR_CREATE_POINT_INPUT    createPoint;
01106     UNICODE_STRING                  name;
01107     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>                        status;
01108     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>                    fileObject;
01109     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>                  deviceObject;
01110     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a>                          event;
01111     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>                            irp;
01112     IO_STATUS_BLOCK                 ioStatus;
01113 
01114     swprintf(dosBuffer, L<span class="stringliteral">"\\DosDevices\\%c:"</span>, DriveLetter);
01115     <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;dosName, dosBuffer);
01116 
01117     createPointSize = <span class="keyword">sizeof</span>(MOUNTMGR_CREATE_POINT_INPUT) +
01118                       dosName.Length + DeviceName-&gt;Length;
01119 
01120     createPoint = (PMOUNTMGR_CREATE_POINT_INPUT)
01121                   <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(PagedPool, createPointSize, 'btsF');
01122     <span class="keywordflow">if</span> (!createPoint) {
01123         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
01124     }
01125 
01126     createPoint-&gt;SymbolicLinkNameOffset = <span class="keyword">sizeof</span>(MOUNTMGR_CREATE_POINT_INPUT);
01127     createPoint-&gt;SymbolicLinkNameLength = dosName.Length;
01128     createPoint-&gt;DeviceNameOffset = createPoint-&gt;SymbolicLinkNameOffset +
01129                                     createPoint-&gt;SymbolicLinkNameLength;
01130     createPoint-&gt;DeviceNameLength = DeviceName-&gt;Length;
01131 
01132     RtlCopyMemory((PCHAR) createPoint + createPoint-&gt;SymbolicLinkNameOffset,
01133                   dosName.Buffer, dosName.Length);
01134     RtlCopyMemory((PCHAR) createPoint + createPoint-&gt;DeviceNameOffset,
01135                   DeviceName-&gt;Buffer, DeviceName-&gt;Length);
01136 
01137     <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;name, MOUNTMGR_DEVICE_NAME);
01138     status = <a class="code" href="../../d4/d6/iosubs_8c.html#a71">IoGetDeviceObjectPointer</a>(&amp;name, FILE_READ_ATTRIBUTES, &amp;fileObject,
01139                                       &amp;deviceObject);
01140     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
01141         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(createPoint);
01142         <span class="keywordflow">return</span> status;
01143     }
01144 
01145     <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>(&amp;event, NotificationEvent, FALSE);
01146     irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a25">IoBuildDeviceIoControlRequest</a>(IOCTL_MOUNTMGR_CREATE_POINT,
01147                                         deviceObject, createPoint,
01148                                         createPointSize, NULL, 0, FALSE,
01149                                         &amp;event, &amp;ioStatus);
01150     <span class="keywordflow">if</span> (!irp) {
01151         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>(fileObject);
01152         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(createPoint);
01153         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
01154     }
01155 
01156     status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>(deviceObject, irp);
01157     <span class="keywordflow">if</span> (status == STATUS_PENDING) {
01158         <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>(&amp;event, Executive, KernelMode, FALSE, NULL);
01159         status = ioStatus.Status;
01160     }
01161 
01162     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>(fileObject);
01163     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(createPoint);
01164 
01165     <span class="keywordflow">return</span> status;
01166 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a29" doxytag="drivesup.c::xHalExamineMBR" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID FASTCALL xHalExamineMBR           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>DeviceObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>SectorSize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>MBRTypeIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PVOID *&nbsp;</td>
          <td class="mdname" nowrap> <em>Buffer</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00190">190</a> of file <a class="el" href="../../d8/d1/drivesup_8c-source.html">drivesup.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d3/d6/hal_8h-source.html#l00157">BOOT_RECORD_SIGNATURE</a>, <a class="el" href="../../d3/d6/hal_8h-source.html#l00151">BOOT_SIGNATURE_OFFSET</a>, <a class="el" href="../../d7/d1/rtqkey_8c-source.html#l00042">Buffer</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l00253">ExAllocatePoolWithTag</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00623">Executive</a>, <a class="el" href="../../d7/d2/cmwraper_8c-source.html#l00304">ExFreePool()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02030">_IO_STACK_LOCATION::Flags</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l01933">IoBuildSynchronousFsdRequest()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02865">IoCallDriver</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l03398">IoGetNextIrpStackLocation</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00058">IRP_MJ_READ</a>, <a class="el" href="../../d5/d8/ke_8h-source.html#l01066">KeInitializeEvent</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00624">KernelMode</a>, <a class="el" href="../../d2/d6/wait_8c-source.html#l00810">KeWaitForSingleObject()</a>, <a class="el" href="../../d5/d8/ex_8h.html#a329a177">NonPagedPoolCacheAligned</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00599">PAGE_SIZE</a>, <a class="el" href="../../d3/d6/hal_8h-source.html#l00150">PARTITION_TABLE_OFFSET</a>, <a class="el" href="../../d3/d6/hal_8h-source.html#l00126">_PARTITION_DESCRIPTOR::PartitionType</a>, <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00085">PUSHORT</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00230">SectorSize</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01874">SL_OVERRIDE_VERIFY_VOLUME</a>, and <a class="el" href="../../d2/d7/hal_8h.html#a212">VOID()</a>.
<p>
<pre class="fragment"><div>00199                    :
00200 
00201     Given a master boot record <a class="code" href="../../d4/d4/iafptrap_8c.html#a9">type</a> (MBR - the zero'th sector on the disk),
00202     read <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> master boot record of a disk.  If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> MBR <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> found to be of that
00203     <a class="code" href="../../d3/d5/i386_2trapc_8c.html#a9">type</a>, allocate a structure whose layout <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> dependant upon that partition
00204     <a class="code" href="../../d3/d5/i386_2trapc_8c.html#a9">type</a>, fill with <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> appropriate values, and <span class="keywordflow">return</span> a pointer to that buffer
00205     in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> output parameter.
00206 
00207     The best example <span class="keywordflow">for</span> a use of <span class="keyword">this</span> routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> to support Ontrack
00208     systems DiskManager software.  Ontrack software lays down a special
00209     partition describing <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> entire drive.  The special partition <a class="code" href="../../d3/d5/i386_2trapc_8c.html#a9">type</a>
00210     (0x54) will be recognized and a couple of longwords of data will
00211     be passed back in a buffer <span class="keywordflow">for</span> a disk driver to act upon.
00212 
00213 Arguments:
00214 
00215     DeviceObject - The device object describing <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> entire drive.
00216 
00217     <a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a> - The <a class="code" href="../../d0/d4/mrcf_8c.html#a3">minimum</a> number of bytes that an IO operation can
00218                  fetch.
00219 
00220     MBRIndentifier - <a class="code" href="../../d2/d1/bench_8h.html#a5">A</a> value that will be searched <span class="keywordflow">for</span> in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00221                      in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> MBR.  This routine will understand
00222                      <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> semantics implied by <span class="keyword">this</span> value.
00223 
00224     <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> - Pointer to a buffer that returns data according to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00225              <a class="code" href="../../d3/d5/i386_2trapc_8c.html#a9">type</a> of MBR searched <span class="keywordflow">for</span>.  If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> MBR <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00226              <a class="code" href="../../d3/d5/i386_2trapc_8c.html#a9">type</a> asked <span class="keywordflow">for</span>, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> buffer will not be allocated and <span class="keyword">this</span>
00227              pointer will be <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>.  It <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> responsibility of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00228              caller of <a class="code" href="../../d2/d7/hal_8h.html#a23">HalExamineMBR</a> to deallocate <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> buffer.  The
00229              caller should deallocate <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> memory ASAP.
00230 
00231 Return Value:
00232 
00233     None.
00234 
00235 --*/
00236 
00237 {
00238 
00239 
00240     LARGE_INTEGER partitionTableOffset;
00241     PUCHAR readBuffer = (PUCHAR) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00242     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> event;
00243     IO_STATUS_BLOCK ioStatus;
00244     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
00245     <a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html">PPARTITION_DESCRIPTOR</a> partitionTableEntry;
00246     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status = STATUS_SUCCESS;
00247     ULONG readSize;
00248 
00249     *<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00250     <span class="comment">//</span>
00251     <span class="comment">// Determine the size of a read operation to ensure that at least 512</span>
00252     <span class="comment">// bytes are read.  This will guarantee that enough data is read to</span>
00253     <span class="comment">// include an entire partition table.  Note that this code assumes that</span>
00254     <span class="comment">// the actual sector size of the disk (if less than 512 bytes) is a</span>
00255     <span class="comment">// multiple of 2, a fairly reasonable assumption.</span>
00256     <span class="comment">//</span>
00257 
00258     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a> &gt;= 512) {
00259         readSize = <a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a>;
00260     } <span class="keywordflow">else</span> {
00261         readSize = 512;
00262     }
00263 
00264     <span class="comment">//</span>
00265     <span class="comment">// Start at sector 0 of the device.</span>
00266     <span class="comment">//</span>
00267 
00268     partitionTableOffset = RtlConvertUlongToLargeInteger( 0 );
00269 
00270     <span class="comment">//</span>
00271     <span class="comment">// Allocate a buffer that will hold the reads.</span>
00272     <span class="comment">//</span>
00273 
00274     readBuffer = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(
00275                      NonPagedPoolCacheAligned,
00276                      PAGE_SIZE&gt;readSize?PAGE_SIZE:readSize,
00277                      'btsF'
00278                      );
00279 
00280     <span class="keywordflow">if</span> (readBuffer == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00281         <span class="keywordflow">return</span>;
00282     }
00283 
00284     <span class="comment">//</span>
00285     <span class="comment">// Read record containing partition table.</span>
00286     <span class="comment">//</span>
00287     <span class="comment">// Create a notification event object to be used while waiting for</span>
00288     <span class="comment">// the read request to complete.</span>
00289     <span class="comment">//</span>
00290 
00291     <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;event, NotificationEvent, FALSE );
00292 
00293     irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a27">IoBuildSynchronousFsdRequest</a>( IRP_MJ_READ,
00294                                         DeviceObject,
00295                                         readBuffer,
00296                                         readSize,
00297                                         &amp;partitionTableOffset,
00298                                         &amp;event,
00299                                         &amp;ioStatus );
00300 
00301     <span class="keywordflow">if</span> (!irp) {
00302         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(readBuffer);
00303         <span class="keywordflow">return</span>;
00304     } <span class="keywordflow">else</span> {
00305         <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpStack;
00306         irpStack = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>(irp);
00307         irpStack-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o2">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a203">SL_OVERRIDE_VERIFY_VOLUME</a>;
00308     }
00309 
00310     status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( DeviceObject, irp );
00311 
00312     <span class="keywordflow">if</span> (status == STATUS_PENDING) {
00313         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
00314                                       Executive,
00315                                       KernelMode,
00316                                       FALSE,
00317                                       (PLARGE_INTEGER) NULL);
00318         status = ioStatus.Status;
00319     }
00320 
00321     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
00322         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(readBuffer);
00323         <span class="keywordflow">return</span>;
00324     }
00325 
00326     <span class="comment">//</span>
00327     <span class="comment">// Check for Boot Record signature.</span>
00328     <span class="comment">//</span>
00329 
00330     <span class="keywordflow">if</span> (((<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>) readBuffer)[<a class="code" href="../../d2/d7/hal_8h.html#a11">BOOT_SIGNATURE_OFFSET</a>] != <a class="code" href="../../d2/d7/hal_8h.html#a12">BOOT_RECORD_SIGNATURE</a>) {
00331         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(readBuffer);
00332         <span class="keywordflow">return</span>;
00333     }
00334 
00335     <span class="comment">//</span>
00336     <span class="comment">// Check for DM type partition.</span>
00337     <span class="comment">//</span>
00338 
00339     partitionTableEntry = (<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html">PPARTITION_DESCRIPTOR</a>) &amp;(((<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>) readBuffer)[<a class="code" href="../../d2/d7/hal_8h.html#a10">PARTITION_TABLE_OFFSET</a>]);
00340 
00341     <span class="keywordflow">if</span> (partitionTableEntry-&gt;<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html#o4">PartitionType</a> != MBRTypeIdentifier) {
00342 
00343         <span class="comment">//</span>
00344         <span class="comment">// The partition type isn't what the caller cares about.</span>
00345         <span class="comment">//</span>
00346         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(readBuffer);
00347 
00348     } <span class="keywordflow">else</span> {
00349 
00350         <span class="keywordflow">if</span> (partitionTableEntry-&gt;<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html#o4">PartitionType</a> == 0x54) {
00351 
00352             <span class="comment">//</span>
00353             <span class="comment">// Rather than allocate a new piece of memory to return</span>
00354             <span class="comment">// the data - just use the memory allocated for the buffer.</span>
00355             <span class="comment">// We can assume the caller will delete this shortly.</span>
00356             <span class="comment">//</span>
00357 
00358             ((PULONG)readBuffer)[0] = 63;
00359             *<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = readBuffer;
00360 
00361         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (partitionTableEntry-&gt;<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html#o4">PartitionType</a> == 0x55) {
00362 
00363             <span class="comment">//</span>
00364             <span class="comment">// EzDrive Parititon.  Simply return the pointer to non-null</span>
00365             <span class="comment">// There is no skewing here.</span>
00366             <span class="comment">//</span>
00367 
00368             *<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = readBuffer;
00369 
00370         } <span class="keywordflow">else</span> {
00371 
00372             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(partitionTableEntry-&gt;<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html#o4">PartitionType</a> == 0x55);
00373 
00374         }
00375 
00376     }
00377 
00378 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="drivesup.c::xHalGetPartialGeometry" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID FASTCALL xHalGetPartialGeometry           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>DeviceObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>ConventionalCylinders</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PLONGLONG&nbsp;</td>
          <td class="mdname" nowrap> <em>DiskSize</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00382">382</a> of file <a class="el" href="../../d8/d1/drivesup_8c-source.html">drivesup.c</a>.
<p>
References <a class="el" href="../../d6/d7/ex_8h-source.html#l00253">ExAllocatePoolWithTag</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00623">Executive</a>, <a class="el" href="../../d7/d2/cmwraper_8c-source.html#l00304">ExFreePool()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l01552">IoBuildDeviceIoControlRequest()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02865">IoCallDriver</a>, <a class="el" href="../../d5/d8/ke_8h-source.html#l01066">KeInitializeEvent</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00624">KernelMode</a>, <a class="el" href="../../d2/d6/wait_8c-source.html#l00810">KeWaitForSingleObject()</a>, <a class="el" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, and <a class="el" href="../../d2/d7/hal_8h.html#a212">VOID()</a>.
<p>
Referenced by <a class="el" href="../../d8/d1/drivesup_8c-source.html#l03486">xHalIoClearPartitionTable()</a>, and <a class="el" href="../../d8/d1/drivesup_8c-source.html#l02879">xHalIoWritePartitionTable()</a>.
<p>
<pre class="fragment"><div>00390                    :
00391 
00392     We need <span class="keyword">this</span> routine to get <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> number of cylinders that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> disk driver
00393     thinks <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> on <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> drive.  We will need <span class="keyword">this</span> to calculate <a class="code" href="../../d4/d8/struct__tagCHS.html">CHS</a> values
00394     when we fill in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partition table entries.
00395 
00396 Arguments:
00397 
00398     DeviceObject - The device object describing <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> entire drive.
00399 
00400     ConventionalCylinders - Number of cylinders on <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> drive.
00401 
00402 Return Value:
00403 
00404     None.
00405 
00406 --*/
00407 
00408 {
00409     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> localIrp;
00410     PDISK_GEOMETRY diskGeometry;
00411     PIO_STATUS_BLOCK iosb;
00412     <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> eventPtr;
00413     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
00414 
00415     *ConventionalCylinders = 0UL;
00416     *DiskSize = 0UL;
00417 
00418     diskGeometry = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(
00419                       NonPagedPool,
00420                       <span class="keyword">sizeof</span>(DISK_GEOMETRY),
00421                       'btsF'
00422                       );
00423 
00424     <span class="keywordflow">if</span> (!diskGeometry) {
00425 
00426         <span class="keywordflow">return</span>;
00427 
00428     }
00429 
00430     iosb = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(
00431                NonPagedPool,
00432                <span class="keyword">sizeof</span>(IO_STATUS_BLOCK),
00433                'btsF'
00434                );
00435 
00436     <span class="keywordflow">if</span> (!iosb) {
00437 
00438         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(diskGeometry);
00439         <span class="keywordflow">return</span>;
00440 
00441     }
00442 
00443     eventPtr = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(
00444                    NonPagedPool,
00445                    <span class="keyword">sizeof</span>(<a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a>),
00446                    'btsF'
00447                    );
00448 
00449     <span class="keywordflow">if</span> (!eventPtr) {
00450 
00451         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(iosb);
00452         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(diskGeometry);
00453         <span class="keywordflow">return</span>;
00454 
00455     }
00456 
00457     <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>(
00458         eventPtr,
00459         NotificationEvent,
00460         FALSE
00461         );
00462 
00463     localIrp = <a class="code" href="../../d4/d6/iosubs_8c.html#a25">IoBuildDeviceIoControlRequest</a>(
00464                    IOCTL_DISK_GET_DRIVE_GEOMETRY,
00465                    DeviceObject,
00466                    NULL,
00467                    0UL,
00468                    diskGeometry,
00469                    <span class="keyword">sizeof</span>(DISK_GEOMETRY),
00470                    FALSE,
00471                    eventPtr,
00472                    iosb
00473                    );
00474 
00475     <span class="keywordflow">if</span> (!localIrp) {
00476 
00477         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(eventPtr);
00478         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(iosb);
00479         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(diskGeometry);
00480         <span class="keywordflow">return</span>;
00481 
00482     }
00483 
00484 
00485     <span class="comment">//</span>
00486     <span class="comment">// Call the lower level driver, wait for the opertion</span>
00487     <span class="comment">// to finish.</span>
00488     <span class="comment">//</span>
00489 
00490     status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>(
00491                  DeviceObject,
00492                  localIrp
00493                  );
00494 
00495     <span class="keywordflow">if</span> (status == STATUS_PENDING) {
00496         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>(
00497                    eventPtr,
00498                    Executive,
00499                    KernelMode,
00500                    FALSE,
00501                    (PLARGE_INTEGER) NULL
00502                    );
00503         status = iosb-&gt;Status;
00504     }
00505 
00506     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
00507 
00508     <span class="comment">//</span>
00509     <span class="comment">// The operation completed successfully.  Get the cylinder</span>
00510     <span class="comment">// count of the drive.</span>
00511     <span class="comment">//</span>
00512 
00513         *ConventionalCylinders = diskGeometry-&gt;Cylinders.LowPart;
00514 
00515         <span class="comment">//</span>
00516         <span class="comment">// If the count is less than 1024 we can pass that back.  Otherwise</span>
00517         <span class="comment">// send back the 1024</span>
00518         <span class="comment">//</span>
00519 
00520         <span class="keywordflow">if</span> (diskGeometry-&gt;Cylinders.QuadPart &gt;= (LONGLONG)1024) {
00521 
00522             *ConventionalCylinders = 1024;
00523 
00524         }
00525 
00526         <span class="comment">//</span>
00527         <span class="comment">// Calculate disk size from gemotry information</span>
00528         <span class="comment">//</span>
00529 
00530         *DiskSize = diskGeometry-&gt;Cylinders.QuadPart *
00531                     diskGeometry-&gt;TracksPerCylinder *
00532                     diskGeometry-&gt;SectorsPerTrack *
00533                     diskGeometry-&gt;BytesPerSector;
00534 
00535     }
00536 
00537     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(eventPtr);
00538     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(iosb);
00539     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(diskGeometry);
00540     <span class="keywordflow">return</span>;
00541 
00542 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a30" doxytag="drivesup.c::xHalIoAssignDriveLetters" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID FASTCALL xHalIoAssignDriveLetters           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN struct <a class="el" href="../../d1/d2/struct__LOADER__PARAMETER__BLOCK.html">_LOADER_PARAMETER_BLOCK</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>LoaderBlock</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PSTRING&nbsp;</td>
          <td class="mdname" nowrap> <em>NtDeviceName</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PUCHAR&nbsp;</td>
          <td class="mdname" nowrap> <em>NtSystemPath</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PSTRING&nbsp;</td>
          <td class="mdname" nowrap> <em>NtSystemPathString</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d1/drivesup_8c-source.html#l01243">1243</a> of file <a class="el" href="../../d8/d1/drivesup_8c-source.html">drivesup.c</a>.
<p>
References <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00699">BOOTABLE_PARTITION</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02551">_CONFIGURATION_INFORMATION::CdRomCount</a>, <a class="el" href="../../d7/d5/memprint_8h-source.html#l00079">DbgPrint</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02549">_CONFIGURATION_INFORMATION::DiskCount</a>, <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00091">DiskPartitionName</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l00253">ExAllocatePoolWithTag</a>, <a class="el" href="../../d7/d2/cmwraper_8c-source.html#l00304">ExFreePool()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02550">_CONFIGURATION_INFORMATION::FloppyCount</a>, <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00702">FT_PARTITION</a>, <a class="el" href="../../d8/d1/drivesup_8c-source.html#l01022">HalpEnableAutomaticDriveLetterAssignment()</a>, <a class="el" href="../../d8/d1/drivesup_8c-source.html#l01171">HalpIsOldStyleFloppy()</a>, <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00934">HalpNextDriveLetter()</a>, <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00792">HalpQueryDriveLayout()</a>, <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00706">HalpQueryPartitionType()</a>, <a class="el" href="../../d8/d1/drivesup_8c-source.html#l01078">HalpSetMountLetter()</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l05675">IoCreateSymbolicLink()</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l06927">IoGetConfigurationInformation()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l04577">IoRemoteBootClient</a>, <a class="el" href="../../d0/d1/bugcheck_8c-source.html#l00070">KeBugCheck()</a>, <a class="el" href="../../d3/d9/aw_8h-source.html#l00031">L</a>, <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00701">LOGICAL_PARTITION</a>, <a class="el" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d0/d5/io_8h.html#a378">PCONFIGURATION_INFORMATION</a>, <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00700">PRIMARY_PARTITION</a>, <a class="el" href="../../d7/d5/nls_8c-source.html#l00082">RtlAnsiStringToUnicodeString()</a>, <a class="el" href="../../d7/d5/nls_8c-source.html#l01215">RtlFreeUnicodeString()</a>, <a class="el" href="../../d3/d6/string_8c-source.html#l00102">RtlInitAnsiString()</a>, <a class="el" href="../../d3/d6/string_8c-source.html#l00056">RtlInitString()</a>, <a class="el" href="../../d3/d6/string_8c-source.html#l00148">RtlInitUnicodeString()</a>, <a class="el" href="../../d7/d5/nls_8c-source.html#l01690">RtlPrefixUnicodeString()</a>, <a class="el" href="../../d4/d7/setupblk_8h-source.html#l00526">SETUPBLK_FLAGS_REMOTE_INSTALL</a>, <a class="el" href="../../d4/d7/setupblk_8h-source.html#l00527">SETUPBLK_FLAGS_SYSPREP_INSTALL</a>, <a class="el" href="../../d6/d9/heappage_8c.html#a68">sprintf()</a>, <a class="el" href="../../d2/d7/regtest_8c.html#a2">strlen()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, and <a class="el" href="../../d7/d8/restrfil_8c-source.html#l00582">ZwOpenFile()</a>.
<p>
<pre class="fragment"><div>01252                    :
01253 
01254     This routine assigns DOS drive letters to eligible disk partitions
01255     and CDROM drives. It also maps <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partition containing <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> NT
01256     boot <a class="code" href="../../d3/d3/dumpuser_8c.html#a14">path</a> to \SystemRoot. In NT, objects are built <span class="keywordflow">for</span> all partition
01257     types except 0 (unused) and 5 (extended). But drive letters are assigned
01258     <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> to recognized partition types (1, 4, 6, 7, e).
01259 
01260     Drive letter assignment <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> done in several stages:
01261 
01262         1) For each CdRom:
01263             Determine <span class="keywordflow">if</span> sticky letters are assigned and reserve <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> letter.
01264 
01265         2) For each disk:
01266             Determine how many primary partitions and which <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> bootable.
01267             Determine which partitions already have 'sticky letters'
01268                 and create their symbolic links.
01269             <a class="code" href="../../d4/d5/conimep_8h.html#a111">Create</a> a bit map <span class="keywordflow">for</span> each disk that idicates which partitions
01270                 require <span class="keywordflow">default</span> drive letter assignments.
01271 
01272         3) For each disk:
01273             Assign <span class="keywordflow">default</span> drive letters <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> bootable
01274                 primary partition or <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> first nonbootable primary partition.
01275 
01276         4) For each disk:
01277             Assign <span class="keywordflow">default</span> drive letters <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partitions in
01278                 extended volumes.
01279 
01280         5) For each disk:
01281             Assign <span class="keywordflow">default</span> drive letters <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> remaining (ENHANCED)
01282                 primary partitions.
01283 
01284         6) Assign A: and B: to the first two floppies in the system if they
01285             exist. Then assign remaining floppies next available drive letters.
01286 
01287         7) Assign drive letters to CdRoms (either sticky or default).
01288 
01289 Arguments:
01290 
01291     LoaderBlock - pointer to a loader parameter block.
01292 
01293     NtDeviceName - pointer to the boot device name string used
01294             to resolve NtSystemPath.
01295 
01296 Return Value:
01297 
01298     None.
01299 
01300 --*/
01301 
01302 {
01303     PUCHAR ntName;
01304     STRING ansiString;
01305     UNICODE_STRING unicodeString;
01306     PUCHAR ntPhysicalName;
01307     STRING ansiPhysicalString;
01308     UNICODE_STRING unicodePhysicalString;
01309     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
01310     OBJECT_ATTRIBUTES objectAttributes;
01311     <a class="code" href="../../d6/d8/struct__CONFIGURATION__INFORMATION.html">PCONFIGURATION_INFORMATION</a> configurationInformation;
01312     ULONG diskCount;
01313     ULONG floppyCount;
01314     HANDLE deviceHandle;
01315     IO_STATUS_BLOCK ioStatusBlock;
01316     ULONG diskNumber;
01317     ULONG i, j;
01318     UCHAR driveLetter;
01319     WCHAR deviceNameBuffer[50];
01320     UNICODE_STRING deviceName, floppyPrefix, cdromPrefix;
01321     PDRIVE_LAYOUT_INFORMATION layout;
01322     BOOLEAN bootable;
01323     ULONG partitionType;
01324     ULONG skip;
01325     ULONG diskCountIncrement;
01326     ULONG actualDiskCount = 0;
01327 
01328     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01329 
01330     <span class="comment">//</span>
01331     <span class="comment">// Get the count of devices from the registry.</span>
01332     <span class="comment">//</span>
01333 
01334     configurationInformation = <a class="code" href="../../d4/d6/iosubs_8c.html#a69">IoGetConfigurationInformation</a>();
01335 
01336     diskCount = configurationInformation-&gt;<a class="code" href="../../d6/d8/struct__CONFIGURATION__INFORMATION.html#o0">DiskCount</a>;
01337     floppyCount = configurationInformation-&gt;<a class="code" href="../../d6/d8/struct__CONFIGURATION__INFORMATION.html#o1">FloppyCount</a>;
01338 
01339     <span class="comment">//</span>
01340     <span class="comment">// Allocate general NT name buffer.</span>
01341     <span class="comment">//</span>
01342 
01343     ntName = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( NonPagedPool, 128, 'btsF');
01344 
01345     ntPhysicalName = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( NonPagedPool, 64, 'btsF');
01346 
01347     <span class="keywordflow">if</span> (ntName == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> || ntPhysicalName == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01348 
01349         <a class="code" href="../../d9/d1/bugcheck_8c.html#a13">KeBugCheck</a>( ASSIGN_DRIVE_LETTERS_FAILED );
01350 
01351     }
01352 
01353     <span class="comment">//</span>
01354     <span class="comment">// If we're doing a remote boot, set NtSystemPath appropriately.</span>
01355     <span class="comment">//</span>
01356 
01357     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d5/io_8h.html#a399">IoRemoteBootClient</a>) {
01358 
01359         PUCHAR p;
01360         PUCHAR q;
01361 
01362         <span class="comment">//</span>
01363         <span class="comment">// If this is a remote boot setup boot, NtBootPathName is of the</span>
01364         <span class="comment">// form &lt;server&gt;&lt;share&gt;\setup&lt;install-directory&gt;&lt;platform&gt;.</span>
01365         <span class="comment">// We want the root of the X: drive to be the root of the install</span>
01366         <span class="comment">// directory.</span>
01367         <span class="comment">//</span>
01368         <span class="comment">// If this is a normal remote boot, NtBootPathName is of the form</span>
01369         <span class="comment">// &lt;server&gt;&lt;share&gt;\images&lt;machine&gt;\winnt. We want the root of</span>
01370         <span class="comment">// the X: drive to be the root of the machine directory.</span>
01371         <span class="comment">//</span>
01372         <span class="comment">// Thus in either case, we need to remove all but the last element</span>
01373         <span class="comment">// of the path.</span>
01374         <span class="comment">//</span>
01375         <span class="comment">// Find the beginning of the last element of the path (including</span>
01376         <span class="comment">// the leading backslash).</span>
01377         <span class="comment">//</span>
01378 
01379         p = strrchr( LoaderBlock-&gt;NtBootPathName, <span class="charliteral">'\\'</span> );   <span class="comment">// find last separator</span>
01380         q = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01381         <span class="keywordflow">if</span> ( (p != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp; (*(p+1) == 0) ) {
01382 
01383             <span class="comment">//</span>
01384             <span class="comment">// NtBootPathName ends with a backslash, so we need to back up</span>
01385             <span class="comment">// to the previous backslash.</span>
01386             <span class="comment">//</span>
01387 
01388             q = p;
01389             *q = 0;
01390             p = strrchr( LoaderBlock-&gt;NtBootPathName, <span class="charliteral">'\\'</span> );   <span class="comment">// find last separator</span>
01391             *q = <span class="charliteral">'\\'</span>;
01392         }
01393         <span class="keywordflow">if</span> ( p == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
01394             <a class="code" href="../../d9/d1/bugcheck_8c.html#a13">KeBugCheck</a>( ASSIGN_DRIVE_LETTERS_FAILED );
01395         }
01396 
01397         <span class="comment">//</span>
01398         <span class="comment">// Set NtSystemPath to X:&lt;last element of path&gt;. Note that the symbolic</span>
01399         <span class="comment">// link for X: is created in io\ioinit.c\IopInitializeBootDrivers.</span>
01400         <span class="comment">//</span>
01401         <span class="comment">// Note that we use X: for the textmode setup phase of a remote</span>
01402         <span class="comment">// installation. But for a true remote boot, we use C:.</span>
01403         <span class="comment">//</span>
01404 
01405 <span class="preprocessor">#if defined(REMOTE_BOOT)</span>
01406 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ((LoaderBlock-&gt;SetupLoaderBlock-&gt;Flags &amp; (<a class="code" href="../../d3/d8/setupblk_8h.html#a28">SETUPBLK_FLAGS_REMOTE_INSTALL</a> |
01407                                                      <a class="code" href="../../d3/d8/setupblk_8h.html#a29">SETUPBLK_FLAGS_SYSPREP_INSTALL</a>)) == 0) {
01408             NtSystemPath[0] = <span class="charliteral">'C'</span>;
01409         } <span class="keywordflow">else</span>
01410 <span class="preprocessor">#endif</span>
01411 <span class="preprocessor"></span>        {
01412             NtSystemPath[0] = <span class="charliteral">'X'</span>;
01413         }
01414         NtSystemPath[1] = <span class="charliteral">':'</span>;
01415         strcpy(&amp;NtSystemPath[2], p );
01416         <span class="keywordflow">if</span> ( q != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
01417             NtSystemPath[<a class="code" href="../../d2/d7/regtest_8c.html#a2">strlen</a>(NtSystemPath)-1] = <span class="charliteral">'\0'</span>; <span class="comment">// remove trailing backslash</span>
01418         }
01419         <a class="code" href="../../d2/d7/string_8c.html#a5">RtlInitString</a>(NtSystemPathString, NtSystemPath);
01420 
01421     }
01422 
01423     <span class="comment">//</span>
01424     <span class="comment">// For each disk ...</span>
01425     <span class="comment">//</span>
01426 
01427     diskCountIncrement = 0;
01428     <span class="keywordflow">for</span> (diskNumber = 0; diskNumber &lt; diskCount; diskNumber++) {
01429 
01430         <span class="comment">//</span>
01431         <span class="comment">// Create ANSI name string for physical disk.</span>
01432         <span class="comment">//</span>
01433 
01434         <a class="code" href="../../d6/d9/heappage_8c.html#a68">sprintf</a>( ntName, DiskPartitionName, diskNumber, 0 );
01435 
01436         <span class="comment">//</span>
01437         <span class="comment">// Convert to unicode string.</span>
01438         <span class="comment">//</span>
01439 
01440         <a class="code" href="../../d2/d7/string_8c.html#a6">RtlInitAnsiString</a>( &amp;ansiString, ntName );
01441 
01442         <a class="code" href="../../d6/d6/nls_8c.html#a21">RtlAnsiStringToUnicodeString</a>( &amp;unicodeString, &amp;ansiString, TRUE );
01443 
01444         InitializeObjectAttributes( &amp;objectAttributes,
01445                                     &amp;unicodeString,
01446                                     OBJ_CASE_INSENSITIVE,
01447                                     NULL,
01448                                     NULL );
01449 
01450         <span class="comment">//</span>
01451         <span class="comment">// Open device by name.</span>
01452         <span class="comment">//</span>
01453 
01454         status = <a class="code" href="../../d6/d9/restrfil_8c.html#a33">ZwOpenFile</a>( &amp;deviceHandle,
01455                              FILE_READ_DATA | SYNCHRONIZE,
01456                              &amp;objectAttributes,
01457                              &amp;ioStatusBlock,
01458                              FILE_SHARE_READ,
01459                              FILE_SYNCHRONOUS_IO_NONALERT );
01460 
01461         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
01462 
01463             <span class="comment">//</span>
01464             <span class="comment">// The device was successfully opened.  Generate a DOS device name</span>
01465             <span class="comment">// for the drive itself.</span>
01466             <span class="comment">//</span>
01467 
01468             <a class="code" href="../../d6/d9/heappage_8c.html#a68">sprintf</a>( ntPhysicalName, <span class="stringliteral">"\\DosDevices\\PhysicalDrive%d"</span>, diskNumber );
01469 
01470             <a class="code" href="../../d2/d7/string_8c.html#a6">RtlInitAnsiString</a>( &amp;ansiPhysicalString, ntPhysicalName );
01471 
01472             <a class="code" href="../../d6/d6/nls_8c.html#a21">RtlAnsiStringToUnicodeString</a>( &amp;unicodePhysicalString, &amp;ansiPhysicalString, TRUE );
01473 
01474             <a class="code" href="../../d4/d6/iosubs_8c.html#a50">IoCreateSymbolicLink</a>( &amp;unicodePhysicalString, &amp;unicodeString );
01475 
01476             <a class="code" href="../../d6/d6/nls_8c.html#a34">RtlFreeUnicodeString</a>( &amp;unicodePhysicalString );
01477 
01478             ZwClose(deviceHandle);
01479 
01480             actualDiskCount = diskNumber + 1;
01481         }
01482 
01483         <a class="code" href="../../d6/d6/nls_8c.html#a34">RtlFreeUnicodeString</a>( &amp;unicodeString );
01484 
01485         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
01486 
01487 <span class="preprocessor">#if DBG</span>
01488 <span class="preprocessor"></span>            <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( <span class="stringliteral">"IoAssignDriveLetters: Failed to open %s\n"</span>, ntName );
01489 <span class="preprocessor">#endif // DBG</span>
01490 <span class="preprocessor"></span>
01491             <span class="comment">//</span>
01492             <span class="comment">// This may be a sparse name space.  Try going farther but</span>
01493             <span class="comment">// not forever.</span>
01494             <span class="comment">//</span>
01495 
01496             <span class="keywordflow">if</span> (diskCountIncrement &lt; 50) {
01497                 diskCountIncrement++;
01498                 diskCount++;
01499             }
01500         }
01501 
01502     } <span class="comment">// end for diskNumber ...</span>
01503 
01504     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( ntName );
01505     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( ntPhysicalName );
01506 
01507     diskCount -= diskCountIncrement;
01508     <span class="keywordflow">if</span> (actualDiskCount &gt; diskCount) {
01509         diskCount = actualDiskCount;
01510     }
01511 
01512     <span class="keywordflow">for</span> (i = 0; i &lt; diskCount; i++) {
01513 
01514         swprintf(deviceNameBuffer, L<span class="stringliteral">"\\Device\\Harddisk%d\\Partition0"</span>, i);
01515         <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;deviceName, deviceNameBuffer);
01516 
01517         status = <a class="code" href="../../d7/d2/drivesup_8c.html#a20">HalpQueryDriveLayout</a>(&amp;deviceName, &amp;layout);
01518         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
01519             layout = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01520         }
01521 
01522         bootable = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01523         <span class="keywordflow">for</span> (j = 1; ; j++) {
01524 
01525             swprintf(deviceNameBuffer, L<span class="stringliteral">"\\Device\\Harddisk%d\\Partition%d"</span>,
01526                      i, j);
01527             <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;deviceName, deviceNameBuffer);
01528 
01529             status = <a class="code" href="../../d7/d2/drivesup_8c.html#a19">HalpQueryPartitionType</a>(&amp;deviceName, layout,
01530                                             &amp;partitionType);
01531             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
01532                 <span class="keywordflow">break</span>;
01533             }
01534 
01535             <span class="keywordflow">if</span> (partitionType != <a class="code" href="../../d7/d2/drivesup_8c.html#a3">BOOTABLE_PARTITION</a>) {
01536                 <span class="keywordflow">continue</span>;
01537             }
01538 
01539             bootable = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01540 
01541             <a class="code" href="../../d7/d2/drivesup_8c.html#a25">HalpNextDriveLetter</a>(&amp;deviceName, NtDeviceName, NtSystemPath, FALSE);
01542             <span class="keywordflow">break</span>;
01543         }
01544 
01545         <span class="keywordflow">if</span> (bootable) {
01546             <span class="keywordflow">if</span> (layout) {
01547                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(layout);
01548             }
01549             <span class="keywordflow">continue</span>;
01550         }
01551 
01552         <span class="keywordflow">for</span> (j = 1; ; j++) {
01553 
01554             swprintf(deviceNameBuffer, L<span class="stringliteral">"\\Device\\Harddisk%d\\Partition%d"</span>,
01555                      i, j);
01556             <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;deviceName, deviceNameBuffer);
01557 
01558             status = <a class="code" href="../../d7/d2/drivesup_8c.html#a19">HalpQueryPartitionType</a>(&amp;deviceName, layout,
01559                                             &amp;partitionType);
01560             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
01561                 <span class="keywordflow">break</span>;
01562             }
01563 
01564             <span class="keywordflow">if</span> (partitionType != <a class="code" href="../../d7/d2/drivesup_8c.html#a4">PRIMARY_PARTITION</a>) {
01565                 <span class="keywordflow">continue</span>;
01566             }
01567 
01568             <a class="code" href="../../d7/d2/drivesup_8c.html#a25">HalpNextDriveLetter</a>(&amp;deviceName, NtDeviceName, NtSystemPath, FALSE);
01569             <span class="keywordflow">break</span>;
01570         }
01571 
01572         <span class="keywordflow">if</span> (layout) {
01573             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(layout);
01574         }
01575     }
01576 
01577     <span class="keywordflow">for</span> (i = 0; i &lt; diskCount; i++) {
01578 
01579         swprintf(deviceNameBuffer, L<span class="stringliteral">"\\Device\\Harddisk%d\\Partition0"</span>, i);
01580         <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;deviceName, deviceNameBuffer);
01581 
01582         status = <a class="code" href="../../d7/d2/drivesup_8c.html#a20">HalpQueryDriveLayout</a>(&amp;deviceName, &amp;layout);
01583         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
01584             layout = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01585         }
01586 
01587         <span class="keywordflow">for</span> (j = 1; ; j++) {
01588 
01589             swprintf(deviceNameBuffer, L<span class="stringliteral">"\\Device\\Harddisk%d\\Partition%d"</span>,
01590                      i, j);
01591             <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;deviceName, deviceNameBuffer);
01592 
01593             status = <a class="code" href="../../d7/d2/drivesup_8c.html#a19">HalpQueryPartitionType</a>(&amp;deviceName, layout,
01594                                             &amp;partitionType);
01595             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
01596                 <span class="keywordflow">break</span>;
01597             }
01598 
01599             <span class="keywordflow">if</span> (partitionType != <a class="code" href="../../d7/d2/drivesup_8c.html#a5">LOGICAL_PARTITION</a>) {
01600                 <span class="keywordflow">continue</span>;
01601             }
01602 
01603             <a class="code" href="../../d7/d2/drivesup_8c.html#a25">HalpNextDriveLetter</a>(&amp;deviceName, NtDeviceName, NtSystemPath, FALSE);
01604         }
01605 
01606         <span class="keywordflow">if</span> (layout) {
01607             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(layout);
01608         }
01609     }
01610 
01611     <span class="keywordflow">for</span> (i = 0; i &lt; diskCount; i++) {
01612 
01613         swprintf(deviceNameBuffer, L<span class="stringliteral">"\\Device\\Harddisk%d\\Partition0"</span>, i);
01614         <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;deviceName, deviceNameBuffer);
01615 
01616         status = <a class="code" href="../../d7/d2/drivesup_8c.html#a20">HalpQueryDriveLayout</a>(&amp;deviceName, &amp;layout);
01617         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
01618             layout = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01619         }
01620 
01621         skip = 0;
01622         <span class="keywordflow">for</span> (j = 1; ; j++) {
01623 
01624             swprintf(deviceNameBuffer, L<span class="stringliteral">"\\Device\\Harddisk%d\\Partition%d"</span>,
01625                      i, j);
01626             <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;deviceName, deviceNameBuffer);
01627 
01628             status = <a class="code" href="../../d7/d2/drivesup_8c.html#a19">HalpQueryPartitionType</a>(&amp;deviceName, layout,
01629                                             &amp;partitionType);
01630             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
01631                 <span class="keywordflow">break</span>;
01632             }
01633 
01634             <span class="keywordflow">if</span> (partitionType == <a class="code" href="../../d7/d2/drivesup_8c.html#a3">BOOTABLE_PARTITION</a>) {
01635                 skip = j;
01636             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (partitionType == <a class="code" href="../../d7/d2/drivesup_8c.html#a4">PRIMARY_PARTITION</a>) {
01637                 <span class="keywordflow">if</span> (!skip) {
01638                     skip = j;
01639                 }
01640             }
01641         }
01642 
01643         <span class="keywordflow">for</span> (j = 1; ; j++) {
01644 
01645             <span class="keywordflow">if</span> (j == skip) {
01646                 <span class="keywordflow">continue</span>;
01647             }
01648 
01649             swprintf(deviceNameBuffer, L<span class="stringliteral">"\\Device\\Harddisk%d\\Partition%d"</span>,
01650                      i, j);
01651             <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;deviceName, deviceNameBuffer);
01652 
01653             status = <a class="code" href="../../d7/d2/drivesup_8c.html#a19">HalpQueryPartitionType</a>(&amp;deviceName, layout,
01654                                             &amp;partitionType);
01655             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
01656                 <span class="keywordflow">break</span>;
01657             }
01658 
01659             <span class="keywordflow">if</span> (partitionType != <a class="code" href="../../d7/d2/drivesup_8c.html#a4">PRIMARY_PARTITION</a> &amp;&amp;
01660                 partitionType != <a class="code" href="../../d7/d2/drivesup_8c.html#a6">FT_PARTITION</a>) {
01661 
01662                 <span class="keywordflow">continue</span>;
01663             }
01664 
01665             <a class="code" href="../../d7/d2/drivesup_8c.html#a25">HalpNextDriveLetter</a>(&amp;deviceName, NtDeviceName, NtSystemPath, FALSE);
01666         }
01667 
01668         <span class="keywordflow">if</span> (layout) {
01669             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(layout);
01670         }
01671     }
01672 
01673     <span class="keywordflow">for</span> (i = 0; i &lt; floppyCount; i++) {
01674 
01675         swprintf(deviceNameBuffer, L<span class="stringliteral">"\\Device\\Floppy%d"</span>, i);
01676         <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;deviceName, deviceNameBuffer);
01677 
01678         <span class="keywordflow">if</span> (!<a class="code" href="../../d7/d2/drivesup_8c.html#a28">HalpIsOldStyleFloppy</a>(&amp;deviceName)) {
01679             <span class="keywordflow">continue</span>;
01680         }
01681 
01682         <a class="code" href="../../d7/d2/drivesup_8c.html#a25">HalpNextDriveLetter</a>(&amp;deviceName, NtDeviceName, NtSystemPath, TRUE);
01683     }
01684 
01685     <span class="keywordflow">for</span> (i = 0; i &lt; floppyCount; i++) {
01686 
01687         swprintf(deviceNameBuffer, L<span class="stringliteral">"\\Device\\Floppy%d"</span>, i);
01688         <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;deviceName, deviceNameBuffer);
01689 
01690         <span class="keywordflow">if</span> (<a class="code" href="../../d7/d2/drivesup_8c.html#a28">HalpIsOldStyleFloppy</a>(&amp;deviceName)) {
01691             <span class="keywordflow">continue</span>;
01692         }
01693 
01694         <a class="code" href="../../d7/d2/drivesup_8c.html#a25">HalpNextDriveLetter</a>(&amp;deviceName, NtDeviceName, NtSystemPath, TRUE);
01695     }
01696 
01697     <span class="keywordflow">for</span> (i = 0; i &lt; configurationInformation-&gt;<a class="code" href="../../d6/d8/struct__CONFIGURATION__INFORMATION.html#o2">CdRomCount</a>; i++) {
01698 
01699         swprintf(deviceNameBuffer, L<span class="stringliteral">"\\Device\\CdRom%d"</span>, i);
01700         <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;deviceName, deviceNameBuffer);
01701 
01702         <a class="code" href="../../d7/d2/drivesup_8c.html#a25">HalpNextDriveLetter</a>(&amp;deviceName, NtDeviceName, NtSystemPath, TRUE);
01703     }
01704 
01705     <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d5/io_8h.html#a399">IoRemoteBootClient</a>) {
01706         <a class="code" href="../../d6/d6/nls_8c.html#a21">RtlAnsiStringToUnicodeString</a>(&amp;unicodeString, NtDeviceName, TRUE);
01707         driveLetter = <a class="code" href="../../d7/d2/drivesup_8c.html#a25">HalpNextDriveLetter</a>(&amp;unicodeString, NULL, NULL, TRUE);
01708         <span class="keywordflow">if</span> (driveLetter) {
01709             <span class="keywordflow">if</span> (driveLetter != 0xFF) {
01710                 NtSystemPath[0] = driveLetter;
01711             }
01712         } <span class="keywordflow">else</span> {
01713             <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;floppyPrefix, L<span class="stringliteral">"\\Device\\Floppy"</span>);
01714             <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;cdromPrefix, L<span class="stringliteral">"\\Device\\CdRom"</span>);
01715             <span class="keywordflow">if</span> (<a class="code" href="../../d6/d6/nls_8c.html#a43">RtlPrefixUnicodeString</a>(&amp;floppyPrefix, &amp;unicodeString, TRUE)) {
01716                 driveLetter = <span class="charliteral">'A'</span>;
01717             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d6/d6/nls_8c.html#a43">RtlPrefixUnicodeString</a>(&amp;cdromPrefix, &amp;unicodeString, TRUE)) {
01718                 driveLetter = <span class="charliteral">'D'</span>;
01719             } <span class="keywordflow">else</span> {
01720                 driveLetter = <span class="charliteral">'C'</span>;
01721             }
01722             <span class="keywordflow">for</span> (; driveLetter &lt;= <span class="charliteral">'Z'</span>; driveLetter++) {
01723                 status = <a class="code" href="../../d7/d2/drivesup_8c.html#a27">HalpSetMountLetter</a>(&amp;unicodeString, driveLetter);
01724                 <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
01725                     NtSystemPath[0] = driveLetter;
01726                 }
01727             }
01728         }
01729         <a class="code" href="../../d6/d6/nls_8c.html#a34">RtlFreeUnicodeString</a>(&amp;unicodeString);
01730     }
01731 
01732     <a class="code" href="../../d7/d2/drivesup_8c.html#a26">HalpEnableAutomaticDriveLetterAssignment</a>();
01733 
01734 } <span class="comment">// end IoAssignDriveLetters()</span>

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a34" doxytag="drivesup.c::xHalIoClearPartitionTable" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS FASTCALL xHalIoClearPartitionTable           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>DeviceObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>SectorSize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>SectorsPerTrack</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>NumberOfHeads</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d1/drivesup_8c-source.html#l03486">3486</a> of file <a class="el" href="../../d8/d1/drivesup_8c-source.html">drivesup.c</a>.
<p>
References <a class="el" href="../../d3/d6/hal_8h-source.html#l00157">BOOT_RECORD_SIGNATURE</a>, <a class="el" href="../../d3/d6/hal_8h-source.html#l00151">BOOT_SIGNATURE_OFFSET</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l00253">ExAllocatePoolWithTag</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00623">Executive</a>, <a class="el" href="../../d7/d2/cmwraper_8c-source.html#l00304">ExFreePool()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02030">_IO_STACK_LOCATION::Flags</a>, <a class="el" href="../../d3/d6/hal_8h-source.html#l01545">HalExamineMBR</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l01933">IoBuildSynchronousFsdRequest()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02865">IoCallDriver</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l03398">IoGetNextIrpStackLocation</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00058">IRP_MJ_READ</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00059">IRP_MJ_WRITE</a>, <a class="el" href="../../d5/d8/ke_8h-source.html#l01066">KeInitializeEvent</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00624">KernelMode</a>, <a class="el" href="../../d2/d6/wait_8c-source.html#l00810">KeWaitForSingleObject()</a>, <a class="el" href="../../d5/d8/ex_8h.html#a329a177">NonPagedPoolCacheAligned</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00599">PAGE_SIZE</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00085">PUSHORT</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00230">SectorSize</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01874">SL_OVERRIDE_VERIFY_VOLUME</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00064">USHORT</a>, <a class="el" href="../../d2/d7/hal_8h.html#a212">VOID()</a>, <a class="el" href="../../d7/d2/drivesup_8c.html#a9">WHICH_BIT</a>, and <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00382">xHalGetPartialGeometry()</a>.
<p>
<pre class="fragment"><div>03495                    :
03496 
03497     This routine walks <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> disk writing <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partition tables from
03498     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> entries in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partition list buffer <span class="keywordflow">for</span> each partition.
03499 
03500     Applications that create and <span class="keyword">delete</span> partitions should issue a
03501     <a class="code" href="../../d2/d7/hal_8h.html#a192">IoReadPartitionTable</a> call with <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> '<span class="keywordflow">return</span> recognized partitions'
03502     <span class="keywordtype">boolean</span> set to <span class="keyword">false</span> to get a full description of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> system.
03503 
03504     Then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> drive layout structure can be modified by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> application to
03505     reflect <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keyword">new</span> configuration of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> disk and then <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> written back
03506     to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> disk <span class="keyword">using</span> <span class="keyword">this</span> routine.
03507 
03508 Arguments:
03509 
03510     DeviceObject - Pointer to device object <span class="keywordflow">for</span> <span class="keyword">this</span> disk.
03511 
03512     <a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a> - Sector size on <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> device.
03513 
03514     SectorsPerTrack - Track size on <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> device.
03515 
03516     NumberOfHeads - Same as tracks per cylinder.
03517 
03518 Return Value:
03519 
03520     The functional value <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> STATUS_SUCCESS <span class="keywordflow">if</span> all writes are completed
03521     without error.
03522 
03523 --*/
03524 
03525 {
03526 <span class="keyword">typedef</span> <span class="keyword">struct </span>_PARTITION_TABLE {
03527     PARTITION_INFORMATION PartitionEntry[4];
03528 } PARTITION_TABLE, *PPARTITION_TABLE;
03529 
03530 <span class="keyword">typedef</span> <span class="keyword">struct </span>_DISK_LAYOUT {
03531     ULONG TableCount;
03532     ULONG Signature;
03533     PARTITION_TABLE PartitionTable[1];
03534 } DISK_LAYOUT, *PDISK_LAYOUT;
03535 
03536 <span class="keyword">typedef</span> <span class="keyword">struct </span>_PTE {
03537     UCHAR ActiveFlag;               <span class="comment">// Bootable or not</span>
03538     UCHAR StartingTrack;            <span class="comment">// Not used</span>
03539     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> StartingCylinder;        <span class="comment">// Not used</span>
03540     UCHAR PartitionType;            <span class="comment">// 12 bit FAT, 16 bit FAT etc.</span>
03541     UCHAR EndingTrack;              <span class="comment">// Not used</span>
03542     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> EndingCylinder;          <span class="comment">// Not used</span>
03543     ULONG StartingSector;           <span class="comment">// Hidden sectors</span>
03544     ULONG PartitionLength;          <span class="comment">// Sectors in this partition</span>
03545 } PTE;
03546 <span class="keyword">typedef</span> PTE UNALIGNED *PPTE;
03547 
03548 <span class="comment">//</span>
03549 <span class="comment">// This macro has the effect of Bit = log2(Data)</span>
03550 <span class="comment">//</span>
03551 
03552 <span class="preprocessor">#define WHICH_BIT(Data, Bit) {                      \</span>
03553 <span class="preprocessor">    for (Bit = 0; Bit &lt; 32; Bit++) {                \</span>
03554 <span class="preprocessor">        if ((Data &gt;&gt; Bit) == 1) {                   \</span>
03555 <span class="preprocessor">            break;                                  \</span>
03556 <span class="preprocessor">        }                                           \</span>
03557 <span class="preprocessor">    }                                               \</span>
03558 <span class="preprocessor">}</span>
03559 <span class="preprocessor"></span>
03560     ULONG writeSize;
03561     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a> writeBuffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03562     PPARTITION_TABLE partitionTable;
03563     CCHAR shiftCount;
03564     LARGE_INTEGER partitionTableOffset;
03565     LARGE_INTEGER nextRecordOffset;
03566     ULONG partitionTableCount;
03567     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> event;
03568     IO_STATUS_BLOCK ioStatus;
03569     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
03570     BOOLEAN rewritePartition = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03571     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status = STATUS_SUCCESS;
03572     LARGE_INTEGER tempInt;
03573     BOOLEAN foundEZHooker = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03574     ULONG conventionalCylinders;
03575     LONGLONG diskSize;
03576 
03577     BOOLEAN isSuperFloppy = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03578 
03579     <span class="comment">//</span>
03580     <span class="comment">// Ensure that no one is calling this function illegally.</span>
03581     <span class="comment">//</span>
03582 
03583     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
03584 
03585     <span class="comment">//</span>
03586     <span class="comment">// Determine the size of a write operation to ensure that at least 512</span>
03587     <span class="comment">// bytes are written.  This will guarantee that enough data is written to</span>
03588     <span class="comment">// include an entire partition table.  Note that this code assumes that</span>
03589     <span class="comment">// the actual sector size of the disk (if less than 512 bytes) is a</span>
03590     <span class="comment">// multiple of 2, a fairly reasonable assumption.</span>
03591     <span class="comment">//</span>
03592 
03593     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a> &gt;= 512) {
03594         writeSize = <a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a>;
03595     } <span class="keywordflow">else</span> {
03596         writeSize = 512;
03597     }
03598 
03599     <a class="code" href="../../d7/d2/drivesup_8c.html#a21">xHalGetPartialGeometry</a>( DeviceObject,
03600                             &amp;conventionalCylinders,
03601                             &amp;diskSize );
03602 
03603     <span class="comment">//</span>
03604     <span class="comment">// Look to see if this is an EZDrive Disk.  If it is then get the</span>
03605     <span class="comment">// real partititon table at 1.</span>
03606     <span class="comment">//</span>
03607 
03608     {
03609 
03610         PVOID buff;
03611 
03612         <a class="code" href="../../d2/d7/hal_8h.html#a23">HalExamineMBR</a>(
03613             DeviceObject,
03614             writeSize,
03615             (ULONG)0x55,
03616             &amp;buff
03617             );
03618 
03619         <span class="keywordflow">if</span> (buff) {
03620 
03621             foundEZHooker = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03622             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(buff);
03623             partitionTableOffset.QuadPart = 512;
03624 
03625         } <span class="keywordflow">else</span> {
03626 
03627             partitionTableOffset.QuadPart = 0;
03628 
03629         }
03630 
03631     }
03632 
03633     <span class="comment">//</span>
03634     <span class="comment">// Calculate shift count for converting between byte and sector.</span>
03635     <span class="comment">//</span>
03636 
03637     <a class="code" href="../../d7/d2/drivesup_8c.html#a9">WHICH_BIT</a>( SectorSize, shiftCount );
03638 
03639     <span class="comment">//</span>
03640     <span class="comment">// Allocate a buffer for the sector writes.</span>
03641     <span class="comment">//</span>
03642 
03643     writeBuffer = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( NonPagedPoolCacheAligned, PAGE_SIZE, 'btsF');
03644 
03645     <span class="keywordflow">if</span> (writeBuffer == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03646         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
03647     }
03648 
03649     <span class="comment">//</span>
03650     <span class="comment">// Read the boot record that's already there into the write buffer</span>
03651     <span class="comment">// and save its boot code area if the signature is valid.  This way</span>
03652     <span class="comment">// we don't clobber any boot code that might be there already.</span>
03653     <span class="comment">//</span>
03654 
03655     <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;event, SynchronizationEvent, FALSE );
03656 
03657     irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a27">IoBuildSynchronousFsdRequest</a>( IRP_MJ_READ,
03658                                         DeviceObject,
03659                                         writeBuffer,
03660                                         writeSize,
03661                                         &amp;partitionTableOffset,
03662                                         &amp;event,
03663                                         &amp;ioStatus );
03664 
03665     <span class="keywordflow">if</span> (!irp) {
03666         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(writeBuffer);
03667         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
03668     }
03669 
03670     status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( DeviceObject, irp );
03671 
03672     <span class="keywordflow">if</span> (status == STATUS_PENDING) {
03673         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
03674                                   Executive,
03675                                   KernelMode,
03676                                   FALSE,
03677                                   (PLARGE_INTEGER) NULL);
03678         status = ioStatus.Status;
03679     }
03680 
03681     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
03682         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(writeBuffer);
03683         <span class="keywordflow">return</span> status;
03684     }
03685 
03686     <span class="comment">//</span>
03687     <span class="comment">// If there's an 0xaa55 in the MBR signature, clear it out.  </span>
03688     <span class="comment">//</span>
03689 
03690     <span class="keywordflow">if</span>(writeBuffer[<a class="code" href="../../d2/d7/hal_8h.html#a11">BOOT_SIGNATURE_OFFSET</a>] == <a class="code" href="../../d2/d7/hal_8h.html#a12">BOOT_RECORD_SIGNATURE</a>) {
03691         writeBuffer[<a class="code" href="../../d2/d7/hal_8h.html#a11">BOOT_SIGNATURE_OFFSET</a>] += 0x1111;
03692     }
03693     
03694     irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a27">IoBuildSynchronousFsdRequest</a>( IRP_MJ_WRITE,
03695                                     DeviceObject,
03696                                     writeBuffer,
03697                                     writeSize,
03698                                     &amp;partitionTableOffset,
03699                                     &amp;event,
03700                                     &amp;ioStatus );
03701 
03702     <span class="keywordflow">if</span> (!irp) {
03703         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(writeBuffer);
03704         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
03705     } <span class="keywordflow">else</span> {
03706         <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpStack;
03707         irpStack = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>(irp);
03708         irpStack-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o2">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a203">SL_OVERRIDE_VERIFY_VOLUME</a>;
03709     }
03710 
03711     status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( DeviceObject, irp );
03712 
03713     <span class="keywordflow">if</span> (status == STATUS_PENDING) {
03714         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
03715                                   Executive,
03716                                   KernelMode,
03717                                   FALSE,
03718                                   (PLARGE_INTEGER) NULL);
03719         status = ioStatus.Status;
03720     }
03721 
03722     <span class="comment">//</span>
03723     <span class="comment">// Deallocate write buffer if it was allocated it.</span>
03724     <span class="comment">//</span>
03725 
03726     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( writeBuffer );
03727 
03728     <span class="keywordflow">return</span> status;
03729 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a31" doxytag="drivesup.c::xHalIoReadPartitionTable" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS FASTCALL xHalIoReadPartitionTable           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>DeviceObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>SectorSize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>ReturnRecognizedPartitions</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT struct _DRIVE_LAYOUT_INFORMATION **&nbsp;</td>
          <td class="mdname" nowrap> <em>PartitionBuffer</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d1/drivesup_8c-source.html#l01739">1739</a> of file <a class="el" href="../../d8/d1/drivesup_8c-source.html">drivesup.c</a>.
<p>
References <a class="el" href="../../d3/d6/hal_8h-source.html#l00122">_PARTITION_DESCRIPTOR::ActiveFlag</a>, <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d3/d6/hal_8h-source.html#l00157">BOOT_RECORD_SIGNATURE</a>, <a class="el" href="../../d3/d6/hal_8h-source.html#l00151">BOOT_SIGNATURE_OFFSET</a>, <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00052">DebugPrint</a>, <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00043">DrivesupBreakIn</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l00253">ExAllocatePoolWithTag</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00623">Executive</a>, <a class="el" href="../../d7/d2/cmwraper_8c-source.html#l00304">ExFreePool()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02030">_IO_STACK_LOCATION::Flags</a>, <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00064">GET_PARTITION_LENGTH</a>, <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00058">GET_STARTING_SECTOR</a>, <a class="el" href="../../d3/d6/hal_8h-source.html#l01545">HalExamineMBR</a>, <a class="el" href="../../d8/d1/drivesup_8c-source.html#l03735">HalpGetFullGeometry()</a>, <a class="el" href="../../d8/d1/drivesup_8c-source.html#l03425">HalpIsValidPartitionEntry()</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l01933">IoBuildSynchronousFsdRequest()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02865">IoCallDriver</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l03398">IoGetNextIrpStackLocation</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00058">IRP_MJ_READ</a>, <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00075">_BOOT_SECTOR_INFO::JumpByte</a>, <a class="el" href="../../d5/d8/ke_8h-source.html#l01066">KeInitializeEvent</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00624">KernelMode</a>, <a class="el" href="../../d2/d6/wait_8c-source.html#l00810">KeWaitForSingleObject()</a>, <a class="el" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, <a class="el" href="../../d5/d8/ex_8h.html#a329a177">NonPagedPoolCacheAligned</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d3/d6/hal_8h-source.html#l00144">NUM_PARTITION_TABLE_ENTRIES</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00599">PAGE_SIZE</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d3/d6/hal_8h-source.html#l00169">PARTITION_ACTIVE_FLAG</a>, <a class="el" href="../../d3/d6/hal_8h-source.html#l00163">PARTITION_BUFFER_SIZE</a>, <a class="el" href="../../d3/d6/hal_8h-source.html#l00150">PARTITION_TABLE_OFFSET</a>, <a class="el" href="../../d3/d6/hal_8h-source.html#l00126">_PARTITION_DESCRIPTOR::PartitionType</a>, <a class="el" href="../../d7/d2/drivesup_8c.html#a14">PBOOT_SECTOR_INFO</a>, <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00085">PUSHORT</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00230">SectorSize</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01874">SL_OVERRIDE_VERIFY_VOLUME</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, and <a class="el" href="../../d2/d7/hal_8h.html#a212">VOID()</a>.
<p>
<pre class="fragment"><div>01748                    :
01749 
01750     This routine walks <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> disk reading <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partition tables and creates
01751     an entry in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partition list buffer <span class="keywordflow">for</span> each partition.
01752 
01753     The algorithm used by <span class="keyword">this</span> routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> two-fold:
01754 
01755         1)  Read each partition table and <span class="keywordflow">for</span> each valid, recognized
01756             partition found, to build a descriptor in a partition list.
01757             Extended partitions are located in order to find other
01758             partition tables, but no descriptors are built <span class="keywordflow">for</span> these.
01759             The partition list <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> built in nonpaged <a class="code" href="../../d4/d6/regext_8c.html#a17">pool</a> that <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> allocated
01760             by <span class="keyword">this</span> routine.  It <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller's responsibility to free
01761             <span class="keyword">this</span> <a class="code" href="../../d4/d6/regext_8c.html#a17">pool</a> after <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> has gathered <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> appropriate information
01762             from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> list.
01763 
01764         2)  Read each partition table and <span class="keywordflow">for</span> each and every entry, build
01765             a descriptor in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partition list.  Extended partitions are
01766             located to find each partition table on <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> disk, and entries
01767             are built <span class="keywordflow">for</span> these as well.  The partition list <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> build in
01768             nonpaged <a class="code" href="../../d4/d6/regext_8c.html#a17">pool</a> that <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> allocated by <span class="keyword">this</span> routine.  It <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01769             caller's responsibility to free <span class="keyword">this</span> <a class="code" href="../../d4/d6/regext_8c.html#a17">pool</a> after <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> has copied
01770             <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> information back to its caller.
01771 
01772     The first algorithm <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> used when <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> ReturnRecognizedPartitions flag
01773     <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> set.  This <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> used to determine how many partition device objects
01774     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> device driver <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> to create, and where each lives on <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> drive.
01775 
01776     The second algorithm <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> used when <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> ReturnRecognizedPartitions flag
01777     <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> clear.  This <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> used to find all of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partition tables and their
01778     entries <span class="keywordflow">for</span> a utility such as fdisk, that would like to revamp where
01779     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partitions live.
01780 
01781 Arguments:
01782 
01783     DeviceObject - Pointer to device object <span class="keywordflow">for</span> <span class="keyword">this</span> disk.
01784 
01785     <a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a> - Sector size on <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> device.
01786 
01787     ReturnRecognizedPartitions - <a class="code" href="../../d2/d1/bench_8h.html#a5">A</a> flag indicated whether <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> recognized
01788         partition descriptors are to be returned, or whether all partition
01789         entries are to be returned.
01790 
01791     PartitionBuffer - Pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> pointer of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> buffer in which <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> list
01792         of partition will be stored.
01793 
01794 Return Value:
01795 
01796     The functional value <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> STATUS_SUCCESS <span class="keywordflow">if</span> at least one sector table was
01797     read.
01798 
01799 Notes:
01800 
01801     It <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> responsibility of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller to deallocate <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partition list
01802     buffer allocated by <span class="keyword">this</span> routine.
01803 
01804 --*/
01805 
01806 {
01807     ULONG partitionBufferSize = <a class="code" href="../../d2/d7/hal_8h.html#a13">PARTITION_BUFFER_SIZE</a>;
01808     PDRIVE_LAYOUT_INFORMATION newPartitionBuffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01809 
01810     LONG partitionTableCounter = -1;
01811 
01812     DISK_GEOMETRY diskGeometry;
01813     ULONGLONG endSector;
01814     ULONGLONG maxSector;
01815     ULONGLONG maxOffset;
01816 
01817     LARGE_INTEGER partitionTableOffset;
01818     LARGE_INTEGER volumeStartOffset;
01819     LARGE_INTEGER tempInt;
01820     BOOLEAN primaryPartitionTable;
01821     LONG partitionNumber;
01822     PUCHAR readBuffer = (PUCHAR) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01823     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> event;
01824 
01825     IO_STATUS_BLOCK ioStatus;
01826     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
01827     <a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html">PPARTITION_DESCRIPTOR</a> partitionTableEntry;
01828     CCHAR partitionEntry;
01829     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status = STATUS_SUCCESS;
01830     ULONG readSize;
01831     PPARTITION_INFORMATION partitionInfo;
01832     BOOLEAN foundEZHooker = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01833 
01834     BOOLEAN mbrSignatureFound = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01835     BOOLEAN emptyPartitionTable = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01836 
01837     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01838 
01839     <span class="comment">//</span>
01840     <span class="comment">// Create the buffer that will be passed back to the driver containing</span>
01841     <span class="comment">// the list of partitions on the disk.</span>
01842     <span class="comment">//</span>
01843 
01844     *PartitionBuffer = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( NonPagedPool,
01845                                               partitionBufferSize,
01846                                               'btsF' );
01847 
01848     <span class="keywordflow">if</span> (*PartitionBuffer == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01849         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
01850     }
01851 
01852     <span class="comment">//</span>
01853     <span class="comment">// Determine the size of a read operation to ensure that at least 512</span>
01854     <span class="comment">// bytes are read.  This will guarantee that enough data is read to</span>
01855     <span class="comment">// include an entire partition table.  Note that this code assumes that</span>
01856     <span class="comment">// the actual sector size of the disk (if less than 512 bytes) is a</span>
01857     <span class="comment">// multiple of 2, a fairly reasonable assumption.</span>
01858     <span class="comment">//</span>
01859 
01860     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a> &gt;= 512) {
01861         readSize = <a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a>;
01862     } <span class="keywordflow">else</span> {
01863         readSize = 512;
01864     }
01865 
01866     <span class="comment">//</span>
01867     <span class="comment">// Look to see if this is an EZDrive Disk.  If it is then get the</span>
01868     <span class="comment">// real parititon table at 1.</span>
01869     <span class="comment">//</span>
01870 
01871     {
01872 
01873         PVOID buff;
01874 
01875         <a class="code" href="../../d2/d7/hal_8h.html#a23">HalExamineMBR</a>(
01876             DeviceObject,
01877             readSize,
01878             (ULONG)0x55,
01879             &amp;buff
01880             );
01881 
01882         <span class="keywordflow">if</span> (buff) {
01883 
01884             foundEZHooker = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01885             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(buff);
01886             partitionTableOffset.QuadPart = 512;
01887 
01888         } <span class="keywordflow">else</span> {
01889 
01890             partitionTableOffset.QuadPart = 0;
01891 
01892         }
01893 
01894     }
01895 
01896     <span class="comment">//</span>
01897     <span class="comment">// Get the drive size so we can verify that the partition table is </span>
01898     <span class="comment">// correct.</span>
01899     <span class="comment">//</span>
01900 
01901     status = <a class="code" href="../../d7/d2/drivesup_8c.html#a22">HalpGetFullGeometry</a>(DeviceObject, 
01902                                  &amp;diskGeometry, 
01903                                  &amp;maxOffset);
01904 
01905     <span class="keywordflow">if</span>(!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
01906         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(*PartitionBuffer);
01907         *PartitionBuffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01908         <span class="keywordflow">return</span> status;
01909     }
01910 
01911     <span class="comment">//</span>
01912     <span class="comment">// Partition offsets need to fit on the disk or we're not going to </span>
01913     <span class="comment">// expose them.  Partition ends are generally very very sloppy so we </span>
01914     <span class="comment">// need to allow some slop.  Adding in a cylinders worth isn't enough </span>
01915     <span class="comment">// so now we'll assume that all partitions end within 2x of the real end</span>
01916     <span class="comment">// of the disk.</span>
01917     <span class="comment">//</span>
01918 
01919     endSector = maxOffset;
01920 
01921     maxSector = maxOffset * 2;
01922 
01923     <a class="code" href="../../d7/d2/drivesup_8c.html#a0">DebugPrint</a>((2, <span class="stringliteral">"MaxOffset = %#I64x, maxSector = %#I64x\n"</span>, 
01924                 maxOffset, maxSector));
01925 
01926     <span class="comment">//</span>
01927     <span class="comment">// Indicate that the primary partition table is being read and</span>
01928     <span class="comment">// processed.</span>
01929     <span class="comment">//</span>
01930 
01931     primaryPartitionTable = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01932 
01933     <span class="comment">//</span>
01934     <span class="comment">// The partitions in this volume have their start sector as 0.</span>
01935     <span class="comment">//</span>
01936 
01937     volumeStartOffset.QuadPart = 0;
01938 
01939     <span class="comment">//</span>
01940     <span class="comment">// Initialize the number of partitions in the list.</span>
01941     <span class="comment">//</span>
01942 
01943     partitionNumber = -1;
01944 
01945     <span class="comment">//</span>
01946     <span class="comment">// Allocate a buffer that will hold the reads.</span>
01947     <span class="comment">//</span>
01948 
01949     readBuffer = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( NonPagedPoolCacheAligned,
01950                                         PAGE_SIZE,
01951                                         'btsF' );
01952 
01953     <span class="keywordflow">if</span> (readBuffer == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01954         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( *PartitionBuffer );
01955         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
01956     }
01957 
01958     <span class="comment">//</span>
01959     <span class="comment">// Read each partition table, create an object for the partition(s)</span>
01960     <span class="comment">// it represents, and then if there is a link entry to another</span>
01961     <span class="comment">// partition table, repeat.</span>
01962     <span class="comment">//</span>
01963 
01964     <span class="keywordflow">do</span> {
01965 
01966         BOOLEAN tableIsValid;
01967         ULONG containerPartitionCount;
01968 
01969         tableIsValid = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01970 
01971         <span class="comment">//</span>
01972         <span class="comment">// Read record containing partition table.</span>
01973         <span class="comment">//</span>
01974         <span class="comment">// Create a notification event object to be used while waiting for</span>
01975         <span class="comment">// the read request to complete.</span>
01976         <span class="comment">//</span>
01977 
01978         <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;event, NotificationEvent, FALSE );
01979 
01980         <span class="comment">//</span>
01981         <span class="comment">// Zero out the buffer we're reading into.  In case we get back </span>
01982         <span class="comment">// STATUS_NO_DATA_DETECTED we'll be prepared.</span>
01983         <span class="comment">//</span>
01984 
01985         RtlZeroMemory(readBuffer, readSize);
01986 
01987         irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a27">IoBuildSynchronousFsdRequest</a>( IRP_MJ_READ,
01988                                             DeviceObject,
01989                                             readBuffer,
01990                                             readSize,
01991                                             &amp;partitionTableOffset,
01992                                             &amp;event,
01993                                             &amp;ioStatus );
01994 
01995         <span class="keywordflow">if</span> (!irp) {
01996             status = STATUS_INSUFFICIENT_RESOURCES;
01997             <span class="keywordflow">break</span>;
01998         } <span class="keywordflow">else</span> {
01999             <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpStack;
02000             irpStack = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>(irp);
02001             irpStack-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o2">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a203">SL_OVERRIDE_VERIFY_VOLUME</a>;
02002         }
02003 
02004         status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( DeviceObject, irp );
02005 
02006         <span class="keywordflow">if</span> (status == STATUS_PENDING) {
02007             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
02008                                           Executive,
02009                                           KernelMode,
02010                                           FALSE,
02011                                           (PLARGE_INTEGER) NULL);
02012             status = ioStatus.Status;
02013         }
02014 
02015         <span class="comment">//</span>
02016         <span class="comment">// Special case - if we got a blank-check reading the sector then </span>
02017         <span class="comment">// pretend it was just successful so we can deal with superfloppies</span>
02018         <span class="comment">// where noone bothered to write anything to the non-filesystem sectors</span>
02019         <span class="comment">//</span>
02020 
02021         <span class="keywordflow">if</span>(status == STATUS_NO_DATA_DETECTED) {
02022             status = STATUS_SUCCESS;
02023         }
02024 
02025         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
02026             <span class="keywordflow">break</span>;
02027         }
02028 
02029         <span class="comment">//</span>
02030         <span class="comment">// If EZDrive is hooking the MBR then we found the first partition table</span>
02031         <span class="comment">// in sector 1 rather than 0.  However that partition table is relative</span>
02032         <span class="comment">// to sector zero.  So, Even though we got it from one, reset the partition</span>
02033         <span class="comment">// offset to 0.</span>
02034         <span class="comment">//</span>
02035 
02036         <span class="keywordflow">if</span> (foundEZHooker &amp;&amp; (partitionTableOffset.QuadPart == 512)) {
02037 
02038             partitionTableOffset.QuadPart = 0;
02039 
02040         }
02041 
02042         <span class="comment">//</span>
02043         <span class="comment">// Check for Boot Record signature.</span>
02044         <span class="comment">//</span>
02045 
02046         <span class="keywordflow">if</span> (((<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>) readBuffer)[<a class="code" href="../../d2/d7/hal_8h.html#a11">BOOT_SIGNATURE_OFFSET</a>] != <a class="code" href="../../d2/d7/hal_8h.html#a12">BOOT_RECORD_SIGNATURE</a>) {
02047 
02048             <a class="code" href="../../d7/d2/drivesup_8c.html#a0">DebugPrint</a>((1, <span class="stringliteral">"xHalIoReadPT: No 0xaa55 found in partition table %d\n"</span>,
02049                         partitionTableCounter + 1));
02050 
02051             <span class="keywordflow">break</span>;
02052 
02053         } <span class="keywordflow">else</span> {
02054             mbrSignatureFound = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02055         }
02056 
02057         <span class="comment">//</span>
02058         <span class="comment">// Copy NTFT disk signature to buffer</span>
02059         <span class="comment">//</span>
02060 
02061         <span class="keywordflow">if</span> (partitionTableOffset.QuadPart == 0) {
02062             (*PartitionBuffer)-&gt;Signature =  ((PULONG) readBuffer)[<a class="code" href="../../d2/d7/hal_8h.html#a10">PARTITION_TABLE_OFFSET</a>/2-1];
02063         }
02064 
02065         partitionTableEntry = (<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html">PPARTITION_DESCRIPTOR</a>) &amp;(((<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>) readBuffer)[<a class="code" href="../../d2/d7/hal_8h.html#a10">PARTITION_TABLE_OFFSET</a>]);
02066 
02067         <span class="comment">//</span>
02068         <span class="comment">// Keep count of partition tables in case we have an extended partition;</span>
02069         <span class="comment">//</span>
02070 
02071         partitionTableCounter++;
02072 
02073         <span class="comment">//</span>
02074         <span class="comment">// First create the objects corresponding to the entries in this</span>
02075         <span class="comment">// table that are not link entries or are unused.</span>
02076         <span class="comment">//</span>
02077 
02078         <a class="code" href="../../d7/d2/drivesup_8c.html#a0">DebugPrint</a>((2, <span class="stringliteral">"Partition Table %d:\n"</span>, partitionTableCounter));
02079 
02080         <span class="keywordflow">for</span> (partitionEntry = 1, containerPartitionCount = 0;
02081              partitionEntry &lt;= <a class="code" href="../../d2/d7/hal_8h.html#a9">NUM_PARTITION_TABLE_ENTRIES</a>;
02082              partitionEntry++, partitionTableEntry++) {
02083 
02084             <a class="code" href="../../d7/d2/drivesup_8c.html#a0">DebugPrint</a>((2, <span class="stringliteral">"Partition Entry %d,%d: type %#x %s\n"</span>, 
02085                         partitionTableCounter,
02086                         partitionEntry,
02087                         partitionTableEntry-&gt;<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html#o4">PartitionType</a>,
02088                         (partitionTableEntry-&gt;<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html#o0">ActiveFlag</a>) ? <span class="stringliteral">"Active"</span> : <span class="stringliteral">""</span>));
02089 
02090             <a class="code" href="../../d7/d2/drivesup_8c.html#a0">DebugPrint</a>((2, <span class="stringliteral">"\tOffset %#08lx for %#08lx Sectors\n"</span>, 
02091                         <a class="code" href="../../d7/d2/drivesup_8c.html#a1">GET_STARTING_SECTOR</a>(partitionTableEntry),
02092                         <a class="code" href="../../d7/d2/drivesup_8c.html#a2">GET_PARTITION_LENGTH</a>(partitionTableEntry)));
02093             <span class="comment">//</span>
02094             <span class="comment">// Do a quick pass over the entry to see if this table is valid.</span>
02095             <span class="comment">// It's only fatal if the master partition table is invalid.</span>
02096             <span class="comment">//</span>
02097 
02098             <span class="keywordflow">if</span>((<a class="code" href="../../d7/d2/drivesup_8c.html#a23">HalpIsValidPartitionEntry</a>(partitionTableEntry, 
02099                                           maxOffset,
02100                                           maxSector) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp; 
02101                (partitionTableCounter == 0)) {
02102 
02103                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(DrivesupBreakIn == FALSE);
02104                 <a class="code" href="../../d7/d2/drivesup_8c.html#a12">DrivesupBreakIn</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02105                 tableIsValid = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02106                 <span class="keywordflow">break</span>;
02107 
02108             } 
02109             <span class="comment">//</span>
02110             <span class="comment">// Only one container partition is allowed per table - any more </span>
02111             <span class="comment">// and it's invalid.</span>
02112             <span class="comment">//</span>
02113 
02114             <span class="keywordflow">if</span>(IsContainerPartition(partitionTableEntry-&gt;<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html#o4">PartitionType</a>)) {
02115 
02116                 containerPartitionCount++;
02117 
02118                 <span class="keywordflow">if</span>(containerPartitionCount != 1) {
02119 
02120                     <a class="code" href="../../d7/d2/drivesup_8c.html#a0">DebugPrint</a>((1, <span class="stringliteral">"Multiple container partitions found in "</span>
02121                                    <span class="stringliteral">"partition table %d\n - table is invalid\n"</span>,
02122                                 partitionTableCounter));
02123                     tableIsValid = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02124                     <span class="keywordflow">break</span>;
02125                 }
02126 
02127             }
02128 
02129             <span class="keywordflow">if</span>(emptyPartitionTable) {
02130 
02131                 <span class="keywordflow">if</span>((<a class="code" href="../../d7/d2/drivesup_8c.html#a1">GET_STARTING_SECTOR</a>(partitionTableEntry) != 0) ||
02132                    (<a class="code" href="../../d7/d2/drivesup_8c.html#a2">GET_PARTITION_LENGTH</a>(partitionTableEntry) != 0)) {
02133 
02134                     <span class="comment">//</span>
02135                     <span class="comment">// There's a valid, non-empty partition here. The table</span>
02136                     <span class="comment">// is not empty.</span>
02137                     <span class="comment">//</span>
02138 
02139                     emptyPartitionTable = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02140                 }
02141             }
02142 
02143             <span class="comment">//</span>
02144             <span class="comment">// If the partition entry is not used or not recognized, skip</span>
02145             <span class="comment">// it.  Note that this is only done if the caller wanted only</span>
02146             <span class="comment">// recognized partition descriptors returned.</span>
02147             <span class="comment">//</span>
02148 
02149             <span class="keywordflow">if</span> (ReturnRecognizedPartitions) {
02150 
02151                 <span class="comment">//</span>
02152                 <span class="comment">// Check if partition type is 0 (unused) or 5/f (extended).</span>
02153                 <span class="comment">// The definition of recognized partitions has broadened</span>
02154                 <span class="comment">// to include any partition type other than 0 or 5/f.</span>
02155                 <span class="comment">//</span>
02156 
02157                 <span class="keywordflow">if</span> ((partitionTableEntry-&gt;<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html#o4">PartitionType</a> == PARTITION_ENTRY_UNUSED) ||
02158                     IsContainerPartition(partitionTableEntry-&gt;<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html#o4">PartitionType</a>)) {
02159 
02160                     <span class="keywordflow">continue</span>;
02161                 }
02162             }
02163 
02164             <span class="comment">//</span>
02165             <span class="comment">// Bump up to the next partition entry.</span>
02166             <span class="comment">//</span>
02167 
02168             partitionNumber++;
02169 
02170             <span class="keywordflow">if</span> (((partitionNumber * <span class="keyword">sizeof</span>( PARTITION_INFORMATION )) + 
02171                  <span class="keyword">sizeof</span>( DRIVE_LAYOUT_INFORMATION )) &gt; 
02172                 (ULONG) partitionBufferSize) {
02173 
02174                 <span class="comment">//</span>
02175                 <span class="comment">// The partition list is too small to contain all of the</span>
02176                 <span class="comment">// entries, so create a buffer that is twice as large to</span>
02177                 <span class="comment">// store the partition list and copy the old buffer into</span>
02178                 <span class="comment">// the new one.</span>
02179                 <span class="comment">//</span>
02180 
02181                 newPartitionBuffer = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( NonPagedPool,
02182                                                             partitionBufferSize &lt;&lt; 1,
02183                                                             'btsF' );
02184 
02185                 <span class="keywordflow">if</span> (newPartitionBuffer == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02186                     --partitionNumber;
02187                     status = STATUS_INSUFFICIENT_RESOURCES;
02188                     <span class="keywordflow">break</span>;
02189                 }
02190 
02191                 RtlMoveMemory( newPartitionBuffer,
02192                                *PartitionBuffer,
02193                                partitionBufferSize );
02194 
02195                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( *PartitionBuffer );
02196 
02197                 <span class="comment">//</span>
02198                 <span class="comment">// Reassign the new buffer to the return parameter and</span>
02199                 <span class="comment">// reset the size of the buffer.</span>
02200                 <span class="comment">//</span>
02201 
02202                 *PartitionBuffer = newPartitionBuffer;
02203                 partitionBufferSize &lt;&lt;= 1;
02204             }
02205 
02206             <span class="comment">//</span>
02207             <span class="comment">// Describe this partition table entry in the partition list</span>
02208             <span class="comment">// entry being built for the driver.  This includes writing</span>
02209             <span class="comment">// the partition type, starting offset of the partition, and</span>
02210             <span class="comment">// the length of the partition.</span>
02211             <span class="comment">//</span>
02212 
02213             partitionInfo = &amp;(*PartitionBuffer)-&gt;PartitionEntry[partitionNumber];
02214 
02215             partitionInfo-&gt;PartitionType = partitionTableEntry-&gt;<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html#o4">PartitionType</a>;
02216 
02217             partitionInfo-&gt;RewritePartition = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02218 
02219             <span class="keywordflow">if</span> (partitionTableEntry-&gt;<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html#o4">PartitionType</a> != PARTITION_ENTRY_UNUSED) {
02220                 LONGLONG startOffset;
02221 
02222                 partitionInfo-&gt;BootIndicator =
02223                     partitionTableEntry-&gt;<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html#o0">ActiveFlag</a> &amp; <a class="code" href="../../d2/d7/hal_8h.html#a14">PARTITION_ACTIVE_FLAG</a> ?
02224                         (BOOLEAN) <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> : (BOOLEAN) <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02225 
02226                 <span class="keywordflow">if</span> (IsContainerPartition(partitionTableEntry-&gt;<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html#o4">PartitionType</a>)) {
02227                     partitionInfo-&gt;RecognizedPartition = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02228                     startOffset = volumeStartOffset.QuadPart;
02229                 } <span class="keywordflow">else</span> {
02230                     partitionInfo-&gt;RecognizedPartition = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02231                     startOffset = partitionTableOffset.QuadPart;
02232                 }
02233 
02234                 partitionInfo-&gt;StartingOffset.QuadPart = startOffset +
02235                     UInt32x32To64(<a class="code" href="../../d7/d2/drivesup_8c.html#a1">GET_STARTING_SECTOR</a>(partitionTableEntry),
02236                                   SectorSize);
02237                 tempInt.QuadPart = (partitionInfo-&gt;StartingOffset.QuadPart -
02238                                    startOffset) / <a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a>;
02239                 partitionInfo-&gt;HiddenSectors = tempInt.LowPart;
02240 
02241                 partitionInfo-&gt;PartitionLength.QuadPart =
02242                     UInt32x32To64(<a class="code" href="../../d7/d2/drivesup_8c.html#a2">GET_PARTITION_LENGTH</a>(partitionTableEntry),
02243                                   SectorSize);
02244 
02245             } <span class="keywordflow">else</span> {
02246 
02247                 <span class="comment">//</span>
02248                 <span class="comment">// Partitions that are not used do not describe any part</span>
02249                 <span class="comment">// of the disk.  These types are recorded in the partition</span>
02250                 <span class="comment">// list buffer when the caller requested all of the entries</span>
02251                 <span class="comment">// be returned.  Simply zero out the remaining fields in</span>
02252                 <span class="comment">// the entry.</span>
02253                 <span class="comment">//</span>
02254 
02255                 partitionInfo-&gt;BootIndicator = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02256                 partitionInfo-&gt;RecognizedPartition = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02257                 partitionInfo-&gt;StartingOffset.QuadPart = 0;
02258                 partitionInfo-&gt;PartitionLength.QuadPart = 0;
02259                 partitionInfo-&gt;HiddenSectors = 0;
02260             }
02261 
02262         }
02263 
02264         <a class="code" href="../../d7/d2/drivesup_8c.html#a0">DebugPrint</a>((2, <span class="stringliteral">"\n"</span>));
02265 
02266         <span class="comment">//</span>
02267         <span class="comment">// If an error occurred, leave the routine now.</span>
02268         <span class="comment">//</span>
02269 
02270         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
02271             <span class="keywordflow">break</span>;
02272         }
02273 
02274         <span class="keywordflow">if</span>(tableIsValid == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
02275             
02276             <span class="comment">//</span>
02277             <span class="comment">// Invalidate this partition table and stop looking for new ones.</span>
02278             <span class="comment">// we'll build the partition list based on the ones we found </span>
02279             <span class="comment">// previously.</span>
02280             <span class="comment">//</span>
02281 
02282             partitionTableCounter--;
02283             <span class="keywordflow">break</span>;
02284         }
02285 
02286         <span class="comment">//</span>
02287         <span class="comment">// Now check to see if there are any link entries in this table,</span>
02288         <span class="comment">// and if so, set up the sector address of the next partition table.</span>
02289         <span class="comment">// There can only be one link entry in each partition table, and it</span>
02290         <span class="comment">// will point to the next table.</span>
02291         <span class="comment">//</span>
02292 
02293         partitionTableEntry = (<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html">PPARTITION_DESCRIPTOR</a>) &amp;(((<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>) readBuffer)[<a class="code" href="../../d2/d7/hal_8h.html#a10">PARTITION_TABLE_OFFSET</a>]);
02294 
02295         <span class="comment">//</span>
02296         <span class="comment">// Assume that the link entry is empty.</span>
02297         <span class="comment">//</span>
02298 
02299         partitionTableOffset.QuadPart = 0;
02300 
02301         <span class="keywordflow">for</span> (partitionEntry = 1;
02302              partitionEntry &lt;= <a class="code" href="../../d2/d7/hal_8h.html#a9">NUM_PARTITION_TABLE_ENTRIES</a>;
02303              partitionEntry++, partitionTableEntry++) {
02304 
02305             <span class="keywordflow">if</span> (IsContainerPartition(partitionTableEntry-&gt;<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html#o4">PartitionType</a>)) {
02306 
02307                 <span class="comment">//</span>
02308                 <span class="comment">// Obtain the address of the next partition table on the</span>
02309                 <span class="comment">// disk.  This is the number of hidden sectors added to</span>
02310                 <span class="comment">// the beginning of the extended partition (in the case of</span>
02311                 <span class="comment">// logical drives), since all logical drives are relative</span>
02312                 <span class="comment">// to the extended partition.  The VolumeStartSector will</span>
02313                 <span class="comment">// be zero if this is the primary parition table.</span>
02314                 <span class="comment">//</span>
02315 
02316                 partitionTableOffset.QuadPart = volumeStartOffset.QuadPart +
02317                     UInt32x32To64(<a class="code" href="../../d7/d2/drivesup_8c.html#a1">GET_STARTING_SECTOR</a>(partitionTableEntry),
02318                                   SectorSize);
02319 
02320                 <span class="comment">//</span>
02321                 <span class="comment">// Set the VolumeStartSector to be the begining of the</span>
02322                 <span class="comment">// second partition (extended partition) because all of</span>
02323                 <span class="comment">// the offsets to the partition tables of the logical drives</span>
02324                 <span class="comment">// are relative to this extended partition.</span>
02325                 <span class="comment">//</span>
02326 
02327                 <span class="keywordflow">if</span> (primaryPartitionTable) {
02328                     volumeStartOffset = partitionTableOffset;
02329                 }
02330 
02331                 <span class="comment">//</span>
02332                 <span class="comment">// Update the maximum sector to be the end of the container </span>
02333                 <span class="comment">// partition.</span>
02334                 <span class="comment">//</span>
02335 
02336                 maxSector = <a class="code" href="../../d7/d2/drivesup_8c.html#a2">GET_PARTITION_LENGTH</a>(partitionTableEntry);
02337 
02338                 <a class="code" href="../../d7/d2/drivesup_8c.html#a0">DebugPrint</a>((2, <span class="stringliteral">"MaxSector now = %#08lx\n"</span>, maxSector));
02339 
02340                 <span class="comment">//</span>
02341                 <span class="comment">// There is only ever one link entry per partition table,</span>
02342                 <span class="comment">// exit the loop once it has been found.</span>
02343                 <span class="comment">//</span>
02344 
02345                 <span class="keywordflow">break</span>;
02346             }
02347         }
02348 
02349 
02350         <span class="comment">//</span>
02351         <span class="comment">// All the other partitions will be logical drives.</span>
02352         <span class="comment">//</span>
02353 
02354         primaryPartitionTable = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02355 
02356 
02357     } <span class="keywordflow">while</span> (partitionTableOffset.HighPart | partitionTableOffset.LowPart);
02358 
02359     <span class="comment">//</span>
02360     <span class="comment">// Detect super-floppy media attempt #1.</span>
02361     <span class="comment">// If the media is removable and has an 0xaa55 signature on it and </span>
02362     <span class="comment">// is empty then check to see if we can recognize the BPB.  If we recognize</span>
02363     <span class="comment">// a jump-byte at the beginning of the media then it's a super floppy.  If</span>
02364     <span class="comment">// we don't then it's an unpartitioned disk.</span>
02365     <span class="comment">// </span>
02366 
02367     <a class="code" href="../../d7/d2/drivesup_8c.html#a0">DebugPrint</a>((4, <span class="stringliteral">"xHalIoReadPartitionTable: RM %d  PTC %d  MBR %d  EPT %d\n"</span>, 
02368                 diskGeometry.MediaType,
02369                 partitionTableCounter,
02370                 mbrSignatureFound,
02371                 emptyPartitionTable));
02372 
02373     <span class="keywordflow">if</span>((diskGeometry.MediaType == RemovableMedia) &amp;&amp;
02374        (partitionTableCounter == 0) &amp;&amp;
02375        (mbrSignatureFound == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) &amp;&amp;
02376        (emptyPartitionTable == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>)) {
02377 
02378         <a class="code" href="../../d7/d4/struct__BOOT__SECTOR__INFO.html">PBOOT_SECTOR_INFO</a> bootSector = (<a class="code" href="../../d7/d4/struct__BOOT__SECTOR__INFO.html">PBOOT_SECTOR_INFO</a>) readBuffer;
02379 
02380         <span class="keywordflow">if</span>((bootSector-&gt;<a class="code" href="../../d7/d4/struct__BOOT__SECTOR__INFO.html#o0">JumpByte</a>[0] == 0xeb) ||
02381            (bootSector-&gt;<a class="code" href="../../d7/d4/struct__BOOT__SECTOR__INFO.html#o0">JumpByte</a>[0] == 0xe9)) {
02382 
02383             <span class="comment">//</span>
02384             <span class="comment">// We've got a superfloppy of some sort.</span>
02385             <span class="comment">//</span>
02386 
02387             <a class="code" href="../../d7/d2/drivesup_8c.html#a0">DebugPrint</a>((1, <span class="stringliteral">"xHalIoReadPartitionTable: Jump byte %#x found "</span>
02388                            <span class="stringliteral">"along with empty partition table - disk is a "</span>
02389                            <span class="stringliteral">"super floppy and has no valid MBR\n"</span>, 
02390                         bootSector-&gt;<a class="code" href="../../d7/d4/struct__BOOT__SECTOR__INFO.html#o0">JumpByte</a>));
02391 
02392             partitionTableCounter = -1;
02393         }
02394     }
02395 
02396     <span class="comment">//</span>
02397     <span class="comment">// If the partition table count is still -1 then we didn't find any </span>
02398     <span class="comment">// valid partition records.  In this case we'll build a partition list </span>
02399     <span class="comment">// that contiains one partition spanning the entire disk.</span>
02400     <span class="comment">//</span>
02401 
02402     <span class="keywordflow">if</span>(partitionTableCounter == -1) {
02403 
02404         <span class="keywordflow">if</span>((mbrSignatureFound == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) ||
02405            (diskGeometry.MediaType == RemovableMedia)) {
02406 
02407             <span class="comment">//</span>
02408             <span class="comment">// Either we found a signature but the partition layout was </span>
02409             <span class="comment">// invalid (for all disks) or we didn't find a signature but this</span>
02410             <span class="comment">// is a removable disk.  Either of these two cases makes a </span>
02411             <span class="comment">// superfloppy.</span>
02412             <span class="comment">//</span>
02413 
02414             <a class="code" href="../../d7/d2/drivesup_8c.html#a0">DebugPrint</a>((1, <span class="stringliteral">"xHalIoReadPartitionTable: Drive %#p has no valid MBR. "</span> 
02415                            <span class="stringliteral">"Make it into a super-floppy\n"</span>, DeviceObject));
02416     
02417             <a class="code" href="../../d7/d2/drivesup_8c.html#a0">DebugPrint</a>((1, <span class="stringliteral">"xHalIoReadPartitionTable: Drive has %#08lx sectors "</span>
02418                            <span class="stringliteral">"and is %#016I64x bytes large\n"</span>, 
02419                         endSector, endSector * diskGeometry.BytesPerSector));
02420     
02421             <span class="keywordflow">if</span> (endSector &gt; 0) {
02422     
02423                 partitionInfo = &amp;(*PartitionBuffer)-&gt;PartitionEntry[0];
02424     
02425                 partitionInfo-&gt;RewritePartition = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02426                 partitionInfo-&gt;RecognizedPartition = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02427                 partitionInfo-&gt;PartitionType = PARTITION_FAT_16;
02428                 partitionInfo-&gt;BootIndicator = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02429     
02430                 partitionInfo-&gt;HiddenSectors = 0;
02431     
02432                 partitionInfo-&gt;StartingOffset.QuadPart = 0;
02433     
02434                 partitionInfo-&gt;PartitionLength.QuadPart = 
02435                     (endSector * diskGeometry.BytesPerSector);
02436     
02437                 (*PartitionBuffer)-&gt;Signature = 1;
02438     
02439                 partitionNumber = 0;
02440             }
02441         } <span class="keywordflow">else</span> {
02442 
02443             <span class="comment">//</span>
02444             <span class="comment">// We found no partitions.  Make sure the partition count is -1</span>
02445             <span class="comment">// so that we setup a zeroed-out partition table below.</span>
02446             <span class="comment">//</span>
02447 
02448             partitionNumber = -1;
02449         }
02450     } 
02451 
02452     <span class="comment">//</span>
02453     <span class="comment">// Fill in the first field in the PartitionBuffer. This field indicates how</span>
02454     <span class="comment">// many partition entries there are in the PartitionBuffer.</span>
02455     <span class="comment">//</span>
02456 
02457     (*PartitionBuffer)-&gt;PartitionCount = ++partitionNumber;
02458 
02459     <span class="keywordflow">if</span> (!partitionNumber) {
02460 
02461         <span class="comment">//</span>
02462         <span class="comment">// Zero out disk signature.</span>
02463         <span class="comment">//</span>
02464 
02465         (*PartitionBuffer)-&gt;Signature = 0;
02466     }
02467 
02468     <span class="comment">//</span>
02469     <span class="comment">// Deallocate read buffer if it was allocated it.</span>
02470     <span class="comment">//</span>
02471 
02472     <span class="keywordflow">if</span> (readBuffer != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02473         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( readBuffer );
02474     }
02475 
02476     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
02477         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(*PartitionBuffer);
02478         *PartitionBuffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02479     }
02480     <span class="keywordflow">return</span> status;
02481 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a32" doxytag="drivesup.c::xHalIoSetPartitionInformation" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS FASTCALL xHalIoSetPartitionInformation           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>DeviceObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>SectorSize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>PartitionNumber</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>PartitionType</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d1/drivesup_8c-source.html#l02485">2485</a> of file <a class="el" href="../../d8/d1/drivesup_8c-source.html">drivesup.c</a>.
<p>
References <a class="el" href="../../d3/d6/hal_8h-source.html#l00157">BOOT_RECORD_SIGNATURE</a>, <a class="el" href="../../d3/d6/hal_8h-source.html#l00151">BOOT_SIGNATURE_OFFSET</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l00253">ExAllocatePoolWithTag</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00623">Executive</a>, <a class="el" href="../../d7/d2/cmwraper_8c-source.html#l00304">ExFreePool()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02030">_IO_STACK_LOCATION::Flags</a>, <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00058">GET_STARTING_SECTOR</a>, <a class="el" href="../../d3/d6/hal_8h-source.html#l01545">HalExamineMBR</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l01933">IoBuildSynchronousFsdRequest()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02865">IoCallDriver</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l03398">IoGetNextIrpStackLocation</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00058">IRP_MJ_READ</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00059">IRP_MJ_WRITE</a>, <a class="el" href="../../d5/d8/ke_8h-source.html#l01066">KeInitializeEvent</a>, <a class="el" href="../../d3/d7/eventobj_8c-source.html#l00285">KeResetEvent()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00624">KernelMode</a>, <a class="el" href="../../d2/d6/wait_8c-source.html#l00810">KeWaitForSingleObject()</a>, <a class="el" href="../../d5/d8/ex_8h.html#a329a177">NonPagedPoolCacheAligned</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d3/d6/hal_8h-source.html#l00144">NUM_PARTITION_TABLE_ENTRIES</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00599">PAGE_SIZE</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d3/d6/hal_8h-source.html#l00150">PARTITION_TABLE_OFFSET</a>, <a class="el" href="../../d3/d6/hal_8h-source.html#l00126">_PARTITION_DESCRIPTOR::PartitionType</a>, <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00085">PUSHORT</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00230">SectorSize</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01874">SL_OVERRIDE_VERIFY_VOLUME</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, and <a class="el" href="../../d2/d7/hal_8h.html#a212">VOID()</a>.
<p>
<pre class="fragment"><div>02494                    :
02495 
02496     This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> invoked when a disk device driver <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> asked to set <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
02497     partition <a class="code" href="../../d3/d5/i386_2trapc_8c.html#a9">type</a> in a partition table entry via an I/O <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> code.  This
02498     <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> code <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> generally issued by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d8/d0/rtbatcr_8c.html#a8">format</a> utility just after <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a>
02499     has formatted <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partition.  The <a class="code" href="../../d8/d0/rtbatcr_8c.html#a8">format</a> utility performs <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> I/O <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a>
02500     function on <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partition and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> driver passes <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> base
02501     physical device object and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> number of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partition associated with
02502     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> device object that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d8/d0/rtbatcr_8c.html#a8">format</a> utility has open.  If <span class="keyword">this</span> routine
02503     returns success, then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> disk driver should updates its notion of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
02504     partition <a class="code" href="../../d3/d5/i386_2trapc_8c.html#a9">type</a> <span class="keywordflow">for</span> <span class="keyword">this</span> partition in its device <a class="code" href="../../d7/d1/genuedef_8c.html#a6">extension</a>.
02505 
02506 Arguments:
02507 
02508     DeviceObject - Pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> base physical device object <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> device
02509         on which <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partition <a class="code" href="../../d3/d5/i386_2trapc_8c.html#a9">type</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> to be set.
02510 
02511     <a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a> - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> size of a sector on <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> disk in bytes.
02512 
02513     PartitionNumber - Specifies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partition number on <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> device whose
02514         partition <a class="code" href="../../d3/d5/i386_2trapc_8c.html#a9">type</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> to be changed.
02515 
02516     PartitionType - Specifies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keyword">new</span> <a class="code" href="../../d3/d5/i386_2trapc_8c.html#a9">type</a> <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partition.
02517 
02518 Return Value:
02519 
02520     The function value <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keyword">final</span> status of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> operation.
02521 
02522 Notes:
02523 
02524     This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> synchronous.  Therefore, <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> MUST be invoked by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> disk
02525     driver's dispatch routine, or by a disk driver's thread.  Likewise, all
02526     users, FSP threads, etc., must be prepared to enter a wait state when
02527     issuing <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> I/O <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> code to set <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partition <a class="code" href="../../d3/d5/i386_2trapc_8c.html#a9">type</a> <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> device.
02528 
02529     Note also that <span class="keyword">this</span> routine assumes that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partition number passed
02530     in by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> disk driver actually exists since <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> driver itself supplies
02531     <span class="keyword">this</span> parameter.
02532 
02533     Finally, note that <span class="keyword">this</span> routine may NOT be invoked at <a class="code" href="../../d6/d7/halmips_8h.html#a52">APC_LEVEL</a>.  It
02534     must be invoked at <a class="code" href="../../d1/d3/ppcdef_8h.html#a21">PASSIVE_LEVEL</a>.  This <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> due to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> fact that <span class="keyword">this</span>
02535     routine uses a kernel event object to synchronize I/O completion on <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
02536     device.  The event cannot be set to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> signaled state without queueing
02537     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> I/O system's special kernel APC routine <span class="keywordflow">for</span> I/O completion and
02538     executing <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a>.  (This rules <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a bit esoteric since <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> holds <span class="keyword">true</span>
02539     <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> device driver returns something other than STATUS_PENDING, which
02540     <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> will probably never <span class="keywordflow">do</span>.)
02541 
02542 --*/
02543 
02544 {
02545 
02546 <span class="preprocessor">#define GET_STARTING_SECTOR( p ) (                  \</span>
02547 <span class="preprocessor">        (ULONG) (p-&gt;StartingSectorLsb0) +           \</span>
02548 <span class="preprocessor">        (ULONG) (p-&gt;StartingSectorLsb1 &lt;&lt; 8) +      \</span>
02549 <span class="preprocessor">        (ULONG) (p-&gt;StartingSectorMsb0 &lt;&lt; 16) +     \</span>
02550 <span class="preprocessor">        (ULONG) (p-&gt;StartingSectorMsb1 &lt;&lt; 24) )</span>
02551 <span class="preprocessor"></span>
02552     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
02553     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> event;
02554     IO_STATUS_BLOCK ioStatus;
02555     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
02556     LARGE_INTEGER partitionTableOffset;
02557     LARGE_INTEGER volumeStartOffset;
02558     PUCHAR buffer = (PUCHAR) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02559     ULONG transferSize;
02560     ULONG partitionNumber;
02561     ULONG partitionEntry;
02562     <a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html">PPARTITION_DESCRIPTOR</a> partitionTableEntry;
02563     BOOLEAN primaryPartitionTable;
02564     BOOLEAN foundEZHooker = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02565 
02566     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02567 
02568     <span class="comment">//</span>
02569     <span class="comment">// Begin by determining the size of the buffer required to read and write</span>
02570     <span class="comment">// the partition information to/from the disk.  This is done to ensure</span>
02571     <span class="comment">// that at least 512 bytes are read, thereby guaranteeing that enough data</span>
02572     <span class="comment">// is read to include an entire partition table.  Note that this code</span>
02573     <span class="comment">// assumes that the actual sector size of the disk (if less than 512</span>
02574     <span class="comment">// bytes) is a multiple of 2, a</span>
02575     <span class="comment">// fairly reasonable assumption.</span>
02576     <span class="comment">//</span>
02577 
02578     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a> &gt;= 512) {
02579         transferSize = <a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a>;
02580     } <span class="keywordflow">else</span> {
02581         transferSize = 512;
02582     }
02583 
02584 
02585     <span class="comment">//</span>
02586     <span class="comment">// Look to see if this is an EZDrive Disk.  If it is then get the</span>
02587     <span class="comment">// real parititon table at 1.</span>
02588     <span class="comment">//</span>
02589 
02590     {
02591 
02592         PVOID buff;
02593 
02594         <a class="code" href="../../d2/d7/hal_8h.html#a23">HalExamineMBR</a>(
02595             DeviceObject,
02596             transferSize,
02597             (ULONG)0x55,
02598             &amp;buff
02599             );
02600 
02601         <span class="keywordflow">if</span> (buff) {
02602 
02603             foundEZHooker = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02604             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(buff);
02605             partitionTableOffset.QuadPart = 512;
02606 
02607         } <span class="keywordflow">else</span> {
02608 
02609             partitionTableOffset.QuadPart = 0;
02610 
02611         }
02612 
02613     }
02614 
02615 
02616     <span class="comment">//</span>
02617     <span class="comment">// The partitions in this primary partition have their start sector 0.</span>
02618     <span class="comment">//</span>
02619 
02620     volumeStartOffset.QuadPart = 0;
02621 
02622     <span class="comment">//</span>
02623     <span class="comment">// Indicate that the table being read and processed is the primary partition</span>
02624     <span class="comment">// table.</span>
02625     <span class="comment">//</span>
02626 
02627     primaryPartitionTable = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02628 
02629     <span class="comment">//</span>
02630     <span class="comment">// Initialize the number of partitions found thus far.</span>
02631     <span class="comment">//</span>
02632 
02633     partitionNumber = 0;
02634 
02635     <span class="comment">//</span>
02636     <span class="comment">// Allocate a buffer that will hold the read/write data.</span>
02637     <span class="comment">//</span>
02638 
02639     buffer = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( NonPagedPoolCacheAligned, PAGE_SIZE, 'btsF');
02640     <span class="keywordflow">if</span> (buffer == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02641         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
02642     }
02643 
02644     <span class="comment">//</span>
02645     <span class="comment">// Initialize a kernel event to use in synchronizing device requests</span>
02646     <span class="comment">// with I/O completion.</span>
02647     <span class="comment">//</span>
02648 
02649     <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;event, NotificationEvent, FALSE );
02650 
02651     <span class="comment">//</span>
02652     <span class="comment">// Read each partition table scanning for the partition table entry that</span>
02653     <span class="comment">// the caller wishes to modify.</span>
02654     <span class="comment">//</span>
02655 
02656     <span class="keywordflow">do</span> {
02657 
02658         <span class="comment">//</span>
02659         <span class="comment">// Read the record containing the partition table.</span>
02660         <span class="comment">//</span>
02661 
02662         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d2/d8/eventobj_8c.html#a7">KeResetEvent</a>( &amp;event );
02663 
02664         irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a27">IoBuildSynchronousFsdRequest</a>( IRP_MJ_READ,
02665                                             DeviceObject,
02666                                             buffer,
02667                                             transferSize,
02668                                             &amp;partitionTableOffset,
02669                                             &amp;event,
02670                                             &amp;ioStatus );
02671 
02672         <span class="keywordflow">if</span> (!irp) {
02673             status = STATUS_INSUFFICIENT_RESOURCES;
02674             <span class="keywordflow">break</span>;
02675         } <span class="keywordflow">else</span> {
02676             <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpStack;
02677             irpStack = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>(irp);
02678             irpStack-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o2">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a203">SL_OVERRIDE_VERIFY_VOLUME</a>;
02679         }
02680 
02681         status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( DeviceObject, irp );
02682 
02683         <span class="keywordflow">if</span> (status == STATUS_PENDING) {
02684             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
02685                                           Executive,
02686                                           KernelMode,
02687                                           FALSE,
02688                                           (PLARGE_INTEGER) NULL );
02689             status = ioStatus.Status;
02690         }
02691 
02692         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
02693             <span class="keywordflow">break</span>;
02694         }
02695 
02696         <span class="comment">//</span>
02697         <span class="comment">// If EZDrive is hooking the MBR then we found the first partition table</span>
02698         <span class="comment">// in sector 1 rather than 0.  However that partition table is relative</span>
02699         <span class="comment">// to sector zero.  So, Even though we got it from one, reset the partition</span>
02700         <span class="comment">// offset to 0.</span>
02701         <span class="comment">//</span>
02702 
02703         <span class="keywordflow">if</span> (foundEZHooker &amp;&amp; (partitionTableOffset.QuadPart == 512)) {
02704 
02705             partitionTableOffset.QuadPart = 0;
02706 
02707         }
02708 
02709         <span class="comment">//</span>
02710         <span class="comment">// Check for a valid Boot Record signature in the partition table</span>
02711         <span class="comment">// record.</span>
02712         <span class="comment">//</span>
02713 
02714         <span class="keywordflow">if</span> (((<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>) buffer)[<a class="code" href="../../d2/d7/hal_8h.html#a11">BOOT_SIGNATURE_OFFSET</a>] != <a class="code" href="../../d2/d7/hal_8h.html#a12">BOOT_RECORD_SIGNATURE</a>) {
02715             status = STATUS_BAD_MASTER_BOOT_RECORD;
02716             <span class="keywordflow">break</span>;
02717         }
02718 
02719         partitionTableEntry = (<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html">PPARTITION_DESCRIPTOR</a>) &amp;(((<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>) buffer)[<a class="code" href="../../d2/d7/hal_8h.html#a10">PARTITION_TABLE_OFFSET</a>]);
02720 
02721         <span class="comment">//</span>
02722         <span class="comment">// Scan the partition entries in this partition table to determine if</span>
02723         <span class="comment">// any of the entries are the desired entry.  Each entry in each</span>
02724         <span class="comment">// table must be scanned in the same order as in IoReadPartitionTable</span>
02725         <span class="comment">// so that the partition table entry cooresponding to the driver's</span>
02726         <span class="comment">// notion of the partition number can be located.</span>
02727         <span class="comment">//</span>
02728 
02729         <span class="keywordflow">for</span> (partitionEntry = 1;
02730             partitionEntry &lt;= <a class="code" href="../../d2/d7/hal_8h.html#a9">NUM_PARTITION_TABLE_ENTRIES</a>;
02731             partitionEntry++, partitionTableEntry++) {
02732 
02733 
02734             <span class="comment">//</span>
02735             <span class="comment">// If the partition entry is empty or for an extended, skip it.</span>
02736             <span class="comment">//</span>
02737 
02738             <span class="keywordflow">if</span> ((partitionTableEntry-&gt;<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html#o4">PartitionType</a> == PARTITION_ENTRY_UNUSED) ||
02739                 IsContainerPartition(partitionTableEntry-&gt;<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html#o4">PartitionType</a>)) {
02740                 <span class="keywordflow">continue</span>;
02741             }
02742 
02743             <span class="comment">//</span>
02744             <span class="comment">// A valid partition entry that is recognized has been located.</span>
02745             <span class="comment">// Bump the count and check to see if this entry is the desired</span>
02746             <span class="comment">// entry.</span>
02747             <span class="comment">//</span>
02748 
02749             partitionNumber++;
02750 
02751             <span class="keywordflow">if</span> (partitionNumber == PartitionNumber) {
02752 
02753                 <span class="comment">//</span>
02754                 <span class="comment">// This is the desired partition that is to be changed.  Simply</span>
02755                 <span class="comment">// overwrite the partition type and write the entire partition</span>
02756                 <span class="comment">// buffer back out to the disk.</span>
02757                 <span class="comment">//</span>
02758 
02759                 partitionTableEntry-&gt;<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html#o4">PartitionType</a> = (UCHAR) PartitionType;
02760 
02761                 (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d2/d8/eventobj_8c.html#a7">KeResetEvent</a>( &amp;event );
02762 
02763                 irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a27">IoBuildSynchronousFsdRequest</a>( IRP_MJ_WRITE,
02764                                                     DeviceObject,
02765                                                     buffer,
02766                                                     transferSize,
02767                                                     &amp;partitionTableOffset,
02768                                                     &amp;event,
02769                                                     &amp;ioStatus );
02770 
02771                 <span class="keywordflow">if</span> (!irp) {
02772                     status = STATUS_INSUFFICIENT_RESOURCES;
02773                     <span class="keywordflow">break</span>;
02774                 } <span class="keywordflow">else</span> {
02775                     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpStack;
02776                     irpStack = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>(irp);
02777                     irpStack-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o2">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a203">SL_OVERRIDE_VERIFY_VOLUME</a>;
02778                 }
02779 
02780                 status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( DeviceObject, irp );
02781 
02782                 <span class="keywordflow">if</span> (status == STATUS_PENDING) {
02783                     (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
02784                                                   Executive,
02785                                                   KernelMode,
02786                                                   FALSE,
02787                                                   (PLARGE_INTEGER) NULL );
02788                     status = ioStatus.Status;
02789                 }
02790 
02791                 <span class="keywordflow">break</span>;
02792             }
02793         }
02794 
02795         <span class="comment">//</span>
02796         <span class="comment">// If all of the entries in the current buffer were scanned and the</span>
02797         <span class="comment">// desired entry was not found, then continue.  Otherwise, leave the</span>
02798         <span class="comment">// routine.</span>
02799         <span class="comment">//</span>
02800 
02801         <span class="keywordflow">if</span> (partitionEntry &lt;= <a class="code" href="../../d2/d7/hal_8h.html#a9">NUM_PARTITION_TABLE_ENTRIES</a>) {
02802             <span class="keywordflow">break</span>;
02803         }
02804 
02805         <span class="comment">//</span>
02806         <span class="comment">// Now scan the current buffer to locate an extended partition entry</span>
02807         <span class="comment">// in the table so that its partition information can be read.  There</span>
02808         <span class="comment">// can only be one extended partition entry in each partition table,</span>
02809         <span class="comment">// and it will point to the next table.</span>
02810         <span class="comment">//</span>
02811 
02812         partitionTableEntry = (<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html">PPARTITION_DESCRIPTOR</a>) &amp;(((<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a>) buffer)[<a class="code" href="../../d2/d7/hal_8h.html#a10">PARTITION_TABLE_OFFSET</a>]);
02813 
02814         <span class="keywordflow">for</span> (partitionEntry = 1;
02815             partitionEntry &lt;= <a class="code" href="../../d2/d7/hal_8h.html#a9">NUM_PARTITION_TABLE_ENTRIES</a>;
02816             partitionEntry++, partitionTableEntry++) {
02817 
02818             <span class="keywordflow">if</span> (IsContainerPartition(partitionTableEntry-&gt;<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html#o4">PartitionType</a>)) {
02819 
02820                 <span class="comment">//</span>
02821                 <span class="comment">// Obtain the address of the next partition table on the disk.</span>
02822                 <span class="comment">// This is the number of hidden sectors added to the beginning</span>
02823                 <span class="comment">// of the extended partition (in the case of logical drives),</span>
02824                 <span class="comment">// since all logical drives are relative to the extended</span>
02825                 <span class="comment">// partition.  The starting offset of the volume will be zero</span>
02826                 <span class="comment">// if this is the primary partition table.</span>
02827                 <span class="comment">//</span>
02828 
02829                 partitionTableOffset.QuadPart = volumeStartOffset.QuadPart +
02830                     UInt32x32To64(<a class="code" href="../../d7/d2/drivesup_8c.html#a1">GET_STARTING_SECTOR</a>(partitionTableEntry),
02831                                   SectorSize);
02832 
02833                 <span class="comment">//</span>
02834                 <span class="comment">// Set the starting offset of the volume to be the beginning of</span>
02835                 <span class="comment">// the second partition (the extended partition) because all of</span>
02836                 <span class="comment">// the offsets to the partition tables of the logical drives</span>
02837                 <span class="comment">// are relative to this extended partition.</span>
02838                 <span class="comment">//</span>
02839 
02840                 <span class="keywordflow">if</span> (primaryPartitionTable) {
02841                     volumeStartOffset = partitionTableOffset;
02842                 }
02843 
02844                 <span class="keywordflow">break</span>;
02845             }
02846         }
02847 
02848         <span class="comment">//</span>
02849         <span class="comment">// Ensure that a partition entry was located that was an extended</span>
02850         <span class="comment">// partition, otherwise the desired partition will never be found.</span>
02851         <span class="comment">//</span>
02852 
02853         <span class="keywordflow">if</span> (partitionEntry &gt; <a class="code" href="../../d2/d7/hal_8h.html#a9">NUM_PARTITION_TABLE_ENTRIES</a>) {
02854             status = STATUS_BAD_MASTER_BOOT_RECORD;
02855             <span class="keywordflow">break</span>;
02856         }
02857 
02858         <span class="comment">//</span>
02859         <span class="comment">// All the other partitions will be logical drives.</span>
02860         <span class="comment">//</span>
02861 
02862         primaryPartitionTable = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02863 
02864     } <span class="keywordflow">while</span> (partitionNumber &lt; PartitionNumber);
02865 
02866     <span class="comment">//</span>
02867     <span class="comment">// If a data buffer was successfully allocated, deallocate it now.</span>
02868     <span class="comment">//</span>
02869 
02870     <span class="keywordflow">if</span> (buffer != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02871         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( buffer );
02872     }
02873 
02874     <span class="keywordflow">return</span> status;
02875 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a33" doxytag="drivesup.c::xHalIoWritePartitionTable" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS FASTCALL xHalIoWritePartitionTable           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>DeviceObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>SectorSize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>SectorsPerTrack</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>NumberOfHeads</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN struct _DRIVE_LAYOUT_INFORMATION *&nbsp;</td>
          <td class="mdname" nowrap> <em>PartitionBuffer</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d1/drivesup_8c-source.html#l02879">2879</a> of file <a class="el" href="../../d8/d1/drivesup_8c-source.html">drivesup.c</a>.
<p>
References <a class="el" href="../../d3/d6/hal_8h-source.html#l00157">BOOT_RECORD_SIGNATURE</a>, <a class="el" href="../../d3/d6/hal_8h-source.html#l00151">BOOT_SIGNATURE_OFFSET</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l00253">ExAllocatePoolWithTag</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00623">Executive</a>, <a class="el" href="../../d7/d2/cmwraper_8c-source.html#l00304">ExFreePool()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02030">_IO_STACK_LOCATION::Flags</a>, <a class="el" href="../../d3/d6/hal_8h-source.html#l01545">HalExamineMBR</a>, <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00546">HalpCalculateChsValues()</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l01933">IoBuildSynchronousFsdRequest()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02865">IoCallDriver</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l03398">IoGetNextIrpStackLocation</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00058">IRP_MJ_READ</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00059">IRP_MJ_WRITE</a>, <a class="el" href="../../d5/d8/ke_8h-source.html#l01066">KeInitializeEvent</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00624">KernelMode</a>, <a class="el" href="../../d2/d6/wait_8c-source.html#l00810">KeWaitForSingleObject()</a>, <a class="el" href="../../d5/d8/ex_8h.html#a329a177">NonPagedPoolCacheAligned</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d3/d6/hal_8h-source.html#l00144">NUM_PARTITION_TABLE_ENTRIES</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00599">PAGE_SIZE</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d3/d6/hal_8h-source.html#l00169">PARTITION_ACTIVE_FLAG</a>, <a class="el" href="../../d3/d6/hal_8h-source.html#l00150">PARTITION_TABLE_OFFSET</a>, <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00085">PUSHORT</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00230">SectorSize</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01874">SL_OVERRIDE_VERIFY_VOLUME</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00064">USHORT</a>, <a class="el" href="../../d2/d7/hal_8h.html#a212">VOID()</a>, <a class="el" href="../../d7/d2/drivesup_8c.html#a9">WHICH_BIT</a>, and <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00382">xHalGetPartialGeometry()</a>.
<p>
<pre class="fragment"><div>02889                    :
02890 
02891     This routine walks <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> disk writing <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partition tables from
02892     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> entries in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> partition list buffer <span class="keywordflow">for</span> each partition.
02893 
02894     Applications that create and <span class="keyword">delete</span> partitions should issue a
02895     <a class="code" href="../../d2/d7/hal_8h.html#a192">IoReadPartitionTable</a> call with <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> '<span class="keywordflow">return</span> recognized partitions'
02896     <span class="keywordtype">boolean</span> set to <span class="keyword">false</span> to get a full description of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> system.
02897 
02898     Then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> drive layout structure can be modified by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> application to
02899     reflect <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keyword">new</span> configuration of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> disk and then <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> written back
02900     to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> disk <span class="keyword">using</span> <span class="keyword">this</span> routine.
02901 
02902 Arguments:
02903 
02904     DeviceObject - Pointer to device object <span class="keywordflow">for</span> <span class="keyword">this</span> disk.
02905 
02906     <a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a> - Sector size on <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> device.
02907 
02908     SectorsPerTrack - Track size on <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> device.
02909 
02910     NumberOfHeads - Same as tracks per cylinder.
02911 
02912     PartitionBuffer - Pointer drive layout buffer.
02913 
02914 Return Value:
02915 
02916     The functional value <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> STATUS_SUCCESS <span class="keywordflow">if</span> all writes are completed
02917     without error.
02918 
02919 --*/
02920 
02921 {
02922 <span class="keyword">typedef</span> <span class="keyword">struct </span>_PARTITION_TABLE {
02923     PARTITION_INFORMATION PartitionEntry[4];
02924 } PARTITION_TABLE, *PPARTITION_TABLE;
02925 
02926 <span class="keyword">typedef</span> <span class="keyword">struct </span>_DISK_LAYOUT {
02927     ULONG TableCount;
02928     ULONG Signature;
02929     PARTITION_TABLE PartitionTable[1];
02930 } DISK_LAYOUT, *PDISK_LAYOUT;
02931 
02932 <span class="keyword">typedef</span> <span class="keyword">struct </span>_PTE {
02933     UCHAR ActiveFlag;               <span class="comment">// Bootable or not</span>
02934     UCHAR StartingTrack;            <span class="comment">// Not used</span>
02935     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> StartingCylinder;        <span class="comment">// Not used</span>
02936     UCHAR PartitionType;            <span class="comment">// 12 bit FAT, 16 bit FAT etc.</span>
02937     UCHAR EndingTrack;              <span class="comment">// Not used</span>
02938     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> EndingCylinder;          <span class="comment">// Not used</span>
02939     ULONG StartingSector;           <span class="comment">// Hidden sectors</span>
02940     ULONG PartitionLength;          <span class="comment">// Sectors in this partition</span>
02941 } PTE;
02942 <span class="keyword">typedef</span> PTE UNALIGNED *PPTE;
02943 
02944 <span class="comment">//</span>
02945 <span class="comment">// This macro has the effect of Bit = log2(Data)</span>
02946 <span class="comment">//</span>
02947 
02948 <span class="preprocessor">#define WHICH_BIT(Data, Bit) {                      \</span>
02949 <span class="preprocessor">    for (Bit = 0; Bit &lt; 32; Bit++) {                \</span>
02950 <span class="preprocessor">        if ((Data &gt;&gt; Bit) == 1) {                   \</span>
02951 <span class="preprocessor">            break;                                  \</span>
02952 <span class="preprocessor">        }                                           \</span>
02953 <span class="preprocessor">    }                                               \</span>
02954 <span class="preprocessor">}</span>
02955 <span class="preprocessor"></span>
02956     ULONG writeSize;
02957     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a22">PUSHORT</a> writeBuffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02958     PPTE partitionEntry;
02959     PPARTITION_TABLE partitionTable;
02960     CCHAR shiftCount;
02961     LARGE_INTEGER partitionTableOffset;
02962     LARGE_INTEGER nextRecordOffset;
02963     ULONG partitionTableCount;
02964     ULONG partitionEntryCount;
02965     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> event;
02966     IO_STATUS_BLOCK ioStatus;
02967     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
02968     BOOLEAN rewritePartition = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02969     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status = STATUS_SUCCESS;
02970     LARGE_INTEGER tempInt;
02971     BOOLEAN foundEZHooker = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02972     ULONG conventionalCylinders;
02973     LONGLONG diskSize;
02974 
02975     BOOLEAN isSuperFloppy = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02976 
02977     <span class="comment">//</span>
02978     <span class="comment">// Cast to a structure that is easier to use.</span>
02979     <span class="comment">//</span>
02980 
02981     PDISK_LAYOUT diskLayout = (PDISK_LAYOUT) PartitionBuffer;
02982 
02983     <span class="comment">//</span>
02984     <span class="comment">// Ensure that no one is calling this function illegally.</span>
02985     <span class="comment">//</span>
02986 
02987     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02988 
02989     <span class="comment">//</span>
02990     <span class="comment">// Determine the size of a write operation to ensure that at least 512</span>
02991     <span class="comment">// bytes are written.  This will guarantee that enough data is written to</span>
02992     <span class="comment">// include an entire partition table.  Note that this code assumes that</span>
02993     <span class="comment">// the actual sector size of the disk (if less than 512 bytes) is a</span>
02994     <span class="comment">// multiple of 2, a fairly reasonable assumption.</span>
02995     <span class="comment">//</span>
02996 
02997     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a> &gt;= 512) {
02998         writeSize = <a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a>;
02999     } <span class="keywordflow">else</span> {
03000         writeSize = 512;
03001     }
03002 
03003     <a class="code" href="../../d7/d2/drivesup_8c.html#a21">xHalGetPartialGeometry</a>( DeviceObject,
03004                             &amp;conventionalCylinders,
03005                             &amp;diskSize );
03006 
03007     <span class="comment">//</span>
03008     <span class="comment">// Look to see if this is an EZDrive Disk.  If it is then get the</span>
03009     <span class="comment">// real partititon table at 1.</span>
03010     <span class="comment">//</span>
03011 
03012     {
03013 
03014         PVOID buff;
03015 
03016         <a class="code" href="../../d2/d7/hal_8h.html#a23">HalExamineMBR</a>(
03017             DeviceObject,
03018             writeSize,
03019             (ULONG)0x55,
03020             &amp;buff
03021             );
03022 
03023         <span class="keywordflow">if</span> (buff) {
03024 
03025             foundEZHooker = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03026             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(buff);
03027             partitionTableOffset.QuadPart = 512;
03028 
03029         } <span class="keywordflow">else</span> {
03030 
03031             partitionTableOffset.QuadPart = 0;
03032 
03033         }
03034 
03035     }
03036 
03037     <span class="comment">//</span>
03038     <span class="comment">// Initialize starting variables.</span>
03039     <span class="comment">//</span>
03040 
03041     nextRecordOffset.QuadPart = 0;
03042 
03043     <span class="comment">//</span>
03044     <span class="comment">// Calculate shift count for converting between byte and sector.</span>
03045     <span class="comment">//</span>
03046 
03047     <a class="code" href="../../d7/d2/drivesup_8c.html#a9">WHICH_BIT</a>( SectorSize, shiftCount );
03048 
03049     <span class="comment">//</span>
03050     <span class="comment">// Check to see if this device is partitioned (or is being partitioned) </span>
03051     <span class="comment">// as a floppy.  Floppys have a single partititon with hidden sector count </span>
03052     <span class="comment">// and partition offset equal to zero.  If the disk is being partitioned</span>
03053     <span class="comment">// like this then we need to be sure not to write an MBR signature or </span>
03054     <span class="comment">// an NTFT signature to the media.</span>
03055     <span class="comment">//</span>
03056     <span class="comment">// NOTE: this is only to catch ourself when someone tries to write the </span>
03057     <span class="comment">// existing partition table back to disk.  Any changes to the table will </span>
03058     <span class="comment">// result in a real MBR being written out.</span>
03059     <span class="comment">//</span>
03060 
03061     <span class="keywordflow">if</span>(PartitionBuffer-&gt;PartitionCount == 1) {
03062        
03063         PPARTITION_INFORMATION partitionEntry = PartitionBuffer-&gt;PartitionEntry;
03064 
03065         <span class="keywordflow">if</span>((partitionEntry-&gt;StartingOffset.QuadPart == 0) &amp;&amp;
03066            (partitionEntry-&gt;HiddenSectors == 0)) {
03067 
03068             isSuperFloppy = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03069 
03070             <span class="comment">//</span>
03071             <span class="comment">// This would indeed appear to be an attempt to format a floppy.</span>
03072             <span class="comment">// Make sure the other parameters match the defaut values we </span>
03073             <span class="comment">// provide in ReadParititonTable.  If they don't then fail </span>
03074             <span class="comment">// the write operation.</span>
03075             <span class="comment">//</span>
03076 
03077             <span class="keywordflow">if</span>((partitionEntry-&gt;PartitionNumber != 0) ||
03078                (partitionEntry-&gt;PartitionType != PARTITION_FAT_16) ||
03079                (partitionEntry-&gt;BootIndicator == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>)) {
03080 
03081                 <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
03082             }
03083 
03084             <span class="keywordflow">if</span>(partitionEntry-&gt;RewritePartition == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
03085                 rewritePartition = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03086             }
03087 
03088             foundEZHooker = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03089         }
03090     }
03091 
03092     <span class="comment">//</span>
03093     <span class="comment">// Convert partition count to partition table or boot sector count.</span>
03094     <span class="comment">//</span>
03095 
03096     diskLayout-&gt;TableCount =
03097         (PartitionBuffer-&gt;PartitionCount +
03098         <a class="code" href="../../d2/d7/hal_8h.html#a9">NUM_PARTITION_TABLE_ENTRIES</a> - 1) /
03099         <a class="code" href="../../d2/d7/hal_8h.html#a9">NUM_PARTITION_TABLE_ENTRIES</a>;
03100 
03101     <span class="comment">//</span>
03102     <span class="comment">// Allocate a buffer for the sector writes.</span>
03103     <span class="comment">//</span>
03104 
03105     writeBuffer = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( NonPagedPoolCacheAligned, PAGE_SIZE, 'btsF');
03106 
03107     <span class="keywordflow">if</span> (writeBuffer == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03108         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
03109     }
03110 
03111     <span class="comment">//</span>
03112     <span class="comment">// Point to the partition table entries in write buffer.</span>
03113     <span class="comment">//</span>
03114 
03115     partitionEntry = (PPTE) &amp;writeBuffer[<a class="code" href="../../d2/d7/hal_8h.html#a10">PARTITION_TABLE_OFFSET</a>];
03116 
03117     <span class="keywordflow">for</span> (partitionTableCount = 0;
03118          partitionTableCount &lt; diskLayout-&gt;TableCount;
03119          partitionTableCount++) {
03120 
03121         UCHAR   partitionType;
03122 
03123         <span class="comment">//</span>
03124         <span class="comment">// the first partition table is in the mbr (physical sector 0).</span>
03125         <span class="comment">// other partition tables are in ebr's within the extended partition.</span>
03126         <span class="comment">//</span>
03127 
03128         BOOLEAN mbr = (BOOLEAN) (!partitionTableCount);
03129         LARGE_INTEGER extendedPartitionOffset;
03130 
03131         <span class="comment">//</span>
03132         <span class="comment">// Read the boot record that's already there into the write buffer</span>
03133         <span class="comment">// and save its boot code area if the signature is valid.  This way</span>
03134         <span class="comment">// we don't clobber any boot code that might be there already.</span>
03135         <span class="comment">//</span>
03136 
03137         <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;event, NotificationEvent, FALSE );
03138 
03139         irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a27">IoBuildSynchronousFsdRequest</a>( IRP_MJ_READ,
03140                                         DeviceObject,
03141                                         writeBuffer,
03142                                         writeSize,
03143                                         &amp;partitionTableOffset,
03144                                         &amp;event,
03145                                         &amp;ioStatus );
03146 
03147         <span class="keywordflow">if</span> (!irp) {
03148             status = STATUS_INSUFFICIENT_RESOURCES;
03149             <span class="keywordflow">break</span>;
03150         } <span class="keywordflow">else</span> {
03151             <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpStack;
03152             irpStack = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>(irp);
03153             irpStack-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o2">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a203">SL_OVERRIDE_VERIFY_VOLUME</a>;
03154         }
03155 
03156         status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( DeviceObject, irp );
03157 
03158         <span class="keywordflow">if</span> (status == STATUS_PENDING) {
03159             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
03160                                       Executive,
03161                                       KernelMode,
03162                                       FALSE,
03163                                       (PLARGE_INTEGER) NULL);
03164             status = ioStatus.Status;
03165         }
03166 
03167         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
03168             <span class="keywordflow">break</span>;
03169         }
03170 
03171         <span class="comment">//</span>
03172         <span class="comment">// If EZDrive is hooking the MBR then we found the first partition table</span>
03173         <span class="comment">// in sector 1 rather than 0.  However that partition table is relative</span>
03174         <span class="comment">// to sector zero.  So, Even though we got it from one, reset the partition</span>
03175         <span class="comment">// offset to 0.</span>
03176         <span class="comment">//</span>
03177 
03178         <span class="keywordflow">if</span> (foundEZHooker &amp;&amp; (partitionTableOffset.QuadPart == 512)) {
03179 
03180             partitionTableOffset.QuadPart = 0;
03181 
03182         }
03183 
03184         <span class="keywordflow">if</span>(isSuperFloppy == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
03185 
03186             <span class="comment">//</span>
03187             <span class="comment">// Write signature to last word of boot sector.</span>
03188             <span class="comment">//</span>
03189     
03190             writeBuffer[<a class="code" href="../../d2/d7/hal_8h.html#a11">BOOT_SIGNATURE_OFFSET</a>] = <a class="code" href="../../d2/d7/hal_8h.html#a12">BOOT_RECORD_SIGNATURE</a>;
03191     
03192             <span class="comment">//</span>
03193             <span class="comment">// Write NTFT disk signature if it changed and this is the MBR.</span>
03194             <span class="comment">//</span>
03195     
03196             rewritePartition = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03197             <span class="keywordflow">if</span> (partitionTableOffset.QuadPart == 0) {
03198     
03199                 <span class="keywordflow">if</span> (((PULONG)writeBuffer)[<a class="code" href="../../d2/d7/hal_8h.html#a10">PARTITION_TABLE_OFFSET</a>/2-1] !=
03200                     PartitionBuffer-&gt;Signature) {
03201     
03202                     ((PULONG) writeBuffer)[<a class="code" href="../../d2/d7/hal_8h.html#a10">PARTITION_TABLE_OFFSET</a>/2-1] =
03203                         PartitionBuffer-&gt;Signature;
03204                     rewritePartition = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03205                 }
03206             }
03207 
03208             <span class="comment">//</span>
03209             <span class="comment">// Get pointer to first partition table.</span>
03210             <span class="comment">//</span>
03211     
03212             partitionTable = &amp;diskLayout-&gt;PartitionTable[partitionTableCount];
03213     
03214             <span class="comment">//</span>
03215             <span class="comment">// Walk table to determine whether this boot record has changed</span>
03216             <span class="comment">// and update partition table in write buffer in case it needs</span>
03217             <span class="comment">// to be written out to disk.</span>
03218             <span class="comment">//</span>
03219     
03220             <span class="keywordflow">for</span> (partitionEntryCount = 0;
03221                  partitionEntryCount &lt; <a class="code" href="../../d2/d7/hal_8h.html#a9">NUM_PARTITION_TABLE_ENTRIES</a>;
03222                  partitionEntryCount++) {
03223     
03224                 partitionType =
03225                         partitionTable-&gt;PartitionEntry[partitionEntryCount].PartitionType;
03226     
03227                 <span class="comment">//</span>
03228                 <span class="comment">// If the rewrite ISN'T true then copy then just leave the data</span>
03229                 <span class="comment">// alone that is in the on-disk table.</span>
03230                 <span class="comment">//</span>
03231     
03232                 <span class="keywordflow">if</span> (partitionTable-&gt;PartitionEntry[partitionEntryCount].RewritePartition) {
03233     
03234                     <span class="comment">//</span>
03235                     <span class="comment">// This boot record needs to be written back to disk.</span>
03236                     <span class="comment">//</span>
03237     
03238                     rewritePartition = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03239     
03240                     <span class="comment">//</span>
03241                     <span class="comment">// Copy partition type from user buffer to write buffer.</span>
03242                     <span class="comment">//</span>
03243     
03244                     partitionEntry[partitionEntryCount].PartitionType =
03245                         partitionTable-&gt;PartitionEntry[partitionEntryCount].PartitionType;
03246     
03247                     <span class="comment">//</span>
03248                     <span class="comment">// Copy the partition active flag.</span>
03249                     <span class="comment">//</span>
03250     
03251                     partitionEntry[partitionEntryCount].ActiveFlag =
03252                         partitionTable-&gt;PartitionEntry[partitionEntryCount].BootIndicator ?
03253                         (UCHAR) <a class="code" href="../../d2/d7/hal_8h.html#a14">PARTITION_ACTIVE_FLAG</a> : (UCHAR) 0;
03254     
03255                     <span class="keywordflow">if</span> (partitionType != PARTITION_ENTRY_UNUSED) {
03256     
03257                         LARGE_INTEGER sectorOffset;
03258     
03259                         <span class="comment">//</span>
03260                         <span class="comment">// Calculate partition offset.</span>
03261                         <span class="comment">// If in the mbr or the entry is not a link entry, partition offset</span>
03262                         <span class="comment">// is sectors past last boot record.  Otherwise (not in the mbr and</span>
03263                         <span class="comment">// entry is a link entry), partition offset is sectors past start</span>
03264                         <span class="comment">// of extended partition.</span>
03265                         <span class="comment">//</span>
03266     
03267                         <span class="keywordflow">if</span> (mbr || !IsContainerPartition(partitionType)) {
03268                             tempInt.QuadPart = partitionTableOffset.QuadPart;
03269                         } <span class="keywordflow">else</span> {
03270                             tempInt.QuadPart = extendedPartitionOffset.QuadPart;
03271                         }
03272     
03273                         sectorOffset.QuadPart =
03274                             partitionTable-&gt;PartitionEntry[partitionEntryCount].StartingOffset.QuadPart -
03275                             tempInt.QuadPart;
03276     
03277                         tempInt.QuadPart = sectorOffset.QuadPart &gt;&gt; shiftCount;
03278                         partitionEntry[partitionEntryCount].StartingSector = tempInt.LowPart;
03279     
03280                         <span class="comment">//</span>
03281                         <span class="comment">// Calculate partition length.</span>
03282                         <span class="comment">//</span>
03283     
03284                         tempInt.QuadPart = partitionTable-&gt;PartitionEntry[partitionEntryCount].PartitionLength.QuadPart &gt;&gt; shiftCount;
03285                         partitionEntry[partitionEntryCount].PartitionLength = tempInt.LowPart;
03286     
03287                         <span class="comment">//</span>
03288                         <span class="comment">// Fill in CHS values</span>
03289                         <span class="comment">//</span>
03290     
03291                         <a class="code" href="../../d7/d2/drivesup_8c.html#a18">HalpCalculateChsValues</a>(
03292                             &amp;partitionTable-&gt;PartitionEntry[partitionEntryCount].StartingOffset,
03293                             &amp;partitionTable-&gt;PartitionEntry[partitionEntryCount].PartitionLength,
03294                             shiftCount,
03295                             SectorsPerTrack,
03296                             NumberOfHeads,
03297                             conventionalCylinders,
03298                             (<a class="code" href="../../d5/d8/struct__PARTITION__DESCRIPTOR.html">PPARTITION_DESCRIPTOR</a>) &amp;partitionEntry[partitionEntryCount]);
03299     
03300                     } <span class="keywordflow">else</span> {
03301     
03302                         <span class="comment">//</span>
03303                         <span class="comment">// Zero out partition entry fields in case an entry</span>
03304                         <span class="comment">// was deleted.</span>
03305                         <span class="comment">//</span>
03306     
03307                         partitionEntry[partitionEntryCount].StartingSector = 0;
03308                         partitionEntry[partitionEntryCount].PartitionLength = 0;
03309                         partitionEntry[partitionEntryCount].StartingTrack = 0;
03310                         partitionEntry[partitionEntryCount].EndingTrack = 0;
03311                         partitionEntry[partitionEntryCount].StartingCylinder = 0;
03312                         partitionEntry[partitionEntryCount].EndingCylinder = 0;
03313                     }
03314     
03315                 }
03316     
03317                 <span class="keywordflow">if</span> (IsContainerPartition(partitionType)) {
03318     
03319                     <span class="comment">//</span>
03320                     <span class="comment">// Save next record offset.</span>
03321                     <span class="comment">//</span>
03322     
03323                     nextRecordOffset =
03324                         partitionTable-&gt;PartitionEntry[partitionEntryCount].StartingOffset;
03325                 }
03326     
03327             } <span class="comment">// end for partitionEntryCount ...</span>
03328 
03329         } <span class="keywordflow">else</span> {
03330 
03331             <span class="comment">//</span>
03332             <span class="comment">// If there's an 0xaa55 in the MBR signature, clear it out.  </span>
03333             <span class="comment">//</span>
03334 
03335             <span class="comment">//</span>
03336             <span class="comment">// BUGBUG - don't do this.</span>
03337             <span class="comment">//</span>
03338 
03339             <span class="keywordflow">if</span>(writeBuffer[<a class="code" href="../../d2/d7/hal_8h.html#a11">BOOT_SIGNATURE_OFFSET</a>] == <a class="code" href="../../d2/d7/hal_8h.html#a12">BOOT_RECORD_SIGNATURE</a>) {
03340                 <span class="comment">// writeBuffer[BOOT_SIGNATURE_OFFSET] += 0x1111;</span>
03341             }
03342         }
03343     
03344         <span class="keywordflow">if</span> (rewritePartition == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
03345 
03346             rewritePartition = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03347 
03348             <span class="comment">//</span>
03349             <span class="comment">// Create a notification event object to be used while waiting for</span>
03350             <span class="comment">// the write request to complete.</span>
03351             <span class="comment">//</span>
03352 
03353             <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;event, NotificationEvent, FALSE );
03354 
03355             <span class="keywordflow">if</span> (foundEZHooker &amp;&amp; (partitionTableOffset.QuadPart == 0)) {
03356 
03357                 partitionTableOffset.QuadPart = 512;
03358 
03359             }
03360             irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a27">IoBuildSynchronousFsdRequest</a>( IRP_MJ_WRITE,
03361                                             DeviceObject,
03362                                             writeBuffer,
03363                                             writeSize,
03364                                             &amp;partitionTableOffset,
03365                                             &amp;event,
03366                                             &amp;ioStatus );
03367 
03368             <span class="keywordflow">if</span> (!irp) {
03369                 status = STATUS_INSUFFICIENT_RESOURCES;
03370                 <span class="keywordflow">break</span>;
03371             } <span class="keywordflow">else</span> {
03372                 <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpStack;
03373                 irpStack = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>(irp);
03374                 irpStack-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o2">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a203">SL_OVERRIDE_VERIFY_VOLUME</a>;
03375             }
03376 
03377             status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( DeviceObject, irp );
03378 
03379             <span class="keywordflow">if</span> (status == STATUS_PENDING) {
03380                 (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
03381                                           Executive,
03382                                           KernelMode,
03383                                           FALSE,
03384                                           (PLARGE_INTEGER) NULL);
03385                 status = ioStatus.Status;
03386             }
03387 
03388             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
03389                 <span class="keywordflow">break</span>;
03390             }
03391 
03392 
03393             <span class="keywordflow">if</span> (foundEZHooker &amp;&amp; (partitionTableOffset.QuadPart == 512)) {
03394 
03395                 partitionTableOffset.QuadPart = 0;
03396 
03397             }
03398 
03399         } <span class="comment">// end if (reWrite ...</span>
03400 
03401         <span class="comment">//</span>
03402         <span class="comment">// Update partitionTableOffset to next boot record offset</span>
03403         <span class="comment">//</span>
03404 
03405         partitionTableOffset = nextRecordOffset;
03406         <span class="keywordflow">if</span>(mbr) {
03407             extendedPartitionOffset = nextRecordOffset;
03408         }
03409 
03410     } <span class="comment">// end for partitionTableCount ...</span>
03411 
03412     <span class="comment">//</span>
03413     <span class="comment">// Deallocate write buffer if it was allocated it.</span>
03414     <span class="comment">//</span>
03415 
03416     <span class="keywordflow">if</span> (writeBuffer != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03417         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( writeBuffer );
03418     }
03419 
03420     <span class="keywordflow">return</span> status;
03421 }

</div></pre>    </td>
  </tr>
</table>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="a15" doxytag="drivesup.c::DiskPartitionName" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> PUCHAR <a class="el" href="../../d7/d2/drivesup_8c.html#a15">DiskPartitionName</a> = "\\Device\\Harddisk%d\\Partition%d"<code> [static]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00091">91</a> of file <a class="el" href="../../d8/d1/drivesup_8c-source.html">drivesup.c</a>.
<p>
Referenced by <a class="el" href="../../d8/d1/drivesup_8c-source.html#l01243">xHalIoAssignDriveLetters()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="drivesup.c::DrivesupBreakIn" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG <a class="el" href="../../d7/d2/drivesup_8c.html#a12">DrivesupBreakIn</a> = FALSE          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00043">43</a> of file <a class="el" href="../../d8/d1/drivesup_8c-source.html">drivesup.c</a>.
<p>
Referenced by <a class="el" href="../../d8/d1/drivesup_8c-source.html#l01739">xHalIoReadPartitionTable()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="drivesup.c::DrivesupDebug" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG <a class="el" href="../../d7/d2/drivesup_8c.html#a11">DrivesupDebug</a> = 0          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00042">42</a> of file <a class="el" href="../../d8/d1/drivesup_8c-source.html">drivesup.c</a>.
<p>
Referenced by <a class="el" href="../../d8/d1/drivesup_8c-source.html#l03882">DrivesupDebugPrint()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a16" doxytag="drivesup.c::RegistryKeyName" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> PUCHAR <a class="el" href="../../d7/d2/drivesup_8c.html#a16">RegistryKeyName</a> = DISK_REGISTRY_KEY<code> [static]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d1/drivesup_8c-source.html#l00092">92</a> of file <a class="el" href="../../d8/d1/drivesup_8c-source.html">drivesup.c</a>.    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:43:30 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
