<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: obdir.c File Reference</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>obdir.c File Reference</h1><code>#include "<a class="el" href="../../d6/d0/obp_8h-source.html">obp.h</a>"</code><br>

<p>
<a href="../../d9/d9/obdir_8c-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d0/obdir_8c.html#a0">NtCreateDirectoryObject</a> (OUT PHANDLE <a class="el" href="../../d3/d3/tob_8c.html#a23">DirectoryHandle</a>, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES <a class="el" href="../../d8/d0/ctlpcqos_8c.html#a1">ObjectAttributes</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d0/obdir_8c.html#a1">NtOpenDirectoryObject</a> (OUT PHANDLE <a class="el" href="../../d3/d3/tob_8c.html#a23">DirectoryHandle</a>, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES <a class="el" href="../../d8/d0/ctlpcqos_8c.html#a1">ObjectAttributes</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d0/obdir_8c.html#a2">NtQueryDirectoryObject</a> (IN HANDLE <a class="el" href="../../d3/d3/tob_8c.html#a23">DirectoryHandle</a>, OUT PVOID <a class="el" href="../../d8/d6/ttri_8c.html#a3">Buffer</a>, IN ULONG Length, IN BOOLEAN ReturnSingleEntry, IN BOOLEAN RestartScan, IN OUT PULONG Context, OUT PULONG ReturnLength OPTIONAL)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>PVOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d0/obdir_8c.html#a3">ObpLookupDirectoryEntry</a> (IN <a class="el" href="../../d8/d4/struct__OBJECT__DIRECTORY.html">POBJECT_DIRECTORY</a> Directory, IN PUNICODE_STRING <a class="el" href="../../d9/d3/rules_8c.html#a6">Name</a>, IN ULONG Attributes)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d0/obdir_8c.html#a4">ObpInsertDirectoryEntry</a> (IN <a class="el" href="../../d8/d4/struct__OBJECT__DIRECTORY.html">POBJECT_DIRECTORY</a> Directory, IN PVOID Object)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d0/obdir_8c.html#a5">ObpDeleteDirectoryEntry</a> (IN <a class="el" href="../../d8/d4/struct__OBJECT__DIRECTORY.html">POBJECT_DIRECTORY</a> Directory)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d0/obdir_8c.html#a6">ObpLookupObjectName</a> (IN HANDLE RootDirectoryHandle OPTIONAL, IN PUNICODE_STRING ObjectName, IN ULONG Attributes, IN <a class="el" href="../../d3/d6/struct__OBJECT__TYPE.html">POBJECT_TYPE</a> ObjectType, IN <a class="el" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> AccessMode, IN PVOID ParseContext OPTIONAL, IN PSECURITY_QUALITY_OF_SERVICE <a class="el" href="../../d8/d0/ctlpcqos_8c.html#a9">SecurityQos</a> OPTIONAL, IN PVOID InsertObject OPTIONAL, IN OUT <a class="el" href="../../d2/d5/struct__ACCESS__STATE.html">PACCESS_STATE</a> AccessState, OUT PBOOLEAN DirectoryLocked, OUT PVOID *FoundObject)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a0" doxytag="obdir.c::NtCreateDirectoryObject" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS NtCreateDirectoryObject           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OUT PHANDLE&nbsp;</td>
          <td class="mdname" nowrap> <em>DirectoryHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ACCESS_MASK&nbsp;</td>
          <td class="mdname" nowrap> <em>DesiredAccess</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN POBJECT_ATTRIBUTES&nbsp;</td>
          <td class="mdname" nowrap> <em>ObjectAttributes</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d9/obdir_8c-source.html#l00032">32</a> of file <a class="el" href="../../d9/d9/obdir_8c-source.html">obdir.c</a>.
<p>
References <a class="el" href="../../d3/d4/editreg_8c-source.html#l00903">Directory()</a>, <a class="el" href="../../d4/d2/tob_8c-source.html#l00063">DirectoryHandle</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00055">EXCEPTION_EXECUTE_HANDLER</a>, <a class="el" href="../../d8/d9/cmdat2_8c-source.html#l00091">Handle</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00624">KernelMode</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00174">KPROCESSOR_MODE</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d7/d9/obcreate_8c-source.html#l00055">ObCreateObject()</a>, <a class="el" href="../../d2/d0/obinsert_8c-source.html#l00029">ObInsertObject()</a>, <a class="el" href="../../d8/d9/ctlnpqos_8c-source.html#l00027">ObjectAttributes</a>, <a class="el" href="../../d6/d0/obp_8h-source.html#l00367">ObpDirectoryObjectType</a>, <a class="el" href="../../d6/d0/obp_8h-source.html#l00071">ObpValidateIrql</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l01564">ProbeForWriteHandle</a>, and <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>.
<p>
Referenced by <a class="el" href="../../d8/d8/uob_8c-source.html#l00039">DumpObjectDirs()</a>, <a class="el" href="../../d3/d3/ex_2callback_8c-source.html#l00101">ExpInitializeCallbacks()</a>, <a class="el" href="../../d0/d5/ioinit_8c-source.html#l02155">IopCreateRootDirectories()</a>, <a class="el" href="../../d1/d0/obinit_8c-source.html#l00117">ObInitSystem()</a>, <a class="el" href="../../d1/d0/obinit_8c-source.html#l01349">ObpCreateDosDevicesDirectory()</a>, <a class="el" href="../../d4/d2/tob_8c-source.html#l00187">obtest()</a>, <a class="el" href="../../d0/d5/seinit_8c-source.html#l00184">SepInitializationPhase1()</a>, and <a class="el" href="../../d8/d8/uob_8c-source.html#l00232">TestParent()</a>.
<p>
<pre class="fragment"><div>00040                    :
00041 
00042     This routine creates a <span class="keyword">new</span> directory object according to user
00043     specified object attributes
00044 
00045 Arguments:
00046 
00047     <a class="code" href="../../d3/d3/tob_8c.html#a23">DirectoryHandle</a> - Receives <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> handle <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> newly created
00048         directory object
00049 
00050     DesiredAccess - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> access being requested <span class="keywordflow">for</span> <span class="keyword">this</span>
00051         <span class="keyword">new</span> directory object
00052 
00053     <a class="code" href="../../d7/d0/ctlnpqos_8c.html#a4">ObjectAttributes</a> - Supplies caller specified attributes <span class="keywordflow">for</span> <span class="keyword">new</span>
00054         directory object
00055 
00056 Return Value:
00057 
00058     An appropriate status value.
00059 
00060 --*/
00061 
00062 {
00063     <a class="code" href="../../d8/d4/struct__OBJECT__DIRECTORY.html">POBJECT_DIRECTORY</a> <a class="code" href="../../d2/d5/editreg_8c.html#a68">Directory</a>;
00064     HANDLE <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>;
00065     <a class="code" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> PreviousMode;
00066     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00067 
00068     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00069 
00070     <a class="code" href="../../d5/d1/obp_8h.html#a2">ObpValidateIrql</a>( <span class="stringliteral">"NtCreateDirectoryObject"</span> );
00071 
00072     <span class="comment">//</span>
00073     <span class="comment">//  Get previous processor mode and probe output arguments if necessary.</span>
00074     <span class="comment">//</span>
00075 
00076     PreviousMode = KeGetPreviousMode();
00077 
00078     <span class="keywordflow">if</span> (PreviousMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
00079 
00080         <span class="keywordflow">try</span> {
00081 
00082             <a class="code" href="../../d5/d8/ex_8h.html#a35">ProbeForWriteHandle</a>( DirectoryHandle );
00083 
00084         } except( EXCEPTION_EXECUTE_HANDLER ) {
00085 
00086             <span class="keywordflow">return</span>( GetExceptionCode() );
00087         }
00088     }
00089 
00090     <span class="comment">//</span>
00091     <span class="comment">//  Allocate and initialize a new Directory Object.  We don't need</span>
00092     <span class="comment">//  to specify a parse context or charge any quota.  The size of</span>
00093     <span class="comment">//  the object body is simply a directory object.  This call gets</span>
00094     <span class="comment">//  us a new referenced object.</span>
00095     <span class="comment">//</span>
00096 
00097     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d0/obcreate_8c.html#a5">ObCreateObject</a>( PreviousMode,
00098                              ObpDirectoryObjectType,
00099                              ObjectAttributes,
00100                              PreviousMode,
00101                              NULL,
00102                              <span class="keyword">sizeof</span>( *Directory ),
00103                              0,
00104                              0,
00105                              (PVOID *)&amp;Directory );
00106 
00107     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
00108 
00109         <span class="keywordflow">return</span>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
00110     }
00111 
00112     RtlZeroMemory( Directory, <span class="keyword">sizeof</span>( *Directory ) );
00113 
00114     <span class="comment">//</span>
00115     <span class="comment">//  Insert directory object in the current processes handle table,</span>
00116     <span class="comment">//  set directory handle value and return status.</span>
00117     <span class="comment">//</span>
00118     <span class="comment">//  **** If the insert fails should we backout the create?</span>
00119     <span class="comment">//</span>
00120 
00121     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d1/d1/obinsert_8c.html#a0">ObInsertObject</a>( Directory,
00122                              NULL,
00123                              DesiredAccess,
00124                              0,
00125                              (PVOID *)NULL,
00126                              &amp;Handle );
00127 
00128     <span class="keywordflow">try</span> {
00129 
00130         *<a class="code" href="../../d3/d3/tob_8c.html#a23">DirectoryHandle</a> = <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>;
00131 
00132     } except( EXCEPTION_EXECUTE_HANDLER ) {
00133 
00134         <span class="comment">//</span>
00135         <span class="comment">//  Fall through, since we do not want to undo what we have done.</span>
00136         <span class="comment">//</span>
00137     }
00138 
00139     <span class="keywordflow">return</span>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
00140 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="obdir.c::NtOpenDirectoryObject" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS NtOpenDirectoryObject           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">OUT PHANDLE&nbsp;</td>
          <td class="mdname" nowrap> <em>DirectoryHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ACCESS_MASK&nbsp;</td>
          <td class="mdname" nowrap> <em>DesiredAccess</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN POBJECT_ATTRIBUTES&nbsp;</td>
          <td class="mdname" nowrap> <em>ObjectAttributes</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d9/obdir_8c-source.html#l00144">144</a> of file <a class="el" href="../../d9/d9/obdir_8c-source.html">obdir.c</a>.
<p>
References <a class="el" href="../../d4/d2/tob_8c-source.html#l00063">DirectoryHandle</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00055">EXCEPTION_EXECUTE_HANDLER</a>, <a class="el" href="../../d8/d9/cmdat2_8c-source.html#l00091">Handle</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00624">KernelMode</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00174">KPROCESSOR_MODE</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d8/d9/ctlnpqos_8c-source.html#l00027">ObjectAttributes</a>, <a class="el" href="../../d8/d0/obref_8c-source.html#l00095">ObOpenObjectByName()</a>, <a class="el" href="../../d6/d0/obp_8h-source.html#l00367">ObpDirectoryObjectType</a>, <a class="el" href="../../d6/d0/obp_8h-source.html#l00071">ObpValidateIrql</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l01564">ProbeForWriteHandle</a>, and <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>.
<p>
Referenced by <a class="el" href="../../d3/d7/api_8c-source.html#l01169">CleanupSessionObjectDirectories()</a>, <a class="el" href="../../d4/d7/client_8c-source.html#l02154">CommonCreateWindowStation()</a>, <a class="el" href="../../d4/d7/client_8c-source.html#l02336">CommonOpenWindowStation()</a>, <a class="el" href="../../d9/d1/ldrinit_8c-source.html#l00616">LdrpInitializeProcess()</a>, <a class="el" href="../../d4/d7/symtest_8c-source.html#l00007">main()</a>, <a class="el" href="../../d8/d8/uob_8c-source.html#l00624">TestChild()</a>, and <a class="el" href="../../d8/d8/uob_8c-source.html#l00232">TestParent()</a>.
<p>
<pre class="fragment"><div>00152                    :
00153 
00154     This routine opens an existing directory object.
00155 
00156 Arguments:
00157 
00158     <a class="code" href="../../d3/d3/tob_8c.html#a23">DirectoryHandle</a> - Receives <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> handle <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> newly opened directory
00159         object
00160 
00161     DesiredAccess - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> access being requested <span class="keywordflow">for</span> <span class="keyword">this</span>
00162         directory object
00163 
00164     <a class="code" href="../../d7/d0/ctlnpqos_8c.html#a4">ObjectAttributes</a> - Supplies caller specified attributes <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00165         directory object
00166 
00167 Return Value:
00168 
00169     An appropriate status value.
00170 
00171 --*/
00172 
00173 {
00174     <a class="code" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> PreviousMode;
00175     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00176     HANDLE <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>;
00177 
00178     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00179 
00180     <a class="code" href="../../d5/d1/obp_8h.html#a2">ObpValidateIrql</a>( <span class="stringliteral">"NtOpenDirectoryObject"</span> );
00181 
00182     <span class="comment">//</span>
00183     <span class="comment">//  Get previous processor mode and probe output arguments if necessary.</span>
00184     <span class="comment">//</span>
00185 
00186     PreviousMode = KeGetPreviousMode();
00187 
00188     <span class="keywordflow">if</span> (PreviousMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
00189 
00190         <span class="keywordflow">try</span> {
00191 
00192             <a class="code" href="../../d5/d8/ex_8h.html#a35">ProbeForWriteHandle</a>( DirectoryHandle );
00193 
00194         } except( EXCEPTION_EXECUTE_HANDLER ) {
00195 
00196             <span class="keywordflow">return</span>( GetExceptionCode() );
00197         }
00198     }
00199 
00200     <span class="comment">//</span>
00201     <span class="comment">//  Open handle to the directory object with the specified desired access,</span>
00202     <span class="comment">//  set directory handle value, and return service completion status.</span>
00203     <span class="comment">//</span>
00204 
00205     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d7/d1/obref_8c.html#a2">ObOpenObjectByName</a>( ObjectAttributes,
00206                                  ObpDirectoryObjectType,
00207                                  PreviousMode,
00208                                  NULL,
00209                                  DesiredAccess,
00210                                  NULL,
00211                                  &amp;Handle );
00212 
00213     <span class="keywordflow">try</span> {
00214 
00215         *<a class="code" href="../../d3/d3/tob_8c.html#a23">DirectoryHandle</a> = <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>;
00216 
00217     } except( EXCEPTION_EXECUTE_HANDLER ) {
00218 
00219         <span class="comment">//</span>
00220         <span class="comment">//  Fall through, since we do not want to undo what we have done.</span>
00221         <span class="comment">//</span>
00222     }
00223 
00224     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00225 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="obdir.c::NtQueryDirectoryObject" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS NtQueryDirectoryObject           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN HANDLE&nbsp;</td>
          <td class="mdname" nowrap> <em>DirectoryHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>ReturnSingleEntry</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>RestartScan</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT PULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Context</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PULONG ReturnLength&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d9/obdir_8c-source.html#l00229">229</a> of file <a class="el" href="../../d9/d9/obdir_8c-source.html">obdir.c</a>.
<p>
References <a class="el" href="../../d7/d1/rtqkey_8c-source.html#l00042">Buffer</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00220">_OBJECT_DIRECTORY_ENTRY::ChainLink</a>, <a class="el" href="../../d3/d4/editreg_8c-source.html#l00903">Directory()</a>, <a class="el" href="../../d4/d2/tob_8c-source.html#l00063">DirectoryHandle</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l00253">ExAllocatePoolWithTag</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00055">EXCEPTION_EXECUTE_HANDLER</a>, <a class="el" href="../../d7/d2/cmwraper_8c-source.html#l00304">ExFreePool()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00624">KernelMode</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00174">KPROCESSOR_MODE</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00189">_OBJECT_TYPE::Name</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00332">_OBJECT_HEADER_NAME_INFO::Name</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00206">NUMBER_HASH_BUCKETS</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00494">ObDereferenceObject</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00221">_OBJECT_DIRECTORY_ENTRY::Object</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00368">OBJECT_HEADER_TO_NAME_INFO</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00355">OBJECT_TO_OBJECT_HEADER</a>, <a class="el" href="../../d6/d0/obp_8h-source.html#l00367">ObpDirectoryObjectType</a>, <a class="el" href="../../d6/d0/obp_8h-source.html#l00189">ObpEnterRootDirectoryMutex</a>, <a class="el" href="../../d6/d0/obp_8h-source.html#l00424">ObpIsOverflow</a>, <a class="el" href="../../d6/d0/obp_8h-source.html#l00202">ObpLeaveRootDirectoryMutex</a>, <a class="el" href="../../d6/d0/obp_8h-source.html#l00071">ObpValidateIrql</a>, <a class="el" href="../../d8/d0/obref_8c-source.html#l00542">ObReferenceObjectByHandle()</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>, <a class="el" href="../../d0/d4/probe_8c-source.html#l00034">ProbeForWrite()</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l01649">ProbeForWriteUlong</a>, <a class="el" href="../../d3/d6/string_8c-source.html#l00148">RtlInitUnicodeString()</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00302">_OBJECT_HEADER::Type</a>, and <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00064">USHORT</a>.
<p>
Referenced by <a class="el" href="../../d3/d7/api_8c-source.html#l01169">CleanupSessionObjectDirectories()</a>, and <a class="el" href="../../d8/d8/uob_8c-source.html#l00039">DumpObjectDirs()</a>.
<p>
<pre class="fragment"><div>00241                    :
00242 
00243     This function returns information regarding a specified object
00244     directory.
00245 
00246 Arguments:
00247 
00248     <a class="code" href="../../d3/d3/tob_8c.html#a23">DirectoryHandle</a> - Supplies a handle to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> directory being queried
00249 
00250     <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> output buffer to receive <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> directory
00251         information.  On <span class="keywordflow">return</span> <span class="keyword">this</span> contains one or more OBJECT DIRECTORY
00252         INFORMATION structures, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> last one being null.  And then <span class="keyword">this</span> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
00253         followed by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> string names <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> directory entries.
00254 
00255     Length - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> length, in bytes, of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> user supplied output
00256         buffer
00257 
00258     ReturnSingleEntry - Indicates <span class="keywordflow">if</span> <span class="keyword">this</span> routine should just <span class="keywordflow">return</span>
00259         one entry in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> directory
00260 
00261     RestartScan - Indicates <span class="keywordflow">if</span> we are to restart <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> scan or <span class="keywordflow">continue</span>
00262         relative to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> enumeration context passed in as <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> next
00263         parameter
00264 
00265     Context - Supplies an enumeration context that must be resupplied
00266         to <span class="keyword">this</span> routine on subsequent calls to keep <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> enumeration
00267         in sync
00268 
00269     ReturnLength - Optionally receives <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> length, in bytes, that <span class="keyword">this</span>
00270         routine has stuffed into <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> output buffer
00271 
00272 Return Value:
00273 
00274     An appropriate status value.
00275 
00276 --*/
00277 
00278 {
00279     <a class="code" href="../../d8/d4/struct__OBJECT__DIRECTORY.html">POBJECT_DIRECTORY</a> <a class="code" href="../../d2/d5/editreg_8c.html#a68">Directory</a>;
00280     <a class="code" href="../../d9/d4/struct__OBJECT__DIRECTORY__ENTRY.html">POBJECT_DIRECTORY_ENTRY</a> DirectoryEntry;
00281     <a class="code" href="../../d4/d5/struct__OBJECT__HEADER.html">POBJECT_HEADER</a> ObjectHeader;
00282     <a class="code" href="../../d0/d6/struct__OBJECT__HEADER__NAME__INFO.html">POBJECT_HEADER_NAME_INFO</a> NameInfo;
00283     UNICODE_STRING ObjectName;
00284     POBJECT_DIRECTORY_INFORMATION DirInfo;
00285     PWCH NameBuffer;
00286     <a class="code" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> PreviousMode;
00287     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00288     ULONG Bucket, EntryNumber, CapturedContext;
00289     ULONG TotalLengthNeeded, LengthNeeded, EntriesFound;
00290     PCHAR TempBuffer;
00291 
00292     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00293 
00294     <a class="code" href="../../d5/d1/obp_8h.html#a2">ObpValidateIrql</a>( <span class="stringliteral">"NtQueryDirectoryObject"</span> );
00295 
00296     <span class="comment">//</span>
00297     <span class="comment">//  Get previous processor mode and probe output arguments if necessary.</span>
00298     <span class="comment">//</span>
00299 
00300     PreviousMode = KeGetPreviousMode();
00301 
00302     <span class="keywordflow">if</span> (PreviousMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
00303 
00304         <span class="keywordflow">try</span> {
00305 
00306             <a class="code" href="../../d5/d8/ex_8h.html#a259">ProbeForWrite</a>( Buffer, Length, <span class="keyword">sizeof</span>( WCHAR ) );
00307             <a class="code" href="../../d5/d8/ex_8h.html#a40">ProbeForWriteUlong</a>( Context );
00308 
00309             <span class="keywordflow">if</span> (ARGUMENT_PRESENT( ReturnLength )) {
00310 
00311                 <a class="code" href="../../d5/d8/ex_8h.html#a40">ProbeForWriteUlong</a>( ReturnLength );
00312             }
00313 
00314             <span class="keywordflow">if</span> (RestartScan) {
00315 
00316                 CapturedContext = 0;
00317 
00318             } <span class="keywordflow">else</span> {
00319 
00320                 CapturedContext = *Context;
00321             }
00322 
00323         } except( EXCEPTION_EXECUTE_HANDLER ) {
00324 
00325             <span class="keywordflow">return</span>( GetExceptionCode() );
00326         }
00327 
00328     } <span class="keywordflow">else</span> {
00329 
00330         <span class="keywordflow">if</span> (RestartScan) {
00331 
00332             CapturedContext = 0;
00333 
00334         } <span class="keywordflow">else</span> {
00335 
00336             CapturedContext = *Context;
00337         }
00338     }
00339 
00340     <span class="comment">//</span>
00341     <span class="comment">//  Allocate space for a temporary work buffer, make sure we got it,</span>
00342     <span class="comment">//  and then zero it out.  Make sure the buffer is large enough to</span>
00343     <span class="comment">//  hold at least one dir info record.  This will make the logic work</span>
00344     <span class="comment">//  better when the a bad length is passed in.</span>
00345     <span class="comment">//</span>
00346 
00347 
00348     <span class="comment">//</span>
00349     <span class="comment">//  Test for 64 bit if Length + sizeof( OBJECT_DIRECTORY_INFORMATION ) is less than Length</span>
00350     <span class="comment">//  Return STATUS_INVALID_PARAMETER if there is an overflow</span>
00351     <span class="comment">//</span>
00352 
00353     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d1/obp_8h.html#a28">ObpIsOverflow</a>( Length, <span class="keyword">sizeof</span>( OBJECT_DIRECTORY_INFORMATION ))) {
00354 
00355         <span class="keywordflow">return</span>( STATUS_INVALID_PARAMETER );
00356     }
00357 
00358     TempBuffer = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( PagedPool,
00359                                         Length + <span class="keyword">sizeof</span>( OBJECT_DIRECTORY_INFORMATION ),
00360                                         'mNbO' );
00361 
00362     <span class="keywordflow">if</span> (TempBuffer == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00363 
00364         <span class="keywordflow">return</span>( STATUS_INSUFFICIENT_RESOURCES );
00365     }
00366 
00367     RtlZeroMemory( TempBuffer, Length );
00368 
00369     <span class="comment">//</span>
00370     <span class="comment">//  Reference the directory object</span>
00371     <span class="comment">//</span>
00372 
00373     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a>( DirectoryHandle,
00374                                         DIRECTORY_QUERY,
00375                                         ObpDirectoryObjectType,
00376                                         PreviousMode,
00377                                         (PVOID *)&amp;Directory,
00378                                         NULL );
00379 
00380     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
00381 
00382         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( TempBuffer );
00383 
00384         <span class="keywordflow">return</span>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
00385     }
00386 
00387     <span class="comment">//</span>
00388     <span class="comment">//  Lock down the directory structures for the life of this</span>
00389     <span class="comment">//  procedure</span>
00390     <span class="comment">//</span>
00391 
00392     <a class="code" href="../../d5/d1/obp_8h.html#a10">ObpEnterRootDirectoryMutex</a>();
00393 
00394     <span class="comment">//</span>
00395     <span class="comment">//  DirInfo is used to march through the output buffer filling</span>
00396     <span class="comment">//  in directory information.  We'll start off by making sure</span>
00397     <span class="comment">//  there is room for a NULL entry at end.</span>
00398     <span class="comment">//</span>
00399 
00400     DirInfo = (POBJECT_DIRECTORY_INFORMATION)TempBuffer;
00401 
00402     TotalLengthNeeded = <span class="keyword">sizeof</span>( *DirInfo );
00403 
00404     <span class="comment">//</span>
00405     <span class="comment">//  Keep track of the number of entries found and actual</span>
00406     <span class="comment">//  entry that we are processing</span>
00407     <span class="comment">//</span>
00408 
00409     EntryNumber = 0;
00410     EntriesFound = 0;
00411 
00412     <span class="comment">//</span>
00413     <span class="comment">//  By default we'll say there are no more entries until the</span>
00414     <span class="comment">//  following loop put in some data</span>
00415     <span class="comment">//</span>
00416 
00417     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_NO_MORE_ENTRIES;
00418 
00419     <span class="comment">//</span>
00420     <span class="comment">//  Our outer loop processes each hash bucket in the directory object</span>
00421     <span class="comment">//</span>
00422 
00423     <span class="keywordflow">for</span> (Bucket=0; Bucket&lt;<a class="code" href="../../d4/d0/ob_8h.html#a0">NUMBER_HASH_BUCKETS</a>; Bucket++) {
00424 
00425         DirectoryEntry = <a class="code" href="../../d2/d5/editreg_8c.html#a68">Directory</a>-&gt;HashBuckets[ Bucket ];
00426 
00427         <span class="comment">//</span>
00428         <span class="comment">//  For this hash bucket we'll zip through its list of entries.</span>
00429         <span class="comment">//  This is a singly linked list so when the next pointer is null</span>
00430         <span class="comment">//  (i.e., false) we at the end of the hash list</span>
00431         <span class="comment">//</span>
00432 
00433         <span class="keywordflow">while</span> (DirectoryEntry) {
00434 
00435             <span class="comment">//</span>
00436             <span class="comment">//  The captured context is simply the entry count unless the</span>
00437             <span class="comment">//  user specified otherwise we start at zero, which means</span>
00438             <span class="comment">//  the first entry is always returned in the enumeration.</span>
00439             <span class="comment">//  If we have an match based on the entry index then we</span>
00440             <span class="comment">//  process this entry.  We bump the captured context further</span>
00441             <span class="comment">//  done in the code.</span>
00442             <span class="comment">//</span>
00443 
00444             <span class="keywordflow">if</span> (CapturedContext == EntryNumber++) {
00445 
00446                 <span class="comment">//</span>
00447                 <span class="comment">//  For this directory entry we'll get a pointer to the</span>
00448                 <span class="comment">//  object body and see if it has an object name.  If it</span>
00449                 <span class="comment">//  doesn't have a name then we'll give it an empty name.</span>
00450                 <span class="comment">//</span>
00451 
00452                 ObjectHeader = <a class="code" href="../../d4/d0/ob_8h.html#a8">OBJECT_TO_OBJECT_HEADER</a>( DirectoryEntry-&gt;<a class="code" href="../../d9/d4/struct__OBJECT__DIRECTORY__ENTRY.html#o1">Object</a> );
00453                 NameInfo = <a class="code" href="../../d4/d0/ob_8h.html#a12">OBJECT_HEADER_TO_NAME_INFO</a>( ObjectHeader );
00454 
00455                 <span class="keywordflow">if</span> (NameInfo != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00456 
00457                     ObjectName = NameInfo-&gt;<a class="code" href="../../d0/d6/struct__OBJECT__HEADER__NAME__INFO.html#o1">Name</a>;
00458 
00459                 } <span class="keywordflow">else</span> {
00460 
00461                     <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>( &amp;ObjectName, NULL );
00462                 }
00463 
00464                 <span class="comment">//</span>
00465                 <span class="comment">//  Now compute the length needed for this entry.  This would</span>
00466                 <span class="comment">//  be the size of the object directory information record,</span>
00467                 <span class="comment">//  plus the size of the object name and object type name both</span>
00468                 <span class="comment">//  null terminated.</span>
00469                 <span class="comment">//</span>
00470 
00471                 LengthNeeded = <span class="keyword">sizeof</span>( *DirInfo ) +
00472                                ObjectName.Length + <span class="keyword">sizeof</span>( UNICODE_NULL ) +
00473                                ObjectHeader-&gt;<a class="code" href="../../d4/d5/struct__OBJECT__HEADER.html#o3">Type</a>-&gt;<a class="code" href="../../d3/d6/struct__OBJECT__TYPE.html#o2">Name</a>.Length + <span class="keyword">sizeof</span>( UNICODE_NULL );
00474 
00475                 <span class="comment">//</span>
00476                 <span class="comment">//  If there isn't enough room then take the following error</span>
00477                 <span class="comment">//  path.   If the user wanted a single entry then tell the</span>
00478                 <span class="comment">//  caller what length is really needed and say the buffer was</span>
00479                 <span class="comment">//  too small.  Otherwise the user wanted multiple entries,</span>
00480                 <span class="comment">//  so we'll just say there are more entries in the directory.</span>
00481                 <span class="comment">//  In both cases we drop down the entry number because we</span>
00482                 <span class="comment">//  weren't able to fit it in on this call</span>
00483                 <span class="comment">//</span>
00484 
00485                 <span class="keywordflow">if</span> ((TotalLengthNeeded + LengthNeeded) &gt; Length) {
00486 
00487                     <span class="keywordflow">if</span> (ReturnSingleEntry) {
00488 
00489                         TotalLengthNeeded += LengthNeeded;
00490 
00491                         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_BUFFER_TOO_SMALL;
00492 
00493                     } <span class="keywordflow">else</span> {
00494 
00495                         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_MORE_ENTRIES;
00496                     }
00497 
00498                     EntryNumber -= 1;
00499                     <span class="keywordflow">goto</span> querydone;
00500                 }
00501 
00502                 <span class="comment">//</span>
00503                 <span class="comment">//  The information will fit in the buffer.  So now fill</span>
00504                 <span class="comment">//  in the output buffer.  We temporarily put in pointers</span>
00505                 <span class="comment">//  to the name buffer as stored in the object and object</span>
00506                 <span class="comment">//  type.  We copy the data buffer to the user buffer</span>
00507                 <span class="comment">//  right before we return to the caller</span>
00508                 <span class="comment">//</span>
00509 
00510                 <span class="keywordflow">try</span> {
00511 
00512                     DirInfo-&gt;Name.Length            = ObjectName.Length;
00513                     DirInfo-&gt;Name.MaximumLength     = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(ObjectName.Length+<span class="keyword">sizeof</span>( UNICODE_NULL ));
00514                     DirInfo-&gt;Name.Buffer            = ObjectName.Buffer;
00515 
00516                     DirInfo-&gt;TypeName.Length        = ObjectHeader-&gt;<a class="code" href="../../d4/d5/struct__OBJECT__HEADER.html#o3">Type</a>-&gt;<a class="code" href="../../d3/d6/struct__OBJECT__TYPE.html#o2">Name</a>.Length;
00517                     DirInfo-&gt;TypeName.MaximumLength = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(ObjectHeader-&gt;<a class="code" href="../../d4/d5/struct__OBJECT__HEADER.html#o3">Type</a>-&gt;<a class="code" href="../../d3/d6/struct__OBJECT__TYPE.html#o2">Name</a>.Length+<span class="keyword">sizeof</span>( UNICODE_NULL ));
00518                     DirInfo-&gt;TypeName.Buffer        = ObjectHeader-&gt;<a class="code" href="../../d4/d5/struct__OBJECT__HEADER.html#o3">Type</a>-&gt;<a class="code" href="../../d3/d6/struct__OBJECT__TYPE.html#o2">Name</a>.Buffer;
00519 
00520                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
00521 
00522                 } except( EXCEPTION_EXECUTE_HANDLER ) {
00523 
00524                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = GetExceptionCode();
00525                 }
00526 
00527                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
00528 
00529                     <span class="keywordflow">goto</span> querydone;
00530                 }
00531 
00532                 <span class="comment">//</span>
00533                 <span class="comment">//  Update the total number of bytes needed in this query.</span>
00534                 <span class="comment">//  Push the dir info pointer to the next output location,</span>
00535                 <span class="comment">//  and indicate how many entries we've processed</span>
00536                 <span class="comment">//</span>
00537                 <span class="comment">//</span>
00538 
00539                 TotalLengthNeeded += LengthNeeded;
00540 
00541                 DirInfo++;
00542                 EntriesFound++;
00543 
00544                 <span class="comment">//</span>
00545                 <span class="comment">//  If we are to return only one entry then move on to the</span>
00546                 <span class="comment">//  post processing phase, otherwise indicate that we're</span>
00547                 <span class="comment">//  processing the next entry and go back to the top of</span>
00548                 <span class="comment">//  the inner loop</span>
00549                 <span class="comment">//</span>
00550 
00551                 <span class="keywordflow">if</span> (ReturnSingleEntry) {
00552 
00553                     <span class="keywordflow">goto</span> querydone;
00554 
00555                 } <span class="keywordflow">else</span> {
00556 
00557                     <span class="comment">//</span>
00558                     <span class="comment">//  Bump the captured context by one entry.</span>
00559                     <span class="comment">//</span>
00560 
00561                     CapturedContext++;
00562                 }
00563             }
00564 
00565             <span class="comment">//</span>
00566             <span class="comment">//  Get the next directory entry from the singly linked hash</span>
00567             <span class="comment">//  bucket chain</span>
00568             <span class="comment">//</span>
00569 
00570             DirectoryEntry = DirectoryEntry-&gt;<a class="code" href="../../d9/d4/struct__OBJECT__DIRECTORY__ENTRY.html#o0">ChainLink</a>;
00571         }
00572     }
00573 
00574     <span class="comment">//</span>
00575     <span class="comment">//  At this point we've processed the directory entries and the first</span>
00576     <span class="comment">//  part of the output buffer now contains a bunch of object directory</span>
00577     <span class="comment">//  information records,  but the pointers in them refer to the wrong</span>
00578     <span class="comment">//  copies.  So now we have some fixup to do.</span>
00579     <span class="comment">//</span>
00580 
00581 querydone:
00582 
00583     <span class="keywordflow">try</span> {
00584 
00585         <span class="comment">//</span>
00586         <span class="comment">//  We'll only do this post processing if we've been successful</span>
00587         <span class="comment">//  so far.  Note that this means we could be returning in the</span>
00588         <span class="comment">//  user's output buffer system address that are meaningless, but</span>
00589         <span class="comment">//  then getting back an error status should tell the caller to</span>
00590         <span class="comment">//  forget about everything in the output buffer.  Given back</span>
00591         <span class="comment">//  a system address also isn't harmful because there is nothing</span>
00592         <span class="comment">//  that the user can really do with it.</span>
00593         <span class="comment">//</span>
00594 
00595         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
00596 
00597             <span class="comment">//</span>
00598             <span class="comment">//  Null terminate the string of object directory information</span>
00599             <span class="comment">//  records and point to where the actual names will go</span>
00600             <span class="comment">//</span>
00601 
00602             RtlZeroMemory( DirInfo, <span class="keyword">sizeof</span>( *DirInfo ));
00603 
00604             DirInfo++;
00605 
00606             NameBuffer = (PWCH)DirInfo;
00607 
00608             <span class="comment">//</span>
00609             <span class="comment">//  Now for every entry that we've put in the output buffer</span>
00610             <span class="comment">//  DirInfo will point to the entry and EntriesFound kept the</span>
00611             <span class="comment">//  count.  Note that we are guaranteed space because of</span>
00612             <span class="comment">//  the math we did earlier in computing TotalLengthNeeded.</span>
00613             <span class="comment">//</span>
00614 
00615             DirInfo = (POBJECT_DIRECTORY_INFORMATION)TempBuffer;
00616 
00617             <span class="keywordflow">while</span> (EntriesFound--) {
00618 
00619                 <span class="comment">//</span>
00620                 <span class="comment">//  Copy over the object name, set the dir info pointer into</span>
00621                 <span class="comment">//  the user's buffer, then null terminate the string.  Note</span>
00622                 <span class="comment">//  that we are really copying the data into our temp buffer</span>
00623                 <span class="comment">//  but the pointer fix up is for the user's buffer which</span>
00624                 <span class="comment">//  we'll copy into right after this loop.</span>
00625                 <span class="comment">//</span>
00626 
00627                 RtlMoveMemory( NameBuffer,
00628                                DirInfo-&gt;Name.Buffer,
00629                                DirInfo-&gt;Name.Length );
00630 
00631                 DirInfo-&gt;Name.Buffer = (PVOID)((ULONG_PTR)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> + ((ULONG_PTR)NameBuffer - (ULONG_PTR)TempBuffer));
00632                 NameBuffer           = (PWCH)((ULONG_PTR)NameBuffer + DirInfo-&gt;Name.Length);
00633                 *NameBuffer++        = UNICODE_NULL;
00634 
00635                 <span class="comment">//</span>
00636                 <span class="comment">//  Do the same copy with the object type name</span>
00637                 <span class="comment">//</span>
00638 
00639                 RtlMoveMemory( NameBuffer,
00640                                DirInfo-&gt;TypeName.Buffer,
00641                                DirInfo-&gt;TypeName.Length );
00642 
00643                 DirInfo-&gt;TypeName.Buffer = (PVOID)((ULONG_PTR)<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> + ((ULONG_PTR)NameBuffer - (ULONG_PTR)TempBuffer));
00644                 NameBuffer               = (PWCH)((ULONG_PTR)NameBuffer + DirInfo-&gt;TypeName.Length);
00645                 *NameBuffer++            = UNICODE_NULL;
00646 
00647                 <span class="comment">//</span>
00648                 <span class="comment">//  Move on to the next dir info record</span>
00649                 <span class="comment">//</span>
00650 
00651                 DirInfo++;
00652             }
00653 
00654             <span class="comment">//</span>
00655             <span class="comment">//  Set the enumeration context to the entry number of the next</span>
00656             <span class="comment">//  entry to return.</span>
00657             <span class="comment">//</span>
00658 
00659             *Context = EntryNumber;
00660         }
00661 
00662         <span class="comment">//</span>
00663         <span class="comment">//  Copy over the results from our temp buffer to the users buffer.</span>
00664         <span class="comment">//  But adjust the amount copied just in case the total length needed</span>
00665         <span class="comment">//  exceeds the length we allocated.</span>
00666         <span class="comment">//</span>
00667 
00668         RtlMoveMemory( Buffer,
00669                        TempBuffer,
00670                        (TotalLengthNeeded &lt;= Length ? TotalLengthNeeded : Length) );
00671 
00672         <span class="comment">//</span>
00673         <span class="comment">//  In all cases we'll tell the caller how much space if really needed</span>
00674         <span class="comment">//  provided the user asked for this information</span>
00675         <span class="comment">//</span>
00676 
00677         <span class="keywordflow">if</span> (ARGUMENT_PRESENT( ReturnLength )) {
00678 
00679             *ReturnLength = TotalLengthNeeded;
00680         }
00681 
00682     } except( EXCEPTION_EXECUTE_HANDLER ) {
00683 
00684         <span class="comment">//</span>
00685         <span class="comment">//  Fall through, since we do not want to undo what we have done.</span>
00686         <span class="comment">//</span>
00687     }
00688 
00689     <span class="comment">//</span>
00690     <span class="comment">//  Unlock the directroy structures, dereference the directory object,</span>
00691     <span class="comment">//  free up our temp buffer, and return to our caller</span>
00692     <span class="comment">//</span>
00693 
00694     <a class="code" href="../../d5/d1/obp_8h.html#a11">ObpLeaveRootDirectoryMutex</a>();
00695 
00696     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( Directory );
00697 
00698     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( TempBuffer );
00699 
00700     <span class="keywordflow">return</span>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
00701 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="obdir.c::ObpDeleteDirectoryEntry" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN ObpDeleteDirectoryEntry           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d8/d4/struct__OBJECT__DIRECTORY.html">POBJECT_DIRECTORY</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>Directory</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d9/obdir_8c-source.html#l01009">1009</a> of file <a class="el" href="../../d9/d9/obdir_8c-source.html">obdir.c</a>.
<p>
References <a class="el" href="../../d5/d9/ob_8h-source.html#l00220">_OBJECT_DIRECTORY_ENTRY::ChainLink</a>, <a class="el" href="../../d3/d4/editreg_8c-source.html#l00903">Directory()</a>, <a class="el" href="../../d7/d2/cmwraper_8c-source.html#l00304">ExFreePool()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
Referenced by <a class="el" href="../../d2/d0/obinsert_8c-source.html#l00029">ObInsertObject()</a>, and <a class="el" href="../../d8/d0/obref_8c-source.html#l01497">ObpDeleteNameCheck()</a>.
<p>
<pre class="fragment"><div>01015                    :
01016 
01017     This routine deletes <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> most recently found directory entry from
01018     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified directory object.  It will <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> succeed after a
01019     successful <a class="code" href="../../d8/d0/obdir_8c.html#a3">ObpLookupDirectoryEntry</a> call.
01020 
01021 Arguments:
01022 
01023     <a class="code" href="../../d2/d5/editreg_8c.html#a68">Directory</a> - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> directory being modified
01024 
01025 Return Value:
01026 
01027     <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> deletion succeeded and <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> otherwise
01028 
01029 --*/
01030 
01031 {
01032     <a class="code" href="../../d9/d4/struct__OBJECT__DIRECTORY__ENTRY.html">POBJECT_DIRECTORY_ENTRY</a> *HeadDirectoryEntry;
01033     <a class="code" href="../../d9/d4/struct__OBJECT__DIRECTORY__ENTRY.html">POBJECT_DIRECTORY_ENTRY</a> DirectoryEntry;
01034 
01035     <span class="comment">//</span>
01036     <span class="comment">//  Make sure we have a directory and that it has a found entry</span>
01037     <span class="comment">//</span>
01038 
01039     <span class="keywordflow">if</span> (!<a class="code" href="../../d2/d5/editreg_8c.html#a68">Directory</a> || !<a class="code" href="../../d2/d5/editreg_8c.html#a68">Directory</a>-&gt;LookupFound) {
01040 
01041         <span class="keywordflow">return</span>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01042     }
01043 
01044     <span class="comment">//</span>
01045     <span class="comment">//  Also make sure that the lookup bucket is valid</span>
01046     <span class="comment">//</span>
01047 
01048     HeadDirectoryEntry = <a class="code" href="../../d2/d5/editreg_8c.html#a68">Directory</a>-&gt;LookupBucket;
01049 
01050     <span class="keywordflow">if</span> (!HeadDirectoryEntry) {
01051 
01052         <span class="keywordflow">return</span>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01053     }
01054 
01055     DirectoryEntry = *HeadDirectoryEntry;
01056 
01057     <span class="keywordflow">if</span> (!DirectoryEntry) {
01058 
01059         <span class="keywordflow">return</span>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01060     }
01061 
01062     <span class="comment">//</span>
01063     <span class="comment">//  Unlink the entry from the head of the bucket chain and free the</span>
01064     <span class="comment">//  memory for the entry.</span>
01065     <span class="comment">//</span>
01066 
01067     *HeadDirectoryEntry = DirectoryEntry-&gt;<a class="code" href="../../d9/d4/struct__OBJECT__DIRECTORY__ENTRY.html#o0">ChainLink</a>;
01068     DirectoryEntry-&gt;<a class="code" href="../../d9/d4/struct__OBJECT__DIRECTORY__ENTRY.html#o0">ChainLink</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01069 
01070     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( DirectoryEntry );
01071 
01072     <span class="comment">//</span>
01073     <span class="comment">//  Return success</span>
01074     <span class="comment">//</span>
01075 
01076     <span class="keywordflow">return</span>( <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
01077 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="obdir.c::ObpInsertDirectoryEntry" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN ObpInsertDirectoryEntry           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d8/d4/struct__OBJECT__DIRECTORY.html">POBJECT_DIRECTORY</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Directory</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>Object</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d9/obdir_8c-source.html#l00903">903</a> of file <a class="el" href="../../d9/d9/obdir_8c-source.html">obdir.c</a>.
<p>
References <a class="el" href="../../d5/d9/ob_8h-source.html#l00220">_OBJECT_DIRECTORY_ENTRY::ChainLink</a>, <a class="el" href="../../d3/d4/editreg_8c-source.html#l00903">Directory()</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00331">_OBJECT_HEADER_NAME_INFO::Directory</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l00253">ExAllocatePoolWithTag</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00221">_OBJECT_DIRECTORY_ENTRY::Object</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00368">OBJECT_HEADER_TO_NAME_INFO</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00355">OBJECT_TO_OBJECT_HEADER</a>, <a class="el" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
Referenced by <a class="el" href="../../d1/d1/obtype_8c-source.html#l00069">ObCreateObjectType()</a>, <a class="el" href="../../d1/d0/obinit_8c-source.html#l00117">ObInitSystem()</a>, and <a class="el" href="../../d9/d9/obdir_8c-source.html#l01081">ObpLookupObjectName()</a>.
<p>
<pre class="fragment"><div>00910                    :
00911 
00912     This routine will insert a <span class="keyword">new</span> directory entry into a directory
00913     object.  The directory must have already have been searched <span class="keyword">using</span>
00914     <a class="code" href="../../d8/d0/obdir_8c.html#a3">ObpLookupDirectoryEntry</a> because that routine sets <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> LookupBucket
00915 
00916 Arguments:
00917 
00918     <a class="code" href="../../d2/d5/editreg_8c.html#a68">Directory</a> - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> directory object being modified.  This
00919         function assumes that we earlier did a lookup on <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> name
00920         that was successful or we just did an insertion
00921 
00922     Object - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> object to insert into <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> directory
00923 
00924 Return Value:
00925 
00926     <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> object <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> inserted successfully and <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> otherwise
00927 
00928 --*/
00929 
00930 {
00931     <a class="code" href="../../d9/d4/struct__OBJECT__DIRECTORY__ENTRY.html">POBJECT_DIRECTORY_ENTRY</a> *HeadDirectoryEntry;
00932     <a class="code" href="../../d9/d4/struct__OBJECT__DIRECTORY__ENTRY.html">POBJECT_DIRECTORY_ENTRY</a> NewDirectoryEntry;
00933     <a class="code" href="../../d0/d6/struct__OBJECT__HEADER__NAME__INFO.html">POBJECT_HEADER_NAME_INFO</a> NameInfo;
00934 
00935     <span class="comment">//</span>
00936     <span class="comment">//  Make sure we have a directory and that the last search was</span>
00937     <span class="comment">//  successful, meaning there is a lookupbuket</span>
00938     <span class="comment">//</span>
00939 
00940     <span class="keywordflow">if</span> (!<a class="code" href="../../d2/d5/editreg_8c.html#a68">Directory</a> || <a class="code" href="../../d2/d5/editreg_8c.html#a68">Directory</a>-&gt;LookupFound) {
00941 
00942         <span class="keywordflow">return</span>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00943     }
00944 
00945     <span class="comment">//</span>
00946     <span class="comment">//  Also verify that we have a good lookupbucket</span>
00947     <span class="comment">//</span>
00948 
00949     HeadDirectoryEntry = <a class="code" href="../../d2/d5/editreg_8c.html#a68">Directory</a>-&gt;LookupBucket;
00950 
00951     <span class="keywordflow">if</span> (!HeadDirectoryEntry) {
00952 
00953         <span class="keywordflow">return</span>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00954     }
00955 
00956     <span class="comment">//</span>
00957     <span class="comment">//  Translate the object into a name info record, and make sure</span>
00958     <span class="comment">//  that the object has a name</span>
00959     <span class="comment">//</span>
00960 
00961     NameInfo = <a class="code" href="../../d4/d0/ob_8h.html#a12">OBJECT_HEADER_TO_NAME_INFO</a>( <a class="code" href="../../d4/d0/ob_8h.html#a8">OBJECT_TO_OBJECT_HEADER</a>( Object ) );
00962 
00963     <span class="keywordflow">if</span> (NameInfo == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00964 
00965         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00966     }
00967 
00968     <span class="comment">//</span>
00969     <span class="comment">//  Allocate memory for a new entry, and fail if not enough memory.</span>
00970     <span class="comment">//</span>
00971 
00972     NewDirectoryEntry = (<a class="code" href="../../d9/d4/struct__OBJECT__DIRECTORY__ENTRY.html">POBJECT_DIRECTORY_ENTRY</a>)<a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( PagedPool,
00973                                                                         <span class="keyword">sizeof</span>( <a class="code" href="../../d9/d4/struct__OBJECT__DIRECTORY__ENTRY.html">OBJECT_DIRECTORY_ENTRY</a> ),
00974                                                                         'iDbO' );
00975 
00976     <span class="keywordflow">if</span> (NewDirectoryEntry == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00977 
00978         <span class="keywordflow">return</span>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00979     }
00980 
00981     <span class="comment">//</span>
00982     <span class="comment">//  Link the new entry into the chain at the insertion point.</span>
00983     <span class="comment">//  This puts the new object right at the head of the current</span>
00984     <span class="comment">//  hash bucket chain</span>
00985     <span class="comment">//</span>
00986 
00987     NewDirectoryEntry-&gt;<a class="code" href="../../d9/d4/struct__OBJECT__DIRECTORY__ENTRY.html#o0">ChainLink</a> = *HeadDirectoryEntry;
00988     *HeadDirectoryEntry = NewDirectoryEntry;
00989     NewDirectoryEntry-&gt;<a class="code" href="../../d9/d4/struct__OBJECT__DIRECTORY__ENTRY.html#o1">Object</a> = Object;
00990 
00991     <span class="comment">//</span>
00992     <span class="comment">//  Point the object header back to the directory we just inserted</span>
00993     <span class="comment">//  it into.</span>
00994     <span class="comment">//</span>
00995 
00996     NameInfo-&gt;<a class="code" href="../../d0/d6/struct__OBJECT__HEADER__NAME__INFO.html#o0">Directory</a> = <a class="code" href="../../d2/d5/editreg_8c.html#a68">Directory</a>;
00997 
00998     <span class="comment">//</span>
00999     <span class="comment">//  Return success.</span>
01000     <span class="comment">//</span>
01001 
01002     <a class="code" href="../../d2/d5/editreg_8c.html#a68">Directory</a>-&gt;LookupFound = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01003 
01004     <span class="keywordflow">return</span>( <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
01005 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="obdir.c::ObpLookupDirectoryEntry" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> PVOID ObpLookupDirectoryEntry           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d8/d4/struct__OBJECT__DIRECTORY.html">POBJECT_DIRECTORY</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>Directory</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PUNICODE_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>Name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Attributes</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d9/obdir_8c-source.html#l00705">705</a> of file <a class="el" href="../../d9/d9/obdir_8c-source.html">obdir.c</a>.
<p>
References <a class="el" href="../../d7/d1/rtqkey_8c-source.html#l00042">Buffer</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00220">_OBJECT_DIRECTORY_ENTRY::ChainLink</a>, <a class="el" href="../../d3/d4/editreg_8c-source.html#l00903">Directory()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d9/d9/geninst_8c-source.html#l00154">Name</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00332">_OBJECT_HEADER_NAME_INFO::Name</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00206">NUMBER_HASH_BUCKETS</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00221">_OBJECT_DIRECTORY_ENTRY::Object</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00368">OBJECT_HEADER_TO_NAME_INFO</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00355">OBJECT_TO_OBJECT_HEADER</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d7/d5/nls_8c-source.html#l01608">RtlEqualUnicodeString()</a>, <a class="el" href="../../d7/d5/nls_8c-source.html#l01178">RtlUpcaseUnicodeChar()</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
Referenced by <a class="el" href="../../d1/d1/obtype_8c-source.html#l00069">ObCreateObjectType()</a>, <a class="el" href="../../d1/d0/obinit_8c-source.html#l00117">ObInitSystem()</a>, <a class="el" href="../../d8/d0/obref_8c-source.html#l01497">ObpDeleteNameCheck()</a>, <a class="el" href="../../d9/d9/obdir_8c-source.html#l01081">ObpLookupObjectName()</a>, and <a class="el" href="../../d5/d0/oblink_8c-source.html#l01121">ObpProcessDosDeviceSymbolicLink()</a>.
<p>
<pre class="fragment"><div>00713                    :
00714 
00715     This routine will lookup a single directory entry in a given directory.
00716 
00717     I believe <span class="keyword">this</span> routine assumes that <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> called with <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> root directory
00718     locked.
00719 
00720     Also note that <span class="keyword">this</span> routine does not reference <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> returned object
00721 
00722 Arguments:
00723 
00724     <a class="code" href="../../d2/d5/editreg_8c.html#a68">Directory</a> - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> directory being searched
00725 
00726     <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a> - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> name of entry we're looking <span class="keywordflow">for</span>
00727 
00728     Attributes - Indicates <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> lookup should be <span class="keywordflow">case</span> insensitive
00729         or not
00730 
00731 Return Value:
00732 
00733     Returns a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> corresponding object body <span class="keywordflow">if</span> found and <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
00734     otherwise.
00735 
00736 --*/
00737 
00738 {
00739     <a class="code" href="../../d9/d4/struct__OBJECT__DIRECTORY__ENTRY.html">POBJECT_DIRECTORY_ENTRY</a> *HeadDirectoryEntry;
00740     <a class="code" href="../../d9/d4/struct__OBJECT__DIRECTORY__ENTRY.html">POBJECT_DIRECTORY_ENTRY</a> DirectoryEntry;
00741     <a class="code" href="../../d4/d5/struct__OBJECT__HEADER.html">POBJECT_HEADER</a> ObjectHeader;
00742     <a class="code" href="../../d0/d6/struct__OBJECT__HEADER__NAME__INFO.html">POBJECT_HEADER_NAME_INFO</a> NameInfo;
00743     PWCH <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>;
00744     WCHAR Wchar;
00745     ULONG HashIndex;
00746     ULONG WcharLength;
00747     BOOLEAN CaseInSensitive;
00748 
00749     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00750 
00751     <span class="comment">//</span>
00752     <span class="comment">//  The caller needs to specify both a directory and a name otherwise</span>
00753     <span class="comment">//  we can't process the request</span>
00754     <span class="comment">//</span>
00755 
00756     <span class="keywordflow">if</span> (!<a class="code" href="../../d2/d5/editreg_8c.html#a68">Directory</a> || !<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>) {
00757 
00758         <span class="keywordflow">return</span>( <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ); <span class="comment">// BUG BUG</span>
00759     }
00760 
00761     <span class="comment">//</span>
00762     <span class="comment">//  Set a local variable to tell us if the search is case sensitive</span>
00763     <span class="comment">//</span>
00764 
00765     <span class="keywordflow">if</span> (Attributes &amp; OBJ_CASE_INSENSITIVE) {
00766 
00767         CaseInSensitive = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00768 
00769     } <span class="keywordflow">else</span> {
00770 
00771         CaseInSensitive = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00772     }
00773 
00774     <span class="comment">//</span>
00775     <span class="comment">//  Establish our local pointer to the input name buffer and get the</span>
00776     <span class="comment">//  number of unicode characters in the input name.  Also make sure</span>
00777     <span class="comment">//  the caller gave us a non null name</span>
00778     <span class="comment">//</span>
00779 
00780     <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer;
00781     WcharLength = <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length / <span class="keyword">sizeof</span>( *Buffer );
00782 
00783     <span class="keywordflow">if</span> (!WcharLength || !<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>) {
00784 
00785         <span class="keywordflow">return</span>( <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ); <span class="comment">// BUG BUG</span>
00786     }
00787 
00788     <span class="comment">//</span>
00789     <span class="comment">//  Compute the address of the head of the bucket chain for this name.</span>
00790     <span class="comment">//</span>
00791 
00792     HashIndex = 0;
00793     <span class="keywordflow">while</span> (WcharLength--) {
00794 
00795         Wchar = *<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>++;
00796         HashIndex += (HashIndex &lt;&lt; 1) + (HashIndex &gt;&gt; 1);
00797 
00798         <span class="keywordflow">if</span> (Wchar &lt; <span class="charliteral">'a'</span>) {
00799 
00800             HashIndex += Wchar;
00801 
00802         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Wchar &gt; <span class="charliteral">'z'</span>) {
00803 
00804             HashIndex += <a class="code" href="../../d6/d6/nls_8c.html#a33">RtlUpcaseUnicodeChar</a>( Wchar );
00805 
00806         } <span class="keywordflow">else</span> {
00807 
00808             HashIndex += (Wchar - (<span class="charliteral">'a'</span>-<span class="charliteral">'A'</span>));
00809         }
00810     }
00811 
00812     HashIndex %= <a class="code" href="../../d4/d0/ob_8h.html#a0">NUMBER_HASH_BUCKETS</a>;
00813 
00814     HeadDirectoryEntry = (<a class="code" href="../../d9/d4/struct__OBJECT__DIRECTORY__ENTRY.html">POBJECT_DIRECTORY_ENTRY</a> *)&amp;<a class="code" href="../../d2/d5/editreg_8c.html#a68">Directory</a>-&gt;HashBuckets[ HashIndex ];
00815 
00816     <a class="code" href="../../d2/d5/editreg_8c.html#a68">Directory</a>-&gt;LookupBucket = HeadDirectoryEntry;
00817 
00818     <span class="comment">//</span>
00819     <span class="comment">//  Walk the chain of directory entries for this hash bucket, looking</span>
00820     <span class="comment">//  for either a match, or the insertion point if no match in the chain.</span>
00821     <span class="comment">//</span>
00822 
00823     <span class="keywordflow">while</span> ((DirectoryEntry = *HeadDirectoryEntry) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00824 
00825         <span class="comment">//</span>
00826         <span class="comment">//  Get the object header and name from the object body</span>
00827         <span class="comment">//</span>
00828         <span class="comment">//  This function assumes the name must exist, otherwise it</span>
00829         <span class="comment">//  wouldn't be in a directory</span>
00830         <span class="comment">//</span>
00831 
00832         ObjectHeader = <a class="code" href="../../d4/d0/ob_8h.html#a8">OBJECT_TO_OBJECT_HEADER</a>( DirectoryEntry-&gt;<a class="code" href="../../d9/d4/struct__OBJECT__DIRECTORY__ENTRY.html#o1">Object</a> );
00833         NameInfo = <a class="code" href="../../d4/d0/ob_8h.html#a12">OBJECT_HEADER_TO_NAME_INFO</a>( ObjectHeader );
00834 
00835         <span class="comment">//</span>
00836         <span class="comment">//  Compare strings using appropriate function.</span>
00837         <span class="comment">//</span>
00838 
00839         <span class="keywordflow">if</span> ((<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length == NameInfo-&gt;<a class="code" href="../../d0/d6/struct__OBJECT__HEADER__NAME__INFO.html#o1">Name</a>.Length) &amp;&amp;
00840             <a class="code" href="../../d6/d6/nls_8c.html#a42">RtlEqualUnicodeString</a>( Name,
00841                                    &amp;NameInfo-&gt;<a class="code" href="../../d0/d6/struct__OBJECT__HEADER__NAME__INFO.html#o1">Name</a>,
00842                                    CaseInSensitive )) {
00843 
00844             <span class="comment">//</span>
00845             <span class="comment">//  If name matches, then exit loop with DirectoryEntry</span>
00846             <span class="comment">//  pointing to matching entry.</span>
00847             <span class="comment">//</span>
00848 
00849             <span class="keywordflow">break</span>;
00850         }
00851 
00852         HeadDirectoryEntry = &amp;DirectoryEntry-&gt;<a class="code" href="../../d9/d4/struct__OBJECT__DIRECTORY__ENTRY.html#o0">ChainLink</a>;
00853     }
00854 
00855     <span class="comment">//</span>
00856     <span class="comment">//  At this point, there are two possiblilities:</span>
00857     <span class="comment">//</span>
00858     <span class="comment">//   - we found an entry that matched and DirectoryEntry points to that</span>
00859     <span class="comment">//     entry.  Update the bucket chain so that the entry found is at the</span>
00860     <span class="comment">//     head of the bucket chain.  This is so the ObpDeleteDirectoryEntry</span>
00861     <span class="comment">//     and ObpInsertDirectoryEntry functions will work.  Also repeated</span>
00862     <span class="comment">//     lookups of the same name will succeed quickly.</span>
00863     <span class="comment">//</span>
00864     <span class="comment">//   - we did not find an entry that matched and DirectoryEntry is NULL.</span>
00865     <span class="comment">//</span>
00866 
00867     <span class="keywordflow">if</span> (DirectoryEntry) {
00868 
00869         <a class="code" href="../../d2/d5/editreg_8c.html#a68">Directory</a>-&gt;LookupFound = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00870 
00871         <span class="comment">//</span>
00872         <span class="comment">//  The following convoluted piece of code moves a directory entry</span>
00873         <span class="comment">//  we've found to the front of the hash list.</span>
00874         <span class="comment">//</span>
00875 
00876         <span class="keywordflow">if</span> (HeadDirectoryEntry != <a class="code" href="../../d2/d5/editreg_8c.html#a68">Directory</a>-&gt;LookupBucket) {
00877 
00878             *HeadDirectoryEntry = DirectoryEntry-&gt;<a class="code" href="../../d9/d4/struct__OBJECT__DIRECTORY__ENTRY.html#o0">ChainLink</a>;
00879             DirectoryEntry-&gt;<a class="code" href="../../d9/d4/struct__OBJECT__DIRECTORY__ENTRY.html#o0">ChainLink</a> = *(<a class="code" href="../../d2/d5/editreg_8c.html#a68">Directory</a>-&gt;LookupBucket);
00880             *(<a class="code" href="../../d2/d5/editreg_8c.html#a68">Directory</a>-&gt;LookupBucket) = DirectoryEntry;
00881         }
00882 
00883         <span class="comment">//</span>
00884         <span class="comment">//  Now return the object to our caller</span>
00885         <span class="comment">//</span>
00886 
00887         <span class="keywordflow">return</span>( DirectoryEntry-&gt;<a class="code" href="../../d9/d4/struct__OBJECT__DIRECTORY__ENTRY.html#o1">Object</a> );
00888 
00889     } <span class="keywordflow">else</span> {
00890 
00891         <span class="comment">//</span>
00892         <span class="comment">//  Otherwise we didn't find anything so return null</span>
00893         <span class="comment">//</span>
00894 
00895         <a class="code" href="../../d2/d5/editreg_8c.html#a68">Directory</a>-&gt;LookupFound = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00896 
00897         <span class="keywordflow">return</span>( <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00898     }
00899 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="obdir.c::ObpLookupObjectName" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS ObpLookupObjectName           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN HANDLE RootDirectoryHandle&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PUNICODE_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>ObjectName</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>Attributes</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d3/d6/struct__OBJECT__TYPE.html">POBJECT_TYPE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>ObjectType</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>AccessMode</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID ParseContext&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PSECURITY_QUALITY_OF_SERVICE <a class="el" href="../../d8/d0/ctlpcqos_8c.html#a9">SecurityQos</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID InsertObject&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT <a class="el" href="../../d2/d5/struct__ACCESS__STATE.html">PACCESS_STATE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>AccessState</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PBOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>DirectoryLocked</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PVOID *&nbsp;</td>
          <td class="mdname" nowrap> <em>FoundObject</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d9/obdir_8c-source.html#l01081">1081</a> of file <a class="el" href="../../d9/d9/obdir_8c-source.html">obdir.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00313">_OBJECT_HEADER::Body</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00213">_OBJECT_DIRECTORY::DeviceMap</a>, <a class="el" href="../../d3/d4/editreg_8c-source.html#l00903">Directory()</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00244">_DEVICE_MAP::DosDevicesDirectory</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l00253">ExAllocatePoolWithTag</a>, <a class="el" href="../../d7/d2/cmwraper_8c-source.html#l00304">ExFreePool()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d6/d7/fssup_8c-source.html#l00044">IoFileObjectType</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00332">_OBJECT_HEADER_NAME_INFO::Name</a>, <a class="el" href="../../d0/d2/rtreplac_8c-source.html#l00045">NewName</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00107">OB_PARSE_METHOD</a>, <a class="el" href="../../d0/d1/obse_8c-source.html#l00983">ObCheckCreateObjectAccess()</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00494">ObDereferenceObject</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00368">OBJECT_HEADER_TO_NAME_INFO</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00355">OBJECT_TO_OBJECT_HEADER</a>, <a class="el" href="../../d6/d0/obp_8h-source.html#l00056">ObpBeginTypeSpecificCallOut</a>, <a class="el" href="../../d0/d1/obse_8c-source.html#l00778">ObpCheckTraverseAccess()</a>, <a class="el" href="../../d6/d0/obp_8h-source.html#l00098">ObpDeviceMapLock</a>, <a class="el" href="../../d6/d0/obp_8h-source.html#l00367">ObpDirectoryObjectType</a>, <a class="el" href="../../d1/d0/obinit_8c-source.html#l00110">ObpDosDevicesShortName</a>, <a class="el" href="../../d1/d0/obinit_8c-source.html#l00111">ObpDosDevicesShortNamePrefix</a>, <a class="el" href="../../d1/d0/obinit_8c-source.html#l00112">ObpDosDevicesShortNameRoot</a>, <a class="el" href="../../d6/d0/obp_8h-source.html#l00057">ObpEndTypeSpecificCallOut</a>, <a class="el" href="../../d6/d0/obp_8h-source.html#l00189">ObpEnterRootDirectoryMutex</a>, <a class="el" href="../../d6/d0/obp_8h-source.html#l00143">ObpIncrPointerCount</a>, <a class="el" href="../../d9/d9/obdir_8c-source.html#l00903">ObpInsertDirectoryEntry()</a>, <a class="el" href="../../d6/d0/obp_8h-source.html#l00202">ObpLeaveRootDirectoryMutex</a>, <a class="el" href="../../d9/d9/obdir_8c-source.html#l00705">ObpLookupDirectoryEntry()</a>, <a class="el" href="../../d5/d0/oblink_8c-source.html#l00501">ObpParseSymbolicLink()</a>, <a class="el" href="../../d9/d4/kddata_8c-source.html#l00046">ObpRootDirectoryObject</a>, <a class="el" href="../../d6/d0/obp_8h-source.html#l00071">ObpValidateIrql</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00514">ObReferenceObject</a>, <a class="el" href="../../d8/d0/obref_8c-source.html#l00542">ObReferenceObjectByHandle()</a>, <a class="el" href="../../d8/d0/obref_8c-source.html#l01022">ObReferenceObjectByPointer()</a>, <a class="el" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00180">_OBJECT_TYPE_INITIALIZER::ParseProcedure</a>, <a class="el" href="../../d2/d8/ps_8h-source.html#l00643">PsGetCurrentProcess</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00243">_DEVICE_MAP::ReferenceCount</a>, <a class="el" href="../../d8/d9/ctlnpqos_8c-source.html#l00037">SecurityQos</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d1/d4/se_8h-source.html#l00072">TOKEN_HAS_TRAVERSE_PRIVILEGE</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00302">_OBJECT_HEADER::Type</a>, and <a class="el" href="../../d5/d9/ob_8h-source.html#l00196">_OBJECT_TYPE::TypeInfo</a>.
<p>
Referenced by <a class="el" href="../../d2/d0/obinsert_8c-source.html#l00029">ObInsertObject()</a>, <a class="el" href="../../d8/d0/obref_8c-source.html#l00095">ObOpenObjectByName()</a>, and <a class="el" href="../../d8/d0/obref_8c-source.html#l00844">ObReferenceObjectByName()</a>.
<p>
<pre class="fragment"><div>01097                    :
01098 
01099     This function will search a given directoroy <span class="keywordflow">for</span> a specified
01100     object name.  It will also create a <span class="keyword">new</span> object specified by
01101     InsertObject.
01102 
01103 Arguments:
01104 
01105     RootDirectoryHandle - Optionally supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> directory being
01106         searched.  If not supplied then <span class="keyword">this</span> routine searches
01107         <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> root directory
01108 
01109     ObjectName - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> name of object to lookup
01110 
01111     Attributes - Specifies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> attributes <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> lookup (e.g., <span class="keywordflow">case</span>
01112         insensitive)
01113 
01114     ObjectType - Specifies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d3/d5/i386_2trapc_8c.html#a9">type</a> of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> object to lookup
01115 
01116     AccessMode - Specifies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> callers processor mode
01117 
01118     ParseContext - Optionally supplies a parse context that <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> blindly
01119         passed to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> parse callback <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a24">routines</a>
01120 
01121     <a class="code" href="../../d7/d0/ctlnpqos_8c.html#a14">SecurityQos</a> - Optionally supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> passed Security
01122         Quality of Service parameter that <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> blindly passed to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> parse
01123         callback <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a24">routines</a>
01124 
01125     InsertObject - Optionally supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> object we think will be found.
01126         This <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> used <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller did not give a root directory handle
01127         and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> object name <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <span class="stringliteral">"\" and the root object directory hasn't</span>
01128 <span class="stringliteral">        been created yet.  In other cases where we wind up creating</span>
01129 <span class="stringliteral">        a new directory entry this is the object inserted.</span>
01130 <span class="stringliteral"></span>
01131 <span class="stringliteral">    AccessState - Current access state, describing already granted access</span>
01132 <span class="stringliteral">        types, the privileges used to get them, and any access types yet to</span>
01133 <span class="stringliteral">        be granted.  The access masks may not contain any generic access</span>
01134 <span class="stringliteral">        types.</span>
01135 <span class="stringliteral"></span>
01136 <span class="stringliteral">    DirectoryLocked - Receives an indication if this routine has returned</span>
01137 <span class="stringliteral">        with the input directory locked</span>
01138 <span class="stringliteral"></span>
01139 <span class="stringliteral">    FoundObject - Receives a pointer to the object body if found</span>
01140 <span class="stringliteral"></span>
01141 <span class="stringliteral">Return Value:</span>
01142 <span class="stringliteral"></span>
01143 <span class="stringliteral">    An appropriate status value</span>
01144 <span class="stringliteral"></span>
01145 <span class="stringliteral">--*/</span>
01146 <span class="stringliteral"></span>
01147 <span class="stringliteral">{</span>
01148 <span class="stringliteral">    POBJECT_DIRECTORY RootDirectory;</span>
01149 <span class="stringliteral">    POBJECT_DIRECTORY Directory;</span>
01150 <span class="stringliteral">    POBJECT_DIRECTORY ParentDirectory = NULL;</span>
01151 <span class="stringliteral">    POBJECT_HEADER ObjectHeader;</span>
01152 <span class="stringliteral">    POBJECT_HEADER_NAME_INFO NameInfo;</span>
01153 <span class="stringliteral">    PDEVICE_MAP DeviceMap = NULL;</span>
01154 <span class="stringliteral">    PVOID Object;</span>
01155 <span class="stringliteral">    UNICODE_STRING RemainingName;</span>
01156 <span class="stringliteral">    UNICODE_STRING ComponentName;</span>
01157 <span class="stringliteral">    PWCH NewName;</span>
01158 <span class="stringliteral">    NTSTATUS Status;</span>
01159 <span class="stringliteral">    BOOLEAN Reparse;</span>
01160 <span class="stringliteral">    ULONG MaxReparse = OBJ_MAX_REPARSE_ATTEMPTS;</span>
01161 <span class="stringliteral">    OB_PARSE_METHOD ParseProcedure;</span>
01162 <span class="stringliteral">    extern POBJECT_TYPE IoFileObjectType;</span>
01163 <span class="stringliteral"></span>
01164 <span class="stringliteral">    ObpValidateIrql( "</span><a class="code" href="../../d8/d0/obdir_8c.html#a6">ObpLookupObjectName</a><span class="stringliteral">" );</span>
01165 <span class="stringliteral"></span>
01166 <span class="stringliteral">    //</span>
01167 <span class="stringliteral">    //  Initialize our output variables to say we haven't lock or found</span>
01168 <span class="stringliteral">    //  anything but we were successful at it</span>
01169 <span class="stringliteral">    //</span>
01170 <span class="stringliteral"></span>
01171 <span class="stringliteral">    *DirectoryLocked = FALSE;</span>
01172 <span class="stringliteral">    *FoundObject = NULL;</span>
01173 <span class="stringliteral">    Status = STATUS_SUCCESS;</span>
01174 <span class="stringliteral"></span>
01175 <span class="stringliteral">    Object = NULL;</span>
01176 <span class="stringliteral"></span>
01177 <span class="stringliteral">    //</span>
01178 <span class="stringliteral">    //  Check if the caller has given us a directory to search.  Otherwise</span>
01179 <span class="stringliteral">    //  we'll search the root object directory</span>
01180 <span class="stringliteral">    //</span>
01181 <span class="stringliteral"></span>
01182 <span class="stringliteral">    if (ARGUMENT_PRESENT( RootDirectoryHandle )) {</span>
01183 <span class="stringliteral"></span>
01184 <span class="stringliteral">        //</span>
01185 <span class="stringliteral">        //  Otherwise reference the directory object and make sure</span>
01186 <span class="stringliteral">        //  that we successfully got the object</span>
01187 <span class="stringliteral">        //</span>
01188 <span class="stringliteral"></span>
01189 <span class="stringliteral">        Status = ObReferenceObjectByHandle( RootDirectoryHandle,</span>
01190 <span class="stringliteral">                                            0,</span>
01191 <span class="stringliteral">                                            NULL,</span>
01192 <span class="stringliteral">                                            AccessMode,</span>
01193 <span class="stringliteral">                                            (PVOID *)&amp;RootDirectory,</span>
01194 <span class="stringliteral">                                            NULL );</span>
01195 <span class="stringliteral"></span>
01196 <span class="stringliteral">        if (!NT_SUCCESS( Status )) {</span>
01197 <span class="stringliteral"></span>
01198 <span class="stringliteral">            return( Status );</span>
01199 <span class="stringliteral">        }</span>
01200 <span class="stringliteral"></span>
01201 <span class="stringliteral">        //</span>
01202 <span class="stringliteral">        //  Translate the directory object to its object header</span>
01203 <span class="stringliteral">        //</span>
01204 <span class="stringliteral"></span>
01205 <span class="stringliteral">        ObjectHeader = OBJECT_TO_OBJECT_HEADER( RootDirectory );</span>
01206 <span class="stringliteral"></span>
01207 <span class="stringliteral">        //</span>
01208 <span class="stringliteral">        //  Now if the name we're looking up starts with a "</span>\<span class="stringliteral">" and it</span>
01209 <span class="stringliteral">        //  does not have a parse procedure then the syntax is bad</span>
01210 <span class="stringliteral">        //</span>
01211 <span class="stringliteral"></span>
01212 <span class="stringliteral">        if ((ObjectName-&gt;Buffer != NULL) &amp;&amp;</span>
01213 <span class="stringliteral">            (*(ObjectName-&gt;Buffer) == OBJ_NAME_PATH_SEPARATOR) &amp;&amp;</span>
01214 <span class="stringliteral">            (ObjectHeader-&gt;Type != IoFileObjectType)) {</span>
01215 <span class="stringliteral"></span>
01216 <span class="stringliteral">            ObDereferenceObject( RootDirectory );</span>
01217 <span class="stringliteral"></span>
01218 <span class="stringliteral">            return( STATUS_OBJECT_PATH_SYNTAX_BAD );</span>
01219 <span class="stringliteral">        }</span>
01220 <span class="stringliteral"></span>
01221 <span class="stringliteral">        //</span>
01222 <span class="stringliteral">        //  Now make sure that we do not have the directory of the</span>
01223 <span class="stringliteral">        //  object types</span>
01224 <span class="stringliteral">        //</span>
01225 <span class="stringliteral"></span>
01226 <span class="stringliteral">        if (ObjectHeader-&gt;Type != ObpDirectoryObjectType) {</span>
01227 <span class="stringliteral"></span>
01228 <span class="stringliteral">            //</span>
01229 <span class="stringliteral">            //  We have an object directory that is not the object type</span>
01230 <span class="stringliteral">            //  directory.  So now if it doesn't have a parse routine</span>
01231 <span class="stringliteral">            //  then there is nothing we can</span>
01232 <span class="stringliteral">            //</span>
01233 <span class="stringliteral"></span>
01234 <span class="stringliteral">            if (ObjectHeader-&gt;Type-&gt;TypeInfo.ParseProcedure == NULL) {</span>
01235 <span class="stringliteral"></span>
01236 <span class="stringliteral">                ObDereferenceObject( RootDirectory );</span>
01237 <span class="stringliteral"></span>
01238 <span class="stringliteral">                return( STATUS_INVALID_HANDLE );</span>
01239 <span class="stringliteral"></span>
01240 <span class="stringliteral">            } else {</span>
01241 <span class="stringliteral"></span>
01242 <span class="stringliteral">                MaxReparse = OBJ_MAX_REPARSE_ATTEMPTS;</span>
01243 <span class="stringliteral"></span>
01244 <span class="stringliteral">                //</span>
01245 <span class="stringliteral">                //  The following loop cycles cycles through the various</span>
01246 <span class="stringliteral">                //  parse routine to we could encounter trying to resolve</span>
01247 <span class="stringliteral">                //  this name through symbolic links.</span>
01248 <span class="stringliteral">                //</span>
01249 <span class="stringliteral"></span>
01250 <span class="stringliteral">                while (TRUE) {</span>
01251 <span class="stringliteral"></span>
01252 <span class="stringliteral">                    KIRQL SaveIrql;</span>
01253 <span class="stringliteral"></span>
01254 <span class="stringliteral">                    RemainingName = *ObjectName;</span>
01255 <span class="stringliteral"></span>
01256 <span class="stringliteral">                    //</span>
01257 <span class="stringliteral">                    //  Invoke the callback routine to parse the remaining</span>
01258 <span class="stringliteral">                    //  object name</span>
01259 <span class="stringliteral">                    //</span>
01260 <span class="stringliteral"></span>
01261 <span class="stringliteral">                    ObpBeginTypeSpecificCallOut( SaveIrql );</span>
01262 <span class="stringliteral"></span>
01263 <span class="stringliteral">                    Status = (*ObjectHeader-&gt;Type-&gt;TypeInfo.ParseProcedure)( RootDirectory,</span>
01264 <span class="stringliteral">                                                                             ObjectType,</span>
01265 <span class="stringliteral">                                                                             AccessState,</span>
01266 <span class="stringliteral">                                                                             AccessMode,</span>
01267 <span class="stringliteral">                                                                             Attributes,</span>
01268 <span class="stringliteral">                                                                             ObjectName,</span>
01269 <span class="stringliteral">                                                                             &amp;RemainingName,</span>
01270 <span class="stringliteral">                                                                             ParseContext,</span>
01271 <span class="stringliteral">                                                                             SecurityQos,</span>
01272 <span class="stringliteral">                                                                             &amp;Object );</span>
01273 <span class="stringliteral"></span>
01274 <span class="stringliteral">                    ObpEndTypeSpecificCallOut( SaveIrql, "</span>Parse<span class="stringliteral">", ObjectHeader-&gt;Type, Object );</span>
01275 <span class="stringliteral"></span>
01276 <span class="stringliteral">                    //</span>
01277 <span class="stringliteral">                    //  If the status was not to do a reparse and the lookup</span>
01278 <span class="stringliteral">                    //  was not successful then we found nothing so we</span>
01279 <span class="stringliteral">                    //  dereference the directory and return the status to</span>
01280 <span class="stringliteral">                    //  our caller.  If the object we got back was null then</span>
01281 <span class="stringliteral">                    //  we'll tell our caller that we couldn't find the name.</span>
01282 <span class="stringliteral">                    //  Lastly if we did not get a reparse and we were</span>
01283 <span class="stringliteral">                    //  successful and the object is not null then everything</span>
01284 <span class="stringliteral">                    //  gets nicely returned to our caller</span>
01285 <span class="stringliteral">                    //</span>
01286 <span class="stringliteral"></span>
01287 <span class="stringliteral">                    if ( ( Status != STATUS_REPARSE ) &amp;&amp; </span>
01288 <span class="stringliteral">                         ( Status != STATUS_REPARSE_OBJECT )) {</span>
01289 <span class="stringliteral"></span>
01290 <span class="stringliteral">                        if (!NT_SUCCESS( Status )) {</span>
01291 <span class="stringliteral"></span>
01292 <span class="stringliteral">                            Object = NULL;</span>
01293 <span class="stringliteral"></span>
01294 <span class="stringliteral">                        } else if (Object == NULL) {</span>
01295 <span class="stringliteral"></span>
01296 <span class="stringliteral">                            Status = STATUS_OBJECT_NAME_NOT_FOUND;</span>
01297 <span class="stringliteral">                        }</span>
01298 <span class="stringliteral">    </span>
01299 <span class="stringliteral">                        ObDereferenceObject( RootDirectory );</span>
01300 <span class="stringliteral"></span>
01301 <span class="stringliteral">                        *FoundObject = Object;</span>
01302 <span class="stringliteral">                        </span>
01303 <span class="stringliteral">                        return( Status );</span>
01304 <span class="stringliteral"></span>
01305 <span class="stringliteral">                    //</span>
01306 <span class="stringliteral">                    //  We got a status reparse, which means the object</span>
01307 <span class="stringliteral">                    //  name has been modified to have use start all over</span>
01308 <span class="stringliteral">                    //  again.  If the reparse target is now empty or it</span>
01309 <span class="stringliteral">                    //  is a path separator then we start the parse at the</span>
01310 <span class="stringliteral">                    //  root directory</span>
01311 <span class="stringliteral">                    //</span>
01312 <span class="stringliteral"></span>
01313 <span class="stringliteral">                    } else if ((ObjectName-&gt;Length == 0) ||</span>
01314 <span class="stringliteral">                               (ObjectName-&gt;Buffer == NULL) ||</span>
01315 <span class="stringliteral">                               (*(ObjectName-&gt;Buffer) == OBJ_NAME_PATH_SEPARATOR)) {</span>
01316 <span class="stringliteral"></span>
01317 <span class="stringliteral">                        //</span>
01318 <span class="stringliteral">                        //  Restart the parse relative to the root directory.</span>
01319 <span class="stringliteral">                        //</span>
01320 <span class="stringliteral"></span>
01321 <span class="stringliteral">                        ObDereferenceObject( RootDirectory );</span>
01322 <span class="stringliteral"></span>
01323 <span class="stringliteral">                        RootDirectory = ObpRootDirectoryObject;</span>
01324 <span class="stringliteral">                        RootDirectoryHandle = NULL;</span>
01325 <span class="stringliteral"></span>
01326 <span class="stringliteral">                        break;</span>
01327 <span class="stringliteral"></span>
01328 <span class="stringliteral">                    //</span>
01329 <span class="stringliteral">                    //  We got a reparse and we actually have a new name to</span>
01330 <span class="stringliteral">                    //  go to we if we haven't exhausted our reparse attempts</span>
01331 <span class="stringliteral">                    //  yet then just continue to the top of this loop.</span>
01332 <span class="stringliteral">                    //</span>
01333 <span class="stringliteral"></span>
01334 <span class="stringliteral">                    } else if (--MaxReparse) {</span>
01335 <span class="stringliteral"></span>
01336 <span class="stringliteral">                        continue;</span>
01337 <span class="stringliteral"></span>
01338 <span class="stringliteral">                    //</span>
01339 <span class="stringliteral">                    //  We got a reparse and we've exhausted our times through</span>
01340 <span class="stringliteral">                    //  the loop so we'll return what we found.</span>
01341 <span class="stringliteral">                    //</span>
01342 <span class="stringliteral">                    //  **** this doesn't seem right.  It probably should be</span>
01343 <span class="stringliteral">                    //  an error</span>
01344 <span class="stringliteral">                    //</span>
01345 <span class="stringliteral"></span>
01346 <span class="stringliteral">                    } else {</span>
01347 <span class="stringliteral"></span>
01348 <span class="stringliteral">                        ObDereferenceObject( RootDirectory );</span>
01349 <span class="stringliteral"></span>
01350 <span class="stringliteral">                        *FoundObject = Object;</span>
01351 <span class="stringliteral"></span>
01352 <span class="stringliteral">                        //</span>
01353 <span class="stringliteral">                        //  At this point we were failing in stress by</span>
01354 <span class="stringliteral">                        //  returning to the caller with a success status but</span>
01355 <span class="stringliteral">                        //  a null object pointer.</span>
01356 <span class="stringliteral">                        //</span>
01357 <span class="stringliteral"></span>
01358 <span class="stringliteral">                        if (Object == NULL) {</span>
01359 <span class="stringliteral"></span>
01360 <span class="stringliteral">                            Status = STATUS_OBJECT_NAME_NOT_FOUND;</span>
01361 <span class="stringliteral">                        }</span>
01362 <span class="stringliteral"></span>
01363 <span class="stringliteral">                        return( Status );</span>
01364 <span class="stringliteral">                    }</span>
01365 <span class="stringliteral">                }</span>
01366 <span class="stringliteral">            }</span>
01367 <span class="stringliteral"></span>
01368 <span class="stringliteral">        //</span>
01369 <span class="stringliteral">        //  At this point the caller has given us the directory of object</span>
01370 <span class="stringliteral">        //  types.  If the caller didn't specify a name then we'll return</span>
01371 <span class="stringliteral">        //  a pointer to the root object directory.</span>
01372 <span class="stringliteral">        //</span>
01373 <span class="stringliteral"></span>
01374 <span class="stringliteral">        } else if ((ObjectName-&gt;Length == 0) ||</span>
01375 <span class="stringliteral">                   (ObjectName-&gt;Buffer == NULL)) {</span>
01376 <span class="stringliteral"></span>
01377 <span class="stringliteral">            Status = ObReferenceObjectByPointer( RootDirectory,</span>
01378 <span class="stringliteral">                                                 0,</span>
01379 <span class="stringliteral">                                                 ObjectType,</span>
01380 <span class="stringliteral">                                                 AccessMode );</span>
01381 <span class="stringliteral"></span>
01382 <span class="stringliteral">            if (NT_SUCCESS( Status )) {</span>
01383 <span class="stringliteral"></span>
01384 <span class="stringliteral">                Object = RootDirectory;</span>
01385 <span class="stringliteral">            }</span>
01386 <span class="stringliteral"></span>
01387 <span class="stringliteral">            ObDereferenceObject( RootDirectory );</span>
01388 <span class="stringliteral"></span>
01389 <span class="stringliteral">            *FoundObject = Object;</span>
01390 <span class="stringliteral"></span>
01391 <span class="stringliteral">            return( Status );</span>
01392 <span class="stringliteral">        }</span>
01393 <span class="stringliteral"></span>
01394 <span class="stringliteral">    //</span>
01395 <span class="stringliteral">    //  Otherwise the caller did not specify a directory to search so</span>
01396 <span class="stringliteral">    //  we'll default to the object root directory</span>
01397 <span class="stringliteral">    //</span>
01398 <span class="stringliteral"></span>
01399 <span class="stringliteral">    } else {</span>
01400 <span class="stringliteral"></span>
01401 <span class="stringliteral">        RootDirectory = ObpRootDirectoryObject;</span>
01402 <span class="stringliteral"></span>
01403 <span class="stringliteral">        //</span>
01404 <span class="stringliteral">        //  If the name we're looking for is empty then it is illformed.</span>
01405 <span class="stringliteral">        //  Also it has to start with a "</span>\<span class="stringliteral">" or it is illformed.</span>
01406 <span class="stringliteral">        //</span>
01407 <span class="stringliteral"></span>
01408 <span class="stringliteral">        if ((ObjectName-&gt;Length == 0) ||</span>
01409 <span class="stringliteral">            (ObjectName-&gt;Buffer == NULL) ||</span>
01410 <span class="stringliteral">            (*(ObjectName-&gt;Buffer) != OBJ_NAME_PATH_SEPARATOR)) {</span>
01411 <span class="stringliteral"></span>
01412 <span class="stringliteral">            return( STATUS_OBJECT_PATH_SYNTAX_BAD );</span>
01413 <span class="stringliteral">        }</span>
01414 <span class="stringliteral"></span>
01415 <span class="stringliteral">        //</span>
01416 <span class="stringliteral">        //  Check if the name is has only one character (that is the "</span>\<span class="stringliteral">")</span>
01417 <span class="stringliteral">        //  Which means that the caller really just wants to lookup the</span>
01418 <span class="stringliteral">        //  root directory.</span>
01419 <span class="stringliteral">        //</span>
01420 <span class="stringliteral"></span>
01421 <span class="stringliteral">        if (ObjectName-&gt;Length == sizeof( OBJ_NAME_PATH_SEPARATOR )) {</span>
01422 <span class="stringliteral"></span>
01423 <span class="stringliteral">            //</span>
01424 <span class="stringliteral">            //  If there is not a root directory yet.  Then we really</span>
01425 <span class="stringliteral">            //  can't return it, however if the caller specified</span>
01426 <span class="stringliteral">            //  an insert object that is the one we'll reference and</span>
01427 <span class="stringliteral">            //  return to our caller</span>
01428 <span class="stringliteral">            //</span>
01429 <span class="stringliteral"></span>
01430 <span class="stringliteral">            if (!RootDirectory) {</span>
01431 <span class="stringliteral"></span>
01432 <span class="stringliteral">                if (InsertObject) {</span>
01433 <span class="stringliteral"></span>
01434 <span class="stringliteral">                    Status = ObReferenceObjectByPointer( InsertObject,</span>
01435 <span class="stringliteral">                                                         0,</span>
01436 <span class="stringliteral">                                                         ObjectType,</span>
01437 <span class="stringliteral">                                                         AccessMode );</span>
01438 <span class="stringliteral"></span>
01439 <span class="stringliteral">                    if (NT_SUCCESS( Status )) {</span>
01440 <span class="stringliteral"></span>
01441 <span class="stringliteral">                        *FoundObject = InsertObject;</span>
01442 <span class="stringliteral">                    }</span>
01443 <span class="stringliteral"></span>
01444 <span class="stringliteral">                    return( Status );</span>
01445 <span class="stringliteral"></span>
01446 <span class="stringliteral">                } else {</span>
01447 <span class="stringliteral"></span>
01448 <span class="stringliteral">                    return( STATUS_INVALID_PARAMETER );</span>
01449 <span class="stringliteral">                }</span>
01450 <span class="stringliteral"></span>
01451 <span class="stringliteral">            //</span>
01452 <span class="stringliteral">            //  At this point the caller did not specify a root directory,</span>
01453 <span class="stringliteral">            //  the name is "</span>\<span class="stringliteral">" and the root object directory exists so</span>
01454 <span class="stringliteral">            //  we'll simply return the real root directory object</span>
01455 <span class="stringliteral">            //</span>
01456 <span class="stringliteral"></span>
01457 <span class="stringliteral">            } else {</span>
01458 <span class="stringliteral"></span>
01459 <span class="stringliteral">                Status = ObReferenceObjectByPointer( RootDirectory,</span>
01460 <span class="stringliteral">                                                     0,</span>
01461 <span class="stringliteral">                                                     ObjectType,</span>
01462 <span class="stringliteral">                                                     AccessMode );</span>
01463 <span class="stringliteral"></span>
01464 <span class="stringliteral">                if (NT_SUCCESS( Status )) {</span>
01465 <span class="stringliteral"></span>
01466 <span class="stringliteral">                    *FoundObject = RootDirectory;</span>
01467 <span class="stringliteral">                }</span>
01468 <span class="stringliteral"></span>
01469 <span class="stringliteral">                return( Status );</span>
01470 <span class="stringliteral">            }</span>
01471 <span class="stringliteral"></span>
01472 <span class="stringliteral">        //</span>
01473 <span class="stringliteral">        //  At this pointer the caller did not specify a root directory,</span>
01474 <span class="stringliteral">        //  and the name is more than just a "</span>\<span class="stringliteral">"</span>
01475 <span class="stringliteral">        //</span>
01476 <span class="stringliteral">        //  Now if the lookup is case insensitive, and the name buffer is a</span>
01477 <span class="stringliteral">        //  legitimate pointer (meaning that is it quadword aligned), and</span>
01478 <span class="stringliteral">        //  there is a dos device map for the process.  Then we'll handle</span>
01479 <span class="stringliteral">        //  the situation here. First get the device map and make sure it</span>
01480 <span class="stringliteral">        //  doesn't go away while we're using it.</span>
01481 <span class="stringliteral">        //</span>
01482 <span class="stringliteral"></span>
01483 <span class="stringliteral">        } else {</span>
01484 <span class="stringliteral"></span>
01485 <span class="stringliteral">            KIRQL OldIrql;</span>
01486 <span class="stringliteral"></span>
01487 <span class="stringliteral">            ExAcquireSpinLock( &amp;ObpDeviceMapLock, &amp;OldIrql );</span>
01488 <span class="stringliteral"></span>
01489 <span class="stringliteral">            if ((DeviceMap = PsGetCurrentProcess()-&gt;DeviceMap) != NULL) {</span>
01490 <span class="stringliteral"></span>
01491 <span class="stringliteral">                DeviceMap-&gt;ReferenceCount++;</span>
01492 <span class="stringliteral">                ExReleaseSpinLock( &amp;ObpDeviceMapLock, OldIrql );</span>
01493 <span class="stringliteral"></span>
01494 <span class="stringliteral">                if (!((ULONG_PTR)(ObjectName-&gt;Buffer) &amp; (sizeof(ULONGLONG)-1))</span>
01495 <span class="stringliteral"></span>
01496 <span class="stringliteral">                            &amp;&amp;</span>
01497 <span class="stringliteral"></span>
01498 <span class="stringliteral">                    (DeviceMap-&gt;DosDevicesDirectory != NULL )) {</span>
01499 <span class="stringliteral"></span>
01500 <span class="stringliteral">                    //</span>
01501 <span class="stringliteral">                    //  Check if the object name is actually equal to the</span>
01502 <span class="stringliteral">                    //  global dos devices short name prefix "</span>\??\<span class="stringliteral">"</span>
01503 <span class="stringliteral">                    //</span>
01504 <span class="stringliteral"></span>
01505 <span class="stringliteral">                    if ((ObjectName-&gt;Length &gt;= ObpDosDevicesShortName.Length)</span>
01506 <span class="stringliteral"></span>
01507 <span class="stringliteral">                            &amp;&amp;</span>
01508 <span class="stringliteral"></span>
01509 <span class="stringliteral">                        (*(PULONGLONG)(ObjectName-&gt;Buffer) == ObpDosDevicesShortNamePrefix.QuadPart)) {</span>
01510 <span class="stringliteral"></span>
01511 <span class="stringliteral">                        //</span>
01512 <span class="stringliteral">                        //  The user gave us the dos short name prefix so we'll</span>
01513 <span class="stringliteral">                        //  look down the directory, and start the search at the</span>
01514 <span class="stringliteral">                        //  dos device directory</span>
01515 <span class="stringliteral">                        //</span>
01516 <span class="stringliteral"></span>
01517 <span class="stringliteral">                        *DirectoryLocked = TRUE;</span>
01518 <span class="stringliteral"></span>
01519 <span class="stringliteral">                        ObpEnterRootDirectoryMutex();</span>
01520 <span class="stringliteral"></span>
01521 <span class="stringliteral">                        ParentDirectory = RootDirectory;</span>
01522 <span class="stringliteral"></span>
01523 <span class="stringliteral">                        Directory = DeviceMap-&gt;DosDevicesDirectory;</span>
01524 <span class="stringliteral"></span>
01525 <span class="stringliteral">                        RemainingName = *ObjectName;</span>
01526 <span class="stringliteral">                        RemainingName.Buffer += (ObpDosDevicesShortName.Length / sizeof( WCHAR ));</span>
01527 <span class="stringliteral">                        RemainingName.Length -= ObpDosDevicesShortName.Length;</span>
01528 <span class="stringliteral"></span>
01529 <span class="stringliteral">                        goto quickStart;</span>
01530 <span class="stringliteral"></span>
01531 <span class="stringliteral">                    //</span>
01532 <span class="stringliteral">                    //  The name is not equal to "</span>\??\<span class="stringliteral">" but check if it is</span>
01533 <span class="stringliteral">                    //  equal to "</span>\??<span class="stringliteral">"</span>
01534 <span class="stringliteral">                    //</span>
01535 <span class="stringliteral"></span>
01536 <span class="stringliteral">                    } else if ((ObjectName-&gt;Length == ObpDosDevicesShortName.Length - sizeof( WCHAR ))</span>
01537 <span class="stringliteral"></span>
01538 <span class="stringliteral">                                    &amp;&amp;</span>
01539 <span class="stringliteral"></span>
01540 <span class="stringliteral">                               (*(PULONG)(ObjectName-&gt;Buffer) == ObpDosDevicesShortNameRoot.LowPart)</span>
01541 <span class="stringliteral"></span>
01542 <span class="stringliteral">                                    &amp;&amp;</span>
01543 <span class="stringliteral"></span>
01544 <span class="stringliteral">                               (*((PWCHAR)(ObjectName-&gt;Buffer)+2) == (WCHAR)(ObpDosDevicesShortNameRoot.HighPart))) {</span>
01545 <span class="stringliteral"></span>
01546 <span class="stringliteral">                        //</span>
01547 <span class="stringliteral">                        //  The user specified "</span>\??<span class="stringliteral">" so we return to dos devices</span>
01548 <span class="stringliteral">                        //  directory to our caller</span>
01549 <span class="stringliteral">                        //</span>
01550 <span class="stringliteral"></span>
01551 <span class="stringliteral">                        Status = ObReferenceObjectByPointer( DeviceMap-&gt;DosDevicesDirectory,</span>
01552 <span class="stringliteral">                                                             0,</span>
01553 <span class="stringliteral">                                                             ObjectType,</span>
01554 <span class="stringliteral">                                                             AccessMode );</span>
01555 <span class="stringliteral"></span>
01556 <span class="stringliteral">                        if (NT_SUCCESS( Status )) {</span>
01557 <span class="stringliteral"></span>
01558 <span class="stringliteral">                            *FoundObject = DeviceMap-&gt;DosDevicesDirectory;</span>
01559 <span class="stringliteral">                        }</span>
01560 <span class="stringliteral"></span>
01561 <span class="stringliteral">                        //</span>
01562 <span class="stringliteral">                        //  Dereference the Device Map</span>
01563 <span class="stringliteral">                        //</span>
01564 <span class="stringliteral"></span>
01565 <span class="stringliteral">                        {</span>
01566 <span class="stringliteral">                            KIRQL OldIrql;</span>
01567 <span class="stringliteral"></span>
01568 <span class="stringliteral">                            ExAcquireSpinLock( &amp;ObpDeviceMapLock, &amp;OldIrql );</span>
01569 <span class="stringliteral"></span>
01570 <span class="stringliteral">                            DeviceMap-&gt;ReferenceCount--;</span>
01571 <span class="stringliteral"></span>
01572 <span class="stringliteral">                            if (DeviceMap-&gt;ReferenceCount == 0) {</span>
01573 <span class="stringliteral"></span>
01574 <span class="stringliteral">                                ExReleaseSpinLock( &amp;ObpDeviceMapLock, OldIrql );</span>
01575 <span class="stringliteral"></span>
01576 <span class="stringliteral">                                DeviceMap-&gt;DosDevicesDirectory-&gt;DeviceMap = NULL;</span>
01577 <span class="stringliteral">                                ObDereferenceObject( DeviceMap-&gt;DosDevicesDirectory );</span>
01578 <span class="stringliteral"></span>
01579 <span class="stringliteral">                                ExFreePool( DeviceMap );</span>
01580 <span class="stringliteral"></span>
01581 <span class="stringliteral">                            } else {</span>
01582 <span class="stringliteral"></span>
01583 <span class="stringliteral">                                ExReleaseSpinLock( &amp;ObpDeviceMapLock, OldIrql );</span>
01584 <span class="stringliteral">                            }</span>
01585 <span class="stringliteral">                        }</span>
01586 <span class="stringliteral"></span>
01587 <span class="stringliteral">                        return( Status );</span>
01588 <span class="stringliteral">                    }</span>
01589 <span class="stringliteral">                }</span>
01590 <span class="stringliteral"></span>
01591 <span class="stringliteral">            } else {</span>
01592 <span class="stringliteral"></span>
01593 <span class="stringliteral">                ExReleaseSpinLock( &amp;ObpDeviceMapLock, OldIrql );</span>
01594 <span class="stringliteral">            }</span>
01595 <span class="stringliteral">        }</span>
01596 <span class="stringliteral">    }</span>
01597 <span class="stringliteral"></span>
01598 <span class="stringliteral">    //</span>
01599 <span class="stringliteral">    //  At this point either</span>
01600 <span class="stringliteral">    //</span>
01601 <span class="stringliteral">    //  the user specified a directory that is not the object</span>
01602 <span class="stringliteral">    //  type directory and got repase back to the root directory</span>
01603 <span class="stringliteral">    //</span>
01604 <span class="stringliteral">    //  the user specified the object type directory and gave us</span>
01605 <span class="stringliteral">    //  a name to actually look up</span>
01606 <span class="stringliteral">    //</span>
01607 <span class="stringliteral">    //  the user did not specify a search directory (default</span>
01608 <span class="stringliteral">    //  to root object directory) and if the name did start off</span>
01609 <span class="stringliteral">    //  with the dos device prefix we've munged outselves back to</span>
01610 <span class="stringliteral">    //  it to the dos device directory for the process</span>
01611 <span class="stringliteral">    //</span>
01612 <span class="stringliteral"></span>
01613 <span class="stringliteral">    Reparse = TRUE;</span>
01614 <span class="stringliteral">    MaxReparse = OBJ_MAX_REPARSE_ATTEMPTS;</span>
01615 <span class="stringliteral"></span>
01616 <span class="stringliteral">    while (Reparse) {</span>
01617 <span class="stringliteral"></span>
01618 <span class="stringliteral">        RemainingName = *ObjectName;</span>
01619 <span class="stringliteral"></span>
01620 <span class="stringliteral">quickStart:</span>
01621 <span class="stringliteral"></span>
01622 <span class="stringliteral">        Reparse = FALSE;</span>
01623 <span class="stringliteral"></span>
01624 <span class="stringliteral">        while (TRUE) {</span>
01625 <span class="stringliteral"></span>
01626 <span class="stringliteral">            Object = NULL;</span>
01627 <span class="stringliteral"></span>
01628 <span class="stringliteral">            //if (RemainingName.Length == 0) {</span>
01629 <span class="stringliteral">            //    Status = STATUS_OBJECT_NAME_INVALID;</span>
01630 <span class="stringliteral">            //    break;</span>
01631 <span class="stringliteral">            //    }</span>
01632 <span class="stringliteral"></span>
01633 <span class="stringliteral">            //</span>
01634 <span class="stringliteral">            //  If the remaining name for the object starts with a</span>
01635 <span class="stringliteral">            //  "</span>\<span class="stringliteral">" then just gobble up the "</span>\<span class="stringliteral">"</span>
01636 <span class="stringliteral">            //</span>
01637 <span class="stringliteral"></span>
01638 <span class="stringliteral">            if ( (RemainingName.Length != 0) &amp;&amp;</span>
01639 <span class="stringliteral">                 (*(RemainingName.Buffer) == OBJ_NAME_PATH_SEPARATOR) ) {</span>
01640 <span class="stringliteral"></span>
01641 <span class="stringliteral">                RemainingName.Buffer++;</span>
01642 <span class="stringliteral">                RemainingName.Length -= sizeof( OBJ_NAME_PATH_SEPARATOR );</span>
01643 <span class="stringliteral">            }</span>
01644 <span class="stringliteral"></span>
01645 <span class="stringliteral">            //</span>
01646 <span class="stringliteral">            //  The following piece of code will calculate the first</span>
01647 <span class="stringliteral">            //  component of the remaining name.  If there is not</span>
01648 <span class="stringliteral">            //  a remaining component then the object name is illformed</span>
01649 <span class="stringliteral">            //</span>
01650 <span class="stringliteral"></span>
01651 <span class="stringliteral">            ComponentName = RemainingName;</span>
01652 <span class="stringliteral"></span>
01653 <span class="stringliteral">            while (RemainingName.Length != 0) {</span>
01654 <span class="stringliteral"></span>
01655 <span class="stringliteral">                if (*(RemainingName.Buffer) == OBJ_NAME_PATH_SEPARATOR) {</span>
01656 <span class="stringliteral"></span>
01657 <span class="stringliteral">                    break;</span>
01658 <span class="stringliteral">                }</span>
01659 <span class="stringliteral"></span>
01660 <span class="stringliteral">                RemainingName.Buffer++;</span>
01661 <span class="stringliteral">                RemainingName.Length -= sizeof( OBJ_NAME_PATH_SEPARATOR );</span>
01662 <span class="stringliteral">            }</span>
01663 <span class="stringliteral"></span>
01664 <span class="stringliteral">            ComponentName.Length -= RemainingName.Length;</span>
01665 <span class="stringliteral"></span>
01666 <span class="stringliteral">            if (ComponentName.Length == 0) {</span>
01667 <span class="stringliteral"></span>
01668 <span class="stringliteral">                Status = STATUS_OBJECT_NAME_INVALID;</span>
01669 <span class="stringliteral">                break;</span>
01670 <span class="stringliteral">            }</span>
01671 <span class="stringliteral"></span>
01672 <span class="stringliteral">            //</span>
01673 <span class="stringliteral">            //  Now we have the first component name to lookup so we'll</span>
01674 <span class="stringliteral">            //  look the directory is necessary</span>
01675 <span class="stringliteral">            //</span>
01676 <span class="stringliteral"></span>
01677 <span class="stringliteral">            if (!*DirectoryLocked) {</span>
01678 <span class="stringliteral"></span>
01679 <span class="stringliteral">                *DirectoryLocked = TRUE;</span>
01680 <span class="stringliteral">                ObpEnterRootDirectoryMutex();</span>
01681 <span class="stringliteral">                Directory = RootDirectory;</span>
01682 <span class="stringliteral">            }</span>
01683 <span class="stringliteral"></span>
01684 <span class="stringliteral">            //</span>
01685 <span class="stringliteral">            //  Now if the caller does not have traverse privilege and</span>
01686 <span class="stringliteral">            //  there is a parent directory then we must check if the</span>
01687 <span class="stringliteral">            //  user has traverse access to the directory.  Our local</span>
01688 <span class="stringliteral">            //  Reparse variable should be false at this point so we'll</span>
01689 <span class="stringliteral">            //  drop out of both loops</span>
01690 <span class="stringliteral">            //</span>
01691 <span class="stringliteral"></span>
01692 <span class="stringliteral">            if ( !(AccessState-&gt;Flags &amp; TOKEN_HAS_TRAVERSE_PRIVILEGE) &amp;&amp; (ParentDirectory != NULL) ) {</span>
01693 <span class="stringliteral"></span>
01694 <span class="stringliteral">                if (!ObpCheckTraverseAccess( ParentDirectory,</span>
01695 <span class="stringliteral">                                             DIRECTORY_TRAVERSE,</span>
01696 <span class="stringliteral">                                             AccessState,</span>
01697 <span class="stringliteral">                                             FALSE,</span>
01698 <span class="stringliteral">                                             AccessMode,</span>
01699 <span class="stringliteral">                                             &amp;Status )) {</span>
01700 <span class="stringliteral"></span>
01701 <span class="stringliteral">                    break;</span>
01702 <span class="stringliteral">                }</span>
01703 <span class="stringliteral">            }</span>
01704 <span class="stringliteral"></span>
01705 <span class="stringliteral">            //</span>
01706 <span class="stringliteral">            //  If the object already exists in this directory, find it,</span>
01707 <span class="stringliteral">            //  else return NULL.</span>
01708 <span class="stringliteral">            //</span>
01709 <span class="stringliteral"></span>
01710 <span class="stringliteral">            Object = ObpLookupDirectoryEntry( Directory, &amp;ComponentName, Attributes );</span>
01711 <span class="stringliteral"></span>
01712 <span class="stringliteral">            if (!Object) {</span>
01713 <span class="stringliteral"></span>
01714 <span class="stringliteral">                //</span>
01715 <span class="stringliteral">                //  We didn't find the object.  If there is some remaining</span>
01716 <span class="stringliteral">                //  name left (meaning the component name is a directory in</span>
01717 <span class="stringliteral">                //  path we trying to break) or the caller didn't specify an</span>
01718 <span class="stringliteral">                //  insert object then we then we'll break out here with an</span>
01719 <span class="stringliteral">                //  error status</span>
01720 <span class="stringliteral">                //</span>
01721 <span class="stringliteral"></span>
01722 <span class="stringliteral">                if (RemainingName.Length != 0) {</span>
01723 <span class="stringliteral"></span>
01724 <span class="stringliteral">                    Status = STATUS_OBJECT_PATH_NOT_FOUND;</span>
01725 <span class="stringliteral">                    break;</span>
01726 <span class="stringliteral">                }</span>
01727 <span class="stringliteral"></span>
01728 <span class="stringliteral">                if (!InsertObject) {</span>
01729 <span class="stringliteral"></span>
01730 <span class="stringliteral">                    Status = STATUS_OBJECT_NAME_NOT_FOUND;</span>
01731 <span class="stringliteral">                    break;</span>
01732 <span class="stringliteral">                }</span>
01733 <span class="stringliteral"></span>
01734 <span class="stringliteral">                //</span>
01735 <span class="stringliteral">                //  Check that the caller has the access to the directory</span>
01736 <span class="stringliteral">                //  to either create a subdirectory (in the object type</span>
01737 <span class="stringliteral">                //  directory) or to create an object of the given component</span>
01738 <span class="stringliteral">                //  name.  If the call fails then we'll break out of here</span>
01739 <span class="stringliteral">                //  with the status value set</span>
01740 <span class="stringliteral">                //</span>
01741 <span class="stringliteral"></span>
01742 <span class="stringliteral">                if (!ObCheckCreateObjectAccess( Directory,</span>
01743 <span class="stringliteral">                                                ObjectType == ObpDirectoryObjectType ?</span>
01744 <span class="stringliteral">                                                        DIRECTORY_CREATE_SUBDIRECTORY :</span>
01745 <span class="stringliteral">                                                        DIRECTORY_CREATE_OBJECT,</span>
01746 <span class="stringliteral">                                                AccessState,</span>
01747 <span class="stringliteral">                                                &amp;ComponentName,</span>
01748 <span class="stringliteral">                                                FALSE,</span>
01749 <span class="stringliteral">                                                AccessMode,</span>
01750 <span class="stringliteral">                                                &amp;Status )) {</span>
01751 <span class="stringliteral"></span>
01752 <span class="stringliteral">                    break;</span>
01753 <span class="stringliteral">                }</span>
01754 <span class="stringliteral"></span>
01755 <span class="stringliteral">                //</span>
01756 <span class="stringliteral">                //  The object does not exist in the directory and</span>
01757 <span class="stringliteral">                //  we are allowed to create one.  So allocate space</span>
01758 <span class="stringliteral">                //  for the name and insert the name into the directory</span>
01759 <span class="stringliteral">                //</span>
01760 <span class="stringliteral"></span>
01761 <span class="stringliteral">                NewName = ExAllocatePoolWithTag( PagedPool, ComponentName.Length, 'mNbO' );</span>
01762 <span class="stringliteral"></span>
01763 <span class="stringliteral">                if ((NewName == NULL) ||</span>
01764 <span class="stringliteral">                    !ObpInsertDirectoryEntry( Directory, InsertObject )) {</span>
01765 <span class="stringliteral"></span>
01766 <span class="stringliteral">                    if (NewName != NULL) {</span>
01767 <span class="stringliteral"></span>
01768 <span class="stringliteral">                        ExFreePool( NewName );</span>
01769 <span class="stringliteral">                    }</span>
01770 <span class="stringliteral"></span>
01771 <span class="stringliteral">                    Status = STATUS_INSUFFICIENT_RESOURCES;</span>
01772 <span class="stringliteral">                    break;</span>
01773 <span class="stringliteral">                }</span>
01774 <span class="stringliteral"></span>
01775 <span class="stringliteral">                //</span>
01776 <span class="stringliteral">                //  We have an insert object so now get its name info,</span>
01777 <span class="stringliteral">                //  because we are going to change its name and insert it</span>
01778 <span class="stringliteral">                //  into the directory</span>
01779 <span class="stringliteral">                //</span>
01780 <span class="stringliteral"></span>
01781 <span class="stringliteral">                ObReferenceObject( InsertObject );</span>
01782 <span class="stringliteral"></span>
01783 <span class="stringliteral">                ObjectHeader = OBJECT_TO_OBJECT_HEADER( InsertObject );</span>
01784 <span class="stringliteral"></span>
01785 <span class="stringliteral">                NameInfo = OBJECT_HEADER_TO_NAME_INFO( ObjectHeader );</span>
01786 <span class="stringliteral"></span>
01787 <span class="stringliteral">                ObReferenceObject( Directory );</span>
01788 <span class="stringliteral"></span>
01789 <span class="stringliteral">                RtlMoveMemory( NewName,</span>
01790 <span class="stringliteral">                               ComponentName.Buffer,</span>
01791 <span class="stringliteral">                               ComponentName.Length );</span>
01792 <span class="stringliteral"></span>
01793 <span class="stringliteral">                if (NameInfo-&gt;Name.Buffer) {</span>
01794 <span class="stringliteral"></span>
01795 <span class="stringliteral">                    ExFreePool( NameInfo-&gt;Name.Buffer );</span>
01796 <span class="stringliteral">                }</span>
01797 <span class="stringliteral"></span>
01798 <span class="stringliteral">                NameInfo-&gt;Name.Buffer = NewName;</span>
01799 <span class="stringliteral">                NameInfo-&gt;Name.Length = ComponentName.Length;</span>
01800 <span class="stringliteral">                NameInfo-&gt;Name.MaximumLength = ComponentName.Length;</span>
01801 <span class="stringliteral"></span>
01802 <span class="stringliteral">                Object = InsertObject;</span>
01803 <span class="stringliteral"></span>
01804 <span class="stringliteral">                Status = STATUS_SUCCESS;</span>
01805 <span class="stringliteral"></span>
01806 <span class="stringliteral">                break;</span>
01807 <span class="stringliteral">            }</span>
01808 <span class="stringliteral"></span>
01809 <span class="stringliteral">            //</span>
01810 <span class="stringliteral">            //  At this point we've found the component name within</span>
01811 <span class="stringliteral">            //  the directory.  So we'll now grab the components object</span>
01812 <span class="stringliteral">            //  header, and get its parse routine</span>
01813 <span class="stringliteral">            //</span>
01814 <span class="stringliteral"></span>
01815 <span class="stringliteral">ReparseObject:</span>
01816 <span class="stringliteral"></span>
01817 <span class="stringliteral">            ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );</span>
01818 <span class="stringliteral">            ParseProcedure = ObjectHeader-&gt;Type-&gt;TypeInfo.ParseProcedure;</span>
01819 <span class="stringliteral"></span>
01820 <span class="stringliteral">            //</span>
01821 <span class="stringliteral">            //  Now if there is a parse routine for the type and we are not</span>
01822 <span class="stringliteral">            //  inserting a new object or the parse routine is for symbolic</span>
01823 <span class="stringliteral">            //  links then we'll actually call the parse routine</span>
01824 <span class="stringliteral">            //</span>
01825 <span class="stringliteral"></span>
01826 <span class="stringliteral">            if (ParseProcedure &amp;&amp; (!InsertObject || (ParseProcedure == ObpParseSymbolicLink))) {</span>
01827 <span class="stringliteral"></span>
01828 <span class="stringliteral">                KIRQL SaveIrql;</span>
01829 <span class="stringliteral"></span>
01830 <span class="stringliteral">                //</span>
01831 <span class="stringliteral">                //  Reference the object and then free the directory lock</span>
01832 <span class="stringliteral">                //  This will keep the object from going away with the</span>
01833 <span class="stringliteral">                //  directory unlocked</span>
01834 <span class="stringliteral">                //</span>
01835 <span class="stringliteral"></span>
01836 <span class="stringliteral">                ObpIncrPointerCount( ObjectHeader );</span>
01837 <span class="stringliteral"></span>
01838 <span class="stringliteral">                ASSERT(*DirectoryLocked);</span>
01839 <span class="stringliteral"></span>
01840 <span class="stringliteral">                ObpLeaveRootDirectoryMutex();</span>
01841 <span class="stringliteral"></span>
01842 <span class="stringliteral">                *DirectoryLocked = FALSE;</span>
01843 <span class="stringliteral"></span>
01844 <span class="stringliteral">                ObpBeginTypeSpecificCallOut( SaveIrql );</span>
01845 <span class="stringliteral"></span>
01846 <span class="stringliteral">                //</span>
01847 <span class="stringliteral">                //  Call the objects parse routine</span>
01848 <span class="stringliteral">                //</span>
01849 <span class="stringliteral"></span>
01850 <span class="stringliteral">                Status = (*ParseProcedure)( Object,</span>
01851 <span class="stringliteral">                                            (PVOID)ObjectType,</span>
01852 <span class="stringliteral">                                            AccessState,</span>
01853 <span class="stringliteral">                                            AccessMode,</span>
01854 <span class="stringliteral">                                            Attributes,</span>
01855 <span class="stringliteral">                                            ObjectName,</span>
01856 <span class="stringliteral">                                            &amp;RemainingName,</span>
01857 <span class="stringliteral">                                            ParseContext,</span>
01858 <span class="stringliteral">                                            SecurityQos,</span>
01859 <span class="stringliteral">                                            &amp;Object );</span>
01860 <span class="stringliteral"></span>
01861 <span class="stringliteral">                ObpEndTypeSpecificCallOut( SaveIrql, "</span>Parse<span class="stringliteral">", ObjectHeader-&gt;Type, Object );</span>
01862 <span class="stringliteral"></span>
01863 <span class="stringliteral">                //</span>
01864 <span class="stringliteral">                //  We can now decrement the object reference count</span>
01865 <span class="stringliteral">                //</span>
01866 <span class="stringliteral"></span>
01867 <span class="stringliteral">                ObDereferenceObject( &amp;ObjectHeader-&gt;Body );</span>
01868 <span class="stringliteral"></span>
01869 <span class="stringliteral">                //</span>
01870 <span class="stringliteral">                //  Check if we have some reparsing to do</span>
01871 <span class="stringliteral">                //</span>
01872 <span class="stringliteral"></span>
01873 <span class="stringliteral">                if ((Status == STATUS_REPARSE) || (Status == STATUS_REPARSE_OBJECT)) {</span>
01874 <span class="stringliteral"></span>
01875 <span class="stringliteral">                    //</span>
01876 <span class="stringliteral">                    //  See if we've reparsed too many times already and if</span>
01877 <span class="stringliteral">                    //  so we'll fail the request</span>
01878 <span class="stringliteral">                    //</span>
01879 <span class="stringliteral"></span>
01880 <span class="stringliteral">                    if (--MaxReparse) {</span>
01881 <span class="stringliteral"></span>
01882 <span class="stringliteral">                        //</span>
01883 <span class="stringliteral">                        //  Tell the outer loop to continue looping</span>
01884 <span class="stringliteral">                        //</span>
01885 <span class="stringliteral"></span>
01886 <span class="stringliteral">                        Reparse = TRUE;</span>
01887 <span class="stringliteral"></span>
01888 <span class="stringliteral">                        //</span>
01889 <span class="stringliteral">                        //  Check if we have a reparse object or the name</span>
01890 <span class="stringliteral">                        //  starts with a "</span>\<span class="stringliteral">"</span>
01891 <span class="stringliteral">                        //</span>
01892 <span class="stringliteral"></span>
01893 <span class="stringliteral">                        if ((Status == STATUS_REPARSE_OBJECT) ||</span>
01894 <span class="stringliteral">                            (*(ObjectName-&gt;Buffer) == OBJ_NAME_PATH_SEPARATOR)) {</span>
01895 <span class="stringliteral"></span>
01896 <span class="stringliteral">                            //</span>
01897 <span class="stringliteral">                            //  If the user specified a start directory then</span>
01898 <span class="stringliteral">                            //  remove this information because we're taking</span>
01899 <span class="stringliteral">                            //  a reparse point to someplace else</span>
01900 <span class="stringliteral">                             //</span>
01901 <span class="stringliteral"></span>
01902 <span class="stringliteral">                            if (ARGUMENT_PRESENT( RootDirectoryHandle )) {</span>
01903 <span class="stringliteral"></span>
01904 <span class="stringliteral">                                ObDereferenceObject( RootDirectory );</span>
01905 <span class="stringliteral">                                RootDirectoryHandle = NULL;</span>
01906 <span class="stringliteral">                            }</span>
01907 <span class="stringliteral"></span>
01908 <span class="stringliteral">                            //</span>
01909 <span class="stringliteral">                            //  And where we start is the root directory</span>
01910 <span class="stringliteral">                            //  object</span>
01911 <span class="stringliteral">                            //</span>
01912 <span class="stringliteral"></span>
01913 <span class="stringliteral">                            ParentDirectory = NULL;</span>
01914 <span class="stringliteral">                            RootDirectory = ObpRootDirectoryObject;</span>
01915 <span class="stringliteral"></span>
01916 <span class="stringliteral">                            //</span>
01917 <span class="stringliteral">                            //  Now if this is a reparse object (means we have</span>
01918 <span class="stringliteral">                            //  encountered a symbolic link that has already been</span>
01919 <span class="stringliteral">                            //  snapped so we have an object and remaining</span>
01920 <span class="stringliteral">                            //  name that need to be examined) and we didn't</span>
01921 <span class="stringliteral">                            //  find an object from the parse routine object</span>
01922 <span class="stringliteral">                            //  break out of both loops.</span>
01923 <span class="stringliteral">                            //</span>
01924 <span class="stringliteral"></span>
01925 <span class="stringliteral">                            if (Status == STATUS_REPARSE_OBJECT) {</span>
01926 <span class="stringliteral"></span>
01927 <span class="stringliteral">                                Reparse = FALSE;</span>
01928 <span class="stringliteral"></span>
01929 <span class="stringliteral">                                if (Object == NULL) {</span>
01930 <span class="stringliteral"></span>
01931 <span class="stringliteral">                                    Status = STATUS_OBJECT_NAME_NOT_FOUND;</span>
01932 <span class="stringliteral"></span>
01933 <span class="stringliteral">                                } else {</span>
01934 <span class="stringliteral"></span>
01935 <span class="stringliteral">                                    //</span>
01936 <span class="stringliteral">                                    //  At this point we have a reparse object</span>
01937 <span class="stringliteral">                                    //  so we'll look the directory down and</span>
01938 <span class="stringliteral">                                    //  parse the new object</span>
01939 <span class="stringliteral">                                    //</span>
01940 <span class="stringliteral"></span>
01941 <span class="stringliteral">                                    *DirectoryLocked = TRUE;</span>
01942 <span class="stringliteral">                                    ObpEnterRootDirectoryMutex();</span>
01943 <span class="stringliteral"></span>
01944 <span class="stringliteral">                                    goto ReparseObject;</span>
01945 <span class="stringliteral">                                }</span>
01946 <span class="stringliteral">                            }</span>
01947 <span class="stringliteral"></span>
01948 <span class="stringliteral">                        //</span>
01949 <span class="stringliteral">                        //  We did not have a reparse object and the name</span>
01950 <span class="stringliteral">                        //  does not start with a "</span>\<span class="stringliteral">".  Meaning we got back</span>
01951 <span class="stringliteral">                        //  STATUS_REPASE, so now check if the directory</span>
01952 <span class="stringliteral">                        //  is the root object directory and if so then</span>
01953 <span class="stringliteral">                        //  we didn't the name otherwise we'll drop out of</span>
01954 <span class="stringliteral">                        //  the inner loop and reparse true to get back to</span>
01955 <span class="stringliteral">                        //  outer loop</span>
01956 <span class="stringliteral">                        //</span>
01957 <span class="stringliteral"></span>
01958 <span class="stringliteral">                        } else if (RootDirectory == ObpRootDirectoryObject) {</span>
01959 <span class="stringliteral"></span>
01960 <span class="stringliteral">                            Object = NULL;</span>
01961 <span class="stringliteral">                            Status = STATUS_OBJECT_NAME_NOT_FOUND;</span>
01962 <span class="stringliteral"></span>
01963 <span class="stringliteral">                            Reparse = FALSE;</span>
01964 <span class="stringliteral">                        }</span>
01965 <span class="stringliteral"></span>
01966 <span class="stringliteral">                    } else {</span>
01967 <span class="stringliteral"></span>
01968 <span class="stringliteral">                        //</span>
01969 <span class="stringliteral">                        //  **** this should probably be a differnt error</span>
01970 <span class="stringliteral">                        //  status related to too many reparse points</span>
01971 <span class="stringliteral">                        //</span>
01972 <span class="stringliteral"></span>
01973 <span class="stringliteral">                        Object = NULL;</span>
01974 <span class="stringliteral">                        Status = STATUS_OBJECT_NAME_NOT_FOUND;</span>
01975 <span class="stringliteral">                    }</span>
01976 <span class="stringliteral"></span>
01977 <span class="stringliteral">                //</span>
01978 <span class="stringliteral">                //  We are not reparsing and if we did not get success then</span>
01979 <span class="stringliteral">                //  the object is null and we'll break out of our loops</span>
01980 <span class="stringliteral">                //</span>
01981 <span class="stringliteral"></span>
01982 <span class="stringliteral">                } else if (!NT_SUCCESS( Status )) {</span>
01983 <span class="stringliteral"></span>
01984 <span class="stringliteral">                    Object = NULL;</span>
01985 <span class="stringliteral"></span>
01986 <span class="stringliteral">                //</span>
01987 <span class="stringliteral">                //  We are not reparsing and we got back success but check</span>
01988 <span class="stringliteral">                //  if the object is null because that means we really didn't</span>
01989 <span class="stringliteral">                //  find the object, and then break out of our loops</span>
01990 <span class="stringliteral">                //</span>
01991 <span class="stringliteral">                //  If the object is not null then we've been successful and</span>
01992 <span class="stringliteral">                //  prosperous so break out with the object set.</span>
01993 <span class="stringliteral">                //</span>
01994 <span class="stringliteral"></span>
01995 <span class="stringliteral">                } else if (Object == NULL) {</span>
01996 <span class="stringliteral"></span>
01997 <span class="stringliteral">                    Status = STATUS_OBJECT_NAME_NOT_FOUND;</span>
01998 <span class="stringliteral">                }</span>
01999 <span class="stringliteral"></span>
02000 <span class="stringliteral">                break;</span>
02001 <span class="stringliteral"></span>
02002 <span class="stringliteral">            } else {</span>
02003 <span class="stringliteral"></span>
02004 <span class="stringliteral">                //</span>
02005 <span class="stringliteral">                //  At this point we do not have a parse routine or if there</span>
02006 <span class="stringliteral">                //  is a parse routine it is not for symbolic links or there</span>
02007 <span class="stringliteral">                //  may not be a specified insert object</span>
02008 <span class="stringliteral">                //</span>
02009 <span class="stringliteral">                //  Check to see if we have exhausted the remaining name</span>
02010 <span class="stringliteral">                //</span>
02011 <span class="stringliteral"></span>
02012 <span class="stringliteral">                if (RemainingName.Length == 0) {</span>
02013 <span class="stringliteral"></span>
02014 <span class="stringliteral">                    //</span>
02015 <span class="stringliteral">                    //  Check if the caller specified an object to insert.</span>
02016 <span class="stringliteral">                    //  If specified then we'll break out of our loops with</span>
02017 <span class="stringliteral">                    //  the object that we've found</span>
02018 <span class="stringliteral">                    //</span>
02019 <span class="stringliteral"></span>
02020 <span class="stringliteral">                    if (!InsertObject) {</span>
02021 <span class="stringliteral"></span>
02022 <span class="stringliteral">                        //</span>
02023 <span class="stringliteral">                        //  The user did not specify an insert object</span>
02024 <span class="stringliteral">                        //  so we're opening an existing object.  Make sure</span>
02025 <span class="stringliteral">                        //  we have traverse access to the container</span>
02026 <span class="stringliteral">                        //  directory.</span>
02027 <span class="stringliteral">                        //</span>
02028 <span class="stringliteral"></span>
02029 <span class="stringliteral">                        if ( !(AccessState-&gt;Flags &amp; TOKEN_HAS_TRAVERSE_PRIVILEGE) ) {</span>
02030 <span class="stringliteral"></span>
02031 <span class="stringliteral">                            if (!ObpCheckTraverseAccess( Directory,</span>
02032 <span class="stringliteral">                                                         DIRECTORY_TRAVERSE,</span>
02033 <span class="stringliteral">                                                         AccessState,</span>
02034 <span class="stringliteral">                                                         FALSE,</span>
02035 <span class="stringliteral">                                                         AccessMode,</span>
02036 <span class="stringliteral">                                                         &amp;Status )) {</span>
02037 <span class="stringliteral"></span>
02038 <span class="stringliteral">                                Object = NULL;</span>
02039 <span class="stringliteral">                                break;</span>
02040 <span class="stringliteral">                            }</span>
02041 <span class="stringliteral">                        }</span>
02042 <span class="stringliteral"></span>
02043 <span class="stringliteral">                        Status = ObReferenceObjectByPointer( Object,</span>
02044 <span class="stringliteral">                                                             0,</span>
02045 <span class="stringliteral">                                                             ObjectType,</span>
02046 <span class="stringliteral">                                                             AccessMode );</span>
02047 <span class="stringliteral"></span>
02048 <span class="stringliteral">                        if (!NT_SUCCESS( Status )) {</span>
02049 <span class="stringliteral"></span>
02050 <span class="stringliteral">                            Object = NULL;</span>
02051 <span class="stringliteral">                        }</span>
02052 <span class="stringliteral">                    }</span>
02053 <span class="stringliteral"></span>
02054 <span class="stringliteral">                    break;</span>
02055 <span class="stringliteral"></span>
02056 <span class="stringliteral">                } else {</span>
02057 <span class="stringliteral"></span>
02058 <span class="stringliteral">                    //</span>
02059 <span class="stringliteral">                    //  There is some name remaining names to process</span>
02060 <span class="stringliteral">                    //  if the directory we're looking at is the</span>
02061 <span class="stringliteral">                    //  directory of object types and set ourselves</span>
02062 <span class="stringliteral">                    //  up to parse it all over again.</span>
02063 <span class="stringliteral">                    //</span>
02064 <span class="stringliteral"></span>
02065 <span class="stringliteral">                    if (ObjectHeader-&gt;Type == ObpDirectoryObjectType) {</span>
02066 <span class="stringliteral"></span>
02067 <span class="stringliteral">                        ParentDirectory = Directory;</span>
02068 <span class="stringliteral">                        Directory = (POBJECT_DIRECTORY)Object;</span>
02069 <span class="stringliteral"></span>
02070 <span class="stringliteral">                    } else {</span>
02071 <span class="stringliteral"></span>
02072 <span class="stringliteral">                        //</span>
02073 <span class="stringliteral">                        //  Otherwise there has been a mismatch so we'll</span>
02074 <span class="stringliteral">                        //  set our error status and break out of the</span>
02075 <span class="stringliteral">                        //  loops</span>
02076 <span class="stringliteral">                        //</span>
02077 <span class="stringliteral"></span>
02078 <span class="stringliteral">                        Status = STATUS_OBJECT_TYPE_MISMATCH;</span>
02079 <span class="stringliteral">                        Object = NULL;</span>
02080 <span class="stringliteral"></span>
02081 <span class="stringliteral">                        break;</span>
02082 <span class="stringliteral">                    }</span>
02083 <span class="stringliteral">                }</span>
02084 <span class="stringliteral">            }</span>
02085 <span class="stringliteral">        }</span>
02086 <span class="stringliteral">    }</span>
02087 <span class="stringliteral"></span>
02088 <span class="stringliteral">    //</span>
02089 <span class="stringliteral">    //  If the device map has been referenced then dereference it</span>
02090 <span class="stringliteral">    //</span>
02091 <span class="stringliteral"></span>
02092 <span class="stringliteral">    if (DeviceMap != NULL) {</span>
02093 <span class="stringliteral"></span>
02094 <span class="stringliteral">        KIRQL OldIrql;</span>
02095 <span class="stringliteral"></span>
02096 <span class="stringliteral">        ExAcquireSpinLock( &amp;ObpDeviceMapLock, &amp;OldIrql );</span>
02097 <span class="stringliteral"></span>
02098 <span class="stringliteral">        DeviceMap-&gt;ReferenceCount--;</span>
02099 <span class="stringliteral"></span>
02100 <span class="stringliteral">        if (DeviceMap-&gt;ReferenceCount == 0) {</span>
02101 <span class="stringliteral"></span>
02102 <span class="stringliteral">            ExReleaseSpinLock( &amp;ObpDeviceMapLock, OldIrql );</span>
02103 <span class="stringliteral"></span>
02104 <span class="stringliteral">            DeviceMap-&gt;DosDevicesDirectory-&gt;DeviceMap = NULL;</span>
02105 <span class="stringliteral">            ObDereferenceObject( DeviceMap-&gt;DosDevicesDirectory );</span>
02106 <span class="stringliteral"></span>
02107 <span class="stringliteral">            ExFreePool( DeviceMap );</span>
02108 <span class="stringliteral"></span>
02109 <span class="stringliteral">        } else {</span>
02110 <span class="stringliteral"></span>
02111 <span class="stringliteral">            ExReleaseSpinLock( &amp;ObpDeviceMapLock, OldIrql );</span>
02112 <span class="stringliteral">        }</span>
02113 <span class="stringliteral">    }</span>
02114 <span class="stringliteral"></span>
02115 <span class="stringliteral">    //</span>
02116 <span class="stringliteral">    //  At this point we've parsed the object name as much as possible</span>
02117 <span class="stringliteral">    //  going through symbolic links as necessary.  So now set the</span>
02118 <span class="stringliteral">    //  output object pointer, and if we really did not find an object</span>
02119 <span class="stringliteral">    //  then we might need to modify the error status.  If the</span>
02120 <span class="stringliteral">    //  status was repase or some success status then translate it</span>
02121 <span class="stringliteral">    //  to name not found.</span>
02122 <span class="stringliteral">    //</span>
02123 <span class="stringliteral"></span>
02124 <span class="stringliteral">    if (!(*FoundObject = Object)) {</span>
02125 <span class="stringliteral"></span>
02126 <span class="stringliteral">        if (Status == STATUS_REPARSE) {</span>
02127 <span class="stringliteral"></span>
02128 <span class="stringliteral">            Status = STATUS_OBJECT_NAME_NOT_FOUND;</span>
02129 <span class="stringliteral"></span>
02130 <span class="stringliteral">        } else if (NT_SUCCESS( Status )) {</span>
02131 <span class="stringliteral"></span>
02132 <span class="stringliteral">            Status = STATUS_OBJECT_NAME_NOT_FOUND;</span>
02133 <span class="stringliteral">        }</span>
02134 <span class="stringliteral">    }</span>
02135 <span class="stringliteral"></span>
02136 <span class="stringliteral">    //</span>
02137 <span class="stringliteral">    //  If the caller gave us a root directory to search (and we didn't</span>
02138 <span class="stringliteral">    //  zero out this value) then free up our reference</span>
02139 <span class="stringliteral">    //</span>
02140 <span class="stringliteral"></span>
02141 <span class="stringliteral">    if (ARGUMENT_PRESENT( RootDirectoryHandle )) {</span>
02142 <span class="stringliteral"></span>
02143 <span class="stringliteral">        ObDereferenceObject( RootDirectory );</span>
02144 <span class="stringliteral">        RootDirectoryHandle = NULL;</span>
02145 <span class="stringliteral">    }</span>
02146 <span class="stringliteral"></span>
02147 <span class="stringliteral">    //</span>
02148 <span class="stringliteral">    //  And return to our caller</span>
02149 <span class="stringliteral">    //</span>
02150 <span class="stringliteral"></span>
02151 <span class="stringliteral">    return( Status );</span>
02152 <span class="stringliteral">}</span>
</span>
</div></pre>    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:44:57 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
