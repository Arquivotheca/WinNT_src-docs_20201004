<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: cmwrapr.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>cmwrapr.c</h1><a href="../../d7/d3/cmwrapr_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1991  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    cmwrapr.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module contains the source for wrapper routines called by the</span>
00012 <span class="comment">    hive code, which in turn call the appropriate NT routines.</span>
00013 <span class="comment"></span>
00014 <span class="comment">Author:</span>
00015 <span class="comment"></span>
00016 <span class="comment">    Bryan M. Willman (bryanwi) 16-Dec-1991</span>
00017 <span class="comment"></span>
00018 <span class="comment">Revision History:</span>
00019 <span class="comment"></span>
00020 <span class="comment">--*/</span>
00021 
00022 <span class="preprocessor">#include    "<a class="code" href="../../d1/d2/cmp_8h.html">cmp.h</a>"</span>
00023 
<a name="l00024"></a><a class="code" href="../../d7/d3/cmwrapr_8c.html#a5">00024</a> ULONG <a class="code" href="../../d7/d3/cmwrapr_8c.html#a5">perftouchbuffer</a> = 0;
00025 
00026 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00027 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,CmpAllocate)</span>
00028 <span class="preprocessor"></span><span class="preprocessor">#ifdef POOL_TAGGING</span>
00029 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,CmpAllocateTag)</span>
00030 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00031 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,CmpFree)</span>
00032 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,CmpDoFileSetSize)</span>
00033 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,CmpFileRead)</span>
00034 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,CmpFileWrite)</span>
00035 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,CmpFileFlush)</span>
00036 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00037 <span class="preprocessor"></span>
<a name="l00038"></a><a class="code" href="../../d7/d3/cmwrapr_8c.html#a6">00038</a> <span class="keyword">extern</span> BOOLEAN <a class="code" href="../../d8/d9/cmapi_8c.html#a0">CmpNoWrite</a>;
00039 
00040 <span class="comment">//</span>
00041 <span class="comment">// never read more than 64k, neither the filesystem nor some disk drivers</span>
00042 <span class="comment">// like it much.</span>
00043 <span class="comment">//</span>
<a name="l00044"></a><a class="code" href="../../d7/d3/cmwrapr_8c.html#a0">00044</a> <span class="preprocessor">#define MAX_FILE_IO 0x10000</span>
00045 <span class="preprocessor"></span>
<a name="l00046"></a><a class="code" href="../../d7/d3/cmwrapr_8c.html#a1">00046</a> <span class="preprocessor">#define CmpIoFileRead       1</span>
<a name="l00047"></a><a class="code" href="../../d7/d3/cmwrapr_8c.html#a2">00047</a> <span class="preprocessor"></span><span class="preprocessor">#define CmpIoFileWrite      2</span>
<a name="l00048"></a><a class="code" href="../../d7/d3/cmwrapr_8c.html#a3">00048</a> <span class="preprocessor"></span><span class="preprocessor">#define CmpIoFileSetSize    3</span>
<a name="l00049"></a><a class="code" href="../../d7/d3/cmwrapr_8c.html#a4">00049</a> <span class="preprocessor"></span><span class="preprocessor">#define CmpIoFileFlush      4</span>
00050 <span class="preprocessor"></span>
00051 <span class="keyword">extern</span> <span class="keyword">struct </span>{
<a name="l00052"></a><a class="code" href="../../d7/d3/cmwrapr_8c.html#a7">00052</a>     ULONG       <a class="code" href="../../d7/d0/cmdat2_8c.html#a18">Action</a>;
<a name="l00053"></a><a class="code" href="../../d7/d3/cmwrapr_8c.html#a8">00053</a>     HANDLE      <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>;
<a name="l00054"></a><a class="code" href="../../d7/d3/cmwrapr_8c.html#a9">00054</a>     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>    <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00055 } <a class="code" href="../../d7/d0/cmdat2_8c.html#a20">CmRegistryIODebug</a>;
00056 
00057 <span class="comment">//</span>
00058 <span class="comment">// Storage management</span>
00059 <span class="comment">//</span>
00060 
00061 PVOID
<a name="l00062"></a><a class="code" href="../../d7/d3/cmwrapr_8c.html#a11">00062</a> <a class="code" href="../../d7/d3/cmwrapr_8c.html#a11">CmpAllocate</a>(
00063     ULONG   Size,
00064     BOOLEAN UseForIo
00065     )
00066 <span class="comment">/*++</span>
00067 <span class="comment"></span>
00068 <span class="comment">Routine Description:</span>
00069 <span class="comment"></span>
00070 <span class="comment">    This routine makes more memory available to a hive.</span>
00071 <span class="comment"></span>
00072 <span class="comment">    It is environment specific.</span>
00073 <span class="comment"></span>
00074 <span class="comment">Arguments:</span>
00075 <span class="comment"></span>
00076 <span class="comment">    Size - amount of space caller wants</span>
00077 <span class="comment"></span>
00078 <span class="comment">    UseForIo - TRUE if object allocated will be target of I/O,</span>
00079 <span class="comment">               FALSE if not.</span>
00080 <span class="comment"></span>
00081 <span class="comment">Return Value:</span>
00082 <span class="comment"></span>
00083 <span class="comment">    NULL if failure, address of allocated block if not.</span>
00084 <span class="comment"></span>
00085 <span class="comment">--*/</span>
00086 {
00087     PVOID   result;
00088     ULONG   pooltype;
00089 <span class="preprocessor">#if DBG</span>
00090 <span class="preprocessor"></span>    PVOID   Caller;
00091     PVOID   CallerCaller;
00092     <a class="code" href="../../d5/d2/ppc_2getcalr_8c.html#a0">RtlGetCallersAddress</a>(&amp;Caller, &amp;CallerCaller);
00093 <span class="preprocessor">#endif</span>
00094 <span class="preprocessor"></span>
00095     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d2/cmp_8h.html#a247">CmpClaimGlobalQuota</a>(<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00096         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00097     }
00098 
00099     pooltype = (UseForIo) ? <a class="code" href="../../d5/d8/ex_8h.html#a329a178">PagedPoolCacheAligned</a> : <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>;
00100     result = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(
00101                 pooltype,
00102                 <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>,
00103                 CM_POOL_TAG
00104                 );
00105 
00106 <span class="preprocessor">#if DBG</span>
00107 <span class="preprocessor"></span>    <a class="code" href="../../d1/d2/cmp_8h.html#a55">CMLOG</a>(<a class="code" href="../../d1/d2/cmp_8h.html#a23">CML_MINOR</a>, <a class="code" href="../../d1/d2/cmp_8h.html#a35">CMS_POOL</a>) {
00108         KdPrint((<span class="stringliteral">"**CmpAllocate: allocate:%08lx, "</span>, <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>));
00109         KdPrint((<span class="stringliteral">"type:%d, at:%08lx  "</span>, <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>, result));
00110         KdPrint((<span class="stringliteral">"c:%08lx  cc:%08lx\n"</span>, Caller, CallerCaller));
00111     }
00112 <span class="preprocessor">#endif</span>
00113 <span class="preprocessor"></span>
00114     <span class="keywordflow">if</span> (result == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00115         <a class="code" href="../../d1/d2/cmp_8h.html#a248">CmpReleaseGlobalQuota</a>(<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>);
00116     }
00117 
00118     <span class="keywordflow">return</span> result;
00119 }
00120 
00121 <span class="preprocessor">#ifdef POOL_TAGGING</span>
00122 <span class="preprocessor"></span>PVOID
00123 <a class="code" href="../../d1/d2/cmp_8h.html#a14">CmpAllocateTag</a>(
00124     ULONG   Size,
00125     BOOLEAN UseForIo,
00126     ULONG   Tag
00127     )
00128 <span class="comment">/*++</span>
00129 <span class="comment"></span>
00130 <span class="comment">Routine Description:</span>
00131 <span class="comment"></span>
00132 <span class="comment">    This routine makes more memory available to a hive.</span>
00133 <span class="comment"></span>
00134 <span class="comment">    It is environment specific.</span>
00135 <span class="comment"></span>
00136 <span class="comment">Arguments:</span>
00137 <span class="comment"></span>
00138 <span class="comment">    Size - amount of space caller wants</span>
00139 <span class="comment"></span>
00140 <span class="comment">    UseForIo - TRUE if object allocated will be target of I/O,</span>
00141 <span class="comment">               FALSE if not.</span>
00142 <span class="comment"></span>
00143 <span class="comment">Return Value:</span>
00144 <span class="comment"></span>
00145 <span class="comment">    NULL if failure, address of allocated block if not.</span>
00146 <span class="comment"></span>
00147 <span class="comment">--*/</span>
00148 {
00149     PVOID   result;
00150     ULONG   pooltype;
00151 <span class="preprocessor">#if DBG</span>
00152 <span class="preprocessor"></span>    PVOID   Caller;
00153     PVOID   CallerCaller;
00154     <a class="code" href="../../d5/d2/ppc_2getcalr_8c.html#a0">RtlGetCallersAddress</a>(&amp;Caller, &amp;CallerCaller);
00155 <span class="preprocessor">#endif</span>
00156 <span class="preprocessor"></span>
00157     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d2/cmp_8h.html#a247">CmpClaimGlobalQuota</a>(Size) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00158         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00159     }
00160 
00161     pooltype = (UseForIo) ? <a class="code" href="../../d5/d8/ex_8h.html#a329a178">PagedPoolCacheAligned</a> : <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>;
00162     result = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(
00163                 pooltype,
00164                 Size,
00165                 Tag
00166                 );
00167 
00168 <span class="preprocessor">#if DBG</span>
00169 <span class="preprocessor"></span>    <a class="code" href="../../d1/d2/cmp_8h.html#a55">CMLOG</a>(CML_MINOR, CMS_POOL) {
00170         KdPrint((<span class="stringliteral">"**CmpAllocate: allocate:%08lx, "</span>, Size));
00171         KdPrint((<span class="stringliteral">"type:%d, at:%08lx  "</span>, PagedPool, result));
00172         KdPrint((<span class="stringliteral">"c:%08lx  cc:%08lx\n"</span>, Caller, CallerCaller));
00173     }
00174 <span class="preprocessor">#endif</span>
00175 <span class="preprocessor"></span>
00176     <span class="keywordflow">if</span> (result == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00177         <a class="code" href="../../d1/d2/cmp_8h.html#a248">CmpReleaseGlobalQuota</a>(Size);
00178     }
00179 
00180     <span class="keywordflow">return</span> result;
00181 }
00182 <span class="preprocessor">#endif</span>
00183 <span class="preprocessor"></span>
00184 
00185 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00186"></a><a class="code" href="../../d7/d3/cmwrapr_8c.html#a12">00186</a> <a class="code" href="../../d7/d3/cmwrapr_8c.html#a12">CmpFree</a>(
00187     PVOID   MemoryBlock,
00188     ULONG   GlobalQuotaSize
00189     )
00190 <span class="comment">/*++</span>
00191 <span class="comment"></span>
00192 <span class="comment">Routine Description:</span>
00193 <span class="comment"></span>
00194 <span class="comment">    This routine frees memory that has been allocated by the registry.</span>
00195 <span class="comment"></span>
00196 <span class="comment">    It is environment specific</span>
00197 <span class="comment"></span>
00198 <span class="comment"></span>
00199 <span class="comment">Arguments:</span>
00200 <span class="comment"></span>
00201 <span class="comment">    MemoryBlock - supplies address of memory object to free</span>
00202 <span class="comment"></span>
00203 <span class="comment">    GlobalQuotaSize - amount of global quota to release</span>
00204 <span class="comment"></span>
00205 <span class="comment">Return Value:</span>
00206 <span class="comment"></span>
00207 <span class="comment">    NONE</span>
00208 <span class="comment"></span>
00209 <span class="comment">--*/</span>
00210 {
00211 <span class="preprocessor">#if DBG</span>
00212 <span class="preprocessor"></span>    PVOID   Caller;
00213     PVOID   CallerCaller;
00214     <a class="code" href="../../d5/d2/ppc_2getcalr_8c.html#a0">RtlGetCallersAddress</a>(&amp;Caller, &amp;CallerCaller);
00215     <a class="code" href="../../d1/d2/cmp_8h.html#a55">CMLOG</a>(<a class="code" href="../../d1/d2/cmp_8h.html#a23">CML_MINOR</a>, <a class="code" href="../../d1/d2/cmp_8h.html#a35">CMS_POOL</a>) {
00216         KdPrint((<span class="stringliteral">"**FREEING:%08lx c,cc:%08lx,%08lx\n"</span>, MemoryBlock, Caller, CallerCaller));
00217     }
00218 <span class="preprocessor">#endif</span>
00219 <span class="preprocessor"></span>    <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(GlobalQuotaSize &gt; 0);
00220     <a class="code" href="../../d1/d2/cmp_8h.html#a248">CmpReleaseGlobalQuota</a>(GlobalQuotaSize);
00221     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(MemoryBlock);
00222     <span class="keywordflow">return</span>;
00223 }
00224 
00225 
00226 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00227"></a><a class="code" href="../../d7/d3/cmwrapr_8c.html#a13">00227</a> <a class="code" href="../../d7/d3/cmwrapr_8c.html#a13">CmpDoFileSetSize</a>(
00228     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>      Hive,
00229     ULONG       FileType,
00230     ULONG       FileSize
00231     )
00232 <span class="comment">/*++</span>
00233 <span class="comment"></span>
00234 <span class="comment">Routine Description:</span>
00235 <span class="comment"></span>
00236 <span class="comment">    This routine sets the size of a file.  It must not return until</span>
00237 <span class="comment">    the size is guaranteed.</span>
00238 <span class="comment"></span>
00239 <span class="comment">    It is environment specific.</span>
00240 <span class="comment"></span>
00241 <span class="comment">    Must be running in the context of the cmp worker thread.</span>
00242 <span class="comment"></span>
00243 <span class="comment">Arguments:</span>
00244 <span class="comment"></span>
00245 <span class="comment">    Hive - Hive we are doing I/O for</span>
00246 <span class="comment"></span>
00247 <span class="comment">    FileType - which supporting file to use</span>
00248 <span class="comment"></span>
00249 <span class="comment">    FileSize - 32 bit value to set the file's size to</span>
00250 <span class="comment"></span>
00251 <span class="comment">Return Value:</span>
00252 <span class="comment"></span>
00253 <span class="comment">    FALSE if failure</span>
00254 <span class="comment">    TRUE if success</span>
00255 <span class="comment"></span>
00256 <span class="comment">--*/</span>
00257 {
00258     <a class="code" href="../../d9/d6/struct__CMHIVE.html">PCMHIVE</a> CmHive;
00259     HANDLE  FileHandle;
00260     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00261     FILE_END_OF_FILE_INFORMATION FileInfo;
00262     IO_STATUS_BLOCK IoStatus;
00263     BOOLEAN oldFlag;
00264 
00265     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(FIELD_OFFSET(<a class="code" href="../../d9/d6/struct__CMHIVE.html">CMHIVE</a>, <a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>) == 0);
00266 
00267     CmHive = (<a class="code" href="../../d9/d6/struct__CMHIVE.html">PCMHIVE</a>)<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>;
00268     FileHandle = CmHive-&gt;<a class="code" href="../../d9/d6/struct__CMHIVE.html#o1">FileHandles</a>[FileType];
00269     <span class="keywordflow">if</span> (FileHandle == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00270         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00271     }
00272 
00273     <span class="comment">//</span>
00274     <span class="comment">// disable hard error popups, to avoid self deadlock on bogus devices</span>
00275     <span class="comment">//</span>
00276     oldFlag = <a class="code" href="../../d4/d6/iosubs_8c.html#a108">IoSetThreadHardErrorMode</a>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00277 
00278     FileInfo.EndOfFile.HighPart = 0<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>;
00279     FileInfo.EndOfFile.LowPart  = FileSize;
00280 
00281     <a class="code" href="../../d1/d2/cmp_8h.html#a63">ASSERT_PASSIVE_LEVEL</a>();
00282 
00283     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d9/restrfil_8c.html#a39">ZwSetInformationFile</a>(
00284                 FileHandle,
00285                 &amp;IoStatus,
00286                 (PVOID)&amp;FileInfo,
00287                 <span class="keyword">sizeof</span>(FILE_END_OF_FILE_INFORMATION),
00288                 FileEndOfFileInformation
00289                 );
00290 
00291     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
00292         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(IoStatus.Status == <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>);
00293     } <span class="keywordflow">else</span> {
00294         
00295         <span class="comment">//</span>
00296         <span class="comment">// set debugging info</span>
00297         <span class="comment">//</span>
00298         <a class="code" href="../../d7/d0/cmdat2_8c.html#a20">CmRegistryIODebug</a>.Action = <a class="code" href="../../d7/d3/cmwrapr_8c.html#a3">CmpIoFileSetSize</a>;
00299         <a class="code" href="../../d7/d0/cmdat2_8c.html#a20">CmRegistryIODebug</a>.Handle = FileHandle;
00300         <a class="code" href="../../d7/d0/cmdat2_8c.html#a20">CmRegistryIODebug</a>.Status = <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00301         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"CmpFileSetSize:\tHandle=%08lx  NewLength=%08lx  \n"</span>, FileHandle, FileSize);
00302     }
00303 
00304     <span class="comment">//</span>
00305     <span class="comment">// restore hard error popups mode</span>
00306     <span class="comment">//</span>
00307     <a class="code" href="../../d4/d6/iosubs_8c.html#a108">IoSetThreadHardErrorMode</a>(oldFlag);
00308 
00309     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00310 }
00311 
00312 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00313"></a><a class="code" href="../../d7/d3/cmwrapr_8c.html#a14">00313</a> <a class="code" href="../../d7/d3/cmwrapr_8c.html#a14">CmpCreateEvent</a>(
00314     IN EVENT_TYPE  eventType,
00315     OUT PHANDLE eventHandle,
00316     OUT <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> *event
00317     )
00318 {
00319     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
00320     OBJECT_ATTRIBUTES obja;
00321 
00322     InitializeObjectAttributes( &amp;obja, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00323     status = ZwCreateEvent(
00324         eventHandle,
00325         EVENT_ALL_ACCESS,
00326         &amp;obja,
00327         eventType,
00328         <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00329     
00330     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
00331         <span class="keywordflow">return</span> status;
00332     }
00333     
00334     status = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a>(
00335         *eventHandle,
00336         EVENT_ALL_ACCESS,
00337         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00338         <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
00339         event,
00340         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00341     
00342     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
00343         ZwClose(*eventHandle);
00344         <span class="keywordflow">return</span> status;
00345     }
00346     <span class="keywordflow">return</span> status;
00347 }
00348 
00349 
00350 BOOLEAN
<a name="l00351"></a><a class="code" href="../../d7/d3/cmwrapr_8c.html#a15">00351</a> <a class="code" href="../../d7/d3/cmwrapr_8c.html#a15">CmpFileRead</a> (
00352     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>      Hive,
00353     ULONG       FileType,
00354     PULONG      FileOffset,
00355     PVOID       DataBuffer,
00356     ULONG       DataLength
00357     )
00358 <span class="comment">/*++</span>
00359 <span class="comment"></span>
00360 <span class="comment">Routine Description:</span>
00361 <span class="comment"></span>
00362 <span class="comment">    This routine reads in a buffer from a file.</span>
00363 <span class="comment"></span>
00364 <span class="comment">    It is environment specific.</span>
00365 <span class="comment"></span>
00366 <span class="comment">    NOTE:   We assume the handle is opened for asynchronous access,</span>
00367 <span class="comment">            and that we, and not the IO system, are keeping the</span>
00368 <span class="comment">            offset pointer.</span>
00369 <span class="comment"></span>
00370 <span class="comment">    NOTE:   Only 32bit offsets are supported, even though the underlying</span>
00371 <span class="comment">            IO system on NT supports 64 bit offsets.</span>
00372 <span class="comment"></span>
00373 <span class="comment">Arguments:</span>
00374 <span class="comment"></span>
00375 <span class="comment">    Hive - Hive we are doing I/O for</span>
00376 <span class="comment"></span>
00377 <span class="comment">    FileType - which supporting file to use</span>
00378 <span class="comment"></span>
00379 <span class="comment">    FileOffset - pointer to variable providing 32bit offset on input,</span>
00380 <span class="comment">                 and receiving new 32bit offset on output.</span>
00381 <span class="comment"></span>
00382 <span class="comment">    DataBuffer - pointer to buffer</span>
00383 <span class="comment"></span>
00384 <span class="comment">    DataLength - length of buffer</span>
00385 <span class="comment"></span>
00386 <span class="comment">Return Value:</span>
00387 <span class="comment"></span>
00388 <span class="comment">    FALSE if failure</span>
00389 <span class="comment">    TRUE if success</span>
00390 <span class="comment"></span>
00391 <span class="comment">--*/</span>
00392 {
00393     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
00394     LARGE_INTEGER   <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
00395     IO_STATUS_BLOCK IoStatus;
00396     <a class="code" href="../../d9/d6/struct__CMHIVE.html">PCMHIVE</a> CmHive;
00397     HANDLE  FileHandle;
00398     ULONG LengthToRead;
00399     HANDLE eventHandle = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00400     <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> eventObject = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00401 
00402     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(FIELD_OFFSET(<a class="code" href="../../d9/d6/struct__CMHIVE.html">CMHIVE</a>, <a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>) == 0);
00403     CmHive = (<a class="code" href="../../d9/d6/struct__CMHIVE.html">PCMHIVE</a>)<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>;
00404     FileHandle = CmHive-&gt;<a class="code" href="../../d9/d6/struct__CMHIVE.html#o1">FileHandles</a>[FileType];
00405     <span class="keywordflow">if</span> (FileHandle == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00406         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00407     }
00408 
00409     <a class="code" href="../../d1/d2/cmp_8h.html#a55">CMLOG</a>(<a class="code" href="../../d1/d2/cmp_8h.html#a22">CML_MAJOR</a>, <a class="code" href="../../d1/d2/cmp_8h.html#a30">CMS_IO</a>) {
00410         KdPrint((<span class="stringliteral">"CmpFileRead:\n"</span>));
00411         KdPrint((<span class="stringliteral">"\tHandle=%08lx  Offset=%08lx  "</span>, FileHandle, *FileOffset));
00412         KdPrint((<span class="stringliteral">"Buffer=%08lx  Length=%08lx\n"</span>, DataBuffer, DataLength));
00413     }
00414 
00415     <span class="comment">//</span>
00416     <span class="comment">// Detect attempt to read off end of 2gig file (this should be irrelevent)</span>
00417     <span class="comment">//</span>
00418     <span class="keywordflow">if</span> ((0xffffffff - *FileOffset) &lt; DataLength) {
00419         <a class="code" href="../../d1/d2/cmp_8h.html#a55">CMLOG</a>(<a class="code" href="../../d1/d2/cmp_8h.html#a22">CML_MAJOR</a>, <a class="code" href="../../d1/d2/cmp_8h.html#a45">CMS_IO_ERROR</a>) KdPrint((<span class="stringliteral">"CmpFileRead: runoff\n"</span>));
00420         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00421     }
00422 
00423     status = <a class="code" href="../../d7/d3/cmwrapr_8c.html#a14">CmpCreateEvent</a>(
00424         SynchronizationEvent,
00425         &amp;eventHandle,
00426         &amp;eventObject);
00427     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status))
00428         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00429 
00430     <span class="comment">//</span>
00431     <span class="comment">// We'd really like to just call the filesystems and have them do</span>
00432     <span class="comment">// the right thing.  But the filesystem will attempt to lock our</span>
00433     <span class="comment">// entire buffer into memory, and that may fail for large requests.</span>
00434     <span class="comment">// So we split our reads into 64k chunks and call the filesystem for</span>
00435     <span class="comment">// each one.</span>
00436     <span class="comment">//</span>
00437     <a class="code" href="../../d1/d2/cmp_8h.html#a63">ASSERT_PASSIVE_LEVEL</a>();
00438     <span class="keywordflow">while</span> (DataLength &gt; 0) {
00439 
00440         <span class="comment">//</span>
00441         <span class="comment">// Convert ULONG to Large</span>
00442         <span class="comment">//</span>
00443         <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.LowPart = *FileOffset;
00444         <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.HighPart = 0<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>;
00445 
00446         <span class="comment">//</span>
00447         <span class="comment">// trim request down if necessary.</span>
00448         <span class="comment">//</span>
00449         <span class="keywordflow">if</span> (DataLength &gt; <a class="code" href="../../d7/d3/cmwrapr_8c.html#a0">MAX_FILE_IO</a>) {
00450             LengthToRead = <a class="code" href="../../d7/d3/cmwrapr_8c.html#a0">MAX_FILE_IO</a>;
00451         } <span class="keywordflow">else</span> {
00452             LengthToRead = DataLength;
00453         }
00454 
00455         status = ZwReadFile(
00456                     FileHandle,
00457                     eventHandle,
00458                     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,               <span class="comment">// apcroutine</span>
00459                     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,               <span class="comment">// apccontext</span>
00460                     &amp;IoStatus,
00461                     DataBuffer,
00462                     LengthToRead,
00463                     &amp;<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>,
00464                     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>                <span class="comment">// key</span>
00465                     );
00466 
00467         <span class="keywordflow">if</span> (STATUS_PENDING == status) {
00468             status = <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>(eventObject, <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
00469                                            <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00470             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(STATUS_SUCCESS == status);
00471             status = IoStatus.Status;
00472         }
00473 
00474         <span class="comment">//</span>
00475         <span class="comment">// adjust offsets</span>
00476         <span class="comment">//</span>
00477         *FileOffset = <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.LowPart + LengthToRead;
00478         DataLength -= LengthToRead;
00479         (PUCHAR)DataBuffer += LengthToRead;
00480 
00481         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
00482             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(IoStatus.Status == status);
00483             <span class="keywordflow">if</span> (IoStatus.Information != LengthToRead) {
00484                 <a class="code" href="../../d1/d2/cmp_8h.html#a55">CMLOG</a>(<a class="code" href="../../d1/d2/cmp_8h.html#a22">CML_MAJOR</a>, <a class="code" href="../../d1/d2/cmp_8h.html#a45">CMS_IO_ERROR</a>) {
00485                     KdPrint((<span class="stringliteral">"CmpFileRead:\n\t"</span>));
00486                     KdPrint((<span class="stringliteral">"Failure1: status = %08lx  "</span>, status));
00487                     KdPrint((<span class="stringliteral">"IoInformation = %08lx\n"</span>, IoStatus.Information));
00488                 }
00489                 <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>(eventObject);
00490                 ZwClose(eventHandle);
00491                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00492             }
00493         } <span class="keywordflow">else</span> {
00494             <span class="comment">//</span>
00495             <span class="comment">// set debugging info</span>
00496             <span class="comment">//</span>
00497             <a class="code" href="../../d7/d0/cmdat2_8c.html#a20">CmRegistryIODebug</a>.Action = <a class="code" href="../../d7/d3/cmwrapr_8c.html#a1">CmpIoFileRead</a>;
00498             <a class="code" href="../../d7/d0/cmdat2_8c.html#a20">CmRegistryIODebug</a>.Handle = FileHandle;
00499             <a class="code" href="../../d7/d0/cmdat2_8c.html#a20">CmRegistryIODebug</a>.Status = status;
00500             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"CmpFileRead:\tFailure2: status = %08lx  IoStatus = %08lx\n"</span>, status, IoStatus.Status);
00501 
00502             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>(eventObject);
00503             ZwClose(eventHandle);
00504             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00505         }
00506 
00507     }
00508     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>(eventObject);
00509     ZwClose(eventHandle);
00510     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00511 }
00512 
00513 
00514 
00515 BOOLEAN
<a name="l00516"></a><a class="code" href="../../d7/d3/cmwrapr_8c.html#a16">00516</a> <a class="code" href="../../d7/d3/cmwrapr_8c.html#a16">CmpFileWrite</a>(
00517     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>      Hive,
00518     ULONG       FileType,
00519     PCMP_OFFSET_ARRAY offsetArray,
00520     ULONG offsetArrayCount,
00521     PULONG      FileOffset
00522     )
00523 <span class="comment">/*++</span>
00524 <span class="comment"></span>
00525 <span class="comment">Routine Description:</span>
00526 <span class="comment"></span>
00527 <span class="comment">    This routine writes an array of buffers out to a file.</span>
00528 <span class="comment"></span>
00529 <span class="comment">    It is environment specific.</span>
00530 <span class="comment"></span>
00531 <span class="comment">    NOTE:   We assume the handle is opened for asynchronous access,</span>
00532 <span class="comment">            and that we, and not the IO system, are keeping the</span>
00533 <span class="comment">            offset pointer.</span>
00534 <span class="comment"></span>
00535 <span class="comment">    NOTE:   Only 32bit offsets are supported, even though the underlying</span>
00536 <span class="comment">            IO system on NT supports 64 bit offsets.</span>
00537 <span class="comment"></span>
00538 <span class="comment">Arguments:</span>
00539 <span class="comment"></span>
00540 <span class="comment">    Hive - Hive we are doing I/O for</span>
00541 <span class="comment"></span>
00542 <span class="comment">    FileType - which supporting file to use</span>
00543 <span class="comment"></span>
00544 <span class="comment">    offsetArray - array of structures where each structure holds a 32bit offset</span>
00545 <span class="comment">                  into the Hive file and pointer the a buffer written to that</span>
00546 <span class="comment">                  file offset.</span>
00547 <span class="comment"></span>
00548 <span class="comment">    offsetArrayCount - number of elements in the offsetArray.</span>
00549 <span class="comment"></span>
00550 <span class="comment">    FileOffset - returns the file offset after the last write to the file.</span>
00551 <span class="comment"></span>
00552 <span class="comment">Return Value:</span>
00553 <span class="comment"></span>
00554 <span class="comment">    FALSE if failure</span>
00555 <span class="comment">    TRUE if success</span>
00556 <span class="comment"></span>
00557 <span class="comment">--*/</span>
00558 {
00559     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
00560     LARGE_INTEGER   <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
00561     <a class="code" href="../../d9/d6/struct__CMHIVE.html">PCMHIVE</a> CmHive;
00562     HANDLE  FileHandle;
00563     ULONG LengthToWrite;
00564     LONG WaitBufferCount = 0;
00565     LONG idx;
00566     ULONG arrayCount = 0;
00567     PVOID       DataBuffer;
00568     ULONG       DataLength;
00569     HANDLE eventHandles[MAXIMUM_WAIT_OBJECTS];
00570     <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> eventObjects[MAXIMUM_WAIT_OBJECTS];
00571     <a class="code" href="../../d4/d8/struct__KWAIT__BLOCK.html">KWAIT_BLOCK</a> waitBlockArray[MAXIMUM_WAIT_OBJECTS];
00572     IO_STATUS_BLOCK IoStatus[MAXIMUM_WAIT_OBJECTS];
00573     BOOLEAN ret_val = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00574 
00575     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d9/cmapi_8c.html#a0">CmpNoWrite</a>) {
00576         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00577     }
00578 
00579     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(FIELD_OFFSET(<a class="code" href="../../d9/d6/struct__CMHIVE.html">CMHIVE</a>, <a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>) == 0);
00580     CmHive = (<a class="code" href="../../d9/d6/struct__CMHIVE.html">PCMHIVE</a>)<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>;
00581     FileHandle = CmHive-&gt;<a class="code" href="../../d9/d6/struct__CMHIVE.html#o1">FileHandles</a>[FileType];
00582     <span class="keywordflow">if</span> (FileHandle == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00583         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00584     }
00585 
00586     <a class="code" href="../../d1/d2/cmp_8h.html#a55">CMLOG</a>(<a class="code" href="../../d1/d2/cmp_8h.html#a22">CML_MAJOR</a>, <a class="code" href="../../d1/d2/cmp_8h.html#a30">CMS_IO</a>) {
00587         KdPrint((<span class="stringliteral">"CmpFileWrite:\n"</span>));
00588         KdPrint((<span class="stringliteral">"\tHandle=%08lx  "</span>, FileHandle));
00589     }
00590 
00591     <span class="keywordflow">for</span> (idx = 0; idx &lt; MAXIMUM_WAIT_OBJECTS; idx++) {
00592         eventHandles[idx] = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00593     }
00594 
00595     <span class="comment">// Bring pages being written into memory first to allow disk to write</span>
00596     <span class="comment">// buffer contiguously.</span>
00597     <span class="keywordflow">for</span> (idx = 0; (ULONG) idx &lt; offsetArrayCount; idx++) {
00598         <span class="keywordtype">char</span> * start = offsetArray[idx].DataBuffer;
00599         <span class="keywordtype">char</span> * end = (<span class="keywordtype">char</span> *) start + offsetArray[idx].DataLength;
00600         <span class="keywordflow">while</span> (start &lt; end) {
00601             <span class="comment">// perftouchbuffer globally declared so that compiler won't try</span>
00602             <span class="comment">// to remove it and this loop (if its smart enough?).</span>
00603             <a class="code" href="../../d7/d3/cmwrapr_8c.html#a5">perftouchbuffer</a> += (ULONG) *start;
00604             start += <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
00605         }
00606     }
00607 
00608     <span class="comment">//</span>
00609     <span class="comment">// We'd really like to just call the filesystems and have them do</span>
00610     <span class="comment">// the right thing.  But the filesystem will attempt to lock our</span>
00611     <span class="comment">// entire buffer into memory, and that may fail for large requests.</span>
00612     <span class="comment">// So we split our reads into 64k chunks and call the filesystem for</span>
00613     <span class="comment">// each one.</span>
00614     <span class="comment">//</span>
00615     <a class="code" href="../../d1/d2/cmp_8h.html#a63">ASSERT_PASSIVE_LEVEL</a>();
00616     arrayCount = 0;
00617     DataLength = 0;
00618     <span class="comment">// This outer loop is hit more than once if the MAXIMUM_WAIT_OBJECTS limit</span>
00619     <span class="comment">// is hit before the offset array is drained.</span>
00620     <span class="keywordflow">while</span> (arrayCount &lt; offsetArrayCount) {
00621         WaitBufferCount = 0;
00622 
00623         <span class="comment">// This loop fills the wait buffer.</span>
00624         <span class="keywordflow">while</span> ((arrayCount &lt; offsetArrayCount) &amp;&amp;
00625                (WaitBufferCount &lt; MAXIMUM_WAIT_OBJECTS)) {
00626 
00627             <span class="comment">// If data length isn't zero than the wait buffer filled before the</span>
00628             <span class="comment">// buffer in the last offsetArray element was sent to write file.</span>
00629             <span class="keywordflow">if</span> (DataLength == 0) {
00630                 *FileOffset = offsetArray[arrayCount].FileOffset;
00631                 DataBuffer =  offsetArray[arrayCount].DataBuffer;
00632                 DataLength =  offsetArray[arrayCount].DataLength;
00633                 <span class="comment">//</span>
00634                 <span class="comment">// Detect attempt to read off end of 2gig file</span>
00635                 <span class="comment">// (this should be irrelevent)</span>
00636                 <span class="comment">//</span>
00637                 <span class="keywordflow">if</span> ((0xffffffff - *FileOffset) &lt; DataLength) {
00638                     <a class="code" href="../../d1/d2/cmp_8h.html#a55">CMLOG</a>(<a class="code" href="../../d1/d2/cmp_8h.html#a22">CML_MAJOR</a>, <a class="code" href="../../d1/d2/cmp_8h.html#a45">CMS_IO_ERROR</a>) KdPrint((<span class="stringliteral">"CmpFileWrite: runoff\n"</span>));
00639                     <span class="keywordflow">goto</span> Error_Exit;
00640                 }
00641             }
00642             <span class="comment">// else still more to write out of last buffer.</span>
00643 
00644             <span class="keywordflow">while</span> ((DataLength &gt; 0) &amp;&amp; (WaitBufferCount &lt; MAXIMUM_WAIT_OBJECTS)) {
00645 
00646                 <span class="comment">//</span>
00647                 <span class="comment">// Convert ULONG to Large</span>
00648                 <span class="comment">//</span>
00649                 <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.LowPart = *FileOffset;
00650                 <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.HighPart = 0<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>;
00651 
00652                 <span class="comment">//</span>
00653                 <span class="comment">// trim request down if necessary.</span>
00654                 <span class="comment">//</span>
00655                 <span class="keywordflow">if</span> (DataLength &gt; <a class="code" href="../../d7/d3/cmwrapr_8c.html#a0">MAX_FILE_IO</a>) {
00656                     LengthToWrite = <a class="code" href="../../d7/d3/cmwrapr_8c.html#a0">MAX_FILE_IO</a>;
00657                 } <span class="keywordflow">else</span> {
00658                     LengthToWrite = DataLength;
00659                 }
00660 
00661                 <span class="comment">// Previously created events are reused.</span>
00662                 <span class="keywordflow">if</span> (eventHandles[WaitBufferCount] == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00663                     status = <a class="code" href="../../d7/d3/cmwrapr_8c.html#a14">CmpCreateEvent</a>(SynchronizationEvent,
00664                                             &amp;eventHandles[WaitBufferCount],
00665                                             &amp;eventObjects[WaitBufferCount]);
00666                     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
00667                         <span class="comment">// Make sure we don't try to clean this up.</span>
00668                         eventHandles[WaitBufferCount] = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00669                         <span class="keywordflow">goto</span> Error_Exit;
00670                     }
00671                 }
00672                         
00673                 status = ZwWriteFile(FileHandle,
00674                                      eventHandles[WaitBufferCount],
00675                                      <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,               <span class="comment">// apcroutine</span>
00676                                      <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,               <span class="comment">// apccontext</span>
00677                                      &amp;IoStatus[WaitBufferCount],
00678                                      DataBuffer,
00679                                      LengthToWrite,
00680                                      &amp;<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>,
00681                                      <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00682                         
00683                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
00684                     <span class="keywordflow">goto</span> Error_Exit;
00685                 }
00686 
00687                 WaitBufferCount++;
00688                 
00689                 <span class="comment">//</span>
00690                 <span class="comment">// adjust offsets</span>
00691                 <span class="comment">//</span>
00692                 *FileOffset = <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.LowPart + LengthToWrite;
00693                 DataLength -= LengthToWrite;
00694                 (PUCHAR)DataBuffer += LengthToWrite;
00695             } <span class="comment">// while (DataLength &gt; 0 &amp;&amp; WaitBufferCount &lt; MAXIMUM_WAIT_OBJECTS)</span>
00696             
00697             arrayCount++;
00698             
00699         } <span class="comment">// while (arrayCount &lt; offsetArrayCount &amp;&amp; </span>
00700           <span class="comment">//        WaitBufferCount &lt; MAXIMUM_WAIT_OBJECTS)</span>
00701 
00702         status = <a class="code" href="../../d1/d7/wait_8c.html#a3">KeWaitForMultipleObjects</a>(WaitBufferCount, 
00703                                           eventObjects,
00704                                           WaitAll,
00705                                           <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
00706                                           <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>, 
00707                                           <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, 
00708                                           <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00709                                           waitBlockArray);
00710         
00711         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status))
00712             <span class="keywordflow">goto</span> Error_Exit;
00713         
00714         <span class="keywordflow">for</span> (idx = 0; idx &lt; WaitBufferCount; idx++) {
00715             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(IoStatus[idx].<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
00716                 ret_val = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00717                 <span class="keywordflow">goto</span> Done;
00718             }
00719         }
00720         
00721         <span class="comment">// There may still be more to do if the last element held a big buffer</span>
00722         <span class="comment">// and the wait buffer filled before it was all sent to the file.</span>
00723         <span class="keywordflow">if</span> (DataLength &gt; 0) {
00724             arrayCount--;
00725         }
00726 
00727     } <span class="comment">// while (arrayCount &lt; offsetArrayCount)</span>
00728 
00729     ret_val = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00730 
00731     <span class="keywordflow">goto</span> Done;
00732 Error_Exit:
00733     <span class="comment">//</span>
00734     <span class="comment">// set debugging info</span>
00735     <span class="comment">//</span>
00736     <a class="code" href="../../d7/d0/cmdat2_8c.html#a20">CmRegistryIODebug</a>.Action = <a class="code" href="../../d7/d3/cmwrapr_8c.html#a2">CmpIoFileWrite</a>;
00737     <a class="code" href="../../d7/d0/cmdat2_8c.html#a20">CmRegistryIODebug</a>.Handle = FileHandle;
00738     <a class="code" href="../../d7/d0/cmdat2_8c.html#a20">CmRegistryIODebug</a>.Status = status;
00739     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"CmpFileWrite: error exiting %d\n"</span>, status);
00740     <span class="comment">//</span>
00741     <span class="comment">// if WaitBufferCount &gt; 0 then we have successfully issued</span>
00742     <span class="comment">// some I/Os, but not all of them. This is an error, but we</span>
00743     <span class="comment">// cannot return from this routine until all the successfully</span>
00744     <span class="comment">// issued I/Os have completed.</span>
00745     <span class="comment">//</span>
00746     <span class="keywordflow">if</span> (WaitBufferCount &gt; 0) {
00747         status = <a class="code" href="../../d1/d7/wait_8c.html#a3">KeWaitForMultipleObjects</a>(WaitBufferCount, 
00748                                           eventObjects,
00749                                           WaitAll,
00750                                           <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
00751                                           <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>, 
00752                                           <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, 
00753                                           <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00754                                           waitBlockArray);
00755     }
00756 
00757 
00758     ret_val = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00759 Done:
00760     idx = 0;
00761     <span class="comment">// Clean up open event handles and objects.</span>
00762     <span class="keywordflow">while</span> ((idx &lt; MAXIMUM_WAIT_OBJECTS) &amp;&amp; (eventHandles[idx] != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
00763         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>(eventObjects[idx]);
00764         ZwClose(eventHandles[idx]);
00765         idx++;
00766     }
00767     <span class="keywordflow">return</span> ret_val;
00768 }
00769 
00770 
00771 BOOLEAN
<a name="l00772"></a><a class="code" href="../../d7/d3/cmwrapr_8c.html#a17">00772</a> <a class="code" href="../../d7/d3/cmwrapr_8c.html#a17">CmpFileFlush</a> (
00773     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>      Hive,
00774     ULONG       FileType
00775     )
00776 <span class="comment">/*++</span>
00777 <span class="comment"></span>
00778 <span class="comment">Routine Description:</span>
00779 <span class="comment"></span>
00780 <span class="comment">    This routine performs a flush on a file handle.</span>
00781 <span class="comment"></span>
00782 <span class="comment">Arguments:</span>
00783 <span class="comment"></span>
00784 <span class="comment">    Hive - Hive we are doing I/O for</span>
00785 <span class="comment"></span>
00786 <span class="comment">    FileType - which supporting file to use</span>
00787 <span class="comment"></span>
00788 <span class="comment">Return Value:</span>
00789 <span class="comment"></span>
00790 <span class="comment">    FALSE if failure</span>
00791 <span class="comment">    TRUE if success</span>
00792 <span class="comment"></span>
00793 <span class="comment">--*/</span>
00794 {
00795     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
00796     IO_STATUS_BLOCK IoStatus;
00797     <a class="code" href="../../d9/d6/struct__CMHIVE.html">PCMHIVE</a> CmHive;
00798     HANDLE  FileHandle;
00799 
00800     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(FIELD_OFFSET(<a class="code" href="../../d9/d6/struct__CMHIVE.html">CMHIVE</a>, <a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>) == 0);
00801     CmHive = (<a class="code" href="../../d9/d6/struct__CMHIVE.html">PCMHIVE</a>)<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>;
00802     FileHandle = CmHive-&gt;<a class="code" href="../../d9/d6/struct__CMHIVE.html#o1">FileHandles</a>[FileType];
00803     <span class="keywordflow">if</span> (FileHandle == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00804         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00805     }
00806 
00807     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d9/cmapi_8c.html#a0">CmpNoWrite</a>) {
00808         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00809     }
00810 
00811     <a class="code" href="../../d1/d2/cmp_8h.html#a55">CMLOG</a>(<a class="code" href="../../d1/d2/cmp_8h.html#a22">CML_MAJOR</a>, <a class="code" href="../../d1/d2/cmp_8h.html#a30">CMS_IO</a>) {
00812         KdPrint((<span class="stringliteral">"CmpFileFlush:\n\tHandle = %08lx\n"</span>, FileHandle));
00813     }
00814 
00815     <a class="code" href="../../d1/d2/cmp_8h.html#a63">ASSERT_PASSIVE_LEVEL</a>();
00816 
00817     status = ZwFlushBuffersFile(
00818                 FileHandle,
00819                 &amp;IoStatus
00820                 );
00821 
00822     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
00823         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(IoStatus.Status == status);
00824         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00825     } <span class="keywordflow">else</span> {
00826         <span class="comment">//</span>
00827         <span class="comment">// set debugging info</span>
00828         <span class="comment">//</span>
00829         <a class="code" href="../../d7/d0/cmdat2_8c.html#a20">CmRegistryIODebug</a>.Action = <a class="code" href="../../d7/d3/cmwrapr_8c.html#a4">CmpIoFileFlush</a>;
00830         <a class="code" href="../../d7/d0/cmdat2_8c.html#a20">CmRegistryIODebug</a>.Handle = FileHandle;
00831         <a class="code" href="../../d7/d0/cmdat2_8c.html#a20">CmRegistryIODebug</a>.Status = status;
00832         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"CmpFileFlush:\tFailure1: status = %08lx  IoStatus = %08lx\n"</span>,status,IoStatus.Status);
00833         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00834     }
00835     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00836 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:39:29 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
