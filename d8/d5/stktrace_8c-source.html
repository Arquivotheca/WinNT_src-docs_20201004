<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: stktrace.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>stktrace.c</h1><a href="../../d7/d6/stktrace_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1991  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    stktrace.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module implements routines to snapshot a set of stack back traces</span>
00012 <span class="comment">    in a data base.  Useful for heap allocators to track allocation requests</span>
00013 <span class="comment">    cheaply.</span>
00014 <span class="comment"></span>
00015 <span class="comment">Author:</span>
00016 <span class="comment"></span>
00017 <span class="comment">    Steve Wood (stevewo) 29-Jan-1992</span>
00018 <span class="comment"></span>
00019 <span class="comment">Revision History:</span>
00020 <span class="comment"></span>
00021 <span class="comment">    17-May-1999 (silviuc) : added RtlWalkFrameChain that replaces the</span>
00022 <span class="comment">    unsafe RtlCaptureStackBackTrace.</span>
00023 <span class="comment"></span>
00024 <span class="comment">--*/</span>
00025 
00026 <span class="preprocessor">#include &lt;<a class="code" href="../../d9/d8/ntos_8h.html">ntos.h</a>&gt;</span>
00027 <span class="preprocessor">#include &lt;ntrtl.h&gt;</span>
00028 <span class="preprocessor">#include &lt;nturtl.h&gt;</span>
00029 <span class="preprocessor">#include &lt;zwapi.h&gt;</span>
00030 <span class="preprocessor">#include &lt;<a class="code" href="../../d8/d6/stktrace_8h.html">stktrace.h</a>&gt;</span>
00031 <span class="preprocessor">#include &lt;<a class="code" href="../../d3/d9/heap_8h.html">heap.h</a>&gt;</span>
00032 <span class="preprocessor">#include &lt;<a class="code" href="../../d9/d9/heappriv_8h.html">heappriv.h</a>&gt;</span>
00033 
00034 BOOLEAN
00035 <a class="code" href="../../d1/d1/theap_8c.html#a18">NtdllOkayToLockRoutine</a>(
00036     IN PVOID Lock
00037     );
00038 
00039 <span class="preprocessor">#if !defined(RtlGetCallersAddress) &amp;&amp; defined(_X86_) &amp;&amp; (!NTOS_KERNEL_RUNTIME)</span>
00040 <span class="preprocessor"></span>
00041 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00042 <a class="code" href="../../d5/d2/ppc_2getcalr_8c.html#a0">RtlGetCallersAddress</a>(
00043     OUT PVOID *CallersAddress,
00044     OUT PVOID *CallersCaller
00045     )
00046 <span class="comment">/*++</span>
00047 <span class="comment"></span>
00048 <span class="comment">Routine Description:</span>
00049 <span class="comment"></span>
00050 <span class="comment">    This routine returns the first to callers on the current stack. It should be</span>
00051 <span class="comment">    noted that the function can miss some of the callers in the presence of FPO</span>
00052 <span class="comment">    optimization.</span>
00053 <span class="comment"></span>
00054 <span class="comment">Arguments:</span>
00055 <span class="comment"></span>
00056 <span class="comment">    CallersAddress - address to save the first caller.</span>
00057 <span class="comment">    </span>
00058 <span class="comment">    CallersCaller - address to save the second caller.</span>
00059 <span class="comment"></span>
00060 <span class="comment">Return Value:</span>
00061 <span class="comment"></span>
00062 <span class="comment">    None. If the function does not succeed in finding the two callers</span>
00063 <span class="comment">    it will zero the addresses where it was supposed to write them.</span>
00064 <span class="comment"></span>
00065 <span class="comment">Environment:</span>
00066 <span class="comment"></span>
00067 <span class="comment">    X86, user mode and w/o having a macro with same name defined.</span>
00068 <span class="comment"></span>
00069 <span class="comment">--*/</span>
00070 
00071 {
00072     PVOID BackTrace[ 2 ];
00073     ULONG Hash;
00074     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>;
00075 
00076     <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> = <a class="code" href="../../d5/d2/ppc_2getcalr_8c.html#a1">RtlCaptureStackBackTrace</a>(
00077         2,
00078         2,
00079         BackTrace,
00080         &amp;Hash
00081         );
00082 
00083     <span class="keywordflow">if</span> (ARGUMENT_PRESENT( CallersAddress )) {
00084         <span class="keywordflow">if</span> (<a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> &gt;= 1) {
00085             *CallersAddress = BackTrace[ 0 ];
00086         }
00087         <span class="keywordflow">else</span> {
00088             *CallersAddress = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00089         }
00090     }
00091 
00092     <span class="keywordflow">if</span> (ARGUMENT_PRESENT( CallersCaller )) {
00093         <span class="keywordflow">if</span> (<a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> &gt;= 2) {
00094             *CallersCaller = BackTrace[ 1 ];
00095         }
00096         <span class="keywordflow">else</span> {
00097             *CallersCaller = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00098         }
00099     }
00100 
00101     <span class="keywordflow">return</span>;
00102 }
00103 
00104 <span class="preprocessor">#endif // !defined(RtlGetCallersAddress) &amp;&amp; defined(_X86_) &amp;&amp; (!NTOS_KERNEL_RUNTIME)</span>
00105 <span class="preprocessor"></span>
00106 <span class="comment">// bugbug (silviuc): I do not think !FPO is correct below</span>
00107 <span class="comment">// The reason is ExtendDb function uses VirtualAlloc.</span>
00108 <span class="preprocessor">#if defined(_X86_) &amp;&amp; (!NTOS_KERNEL_RUNTIME || !FPO)</span>
00109 <span class="preprocessor"></span>
00110 <span class="comment">//</span>
00111 <span class="comment">// Global per process stack trace database.</span>
00112 <span class="comment">//</span>
00113 
00114 <a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html">PSTACK_TRACE_DATABASE</a> RtlpStackTraceDataBase;
00115 
00116 
00117 <a class="code" href="../../d9/d5/struct__RTL__STACK__TRACE__ENTRY.html">PRTL_STACK_TRACE_ENTRY</a>
00118 RtlpExtendStackTraceDataBase(
00119     IN <a class="code" href="../../d9/d5/struct__RTL__STACK__TRACE__ENTRY.html">PRTL_STACK_TRACE_ENTRY</a> InitialValue,
00120     IN ULONG Size
00121     );
00122 
00123 
00124 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00125 RtlInitStackTraceDataBaseEx(
00126     IN PVOID CommitBase,
00127     IN ULONG CommitSize,
00128     IN ULONG ReserveSize,
00129     IN PRTL_INITIALIZE_LOCK_ROUTINE InitializeLockRoutine,
00130     IN PRTL_ACQUIRE_LOCK_ROUTINE AcquireLockRoutine,
00131     IN PRTL_RELEASE_LOCK_ROUTINE ReleaseLockRoutine,
00132     IN PRTL_OKAY_TO_LOCK_ROUTINE OkayToLockRoutine
00133     );
00134 
00135 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00136 RtlInitStackTraceDataBaseEx(
00137     IN PVOID CommitBase,
00138     IN ULONG CommitSize,
00139     IN ULONG ReserveSize,
00140     IN PRTL_INITIALIZE_LOCK_ROUTINE InitializeLockRoutine,
00141     IN PRTL_ACQUIRE_LOCK_ROUTINE AcquireLockRoutine,
00142     IN PRTL_RELEASE_LOCK_ROUTINE ReleaseLockRoutine,
00143     IN PRTL_OKAY_TO_LOCK_ROUTINE OkayToLockRoutine
00144     )
00145 {
00146     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00147     <a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html">PSTACK_TRACE_DATABASE</a> DataBase;
00148 
00149     DataBase = (<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html">PSTACK_TRACE_DATABASE</a>)CommitBase;
00150     <span class="keywordflow">if</span> (CommitSize == 0) {
00151         CommitSize = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
00152         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwAllocateVirtualMemory( NtCurrentProcess(),
00153                                           (PVOID *)&amp;CommitBase,
00154                                           0,
00155                                           &amp;CommitSize,
00156                                           MEM_COMMIT,
00157                                           PAGE_READWRITE
00158                                         );
00159         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
00160             KdPrint(( <span class="stringliteral">"RTL: Unable to commit space to extend stack trace data base - Status = %lx\n"</span>,
00161                       Status
00162                    ));
00163             <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00164             }
00165 
00166         DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o6">PreCommitted</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00167         }
00168     <span class="keywordflow">else</span>
00169     <span class="keywordflow">if</span> (CommitSize == ReserveSize) {
00170         RtlZeroMemory( DataBase, <span class="keyword">sizeof</span>( *DataBase ) );
00171         DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o6">PreCommitted</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00172         }
00173     <span class="keywordflow">else</span> {
00174         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
00175         }
00176 
00177     DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o8">CommitBase</a> = CommitBase;
00178     DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o16">NumberOfBuckets</a> = 37;
00179     DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o11">NextFreeLowerMemory</a> = (PCHAR)
00180         (&amp;DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o17">Buckets</a>[ DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o16">NumberOfBuckets</a> ]);
00181     DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o12">NextFreeUpperMemory</a> = (PCHAR)CommitBase + ReserveSize;
00182 
00183     <span class="keywordflow">if</span>(!DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o6">PreCommitted</a>) {
00184         DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o9">CurrentLowerCommitLimit</a> = (PCHAR)CommitBase + CommitSize;
00185         DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o10">CurrentUpperCommitLimit</a> = (PCHAR)CommitBase + ReserveSize;
00186         }
00187     <span class="keywordflow">else</span> {
00188         RtlZeroMemory( &amp;DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o17">Buckets</a>[ 0 ],
00189                        DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o16">NumberOfBuckets</a> * <span class="keyword">sizeof</span>( DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o17">Buckets</a>[ 0 ] )
00190                      );
00191         }
00192 
00193     DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o15">EntryIndexArray</a> = (<a class="code" href="../../d9/d5/struct__RTL__STACK__TRACE__ENTRY.html">PRTL_STACK_TRACE_ENTRY</a> *)DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o12">NextFreeUpperMemory</a>;
00194 
00195     DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o3">AcquireLockRoutine</a> = AcquireLockRoutine;
00196     DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o4">ReleaseLockRoutine</a> = ReleaseLockRoutine;
00197     DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o5">OkayToLockRoutine</a> = OkayToLockRoutine;
00198 
00199     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = (InitializeLockRoutine)( &amp;DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o2">Lock</a>.CriticalSection );
00200     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
00201         KdPrint(( <span class="stringliteral">"RTL: Unable to initialize stack trace data base CriticalSection,  Status = %lx\n"</span>,
00202                   Status
00203                ));
00204         <span class="keywordflow">return</span>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
00205         }
00206 
00207     RtlpStackTraceDataBase = DataBase;
00208     <span class="keywordflow">return</span>( STATUS_SUCCESS );
00209 }
00210 
00211 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00212 RtlInitializeStackTraceDataBase(
00213     IN PVOID CommitBase,
00214     IN ULONG CommitSize,
00215     IN ULONG ReserveSize
00216     )
00217 {
00218 <span class="preprocessor">#ifdef NTOS_KERNEL_RUNTIME</span>
00219 <span class="preprocessor"></span>
00220 BOOLEAN
00221 <a class="code" href="../../d2/d2/ex_2pool_8c.html#a70">ExOkayToLockRoutine</a>(
00222     IN PVOID Lock
00223     );
00224 
00225     <span class="keywordflow">return</span> RtlInitStackTraceDataBaseEx(
00226                 CommitBase,
00227                 CommitSize,
00228                 ReserveSize,
00229                 ExInitializeResource,
00230                 (PRTL_RELEASE_LOCK_ROUTINE)ExAcquireResourceExclusive,
00231                 (PRTL_RELEASE_LOCK_ROUTINE)ExReleaseResourceLite,
00232                 ExOkayToLockRoutine
00233                 );
00234 <span class="preprocessor">#else // #ifdef NTOS_KERNEL_RUNTIME</span>
00235 <span class="preprocessor"></span>
00236     <span class="keywordflow">return</span> RtlInitStackTraceDataBaseEx(
00237                 CommitBase,
00238                 CommitSize,
00239                 ReserveSize,
00240                 RtlInitializeCriticalSection,
00241                 RtlEnterCriticalSection,
00242                 RtlLeaveCriticalSection,
00243                 NtdllOkayToLockRoutine
00244                 );
00245 <span class="preprocessor">#endif // #ifdef NTOS_KERNEL_RUNTIME</span>
00246 <span class="preprocessor"></span>}
00247 
00248 
00249 <a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html">PSTACK_TRACE_DATABASE</a>
00250 <a class="code" href="../../d8/d6/stktrace_8h.html#a4">RtlpAcquireStackTraceDataBase</a>( VOID )
00251 {
00252     <span class="keywordflow">if</span> (RtlpStackTraceDataBase != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00253         <span class="keywordflow">if</span> (RtlpStackTraceDataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o7">DumpInProgress</a> ||
00254             !(RtlpStackTraceDataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o5">OkayToLockRoutine</a>)( &amp;RtlpStackTraceDataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o2">Lock</a>.CriticalSection )
00255            ) {
00256             <span class="keywordflow">return</span>( <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00257             }
00258 
00259         (RtlpStackTraceDataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o3">AcquireLockRoutine</a>)( &amp;RtlpStackTraceDataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o2">Lock</a>.CriticalSection );
00260         }
00261 
00262     <span class="keywordflow">return</span>( RtlpStackTraceDataBase );
00263 }
00264 
00265 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00266 <a class="code" href="../../d8/d6/stktrace_8h.html#a5">RtlpReleaseStackTraceDataBase</a>( VOID )
00267 {
00268     (RtlpStackTraceDataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o4">ReleaseLockRoutine</a>)( &amp;RtlpStackTraceDataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o2">Lock</a>.CriticalSection );
00269     <span class="keywordflow">return</span>;
00270 }
00271 
00272 <a class="code" href="../../d9/d5/struct__RTL__STACK__TRACE__ENTRY.html">PRTL_STACK_TRACE_ENTRY</a>
00273 RtlpExtendStackTraceDataBase(
00274     IN <a class="code" href="../../d9/d5/struct__RTL__STACK__TRACE__ENTRY.html">PRTL_STACK_TRACE_ENTRY</a> InitialValue,
00275     IN ULONG Size
00276     )
00277 <span class="comment">/*++</span>
00278 <span class="comment"></span>
00279 <span class="comment">Routine Description:</span>
00280 <span class="comment"></span>
00281 <span class="comment">    This routine extends the stack trace database in order to accomodate</span>
00282 <span class="comment">    the new stack trace that has to be saved.</span>
00283 <span class="comment"></span>
00284 <span class="comment">Arguments:</span>
00285 <span class="comment"></span>
00286 <span class="comment">    InitialValue - stack trace to be saved.</span>
00287 <span class="comment">    </span>
00288 <span class="comment">    Size - size of the stack trace in bytes. Note that this is not the</span>
00289 <span class="comment">        depth of the trace but rather `Depth * sizeof(PVOID)'.</span>
00290 <span class="comment"></span>
00291 <span class="comment">Return Value:</span>
00292 <span class="comment"></span>
00293 <span class="comment">    The address of the just saved stack trace or null in case we have hit</span>
00294 <span class="comment">    the maximum size of the database or we get commit errors.</span>
00295 <span class="comment"></span>
00296 <span class="comment">Environment:</span>
00297 <span class="comment"></span>
00298 <span class="comment">    User mode. </span>
00299 <span class="comment">    </span>
00300 <span class="comment">    Note. In order to make all this code work in kernel mode we have to</span>
00301 <span class="comment">    rewrite this function that relies on VirtualAlloc.</span>
00302 <span class="comment"></span>
00303 <span class="comment">--*/</span>
00304 
00305 {
00306     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00307     <a class="code" href="../../d9/d5/struct__RTL__STACK__TRACE__ENTRY.html">PRTL_STACK_TRACE_ENTRY</a> p, *pp;
00308     ULONG CommitSize;
00309     <a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html">PSTACK_TRACE_DATABASE</a> DataBase;
00310 
00311     DataBase = RtlpStackTraceDataBase;
00312 
00313     <span class="comment">//</span>
00314     <span class="comment">// We will try to find space for one stack trace entry in the</span>
00315     <span class="comment">// upper part of the database.</span>
00316     <span class="comment">//</span>
00317 
00318     pp = (<a class="code" href="../../d9/d5/struct__RTL__STACK__TRACE__ENTRY.html">PRTL_STACK_TRACE_ENTRY</a> *)DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o12">NextFreeUpperMemory</a>;
00319 
00320     <span class="keywordflow">if</span> ((! DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o6">PreCommitted</a>) &amp;&amp;
00321         ((PCHAR)(pp - 1) &lt; (PCHAR)DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o10">CurrentUpperCommitLimit</a>)) {
00322 
00323         <span class="comment">//</span>
00324         <span class="comment">// No more committed space in the upper part of the database.</span>
00325         <span class="comment">// We need to extend it downwards.</span>
00326         <span class="comment">//</span>
00327 
00328         DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o10">CurrentUpperCommitLimit</a> = 
00329             (PVOID)((PCHAR)DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o10">CurrentUpperCommitLimit</a> - <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
00330 
00331         <span class="keywordflow">if</span> (DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o10">CurrentUpperCommitLimit</a> &lt; DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o9">CurrentLowerCommitLimit</a>) {
00332 
00333             <span class="comment">//</span>
00334             <span class="comment">// No more space at all. We have got over the lower part of the db.</span>
00335             <span class="comment">// We failed therefore increase back the UpperCommitLimit pointer.</span>
00336             <span class="comment">//</span>
00337 
00338             DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o10">CurrentUpperCommitLimit</a> = 
00339                 (PVOID)((PCHAR)DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o10">CurrentUpperCommitLimit</a> + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
00340 
00341             <span class="keywordflow">return</span>( <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00342         }
00343 
00344         CommitSize = <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
00345         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwAllocateVirtualMemory( 
00346             NtCurrentProcess(),
00347             (PVOID *)&amp;DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o10">CurrentUpperCommitLimit</a>,
00348             0,
00349             &amp;CommitSize,
00350             MEM_COMMIT,
00351             PAGE_READWRITE
00352             );
00353 
00354         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
00355 
00356             <span class="comment">//</span>
00357             <span class="comment">// We tried to increase the upper part of the db by one page.</span>
00358             <span class="comment">// We failed therefore increase back the UpperCommitLimit pointer</span>
00359             <span class="comment">//</span>
00360 
00361             DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o10">CurrentUpperCommitLimit</a> = 
00362                 (PVOID)((PCHAR)DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o10">CurrentUpperCommitLimit</a> + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
00363 
00364             KdPrint(( <span class="stringliteral">"RTL: Unable to commit space to extend stack trace data base - Status = %lx\n"</span>,
00365                 Status
00366                 ));
00367             <span class="keywordflow">return</span>( <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00368         }
00369     }
00370 
00371     <span class="comment">//</span>
00372     <span class="comment">// We managed to make sure we have usable space in the upper part</span>
00373     <span class="comment">// therefore we take out one stack trace entry address.</span>
00374     <span class="comment">//</span>
00375 
00376     DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o12">NextFreeUpperMemory</a> -= <span class="keyword">sizeof</span>( *pp );
00377 
00378     <span class="comment">//</span>
00379     <span class="comment">// Now we will try to find space in the lower part of the database for</span>
00380     <span class="comment">// for the eactual stack trace.</span>
00381     <span class="comment">//</span>
00382 
00383     p = (<a class="code" href="../../d9/d5/struct__RTL__STACK__TRACE__ENTRY.html">PRTL_STACK_TRACE_ENTRY</a>)DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o11">NextFreeLowerMemory</a>;
00384 
00385     <span class="keywordflow">if</span> ((! DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o6">PreCommitted</a>) &amp;&amp;
00386         (((PCHAR)p + <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>) &gt; (PCHAR)DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o9">CurrentLowerCommitLimit</a>)) {
00387 
00388         <span class="comment">//</span>
00389         <span class="comment">// We need to extend the lower part.</span>
00390         <span class="comment">//</span>
00391 
00392         <span class="keywordflow">if</span> (DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o9">CurrentLowerCommitLimit</a> &gt;= DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o10">CurrentUpperCommitLimit</a>) {
00393 
00394             <span class="comment">//</span>
00395             <span class="comment">// We have hit the maximum size of the database.</span>
00396             <span class="comment">//</span>
00397 
00398             <span class="keywordflow">return</span>( <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00399         }
00400 
00401         <span class="comment">//</span>
00402         <span class="comment">// Extend the lower part of the database by one page.</span>
00403         <span class="comment">//</span>
00404 
00405         CommitSize = <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
00406         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwAllocateVirtualMemory( 
00407             NtCurrentProcess(),
00408             (PVOID *)&amp;DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o9">CurrentLowerCommitLimit</a>,
00409             0,
00410             &amp;CommitSize,
00411             MEM_COMMIT,
00412             PAGE_READWRITE
00413             );
00414 
00415         <span class="keywordflow">if</span> (! <a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status )) {
00416             KdPrint(( <span class="stringliteral">"RTL: Unable to commit space to extend stack trace data base - Status = %lx\n"</span>,
00417                 Status
00418                 ));
00419             <span class="keywordflow">return</span>( <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00420         }
00421 
00422         DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o9">CurrentLowerCommitLimit</a> =
00423             (PCHAR)DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o9">CurrentLowerCommitLimit</a> + CommitSize;
00424     }
00425 
00426     <span class="comment">//</span>
00427     <span class="comment">// Take out the space for the stack trace.</span>
00428     <span class="comment">//</span>
00429 
00430     DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o11">NextFreeLowerMemory</a> += <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
00431 
00432     <span class="comment">//</span>
00433     <span class="comment">// Deal with a precommitted database case. If the lower and upper</span>
00434     <span class="comment">// pointers have crossed each other then rollback and return failure.</span>
00435     <span class="comment">//</span>
00436 
00437     <span class="keywordflow">if</span> (DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o6">PreCommitted</a> &amp;&amp;
00438         DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o11">NextFreeLowerMemory</a> &gt;= DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o12">NextFreeUpperMemory</a>) {
00439 
00440         DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o12">NextFreeUpperMemory</a> += <span class="keyword">sizeof</span>( *pp );
00441         DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o11">NextFreeLowerMemory</a> -= <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
00442         <span class="keywordflow">return</span>( <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00443     }
00444 
00445     <span class="comment">//</span>
00446     <span class="comment">// Save the stack trace in the database</span>
00447     <span class="comment">//</span>
00448 
00449     RtlMoveMemory( p, InitialValue, Size );
00450     p-&gt;<a class="code" href="../../d9/d5/struct__RTL__STACK__TRACE__ENTRY.html#o0">HashChain</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00451     p-&gt;<a class="code" href="../../d9/d5/struct__RTL__STACK__TRACE__ENTRY.html#o1">TraceCount</a> = 0;
00452     p-&gt;<a class="code" href="../../d9/d5/struct__RTL__STACK__TRACE__ENTRY.html#o2">Index</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(++DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o14">NumberOfEntriesAdded</a>);
00453 
00454     <span class="comment">//</span>
00455     <span class="comment">// Save the address of the new stack trace entry in the</span>
00456     <span class="comment">// upper part of the databse.</span>
00457     <span class="comment">//</span>
00458 
00459     *--pp = p;
00460 
00461     <span class="comment">//</span>
00462     <span class="comment">// Return address of the saved stack trace entry.</span>
00463     <span class="comment">//</span>
00464 
00465     <span class="keywordflow">return</span>( p );
00466 }
00467 
00468 <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>
00469 RtlLogStackBackTrace( 
00470     VOID 
00471     )
00472 <span class="comment">/*++</span>
00473 <span class="comment"></span>
00474 <span class="comment">Routine Description:</span>
00475 <span class="comment"></span>
00476 <span class="comment">    This routine will capture the current stacktrace (skipping the </span>
00477 <span class="comment">    present function) and will save it in the global (per process) </span>
00478 <span class="comment">    stack trace database. It should be noted that we do not save</span>
00479 <span class="comment">    duplicate traces.</span>
00480 <span class="comment"></span>
00481 <span class="comment">Arguments:</span>
00482 <span class="comment"></span>
00483 <span class="comment">    None.</span>
00484 <span class="comment"></span>
00485 <span class="comment">Return Value:</span>
00486 <span class="comment"></span>
00487 <span class="comment">    Index of the stack trace saved. The index can be used by tools</span>
00488 <span class="comment">    to access quickly the trace data. This is the reason at the end of</span>
00489 <span class="comment">    the database we save downwards a list of pointers to trace entries.</span>
00490 <span class="comment">    This index can be used to find this pointer in constant time.</span>
00491 <span class="comment">    </span>
00492 <span class="comment">    A zero index will be returned for error conditions (e.g. stack </span>
00493 <span class="comment">    trace database not initialized).</span>
00494 <span class="comment"></span>
00495 <span class="comment">Environment:</span>
00496 <span class="comment"></span>
00497 <span class="comment">    User mode. </span>
00498 <span class="comment"></span>
00499 <span class="comment">--*/</span>
00500 
00501 {
00502     <a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html">PSTACK_TRACE_DATABASE</a> DataBase;
00503     <a class="code" href="../../d9/d5/struct__RTL__STACK__TRACE__ENTRY.html">RTL_STACK_TRACE_ENTRY</a> StackTrace;
00504     <a class="code" href="../../d9/d5/struct__RTL__STACK__TRACE__ENTRY.html">PRTL_STACK_TRACE_ENTRY</a> p, *pp;
00505     ULONG Hash, RequestedSize, DepthSize;
00506 
00507     <span class="keywordflow">if</span> (RtlpStackTraceDataBase == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00508         <span class="keywordflow">return</span> 0;
00509         }
00510 
00511     Hash = 0;
00512 
00513     <span class="comment">//</span>
00514     <span class="comment">// Capture stack trace. The try/except was useful</span>
00515     <span class="comment">// in the old days when the function did not validate</span>
00516     <span class="comment">// the stack frame chain. We keep it just ot be defensive.</span>
00517     <span class="comment">//</span>
00518 
00519     <span class="keywordflow">try</span> {
00520         StackTrace.<a class="code" href="../../d9/d5/struct__RTL__STACK__TRACE__ENTRY.html#o3">Depth</a> = <a class="code" href="../../d5/d2/ppc_2getcalr_8c.html#a1">RtlCaptureStackBackTrace</a>(
00521             1,
00522             MAX_STACK_DEPTH,
00523             StackTrace.<a class="code" href="../../d9/d5/struct__RTL__STACK__TRACE__ENTRY.html#o4">BackTrace</a>,
00524             &amp;Hash
00525             );
00526     }
00527     except(EXCEPTION_EXECUTE_HANDLER) {
00528         StackTrace.<a class="code" href="../../d9/d5/struct__RTL__STACK__TRACE__ENTRY.html#o3">Depth</a> = 0;
00529     }
00530 
00531     <span class="keywordflow">if</span> (StackTrace.<a class="code" href="../../d9/d5/struct__RTL__STACK__TRACE__ENTRY.html#o3">Depth</a> == 0) {
00532         <span class="keywordflow">return</span> 0;
00533     }
00534 
00535     <span class="comment">//</span>
00536     <span class="comment">// Lock the global per-process stack trace database.</span>
00537     <span class="comment">//</span>
00538 
00539     DataBase = <a class="code" href="../../d8/d6/stktrace_8h.html#a4">RtlpAcquireStackTraceDataBase</a>();
00540     
00541     <span class="keywordflow">if</span> (DataBase == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00542         <span class="keywordflow">return</span>( 0 );
00543     }
00544 
00545     DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o13">NumberOfEntriesLookedUp</a>++;
00546 
00547     <span class="keywordflow">try</span> {
00548 
00549         <span class="comment">//</span>
00550         <span class="comment">// We will try to find out if the trace has been saved in the past.</span>
00551         <span class="comment">// We find the right hash chain and then traverse it.</span>
00552         <span class="comment">//</span>
00553 
00554         DepthSize = StackTrace.<a class="code" href="../../d9/d5/struct__RTL__STACK__TRACE__ENTRY.html#o3">Depth</a> * <span class="keyword">sizeof</span>( StackTrace.<a class="code" href="../../d9/d5/struct__RTL__STACK__TRACE__ENTRY.html#o4">BackTrace</a>[ 0 ] );
00555         pp = &amp;DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o17">Buckets</a>[ Hash % DataBase-&gt;<a class="code" href="../../d7/d5/struct__STACK__TRACE__DATABASE.html#o16">NumberOfBuckets</a> ];
00556 
00557         <span class="keywordflow">while</span> (p = *pp) {
00558             <span class="keywordflow">if</span> (p-&gt;<a class="code" href="../../d9/d5/struct__RTL__STACK__TRACE__ENTRY.html#o3">Depth</a> == StackTrace.<a class="code" href="../../d9/d5/struct__RTL__STACK__TRACE__ENTRY.html#o3">Depth</a> &amp;&amp;
00559                 RtlCompareMemory( &amp;p-&gt;<a class="code" href="../../d9/d5/struct__RTL__STACK__TRACE__ENTRY.html#o4">BackTrace</a>[ 0 ],
00560                 &amp;StackTrace.<a class="code" href="../../d9/d5/struct__RTL__STACK__TRACE__ENTRY.html#o4">BackTrace</a>[ 0 ],
00561                 DepthSize
00562                 ) == DepthSize
00563                 ) {
00564                 <span class="keywordflow">break</span>;
00565             }
00566             <span class="keywordflow">else</span> {
00567                 pp = &amp;p-&gt;<a class="code" href="../../d9/d5/struct__RTL__STACK__TRACE__ENTRY.html#o0">HashChain</a>;
00568             }
00569         }
00570 
00571         <span class="keywordflow">if</span> (p == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00572 
00573             <span class="comment">//</span>
00574             <span class="comment">// We did not find the stack trace. We will extend the database</span>
00575             <span class="comment">// and save the new trace.</span>
00576             <span class="comment">//</span>
00577 
00578             RequestedSize = FIELD_OFFSET( <a class="code" href="../../d9/d5/struct__RTL__STACK__TRACE__ENTRY.html">RTL_STACK_TRACE_ENTRY</a>, BackTrace ) +
00579                 DepthSize;
00580 
00581             p = RtlpExtendStackTraceDataBase( &amp;StackTrace, RequestedSize );
00582             
00583             <span class="comment">//</span>
00584             <span class="comment">// If we managed to stack the trace we need to link it as the last</span>
00585             <span class="comment">// element in the proper hash chain.</span>
00586             <span class="comment">//</span>
00587 
00588             <span class="keywordflow">if</span> (p != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00589                 *pp = p;
00590             }
00591         }
00592     }
00593     except(EXCEPTION_EXECUTE_HANDLER) {
00594 
00595         <span class="comment">//</span>
00596         <span class="comment">// bugbug (silviuc): We should not be here. Right?</span>
00597         <span class="comment">//</span>
00598 
00599         p = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00600     }
00601 
00602     <span class="comment">//</span>
00603     <span class="comment">// Release global trace db.</span>
00604     <span class="comment">//</span>
00605 
00606     <a class="code" href="../../d8/d6/stktrace_8h.html#a5">RtlpReleaseStackTraceDataBase</a>();
00607 
00608     <span class="keywordflow">if</span> (p != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00609         p-&gt;<a class="code" href="../../d9/d5/struct__RTL__STACK__TRACE__ENTRY.html#o1">TraceCount</a>++;
00610         <span class="keywordflow">return</span>( p-&gt;<a class="code" href="../../d9/d5/struct__RTL__STACK__TRACE__ENTRY.html#o2">Index</a> );
00611         }
00612     <span class="keywordflow">else</span> {
00613         <span class="keywordflow">return</span>( 0 );
00614         }
00615 
00616     <span class="keywordflow">return</span> 0;
00617 }
00618 <span class="preprocessor">#endif // defined(_X86_) &amp;&amp; !NTOS_KERNEL_RUNTIME</span>
00619 <span class="preprocessor"></span>
00620 
00621 <span class="preprocessor">#if defined(_X86_)</span>
00622 <span class="preprocessor"></span>
00623 <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>
00624 <a class="code" href="../../d5/d2/ppc_2getcalr_8c.html#a1">RtlCaptureStackBackTrace</a>(
00625     IN ULONG FramesToSkip,
00626     IN ULONG FramesToCapture,
00627     OUT PVOID *BackTrace,
00628     OUT PULONG BackTraceHash
00629     )
00630 <span class="comment">/*++</span>
00631 <span class="comment"></span>
00632 <span class="comment">Routine Description:</span>
00633 <span class="comment"></span>
00634 <span class="comment">    This routine walks up the stack frames, capturing the return address from</span>
00635 <span class="comment">    each frame requested. This used to be implemented in assembly language and</span>
00636 <span class="comment">    used to be unsafe in special contexts (DPC level). Right now it uses</span>
00637 <span class="comment">    RtlWalkFrameChain that validates the chain of pointers and it guarantees</span>
00638 <span class="comment">    not to take exceptions.</span>
00639 <span class="comment"></span>
00640 <span class="comment">Arguments:</span>
00641 <span class="comment"></span>
00642 <span class="comment">    FramesToSkip - frames detected but not included in the stack trace</span>
00643 <span class="comment"></span>
00644 <span class="comment">    FramesToCapture - frames to be captured in the stack trace buffer. </span>
00645 <span class="comment">        One of the frames will be for RtlCaptureStackBackTrace.</span>
00646 <span class="comment"></span>
00647 <span class="comment">    BackTrace - stack trace buffer</span>
00648 <span class="comment"></span>
00649 <span class="comment">    BackTraceHash - very simple hash value that can be used to organize</span>
00650 <span class="comment">      hash tables. It is just an arithmetic sum of the pointers in the</span>
00651 <span class="comment">      stack trace buffer.</span>
00652 <span class="comment"></span>
00653 <span class="comment">Return Value:</span>
00654 <span class="comment"></span>
00655 <span class="comment">     Number of return addresses returned in the stack trace buffer.</span>
00656 <span class="comment"></span>
00657 <span class="comment">--*/</span>
00658 {
00659     PVOID Trace [2 * MAX_STACK_DEPTH];
00660     ULONG FramesFound;
00661     ULONG HashValue;
00662     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00663 
00664     <span class="comment">//</span>
00665     <span class="comment">// One more frame to skip for the "capture" function (WalkFrameChain).</span>
00666     <span class="comment">//</span>
00667 
00668     FramesToSkip++;
00669 
00670     <span class="comment">//</span>
00671     <span class="comment">// Sanity checks.</span>
00672     <span class="comment">//</span>
00673 
00674     <span class="keywordflow">if</span> (FramesToCapture + FramesToSkip &gt;= 2 * MAX_STACK_DEPTH) {
00675         <span class="keywordflow">return</span> 0;
00676     }
00677 
00678     FramesFound = <a class="code" href="../../d7/d6/stktrace_8c.html#a7">RtlWalkFrameChain</a> (
00679         Trace,
00680         FramesToCapture + FramesToSkip,
00681         0);
00682 
00683     <span class="keywordflow">if</span> (FramesFound &lt;= FramesToSkip) {
00684         <span class="keywordflow">return</span> 0;
00685     }
00686 
00687     <span class="keywordflow">for</span> (HashValue = 0, <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; FramesToCapture; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>++) {
00688 
00689         <span class="keywordflow">if</span> (FramesToSkip + <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &gt;= FramesFound) {
00690             <span class="keywordflow">break</span>;
00691         }
00692 
00693         BackTrace[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>] = Trace[FramesToSkip + <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>];
00694         HashValue += PtrToUlong(BackTrace[Index]);
00695     }
00696 
00697     *BackTraceHash = HashValue;
00698     <span class="keywordflow">return</span> (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00699 }
00700 <span class="preprocessor">#endif</span>
00701 <span class="preprocessor"></span>
00702 
00703 
00707 
00708 <span class="comment">//</span>
00709 <span class="comment">// This section contains an algorithm for getting stack traces.</span>
00710 <span class="comment">// It works only on x86. It is an improvement of</span>
00711 <span class="comment">// RtlCaptureStackBackTrace which for reasons that escape me is written</span>
00712 <span class="comment">// in assembly and it is unsafe (can raise exceptions). The new function</span>
00713 <span class="comment">// RtlWalkFrameChain is guaranteed to not take exceptions whatever the</span>
00714 <span class="comment">// call context.</span>
00715 <span class="comment">//</span>
00716 <span class="comment">// Note. It might be a good idea to not BBT this code. Especially I am concerned</span>
00717 <span class="comment">// about the only assembly instruction used in the whole code that saves</span>
00718 <span class="comment">// the value of the EBP register.</span>
00719 <span class="comment">//</span>
00720 
00721 <span class="preprocessor">#ifdef NTOS_KERNEL_RUNTIME</span>
00722 <span class="preprocessor"></span><span class="preprocessor">#define _KERNEL_MODE_STACK_TRACES_       1</span>
00723 <span class="preprocessor"></span><span class="preprocessor">#define _COLLECT_FRAME_WALK_STATISTICS_  0</span>
00724 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00725"></a><a class="code" href="../../d7/d6/stktrace_8c.html#a0">00725</a> <span class="preprocessor"></span><span class="preprocessor">#define _KERNEL_MODE_STACK_TRACES_       0</span>
<a name="l00726"></a><a class="code" href="../../d7/d6/stktrace_8c.html#a1">00726</a> <span class="preprocessor"></span><span class="preprocessor">#define _COLLECT_FRAME_WALK_STATISTICS_  0</span>
00727 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00728 <span class="preprocessor"></span>
<a name="l00729"></a><a class="code" href="../../d7/d6/stktrace_8c.html#a2">00729</a> <span class="preprocessor">#define SIZE_1_KB  ((ULONG_PTR) 0x400)</span>
<a name="l00730"></a><a class="code" href="../../d7/d6/stktrace_8c.html#a3">00730</a> <span class="preprocessor"></span><span class="preprocessor">#define SIZE_1_GB  ((ULONG_PTR) 0x40000000)</span>
00731 <span class="preprocessor"></span>
<a name="l00732"></a><a class="code" href="../../d7/d6/stktrace_8c.html#a4">00732</a> <span class="preprocessor">#define PAGE_START(address) (((ULONG_PTR)address) &amp; ~((ULONG_PTR)PAGE_SIZE - 1))</span>
00733 <span class="preprocessor"></span>
00734 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a> <a class="code" href="../../d7/d6/stktrace_8c.html#a6">CollectFrameWalkStatistics</a> (ULONG Index);
00735 
00736 <span class="preprocessor">#if (( i386 ) &amp;&amp; ( FPO ))</span>
00737 <span class="preprocessor"></span><span class="preprocessor">#pragma optimize( "y", off )    // disable FPO for consistent stack traces</span>
00738 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00739 <span class="preprocessor"></span>
00740 ULONG
<a name="l00741"></a><a class="code" href="../../d7/d6/stktrace_8c.html#a7">00741</a> <a class="code" href="../../d7/d6/stktrace_8c.html#a7">RtlWalkFrameChain</a> (
00742 
00743     OUT PVOID *Callers,
00744     IN ULONG Count,
00745     IN ULONG Flags)
00746 
00747 <span class="comment">/*++</span>
00748 <span class="comment"></span>
00749 <span class="comment">Routine Description:</span>
00750 <span class="comment"></span>
00751 <span class="comment">    RtlWalkFrameChain</span>
00752 <span class="comment"></span>
00753 <span class="comment">Description:</span>
00754 <span class="comment"></span>
00755 <span class="comment">    This function tries to walk the EBP chain and fill out a vector of</span>
00756 <span class="comment">    return addresses. The function works only on x86. It is possible that</span>
00757 <span class="comment">    the function cannot fill the requested number of callers because somewhere</span>
00758 <span class="comment">    on the stack we have a function compiled FPO (the frame register (EBP) is</span>
00759 <span class="comment">    used as a normal register. In this case the function will just return with</span>
00760 <span class="comment">    a less then requested count. In kernel mode the function should not take</span>
00761 <span class="comment">    any exceptions (page faults) because it can be called at all sorts of</span>
00762 <span class="comment">    irql levels.</span>
00763 <span class="comment"></span>
00764 <span class="comment">    The `Flags' parameter is used for future extensions. A zero value will be</span>
00765 <span class="comment">    compatible with new stack walking algorithms.</span>
00766 <span class="comment"></span>
00767 <span class="comment">    Note. The algorithm can be somewhat improved by unassembling the return</span>
00768 <span class="comment">    addresses identified. However this is impractical in kernel mode because</span>
00769 <span class="comment">    the function might get called at high irql levels where page faults are</span>
00770 <span class="comment">    not allowed.</span>
00771 <span class="comment"></span>
00772 <span class="comment">Return value:</span>
00773 <span class="comment"></span>
00774 <span class="comment">    The number of identified return addresses on the stack. This can be less</span>
00775 <span class="comment">    then the Count requested if the stack ends or we encounter a FPO compiled</span>
00776 <span class="comment">    function.</span>
00777 <span class="comment"></span>
00778 <span class="comment">--*/</span>
00779 
00780 {
00781 <span class="preprocessor">#if defined(_X86_)</span>
00782 <span class="preprocessor"></span>
00783     ULONG_PTR Fp, NewFp, ReturnAddress;
00784     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00785     ULONG_PTR StackEnd, StackStart;
00786     BOOLEAN Result;
00787 
00788     <span class="comment">//</span>
00789     <span class="comment">// Get the current EBP pointer which is supposed to</span>
00790     <span class="comment">// be the start of the EBP chain.</span>
00791     <span class="comment">//</span>
00792 
00793     _asm mov Fp, EBP;
00794 
00795     StackStart = Fp;
00796 
00797 <span class="preprocessor">#if _KERNEL_MODE_STACK_TRACES_</span>
00798 <span class="preprocessor"></span>
00799     StackEnd = (ULONG_PTR)(<a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>()-&gt;StackBase);
00800 
00801     <span class="comment">//</span>
00802     <span class="comment">// bugbug: find a reliable way to get the stack limit in kernel mode.</span>
00803     <span class="comment">// `StackBase' is not a reliable way to get the stack end in kernel</span>
00804     <span class="comment">// mode because we might execute a DPC routine on thread's behalf.</span>
00805     <span class="comment">// There are a few other reasons why we cannot trust this completely.</span>
00806     <span class="comment">//</span>
00807     <span class="comment">// Note. The condition `PAGE_START(StackEnd) - PAGE_START(StackStart) &gt; PAGE_SIZE'</span>
00808     <span class="comment">// is not totally safe. We can encounter a situation where in this case we</span>
00809     <span class="comment">// do not have the same stack. Can we?</span>
00810     <span class="comment">//</span>
00811     <span class="comment">// The DPC stack is actually the stack of the idle thread corresponding to</span>
00812     <span class="comment">// the current processor. Based on that we probably can figure out in almost</span>
00813     <span class="comment">// all contexts what are the real limits of the stack.</span>
00814     <span class="comment">//</span>
00815 
00816     <span class="keywordflow">if</span> ((StackStart &gt; StackEnd)
00817         || (<a class="code" href="../../d7/d6/stktrace_8c.html#a4">PAGE_START</a>(StackEnd) - <a class="code" href="../../d7/d6/stktrace_8c.html#a4">PAGE_START</a>(StackStart) &gt; <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>)) {
00818 
00819         StackEnd = (StackStart + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>) &amp; ~((ULONG_PTR)<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1);
00820     
00821         <span class="comment">//</span>
00822         <span class="comment">// Try to get one more page if possible. Note that this is not</span>
00823         <span class="comment">// 100% reliable because a non faulting address can fault if</span>
00824         <span class="comment">// appropriate locks are not held.</span>
00825         <span class="comment">//</span>
00826 
00827         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d2/pagfault_8c.html#a26">MmIsAddressValid</a> ((PVOID)StackEnd)) {
00828             StackEnd += <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
00829         }
00830     }
00831 
00832 <span class="preprocessor">#else</span>
00833 <span class="preprocessor"></span>
00834     StackEnd = (ULONG_PTR)(NtCurrentTeb()-&gt;NtTib.StackBase);
00835 
00836 <span class="preprocessor">#endif // #if _KERNEL_MODE_STACK_TRACES_</span>
00837 <span class="preprocessor"></span>
00838     <span class="keywordflow">try</span> {
00839 
00840         <span class="keywordflow">for</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>++) {
00841 
00842             <span class="keywordflow">if</span> (Fp + <span class="keyword">sizeof</span>(ULONG_PTR) &gt;= StackEnd) {
00843                 <span class="keywordflow">break</span>;
00844             }
00845 
00846             NewFp = *((PULONG_PTR)(Fp + 0));
00847             ReturnAddress = *((PULONG_PTR)(Fp + <span class="keyword">sizeof</span>(ULONG_PTR)));
00848 
00849             <span class="comment">//</span>
00850             <span class="comment">// Figure out if the new frame pointer is ok. This validation</span>
00851             <span class="comment">// should avoid all exceptions in kernel mode because we always</span>
00852             <span class="comment">// read within the current thread's stack and the stack is</span>
00853             <span class="comment">// guaranteed to be in memory (no page faults). It is also guaranteed</span>
00854             <span class="comment">// that we do not take random exceptions in user mode because we always</span>
00855             <span class="comment">// keep the frame pointer within stack limits.</span>
00856             <span class="comment">//</span>
00857 
00858             <span class="keywordflow">if</span> (! (Fp &lt; NewFp &amp;&amp; NewFp &lt; StackEnd)) {
00859                 <span class="keywordflow">break</span>;
00860             }
00861 
00862             <span class="comment">//</span>
00863             <span class="comment">// Figure out if the return address is ok. If return address</span>
00864             <span class="comment">// is a stack address or &lt;64k then something is wrong. There is</span>
00865             <span class="comment">// no reason to return garbage to the caller therefore we stop.</span>
00866             <span class="comment">//</span>
00867 
00868             <span class="keywordflow">if</span> (StackStart &lt; ReturnAddress &amp;&amp; ReturnAddress &lt; StackEnd) {
00869                 <span class="keywordflow">break</span>;
00870             }
00871 
00872             <span class="keywordflow">if</span> (ReturnAddress &lt; 64 * <a class="code" href="../../d7/d6/stktrace_8c.html#a2">SIZE_1_KB</a>) {
00873                 <span class="keywordflow">break</span>;
00874             }
00875 
00876             <span class="comment">//</span>
00877             <span class="comment">// Store new fp and return address and move on.</span>
00878             <span class="comment">//</span>
00879 
00880             Fp = NewFp;
00881             Callers[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>] = (PVOID)ReturnAddress;
00882         }
00883     }
00884     except (<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00885 
00886         <span class="comment">//</span>
00887         <span class="comment">// The frame traversal algorithm is written so that we should</span>
00888         <span class="comment">// not get any exception. Therefore if we get some exception</span>
00889         <span class="comment">// we better debug it.</span>
00890         <span class="comment">//</span>
00891         <span class="comment">// bugbug: enable bkpt only on checked builds</span>
00892         <span class="comment">// After we get some coverage on this we should leave it active</span>
00893         <span class="comment">// only on checked builds.</span>
00894         <span class="comment">//</span>
00895 
00896         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a> (<span class="stringliteral">"Unexpected exception in RtlWalkFrameChain ...\n"</span>);
00897         DbgBreakPoint ();
00898     }
00899 
00900     <span class="comment">//</span>
00901     <span class="comment">// Return the number of return addresses identified on the stack.</span>
00902     <span class="comment">//</span>
00903 
00904 <span class="preprocessor">#if _COLLECT_FRAME_WALK_STATISTICS_</span>
00905 <span class="preprocessor"></span>    <a class="code" href="../../d7/d6/stktrace_8c.html#a6">CollectFrameWalkStatistics</a> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>);
00906 <span class="preprocessor">#endif // #if _COLLECT_FRAME_WALK_STATISTICS_</span>
00907 <span class="preprocessor"></span>
00908     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00909 
00910 <span class="preprocessor">#else</span>
00911 <span class="preprocessor"></span>
00912     <span class="keywordflow">return</span> 0;
00913 
00914 <span class="preprocessor">#endif // #if defined(_X86_)</span>
00915 <span class="preprocessor"></span>}
00916 
00917 
00918 <span class="preprocessor">#if _COLLECT_FRAME_WALK_STATISTICS_</span>
00919 <span class="preprocessor"></span>
00920 KSPIN_LOCK FrameWalkStatisticsLock;
00921 ULONG FrameWalkStatisticsCounters [32];
00922 ULONG FrameWalkCollectStatisticsCalls;
00923 BOOLEAN FrameWalkStatisticsInitialized;
00924 
00925 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00926 <a class="code" href="../../d7/d6/stktrace_8c.html#a6">CollectFrameWalkStatistics</a> (
00927 
00928     ULONG Index)
00929 
00930 <span class="comment">/*++</span>
00931 <span class="comment"></span>
00932 <span class="comment">Routine description:</span>
00933 <span class="comment"></span>
00934 <span class="comment">    CollectFrameWalkStatistics</span>
00935 <span class="comment"></span>
00936 <span class="comment">Description:</span>
00937 <span class="comment"></span>
00938 <span class="comment">    This function computes the distribution of detectable chain</span>
00939 <span class="comment">    lengths. This is used only for debugging the frame traversal</span>
00940 <span class="comment">    algorithm. It proves that it is worth trying to get stack</span>
00941 <span class="comment">    traces on optimized images because only about 8% of the calls</span>
00942 <span class="comment">    cannot be resolved to more than two callers. A sample distribution</span>
00943 <span class="comment">    computed by calling RtlWalkFrameChain for every call to</span>
00944 <span class="comment">    ExAllocatePoolWithTag gave the results below:</span>
00945 <span class="comment"></span>
00946 <span class="comment">         Length       Percentage</span>
00947 <span class="comment">         0-2          5%</span>
00948 <span class="comment">         3-5          20%</span>
00949 <span class="comment">         6-10         40%</span>
00950 <span class="comment">         10-16        35%</span>
00951 <span class="comment"></span>
00952 <span class="comment">    With a failure rate of 5% it is worth using it.</span>
00953 <span class="comment"></span>
00954 <span class="comment">--*/</span>
00955 
00956 {
00957     KIRQL PreviousIrql;
00958     ULONG I;
00959     ULONG Percentage;
00960     ULONG TotalPercentage;
00961 
00962     <span class="comment">//</span>
00963     <span class="comment">// Spin lock initialization is not safe in the code below</span>
00964     <span class="comment">// but this code is used only during frame walk algorithm</span>
00965     <span class="comment">// development so there is no reason to make it bulletproof.</span>
00966     <span class="comment">//</span>
00967 
00968     <span class="keywordflow">if</span> (! FrameWalkStatisticsInitialized) {
00969         <a class="code" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock</a> (&amp;FrameWalkStatisticsLock);
00970         FrameWalkStatisticsInitialized = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00971     }
00972 
00973     <a class="code" href="../../d4/d9/ke_8h.html#a37">KeAcquireSpinLock</a> (
00974         &amp;FrameWalkStatisticsLock,
00975         &amp;PreviousIrql);
00976 
00977     FrameWalkCollectStatisticsCalls++;
00978 
00979     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; 32) {
00980         FrameWalkStatisticsCounters[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>]++;
00981     }
00982 
00983     <span class="keywordflow">if</span> (FrameWalkCollectStatisticsCalls != 0
00984         &amp;&amp; (FrameWalkCollectStatisticsCalls % 60000 == 0)) {
00985 
00986         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a> (<span class="stringliteral">"FrameWalk: %u calls \n"</span>, FrameWalkCollectStatisticsCalls);
00987 
00988         TotalPercentage = 0;
00989 
00990         <span class="keywordflow">for</span> (I = 0; I &lt; 32; I++) {
00991 
00992             Percentage = FrameWalkStatisticsCounters[I] * 100
00993                 / FrameWalkCollectStatisticsCalls;
00994 
00995             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a> (<span class="stringliteral">"FrameWalk: [%02u] %02u \n"</span>, I, Percentage);
00996 
00997             TotalPercentage += Percentage;
00998         }
00999 
01000         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a> (<span class="stringliteral">"FrameWalk: total %u \n"</span>, TotalPercentage);
01001         DbgBreakPoint ();
01002     }
01003 
01004     <a class="code" href="../../d9/d5/verifier_8c.html#a119">KeReleaseSpinLock</a> (
01005         &amp;FrameWalkStatisticsLock,
01006         PreviousIrql);
01007 }
01008 
01009 <span class="preprocessor">#endif // #if _COLLECT_FRAME_WALK_STATISTICS_</span>
01010 <span class="preprocessor"></span>
01011 
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:41:52 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
