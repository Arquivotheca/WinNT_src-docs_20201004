<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: physical.c File Reference</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>physical.c File Reference</h1><code>#include "<a class="el" href="../../d5/d7/mi_8h-source.html">mi.h</a>"</code><br>

<p>
<a href="../../d9/d4/physical_8c-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d5/physical_8c.html#a0">COPY_STACK_SIZE</a>&nbsp;&nbsp;&nbsp;256</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d5/physical_8c.html#a1">BITS_IN_ULONG</a>&nbsp;&nbsp;&nbsp;((sizeof (ULONG)) * 8)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d5/physical_8c.html#a2">LOWEST_USABLE_PHYSICAL_ADDRESS</a>&nbsp;&nbsp;&nbsp;(16 * 1024 * 1024)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d5/physical_8c.html#a3">LOWEST_USABLE_PHYSICAL_PAGE</a>&nbsp;&nbsp;&nbsp;(LOWEST_USABLE_PHYSICAL_ADDRESS &gt;&gt; PAGE_SHIFT)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d5/physical_8c.html#a4">LOWEST_BITMAP_PHYSICAL_PAGE</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d5/physical_8c.html#a5">MI_FRAME_TO_BITMAP_INDEX</a>(x)&nbsp;&nbsp;&nbsp;((ULONG)(x))</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d5/physical_8c.html#a6">MI_BITMAP_INDEX_TO_FRAME</a>(x)&nbsp;&nbsp;&nbsp;((ULONG)(x))</td></tr>

<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d5/physical_8c.html#a8">MiFlushUserPhysicalPteList</a> (IN <a class="el" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html">PMMPTE_FLUSH_LIST</a> PteFlushList)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d5/physical_8c.html#a9">NtMapUserPhysicalPages</a> (IN PVOID VirtualAddress, IN ULONG_PTR NumberOfPages, IN PULONG_PTR UserPfnArray OPTIONAL)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d5/physical_8c.html#a10">NtMapUserPhysicalPagesScatter</a> (IN PVOID *VirtualAddresses, IN ULONG_PTR NumberOfPages, IN PULONG_PTR UserPfnArray OPTIONAL)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d5/physical_8c.html#a11">NtAllocateUserPhysicalPages</a> (IN HANDLE ProcessHandle, IN OUT PULONG_PTR NumberOfPages, OUT PULONG_PTR UserPfnArray)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d5/physical_8c.html#a12">NtFreeUserPhysicalPages</a> (IN HANDLE ProcessHandle, IN OUT PULONG_PTR NumberOfPages, IN PULONG_PTR UserPfnArray)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d5/physical_8c.html#a13">MiRemoveUserPhysicalPagesVad</a> (IN <a class="el" href="../../d3/d7/struct__MMVAD__SHORT.html">PMMVAD_SHORT</a> Vad)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d5/physical_8c.html#a14">MiUpdateVadPhysicalPages</a> (IN ULONG_PTR TotalFreedPages)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d5/physical_8c.html#a15">MiCleanPhysicalProcessPages</a> (IN <a class="el" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process)</td></tr>

<tr><td colspan=2><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG_PTR&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d5/physical_8c.html#a7">MmVadPhysicalPages</a></td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="a1" doxytag="physical.c::BITS_IN_ULONG" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define BITS_IN_ULONG&nbsp;&nbsp;&nbsp;((sizeof (ULONG)) * 8)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d4/physical_8c-source.html#l00067">67</a> of file <a class="el" href="../../d9/d4/physical_8c-source.html">physical.c</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a0" doxytag="physical.c::COPY_STACK_SIZE" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define COPY_STACK_SIZE&nbsp;&nbsp;&nbsp;256          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d4/physical_8c-source.html#l00065">65</a> of file <a class="el" href="../../d9/d4/physical_8c-source.html">physical.c</a>.
<p>
Referenced by <a class="el" href="../../d9/d4/physical_8c-source.html#l02313">MiCleanPhysicalProcessPages()</a>, <a class="el" href="../../d0/d5/readwrt_8c-source.html#l00758">MiDoPoolCopy()</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l01624">NtFreeUserPhysicalPages()</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l00085">NtMapUserPhysicalPages()</a>, and <a class="el" href="../../d9/d4/physical_8c-source.html#l00498">NtMapUserPhysicalPagesScatter()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="physical.c::LOWEST_BITMAP_PHYSICAL_PAGE" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define LOWEST_BITMAP_PHYSICAL_PAGE&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d4/physical_8c-source.html#l00072">72</a> of file <a class="el" href="../../d9/d4/physical_8c-source.html">physical.c</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="physical.c::LOWEST_USABLE_PHYSICAL_ADDRESS" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define LOWEST_USABLE_PHYSICAL_ADDRESS&nbsp;&nbsp;&nbsp;(16 * 1024 * 1024)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d4/physical_8c-source.html#l00069">69</a> of file <a class="el" href="../../d9/d4/physical_8c-source.html">physical.c</a>.
<p>
Referenced by <a class="el" href="../../d9/d4/physical_8c-source.html#l00970">NtAllocateUserPhysicalPages()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="physical.c::LOWEST_USABLE_PHYSICAL_PAGE" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define LOWEST_USABLE_PHYSICAL_PAGE&nbsp;&nbsp;&nbsp;(LOWEST_USABLE_PHYSICAL_ADDRESS &gt;&gt; PAGE_SHIFT)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d4/physical_8c-source.html#l00070">70</a> of file <a class="el" href="../../d9/d4/physical_8c-source.html">physical.c</a>.
<p>
Referenced by <a class="el" href="../../d9/d4/physical_8c-source.html#l02313">MiCleanPhysicalProcessPages()</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l02110">MiRemoveUserPhysicalPagesVad()</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l00970">NtAllocateUserPhysicalPages()</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l01624">NtFreeUserPhysicalPages()</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l00085">NtMapUserPhysicalPages()</a>, and <a class="el" href="../../d9/d4/physical_8c-source.html#l00498">NtMapUserPhysicalPagesScatter()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="physical.c::MI_BITMAP_INDEX_TO_FRAME" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define MI_BITMAP_INDEX_TO_FRAME          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">x&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;((ULONG)(x))</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d4/physical_8c-source.html#l00074">74</a> of file <a class="el" href="../../d9/d4/physical_8c-source.html">physical.c</a>.
<p>
Referenced by <a class="el" href="../../d9/d4/physical_8c-source.html#l02313">MiCleanPhysicalProcessPages()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="physical.c::MI_FRAME_TO_BITMAP_INDEX" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define MI_FRAME_TO_BITMAP_INDEX          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">x&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;((ULONG)(x))</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d4/physical_8c-source.html#l00073">73</a> of file <a class="el" href="../../d9/d4/physical_8c-source.html">physical.c</a>.
<p>
Referenced by <a class="el" href="../../d9/d4/physical_8c-source.html#l00970">NtAllocateUserPhysicalPages()</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l01624">NtFreeUserPhysicalPages()</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l00085">NtMapUserPhysicalPages()</a>, and <a class="el" href="../../d9/d4/physical_8c-source.html#l00498">NtMapUserPhysicalPagesScatter()</a>.    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a15" doxytag="physical.c::MiCleanPhysicalProcessPages" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID MiCleanPhysicalProcessPages           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>Process</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d4/physical_8c-source.html#l02313">2313</a> of file <a class="el" href="../../d9/d4/physical_8c-source.html">physical.c</a>.
<p>
References <a class="el" href="../../d7/d6/halmips_8h-source.html#l00086">APC_LEVEL</a>, <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d9/d8/tbitmap_8c-source.html#l00028">BitMap</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l00065">COPY_STACK_SIZE</a>, <a class="el" href="../../d7/d2/cmwraper_8c-source.html#l00304">ExFreePool()</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l00070">LOWEST_USABLE_PHYSICAL_PAGE</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l00074">MI_BITMAP_INDEX_TO_FRAME</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l00769">MI_PFN_ELEMENT</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l01221">MI_PFN_IS_AWE</a>, <a class="el" href="../../d9/d7/alpha_2mialpha_8h-source.html#l00909">MI_SET_PFN_DELETED</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l02278">MiUpdateVadPhysicalPages()</a>, <a class="el" href="../../d6/d5/iosup_8c-source.html#l05051">MmFreePagesFromMdl()</a>, <a class="el" href="../../d3/d2/dumpctl_8c-source.html#l00076">MmHighestPossiblePhysicalPage</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l01789">MmInitializeMdl</a>, <a class="el" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00600">PAGE_SHIFT</a>, <a class="el" href="../../d1/d1/psquota_8c-source.html#l00356">PsReturnPoolQuota()</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l01281">_MMPFN::PteAddress</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00866">RtlFindSetBits()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, and <a class="el" href="../../d4/d3/struct__MMPFN.html#o10">_MMPFN::u2</a>.
<p>
Referenced by <a class="el" href="../../d5/d4/procsup_8c-source.html#l01695">MmCleanProcessAddressSpace()</a>.
<p>
<pre class="fragment"><div>02319                    :
02320 
02321     This routine frees <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> VadPhysicalBitMap, any remaining physical pages (as
02322     they may not have been currently mapped into any Vads) and returns <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
02323     bitmap quota.
02324 
02325 Arguments:
02326 
02327     Process - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> process to clean.
02328 
02329 Return Value:
02330 
02331     None.
02332 
02333 Environment:
02334 
02335     Kernel mode, APC level, working set mutex held.  Called <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> on process
02336     <a class="code" href="../../d9/d1/fedefs_8h.html#a16">exit</a>, so <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> AWE lock <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not needed here.
02337 
02338 --*/
02339 
02340 {
02341     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
02342     ULONG BitMapSize;
02343     ULONG BitMapIndex;
02344     ULONG BitMapHint;
02345     PRTL_BITMAP <a class="code" href="../../d2/d1/structBitMap.html">BitMap</a>;
02346     PPFN_NUMBER MdlPage;
02347     PFN_NUMBER MdlHack[(<span class="keyword">sizeof</span>(<a class="code" href="../../d6/d7/struct__MDL.html">MDL</a>) / <span class="keyword">sizeof</span>(PFN_NUMBER)) + <a class="code" href="../../d8/d5/physical_8c.html#a0">COPY_STACK_SIZE</a>];
02348     ULONG_PTR MdlPages;
02349     ULONG_PTR NumberOfPages;
02350     ULONG_PTR TotalFreedPages;
02351     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MemoryDescriptorList;
02352     PFN_NUMBER PageFrameIndex;
02353 <span class="preprocessor">#if DBG</span>
02354 <span class="preprocessor"></span>    ULONG_PTR ActualPages = 0;
02355     ULONG_PTR ExpectedPages = 0;
02356 <span class="preprocessor">#endif</span>
02357 <span class="preprocessor"></span>
02358     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (KeGetCurrentIrql() == APC_LEVEL);
02359 
02360 <span class="preprocessor">#if DBG</span>
02361 <span class="preprocessor"></span>    ExpectedPages = Process-&gt;VadPhysicalPages;
02362 <span class="preprocessor">#else</span>
02363 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (Process-&gt;VadPhysicalPages == 0) {
02364         <span class="keywordflow">return</span>;
02365     }
02366 <span class="preprocessor">#endif</span>
02367 <span class="preprocessor"></span>
02368     TotalFreedPages = 0;
02369     <a class="code" href="../../d8/d9/tbitmap_8c.html#a2">BitMap</a> = Process-&gt;VadPhysicalPagesBitMap;
02370 
02371     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d9/tbitmap_8c.html#a2">BitMap</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02372 
02373         MdlPages = <a class="code" href="../../d8/d5/physical_8c.html#a0">COPY_STACK_SIZE</a>;
02374         MemoryDescriptorList = (<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>)&amp;MdlHack[0];
02375 
02376         MdlPage = (PPFN_NUMBER)(MemoryDescriptorList + 1);
02377         NumberOfPages = 0;
02378     
02379         BitMapHint = 0;
02380 
02381         <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
02382 
02383             BitMapIndex = <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a30">RtlFindSetBits</a> (BitMap, 1, BitMapHint);
02384 
02385             <span class="keywordflow">if</span> (BitMapIndex &lt; BitMapHint) {
02386                 <span class="keywordflow">break</span>;
02387             }
02388 
02389             <span class="keywordflow">if</span> (BitMapIndex == 0xFFFFFFFF) {
02390                 <span class="keywordflow">break</span>;
02391             }
02392 
02393             PageFrameIndex = <a class="code" href="../../d8/d5/physical_8c.html#a6">MI_BITMAP_INDEX_TO_FRAME</a>(BitMapIndex);
02394 
02395 <span class="preprocessor">#if defined (_WIN64)</span>
02396 <span class="preprocessor"></span>
02397             <span class="comment">//</span>
02398             <span class="comment">// This may become a problem for 64-bit systems with &gt; 32tb</span>
02399             <span class="comment">// of physical memory as the 3rd parameter to RtlFindSetBits is</span>
02400             <span class="comment">// a ULONG.</span>
02401             <span class="comment">//</span>
02402 
02403             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PageFrameIndex &lt; 0x100000000);
02404 <span class="preprocessor">#endif</span>
02405 <span class="preprocessor"></span>
02406             <span class="comment">//</span>
02407             <span class="comment">// The bitmap search wraps, so handle it here.</span>
02408             <span class="comment">// Note PFN 0 is illegal.</span>
02409             <span class="comment">//</span>
02410     
02411             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PageFrameIndex != 0);
02412             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PageFrameIndex &gt;= LOWEST_USABLE_PHYSICAL_PAGE);
02413 
02414             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (ExpectedPages != 0);
02415             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(PageFrameIndex);
02416             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount == 1);
02417             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> == (<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)0);
02418 
02419             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (MI_PFN_IS_AWE (Pfn1));
02420 
02421             <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a120">MI_SET_PFN_DELETED</a>(Pfn1);
02422 
02423             *MdlPage = PageFrameIndex;
02424             MdlPage += 1;
02425             NumberOfPages += 1;
02426 <span class="preprocessor">#if DBG</span>
02427 <span class="preprocessor"></span>            ActualPages += 1;
02428 <span class="preprocessor">#endif</span>
02429 <span class="preprocessor"></span>
02430             <span class="keywordflow">if</span> (NumberOfPages == <a class="code" href="../../d8/d5/physical_8c.html#a0">COPY_STACK_SIZE</a>) {
02431 
02432                 <span class="comment">//</span>
02433                 <span class="comment">// Free the pages in the full MDL.</span>
02434                 <span class="comment">//</span>
02435 
02436                 <a class="code" href="../../d2/d1/mm_8h.html#a24">MmInitializeMdl</a> (MemoryDescriptorList,
02437                                  0,
02438                                  NumberOfPages &lt;&lt; PAGE_SHIFT);
02439 
02440                 <a class="code" href="../../d5/d6/iosup_8c.html#a64">MmFreePagesFromMdl</a> (MemoryDescriptorList);
02441 
02442                 MdlPage = (PPFN_NUMBER)(MemoryDescriptorList + 1);
02443                 Process-&gt;VadPhysicalPages -= NumberOfPages;
02444                 TotalFreedPages += NumberOfPages;
02445                 NumberOfPages = 0;
02446             }
02447 
02448             BitMapHint = BitMapIndex + 1;
02449             <span class="keywordflow">if</span> (BitMapHint &gt;= <a class="code" href="../../d8/d9/tbitmap_8c.html#a2">BitMap</a>-&gt;SizeOfBitMap) {
02450                 <span class="keywordflow">break</span>;
02451             }
02452         }
02453 
02454         <span class="comment">//</span>
02455         <span class="comment">// Free any straggling MDL pages here.</span>
02456         <span class="comment">//</span>
02457 
02458         <span class="keywordflow">if</span> (NumberOfPages != 0) {
02459             <a class="code" href="../../d2/d1/mm_8h.html#a24">MmInitializeMdl</a> (MemoryDescriptorList,
02460                              0,
02461                              NumberOfPages &lt;&lt; PAGE_SHIFT);
02462 
02463             <a class="code" href="../../d5/d6/iosup_8c.html#a64">MmFreePagesFromMdl</a> (MemoryDescriptorList);
02464             Process-&gt;VadPhysicalPages -= NumberOfPages;
02465             TotalFreedPages += NumberOfPages;
02466         }
02467 
02468         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (ExpectedPages == ActualPages);
02469 
02470         BitMapSize = <span class="keyword">sizeof</span>(RTL_BITMAP) + (ULONG)((((<a class="code" href="../../d2/d3/dumpctl_8c.html#a16">MmHighestPossiblePhysicalPage</a> + 1) + 31) / 32) * 4);
02471 
02472         Process-&gt;VadPhysicalPagesBitMap = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02473         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (BitMap);
02474         <a class="code" href="../../d0/d2/psquota_8c.html#a3">PsReturnPoolQuota</a> (Process, NonPagedPool, BitMapSize);
02475     }
02476 
02477     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (ExpectedPages == ActualPages);
02478     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Process-&gt;VadPhysicalPages == 0);
02479 
02480     <span class="keywordflow">if</span> (TotalFreedPages != 0) {
02481         <a class="code" href="../../d8/d5/physical_8c.html#a14">MiUpdateVadPhysicalPages</a> (TotalFreedPages);
02482     }
02483 
02484     <span class="keywordflow">return</span>;
02485 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="physical.c::MiFlushUserPhysicalPteList" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID MiFlushUserPhysicalPteList           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html">PMMPTE_FLUSH_LIST</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>PteFlushList</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d4/physical_8c-source.html#l02488">2488</a> of file <a class="el" href="../../d9/d4/physical_8c-source.html">physical.c</a>.
<p>
References <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d1/d5/ppc_2flushtb_8c-source.html#l00033">KeFlushEntireTb()</a>, <a class="el" href="../../d1/d5/ppc_2flushtb_8c-source.html#l00104">KeFlushMultipleTb()</a>, <a class="el" href="../../d1/d5/ppc_2flushtb_8c-source.html#l00188">KeFlushSingleTb()</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l00127">MM_MAXIMUM_FLUSH_COUNT</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d2/d4/struct__MMPTE.html#o8">_MMPTE::u</a>, and <a class="el" href="../../d5/d1/datalpha_8c-source.html#l00030">ZeroPte</a>.
<p>
Referenced by <a class="el" href="../../d9/d4/physical_8c-source.html#l02110">MiRemoveUserPhysicalPagesVad()</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l00970">NtAllocateUserPhysicalPages()</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l01624">NtFreeUserPhysicalPages()</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l00085">NtMapUserPhysicalPages()</a>, and <a class="el" href="../../d9/d4/physical_8c-source.html#l00498">NtMapUserPhysicalPagesScatter()</a>.
<p>
<pre class="fragment"><div>02494                    :
02495 
02496     This routine flushes all <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> PTEs in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> PTE flush list.
02497     If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> list has overflowed, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> entire TB <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> flushed.
02498 
02499     N.B.  The intent was <span class="keywordflow">for</span> <span class="keyword">this</span> routine to NEVER write <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> PTEs and have
02500           <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> caller <span class="keywordflow">do</span> <span class="keyword">this</span> instead.  There <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> no such export from Ke, so
02501           <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> flush of a single TB just reuses <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> PTE.
02502 
02503 Arguments:
02504 
02505     PteFlushList - Supplies an optional pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> list to be flushed.
02506 
02507 Return Value:
02508 
02509     None.
02510 
02511 Environment:
02512 
02513     Kernel mode, PFN lock NOT held.
02514 
02515 --*/
02516 
02517 {
02518     ULONG count;
02519 
02520     count = PteFlushList-&gt;Count;
02521 
02522     <span class="keywordflow">if</span> (count == 0) {
02523         <span class="keywordflow">return</span>;
02524     }
02525 
02526     <span class="keywordflow">if</span> (count != 1) {
02527         <span class="keywordflow">if</span> (count &lt; <a class="code" href="../../d4/d8/mi_8h.html#a34">MM_MAXIMUM_FLUSH_COUNT</a>) {
02528             <a class="code" href="../../d0/d6/ppc_2flushtb_8c.html#a1">KeFlushMultipleTb</a> (count,
02529                                &amp;PteFlushList-&gt;FlushVa[0],
02530                                TRUE,
02531                                FALSE,
02532                                NULL,
02533                                <a class="code" href="../../d4/d2/datalpha_8c.html#a0">ZeroPte</a>.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Flush);
02534         }
02535         <span class="keywordflow">else</span> {
02536 
02537             <span class="comment">//</span>
02538             <span class="comment">// Array has overflowed, flush the entire TB.</span>
02539             <span class="comment">//</span>
02540 
02541             <a class="code" href="../../d0/d6/ppc_2flushtb_8c.html#a0">KeFlushEntireTb</a> (TRUE, FALSE);
02542         }
02543     }
02544     <span class="keywordflow">else</span> {
02545 
02546         <span class="comment">//</span>
02547         <span class="comment">// This always writes the (same) value into the PTE.</span>
02548         <span class="comment">//</span>
02549 
02550         <a class="code" href="../../d0/d6/ppc_2flushtb_8c.html#a2">KeFlushSingleTb</a> (PteFlushList-&gt;FlushVa[0],
02551                          TRUE,
02552                          FALSE,
02553                          (PHARDWARE_PTE)PteFlushList-&gt;FlushPte[0],
02554                          *(PHARDWARE_PTE)PteFlushList-&gt;FlushPte[0]);
02555     }
02556 
02557     PteFlushList-&gt;Count = 0;
02558     <span class="keywordflow">return</span>;
02559 }
}
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="physical.c::MiRemoveUserPhysicalPagesVad" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID MiRemoveUserPhysicalPagesVad           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d3/d7/struct__MMVAD__SHORT.html">PMMVAD_SHORT</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>Vad</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d4/physical_8c-source.html#l02110">2110</a> of file <a class="el" href="../../d9/d4/physical_8c-source.html">physical.c</a>.
<p>
References <a class="el" href="../../d7/d6/halmips_8h-source.html#l00086">APC_LEVEL</a>, <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l02655">_MMPTE_FLUSH_LIST::Count</a>, <a class="el" href="../../d7/d5/memprint_8h-source.html#l00079">DbgPrint</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l02656">_MMPTE_FLUSH_LIST::FlushPte</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l02657">_MMPTE_FLUSH_LIST::FlushVa</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l00922">LOCK_AWE</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l00901">LOCK_PFN2</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l00070">LOWEST_USABLE_PHYSICAL_PAGE</a>, <a class="el" href="../../d9/d7/alpha_2mialpha_8h-source.html#l02410">MI_GET_PAGE_FRAME_FROM_PTE</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l00769">MI_PFN_ELEMENT</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l01221">MI_PFN_IS_AWE</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l00763">MI_VPN_TO_VA</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l00765">MI_VPN_TO_VA_ENDING</a>, <a class="el" href="../../d9/d7/alpha_2mialpha_8h-source.html#l02486">MI_WRITE_INVALID_PTE</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l02488">MiFlushUserPhysicalPteList()</a>, <a class="el" href="../../d9/d7/alpha_2mialpha_8h-source.html#l01671">MiGetPteAddress</a>, <a class="el" href="../../d9/d7/alpha_2mialpha_8h-source.html#l01842">MiGetVirtualAddressMappedByPte</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l00127">MM_MAXIMUM_FLUSH_COUNT</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d2/d8/ps_8h-source.html#l00267">_EPROCESS::PhysicalVadList</a>, <a class="el" href="../../d2/d8/ps_8h-source.html#l00643">PsGetCurrentProcess</a>, <a class="el" href="../../d2/d4/struct__MMPTE.html#o8">_MMPTE::u</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l00925">UNLOCK_AWE</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l00905">UNLOCK_PFN2</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l02427">_MI_PHYSICAL_VIEW::Vad</a>, <a class="el" href="../../d2/d8/ps_8h-source.html#l00310">_EPROCESS::VadPhysicalPages</a>, <a class="el" href="../../d2/d8/ps_8h-source.html#l00309">_EPROCESS::VadPhysicalPagesBitMap</a>, and <a class="el" href="../../d5/d1/datalpha_8c-source.html#l00030">ZeroPte</a>.
<p>
Referenced by <a class="el" href="../../d5/d4/procsup_8c-source.html#l01695">MmCleanProcessAddressSpace()</a>, and <a class="el" href="../../d4/d6/freevm_8c-source.html#l00066">NtFreeVirtualMemory()</a>.
<p>
<pre class="fragment"><div>02116                    :
02117 
02118     This function removes <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> user-physical-pages mapped region from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
02119     current process's address space.  This mapped region <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <span class="keyword">private</span> memory.
02120 
02121     The physical pages of <span class="keyword">this</span> Vad are unmapped here, but not freed.
02122 
02123     Pagetable pages are freed and their use/commitment counts/quotas are
02124     managed by our caller.
02125 
02126 Arguments:
02127 
02128     Vad - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> VAD which manages <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address space.
02129 
02130 Return Value:
02131 
02132     None.
02133 
02134 Environment:
02135 
02136     APC level, working set mutex and address creation mutex held.
02137 
02138 --*/
02139 
02140 {
02141     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
02142     <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process;
02143     PFN_NUMBER PageFrameIndex;
02144     <a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html">MMPTE_FLUSH_LIST</a> PteFlushList;
02145     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
02146     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> PteContents;
02147     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> EndingPte;
02148 <span class="preprocessor">#if DBG</span>
02149 <span class="preprocessor"></span>    KIRQL OldIrql;
02150     KIRQL OldIrql2;
02151     ULONG_PTR ActualPages;
02152     ULONG_PTR ExpectedPages;
02153     PLIST_ENTRY NextEntry;
02154     <a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html">PMI_PHYSICAL_VIEW</a> PhysicalView;
02155 <span class="preprocessor">#endif</span>
02156 <span class="preprocessor"></span>
02157     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (KeGetCurrentIrql() == APC_LEVEL);
02158 
02159     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Vad-&gt;u.VadFlags.UserPhysicalPages == 1);
02160 
02161     Process = <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>();
02162 
02163     <span class="comment">//</span>
02164     <span class="comment">// If the physical pages count is zero, nothing needs to be done.</span>
02165     <span class="comment">// On checked systems, verify the list anyway.</span>
02166     <span class="comment">//</span>
02167 
02168 <span class="preprocessor">#if DBG</span>
02169 <span class="preprocessor"></span>    ActualPages = 0;
02170     ExpectedPages = Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o89">VadPhysicalPages</a>;
02171 <span class="preprocessor">#else</span>
02172 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o89">VadPhysicalPages</a> == 0) {
02173         <span class="keywordflow">return</span>;
02174     }
02175 <span class="preprocessor">#endif</span>
02176 <span class="preprocessor"></span>
02177     <span class="comment">//</span>
02178     <span class="comment">// The caller must have removed this Vad from the physical view list,</span>
02179     <span class="comment">// otherwise another thread could immediately remap pages back into the Vad.</span>
02180     <span class="comment">//</span>
02181     <span class="comment">// This allows us to proceed without acquiring the AWE or PFN locks -</span>
02182     <span class="comment">// everything can be done under the WS lock which is already held.</span>
02183     <span class="comment">//</span>
02184 
02185 <span class="preprocessor">#if DBG</span>
02186 <span class="preprocessor"></span>    <a class="code" href="../../d4/d8/mi_8h.html#a133">LOCK_AWE</a> (Process, OldIrql);
02187 
02188     <a class="code" href="../../d4/d8/mi_8h.html#a130">LOCK_PFN2</a> (OldIrql2);
02189 
02190     NextEntry = Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o61">PhysicalVadList</a>.Flink;
02191     <span class="keywordflow">while</span> (NextEntry != &amp;Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o61">PhysicalVadList</a>) {
02192 
02193         PhysicalView = CONTAINING_RECORD(NextEntry,
02194                                          <a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html">MI_PHYSICAL_VIEW</a>,
02195                                          ListEntry);
02196 
02197         <span class="keywordflow">if</span> (PhysicalView-&gt;<a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html#o1">Vad</a> == (<a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a>)Vad) {
02198             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a> (<span class="stringliteral">"MiRemoveUserPhysicalPagesVad : Vad %p still in list!\n"</span>,
02199                 Vad);
02200             DbgBreakPoint ();
02201         }
02202 
02203         NextEntry = NextEntry-&gt;Flink;
02204     }
02205 
02206     <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrql2);
02207     <a class="code" href="../../d4/d8/mi_8h.html#a134">UNLOCK_AWE</a> (Process, OldIrql);
02208 <span class="preprocessor">#endif</span>
02209 <span class="preprocessor"></span>
02210     <span class="comment">//</span>
02211     <span class="comment">// If the physical pages bitmap doesn't exist, nothing needs to be done.</span>
02212     <span class="comment">//</span>
02213 
02214     <span class="keywordflow">if</span> (Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o88">VadPhysicalPagesBitMap</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02215         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (ExpectedPages == 0);
02216         <span class="keywordflow">return</span>;
02217     }
02218 
02219     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (MI_VPN_TO_VA (Vad-&gt;StartingVpn));
02220     EndingPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (MI_VPN_TO_VA_ENDING (Vad-&gt;EndingVpn));
02221 
02222     PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a> = 0;
02223     
02224     <span class="keywordflow">while</span> (PointerPte &lt;= EndingPte) {
02225         PteContents = *PointerPte;
02226         <span class="keywordflow">if</span> (PteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 0) {
02227             PointerPte += 1;
02228             <span class="keywordflow">continue</span>;
02229         }
02230 
02231         PageFrameIndex = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a182">MI_GET_PAGE_FRAME_FROM_PTE</a> (PointerPte);
02232 
02233         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PageFrameIndex &gt;= LOWEST_USABLE_PHYSICAL_PAGE);
02234         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (ExpectedPages != 0);
02235 
02236         Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(PageFrameIndex);
02237 
02238         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (MI_PFN_IS_AWE (Pfn1));
02239         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount == 2);
02240         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> == PointerPte);
02241 
02242         <span class="comment">//</span>
02243         <span class="comment">// The frame is currently mapped in this Vad so the PTE must</span>
02244         <span class="comment">// be cleared and the TB entry flushed.</span>
02245         <span class="comment">//</span>
02246 
02247         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount -= 1;
02248         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> = (<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)0;
02249 
02250         <span class="keywordflow">if</span> (PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a> != <a class="code" href="../../d4/d8/mi_8h.html#a34">MM_MAXIMUM_FLUSH_COUNT</a>) {
02251             PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o2">FlushVa</a>[PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a>] =
02252                 <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPte);
02253             PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o1">FlushPte</a>[PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a>] = PointerPte;
02254             PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a> += 1;
02255         }
02256 
02257         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a187">MI_WRITE_INVALID_PTE</a> (PointerPte, ZeroPte);
02258 
02259         PointerPte += 1;
02260 <span class="preprocessor">#if DBG</span>
02261 <span class="preprocessor"></span>        ActualPages += 1;
02262 <span class="preprocessor">#endif</span>
02263 <span class="preprocessor"></span>        <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (ActualPages &lt;= ExpectedPages);
02264     }
02265 
02266     <span class="comment">//</span>
02267     <span class="comment">// Flush the TB entries for these pages.  Note ZeroPte is only used</span>
02268     <span class="comment">// when the FlushPte[0] field is nonzero or if only a single PTE is</span>
02269     <span class="comment">// being flushed.</span>
02270     <span class="comment">//</span>
02271 
02272     <a class="code" href="../../d8/d5/physical_8c.html#a8">MiFlushUserPhysicalPteList</a> (&amp;PteFlushList);
02273 
02274     <span class="keywordflow">return</span>;
02275 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="physical.c::MiUpdateVadPhysicalPages" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID MiUpdateVadPhysicalPages           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN ULONG_PTR&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>TotalFreedPages</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d4/physical_8c-source.html#l02278">2278</a> of file <a class="el" href="../../d9/d4/physical_8c-source.html">physical.c</a>.
<p>
References <a class="el" href="../../d5/d7/mi_8h-source.html#l00886">LOCK_PFN</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l00076">MmVadPhysicalPages</a>, and <a class="el" href="../../d5/d7/mi_8h-source.html#l00896">UNLOCK_PFN</a>.
<p>
Referenced by <a class="el" href="../../d9/d4/physical_8c-source.html#l02313">MiCleanPhysicalProcessPages()</a>.
<p>
<pre class="fragment"><div>02284                    :
02285 
02286     Nonpaged helper routine to update <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> VadPhysicalPages count.
02287 
02288 Arguments:
02289 
02290     TotalFreedPages - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> number of pages just freed.
02291 
02292 Return Value:
02293 
02294     None.
02295 
02296 Environment:
02297 
02298     Kernel mode, APC level or below.
02299 
02300 --*/
02301 
02302 {
02303     KIRQL OldIrql;
02304 
02305     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
02306     <a class="code" href="../../d8/d5/physical_8c.html#a7">MmVadPhysicalPages</a> -= TotalFreedPages;
02307     <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
02308 
02309     <span class="keywordflow">return</span>;
02310 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="physical.c::NtAllocateUserPhysicalPages" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS NtAllocateUserPhysicalPages           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN HANDLE&nbsp;</td>
          <td class="mdname" nowrap> <em>ProcessHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT PULONG_PTR&nbsp;</td>
          <td class="mdname" nowrap> <em>NumberOfPages</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PULONG_PTR&nbsp;</td>
          <td class="mdname" nowrap> <em>UserPfnArray</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d4/physical_8c-source.html#l00970">970</a> of file <a class="el" href="../../d9/d4/physical_8c-source.html">physical.c</a>.
<p>
References <a class="el" href="../../d2/d8/ps_8h-source.html#l00216">_EPROCESS::AddressSpaceDeleted</a>, <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d9/d8/tbitmap_8c-source.html#l00028">BitMap</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00420">_MDL::ByteCount</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l02655">_MMPTE_FLUSH_LIST::Count</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l00253">ExAllocatePoolWithTag</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00055">EXCEPTION_EXECUTE_HANDLER</a>, <a class="el" href="../../d7/d2/cmwraper_8c-source.html#l00304">ExFreePool()</a>, <a class="el" href="../../d5/d8/ex_8h.html#a307">ExSystemExceptionFilter()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l02656">_MMPTE_FLUSH_LIST::FlushPte</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l02657">_MMPTE_FLUSH_LIST::FlushVa</a>, <a class="el" href="../../d4/d4/procobj_8c-source.html#l00166">KeAttachProcess()</a>, <a class="el" href="../../d4/d4/procobj_8c-source.html#l00405">KeDetachProcess()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00624">KernelMode</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00174">KPROCESSOR_MODE</a>, <a class="el" href="../../d3/d9/aw_8h-source.html#l00031">L</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l00922">LOCK_AWE</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l00886">LOCK_PFN</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l01039">LOCK_WS</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l00069">LOWEST_USABLE_PHYSICAL_ADDRESS</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l00070">LOWEST_USABLE_PHYSICAL_PAGE</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l00073">MI_FRAME_TO_BITMAP_INDEX</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l00769">MI_PFN_ELEMENT</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l01221">MI_PFN_IS_AWE</a>, <a class="el" href="../../d9/d7/alpha_2mialpha_8h-source.html#l00909">MI_SET_PFN_DELETED</a>, <a class="el" href="../../d9/d7/alpha_2mialpha_8h-source.html#l02486">MI_WRITE_INVALID_PTE</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l02488">MiFlushUserPhysicalPteList()</a>, <a class="el" href="../../d9/d7/alpha_2mialpha_8h-source.html#l01842">MiGetVirtualAddressMappedByPte</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l00127">MM_MAXIMUM_FLUSH_COUNT</a>, <a class="el" href="../../d6/d5/iosup_8c-source.html#l04270">MmAllocatePagesForMdl()</a>, <a class="el" href="../../d6/d5/iosup_8c-source.html#l05051">MmFreePagesFromMdl()</a>, <a class="el" href="../../d3/d2/dumpctl_8c-source.html#l00076">MmHighestPossiblePhysicalPage</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l00076">MmVadPhysicalPages</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00414">_MDL::Next</a>, <a class="el" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00494">ObDereferenceObject</a>, <a class="el" href="../../d8/d0/obref_8c-source.html#l00542">ObReferenceObjectByHandle()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00600">PAGE_SHIFT</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00599">PAGE_SIZE</a>, <a class="el" href="../../d2/d2/ppcdef_8h-source.html#l00079">PASSIVE_LEVEL</a>, <a class="el" href="../../d2/d8/ps_8h-source.html#l00166">_EPROCESS::Pcb</a>, <a class="el" href="../../d0/d4/probe_8c-source.html#l00034">ProbeForWrite()</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l01598">ProbeForWritePointer</a>, <a class="el" href="../../d1/d1/psquota_8c-source.html#l00246">PsChargePoolQuota()</a>, <a class="el" href="../../d2/d8/ps_8h-source.html#l00643">PsGetCurrentProcess</a>, <a class="el" href="../../d0/d8/ntos_8h-source.html#l00088">PsProcessType</a>, <a class="el" href="../../d1/d1/psquota_8c-source.html#l00356">PsReturnPoolQuota()</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00266">RtlClearAllBits()</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l01508">RtlClearBits()</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00866">RtlFindSetBits()</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l00219">RtlInitializeBitMap()</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l01634">RtlSetBits()</a>, <a class="el" href="../../d1/d4/se_8h-source.html#l01672">SeLockMemoryPrivilege</a>, <a class="el" href="../../d9/d3/privileg_8c-source.html#l00436">SeSinglePrivilegeCheck()</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d2/d4/struct__MMPTE.html#o8">_MMPTE::u</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l00925">UNLOCK_AWE</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l00896">UNLOCK_PFN</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l01081">UNLOCK_WS</a>, <a class="el" href="../../d2/d8/ps_8h-source.html#l00310">_EPROCESS::VadPhysicalPages</a>, <a class="el" href="../../d2/d8/ps_8h-source.html#l00309">_EPROCESS::VadPhysicalPagesBitMap</a>, and <a class="el" href="../../d5/d1/datalpha_8c-source.html#l00030">ZeroPte</a>.
<p>
<pre class="fragment"><div>00978                    :
00979 
00980     This function allocates nonpaged physical pages <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified
00981     subject process.
00982 
00983     No WSLEs are maintained <span class="keywordflow">for</span> <span class="keyword">this</span> range.
00984 
00985     The caller must check <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> NumberOfPages returned to determine how many
00986     pages were actually allocated (<span class="keyword">this</span> number may be less than the requested
00987     amount).
00988 
00989     On success, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> user array <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> filled with <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> allocated physical page
00990     frame numbers (only up to the returned NumberOfPages is filled in).
00991 
00992     No PTEs are filled here - <span class="keyword">this</span> gives <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> application <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> flexibility
00993     to order <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address space with no metadata structure imposed by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Mm.
00994     Applications <span class="keywordflow">do</span> <span class="keyword">this</span> via <a class="code" href="../../d8/d5/physical_8c.html#a9">NtMapUserPhysicalPages</a> - ie:
00995 
00996         - Each physical page allocated <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> set in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> process's bitmap.
00997           This provides remap, free and unmap a way to validate and rundown
00998           these frames.
00999 
01000           Unmaps may result in a walk of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> entire bitmap, but that's ok as
01001           unmaps should be less frequent.  The win <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> saves us from
01002           <span class="keyword">using</span> up system <span class="keyword">virtual</span> address space to manage these frames.
01003 
01004         - Note that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> same physical frame may NOT be mapped at two different
01005           <span class="keyword">virtual</span> addresses in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> process.  This makes frees and unmaps
01006           substantially faster as no checks <span class="keywordflow">for</span> aliasing need be performed.
01007 
01008 Arguments:
01009 
01010     ProcessHandle - Supplies an open handle to a process object.
01011 
01012     NumberOfPages - Supplies a pointer to a variable that supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01013                     desired size in pages of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> allocation.  This <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> filled
01014                     with <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> actual number of pages allocated.
01015         
01016     UserPfnArray - Supplies a pointer to user memory to store <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> allocated
01017                    frame numbers into.
01018 
01019 Return Value:
01020 
01021     Various <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> codes.
01022 
01023 --*/
01024 
01025 {
01026     ULONG i;
01027     KIRQL OldIrql;
01028     KIRQL OldIrqlPfn;
01029     <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process;
01030     <a class="code" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> PreviousMode;
01031     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01032     LOGICAL Attached;
01033     LOGICAL WsHeld;
01034     ULONG_PTR CapturedNumberOfPages;
01035     ULONG_PTR AllocatedPages;
01036     ULONG_PTR MdlRequestInPages;
01037     ULONG_PTR TotalAllocatedPages;
01038     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MemoryDescriptorList;
01039     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MemoryDescriptorList2;
01040     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MemoryDescriptorHead;
01041     PPFN_NUMBER MdlPage;
01042     PRTL_BITMAP <a class="code" href="../../d2/d1/structBitMap.html">BitMap</a>;
01043     ULONG BitMapSize;
01044     ULONG BitMapIndex;
01045     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
01046     PHYSICAL_ADDRESS LowAddress;
01047     PHYSICAL_ADDRESS MdlLowAddress;
01048     PHYSICAL_ADDRESS HighAddress;
01049     PHYSICAL_ADDRESS SkipBytes;
01050     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
01051     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> OldPteContents;
01052     <a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html">MMPTE_FLUSH_LIST</a> PteFlushList;
01053     ULONG SizeOfBitMap;
01054 
01055     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (KeGetCurrentIrql() == PASSIVE_LEVEL);
01056 
01057     Attached = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01058     WsHeld = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01059 
01060     <span class="comment">//</span>
01061     <span class="comment">// Check the allocation type field.</span>
01062     <span class="comment">//</span>
01063 
01064     PreviousMode = KeGetPreviousMode();
01065 
01066     <span class="comment">//</span>
01067     <span class="comment">// Establish an exception handler, probe the specified addresses</span>
01068     <span class="comment">// for write access and capture the initial values.</span>
01069     <span class="comment">//</span>
01070 
01071     <span class="keywordflow">try</span> {
01072 
01073         <span class="comment">//</span>
01074         <span class="comment">// Capture the number of pages.</span>
01075         <span class="comment">//</span>
01076 
01077         <span class="keywordflow">if</span> (PreviousMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
01078 
01079             <a class="code" href="../../d5/d8/ex_8h.html#a37">ProbeForWritePointer</a> (NumberOfPages);
01080 
01081             CapturedNumberOfPages = *NumberOfPages;
01082 
01083             <span class="keywordflow">if</span> (CapturedNumberOfPages == 0) {
01084                 <span class="keywordflow">return</span> STATUS_SUCCESS;
01085             }
01086 
01087             <span class="keywordflow">if</span> (CapturedNumberOfPages &gt; (MAXULONG_PTR / <span class="keyword">sizeof</span>(ULONG_PTR))) {
01088                 <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER_2;
01089             }
01090 
01091             <a class="code" href="../../d5/d8/ex_8h.html#a259">ProbeForWrite</a> (UserPfnArray,
01092                            (ULONG)(CapturedNumberOfPages * <span class="keyword">sizeof</span> (ULONG_PTR)),
01093                            <span class="keyword">sizeof</span>(PULONG_PTR));
01094 
01095         }
01096         <span class="keywordflow">else</span> {
01097             CapturedNumberOfPages = *NumberOfPages;
01098         }
01099 
01100     } except (<a class="code" href="../../d5/d8/ex_8h.html#a307">ExSystemExceptionFilter</a>()) {
01101 
01102         <span class="comment">//</span>
01103         <span class="comment">// If an exception occurs during the probe or capture</span>
01104         <span class="comment">// of the initial values, then handle the exception and</span>
01105         <span class="comment">// return the exception code as the status value.</span>
01106         <span class="comment">//</span>
01107 
01108         <span class="keywordflow">return</span> GetExceptionCode();
01109     }
01110 
01111     <span class="comment">//</span>
01112     <span class="comment">// Reference the specified process handle for VM_OPERATION access.</span>
01113     <span class="comment">//</span>
01114 
01115     <span class="keywordflow">if</span> (ProcessHandle == NtCurrentProcess()) {
01116         Process = <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>();
01117     }
01118     <span class="keywordflow">else</span> {
01119         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a> ( ProcessHandle,
01120                                              PROCESS_VM_OPERATION,
01121                                              PsProcessType,
01122                                              PreviousMode,
01123                                              (PVOID *)&amp;Process,
01124                                              NULL );
01125 
01126         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status)) {
01127             <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01128         }
01129     }
01130 
01131     <span class="keywordflow">if</span> (!<a class="code" href="../../d8/d4/privileg_8c.html#a3">SeSinglePrivilegeCheck</a> (SeLockMemoryPrivilege, PreviousMode)) {
01132         <span class="keywordflow">if</span> (ProcessHandle != NtCurrentProcess()) {
01133             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a> (Process);
01134         }
01135         <span class="keywordflow">return</span> STATUS_PRIVILEGE_NOT_HELD;
01136     }
01137 
01138     <span class="comment">//</span>
01139     <span class="comment">// If the specified process is not the current process, attach</span>
01140     <span class="comment">// to the specified process.</span>
01141     <span class="comment">//</span>
01142 
01143     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>() != Process) {
01144         <a class="code" href="../../d3/d5/procobj_8c.html#a4">KeAttachProcess</a> (&amp;Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o0">Pcb</a>);
01145         Attached = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01146     }
01147 
01148     BitMapSize = 0;
01149 
01150     <span class="comment">//</span>
01151     <span class="comment">// Get the working set mutex to synchronize.  This also blocks APCs so</span>
01152     <span class="comment">// an APC which takes a page fault does not corrupt various structures.</span>
01153     <span class="comment">//</span>
01154 
01155     <a class="code" href="../../d4/d8/mi_8h.html#a154">LOCK_WS</a> (Process);
01156 
01157     WsHeld = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01158 
01159     <span class="comment">//</span>
01160     <span class="comment">// Make sure the address space was not deleted, If so, return an error.</span>
01161     <span class="comment">//</span>
01162 
01163     <span class="keywordflow">if</span> (Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o27">AddressSpaceDeleted</a> != 0) {
01164         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_PROCESS_IS_TERMINATING;
01165         <span class="keywordflow">goto</span> ErrorReturn;
01166     }
01167 
01168     <span class="comment">//</span>
01169     <span class="comment">// Create the physical pages bitmap if it does not already exist.</span>
01170     <span class="comment">// LockMemory privilege is required.</span>
01171     <span class="comment">//</span>
01172 
01173     <a class="code" href="../../d8/d9/tbitmap_8c.html#a2">BitMap</a> = Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o88">VadPhysicalPagesBitMap</a>;
01174 
01175     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d9/tbitmap_8c.html#a2">BitMap</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01176 
01177         BitMapSize = <span class="keyword">sizeof</span>(RTL_BITMAP) + (ULONG)((((<a class="code" href="../../d2/d3/dumpctl_8c.html#a16">MmHighestPossiblePhysicalPage</a> + 1) + 31) / 32) * 4);
01178 
01179         <a class="code" href="../../d8/d9/tbitmap_8c.html#a2">BitMap</a> = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a> (NonPagedPool, BitMapSize, 'LdaV');
01180 
01181         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d9/tbitmap_8c.html#a2">BitMap</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01182             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INSUFFICIENT_RESOURCES;
01183             <span class="keywordflow">goto</span> ErrorReturn;
01184         }
01185 
01186         <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a26">RtlInitializeBitMap</a> (BitMap,
01187                              (PULONG)(BitMap + 1),
01188                              (ULONG)(MmHighestPossiblePhysicalPage + 1));
01189 
01190         <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a27">RtlClearAllBits</a> (BitMap);
01191 
01192         <span class="keywordflow">try</span> {
01193 
01194             <span class="comment">//</span>
01195             <span class="comment">// Charge quota for the nonpaged pool for the bitmap.  This is</span>
01196             <span class="comment">// done here rather than by using ExAllocatePoolWithQuota</span>
01197             <span class="comment">// so the process object is not referenced by the quota charge.</span>
01198             <span class="comment">//</span>
01199 
01200             <a class="code" href="../../d0/d2/psquota_8c.html#a2">PsChargePoolQuota</a> (Process, NonPagedPool, BitMapSize);
01201 
01202         } except (EXCEPTION_EXECUTE_HANDLER) {
01203             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = GetExceptionCode();
01204             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (BitMap);
01205             <span class="keywordflow">goto</span> ErrorReturn;
01206         }
01207 
01208         SizeOfBitMap = <a class="code" href="../../d8/d9/tbitmap_8c.html#a2">BitMap</a>-&gt;SizeOfBitMap;
01209     }
01210     <span class="keywordflow">else</span> {
01211 
01212         <span class="comment">//</span>
01213         <span class="comment">// It's ok to snap this without a lock.</span>
01214         <span class="comment">//</span>
01215 
01216         SizeOfBitMap = Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o88">VadPhysicalPagesBitMap</a>-&gt;SizeOfBitMap;
01217     }
01218 
01219     AllocatedPages = 0;
01220     TotalAllocatedPages = 0;
01221     MemoryDescriptorHead = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01222 
01223     SkipBytes.QuadPart = 0;
01224 
01225     <span class="comment">//</span>
01226     <span class="comment">// Allocate from the top of memory going down to preserve low pages</span>
01227     <span class="comment">// for 32/24-bit device drivers.  Just under 4gb is the maximum allocation</span>
01228     <span class="comment">// per MDL so the ByteCount field does not overflow.</span>
01229     <span class="comment">//</span>
01230 
01231     HighAddress.QuadPart = ((ULONGLONG)(SizeOfBitMap - 1)) &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
01232 
01233     <span class="keywordflow">if</span> (HighAddress.QuadPart &gt; (ULONGLONG)0x100000000) {
01234         LowAddress.QuadPart = (ULONGLONG)0x100000000;
01235     }
01236     <span class="keywordflow">else</span> {
01237         LowAddress.QuadPart = <a class="code" href="../../d8/d5/physical_8c.html#a2">LOWEST_USABLE_PHYSICAL_ADDRESS</a>;
01238         <span class="keywordflow">if</span> (LowAddress.QuadPart &gt;= HighAddress.QuadPart) {
01239             <span class="keywordflow">if</span> (BitMapSize) {
01240                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (BitMap);
01241                 <a class="code" href="../../d0/d2/psquota_8c.html#a3">PsReturnPoolQuota</a> (Process, NonPagedPool, BitMapSize);
01242             }
01243             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INSUFFICIENT_RESOURCES;
01244             <span class="keywordflow">goto</span> ErrorReturn;
01245         }
01246     }
01247 
01248     MdlLowAddress = LowAddress;
01249 
01250     <span class="keywordflow">do</span> {
01251 
01252         MdlRequestInPages = CapturedNumberOfPages - TotalAllocatedPages;
01253 
01254         <span class="keywordflow">if</span> (MdlRequestInPages &gt; (ULONG_PTR)((MAXULONG - <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>) &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>)) {
01255             MdlRequestInPages = (ULONG_PTR)((MAXULONG - <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>) &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
01256         }
01257 
01258         <span class="comment">//</span>
01259         <span class="comment">// Note this allocation returns zeroed pages.</span>
01260         <span class="comment">//</span>
01261 
01262         MemoryDescriptorList = <a class="code" href="../../d5/d6/iosup_8c.html#a63">MmAllocatePagesForMdl</a> (MdlLowAddress,
01263                                                       HighAddress,
01264                                                       SkipBytes,
01265                                                       MdlRequestInPages &lt;&lt; PAGE_SHIFT);
01266 
01267         <span class="keywordflow">if</span> (MemoryDescriptorList != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01268             MemoryDescriptorList-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o0">Next</a> = MemoryDescriptorHead;
01269             MemoryDescriptorHead = MemoryDescriptorList;
01270 
01271             MdlPage = (PPFN_NUMBER)(MemoryDescriptorList + 1);
01272 
01273             AllocatedPages = MemoryDescriptorList-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o6">ByteCount</a> &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
01274             TotalAllocatedPages += AllocatedPages;
01275 
01276             <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrqlPfn);
01277             <a class="code" href="../../d8/d5/physical_8c.html#a7">MmVadPhysicalPages</a> += AllocatedPages;
01278             <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrqlPfn);
01279 
01280             <span class="comment">//</span>
01281             <span class="comment">// The per-process WS lock guards updates to</span>
01282             <span class="comment">// Process-&gt;VadPhysicalPages.</span>
01283             <span class="comment">//</span>
01284 
01285             Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o89">VadPhysicalPages</a> += AllocatedPages;
01286 
01287 <span class="preprocessor">#if defined(_ALPHA_) &amp;&amp; !defined(_AXP64_)</span>
01288 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (BitMapSize == 0) {
01289                 <a class="code" href="../../d4/d8/mi_8h.html#a133">LOCK_AWE</a> (Process, OldIrql);
01290             }
01291 <span class="preprocessor">#endif</span>
01292 <span class="preprocessor"></span>
01293             <span class="comment">//</span>
01294             <span class="comment">// Update the allocation bitmap for each allocated frame.</span>
01295             <span class="comment">// Note the PFN lock is not needed to modify the PteAddress below.</span>
01296             <span class="comment">// In fact, even the AWE lock is not needed (except on Alpha32 due</span>
01297             <span class="comment">// to word tearing in an already existing bitmap) as these pages</span>
01298             <span class="comment">// are brand new.</span>
01299             <span class="comment">//</span>
01300 
01301             <span class="keywordflow">for</span> (i = 0; i &lt; AllocatedPages; i += 1) {
01302 
01303                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (*MdlPage &gt;= LOWEST_USABLE_PHYSICAL_PAGE);
01304 
01305                 BitMapIndex = <a class="code" href="../../d8/d5/physical_8c.html#a5">MI_FRAME_TO_BITMAP_INDEX</a>(*MdlPage);
01306 
01307                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (BitMapIndex &lt; BitMap-&gt;SizeOfBitMap);
01308                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (RtlCheckBit (BitMap, BitMapIndex) == 0);
01309 
01310 <span class="preprocessor">#if defined (_WIN64)</span>
01311 <span class="preprocessor"></span>                <span class="comment">//</span>
01312                 <span class="comment">// This may become a problem for 64-bit systems with &gt; 32tb</span>
01313                 <span class="comment">// of physical memory as the 2nd parameter to RtlSetBits is</span>
01314                 <span class="comment">// a ULONG.</span>
01315                 <span class="comment">//</span>
01316 
01317                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (*MdlPage &lt; 0x100000000);
01318 <span class="preprocessor">#endif</span>
01319 <span class="preprocessor"></span>
01320                 Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (*MdlPage);
01321                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (MI_PFN_IS_AWE (Pfn1));
01322                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> = (<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)0;
01323                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount == 1);
01324 
01325                 <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a34">RtlSetBits</a> (BitMap, BitMapIndex, 1L);
01326 
01327                 MdlPage += 1;
01328             }
01329 
01330 <span class="preprocessor">#if defined(_ALPHA_) &amp;&amp; !defined(_AXP64_)</span>
01331 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (BitMapSize == 0) {
01332                 <a class="code" href="../../d4/d8/mi_8h.html#a134">UNLOCK_AWE</a> (Process, OldIrql);
01333             }
01334 <span class="preprocessor">#endif</span>
01335 <span class="preprocessor"></span>
01336             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (TotalAllocatedPages &lt;= CapturedNumberOfPages);
01337 
01338             <span class="keywordflow">if</span> (TotalAllocatedPages == CapturedNumberOfPages) {
01339                 <span class="keywordflow">break</span>;
01340             }
01341 
01342             <span class="comment">//</span>
01343             <span class="comment">// Try the same memory range again - there might be more pages</span>
01344             <span class="comment">// left in it that can be claimed as a truncated MDL had to be</span>
01345             <span class="comment">// used for the last request.</span>
01346             <span class="comment">//</span>
01347 
01348             <span class="keywordflow">continue</span>;
01349         }
01350 
01351         <span class="keywordflow">if</span> (LowAddress.QuadPart == <a class="code" href="../../d8/d5/physical_8c.html#a2">LOWEST_USABLE_PHYSICAL_ADDRESS</a>) {
01352 
01353             <span class="comment">//</span>
01354             <span class="comment">// No (more) pages available.  If this becomes a common situation,</span>
01355             <span class="comment">// all the working sets could be flushed here.</span>
01356             <span class="comment">//</span>
01357 
01358             <span class="keywordflow">if</span> (TotalAllocatedPages == 0) {
01359                 <span class="keywordflow">if</span> (BitMapSize) {
01360                     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (BitMap);
01361                     <a class="code" href="../../d0/d2/psquota_8c.html#a3">PsReturnPoolQuota</a> (Process, NonPagedPool, BitMapSize);
01362                 }
01363                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INSUFFICIENT_RESOURCES;
01364                 <span class="keywordflow">goto</span> ErrorReturn;
01365             }
01366 
01367             <span class="comment">//</span>
01368             <span class="comment">// Make do with what we've gotten so far.</span>
01369             <span class="comment">//</span>
01370 
01371             <span class="keywordflow">break</span>;
01372         }
01373 
01374         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (HighAddress.QuadPart &gt; (ULONGLONG)0x100000000);
01375 
01376         HighAddress.QuadPart = (ULONGLONG)0x100000000 - 1;
01377         LowAddress.QuadPart = <a class="code" href="../../d8/d5/physical_8c.html#a2">LOWEST_USABLE_PHYSICAL_ADDRESS</a>;
01378 
01379         MdlLowAddress = LowAddress;
01380 
01381     } <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
01382 
01383     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (TotalAllocatedPages != 0);
01384 
01385     <span class="keywordflow">if</span> (BitMapSize != 0) {
01386 
01387         <span class="comment">//</span>
01388         <span class="comment">// If this API resulted in the creation of the bitmap, then set it</span>
01389         <span class="comment">// in the process structure now.  No need for locking around this.</span>
01390         <span class="comment">//</span>
01391 
01392         Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o88">VadPhysicalPagesBitMap</a> = <a class="code" href="../../d8/d9/tbitmap_8c.html#a2">BitMap</a>;
01393     }
01394 
01395     <a class="code" href="../../d4/d8/mi_8h.html#a158">UNLOCK_WS</a> (Process);
01396     WsHeld = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01397 
01398     <span class="keywordflow">if</span> (Attached == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01399         <a class="code" href="../../d3/d5/procobj_8c.html#a7">KeDetachProcess</a>();
01400         Attached = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01401     }
01402 
01403     <span class="comment">//</span>
01404     <span class="comment">// Establish an exception handler and carefully write out the</span>
01405     <span class="comment">// number of pages and the frame numbers.</span>
01406     <span class="comment">//</span>
01407 
01408     <span class="keywordflow">try</span> {
01409 
01410         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (TotalAllocatedPages &lt;= CapturedNumberOfPages);
01411 
01412         *NumberOfPages = TotalAllocatedPages;
01413 
01414         MemoryDescriptorList = MemoryDescriptorHead;
01415 
01416         <span class="keywordflow">while</span> (MemoryDescriptorList != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01417 
01418             MdlPage = (PPFN_NUMBER)(MemoryDescriptorList + 1);
01419             AllocatedPages = MemoryDescriptorList-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o6">ByteCount</a> &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
01420 
01421             <span class="keywordflow">for</span> (i = 0; i &lt; AllocatedPages; i += 1) {
01422                 *UserPfnArray = *(PULONG_PTR)MdlPage;
01423                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(*MdlPage)-&gt;u2.ShareCount == 1);
01424                 UserPfnArray += 1;
01425                 MdlPage += 1;
01426             }
01427             MemoryDescriptorList = MemoryDescriptorList-&gt;Next;
01428         }
01429 
01430         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
01431 
01432     } except (<a class="code" href="../../d5/d8/ex_8h.html#a307">ExSystemExceptionFilter</a>()) {
01433 
01434         <span class="comment">//</span>
01435         <span class="comment">// If anything went wrong communicating the pages back to the user</span>
01436         <span class="comment">// then the entire system service is rolled back.</span>
01437         <span class="comment">//</span>
01438 
01439         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = GetExceptionCode();
01440 
01441         MemoryDescriptorList = MemoryDescriptorHead;
01442 
01443         PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a> = 0;
01444 
01445         <span class="keywordflow">if</span> (<a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>() != Process) {
01446             <a class="code" href="../../d3/d5/procobj_8c.html#a4">KeAttachProcess</a> (&amp;Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o0">Pcb</a>);
01447             Attached = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01448         }
01449 
01450         <a class="code" href="../../d4/d8/mi_8h.html#a154">LOCK_WS</a> (Process);
01451         WsHeld = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01452 
01453         <span class="keywordflow">if</span> (Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o27">AddressSpaceDeleted</a> != 0) {
01454             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_PROCESS_IS_TERMINATING;
01455             <span class="keywordflow">goto</span> ErrorReturn;
01456         }
01457 
01458         <span class="comment">//</span>
01459         <span class="comment">// AWE lock protection is needed here to prevent the malicious app</span>
01460         <span class="comment">// that is mapping these pages between our allocation and our free</span>
01461         <span class="comment">// below.</span>
01462         <span class="comment">//</span>
01463 
01464         <a class="code" href="../../d4/d8/mi_8h.html#a133">LOCK_AWE</a> (Process, OldIrql);
01465 
01466         <span class="keywordflow">while</span> (MemoryDescriptorList != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01467 
01468             AllocatedPages = MemoryDescriptorList-&gt;ByteCount &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
01469             MdlPage = (PPFN_NUMBER)(MemoryDescriptorList + 1);
01470 
01471             <span class="keywordflow">for</span> (i = 0; i &lt; AllocatedPages; i += 1) {
01472 
01473                 BitMapIndex = <a class="code" href="../../d8/d5/physical_8c.html#a5">MI_FRAME_TO_BITMAP_INDEX</a>(*MdlPage);
01474 
01475                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (BitMapIndex &lt; BitMap-&gt;SizeOfBitMap);
01476                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (RtlCheckBit (BitMap, BitMapIndex) == 1);
01477 
01478 <span class="preprocessor">#if defined (_WIN64)</span>
01479 <span class="preprocessor"></span>                <span class="comment">//</span>
01480                 <span class="comment">// This may become a problem for 64-bit systems with &gt; 32tb</span>
01481                 <span class="comment">// of physical memory as the 2nd parameter to RtlSetBits is</span>
01482                 <span class="comment">// a ULONG.</span>
01483                 <span class="comment">//</span>
01484 
01485                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (*MdlPage &lt; 0x100000000);
01486 <span class="preprocessor">#endif</span>
01487 <span class="preprocessor"></span>                <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a33">RtlClearBits</a> (BitMap, BitMapIndex, 1L);
01488 
01489                 <span class="comment">//</span>
01490                 <span class="comment">// Note the PFN lock is not needed for the operations below.</span>
01491                 <span class="comment">//</span>
01492 
01493                 Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (*MdlPage);
01494                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (MI_PFN_IS_AWE (Pfn1));
01495 
01496                 <span class="comment">//</span>
01497                 <span class="comment">// The frame cannot be currently mapped in any Vad unless a</span>
01498                 <span class="comment">// malicious app is trying random pages in an attempt to</span>
01499                 <span class="comment">// corrupt the system.  Prevent this behavior by checking</span>
01500                 <span class="comment">// the sharecount and handling it properly here.</span>
01501                 <span class="comment">//</span>
01502 
01503                 <span class="keywordflow">if</span> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount != 1) {
01504         
01505                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount == 2);
01506     
01507                     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount -= 1;
01508         
01509                     PointerPte = Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a>;
01510                     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> = (<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)0;
01511 
01512                     OldPteContents = *PointerPte;
01513             
01514                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (OldPteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1);
01515         
01516                     <span class="keywordflow">if</span> (PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a> != <a class="code" href="../../d4/d8/mi_8h.html#a34">MM_MAXIMUM_FLUSH_COUNT</a>) {
01517                         PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o2">FlushVa</a>[PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a>] =
01518                             <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPte);
01519                         PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o1">FlushPte</a>[PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a>] = PointerPte;
01520                         PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a> += 1;
01521                     }
01522     
01523                     <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a187">MI_WRITE_INVALID_PTE</a> (PointerPte, ZeroPte);
01524                 }
01525 
01526                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount == 1);
01527 
01528                 <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a120">MI_SET_PFN_DELETED</a>(Pfn1);
01529 
01530                 MdlPage += 1;
01531             }
01532 
01533             Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o89">VadPhysicalPages</a> -= AllocatedPages;
01534             <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrqlPfn);
01535             <a class="code" href="../../d8/d5/physical_8c.html#a7">MmVadPhysicalPages</a> -= AllocatedPages;
01536             <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrqlPfn);
01537             MemoryDescriptorList = MemoryDescriptorList-&gt;Next;
01538         }
01539 
01540         <span class="comment">//</span>
01541         <span class="comment">// Flush the TB entries for any pages which a malicious user may</span>
01542         <span class="comment">// have mapped.  Note ZeroPte is only used when the FlushPte[0]</span>
01543         <span class="comment">// field is nonzero or if only a single PTE is being flushed.</span>
01544         <span class="comment">//</span>
01545     
01546         <a class="code" href="../../d8/d5/physical_8c.html#a8">MiFlushUserPhysicalPteList</a> (&amp;PteFlushList);
01547     
01548         <span class="comment">//</span>
01549         <span class="comment">// Carefully check to see if the bitmap can be freed.</span>
01550         <span class="comment">// Remember the working set mutex was dropped, so other threads may</span>
01551         <span class="comment">// have created or added to the bitmap.  If there is no one else using</span>
01552         <span class="comment">// the bitmap and it's empty, free the bitmap and return its quota.</span>
01553         <span class="comment">// Keep in mind that this thread may not have even been the creator.</span>
01554         <span class="comment">//</span>
01555 
01556         <span class="keywordflow">if</span> (Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o89">VadPhysicalPages</a> == 0) {
01557 
01558             <a class="code" href="../../d8/d9/tbitmap_8c.html#a2">BitMap</a> = Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o88">VadPhysicalPagesBitMap</a>;
01559     
01560             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (BitMap != NULL);
01561             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (RtlFindSetBits (BitMap, 1, 0) == 0xFFFFFFFF);
01562 
01563             BitMapSize = <span class="keyword">sizeof</span>(RTL_BITMAP) + (ULONG)((((<a class="code" href="../../d2/d3/dumpctl_8c.html#a16">MmHighestPossiblePhysicalPage</a> + 1) + 31) / 32) * 4);
01564             Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o88">VadPhysicalPagesBitMap</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01565             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (BitMap);
01566             <a class="code" href="../../d0/d2/psquota_8c.html#a3">PsReturnPoolQuota</a> (Process, NonPagedPool, BitMapSize);
01567         }
01568         <span class="keywordflow">else</span> {
01569             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o88">VadPhysicalPagesBitMap</a> != NULL);
01570         }
01571 
01572         <a class="code" href="../../d4/d8/mi_8h.html#a134">UNLOCK_AWE</a> (Process, OldIrql);
01573 
01574         <a class="code" href="../../d4/d8/mi_8h.html#a158">UNLOCK_WS</a> (Process);
01575 
01576         WsHeld = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01577 
01578         <span class="comment">//</span>
01579         <span class="comment">// Now that we're back at APC level or below, free the pages.</span>
01580         <span class="comment">//</span>
01581 
01582         MemoryDescriptorList = MemoryDescriptorHead;
01583         <span class="keywordflow">while</span> (MemoryDescriptorList != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01584             <a class="code" href="../../d5/d6/iosup_8c.html#a64">MmFreePagesFromMdl</a> (MemoryDescriptorList);
01585             MemoryDescriptorList = MemoryDescriptorList-&gt;Next;
01586         }
01587 
01588         <span class="comment">//</span>
01589         <span class="comment">// Fall through...</span>
01590         <span class="comment">//</span>
01591     }
01592 
01593     <span class="comment">//</span>
01594     <span class="comment">// Free the space consumed by the MDLs now that the page frame numbers</span>
01595     <span class="comment">// have been saved in the bitmap and copied to the user.</span>
01596     <span class="comment">//</span>
01597 
01598     MemoryDescriptorList = MemoryDescriptorHead;
01599     <span class="keywordflow">while</span> (MemoryDescriptorList != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01600         MemoryDescriptorList2 = MemoryDescriptorList-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o0">Next</a>;
01601         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (MemoryDescriptorList);
01602         MemoryDescriptorList = MemoryDescriptorList2;
01603     }
01604 
01605 ErrorReturn:
01606 
01607     <span class="keywordflow">if</span> (WsHeld == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01608         <a class="code" href="../../d4/d8/mi_8h.html#a158">UNLOCK_WS</a> (Process);
01609     }
01610 
01611     <span class="keywordflow">if</span> (Attached == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01612         <a class="code" href="../../d3/d5/procobj_8c.html#a7">KeDetachProcess</a>();
01613     }
01614 
01615     <span class="keywordflow">if</span> (ProcessHandle != NtCurrentProcess()) {
01616         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a> (Process);
01617     }
01618 
01619     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01620 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="physical.c::NtFreeUserPhysicalPages" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS NtFreeUserPhysicalPages           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN HANDLE&nbsp;</td>
          <td class="mdname" nowrap> <em>ProcessHandle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT PULONG_PTR&nbsp;</td>
          <td class="mdname" nowrap> <em>NumberOfPages</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PULONG_PTR&nbsp;</td>
          <td class="mdname" nowrap> <em>UserPfnArray</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d4/physical_8c-source.html#l01624">1624</a> of file <a class="el" href="../../d9/d4/physical_8c-source.html">physical.c</a>.
<p>
References <a class="el" href="../../d2/d8/ps_8h-source.html#l00216">_EPROCESS::AddressSpaceDeleted</a>, <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d9/d8/tbitmap_8c-source.html#l00028">BitMap</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00420">_MDL::ByteCount</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l00065">COPY_STACK_SIZE</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l02655">_MMPTE_FLUSH_LIST::Count</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00055">EXCEPTION_EXECUTE_HANDLER</a>, <a class="el" href="../../d7/d2/cmwraper_8c-source.html#l00304">ExFreePool()</a>, <a class="el" href="../../d5/d8/ex_8h.html#a307">ExSystemExceptionFilter()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l02656">_MMPTE_FLUSH_LIST::FlushPte</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l02657">_MMPTE_FLUSH_LIST::FlushVa</a>, <a class="el" href="../../d4/d4/procobj_8c-source.html#l00166">KeAttachProcess()</a>, <a class="el" href="../../d4/d4/procobj_8c-source.html#l00405">KeDetachProcess()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00624">KernelMode</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00174">KPROCESSOR_MODE</a>, <a class="el" href="../../d3/d9/aw_8h-source.html#l00031">L</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l00922">LOCK_AWE</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l00901">LOCK_PFN2</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l01039">LOCK_WS</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l00070">LOWEST_USABLE_PHYSICAL_PAGE</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l00073">MI_FRAME_TO_BITMAP_INDEX</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l00769">MI_PFN_ELEMENT</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l01221">MI_PFN_IS_AWE</a>, <a class="el" href="../../d9/d7/alpha_2mialpha_8h-source.html#l00909">MI_SET_PFN_DELETED</a>, <a class="el" href="../../d9/d7/alpha_2mialpha_8h-source.html#l02486">MI_WRITE_INVALID_PTE</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l02488">MiFlushUserPhysicalPteList()</a>, <a class="el" href="../../d9/d7/alpha_2mialpha_8h-source.html#l01842">MiGetVirtualAddressMappedByPte</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l00127">MM_MAXIMUM_FLUSH_COUNT</a>, <a class="el" href="../../d6/d5/iosup_8c-source.html#l05852">MmCreateMdl()</a>, <a class="el" href="../../d6/d5/iosup_8c-source.html#l05051">MmFreePagesFromMdl()</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l01789">MmInitializeMdl</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l00076">MmVadPhysicalPages</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00494">ObDereferenceObject</a>, <a class="el" href="../../d8/d0/obref_8c-source.html#l00542">ObReferenceObjectByHandle()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00600">PAGE_SHIFT</a>, <a class="el" href="../../d2/d2/ppcdef_8h-source.html#l00079">PASSIVE_LEVEL</a>, <a class="el" href="../../d2/d8/ps_8h-source.html#l00166">_EPROCESS::Pcb</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l01209">ProbeForRead</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l01598">ProbeForWritePointer</a>, <a class="el" href="../../d2/d8/ps_8h-source.html#l00643">PsGetCurrentProcess</a>, <a class="el" href="../../d0/d8/ntos_8h-source.html#l00088">PsProcessType</a>, <a class="el" href="../../d5/d0/rtl_2bitmap_8c-source.html#l01508">RtlClearBits()</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d2/d4/struct__MMPTE.html#o8">_MMPTE::u</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l00925">UNLOCK_AWE</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l00905">UNLOCK_PFN2</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l01081">UNLOCK_WS</a>, <a class="el" href="../../d2/d8/ps_8h-source.html#l00310">_EPROCESS::VadPhysicalPages</a>, <a class="el" href="../../d2/d8/ps_8h-source.html#l00309">_EPROCESS::VadPhysicalPagesBitMap</a>, and <a class="el" href="../../d5/d1/datalpha_8c-source.html#l00030">ZeroPte</a>.
<p>
<pre class="fragment"><div>01632                    :
01633 
01634     This function frees <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> nonpaged physical pages <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified
01635     subject process.  Any PTEs referencing these pages are also invalidated.
01636 
01637     Note there <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> no need to walk <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> entire VAD tree to clear <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> PTEs that
01638     match each page as each physical page can <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> be mapped at a single
01639     <span class="keyword">virtual</span> address (alias addresses within the VAD are not allowed).
01640 
01641 Arguments:
01642 
01643     ProcessHandle - Supplies an open handle to a process object.
01644 
01645     NumberOfPages - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> size in pages of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> allocation to <span class="keyword">delete</span>.
01646                     Returns <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> actual number of pages deleted.
01647         
01648     UserPfnArray - Supplies a pointer to memory to retrieve <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> page frame
01649                    numbers from.
01650 
01651 Return Value:
01652 
01653     Various <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> codes.
01654 
01655 --*/
01656 
01657 {
01658     ULONG i;
01659     KIRQL OldIrql;
01660     KIRQL OldIrqlPfn;
01661     ULONG_PTR CapturedNumberOfPages;
01662     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MemoryDescriptorList;
01663     PPFN_NUMBER MdlPage;
01664     PFN_NUMBER PagesInMdl;
01665     PFN_NUMBER PageFrameIndex;
01666     PRTL_BITMAP <a class="code" href="../../d2/d1/structBitMap.html">BitMap</a>;
01667     ULONG BitMapIndex;
01668     ULONG_PTR PagesProcessed;
01669     PFN_NUMBER MdlHack[(<span class="keyword">sizeof</span>(<a class="code" href="../../d6/d7/struct__MDL.html">MDL</a>) / <span class="keyword">sizeof</span>(PFN_NUMBER)) + <a class="code" href="../../d8/d5/physical_8c.html#a0">COPY_STACK_SIZE</a>];
01670     ULONG_PTR MdlPages;
01671     ULONG_PTR NumberOfBytes;
01672     <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process;
01673     <a class="code" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> PreviousMode;
01674     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01675     LOGICAL Attached;
01676     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
01677     LOGICAL WsHeld;
01678     LOGICAL AweLockHeld;
01679     LOGICAL OnePassComplete;
01680     LOGICAL ProcessReferenced;
01681     <a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html">MMPTE_FLUSH_LIST</a> PteFlushList;
01682     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
01683     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> OldPteContents;
01684 
01685     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (KeGetCurrentIrql() == PASSIVE_LEVEL);
01686 
01687     <span class="comment">//</span>
01688     <span class="comment">// Establish an exception handler, probe the specified addresses</span>
01689     <span class="comment">// for read access and capture the page frame numbers.</span>
01690     <span class="comment">//</span>
01691 
01692     PreviousMode = KeGetPreviousMode();
01693 
01694     <span class="keywordflow">if</span> (PreviousMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
01695 
01696         <span class="keywordflow">try</span> {
01697 
01698             <a class="code" href="../../d5/d8/ex_8h.html#a37">ProbeForWritePointer</a> (NumberOfPages);
01699 
01700             CapturedNumberOfPages = *NumberOfPages;
01701 
01702             <span class="comment">//</span>
01703             <span class="comment">// Initialize the NumberOfPages freed to zero so the user can be</span>
01704             <span class="comment">// reasonably informed about errors that occur midway through</span>
01705             <span class="comment">// the transaction.</span>
01706             <span class="comment">//</span>
01707 
01708             *NumberOfPages = 0;
01709 
01710         } except (<a class="code" href="../../d5/d8/ex_8h.html#a307">ExSystemExceptionFilter</a>()) {
01711 
01712             <span class="comment">//</span>
01713             <span class="comment">// If an exception occurs during the probe or capture</span>
01714             <span class="comment">// of the initial values, then handle the exception and</span>
01715             <span class="comment">// return the exception code as the status value.</span>
01716             <span class="comment">//</span>
01717     
01718             <span class="keywordflow">return</span> GetExceptionCode();
01719         }
01720     }
01721     <span class="keywordflow">else</span> {
01722         CapturedNumberOfPages = *NumberOfPages;
01723     }
01724 
01725     <span class="keywordflow">if</span> (CapturedNumberOfPages == 0) {
01726         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER_2;
01727     }
01728 
01729     OnePassComplete = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01730     PagesProcessed = 0;
01731 
01732     MemoryDescriptorList = (<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>)0;
01733 
01734     <span class="keywordflow">if</span> (CapturedNumberOfPages &gt; <a class="code" href="../../d8/d5/physical_8c.html#a0">COPY_STACK_SIZE</a>) {
01735 
01736         <span class="comment">//</span>
01737         <span class="comment">// Ensure the number of pages can fit into an MDL's ByteCount.</span>
01738         <span class="comment">//</span>
01739 
01740         <span class="keywordflow">if</span> (CapturedNumberOfPages &gt; ((ULONG)MAXULONG &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>)) {
01741             MdlPages = (ULONG_PTR)((ULONG)MAXULONG &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
01742         }
01743         <span class="keywordflow">else</span> {
01744             MdlPages = CapturedNumberOfPages;
01745         }
01746 
01747         <span class="keywordflow">while</span> (MdlPages &gt; <a class="code" href="../../d8/d5/physical_8c.html#a0">COPY_STACK_SIZE</a>) {
01748             MemoryDescriptorList = <a class="code" href="../../d5/d6/iosup_8c.html#a73">MmCreateMdl</a> (NULL,
01749                                                 0,
01750                                                 MdlPages &lt;&lt; PAGE_SHIFT);
01751     
01752             <span class="keywordflow">if</span> (MemoryDescriptorList != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01753                 <span class="keywordflow">break</span>;
01754             }
01755 
01756             MdlPages &gt;&gt;= 1;
01757         }
01758     }
01759 
01760     <span class="keywordflow">if</span> (MemoryDescriptorList == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01761         MdlPages = <a class="code" href="../../d8/d5/physical_8c.html#a0">COPY_STACK_SIZE</a>;
01762         MemoryDescriptorList = (<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>)&amp;MdlHack[0];
01763     }
01764 
01765     WsHeld = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01766     AweLockHeld = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01767     ProcessReferenced = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01768 
01769 repeat:
01770 
01771     <span class="keywordflow">if</span> (CapturedNumberOfPages &lt; MdlPages) {
01772         MdlPages = CapturedNumberOfPages;
01773     }
01774 
01775     <a class="code" href="../../d2/d1/mm_8h.html#a24">MmInitializeMdl</a> (MemoryDescriptorList, 0, MdlPages &lt;&lt; PAGE_SHIFT);
01776 
01777     MdlPage = (PPFN_NUMBER)(MemoryDescriptorList + 1);
01778 
01779     NumberOfBytes = MdlPages * <span class="keyword">sizeof</span>(ULONG_PTR);
01780 
01781     Attached = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01782 
01783     <span class="comment">//</span>
01784     <span class="comment">// Establish an exception handler, probe the specified addresses</span>
01785     <span class="comment">// for read access and capture the page frame numbers.</span>
01786     <span class="comment">//</span>
01787 
01788     <span class="keywordflow">if</span> (PreviousMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
01789 
01790         <span class="keywordflow">try</span> {
01791 
01792             <span class="comment">//</span>
01793             <span class="comment">// Update the user's count so if anything goes wrong, the user can</span>
01794             <span class="comment">// be reasonably informed about how far into the transaction it</span>
01795             <span class="comment">// occurred.</span>
01796             <span class="comment">//</span>
01797 
01798             *NumberOfPages = PagesProcessed;
01799 
01800             <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a> (UserPfnArray,
01801                           NumberOfBytes,
01802                           <span class="keyword">sizeof</span>(PULONG_PTR));
01803 
01804             RtlCopyMemory ((PVOID)MdlPage,
01805                            UserPfnArray,
01806                            NumberOfBytes);
01807 
01808         } except (<a class="code" href="../../d5/d8/ex_8h.html#a307">ExSystemExceptionFilter</a>()) {
01809 
01810             <span class="comment">//</span>
01811             <span class="comment">// If an exception occurs during the probe or capture</span>
01812             <span class="comment">// of the initial values, then handle the exception and</span>
01813             <span class="comment">// return the exception code as the status value.</span>
01814             <span class="comment">//</span>
01815 
01816             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = GetExceptionCode();
01817             <span class="keywordflow">goto</span> ErrorReturn;
01818         }
01819     }
01820     <span class="keywordflow">else</span> {
01821         RtlCopyMemory ((PVOID)MdlPage,
01822                        UserPfnArray,
01823                        NumberOfBytes);
01824     }
01825 
01826     <span class="keywordflow">if</span> (OnePassComplete == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01827 
01828         <span class="comment">//</span>
01829         <span class="comment">// Reference the specified process handle for VM_OPERATION access.</span>
01830         <span class="comment">//</span>
01831     
01832         <span class="keywordflow">if</span> (ProcessHandle == NtCurrentProcess()) {
01833             Process = <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>();
01834         }
01835         <span class="keywordflow">else</span> {
01836             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a> ( ProcessHandle,
01837                                                  PROCESS_VM_OPERATION,
01838                                                  PsProcessType,
01839                                                  PreviousMode,
01840                                                  (PVOID *)&amp;Process,
01841                                                  NULL );
01842     
01843             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(Status)) {
01844                 <span class="keywordflow">goto</span> ErrorReturn;
01845             }
01846             ProcessReferenced = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01847         }
01848     }
01849     
01850     <span class="comment">//</span>
01851     <span class="comment">// If the specified process is not the current process, attach</span>
01852     <span class="comment">// to the specified process.</span>
01853     <span class="comment">//</span>
01854 
01855     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>() != Process) {
01856         <a class="code" href="../../d3/d5/procobj_8c.html#a4">KeAttachProcess</a> (&amp;Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o0">Pcb</a>);
01857         Attached = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01858     }
01859 
01860     <span class="comment">//</span>
01861     <span class="comment">// Get the address creation mutex to block multiple threads from</span>
01862     <span class="comment">// creating or deleting address space at the same time and</span>
01863     <span class="comment">// get the working set mutex so virtual address descriptors can</span>
01864     <span class="comment">// be inserted and walked.  Block APCs so an APC which takes a page</span>
01865     <span class="comment">// fault does not corrupt various structures.</span>
01866     <span class="comment">//</span>
01867 
01868     <a class="code" href="../../d4/d8/mi_8h.html#a154">LOCK_WS</a> (Process);
01869     WsHeld = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01870 
01871     <span class="comment">//</span>
01872     <span class="comment">// Make sure the address space was not deleted, if so, return an error.</span>
01873     <span class="comment">//</span>
01874 
01875     <span class="keywordflow">if</span> (Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o27">AddressSpaceDeleted</a> != 0) {
01876         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_PROCESS_IS_TERMINATING;
01877         <span class="keywordflow">goto</span> ErrorReturn;
01878     }
01879 
01880     <a class="code" href="../../d4/d8/mi_8h.html#a133">LOCK_AWE</a> (Process, OldIrql);
01881     AweLockHeld = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01882 
01883     <span class="comment">//</span>
01884     <span class="comment">// The physical pages bitmap must exist.</span>
01885     <span class="comment">//</span>
01886 
01887     <a class="code" href="../../d8/d9/tbitmap_8c.html#a2">BitMap</a> = Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o88">VadPhysicalPagesBitMap</a>;
01888 
01889     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d9/tbitmap_8c.html#a2">BitMap</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01890         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_PARAMETER_2;
01891         <span class="keywordflow">goto</span> ErrorReturn;
01892     }
01893 
01894     PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a> = 0;
01895 
01896     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
01897 
01898     <span class="keywordflow">for</span> (i = 0; i &lt; MdlPages; i += 1, MdlPage += 1) {
01899 
01900         PageFrameIndex = *MdlPage;
01901         BitMapIndex = <a class="code" href="../../d8/d5/physical_8c.html#a5">MI_FRAME_TO_BITMAP_INDEX</a>(PageFrameIndex);
01902 
01903 <span class="preprocessor">#if defined (_WIN64)</span>
01904 <span class="preprocessor"></span>        <span class="comment">//</span>
01905         <span class="comment">// Ensure the frame is a 32-bit number.</span>
01906         <span class="comment">//</span>
01907 
01908         <span class="keywordflow">if</span> (BitMapIndex != PageFrameIndex) {
01909             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_CONFLICTING_ADDRESSES;
01910             <span class="keywordflow">break</span>;
01911         }
01912 <span class="preprocessor">#endif</span>
01913 <span class="preprocessor"></span>            
01914         <span class="comment">//</span>
01915         <span class="comment">// Frames past the end of the bitmap are not allowed.</span>
01916         <span class="comment">//</span>
01917 
01918         <span class="keywordflow">if</span> (BitMapIndex &gt;= <a class="code" href="../../d8/d9/tbitmap_8c.html#a2">BitMap</a>-&gt;SizeOfBitMap) {
01919             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_CONFLICTING_ADDRESSES;
01920             <span class="keywordflow">break</span>;
01921         }
01922 
01923         <span class="comment">//</span>
01924         <span class="comment">// Frames not in the bitmap are not allowed.</span>
01925         <span class="comment">//</span>
01926 
01927         <span class="keywordflow">if</span> (RtlCheckBit (BitMap, BitMapIndex) == 0) {
01928             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_CONFLICTING_ADDRESSES;
01929             <span class="keywordflow">break</span>;
01930         }
01931 
01932         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PageFrameIndex &gt;= LOWEST_USABLE_PHYSICAL_PAGE);
01933 
01934         PagesProcessed += 1;
01935 
01936 <span class="preprocessor">#if defined (_WIN64)</span>
01937 <span class="preprocessor"></span>        <span class="comment">//</span>
01938         <span class="comment">// This may become a problem for 64-bit systems with &gt; 32tb</span>
01939         <span class="comment">// of physical memory as the 2nd parameter to RtlClearBits is</span>
01940         <span class="comment">// a ULONG.</span>
01941         <span class="comment">//</span>
01942 
01943         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PageFrameIndex &lt; 0x100000000);
01944 <span class="preprocessor">#endif</span>
01945 <span class="preprocessor"></span>
01946         <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a33">RtlClearBits</a> (BitMap, BitMapIndex, 1L);
01947 
01948         Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(PageFrameIndex);
01949 
01950         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (MI_PFN_IS_AWE (Pfn1));
01951 
01952 <span class="preprocessor">#if DBG</span>
01953 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount == 1) {
01954             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> == (<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)0);
01955         }
01956         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount == 2) {
01957             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> != (<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)0);
01958         }
01959         <span class="keywordflow">else</span> {
01960             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (FALSE);
01961         }
01962 <span class="preprocessor">#endif</span>
01963 <span class="preprocessor"></span>
01964         <span class="comment">//</span>
01965         <span class="comment">// If the frame is currently mapped in the Vad then the PTE must</span>
01966         <span class="comment">// be cleared and the TB entry flushed.</span>
01967         <span class="comment">//</span>
01968 
01969         <span class="keywordflow">if</span> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount != 1) {
01970 
01971             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount -= 1;
01972 
01973             PointerPte = Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a>;
01974             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> = (<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)0;
01975 
01976             OldPteContents = *PointerPte;
01977     
01978             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (OldPteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1);
01979 
01980             <span class="keywordflow">if</span> (PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a> != <a class="code" href="../../d4/d8/mi_8h.html#a34">MM_MAXIMUM_FLUSH_COUNT</a>) {
01981                 PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o2">FlushVa</a>[PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a>] =
01982                     <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPte);
01983                 PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o1">FlushPte</a>[PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a>] = PointerPte;
01984                 PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a> += 1;
01985             }
01986 
01987             <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a187">MI_WRITE_INVALID_PTE</a> (PointerPte, ZeroPte);
01988         }
01989 
01990         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a120">MI_SET_PFN_DELETED</a>(Pfn1);
01991     }
01992 
01993     <span class="comment">//</span>
01994     <span class="comment">// Flush the TB entries for these pages.  Note ZeroPte is only used</span>
01995     <span class="comment">// when the FlushPte[0] field is nonzero or if only a single PTE is</span>
01996     <span class="comment">// being flushed.</span>
01997     <span class="comment">//</span>
01998 
01999     <a class="code" href="../../d8/d5/physical_8c.html#a8">MiFlushUserPhysicalPteList</a> (&amp;PteFlushList);
02000 
02001     <span class="comment">//</span>
02002     <span class="comment">// Free the actual pages (this may be a partially filled MDL).</span>
02003     <span class="comment">//</span>
02004 
02005     PagesInMdl = MdlPage - (PPFN_NUMBER)(MemoryDescriptorList + 1);
02006 
02007     <span class="comment">//</span>
02008     <span class="comment">// Set the ByteCount to the actual number of validated pages - the caller</span>
02009     <span class="comment">// may have lied and we have to sync up here to account for any bogus</span>
02010     <span class="comment">// frames.</span>
02011     <span class="comment">//</span>
02012 
02013     MemoryDescriptorList-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o6">ByteCount</a> = (ULONG)(PagesInMdl &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
02014 
02015     <span class="keywordflow">if</span> (PagesInMdl != 0) {
02016         Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o89">VadPhysicalPages</a> -= PagesInMdl;
02017         <a class="code" href="../../d4/d8/mi_8h.html#a134">UNLOCK_AWE</a> (Process, OldIrql);
02018         AweLockHeld = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02019 
02020         <a class="code" href="../../d4/d8/mi_8h.html#a130">LOCK_PFN2</a> (OldIrqlPfn);
02021         <a class="code" href="../../d8/d5/physical_8c.html#a7">MmVadPhysicalPages</a> -= PagesInMdl;
02022         <a class="code" href="../../d4/d8/mi_8h.html#a131">UNLOCK_PFN2</a> (OldIrqlPfn);
02023 
02024         <a class="code" href="../../d5/d6/iosup_8c.html#a64">MmFreePagesFromMdl</a> (MemoryDescriptorList);
02025     }
02026     <span class="keywordflow">else</span> {
02027         <span class="keywordflow">if</span> (AweLockHeld == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
02028             <a class="code" href="../../d4/d8/mi_8h.html#a134">UNLOCK_AWE</a> (Process, OldIrql);
02029             AweLockHeld = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02030         }
02031     }
02032 
02033     CapturedNumberOfPages -= PagesInMdl;
02034 
02035     <span class="keywordflow">if</span> ((<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_SUCCESS) &amp;&amp; (CapturedNumberOfPages != 0)) {
02036 
02037         <a class="code" href="../../d4/d8/mi_8h.html#a158">UNLOCK_WS</a> (Process);
02038         WsHeld = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02039 
02040         <span class="keywordflow">if</span> (Attached == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
02041             <a class="code" href="../../d3/d5/procobj_8c.html#a7">KeDetachProcess</a>();
02042             Attached = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02043         }
02044 
02045         OnePassComplete = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02046         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (MdlPages == PagesInMdl);
02047         UserPfnArray += MdlPages;
02048 
02049         <span class="comment">//</span>
02050         <span class="comment">// Do it all again until all the pages are freed or an error occurs.</span>
02051         <span class="comment">//</span>
02052 
02053         <span class="keywordflow">goto</span> repeat;
02054     }
02055 
02056     <span class="comment">//</span>
02057     <span class="comment">// Fall through.</span>
02058     <span class="comment">//</span>
02059 
02060 ErrorReturn:
02061 
02062     <span class="keywordflow">if</span> (AweLockHeld == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
02063         <a class="code" href="../../d4/d8/mi_8h.html#a134">UNLOCK_AWE</a> (Process, OldIrql);
02064     }
02065 
02066     <span class="keywordflow">if</span> (WsHeld == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
02067         <a class="code" href="../../d4/d8/mi_8h.html#a158">UNLOCK_WS</a> (Process);
02068     }
02069 
02070     <span class="comment">//</span>
02071     <span class="comment">// Free any pool acquired for holding MDLs.</span>
02072     <span class="comment">//</span>
02073 
02074     <span class="keywordflow">if</span> (MemoryDescriptorList != (<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>)&amp;MdlHack[0]) {
02075         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (MemoryDescriptorList);
02076     }
02077 
02078     <span class="keywordflow">if</span> (Attached == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
02079         <a class="code" href="../../d3/d5/procobj_8c.html#a7">KeDetachProcess</a>();
02080     }
02081 
02082     <span class="comment">//</span>
02083     <span class="comment">// Establish an exception handler and carefully write out the</span>
02084     <span class="comment">// number of pages actually processed.</span>
02085     <span class="comment">//</span>
02086 
02087     <span class="keywordflow">try</span> {
02088 
02089         *NumberOfPages = PagesProcessed;
02090 
02091     } except (EXCEPTION_EXECUTE_HANDLER) {
02092 
02093         <span class="comment">//</span>
02094         <span class="comment">// Return success at this point even if the results</span>
02095         <span class="comment">// cannot be written.</span>
02096         <span class="comment">//</span>
02097 
02098         NOTHING;
02099     }
02100 
02101     <span class="keywordflow">if</span> (ProcessReferenced == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
02102         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a> (Process);
02103     }
02104 
02105     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
02106 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="physical.c::NtMapUserPhysicalPages" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS NtMapUserPhysicalPages           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>VirtualAddress</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG_PTR&nbsp;</td>
          <td class="mdname" nowrap> <em>NumberOfPages</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PULONG_PTR UserPfnArray&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d4/physical_8c-source.html#l00085">85</a> of file <a class="el" href="../../d9/d4/physical_8c-source.html">physical.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d9/d8/tbitmap_8c-source.html#l00028">BitMap</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l00065">COPY_STACK_SIZE</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l02655">_MMPTE_FLUSH_LIST::Count</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l02429">_MI_PHYSICAL_VIEW::EndVa</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l00253">ExAllocatePoolWithTag</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00055">EXCEPTION_EXECUTE_HANDLER</a>, <a class="el" href="../../d7/d2/cmwraper_8c-source.html#l00304">ExFreePool()</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l02656">_MMPTE_FLUSH_LIST::FlushPte</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l02657">_MMPTE_FLUSH_LIST::FlushVa</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l00922">LOCK_AWE</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l00070">LOWEST_USABLE_PHYSICAL_PAGE</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l00073">MI_FRAME_TO_BITMAP_INDEX</a>, <a class="el" href="../../d9/d7/alpha_2mialpha_8h-source.html#l00494">MI_MAKE_VALID_PTE</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l00769">MI_PFN_ELEMENT</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l01221">MI_PFN_IS_AWE</a>, <a class="el" href="../../d9/d7/alpha_2mialpha_8h-source.html#l00710">MI_SET_PTE_DIRTY</a>, <a class="el" href="../../d9/d7/alpha_2mialpha_8h-source.html#l02486">MI_WRITE_INVALID_PTE</a>, <a class="el" href="../../d9/d7/alpha_2mialpha_8h-source.html#l02459">MI_WRITE_VALID_PTE</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l02488">MiFlushUserPhysicalPteList()</a>, <a class="el" href="../../d9/d7/alpha_2mialpha_8h-source.html#l01671">MiGetPteAddress</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l00127">MM_MAXIMUM_FLUSH_COUNT</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l00137">MM_READWRITE</a>, <a class="el" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d3/d0/mm_8h-source.html#l00190">PAGE_ALIGN</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00600">PAGE_SHIFT</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00599">PAGE_SIZE</a>, <a class="el" href="../../d2/d2/ppcdef_8h-source.html#l00079">PASSIVE_LEVEL</a>, <a class="el" href="../../d2/d8/ps_8h-source.html#l00267">_EPROCESS::PhysicalVadList</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l01209">ProbeForRead</a>, <a class="el" href="../../d2/d8/ps_8h-source.html#l00643">PsGetCurrentProcess</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l01281">_MMPFN::PteAddress</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l02428">_MI_PHYSICAL_VIEW::StartVa</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d2/d4/struct__MMPTE.html#o8">_MMPTE::u</a>, <a class="el" href="../../d6/d6/struct__MMVAD.html#o7">_MMVAD::u</a>, <a class="el" href="../../d4/d3/struct__MMPFN.html#o10">_MMPFN::u2</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l00925">UNLOCK_AWE</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l02427">_MI_PHYSICAL_VIEW::Vad</a>, <a class="el" href="../../d2/d8/ps_8h-source.html#l00309">_EPROCESS::VadPhysicalPagesBitMap</a>, <a class="el" href="../../d2/d7/hal_8h.html#a212">VOID()</a>, and <a class="el" href="../../d5/d1/datalpha_8c-source.html#l00030">ZeroPte</a>.
<p>
<pre class="fragment"><div>00093                    :
00094 
00095     This function maps <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified nonpaged physical pages into <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified
00096     user address range.
00097 
00098     Note no WSLEs are maintained <span class="keywordflow">for</span> <span class="keyword">this</span> range as <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> all nonpaged.
00099 
00100 Arguments:
00101 
00102     VirtualAddress - Supplies a user <span class="keyword">virtual</span> address within a UserPhysicalPages
00103                      Vad.
00104         
00105     NumberOfPages - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> number of pages to map.
00106         
00107     UserPfnArray - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> page frame numbers to map in.
00108                    If <span class="keyword">this</span> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> zero, then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keyword">virtual</span> addresses are set to
00109                    NO_ACCESS.
00110 
00111 Return Value:
00112 
00113     Various <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> codes.
00114 
00115 --*/
00116 
00117 {
00118     <a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a> FoundVad;
00119     KIRQL OldIrql;
00120     ULONG_PTR i;
00121     <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process;
00122     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
00123     PVOID EndAddress;
00124     PFN_NUMBER PageFrameIndex;
00125     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
00126     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00127     <a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html">MMPTE_FLUSH_LIST</a> PteFlushList;
00128     PVOID PoolArea;
00129     PPFN_NUMBER FrameList;
00130     ULONG BitMapIndex;
00131     ULONG_PTR StackArray[<a class="code" href="../../d8/d5/physical_8c.html#a0">COPY_STACK_SIZE</a>];
00132     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> OldPteContents;
00133     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> NewPteContents;
00134     ULONG_PTR NumberOfBytes;
00135     PRTL_BITMAP <a class="code" href="../../d2/d1/structBitMap.html">BitMap</a>;
00136     PLIST_ENTRY NextEntry;
00137     <a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html">PMI_PHYSICAL_VIEW</a> PhysicalView;
00138 
00139     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (KeGetCurrentIrql() == PASSIVE_LEVEL);
00140 
00141     <span class="keywordflow">if</span> (NumberOfPages &gt; (MAXULONG_PTR / <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>)) {
00142         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER_2;
00143     }
00144 
00145     VirtualAddress = <a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a>(VirtualAddress);
00146     EndAddress = (PVOID)((PCHAR)VirtualAddress + (NumberOfPages &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>) -1);
00147 
00148     <span class="keywordflow">if</span> (EndAddress &lt;= VirtualAddress) {
00149         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER_2;
00150     }
00151 
00152     <span class="comment">//</span>
00153     <span class="comment">// Carefully probe and capture all user parameters.</span>
00154     <span class="comment">//</span>
00155 
00156     PoolArea = (PVOID)&amp;StackArray[0];
00157 
00158     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(UserPfnArray)) {
00159 
00160         NumberOfBytes = NumberOfPages * <span class="keyword">sizeof</span>(ULONG_PTR);
00161 
00162         <span class="keywordflow">if</span> (NumberOfPages &gt; <a class="code" href="../../d8/d5/physical_8c.html#a0">COPY_STACK_SIZE</a>) {
00163             PoolArea = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a> (NonPagedPool,
00164                                               NumberOfBytes,
00165                                               'wRmM');
00166     
00167             <span class="keywordflow">if</span> (PoolArea == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00168                 <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
00169             }
00170         }
00171     
00172         <span class="comment">//</span>
00173         <span class="comment">// Capture the specified page frame numbers.</span>
00174         <span class="comment">//</span>
00175 
00176         <span class="keywordflow">try</span> {
00177             <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a> (UserPfnArray,
00178                           NumberOfBytes,
00179                           <span class="keyword">sizeof</span>(ULONG_PTR));
00180 
00181             RtlCopyMemory (PoolArea, UserPfnArray, NumberOfBytes);
00182 
00183         } except(EXCEPTION_EXECUTE_HANDLER) {
00184             <span class="keywordflow">if</span> (PoolArea != (PVOID)&amp;StackArray[0]) {
00185                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (PoolArea);
00186             }
00187             <span class="keywordflow">return</span> GetExceptionCode();
00188         }
00189     }
00190 
00191     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (VirtualAddress);
00192 
00193     Process = <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>();
00194 
00195     <span class="comment">//</span>
00196     <span class="comment">// The AWE lock protects insertion/removal of Vads into each process'</span>
00197     <span class="comment">// PhysicalVadList.  It also protects creation/deletion and adds/removes</span>
00198     <span class="comment">// of the VadPhysicalPagesBitMap.  Finally, it protects the PFN</span>
00199     <span class="comment">// modifications for pages in the bitmap.</span>
00200     <span class="comment">//</span>
00201 
00202     <a class="code" href="../../d4/d8/mi_8h.html#a133">LOCK_AWE</a> (Process, OldIrql);
00203 
00204     <span class="comment">//</span>
00205     <span class="comment">// The physical pages bitmap must exist.</span>
00206     <span class="comment">//</span>
00207 
00208     <a class="code" href="../../d8/d9/tbitmap_8c.html#a2">BitMap</a> = Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o88">VadPhysicalPagesBitMap</a>;
00209 
00210     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d9/tbitmap_8c.html#a2">BitMap</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00211         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_PARAMETER_1;
00212         <span class="keywordflow">goto</span> ErrorReturn;
00213     }
00214 
00215     <span class="comment">//</span>
00216     <span class="comment">// Note that the PFN lock is not needed to traverse this list (even though</span>
00217     <span class="comment">// MmProbeAndLockPages uses it), because all modifications are made while</span>
00218     <span class="comment">// also holding the AWE lock.</span>
00219     <span class="comment">//</span>
00220     <span class="comment">// The PhysicalVadList should typically have just one entry - the view</span>
00221     <span class="comment">// we're looking for, so this traverse should be quick.</span>
00222     <span class="comment">//</span>
00223 
00224     FoundVad = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00225     NextEntry = Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o61">PhysicalVadList</a>.Flink;
00226     <span class="keywordflow">while</span> (NextEntry != &amp;Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o61">PhysicalVadList</a>) {
00227 
00228         PhysicalView = CONTAINING_RECORD(NextEntry,
00229                                          <a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html">MI_PHYSICAL_VIEW</a>,
00230                                          ListEntry);
00231 
00232         <span class="keywordflow">if</span> (PhysicalView-&gt;<a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html#o1">Vad</a>-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.VadFlags.UserPhysicalPages == 1) {
00233 
00234             <span class="keywordflow">if</span> ((VirtualAddress &gt;= (PVOID)PhysicalView-&gt;<a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html#o2">StartVa</a>) &amp;&amp;
00235                 (EndAddress &lt;= (PVOID)PhysicalView-&gt;<a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html#o3">EndVa</a>)) {
00236 
00237                     FoundVad = PhysicalView-&gt;<a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html#o1">Vad</a>;
00238                     <span class="keywordflow">break</span>;
00239             }
00240         }
00241 
00242         NextEntry = NextEntry-&gt;Flink;
00243         <span class="keywordflow">continue</span>;
00244     }
00245 
00246     <span class="keywordflow">if</span> (FoundVad == (<a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a>)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00247 
00248         <span class="comment">//</span>
00249         <span class="comment">// No virtual address is reserved at the specified base address,</span>
00250         <span class="comment">// return an error.</span>
00251         <span class="comment">//</span>
00252 
00253         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_PARAMETER_1;
00254         <span class="keywordflow">goto</span> ErrorReturn;
00255     }
00256 
00257     <span class="comment">//</span>
00258     <span class="comment">// Ensure the PFN element corresponding to each specified page is owned</span>
00259     <span class="comment">// by the specified VAD.</span>
00260     <span class="comment">//</span>
00261     <span class="comment">// Since this ownership can only be changed while holding this process'</span>
00262     <span class="comment">// working set lock, the PFN can be scanned here without holding the PFN</span>
00263     <span class="comment">// lock.</span>
00264     <span class="comment">//</span>
00265     <span class="comment">// Note the PFN lock is not needed because any race with MmProbeAndLockPages</span>
00266     <span class="comment">// can only result in the I/O going to the old page or the new page.</span>
00267     <span class="comment">// If the user breaks the rules, the PFN database (and any pages being</span>
00268     <span class="comment">// windowed here) are still protected because of the reference counts</span>
00269     <span class="comment">// on the pages with inprogress I/O.  This is possible because NO pages</span>
00270     <span class="comment">// are actually freed here - they are just windowed.</span>
00271     <span class="comment">//</span>
00272 
00273     PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a> = 0;
00274 
00275     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(UserPfnArray)) {
00276 
00277         <span class="comment">//</span>
00278         <span class="comment">// By keeping the PFN bitmap in the VAD (instead of in the PFN</span>
00279         <span class="comment">// database itself), a few benefits are realized:</span>
00280         <span class="comment">//</span>
00281         <span class="comment">// 1. No need to acquire the PFN lock here.</span>
00282         <span class="comment">// 2. Faster handling of PFN databases with holes.</span>
00283         <span class="comment">// 3. Transparent support for dynamic PFN database growth.</span>
00284         <span class="comment">// 4. Less nonpaged memory is used (for the bitmap vs adding a</span>
00285         <span class="comment">//    field to the PFN) on systems with no unused pack space in</span>
00286         <span class="comment">//    the PFN database, presuming not many of these VADs get</span>
00287         <span class="comment">//    allocated.</span>
00288         <span class="comment">//</span>
00289 
00290         <span class="comment">//</span>
00291         <span class="comment">// The first pass here ensures all the frames are secure.</span>
00292         <span class="comment">//</span>
00293 
00294         <span class="comment">//</span>
00295         <span class="comment">// N.B.  This implies that PFN_NUMBER is always ULONG_PTR in width</span>
00296         <span class="comment">//       as PFN_NUMBER is not exposed to application code today.</span>
00297         <span class="comment">//</span>
00298 
00299         FrameList = (PPFN_NUMBER)PoolArea;
00300 
00301         <span class="keywordflow">for</span> (i = 0; i &lt; NumberOfPages; i += 1, FrameList += 1) {
00302 
00303             PageFrameIndex = *FrameList;
00304 
00305             <span class="comment">//</span>
00306             <span class="comment">// Frames past the end of the bitmap are not allowed.</span>
00307             <span class="comment">//</span>
00308 
00309             BitMapIndex = <a class="code" href="../../d8/d5/physical_8c.html#a5">MI_FRAME_TO_BITMAP_INDEX</a>(PageFrameIndex);
00310 
00311 <span class="preprocessor">#if defined (_WIN64)</span>
00312 <span class="preprocessor"></span>            <span class="comment">//</span>
00313             <span class="comment">// Ensure the frame is a 32-bit number.</span>
00314             <span class="comment">//</span>
00315 
00316             <span class="keywordflow">if</span> (BitMapIndex != PageFrameIndex) {
00317                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_CONFLICTING_ADDRESSES;
00318                 <span class="keywordflow">goto</span> ErrorReturn0;
00319             }
00320 <span class="preprocessor">#endif</span>
00321 <span class="preprocessor"></span>            
00322             <span class="keywordflow">if</span> (BitMapIndex &gt;= <a class="code" href="../../d8/d9/tbitmap_8c.html#a2">BitMap</a>-&gt;SizeOfBitMap) {
00323                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_CONFLICTING_ADDRESSES;
00324                 <span class="keywordflow">goto</span> ErrorReturn0;
00325             }
00326 
00327             <span class="comment">//</span>
00328             <span class="comment">// Frames not in the bitmap are not allowed.</span>
00329             <span class="comment">//</span>
00330 
00331             <span class="keywordflow">if</span> (RtlCheckBit (BitMap, BitMapIndex) == 0) {
00332                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_CONFLICTING_ADDRESSES;
00333                 <span class="keywordflow">goto</span> ErrorReturn0;
00334             }
00335 
00336             <span class="comment">//</span>
00337             <span class="comment">// The frame must not be already mapped anywhere.</span>
00338             <span class="comment">// Or be passed in twice in different spots in the array.</span>
00339             <span class="comment">//</span>
00340 
00341             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PageFrameIndex);
00342 
00343             <span class="keywordflow">if</span> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount != 1) {
00344                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_PARAMETER_3;
00345                 <span class="keywordflow">goto</span> ErrorReturn0;
00346             }
00347 
00348             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (MI_PFN_IS_AWE (Pfn1));
00349 
00350             <span class="comment">//</span>
00351             <span class="comment">// Mark the frame as "about to be mapped".</span>
00352             <span class="comment">//</span>
00353 
00354             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount = 3;
00355 
00356             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PageFrameIndex &gt;= LOWEST_USABLE_PHYSICAL_PAGE);
00357         }
00358 
00359         <span class="comment">//</span>
00360         <span class="comment">// This pass actually inserts them all into the page table pages and</span>
00361         <span class="comment">// the TBs now that we know the frames are good.</span>
00362         <span class="comment">//</span>
00363 
00364         FrameList = (PPFN_NUMBER)PoolArea;
00365 
00366         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a105">MI_MAKE_VALID_PTE</a> (NewPteContents,
00367                            PageFrameIndex,
00368                            MM_READWRITE,
00369                            PointerPte);
00370 
00371         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a112">MI_SET_PTE_DIRTY</a> (NewPteContents);
00372 
00373         <span class="keywordflow">for</span> (i = 0; i &lt; NumberOfPages; i += 1) {
00374 
00375             PageFrameIndex = *FrameList;
00376             NewPteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber = PageFrameIndex;
00377 
00378             OldPteContents = *PointerPte;
00379 
00380             <span class="comment">//</span>
00381             <span class="comment">// Flush the TB entry for this page if it's valid.</span>
00382             <span class="comment">//</span>
00383         
00384             <span class="keywordflow">if</span> (OldPteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1) {
00385                 Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (OldPteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
00386                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> != (<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)0);
00387                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount == 2);
00388                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount -= 1;
00389                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> = (<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)0;
00390 
00391 <span class="preprocessor">#if defined (_X86PAE_)</span>
00392 <span class="preprocessor"></span>                (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)KeInterlockedSwapPte ((PHARDWARE_PTE)PointerPte,
00393                                             (PHARDWARE_PTE)&amp;NewPteContents);
00394 <span class="preprocessor">#else</span>
00395 <span class="preprocessor"></span>                *PointerPte = NewPteContents;
00396 <span class="preprocessor">#endif</span>
00397 <span class="preprocessor"></span>    
00398                 <span class="keywordflow">if</span> (PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a> != <a class="code" href="../../d4/d8/mi_8h.html#a34">MM_MAXIMUM_FLUSH_COUNT</a>) {
00399                     PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o2">FlushVa</a>[PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a>] = VirtualAddress;
00400                     PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o1">FlushPte</a>[PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a>] = PointerPte;
00401                     PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a> += 1;
00402                 }
00403             }
00404             <span class="keywordflow">else</span> {
00405                 <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a186">MI_WRITE_VALID_PTE</a> (PointerPte, NewPteContents);
00406             }
00407 
00408             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PageFrameIndex);
00409             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> == (<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)0);
00410             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount == 3);
00411             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount = 2;
00412             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> = PointerPte;
00413 
00414             VirtualAddress = (PVOID)((PCHAR)VirtualAddress + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
00415             PointerPte += 1;
00416             FrameList += 1;
00417         }
00418     }
00419     <span class="keywordflow">else</span> {
00420 
00421         <span class="comment">//</span>
00422         <span class="comment">// Set the specified virtual address range to no access.</span>
00423         <span class="comment">//</span>
00424 
00425         <span class="keywordflow">for</span> (i = 0; i &lt; NumberOfPages; i += 1) {
00426 
00427             OldPteContents = *PointerPte;
00428     
00429             <span class="comment">//</span>
00430             <span class="comment">// Flush the TB entry for this page if it's valid.</span>
00431             <span class="comment">//</span>
00432         
00433             <span class="keywordflow">if</span> (OldPteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1) {
00434 
00435                 Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (OldPteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
00436                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> != (<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)0);
00437                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount == 2);
00438                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (MI_PFN_IS_AWE (Pfn1));
00439                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount -= 1;
00440                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> = (<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)0;
00441 
00442                 <span class="keywordflow">if</span> (PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a> != <a class="code" href="../../d4/d8/mi_8h.html#a34">MM_MAXIMUM_FLUSH_COUNT</a>) {
00443                     PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o2">FlushVa</a>[PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a>] = VirtualAddress;
00444                     PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o1">FlushPte</a>[PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a>] = PointerPte;
00445                     PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a> += 1;
00446                 }
00447             }
00448 
00449             <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a187">MI_WRITE_INVALID_PTE</a> (PointerPte, ZeroPte);
00450 
00451             VirtualAddress = (PVOID)((PCHAR)VirtualAddress + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
00452             PointerPte += 1;
00453         }
00454     }
00455 
00456     <span class="comment">//</span>
00457     <span class="comment">// Flush the TB entries for these pages.  Note ZeroPte is only used</span>
00458     <span class="comment">// when the FlushPte[0] field is nonzero or if only a single PTE is</span>
00459     <span class="comment">// being flushed.</span>
00460     <span class="comment">//</span>
00461 
00462     <span class="keywordflow">if</span> (PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a> != 0) {
00463         <a class="code" href="../../d8/d5/physical_8c.html#a8">MiFlushUserPhysicalPteList</a> (&amp;PteFlushList);
00464     }
00465 
00466     <a class="code" href="../../d4/d8/mi_8h.html#a134">UNLOCK_AWE</a> (Process, OldIrql);
00467 
00468     <span class="keywordflow">if</span> (PoolArea != (PVOID)&amp;StackArray[0]) {
00469         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (PoolArea);
00470     }
00471 
00472     <span class="keywordflow">return</span> STATUS_SUCCESS;
00473 
00474 ErrorReturn0:
00475 
00476     <span class="keywordflow">while</span> (i != 0) {
00477         FrameList -= 1;
00478         PageFrameIndex = *FrameList;
00479         Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PageFrameIndex);
00480         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount == 3);
00481         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount = 1;
00482         i -= 1;
00483     }
00484 
00485 ErrorReturn:
00486 
00487     <a class="code" href="../../d4/d8/mi_8h.html#a134">UNLOCK_AWE</a> (Process, OldIrql);
00488 
00489     <span class="keywordflow">if</span> (PoolArea != (PVOID)&amp;StackArray[0]) {
00490         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (PoolArea);
00491     }
00492 
00493     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00494 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="physical.c::NtMapUserPhysicalPagesScatter" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS NtMapUserPhysicalPagesScatter           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID *&nbsp;</td>
          <td class="mdname" nowrap> <em>VirtualAddresses</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG_PTR&nbsp;</td>
          <td class="mdname" nowrap> <em>NumberOfPages</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PULONG_PTR UserPfnArray&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d4/physical_8c-source.html#l00498">498</a> of file <a class="el" href="../../d9/d4/physical_8c-source.html">physical.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d9/d8/tbitmap_8c-source.html#l00028">BitMap</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l00065">COPY_STACK_SIZE</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l02655">_MMPTE_FLUSH_LIST::Count</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l02429">_MI_PHYSICAL_VIEW::EndVa</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l00253">ExAllocatePoolWithTag</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00055">EXCEPTION_EXECUTE_HANDLER</a>, <a class="el" href="../../d7/d2/cmwraper_8c-source.html#l00304">ExFreePool()</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l02656">_MMPTE_FLUSH_LIST::FlushPte</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l02657">_MMPTE_FLUSH_LIST::FlushVa</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l00922">LOCK_AWE</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l00070">LOWEST_USABLE_PHYSICAL_PAGE</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l00073">MI_FRAME_TO_BITMAP_INDEX</a>, <a class="el" href="../../d9/d7/alpha_2mialpha_8h-source.html#l00494">MI_MAKE_VALID_PTE</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l00769">MI_PFN_ELEMENT</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l01221">MI_PFN_IS_AWE</a>, <a class="el" href="../../d9/d7/alpha_2mialpha_8h-source.html#l00710">MI_SET_PTE_DIRTY</a>, <a class="el" href="../../d9/d7/alpha_2mialpha_8h-source.html#l02486">MI_WRITE_INVALID_PTE</a>, <a class="el" href="../../d9/d7/alpha_2mialpha_8h-source.html#l02459">MI_WRITE_VALID_PTE</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l02488">MiFlushUserPhysicalPteList()</a>, <a class="el" href="../../d9/d7/alpha_2mialpha_8h-source.html#l01671">MiGetPteAddress</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l00127">MM_MAXIMUM_FLUSH_COUNT</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l00137">MM_READWRITE</a>, <a class="el" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00599">PAGE_SIZE</a>, <a class="el" href="../../d2/d2/ppcdef_8h-source.html#l00079">PASSIVE_LEVEL</a>, <a class="el" href="../../d2/d8/ps_8h-source.html#l00267">_EPROCESS::PhysicalVadList</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l01209">ProbeForRead</a>, <a class="el" href="../../d2/d8/ps_8h-source.html#l00643">PsGetCurrentProcess</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l01281">_MMPFN::PteAddress</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l02428">_MI_PHYSICAL_VIEW::StartVa</a>, <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>, <a class="el" href="../../d2/d4/struct__MMPTE.html#o8">_MMPTE::u</a>, <a class="el" href="../../d6/d6/struct__MMVAD.html#o7">_MMVAD::u</a>, <a class="el" href="../../d4/d3/struct__MMPFN.html#o10">_MMPFN::u2</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l00925">UNLOCK_AWE</a>, <a class="el" href="../../d5/d7/mi_8h-source.html#l02427">_MI_PHYSICAL_VIEW::Vad</a>, <a class="el" href="../../d2/d8/ps_8h-source.html#l00309">_EPROCESS::VadPhysicalPagesBitMap</a>, <a class="el" href="../../d2/d7/hal_8h.html#a212">VOID()</a>, and <a class="el" href="../../d5/d1/datalpha_8c-source.html#l00030">ZeroPte</a>.
<p>
<pre class="fragment"><div>00506                    :
00507 
00508     This function maps <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified nonpaged physical pages into <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified
00509     user address range.
00510 
00511     Note no WSLEs are maintained <span class="keywordflow">for</span> <span class="keyword">this</span> range as <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> all nonpaged.
00512 
00513 Arguments:
00514 
00515     VirtualAddresses - Supplies a pointer to an array of user <span class="keyword">virtual</span> addresses
00516                        within UserPhysicalPages Vads.  Each array entry <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
00517                        presumed to map a single page.
00518         
00519     NumberOfPages - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> number of pages to map.
00520         
00521     UserPfnArray - Supplies a pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> page frame numbers to map in.
00522                    If <span class="keyword">this</span> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> zero, then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keyword">virtual</span> addresses are set to
00523                    NO_ACCESS.  If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> array entry <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> zero then just <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00524                    corresponding <span class="keyword">virtual</span> address <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> set to NO_ACCESS.
00525 
00526 Return Value:
00527 
00528     Various <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> codes.
00529 
00530 --*/
00531 
00532 {
00533     <a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a> FoundVad;
00534     KIRQL OldIrql;
00535     ULONG_PTR i;
00536     <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process;
00537     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
00538     PFN_NUMBER PageFrameIndex;
00539     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
00540     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00541     <a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html">MMPTE_FLUSH_LIST</a> PteFlushList;
00542     PVOID PoolArea;
00543     PVOID *PoolVirtualArea;
00544     PPFN_NUMBER FrameList;
00545     ULONG BitMapIndex;
00546     PVOID StackVirtualArray[<a class="code" href="../../d8/d5/physical_8c.html#a0">COPY_STACK_SIZE</a>];
00547     ULONG_PTR StackArray[<a class="code" href="../../d8/d5/physical_8c.html#a0">COPY_STACK_SIZE</a>];
00548     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> OldPteContents;
00549     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> NewPteContents;
00550     ULONG_PTR NumberOfBytes;
00551     PRTL_BITMAP <a class="code" href="../../d2/d1/structBitMap.html">BitMap</a>;
00552     PLIST_ENTRY NextEntry;
00553     <a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html">PMI_PHYSICAL_VIEW</a> PhysicalView;
00554     PVOID VirtualAddress;
00555 
00556     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (KeGetCurrentIrql() == PASSIVE_LEVEL);
00557 
00558     <span class="keywordflow">if</span> (NumberOfPages &gt; (MAXULONG_PTR / <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>)) {
00559         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER_2;
00560     }
00561 
00562     <span class="comment">//</span>
00563     <span class="comment">// Carefully probe and capture the user virtual address array.</span>
00564     <span class="comment">//</span>
00565 
00566     PoolArea = (PVOID)&amp;StackArray[0];
00567     PoolVirtualArea = (PVOID)&amp;StackVirtualArray[0];
00568 
00569     NumberOfBytes = NumberOfPages * <span class="keyword">sizeof</span>(PVOID);
00570 
00571     <span class="keywordflow">if</span> (NumberOfPages &gt; <a class="code" href="../../d8/d5/physical_8c.html#a0">COPY_STACK_SIZE</a>) {
00572         PoolVirtualArea = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a> (NonPagedPool,
00573                                                  NumberOfBytes,
00574                                                  'wRmM');
00575 
00576         <span class="keywordflow">if</span> (PoolVirtualArea == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00577             <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
00578         }
00579     }
00580 
00581     <span class="keywordflow">try</span> {
00582         <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a> (VirtualAddresses,
00583                       NumberOfBytes,
00584                       <span class="keyword">sizeof</span>(PVOID));
00585 
00586         RtlCopyMemory (PoolVirtualArea, VirtualAddresses, NumberOfBytes);
00587 
00588     } except(EXCEPTION_EXECUTE_HANDLER) {
00589         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = GetExceptionCode();
00590         <span class="keywordflow">goto</span> ErrorReturn2;
00591     }
00592 
00593     <span class="comment">//</span>
00594     <span class="comment">// Carefully probe and capture the user PFN array.</span>
00595     <span class="comment">//</span>
00596 
00597     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(UserPfnArray)) {
00598 
00599         NumberOfBytes = NumberOfPages * <span class="keyword">sizeof</span>(ULONG_PTR);
00600 
00601         <span class="keywordflow">if</span> (NumberOfPages &gt; <a class="code" href="../../d8/d5/physical_8c.html#a0">COPY_STACK_SIZE</a>) {
00602             PoolArea = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a> (NonPagedPool,
00603                                               NumberOfBytes,
00604                                               'wRmM');
00605     
00606             <span class="keywordflow">if</span> (PoolArea == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00607                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INSUFFICIENT_RESOURCES;
00608                 <span class="keywordflow">goto</span> ErrorReturn2;
00609             }
00610         }
00611     
00612         <span class="comment">//</span>
00613         <span class="comment">// Capture the specified page frame numbers.</span>
00614         <span class="comment">//</span>
00615 
00616         <span class="keywordflow">try</span> {
00617             <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a> (UserPfnArray,
00618                           NumberOfBytes,
00619                           <span class="keyword">sizeof</span>(ULONG_PTR));
00620 
00621             RtlCopyMemory (PoolArea, UserPfnArray, NumberOfBytes);
00622 
00623         } except(EXCEPTION_EXECUTE_HANDLER) {
00624             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = GetExceptionCode();
00625             <span class="keywordflow">goto</span> ErrorReturn2;
00626         }
00627     }
00628 
00629     Process = <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>();
00630 
00631     <span class="comment">//</span>
00632     <span class="comment">// The AWE lock protects insertion/removal of Vads into each process'</span>
00633     <span class="comment">// PhysicalVadList.  It also protects creation/deletion and adds/removes</span>
00634     <span class="comment">// of the VadPhysicalPagesBitMap.  Finally, it protects the PFN</span>
00635     <span class="comment">// modifications for pages in the bitmap.</span>
00636     <span class="comment">//</span>
00637 
00638     PhysicalView = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00639 
00640     <a class="code" href="../../d4/d8/mi_8h.html#a133">LOCK_AWE</a> (Process, OldIrql);
00641 
00642     <span class="comment">//</span>
00643     <span class="comment">// The physical pages bitmap must exist.</span>
00644     <span class="comment">//</span>
00645 
00646     <a class="code" href="../../d8/d9/tbitmap_8c.html#a2">BitMap</a> = Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o88">VadPhysicalPagesBitMap</a>;
00647 
00648     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d9/tbitmap_8c.html#a2">BitMap</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00649         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_PARAMETER_1;
00650         <span class="keywordflow">goto</span> ErrorReturn;
00651     }
00652 
00653     <span class="comment">//</span>
00654     <span class="comment">// Note that the PFN lock is not needed to traverse this list (even though</span>
00655     <span class="comment">// MmProbeAndLockPages uses it), because all modifications are made while</span>
00656     <span class="comment">// also holding the AWE lock.</span>
00657     <span class="comment">//</span>
00658     <span class="comment">// The PhysicalVadList should typically have just one entry - the view</span>
00659     <span class="comment">// we're looking for, so this traverse should be quick.</span>
00660     <span class="comment">//</span>
00661 
00662     <span class="keywordflow">for</span> (i = 0; i &lt; NumberOfPages; i += 1) {
00663 
00664         VirtualAddress = PoolVirtualArea[i];
00665 
00666         <span class="keywordflow">if</span> (PhysicalView != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00667             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PhysicalView-&gt;<a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html#o1">Vad</a>-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.VadFlags.UserPhysicalPages == 1);
00668             <span class="keywordflow">if</span> ((VirtualAddress &gt;= (PVOID)PhysicalView-&gt;<a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html#o2">StartVa</a>) &amp;&amp;
00669                 (VirtualAddress &lt;= (PVOID)PhysicalView-&gt;<a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html#o3">EndVa</a>)) {
00670                     <span class="keywordflow">continue</span>;
00671             }
00672         }
00673 
00674         FoundVad = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00675         NextEntry = Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o61">PhysicalVadList</a>.Flink;
00676         <span class="keywordflow">while</span> (NextEntry != &amp;Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o61">PhysicalVadList</a>) {
00677     
00678             PhysicalView = CONTAINING_RECORD(NextEntry,
00679                                              <a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html">MI_PHYSICAL_VIEW</a>,
00680                                              ListEntry);
00681     
00682             <span class="keywordflow">if</span> (PhysicalView-&gt;<a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html#o1">Vad</a>-&gt;<a class="code" href="../../d6/d6/struct__MMVAD.html#o7">u</a>.VadFlags.UserPhysicalPages == 1) {
00683     
00684                 <span class="keywordflow">if</span> ((VirtualAddress &gt;= (PVOID)PhysicalView-&gt;<a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html#o2">StartVa</a>) &amp;&amp;
00685                     (VirtualAddress &lt;= (PVOID)PhysicalView-&gt;<a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html#o3">EndVa</a>)) {
00686     
00687                         FoundVad = PhysicalView-&gt;<a class="code" href="../../d3/d9/struct__MI__PHYSICAL__VIEW.html#o1">Vad</a>;
00688                         <span class="keywordflow">break</span>;
00689                 }
00690             }
00691     
00692             NextEntry = NextEntry-&gt;Flink;
00693             <span class="keywordflow">continue</span>;
00694         }
00695     
00696         <span class="keywordflow">if</span> (FoundVad == (<a class="code" href="../../d6/d6/struct__MMVAD.html">PMMVAD</a>)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00697     
00698             <span class="comment">//</span>
00699             <span class="comment">// No virtual address is reserved at the specified base address,</span>
00700             <span class="comment">// return an error.</span>
00701             <span class="comment">//</span>
00702     
00703             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_PARAMETER_1;
00704             <span class="keywordflow">goto</span> ErrorReturn;
00705         }
00706     }
00707 
00708     <span class="comment">//</span>
00709     <span class="comment">// Ensure the PFN element corresponding to each specified page is owned</span>
00710     <span class="comment">// by the specified VAD.</span>
00711     <span class="comment">//</span>
00712     <span class="comment">// Since this ownership can only be changed while holding this process'</span>
00713     <span class="comment">// working set lock, the PFN can be scanned here without holding the PFN</span>
00714     <span class="comment">// lock.</span>
00715     <span class="comment">//</span>
00716     <span class="comment">// Note the PFN lock is not needed because any race with MmProbeAndLockPages</span>
00717     <span class="comment">// can only result in the I/O going to the old page or the new page.</span>
00718     <span class="comment">// If the user breaks the rules, the PFN database (and any pages being</span>
00719     <span class="comment">// windowed here) are still protected because of the reference counts</span>
00720     <span class="comment">// on the pages with inprogress I/O.  This is possible because NO pages</span>
00721     <span class="comment">// are actually freed here - they are just windowed.</span>
00722     <span class="comment">//</span>
00723 
00724     PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a> = 0;
00725 
00726     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(UserPfnArray)) {
00727 
00728         <span class="comment">//</span>
00729         <span class="comment">// By keeping the PFN bitmap in the VAD (instead of in the PFN</span>
00730         <span class="comment">// database itself), a few benefits are realized:</span>
00731         <span class="comment">//</span>
00732         <span class="comment">// 1. No need to acquire the PFN lock here.</span>
00733         <span class="comment">// 2. Faster handling of PFN databases with holes.</span>
00734         <span class="comment">// 3. Transparent support for dynamic PFN database growth.</span>
00735         <span class="comment">// 4. Less nonpaged memory is used (for the bitmap vs adding a</span>
00736         <span class="comment">//    field to the PFN) on systems with no unused pack space in</span>
00737         <span class="comment">//    the PFN database, presuming not many of these VADs get</span>
00738         <span class="comment">//    allocated.</span>
00739         <span class="comment">//</span>
00740 
00741         <span class="comment">//</span>
00742         <span class="comment">// The first pass here ensures all the frames are secure.</span>
00743         <span class="comment">//</span>
00744 
00745         <span class="comment">//</span>
00746         <span class="comment">// N.B.  This implies that PFN_NUMBER is always ULONG_PTR in width</span>
00747         <span class="comment">//       as PFN_NUMBER is not exposed to application code today.</span>
00748         <span class="comment">//</span>
00749 
00750         FrameList = (PPFN_NUMBER)PoolArea;
00751 
00752         <span class="keywordflow">for</span> (i = 0; i &lt; NumberOfPages; i += 1, FrameList += 1) {
00753 
00754             PageFrameIndex = *FrameList;
00755 
00756             <span class="comment">//</span>
00757             <span class="comment">// Zero entries are treated as a command to unmap.</span>
00758             <span class="comment">//</span>
00759 
00760             <span class="keywordflow">if</span> (PageFrameIndex == 0) {
00761                 <span class="keywordflow">continue</span>;
00762             }
00763 
00764             <span class="comment">//</span>
00765             <span class="comment">// Frames past the end of the bitmap are not allowed.</span>
00766             <span class="comment">//</span>
00767 
00768             BitMapIndex = <a class="code" href="../../d8/d5/physical_8c.html#a5">MI_FRAME_TO_BITMAP_INDEX</a>(PageFrameIndex);
00769 
00770 <span class="preprocessor">#if defined (_WIN64)</span>
00771 <span class="preprocessor"></span>            <span class="comment">//</span>
00772             <span class="comment">// Ensure the frame is a 32-bit number.</span>
00773             <span class="comment">//</span>
00774 
00775             <span class="keywordflow">if</span> (BitMapIndex != PageFrameIndex) {
00776                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_CONFLICTING_ADDRESSES;
00777                 <span class="keywordflow">goto</span> ErrorReturn0;
00778             }
00779 <span class="preprocessor">#endif</span>
00780 <span class="preprocessor"></span>            
00781             <span class="keywordflow">if</span> (BitMapIndex &gt;= <a class="code" href="../../d8/d9/tbitmap_8c.html#a2">BitMap</a>-&gt;SizeOfBitMap) {
00782                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_CONFLICTING_ADDRESSES;
00783                 <span class="keywordflow">goto</span> ErrorReturn0;
00784             }
00785 
00786             <span class="comment">//</span>
00787             <span class="comment">// Frames not in the bitmap are not allowed.</span>
00788             <span class="comment">//</span>
00789 
00790             <span class="keywordflow">if</span> (RtlCheckBit (BitMap, BitMapIndex) == 0) {
00791                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_CONFLICTING_ADDRESSES;
00792                 <span class="keywordflow">goto</span> ErrorReturn0;
00793             }
00794 
00795             <span class="comment">//</span>
00796             <span class="comment">// The frame must not be already mapped anywhere.</span>
00797             <span class="comment">// Or be passed in twice in different spots in the array.</span>
00798             <span class="comment">//</span>
00799 
00800             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PageFrameIndex);
00801 
00802             <span class="keywordflow">if</span> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount != 1) {
00803                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_INVALID_PARAMETER_3;
00804                 <span class="keywordflow">goto</span> ErrorReturn0;
00805             }
00806 
00807             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (MI_PFN_IS_AWE (Pfn1));
00808 
00809             <span class="comment">//</span>
00810             <span class="comment">// Mark the frame as "about to be mapped".</span>
00811             <span class="comment">//</span>
00812 
00813             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount = 3;
00814 
00815             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PageFrameIndex &gt;= LOWEST_USABLE_PHYSICAL_PAGE);
00816         }
00817 
00818         <span class="comment">//</span>
00819         <span class="comment">// This pass actually inserts them all into the page table pages and</span>
00820         <span class="comment">// the TBs now that we know the frames are good.</span>
00821         <span class="comment">//</span>
00822 
00823         FrameList = (PPFN_NUMBER)PoolArea;
00824 
00825         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a105">MI_MAKE_VALID_PTE</a> (NewPteContents,
00826                            PageFrameIndex,
00827                            MM_READWRITE,
00828                            0);
00829 
00830         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a112">MI_SET_PTE_DIRTY</a> (NewPteContents);
00831 
00832         <span class="keywordflow">for</span> (i = 0; i &lt; NumberOfPages; i += 1, FrameList += 1) {
00833 
00834             PageFrameIndex = *FrameList;
00835 
00836             VirtualAddress = PoolVirtualArea[i];
00837             PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (VirtualAddress);
00838             OldPteContents = *PointerPte;
00839 
00840             <span class="comment">//</span>
00841             <span class="comment">// Flush the TB entry for this page if it's valid.</span>
00842             <span class="comment">//</span>
00843         
00844             <span class="keywordflow">if</span> (OldPteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1) {
00845                 Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (OldPteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
00846                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> != (<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)0);
00847                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount == 2);
00848                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (MI_PFN_IS_AWE (Pfn1));
00849                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount -= 1;
00850                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> = (<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)0;
00851 
00852                 <span class="keywordflow">if</span> (PageFrameIndex != 0) {
00853 
00854                     NewPteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber = PageFrameIndex;
00855 <span class="preprocessor">#if defined (_X86PAE_)</span>
00856 <span class="preprocessor"></span>                    (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)KeInterlockedSwapPte ((PHARDWARE_PTE)PointerPte,
00857                                                 (PHARDWARE_PTE)&amp;NewPteContents);
00858 <span class="preprocessor">#else</span>
00859 <span class="preprocessor"></span>                    *PointerPte = NewPteContents;
00860 <span class="preprocessor">#endif</span>
00861 <span class="preprocessor"></span>                }
00862                 <span class="keywordflow">else</span> {
00863                     <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a187">MI_WRITE_INVALID_PTE</a> (PointerPte, ZeroPte);
00864                 }
00865     
00866                 <span class="keywordflow">if</span> (PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a> != <a class="code" href="../../d4/d8/mi_8h.html#a34">MM_MAXIMUM_FLUSH_COUNT</a>) {
00867                     PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o2">FlushVa</a>[PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a>] = VirtualAddress;
00868                     PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o1">FlushPte</a>[PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a>] = PointerPte;
00869                     PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a> += 1;
00870                 }
00871             }
00872             <span class="keywordflow">else</span> {
00873                 <span class="keywordflow">if</span> (PageFrameIndex != 0) {
00874                     NewPteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber = PageFrameIndex;
00875                     <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a186">MI_WRITE_VALID_PTE</a> (PointerPte, NewPteContents);
00876                 }
00877             }
00878 
00879             <span class="keywordflow">if</span> (PageFrameIndex != 0) {
00880                 Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PageFrameIndex);
00881                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> == (<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)0);
00882                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount == 3);
00883                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount = 2;
00884                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> = PointerPte;
00885             }
00886         }
00887     }
00888     <span class="keywordflow">else</span> {
00889 
00890         <span class="comment">//</span>
00891         <span class="comment">// Set the specified virtual address range to no access.</span>
00892         <span class="comment">//</span>
00893 
00894         <span class="keywordflow">for</span> (i = 0; i &lt; NumberOfPages; i += 1) {
00895 
00896             VirtualAddress = PoolVirtualArea[i];
00897             PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (VirtualAddress);
00898             OldPteContents = *PointerPte;
00899     
00900             <span class="comment">//</span>
00901             <span class="comment">// Flush the TB entry for this page if it's valid.</span>
00902             <span class="comment">//</span>
00903         
00904             <span class="keywordflow">if</span> (OldPteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1) {
00905 
00906                 Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (OldPteContents.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
00907                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> != (<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)0);
00908                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount == 2);
00909                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (MI_PFN_IS_AWE (Pfn1));
00910                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount -= 1;
00911                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> = (<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)0;
00912 
00913                 <span class="keywordflow">if</span> (PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a> != <a class="code" href="../../d4/d8/mi_8h.html#a34">MM_MAXIMUM_FLUSH_COUNT</a>) {
00914                     PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o2">FlushVa</a>[PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a>] = VirtualAddress;
00915                     PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o1">FlushPte</a>[PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a>] = PointerPte;
00916                     PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a> += 1;
00917                 }
00918             }
00919 
00920             <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a187">MI_WRITE_INVALID_PTE</a> (PointerPte, ZeroPte);
00921         }
00922     }
00923 
00924     <span class="comment">//</span>
00925     <span class="comment">// Flush the TB entries for these pages.  Note ZeroPte is only used</span>
00926     <span class="comment">// when the FlushPte[0] field is nonzero or if only a single PTE is</span>
00927     <span class="comment">// being flushed.</span>
00928     <span class="comment">//</span>
00929 
00930     <span class="keywordflow">if</span> (PteFlushList.<a class="code" href="../../d9/d4/struct__MMPTE__FLUSH__LIST.html#o0">Count</a> != 0) {
00931         <a class="code" href="../../d8/d5/physical_8c.html#a8">MiFlushUserPhysicalPteList</a> (&amp;PteFlushList);
00932     }
00933 
00934     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
00935 
00936 ErrorReturn:
00937 
00938     <a class="code" href="../../d4/d8/mi_8h.html#a134">UNLOCK_AWE</a> (Process, OldIrql);
00939 
00940 ErrorReturn2:
00941 
00942     <span class="keywordflow">if</span> (PoolArea != (PVOID)&amp;StackArray[0]) {
00943         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (PoolArea);
00944     }
00945 
00946     <span class="keywordflow">if</span> (PoolVirtualArea != (PVOID)&amp;StackVirtualArray[0]) {
00947         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (PoolVirtualArea);
00948     }
00949 
00950     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00951 
00952 ErrorReturn0:
00953 
00954     <span class="keywordflow">while</span> (i != 0) {
00955         FrameList -= 1;
00956         PageFrameIndex = *FrameList;
00957         <span class="keywordflow">if</span> (PageFrameIndex != 0) {
00958             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PageFrameIndex);
00959             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount == 3);
00960             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (MI_PFN_IS_AWE (Pfn1));
00961             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount = 1;
00962         }
00963         i -= 1;
00964     }
00965     <span class="keywordflow">goto</span> ErrorReturn;
00966 }

</div></pre>    </td>
  </tr>
</table>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="a7" doxytag="physical.c::MmVadPhysicalPages" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG_PTR <a class="el" href="../../d8/d5/physical_8c.html#a7">MmVadPhysicalPages</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d4/physical_8c-source.html#l00076">76</a> of file <a class="el" href="../../d9/d4/physical_8c-source.html">physical.c</a>.
<p>
Referenced by <a class="el" href="../../d9/d4/physical_8c-source.html#l02278">MiUpdateVadPhysicalPages()</a>, <a class="el" href="../../d9/d4/physical_8c-source.html#l00970">NtAllocateUserPhysicalPages()</a>, and <a class="el" href="../../d9/d4/physical_8c-source.html#l01624">NtFreeUserPhysicalPages()</a>.    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:45:02 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
