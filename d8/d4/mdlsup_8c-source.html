<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: mdlsup.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>mdlsup.c</h1><a href="../../d7/d5/mdlsup_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1990  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    mdlsup.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module implements the Mdl support routines for the Cache subsystem.</span>
00012 <span class="comment"></span>
00013 <span class="comment">Author:</span>
00014 <span class="comment"></span>
00015 <span class="comment">    Tom Miller      [TomM]      4-May-1990</span>
00016 <span class="comment"></span>
00017 <span class="comment">Revision History:</span>
00018 <span class="comment"></span>
00019 <span class="comment">--*/</span>
00020 
00021 <span class="preprocessor">#include "<a class="code" href="../../d5/d5/cc_8h.html">cc.h</a>"</span>
00022 
00023 <span class="comment">//</span>
00024 <span class="comment">//  Debug Trace Level</span>
00025 <span class="comment">//</span>
00026 
<a name="l00027"></a><a class="code" href="../../d7/d5/mdlsup_8c.html#a0">00027</a> <span class="preprocessor">#define me                               (0x00000010)</span>
00028 <span class="preprocessor"></span>
00029 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00030"></a><a class="code" href="../../d4/d2/cache_8h.html#a78">00030</a> <a class="code" href="../../d4/d2/cache_8h.html#a78">CcMdlRead</a> (
00031     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00032     IN PLARGE_INTEGER FileOffset,
00033     IN ULONG Length,
00034     OUT <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> *MdlChain,
00035     OUT PIO_STATUS_BLOCK IoStatus
00036     )
00037 
00038 <span class="comment">/*++</span>
00039 <span class="comment"></span>
00040 <span class="comment">Routine Description:</span>
00041 <span class="comment"></span>
00042 <span class="comment">    This routine attempts to lock the specified file data in the cache</span>
00043 <span class="comment">    and return a description of it in an Mdl along with the correct</span>
00044 <span class="comment">    I/O status.  It is *not* safe to call this routine from Dpc level.</span>
00045 <span class="comment"></span>
00046 <span class="comment">    This routine is synchronous, and raises on errors.</span>
00047 <span class="comment"></span>
00048 <span class="comment">    As each call returns, the pages described by the Mdl are</span>
00049 <span class="comment">    locked in memory, but not mapped in system space.  If the caller</span>
00050 <span class="comment">    needs the pages mapped in system space, then it must map them.</span>
00051 <span class="comment"></span>
00052 <span class="comment">    Note that each call is a "single shot" which should be followed by</span>
00053 <span class="comment">    a call to CcMdlReadComplete.  To resume an Mdl-based transfer, the</span>
00054 <span class="comment">    caller must form one or more subsequent calls to CcMdlRead with</span>
00055 <span class="comment">    appropriately adjusted parameters.</span>
00056 <span class="comment"></span>
00057 <span class="comment">Arguments:</span>
00058 <span class="comment"></span>
00059 <span class="comment">    FileObject - Pointer to the file object for a file which was</span>
00060 <span class="comment">                 opened with NO_INTERMEDIATE_BUFFERING clear, i.e., for</span>
00061 <span class="comment">                 which CcInitializeCacheMap was called by the file system.</span>
00062 <span class="comment"></span>
00063 <span class="comment">    FileOffset - Byte offset in file for desired data.</span>
00064 <span class="comment"></span>
00065 <span class="comment">    Length - Length of desired data in bytes.</span>
00066 <span class="comment"></span>
00067 <span class="comment">    MdlChain - On output it returns a pointer to an Mdl chain describing</span>
00068 <span class="comment">               the desired data.  Note that even if FALSE is returned,</span>
00069 <span class="comment">               one or more Mdls may have been allocated, as may be ascertained</span>
00070 <span class="comment">               by the IoStatus.Information field (see below).</span>
00071 <span class="comment"></span>
00072 <span class="comment">    IoStatus - Pointer to standard I/O status block to receive the status</span>
00073 <span class="comment">               for the transfer.  (STATUS_SUCCESS guaranteed for cache</span>
00074 <span class="comment">               hits, otherwise the actual I/O status is returned.)  The</span>
00075 <span class="comment">               I/O Information Field indicates how many bytes have been</span>
00076 <span class="comment">               successfully locked down in the Mdl Chain.</span>
00077 <span class="comment"></span>
00078 <span class="comment">Return Value:</span>
00079 <span class="comment"></span>
00080 <span class="comment">    None</span>
00081 <span class="comment"></span>
00082 <span class="comment">Raises:</span>
00083 <span class="comment"></span>
00084 <span class="comment">    STATUS_INSUFFICIENT_RESOURCES - If a pool allocation failure occurs.</span>
00085 <span class="comment"></span>
00086 <span class="comment">--*/</span>
00087 
00088 {
00089     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
00090     <a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html">PPRIVATE_CACHE_MAP</a> PrivateCacheMap;
00091     PVOID CacheBuffer;
00092     LARGE_INTEGER FOffset;
00093     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> Mdl = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00094     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MdlTemp;
00095     <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a> Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
00096     ULONG SavedState = 0;
00097     ULONG OriginalLength = Length;
00098     ULONG Information = 0;
00099     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> Vacb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00100     ULONG SavedMissCounter = 0;
00101 
00102     KIRQL OldIrql;
00103     ULONG ActivePage;
00104     ULONG PageIsDirty;
00105     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> ActiveVacb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00106 
00107     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcMdlRead\n"</span>, 0 );
00108     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    FileObject = %08lx\n"</span>, FileObject );
00109     <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>(0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    FileOffset = %08lx, %08lx\n"</span>, FileOffset-&gt;LowPart,
00110                                                           FileOffset-&gt;HighPart );
00111     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    Length = %08lx\n"</span>, Length );
00112 
00113     <span class="comment">//</span>
00114     <span class="comment">//  Save the current readahead hints.</span>
00115     <span class="comment">//</span>
00116 
00117     <a class="code" href="../../d2/d1/mm_8h.html#a19">MmSavePageFaultReadAhead</a>( Thread, &amp;SavedState );
00118 
00119     <span class="comment">//</span>
00120     <span class="comment">//  Get pointer to SharedCacheMap.</span>
00121     <span class="comment">//</span>
00122 
00123     SharedCacheMap = FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap;
00124     PrivateCacheMap = FileObject-&gt;PrivateCacheMap;
00125 
00126     <span class="comment">//</span>
00127     <span class="comment">//  See if we have an active Vacb, that we need to free.</span>
00128     <span class="comment">//</span>
00129 
00130     <a class="code" href="../../d5/d5/cc_8h.html#a82">GetActiveVacb</a>( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, PageIsDirty );
00131 
00132     <span class="comment">//</span>
00133     <span class="comment">//  If there is an end of a page to be zeroed, then free that page now,</span>
00134     <span class="comment">//  so we don't send Greg the uninitialized data...</span>
00135     <span class="comment">//</span>
00136 
00137     <span class="keywordflow">if</span> ((ActiveVacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) || (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
00138 
00139         <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );
00140     }
00141 
00142     <span class="comment">//</span>
00143     <span class="comment">//  If read ahead is enabled, then do the read ahead here so it</span>
00144     <span class="comment">//  overlaps with the copy (otherwise we will do it below).</span>
00145     <span class="comment">//  Note that we are assuming that we will not get ahead of our</span>
00146     <span class="comment">//  current transfer - if read ahead is working it should either</span>
00147     <span class="comment">//  already be in memory or else underway.</span>
00148     <span class="comment">//</span>
00149 
00150     <span class="keywordflow">if</span> (PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o13">ReadAheadEnabled</a> &amp;&amp; (PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o8">ReadAheadLength</a>[1] == 0)) {
00151         <a class="code" href="../../d4/d2/cache_8h.html#a84">CcScheduleReadAhead</a>( FileObject, FileOffset, Length );
00152     }
00153 
00154     <span class="comment">//</span>
00155     <span class="comment">//  Increment performance counters</span>
00156     <span class="comment">//</span>
00157 
00158     <a class="code" href="../../d5/d2/cachedat_8c.html#a66">CcMdlReadWait</a> += 1;
00159 
00160     <span class="comment">//</span>
00161     <span class="comment">//  This is not an exact solution, but when IoPageRead gets a miss,</span>
00162     <span class="comment">//  it cannot tell whether it was CcCopyRead or CcMdlRead, but since</span>
00163     <span class="comment">//  the miss should occur very soon, by loading the pointer here</span>
00164     <span class="comment">//  probably the right counter will get incremented, and in any case,</span>
00165     <span class="comment">//  we hope the errrors average out!</span>
00166     <span class="comment">//</span>
00167 
00168     <a class="code" href="../../d5/d2/cachedat_8c.html#a75">CcMissCounter</a> = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a68">CcMdlReadWaitMiss</a>;
00169 
00170     FOffset = *FileOffset;
00171 
00172     <span class="comment">//</span>
00173     <span class="comment">//  Check for read past file size, the caller must filter this case out.</span>
00174     <span class="comment">//</span>
00175 
00176     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( ( FOffset.QuadPart + (LONGLONG)Length ) &lt;= SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o3">FileSize</a>.QuadPart );
00177 
00178     <span class="comment">//</span>
00179     <span class="comment">//  Put try-finally around the loop to deal with any exceptions</span>
00180     <span class="comment">//</span>
00181 
00182     <span class="keywordflow">try</span> {
00183 
00184         <span class="comment">//</span>
00185         <span class="comment">//  Not all of the transfer will come back at once, so we have to loop</span>
00186         <span class="comment">//  until the entire transfer is complete.</span>
00187         <span class="comment">//</span>
00188 
00189         <span class="keywordflow">while</span> (Length != 0) {
00190 
00191             ULONG ReceivedLength;
00192             LARGE_INTEGER BeyondLastByte;
00193 
00194             <span class="comment">//</span>
00195             <span class="comment">//  Map the data and read it in (if necessary) with the</span>
00196             <span class="comment">//  MmProbeAndLockPages call below.</span>
00197             <span class="comment">//</span>
00198 
00199             CacheBuffer = <a class="code" href="../../d5/d3/vacbsup_8c.html#a15">CcGetVirtualAddress</a>( SharedCacheMap,
00200                                                FOffset,
00201                                                &amp;Vacb,
00202                                                &amp;ReceivedLength );
00203 
00204             <span class="keywordflow">if</span> (ReceivedLength &gt; Length) {
00205                 ReceivedLength = Length;
00206             }
00207 
00208             BeyondLastByte.QuadPart = FOffset.QuadPart + (LONGLONG)ReceivedLength;
00209 
00210             <span class="comment">//</span>
00211             <span class="comment">//  Now attempt to allocate an Mdl to describe the mapped data.</span>
00212             <span class="comment">//</span>
00213 
00214             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"IoAllocateMdl:\n"</span>, 0 );
00215             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"    BaseAddress = %08lx\n"</span>, CacheBuffer );
00216             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"    Length = %08lx\n"</span>, ReceivedLength );
00217 
00218             Mdl = <a class="code" href="../../d4/d6/iosubs_8c.html#a19">IoAllocateMdl</a>( CacheBuffer,
00219                                  ReceivedLength,
00220                                  <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00221                                  <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00222                                  <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00223 
00224             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"    &lt;Mdl = %08lx\n"</span>, Mdl );
00225 
00226             <span class="keywordflow">if</span> (Mdl == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00227                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, 0, <span class="stringliteral">"Failed to allocate Mdl\n"</span>, 0 );
00228 
00229                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INSUFFICIENT_RESOURCES );
00230             }
00231 
00232             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"MmProbeAndLockPages:\n"</span>, 0 );
00233             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"    Mdl = %08lx\n"</span>, Mdl );
00234 
00235             <span class="comment">//</span>
00236             <span class="comment">//  Set to see if the miss counter changes in order to</span>
00237             <span class="comment">//  detect when we should turn on read ahead.</span>
00238             <span class="comment">//</span>
00239 
00240             SavedMissCounter += <a class="code" href="../../d5/d2/cachedat_8c.html#a68">CcMdlReadWaitMiss</a>;
00241 
00242             <a class="code" href="../../d2/d1/mm_8h.html#a20">MmSetPageFaultReadAhead</a>( Thread, <a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a>( CacheBuffer, ReceivedLength ) - 1);
00243             <a class="code" href="../../d5/d6/iosup_8c.html#a41">MmProbeAndLockPages</a>( Mdl, <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>, <a class="code" href="../../d2/d1/mm_8h.html#a344a168">IoReadAccess</a> );
00244 
00245             SavedMissCounter -= <a class="code" href="../../d5/d2/cachedat_8c.html#a68">CcMdlReadWaitMiss</a>;
00246 
00247             <span class="comment">//</span>
00248             <span class="comment">//  Unmap the data now, now that the pages are locked down.</span>
00249             <span class="comment">//</span>
00250 
00251             <a class="code" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a>( Vacb );
00252             Vacb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00253 
00254             <span class="comment">//</span>
00255             <span class="comment">//  Now link the Mdl into the caller's chain</span>
00256             <span class="comment">//</span>
00257 
00258             <span class="keywordflow">if</span> ( *MdlChain == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
00259                 *MdlChain = Mdl;
00260             } <span class="keywordflow">else</span> {
00261                 MdlTemp = CONTAINING_RECORD( *MdlChain, <a class="code" href="../../d6/d7/struct__MDL.html">MDL</a>, Next );
00262                 <span class="keywordflow">while</span> (MdlTemp-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o0">Next</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00263                     MdlTemp = MdlTemp-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o0">Next</a>;
00264                 }
00265                 MdlTemp-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o0">Next</a> = Mdl;
00266             }
00267             Mdl = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00268 
00269             <span class="comment">//</span>
00270             <span class="comment">//  Assume we did not get all the data we wanted, and set FOffset</span>
00271             <span class="comment">//  to the end of the returned data.</span>
00272             <span class="comment">//</span>
00273 
00274             FOffset = BeyondLastByte;
00275 
00276             <span class="comment">//</span>
00277             <span class="comment">//  Update number of bytes transferred.</span>
00278             <span class="comment">//</span>
00279 
00280             Information += ReceivedLength;
00281 
00282             <span class="comment">//</span>
00283             <span class="comment">//  Calculate length left to transfer.</span>
00284             <span class="comment">//</span>
00285 
00286             Length -= ReceivedLength;
00287         }
00288     }
00289     finally {
00290 
00291         <a class="code" href="../../d5/d2/cachedat_8c.html#a75">CcMissCounter</a> = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a43">CcThrowAway</a>;
00292 
00293         <span class="comment">//</span>
00294         <span class="comment">//  Restore the readahead hints.</span>
00295         <span class="comment">//</span>
00296 
00297         <a class="code" href="../../d2/d1/mm_8h.html#a21">MmResetPageFaultReadAhead</a>( Thread, SavedState );
00298 
00299         <span class="keywordflow">if</span> (AbnormalTermination()) {
00300 
00301             <span class="comment">//</span>
00302             <span class="comment">//  We may have failed to allocate an Mdl while still having</span>
00303             <span class="comment">//  data mapped.</span>
00304             <span class="comment">//</span>
00305 
00306             <span class="keywordflow">if</span> (Vacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00307                 <a class="code" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a>( Vacb );
00308             }
00309 
00310             <span class="keywordflow">if</span> (Mdl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00311                 <a class="code" href="../../d4/d6/iosubs_8c.html#a65">IoFreeMdl</a>( Mdl );
00312             }
00313 
00314             <span class="comment">//</span>
00315             <span class="comment">//  Otherwise loop to deallocate the Mdls</span>
00316             <span class="comment">//</span>
00317 
00318             <span class="keywordflow">while</span> (*MdlChain != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00319                 MdlTemp = (*MdlChain)-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o0">Next</a>;
00320 
00321                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"MmUnlockPages/IoFreeMdl:\n"</span>, 0 );
00322                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"    Mdl = %08lx\n"</span>, *MdlChain );
00323 
00324                 <a class="code" href="../../d5/d6/iosup_8c.html#a45">MmUnlockPages</a>( *MdlChain );
00325                 <a class="code" href="../../d4/d6/iosubs_8c.html#a65">IoFreeMdl</a>( *MdlChain );
00326 
00327                 *MdlChain = MdlTemp;
00328             }
00329 
00330             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcMdlRead -&gt; Unwinding\n"</span>, 0 );
00331 
00332         }
00333         <span class="keywordflow">else</span> {
00334 
00335             <span class="comment">//</span>
00336             <span class="comment">//  Now enable read ahead if it looks like we got any misses, and do</span>
00337             <span class="comment">//  the first one.</span>
00338             <span class="comment">//</span>
00339 
00340             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( FileObject-&gt;Flags, <a class="code" href="../../d0/d5/io_8h.html#a170">FO_RANDOM_ACCESS</a> ) &amp;&amp;
00341                 !PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o13">ReadAheadEnabled</a> &amp;&amp;
00342                 (SavedMissCounter != 0)) {
00343 
00344                 PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o13">ReadAheadEnabled</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00345                 <a class="code" href="../../d4/d2/cache_8h.html#a84">CcScheduleReadAhead</a>( FileObject, FileOffset, OriginalLength );
00346             }
00347 
00348             <span class="comment">//</span>
00349             <span class="comment">//  Now that we have described our desired read ahead, let's</span>
00350             <span class="comment">//  shift the read history down.</span>
00351             <span class="comment">//</span>
00352 
00353             PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o3">FileOffset1</a> = PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o5">FileOffset2</a>;
00354             PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o4">BeyondLastByte1</a> = PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o6">BeyondLastByte2</a>;
00355             PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o5">FileOffset2</a> = *FileOffset;
00356             PrivateCacheMap-&gt;<a class="code" href="../../d7/d9/struct__PRIVATE__CACHE__MAP.html#o6">BeyondLastByte2</a>.QuadPart =
00357                                 FileOffset-&gt;QuadPart + (LONGLONG)OriginalLength;
00358 
00359             IoStatus-&gt;Status = STATUS_SUCCESS;
00360             IoStatus-&gt;Information = Information;
00361         }
00362     }
00363 
00364 
00365     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    &lt;MdlChain = %08lx\n"</span>, *MdlChain );
00366     <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>(0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    &lt;IoStatus = %08lx, %08lx\n"</span>, IoStatus-&gt;Status,
00367                                                          IoStatus-&gt;Information );
00368     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcMdlRead -&gt; VOID\n"</span>, 0 );
00369 
00370     <span class="keywordflow">return</span>;
00371 }
00372 
00373 
00374 <span class="comment">//</span>
00375 <span class="comment">//  First we have the old routine which checks for an entry in the FastIo vector.</span>
00376 <span class="comment">//  This routine becomes obsolete for every component that compiles with the new</span>
00377 <span class="comment">//  definition of FsRtlMdlReadComplete in fsrtl.h.</span>
00378 <span class="comment">//</span>
00379 
00380 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00381"></a><a class="code" href="../../d4/d2/cache_8h.html#a79">00381</a> <a class="code" href="../../d4/d2/cache_8h.html#a79">CcMdlReadComplete</a> (
00382     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00383     IN <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MdlChain
00384     )
00385 
00386 {
00387     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject;
00388     <a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html">PFAST_IO_DISPATCH</a> FastIoDispatch;
00389 
00390     DeviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( FileObject );
00391     FastIoDispatch = DeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o3">DriverObject</a>-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o10">FastIoDispatch</a>;
00392 
00393     <span class="keywordflow">if</span> ((FastIoDispatch != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
00394         (FastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o0">SizeOfFastIoDispatch</a> &gt; FIELD_OFFSET(<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html">FAST_IO_DISPATCH</a>, MdlWriteComplete)) &amp;&amp;
00395         (FastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o17">MdlReadComplete</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
00396         FastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o17">MdlReadComplete</a>( FileObject, MdlChain, DeviceObject )) {
00397 
00398         NOTHING;
00399 
00400     } <span class="keywordflow">else</span> {
00401         <a class="code" href="../../d4/d2/cache_8h.html#a80">CcMdlReadComplete2</a>( FileObject, MdlChain );
00402     }
00403 }
00404 
00405 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00406"></a><a class="code" href="../../d4/d2/cache_8h.html#a80">00406</a> <a class="code" href="../../d4/d2/cache_8h.html#a80">CcMdlReadComplete2</a> (
00407     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00408     IN <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MdlChain
00409     )
00410 
00411 <span class="comment">/*++</span>
00412 <span class="comment"></span>
00413 <span class="comment">Routine Description:</span>
00414 <span class="comment"></span>
00415 <span class="comment">    This routine must be called at IPL0 after a call to CcMdlRead.  The</span>
00416 <span class="comment">    caller must simply supply the address of the MdlChain returned in</span>
00417 <span class="comment">    CcMdlRead.</span>
00418 <span class="comment"></span>
00419 <span class="comment">    This call does the following:</span>
00420 <span class="comment"></span>
00421 <span class="comment">        Deletes the MdlChain</span>
00422 <span class="comment"></span>
00423 <span class="comment">Arguments:</span>
00424 <span class="comment"></span>
00425 <span class="comment">    FileObject - Pointer to the file object for a file which was</span>
00426 <span class="comment">                 opened with NO_INTERMEDIATE_BUFFERING clear, i.e., for</span>
00427 <span class="comment">                 which CcInitializeCacheMap was called by the file system.</span>
00428 <span class="comment"></span>
00429 <span class="comment">    MdlChain - same as returned from corresponding call to CcMdlRead.</span>
00430 <span class="comment"></span>
00431 <span class="comment">Return Value:</span>
00432 <span class="comment"></span>
00433 <span class="comment">    None.</span>
00434 <span class="comment">--*/</span>
00435 
00436 {
00437     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MdlNext;
00438 
00439     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcMdlReadComplete\n"</span>, 0 );
00440     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    FileObject = %08lx\n"</span>, FileObject );
00441     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    MdlChain = %08lx\n"</span>, MdlChain );
00442 
00443     <span class="comment">//</span>
00444     <span class="comment">//  Deallocate the Mdls</span>
00445     <span class="comment">//</span>
00446 
00447     <span class="keywordflow">while</span> (MdlChain != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00448 
00449         MdlNext = MdlChain-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o0">Next</a>;
00450 
00451         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"MmUnlockPages/IoFreeMdl:\n"</span>, 0 );
00452         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"    Mdl = %08lx\n"</span>, MdlChain );
00453 
00454         <a class="code" href="../../d5/d6/iosup_8c.html#a45">MmUnlockPages</a>( MdlChain );
00455 
00456         <a class="code" href="../../d4/d6/iosubs_8c.html#a65">IoFreeMdl</a>( MdlChain );
00457 
00458         MdlChain = MdlNext;
00459     }
00460 
00461     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcMdlReadComplete -&gt; VOID\n"</span>, 0 );
00462 }
00463 
00464 
00465 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00466"></a><a class="code" href="../../d4/d2/cache_8h.html#a81">00466</a> <a class="code" href="../../d4/d2/cache_8h.html#a81">CcPrepareMdlWrite</a> (
00467     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00468     IN PLARGE_INTEGER FileOffset,
00469     IN ULONG Length,
00470     OUT <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> *MdlChain,
00471     OUT PIO_STATUS_BLOCK IoStatus
00472     )
00473 
00474 <span class="comment">/*++</span>
00475 <span class="comment"></span>
00476 <span class="comment">Routine Description:</span>
00477 <span class="comment"></span>
00478 <span class="comment">    This routine attempts to lock the specified file data in the cache</span>
00479 <span class="comment">    and return a description of it in an Mdl along with the correct</span>
00480 <span class="comment">    I/O status.  Pages to be completely overwritten may be satisfied</span>
00481 <span class="comment">    with emtpy pages.  It is *not* safe to call this routine from Dpc level.</span>
00482 <span class="comment"></span>
00483 <span class="comment">    This call is synchronous and raises on error.</span>
00484 <span class="comment"></span>
00485 <span class="comment">    When this call returns, the caller may immediately begin</span>
00486 <span class="comment">    to transfer data into the buffers via the Mdl.</span>
00487 <span class="comment"></span>
00488 <span class="comment">    When the call returns with TRUE, the pages described by the Mdl are</span>
00489 <span class="comment">    locked in memory, but not mapped in system space.  If the caller</span>
00490 <span class="comment">    needs the pages mapped in system space, then it must map them.</span>
00491 <span class="comment">    On the subsequent call to CcMdlWriteComplete the pages will be</span>
00492 <span class="comment">    unmapped if they were mapped, and in any case unlocked and the Mdl</span>
00493 <span class="comment">    deallocated.</span>
00494 <span class="comment"></span>
00495 <span class="comment">Arguments:</span>
00496 <span class="comment"></span>
00497 <span class="comment">    FileObject - Pointer to the file object for a file which was</span>
00498 <span class="comment">                 opened with NO_INTERMEDIATE_BUFFERING clear, i.e., for</span>
00499 <span class="comment">                 which CcInitializeCacheMap was called by the file system.</span>
00500 <span class="comment"></span>
00501 <span class="comment">    FileOffset - Byte offset in file for desired data.</span>
00502 <span class="comment"></span>
00503 <span class="comment">    Length - Length of desired data in bytes.</span>
00504 <span class="comment"></span>
00505 <span class="comment">    MdlChain - On output it returns a pointer to an Mdl chain describing</span>
00506 <span class="comment">               the desired data.  Note that even if FALSE is returned,</span>
00507 <span class="comment">               one or more Mdls may have been allocated, as may be ascertained</span>
00508 <span class="comment">               by the IoStatus.Information field (see below).</span>
00509 <span class="comment"></span>
00510 <span class="comment">    IoStatus - Pointer to standard I/O status block to receive the status</span>
00511 <span class="comment">               for the in-transfer of the data.  (STATUS_SUCCESS guaranteed</span>
00512 <span class="comment">               for cache hits, otherwise the actual I/O status is returned.)</span>
00513 <span class="comment">               The I/O Information Field indicates how many bytes have been</span>
00514 <span class="comment">               successfully locked down in the Mdl Chain.</span>
00515 <span class="comment"></span>
00516 <span class="comment">Return Value:</span>
00517 <span class="comment"></span>
00518 <span class="comment">    None</span>
00519 <span class="comment"></span>
00520 <span class="comment">--*/</span>
00521 
00522 {
00523     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
00524     PVOID CacheBuffer;
00525     LARGE_INTEGER FOffset;
00526     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> Mdl = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00527     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MdlTemp;
00528     LARGE_INTEGER Temp;
00529     ULONG SavedState = 0;
00530     ULONG ZeroFlags = 0;
00531     ULONG Information = 0;
00532 
00533     KIRQL OldIrql;
00534     ULONG ActivePage;
00535     ULONG PageIsDirty;
00536     <a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> Vacb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00537 
00538     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcPrepareMdlWrite\n"</span>, 0 );
00539     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    FileObject = %08lx\n"</span>, FileObject );
00540     <a class="code" href="../../d5/d5/cc_8h.html#a92">DebugTrace2</a>(0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    FileOffset = %08lx, %08lx\n"</span>, FileOffset-&gt;LowPart,
00541                                                           FileOffset-&gt;HighPart );
00542     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    Length = %08lx\n"</span>, Length );
00543 
00544     <span class="comment">//</span>
00545     <span class="comment">//  Get pointer to SharedCacheMap.</span>
00546     <span class="comment">//</span>
00547 
00548     SharedCacheMap = FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap;
00549 
00550     <span class="comment">//</span>
00551     <span class="comment">//  See if we have an active Vacb, that we need to free.</span>
00552     <span class="comment">//</span>
00553 
00554     <a class="code" href="../../d5/d5/cc_8h.html#a82">GetActiveVacb</a>( SharedCacheMap, OldIrql, Vacb, ActivePage, PageIsDirty );
00555 
00556     <span class="comment">//</span>
00557     <span class="comment">//  If there is an end of a page to be zeroed, then free that page now,</span>
00558     <span class="comment">//  so it does not cause our data to get zeroed.  If there is an active</span>
00559     <span class="comment">//  page, free it so we have the correct ValidDataGoal.</span>
00560     <span class="comment">//</span>
00561 
00562     <span class="keywordflow">if</span> ((Vacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) || (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o13">NeedToZero</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
00563 
00564         <a class="code" href="../../d5/d5/cc_8h.html#a182">CcFreeActiveVacb</a>( SharedCacheMap, Vacb, ActivePage, PageIsDirty );
00565         Vacb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00566     }
00567 
00568     FOffset = *FileOffset;
00569 
00570     <span class="comment">//</span>
00571     <span class="comment">//  Put try-finally around the loop to deal with exceptions</span>
00572     <span class="comment">//</span>
00573 
00574     <span class="keywordflow">try</span> {
00575 
00576         <span class="comment">//</span>
00577         <span class="comment">//  Not all of the transfer will come back at once, so we have to loop</span>
00578         <span class="comment">//  until the entire transfer is complete.</span>
00579         <span class="comment">//</span>
00580 
00581         <span class="keywordflow">while</span> (Length != 0) {
00582 
00583             ULONG ReceivedLength;
00584             LARGE_INTEGER BeyondLastByte;
00585 
00586             <span class="comment">//</span>
00587             <span class="comment">//  Map and see how much we could potentially access at this</span>
00588             <span class="comment">//  FileOffset, then cut it down if it is more than we need.</span>
00589             <span class="comment">//</span>
00590 
00591             CacheBuffer = <a class="code" href="../../d5/d3/vacbsup_8c.html#a15">CcGetVirtualAddress</a>( SharedCacheMap,
00592                                                FOffset,
00593                                                &amp;Vacb,
00594                                                &amp;ReceivedLength );
00595 
00596             <span class="keywordflow">if</span> (ReceivedLength &gt; Length) {
00597                 ReceivedLength = Length;
00598             }
00599 
00600             BeyondLastByte.QuadPart = FOffset.QuadPart + (LONGLONG)ReceivedLength;
00601 
00602             <span class="comment">//</span>
00603             <span class="comment">//  At this point we can calculate the ZeroFlags.</span>
00604             <span class="comment">//</span>
00605 
00606             <span class="comment">//</span>
00607             <span class="comment">//  We can always zero middle pages, if any.</span>
00608             <span class="comment">//</span>
00609 
00610             ZeroFlags = <a class="code" href="../../d5/d5/cc_8h.html#a86">ZERO_MIDDLE_PAGES</a>;
00611 
00612             <span class="comment">//</span>
00613             <span class="comment">//  See if we are completely overwriting the first or last page.</span>
00614             <span class="comment">//</span>
00615 
00616             <span class="keywordflow">if</span> (((FOffset.LowPart &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) == 0) &amp;&amp;
00617                 (ReceivedLength &gt;= <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>)) {
00618                 ZeroFlags |= <a class="code" href="../../d5/d5/cc_8h.html#a85">ZERO_FIRST_PAGE</a>;
00619             }
00620 
00621             <span class="keywordflow">if</span> ((BeyondLastByte.LowPart &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) == 0) {
00622                 ZeroFlags |= <a class="code" href="../../d5/d5/cc_8h.html#a87">ZERO_LAST_PAGE</a>;
00623             }
00624 
00625             <span class="comment">//</span>
00626             <span class="comment">//  See if the entire transfer is beyond valid data length,</span>
00627             <span class="comment">//  or at least starting from the second page.</span>
00628             <span class="comment">//</span>
00629 
00630             Temp = FOffset;
00631             Temp.LowPart &amp;= ~(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> -1);
00632             ExAcquireFastLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, &amp;OldIrql );
00633             Temp.QuadPart = SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o7">ValidDataGoal</a>.QuadPart - Temp.QuadPart;
00634             ExReleaseFastLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, OldIrql );
00635 
00636             <span class="keywordflow">if</span> (Temp.QuadPart &lt;= 0) {
00637                 ZeroFlags |= <a class="code" href="../../d5/d5/cc_8h.html#a85">ZERO_FIRST_PAGE</a> | <a class="code" href="../../d5/d5/cc_8h.html#a86">ZERO_MIDDLE_PAGES</a> | <a class="code" href="../../d5/d5/cc_8h.html#a87">ZERO_LAST_PAGE</a>;
00638             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Temp.HighPart == 0) &amp;&amp; (Temp.LowPart &lt;= <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>)) {
00639                 ZeroFlags |= <a class="code" href="../../d5/d5/cc_8h.html#a86">ZERO_MIDDLE_PAGES</a> | <a class="code" href="../../d5/d5/cc_8h.html#a87">ZERO_LAST_PAGE</a>;
00640             }
00641 
00642             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d5/d5/cc_8h.html#a181">CcMapAndRead</a>( SharedCacheMap,
00643                                 &amp;FOffset,
00644                                 ReceivedLength,
00645                                 ZeroFlags,
00646                                 <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00647                                 CacheBuffer );
00648 
00649             <span class="comment">//</span>
00650             <span class="comment">//  Now attempt to allocate an Mdl to describe the mapped data.</span>
00651             <span class="comment">//</span>
00652 
00653             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"IoAllocateMdl:\n"</span>, 0 );
00654             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"    BaseAddress = %08lx\n"</span>, CacheBuffer );
00655             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"    Length = %08lx\n"</span>, ReceivedLength );
00656 
00657             Mdl = <a class="code" href="../../d4/d6/iosubs_8c.html#a19">IoAllocateMdl</a>( CacheBuffer,
00658                                  ReceivedLength,
00659                                  <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00660                                  <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00661                                  <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00662 
00663             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"    &lt;Mdl = %08lx\n"</span>, Mdl );
00664 
00665             <span class="keywordflow">if</span> (Mdl == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00666                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, 0, <span class="stringliteral">"Failed to allocate Mdl\n"</span>, 0 );
00667 
00668                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INSUFFICIENT_RESOURCES );
00669             }
00670 
00671             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"MmProbeAndLockPages:\n"</span>, 0 );
00672             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"    Mdl = %08lx\n"</span>, Mdl );
00673 
00674             <a class="code" href="../../d2/d1/mm_8h.html#a17">MmDisablePageFaultClustering</a>(&amp;SavedState);
00675             <a class="code" href="../../d5/d6/iosup_8c.html#a41">MmProbeAndLockPages</a>( Mdl, <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>, <a class="code" href="../../d2/d1/mm_8h.html#a344a169">IoWriteAccess</a> );
00676             <a class="code" href="../../d2/d1/mm_8h.html#a18">MmEnablePageFaultClustering</a>(SavedState);
00677             SavedState = 0;
00678 
00679             <span class="comment">//</span>
00680             <span class="comment">//  Now that some data (maybe zeros) is locked in memory and</span>
00681             <span class="comment">//  set dirty, it is safe, and necessary for us to advance</span>
00682             <span class="comment">//  valid data goal, so that we will not subsequently ask</span>
00683             <span class="comment">//  for a zero page.  Note if we are extending valid data,</span>
00684             <span class="comment">//  our caller has the file exclusive.</span>
00685             <span class="comment">//</span>
00686 
00687             ExAcquireFastLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, &amp;OldIrql );
00688             <span class="keywordflow">if</span> (BeyondLastByte.QuadPart &gt; SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o7">ValidDataGoal</a>.QuadPart) {
00689                 SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o7">ValidDataGoal</a> = BeyondLastByte;
00690             }
00691             ExReleaseFastLock( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o36">BcbSpinLock</a>, OldIrql );
00692 
00693             <span class="comment">//</span>
00694             <span class="comment">//  Unmap the data now, now that the pages are locked down.</span>
00695             <span class="comment">//</span>
00696 
00697             <a class="code" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a>( Vacb );
00698             Vacb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00699 
00700             <span class="comment">//</span>
00701             <span class="comment">//  Now link the Mdl into the caller's chain</span>
00702             <span class="comment">//</span>
00703 
00704             <span class="keywordflow">if</span> ( *MdlChain == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
00705                 *MdlChain = Mdl;
00706             } <span class="keywordflow">else</span> {
00707                 MdlTemp = CONTAINING_RECORD( *MdlChain, <a class="code" href="../../d6/d7/struct__MDL.html">MDL</a>, Next );
00708                 <span class="keywordflow">while</span> (MdlTemp-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o0">Next</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00709                     MdlTemp = MdlTemp-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o0">Next</a>;
00710                 }
00711                 MdlTemp-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o0">Next</a> = Mdl;
00712             }
00713             Mdl = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00714 
00715             <span class="comment">//</span>
00716             <span class="comment">//  Assume we did not get all the data we wanted, and set FOffset</span>
00717             <span class="comment">//  to the end of the returned data.</span>
00718             <span class="comment">//</span>
00719 
00720             FOffset = BeyondLastByte;
00721 
00722             <span class="comment">//</span>
00723             <span class="comment">//  Update number of bytes transferred.</span>
00724             <span class="comment">//</span>
00725 
00726             Information += ReceivedLength;
00727 
00728             <span class="comment">//</span>
00729             <span class="comment">//  Calculate length left to transfer.</span>
00730             <span class="comment">//</span>
00731 
00732             Length -= ReceivedLength;
00733         }
00734     }
00735     finally {
00736 
00737         <span class="keywordflow">if</span> (AbnormalTermination()) {
00738 
00739             <span class="keywordflow">if</span> (SavedState != 0) {
00740                 <a class="code" href="../../d2/d1/mm_8h.html#a18">MmEnablePageFaultClustering</a>(SavedState);
00741             }
00742 
00743             <span class="keywordflow">if</span> (Vacb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00744                 <a class="code" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a>( Vacb );
00745             }
00746             
00747             <span class="keywordflow">if</span> (Mdl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00748                 <a class="code" href="../../d4/d6/iosubs_8c.html#a65">IoFreeMdl</a>( Mdl );
00749             }
00750 
00751             <span class="comment">//</span>
00752             <span class="comment">//  Otherwise loop to deallocate the Mdls</span>
00753             <span class="comment">//</span>
00754 
00755             FOffset = *FileOffset;
00756             <span class="keywordflow">while</span> (*MdlChain != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00757                 MdlTemp = (*MdlChain)-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o0">Next</a>;
00758 
00759                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"MmUnlockPages/IoFreeMdl:\n"</span>, 0 );
00760                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"    Mdl = %08lx\n"</span>, *MdlChain );
00761 
00762                 <a class="code" href="../../d5/d6/iosup_8c.html#a45">MmUnlockPages</a>( *MdlChain );
00763 
00764                 <span class="comment">//</span>
00765                 <span class="comment">//  Extract the File Offset for this part of the transfer, and</span>
00766                 <span class="comment">//  tell the lazy writer to write these pages, since we have</span>
00767                 <span class="comment">//  marked them dirty.  Ignore the only exception (allocation</span>
00768                 <span class="comment">//  error), and console ourselves for having tried.</span>
00769                 <span class="comment">//</span>
00770 
00771                 <a class="code" href="../../d5/d5/cc_8h.html#a179">CcSetDirtyInMask</a>( SharedCacheMap, &amp;FOffset, (*MdlChain)-&gt;ByteCount );
00772 
00773                 FOffset.QuadPart = FOffset.QuadPart + (LONGLONG)((*MdlChain)-&gt;ByteCount);
00774 
00775                 <a class="code" href="../../d4/d6/iosubs_8c.html#a65">IoFreeMdl</a>( *MdlChain );
00776 
00777                 *MdlChain = MdlTemp;
00778             }
00779 
00780             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcPrepareMdlWrite -&gt; Unwinding\n"</span>, 0 );
00781         }
00782         <span class="keywordflow">else</span> {
00783 
00784             IoStatus-&gt;Status = STATUS_SUCCESS;
00785             IoStatus-&gt;Information = Information;
00786 
00787             <span class="comment">//</span>
00788             <span class="comment">//  Make sure the SharedCacheMap does not go away while</span>
00789             <span class="comment">//  the Mdl write is in progress.  We decrment below.</span>
00790             <span class="comment">//</span>
00791 
00792             <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
00793             <a class="code" href="../../d5/d5/cc_8h.html#a68">CcIncrementOpenCount</a>( SharedCacheMap, 'ldmP' );
00794             <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
00795         }
00796     }
00797 
00798     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    &lt;MdlChain = %08lx\n"</span>, *MdlChain );
00799     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcPrepareMdlWrite -&gt; VOID\n"</span>, 0 );
00800 
00801     <span class="keywordflow">return</span>;
00802 }
00803 
00804 
00805 <span class="comment">//</span>
00806 <span class="comment">//  First we have the old routine which checks for an entry in the FastIo vector.</span>
00807 <span class="comment">//  This routine becomes obsolete for every component that compiles with the new</span>
00808 <span class="comment">//  definition of FsRtlMdlWriteComplete in fsrtl.h.</span>
00809 <span class="comment">//</span>
00810 
00811 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00812"></a><a class="code" href="../../d4/d2/cache_8h.html#a82">00812</a> <a class="code" href="../../d4/d2/cache_8h.html#a82">CcMdlWriteComplete</a> (
00813     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00814     IN PLARGE_INTEGER FileOffset,
00815     IN <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MdlChain
00816     )
00817 
00818 {
00819     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject;
00820     <a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html">PFAST_IO_DISPATCH</a> FastIoDispatch;
00821 
00822     DeviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( FileObject );
00823     FastIoDispatch = DeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o3">DriverObject</a>-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o10">FastIoDispatch</a>;
00824 
00825     <span class="keywordflow">if</span> ((FastIoDispatch != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
00826         (FastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o0">SizeOfFastIoDispatch</a> &gt; FIELD_OFFSET(<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html">FAST_IO_DISPATCH</a>, MdlWriteComplete)) &amp;&amp;
00827         (FastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o19">MdlWriteComplete</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
00828         FastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o19">MdlWriteComplete</a>( FileObject, FileOffset, MdlChain, DeviceObject )) {
00829 
00830         NOTHING;
00831 
00832     } <span class="keywordflow">else</span> {
00833         <a class="code" href="../../d4/d2/cache_8h.html#a83">CcMdlWriteComplete2</a>( FileObject, FileOffset, MdlChain );
00834     }
00835 }
00836 
00837 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00838"></a><a class="code" href="../../d4/d2/cache_8h.html#a83">00838</a> <a class="code" href="../../d4/d2/cache_8h.html#a83">CcMdlWriteComplete2</a> (
00839     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00840     IN PLARGE_INTEGER FileOffset,
00841     IN <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MdlChain
00842     )
00843 
00844 <span class="comment">/*++</span>
00845 <span class="comment"></span>
00846 <span class="comment">Routine Description:</span>
00847 <span class="comment"></span>
00848 <span class="comment">    This routine must be called at IPL0 after a call to CcPrepareMdlWrite.</span>
00849 <span class="comment">    The caller supplies the ActualLength of data that it actually wrote</span>
00850 <span class="comment">    into the buffer, which may be less than or equal to the Length specified</span>
00851 <span class="comment">    in CcPrepareMdlWrite.</span>
00852 <span class="comment"></span>
00853 <span class="comment">    This call does the following:</span>
00854 <span class="comment"></span>
00855 <span class="comment">        Makes sure the data up to ActualLength eventually gets written.</span>
00856 <span class="comment">        If WriteThrough is FALSE, the data will not be written immediately.</span>
00857 <span class="comment">        If WriteThrough is TRUE, then the data is written synchronously.</span>
00858 <span class="comment"></span>
00859 <span class="comment">        Unmaps the pages (if mapped), unlocks them and deletes the MdlChain</span>
00860 <span class="comment"></span>
00861 <span class="comment">Arguments:</span>
00862 <span class="comment"></span>
00863 <span class="comment">    FileObject - Pointer to the file object for a file which was</span>
00864 <span class="comment">                 opened with NO_INTERMEDIATE_BUFFERING clear, i.e., for</span>
00865 <span class="comment">                 which CcInitializeCacheMap was called by the file system.</span>
00866 <span class="comment"></span>
00867 <span class="comment">    FileOffset - Original file offset read above.</span>
00868 <span class="comment"></span>
00869 <span class="comment">    MdlChain - same as returned from corresponding call to CcPrepareMdlWrite.</span>
00870 <span class="comment"></span>
00871 <span class="comment">Return Value:</span>
00872 <span class="comment"></span>
00873 <span class="comment">    None</span>
00874 <span class="comment"></span>
00875 <span class="comment">--*/</span>
00876 
00877 {
00878     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MdlNext;
00879     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
00880     LARGE_INTEGER FOffset;
00881     IO_STATUS_BLOCK IoStatus;
00882     KIRQL OldIrql;
00883     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> StatusToRaise = STATUS_SUCCESS;
00884 
00885     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcMdlWriteComplete\n"</span>, 0 );
00886     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    FileObject = %08lx\n"</span>, FileObject );
00887     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    MdlChain = %08lx\n"</span>, MdlChain );
00888 
00889     SharedCacheMap = FileObject-&gt;SectionObjectPointer-&gt;SharedCacheMap;
00890 
00891     <span class="comment">//</span>
00892     <span class="comment">//  Deallocate the Mdls</span>
00893     <span class="comment">//</span>
00894 
00895     FOffset.QuadPart = *(LONGLONG UNALIGNED *)FileOffset;
00896     <span class="keywordflow">while</span> (MdlChain != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00897 
00898         MdlNext = MdlChain-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o0">Next</a>;
00899 
00900         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"MmUnlockPages/IoFreeMdl:\n"</span>, 0 );
00901         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d5/d5/cc_8h.html#a57">mm</a>, <span class="stringliteral">"    Mdl = %08lx\n"</span>, MdlChain );
00902 
00903         <span class="comment">//</span>
00904         <span class="comment">//  Now clear the dirty bits in the Pte and set them in the</span>
00905         <span class="comment">//  Pfn.</span>
00906         <span class="comment">//</span>
00907 
00908         <a class="code" href="../../d5/d6/iosup_8c.html#a45">MmUnlockPages</a>( MdlChain );
00909 
00910         <span class="comment">//</span>
00911         <span class="comment">//  Extract the File Offset for this part of the transfer.</span>
00912         <span class="comment">//</span>
00913 
00914         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(FileObject-&gt;Flags, <a class="code" href="../../d0/d5/io_8h.html#a154">FO_WRITE_THROUGH</a>)) {
00915 
00916             <a class="code" href="../../d6/d5/flushsec_8c.html#a8">MmFlushSection</a> ( FileObject-&gt;SectionObjectPointer,
00917                              &amp;FOffset,
00918                              MdlChain-&gt;ByteCount,
00919                              &amp;IoStatus,
00920                              <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00921 
00922             <span class="comment">//</span>
00923             <span class="comment">//  If we got an I/O error, remember it.</span>
00924             <span class="comment">//</span>
00925 
00926             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(IoStatus.Status)) {
00927                 StatusToRaise = IoStatus.Status;
00928             }
00929 
00930         } <span class="keywordflow">else</span> {
00931 
00932             <span class="comment">//</span>
00933             <span class="comment">//  Ignore the only exception (allocation error), and console</span>
00934             <span class="comment">//  ourselves for having tried.</span>
00935             <span class="comment">//</span>
00936 
00937             <a class="code" href="../../d5/d5/cc_8h.html#a179">CcSetDirtyInMask</a>( SharedCacheMap, &amp;FOffset, MdlChain-&gt;ByteCount );
00938         }
00939 
00940         FOffset.QuadPart = FOffset.QuadPart + (LONGLONG)(MdlChain-&gt;ByteCount);
00941 
00942         <a class="code" href="../../d4/d6/iosubs_8c.html#a65">IoFreeMdl</a>( MdlChain );
00943 
00944         MdlChain = MdlNext;
00945     }
00946 
00947     <span class="comment">//</span>
00948     <span class="comment">//  Now release our open count.</span>
00949     <span class="comment">//</span>
00950 
00951     <a class="code" href="../../d5/d5/cc_8h.html#a0">CcAcquireMasterLock</a>( &amp;OldIrql );
00952 
00953     <a class="code" href="../../d5/d5/cc_8h.html#a69">CcDecrementOpenCount</a>( SharedCacheMap, 'ldmC' );
00954 
00955     <span class="keywordflow">if</span> ((SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o2">OpenCount</a> == 0) &amp;&amp;
00956         !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a74">WRITE_QUEUED</a>) &amp;&amp;
00957         (SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o20">DirtyPages</a> == 0)) {
00958 
00959         <span class="comment">//</span>
00960         <span class="comment">//  Move to the dirty list.</span>
00961         <span class="comment">//</span>
00962 
00963         RemoveEntryList( &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
00964         InsertTailList( &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a2">CcDirtySharedCacheMapList</a>.<a class="code" href="../../d1/d3/struct__SHARED__CACHE__MAP__LIST__CURSOR.html#o0">SharedCacheMapLinks</a>,
00965                         &amp;SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o17">SharedCacheMapLinks</a> );
00966 
00967         <span class="comment">//</span>
00968         <span class="comment">//  Make sure the Lazy Writer will wake up, because we</span>
00969         <span class="comment">//  want him to delete this SharedCacheMap.</span>
00970         <span class="comment">//</span>
00971 
00972         <a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o6">OtherWork</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00973         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d2/cachedat_8c.html#a41">LazyWriter</a>.<a class="code" href="../../d3/d9/struct__LAZY__WRITER.html#o5">ScanActive</a>) {
00974             <a class="code" href="../../d5/d5/cc_8h.html#a185">CcScheduleLazyWriteScan</a>();
00975         }
00976     }
00977 
00978     <a class="code" href="../../d5/d5/cc_8h.html#a1">CcReleaseMasterLock</a>( OldIrql );
00979 
00980     <span class="comment">//</span>
00981     <span class="comment">//  If we got an I/O error, raise it now.</span>
00982     <span class="comment">//</span>
00983 
00984     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(StatusToRaise)) {
00985         <a class="code" href="../../d1/d8/fsrtl_8h.html#a136">FsRtlNormalizeNtstatus</a>( StatusToRaise,
00986                                 STATUS_UNEXPECTED_IO_ERROR );
00987     }
00988 
00989     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcMdlWriteComplete -&gt; TRUE\n"</span>, 0 );
00990 
00991     <span class="keywordflow">return</span>;
00992 }
00993 
00994 
00995 
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:43 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
