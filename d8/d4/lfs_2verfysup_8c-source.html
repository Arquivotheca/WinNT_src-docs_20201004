<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: verfysup.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>verfysup.c</h1><a href="../../d7/d5/lfs_2verfysup_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1990  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    VerfySup.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module implements consistency checking and structure comparisions</span>
00012 <span class="comment">    on Lfs structures.</span>
00013 <span class="comment"></span>
00014 <span class="comment">Author:</span>
00015 <span class="comment"></span>
00016 <span class="comment">    Brian Andrew    [BrianAn]   20-June-1991</span>
00017 <span class="comment"></span>
00018 <span class="comment">Revision History:</span>
00019 <span class="comment"></span>
00020 <span class="comment">--*/</span>
00021 
00022 <span class="preprocessor">#include "<a class="code" href="../../d0/d4/lfsprocs_8h.html">lfsprocs.h</a>"</span>
00023 
00024 <span class="preprocessor">#ifdef LFS_RAISE</span>
00025 <span class="preprocessor"></span>BOOLEAN LfsRaiseFull = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00026 <span class="preprocessor">#endif</span>
00027 <span class="preprocessor"></span>
00028 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00029 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, LfsCurrentAvailSpace)</span>
00030 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, LfsFindCurrentAvail)</span>
00031 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, LfsVerifyLogSpaceAvail)</span>
00032 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00033 <span class="preprocessor"></span>
00034 
00035 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00036"></a><a class="code" href="../../d7/d5/lfs_2verfysup_8c.html#a0">00036</a> <a class="code" href="../../d7/d5/lfs_2verfysup_8c.html#a0">LfsCurrentAvailSpace</a> (
00037     IN <a class="code" href="../../d1/d0/struct__LFCB.html">PLFCB</a> Lfcb,
00038     OUT PLONGLONG CurrentAvailSpace,
00039     OUT PULONG CurrentPageBytes
00040     )
00041 
00042 <span class="comment">/*++</span>
00043 <span class="comment"></span>
00044 <span class="comment">Routine Description:</span>
00045 <span class="comment"></span>
00046 <span class="comment">    This routine is called to determine the available log space in the log file.</span>
00047 <span class="comment">    It returns the total number of free bytes and the number available on the</span>
00048 <span class="comment">    active page if present.  The total free bytes will reflect all of the empty</span>
00049 <span class="comment">    pages as well as the number in the active page.</span>
00050 <span class="comment"></span>
00051 <span class="comment">Arguments:</span>
00052 <span class="comment"></span>
00053 <span class="comment">    Lfcb - Lfcb for this log file.</span>
00054 <span class="comment"></span>
00055 <span class="comment">    CurrentAvailSpace - This is the number of bytes available for log</span>
00056 <span class="comment">                        records.</span>
00057 <span class="comment"></span>
00058 <span class="comment">    CurrentPageBytes - This is the number of bytes remaining on the</span>
00059 <span class="comment">                       current log page.</span>
00060 <span class="comment"></span>
00061 <span class="comment">Return Value:</span>
00062 <span class="comment"></span>
00063 <span class="comment">    None.</span>
00064 <span class="comment"></span>
00065 <span class="comment">--*/</span>
00066 
00067 {
00068     *CurrentPageBytes = 0;
00069 
00070     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00071 
00072     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( +1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"LfsCurrentAvailSpace:  Entered\n"</span>, 0 );
00073 
00074     <span class="comment">//</span>
00075     <span class="comment">//  Get the total number from the Lfcb.</span>
00076     <span class="comment">//</span>
00077 
00078     *CurrentAvailSpace = Lfcb-&gt;CurrentAvailable;
00079 
00080     <span class="comment">//</span>
00081     <span class="comment">//  We now look to see if there are any bytes available on the Lbcb in</span>
00082     <span class="comment">//  the active queue.  We can add this to the bytes available in the</span>
00083     <span class="comment">//  log pages and also give this back to the caller.</span>
00084     <span class="comment">//</span>
00085 
00086     <span class="keywordflow">if</span> (!IsListEmpty( &amp;Lfcb-&gt;LbcbActive )) {
00087 
00088         <a class="code" href="../../d4/d9/struct__LBCB.html">PLBCB</a> ThisLbcb;
00089 
00090         ThisLbcb = CONTAINING_RECORD( Lfcb-&gt;LbcbActive.Flink,
00091                                       <a class="code" href="../../d4/d9/struct__LBCB.html">LBCB</a>,
00092                                       ActiveLinks );
00093 
00094         <span class="comment">//</span>
00095         <span class="comment">//  If the page is not empty or the page is empty but this is a</span>
00096         <span class="comment">//  restart page then add the remaining bytes on this page.</span>
00097         <span class="comment">//</span>
00098 
00099         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( ThisLbcb-&gt;<a class="code" href="../../d4/d9/struct__LBCB.html#o13">LbcbFlags</a>, <a class="code" href="../../d1/d4/lfsstruc_8h.html#a2">LBCB_NOT_EMPTY</a> | <a class="code" href="../../d1/d4/lfsstruc_8h.html#a3">LBCB_FLUSH_COPY</a> )) {
00100 
00101             *CurrentPageBytes = (ULONG)Lfcb-&gt;LogPageSize - (ULONG)ThisLbcb-&gt;<a class="code" href="../../d4/d9/struct__LBCB.html#o7">BufferOffset</a>;
00102 
00103             *CurrentAvailSpace = *CurrentAvailSpace + *CurrentPageBytes;                                               <span class="comment">//**** xxAdd( *CurrentAvailSpace, xxFromUlong( *CurrentPageBytes ));</span>
00104         }
00105     }
00106 
00107     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( +1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"LfsCurrentAvailSpace:  Exit\n"</span>, 0 );
00108 
00109     <span class="keywordflow">return</span>;
00110 }
00111 
00112 
00113 BOOLEAN
<a name="l00114"></a><a class="code" href="../../d7/d5/lfs_2verfysup_8c.html#a1">00114</a> <a class="code" href="../../d7/d5/lfs_2verfysup_8c.html#a1">LfsVerifyLogSpaceAvail</a> (
00115     IN <a class="code" href="../../d1/d0/struct__LFCB.html">PLFCB</a> Lfcb,
00116     IN <a class="code" href="../../d6/d9/struct__LCH.html">PLCH</a> Lch,
00117     IN ULONG RemainingLogBytes,
00118     IN LONG UndoRequirement,
00119     IN BOOLEAN ForceToDisk
00120     )
00121 
00122 <span class="comment">/*++</span>
00123 <span class="comment"></span>
00124 <span class="comment">Routine Description:</span>
00125 <span class="comment"></span>
00126 <span class="comment">    This routine is called to verify that we may write this log record into the</span>
00127 <span class="comment">    log file.  We want to always leave room for each transaction to abort.</span>
00128 <span class="comment"></span>
00129 <span class="comment">    We determine how much space the current log record will take and the</span>
00130 <span class="comment">    worst case for its undo operation.  If this space is available we</span>
00131 <span class="comment">    update the corresponding values in the Lfcb and Lch for bookkeeping.</span>
00132 <span class="comment">    Otherwise we raise a status indicating that the log file is full.</span>
00133 <span class="comment"></span>
00134 <span class="comment">    The disk usage is different for the packed and unpacked cases.  Make the</span>
00135 <span class="comment">    following adjustments after finding the total available and amount still</span>
00136 <span class="comment">    remaining on the last active page,</span>
00137 <span class="comment"></span>
00138 <span class="comment">    Packed Case:</span>
00139 <span class="comment"></span>
00140 <span class="comment">        Size needed for log record is data size plus header size.</span>
00141 <span class="comment"></span>
00142 <span class="comment">        Undo requirement is the undo data size plus the header size.</span>
00143 <span class="comment">            We have already taken into account the end of the pages</span>
00144 <span class="comment">            except for the current page.</span>
00145 <span class="comment"></span>
00146 <span class="comment">        Add the log record size to the undo requirement to get the</span>
00147 <span class="comment">            log file usage.  Compare this number with the actual available</span>
00148 <span class="comment">            space (Available - CommittedUndo).  If the space is not</span>
00149 <span class="comment">            available, then raise LOG_FILE_FULL.  Must take into account</span>
00150 <span class="comment">            any unused bytes at the end of the current page.</span>
00151 <span class="comment"></span>
00152 <span class="comment">    Unpacked Case:</span>
00153 <span class="comment"></span>
00154 <span class="comment">        Size needed is initially header size plus data size.</span>
00155 <span class="comment"></span>
00156 <span class="comment">        If the log record can't begin on the current page then</span>
00157 <span class="comment">            add the bytes being thrown away to the log record size.</span>
00158 <span class="comment"></span>
00159 <span class="comment">        If the page is being forced to disk then add any remaining</span>
00160 <span class="comment">            bytes on the last page.  To the bytes being used.</span>
00161 <span class="comment"></span>
00162 <span class="comment">        Undo requirement is twice the sum of the header size and</span>
00163 <span class="comment">            undo size.  We double the requested size since the log</span>
00164 <span class="comment">            record will always fit on a page.  This can be a</span>
00165 <span class="comment">            positive or negative number.</span>
00166 <span class="comment"></span>
00167 <span class="comment">        Add the log record usage to the undo usage to get the log file</span>
00168 <span class="comment">            usage.  Compare this number with the actual available</span>
00169 <span class="comment">            space (Available - CommittedUndo).  If the space is not</span>
00170 <span class="comment">            available, then raise LOG_FILE_FULL.</span>
00171 <span class="comment"></span>
00172 <span class="comment">Arguments:</span>
00173 <span class="comment"></span>
00174 <span class="comment">    Lfcb - Lfcb for this log file.</span>
00175 <span class="comment"></span>
00176 <span class="comment">    Lch - Client handle</span>
00177 <span class="comment"></span>
00178 <span class="comment">    RemainingLogBytes - Number of bytes for the current log record</span>
00179 <span class="comment"></span>
00180 <span class="comment">    UndoRequirement - User's requirement for the undo record.</span>
00181 <span class="comment"></span>
00182 <span class="comment">    ForceToDisk - Indicates if this log record will be flushed to disk.</span>
00183 <span class="comment"></span>
00184 <span class="comment">Return Value:</span>
00185 <span class="comment"></span>
00186 <span class="comment">    BOOLEAN - Advisory, indicates that there is less than 1/4 of the log file available.</span>
00187 <span class="comment"></span>
00188 <span class="comment">--*/</span>
00189 
00190 {
00191     ULONG CurrentLogRecordSize;
00192     ULONG LogRecordStart;
00193     ULONG TailBytes;
00194 
00195     LONGLONG CurrentAvailSpace;
00196     ULONG CurrentPageBytes;
00197 
00198     LONGLONG LogFileUsage;
00199 
00200     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00201 
00202     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( +1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"LfsVerifyLogSpaceAvail:  Entered\n"</span>, 0 );
00203     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(  0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"Lfcb              -&gt; %08x\n"</span>, Lfcb );
00204     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(  0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"Lch               -&gt; %08lx\n"</span>, Lch );
00205     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(  0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"RemainingLogBytes -&gt; %08lx\n"</span>, RemainingLogBytes );
00206     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(  0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UndoRequirement   -&gt; %08lx\n"</span>, UndoRequirement );
00207     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(  0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"ForceToDisk       -&gt; %04x\n"</span>, ForceToDisk );
00208 
00209     <span class="comment">//</span>
00210     <span class="comment">//  Start by collecting the current data on the file.</span>
00211     <span class="comment">//</span>
00212 
00213     <a class="code" href="../../d7/d5/lfs_2verfysup_8c.html#a0">LfsCurrentAvailSpace</a>( Lfcb,
00214                           &amp;CurrentAvailSpace,
00215                           &amp;CurrentPageBytes );
00216 
00217     <span class="comment">//</span>
00218     <span class="comment">//  We compute the amount of space needed for the current log record by</span>
00219     <span class="comment">//  adding up the following:</span>
00220     <span class="comment">//</span>
00221     <span class="comment">//      Space at end of current log page which won't be used.</span>
00222     <span class="comment">//      Size of header for log record.</span>
00223     <span class="comment">//      Size of client data in log record.</span>
00224     <span class="comment">//      Size of wasted portion of log page if this is forced to disk.</span>
00225     <span class="comment">//</span>
00226 
00227     <span class="comment">//</span>
00228     <span class="comment">//  Start with the size of the header and the client data.</span>
00229     <span class="comment">//</span>
00230 
00231     CurrentLogRecordSize = RemainingLogBytes + Lfcb-&gt;RecordHeaderLength;
00232 
00233     <span class="comment">//</span>
00234     <span class="comment">//  If the log is packed and there are bytes on the current page we need</span>
00235     <span class="comment">//  to take into account any bytes at the end of the page which won't</span>
00236     <span class="comment">//  be used.  This will happen if the log record spills into the end of</span>
00237     <span class="comment">//  the log page but doesn't use up the page.  If the remaining bytes are</span>
00238     <span class="comment">//  less than a record header size we must throw them away.</span>
00239     <span class="comment">//</span>
00240 
00241     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( Lfcb-&gt;Flags, <a class="code" href="../../d1/d4/lfsstruc_8h.html#a8">LFCB_PACK_LOG</a> )) {
00242 
00243         <span class="keywordflow">if</span> (CurrentPageBytes != 0
00244             &amp;&amp; CurrentLogRecordSize &lt; CurrentPageBytes
00245             &amp;&amp; (CurrentPageBytes - CurrentLogRecordSize) &lt; Lfcb-&gt;RecordHeaderLength) {
00246 
00247             CurrentLogRecordSize += (CurrentPageBytes - CurrentLogRecordSize);
00248         }
00249 
00250     <span class="comment">//</span>
00251     <span class="comment">//  If this is the unpacked case we need to check for bytes being thrown away</span>
00252     <span class="comment">//  on the current page or the last page.</span>
00253     <span class="comment">//</span>
00254 
00255     } <span class="keywordflow">else</span> {
00256 
00257         <span class="comment">//</span>
00258         <span class="comment">//  If there is an active Lbcb, we need to add any bytes that</span>
00259         <span class="comment">//  would be thrown away at the end.</span>
00260         <span class="comment">//</span>
00261 
00262         <span class="keywordflow">if</span> (CurrentPageBytes != 0) {
00263 
00264             <span class="comment">//</span>
00265             <span class="comment">//  We won't use this log page unless the new log record will fit or</span>
00266             <span class="comment">//  unless this is the first log record in the page.</span>
00267             <span class="comment">//</span>
00268 
00269             <span class="keywordflow">if</span> ((CurrentPageBytes != (ULONG)Lfcb-&gt;LogPageDataSize)
00270                 &amp;&amp; (CurrentLogRecordSize &gt; CurrentPageBytes)) {
00271 
00272                 CurrentLogRecordSize += CurrentPageBytes;
00273 
00274                 <span class="comment">//</span>
00275                 <span class="comment">//  Remember that we will start this log record at the first</span>
00276                 <span class="comment">//  byte in the data portion of a page.</span>
00277                 <span class="comment">//</span>
00278 
00279                 LogRecordStart = 0;
00280 
00281             <span class="comment">//</span>
00282             <span class="comment">//  Otherwise this will start at the current offset into the</span>
00283             <span class="comment">//  data portion of the log page.</span>
00284             <span class="comment">//</span>
00285 
00286             } <span class="keywordflow">else</span> {
00287 
00288                 LogRecordStart = (ULONG)Lfcb-&gt;LogPageDataSize - CurrentPageBytes;
00289             }
00290 
00291         <span class="comment">//</span>
00292         <span class="comment">//  If there was no Lbcb, then we know that we will start at the first</span>
00293         <span class="comment">//  byte of the data portion.</span>
00294         <span class="comment">//</span>
00295 
00296         } <span class="keywordflow">else</span> {
00297 
00298             LogRecordStart = 0;
00299         }
00300 
00301         <span class="comment">//</span>
00302         <span class="comment">//  We always assume that we will use up the rest of the bytes on the last page</span>
00303         <span class="comment">//  in computing whether the log record will fit in the available space.  We</span>
00304         <span class="comment">//  only subtract that space from the available space if this is a force write.</span>
00305         <span class="comment">//</span>
00306 
00307         <span class="keywordflow">if</span> (ForceToDisk) {
00308 
00309             <span class="comment">//</span>
00310             <span class="comment">//  We take into account where we start on a log page and continue</span>
00311             <span class="comment">//  to subtract log pages until we know the amount on the last</span>
00312             <span class="comment">//  page.</span>
00313             <span class="comment">//</span>
00314 
00315             TailBytes = RemainingLogBytes + Lfcb-&gt;RecordHeaderLength + LogRecordStart;
00316 
00317             <span class="keywordflow">while</span> (TailBytes &gt; (ULONG)Lfcb-&gt;LogPageDataSize) {
00318 
00319                 TailBytes -= (ULONG)Lfcb-&gt;LogPageDataSize;
00320             }
00321 
00322             TailBytes = (ULONG)Lfcb-&gt;LogPageDataSize - TailBytes;
00323 
00324             CurrentLogRecordSize += TailBytes;
00325         }
00326     }
00327 
00328     <span class="comment">//</span>
00329     <span class="comment">//  We now know the number of bytes needed for the current log page.</span>
00330     <span class="comment">//  Next we compute the number of bytes being reserved by UndoRequirement.</span>
00331     <span class="comment">//  If the UndoRequirement is positive, we will add to the amount reserved</span>
00332     <span class="comment">//  in the log file.  If it is negative, we will subtract from the amount</span>
00333     <span class="comment">//  reserved in the log file.</span>
00334     <span class="comment">//</span>
00335 
00336     <span class="comment">//</span>
00337     <span class="comment">//  When we have an actual reserve amount, we convert it to positive</span>
00338     <span class="comment">//  and then reserve twice the space required to hold the data and</span>
00339     <span class="comment">//  its header (up to the maximum of a single page.</span>
00340     <span class="comment">//</span>
00341 
00342     <span class="keywordflow">if</span> (UndoRequirement != 0) {
00343 
00344         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( Lfcb-&gt;Flags, <a class="code" href="../../d1/d4/lfsstruc_8h.html#a8">LFCB_PACK_LOG</a> )) {
00345 
00346             UndoRequirement *= 2;
00347         }
00348 
00349         <span class="keywordflow">if</span> (UndoRequirement &lt; 0) {
00350 
00351             UndoRequirement -= (2 * Lfcb-&gt;RecordHeaderLength);
00352         } <span class="keywordflow">else</span> {
00353 
00354             UndoRequirement += (2 * Lfcb-&gt;RecordHeaderLength);
00355         }
00356     }
00357 
00358     <span class="comment">//</span>
00359     <span class="comment">//  Now compute the net log file usage.  The result may be positive or</span>
00360     <span class="comment">//  negative.</span>
00361     <span class="comment">//</span>
00362 
00363     LogFileUsage = ((LONG) CurrentLogRecordSize)  + UndoRequirement;                                                   <span class="comment">//**** xxFromLong( ((LONG) CurrentLogRecordSize)  + UndoRequirement );</span>
00364 
00365     <span class="comment">//</span>
00366     <span class="comment">//  The actual available space is the CurrentAvail minus the reserved</span>
00367     <span class="comment">//  undo value in the Lfcb.</span>
00368     <span class="comment">//</span>
00369 
00370     CurrentAvailSpace = CurrentAvailSpace - Lfcb-&gt;TotalUndoCommitment;                                                 <span class="comment">//**** xxSub( CurrentAvailSpace, Lfcb-&gt;TotalUndoCommitment );</span>
00371 
00372     <span class="comment">//</span>
00373     <span class="comment">//  If this log file usage is greater than the available log file space</span>
00374     <span class="comment">//  then we raise a status code.</span>
00375     <span class="comment">//</span>
00376 
00377 <span class="preprocessor">#ifdef LFS_RAISE</span>
00378 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (LfsRaiseFull) {
00379 
00380         LfsRaiseFull = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00381         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"LfsVerifyLogSpaceAvail:  About to raise\n"</span>, 0 );
00382         <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_LOG_FILE_FULL );
00383     }
00384 <span class="preprocessor">#endif</span>
00385 <span class="preprocessor"></span>
00386     <span class="keywordflow">if</span> (LogFileUsage &gt; CurrentAvailSpace) {
00387 
00388         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"LfsVerifyLogSpaceAvail:  About to raise\n"</span>, 0 );
00389         <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_LOG_FILE_FULL );
00390     }
00391 
00392     Lfcb-&gt;TotalUndoCommitment = Lfcb-&gt;TotalUndoCommitment + UndoRequirement;                                           <span class="comment">//**** xxAdd( Lfcb-&gt;TotalUndoCommitment, xxFromLong( UndoRequirement ));</span>
00393 
00394     Lch-&gt;ClientUndoCommitment = Lch-&gt;ClientUndoCommitment + UndoRequirement;                                           <span class="comment">//**** xxAdd( Lch-&gt;ClientUndoCommitment, xxFromLong( UndoRequirement ));</span>
00395 
00396     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"LfsVerifyLogSpaceAvail:  Exit\n"</span>, 0 );
00397 
00398     <span class="comment">//</span>
00399     <span class="comment">//  Now check if the log file is almost used up.</span>
00400     <span class="comment">//</span>
00401 
00402     <span class="keywordflow">if</span> ((CurrentAvailSpace - LogFileUsage) &lt; (Lfcb-&gt;TotalAvailable &gt;&gt; 2)) {
00403 
00404         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00405     }
00406 
00407     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00408 }
00409 
00410 
00411 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00412"></a><a class="code" href="../../d7/d5/lfs_2verfysup_8c.html#a2">00412</a> <a class="code" href="../../d7/d5/lfs_2verfysup_8c.html#a2">LfsFindCurrentAvail</a> (
00413     IN <a class="code" href="../../d1/d0/struct__LFCB.html">PLFCB</a> Lfcb
00414     )
00415 
00416 <span class="comment">/*++</span>
00417 <span class="comment"></span>
00418 <span class="comment">Routine Description:</span>
00419 <span class="comment"></span>
00420 <span class="comment">    This routine is called to calculate the number of bytes available for log</span>
00421 <span class="comment">    records which are in completely empty log record pages.  It ignores any</span>
00422 <span class="comment">    partial pages in the active work queue and ignores any page which is</span>
00423 <span class="comment">    going to be reused.</span>
00424 <span class="comment"></span>
00425 <span class="comment">Arguments:</span>
00426 <span class="comment"></span>
00427 <span class="comment">    Lfcb - Lfcb for this log file.</span>
00428 <span class="comment"></span>
00429 <span class="comment">Return Value:</span>
00430 <span class="comment"></span>
00431 <span class="comment">    None.</span>
00432 <span class="comment"></span>
00433 <span class="comment">--*/</span>
00434 
00435 {
00436     LONGLONG OldestPageOffset;
00437     LONGLONG NextFreePageOffset;
00438     LONGLONG FreeBytes;
00439 
00440     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00441 
00442     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( +1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"LfsFindCurrentAvail:  Entered\n"</span>, 0 );
00443     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(  0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"Lfcb              -&gt; %08x\n"</span>, Lfcb );
00444 
00445     <span class="comment">//</span>
00446     <span class="comment">//  If there is a last lsn in the restart area then we know</span>
00447     <span class="comment">//  that we will have to compute the free range.</span>
00448     <span class="comment">//</span>
00449 
00450     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( Lfcb-&gt;Flags, <a class="code" href="../../d1/d4/lfsstruc_8h.html#a7">LFCB_NO_LAST_LSN</a> )) {
00451 
00452         <span class="comment">//</span>
00453         <span class="comment">//  If there is no oldest Lsn then start at the</span>
00454         <span class="comment">//  first page of the file.</span>
00455         <span class="comment">//</span>
00456 
00457         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( Lfcb-&gt;Flags, <a class="code" href="../../d1/d4/lfsstruc_8h.html#a10">LFCB_NO_OLDEST_LSN</a> )) {
00458 
00459             OldestPageOffset = Lfcb-&gt;FirstLogPage;
00460 
00461         } <span class="keywordflow">else</span> {
00462 
00463             <a class="code" href="../../d0/d4/lfsprocs_8h.html#a6">LfsTruncateOffsetToLogPage</a>( Lfcb,
00464                                         Lfcb-&gt;OldestLsnOffset,
00465                                         &amp;OldestPageOffset );
00466         }
00467 
00468         <span class="comment">//</span>
00469         <span class="comment">//  We will use the next log page offset to compute the</span>
00470         <span class="comment">//  next free page.  If we are going to reuse this page</span>
00471         <span class="comment">//  go to the next page,  if we are at the first page then</span>
00472         <span class="comment">//  use the end of the file.</span>
00473         <span class="comment">//</span>
00474 
00475         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( Lfcb-&gt;Flags, <a class="code" href="../../d1/d4/lfsstruc_8h.html#a9">LFCB_REUSE_TAIL</a> )) {
00476 
00477             NextFreePageOffset = Lfcb-&gt;NextLogPage + Lfcb-&gt;LogPageSize;                                                <span class="comment">//**** xxAdd( Lfcb-&gt;NextLogPage, Lfcb-&gt;LogPageSize );</span>
00478 
00479         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( Lfcb-&gt;NextLogPage == Lfcb-&gt;FirstLogPage ) {                                                        <span class="comment">//**** xxEql( Lfcb-&gt;NextLogPage, Lfcb-&gt;FirstLogPage )</span>
00480 
00481             NextFreePageOffset = Lfcb-&gt;FileSize;
00482 
00483         } <span class="keywordflow">else</span> {
00484 
00485             NextFreePageOffset = Lfcb-&gt;NextLogPage;
00486         }
00487 
00488         <span class="comment">//</span>
00489         <span class="comment">//  If the two offsets are the same then there is no available space.</span>
00490         <span class="comment">//</span>
00491 
00492         <span class="keywordflow">if</span> ( OldestPageOffset == NextFreePageOffset ) {                                                                <span class="comment">//**** xxEql( OldestPageOffset, NextFreePageOffset )</span>
00493 
00494             Lfcb-&gt;CurrentAvailable = 0;
00495 
00496         } <span class="keywordflow">else</span> {
00497 
00498             <span class="comment">//</span>
00499             <span class="comment">//  If the free offset follows the oldest offset then subtract</span>
00500             <span class="comment">//  this range from the total available pages.</span>
00501             <span class="comment">//</span>
00502 
00503             <span class="keywordflow">if</span> ( OldestPageOffset &lt; NextFreePageOffset ) {                                                             <span class="comment">//**** xxLtr( OldestPageOffset, NextFreePageOffset )</span>
00504 
00505                 FreeBytes = Lfcb-&gt;TotalAvailInPages - ( NextFreePageOffset - OldestPageOffset );                       <span class="comment">//**** xxSub( Lfcb-&gt;TotalAvailInPages, xxSub( NextFreePageOffset, OldestPageOffset ));</span>
00506 
00507             } <span class="keywordflow">else</span> {
00508 
00509                 FreeBytes = OldestPageOffset - NextFreePageOffset;                                                     <span class="comment">//**** xxSub( OldestPageOffset, NextFreePageOffset );</span>
00510             }
00511 
00512             <span class="comment">//</span>
00513             <span class="comment">//  We now have the total bytes in the pages available.  We</span>
00514             <span class="comment">//  now have to subtract the size of the page header to get</span>
00515             <span class="comment">//  the total available bytes.</span>
00516             <span class="comment">//</span>
00517             <span class="comment">//  We will convert the bytes to pages and then multiple</span>
00518             <span class="comment">//  by the data size of each page.</span>
00519             <span class="comment">//</span>
00520 
00521             FreeBytes = Int64ShrlMod32(((ULONGLONG)(FreeBytes)), Lfcb-&gt;LogPageShift);
00522 
00523             Lfcb-&gt;CurrentAvailable = FreeBytes * (ULONG)Lfcb-&gt;ReservedLogPageSize;                                     <span class="comment">//**** xxXMul( FreeBytes, Lfcb-&gt;ReservedLogPageSize.LowPart );</span>
00524         }
00525 
00526     <span class="comment">//</span>
00527     <span class="comment">//  Otherwise the entire file is available.</span>
00528     <span class="comment">//</span>
00529 
00530     } <span class="keywordflow">else</span> {
00531 
00532         Lfcb-&gt;CurrentAvailable = Lfcb-&gt;MaxCurrentAvail;
00533     }
00534 
00535     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"LfsFindCurrentAvail:  Exit\n"</span>, 0 );
00536 
00537     <span class="keywordflow">return</span>;
00538 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:42:22 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
