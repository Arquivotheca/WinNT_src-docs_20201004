<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: triangle.h Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>triangle.h</h1><a href="../../d7/d5/triangle_8h.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">//</span>
00002 <span class="comment">//  Define the two pointer triangle splay links and the associated</span>
00003 <span class="comment">//  manipuliation macros and routines.  Note that the tri_splay_links should</span>
00004 <span class="comment">//  be an opaque type.  Routine are provided to traverse and manipulate the</span>
00005 <span class="comment">//  structure.</span>
00006 <span class="comment">//</span>
00007 <span class="comment">//  The structure of a tri_splay_links record is really</span>
00008 <span class="comment">//</span>
00009 <span class="comment">//      typedef struct _TRI_SPLAY_LINKS {</span>
00010 <span class="comment">//          ULONG ParSib; // struct _TRI_SPLAY_LINKS *ParSib;</span>
00011 <span class="comment">//          ULONG Child;  // struct _TRI_SPLAY_LINKS *Child;</span>
00012 <span class="comment">//      } TRI_SPLAY_LINKS;</span>
00013 <span class="comment">//</span>
00014 <span class="comment">//  However to aid in debugging (and without extra cost) we declare the</span>
00015 <span class="comment">//  structure to be a union so we can also reference the links as pointers</span>
00016 <span class="comment">//  in the debugger.</span>
00017 <span class="comment">//</span>
00018 
<a name="l00019"></a><a class="code" href="../../d6/d2/union__TRI__SPLAY__LINKS.html">00019</a> <span class="keyword">typedef</span> <span class="keyword">union </span><a class="code" href="../../d6/d2/union__TRI__SPLAY__LINKS.html">_TRI_SPLAY_LINKS</a> {
00020     <span class="keyword">struct </span>{
<a name="l00021"></a><a class="code" href="../../d6/d2/union__TRI__SPLAY__LINKS.html#o0">00021</a>         ULONG <a class="code" href="../../d6/d2/union__TRI__SPLAY__LINKS.html#o0">ParSib</a>;
<a name="l00022"></a><a class="code" href="../../d6/d2/union__TRI__SPLAY__LINKS.html#o1">00022</a>         ULONG <a class="code" href="../../d6/d2/union__TRI__SPLAY__LINKS.html#o1">Child</a>;
00023     } Refs;
00024     <span class="keyword">struct </span>{
<a name="l00025"></a><a class="code" href="../../d6/d2/union__TRI__SPLAY__LINKS.html#o3">00025</a>         <span class="keyword">union </span><a class="code" href="../../d6/d2/union__TRI__SPLAY__LINKS.html">_TRI_SPLAY_LINKS</a> *<a class="code" href="../../d6/d2/union__TRI__SPLAY__LINKS.html#o3">ParSibPtr</a>;
<a name="l00026"></a><a class="code" href="../../d6/d2/union__TRI__SPLAY__LINKS.html#o4">00026</a>         <span class="keyword">union </span><a class="code" href="../../d6/d2/union__TRI__SPLAY__LINKS.html">_TRI_SPLAY_LINKS</a> *<a class="code" href="../../d6/d2/union__TRI__SPLAY__LINKS.html#o4">ChildPtr</a>;
00027     } Ptrs;
00028 } <a class="code" href="../../d6/d2/union__TRI__SPLAY__LINKS.html">TRI_SPLAY_LINKS</a>;
<a name="l00029"></a><a class="code" href="../../d7/d5/triangle_8h.html#a19">00029</a> <span class="keyword">typedef</span> <a class="code" href="../../d6/d2/union__TRI__SPLAY__LINKS.html">TRI_SPLAY_LINKS</a> *<a class="code" href="../../d6/d2/union__TRI__SPLAY__LINKS.html">PTRI_SPLAY_LINKS</a>;
00030 
00031 <span class="comment">//</span>
00032 <span class="comment">//  The macro procedure InitializeSplayLinks takes as input a pointer to</span>
00033 <span class="comment">//  splay link and initializes its substructure.  All splay link nodes must</span>
00034 <span class="comment">//  be initialized before they are used in the different splay routines and</span>
00035 <span class="comment">//  macros.</span>
00036 <span class="comment">//</span>
00037 <span class="comment">// VOID</span>
00038 <span class="comment">// TriInitializeSplayLinks (</span>
00039 <span class="comment">//     IN PTRI_SPLAY_LINKS Links</span>
00040 <span class="comment">//     );</span>
00041 <span class="comment">//</span>
00042 
<a name="l00043"></a><a class="code" href="../../d7/d5/triangle_8h.html#a0">00043</a> <span class="preprocessor">#define TriInitializeSplayLinks(Links) { \</span>
00044 <span class="preprocessor">    (Links)-&gt;Refs.ParSib = MakeIntoParentRef(Links); \</span>
00045 <span class="preprocessor">    (Links)-&gt;Refs.Child = 0; \</span>
00046 <span class="preprocessor">    }</span>
00047 <span class="preprocessor"></span>
00048 <span class="comment">//</span>
00049 <span class="comment">//  The macro function Parent takes as input a pointer to a splay link in a</span>
00050 <span class="comment">//  tree and returns a pointer to the splay link of the parent of the input</span>
00051 <span class="comment">//  node.  If the input node is the root of the tree the return value is</span>
00052 <span class="comment">//  equal to the input value.</span>
00053 <span class="comment">//</span>
00054 <span class="comment">// PTRI_SPLAY_LINKS</span>
00055 <span class="comment">// TriParent (</span>
00056 <span class="comment">//     IN PTRI_SPLAY_LINKS Links</span>
00057 <span class="comment">//     );</span>
00058 <span class="comment">//</span>
00059 
<a name="l00060"></a><a class="code" href="../../d7/d5/triangle_8h.html#a1">00060</a> <span class="preprocessor">#define TriParent(Links) ( \</span>
00061 <span class="preprocessor">    (IsParentRef((Links)-&gt;Refs.ParSib)) ? \</span>
00062 <span class="preprocessor">        MakeIntoPointer((Links)-&gt;Refs.ParSib) \</span>
00063 <span class="preprocessor">    : \</span>
00064 <span class="preprocessor">        MakeIntoPointer(MakeIntoPointer((Links)-&gt;Refs.ParSib)-&gt;Refs.ParSib) \</span>
00065 <span class="preprocessor">    )</span>
00066 <span class="preprocessor"></span>
00067 <span class="comment">//</span>
00068 <span class="comment">//  The macro function LeftChild takes as input a pointer to a splay link in</span>
00069 <span class="comment">//  a tree and returns a pointer to the splay link of the left child of the</span>
00070 <span class="comment">//  input node.  If the left child does not exist, the return value is NULL.</span>
00071 <span class="comment">//</span>
00072 <span class="comment">// PTRI_SPLAY_LINKS</span>
00073 <span class="comment">// TriLeftChild (</span>
00074 <span class="comment">//     IN PTRI_SPLAY_LINKS Links</span>
00075 <span class="comment">//     );</span>
00076 <span class="comment">//</span>
00077 
<a name="l00078"></a><a class="code" href="../../d7/d5/triangle_8h.html#a2">00078</a> <span class="preprocessor">#define TriLeftChild(Links) ( \</span>
00079 <span class="preprocessor">    (IsLeftChildRef((Links)-&gt;Refs.Child)) ? \</span>
00080 <span class="preprocessor">        MakeIntoPointer((Links)-&gt;Refs.Child) \</span>
00081 <span class="preprocessor">    : \</span>
00082 <span class="preprocessor">        0 \</span>
00083 <span class="preprocessor">    )</span>
00084 <span class="preprocessor"></span>
00085 <span class="comment">//</span>
00086 <span class="comment">//  The macro function RightChild takes as input a pointer to a splay link</span>
00087 <span class="comment">//  in a tree and returns a pointer to the splay link of the right child of</span>
00088 <span class="comment">//  the input node.  If the right child does not exist, the return value is</span>
00089 <span class="comment">//  NULL.</span>
00090 <span class="comment">//</span>
00091 <span class="comment">// PTRI_SPLAY_LINKS</span>
00092 <span class="comment">// TriRightChild (</span>
00093 <span class="comment">//     IN PTRI_SPLAY_LINKS Links</span>
00094 <span class="comment">//     );</span>
00095 <span class="comment">//</span>
00096 
<a name="l00097"></a><a class="code" href="../../d7/d5/triangle_8h.html#a3">00097</a> <span class="preprocessor">#define TriRightChild(Links) ( \</span>
00098 <span class="preprocessor">    (IsRightChildRef((Links)-&gt;Refs.Child)) ? \</span>
00099 <span class="preprocessor">        MakeIntoPointer((Links)-&gt;Refs.Child) \</span>
00100 <span class="preprocessor">    : ( \</span>
00101 <span class="preprocessor">        (IsLeftChildRef((Links)-&gt;Refs.Child) &amp;&amp; \</span>
00102 <span class="preprocessor">         IsSiblingRef(MakeIntoPointer((Links)-&gt;Refs.Child)-&gt;Refs.ParSib)) ? \</span>
00103 <span class="preprocessor">            MakeIntoPointer(MakeIntoPointer((Links)-&gt;Refs.Child)-&gt;Refs.ParSib) \</span>
00104 <span class="preprocessor">        : \</span>
00105 <span class="preprocessor">            0 \</span>
00106 <span class="preprocessor">        ) \</span>
00107 <span class="preprocessor">    )</span>
00108 <span class="preprocessor"></span>
00109 <span class="comment">//</span>
00110 <span class="comment">//  The macro function IsRoot takes as input a pointer to a splay link</span>
00111 <span class="comment">//  in a tree and returns TRUE if the input node is the root of the tree,</span>
00112 <span class="comment">//  otherwise it returns FALSE.</span>
00113 <span class="comment">//</span>
00114 <span class="comment">// BOOLEAN</span>
00115 <span class="comment">// TriIsRoot (</span>
00116 <span class="comment">//     IN PTRI_SPLAY_LINKS Links</span>
00117 <span class="comment">//     );</span>
00118 <span class="comment">//</span>
00119 
<a name="l00120"></a><a class="code" href="../../d7/d5/triangle_8h.html#a4">00120</a> <span class="preprocessor">#define TriIsRoot(Links) ( \</span>
00121 <span class="preprocessor">    (IsParentRef((Links)-&gt;Refs.ParSib) &amp;&amp; MakeIntoPointer((Links)-&gt;Refs.ParSib) == (Links)) ? \</span>
00122 <span class="preprocessor">        TRUE \</span>
00123 <span class="preprocessor">    : \</span>
00124 <span class="preprocessor">        FALSE \</span>
00125 <span class="preprocessor">    )</span>
00126 <span class="preprocessor"></span>
00127 <span class="comment">//</span>
00128 <span class="comment">//  The macro function IsLeftChild takes as input a pointer to a splay link</span>
00129 <span class="comment">//  in a tree and returns TRUE if the input node is the left child of its</span>
00130 <span class="comment">//  parent, otherwise it returns FALSE.  Note that if the input link is the</span>
00131 <span class="comment">//  root node this function returns FALSE.</span>
00132 <span class="comment">//</span>
00133 <span class="comment">// BOOLEAN</span>
00134 <span class="comment">// TriIsLeftChild (</span>
00135 <span class="comment">//     IN PTRI_SPLAY_LINKS Links</span>
00136 <span class="comment">//     );</span>
00137 <span class="comment">//</span>
00138 
<a name="l00139"></a><a class="code" href="../../d7/d5/triangle_8h.html#a5">00139</a> <span class="preprocessor">#define TriIsLeftChild(Links) ( \</span>
00140 <span class="preprocessor">    (TriLeftChild(TriParent(Links)) == (Links)) ? \</span>
00141 <span class="preprocessor">        TRUE \</span>
00142 <span class="preprocessor">    : \</span>
00143 <span class="preprocessor">        FALSE \</span>
00144 <span class="preprocessor">    )</span>
00145 <span class="preprocessor"></span>
00146 <span class="comment">//</span>
00147 <span class="comment">//  The macro function IsRightChild takes as input a pointer to a splay link</span>
00148 <span class="comment">//  in a tree and returns TRUE if the input node is the right child of its</span>
00149 <span class="comment">//  parent, otherwise it returns FALSE.  Note that if the input link is the</span>
00150 <span class="comment">//  root node this function returns FALSE.</span>
00151 <span class="comment">//</span>
00152 <span class="comment">// BOOLEAN</span>
00153 <span class="comment">// TriIsRightChild (</span>
00154 <span class="comment">//     IN PTRI_SPLAY_LINKS Links</span>
00155 <span class="comment">//     );</span>
00156 <span class="comment">//</span>
00157 
<a name="l00158"></a><a class="code" href="../../d7/d5/triangle_8h.html#a6">00158</a> <span class="preprocessor">#define TriIsRightChild(Links) ( \</span>
00159 <span class="preprocessor">    (TriRightChild(TriParent(Links)) == (Links)) ? \</span>
00160 <span class="preprocessor">        TRUE \</span>
00161 <span class="preprocessor">    : \</span>
00162 <span class="preprocessor">        FALSE \</span>
00163 <span class="preprocessor">    )</span>
00164 <span class="preprocessor"></span>
00165 <span class="comment">//</span>
00166 <span class="comment">//  The macro procedure InsertAsLeftChild takes as input a pointer to a splay</span>
00167 <span class="comment">//  link in a tree and a pointer to a node not in a tree.  It inserts the</span>
00168 <span class="comment">//  second node as the left child of the first node.  The first node must not</span>
00169 <span class="comment">//  already have a left child, and the second node must not already have a</span>
00170 <span class="comment">//  parent.</span>
00171 <span class="comment">//</span>
00172 <span class="comment">// VOID</span>
00173 <span class="comment">// TriInsertAsLeftChild (</span>
00174 <span class="comment">//     IN PTRI_SPLAY_LINKS ParentLinks,</span>
00175 <span class="comment">//     IN PTRI_SPLAY_LINKS ChildLinks</span>
00176 <span class="comment">//     );</span>
00177 <span class="comment">//</span>
00178 
<a name="l00179"></a><a class="code" href="../../d7/d5/triangle_8h.html#a7">00179</a> <span class="preprocessor">#define TriInsertAsLeftChild(ParentLinks,ChildLinks) { \</span>
00180 <span class="preprocessor">    PTRI_SPLAY_LINKS RightChild; \</span>
00181 <span class="preprocessor">    if ((ParentLinks)-&gt;Refs.Child == 0) { \</span>
00182 <span class="preprocessor">        (ParentLinks)-&gt;Refs.Child = MakeIntoLeftChildRef(ChildLinks); \</span>
00183 <span class="preprocessor">        (ChildLinks)-&gt;Refs.ParSib = MakeIntoParentRef(ParentLinks); \</span>
00184 <span class="preprocessor">    } else { \</span>
00185 <span class="preprocessor">        RightChild = TriRightChild(ParentLinks); \</span>
00186 <span class="preprocessor">        (ParentLinks)-&gt;Refs.Child = MakeIntoLeftChildRef(ChildLinks); \</span>
00187 <span class="preprocessor">        (ChildLinks)-&gt;Refs.ParSib = MakeIntoSiblingRef(RightChild); \</span>
00188 <span class="preprocessor">    } \</span>
00189 <span class="preprocessor">}</span>
00190 <span class="preprocessor"></span>
00191 <span class="comment">//</span>
00192 <span class="comment">//  The macro procedure InsertAsRightChild takes as input a pointer to a splay</span>
00193 <span class="comment">//  link in a tree and a pointer to a node not in a tree.  It inserts the</span>
00194 <span class="comment">//  second node as the right child of the first node.  The first node must not</span>
00195 <span class="comment">//  already have a right child, and the second node must not already have a</span>
00196 <span class="comment">//  parent.</span>
00197 <span class="comment">//</span>
00198 <span class="comment">// VOID</span>
00199 <span class="comment">// TriInsertAsRightChild (</span>
00200 <span class="comment">//     IN PTRI_SPLAY_LINKS ParentLinks,</span>
00201 <span class="comment">//     IN PTRI_SPLAY_LINKS ChildLinks</span>
00202 <span class="comment">//     );</span>
00203 <span class="comment">//</span>
00204 
<a name="l00205"></a><a class="code" href="../../d7/d5/triangle_8h.html#a8">00205</a> <span class="preprocessor">#define TriInsertAsRightChild(ParentLinks,ChildLinks) { \</span>
00206 <span class="preprocessor">    PTRI_SPLAY_LINKS LeftChild; \</span>
00207 <span class="preprocessor">    if ((ParentLinks)-&gt;Refs.Child == 0) { \</span>
00208 <span class="preprocessor">        (ParentLinks)-&gt;Refs.Child = MakeIntoRightChildRef(ChildLinks); \</span>
00209 <span class="preprocessor">        (ChildLinks)-&gt;Refs.ParSib = MakeIntoParentRef(ParentLinks); \</span>
00210 <span class="preprocessor">    } else { \</span>
00211 <span class="preprocessor">        LeftChild = TriLeftChild(ParentLinks); \</span>
00212 <span class="preprocessor">        LeftChild-&gt;Refs.ParSib = MakeIntoSiblingRef(ChildLinks); \</span>
00213 <span class="preprocessor">        (ChildLinks)-&gt;Refs.ParSib = MakeIntoParentRef(ParentLinks); \</span>
00214 <span class="preprocessor">    } \</span>
00215 <span class="preprocessor">}</span>
00216 <span class="preprocessor"></span>
00217 <span class="comment">//</span>
00218 <span class="comment">//  The Splay function takes as input a pointer to a splay link in a tree</span>
00219 <span class="comment">//  and splays the tree.  Its function return value is a pointer to the</span>
00220 <span class="comment">//  root of the splayed tree.</span>
00221 <span class="comment">//</span>
00222 
00223 <a class="code" href="../../d7/d5/triangle_8h.html#a19">PTRI_SPLAY_LINKS</a>
00224 <a class="code" href="../../d7/d5/triangle_8h.html#a20">TriSplay</a> (
00225     IN PTRI_SPLAY_LINKS Links
00226     );
00227 
00228 <span class="comment">//</span>
00229 <span class="comment">//  The Delete function takes as input a pointer to a splay link in a tree</span>
00230 <span class="comment">//  and deletes that node from the tree.  Its function return value is a</span>
00231 <span class="comment">//  pointer to the root of the tree.  If the tree is now empty, the return</span>
00232 <span class="comment">//  value is NULL.</span>
00233 <span class="comment">//</span>
00234 
00235 <a class="code" href="../../d7/d5/triangle_8h.html#a19">PTRI_SPLAY_LINKS</a>
00236 <a class="code" href="../../d7/d5/triangle_8h.html#a21">TriDelete</a> (
00237     IN PTRI_SPLAY_LINKS Links
00238     );
00239 
00240 <span class="comment">//</span>
00241 <span class="comment">//  The SubtreeSuccessor function takes as input a pointer to a splay link</span>
00242 <span class="comment">//  in a tree and returns a pointer to the successor of the input node of</span>
00243 <span class="comment">//  the substree rooted at the input node.  If there is not a successor, the</span>
00244 <span class="comment">//  return value is NULL.</span>
00245 <span class="comment">//</span>
00246 
00247 <a class="code" href="../../d7/d5/triangle_8h.html#a19">PTRI_SPLAY_LINKS</a>
00248 <a class="code" href="../../d7/d5/triangle_8h.html#a22">TriSubtreeSuccessor</a> (
00249     IN PTRI_SPLAY_LINKS Links
00250     );
00251 
00252 <span class="comment">//</span>
00253 <span class="comment">//  The SubtreePredecessor function takes as input a pointer to a splay link</span>
00254 <span class="comment">//  in a tree and returns a pointer to the predecessor of the input node of</span>
00255 <span class="comment">//  the substree rooted at the input node.  If there is not a predecessor,</span>
00256 <span class="comment">//  the return value is NULL.</span>
00257 <span class="comment">//</span>
00258 
00259 <a class="code" href="../../d7/d5/triangle_8h.html#a19">PTRI_SPLAY_LINKS</a>
00260 <a class="code" href="../../d7/d5/triangle_8h.html#a23">TriSubtreePredecessor</a> (
00261     IN PTRI_SPLAY_LINKS Links
00262     );
00263 
00264 <span class="comment">//</span>
00265 <span class="comment">//  The RealSuccessor function takes as input a pointer to a splay link</span>
00266 <span class="comment">//  in a tree and returns a pointer to the successor of the input node within</span>
00267 <span class="comment">//  the entire tree.  If there is not a successor, the return value is NULL.</span>
00268 <span class="comment">//</span>
00269 
00270 <a class="code" href="../../d7/d5/triangle_8h.html#a19">PTRI_SPLAY_LINKS</a>
00271 <a class="code" href="../../d7/d5/triangle_8h.html#a24">TriRealSuccessor</a> (
00272     IN PTRI_SPLAY_LINKS Links
00273     );
00274 
00275 <span class="comment">//</span>
00276 <span class="comment">//  The RealPredecessor function takes as input a pointer to a splay link</span>
00277 <span class="comment">//  in a tree and returns a pointer to the predecessor of the input node</span>
00278 <span class="comment">//  within the entire tree.  If there is not a predecessor, the return value</span>
00279 <span class="comment">//  is NULL.</span>
00280 <span class="comment">//</span>
00281 
00282 <a class="code" href="../../d7/d5/triangle_8h.html#a19">PTRI_SPLAY_LINKS</a>
00283 <a class="code" href="../../d7/d5/triangle_8h.html#a25">TriRealPredecessor</a> (
00284     IN PTRI_SPLAY_LINKS Links
00285     );
00286 
00287 
00288 <span class="comment">//</span>
00289 <span class="comment">//  The remainder of this module really belong in triangle.c  None of</span>
00290 <span class="comment">//  the macros or routines are (logically) exported for use by the programmer</span>
00291 <span class="comment">//  however they need to appear in this module to allow the earlier macros</span>
00292 <span class="comment">//  to function properly.</span>
00293 <span class="comment">//</span>
00294 <span class="comment">//  In the splay record (declared earlier) the low order bit of the</span>
00295 <span class="comment">//  ParSib field indicates whether the link is to a Parent or a Sibling, and</span>
00296 <span class="comment">//  the low order bit of the Child field is used to indicate if the link</span>
00297 <span class="comment">//  is to a left child or a right child.  The values are:</span>
00298 <span class="comment">//</span>
00299 <span class="comment">//      A parent field has the lower bit set to 0</span>
00300 <span class="comment">//      A sibling field has the lower bit set to 1</span>
00301 <span class="comment">//      A left child field has the lower bit set to 0</span>
00302 <span class="comment">//      A right child field has the lower bit set to 1</span>
00303 <span class="comment">//</span>
00304 <span class="comment">//  The comments and code in triangle.c use the term "Ref" to indicate a</span>
00305 <span class="comment">//  ParSib field or a Child field with the low order bit to indicate its type.</span>
00306 <span class="comment">//  A ref cannot be directly used as a pointer.  The following macros help</span>
00307 <span class="comment">//  in deciding the type of a ref and making refs from pointers.  There is</span>
00308 <span class="comment">//  also a macro (MakeIntoPointer) that takes a ref and returns a pointer.</span>
00309 <span class="comment">//</span>
00310 
<a name="l00311"></a><a class="code" href="../../d7/d5/triangle_8h.html#a9">00311</a> <span class="preprocessor">#define IsParentRef(Ulong)           (((((ULONG)Ulong) &amp; 1) == 0) &amp;&amp; ((Ulong) != 0) ? TRUE : FALSE)</span>
<a name="l00312"></a><a class="code" href="../../d7/d5/triangle_8h.html#a10">00312</a> <span class="preprocessor"></span><span class="preprocessor">#define MakeIntoParentRef(Ulong)     (((ULONG)Ulong) &amp; 0xfffffffc)</span>
00313 <span class="preprocessor"></span>
<a name="l00314"></a><a class="code" href="../../d7/d5/triangle_8h.html#a11">00314</a> <span class="preprocessor">#define IsSiblingRef(Ulong)          ((((ULONG)Ulong) &amp; 1) == 1 ? TRUE : FALSE)</span>
<a name="l00315"></a><a class="code" href="../../d7/d5/triangle_8h.html#a12">00315</a> <span class="preprocessor"></span><span class="preprocessor">#define MakeIntoSiblingRef(Ulong)    (((ULONG)Ulong) | 1)</span>
00316 <span class="preprocessor"></span>
<a name="l00317"></a><a class="code" href="../../d7/d5/triangle_8h.html#a13">00317</a> <span class="preprocessor">#define IsLeftChildRef(Ulong)        (((((ULONG)Ulong) &amp; 1) == 0) &amp;&amp; ((Ulong) != 0) ? TRUE : FALSE)</span>
<a name="l00318"></a><a class="code" href="../../d7/d5/triangle_8h.html#a14">00318</a> <span class="preprocessor"></span><span class="preprocessor">#define MakeIntoLeftChildRef(Ulong)  (((ULONG)Ulong) &amp; 0xfffffffc)</span>
00319 <span class="preprocessor"></span>
<a name="l00320"></a><a class="code" href="../../d7/d5/triangle_8h.html#a15">00320</a> <span class="preprocessor">#define IsRightChildRef(Ulong)       ((((ULONG)Ulong) &amp; 1) == 1 ? TRUE : FALSE)</span>
<a name="l00321"></a><a class="code" href="../../d7/d5/triangle_8h.html#a16">00321</a> <span class="preprocessor"></span><span class="preprocessor">#define MakeIntoRightChildRef(Ulong) (((ULONG)Ulong) | 1)</span>
00322 <span class="preprocessor"></span>
<a name="l00323"></a><a class="code" href="../../d7/d5/triangle_8h.html#a17">00323</a> <span class="preprocessor">#define MakeIntoPointer(Ulong)       ((PTRI_SPLAY_LINKS)((Ulong) &amp; 0xfffffffc))</span>
00324 <span class="preprocessor"></span>
00325 
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:42:05 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
