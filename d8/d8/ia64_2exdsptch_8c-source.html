<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: exdsptch.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>exdsptch.c</h1><a href="../../d7/d9/ia64_2exdsptch_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1990  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    exdsptch.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module implements the dispatching of exceptions and the unwinding of</span>
00012 <span class="comment">    procedure call frames.</span>
00013 <span class="comment"></span>
00014 <span class="comment">Author:</span>
00015 <span class="comment"></span>
00016 <span class="comment">    William K. Cheung (wcheung) 23-Dec-1995</span>
00017 <span class="comment"></span>
00018 <span class="comment">    based on the version by David N. Cutler (davec) 11-Sep-1990</span>
00019 <span class="comment"></span>
00020 <span class="comment">Environment:</span>
00021 <span class="comment"></span>
00022 <span class="comment">    Any mode.</span>
00023 <span class="comment"></span>
00024 <span class="comment">Revision History:</span>
00025 <span class="comment"></span>
00026 <span class="comment">    ATM Shafiqul Khalid [askhalid] 8-23-99</span>
00027 <span class="comment">    Added RtlAddFunctionTable and RtlDeleteFunctionTable</span>
00028 <span class="comment"></span>
00029 <span class="comment">--*/</span>
00030 
00031 
00032 <span class="preprocessor">#include "<a class="code" href="../../d5/d9/ntrtlp_8h.html">ntrtlp.h</a>"</span>
00033 
00034 <span class="comment">//  the following section should move to ntia64.h under sdk\inc</span>
00035 
00036 
00037 
00038 PRUNTIME_FUNCTION
00039 <a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a9">RtlLookupStaticFunctionEntry</a>(
00040     IN ULONG_PTR ControlPc,
00041     OUT PBOOLEAN InImage
00042     );
00043 
00044 PRUNTIME_FUNCTION
00045 <a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a10">RtlLookupDynamicFunctionEntry</a>(
00046     IN ULONG_PTR ControlPc,
00047     OUT PULONGLONG ImageBase,
00048     OUT PULONGLONG TargetGp
00049     );
00050 
00051 
<a name="l00052"></a><a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a8">00052</a> LIST_ENTRY <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a7">DynamicFunctionTable</a>;
00053 
00054 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00055 <a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a11">RtlRestoreContext</a> (
00056     IN PCONTEXT ContextRecord,
00057     IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL
00058     );
00059 
00060 
00061 <span class="comment">//</span>
00062 <span class="comment">// Define local macros.</span>
00063 <span class="comment">//</span>
00064 <span class="comment">// Raise noncontinuable exception with associated exception record.</span>
00065 <span class="comment">//</span>
00066 
<a name="l00067"></a><a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a0">00067</a> <span class="preprocessor">#define IS_HANDLER_DEFINED(f, base)                                \</span>
00068 <span class="preprocessor">    (f-&gt;UnwindInfoAddress &amp;&amp;                                       \</span>
00069 <span class="preprocessor">        (((PUNWIND_INFO)(base+f-&gt;UnwindInfoAddress))-&gt;Flags &amp; 0x3))</span>
00070 <span class="preprocessor"></span>
<a name="l00071"></a><a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a1">00071</a> <span class="preprocessor">#define HANDLER(f, base, target)                                                \</span>
00072 <span class="preprocessor">    (PEXCEPTION_ROUTINE)                                                        \</span>
00073 <span class="preprocessor">        (*(PULONGLONG) ((LONGLONG)target +                                      \</span>
00074 <span class="preprocessor">        (*(PULONGLONG) (base + f-&gt;UnwindInfoAddress + sizeof(UNWIND_INFO)  +    \</span>
00075 <span class="preprocessor">        (((PUNWIND_INFO) (base + f-&gt;UnwindInfoAddress))-&gt;DataLength * sizeof(ULONGLONG))))))</span>
00076 <span class="preprocessor"></span>
<a name="l00077"></a><a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a2">00077</a> <span class="preprocessor">#define RAISE_EXCEPTION(Status, ExceptionRecordt) {                \</span>
00078 <span class="preprocessor">    EXCEPTION_RECORD ExceptionRecordn;                             \</span>
00079 <span class="preprocessor">                                                                   \</span>
00080 <span class="preprocessor">    ExceptionRecordn.ExceptionCode = Status;                       \</span>
00081 <span class="preprocessor">    ExceptionRecordn.ExceptionFlags = EXCEPTION_NONCONTINUABLE;    \</span>
00082 <span class="preprocessor">    ExceptionRecordn.ExceptionRecord = ExceptionRecordt;           \</span>
00083 <span class="preprocessor">    ExceptionRecordn.NumberParameters = 0;                         \</span>
00084 <span class="preprocessor">    RtlRaiseException(&amp;ExceptionRecordn);                          \</span>
00085 <span class="preprocessor">    }</span>
00086 <span class="preprocessor"></span>
<a name="l00087"></a><a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a3">00087</a> <span class="preprocessor">#define IS_SAME_FRAME(Frame1, Frame2)                              \</span>
00088 <span class="preprocessor">    ( (Frame1.MemoryStackFp == Frame2.MemoryStackFp) &amp;&amp;            \</span>
00089 <span class="preprocessor">      (Frame1.BackingStoreFp == Frame2.BackingStoreFp) )</span>
00090 <span class="preprocessor"></span>
<a name="l00091"></a><a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a4">00091</a> <span class="preprocessor">#define INITIALIZE_FRAME(Frame)                                    \</span>
00092 <span class="preprocessor">    Frame.MemoryStackFp = Frame.BackingStoreFp = 0</span>
00093 <span class="preprocessor"></span>
<a name="l00094"></a><a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a5">00094</a> <span class="preprocessor">#define CHECK_MSTACK_FRAME(Establisher, Target)                            \</span>
00095 <span class="preprocessor">    ((Establisher.MemoryStackFp &lt; LowStackLimit) ||                        \</span>
00096 <span class="preprocessor">     (Establisher.MemoryStackFp &gt; HighStackLimit) ||                       \</span>
00097 <span class="preprocessor">     ((Target.MemoryStackFp != 0) &amp;&amp;                                       \</span>
00098 <span class="preprocessor">      ((ULONG)Target.MemoryStackFp &lt; (ULONG)Establisher.MemoryStackFp)) || \</span>
00099 <span class="preprocessor">     ((Establisher.MemoryStackFp &amp; 0x3) != 0))</span>
00100 <span class="preprocessor"></span>
<a name="l00101"></a><a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a6">00101</a> <span class="preprocessor">#define CHECK_BSTORE_FRAME(Establisher, Target)                               \</span>
00102 <span class="preprocessor">    ((Establisher.BackingStoreFp &lt; LowBStoreLimit) ||                         \</span>
00103 <span class="preprocessor">     (Establisher.BackingStoreFp &gt; HighBStoreLimit) ||                        \</span>
00104 <span class="preprocessor">     ((Target.BackingStoreFp != 0) &amp;&amp;                                         \</span>
00105 <span class="preprocessor">      ((ULONG)Target.BackingStoreFp &gt; (ULONG)Establisher.BackingStoreFp)) ||  \</span>
00106 <span class="preprocessor">     ((Establisher.BackingStoreFp &amp; 0x7) != 0))</span>
00107 <span class="preprocessor"></span>
<a name="l00108"></a><a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a7">00108</a> <span class="preprocessor">#define IS_EM_SETJMP_REGISTRATION(ExRegistration)                                               \</span>
00109 <span class="preprocessor">    (   (ExRegistration != NULL)                                                            &amp;&amp;  \</span>
00110 <span class="preprocessor">        (ExRegistration != EXCEPTION_CHAIN_END)                                             &amp;&amp;  \</span>
00111 <span class="preprocessor">        (ExRegistration-&gt;Next == (struct _EXCEPTION_REGISTRATION_RECORD *)(LONG_PTR) 1)          \</span>
00112 <span class="preprocessor">    )</span>
00113 <span class="preprocessor"></span>
00114 
00115 ULONGLONG
00116 <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a6">RtlpVirtualUnwind</a> (
00117     IN ULONGLONG ImageBase,
00118     IN ULONGLONG ControlPc,
00119     IN PRUNTIME_FUNCTION FunctionEntry,
00120     IN PCONTEXT ContextRecord,
00121     OUT PBOOLEAN InFunction,
00122     OUT PFRAME_POINTERS EstablisherFrame,
00123     IN OUT PKNONVOLATILE_CONTEXT_POINTERS ContextPointers OPTIONAL
00124     );
00125 
00126 
00127 PEXCEPTION_REGISTRATION_RECORD
<a name="l00128"></a><a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a13">00128</a> <a class="code" href="../../d3/d9/ntrtli64_8h.html#a3">RtlpGetRegistrationHead</a> (
00129     IN VOID
00130     )
00131 
00132 <span class="comment">/*++</span>
00133 <span class="comment"></span>
00134 <span class="comment">Routine Description:</span>
00135 <span class="comment"></span>
00136 <span class="comment">    This function returns the address of the first exception registration</span>
00137 <span class="comment">    record for the current context.</span>
00138 <span class="comment"></span>
00139 <span class="comment">Arguments:</span>
00140 <span class="comment"></span>
00141 <span class="comment">    None.</span>
00142 <span class="comment"></span>
00143 <span class="comment">Return Value:</span>
00144 <span class="comment"></span>
00145 <span class="comment">    The address of the first registration record.</span>
00146 <span class="comment"></span>
00147 <span class="comment">--*/</span>
00148 
00149 {
00150     PTEB CurrentTeb = NtCurrentTeb();
00151 
00152     <span class="keywordflow">return</span> (CurrentTeb ? CurrentTeb-&gt;NtTib.ExceptionList : EXCEPTION_CHAIN_END);
00153 }
00154 
00155 
00156 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00157"></a><a class="code" href="../../d3/d9/ntrtli64_8h.html#a2">00157</a> <a class="code" href="../../d3/d9/ntrtli64_8h.html#a2">RtlpUnlinkHandler</a> (
00158     PEXCEPTION_REGISTRATION_RECORD UnlinkPointer
00159     )
00160 
00161 <span class="comment">/*++</span>
00162 <span class="comment"></span>
00163 <span class="comment">Routine Description:</span>
00164 <span class="comment"></span>
00165 <span class="comment">    This function removes the specified exception registration record</span>
00166 <span class="comment">    (and thus the relevant handler) from the exception traversal chain.</span>
00167 <span class="comment"></span>
00168 <span class="comment">Arguments:</span>
00169 <span class="comment"></span>
00170 <span class="comment">    UnlinkPointer - Address of registration record to unlink.</span>
00171 <span class="comment"></span>
00172 <span class="comment">Return Value:</span>
00173 <span class="comment"></span>
00174 <span class="comment">    None.</span>
00175 <span class="comment"></span>
00176 <span class="comment">--*/</span>
00177 
00178 {
00179     NtCurrentTeb()-&gt;NtTib.ExceptionList = UnlinkPointer-&gt;Next;
00180 }
00181 
00182 
00183 PRUNTIME_FUNCTION
<a name="l00184"></a><a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a15">00184</a> <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a> (
00185     IN ULONGLONG ControlPc,
00186     OUT PULONGLONG ImageBase,
00187     OUT PULONGLONG TargetGp
00188     )
00189 
00190 <span class="comment">/*++</span>
00191 <span class="comment"></span>
00192 <span class="comment">Routine Description:</span>
00193 <span class="comment"></span>
00194 <span class="comment">    This function searches the currently active function tables for an</span>
00195 <span class="comment">    entry that corresponds to the specified PC value.</span>
00196 <span class="comment"></span>
00197 <span class="comment">Arguments:</span>
00198 <span class="comment"></span>
00199 <span class="comment">    ControlPc - Supplies the virtual address of an instruction bundle</span>
00200 <span class="comment">        within the specified function.</span>
00201 <span class="comment"></span>
00202 <span class="comment">    ImageBase - Returns the base address of the module to which the</span>
00203 <span class="comment">                function belongs.</span>
00204 <span class="comment"></span>
00205 <span class="comment">    TargetGp - Returns the global pointer value of the module.</span>
00206 <span class="comment"></span>
00207 <span class="comment">Return Value:</span>
00208 <span class="comment"></span>
00209 <span class="comment">    If there is no entry in the function table for the specified PC, then</span>
00210 <span class="comment">    NULL is returned.  Otherwise, the address of the function table entry</span>
00211 <span class="comment">    that corresponds to the specified PC is returned.</span>
00212 <span class="comment"></span>
00213 <span class="comment">--*/</span>
00214 
00215 {
00216     PRUNTIME_FUNCTION FunctionEntry;
00217     PRUNTIME_FUNCTION FunctionTable;
00218     ULONG SizeOfExceptionTable;
00219     ULONG <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
00220     LONG High;
00221     LONG Middle;
00222     LONG Low;
00223     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> i;
00224 
00225     <span class="comment">//</span>
00226     <span class="comment">// Search for the image that includes the specified swizzled PC value.</span>
00227     <span class="comment">//</span>
00228 
00229     *ImageBase = (ULONG_PTR)<a class="code" href="../../d6/d4/pctohdr_8c.html#a1">RtlPcToFileHeader</a>((PVOID)ControlPc, 
00230                                               (PVOID *)ImageBase);
00231     
00232 
00233     <span class="comment">//</span>
00234     <span class="comment">// If an image is found that includes the specified PC, then locate the</span>
00235     <span class="comment">// function table for the image.</span>
00236     <span class="comment">//</span>
00237 
00238     <span class="keywordflow">if</span> ((PVOID)*ImageBase != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00239 
00240         *TargetGp = (ULONG_PTR)(<a class="code" href="../../d8/d9/imagedir_8c.html#a5">RtlImageDirectoryEntryToData</a>(
00241                                (PVOID)*ImageBase,
00242                                <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00243                                IMAGE_DIRECTORY_ENTRY_GLOBALPTR,
00244                                &amp;<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>
00245                                ));
00246 
00247         FunctionTable = (PRUNTIME_FUNCTION)<a class="code" href="../../d8/d9/imagedir_8c.html#a5">RtlImageDirectoryEntryToData</a>(
00248                          (PVOID)*ImageBase, 
00249                          <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, 
00250                          IMAGE_DIRECTORY_ENTRY_EXCEPTION,
00251                          &amp;SizeOfExceptionTable);
00252 
00253         <span class="comment">//</span>
00254         <span class="comment">// If a function table is located, then search the table for a</span>
00255         <span class="comment">// function table entry for the specified PC.</span>
00256         <span class="comment">//</span>
00257 
00258         <span class="keywordflow">if</span> (FunctionTable != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00259 
00260             <span class="comment">//</span>
00261             <span class="comment">// Initialize search indices.</span>
00262             <span class="comment">//</span>
00263 
00264             Low = 0;
00265             High = (SizeOfExceptionTable / <span class="keyword">sizeof</span>(RUNTIME_FUNCTION)) - 1;
00266             ControlPc = ControlPc - *ImageBase;
00267 
00268             <span class="comment">//</span>
00269             <span class="comment">// Perform binary search on the function table for a function table</span>
00270             <span class="comment">// entry that subsumes the specified PC.</span>
00271             <span class="comment">//</span>
00272 
00273             <span class="keywordflow">while</span> (High &gt;= Low) {
00274 
00275                 <span class="comment">//</span>
00276                 <span class="comment">// Compute next probe index and test entry. If the specified PC</span>
00277                 <span class="comment">// is greater than of equal to the beginning address and less</span>
00278                 <span class="comment">// than the ending address of the function table entry, then</span>
00279                 <span class="comment">// return the address of the function table entry. Otherwise,</span>
00280                 <span class="comment">// continue the search.</span>
00281                 <span class="comment">//</span>
00282 
00283                 Middle = (Low + High) &gt;&gt; 1;
00284                 FunctionEntry = &amp;FunctionTable[Middle];
00285 
00286                 <span class="keywordflow">if</span> (ControlPc &lt; FunctionEntry-&gt;BeginAddress) {
00287                     High = Middle - 1;
00288 
00289                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ControlPc &gt;= FunctionEntry-&gt;EndAddress) {
00290                     Low = Middle + 1;
00291 
00292                 } <span class="keywordflow">else</span> {
00293                     <span class="keywordflow">return</span> FunctionEntry;
00294 
00295                 }
00296             }
00297         }
00298     } 
00299 <span class="preprocessor">#if !defined(NTOS_KERNEL_RUNTIME)</span>
00300 <span class="preprocessor"></span>    
00301     <span class="keywordflow">else</span>     <span class="comment">// ImageBase == NULL</span>
00302         <span class="keywordflow">return</span>   <a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a10">RtlLookupDynamicFunctionEntry</a> ( ControlPc, ImageBase, TargetGp );
00303 
00304 <span class="preprocessor">#endif  // NTOS_KERNEL_RUNTIME</span>
00305 <span class="preprocessor"></span>
00306     <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00307 }
00308 
00309 
00310 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00311"></a><a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a4">00311</a> <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a4">RtlpRaiseException</a> (
00312     IN PEXCEPTION_RECORD ExceptionRecord
00313     )
00314 
00315 <span class="comment">/*++</span>
00316 <span class="comment"></span>
00317 <span class="comment">Routine Description:</span>
00318 <span class="comment"></span>
00319 <span class="comment">    This function raises a software exception by building a context record</span>
00320 <span class="comment">    and calling the raise exception system service.</span>
00321 <span class="comment"></span>
00322 <span class="comment">Arguments:</span>
00323 <span class="comment"></span>
00324 <span class="comment">    ExceptionRecord - Supplies a pointer to an exception record.</span>
00325 <span class="comment"></span>
00326 <span class="comment">Return Value:</span>
00327 <span class="comment"></span>
00328 <span class="comment">    None.</span>
00329 <span class="comment"></span>
00330 <span class="comment">--*/</span>
00331 
00332 {
00333     ULONGLONG ImageBase;
00334     ULONGLONG TargetGp;
00335     ULONGLONG ControlPc;
00336     CONTEXT ContextRecord;
00337     FRAME_POINTERS EstablisherFrame;
00338     PRUNTIME_FUNCTION FunctionEntry;
00339     BOOLEAN InFunction;
00340     ULONGLONG NextPc;
00341     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00342 
00343     <span class="comment">//</span>
00344     <span class="comment">// Capture the current context, virtually unwind to the caller of this</span>
00345     <span class="comment">// routine, set the fault instruction address to that of the caller, and</span>
00346     <span class="comment">// call the raise exception system service.</span>
00347     <span class="comment">//</span>
00348 
00349     RtlCaptureContext(&amp;ContextRecord);
00350     ControlPc = RtlIa64InsertIPSlotNumber((ContextRecord.BrRp-16), 2);
00351     FunctionEntry = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>(ControlPc, &amp;ImageBase, &amp;TargetGp);
00352     NextPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ImageBase,
00353                               ControlPc,
00354                               FunctionEntry,
00355                               &amp;ContextRecord,
00356                               &amp;InFunction,
00357                               &amp;EstablisherFrame,
00358                               <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00359 
00360     ContextRecord.StIIP = NextPc + 8;
00361     ContextRecord.StIPSR &amp;= ~((ULONGLONG) 3 &lt;&lt; PSR_RI);
00362     ExceptionRecord-&gt;ExceptionAddress = (PVOID)ContextRecord.StIIP;
00363     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwRaiseException(ExceptionRecord, &amp;ContextRecord, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
00364 
00365     <span class="comment">//</span>
00366     <span class="comment">// There should never be a return from this system service unless</span>
00367     <span class="comment">// there is a problem with the argument list itself. Raise another</span>
00368     <span class="comment">// exception specifying the status value returned.</span>
00369     <span class="comment">//</span>
00370 
00371     <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a10">RtlRaiseStatus</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>);
00372     <span class="keywordflow">return</span>;
00373 }
00374 
00375 
00376 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00377"></a><a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a17">00377</a> <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a9">RtlRaiseException</a> (
00378     IN PEXCEPTION_RECORD ExceptionRecord
00379     )
00380 
00381 <span class="comment">/*++</span>
00382 <span class="comment"></span>
00383 <span class="comment">Routine Description:</span>
00384 <span class="comment"></span>
00385 <span class="comment">    This function raises a software exception by building a context record</span>
00386 <span class="comment">    and calling the raise exception system service.</span>
00387 <span class="comment"></span>
00388 <span class="comment">    N.B. This routine is a shell routine that simply calls another routine</span>
00389 <span class="comment">         to do the real work. The reason this is done is to avoid a problem</span>
00390 <span class="comment">         in try/finally scopes where the last statement in the scope is a</span>
00391 <span class="comment">         call to raise an exception.</span>
00392 <span class="comment"></span>
00393 <span class="comment">Arguments:</span>
00394 <span class="comment"></span>
00395 <span class="comment">    ExceptionRecord - Supplies a pointer to an exception record.</span>
00396 <span class="comment"></span>
00397 <span class="comment">Return Value:</span>
00398 <span class="comment"></span>
00399 <span class="comment">    None.</span>
00400 <span class="comment"></span>
00401 <span class="comment">--*/</span>
00402 
00403 {
00404     <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a4">RtlpRaiseException</a>(ExceptionRecord);
00405     <span class="keywordflow">return</span>;
00406 }
00407 
00408 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00409"></a><a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a5">00409</a> <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a5">RtlpRaiseStatus</a> (
00410     IN NTSTATUS Status
00411     )
00412 
00413 <span class="comment">/*++</span>
00414 <span class="comment"></span>
00415 <span class="comment">Routine Description:</span>
00416 <span class="comment"></span>
00417 <span class="comment">    This function raises an exception with the specified status value. The</span>
00418 <span class="comment">    exception is marked as noncontinuable with no parameters.</span>
00419 <span class="comment"></span>
00420 <span class="comment">Arguments:</span>
00421 <span class="comment"></span>
00422 <span class="comment">    Status - Supplies the status value to be used as the exception code</span>
00423 <span class="comment">        for the exception that is to be raised.</span>
00424 <span class="comment"></span>
00425 <span class="comment">Return Value:</span>
00426 <span class="comment"></span>
00427 <span class="comment">    None.</span>
00428 <span class="comment"></span>
00429 <span class="comment">--*/</span>
00430 
00431 {
00432     ULONGLONG ImageBase;
00433     ULONGLONG TargetGp;
00434     ULONGLONG ControlPc;
00435     ULONGLONG NextPc;
00436     CONTEXT ContextRecord;
00437     FRAME_POINTERS EstablisherFrame;
00438     EXCEPTION_RECORD ExceptionRecord;
00439     PRUNTIME_FUNCTION FunctionEntry;
00440     BOOLEAN InFunction;
00441 
00442     <span class="comment">//</span>
00443     <span class="comment">// Construct an exception record.</span>
00444     <span class="comment">//</span>
00445 
00446     ExceptionRecord.ExceptionCode = <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00447     ExceptionRecord.ExceptionRecord = (PEXCEPTION_RECORD)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00448     ExceptionRecord.NumberParameters = 0;
00449     ExceptionRecord.ExceptionFlags = <a class="code" href="../../d6/d7/halmips_8h.html#a25">EXCEPTION_NONCONTINUABLE</a>;
00450 
00451     <span class="comment">//</span>
00452     <span class="comment">// Capture the current context, virtually unwind to the caller of this</span>
00453     <span class="comment">// routine, set the fault instruction address to that of the caller, and</span>
00454     <span class="comment">// call the raise exception system service.</span>
00455     <span class="comment">//</span>
00456 
00457     RtlCaptureContext(&amp;ContextRecord);
00458     ControlPc = RtlIa64InsertIPSlotNumber((ContextRecord.BrRp-16), 2);
00459     FunctionEntry = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>(ControlPc, &amp;ImageBase, &amp;TargetGp);
00460     NextPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ImageBase,
00461                               ControlPc,
00462                               FunctionEntry,
00463                               &amp;ContextRecord,
00464                               &amp;InFunction,
00465                               &amp;EstablisherFrame,
00466                               <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00467     ContextRecord.StIIP = NextPc + 8;
00468     ContextRecord.StIPSR &amp;= ~((ULONGLONG) 3 &lt;&lt; PSR_RI);
00469     ExceptionRecord.ExceptionAddress = (PVOID)ContextRecord.StIIP;
00470     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwRaiseException(&amp;ExceptionRecord, &amp;ContextRecord, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
00471 
00472     <span class="comment">//</span>
00473     <span class="comment">// There should never be a return from this system service unless</span>
00474     <span class="comment">// there is a problem with the argument list itself. Raise another</span>
00475     <span class="comment">// exception specifying the status value returned.</span>
00476     <span class="comment">//</span>
00477 
00478     <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a10">RtlRaiseStatus</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>);
00479     <span class="keywordflow">return</span>;
00480 }
00481 
00482 
00483 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00484"></a><a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a19">00484</a> <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a10">RtlRaiseStatus</a> (
00485     IN NTSTATUS Status
00486     )
00487 
00488 <span class="comment">/*++</span>
00489 <span class="comment"></span>
00490 <span class="comment">Routine Description:</span>
00491 <span class="comment"></span>
00492 <span class="comment">    This function raises an exception with the specified status value. The</span>
00493 <span class="comment">    exception is marked as noncontinuable with no parameters.</span>
00494 <span class="comment"></span>
00495 <span class="comment">    N.B. This routine is a shell routine that simply calls another routine</span>
00496 <span class="comment">         to do the real work. The reason this is done is to avoid a problem</span>
00497 <span class="comment">         in try/finally scopes where the last statement in the scope is a</span>
00498 <span class="comment">         call to raise an exception.</span>
00499 <span class="comment"></span>
00500 <span class="comment">Arguments:</span>
00501 <span class="comment"></span>
00502 <span class="comment">    Status - Supplies the status value to be used as the exception code</span>
00503 <span class="comment">        for the exception that is to be raised.</span>
00504 <span class="comment"></span>
00505 <span class="comment">Return Value:</span>
00506 <span class="comment"></span>
00507 <span class="comment">    None.</span>
00508 <span class="comment"></span>
00509 <span class="comment">--*/</span>
00510 
00511 {
00512     <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a5">RtlpRaiseStatus</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>);
00513     <span class="keywordflow">return</span>;
00514 }
00515 
00516 
00517 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00518"></a><a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a20">00518</a> <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a11">RtlUnwind</a> (
00519     IN PVOID TargetFrame OPTIONAL,
00520     IN PVOID TargetIp OPTIONAL,
00521     IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
00522     IN PVOID ReturnValue
00523     )
00524 
00525 <span class="comment">/*++</span>
00526 <span class="comment"></span>
00527 <span class="comment">Routine Description:</span>
00528 <span class="comment"></span>
00529 <span class="comment">    This function initiates an unwind of procedure call frames. The machine</span>
00530 <span class="comment">    state at the time of the call to unwind is captured in a context record</span>
00531 <span class="comment">    and the unwinding flag is set in the exception flags of the exception</span>
00532 <span class="comment">    record. If the TargetFrame parameter is not specified, then the exit unwind</span>
00533 <span class="comment">    flag is also set in the exception flags of the exception record. A backward</span>
00534 <span class="comment">    scan through the procedure call frames is then performed to find the target</span>
00535 <span class="comment">    of the unwind operation.</span>
00536 <span class="comment"></span>
00537 <span class="comment">    As each frame is encounter, the PC where control left the corresponding</span>
00538 <span class="comment">    function is determined and used to lookup exception handler information</span>
00539 <span class="comment">    in the runtime function table built by the linker. If the respective</span>
00540 <span class="comment">    routine has an exception handler, then the handler is called.</span>
00541 <span class="comment"></span>
00542 <span class="comment">    N.B. This routine is provided for backward compatibility with release 1.</span>
00543 <span class="comment"></span>
00544 <span class="comment">Arguments:</span>
00545 <span class="comment"></span>
00546 <span class="comment">    TargetFrame - Supplies an optional pointer to the call frame that is the</span>
00547 <span class="comment">        target of the unwind. If this parameter is not specified, then an exit</span>
00548 <span class="comment">        unwind is performed.</span>
00549 <span class="comment"></span>
00550 <span class="comment">    TargetIp - Supplies an optional instruction address that specifies the</span>
00551 <span class="comment">        continuation address of the unwind. This address is ignored if the</span>
00552 <span class="comment">        target frame parameter is not specified.</span>
00553 <span class="comment"></span>
00554 <span class="comment">    ExceptionRecord - Supplies an optional pointer to an exception record.</span>
00555 <span class="comment"></span>
00556 <span class="comment">    ReturnValue - Supplies a value that is to be placed in the integer</span>
00557 <span class="comment">        function return register just before continuing execution.</span>
00558 <span class="comment"></span>
00559 <span class="comment">Return Value:</span>
00560 <span class="comment"></span>
00561 <span class="comment">    None.</span>
00562 <span class="comment"></span>
00563 <span class="comment">--*/</span>
00564 
00565 {
00566     CONTEXT ContextRecord;
00567     FRAME_POINTERS Frame;
00568     PEXCEPTION_REGISTRATION_RECORD RegistrationPointer;
00569 
00570     Frame.MemoryStackFp = (ULONG_PTR)TargetFrame;
00571     Frame.BackingStoreFp = 0;
00572     ContextRecord.StIPSR = 0;
00573 
00574     RegistrationPointer = (PEXCEPTION_REGISTRATION_RECORD)TargetFrame;
00575     <span class="keywordflow">if</span> ((RegistrationPointer != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
00576         <a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a7">IS_EM_SETJMP_REGISTRATION</a>(RegistrationPointer)) {
00577 
00578         <span class="comment">//</span>
00579         <span class="comment">// iA longjmp to an EM setjmp site, materialize the TargetFrame.</span>
00580         <span class="comment">// resume execution in EM mode.</span>
00581         <span class="comment">//</span>
00582 
00583         PULONGLONG Record = (PULONGLONG)(RegistrationPointer);
00584 
00585         Frame.MemoryStackFp = Record[1];
00586         Frame.BackingStoreFp = Record[2];
00587     }
00588 
00589     <span class="comment">//</span>
00590     <span class="comment">// Call real unwind routine specifying a context record as an</span>
00591     <span class="comment">// extra argument.</span>
00592     <span class="comment">//</span>
00593 
00594     <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a12">RtlUnwind2</a>(Frame,
00595                TargetIp,
00596                ExceptionRecord,
00597                ReturnValue,
00598                &amp;ContextRecord);
00599 
00600     <span class="keywordflow">return</span>;
00601 }
00602 
00603 
00604 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00605"></a><a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a21">00605</a> <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a12">RtlUnwind2</a> (
00606     IN FRAME_POINTERS TargetFrame OPTIONAL,
00607     IN PVOID TargetIp OPTIONAL,
00608     IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
00609     IN PVOID ReturnValue,
00610     IN PCONTEXT ContextRecord
00611     )
00612 
00613 <span class="comment">/*++</span>
00614 <span class="comment"></span>
00615 <span class="comment">Routine Description:</span>
00616 <span class="comment"></span>
00617 <span class="comment">    This function initiates an unwind of procedure call frames. The machine</span>
00618 <span class="comment">    state at the time of the call to unwind is captured in a context record</span>
00619 <span class="comment">    and the unwinding flag is set in the exception flags of the exception</span>
00620 <span class="comment">    record. If the TargetFrame parameter is not specified, then the exit unwind</span>
00621 <span class="comment">    flag is also set in the exception flags of the exception record. A backward</span>
00622 <span class="comment">    scan through the procedure call frames is then performed to find the target</span>
00623 <span class="comment">    of the unwind operation.</span>
00624 <span class="comment"></span>
00625 <span class="comment">    As each frame is encounter, the PC where control left the corresponding</span>
00626 <span class="comment">    function is determined and used to lookup exception handler information</span>
00627 <span class="comment">    in the runtime function table built by the linker. If the respective</span>
00628 <span class="comment">    routine has an exception handler, then the handler is called.</span>
00629 <span class="comment"></span>
00630 <span class="comment">Arguments:</span>
00631 <span class="comment"></span>
00632 <span class="comment">    TargetFrame - Supplies an optional pointer to the call frame that is the</span>
00633 <span class="comment">        target of the unwind. If this parameter is not specified, then an exit</span>
00634 <span class="comment">        unwind is performed.</span>
00635 <span class="comment"></span>
00636 <span class="comment">    TargetIp - Supplies an optional instruction address that specifies the</span>
00637 <span class="comment">        continuation address of the unwind. This address is ignored if the</span>
00638 <span class="comment">        target frame parameter is not specified.</span>
00639 <span class="comment"></span>
00640 <span class="comment">    ExceptionRecord - Supplies an optional pointer to an exception record.</span>
00641 <span class="comment"></span>
00642 <span class="comment">    ReturnValue - Supplies a value that is to be placed in the integer</span>
00643 <span class="comment">        function return register just before continuing execution.</span>
00644 <span class="comment"></span>
00645 <span class="comment">    ContextRecord - Supplies a pointer to a context record that can be used</span>
00646 <span class="comment">        to store context druing the unwind operation.</span>
00647 <span class="comment"></span>
00648 <span class="comment">Return Value:</span>
00649 <span class="comment"></span>
00650 <span class="comment">    None.</span>
00651 <span class="comment"></span>
00652 <span class="comment">--*/</span>
00653 
00654 {
00655     ULONGLONG TargetGp;
00656     ULONGLONG ImageBase;
00657     ULONGLONG ControlPc;
00658     ULONGLONG NextPc;
00659     ULONG ExceptionFlags;
00660     <a class="code" href="../../d0/d6/struct__DISPATCHER__CONTEXT.html">DISPATCHER_CONTEXT</a> DispatcherContext;
00661     EXCEPTION_DISPOSITION Disposition;
00662     FRAME_POINTERS EstablisherFrame;
00663     EXCEPTION_RECORD ExceptionRecord1;
00664     PRUNTIME_FUNCTION FunctionEntry;
00665     ULONGLONG HighStackLimit;
00666     ULONGLONG LowStackLimit;
00667     ULONGLONG HighBStoreLimit;
00668     ULONGLONG LowBStoreLimit;
00669     ULONG <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
00670     BOOLEAN InFunction;
00671 
00672     <span class="comment">//</span>
00673     <span class="comment">// Get current memory stack and backing store limits, capture the </span>
00674     <span class="comment">// current context, virtually unwind to the caller of this routine, </span>
00675     <span class="comment">// get the initial PC value, and set the unwind target address.</span>
00676     <span class="comment">//</span>
00677     <span class="comment">// N.B. The target gp value is found in the input context record.</span>
00678     <span class="comment">//      The unwinder guarantees that it will not be destroyed</span>
00679     <span class="comment">//      as it is just a scratch register.</span>
00680     <span class="comment">//</span>
00681 
00682     RtlCaptureContext(ContextRecord);
00683 
00684     <span class="comment">//</span>
00685     <span class="comment">// Before getting the limits from the TEB, must flush the RSE to have</span>
00686     <span class="comment">// the OS to grow the backing store and update the BStoreLimit.</span>
00687     <span class="comment">//</span>
00688 
00689     <a class="code" href="../../d3/d9/ntrtli64_8h.html#a0">Rtlp64GetStackLimits</a>(&amp;LowStackLimit, &amp;HighStackLimit);
00690     <a class="code" href="../../d3/d9/ntrtli64_8h.html#a1">Rtlp64GetBStoreLimits</a>(&amp;LowBStoreLimit, &amp;HighBStoreLimit);
00691 
00692     ControlPc = RtlIa64InsertIPSlotNumber((ContextRecord-&gt;BrRp-16), 2);
00693     FunctionEntry = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>(ControlPc, &amp;ImageBase, &amp;TargetGp);
00694     NextPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ImageBase,
00695                               ControlPc,
00696                               FunctionEntry,
00697                               ContextRecord,
00698                               &amp;InFunction,
00699                               &amp;EstablisherFrame,
00700                               <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00701 
00702     ControlPc = NextPc;
00703     ContextRecord-&gt;StIIP = (ULONGLONG)TargetIp;
00704 
00705 <span class="preprocessor">#if defined(NTOS_KERNEL_RUNTIME)</span>
00706 <span class="preprocessor"></span>    ContextRecord-&gt;StIPSR = SANITIZE_PSR(ContextRecord-&gt;StIPSR, <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>);
00707 <span class="preprocessor">#else</span>
00708 <span class="preprocessor"></span>    ContextRecord-&gt;StIPSR = SANITIZE_PSR(ContextRecord-&gt;StIPSR, <a class="code" href="../../d0/d9/ntosdef_8h.html#a76a70">UserMode</a>);
00709 <span class="preprocessor">#endif // defined(NTOS_KERNEL_RUNTIME)</span>
00710 <span class="preprocessor"></span>
00711     <span class="comment">//</span>
00712     <span class="comment">// If an exception record is not specified, then build a local exception</span>
00713     <span class="comment">// record for use in calling exception handlers during the unwind operation.</span>
00714     <span class="comment">//</span>
00715 
00716     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(ExceptionRecord) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00717         ExceptionRecord = &amp;ExceptionRecord1;
00718         ExceptionRecord1.ExceptionCode = STATUS_UNWIND;
00719         ExceptionRecord1.ExceptionRecord = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00720         ExceptionRecord1.ExceptionAddress = (PVOID)ControlPc;
00721         ExceptionRecord1.NumberParameters = 0;
00722     }
00723 
00724     <span class="comment">//</span>
00725     <span class="comment">// If the target frame of the unwind is specified, then a normal unwind</span>
00726     <span class="comment">// is being performed. Otherwise, an exit unwind is being performed.</span>
00727     <span class="comment">//</span>
00728 
00729     ExceptionFlags = <a class="code" href="../../d6/d7/halmips_8h.html#a26">EXCEPTION_UNWINDING</a>;
00730     <span class="keywordflow">if</span> (TargetFrame.BackingStoreFp == 0 &amp;&amp; TargetFrame.MemoryStackFp == 0) {
00731         ExceptionRecord-&gt;ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a27">EXCEPTION_EXIT_UNWIND</a>;
00732     }
00733 
00734     <span class="comment">//</span>
00735     <span class="comment">// Scan backward through the call frame hierarchy and call exception</span>
00736     <span class="comment">// handlers until the target frame of the unwind is reached.</span>
00737     <span class="comment">//</span>
00738 
00739     <span class="keywordflow">do</span> {
00740 
00741         <span class="comment">//</span>
00742         <span class="comment">// Lookup the function table entry using the point at which control</span>
00743         <span class="comment">// left the procedure.</span>
00744         <span class="comment">//</span>
00745 
00746 
00747         FunctionEntry = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>(ControlPc, &amp;ImageBase, &amp;TargetGp);
00748 
00749         <span class="comment">//</span>
00750         <span class="comment">// If there is a function table entry for the routine, then </span>
00751         <span class="comment">// virtually unwind to the caller of the routine to obtain the </span>
00752         <span class="comment">// virtual frame pointer of the establisher, but don't update </span>
00753         <span class="comment">// the context record.</span>
00754         <span class="comment">//</span>
00755 
00756         <span class="keywordflow">if</span> (FunctionEntry != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00757             NextPc = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a6">RtlpVirtualUnwind</a>(ImageBase,
00758                                        ControlPc,
00759                                        FunctionEntry,
00760                                        ContextRecord,
00761                                        &amp;InFunction,
00762                                        &amp;EstablisherFrame,
00763                                        <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00764 
00765         <span class="comment">//</span>
00766         <span class="comment">// If virtual frame is not within the specified limits, unaligned, </span>
00767         <span class="comment">// or the target frame is below the virtual frame and an exit </span>
00768         <span class="comment">// unwind is not being performed, then raise the exception </span>
00769         <span class="comment">// STATUS_BAD_STACK or STATUS_BAD_BSTORE. Otherwise,</span>
00770         <span class="comment">// check to determine if the current routine has an exception</span>
00771         <span class="comment">// handler.</span>
00772         <span class="comment">//</span>
00773 
00774             <span class="keywordflow">if</span> (<a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a5">CHECK_MSTACK_FRAME</a>(EstablisherFrame, TargetFrame)) {
00775 
00776                 <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a0">RAISE_EXCEPTION</a>(STATUS_BAD_STACK, ExceptionRecord);
00777 
00778             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a6">CHECK_BSTORE_FRAME</a>(EstablisherFrame, TargetFrame)) {
00779 
00780                 <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a0">RAISE_EXCEPTION</a>(STATUS_BAD_STACK, ExceptionRecord);
00781 
00782             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (InFunction &amp;&amp; <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a1">IS_HANDLER_DEFINED</a>(FunctionEntry, ImageBase)) {
00783 
00784                 <span class="comment">//</span>
00785                 <span class="comment">// The frame has an exception handler.</span>
00786                 <span class="comment">//</span>
00787                 <span class="comment">// The handler (i.e. personality routine) has to be called to</span>
00788                 <span class="comment">// execute any termination routines in this frame.</span>
00789                 <span class="comment">//</span>
00790                 <span class="comment">// The control PC, establisher frame pointer, the address</span>
00791                 <span class="comment">// of the function table entry, and the address of the</span>
00792                 <span class="comment">// context record are all stored in the dispatcher context.</span>
00793                 <span class="comment">// This information is used by the unwind linkage routine</span>
00794                 <span class="comment">// and can be used by the exception handler itself.</span>
00795                 <span class="comment">//</span>
00796 
00797                 DispatcherContext.ControlPc = ControlPc;
00798                 DispatcherContext.FunctionEntry = FunctionEntry;
00799                 DispatcherContext.ImageBase = ImageBase;
00800                 DispatcherContext.ContextRecord = ContextRecord;
00801 
00802                 <span class="comment">//</span>
00803                 <span class="comment">// Call the exception handler.</span>
00804                 <span class="comment">//</span>
00805 
00806                 <span class="keywordflow">do</span> {
00807 
00808                     <span class="comment">//</span>
00809                     <span class="comment">// If the establisher frame is the target of the unwind</span>
00810                     <span class="comment">// operation, then set the target unwind flag.</span>
00811                     <span class="comment">//</span>
00812 
00813                     <span class="keywordflow">if</span> (<a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a3">IS_SAME_FRAME</a>(TargetFrame, EstablisherFrame)) {
00814                         ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a30">EXCEPTION_TARGET_UNWIND</a>;
00815                     }
00816 
00817                     ExceptionRecord-&gt;ExceptionFlags = ExceptionFlags;
00818 
00819                     <span class="comment">//</span>
00820                     <span class="comment">// Set the specified return value in case the exception</span>
00821                     <span class="comment">// handler directly continues execution.</span>
00822                     <span class="comment">//</span>
00823 
00824                     ContextRecord-&gt;IntV0 = (ULONGLONG)ReturnValue;
00825 
00826                     <span class="comment">//</span>
00827                     <span class="comment">// A linkage routine written in assembler is used to </span>
00828                     <span class="comment">// actually call the actual exception handler. This is </span>
00829                     <span class="comment">// required by the exception handler that is associated </span>
00830                     <span class="comment">// with the linkage routine so it can have access to two </span>
00831                     <span class="comment">// sets of dispatcher context when it is called.</span>
00832                     <span class="comment">//</span>
00833 
00834                     DispatcherContext.EstablisherFrame = EstablisherFrame;
00835                     Disposition = <a class="code" href="../../d3/d9/ntrtli64_8h.html#a5">RtlpExecuteEmHandlerForUnwind</a>(
00836                                       ExceptionRecord,
00837                                       EstablisherFrame.MemoryStackFp,
00838                                       EstablisherFrame.BackingStoreFp,
00839                                       ContextRecord,
00840                                       &amp;DispatcherContext,
00841                                       TargetGp,
00842                                       <a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a1">HANDLER</a>(FunctionEntry, ImageBase, TargetGp));
00843 
00844                     <span class="comment">//</span>
00845                     <span class="comment">// Clear target unwind and collided unwind flags.</span>
00846                     <span class="comment">//</span>
00847 
00848                     ExceptionFlags &amp;= ~(<a class="code" href="../../d6/d7/halmips_8h.html#a31">EXCEPTION_COLLIDED_UNWIND</a> |
00849                                                 <a class="code" href="../../d6/d7/halmips_8h.html#a30">EXCEPTION_TARGET_UNWIND</a>);
00850 
00851                     <span class="comment">//</span>
00852                     <span class="comment">// Case on the handler disposition.</span>
00853                     <span class="comment">//</span>
00854 
00855                     <span class="keywordflow">switch</span> (Disposition) {
00856 
00857                     <span class="comment">//</span>
00858                     <span class="comment">// The disposition is to continue the search.</span>
00859                     <span class="comment">//</span>
00860                     <span class="comment">// If the target frame has not been reached, then</span>
00861                     <span class="comment">// virtually unwind to the caller of the current</span>
00862                     <span class="comment">// routine, update the context record, and continue</span>
00863                     <span class="comment">// the search for a handler.</span>
00864                     <span class="comment">//</span>
00865 
00866                     <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a37">ExceptionContinueSearch</a> :
00867 
00868                         <span class="keywordflow">if</span> (!<a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a3">IS_SAME_FRAME</a>(EstablisherFrame, TargetFrame)) {
00869                             NextPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ImageBase,
00870                                                       ControlPc,
00871                                                       FunctionEntry,
00872                                                       ContextRecord,
00873                                                       &amp;InFunction,
00874                                                       &amp;EstablisherFrame,
00875                                                       <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00876                         }
00877                         <span class="keywordflow">break</span>;
00878 
00879                     <span class="comment">//</span>
00880                     <span class="comment">// The disposition is collided unwind.</span>
00881                     <span class="comment">//</span>
00882                     <span class="comment">// Set the target of the current unwind to the context</span>
00883                     <span class="comment">// record of the previous unwind, and reexecute the</span>
00884                     <span class="comment">// exception handler from the collided frame with the</span>
00885                     <span class="comment">// collided unwind flag set in the exception record.</span>
00886                     <span class="comment">//</span>
00887 
00888                     <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a39">ExceptionCollidedUnwind</a> :
00889 
00890                         ControlPc = DispatcherContext.ControlPc;
00891                         FunctionEntry = DispatcherContext.FunctionEntry;
00892                         ImageBase = DispatcherContext.ImageBase;
00893                         ContextRecord = DispatcherContext.ContextRecord;
00894                         ContextRecord-&gt;StIIP = (ULONGLONG)TargetIp;
00895                         ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a31">EXCEPTION_COLLIDED_UNWIND</a>;
00896                         EstablisherFrame = DispatcherContext.EstablisherFrame;
00897                         TargetGp = (ULONG_PTR)(<a class="code" href="../../d8/d9/imagedir_8c.html#a5">RtlImageDirectoryEntryToData</a>(
00898                                                    (PVOID)ImageBase,
00899                                                    <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00900                                                    IMAGE_DIRECTORY_ENTRY_GLOBALPTR,
00901                                                    &amp;<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>
00902                                                    ));
00903                         <span class="keywordflow">break</span>;
00904 
00905                     <span class="comment">//</span>
00906                     <span class="comment">// All other disposition values are invalid.</span>
00907                     <span class="comment">//</span>
00908                     <span class="comment">// Raise invalid disposition exception.</span>
00909                     <span class="comment">//</span>
00910 
00911                     <span class="keywordflow">default</span> :
00912                         <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a0">RAISE_EXCEPTION</a>(STATUS_INVALID_DISPOSITION, ExceptionRecord);
00913                     }
00914 
00915                 } <span class="keywordflow">while</span> ((ExceptionFlags &amp; <a class="code" href="../../d6/d7/halmips_8h.html#a31">EXCEPTION_COLLIDED_UNWIND</a>) != 0);
00916 
00917             } <span class="keywordflow">else</span> {
00918 
00919                 <span class="comment">//</span>
00920                 <span class="comment">// If the target frame has not been reached, then virtually </span>
00921                 <span class="comment">// unwind to the caller of the current routine and update </span>
00922                 <span class="comment">// the context record.</span>
00923                 <span class="comment">//</span>
00924 
00925                 <span class="keywordflow">if</span> (!<a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a3">IS_SAME_FRAME</a>(EstablisherFrame, TargetFrame)) {
00926                     NextPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ImageBase,
00927                                               ControlPc,
00928                                               FunctionEntry,
00929                                               ContextRecord,
00930                                               &amp;InFunction,
00931                                               &amp;EstablisherFrame,
00932                                               <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00933                 }
00934             }
00935 
00936         } <span class="keywordflow">else</span> {
00937 
00938             <span class="comment">//</span>
00939             <span class="comment">// No function table entry was found.  </span>
00940             <span class="comment">//</span>
00941 
00942             <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a13">SHORT</a> BsFrameSize, TempFrameSize;
00943 
00944             NextPc = RtlIa64InsertIPSlotNumber((ContextRecord-&gt;BrRp-16), 2);
00945             ContextRecord-&gt;StIFS = ContextRecord-&gt;RsPFS;
00946             BsFrameSize = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a13">SHORT</a>)(ContextRecord-&gt;StIFS &gt;&gt; PFS_SIZE_SHIFT) &amp; PFS_SIZE_MASK;
00947             TempFrameSize = BsFrameSize - (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a13">SHORT</a>)((ContextRecord-&gt;RsBSP &gt;&gt; 3) &amp; NAT_BITS_PER_RNAT_REG);
00948             <span class="keywordflow">while</span> (TempFrameSize &gt; 0) {
00949                 BsFrameSize++;
00950                 TempFrameSize -= NAT_BITS_PER_RNAT_REG;
00951             }
00952             ContextRecord-&gt;RsBSP -= BsFrameSize * <span class="keyword">sizeof</span>(ULONGLONG);
00953             ContextRecord-&gt;RsBSPSTORE = ContextRecord-&gt;RsBSP;
00954         }
00955 
00956         <span class="comment">//</span>
00957         <span class="comment">// Set point at which control left the previous routine.</span>
00958         <span class="comment">//</span>
00959 
00960         ControlPc = NextPc;
00961 
00962     } <span class="keywordflow">while</span> (((EstablisherFrame.MemoryStackFp &lt; HighStackLimit) ||
00963              (EstablisherFrame.BackingStoreFp &gt; LowBStoreLimit)) &amp;&amp;
00964              !(<a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a3">IS_SAME_FRAME</a>(EstablisherFrame, TargetFrame)));
00965 
00966     <span class="comment">//</span>
00967     <span class="comment">// If the establisher stack pointer is equal to the target frame</span>
00968     <span class="comment">// pointer, then continue execution. Otherwise, an exit unwind was</span>
00969     <span class="comment">// performed or the target of the unwind did not exist and the</span>
00970     <span class="comment">// debugger and subsystem are given a second chance to handle the</span>
00971     <span class="comment">// unwind.</span>
00972     <span class="comment">//</span>
00973 
00974     <span class="keywordflow">if</span> (<a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a3">IS_SAME_FRAME</a>(EstablisherFrame, TargetFrame)) {
00975         ContextRecord-&gt;IntGp = TargetGp;
00976         ContextRecord-&gt;StIPSR &amp;= ~(0x3i64 &lt;&lt; PSR_RI);
00977         ContextRecord-&gt;IntV0 = (ULONGLONG)ReturnValue;
00978         <a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a11">RtlRestoreContext</a>(ContextRecord, ExceptionRecord);
00979     } <span class="keywordflow">else</span> {
00980         ZwRaiseException(ExceptionRecord, ContextRecord, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00981     }
00982 }
00983 
00984 BOOLEAN
<a name="l00985"></a><a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a22">00985</a> <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a7">RtlDispatchException</a> (
00986     IN PEXCEPTION_RECORD ExceptionRecord,
00987     IN PCONTEXT ContextRecord
00988     )
00989 
00990 <span class="comment">/*++</span>
00991 <span class="comment"></span>
00992 <span class="comment">Routine Description:</span>
00993 <span class="comment"></span>
00994 <span class="comment">    This function attempts to dispatch an exception to a frame based</span>
00995 <span class="comment">    handler by searching backwards through the call frames by unwinding</span>
00996 <span class="comment">    the RSE backing store as well as the memory stack.  The search begins </span>
00997 <span class="comment">    with the frame specified in the context record and continues backward </span>
00998 <span class="comment">    until either a handler is found that handles the exception, the stack </span>
00999 <span class="comment">    and/or the backing store is found to be invalid (i.e., out of limits </span>
01000 <span class="comment">    or unaligned), or the end of the call hierarchy is reached.</span>
01001 <span class="comment"></span>
01002 <span class="comment">    As each frame is encountered, the PC where control left the corresponding</span>
01003 <span class="comment">    function is determined and used to lookup exception handler information</span>
01004 <span class="comment">    in the runtime function table built by the linker. If the respective</span>
01005 <span class="comment">    routine has an exception handler, then the handler is called. If the</span>
01006 <span class="comment">    handler does not handle the exception, then the prologue of the routine</span>
01007 <span class="comment">    is undone to "unwind" the effect of the prologue and then the next</span>
01008 <span class="comment">    frame is examined.</span>
01009 <span class="comment"></span>
01010 <span class="comment">Arguments:</span>
01011 <span class="comment"></span>
01012 <span class="comment">    ExceptionRecord - Supplies a pointer to an exception record.</span>
01013 <span class="comment"></span>
01014 <span class="comment">    ContextRecord - Supplies a pointer to a context record.</span>
01015 <span class="comment"></span>
01016 <span class="comment">Return Value:</span>
01017 <span class="comment"></span>
01018 <span class="comment">    If the exception is handled by one of the frame based handlers, then</span>
01019 <span class="comment">    a value of TRUE is returned. Otherwise a value of FALSE is returned.</span>
01020 <span class="comment"></span>
01021 <span class="comment">--*/</span>
01022 
01023 {
01024     ULONGLONG TargetGp;
01025     ULONGLONG ImageBase;
01026     CONTEXT ContextRecordEm;
01027     ULONGLONG ControlPc;
01028     ULONGLONG NextPc;
01029     <a class="code" href="../../d0/d6/struct__DISPATCHER__CONTEXT.html">DISPATCHER_CONTEXT</a> DispatcherContext;
01030     EXCEPTION_DISPOSITION Disposition;
01031     ULONG ExceptionFlags;
01032     PRUNTIME_FUNCTION FunctionEntry;
01033     FRAME_POINTERS EstablisherFrame;
01034     FRAME_POINTERS TargetFrame;       <span class="comment">// to be removed in the future</span>
01035     ULONGLONG HighStackLimit; 
01036     ULONGLONG LowStackLimit;
01037     ULONGLONG HighBStoreLimit; 
01038     ULONGLONG LowBStoreLimit;
01039     FRAME_POINTERS NestedFrame;
01040     FRAME_POINTERS NullFrame;
01041     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
01042     ULONG <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
01043     BOOLEAN InFunction;
01044 
01045     <span class="comment">//</span>
01046     <span class="comment">// Get the current stack limits, make a copy of the context record,</span>
01047     <span class="comment">// get the initial PC value, capture the exception flags, and set</span>
01048     <span class="comment">// the nested exception frame pointer.</span>
01049     <span class="comment">//</span>
01050 
01051     <a class="code" href="../../d3/d9/ntrtli64_8h.html#a0">Rtlp64GetStackLimits</a>(&amp;LowStackLimit, &amp;HighStackLimit);
01052     <a class="code" href="../../d3/d9/ntrtli64_8h.html#a1">Rtlp64GetBStoreLimits</a>(&amp;LowBStoreLimit, &amp;HighBStoreLimit);
01053 
01054     RtlMoveMemory(&amp;ContextRecordEm, ContextRecord, <span class="keyword">sizeof</span>(CONTEXT));
01055 
01056     <span class="keywordflow">if</span> ( (ExceptionRecord-&gt;ExceptionCode == STATUS_ACCESS_VIOLATION) &amp;&amp;
01057          (ExceptionRecord-&gt;NumberParameters == 5) &amp;&amp;
01058          (ExceptionRecord-&gt;ExceptionInformation[4] &amp; (1 &lt;&lt; ISR_X)) )
01059     {
01060         ControlPc = ExceptionRecord-&gt;ExceptionInformation[3];
01061         ControlPc = RtlIa64InsertIPSlotNumber(ControlPc,
01062                                ((ContextRecordEm.StIPSR &gt;&gt; PSR_RI) &amp; 0x3));
01063     } <span class="keywordflow">else</span> {
01064         ControlPc = RtlIa64InsertIPSlotNumber(ContextRecordEm.StIIP,
01065                                ((ContextRecordEm.StIPSR &gt;&gt; PSR_RI) &amp; 0x3));
01066     }
01067 
01068     ExceptionFlags = ExceptionRecord-&gt;ExceptionFlags &amp; <a class="code" href="../../d6/d7/halmips_8h.html#a25">EXCEPTION_NONCONTINUABLE</a>;
01069 
01070     <a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a4">INITIALIZE_FRAME</a>(NestedFrame);
01071     <a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a4">INITIALIZE_FRAME</a>(NullFrame);
01072 
01073     <span class="comment">//</span>
01074     <span class="comment">// Start with the frame specified by the context record and search</span>
01075     <span class="comment">// backwards through the chain of call frames attempting to find an</span>
01076     <span class="comment">// exception handler that will handle the exception.</span>
01077     <span class="comment">//</span>
01078 
01079     <span class="keywordflow">do</span> {
01080 
01081         <span class="comment">//</span>
01082         <span class="comment">// Lookup the function table entry using the point at which control</span>
01083         <span class="comment">// left the procedure.</span>
01084         <span class="comment">//</span>
01085 
01086 
01087         FunctionEntry = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>(ControlPc, &amp;ImageBase, &amp;TargetGp);
01088 
01089         <span class="comment">//</span>
01090         <span class="comment">// If there is a function table entry for the routine, then </span>
01091         <span class="comment">// virtually unwind to the caller of the current routine to </span>
01092         <span class="comment">// obtain the virtual frame pointer of the establisher and check </span>
01093         <span class="comment">// if there is an exception handler for the frame.</span>
01094         <span class="comment">//</span>
01095 
01096         <span class="keywordflow">if</span> (FunctionEntry != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01097             NextPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ImageBase,
01098                                       ControlPc,
01099                                       FunctionEntry,
01100                                       &amp;ContextRecordEm,
01101                                       &amp;InFunction,
01102                                       &amp;EstablisherFrame,
01103                                       <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
01104 
01105             <span class="comment">//</span>
01106             <span class="comment">// If either one or both of the two virtual frame pointers are </span>
01107             <span class="comment">// not within the specified stack limits or unaligned, </span>
01108             <span class="comment">// then set the stack invalid flag in the exception record and </span>
01109             <span class="comment">// return exception not handled.  Otherwise, check if the </span>
01110             <span class="comment">// current routine has an exception handler.</span>
01111             <span class="comment">//</span>
01112 
01113             <span class="keywordflow">if</span> (<a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a5">CHECK_MSTACK_FRAME</a>(EstablisherFrame, NullFrame)) {
01114 
01115                 ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a28">EXCEPTION_STACK_INVALID</a>;
01116                 <span class="keywordflow">break</span>;
01117 
01118             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a6">CHECK_BSTORE_FRAME</a>(EstablisherFrame, NullFrame)) {
01119     
01120                 ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a28">EXCEPTION_STACK_INVALID</a>;
01121                 <span class="keywordflow">break</span>;
01122 
01123             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((<a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a1">IS_HANDLER_DEFINED</a>(FunctionEntry, ImageBase) &amp;&amp; InFunction)) {
01124 
01125                 <span class="comment">// </span>
01126                 <span class="comment">// The handler (i.e. personality routine) has to be called </span>
01127                 <span class="comment">// to search for an exception handler in this frame.  The </span>
01128                 <span class="comment">// handler must be executed by calling a stub routine that </span>
01129                 <span class="comment">// is written in assembler.  This is required because up </span>
01130                 <span class="comment">// level addressing of this routine information is required </span>
01131                 <span class="comment">// when a nested exception is encountered.</span>
01132                 <span class="comment">//</span>
01133 
01134                 DispatcherContext.ControlPc = ControlPc;
01135                 DispatcherContext.FunctionEntry = FunctionEntry;
01136                 DispatcherContext.ImageBase = ImageBase;
01137 
01138                 <span class="keywordflow">do</span> {
01139 
01140                     ExceptionRecord-&gt;ExceptionFlags = ExceptionFlags;
01141 
01142                     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d2/ldrp_8h.html#a33">NtGlobalFlag</a> &amp; FLG_ENABLE_EXCEPTION_LOGGING) {
01143                         <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = <a class="code" href="../../d5/d9/ntrtlp_8h.html#a48">RtlpLogExceptionHandler</a>(
01144                                         ExceptionRecord,
01145                                         ContextRecord,
01146                                         (ULONG)ControlPc,
01147                                         FunctionEntry,
01148                                         <span class="keyword">sizeof</span>(RUNTIME_FUNCTION));
01149                     }
01150 
01151                     DispatcherContext.EstablisherFrame = EstablisherFrame;
01152                     DispatcherContext.ContextRecord = ContextRecord;
01153                     Disposition = <a class="code" href="../../d3/d9/ntrtli64_8h.html#a4">RtlpExecuteEmHandlerForException</a>(
01154                                       ExceptionRecord,
01155                                       EstablisherFrame.MemoryStackFp,
01156                                       EstablisherFrame.BackingStoreFp,
01157                                       ContextRecord,
01158                                       &amp;DispatcherContext, 
01159                                       TargetGp,
01160                                       <a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a1">HANDLER</a>(FunctionEntry, ImageBase, TargetGp)); 
01161 
01162                     <span class="keywordflow">if</span> (<a class="code" href="../../d9/d2/ldrp_8h.html#a33">NtGlobalFlag</a> &amp; FLG_ENABLE_EXCEPTION_LOGGING) {
01163                         <a class="code" href="../../d5/d9/ntrtlp_8h.html#a49">RtlpLogLastExceptionDisposition</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>, Disposition);
01164                     }
01165 
01166                     ExceptionFlags |=
01167                         (ExceptionRecord-&gt;ExceptionFlags &amp; <a class="code" href="../../d6/d7/halmips_8h.html#a25">EXCEPTION_NONCONTINUABLE</a>);
01168 
01169                     ExceptionFlags &amp;= ~<a class="code" href="../../d6/d7/halmips_8h.html#a31">EXCEPTION_COLLIDED_UNWIND</a>;
01170 
01171                     <span class="comment">//</span>
01172                     <span class="comment">// If the current scan is within a nested context and the</span>
01173                     <span class="comment">// frame just examined is the end of the nested region,</span>
01174                     <span class="comment">// then clear the nested context frame and the nested</span>
01175                     <span class="comment">// exception flag in the exception flags.</span>
01176                     <span class="comment">//</span>
01177 
01178                     <span class="keywordflow">if</span> (<a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a3">IS_SAME_FRAME</a>(NestedFrame, EstablisherFrame)) {
01179                         ExceptionFlags &amp;= (~<a class="code" href="../../d6/d7/halmips_8h.html#a29">EXCEPTION_NESTED_CALL</a>);
01180                         <a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a4">INITIALIZE_FRAME</a>(NestedFrame);
01181                     }
01182 
01183                     <span class="comment">//</span>
01184                     <span class="comment">// Case on the handler disposition.</span>
01185                     <span class="comment">//</span>
01186 
01187                     <span class="keywordflow">switch</span> (Disposition) {
01188 
01189                     <span class="comment">//</span>
01190                     <span class="comment">// The disposition is to continue execution.</span>
01191                     <span class="comment">//</span>
01192                     <span class="comment">// If the exception is not continuable, then raise the</span>
01193                     <span class="comment">// exception STATUS_NONCONTINUABLE_EXCEPTION.  Otherwise,</span>
01194                     <span class="comment">// return exception handled.</span>
01195                     <span class="comment">//</span>
01196 
01197                     <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a36">ExceptionContinueExecution</a>:
01198                         <span class="keywordflow">if</span> ((ExceptionFlags &amp; <a class="code" href="../../d6/d7/halmips_8h.html#a25">EXCEPTION_NONCONTINUABLE</a>) != 0) {
01199                             <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a0">RAISE_EXCEPTION</a>(STATUS_NONCONTINUABLE_EXCEPTION, 
01200                                             ExceptionRecord);
01201                         } <span class="keywordflow">else</span> {
01202                             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01203                         }
01204 
01205                     <span class="comment">//</span>
01206                     <span class="comment">// The disposition is to continue the search.</span>
01207                     <span class="comment">//</span>
01208                     <span class="comment">// Get the next frame address and continue the search.</span>
01209                     <span class="comment">//</span>
01210 
01211                     <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a37">ExceptionContinueSearch</a>:
01212                         <span class="keywordflow">break</span>;
01213 
01214                     <span class="comment">//</span>
01215                     <span class="comment">// The disposition is nested exception.</span>
01216                     <span class="comment">//</span>
01217                     <span class="comment">// Set the nested context frame to the establisher frame</span>
01218                     <span class="comment">// address and set the nested exception flag in the</span>
01219                     <span class="comment">// exception flags.</span>
01220                     <span class="comment">//</span>
01221         
01222                     <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a38">ExceptionNestedException</a>:
01223                         ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a29">EXCEPTION_NESTED_CALL</a>;
01224                         <span class="keywordflow">if</span> (DispatcherContext.EstablisherFrame.MemoryStackFp &gt; NestedFrame.MemoryStackFp) {
01225                             NestedFrame = DispatcherContext.EstablisherFrame;
01226                         }
01227                         <span class="keywordflow">break</span>;
01228 
01229                     <span class="comment">//</span>
01230                     <span class="comment">// The disposition is hitting a frame processed by a</span>
01231                     <span class="comment">// previous unwind.</span>
01232                     <span class="comment">//</span>
01233                     <span class="comment">// Set the target of the current dispatch to the context</span>
01234                     <span class="comment">// record of the previous unwind</span>
01235                     <span class="comment">//</span>
01236 
01237                     <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a39">ExceptionCollidedUnwind</a>:
01238                         ControlPc = DispatcherContext.ControlPc;
01239                         NextPc = ControlPc;
01240                         EstablisherFrame = DispatcherContext.EstablisherFrame;
01241                         FunctionEntry = DispatcherContext.FunctionEntry;
01242                         ImageBase = DispatcherContext.ImageBase;
01243                         RtlMoveMemory(&amp;ContextRecordEm, 
01244                                       DispatcherContext.ContextRecord,
01245                                       <span class="keyword">sizeof</span>(CONTEXT));
01246                         ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a31">EXCEPTION_COLLIDED_UNWIND</a>;
01247                         TargetGp = (ULONG_PTR)(<a class="code" href="../../d8/d9/imagedir_8c.html#a5">RtlImageDirectoryEntryToData</a>(
01248                                                    (PVOID)ImageBase,
01249                                                    <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
01250                                                    IMAGE_DIRECTORY_ENTRY_GLOBALPTR,
01251                                                    &amp;<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>
01252                                                    ));
01253                         <span class="keywordflow">break</span>;
01254 
01255                     <span class="comment">//</span>
01256                     <span class="comment">// All other disposition values are invalid.</span>
01257                     <span class="comment">//</span>
01258                     <span class="comment">// Raise invalid disposition exception.</span>
01259                     <span class="comment">//</span>
01260 
01261                     <span class="keywordflow">default</span>:
01262                         <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a0">RAISE_EXCEPTION</a>(STATUS_INVALID_DISPOSITION, ExceptionRecord);
01263                         <span class="keywordflow">break</span>;
01264                     }
01265 
01266                 } <span class="keywordflow">while</span> ((ExceptionFlags &amp; <a class="code" href="../../d6/d7/halmips_8h.html#a31">EXCEPTION_COLLIDED_UNWIND</a>) != 0);
01267 
01268             }
01269 
01270         } <span class="keywordflow">else</span> {
01271 
01272             <span class="comment">//</span>
01273             <span class="comment">// No function table entry is found.</span>
01274             <span class="comment">//</span>
01275 
01276             <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a13">SHORT</a> BsFrameSize, TempFrameSize;
01277 
01278             NextPc = RtlIa64InsertIPSlotNumber((ContextRecordEm.BrRp-16), 2);
01279             ContextRecordEm.StIFS = ContextRecordEm.RsPFS;
01280             BsFrameSize = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a13">SHORT</a>)(ContextRecordEm.StIFS &gt;&gt; PFS_SIZE_SHIFT) &amp; PFS_SIZE_MASK;
01281             TempFrameSize = BsFrameSize - (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a13">SHORT</a>)((ContextRecordEm.RsBSP &gt;&gt; 3) &amp; NAT_BITS_PER_RNAT_REG);
01282             <span class="keywordflow">while</span> (TempFrameSize &gt; 0) {
01283                 BsFrameSize++;
01284                 TempFrameSize -= NAT_BITS_PER_RNAT_REG;
01285             }
01286             ContextRecordEm.RsBSP -= BsFrameSize * <span class="keyword">sizeof</span>(ULONGLONG);
01287             ContextRecordEm.RsBSPSTORE = ContextRecordEm.RsBSP;
01288 
01289             <span class="keywordflow">if</span> (NextPc == ControlPc) {
01290                 <span class="keywordflow">break</span>;
01291             }
01292         }
01293 
01294         <span class="comment">//</span>
01295         <span class="comment">// Set the point at which control left the previous routine.</span>
01296         <span class="comment">//</span>
01297 
01298         ControlPc = NextPc;
01299 
01300     } <span class="keywordflow">while</span> ( (ContextRecordEm.IntSp &lt; HighStackLimit) ||
01301               (ContextRecordEm.RsBSP &gt; LowBStoreLimit) );
01302 
01303     <span class="comment">//</span>
01304     <span class="comment">// Could not handle the exception.</span>
01305     <span class="comment">//</span>
01306     <span class="comment">// Set final exception flags and return exception not handled.</span>
01307     <span class="comment">//</span>
01308 
01309     ExceptionRecord-&gt;ExceptionFlags = ExceptionFlags;
01310     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01311 }
01312 
01313 
01314 ULONGLONG
<a name="l01315"></a><a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a12">01315</a> <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a6">RtlpVirtualUnwind</a> (
01316     IN ULONGLONG ImageBase,
01317     IN ULONGLONG ControlPc,
01318     IN PRUNTIME_FUNCTION FunctionEntry,
01319     IN PCONTEXT ContextRecord,
01320     OUT PBOOLEAN InFunction,
01321     OUT PFRAME_POINTERS EstablisherFrame,
01322     IN OUT PKNONVOLATILE_CONTEXT_POINTERS ContextPointers OPTIONAL
01323     )
01324 
01325 <span class="comment">/*++</span>
01326 <span class="comment"></span>
01327 <span class="comment">Routine Description:</span>
01328 <span class="comment"></span>
01329 <span class="comment">    This function virtually unwinds the specfified function by executing its</span>
01330 <span class="comment">    prologue code backwards.</span>
01331 <span class="comment"></span>
01332 <span class="comment">    If the function is a leaf function, then the address where control left</span>
01333 <span class="comment">    the previous frame is obtained from the context record. If the function</span>
01334 <span class="comment">    is a nested function, but not an exception or interrupt frame, then the</span>
01335 <span class="comment">    prologue code is executed backwards and the address where control left</span>
01336 <span class="comment">    the previous frame is obtained from the updated context record.</span>
01337 <span class="comment"></span>
01338 <span class="comment">    Otherwise, an exception or interrupt entry to the system is being unwound</span>
01339 <span class="comment">    and a specially coded prologue restores the return address twice. Once</span>
01340 <span class="comment">    from the fault instruction address and once from the saved return address</span>
01341 <span class="comment">    register. The first restore is returned as the function value and the</span>
01342 <span class="comment">    second restore is place in the updated context record.</span>
01343 <span class="comment"></span>
01344 <span class="comment">    If a context pointers record is specified, then the address where each</span>
01345 <span class="comment">    nonvolatile registers is restored from is recorded in the appropriate</span>
01346 <span class="comment">    element of the context pointers record.</span>
01347 <span class="comment"></span>
01348 <span class="comment">    N.B. This function copies the specified context record and only computes</span>
01349 <span class="comment">         the establisher frame and whether control is actually in a function.</span>
01350 <span class="comment"></span>
01351 <span class="comment">Arguments:</span>
01352 <span class="comment"></span>
01353 <span class="comment">    ImageBase - Base address of the module to which the function belongs.</span>
01354 <span class="comment"></span>
01355 <span class="comment">    ControlPc - Supplies the address where control left the specified</span>
01356 <span class="comment">        function.</span>
01357 <span class="comment"></span>
01358 <span class="comment">    FunctionEntry - Supplies the address of the function table entry for the</span>
01359 <span class="comment">        specified function.</span>
01360 <span class="comment"></span>
01361 <span class="comment">    ContextRecord - Supplies the address of a context record.</span>
01362 <span class="comment"></span>
01363 <span class="comment">    InFunction - Supplies a pointer to a variable that receives whether the</span>
01364 <span class="comment">        control PC is within the current function.</span>
01365 <span class="comment"></span>
01366 <span class="comment">    EstablisherFrame - Supplies a pointer to a variable that receives the</span>
01367 <span class="comment">        the establisher frame pointer value.</span>
01368 <span class="comment"></span>
01369 <span class="comment">    ContextPointers - Supplies an optional pointer to a context pointers</span>
01370 <span class="comment">        record.</span>
01371 <span class="comment"></span>
01372 <span class="comment">Return Value:</span>
01373 <span class="comment"></span>
01374 <span class="comment">    The address where control left the previous frame is returned as the</span>
01375 <span class="comment">    function value.</span>
01376 <span class="comment"></span>
01377 <span class="comment">--*/</span>
01378 
01379 {
01380 
01381     CONTEXT LocalContext;
01382 
01383     <span class="comment">//</span>
01384     <span class="comment">// Copy the context record so updates will not be reflected in the</span>
01385     <span class="comment">// original copy and then virtually unwind to the caller of the</span>
01386     <span class="comment">// specified control point.</span>
01387     <span class="comment">//</span>
01388 
01389     RtlCopyMemory((PVOID)&amp;LocalContext, ContextRecord, <span class="keyword">sizeof</span>(CONTEXT));
01390     <span class="keywordflow">return</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ImageBase,
01391                             ControlPc,
01392                             FunctionEntry,
01393                             &amp;LocalContext,
01394                             InFunction,
01395                             EstablisherFrame,
01396                             ContextPointers);
01397 }
01398 
01399 <span class="preprocessor">#if !defined(NTOS_KERNEL_RUNTIME)</span>
01400 <span class="preprocessor"></span>
01401 PLIST_ENTRY
<a name="l01402"></a><a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a23">01402</a> <a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a23">RtlGetFunctionTableListHead</a> (
01403     VOID
01404     )
01405 
01406 <span class="comment">/*++</span>
01407 <span class="comment"></span>
01408 <span class="comment">Routine Description:</span>
01409 <span class="comment"></span>
01410 <span class="comment">    Return the address of the dynamic function table list head.</span>
01411 <span class="comment"></span>
01412 <span class="comment">Return value:</span>
01413 <span class="comment"></span>
01414 <span class="comment">    Address of dynamic function table list head.</span>
01415 <span class="comment"></span>
01416 <span class="comment">--*/</span>
01417 {
01418     <span class="keywordflow">return</span> &amp;<a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a7">DynamicFunctionTable</a>;
01419 }
01420 
01421 BOOLEAN
<a name="l01422"></a><a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a24">01422</a> <a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a24">RtlAddFunctionTable</a>(
01423     IN PRUNTIME_FUNCTION FunctionTable,
01424     IN ULONG             EntryCount,
01425     IN ULONGLONG         BaseAddress,
01426     IN ULONGLONG         TargetGp
01427     )
01428 
01429 <span class="comment">/*++</span>
01430 <span class="comment"></span>
01431 <span class="comment">Routine Description:</span>
01432 <span class="comment"></span>
01433 <span class="comment">    Add a dynamic function table to the dynamic function table list. Dynamic</span>
01434 <span class="comment">    function tables describe code generated at run-time. The dynamic function</span>
01435 <span class="comment">    tables are searched via a call to RtlLookupDynamicFunctionEntry().</span>
01436 <span class="comment">    Normally this is only invoked via calls to RtlLookupFunctionEntry().</span>
01437 <span class="comment"></span>
01438 <span class="comment">    The FunctionTable entries need not be sorted in any particular order. The</span>
01439 <span class="comment">    list is scanned for a Min and Max address range and whether or not it is</span>
01440 <span class="comment">    sorted. If the latter RtlLookupDynamicFunctionEntry() uses a binary</span>
01441 <span class="comment">    search, otherwise it uses a linear search.</span>
01442 <span class="comment"></span>
01443 <span class="comment">    The dynamic function entries will be searched only after a search</span>
01444 <span class="comment">    through the static function entries associated with all current</span>
01445 <span class="comment">    process images has failed.</span>
01446 <span class="comment"></span>
01447 <span class="comment">Arguments:</span>
01448 <span class="comment"></span>
01449 <span class="comment">   FunctionTable       Address of an array of function entries where</span>
01450 <span class="comment">                       each element is of type RUNTIME_FUNCTION.</span>
01451 <span class="comment"></span>
01452 <span class="comment">   EntryCount          The number of function entries in the array</span>
01453 <span class="comment"></span>
01454 <span class="comment">   BaseAddress         Base address to calculate the real address  of the function table entry</span>
01455 <span class="comment">   TargetGp            return back to RtlLookupFunctionEntry for future query.</span>
01456 <span class="comment"></span>
01457 <span class="comment">Return value:</span>
01458 <span class="comment"></span>
01459 <span class="comment">   TRUE                if RtlAddFunctionTable completed successfully</span>
01460 <span class="comment">   FALSE               if RtlAddFunctionTable completed unsuccessfully</span>
01461 <span class="comment"></span>
01462 <span class="comment">--*/</span>
01463 {
01464     PDYNAMIC_FUNCTION_TABLE pNew;
01465     PRUNTIME_FUNCTION FunctionEntry;
01466     ULONG i;
01467 
01468     <span class="keywordflow">if</span> (EntryCount == 0)
01469         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01470 
01471     <span class="comment">//</span>
01472     <span class="comment">// Make sure the link list is initialized;</span>
01473     <span class="comment">//</span>
01474 
01475     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a7">DynamicFunctionTable</a>.Flink == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01476        InitializeListHead(&amp;<a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a7">DynamicFunctionTable</a>);
01477     }
01478 
01479     <span class="comment">//</span>
01480     <span class="comment">//  Allocate memory for this link list entry</span>
01481     <span class="comment">//</span>
01482 
01483     pNew = <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a0">RtlAllocateHeap</a>( RtlProcessHeap(), 0, <span class="keyword">sizeof</span>(DYNAMIC_FUNCTION_TABLE) );
01484 
01485     <span class="keywordflow">if</span> (pNew != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01486         pNew-&gt;FunctionTable = FunctionTable;
01487         pNew-&gt;EntryCount = EntryCount;
01488         NtQuerySystemTime( &amp;pNew-&gt;TimeStamp );
01489 
01490         <span class="comment">//</span>
01491         <span class="comment">// Scan the function table for Minimum/Maximum and to determine</span>
01492         <span class="comment">// if it is sorted. If the latter, we can perform a binary search.</span>
01493         <span class="comment">//</span>
01494 
01495         FunctionEntry = FunctionTable;
01496         pNew-&gt;MinimumAddress = RF_BEGIN_ADDRESS( BaseAddress, FunctionEntry);
01497         pNew-&gt;MaximumAddress = RF_END_ADDRESS(BaseAddress, FunctionEntry);
01498         pNew-&gt;Sorted = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01499         FunctionEntry++;
01500 
01501         <span class="keywordflow">for</span> (i = 1; i &lt; EntryCount; FunctionEntry++, i++) {
01502             <span class="keywordflow">if</span> (pNew-&gt;Sorted &amp;&amp; FunctionEntry-&gt;BeginAddress &lt; FunctionTable[i-1].BeginAddress) {
01503                 pNew-&gt;Sorted = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01504             }
01505             <span class="keywordflow">if</span> (RF_BEGIN_ADDRESS(FunctionTable, FunctionEntry) &lt; pNew-&gt;MinimumAddress) {
01506                 pNew-&gt;MinimumAddress = RF_BEGIN_ADDRESS( BaseAddress, FunctionEntry);
01507             }
01508             <span class="keywordflow">if</span> (RF_END_ADDRESS( FunctionTable, FunctionEntry) &gt; pNew-&gt;MaximumAddress) {
01509                 pNew-&gt;MaximumAddress = RF_END_ADDRESS( BaseAddress, FunctionEntry);
01510             }
01511         }
01512 
01513         <span class="comment">//</span>
01514         <span class="comment">// Insert the new entry in the dynamic function table list.</span>
01515         <span class="comment">// Protect the insertion with the loader lock.</span>
01516         <span class="comment">//</span>
01517 
01518         pNew-&gt;BaseAddress = BaseAddress;
01519         pNew-&gt;TargetGp    = TargetGp;
01520 
01521         RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()-&gt;<a class="code" href="../../d8/d2/ldrinit_8c.html#a12">LoaderLock</a>);
01522         InsertTailList((PLIST_ENTRY)&amp;<a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a7">DynamicFunctionTable</a>, (PLIST_ENTRY)pNew);
01523         RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()-&gt;<a class="code" href="../../d8/d2/ldrinit_8c.html#a12">LoaderLock</a>);
01524 
01525         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01526     } <span class="keywordflow">else</span> {
01527         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01528     }
01529 }
01530 
01531 BOOLEAN
<a name="l01532"></a><a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a25">01532</a> <a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a25">RtlDeleteFunctionTable</a> (
01533     IN PRUNTIME_FUNCTION FunctionTable
01534     )
01535 {
01536 
01537 <span class="comment">/*++</span>
01538 <span class="comment"></span>
01539 <span class="comment">Routine Description:</span>
01540 <span class="comment"></span>
01541 <span class="comment">    Remove a dynamic function table from the dynamic function table list.</span>
01542 <span class="comment"></span>
01543 <span class="comment">Arguments:</span>
01544 <span class="comment"></span>
01545 <span class="comment">   FunctionTable       Address of an array of function entries that</span>
01546 <span class="comment">                       was passed in a previous call to RtlAddFunctionTable</span>
01547 <span class="comment"></span>
01548 <span class="comment">Return Value</span>
01549 <span class="comment"></span>
01550 <span class="comment">    TRUE - If function completed successfully</span>
01551 <span class="comment">    FALSE - If function completed unsuccessfully</span>
01552 <span class="comment"></span>
01553 <span class="comment">--*/</span>
01554 
01555     PDYNAMIC_FUNCTION_TABLE CurrentEntry;
01556     PLIST_ENTRY Head;
01557     PLIST_ENTRY Next;
01558     BOOLEAN <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01559 
01560     RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()-&gt;<a class="code" href="../../d8/d2/ldrinit_8c.html#a12">LoaderLock</a>);
01561 
01562     <span class="comment">//</span>
01563     <span class="comment">// Search the dynamic function table list for a match on the the function</span>
01564     <span class="comment">// table address.</span>
01565     <span class="comment">//</span>
01566 
01567     Head = &amp;<a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a7">DynamicFunctionTable</a>;
01568     <span class="keywordflow">for</span> (Next = Head-&gt;Blink; Next != Head; Next = Next-&gt;Blink) {
01569         CurrentEntry = CONTAINING_RECORD(Next,DYNAMIC_FUNCTION_TABLE,Links);
01570         <span class="keywordflow">if</span> (CurrentEntry-&gt;FunctionTable == FunctionTable) {
01571             RemoveEntryList((PLIST_ENTRY)CurrentEntry);
01572             <a class="code" href="../../d3/d7/config_2utils_2regutil_8c.html#a1">RtlFreeHeap</a>( RtlProcessHeap(), 0, CurrentEntry );
01573             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01574             <span class="keywordflow">break</span>;
01575         }
01576     }
01577 
01578     RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()-&gt;<a class="code" href="../../d8/d2/ldrinit_8c.html#a12">LoaderLock</a>);
01579     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01580 }
01581 
01582 PRUNTIME_FUNCTION
<a name="l01583"></a><a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a10">01583</a> <a class="code" href="../../d7/d9/ia64_2exdsptch_8c.html#a10">RtlLookupDynamicFunctionEntry</a>(
01584     IN ULONG_PTR ControlPc,
01585     OUT PULONGLONG ImageBase,
01586     OUT PULONGLONG TargetGp
01587     )
01588 
01589 <span class="comment">/*++</span>
01590 <span class="comment"></span>
01591 <span class="comment">Routine Description:</span>
01592 <span class="comment"></span>
01593 <span class="comment">  This function searches through the dynamic function entry</span>
01594 <span class="comment">  tables and returns the function entry address that corresponds</span>
01595 <span class="comment">  to the specified ControlPc. This routine does NOT perform the</span>
01596 <span class="comment">  secondary function entry indirection. That is performed</span>
01597 <span class="comment">  by RtlLookupFunctionEntry().</span>
01598 <span class="comment"></span>
01599 <span class="comment">  Argument:</span>
01600 <span class="comment"></span>
01601 <span class="comment">     ControlPc           Supplies a ControlPc.</span>
01602 <span class="comment">     ImageBase           OUT Base address for dynamic code</span>
01603 <span class="comment"></span>
01604 <span class="comment">  Return Value</span>
01605 <span class="comment"></span>
01606 <span class="comment">     NULL - No function entry found that contains the ControlPc.</span>
01607 <span class="comment"></span>
01608 <span class="comment">     NON-NULL - Address of the function entry that describes the</span>
01609 <span class="comment">                code containing ControlPC.</span>
01610 <span class="comment"></span>
01611 <span class="comment">--*/</span>
01612 
01613 {
01614     PDYNAMIC_FUNCTION_TABLE CurrentEntry;
01615     PLIST_ENTRY Next,Head;
01616     PRUNTIME_FUNCTION FunctionTable;
01617     PRUNTIME_FUNCTION FunctionEntry;
01618     LONG High;
01619     LONG Low;
01620     LONG Middle;
01621     SIZE_T BaseAddress;
01622 
01623 
01624     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a7">DynamicFunctionTable</a>.Flink == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> || ImageBase == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)
01625         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01626 
01627 
01628         <span class="comment">//</span>
01629         <span class="comment">//  Search the tree starting from the head, continue until the entry</span>
01630         <span class="comment">//  is found or we reach the end of the list.</span>
01631         <span class="comment">//</span>
01632     <span class="keywordflow">if</span> (RtlTryEnterCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()-&gt;<a class="code" href="../../d8/d2/ldrinit_8c.html#a12">LoaderLock</a>) ) {
01633 
01634         Head = &amp;<a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a7">DynamicFunctionTable</a>;
01635         <span class="keywordflow">for</span> (Next = Head-&gt;Blink; Next != Head; Next = Next-&gt;Blink) {
01636             CurrentEntry = CONTAINING_RECORD(Next,DYNAMIC_FUNCTION_TABLE,Links);
01637             FunctionTable = CurrentEntry-&gt;FunctionTable;
01638 
01639             <span class="comment">//</span>
01640             <span class="comment">// Check if the ControlPC is within the range of this function table</span>
01641             <span class="comment">//</span>
01642 
01643             <span class="keywordflow">if</span> ((ControlPc &gt;= CurrentEntry-&gt;MinimumAddress) &amp;&amp;
01644                 (ControlPc &lt;  CurrentEntry-&gt;MaximumAddress) ) {
01645 
01646 
01647                 <span class="comment">// If this function table is sorted do a binary search.</span>
01648 
01649                 BaseAddress = CurrentEntry-&gt;BaseAddress;
01650                 <span class="keywordflow">if</span> (CurrentEntry-&gt;Sorted) {
01651 
01652                     <span class="comment">//</span>
01653                     <span class="comment">// Perform binary search on the function table for a function table</span>
01654                     <span class="comment">// entry that subsumes the specified PC.</span>
01655                     <span class="comment">//</span>
01656 
01657                     Low = 0;
01658                     High = CurrentEntry-&gt;EntryCount -1 ;
01659                     
01660                     <span class="keywordflow">while</span> (High &gt;= Low) {
01661 
01662                         <span class="comment">//</span>
01663                         <span class="comment">// Compute next probe index and test entry. If the specified PC</span>
01664                         <span class="comment">// is greater than of equal to the beginning address and less</span>
01665                         <span class="comment">// than the ending address of the function table entry, then</span>
01666                         <span class="comment">// return the address of the function table entry. Otherwise,</span>
01667                         <span class="comment">// continue the search.</span>
01668                         <span class="comment">//</span>
01669 
01670 
01671                         Middle = (Low + High) &gt;&gt; 1;
01672                         FunctionEntry = &amp;FunctionTable[Middle];
01673 
01674                         <span class="keywordflow">if</span> (ControlPc &lt; RF_BEGIN_ADDRESS( BaseAddress, FunctionEntry)) {
01675                             High = Middle - 1;
01676 
01677                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ControlPc &gt;= RF_END_ADDRESS( BaseAddress, FunctionEntry)) {
01678                             Low = Middle + 1;
01679 
01680                         } <span class="keywordflow">else</span> {
01681 
01682                             *ImageBase = CurrentEntry-&gt;BaseAddress;
01683 
01684                             <span class="keywordflow">if</span> ( TargetGp != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> )
01685                                 *TargetGp  = CurrentEntry-&gt;TargetGp;
01686 
01687                             RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()-&gt;<a class="code" href="../../d8/d2/ldrinit_8c.html#a12">LoaderLock</a>);
01688                             <span class="keywordflow">return</span> FunctionEntry;
01689                         }
01690                     }
01691 
01692                 } <span class="keywordflow">else</span> {    <span class="comment">// Not sorted. Do linear search.</span>
01693 
01694                     PRUNTIME_FUNCTION LastFunctionEntry = &amp;FunctionTable[CurrentEntry-&gt;EntryCount];
01695 
01696 
01697                     <span class="keywordflow">for</span> (FunctionEntry = FunctionTable; FunctionEntry &lt; LastFunctionEntry; FunctionEntry++) {
01698 
01699                         <span class="keywordflow">if</span> ((ControlPc &gt;= RF_BEGIN_ADDRESS( BaseAddress, FunctionEntry)) &amp;&amp;
01700                             (ControlPc &lt;  RF_END_ADDRESS( BaseAddress, FunctionEntry))) {
01701 
01702                             
01703                             *ImageBase = CurrentEntry-&gt;BaseAddress;
01704 
01705                             <span class="keywordflow">if</span> ( TargetGp != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> )
01706                                 *TargetGp  = CurrentEntry-&gt;TargetGp;
01707 
01708                             RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()-&gt;<a class="code" href="../../d8/d2/ldrinit_8c.html#a12">LoaderLock</a>);
01709                             <span class="keywordflow">return</span> FunctionEntry;
01710                         }
01711                     }
01712                 } <span class="comment">// binary/linear search</span>
01713             } <span class="comment">// if in range</span>
01714         } <span class="comment">// for (... Next != Head ...)</span>
01715         RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()-&gt;<a class="code" href="../../d8/d2/ldrinit_8c.html#a12">LoaderLock</a>);
01716     } <span class="comment">// LoaderLock</span>
01717 
01718     <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01719 }
01720 
01721 <span class="preprocessor">#endif</span>
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:39:57 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
