<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: qsea.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>qsea.c</h1><a href="../../d7/d2/qsea_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1989  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    qsea.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module contains the code to implement the NtQueryEaFile and the</span>
00012 <span class="comment">    NtSetEaFile system services for the NT I/O system.</span>
00013 <span class="comment"></span>
00014 <span class="comment">Author:</span>
00015 <span class="comment"></span>
00016 <span class="comment">    Darryl E. Havens (darrylh) 20-Jun-1989</span>
00017 <span class="comment"></span>
00018 <span class="comment">Environment:</span>
00019 <span class="comment"></span>
00020 <span class="comment">    Kernel mode only</span>
00021 <span class="comment"></span>
00022 <span class="comment">Revision History:</span>
00023 <span class="comment"></span>
00024 <span class="comment"></span>
00025 <span class="comment">--*/</span>
00026 
00027 <span class="preprocessor">#include "<a class="code" href="../../d0/d6/iop_8h.html">iop.h</a>"</span>
00028 
00029 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00030 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, NtQueryEaFile)</span>
00031 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, NtSetEaFile)</span>
00032 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00033 <span class="preprocessor"></span>
00034 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00035"></a><a class="code" href="../../d7/d2/qsea_8c.html#a1">00035</a> <a class="code" href="../../d7/d2/qsea_8c.html#a1">NtQueryEaFile</a>(
00036     IN HANDLE FileHandle,
00037     OUT PIO_STATUS_BLOCK IoStatusBlock,
00038     OUT PVOID Buffer,
00039     IN ULONG Length,
00040     IN BOOLEAN ReturnSingleEntry,
00041     IN PVOID EaList OPTIONAL,
00042     IN ULONG EaListLength,
00043     IN PULONG EaIndex OPTIONAL,
00044     IN BOOLEAN RestartScan
00045     )
00046 
00047 <span class="comment">/*++</span>
00048 <span class="comment"></span>
00049 <span class="comment">Routine Description:</span>
00050 <span class="comment"></span>
00051 <span class="comment">    This service returns the Extended Attributes (EAs) associated with the</span>
00052 <span class="comment">    file specified by the FileHandle parameter.  The amount of information</span>
00053 <span class="comment">    returned is based on the size of the EAs, and the size of the buffer.</span>
00054 <span class="comment">    That is, either all of the EAs are written to the buffer, or the buffer</span>
00055 <span class="comment">    is filled with complete EAs if the buffer is not large enough to contain</span>
00056 <span class="comment">    all of the EAs.  Only complete EAs are ever written to the buffer; no</span>
00057 <span class="comment">    partial EAs will ever be returned.</span>
00058 <span class="comment"></span>
00059 <span class="comment">Arguments:</span>
00060 <span class="comment"></span>
00061 <span class="comment">    FileHandle - Supplies a handle to the file for which the EAs are returned.</span>
00062 <span class="comment"></span>
00063 <span class="comment">    IoStatusBlock - Address of the caller's I/O status block.</span>
00064 <span class="comment"></span>
00065 <span class="comment">    Buffer - Supplies a buffer to receive the EAs for the file.</span>
00066 <span class="comment"></span>
00067 <span class="comment">    Length - Supplies the length, in bytes, of the buffer.</span>
00068 <span class="comment"></span>
00069 <span class="comment">    ReturnSingleEntry - Indicates that only a single entry should be returned</span>
00070 <span class="comment">        rather than filling the buffer with as many EAs as possible.</span>
00071 <span class="comment"></span>
00072 <span class="comment">    EaList - Optionally supplies a list of EA names whose values are returned.</span>
00073 <span class="comment"></span>
00074 <span class="comment">    EaListLength - Supplies the length of the EA list, if an EA list was</span>
00075 <span class="comment">        specified.</span>
00076 <span class="comment"></span>
00077 <span class="comment">    EaIndex - Supplies the optional index of an EA whose value is to be</span>
00078 <span class="comment">        returned.  If specified, then only that EA is returned.</span>
00079 <span class="comment"></span>
00080 <span class="comment">    RestartScan - Indicates whether the scan of the EAs should be restarted</span>
00081 <span class="comment">        from the beginning.</span>
00082 <span class="comment"></span>
00083 <span class="comment">Return Value:</span>
00084 <span class="comment"></span>
00085 <span class="comment">    The status returned is the final completion status of the operation.</span>
00086 <span class="comment"></span>
00087 <span class="comment">--*/</span>
00088 
00089 #define <a class="code" href="../../d2/d4/internal_8c.html#a1">GET_OFFSET_LENGTH</a>( CurrentEa, EaBase ) (    \
00090     (ULONG) ((PCHAR) CurrentEa - (PCHAR) EaBase) )
00091 
00092 
00093 {
00094     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
00095     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
00096     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> fileObject;
00097     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
00098     <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> event = (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00099     PCHAR auxiliaryBuffer = (PCHAR) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00100     BOOLEAN eaListPresent = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00101     ULONG eaIndexValue = 0<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>;
00102     <a class="code" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> requestorMode;
00103     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
00104     IO_STATUS_BLOCK localIoStatus;
00105     BOOLEAN synchronousIo;
00106 
00107     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00108 
00109     <span class="comment">//</span>
00110     <span class="comment">// Get the previous mode;  i.e., the mode of the caller.</span>
00111     <span class="comment">//</span>
00112 
00113     requestorMode = KeGetPreviousMode();
00114 
00115     <span class="keywordflow">if</span> (requestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
00116 
00117         <span class="comment">//</span>
00118         <span class="comment">// The caller's access mode is not kernel so probe each of the arguments</span>
00119         <span class="comment">// and capture them as necessary.  If any failures occur, the condition</span>
00120         <span class="comment">// handler will be invoked to handle them.  It will simply cleanup and</span>
00121         <span class="comment">// return an access violation status code back to the system service</span>
00122         <span class="comment">// dispatcher.</span>
00123         <span class="comment">//</span>
00124 
00125         <span class="keywordflow">try</span> {
00126 
00127             <span class="comment">//</span>
00128             <span class="comment">// The IoStatusBlock parameter must be writeable by the caller.</span>
00129             <span class="comment">//</span>
00130 
00131             <a class="code" href="../../d5/d8/ex_8h.html#a31">ProbeForWriteIoStatus</a>( IoStatusBlock );
00132 
00133             <span class="comment">//</span>
00134             <span class="comment">// The buffer must be writeable by the caller.</span>
00135             <span class="comment">//</span>
00136 
00137             <a class="code" href="../../d5/d8/ex_8h.html#a259">ProbeForWrite</a>( <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, Length, <span class="keyword">sizeof</span>( ULONG ) );
00138 
00139             <span class="comment">//</span>
00140             <span class="comment">// If the optional EaIndex parameter was specified, then it must be</span>
00141             <span class="comment">// readable by the caller.  Capture its value.</span>
00142             <span class="comment">//</span>
00143 
00144             <span class="keywordflow">if</span> (ARGUMENT_PRESENT( EaIndex )) {
00145                 eaIndexValue = <a class="code" href="../../d5/d8/ex_8h.html#a20">ProbeAndReadUlong</a>( EaIndex );
00146             }
00147 
00148             <span class="comment">//</span>
00149             <span class="comment">// If the optional EaList parameter was specified, then it must be</span>
00150             <span class="comment">// readable by the caller.  Validate that the buffer contains a</span>
00151             <span class="comment">// legal get information structure.</span>
00152             <span class="comment">//</span>
00153 
00154             <span class="keywordflow">if</span> (ARGUMENT_PRESENT( EaList ) &amp;&amp; EaListLength != 0) {
00155 
00156                 PFILE_GET_EA_INFORMATION eas;
00157                 LONG tempLength;
00158                 ULONG entrySize;
00159 
00160                 eaListPresent = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00161 
00162                 <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( EaList, EaListLength, <span class="keyword">sizeof</span>( ULONG ) );
00163                 auxiliaryBuffer = <a class="code" href="../../d5/d5/cc_8h.html#a11">ExAllocatePoolWithQuota</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
00164                                                            EaListLength );
00165                 RtlCopyMemory( auxiliaryBuffer, EaList, EaListLength );
00166 
00167                 eas = (PFILE_GET_EA_INFORMATION) auxiliaryBuffer;
00168                 tempLength = EaListLength;
00169 
00170                 <span class="comment">//</span>
00171                 <span class="comment">// Walk the request buffer and ensure that its format is</span>
00172                 <span class="comment">// valid.  That is, ensure that it does not walk off the</span>
00173                 <span class="comment">// end of the buffer that has been captured.</span>
00174                 <span class="comment">//</span>
00175 
00176                 <span class="keywordflow">for</span> (;;) {
00177 
00178                     <span class="comment">//</span>
00179                     <span class="comment">// Get the size of the current entry in the buffer.</span>
00180                     <span class="comment">//</span>
00181 
00182                     <span class="keywordflow">if</span> (tempLength &lt; FIELD_OFFSET( FILE_GET_EA_INFORMATION, EaName[0])) {
00183                         tempLength = 0;
00184                         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( auxiliaryBuffer );
00185                         auxiliaryBuffer = (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00186                         IoStatusBlock-&gt;Status = STATUS_EA_LIST_INCONSISTENT;
00187                         IoStatusBlock-&gt;Information = tempLength;
00188                         <span class="keywordflow">return</span> STATUS_EA_LIST_INCONSISTENT;
00189                         }
00190 
00191                     entrySize = FIELD_OFFSET( FILE_GET_EA_INFORMATION, EaName[0] ) + eas-&gt;EaNameLength + 1;
00192 
00193                     <span class="keywordflow">if</span> ((ULONG) tempLength &lt; entrySize) {
00194                         tempLength = <a class="code" href="../../d2/d4/internal_8c.html#a1">GET_OFFSET_LENGTH</a>( eas, auxiliaryBuffer );
00195                         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( auxiliaryBuffer );
00196                         auxiliaryBuffer = (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00197                         IoStatusBlock-&gt;Status = STATUS_EA_LIST_INCONSISTENT;
00198                         IoStatusBlock-&gt;Information = tempLength;
00199                         <span class="keywordflow">return</span> STATUS_EA_LIST_INCONSISTENT;
00200                         }
00201 
00202                     <span class="keywordflow">if</span> (eas-&gt;NextEntryOffset != 0) {
00203 
00204                         <span class="comment">//</span>
00205                         <span class="comment">// There is another entry in the buffer and it must</span>
00206                         <span class="comment">// be longword aligned.  Ensure that the offset</span>
00207                         <span class="comment">// indicates that it is.  If it isn't, return an</span>
00208                         <span class="comment">// invalid parameter status.</span>
00209                         <span class="comment">//</span>
00210 
00211                         <span class="keywordflow">if</span> ((((entrySize + 3) &amp; ~3) != eas-&gt;NextEntryOffset) ||
00212                             ((LONG) eas-&gt;NextEntryOffset &lt; 0)) {
00213                             tempLength = <a class="code" href="../../d2/d4/internal_8c.html#a1">GET_OFFSET_LENGTH</a>( eas, auxiliaryBuffer );
00214                             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( auxiliaryBuffer );
00215                             auxiliaryBuffer = (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00216                             IoStatusBlock-&gt;Status = STATUS_EA_LIST_INCONSISTENT;
00217                             IoStatusBlock-&gt;Information = tempLength;
00218                             <span class="keywordflow">return</span> STATUS_EA_LIST_INCONSISTENT;
00219 
00220                         } <span class="keywordflow">else</span> {
00221 
00222                             <span class="comment">//</span>
00223                             <span class="comment">// There is another entry in the buffer, so</span>
00224                             <span class="comment">// account for the size of the current entry</span>
00225                             <span class="comment">// in the length and get a pointer to the next</span>
00226                             <span class="comment">// entry.</span>
00227                             <span class="comment">//</span>
00228 
00229                             tempLength -= eas-&gt;NextEntryOffset;
00230                             <span class="keywordflow">if</span> (tempLength &lt; 0) {
00231                                 tempLength = <a class="code" href="../../d2/d4/internal_8c.html#a1">GET_OFFSET_LENGTH</a>( eas, auxiliaryBuffer );
00232                                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( auxiliaryBuffer );
00233                                 auxiliaryBuffer = (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00234                                 IoStatusBlock-&gt;Status = STATUS_EA_LIST_INCONSISTENT;
00235                                 IoStatusBlock-&gt;Information = tempLength;
00236                                 <span class="keywordflow">return</span> STATUS_EA_LIST_INCONSISTENT;
00237                             }
00238                             eas = (PFILE_GET_EA_INFORMATION) ((PCHAR) eas + eas-&gt;NextEntryOffset);
00239                         }
00240 
00241                     } <span class="keywordflow">else</span> {
00242 
00243                         <span class="comment">//</span>
00244                         <span class="comment">// There are no other entries in the buffer.  Simply</span>
00245                         <span class="comment">// account for the overall buffer length according</span>
00246                         <span class="comment">// to the size of the current entry and exit the</span>
00247                         <span class="comment">// loop.</span>
00248                         <span class="comment">//</span>
00249 
00250                         tempLength -= entrySize;
00251                         <span class="keywordflow">break</span>;
00252                     }
00253                 }
00254 
00255                 <span class="comment">//</span>
00256                 <span class="comment">// All of the entries in the buffer have been processed.</span>
00257                 <span class="comment">// Check to see whether the overall buffer length went</span>
00258                 <span class="comment">// negative.  If so, return an error.</span>
00259                 <span class="comment">//</span>
00260 
00261                 <span class="keywordflow">if</span> (tempLength &lt; 0) {
00262                     tempLength = <a class="code" href="../../d2/d4/internal_8c.html#a1">GET_OFFSET_LENGTH</a>( eas, auxiliaryBuffer );
00263                     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( auxiliaryBuffer );
00264                     auxiliaryBuffer = (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00265                     IoStatusBlock-&gt;Status = STATUS_EA_LIST_INCONSISTENT;
00266                     IoStatusBlock-&gt;Information = tempLength;
00267                     <span class="keywordflow">return</span> STATUS_EA_LIST_INCONSISTENT;
00268                 }
00269 
00270             }
00271 
00272         } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00273 
00274             <span class="comment">//</span>
00275             <span class="comment">// An exception was incurred while probing the caller's</span>
00276             <span class="comment">// parameters, allocating the pool buffer, or copying the</span>
00277             <span class="comment">// caller's EA list to the buffer.  Cleanup and return an</span>
00278             <span class="comment">// appropriate error status code.</span>
00279             <span class="comment">//</span>
00280 
00281             <span class="keywordflow">if</span> (auxiliaryBuffer != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00282                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( auxiliaryBuffer );
00283             }
00284 
00285             <span class="keywordflow">return</span> GetExceptionCode();
00286 
00287         }
00288 
00289     } <span class="keywordflow">else</span> {
00290 
00291         <span class="comment">//</span>
00292         <span class="comment">// The caller's mode was KernelMode.  Simply allocate pool for the</span>
00293         <span class="comment">// EaList, if one was specified, and copy the string to it.  Also,</span>
00294         <span class="comment">// if an EaIndex was specified copy it as well.</span>
00295         <span class="comment">//</span>
00296 
00297         <span class="keywordflow">if</span> (ARGUMENT_PRESENT( EaList ) &amp;&amp; (EaListLength != 0)) {
00298             eaListPresent = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00299             <span class="keywordflow">try</span> {
00300                 auxiliaryBuffer = <a class="code" href="../../d5/d5/cc_8h.html#a11">ExAllocatePoolWithQuota</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
00301                                                            EaListLength );
00302             } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00303                 <span class="keywordflow">return</span> GetExceptionCode();
00304             }
00305             RtlCopyMemory( auxiliaryBuffer, EaList, EaListLength );
00306         }
00307 
00308         <span class="keywordflow">if</span> (ARGUMENT_PRESENT( EaIndex )) {
00309             eaIndexValue = *EaIndex;
00310         }
00311     }
00312 
00313     <span class="comment">//</span>
00314     <span class="comment">// There were no blatant errors so far, so reference the file object so</span>
00315     <span class="comment">// the target device object can be found.  Note that if the handle does</span>
00316     <span class="comment">// not refer to a file object, or if the caller does not have the required</span>
00317     <span class="comment">// access to the file, then it will fail.</span>
00318     <span class="comment">//</span>
00319 
00320     status = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a>( FileHandle,
00321                                         FILE_READ_EA,
00322                                         <a class="code" href="../../d5/d8/fssup_8c.html#a3">IoFileObjectType</a>,
00323                                         requestorMode,
00324                                         (PVOID *) &amp;fileObject,
00325                                         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00326     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
00327         <span class="keywordflow">if</span> (eaListPresent) {
00328             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( auxiliaryBuffer );
00329         }
00330         <span class="keywordflow">return</span> status;
00331     }
00332 
00333     <span class="comment">//</span>
00334     <span class="comment">// Make a special check here to determine whether this is a synchronous</span>
00335     <span class="comment">// I/O operation.  If it is, then wait here until the file is owned by</span>
00336     <span class="comment">// the current thread.  If this is not a (serialized) synchronous I/O</span>
00337     <span class="comment">// operation, then allocate and initialize the local event.</span>
00338     <span class="comment">//</span>
00339 
00340     <span class="keywordflow">if</span> (fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>) {
00341 
00342         BOOLEAN interrupted;
00343 
00344         <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d6/iop_8h.html#a13">IopAcquireFastLock</a>( fileObject )) {
00345             status = <a class="code" href="../../d0/d6/iop_8h.html#a147">IopAcquireFileObjectLock</a>( fileObject,
00346                                                requestorMode,
00347                                                (BOOLEAN) ((fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a152">FO_ALERTABLE_IO</a>) != 0),
00348                                                &amp;interrupted );
00349             <span class="keywordflow">if</span> (interrupted) {
00350                 <span class="keywordflow">if</span> (eaListPresent) {
00351                     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( auxiliaryBuffer );
00352                 }
00353                 <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00354                 <span class="keywordflow">return</span> status;
00355             }
00356         }
00357         synchronousIo = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00358     } <span class="keywordflow">else</span> {
00359 
00360         <span class="comment">//</span>
00361         <span class="comment">// This is a synchronous API being invoked for a file that is opened</span>
00362         <span class="comment">// for asynchronous I/O.  This means that this system service is</span>
00363         <span class="comment">// to synchronize the completion of the operation before returning</span>
00364         <span class="comment">// to the caller.  A local event is used to do this.</span>
00365         <span class="comment">//</span>
00366 
00367         event = <a class="code" href="../../d5/d5/cc_8h.html#a10">ExAllocatePool</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, <span class="keyword">sizeof</span>( <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> ) );
00368         <span class="keywordflow">if</span> (event == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00369             <span class="keywordflow">if</span> (eaListPresent) {
00370                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( auxiliaryBuffer );
00371             }
00372             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00373             <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
00374         }
00375         <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( event, SynchronizationEvent, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00376         synchronousIo = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00377     }
00378 
00379     <span class="comment">//</span>
00380     <span class="comment">// Set the file object to the Not-Signaled state.</span>
00381     <span class="comment">//</span>
00382 
00383     <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a>( &amp;fileObject-&gt;Event );
00384 
00385     <span class="comment">//</span>
00386     <span class="comment">// Get the address of the target device object.</span>
00387     <span class="comment">//</span>
00388 
00389     deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( fileObject );
00390 
00391     <span class="comment">//</span>
00392     <span class="comment">// Allocate and initialize the I/O Request Packet (IRP) for this operation.</span>
00393     <span class="comment">// The allocation is performed with an exception handler in case the</span>
00394     <span class="comment">// caller does not have enough quota to allocate the packet.</span>
00395 
00396     irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a17">IoAllocateIrp</a>( deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o13">StackSize</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00397     <span class="keywordflow">if</span> (!irp) {
00398 
00399         <span class="comment">//</span>
00400         <span class="comment">// An IRP could not be allocated.  Cleanup and return an appropriate</span>
00401         <span class="comment">// error status code.</span>
00402         <span class="comment">//</span>
00403 
00404         <span class="keywordflow">if</span> (!(fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>)) {
00405             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( event );
00406         }
00407 
00408         <a class="code" href="../../d0/d6/iop_8h.html#a148">IopAllocateIrpCleanup</a>( fileObject, (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00409 
00410         <span class="keywordflow">if</span> (eaListPresent) {
00411             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( auxiliaryBuffer );
00412         }
00413 
00414         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
00415     }
00416     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.OriginalFileObject = fileObject;
00417     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
00418     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o10">RequestorMode</a> = requestorMode;
00419 
00420     <span class="comment">//</span>
00421     <span class="comment">// Fill in the service independent parameters in the IRP.</span>
00422     <span class="comment">//</span>
00423 
00424     <span class="keywordflow">if</span> (synchronousIo) {
00425         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00426         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = IoStatusBlock;
00427     } <span class="keywordflow">else</span> {
00428         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = event;
00429         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = &amp;localIoStatus;
00430         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a176">IRP_SYNCHRONOUS_API</a>;
00431     }
00432     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00433 
00434     <span class="comment">//</span>
00435     <span class="comment">// Get a pointer to the stack location for the first driver.  This will be</span>
00436     <span class="comment">// used to pass the original function codes and parameters.</span>
00437     <span class="comment">//</span>
00438 
00439     irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
00440     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a20">IRP_MJ_QUERY_EA</a>;
00441     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> = fileObject;
00442 
00443     <span class="comment">//</span>
00444     <span class="comment">// If the caller specified an EA list of names to be queried, then pass</span>
00445     <span class="comment">// the address of the intermediary buffer containing the list to the</span>
00446     <span class="comment">// driver.</span>
00447     <span class="comment">//</span>
00448 
00449     <span class="keywordflow">if</span> (eaListPresent) {
00450         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.AuxiliaryBuffer = auxiliaryBuffer;
00451         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.QueryEa.EaList = auxiliaryBuffer;
00452         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.QueryEa.EaListLength = EaListLength;
00453     }
00454 
00455     <span class="comment">//</span>
00456     <span class="comment">// Now determine whether this driver expects to have data buffered</span>
00457     <span class="comment">// to it or whether it performs direct I/O.  This is based on the</span>
00458     <span class="comment">// DO_BUFFERED_IO flag in the device object.  If the flag is set,</span>
00459     <span class="comment">// then a system buffer is allocated and the driver's data will be</span>
00460     <span class="comment">// copied to it.  If the DO_DIRECT_IO flag is set in the device</span>
00461     <span class="comment">// object, then a Memory Descriptor List (MDL) is allocated and</span>
00462     <span class="comment">// the caller's buffer is locked down using it.  Finally, if the</span>
00463     <span class="comment">// driver specifies neither of the flags, then simply pass the</span>
00464     <span class="comment">// address and length of the buffer and allow the driver to perform</span>
00465     <span class="comment">// all of the checking and buffering if any is required.</span>
00466     <span class="comment">//</span>
00467 
00468     <span class="keywordflow">if</span> (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o8">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a123">DO_BUFFERED_IO</a>) {
00469 
00470         <span class="comment">//</span>
00471         <span class="comment">// The driver wishes the caller's buffered be copied into an</span>
00472         <span class="comment">// intermediary buffer.  Allocate the system buffer and specify</span>
00473         <span class="comment">// that it should be deallocated on completion.  Also indicate</span>
00474         <span class="comment">// that this is an input operation so the data will be copied</span>
00475         <span class="comment">// into the caller's buffer.  This is done using an exception</span>
00476         <span class="comment">// handler that will perform cleanup if the operation fails.</span>
00477         <span class="comment">//</span>
00478 
00479         <span class="keywordflow">if</span> (Length) {
00480             <span class="keywordflow">try</span> {
00481 
00482                 <span class="comment">//</span>
00483                 <span class="comment">// Allocate the intermediary system buffer from nonpaged</span>
00484                 <span class="comment">// pool and charge quota for it.</span>
00485                 <span class="comment">//</span>
00486 
00487                 irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer =
00488                    <a class="code" href="../../d5/d5/cc_8h.html#a11">ExAllocatePoolWithQuota</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, Length );
00489  
00490             } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00491 
00492                 <span class="comment">//</span>
00493                 <span class="comment">// An exception was incurred while either probing the</span>
00494                 <span class="comment">// caller's buffer or allocating the system buffer.</span>
00495                 <span class="comment">// Determine what actually happened, clean everything</span>
00496                 <span class="comment">// up, and return an appropriate error status code.</span>
00497                 <span class="comment">//</span>
00498 
00499                 <a class="code" href="../../d0/d6/iop_8h.html#a170">IopExceptionCleanup</a>( fileObject,
00500                                      irp,
00501                                      (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00502                                      event );
00503 
00504                 <span class="keywordflow">if</span> (auxiliaryBuffer != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00505                     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( auxiliaryBuffer );
00506                 }
00507 
00508                 <span class="keywordflow">return</span> GetExceptionCode();
00509 
00510             }
00511 
00512             <span class="comment">//</span>
00513             <span class="comment">// Remember the address of the caller's buffer so the copy can</span>
00514             <span class="comment">// take place during I/O completion.  Also, set the flags so</span>
00515             <span class="comment">// that the completion code knows to do the copy and to deallocate</span>
00516             <span class="comment">// the buffer.</span>
00517             <span class="comment">//</span>
00518 
00519             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o26">UserBuffer</a> = <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>;
00520             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> |= (ULONG) (<a class="code" href="../../d0/d5/io_8h.html#a178">IRP_BUFFERED_IO</a> |
00521                                    <a class="code" href="../../d0/d5/io_8h.html#a179">IRP_DEALLOCATE_BUFFER</a> |
00522                                    <a class="code" href="../../d0/d5/io_8h.html#a180">IRP_INPUT_OPERATION</a>);
00523         } <span class="keywordflow">else</span> {
00524             <span class="comment">//</span>
00525             <span class="comment">// This is a zero-length request.  Simply indicate that this is</span>
00526             <span class="comment">// buffered I/O, and pass along the request.  The buffer will</span>
00527             <span class="comment">// not be set to deallocate so the completion path does not</span>
00528             <span class="comment">// have to special-case the length.</span>
00529             <span class="comment">//</span>
00530 
00531             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00532             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> |= (ULONG) (<a class="code" href="../../d0/d5/io_8h.html#a178">IRP_BUFFERED_IO</a> | <a class="code" href="../../d0/d5/io_8h.html#a180">IRP_INPUT_OPERATION</a>);
00533 
00534         }
00535 
00536     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o8">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a125">DO_DIRECT_IO</a>) {
00537 
00538         <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> mdl;
00539 
00540         <span class="comment">//</span>
00541         <span class="comment">// This is a direct I/O operation.  Allocate an MDL and invoke</span>
00542         <span class="comment">// the memory management routine to lock the buffer into memory.</span>
00543         <span class="comment">// This is done using an exception handler that will perform</span>
00544         <span class="comment">// cleanup if the operation fails.</span>
00545         <span class="comment">//</span>
00546 
00547         <span class="keywordflow">if</span> (Length) {
00548             mdl = (<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00549 
00550             <span class="keywordflow">try</span> {
00551 
00552                 <span class="comment">//</span>
00553                 <span class="comment">// Allocate an MDL, charging quota for it, and hang it off</span>
00554                 <span class="comment">// of the IRP.  Probe and lock the pages associated with</span>
00555                 <span class="comment">// the caller's buffer for write access and fill in the MDL</span>
00556                 <span class="comment">// with the PFNs of those pages.</span>
00557                 <span class="comment">//</span>
00558 
00559                 mdl = <a class="code" href="../../d4/d6/iosubs_8c.html#a19">IoAllocateMdl</a>( <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, Length, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, irp );
00560                 <span class="keywordflow">if</span> (mdl == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00561                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INSUFFICIENT_RESOURCES );
00562                 }
00563                 <a class="code" href="../../d5/d6/iosup_8c.html#a41">MmProbeAndLockPages</a>( mdl, requestorMode, <a class="code" href="../../d2/d1/mm_8h.html#a344a169">IoWriteAccess</a> );
00564 
00565             } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00566 
00567                 <span class="comment">//</span>
00568                 <span class="comment">// An exception was incurred while either probing the</span>
00569                 <span class="comment">// caller's buffer or allocating the MDL.  Determine what</span>
00570                 <span class="comment">// actually happened, clean everything up, and return an</span>
00571                 <span class="comment">// appropriate error status code.</span>
00572                 <span class="comment">//</span>
00573 
00574                 <a class="code" href="../../d0/d6/iop_8h.html#a170">IopExceptionCleanup</a>( fileObject,
00575                                      irp,
00576                                      (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00577                                      event );
00578 
00579                 <span class="keywordflow">if</span> (auxiliaryBuffer != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00580                     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( auxiliaryBuffer );
00581                 }
00582 
00583                 <span class="keywordflow">return</span> GetExceptionCode();
00584 
00585             }
00586         }
00587 
00588     } <span class="keywordflow">else</span> {
00589 
00590         <span class="comment">//</span>
00591         <span class="comment">// Pass the address of the user's buffer so the driver has access</span>
00592         <span class="comment">// to it.  It is now the driver's responsibility to do everything.</span>
00593         <span class="comment">//</span>
00594 
00595         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o26">UserBuffer</a> = <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>;
00596 
00597     }
00598 
00599     <span class="comment">//</span>
00600     <span class="comment">// Copy the caller's parameters to the service-specific portion of the</span>
00601     <span class="comment">// IRP.</span>
00602     <span class="comment">//</span>
00603 
00604     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.QueryEa.Length = Length;
00605     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.QueryEa.EaIndex = eaIndexValue;
00606     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o2">Flags</a> = 0;
00607     <span class="keywordflow">if</span> (RestartScan) {
00608         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o2">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a208">SL_RESTART_SCAN</a>;
00609     }
00610     <span class="keywordflow">if</span> (ReturnSingleEntry) {
00611         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o2">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a209">SL_RETURN_SINGLE_ENTRY</a>;
00612     }
00613     <span class="keywordflow">if</span> (ARGUMENT_PRESENT( EaIndex )) {
00614         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o2">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a210">SL_INDEX_SPECIFIED</a>;
00615     }
00616 
00617     <span class="comment">//</span>
00618     <span class="comment">// Queue the packet, call the driver, and synchronize appopriately with</span>
00619     <span class="comment">// I/O completion.</span>
00620     <span class="comment">//</span>
00621 
00622     status = <a class="code" href="../../d0/d6/iop_8h.html#a212">IopSynchronousServiceTail</a>( deviceObject,
00623                                         irp,
00624                                         fileObject,
00625                                         <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00626                                         requestorMode,
00627                                         synchronousIo,
00628                                         <a class="code" href="../../d0/d6/iop_8h.html#a240a140">OtherTransfer</a> );
00629 
00630     <span class="comment">//</span>
00631     <span class="comment">// If the file for this operation was not opened for synchronous I/O, then</span>
00632     <span class="comment">// synchronization of completion of the I/O operation has not yet occurred</span>
00633     <span class="comment">// since the allocated event must be used for synchronous APIs on files</span>
00634     <span class="comment">// opened for asynchronous I/O.  Synchronize the completion of the I/O</span>
00635     <span class="comment">// operation now.</span>
00636     <span class="comment">//</span>
00637 
00638     <span class="keywordflow">if</span> (!synchronousIo) {
00639 
00640         status = <a class="code" href="../../d0/d6/iop_8h.html#a211">IopSynchronousApiServiceTail</a>( status,
00641                                                event,
00642                                                irp,
00643                                                requestorMode,
00644                                                &amp;localIoStatus,
00645                                                IoStatusBlock );
00646     }
00647 
00648     <span class="keywordflow">return</span> status;
00649 }
00650 
00651 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00652"></a><a class="code" href="../../d7/d2/qsea_8c.html#a2">00652</a> <a class="code" href="../../d7/d2/qsea_8c.html#a2">NtSetEaFile</a>(
00653     IN HANDLE FileHandle,
00654     OUT PIO_STATUS_BLOCK IoStatusBlock,
00655     IN PVOID Buffer,
00656     IN ULONG Length
00657     )
00658 
00659 <span class="comment">/*++</span>
00660 <span class="comment"></span>
00661 <span class="comment">Routine Description:</span>
00662 <span class="comment"></span>
00663 <span class="comment">    This service replaces the Extended Attributes (EAs) associated with the file</span>
00664 <span class="comment">    specified by the FileHandle parameter.  All of the EAs associated with the</span>
00665 <span class="comment">    file are replaced by the EAs in the specified buffer.</span>
00666 <span class="comment"></span>
00667 <span class="comment">Arguments:</span>
00668 <span class="comment"></span>
00669 <span class="comment">    FileHandle - Supplies a handle to the file whose EAs should be changed.</span>
00670 <span class="comment"></span>
00671 <span class="comment">    IoStatusBlock - Address of the caller's I/O status block.</span>
00672 <span class="comment"></span>
00673 <span class="comment">    FileInformation - Supplies a buffer containing the new EAs which should be</span>
00674 <span class="comment">        used to replace the EAs currently associated with the file.</span>
00675 <span class="comment"></span>
00676 <span class="comment">    Length - Supplies the length, in bytes, of the buffer.</span>
00677 <span class="comment"></span>
00678 <span class="comment">Return Value:</span>
00679 <span class="comment"></span>
00680 <span class="comment">    The status returned is the final completion status of the operation.</span>
00681 <span class="comment"></span>
00682 <span class="comment">--*/</span>
00683 
00684 {
00685     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
00686     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
00687     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> fileObject;
00688     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
00689     <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> event = (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00690     <a class="code" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> requestorMode;
00691     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
00692     IO_STATUS_BLOCK localIoStatus;
00693     BOOLEAN synchronousIo;
00694 
00695     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00696 
00697     <span class="comment">//</span>
00698     <span class="comment">// Get the previous mode;  i.e., the mode of the caller.</span>
00699     <span class="comment">//</span>
00700 
00701     requestorMode = KeGetPreviousMode();
00702 
00703     <span class="keywordflow">if</span> (requestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
00704 
00705         <span class="comment">//</span>
00706         <span class="comment">// The caller's access mode is user, so probe each of the arguments</span>
00707         <span class="comment">// and capture them as necessary.  If any failures occur, the condition</span>
00708         <span class="comment">// handler will be invoked to handle them.  It will simply cleanup and</span>
00709         <span class="comment">// return an access violation status code back to the system service</span>
00710         <span class="comment">// dispatcher.</span>
00711         <span class="comment">//</span>
00712 
00713         <span class="keywordflow">try</span> {
00714 
00715             <span class="comment">//</span>
00716             <span class="comment">// The IoStatusBlock parameter must be writeable by the caller.</span>
00717             <span class="comment">//</span>
00718 
00719             <a class="code" href="../../d5/d8/ex_8h.html#a31">ProbeForWriteIoStatus</a>( IoStatusBlock );
00720 
00721             <span class="comment">//</span>
00722             <span class="comment">// The Buffer parameter must be readable by the caller.</span>
00723             <span class="comment">//</span>
00724 
00725             <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, Length, <span class="keyword">sizeof</span>( ULONG ) );
00726 
00727         } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00728 
00729             <span class="comment">//</span>
00730             <span class="comment">// An exception was incurred while probing the caller's parameters.</span>
00731             <span class="comment">// Cleanup and return an appropriate error status code.</span>
00732             <span class="comment">//</span>
00733 
00734             <span class="keywordflow">return</span> GetExceptionCode();
00735         }
00736     }
00737 
00738 
00739     <span class="comment">//</span>
00740     <span class="comment">// There were no blatant errors so far, so reference the file object so</span>
00741     <span class="comment">// the target device object can be found.  Note that if the handle does</span>
00742     <span class="comment">// not refer to a file object, or if the caller does not have the required</span>
00743     <span class="comment">// access to the file, then it will fail.</span>
00744     <span class="comment">//</span>
00745 
00746     status = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a>( FileHandle,
00747                                         FILE_WRITE_EA,
00748                                         <a class="code" href="../../d5/d8/fssup_8c.html#a3">IoFileObjectType</a>,
00749                                         requestorMode,
00750                                         (PVOID *) &amp;fileObject,
00751                                         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00752     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
00753         <span class="keywordflow">return</span> status;
00754     }
00755 
00756     <span class="comment">//</span>
00757     <span class="comment">// Make a special check here to determine whether this is a synchronous</span>
00758     <span class="comment">// I/O operation.  If it is, then wait here until the file is owned by</span>
00759     <span class="comment">// the current thread.  If this is not a (serialized) synchronous I/O</span>
00760     <span class="comment">// operation, then allocate and initialize the local event.</span>
00761     <span class="comment">//</span>
00762 
00763     <span class="keywordflow">if</span> (fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>) {
00764 
00765         BOOLEAN interrupted;
00766 
00767         <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d6/iop_8h.html#a13">IopAcquireFastLock</a>( fileObject )) {
00768             status = <a class="code" href="../../d0/d6/iop_8h.html#a147">IopAcquireFileObjectLock</a>( fileObject,
00769                                                requestorMode,
00770                                                (BOOLEAN) ((fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a152">FO_ALERTABLE_IO</a>) != 0),
00771                                                &amp;interrupted );
00772             <span class="keywordflow">if</span> (interrupted) {
00773                 <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00774                 <span class="keywordflow">return</span> status;
00775             }
00776         }
00777         synchronousIo = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00778     } <span class="keywordflow">else</span> {
00779 
00780         <span class="comment">//</span>
00781         <span class="comment">// This is a synchronous API being invoked for a file that is opened</span>
00782         <span class="comment">// for asynchronous I/O.  This means that this system service is</span>
00783         <span class="comment">// to synchronize the completion of the operation before returning</span>
00784         <span class="comment">// to the caller.  A local event is used to do this.</span>
00785         <span class="comment">//</span>
00786 
00787         event = <a class="code" href="../../d5/d5/cc_8h.html#a10">ExAllocatePool</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, <span class="keyword">sizeof</span>( <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> ) );
00788         <span class="keywordflow">if</span> (event == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00789             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
00790             <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
00791         }
00792         <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( event, SynchronizationEvent, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00793         synchronousIo = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00794     }
00795 
00796     <span class="comment">//</span>
00797     <span class="comment">// Set the file object to the Not-Signaled state.</span>
00798     <span class="comment">//</span>
00799 
00800     <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a>( &amp;fileObject-&gt;Event );
00801 
00802     <span class="comment">//</span>
00803     <span class="comment">// Get the address of the target device object.</span>
00804     <span class="comment">//</span>
00805 
00806     deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( fileObject );
00807 
00808     <span class="comment">//</span>
00809     <span class="comment">// Allocate and initialize the I/O Request Packet (IRP) for this operation.</span>
00810     <span class="comment">// The allocation is performed with an exception handler in case the</span>
00811     <span class="comment">// caller does not have enough quota to allocate the packet.</span>
00812 
00813     irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a17">IoAllocateIrp</a>( deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o13">StackSize</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00814     <span class="keywordflow">if</span> (!irp) {
00815 
00816         <span class="comment">//</span>
00817         <span class="comment">// An IRP could not be allocated.  Cleanup and return an appropriate</span>
00818         <span class="comment">// error status code.</span>
00819         <span class="comment">//</span>
00820 
00821         <span class="keywordflow">if</span> (!(fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>)) {
00822             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( event );
00823         }
00824 
00825         <a class="code" href="../../d0/d6/iop_8h.html#a148">IopAllocateIrpCleanup</a>( fileObject, (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00826 
00827         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
00828     }
00829     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.OriginalFileObject = fileObject;
00830     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
00831     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o10">RequestorMode</a> = requestorMode;
00832 
00833     <span class="comment">//</span>
00834     <span class="comment">// Fill in the service independent parameters in the IRP.</span>
00835     <span class="comment">//</span>
00836 
00837     <span class="keywordflow">if</span> (synchronousIo) {
00838         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00839         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = IoStatusBlock;
00840     } <span class="keywordflow">else</span> {
00841         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = event;
00842         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = &amp;localIoStatus;
00843         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a176">IRP_SYNCHRONOUS_API</a>;
00844     }
00845     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00846 
00847     <span class="comment">//</span>
00848     <span class="comment">// Get a pointer to the stack location for the first driver.  This will be</span>
00849     <span class="comment">// used to pass the original function codes and parameters.</span>
00850     <span class="comment">//</span>
00851 
00852     irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
00853     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a21">IRP_MJ_SET_EA</a>;
00854     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> = fileObject;
00855 
00856     <span class="comment">//</span>
00857     <span class="comment">// Now determine whether this driver expects to have data buffered to it</span>
00858     <span class="comment">// or whether it performs direct I/O.  This is based on the DO_BUFFERED_IO</span>
00859     <span class="comment">// flag in the device object.  if the flag is set, then a system buffer is</span>
00860     <span class="comment">// allocated and driver's data is copied to it.  If the DO_DIRECT_IO flag</span>
00861     <span class="comment">// is set in the device object, then a Memory Descriptor List (MDL) is</span>
00862     <span class="comment">// allocated and the caller's buffer is locked down using it.  Finally, if</span>
00863     <span class="comment">// the driver specifies neither of the flags, then simply pass the address</span>
00864     <span class="comment">// and length of the buffer and allow the driver to perform all of the</span>
00865     <span class="comment">// checking and buffering if any is required.</span>
00866     <span class="comment">//</span>
00867 
00868     <span class="keywordflow">if</span> (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o8">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a123">DO_BUFFERED_IO</a>) {
00869 
00870         PFILE_FULL_EA_INFORMATION systemBuffer;
00871         ULONG errorOffset;
00872 
00873         <span class="comment">//</span>
00874         <span class="comment">// The driver wishes the caller's buffer to be copied into an</span>
00875         <span class="comment">// intermediary buffer.  Allocate the system buffer and specify</span>
00876         <span class="comment">// that it should be deallocated on completion.  Also check to</span>
00877         <span class="comment">// ensure that the caller's EA list is valid.  All of this is</span>
00878         <span class="comment">// performed within an exception handler that will perform</span>
00879         <span class="comment">// cleanup if the operation fails.</span>
00880         <span class="comment">//</span>
00881 
00882         <span class="keywordflow">if</span> (Length) {
00883             <span class="keywordflow">try</span> {
00884 
00885             <span class="comment">//</span>
00886             <span class="comment">// Allocate the intermediary system buffer and charge the caller</span>
00887             <span class="comment">// quota for its allocation.  Copy the caller's EA buffer into the</span>
00888             <span class="comment">// buffer and check to ensure that it is valid.</span>
00889             <span class="comment">//</span>
00890 
00891                 systemBuffer = <a class="code" href="../../d5/d5/cc_8h.html#a11">ExAllocatePoolWithQuota</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, Length );
00892 
00893                 irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer = systemBuffer;
00894 
00895                 RtlCopyMemory( systemBuffer, <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, Length );
00896 
00897                 status = <a class="code" href="../../d4/d6/iosubs_8c.html#a33">IoCheckEaBufferValidity</a>( systemBuffer,
00898                                                   Length,
00899                                                   &amp;errorOffset );
00900 
00901                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
00902                     IoStatusBlock-&gt;Status = status;
00903                     IoStatusBlock-&gt;Information = errorOffset;
00904                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( status );
00905                 }
00906 
00907             } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00908 
00909                 <span class="comment">//</span>
00910                 <span class="comment">// An exception was incurred while allocating the buffer, copying</span>
00911                 <span class="comment">// the caller's data into it, or walking the EA buffer.  Determine</span>
00912                 <span class="comment">// what happened, cleanup, and return an appropriate error status</span>
00913                 <span class="comment">// code.</span>
00914                 <span class="comment">//</span>
00915 
00916                 <a class="code" href="../../d0/d6/iop_8h.html#a170">IopExceptionCleanup</a>( fileObject,
00917                                      irp,
00918                                      (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00919                                      event );
00920 
00921                 <span class="keywordflow">return</span> GetExceptionCode();
00922 
00923             }
00924 
00925             <span class="comment">//</span>
00926             <span class="comment">// Set the flags so that the completion code knows to deallocate the</span>
00927             <span class="comment">// buffer.</span>
00928             <span class="comment">//</span>
00929     
00930             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a178">IRP_BUFFERED_IO</a> | <a class="code" href="../../d0/d5/io_8h.html#a179">IRP_DEALLOCATE_BUFFER</a>;
00931         } <span class="keywordflow">else</span> {
00932             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00933         }
00934 
00935 
00936     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o8">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a125">DO_DIRECT_IO</a>) {
00937 
00938         <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> mdl;
00939 
00940         <span class="comment">//</span>
00941         <span class="comment">// This is a direct I/O operation.  Allocate an MDL and invoke the</span>
00942         <span class="comment">// memory management routine to lock the buffer into memory.  This is</span>
00943         <span class="comment">// done using an exception handler that will perform cleanup if the</span>
00944         <span class="comment">// operation fails.</span>
00945         <span class="comment">//</span>
00946 
00947         mdl = (<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00948 
00949         <span class="keywordflow">if</span> (Length) {
00950             <span class="keywordflow">try</span> {
00951 
00952                 <span class="comment">//</span>
00953                 <span class="comment">// Allocate an MDL, charging quota for it, and hang it off of the</span>
00954                 <span class="comment">// IRP.  Probe and lock the pages associated with the caller's</span>
00955                 <span class="comment">// buffer for read access and fill in the MDL with the PFNs of those</span>
00956                 <span class="comment">// pages.</span>
00957                 <span class="comment">//</span>
00958 
00959                 mdl = <a class="code" href="../../d4/d6/iosubs_8c.html#a19">IoAllocateMdl</a>( <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, Length, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, irp );
00960                 <span class="keywordflow">if</span> (mdl == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00961                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INSUFFICIENT_RESOURCES );
00962                 }
00963                 <a class="code" href="../../d5/d6/iosup_8c.html#a41">MmProbeAndLockPages</a>( mdl, requestorMode, <a class="code" href="../../d2/d1/mm_8h.html#a344a168">IoReadAccess</a> );
00964 
00965             } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00966 
00967                 <span class="comment">//</span>
00968                 <span class="comment">// An exception was incurred while either probing the caller's</span>
00969                 <span class="comment">// buffer or allocating the MDL.  Determine what actually happened,</span>
00970                 <span class="comment">// clean everything up, and return an appropriate error status code.</span>
00971                 <span class="comment">//</span>
00972 
00973                 <a class="code" href="../../d0/d6/iop_8h.html#a170">IopExceptionCleanup</a>( fileObject,
00974                                      irp,
00975                                      (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00976                                      event );
00977 
00978                 <span class="keywordflow">return</span> GetExceptionCode();
00979 
00980             }
00981         }
00982 
00983     } <span class="keywordflow">else</span> {
00984 
00985         <span class="comment">//</span>
00986         <span class="comment">// Pass the address of the user's buffer so the driver has access to</span>
00987         <span class="comment">// it.  It is now the driver's responsibility to do everything.</span>
00988         <span class="comment">//</span>
00989 
00990         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o26">UserBuffer</a> = <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>;
00991 
00992     }
00993 
00994     <span class="comment">//</span>
00995     <span class="comment">// Copy the caller's parameters to the service-specific portion of the</span>
00996     <span class="comment">// IRP.</span>
00997     <span class="comment">//</span>
00998 
00999     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.SetEa.Length = Length;
01000 
01001 
01002     <span class="comment">//</span>
01003     <span class="comment">// Queue the packet, call the driver, and synchronize appopriately with</span>
01004     <span class="comment">// I/O completion.</span>
01005     <span class="comment">//</span>
01006 
01007     status = <a class="code" href="../../d0/d6/iop_8h.html#a212">IopSynchronousServiceTail</a>( deviceObject,
01008                                         irp,
01009                                         fileObject,
01010                                         <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01011                                         requestorMode,
01012                                         synchronousIo,
01013                                         <a class="code" href="../../d0/d6/iop_8h.html#a240a140">OtherTransfer</a> );
01014 
01015     <span class="comment">//</span>
01016     <span class="comment">// If the file for this operation was not opened for synchronous I/O, then</span>
01017     <span class="comment">// synchronization of completion of the I/O operation has not yet occurred</span>
01018     <span class="comment">// since the allocated event must be used for synchronous APIs on files</span>
01019     <span class="comment">// opened for asynchronous I/O.  Synchronize the completion of the I/O</span>
01020     <span class="comment">// operation now.</span>
01021     <span class="comment">//</span>
01022 
01023     <span class="keywordflow">if</span> (!synchronousIo) {
01024 
01025         status = <a class="code" href="../../d0/d6/iop_8h.html#a211">IopSynchronousApiServiceTail</a>( status,
01026                                                event,
01027                                                irp,
01028                                                requestorMode,
01029                                                &amp;localIoStatus,
01030                                                IoStatusBlock );
01031     }
01032 
01033     <span class="keywordflow">return</span> status;
01034 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:41:33 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
