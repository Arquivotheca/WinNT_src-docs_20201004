<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: mips/exdsptch.c File Reference</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>exdsptch.c File Reference</h1><code>#include "<a class="el" href="../../d6/d8/ntrtlp_8h-source.html">ntrtlp.h</a>"</code><br>

<p>
<a href="../../d9/d8/mips_2exdsptch_8c-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d9/mips_2exdsptch_8c.html#a0">RAISE_EXCEPTION</a>(<a class="el" href="../../d2/d1/cttoken_8c.html#a18">Status</a>, ExceptionRecordt)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d9/mips_2exdsptch_8c.html#a1">RA</a>&nbsp;&nbsp;&nbsp;0x1f</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>&nbsp;&nbsp;&nbsp;0x1d</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d9/mips_2exdsptch_8c.html#a3">ZERO</a>&nbsp;&nbsp;&nbsp;0x0</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d9/mips_2exdsptch_8c.html#a4">SAVED_FLOATING_MASK</a>&nbsp;&nbsp;&nbsp;0xfff00000</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d9/mips_2exdsptch_8c.html#a5">SAVED_INTEGER_MASK</a>&nbsp;&nbsp;&nbsp;0xf3ffff02</td></tr>

<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d9/mips_2exdsptch_8c.html#a6">RtlpRestoreContext</a> (IN PCONTEXT Context, IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d9/mips_2exdsptch_8c.html#a7">RtlpRaiseException</a> (IN PEXCEPTION_RECORD ExceptionRecord)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d9/mips_2exdsptch_8c.html#a8">RtlpRaiseStatus</a> (IN NTSTATUS <a class="el" href="../../d2/d1/cttoken_8c.html#a18">Status</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d9/mips_2exdsptch_8c.html#a9">RtlpVirtualUnwind</a> (IN ULONG ControlPc, IN PRUNTIME_FUNCTION FunctionEntry, IN PCONTEXT ContextRecord, OUT PBOOLEAN InFunction, OUT PULONG EstablisherFrame, IN OUT PKNONVOLATILE_CONTEXT_POINTERS ContextPointers OPTIONAL)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d9/mips_2exdsptch_8c.html#a10">RtlpVirtualUnwind32</a> (IN ULONG ControlPc, IN PRUNTIME_FUNCTION FunctionEntry, IN OUT PCONTEXT ContextRecord, OUT PBOOLEAN InFunction, OUT PULONG EstablisherFrame, IN OUT PKNONVOLATILE_CONTEXT_POINTERS ContextPointers OPTIONAL)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d9/mips_2exdsptch_8c.html#a11">RtlDispatchException</a> (IN PEXCEPTION_RECORD ExceptionRecord, IN PCONTEXT ContextRecord)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>PRUNTIME_FUNCTION&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d9/mips_2exdsptch_8c.html#a12">RtlLookupFunctionEntry</a> (IN ULONG ControlPc)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d9/mips_2exdsptch_8c.html#a13">RtlRaiseException</a> (IN PEXCEPTION_RECORD ExceptionRecord)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d9/mips_2exdsptch_8c.html#a14">RtlRaiseStatus</a> (IN NTSTATUS <a class="el" href="../../d2/d1/cttoken_8c.html#a18">Status</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d9/mips_2exdsptch_8c.html#a15">RtlUnwind</a> (IN PVOID TargetFrame OPTIONAL, IN PVOID TargetIp OPTIONAL, IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL, IN PVOID ReturnValue)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d9/mips_2exdsptch_8c.html#a16">RtlUnwind2</a> (IN PVOID TargetFrame OPTIONAL, IN PVOID TargetIp OPTIONAL, IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL, IN PVOID ReturnValue, IN PCONTEXT ContextRecord)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d8/d9/mips_2exdsptch_8c.html#a17">RtlVirtualUnwind</a> (IN ULONG ControlPc, IN PRUNTIME_FUNCTION FunctionEntry, IN OUT PCONTEXT ContextRecord, OUT PBOOLEAN InFunction, OUT PULONG EstablisherFrame, IN OUT PKNONVOLATILE_CONTEXT_POINTERS ContextPointers OPTIONAL)</td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="a1" doxytag="mips/exdsptch.c::RA" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define RA&nbsp;&nbsp;&nbsp;0x1f          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html#l00048">48</a> of file <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html">mips/exdsptch.c</a>.
<p>
Referenced by <a class="el" href="../../d6/d0/pnpres_8c-source.html#l08336">IopQueryConflictListInternal()</a>, <a class="el" href="../../d6/d0/pnpres_8c-source.html#l03376">IopReserve()</a>, <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html#l01572">RtlpVirtualUnwind32()</a>, and <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html#l01074">RtlVirtualUnwind()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a0" doxytag="mips/exdsptch.c::RAISE_EXCEPTION" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define RAISE_EXCEPTION          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="../../d2/d1/cttoken_8c.html#a18">Status</a>,         <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>ExceptionRecordt&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><pre class="fragment"><div>{ \
    EXCEPTION_RECORD ExceptionRecordn; \
                                            \
    ExceptionRecordn.ExceptionCode = <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>; \
    ExceptionRecordn.ExceptionFlags = <a class="code" href="../../d6/d7/halmips_8h.html#a25">EXCEPTION_NONCONTINUABLE</a>; \
    ExceptionRecordn.ExceptionRecord = ExceptionRecordt; \
    ExceptionRecordn.NumberParameters = 0; \
    <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a17">RtlRaiseException</a>(&amp;ExceptionRecordn); \
    }
</div></pre>
<p>
Definition at line <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html#l00034">34</a> of file <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html">mips/exdsptch.c</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="mips/exdsptch.c::SAVED_FLOATING_MASK" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SAVED_FLOATING_MASK&nbsp;&nbsp;&nbsp;0xfff00000          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html#l00056">56</a> of file <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html">mips/exdsptch.c</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="mips/exdsptch.c::SAVED_INTEGER_MASK" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SAVED_INTEGER_MASK&nbsp;&nbsp;&nbsp;0xf3ffff02          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html#l00057">57</a> of file <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html">mips/exdsptch.c</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="mips/exdsptch.c::SP" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define SP&nbsp;&nbsp;&nbsp;0x1d          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html#l00049">49</a> of file <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html">mips/exdsptch.c</a>.
<p>
Referenced by <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html#l01572">RtlpVirtualUnwind32()</a>, and <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html#l01074">RtlVirtualUnwind()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="mips/exdsptch.c::ZERO" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define ZERO&nbsp;&nbsp;&nbsp;0x0          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html#l00050">50</a> of file <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html">mips/exdsptch.c</a>.
<p>
Referenced by <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html#l01572">RtlpVirtualUnwind32()</a>, and <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html#l01074">RtlVirtualUnwind()</a>.    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a11" doxytag="mips/exdsptch.c::RtlDispatchException" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN RtlDispatchException           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PEXCEPTION_RECORD&nbsp;</td>
          <td class="mdname" nowrap> <em>ExceptionRecord</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PCONTEXT&nbsp;</td>
          <td class="mdname" nowrap> <em>ContextRecord</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html#l00101">101</a> of file <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html">mips/exdsptch.c</a>.
<p>
References <a class="el" href="../../d7/d6/halmips_8h-source.html#l00051">EXCEPTION_NESTED_CALL</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00047">EXCEPTION_NONCONTINUABLE</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00050">EXCEPTION_STACK_INVALID</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00059">ExceptionContinueExecution</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00060">ExceptionContinueSearch</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00061">ExceptionNestedException</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d2/d9/cmchek_8c-source.html#l00095">Index</a>, <a class="el" href="../../d0/d2/ldrp_8h-source.html#l00370">NtGlobalFlag</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l00065">RAISE_EXCEPTION</a>, <a class="el" href="../../d0/d9/ppc_2exdsptch_8c-source.html#l00348">RtlLookupFunctionEntry()</a>, <a class="el" href="../../d6/d9/ntrtlppc_8h.html#a0">RtlpExecuteHandlerForException()</a>, <a class="el" href="../../d9/d9/rtl_2ia64_2miscc_8c-source.html#l00126">RtlpGetStackLimits()</a>, <a class="el" href="../../d4/d8/excptdbg_8c-source.html#l00065">RtlpLogExceptionHandler()</a>, <a class="el" href="../../d5/d9/ntrtlp_8h.html#a49">RtlpLogLastExceptionDisposition()</a>, <a class="el" href="../../d1/d6/ppc_2vunwind_8c-source.html#l00467">RtlVirtualUnwind()</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
<pre class="fragment"><div>00108                    :
00109 
00110     This function attempts to dispatch an exception to a frame based
00111     handler by searching backwards through <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> stack based call frames.
00112     The search begins with <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> frame specified in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> context record and
00113     continues backward until either a handler <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> found that handles <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00114     exception, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> stack <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> found to be invalid (i.e., out of limits or
00115     unaligned), or <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> end of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> call hierarchy <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> reached.
00116 
00117     As each frame <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> encounter, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> PC where <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> left <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> corresponding
00118     function <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> determined and used to lookup exception handler information
00119     in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> runtime function table built by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> linker. If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> respective
00120     routine has an exception handler, then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> handler <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> called. If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00121     handler does not handle <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> exception, then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> prologue of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> routine
00122     <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> executed backwards to <span class="stringliteral">"unwind"</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> effect of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> prologue and then
00123     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> next frame <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> examined.
00124 
00125 Arguments:
00126 
00127     ExceptionRecord - Supplies a pointer to an exception record.
00128 
00129     ContextRecord - Supplies a pointer to a context record.
00130 
00131 Return Value:
00132 
00133     If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> exception <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> handled by one of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> frame based handlers, then
00134     a value of <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned. Otherwise a value of <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned.
00135 
00136 --*/
00137 
00138 {
00139 
00140     CONTEXT ContextRecord1;
00141     ULONG ControlPc;
00142     <a class="code" href="../../d0/d6/struct__DISPATCHER__CONTEXT.html">DISPATCHER_CONTEXT</a> DispatcherContext;
00143     EXCEPTION_DISPOSITION Disposition;
00144     ULONG EstablisherFrame;
00145     ULONG ExceptionFlags;
00146     PRUNTIME_FUNCTION FunctionEntry;
00147     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00148     BOOLEAN InFunction;
00149     ULONG HighLimit;
00150     ULONG LowLimit;
00151     ULONG NestedFrame;
00152     ULONG NextPc;
00153 
00154     <span class="comment">//</span>
00155     <span class="comment">// Get current stack limits, copy the context record, get the initial</span>
00156     <span class="comment">// PC value, capture the exception flags, and set the nested exception</span>
00157     <span class="comment">// frame pointer.</span>
00158     <span class="comment">//</span>
00159 
00160     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a30">RtlpGetStackLimits</a>(&amp;LowLimit, &amp;HighLimit);
00161     RtlMoveMemory(&amp;ContextRecord1, ContextRecord, <span class="keyword">sizeof</span>(CONTEXT));
00162     ControlPc = ContextRecord1.Fir;
00163     ExceptionFlags = ExceptionRecord-&gt;ExceptionFlags &amp; <a class="code" href="../../d6/d7/halmips_8h.html#a25">EXCEPTION_NONCONTINUABLE</a>;
00164     NestedFrame = 0;
00165 
00166     <span class="comment">//</span>
00167     <span class="comment">// Start with the frame specified by the context record and search</span>
00168     <span class="comment">// backwards through the call frame hierarchy attempting to find an</span>
00169     <span class="comment">// exception handler that will handle the exception.</span>
00170     <span class="comment">//</span>
00171 
00172     <span class="keywordflow">do</span> {
00173 
00174         <span class="comment">//</span>
00175         <span class="comment">// Lookup the function table entry using the point at which control</span>
00176         <span class="comment">// left the procedure.</span>
00177         <span class="comment">//</span>
00178 
00179         FunctionEntry = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>(ControlPc);
00180 
00181         <span class="comment">//</span>
00182         <span class="comment">// If there is a function table entry for the routine, then virtually</span>
00183         <span class="comment">// unwind to the caller of the current routine to obtain the virtual</span>
00184         <span class="comment">// frame pointer of the establisher and check if there is an exception</span>
00185         <span class="comment">// handler for the frame.</span>
00186         <span class="comment">//</span>
00187 
00188         <span class="keywordflow">if</span> (FunctionEntry != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00189             NextPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc | 1,
00190                                       FunctionEntry,
00191                                       &amp;ContextRecord1,
00192                                       &amp;InFunction,
00193                                       &amp;EstablisherFrame,
00194                                       NULL);
00195 
00196             <span class="comment">//</span>
00197             <span class="comment">// If the virtual frame pointer is not within the specified stack</span>
00198             <span class="comment">// limits or the virtual frame pointer is unaligned, then set the</span>
00199             <span class="comment">// stack invalid flag in the exception record and return exception</span>
00200             <span class="comment">// not handled. Otherwise, check if the current routine has an</span>
00201             <span class="comment">// exception handler.</span>
00202             <span class="comment">//</span>
00203 
00204             <span class="keywordflow">if</span> ((EstablisherFrame &lt; LowLimit) || (EstablisherFrame &gt; HighLimit) ||
00205                ((EstablisherFrame &amp; 0x7) != 0)) {
00206                 ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a28">EXCEPTION_STACK_INVALID</a>;
00207                 <span class="keywordflow">break</span>;
00208 
00209             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((FunctionEntry-&gt;ExceptionHandler != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp; InFunction) {
00210 
00211                 <span class="comment">//</span>
00212                 <span class="comment">// The frame has an exception handler. The handler must be</span>
00213                 <span class="comment">// executed by calling another routine that is written in</span>
00214                 <span class="comment">// assembler. This is required because up level addressing</span>
00215                 <span class="comment">// of the handler information is required when a nested</span>
00216                 <span class="comment">// exception is encountered.</span>
00217                 <span class="comment">//</span>
00218 
00219                 DispatcherContext.ControlPc = ControlPc;
00220                 DispatcherContext.FunctionEntry = FunctionEntry;
00221                 DispatcherContext.EstablisherFrame = EstablisherFrame;
00222                 DispatcherContext.ContextRecord = ContextRecord;
00223                 ExceptionRecord-&gt;ExceptionFlags = ExceptionFlags;
00224 
00225                 <span class="comment">//</span>
00226                 <span class="comment">// If requested log exception.</span>
00227                 <span class="comment">//</span>
00228 
00229                 <span class="keywordflow">if</span> (<a class="code" href="../../d9/d2/ldrp_8h.html#a33">NtGlobalFlag</a> &amp; FLG_ENABLE_EXCEPTION_LOGGING) {
00230                     <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = <a class="code" href="../../d5/d9/ntrtlp_8h.html#a48">RtlpLogExceptionHandler</a>(ExceptionRecord,
00231                                                     ContextRecord,
00232                                                     ControlPc,
00233                                                     FunctionEntry,
00234                                                     <span class="keyword">sizeof</span>(RUNTIME_FUNCTION));
00235                 }
00236 
00237                 Disposition =
00238                     <a class="code" href="../../d6/d9/ntrtlppc_8h.html#a0">RtlpExecuteHandlerForException</a>(ExceptionRecord,
00239                                                    EstablisherFrame,
00240                                                    ContextRecord,
00241                                                    &amp;DispatcherContext,
00242                                                    FunctionEntry-&gt;ExceptionHandler);
00243 
00244                 <span class="keywordflow">if</span> (<a class="code" href="../../d9/d2/ldrp_8h.html#a33">NtGlobalFlag</a> &amp; FLG_ENABLE_EXCEPTION_LOGGING) {
00245                     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a49">RtlpLogLastExceptionDisposition</a>(Index, Disposition);
00246                 }
00247 
00248                 ExceptionFlags |=
00249                     (ExceptionRecord-&gt;ExceptionFlags &amp; <a class="code" href="../../d6/d7/halmips_8h.html#a25">EXCEPTION_NONCONTINUABLE</a>);
00250 
00251                 <span class="comment">//</span>
00252                 <span class="comment">// If the current scan is within a nested context and the frame</span>
00253                 <span class="comment">// just examined is the end of the nested region, then clear</span>
00254                 <span class="comment">// the nested context frame and the nested exception flag in</span>
00255                 <span class="comment">// the exception flags.</span>
00256                 <span class="comment">//</span>
00257 
00258                 <span class="keywordflow">if</span> (NestedFrame == EstablisherFrame) {
00259                     ExceptionFlags &amp;= (~<a class="code" href="../../d6/d7/halmips_8h.html#a29">EXCEPTION_NESTED_CALL</a>);
00260                     NestedFrame = 0;
00261                 }
00262 
00263                 <span class="comment">//</span>
00264                 <span class="comment">// Case on the handler disposition.</span>
00265                 <span class="comment">//</span>
00266 
00267                 <span class="keywordflow">switch</span> (Disposition) {
00268 
00269                     <span class="comment">//</span>
00270                     <span class="comment">// The disposition is to continue execution.</span>
00271                     <span class="comment">//</span>
00272                     <span class="comment">// If the exception is not continuable, then raise the</span>
00273                     <span class="comment">// exception STATUS_NONCONTINUABLE_EXCEPTION. Otherwise</span>
00274                     <span class="comment">// return exception handled.</span>
00275                     <span class="comment">//</span>
00276 
00277                 <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a36">ExceptionContinueExecution</a> :
00278                     <span class="keywordflow">if</span> ((ExceptionFlags &amp; <a class="code" href="../../d6/d7/halmips_8h.html#a25">EXCEPTION_NONCONTINUABLE</a>) != 0) {
00279                         <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a0">RAISE_EXCEPTION</a>(STATUS_NONCONTINUABLE_EXCEPTION, ExceptionRecord);
00280 
00281                     } <span class="keywordflow">else</span> {
00282                         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00283                     }
00284 
00285                     <span class="comment">//</span>
00286                     <span class="comment">// The disposition is to continue the search.</span>
00287                     <span class="comment">//</span>
00288                     <span class="comment">// Get next frame address and continue the search.</span>
00289                     <span class="comment">//</span>
00290 
00291                 <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a37">ExceptionContinueSearch</a> :
00292                     <span class="keywordflow">break</span>;
00293 
00294                     <span class="comment">//</span>
00295                     <span class="comment">// The disposition is nested exception.</span>
00296                     <span class="comment">//</span>
00297                     <span class="comment">// Set the nested context frame to the establisher frame</span>
00298                     <span class="comment">// address and set the nested exception flag in the</span>
00299                     <span class="comment">// exception flags.</span>
00300                     <span class="comment">//</span>
00301 
00302                 <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a38">ExceptionNestedException</a> :
00303                     ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a29">EXCEPTION_NESTED_CALL</a>;
00304                     <span class="keywordflow">if</span> (DispatcherContext.EstablisherFrame &gt; NestedFrame) {
00305                         NestedFrame = DispatcherContext.EstablisherFrame;
00306                     }
00307 
00308                     <span class="keywordflow">break</span>;
00309 
00310                     <span class="comment">//</span>
00311                     <span class="comment">// All other disposition values are invalid.</span>
00312                     <span class="comment">//</span>
00313                     <span class="comment">// Raise invalid disposition exception.</span>
00314                     <span class="comment">//</span>
00315 
00316                 <span class="keywordflow">default</span> :
00317                     <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a0">RAISE_EXCEPTION</a>(STATUS_INVALID_DISPOSITION, ExceptionRecord);
00318                 }
00319             }
00320 
00321         } <span class="keywordflow">else</span> {
00322 
00323             <span class="comment">//</span>
00324             <span class="comment">// Set point at which control left the previous routine.</span>
00325             <span class="comment">//</span>
00326 
00327             NextPc = (ULONG)(ContextRecord1.XIntRa - 4);
00328 
00329             <span class="comment">//</span>
00330             <span class="comment">// If the next control PC is the same as the old control PC, then</span>
00331             <span class="comment">// the function table is not correctly formed.</span>
00332             <span class="comment">//</span>
00333 
00334             <span class="keywordflow">if</span> (NextPc == ControlPc) {
00335                 <span class="keywordflow">break</span>;
00336             }
00337         }
00338 
00339         <span class="comment">//</span>
00340         <span class="comment">// Set point at which control left the previous routine.</span>
00341         <span class="comment">//</span>
00342 
00343         ControlPc = NextPc;
00344     } <span class="keywordflow">while</span> ((ULONG)ContextRecord1.XIntSp &lt; HighLimit);
00345 
00346     <span class="comment">//</span>
00347     <span class="comment">// Set final exception flags and return exception not handled.</span>
00348     <span class="comment">//</span>
00349 
00350     ExceptionRecord-&gt;ExceptionFlags = ExceptionFlags;
00351     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00352 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="mips/exdsptch.c::RtlLookupFunctionEntry" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> PRUNTIME_FUNCTION RtlLookupFunctionEntry           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN ULONG&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>ControlPc</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html#l00355">355</a> of file <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html">mips/exdsptch.c</a>.
<p>
References <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d9/d8/imagedir_8c-source.html#l00250">RtlImageDirectoryEntryToData()</a>, <a class="el" href="../../d7/d3/pctohdr_8c-source.html#l00042">RtlPcToFileHeader()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, and <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00064">USHORT</a>.
<p>
<pre class="fragment"><div>00361                    :
00362 
00363     This function searches <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> currently active function tables <span class="keywordflow">for</span> an entry
00364     that corresponds to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified PC value.
00365 
00366 Arguments:
00367 
00368     ControlPc - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address of an instruction within <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified
00369         function.
00370 
00371 Return Value:
00372 
00373     If there <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> no entry in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> function table <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified PC, then
00374     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned. Otherwise, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> function table entry
00375     that corresponds to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified PC <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned.
00376 
00377 --*/
00378 
00379 {
00380 
00381     PRUNTIME_FUNCTION FunctionEntry;
00382     PRUNTIME_FUNCTION FunctionTable;
00383     ULONG SizeOfExceptionTable;
00384     LONG High;
00385     PVOID ImageBase;
00386     LONG Low;
00387     LONG Middle;
00388     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> i;
00389 
00390     <span class="comment">//</span>
00391     <span class="comment">// Search for the image that includes the specified PC value.</span>
00392     <span class="comment">//</span>
00393 
00394     ImageBase = <a class="code" href="../../d6/d4/pctohdr_8c.html#a1">RtlPcToFileHeader</a>((PVOID)ControlPc, &amp;ImageBase);
00395 
00396     <span class="comment">//</span>
00397     <span class="comment">// If an image is found that includes the specified PC, then locate the</span>
00398     <span class="comment">// function table for the image.</span>
00399     <span class="comment">//</span>
00400 
00401     <span class="keywordflow">if</span> (ImageBase != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00402         FunctionTable = (PRUNTIME_FUNCTION)<a class="code" href="../../d8/d9/imagedir_8c.html#a5">RtlImageDirectoryEntryToData</a>(
00403                          ImageBase, TRUE, IMAGE_DIRECTORY_ENTRY_EXCEPTION,
00404                          &amp;SizeOfExceptionTable);
00405 
00406         <span class="comment">//</span>
00407         <span class="comment">// If a function table is located, then search the function table</span>
00408         <span class="comment">// for a function table entry for the specified PC.</span>
00409         <span class="comment">//</span>
00410 
00411         <span class="keywordflow">if</span> (FunctionTable != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00412 
00413             <span class="comment">//</span>
00414             <span class="comment">// Initialize search indicies.</span>
00415             <span class="comment">//</span>
00416 
00417             Low = 0;
00418             High = (SizeOfExceptionTable / <span class="keyword">sizeof</span>(RUNTIME_FUNCTION)) - 1;
00419 
00420             <span class="comment">//</span>
00421             <span class="comment">// Perform binary search on the function table for a function table</span>
00422             <span class="comment">// entry that subsumes the specified PC.</span>
00423             <span class="comment">//</span>
00424 
00425             <span class="keywordflow">while</span> (High &gt;= Low) {
00426 
00427                 <span class="comment">//</span>
00428                 <span class="comment">// Compute next probe index and test entry. If the specified PC</span>
00429                 <span class="comment">// is greater than of equal to the beginning address and less</span>
00430                 <span class="comment">// than the ending address of the function table entry, then</span>
00431                 <span class="comment">// return the address of the function table entry. Otherwise,</span>
00432                 <span class="comment">// continue the search.</span>
00433                 <span class="comment">//</span>
00434 
00435                 Middle = (Low + High) &gt;&gt; 1;
00436                 FunctionEntry = &amp;FunctionTable[Middle];
00437                 <span class="keywordflow">if</span> (ControlPc &lt; FunctionEntry-&gt;BeginAddress) {
00438                     High = Middle - 1;
00439 
00440                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ControlPc &gt;= FunctionEntry-&gt;EndAddress) {
00441                     Low = Middle + 1;
00442 
00443                 } <span class="keywordflow">else</span> {
00444 
00445                     <span class="comment">//</span>
00446                     <span class="comment">// The capability exists for more than one function entry</span>
00447                     <span class="comment">// to map to the same function. This permits a function to</span>
00448                     <span class="comment">// have discontiguous code segments described by separate</span>
00449                     <span class="comment">// function table entries. If the ending prologue address</span>
00450                     <span class="comment">// is not within the limits of the begining and ending</span>
00451                     <span class="comment">// address of the function able entry, then the prologue</span>
00452                     <span class="comment">// ending address is the address of a function table entry</span>
00453                     <span class="comment">// that accurately describes the ending prologue address.</span>
00454                     <span class="comment">//</span>
00455 
00456                     <span class="keywordflow">if</span> ((FunctionEntry-&gt;PrologEndAddress &lt; FunctionEntry-&gt;BeginAddress) ||
00457                         (FunctionEntry-&gt;PrologEndAddress &gt; FunctionEntry-&gt;EndAddress)) {
00458                         FunctionEntry = (PRUNTIME_FUNCTION)FunctionEntry-&gt;PrologEndAddress;
00459                     }
00460 
00461                     <span class="keywordflow">return</span> FunctionEntry;
00462                 }
00463             }
00464         }
00465     }
00466 
00467     <span class="comment">//</span>
00468     <span class="comment">// A function table entry for the specified PC was not found.</span>
00469     <span class="comment">//</span>
00470 
00471     <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00472 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="mips/exdsptch.c::RtlpRaiseException" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID RtlpRaiseException           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PEXCEPTION_RECORD&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>ExceptionRecord</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d8/ia64_2exdsptch_8c-source.html#l00311">311</a> of file <a class="el" href="../../d8/d8/ia64_2exdsptch_8c-source.html">ia64/exdsptch.c</a>.
<p>
<pre class="fragment"><div>00317                    :
00318 
00319     This function raises a software exception by building a context record
00320     and calling <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> raise exception system service.
00321 
00322 Arguments:
00323 
00324     ExceptionRecord - Supplies a pointer to an exception record.
00325 
00326 Return Value:
00327 
00328     None.
00329 
00330 --*/
00331 
00332 {
00333     ULONGLONG ImageBase;
00334     ULONGLONG TargetGp;
00335     ULONGLONG ControlPc;
00336     CONTEXT ContextRecord;
00337     FRAME_POINTERS EstablisherFrame;
00338     PRUNTIME_FUNCTION FunctionEntry;
00339     BOOLEAN InFunction;
00340     ULONGLONG NextPc;
00341     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00342 
00343     <span class="comment">//</span>
00344     <span class="comment">// Capture the current context, virtually unwind to the caller of this</span>
00345     <span class="comment">// routine, set the fault instruction address to that of the caller, and</span>
00346     <span class="comment">// call the raise exception system service.</span>
00347     <span class="comment">//</span>
00348 
00349     RtlCaptureContext(&amp;ContextRecord);
00350     ControlPc = RtlIa64InsertIPSlotNumber((ContextRecord.BrRp-16), 2);
00351     FunctionEntry = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>(ControlPc, &amp;ImageBase, &amp;TargetGp);
00352     NextPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ImageBase,
00353                               ControlPc,
00354                               FunctionEntry,
00355                               &amp;ContextRecord,
00356                               &amp;InFunction,
00357                               &amp;EstablisherFrame,
00358                               NULL);
00359 
00360     ContextRecord.StIIP = NextPc + 8;
00361     ContextRecord.StIPSR &amp;= ~((ULONGLONG) 3 &lt;&lt; PSR_RI);
00362     ExceptionRecord-&gt;ExceptionAddress = (PVOID)ContextRecord.StIIP;
00363     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwRaiseException(ExceptionRecord, &amp;ContextRecord, TRUE);
00364 
00365     <span class="comment">//</span>
00366     <span class="comment">// There should never be a return from this system service unless</span>
00367     <span class="comment">// there is a problem with the argument list itself. Raise another</span>
00368     <span class="comment">// exception specifying the status value returned.</span>
00369     <span class="comment">//</span>
00370 
00371     <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a10">RtlRaiseStatus</a>(Status);
00372     <span class="keywordflow">return</span>;
00373 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="mips/exdsptch.c::RtlpRaiseStatus" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID RtlpRaiseStatus           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN NTSTATUS&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>Status</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d8/d8/ia64_2exdsptch_8c-source.html#l00409">409</a> of file <a class="el" href="../../d8/d8/ia64_2exdsptch_8c-source.html">ia64/exdsptch.c</a>.
<p>
<pre class="fragment"><div>00415                    :
00416 
00417     This function raises an exception with <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified status value. The
00418     exception <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> marked as noncontinuable with no parameters.
00419 
00420 Arguments:
00421 
00422     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> status value to be used as <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> exception code
00423         <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> exception that <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> to be raised.
00424 
00425 Return Value:
00426 
00427     None.
00428 
00429 --*/
00430 
00431 {
00432     ULONGLONG ImageBase;
00433     ULONGLONG TargetGp;
00434     ULONGLONG ControlPc;
00435     ULONGLONG NextPc;
00436     CONTEXT ContextRecord;
00437     FRAME_POINTERS EstablisherFrame;
00438     EXCEPTION_RECORD ExceptionRecord;
00439     PRUNTIME_FUNCTION FunctionEntry;
00440     BOOLEAN InFunction;
00441 
00442     <span class="comment">//</span>
00443     <span class="comment">// Construct an exception record.</span>
00444     <span class="comment">//</span>
00445 
00446     ExceptionRecord.ExceptionCode = <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00447     ExceptionRecord.ExceptionRecord = (PEXCEPTION_RECORD)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00448     ExceptionRecord.NumberParameters = 0;
00449     ExceptionRecord.ExceptionFlags = <a class="code" href="../../d6/d7/halmips_8h.html#a25">EXCEPTION_NONCONTINUABLE</a>;
00450 
00451     <span class="comment">//</span>
00452     <span class="comment">// Capture the current context, virtually unwind to the caller of this</span>
00453     <span class="comment">// routine, set the fault instruction address to that of the caller, and</span>
00454     <span class="comment">// call the raise exception system service.</span>
00455     <span class="comment">//</span>
00456 
00457     RtlCaptureContext(&amp;ContextRecord);
00458     ControlPc = RtlIa64InsertIPSlotNumber((ContextRecord.BrRp-16), 2);
00459     FunctionEntry = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>(ControlPc, &amp;ImageBase, &amp;TargetGp);
00460     NextPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ImageBase,
00461                               ControlPc,
00462                               FunctionEntry,
00463                               &amp;ContextRecord,
00464                               &amp;InFunction,
00465                               &amp;EstablisherFrame,
00466                               NULL);
00467     ContextRecord.StIIP = NextPc + 8;
00468     ContextRecord.StIPSR &amp;= ~((ULONGLONG) 3 &lt;&lt; PSR_RI);
00469     ExceptionRecord.ExceptionAddress = (PVOID)ContextRecord.StIIP;
00470     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwRaiseException(&amp;ExceptionRecord, &amp;ContextRecord, TRUE);
00471 
00472     <span class="comment">//</span>
00473     <span class="comment">// There should never be a return from this system service unless</span>
00474     <span class="comment">// there is a problem with the argument list itself. Raise another</span>
00475     <span class="comment">// exception specifying the status value returned.</span>
00476     <span class="comment">//</span>
00477 
00478     <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a10">RtlRaiseStatus</a>(Status);
00479     <span class="keywordflow">return</span>;
00480 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="mips/exdsptch.c::RtlpRestoreContext" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID RtlpRestoreContext           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PCONTEXT&nbsp;</td>
          <td class="mdname" nowrap> <em>Context</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PEXCEPTION_RECORD ExceptionRecord&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="mips/exdsptch.c::RtlpVirtualUnwind" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG RtlpVirtualUnwind           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>ControlPc</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PRUNTIME_FUNCTION&nbsp;</td>
          <td class="mdname" nowrap> <em>FunctionEntry</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PCONTEXT&nbsp;</td>
          <td class="mdname" nowrap> <em>ContextRecord</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PBOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>InFunction</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>EstablisherFrame</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT PKNONVOLATILE_CONTEXT_POINTERS ContextPointers&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html#l01994">1994</a> of file <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html">mips/exdsptch.c</a>.
<p>
References <a class="el" href="../../d1/d6/ppc_2vunwind_8c-source.html#l00467">RtlVirtualUnwind()</a>.
<p>
<pre class="fragment"><div>02005                    :
02006 
02007     This function virtually unwinds <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specfified function by executing its
02008     prologue code backwards.
02009 
02010     If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> function <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a leaf function, then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address where <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> left
02011     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> previous frame <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> obtained from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> context record. If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> function
02012     <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a nested function, but not an exception or interrupt frame, then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
02013     prologue code <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> executed backwards and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address where <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> left
02014     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> previous frame <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> obtained from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> updated context record.
02015 
02016     Otherwise, an exception or interrupt entry to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> system <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> being unwound
02017     and a specially coded prologue restores <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keywordflow">return</span> address twice. Once
02018     from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> fault instruction address and once from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> saved <span class="keywordflow">return</span> address
02019     <span class="keyword">register</span>. The first restore <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned as <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> function value and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
02020     second restore <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> place in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> updated context record.
02021 
02022     If a context pointers record <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> specified, then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address where each
02023     nonvolatile registers <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> restored from <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> recorded in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> appropriate
02024     element of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> context pointers record.
02025 
02026     N.B. This function copies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified context record and <a class="code" href="../../d3/d0/imm32_8def.html#a1">only</a> computes
02027          <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> establisher frame and whether <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> actually in a function.
02028 
02029 Arguments:
02030 
02031     ControlPc - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address where <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> left <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified
02032         function.
02033 
02034     FunctionEntry - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> function table entry <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
02035         specified function.
02036 
02037     ContextRecord - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address of a context record.
02038 
02039     InFunction - Supplies a pointer to a variable that receives whether <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
02040         <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> PC <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> within <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> current function.
02041 
02042     EstablisherFrame - Supplies a pointer to a variable that receives <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
02043         <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> establisher frame pointer value.
02044 
02045     ContextPointers - Supplies an optional pointer to a context pointers
02046         record.
02047 
02048 Return Value:
02049 
02050     The address where <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> left <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> previous frame <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned as <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
02051     function value.
02052 
02053 --*/
02054 
02055 {
02056 
02057     CONTEXT LocalContext;
02058 
02059     <span class="comment">//</span>
02060     <span class="comment">// Copy the context record so updates will not be reflected in the</span>
02061     <span class="comment">// original copy and then virtually unwind to the caller of the</span>
02062     <span class="comment">// specified control point.</span>
02063     <span class="comment">//</span>
02064 
02065     RtlMoveMemory((PVOID)&amp;LocalContext, ContextRecord, <span class="keyword">sizeof</span>(CONTEXT));
02066     <span class="keywordflow">return</span> <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc | 1,
02067                             FunctionEntry,
02068                             &amp;LocalContext,
02069                             InFunction,
02070                             EstablisherFrame,
02071                             ContextPointers);
02072 }
}
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="mips/exdsptch.c::RtlpVirtualUnwind32" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG RtlpVirtualUnwind32           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>ControlPc</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PRUNTIME_FUNCTION&nbsp;</td>
          <td class="mdname" nowrap> <em>FunctionEntry</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT PCONTEXT&nbsp;</td>
          <td class="mdname" nowrap> <em>ContextRecord</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PBOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>InFunction</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>EstablisherFrame</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT PKNONVOLATILE_CONTEXT_POINTERS ContextPointers&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html#l01572">1572</a> of file <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html">mips/exdsptch.c</a>.
<p>
References <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00033">Offset</a>, <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html#l00048">RA</a>, <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html#l00049">SP</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, and <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html#l00050">ZERO</a>.
<p>
Referenced by <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html#l01074">RtlVirtualUnwind()</a>.
<p>
<pre class="fragment"><div>01583                    :
01584 
01585     This function virtually unwinds <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specfified function by executing its
01586     prologue code backwards.
01587 
01588     If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> function <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a leaf function, then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address where <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> left
01589     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> previous frame <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> obtained from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> context record. If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> function
01590     <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a nested function, but not an exception or interrupt frame, then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01591     prologue code <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> executed backwards and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address where <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> left
01592     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> previous frame <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> obtained from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> updated context record.
01593 
01594     Otherwise, an exception or interrupt entry to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> system <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> being unwound
01595     and a specially coded prologue restores <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keywordflow">return</span> address twice. Once
01596     from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> fault instruction address and once from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> saved <span class="keywordflow">return</span> address
01597     <span class="keyword">register</span>. The first restore <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned as <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> function value and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01598     second restore <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> place in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> updated context record.
01599 
01600     If a context pointers record <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> specified, then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address where each
01601     nonvolatile registers <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> restored from <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> recorded in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> appropriate
01602     element of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> context pointers record.
01603 
01604     N.B. This routine handles 32-bit context records.
01605 
01606 Arguments:
01607 
01608     ControlPc - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address where <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> left <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified
01609         function.
01610 
01611     FunctionEntry - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> function table entry <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01612         specified function.
01613 
01614     ContextRecord - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address of a context record.
01615 
01616     InFunction - Supplies a pointer to a variable that receives whether <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01617         <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> PC <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> within <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> current function.
01618 
01619     EstablisherFrame - Supplies a pointer to a variable that receives <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01620         <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> establisher frame pointer value.
01621 
01622     ContextPointers - Supplies an optional pointer to a context pointers
01623         record.
01624 
01625 Return Value:
01626 
01627     The address where <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> left <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> previous frame <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned as <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01628     function value.
01629 
01630 --*/
01631 
01632 {
01633 
01634     ULONG Address;
01635     ULONG DecrementOffset;
01636     ULONG DecrementRegister;
01637     PULONG FloatingRegister;
01638     ULONG Function;
01639     MIPS_INSTRUCTION Instruction;
01640     PULONG IntegerRegister;
01641     ULONG NextPc;
01642     LONG <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
01643     ULONG Opcode;
01644     ULONG Rd;
01645     BOOLEAN RestoredRa;
01646     BOOLEAN RestoredSp;
01647     ULONG Rs;
01648     ULONG Rt;
01649 
01650     <span class="comment">//</span>
01651     <span class="comment">// Set the base address of the integer and floating register arrays.</span>
01652     <span class="comment">//</span>
01653 
01654     FloatingRegister = &amp;ContextRecord-&gt;FltF0;
01655     IntegerRegister = &amp;ContextRecord-&gt;IntZero;
01656 
01657     <span class="comment">//</span>
01658     <span class="comment">// If the instruction at the point where control left the specified</span>
01659     <span class="comment">// function is a return, then any saved registers have been restored</span>
01660     <span class="comment">// with the possible exception of the stack pointer and the control</span>
01661     <span class="comment">// PC is not considered to be in the function (i.e., an epilogue).</span>
01662     <span class="comment">//</span>
01663 
01664     <span class="keywordflow">if</span> (*((PULONG)ControlPc) == JUMP_RA) {
01665         *InFunction = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01666         Instruction.Long = *((PULONG)ControlPc + 1);
01667         Opcode = Instruction.i_format.Opcode;
01668         <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> = Instruction.i_format.Simmediate;
01669         Rd = Instruction.r_format.Rd;
01670         Rs = Instruction.i_format.Rs;
01671         Rt = Instruction.i_format.Rt;
01672         Function = Instruction.r_format.Function;
01673 
01674         <span class="comment">//</span>
01675         <span class="comment">// If the opcode is an add immediate unsigned op and both the source</span>
01676         <span class="comment">// and destination registers are SP, then add the signed offset value</span>
01677         <span class="comment">// to SP. Otherwise, if the opcode is a special op, the operation is</span>
01678         <span class="comment">// an add unsigned, and the source and destination registers are both</span>
01679         <span class="comment">// SP, then add the register specified by Rd to SP.</span>
01680         <span class="comment">//</span>
01681 
01682         <span class="keywordflow">if</span> ((Opcode == ADDIU_OP) &amp;&amp; (Rt == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>) &amp;&amp; (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>)) {
01683             IntegerRegister[<a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>] += <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
01684 
01685         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Opcode == SPEC_OP) &amp;&amp; (Function == ADDU_OP) &amp;&amp;
01686                    (Rd == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>) &amp;&amp; (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>)) {
01687             IntegerRegister[<a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>] += IntegerRegister[Rt];
01688         }
01689 
01690         *EstablisherFrame = ContextRecord-&gt;IntSp;
01691         <span class="keywordflow">return</span> ContextRecord-&gt;IntRa;
01692     }
01693 
01694     <span class="comment">//</span>
01695     <span class="comment">// If the address where control left the specified function is outside</span>
01696     <span class="comment">// the limits of the prologue, then the control PC is considered to be</span>
01697     <span class="comment">// within the function and the control address is set to the end of</span>
01698     <span class="comment">// the prologue. Otherwise, the control PC is not considered to be</span>
01699     <span class="comment">// within the function (i.e., it is within the prologue).</span>
01700     <span class="comment">//</span>
01701 
01702     <span class="keywordflow">if</span> ((ControlPc &lt; FunctionEntry-&gt;BeginAddress) ||
01703         (ControlPc &gt;= FunctionEntry-&gt;PrologEndAddress)) {
01704         *InFunction = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01705         ControlPc = FunctionEntry-&gt;PrologEndAddress;
01706 
01707     } <span class="keywordflow">else</span> {
01708         *InFunction = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01709     }
01710 
01711     <span class="comment">//</span>
01712     <span class="comment">// Scan backward through the prologue and reload callee registers that</span>
01713     <span class="comment">// were stored.</span>
01714     <span class="comment">//</span>
01715 
01716     DecrementRegister = 0;
01717     *EstablisherFrame = ContextRecord-&gt;IntSp;
01718     NextPc = ContextRecord-&gt;IntRa - 4;
01719     RestoredRa = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01720     RestoredSp = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01721     <span class="keywordflow">while</span> (ControlPc &gt; FunctionEntry-&gt;BeginAddress) {
01722 
01723         <span class="comment">//</span>
01724         <span class="comment">// Get instruction value, decode fields, case of opcode value, and</span>
01725         <span class="comment">// reverse store operations.</span>
01726         <span class="comment">//</span>
01727 
01728         ControlPc -= 4;
01729         Instruction.Long = *((PULONG)ControlPc);
01730         Opcode = Instruction.i_format.Opcode;
01731         <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> = Instruction.i_format.Simmediate;
01732         Rd = Instruction.r_format.Rd;
01733         Rs = Instruction.i_format.Rs;
01734         Rt = Instruction.i_format.Rt;
01735         Address = <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> + IntegerRegister[Rs];
01736         <span class="keywordflow">if</span> (Opcode == SW_OP) {
01737 
01738             <span class="comment">//</span>
01739             <span class="comment">// Store word.</span>
01740             <span class="comment">//</span>
01741             <span class="comment">// If the base register is SP and the source register is an</span>
01742             <span class="comment">// integer register, then reload the register value.</span>
01743             <span class="comment">//</span>
01744 
01745             <span class="keywordflow">if</span> (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>) {
01746                 IntegerRegister[Rt] = *((PULONG)Address);
01747 
01748                 <span class="comment">//</span>
01749                 <span class="comment">// If the destination register is RA and this is the first</span>
01750                 <span class="comment">// time that RA is being restored, then set the address of</span>
01751                 <span class="comment">// where control left the previous frame. Otherwise, this</span>
01752                 <span class="comment">// is an interrupt or exception and the return PC should be</span>
01753                 <span class="comment">// biased by 4. Otherwise, if the destination register is</span>
01754                 <span class="comment">// SP and this is the first time that SP is being restored,</span>
01755                 <span class="comment">// then set the establisher frame pointer.</span>
01756                 <span class="comment">//</span>
01757 
01758                 <span class="keywordflow">if</span> (Rt == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a1">RA</a>) {
01759                     <span class="keywordflow">if</span> (RestoredRa == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01760                         NextPc = ContextRecord-&gt;IntRa - 4;
01761                         RestoredRa = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01762 
01763                     } <span class="keywordflow">else</span> {
01764                         NextPc += 4;
01765                     }
01766 
01767                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Rt == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>) {
01768                     <span class="keywordflow">if</span> (RestoredSp == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01769                         *EstablisherFrame = ContextRecord-&gt;IntSp;
01770                         RestoredSp = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01771                     }
01772                 }
01773 
01774                 <span class="comment">//</span>
01775                 <span class="comment">// If a context pointer record is specified, then record</span>
01776                 <span class="comment">// the address where the destination register contents</span>
01777                 <span class="comment">// are stored.</span>
01778                 <span class="comment">//</span>
01779 
01780                 <span class="keywordflow">if</span> (ARGUMENT_PRESENT(ContextPointers)) {
01781                     ContextPointers-&gt;XIntegerContext[Rt] = (PULONGLONG)Address;
01782                 }
01783             }
01784 
01785         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Opcode == SWC1_OP) {
01786 
01787             <span class="comment">//</span>
01788             <span class="comment">// Store word coprocessor 1.</span>
01789             <span class="comment">//</span>
01790             <span class="comment">// If the base register is SP and the source register is a</span>
01791             <span class="comment">// floating register, then reload the register value.</span>
01792             <span class="comment">//</span>
01793 
01794             <span class="keywordflow">if</span> (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>) {
01795                 FloatingRegister[Rt] = *((PULONG)Address);
01796 
01797                 <span class="comment">//</span>
01798                 <span class="comment">// If a context pointer record is specified, then record</span>
01799                 <span class="comment">// the address where the destination register contents</span>
01800                 <span class="comment">// are stored.</span>
01801                 <span class="comment">//</span>
01802 
01803                 <span class="keywordflow">if</span> (ARGUMENT_PRESENT(ContextPointers)) {
01804                     ContextPointers-&gt;FloatingContext[Rt] = (PULONG)Address;
01805                 }
01806             }
01807 
01808         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Opcode == SDC1_OP) {
01809 
01810             <span class="comment">//</span>
01811             <span class="comment">// Store double coprocessor 1.</span>
01812             <span class="comment">//</span>
01813             <span class="comment">// If the base register is SP and the source register is a</span>
01814             <span class="comment">// floating register, then reload the register and the next</span>
01815             <span class="comment">// register values.</span>
01816             <span class="comment">//</span>
01817 
01818             <span class="keywordflow">if</span> (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>) {
01819                 FloatingRegister[Rt] = *((PULONG)Address);
01820                 FloatingRegister[Rt + 1] = *((PULONG)(Address + 4));
01821 
01822                 <span class="comment">//</span>
01823                 <span class="comment">// If a context pointer record is specified, then record</span>
01824                 <span class="comment">// the address where the destination registers contents</span>
01825                 <span class="comment">// are stored.</span>
01826                 <span class="comment">//</span>
01827 
01828                 <span class="keywordflow">if</span> (ARGUMENT_PRESENT(ContextPointers)) {
01829                     ContextPointers-&gt;FloatingContext[Rt] = (PULONG)Address;
01830                     ContextPointers-&gt;FloatingContext[Rt + 1] = (PULONG)(Address + 4);
01831                 }
01832             }
01833 
01834         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Opcode == ADDIU_OP) {
01835 
01836             <span class="comment">//</span>
01837             <span class="comment">// Add immediate unsigned.</span>
01838             <span class="comment">//</span>
01839             <span class="comment">// If both the source and destination registers are SP, then</span>
01840             <span class="comment">// a standard stack allocation was performed and the signed</span>
01841             <span class="comment">// displacement value should be subtracted from SP. Otherwise,</span>
01842             <span class="comment">// if the destination register is the decrement register and</span>
01843             <span class="comment">// the source register is zero, then add the decrement value</span>
01844             <span class="comment">// to SP.</span>
01845             <span class="comment">//</span>
01846 
01847             <span class="keywordflow">if</span> ((Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>) &amp;&amp; (Rt == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>)) {
01848                 IntegerRegister[<a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>] -= <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
01849                 <span class="keywordflow">if</span> (RestoredSp == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01850                     *EstablisherFrame = ContextRecord-&gt;IntSp;
01851                     RestoredSp = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01852                 }
01853 
01854             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Rt == DecrementRegister) &amp;&amp; (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a3">ZERO</a>)) {
01855                 IntegerRegister[<a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>] += <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
01856                 <span class="keywordflow">if</span> (RestoredSp == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01857                     *EstablisherFrame = ContextRecord-&gt;IntSp;
01858                     RestoredSp = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01859                 }
01860             }
01861 
01862         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Opcode == ORI_OP) {
01863 
01864             <span class="comment">//</span>
01865             <span class="comment">// Or immediate.</span>
01866             <span class="comment">//</span>
01867             <span class="comment">// If both the destination and source registers are the decrement</span>
01868             <span class="comment">// register, then save the decrement value. Otherwise, if the</span>
01869             <span class="comment">// destination register is the decrement register and the source</span>
01870             <span class="comment">// register is zero, then add the decrement value to SP.</span>
01871             <span class="comment">//</span>
01872 
01873             <span class="keywordflow">if</span> ((Rs == DecrementRegister) &amp;&amp; (Rt == DecrementRegister)) {
01874                 DecrementOffset = (<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> &amp; 0xffff);
01875 
01876             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Rt == DecrementRegister) &amp;&amp; (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a3">ZERO</a>)) {
01877                 IntegerRegister[<a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>] += (<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> &amp; 0xffff);
01878                 <span class="keywordflow">if</span> (RestoredSp == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01879                     *EstablisherFrame = ContextRecord-&gt;IntSp;
01880                     RestoredSp = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01881                 }
01882             }
01883 
01884         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Opcode == SPEC_OP) {
01885 
01886             <span class="comment">//</span>
01887             <span class="comment">// Special operation.</span>
01888             <span class="comment">//</span>
01889             <span class="comment">// The real opcode is in the function field of special opcode</span>
01890             <span class="comment">// instructions.</span>
01891             <span class="comment">//</span>
01892 
01893             Function = Instruction.r_format.Function;
01894             <span class="keywordflow">if</span> ((Function == ADDU_OP) || (Function == OR_OP)) {
01895 
01896                 <span class="comment">//</span>
01897                 <span class="comment">// Add unsigned or an or operation.</span>
01898                 <span class="comment">//</span>
01899                 <span class="comment">// If one of the source registers is ZERO, then the</span>
01900                 <span class="comment">// operation is a move operation and the destination</span>
01901                 <span class="comment">// register should be moved to the appropriate source</span>
01902                 <span class="comment">// register.</span>
01903                 <span class="comment">//</span>
01904 
01905                 <span class="keywordflow">if</span> (Rt == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a3">ZERO</a>) {
01906                     IntegerRegister[Rs] = IntegerRegister[Rd];
01907 
01908                     <span class="comment">//</span>
01909                     <span class="comment">// If the destination register is RA and this is the</span>
01910                     <span class="comment">// first time that RA is being restored, then set the</span>
01911                     <span class="comment">// address of where control left the previous frame.</span>
01912                     <span class="comment">// Otherwise, this an interrupt or exception and the</span>
01913                     <span class="comment">// return PC should be biased by 4.</span>
01914                     <span class="comment">//</span>
01915 
01916                     <span class="keywordflow">if</span> (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a1">RA</a>) {
01917                         <span class="keywordflow">if</span> (RestoredRa == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01918                             NextPc = ContextRecord-&gt;IntRa - 4;
01919                             RestoredRa = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01920 
01921                         } <span class="keywordflow">else</span> {
01922                             NextPc += 4;
01923                         }
01924                     }
01925 
01926                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a3">ZERO</a>) {
01927                     IntegerRegister[Rt] = IntegerRegister[Rd];
01928 
01929                     <span class="comment">//</span>
01930                     <span class="comment">// If the destination register is RA and this is the</span>
01931                     <span class="comment">// first time that RA is being restored, then set the</span>
01932                     <span class="comment">// address of where control left the previous frame.</span>
01933                     <span class="comment">// Otherwise, this an interrupt or exception and the</span>
01934                     <span class="comment">// return PC should be biased by 4.</span>
01935                     <span class="comment">//</span>
01936 
01937                     <span class="keywordflow">if</span> (Rt == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a1">RA</a>) {
01938                         <span class="keywordflow">if</span> (RestoredRa == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01939                             NextPc = ContextRecord-&gt;IntRa - 4;
01940                             RestoredRa = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01941 
01942                         } <span class="keywordflow">else</span> {
01943                             NextPc += 4;
01944                         }
01945                     }
01946                 }
01947 
01948             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Function == SUBU_OP) {
01949 
01950                 <span class="comment">//</span>
01951                 <span class="comment">// Subtract unsigned.</span>
01952                 <span class="comment">//</span>
01953                 <span class="comment">// If the destination register is SP and the source register</span>
01954                 <span class="comment">// is SP, then a stack allocation greater than 32kb has been</span>
01955                 <span class="comment">// performed and source register number of the decrement must</span>
01956                 <span class="comment">// be saved for later use.</span>
01957                 <span class="comment">//</span>
01958 
01959                 <span class="keywordflow">if</span> ((Rd == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>) &amp;&amp; (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>)) {
01960                     DecrementRegister = Rt;
01961                 }
01962             }
01963 
01964         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Opcode == LUI_OP) {
01965 
01966             <span class="comment">//</span>
01967             <span class="comment">// Load upper immediate.</span>
01968             <span class="comment">//</span>
01969             <span class="comment">// If the destination register is the decrement register, then</span>
01970             <span class="comment">// compute the decrement value, add it from SP, and clear the</span>
01971             <span class="comment">// decrement register number.</span>
01972             <span class="comment">//</span>
01973 
01974             <span class="keywordflow">if</span> (Rt == DecrementRegister) {
01975                 DecrementRegister = 0;
01976                 IntegerRegister[<a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>] += (DecrementOffset + (<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> &lt;&lt; 16));
01977                 <span class="keywordflow">if</span> (RestoredSp == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01978                     *EstablisherFrame = ContextRecord-&gt;IntSp;
01979                     RestoredSp = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01980                 }
01981             }
01982         }
01983     }
01984 
01985     <span class="comment">//</span>
01986     <span class="comment">// Make sure that integer register zero is really zero.</span>
01987     <span class="comment">//</span>
01988 
01989     ContextRecord-&gt;IntZero = 0;
01990     <span class="keywordflow">return</span> NextPc;
01991 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="mips/exdsptch.c::RtlRaiseException" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID RtlRaiseException           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PEXCEPTION_RECORD&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>ExceptionRecord</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html#l00475">475</a> of file <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html">mips/exdsptch.c</a>.
<p>
References <a class="el" href="../../d8/d8/ia64_2exdsptch_8c-source.html#l00311">RtlpRaiseException()</a>.
<p>
<pre class="fragment"><div>00481                    :
00482 
00483     This function raises a software exception by building a context record
00484     and calling <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> raise exception system service.
00485 
00486     N.B. This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a shell routine that simply calls another routine
00487          to <span class="keywordflow">do</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> real work. The <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a10">reason</a> <span class="keyword">this</span> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> done <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> to avoid a problem
00488          in <span class="keywordflow">try</span>/finally scopes where <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> last statement in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> scope <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a
00489          call to raise an exception.
00490 
00491 Arguments:
00492 
00493     ExceptionRecord - Supplies a pointer to an exception record.
00494 
00495 Return Value:
00496 
00497     None.
00498 
00499 --*/
00500 
00501 {
00502 
00503     <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a4">RtlpRaiseException</a>(ExceptionRecord);
00504     <span class="keywordflow">return</span>;
00505 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="mips/exdsptch.c::RtlRaiseStatus" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID RtlRaiseStatus           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN NTSTATUS&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>Status</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html#l00570">570</a> of file <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html">mips/exdsptch.c</a>.
<p>
References <a class="el" href="../../d8/d8/ia64_2exdsptch_8c-source.html#l00409">RtlpRaiseStatus()</a>, and <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>.
<p>
<pre class="fragment"><div>00576                    :
00577 
00578     This function raises an exception with <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified status value. The
00579     exception <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> marked as noncontinuable with no parameters.
00580 
00581     N.B. This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a shell routine that simply calls another routine
00582          to <span class="keywordflow">do</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> real work. The <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a10">reason</a> <span class="keyword">this</span> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> done <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> to avoid a problem
00583          in <span class="keywordflow">try</span>/finally scopes where <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> last statement in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> scope <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a
00584          call to raise an exception.
00585 
00586 Arguments:
00587 
00588     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> status value to be used as <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> exception code
00589         <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> exception that <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> to be raised.
00590 
00591 Return Value:
00592 
00593     None.
00594 
00595 --*/
00596 
00597 {
00598 
00599     <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a5">RtlpRaiseStatus</a>(Status);
00600     <span class="keywordflow">return</span>;
00601 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a15" doxytag="mips/exdsptch.c::RtlUnwind" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID RtlUnwind           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID TargetFrame&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID TargetIp&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PEXCEPTION_RECORD ExceptionRecord&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>ReturnValue</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html#l00676">676</a> of file <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html">mips/exdsptch.c</a>.
<p>
References <a class="el" href="../../d0/d9/ppc_2exdsptch_8c-source.html#l00737">RtlUnwind2()</a>.
<p>
<pre class="fragment"><div>00685                    :
00686 
00687     This function initiates an unwind of <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a69">procedure</a> call frames. The machine
00688     state at <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> time of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> call to unwind <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> captured in a context record
00689     and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> unwinding flag <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> set in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> exception flags of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> exception
00690     record. If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> TargetFrame parameter <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not specified, then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d9/d1/fedefs_8h.html#a16">exit</a> unwind
00691     flag <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> also set in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> exception flags of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> exception record. <a class="code" href="../../d2/d1/bench_8h.html#a5">A</a> backward
00692     scan through <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a69">procedure</a> call frames <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> then performed to find <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> target
00693     of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> unwind operation.
00694 
00695     As each frame <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> encounter, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> PC where <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> left <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> corresponding
00696     function <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> determined and used to lookup exception handler information
00697     in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> runtime function table built by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> linker. If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> respective
00698     routine has an exception handler, then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> handler <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> called.
00699 
00700     N.B. This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> provided <span class="keywordflow">for</span> backward compatibility with release 1.
00701 
00702 Arguments:
00703 
00704     TargetFrame - Supplies an optional pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> call frame that <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00705         target of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> unwind. If <span class="keyword">this</span> parameter <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not specified, then an <a class="code" href="../../d9/d1/fedefs_8h.html#a16">exit</a>
00706         unwind <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> performed.
00707 
00708     TargetIp - Supplies an optional instruction address that specifies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00709         continuation address of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> unwind. This address <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> ignored <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00710         target frame parameter <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not specified.
00711 
00712     ExceptionRecord - Supplies an optional pointer to an exception record.
00713 
00714     ReturnValue - Supplies a value that <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> to be placed in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> integer
00715         function <span class="keywordflow">return</span> <span class="keyword">register</span> just before continuing execution.
00716 
00717 Return Value:
00718 
00719     None.
00720 
00721 --*/
00722 
00723 {
00724 
00725     CONTEXT ContextRecord;
00726 
00727     <span class="comment">//</span>
00728     <span class="comment">// Call real unwind routine specifying a context record as an</span>
00729     <span class="comment">// extra argument.</span>
00730     <span class="comment">//</span>
00731 
00732     <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a12">RtlUnwind2</a>(TargetFrame,
00733                TargetIp,
00734                ExceptionRecord,
00735                ReturnValue,
00736                &amp;ContextRecord);
00737 
00738     <span class="keywordflow">return</span>;
00739 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a16" doxytag="mips/exdsptch.c::RtlUnwind2" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID RtlUnwind2           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID TargetFrame&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID TargetIp&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PEXCEPTION_RECORD ExceptionRecord&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>ReturnValue</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PCONTEXT&nbsp;</td>
          <td class="mdname" nowrap> <em>ContextRecord</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html#l00742">742</a> of file <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html">mips/exdsptch.c</a>.
<p>
References <a class="el" href="../../d7/d6/halmips_8h-source.html#l00053">EXCEPTION_COLLIDED_UNWIND</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00049">EXCEPTION_EXIT_UNWIND</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00052">EXCEPTION_TARGET_UNWIND</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00048">EXCEPTION_UNWINDING</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00062">ExceptionCollidedUnwind</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00060">ExceptionContinueSearch</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d6/d8/alpha_2exdsptch_8c-source.html#l00065">RAISE_EXCEPTION</a>, <a class="el" href="../../d0/d9/ppc_2exdsptch_8c-source.html#l00348">RtlLookupFunctionEntry()</a>, <a class="el" href="../../d6/d9/ntrtlppc_8h.html#a1">RtlpExecuteHandlerForUnwind()</a>, <a class="el" href="../../d9/d9/rtl_2ia64_2miscc_8c-source.html#l00126">RtlpGetStackLimits()</a>, <a class="el" href="../../d9/d9/ppc_2exdsptch_8c.html#a3">RtlpRestoreContext()</a>, <a class="el" href="../../d0/d9/ppc_2exdsptch_8c-source.html#l01102">RtlpVirtualUnwind()</a>, <a class="el" href="../../d0/d9/ppc_2exdsptch_8c-source.html#l00563">RtlRaiseStatus()</a>, and <a class="el" href="../../d1/d6/ppc_2vunwind_8c-source.html#l00467">RtlVirtualUnwind()</a>.
<p>
<pre class="fragment"><div>00752                    :
00753 
00754     This function initiates an unwind of <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a69">procedure</a> call frames. The machine
00755     state at <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> time of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> call to unwind <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> captured in a context record
00756     and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> unwinding flag <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> set in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> exception flags of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> exception
00757     record. If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> TargetFrame parameter <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not specified, then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d9/d1/fedefs_8h.html#a16">exit</a> unwind
00758     flag <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> also set in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> exception flags of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> exception record. <a class="code" href="../../d2/d1/bench_8h.html#a5">A</a> backward
00759     scan through <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a69">procedure</a> call frames <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> then performed to find <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> target
00760     of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> unwind operation.
00761 
00762     As each frame <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> encounter, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> PC where <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> left <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> corresponding
00763     function <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> determined and used to lookup exception handler information
00764     in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> runtime function table built by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> linker. If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> respective
00765     routine has an exception handler, then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> handler <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> called.
00766 
00767 Arguments:
00768 
00769     TargetFrame - Supplies an optional pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> call frame that <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00770         target of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> unwind. If <span class="keyword">this</span> parameter <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not specified, then an <a class="code" href="../../d9/d1/fedefs_8h.html#a16">exit</a>
00771         unwind <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> performed.
00772 
00773     TargetIp - Supplies an optional instruction address that specifies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00774         continuation address of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> unwind. This address <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> ignored <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00775         target frame parameter <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> not specified.
00776 
00777     ExceptionRecord - Supplies an optional pointer to an exception record.
00778 
00779     ReturnValue - Supplies a value that <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> to be placed in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> integer
00780         function <span class="keywordflow">return</span> <span class="keyword">register</span> just before continuing execution.
00781 
00782     ContextRecord - Supplies a pointer to a context record that can be used
00783         to store context druing <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> unwind operation.
00784 
00785 Return Value:
00786 
00787     None.
00788 
00789 --*/
00790 
00791 {
00792 
00793     ULONG ControlPc;
00794     <a class="code" href="../../d0/d6/struct__DISPATCHER__CONTEXT.html">DISPATCHER_CONTEXT</a> DispatcherContext;
00795     EXCEPTION_DISPOSITION Disposition;
00796     ULONG EstablisherFrame;
00797     ULONG ExceptionFlags;
00798     EXCEPTION_RECORD ExceptionRecord1;
00799     PRUNTIME_FUNCTION FunctionEntry;
00800     BOOLEAN InFunction;
00801     ULONG HighLimit;
00802     ULONG LowLimit;
00803     ULONG NextPc;
00804 
00805     <span class="comment">//</span>
00806     <span class="comment">// Get current stack limits, capture the current context, virtually</span>
00807     <span class="comment">// unwind to the caller of this routine, get the initial PC value, and</span>
00808     <span class="comment">// set the unwind target address.</span>
00809     <span class="comment">//</span>
00810 
00811     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a30">RtlpGetStackLimits</a>(&amp;LowLimit, &amp;HighLimit);
00812     RtlCaptureContext(ContextRecord);
00813     ControlPc = (ULONG)(ContextRecord-&gt;XIntRa - 4);
00814     FunctionEntry = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>(ControlPc);
00815     NextPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc | 1,
00816                               FunctionEntry,
00817                               ContextRecord,
00818                               &amp;InFunction,
00819                               &amp;EstablisherFrame,
00820                               NULL);
00821 
00822     ControlPc = NextPc;
00823     ContextRecord-&gt;Fir = (ULONG)TargetIp;
00824 
00825     <span class="comment">//</span>
00826     <span class="comment">// If an exception record is not specified, then build a local exception</span>
00827     <span class="comment">// record for use in calling exception handlers during the unwind operation.</span>
00828     <span class="comment">//</span>
00829 
00830     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(ExceptionRecord) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00831         ExceptionRecord = &amp;ExceptionRecord1;
00832         ExceptionRecord1.ExceptionCode = STATUS_UNWIND;
00833         ExceptionRecord1.ExceptionRecord = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00834         ExceptionRecord1.ExceptionAddress = (PVOID)ControlPc;
00835         ExceptionRecord1.NumberParameters = 0;
00836     }
00837 
00838     <span class="comment">//</span>
00839     <span class="comment">// If the target frame of the unwind is specified, then a normal unwind</span>
00840     <span class="comment">// is being performed. Otherwise, an exit unwind is being performed.</span>
00841     <span class="comment">//</span>
00842 
00843     ExceptionFlags = <a class="code" href="../../d6/d7/halmips_8h.html#a26">EXCEPTION_UNWINDING</a>;
00844     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(TargetFrame) == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00845         ExceptionRecord-&gt;ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a27">EXCEPTION_EXIT_UNWIND</a>;
00846     }
00847 
00848     <span class="comment">//</span>
00849     <span class="comment">// Scan backward through the call frame hierarchy and call exception</span>
00850     <span class="comment">// handlers until the target frame of the unwind is reached.</span>
00851     <span class="comment">//</span>
00852 
00853     <span class="keywordflow">do</span> {
00854 
00855         <span class="comment">//</span>
00856         <span class="comment">// Lookup the function table entry using the point at which control</span>
00857         <span class="comment">// left the procedure.</span>
00858         <span class="comment">//</span>
00859 
00860         FunctionEntry = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a8">RtlLookupFunctionEntry</a>(ControlPc);
00861 
00862         <span class="comment">//</span>
00863         <span class="comment">// If there is a function table entry for the routine, then virtually</span>
00864         <span class="comment">// unwind to the caller of the routine to obtain the virtual frame</span>
00865         <span class="comment">// pointer of the establisher, but don't update the context record.</span>
00866         <span class="comment">//</span>
00867 
00868         <span class="keywordflow">if</span> (FunctionEntry != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00869             NextPc = <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a6">RtlpVirtualUnwind</a>(ControlPc,
00870                                        FunctionEntry,
00871                                        ContextRecord,
00872                                        &amp;InFunction,
00873                                        &amp;EstablisherFrame,
00874                                        NULL);
00875 
00876             <span class="comment">//</span>
00877             <span class="comment">// If the virtual frame pointer is not within the specified stack</span>
00878             <span class="comment">// limits, the virtual frame pointer is unaligned, or the target</span>
00879             <span class="comment">// frame is below the virtual frame and an exit unwind is not being</span>
00880             <span class="comment">// performed, then raise the exception STATUS_BAD_STACK. Otherwise,</span>
00881             <span class="comment">// check to determine if the current routine has an exception</span>
00882             <span class="comment">// handler.</span>
00883             <span class="comment">//</span>
00884 
00885             <span class="keywordflow">if</span> ((EstablisherFrame &lt; LowLimit) || (EstablisherFrame &gt; HighLimit) ||
00886                ((ARGUMENT_PRESENT(TargetFrame) != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
00887                ((ULONG)TargetFrame &lt; EstablisherFrame)) ||
00888                ((EstablisherFrame &amp; 0x7) != 0)) {
00889                 <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a0">RAISE_EXCEPTION</a>(STATUS_BAD_STACK, ExceptionRecord);
00890 
00891             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((FunctionEntry-&gt;ExceptionHandler != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp; InFunction) {
00892 
00893                 <span class="comment">//</span>
00894                 <span class="comment">// The frame has an exception handler.</span>
00895                 <span class="comment">//</span>
00896                 <span class="comment">// The control PC, establisher frame pointer, the address</span>
00897                 <span class="comment">// of the function table entry, and the address of the</span>
00898                 <span class="comment">// context record are all stored in the dispatcher context.</span>
00899                 <span class="comment">// This information is used by the unwind linkage routine</span>
00900                 <span class="comment">// and can be used by the exception handler itself.</span>
00901                 <span class="comment">//</span>
00902                 <span class="comment">// A linkage routine written in assembler is used to actually</span>
00903                 <span class="comment">// call the actual exception handler. This is required by the</span>
00904                 <span class="comment">// exception handler that is associated with the linkage</span>
00905                 <span class="comment">// routine so it can have access to two sets of dispatcher</span>
00906                 <span class="comment">// context when it is called.</span>
00907                 <span class="comment">//</span>
00908 
00909                 DispatcherContext.ControlPc = ControlPc;
00910                 DispatcherContext.FunctionEntry = FunctionEntry;
00911                 DispatcherContext.EstablisherFrame = EstablisherFrame;
00912                 DispatcherContext.ContextRecord = ContextRecord;
00913 
00914                 <span class="comment">//</span>
00915                 <span class="comment">// Call the exception handler.</span>
00916                 <span class="comment">//</span>
00917 
00918                 <span class="keywordflow">do</span> {
00919 
00920                     <span class="comment">//</span>
00921                     <span class="comment">// If the establisher frame is the target of the unwind</span>
00922                     <span class="comment">// operation, then set the target unwind flag.</span>
00923                     <span class="comment">//</span>
00924 
00925                     <span class="keywordflow">if</span> ((ULONG)TargetFrame == EstablisherFrame) {
00926                         ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a30">EXCEPTION_TARGET_UNWIND</a>;
00927                     }
00928 
00929                     ExceptionRecord-&gt;ExceptionFlags = ExceptionFlags;
00930 
00931                     <span class="comment">//</span>
00932                     <span class="comment">// Set the specified return value in case the exception</span>
00933                     <span class="comment">// handler directly continues execution.</span>
00934                     <span class="comment">//</span>
00935 
00936                     ContextRecord-&gt;XIntV0 = (LONG)ReturnValue;
00937                     Disposition =
00938                         <a class="code" href="../../d6/d9/ntrtlppc_8h.html#a1">RtlpExecuteHandlerForUnwind</a>(ExceptionRecord,
00939                                                     EstablisherFrame,
00940                                                     ContextRecord,
00941                                                     &amp;DispatcherContext,
00942                                                     FunctionEntry-&gt;ExceptionHandler);
00943 
00944                     <span class="comment">//</span>
00945                     <span class="comment">// Clear target unwind and collided unwind flags.</span>
00946                     <span class="comment">//</span>
00947 
00948                     ExceptionFlags &amp;= ~(<a class="code" href="../../d6/d7/halmips_8h.html#a31">EXCEPTION_COLLIDED_UNWIND</a> |
00949                                                         <a class="code" href="../../d6/d7/halmips_8h.html#a30">EXCEPTION_TARGET_UNWIND</a>);
00950 
00951                     <span class="comment">//</span>
00952                     <span class="comment">// Case on the handler disposition.</span>
00953                     <span class="comment">//</span>
00954 
00955                     <span class="keywordflow">switch</span> (Disposition) {
00956 
00957                         <span class="comment">//</span>
00958                         <span class="comment">// The disposition is to continue the search.</span>
00959                         <span class="comment">//</span>
00960                         <span class="comment">// If the target frame has not been reached, then</span>
00961                         <span class="comment">// virtually unwind to the caller of the current</span>
00962                         <span class="comment">// routine, update the context record, and continue</span>
00963                         <span class="comment">// the search for a handler.</span>
00964                         <span class="comment">//</span>
00965 
00966                     <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a37">ExceptionContinueSearch</a> :
00967                         <span class="keywordflow">if</span> (EstablisherFrame != (ULONG)TargetFrame) {
00968                             NextPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc | 1,
00969                                                       FunctionEntry,
00970                                                       ContextRecord,
00971                                                       &amp;InFunction,
00972                                                       &amp;EstablisherFrame,
00973                                                       NULL);
00974                         }
00975 
00976                         <span class="keywordflow">break</span>;
00977 
00978                         <span class="comment">//</span>
00979                         <span class="comment">// The disposition is collided unwind.</span>
00980                         <span class="comment">//</span>
00981                         <span class="comment">// Set the target of the current unwind to the context</span>
00982                         <span class="comment">// record of the previous unwind, and reexecute the</span>
00983                         <span class="comment">// exception handler from the collided frame with the</span>
00984                         <span class="comment">// collided unwind flag set in the exception record.</span>
00985                         <span class="comment">//</span>
00986 
00987                     <span class="keywordflow">case</span> <a class="code" href="../../d6/d7/halmips_8h.html#a39">ExceptionCollidedUnwind</a> :
00988                         ControlPc = DispatcherContext.ControlPc;
00989                         FunctionEntry = DispatcherContext.FunctionEntry;
00990                         ContextRecord = DispatcherContext.ContextRecord;
00991                         ContextRecord-&gt;Fir = (ULONG)TargetIp;
00992                         ExceptionFlags |= <a class="code" href="../../d6/d7/halmips_8h.html#a31">EXCEPTION_COLLIDED_UNWIND</a>;
00993                         EstablisherFrame = DispatcherContext.EstablisherFrame;
00994                         <span class="keywordflow">break</span>;
00995 
00996                         <span class="comment">//</span>
00997                         <span class="comment">// All other disposition values are invalid.</span>
00998                         <span class="comment">//</span>
00999                         <span class="comment">// Raise invalid disposition exception.</span>
01000                         <span class="comment">//</span>
01001 
01002                     <span class="keywordflow">default</span> :
01003                         <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a0">RAISE_EXCEPTION</a>(STATUS_INVALID_DISPOSITION, ExceptionRecord);
01004                     }
01005 
01006                 } <span class="keywordflow">while</span> ((ExceptionFlags &amp; <a class="code" href="../../d6/d7/halmips_8h.html#a31">EXCEPTION_COLLIDED_UNWIND</a>) != 0);
01007 
01008             } <span class="keywordflow">else</span> {
01009 
01010                 <span class="comment">//</span>
01011                 <span class="comment">// If the target frame has not been reached, then virtually unwind to the</span>
01012                 <span class="comment">// caller of the current routine and update the context record.</span>
01013                 <span class="comment">//</span>
01014 
01015                 <span class="keywordflow">if</span> (EstablisherFrame != (ULONG)TargetFrame) {
01016                     NextPc = <a class="code" href="../../d0/d7/ppc_2vunwind_8c.html#a38">RtlVirtualUnwind</a>(ControlPc | 1,
01017                                               FunctionEntry,
01018                                               ContextRecord,
01019                                               &amp;InFunction,
01020                                               &amp;EstablisherFrame,
01021                                               NULL);
01022                 }
01023             }
01024 
01025         } <span class="keywordflow">else</span> {
01026 
01027             <span class="comment">//</span>
01028             <span class="comment">// Set point at which control left the previous routine.</span>
01029             <span class="comment">//</span>
01030 
01031             NextPc = (ULONG)(ContextRecord-&gt;XIntRa - 4);
01032 
01033             <span class="comment">//</span>
01034             <span class="comment">// If the next control PC is the same as the old control PC, then</span>
01035             <span class="comment">// the function table is not correctly formed.</span>
01036             <span class="comment">//</span>
01037 
01038             <span class="keywordflow">if</span> (NextPc == ControlPc) {
01039                 <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a10">RtlRaiseStatus</a>(STATUS_BAD_FUNCTION_TABLE);
01040             }
01041         }
01042 
01043         <span class="comment">//</span>
01044         <span class="comment">// Set point at which control left the previous routine.</span>
01045         <span class="comment">//</span>
01046         <span class="comment">// N.B. Make sure the address is in the delay slot of the jal</span>
01047         <span class="comment">//      to prevent the boundary condition of the return address</span>
01048         <span class="comment">//      being at the front of a try body.</span>
01049         <span class="comment">//</span>
01050 
01051         ControlPc = NextPc;
01052 
01053     } <span class="keywordflow">while</span> ((EstablisherFrame &lt; HighLimit) &amp;&amp;
01054             (EstablisherFrame != (ULONG)TargetFrame));
01055 
01056     <span class="comment">//</span>
01057     <span class="comment">// If the establisher stack pointer is equal to the target frame</span>
01058     <span class="comment">// pointer, then continue execution. Otherwise, an exit unwind was</span>
01059     <span class="comment">// performed or the target of the unwind did not exist and the</span>
01060     <span class="comment">// debugger and subsystem are given a second chance to handle the</span>
01061     <span class="comment">// unwind.</span>
01062     <span class="comment">//</span>
01063 
01064     <span class="keywordflow">if</span> (EstablisherFrame == (ULONG)TargetFrame) {
01065         ContextRecord-&gt;XIntV0 = (LONG)ReturnValue;
01066         <a class="code" href="../../d9/d9/ppc_2exdsptch_8c.html#a3">RtlpRestoreContext</a>(ContextRecord, ExceptionRecord);
01067 
01068     } <span class="keywordflow">else</span> {
01069         ZwRaiseException(ExceptionRecord, ContextRecord, FALSE);
01070     }
01071 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a17" doxytag="mips/exdsptch.c::RtlVirtualUnwind" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ULONG RtlVirtualUnwind           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>ControlPc</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PRUNTIME_FUNCTION&nbsp;</td>
          <td class="mdname" nowrap> <em>FunctionEntry</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT PCONTEXT&nbsp;</td>
          <td class="mdname" nowrap> <em>ContextRecord</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PBOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>InFunction</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>EstablisherFrame</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT PKNONVOLATILE_CONTEXT_POINTERS ContextPointers&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html#l01074">1074</a> of file <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html">mips/exdsptch.c</a>.
<p>
References <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d5/d8/heapdbg_8c-source.html#l00033">Offset</a>, <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html#l00048">RA</a>, <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html#l01572">RtlpVirtualUnwind32()</a>, <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html#l00049">SP</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, and <a class="el" href="../../d9/d8/mips_2exdsptch_8c-source.html#l00050">ZERO</a>.
<p>
<pre class="fragment"><div>01085                    :
01086 
01087     This function virtually unwinds <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specfified function by executing its
01088     prologue code backwards.
01089 
01090     If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> function <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a leaf function, then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address where <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> left
01091     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> previous frame <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> obtained from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> context record. If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> function
01092     <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a nested function, but not an exception or interrupt frame, then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01093     prologue code <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> executed backwards and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address where <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> left
01094     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> previous frame <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> obtained from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> updated context record.
01095 
01096     Otherwise, an exception or interrupt entry to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> system <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> being unwound
01097     and a specially coded prologue restores <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <span class="keywordflow">return</span> address twice. Once
01098     from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> fault instruction address and once from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> saved <span class="keywordflow">return</span> address
01099     <span class="keyword">register</span>. The first restore <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned as <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> function value and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01100     second restore <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> place in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> updated context record.
01101 
01102     If a context pointers record <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> specified, then <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address where each
01103     nonvolatile registers <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> restored from <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> recorded in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> appropriate
01104     element of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> context pointers record.
01105 
01106     N.B. This routine handles 64-bit context records.
01107 
01108 Arguments:
01109 
01110     ControlPc - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address where <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> left <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified
01111         function.
01112 
01113         N.B. The <a class="code" href="../../d2/d3/fetypes_8h.html#a457a418">low</a> order bit of <span class="keyword">this</span> argument <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> used to denote <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01114              context record <a class="code" href="../../d3/d5/i386_2trapc_8c.html#a9">type</a>. If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d3/fetypes_8h.html#a457a418">low</a> order bit <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> clear, then
01115              <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> context record contains 32-bit information. Otherwise,
01116              <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> contains 64-bit information.
01117 
01118     FunctionEntry - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> function table entry <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01119         specified function.
01120 
01121     ContextRecord - Supplies <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> address of a context record.
01122 
01123     InFunction - Supplies a pointer to a variable that receives whether <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01124         <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> PC <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> within <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> current function.
01125 
01126     EstablisherFrame - Supplies a pointer to a variable that receives <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01127         <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> establisher frame pointer value.
01128 
01129     ContextPointers - Supplies an optional pointer to a context pointers
01130         record.
01131 
01132 Return Value:
01133 
01134     The address where <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a58">control</a> left <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> previous frame <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> returned as <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
01135     function value.
01136 
01137 --*/
01138 
01139 {
01140 
01141     ULONG Address;
01142     ULONG DecrementOffset;
01143     ULONG DecrementRegister;
01144     PULONG FloatingRegister;
01145     ULONG Function;
01146     MIPS_INSTRUCTION Instruction;
01147     PULONGLONG IntegerRegister;
01148     ULONG NextPc;
01149     LONG <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
01150     ULONG Opcode;
01151     ULONG Rd;
01152     BOOLEAN RestoredRa;
01153     BOOLEAN RestoredSp;
01154     ULONG Rs;
01155     ULONG Rt;
01156 
01157     <span class="comment">//</span>
01158     <span class="comment">// If the low order bit of the control PC is clear, then the context</span>
01159     <span class="comment">// record format is 32-bit. Otherwise, the context record format is</span>
01160     <span class="comment">// 64-bits.</span>
01161     <span class="comment">//</span>
01162 
01163     <span class="keywordflow">if</span> ((ControlPc &amp; 1) == 0) {
01164         <span class="keywordflow">return</span> <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a10">RtlpVirtualUnwind32</a>(ControlPc,
01165                                    FunctionEntry,
01166                                    ContextRecord,
01167                                    InFunction,
01168                                    EstablisherFrame,
01169                                    ContextPointers);
01170 
01171     } <span class="keywordflow">else</span> {
01172 
01173         <span class="comment">//</span>
01174         <span class="comment">// Set the base address of the integer and floating register arrays.</span>
01175         <span class="comment">//</span>
01176 
01177         FloatingRegister = &amp;ContextRecord-&gt;FltF0;
01178         IntegerRegister = &amp;ContextRecord-&gt;XIntZero;
01179 
01180         <span class="comment">//</span>
01181         <span class="comment">// If the instruction at the point where control left the specified</span>
01182         <span class="comment">// function is a return, then any saved registers have been restored</span>
01183         <span class="comment">// with the possible exception of the stack pointer and the control</span>
01184         <span class="comment">// PC is not considered to be in the function (i.e., an epilogue).</span>
01185         <span class="comment">//</span>
01186 
01187         ControlPc &amp;= ~1;
01188         <span class="keywordflow">if</span> (*((PULONG)ControlPc) == JUMP_RA) {
01189             *InFunction = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01190             Instruction.Long = *((PULONG)ControlPc + 1);
01191             Opcode = Instruction.i_format.Opcode;
01192             <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> = Instruction.i_format.Simmediate;
01193             Rd = Instruction.r_format.Rd;
01194             Rs = Instruction.i_format.Rs;
01195             Rt = Instruction.i_format.Rt;
01196             Function = Instruction.r_format.Function;
01197 
01198             <span class="comment">//</span>
01199             <span class="comment">// If the opcode is an add immediate unsigned op and both the</span>
01200             <span class="comment">// source and destination registers are SP, then add the signed</span>
01201             <span class="comment">// offset value to SP. Otherwise, if the opcode is a special op,</span>
01202             <span class="comment">// the operation is an add unsigned, and the source and destination</span>
01203             <span class="comment">// registers are both SP, then add the register specified by Rd to</span>
01204             <span class="comment">// SP.</span>
01205             <span class="comment">//</span>
01206 
01207             <span class="keywordflow">if</span> ((Opcode == ADDIU_OP) &amp;&amp; (Rt == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>) &amp;&amp; (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>)) {
01208                 IntegerRegister[<a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>] += <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
01209 
01210             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Opcode == SPEC_OP) &amp;&amp; (Function == ADDU_OP) &amp;&amp;
01211                        (Rd == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>) &amp;&amp; (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>)) {
01212                 IntegerRegister[<a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>] += IntegerRegister[Rt];
01213             }
01214 
01215             *EstablisherFrame = (ULONG)ContextRecord-&gt;XIntSp;
01216             <span class="keywordflow">return</span> (ULONG)ContextRecord-&gt;XIntRa;
01217         }
01218 
01219         <span class="comment">//</span>
01220         <span class="comment">// If the address where control left the specified function is outside</span>
01221         <span class="comment">// the limits of the prologue, then the control PC is considered to be</span>
01222         <span class="comment">// within the function and the control address is set to the end of</span>
01223         <span class="comment">// the prologue. Otherwise, the control PC is not considered to be</span>
01224         <span class="comment">// within the function (i.e., it is within the prologue).</span>
01225         <span class="comment">//</span>
01226 
01227         <span class="keywordflow">if</span> ((ControlPc &lt; FunctionEntry-&gt;BeginAddress) ||
01228             (ControlPc &gt;= FunctionEntry-&gt;PrologEndAddress)) {
01229             *InFunction = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01230             ControlPc = FunctionEntry-&gt;PrologEndAddress;
01231 
01232         } <span class="keywordflow">else</span> {
01233             *InFunction = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01234         }
01235 
01236         <span class="comment">//</span>
01237         <span class="comment">// Scan backward through the prologue and reload callee registers that</span>
01238         <span class="comment">// were stored.</span>
01239         <span class="comment">//</span>
01240 
01241         DecrementRegister = 0;
01242         *EstablisherFrame = (ULONG)ContextRecord-&gt;XIntSp;
01243         NextPc = (ULONG)(ContextRecord-&gt;XIntRa - 4);
01244         RestoredRa = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01245         RestoredSp = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01246         <span class="keywordflow">while</span> (ControlPc &gt; FunctionEntry-&gt;BeginAddress) {
01247 
01248             <span class="comment">//</span>
01249             <span class="comment">// Get instruction value, decode fields, case of opcode value, and</span>
01250             <span class="comment">// reverse store operations.</span>
01251             <span class="comment">//</span>
01252 
01253             ControlPc -= 4;
01254             Instruction.Long = *((PULONG)ControlPc);
01255             Opcode = Instruction.i_format.Opcode;
01256             <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> = Instruction.i_format.Simmediate;
01257             Rd = Instruction.r_format.Rd;
01258             Rs = Instruction.i_format.Rs;
01259             Rt = Instruction.i_format.Rt;
01260             Address = (ULONG)(<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> + IntegerRegister[Rs]);
01261             <span class="keywordflow">if</span> (Opcode == SW_OP) {
01262 
01263                 <span class="comment">//</span>
01264                 <span class="comment">// Store word.</span>
01265                 <span class="comment">//</span>
01266                 <span class="comment">// If the base register is SP and the source register is an</span>
01267                 <span class="comment">// integer register, then reload the register value.</span>
01268                 <span class="comment">//</span>
01269 
01270                 <span class="keywordflow">if</span> (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>) {
01271                     IntegerRegister[Rt] = *((PLONG)Address);
01272 
01273                     <span class="comment">//</span>
01274                     <span class="comment">// If the destination register is RA and this is the first</span>
01275                     <span class="comment">// time that RA is being restored, then set the address of</span>
01276                     <span class="comment">// where control left the previous frame. Otherwise, this</span>
01277                     <span class="comment">// is an interrupt or exception and the return PC should be</span>
01278                     <span class="comment">// biased by 4. Otherwise, if the destination register is</span>
01279                     <span class="comment">// SP and this is the first time that SP is being restored,</span>
01280                     <span class="comment">// then set the establisher frame pointer.</span>
01281                     <span class="comment">//</span>
01282 
01283                     <span class="keywordflow">if</span> (Rt == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a1">RA</a>) {
01284                         <span class="keywordflow">if</span> (RestoredRa == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01285                             NextPc = (ULONG)(ContextRecord-&gt;XIntRa - 4);
01286                             RestoredRa = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01287 
01288                         } <span class="keywordflow">else</span> {
01289                             NextPc += 4;
01290                         }
01291 
01292                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Rt == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>) {
01293                         <span class="keywordflow">if</span> (RestoredSp == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01294                             *EstablisherFrame = (ULONG)ContextRecord-&gt;XIntSp;
01295                             RestoredSp = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01296                         }
01297                     }
01298 
01299                     <span class="comment">//</span>
01300                     <span class="comment">// If a context pointer record is specified, then record</span>
01301                     <span class="comment">// the address where the destination register contents</span>
01302                     <span class="comment">// are stored.</span>
01303                     <span class="comment">//</span>
01304 
01305                     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(ContextPointers)) {
01306                         ContextPointers-&gt;XIntegerContext[Rt] = (PULONGLONG)Address;
01307                     }
01308                 }
01309 
01310             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Opcode == SD_OP) {
01311 
01312                 <span class="comment">//</span>
01313                 <span class="comment">// Store double.</span>
01314                 <span class="comment">//</span>
01315                 <span class="comment">// If the base register is SP and the source register is an</span>
01316                 <span class="comment">// integer register, then reload the register value.</span>
01317                 <span class="comment">//</span>
01318 
01319                 <span class="keywordflow">if</span> (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>) {
01320                     IntegerRegister[Rt] = *((PULONGLONG)Address);
01321 
01322                     <span class="comment">//</span>
01323                     <span class="comment">// If the destination register is RA and this is the first</span>
01324                     <span class="comment">// time that RA is being restored, then set the address of</span>
01325                     <span class="comment">// where control left the previous frame. Otherwise, this</span>
01326                     <span class="comment">// is an interrupt or exception and the return PC should be</span>
01327                     <span class="comment">// biased by 4. Otherwise, if the destination register is</span>
01328                     <span class="comment">// SP and this is the first time that SP is being restored,</span>
01329                     <span class="comment">// then set the establisher frame pointer.</span>
01330                     <span class="comment">//</span>
01331 
01332                     <span class="keywordflow">if</span> (Rt == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a1">RA</a>) {
01333                         <span class="keywordflow">if</span> (RestoredRa == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01334                             NextPc = (ULONG)(ContextRecord-&gt;XIntRa - 4);
01335                             RestoredRa = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01336 
01337                         } <span class="keywordflow">else</span> {
01338                             NextPc += 4;
01339                         }
01340 
01341                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Rt == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>) {
01342                         <span class="keywordflow">if</span> (RestoredSp == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01343                             *EstablisherFrame = (ULONG)ContextRecord-&gt;XIntSp;
01344                             RestoredSp = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01345                         }
01346                     }
01347 
01348                     <span class="comment">//</span>
01349                     <span class="comment">// If a context pointer record is specified, then record</span>
01350                     <span class="comment">// the address where the destination register contents</span>
01351                     <span class="comment">// are stored.</span>
01352                     <span class="comment">//</span>
01353                     <span class="comment">// N.B. The low order bit of the address is set to indicate</span>
01354                     <span class="comment">//      a store double operation.</span>
01355                     <span class="comment">//</span>
01356 
01357                     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(ContextPointers)) {
01358                         ContextPointers-&gt;XIntegerContext[Rt] = (PLONGLONG)((ULONG)Address | 1);
01359                     }
01360                 }
01361 
01362             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Opcode == SWC1_OP) {
01363 
01364                 <span class="comment">//</span>
01365                 <span class="comment">// Store word coprocessor 1.</span>
01366                 <span class="comment">//</span>
01367                 <span class="comment">// If the base register is SP and the source register is a</span>
01368                 <span class="comment">// floating register, then reload the register value.</span>
01369                 <span class="comment">//</span>
01370 
01371                 <span class="keywordflow">if</span> (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>) {
01372                     FloatingRegister[Rt] = *((PULONG)Address);
01373 
01374                     <span class="comment">//</span>
01375                     <span class="comment">// If a context pointer record is specified, then record</span>
01376                     <span class="comment">// the address where the destination register contents</span>
01377                     <span class="comment">// are stored.</span>
01378                     <span class="comment">//</span>
01379 
01380                     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(ContextPointers)) {
01381                         ContextPointers-&gt;FloatingContext[Rt] = (PULONG)Address;
01382                     }
01383                 }
01384 
01385             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Opcode == SDC1_OP) {
01386 
01387                 <span class="comment">//</span>
01388                 <span class="comment">// Store double coprocessor 1.</span>
01389                 <span class="comment">//</span>
01390                 <span class="comment">// If the base register is SP and the source register is a</span>
01391                 <span class="comment">// floating register, then reload the register and the next</span>
01392                 <span class="comment">// register values.</span>
01393                 <span class="comment">//</span>
01394 
01395                 <span class="keywordflow">if</span> (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>) {
01396                     FloatingRegister[Rt] = *((PULONG)Address);
01397                     FloatingRegister[Rt + 1] = *((PULONG)(Address + 4));
01398 
01399                     <span class="comment">//</span>
01400                     <span class="comment">// If a context pointer record is specified, then record</span>
01401                     <span class="comment">// the address where the destination registers contents</span>
01402                     <span class="comment">// are stored.</span>
01403                     <span class="comment">//</span>
01404 
01405                     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(ContextPointers)) {
01406                         ContextPointers-&gt;FloatingContext[Rt] = (PULONG)Address;
01407                         ContextPointers-&gt;FloatingContext[Rt + 1] = (PULONG)(Address + 4);
01408                     }
01409                 }
01410 
01411             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Opcode == ADDIU_OP) {
01412 
01413                 <span class="comment">//</span>
01414                 <span class="comment">// Add immediate unsigned.</span>
01415                 <span class="comment">//</span>
01416                 <span class="comment">// If both the source and destination registers are SP, then</span>
01417                 <span class="comment">// a standard stack allocation was performed and the signed</span>
01418                 <span class="comment">// displacement value should be subtracted from SP. Otherwise,</span>
01419                 <span class="comment">// if the destination register is the decrement register and</span>
01420                 <span class="comment">// the source register is zero, then add the decrement value</span>
01421                 <span class="comment">// to SP.</span>
01422                 <span class="comment">//</span>
01423 
01424                 <span class="keywordflow">if</span> ((Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>) &amp;&amp; (Rt == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>)) {
01425                     IntegerRegister[<a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>] -= <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
01426                     <span class="keywordflow">if</span> (RestoredSp == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01427                         *EstablisherFrame = (ULONG)ContextRecord-&gt;XIntSp;
01428                         RestoredSp = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01429                     }
01430 
01431                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Rt == DecrementRegister) &amp;&amp; (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a3">ZERO</a>)) {
01432                     IntegerRegister[<a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>] += <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
01433                     <span class="keywordflow">if</span> (RestoredSp == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01434                         *EstablisherFrame = (ULONG)ContextRecord-&gt;XIntSp;
01435                         RestoredSp = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01436                     }
01437                 }
01438 
01439             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Opcode == ORI_OP) {
01440 
01441                 <span class="comment">//</span>
01442                 <span class="comment">// Or immediate.</span>
01443                 <span class="comment">//</span>
01444                 <span class="comment">// If both the destination and source registers are the decrement</span>
01445                 <span class="comment">// register, then save the decrement value. Otherwise, if the</span>
01446                 <span class="comment">// destination register is the decrement register and the source</span>
01447                 <span class="comment">// register is zero, then add the decrement value to SP.</span>
01448                 <span class="comment">//</span>
01449 
01450                 <span class="keywordflow">if</span> ((Rs == DecrementRegister) &amp;&amp; (Rt == DecrementRegister)) {
01451                     DecrementOffset = (<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> &amp; 0xffff);
01452 
01453                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Rt == DecrementRegister) &amp;&amp; (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a3">ZERO</a>)) {
01454                     IntegerRegister[<a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>] += (<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> &amp; 0xffff);
01455                     <span class="keywordflow">if</span> (RestoredSp == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01456                         *EstablisherFrame = (ULONG)ContextRecord-&gt;XIntSp;
01457                         RestoredSp = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01458                     }
01459                 }
01460 
01461             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Opcode == SPEC_OP) {
01462 
01463                 <span class="comment">//</span>
01464                 <span class="comment">// Special operation.</span>
01465                 <span class="comment">//</span>
01466                 <span class="comment">// The real opcode is in the function field of special opcode</span>
01467                 <span class="comment">// instructions.</span>
01468                 <span class="comment">//</span>
01469 
01470                 Function = Instruction.r_format.Function;
01471                 <span class="keywordflow">if</span> ((Function == ADDU_OP) || (Function == OR_OP)) {
01472 
01473                     <span class="comment">//</span>
01474                     <span class="comment">// Add unsigned or an or operation.</span>
01475                     <span class="comment">//</span>
01476                     <span class="comment">// If one of the source registers is ZERO, then the</span>
01477                     <span class="comment">// operation is a move operation and the destination</span>
01478                     <span class="comment">// register should be moved to the appropriate source</span>
01479                     <span class="comment">// register.</span>
01480                     <span class="comment">//</span>
01481 
01482                     <span class="keywordflow">if</span> (Rt == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a3">ZERO</a>) {
01483                         IntegerRegister[Rs] = IntegerRegister[Rd];
01484 
01485                         <span class="comment">//</span>
01486                         <span class="comment">// If the destination register is RA and this is the</span>
01487                         <span class="comment">// first time that RA is being restored, then set the</span>
01488                         <span class="comment">// address of where control left the previous frame.</span>
01489                         <span class="comment">// Otherwise, this an interrupt or exception and the</span>
01490                         <span class="comment">// return PC should be biased by 4.</span>
01491                         <span class="comment">//</span>
01492 
01493                         <span class="keywordflow">if</span> (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a1">RA</a>) {
01494                             <span class="keywordflow">if</span> (RestoredRa == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01495                                 NextPc = (ULONG)(ContextRecord-&gt;XIntRa - 4);
01496                                 RestoredRa = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01497 
01498                             } <span class="keywordflow">else</span> {
01499                                 NextPc += 4;
01500                             }
01501                         }
01502 
01503                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a3">ZERO</a>) {
01504                         IntegerRegister[Rt] = IntegerRegister[Rd];
01505 
01506                         <span class="comment">//</span>
01507                         <span class="comment">// If the destination register is RA and this is the</span>
01508                         <span class="comment">// first time that RA is being restored, then set the</span>
01509                         <span class="comment">// address of where control left the previous frame.</span>
01510                         <span class="comment">// Otherwise, this an interrupt or exception and the</span>
01511                         <span class="comment">// return PC should be biased by 4.</span>
01512                         <span class="comment">//</span>
01513 
01514                         <span class="keywordflow">if</span> (Rt == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a1">RA</a>) {
01515                             <span class="keywordflow">if</span> (RestoredRa == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01516                                 NextPc = (ULONG)(ContextRecord-&gt;XIntRa - 4);
01517                                 RestoredRa = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01518 
01519                             } <span class="keywordflow">else</span> {
01520                                 NextPc += 4;
01521                             }
01522                         }
01523                     }
01524 
01525                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Function == SUBU_OP) {
01526 
01527                     <span class="comment">//</span>
01528                     <span class="comment">// Subtract unsigned.</span>
01529                     <span class="comment">//</span>
01530                     <span class="comment">// If the destination register is SP and the source register</span>
01531                     <span class="comment">// is SP, then a stack allocation greater than 32kb has been</span>
01532                     <span class="comment">// performed and source register number of the decrement must</span>
01533                     <span class="comment">// be saved for later use.</span>
01534                     <span class="comment">//</span>
01535 
01536                     <span class="keywordflow">if</span> ((Rd == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>) &amp;&amp; (Rs == <a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>)) {
01537                         DecrementRegister = Rt;
01538                     }
01539                 }
01540 
01541             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Opcode == LUI_OP) {
01542 
01543                 <span class="comment">//</span>
01544                 <span class="comment">// Load upper immediate.</span>
01545                 <span class="comment">//</span>
01546                 <span class="comment">// If the destination register is the decrement register, then</span>
01547                 <span class="comment">// compute the decrement value, add it from SP, and clear the</span>
01548                 <span class="comment">// decrement register number.</span>
01549                 <span class="comment">//</span>
01550 
01551                 <span class="keywordflow">if</span> (Rt == DecrementRegister) {
01552                     DecrementRegister = 0;
01553                     IntegerRegister[<a class="code" href="../../d8/d9/mips_2exdsptch_8c.html#a2">SP</a>] += (LONG)(DecrementOffset + (<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a> &lt;&lt; 16));
01554                     <span class="keywordflow">if</span> (RestoredSp == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01555                         *EstablisherFrame = (ULONG)(ContextRecord-&gt;XIntSp);
01556                         RestoredSp = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01557                     }
01558                 }
01559             }
01560         }
01561 
01562         <span class="comment">//</span>
01563         <span class="comment">// Make sure that integer register zero is really zero.</span>
01564         <span class="comment">//</span>
01565 
01566         ContextRecord-&gt;XIntZero = 0;
01567         <span class="keywordflow">return</span> NextPc;
01568     }
01569 }

</div></pre>    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:43:35 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
