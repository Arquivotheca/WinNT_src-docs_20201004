<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: wstree.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>wstree.c</h1><a href="../../d7/d0/wstree_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1989  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">   wstree.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module contains the routines which manipulate the working</span>
00012 <span class="comment">    set list tree.</span>
00013 <span class="comment"></span>
00014 <span class="comment">Author:</span>
00015 <span class="comment"></span>
00016 <span class="comment">    Lou Perazzoli (loup) 15-May-1989</span>
00017 <span class="comment"></span>
00018 <span class="comment">Revision History:</span>
00019 <span class="comment"></span>
00020 <span class="comment">--*/</span>
00021 
00022 <span class="preprocessor">#include "<a class="code" href="../../d4/d8/mi_8h.html">mi.h</a>"</span>
00023 
00024 <span class="preprocessor">#if (_MSC_VER &gt;= 800)</span>
00025 <span class="preprocessor"></span><span class="preprocessor">#pragma warning(disable:4010)           </span><span class="comment">/* Allow pretty pictures without the noise */</span>
00026 <span class="preprocessor">#endif</span>
00027 <span class="preprocessor"></span>
<a name="l00028"></a><a class="code" href="../../d7/d0/wstree_8c.html#a0">00028</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d6/d8/sysinfo_8c.html#a9">MmSystemCodePage</a>;
<a name="l00029"></a><a class="code" href="../../d7/d0/wstree_8c.html#a1">00029</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d6/d8/sysinfo_8c.html#a10">MmSystemCachePage</a>;
<a name="l00030"></a><a class="code" href="../../d7/d0/wstree_8c.html#a2">00030</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d6/d8/sysinfo_8c.html#a11">MmPagedPoolPage</a>;
<a name="l00031"></a><a class="code" href="../../d7/d0/wstree_8c.html#a3">00031</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d6/d8/sysinfo_8c.html#a12">MmSystemDriverPage</a>;
00032 
00033 <span class="preprocessor">#if DBG</span>
00034 <span class="preprocessor"></span>ULONG MmNumberOfInserts;
00035 <span class="preprocessor">#endif</span>
00036 <span class="preprocessor"></span>
00037 ULONG
00038 <a class="code" href="../../d7/d0/wstree_8c.html#a4">MiLookupWsleHashIndex</a> (
00039     IN ULONG_PTR WsleEntry,
00040     IN <a class="code" href="../../d0/d8/struct__MMWSL.html">PMMWSL</a> WorkingSetList
00041     );
00042 
00043 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00044 <a class="code" href="../../d7/d0/wstree_8c.html#a5">MiCheckWsleHash</a> (
00045     IN <a class="code" href="../../d0/d8/struct__MMWSL.html">PMMWSL</a> WorkingSetList
00046     );
00047 
00048 
00049 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00050 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l00051"></a><a class="code" href="../../d7/d0/wstree_8c.html#a6">00051</a> <a class="code" href="../../d7/d0/wstree_8c.html#a6">MiInsertWsle</a> (
00052     IN WSLE_NUMBER Entry,
00053     IN <a class="code" href="../../d0/d8/struct__MMWSL.html">PMMWSL</a> WorkingSetList
00054     )
00055 
00056 <span class="comment">/*++</span>
00057 <span class="comment"></span>
00058 <span class="comment">Routine Description:</span>
00059 <span class="comment"></span>
00060 <span class="comment">    This routine inserts a Working Set List Entry (WSLE) into the</span>
00061 <span class="comment">    working set.</span>
00062 <span class="comment"></span>
00063 <span class="comment">Arguments:</span>
00064 <span class="comment"></span>
00065 <span class="comment">    Entry - The index number of the WSLE to insert.</span>
00066 <span class="comment"></span>
00067 <span class="comment">    WorkingSetList - Supplies the working set list to insert into.</span>
00068 <span class="comment"></span>
00069 <span class="comment">Return Value:</span>
00070 <span class="comment"></span>
00071 <span class="comment">    None.</span>
00072 <span class="comment"></span>
00073 <span class="comment">Environment:</span>
00074 <span class="comment"></span>
00075 <span class="comment">    Kernel mode, APCs disabled, Working Set Mutex held.</span>
00076 <span class="comment"></span>
00077 <span class="comment">--*/</span>
00078 
00079 {
00080     PVOID VirtualAddress;
00081     <a class="code" href="../../d1/d8/struct__MMWSLE.html">PMMWSLE</a> Wsle;
00082     <a class="code" href="../../d3/d6/struct__MMSUPPORT.html">PMMSUPPORT</a> WsInfo;
00083     <a class="code" href="../../d4/d8/mi_8h.html#a435">WSLE_NUMBER</a> Hash;
00084     <a class="code" href="../../d3/d8/struct__MMWSLE__HASH.html">PMMWSLE_HASH</a> Table;
00085     <a class="code" href="../../d4/d8/mi_8h.html#a435">WSLE_NUMBER</a> j;
00086     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
00087     <a class="code" href="../../d4/d8/mi_8h.html#a435">WSLE_NUMBER</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00088     LARGE_INTEGER <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a7">TickCount</a>;
00089     ULONG <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
00090 <span class="preprocessor">#if defined(_ALPHA_) &amp;&amp; !defined(_AXP64_)</span>
00091 <span class="preprocessor"></span>    KIRQL OldIrql;
00092 <span class="preprocessor">#endif</span>
00093 <span class="preprocessor"></span>
00094     Wsle = WorkingSetList-&gt;Wsle;
00095 
00096     VirtualAddress = <a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a>(Wsle[Entry].u1.<a class="code" href="../../d1/d8/struct__MMWSLE.html#o0">VirtualAddress</a>);
00097 
00098 <span class="preprocessor">#if DBG</span>
00099 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (MmDebug &amp; <a class="code" href="../../d4/d8/mi_8h.html#a57">MM_DBG_PTE_UPDATE</a>) {
00100         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"inserting element %lx %lx\n"</span>, Entry, Wsle[Entry].u1.<a class="code" href="../../d1/d8/struct__MMWSLE.html#o1">Long</a>);
00101     }
00102 
00103     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Wsle[Entry].u1.<a class="code" href="../../d1/d8/struct__MMWSLE.html#o2">e1</a>.<a class="code" href="../../d4/d8/struct__MMWSLENTRY.html#o0">Valid</a> == 1);
00104     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Wsle[Entry].u1.<a class="code" href="../../d1/d8/struct__MMWSLE.html#o2">e1</a>.<a class="code" href="../../d4/d8/struct__MMWSLENTRY.html#o5">Direct</a> != 1);
00105 <span class="preprocessor">#endif //DBG</span>
00106 <span class="preprocessor"></span>
00107     WorkingSetList-&gt;NonDirectCount += 1;
00108 
00109     <span class="keywordflow">if</span> ((Table = WorkingSetList-&gt;HashTable) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00110         <span class="keywordflow">return</span>;
00111     }
00112 
00113 <span class="preprocessor">#if DBG</span>
00114 <span class="preprocessor"></span>    MmNumberOfInserts += 1;
00115 <span class="preprocessor">#endif //DBG</span>
00116 <span class="preprocessor"></span>
00117     Hash = <a class="code" href="../../d4/d8/mi_8h.html#a191">MI_WSLE_HASH</a>(Wsle[Entry].u1.<a class="code" href="../../d1/d8/struct__MMWSLE.html#o1">Long</a>, WorkingSetList);
00118 
00119     <span class="comment">//</span>
00120     <span class="comment">// Check hash table size and see if there is enough room to</span>
00121     <span class="comment">// hash or if the table should be grown.</span>
00122     <span class="comment">//</span>
00123 
00124     <span class="keywordflow">if</span> ((WorkingSetList-&gt;NonDirectCount + 10 +
00125             (WorkingSetList-&gt;HashTableSize &gt;&gt; 4)) &gt;
00126                                  WorkingSetList-&gt;HashTableSize) {
00127 
00128         <span class="keywordflow">if</span> (WorkingSetList == <a class="code" href="../../d4/d8/mi_8h.html#a672">MmWorkingSetList</a>) {
00129             WsInfo = &amp;<a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>()-&gt;Vm;
00130             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (WsInfo-&gt;<a class="code" href="../../d3/d6/struct__MMSUPPORT.html#o15">u</a>.Flags.SessionSpace == 0);
00131         }
00132         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (WorkingSetList == <a class="code" href="../../d4/d8/mi_8h.html#a657">MmSystemCacheWorkingSetList</a>) {
00133             WsInfo = &amp;<a class="code" href="../../d6/d8/sysinfo_8c.html#a21">MmSystemCacheWs</a>;
00134             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (WsInfo-&gt;<a class="code" href="../../d3/d6/struct__MMSUPPORT.html#o15">u</a>.Flags.SessionSpace == 0);
00135         }
00136         <span class="keywordflow">else</span> {
00137             WsInfo = &amp;<a class="code" href="../../d4/d8/mi_8h.html#a753">MmSessionSpace</a>-&gt;<a class="code" href="../../d0/d0/struct__MM__SESSION__SPACE.html#o30">Vm</a>;
00138             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (WsInfo-&gt;<a class="code" href="../../d3/d6/struct__MMSUPPORT.html#o15">u</a>.Flags.SessionSpace == 1);
00139         }
00140 
00141         <span class="keywordflow">if</span> ((Table + WorkingSetList-&gt;HashTableSize + ((2*<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>) / <span class="keyword">sizeof</span> (<a class="code" href="../../d3/d8/struct__MMWSLE__HASH.html">MMWSLE_HASH</a>)) &lt;= (<a class="code" href="../../d3/d8/struct__MMWSLE__HASH.html">PMMWSLE_HASH</a>)WorkingSetList-&gt;HighestPermittedHashAddress) &amp;&amp;
00142                 (WsInfo-&gt;<a class="code" href="../../d3/d6/struct__MMSUPPORT.html#o9">AllowWorkingSetAdjustment</a>)) {
00143 
00144 <span class="preprocessor">#if defined(_ALPHA_) &amp;&amp; !defined(_AXP64_)</span>
00145 <span class="preprocessor"></span>            <a class="code" href="../../d4/d8/mi_8h.html#a142">LOCK_EXPANSION_IF_ALPHA</a> (OldIrql);
00146 <span class="preprocessor">#endif</span>
00147 <span class="preprocessor"></span>            WsInfo-&gt;<a class="code" href="../../d3/d6/struct__MMSUPPORT.html#o9">AllowWorkingSetAdjustment</a> = <a class="code" href="../../d4/d8/mi_8h.html#a32">MM_GROW_WSLE_HASH</a>;
00148 <span class="preprocessor">#if defined(_ALPHA_) &amp;&amp; !defined(_AXP64_)</span>
00149 <span class="preprocessor"></span>            <a class="code" href="../../d4/d8/mi_8h.html#a143">UNLOCK_EXPANSION_IF_ALPHA</a> (OldIrql);
00150 <span class="preprocessor">#endif</span>
00151 <span class="preprocessor"></span>        }
00152 
00153         <span class="keywordflow">if</span> ((WorkingSetList-&gt;NonDirectCount +
00154                 (WorkingSetList-&gt;HashTableSize &gt;&gt; 4)) &gt;
00155                                      WorkingSetList-&gt;HashTableSize) {
00156 
00157             <span class="comment">//</span>
00158             <span class="comment">// No more room in the hash table, remove one and add there.</span>
00159             <span class="comment">// Pick a victim within 16 of where this would hash to.</span>
00160             <span class="comment">//</span>
00161 
00162             <a class="code" href="../../d7/d0/ke_2miscc_8c.html#a4">KeQueryTickCount</a>(&amp;<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a7">TickCount</a>);
00163             j = Hash + (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a7">TickCount</a>.LowPart &amp; 0xF);
00164 
00165             <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> = WorkingSetList-&gt;HashTableSize;
00166 
00167             <span class="keywordflow">if</span> (j &gt;= <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>) {
00168                 j = <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a7">TickCount</a>.LowPart &amp; 0xF;
00169             }
00170 
00171             <span class="keywordflow">do</span> {
00172                 <span class="keywordflow">if</span> (Table[j].<a class="code" href="../../d3/d8/struct__MMWSLE__HASH.html#o0">Key</a> != 0) {
00173                     <a class="code" href="../../d2/d1/mm_8h.html#a80">PERFINFO_PAGE_INFO_DECL</a>();
00174 
00175                     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (Table[j].<a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>);
00176                     <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = WorkingSetList-&gt;HashTable[j].Index;
00177                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Wsle[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].u1.e1.Valid == 1);
00178                     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (Wsle[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].u1.VirtualAddress);
00179 
00180                     <a class="code" href="../../d2/d1/mm_8h.html#a53">PERFINFO_GET_PAGE_INFO</a>(PointerPte);
00181                     <span class="keywordflow">if</span> (<a class="code" href="../../d4/d0/wslist_8c.html#a26">MiFreeWsle</a> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>, WsInfo, PointerPte)) {
00182                         <a class="code" href="../../d2/d1/mm_8h.html#a74">PERFINFO_LOG_WS_REMOVAL</a>(PERFINFO_LOG_TYPE_OUTWS_HASHFULL, WsInfo);
00183                         <span class="keywordflow">break</span>;
00184                     }
00185                 }
00186                 j += 1;
00187                 <span class="keywordflow">if</span> (j &gt;= <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>) {
00188                     j = 0;
00189                 }
00190             } <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
00191         }
00192     }
00193 
00194     <span class="comment">//</span>
00195     <span class="comment">// Add to the hash table.</span>
00196     <span class="comment">//</span>
00197 
00198     <span class="keywordflow">while</span> (Table[Hash].<a class="code" href="../../d3/d8/struct__MMWSLE__HASH.html#o0">Key</a> != 0) {
00199         Hash += 1;
00200         <span class="keywordflow">if</span> (Hash &gt;= WorkingSetList-&gt;HashTableSize) {
00201             Hash = 0;
00202         }
00203     }
00204 
00205     Table[Hash].<a class="code" href="../../d3/d8/struct__MMWSLE__HASH.html#o0">Key</a> = Wsle[Entry].<a class="code" href="../../d1/d8/struct__MMWSLE.html#o3">u1</a>.Long &amp; ~(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1);
00206     Table[Hash].<a class="code" href="../../d3/d8/struct__MMWSLE__HASH.html#o1">Index</a> = Entry;
00207 
00208 <span class="preprocessor">#if DBG</span>
00209 <span class="preprocessor"></span>    <span class="keywordflow">if</span> ((MmNumberOfInserts % 1000) == 0) {
00210         <a class="code" href="../../d7/d0/wstree_8c.html#a5">MiCheckWsleHash</a> (WorkingSetList);
00211     }
00212 <span class="preprocessor">#endif //DBG</span>
00213 <span class="preprocessor"></span>    <span class="keywordflow">return</span>;
00214 }
00215 
00216 <span class="preprocessor">#if DBG</span>
00217 <span class="preprocessor"></span><a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00218 <a class="code" href="../../d7/d0/wstree_8c.html#a5">MiCheckWsleHash</a> (
00219     IN <a class="code" href="../../d0/d8/struct__MMWSL.html">PMMWSL</a> WorkingSetList
00220     )
00221 
00222 {
00223     ULONG j;
00224     ULONG found = 0;
00225     <a class="code" href="../../d1/d8/struct__MMWSLE.html">PMMWSLE</a> Wsle;
00226 
00227     Wsle = WorkingSetList-&gt;Wsle;
00228 
00229     <span class="keywordflow">for</span> (j =0; j &lt; WorkingSetList-&gt;HashTableSize ; j++ ) {
00230         <span class="keywordflow">if</span> (WorkingSetList-&gt;HashTable[j].Key != 0) {
00231             found += 1;
00232             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (WorkingSetList-&gt;HashTable[j].Key ==
00233                      (Wsle[WorkingSetList-&gt;HashTable[j].Index].u1.Long &amp;
00234                                                             ~(PAGE_SIZE -1)));
00235         }
00236     }
00237     <span class="keywordflow">if</span> (found != WorkingSetList-&gt;NonDirectCount) {
00238         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"MMWSLE: Found %lx, nondirect %lx\n"</span>,
00239                     found, WorkingSetList-&gt;NonDirectCount);
00240         DbgBreakPoint();
00241     }
00242 }
00243 <span class="preprocessor">#endif //dbg</span>
00244 <span class="preprocessor"></span>
00245 
00246 <a class="code" href="../../d4/d8/mi_8h.html#a435">WSLE_NUMBER</a>
00247 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l00248"></a><a class="code" href="../../d7/d0/wstree_8c.html#a7">00248</a> <a class="code" href="../../d7/d0/wstree_8c.html#a7">MiLocateWsle</a> (
00249     IN PVOID VirtualAddress,
00250     IN <a class="code" href="../../d0/d8/struct__MMWSL.html">PMMWSL</a> WorkingSetList,
00251     IN WSLE_NUMBER WsPfnIndex
00252     )
00253 
00254 <span class="comment">/*++</span>
00255 <span class="comment"></span>
00256 <span class="comment">Routine Description:</span>
00257 <span class="comment"></span>
00258 <span class="comment">    This function locates the specified virtual address within the</span>
00259 <span class="comment">    working set list.</span>
00260 <span class="comment"></span>
00261 <span class="comment">Arguments:</span>
00262 <span class="comment"></span>
00263 <span class="comment">    VirtualAddress - Supplies the virtual to locate within the working</span>
00264 <span class="comment">                     set list.</span>
00265 <span class="comment"></span>
00266 <span class="comment">    WorkingSetList - Supplies the working set list to search.</span>
00267 <span class="comment"></span>
00268 <span class="comment">    WsPfnIndex - Supplies a hint to try before hashing or walking linearly.</span>
00269 <span class="comment"></span>
00270 <span class="comment">Return Value:</span>
00271 <span class="comment"></span>
00272 <span class="comment">    Returns the index into the working set list which contains the entry.</span>
00273 <span class="comment"></span>
00274 <span class="comment">Environment:</span>
00275 <span class="comment"></span>
00276 <span class="comment">    Kernel mode, APCs disabled, Working Set Mutex held.</span>
00277 <span class="comment"></span>
00278 <span class="comment">--*/</span>
00279 
00280 {
00281     <a class="code" href="../../d4/d8/mi_8h.html#a435">WSLE_NUMBER</a> i;
00282     <a class="code" href="../../d1/d8/struct__MMWSLE.html">PMMWSLE</a> Wsle;
00283     ULONG Hash;
00284     <a class="code" href="../../d3/d8/struct__MMWSLE__HASH.html">PMMWSLE_HASH</a> Table;
00285     ULONG Tries;
00286     <a class="code" href="../../d4/d8/mi_8h.html#a435">WSLE_NUMBER</a> WsPteIndex;
00287     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
00288 
00289     Wsle = WorkingSetList-&gt;Wsle;
00290 
00291     VirtualAddress = <a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a>(VirtualAddress);
00292 
00293 <span class="preprocessor">#if defined (_WIN64)</span>
00294 <span class="preprocessor"></span>    PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (VirtualAddress);
00295     WsPteIndex = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a110">MI_GET_WORKING_SET_FROM_PTE</a> (PointerPte);
00296     <span class="keywordflow">if</span> (WsPteIndex != 0) {
00297         <span class="keywordflow">while</span> (WsPteIndex &lt;= WorkingSetList-&gt;LastInitializedWsle) {
00298             <span class="keywordflow">if</span> ((VirtualAddress == <a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a>(Wsle[WsPteIndex].u1.<a class="code" href="../../d1/d8/struct__MMWSLE.html#o0">VirtualAddress</a>)) &amp;&amp;
00299                 (Wsle[WsPteIndex].<a class="code" href="../../d1/d8/struct__MMWSLE.html#o3">u1</a>.e1.Valid == 1)) {
00300                     <span class="keywordflow">return</span> WsPteIndex;
00301             }
00302             WsPteIndex += <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a92">MI_MAXIMUM_PTE_WORKING_SET_INDEX</a>;
00303         }
00304 
00305         <span class="comment">//</span>
00306         <span class="comment">// No working set index for this PTE !</span>
00307         <span class="comment">//</span>
00308 
00309         <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a> (MEMORY_MANAGEMENT,
00310                       0x41283,
00311                       (ULONG_PTR)VirtualAddress,
00312                       PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long,
00313                       (ULONG_PTR)WorkingSetList);
00314     }
00315 <span class="preprocessor">#endif</span>
00316 <span class="preprocessor"></span>
00317     <span class="keywordflow">if</span> (WsPfnIndex &lt;= WorkingSetList-&gt;LastInitializedWsle) {
00318         <span class="keywordflow">if</span> ((VirtualAddress == <a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a>(Wsle[WsPfnIndex].u1.<a class="code" href="../../d1/d8/struct__MMWSLE.html#o0">VirtualAddress</a>)) &amp;&amp;
00319             (Wsle[WsPfnIndex].<a class="code" href="../../d1/d8/struct__MMWSLE.html#o3">u1</a>.e1.Valid == 1)) {
00320             <span class="keywordflow">return</span> WsPfnIndex;
00321         }
00322     }
00323 
00324     <span class="keywordflow">if</span> (WorkingSetList-&gt;HashTable) {
00325         Tries = 0;
00326         Table = WorkingSetList-&gt;HashTable;
00327 
00328         Hash = <a class="code" href="../../d4/d8/mi_8h.html#a191">MI_WSLE_HASH</a>(VirtualAddress, WorkingSetList);
00329 
00330         <span class="keywordflow">while</span> (Table[Hash].<a class="code" href="../../d3/d8/struct__MMWSLE__HASH.html#o0">Key</a> != (ULONG_PTR)VirtualAddress) {
00331             Hash += 1;
00332             <span class="keywordflow">if</span> (Hash &gt;= WorkingSetList-&gt;HashTableSize) {
00333                 Hash = 0;
00334                 <span class="keywordflow">if</span> (Tries != 0) {
00335                     <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a> (MEMORY_MANAGEMENT,
00336                                   0x41284,
00337                                   (ULONG_PTR)VirtualAddress,
00338                                   WsPfnIndex,
00339                                   (ULONG_PTR)WorkingSetList);
00340                 }
00341                 Tries = 1;
00342             }
00343         }
00344         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (WorkingSetList-&gt;Wsle[Table[Hash].<a class="code" href="../../d3/d8/struct__MMWSLE__HASH.html#o1">Index</a>].u1.e1.Direct == 0);
00345         <span class="keywordflow">return</span> Table[Hash].<a class="code" href="../../d3/d8/struct__MMWSLE__HASH.html#o1">Index</a>;
00346     }
00347 
00348     i = 0;
00349 
00350     <span class="keywordflow">for</span> (; ; ) {
00351         <span class="keywordflow">if</span> ((VirtualAddress == <a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a>(Wsle[i].u1.<a class="code" href="../../d1/d8/struct__MMWSLE.html#o0">VirtualAddress</a>)) &amp;&amp;
00352             (Wsle[i].<a class="code" href="../../d1/d8/struct__MMWSLE.html#o3">u1</a>.e1.Valid == 1)) {
00353             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (WorkingSetList-&gt;Wsle[i].u1.e1.Direct == 0);
00354             <span class="keywordflow">return</span> i;
00355         }
00356         i += 1;
00357     }
00358 }
00359 
00360 
00361 <span class="preprocessor">#if 0</span>
00362 <span class="preprocessor"></span>
00363 ULONG
00364 MiLocateWsleAndParent (
00365     IN PVOID VirtualAddress,
00366     OUT PULONG Parent,
00367     IN <a class="code" href="../../d0/d8/struct__MMWSL.html">PMMWSL</a> WorkingSetList,
00368     IN ULONG WsPfnIndex
00369     )
00370 
00371 <span class="comment">/*++</span>
00372 <span class="comment"></span>
00373 <span class="comment">Routine Description:</span>
00374 <span class="comment"></span>
00375 <span class="comment">    This routine locates both the working set list entry (via index) and</span>
00376 <span class="comment">    it's parent.</span>
00377 <span class="comment"></span>
00378 <span class="comment">Arguments:</span>
00379 <span class="comment"></span>
00380 <span class="comment">    VirtualAddress - Supplies the virtual address of the WSLE to locate.</span>
00381 <span class="comment"></span>
00382 <span class="comment">    Parent - Returns the index into the working set list for the parent.</span>
00383 <span class="comment"></span>
00384 <span class="comment">    WorkingSetList - Supplies a pointer to the working set list.</span>
00385 <span class="comment"></span>
00386 <span class="comment">    WsPfnIndex - Supplies the index field from the PFN database for</span>
00387 <span class="comment">                 the physical page that maps the specified virtual address.</span>
00388 <span class="comment"></span>
00389 <span class="comment">Return Value:</span>
00390 <span class="comment"></span>
00391 <span class="comment">    Returns the index of the virtual address in the working set list.</span>
00392 <span class="comment"></span>
00393 <span class="comment">Environment:</span>
00394 <span class="comment"></span>
00395 <span class="comment">    Kernel mode, APCs disabled, Working Set Mutex held.</span>
00396 <span class="comment"></span>
00397 <span class="comment">--*/</span>
00398 
00399 {
00400     ULONG Previous;
00401     ULONG Entry;
00402     <a class="code" href="../../d1/d8/struct__MMWSLE.html">PMMWSLE</a> Wsle;
00403 
00404     Wsle = WorkingSetList-&gt;Wsle;
00405 
00406     <span class="comment">//</span>
00407     <span class="comment">// Check to see if the PfnIndex field refers to the WSLE in question.</span>
00408     <span class="comment">// Make sure the index is within the specified working set list.</span>
00409     <span class="comment">//</span>
00410 
00411     <span class="keywordflow">if</span> (WsPfnIndex &lt;= WorkingSetList-&gt;LastInitializedWsle) {
00412         <span class="keywordflow">if</span> (VirtualAddress == <a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a>(Wsle[WsPfnIndex].u1.VirtualAddress)) {
00413 
00414             <span class="comment">//</span>
00415             <span class="comment">// The index field points to the WSLE, however, this could</span>
00416             <span class="comment">// have been just a coincidence, so check to ensure it</span>
00417             <span class="comment">// really doesn't have a parent.</span>
00418             <span class="comment">//</span>
00419 
00420             <span class="keywordflow">if</span> (Wsle[WsPfnIndex].u2.BothPointers == 0) {
00421 
00422                 <span class="comment">//</span>
00423                 <span class="comment">// Not in tree, therefore has no parent.</span>
00424                 <span class="comment">//</span>
00425 
00426                 *Parent = <a class="code" href="../../d4/d8/mi_8h.html#a10">WSLE_NULL_INDEX</a>;
00427                 <span class="keywordflow">return</span> WsPfnIndex;
00428             }
00429         }
00430     }
00431 
00432     <span class="comment">//</span>
00433     <span class="comment">// Search the tree for the entry remembering the parents.</span>
00434     <span class="comment">//</span>
00435 
00436     Entry = WorkingSetList-&gt;Root;
00437     Previous = Entry;
00438 
00439     <span class="keywordflow">for</span> (;;) {
00440 
00441         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Entry != WSLE_NULL_INDEX);
00442 
00443         <span class="keywordflow">if</span> (VirtualAddress == <a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a>(Wsle[Entry].u1.VirtualAddress)) {
00444             <span class="keywordflow">break</span>;
00445         }
00446 
00447         <span class="keywordflow">if</span> (VirtualAddress &lt; <a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a>(Wsle[Entry].u1.VirtualAddress)) {
00448             Previous = Entry;
00449             Entry = Wsle[Entry].u2.s.LeftChild;
00450         } <span class="keywordflow">else</span> {
00451             Previous = Entry;
00452             Entry = Wsle[Entry].u2.s.RightChild;
00453         }
00454     }
00455 
00456     *Parent = Previous;
00457     <span class="keywordflow">return</span> Entry;
00458 }
00459 <span class="preprocessor">#endif //0</span>
00460 <span class="preprocessor"></span>
00461 
00462 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00463 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l00464"></a><a class="code" href="../../d7/d0/wstree_8c.html#a8">00464</a> <a class="code" href="../../d7/d0/wstree_8c.html#a8">MiRemoveWsle</a> (
00465     IN WSLE_NUMBER Entry,
00466     IN <a class="code" href="../../d0/d8/struct__MMWSL.html">PMMWSL</a> WorkingSetList
00467     )
00468 
00469 <span class="comment">/*++</span>
00470 <span class="comment"></span>
00471 <span class="comment">Routine Description:</span>
00472 <span class="comment"></span>
00473 <span class="comment">    This routine removes a Working Set List Entry (WSLE) from the</span>
00474 <span class="comment">    working set.</span>
00475 <span class="comment"></span>
00476 <span class="comment">Arguments:</span>
00477 <span class="comment"></span>
00478 <span class="comment">    Entry - The index number of the WSLE to remove.</span>
00479 <span class="comment"></span>
00480 <span class="comment"></span>
00481 <span class="comment">Return Value:</span>
00482 <span class="comment"></span>
00483 <span class="comment">    None.</span>
00484 <span class="comment"></span>
00485 <span class="comment">Environment:</span>
00486 <span class="comment"></span>
00487 <span class="comment">    Kernel mode, APCs disabled, Working Set Mutex held.</span>
00488 <span class="comment"></span>
00489 <span class="comment">--*/</span>
00490 {
00491     <a class="code" href="../../d1/d8/struct__MMWSLE.html">PMMWSLE</a> Wsle;
00492     PVOID VirtualAddress;
00493     <a class="code" href="../../d3/d8/struct__MMWSLE__HASH.html">PMMWSLE_HASH</a> Table;
00494     ULONG Hash;
00495     ULONG Tries;
00496 
00497     Wsle = WorkingSetList-&gt;Wsle;
00498 
00499     <span class="comment">//</span>
00500     <span class="comment">// Locate the entry in the tree.</span>
00501     <span class="comment">//</span>
00502 
00503 <span class="preprocessor">#if DBG</span>
00504 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (MmDebug &amp; <a class="code" href="../../d4/d8/mi_8h.html#a57">MM_DBG_PTE_UPDATE</a>) {
00505         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"removing wsle %lx   %lx\n"</span>,
00506             Entry, Wsle[Entry].u1.<a class="code" href="../../d1/d8/struct__MMWSLE.html#o1">Long</a>);
00507     }
00508     <span class="keywordflow">if</span> (MmDebug &amp; <a class="code" href="../../d4/d8/mi_8h.html#a58">MM_DBG_DUMP_WSL</a>) {
00509         <a class="code" href="../../d4/d8/mi_8h.html#a967">MiDumpWsl</a>();
00510         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">" \n"</span>);
00511     }
00512 
00513 <span class="preprocessor">#endif //DBG</span>
00514 <span class="preprocessor"></span>
00515     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Wsle[Entry].u1.<a class="code" href="../../d1/d8/struct__MMWSLE.html#o2">e1</a>.<a class="code" href="../../d4/d8/struct__MMWSLENTRY.html#o0">Valid</a> == 1);
00516 
00517     VirtualAddress = <a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a> (Wsle[Entry].u1.<a class="code" href="../../d1/d8/struct__MMWSLE.html#o0">VirtualAddress</a>);
00518 
00519     <span class="keywordflow">if</span> (WorkingSetList == <a class="code" href="../../d4/d8/mi_8h.html#a657">MmSystemCacheWorkingSetList</a>) {
00520 
00521         <span class="comment">//</span>
00522         <span class="comment">// count system space inserts and removals.</span>
00523         <span class="comment">//</span>
00524 
00525 <span class="preprocessor">#if defined(_X86_)</span>
00526 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a196">MI_IS_SYSTEM_CACHE_ADDRESS</a>(VirtualAddress)) {
00527             <a class="code" href="../../d6/d8/sysinfo_8c.html#a10">MmSystemCachePage</a> -= 1;
00528         } <span class="keywordflow">else</span>
00529 <span class="preprocessor">#endif</span>
00530 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (VirtualAddress &lt; <a class="code" href="../../d8/d5/kddata_8c.html#a11">MmSystemCacheStart</a>) {
00531             <a class="code" href="../../d6/d8/sysinfo_8c.html#a9">MmSystemCodePage</a> -= 1;
00532         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (VirtualAddress &lt; <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a21">MM_PAGED_POOL_START</a>) {
00533             <a class="code" href="../../d6/d8/sysinfo_8c.html#a10">MmSystemCachePage</a> -= 1;
00534         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (VirtualAddress &lt; <a class="code" href="../../d8/d5/kddata_8c.html#a22">MmNonPagedSystemStart</a>) {
00535             <a class="code" href="../../d6/d8/sysinfo_8c.html#a11">MmPagedPoolPage</a> -= 1;
00536         } <span class="keywordflow">else</span> {
00537             <a class="code" href="../../d6/d8/sysinfo_8c.html#a12">MmSystemDriverPage</a> -= 1;
00538         }
00539     }
00540 
00541     Wsle[Entry].<a class="code" href="../../d1/d8/struct__MMWSLE.html#o3">u1</a>.e1.Valid = 0;
00542 
00543     <span class="keywordflow">if</span> (Wsle[Entry].<a class="code" href="../../d1/d8/struct__MMWSLE.html#o3">u1</a>.e1.Direct == 0) {
00544 
00545         WorkingSetList-&gt;NonDirectCount -= 1;
00546 
00547         <span class="keywordflow">if</span> (WorkingSetList-&gt;HashTable) {
00548             Hash = <a class="code" href="../../d4/d8/mi_8h.html#a191">MI_WSLE_HASH</a>(Wsle[Entry].u1.<a class="code" href="../../d1/d8/struct__MMWSLE.html#o1">Long</a>, WorkingSetList);
00549             Table = WorkingSetList-&gt;HashTable;
00550             Tries = 0;
00551 
00552             <span class="keywordflow">while</span> (Table[Hash].<a class="code" href="../../d3/d8/struct__MMWSLE__HASH.html#o0">Key</a> != (ULONG_PTR)VirtualAddress) {
00553                 Hash += 1;
00554                 <span class="keywordflow">if</span> (Hash &gt;= WorkingSetList-&gt;HashTableSize) {
00555                     Hash = 0;
00556                     <span class="keywordflow">if</span> (Tries != 0) {
00557                         <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a> (MEMORY_MANAGEMENT,
00558                                       0x41784,
00559                                       (ULONG_PTR)VirtualAddress,
00560                                       Entry,
00561                                       (ULONG_PTR)WorkingSetList);
00562                     }
00563                     Tries = 1;
00564                 }
00565             }
00566             Table[Hash].<a class="code" href="../../d3/d8/struct__MMWSLE__HASH.html#o0">Key</a> = 0;
00567 
00568         }
00569     }
00570 
00571     <span class="keywordflow">return</span>;
00572 }
00573 
00574 
00575 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00576"></a><a class="code" href="../../d7/d0/wstree_8c.html#a9">00576</a> <a class="code" href="../../d7/d0/wstree_8c.html#a9">MiSwapWslEntries</a> (
00577     IN WSLE_NUMBER SwapEntry,
00578     IN WSLE_NUMBER Entry,
00579     IN <a class="code" href="../../d3/d6/struct__MMSUPPORT.html">PMMSUPPORT</a> WsInfo
00580     )
00581 
00582 <span class="comment">/*++</span>
00583 <span class="comment"></span>
00584 <span class="comment">Routine Description:</span>
00585 <span class="comment"></span>
00586 <span class="comment">    This routine swaps the working set list entries Entry and SwapEntry</span>
00587 <span class="comment">    in the specified working set list (process or system cache).</span>
00588 <span class="comment"></span>
00589 <span class="comment">Arguments:</span>
00590 <span class="comment"></span>
00591 <span class="comment">    SwapEntry - Supplies the first entry to swap.  This entry must be</span>
00592 <span class="comment">                valid, i.e. in the working set at the current time.</span>
00593 <span class="comment"></span>
00594 <span class="comment">    Entry - Supplies the other entry to swap.  This entry may be valid</span>
00595 <span class="comment">            or invalid.</span>
00596 <span class="comment"></span>
00597 <span class="comment">    WsInfo - Supplies the working set list.</span>
00598 <span class="comment"></span>
00599 <span class="comment">Return Value:</span>
00600 <span class="comment"></span>
00601 <span class="comment">    None.</span>
00602 <span class="comment"></span>
00603 <span class="comment">Environment:</span>
00604 <span class="comment"></span>
00605 <span class="comment">    Kernel mode, Working set lock and PFN lock held (if system cache),</span>
00606 <span class="comment">                 APCs disabled.</span>
00607 <span class="comment"></span>
00608 <span class="comment">--*/</span>
00609 
00610 {
00611     <a class="code" href="../../d1/d8/struct__MMWSLE.html">MMWSLE</a> WsleEntry;
00612     <a class="code" href="../../d1/d8/struct__MMWSLE.html">MMWSLE</a> WsleSwap;
00613     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
00614     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
00615     <a class="code" href="../../d1/d8/struct__MMWSLE.html">PMMWSLE</a> Wsle;
00616     <a class="code" href="../../d0/d8/struct__MMWSL.html">PMMWSL</a> WorkingSetList;
00617     <a class="code" href="../../d3/d8/struct__MMWSLE__HASH.html">PMMWSLE_HASH</a> Table;
00618 <span class="preprocessor">#if DBG</span>
00619 <span class="preprocessor"></span>    <a class="code" href="../../d4/d8/mi_8h.html#a435">WSLE_NUMBER</a> CurrentSize = WsInfo-&gt;WorkingSetSize;
00620 <span class="preprocessor">#endif //DBG</span>
00621 <span class="preprocessor"></span><span class="preprocessor">#if PFN_CONSISTENCY</span>
00622 <span class="preprocessor"></span>    KIRQL OldIrql;
00623 <span class="preprocessor">#endif</span>
00624 <span class="preprocessor"></span>
00625     WorkingSetList = WsInfo-&gt;VmWorkingSetList;
00626     Wsle = WorkingSetList-&gt;<a class="code" href="../../d0/d8/struct__MMWSL.html#o5">Wsle</a>;
00627 
00628     WsleSwap = Wsle[SwapEntry];
00629 
00630     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (WsleSwap.<a class="code" href="../../d1/d8/struct__MMWSLE.html#o3">u1</a>.e1.Valid != 0);
00631 
00632     WsleEntry = Wsle[Entry];
00633 
00634     Table = WorkingSetList-&gt;<a class="code" href="../../d0/d8/struct__MMWSL.html#o9">HashTable</a>;
00635 
00636     <span class="keywordflow">if</span> (WsleEntry.<a class="code" href="../../d1/d8/struct__MMWSLE.html#o3">u1</a>.e1.Valid == 0) {
00637 
00638         <span class="comment">//</span>
00639         <span class="comment">// Entry is not on any list. Remove it from the free list.</span>
00640         <span class="comment">//</span>
00641 
00642         <a class="code" href="../../d7/d0/wstree_8c.html#a10">MiRemoveWsleFromFreeList</a> (Entry, Wsle, WorkingSetList);
00643 
00644         <span class="comment">//</span>
00645         <span class="comment">// Copy the Entry to this free one.</span>
00646         <span class="comment">//</span>
00647 
00648         Wsle[Entry] = WsleSwap;
00649 
00650         PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (WsleSwap.u1.VirtualAddress);
00651 
00652         <span class="keywordflow">if</span> (WsleSwap.u1.e1.Direct) {
00653             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
00654 <span class="preprocessor">#if PFN_CONSISTENCY</span>
00655 <span class="preprocessor"></span>            OldIrql = 99;
00656             <span class="keywordflow">if</span> (PFN_LOCK_OWNED_BY_ME() == 0) {
00657                 <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
00658             }
00659 <span class="preprocessor">#endif</span>
00660 <span class="preprocessor"></span>            Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.WsIndex = Entry;
00661 <span class="preprocessor">#if PFN_CONSISTENCY</span>
00662 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (OldIrql != 99) {
00663                 <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
00664             }
00665 <span class="preprocessor">#endif</span>
00666 <span class="preprocessor"></span>        } <span class="keywordflow">else</span> {
00667 
00668             <span class="comment">//</span>
00669             <span class="comment">// Update hash table.</span>
00670             <span class="comment">//</span>
00671 
00672             <span class="keywordflow">if</span> (Table) {
00673                 Table [ <a class="code" href="../../d7/d0/wstree_8c.html#a4">MiLookupWsleHashIndex</a> (WsleSwap.u1.Long,
00674                                            WorkingSetList)].<a class="code" href="../../d3/d8/struct__MMWSLE__HASH.html#o1">Index</a> = Entry;
00675             }
00676         }
00677 
00678         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a109">MI_SET_PTE_IN_WORKING_SET</a> (PointerPte, Entry);
00679 
00680         <span class="comment">//</span>
00681         <span class="comment">// Put entry on free list.</span>
00682         <span class="comment">//</span>
00683 
00684         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (WorkingSetList-&gt;<a class="code" href="../../d0/d8/struct__MMWSL.html#o1">FirstFree</a> &lt;= WorkingSetList-&gt;<a class="code" href="../../d0/d8/struct__MMWSL.html#o7">LastInitializedWsle</a>);
00685         Wsle[SwapEntry].u1.Long = WorkingSetList-&gt;<a class="code" href="../../d0/d8/struct__MMWSL.html#o1">FirstFree</a> &lt;&lt; <a class="code" href="../../d4/d8/mi_8h.html#a9">MM_FREE_WSLE_SHIFT</a>;
00686         WorkingSetList-&gt;<a class="code" href="../../d0/d8/struct__MMWSL.html#o1">FirstFree</a> = SwapEntry;
00687         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((WorkingSetList-&gt;<a class="code" href="../../d0/d8/struct__MMWSL.html#o1">FirstFree</a> &lt;= WorkingSetList-&gt;<a class="code" href="../../d0/d8/struct__MMWSL.html#o7">LastInitializedWsle</a>) ||
00688             (WorkingSetList-&gt;<a class="code" href="../../d0/d8/struct__MMWSL.html#o1">FirstFree</a> == <a class="code" href="../../d4/d8/mi_8h.html#a10">WSLE_NULL_INDEX</a>));
00689 
00690     } <span class="keywordflow">else</span> {
00691 
00692         <span class="comment">//</span>
00693         <span class="comment">// Both entries are valid.</span>
00694         <span class="comment">//</span>
00695 
00696         Wsle[SwapEntry] = WsleEntry;
00697 
00698         PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (WsleEntry.u1.VirtualAddress);
00699 
00700         <span class="keywordflow">if</span> (WsleEntry.u1.e1.Direct) {
00701 
00702             <span class="comment">//</span>
00703             <span class="comment">// Swap the PFN WsIndex element to point to the new slot.</span>
00704             <span class="comment">//</span>
00705 
00706             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
00707 <span class="preprocessor">#if PFN_CONSISTENCY</span>
00708 <span class="preprocessor"></span>            OldIrql = 99;
00709             <span class="keywordflow">if</span> (PFN_LOCK_OWNED_BY_ME() == 0) {
00710                 <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
00711             }
00712 <span class="preprocessor">#endif</span>
00713 <span class="preprocessor"></span>            Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.WsIndex = SwapEntry;
00714 <span class="preprocessor">#if PFN_CONSISTENCY</span>
00715 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (OldIrql != 99) {
00716                 <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
00717             }
00718 <span class="preprocessor">#endif</span>
00719 <span class="preprocessor"></span>        } <span class="keywordflow">else</span> {
00720 
00721             <span class="comment">//</span>
00722             <span class="comment">// Update hash table.</span>
00723             <span class="comment">//</span>
00724 
00725             <span class="keywordflow">if</span> (Table) {
00726                 Table[ <a class="code" href="../../d7/d0/wstree_8c.html#a4">MiLookupWsleHashIndex</a> (WsleEntry.u1.Long,
00727                                            WorkingSetList)].<a class="code" href="../../d3/d8/struct__MMWSLE__HASH.html#o1">Index</a> = SwapEntry;
00728             }
00729         }
00730 
00731         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a109">MI_SET_PTE_IN_WORKING_SET</a> (PointerPte, SwapEntry);
00732 
00733         Wsle[Entry] = WsleSwap;
00734 
00735         PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (WsleSwap.u1.VirtualAddress);
00736 
00737         <span class="keywordflow">if</span> (WsleSwap.u1.e1.Direct) {
00738 
00739             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
00740 <span class="preprocessor">#if PFN_CONSISTENCY</span>
00741 <span class="preprocessor"></span>            OldIrql = 99;
00742             <span class="keywordflow">if</span> (PFN_LOCK_OWNED_BY_ME() == 0) {
00743                 <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
00744             }
00745 <span class="preprocessor">#endif</span>
00746 <span class="preprocessor"></span>            Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.WsIndex = Entry;
00747 <span class="preprocessor">#if PFN_CONSISTENCY</span>
00748 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (OldIrql != 99) {
00749                 <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
00750             }
00751 <span class="preprocessor">#endif</span>
00752 <span class="preprocessor"></span>        } <span class="keywordflow">else</span> {
00753             <span class="keywordflow">if</span> (Table) {
00754                 Table[ <a class="code" href="../../d7/d0/wstree_8c.html#a4">MiLookupWsleHashIndex</a> (WsleSwap.u1.Long,
00755                                            WorkingSetList)].<a class="code" href="../../d3/d8/struct__MMWSLE__HASH.html#o1">Index</a> = Entry;
00756             }
00757         }
00758         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a109">MI_SET_PTE_IN_WORKING_SET</a> (PointerPte, Entry);
00759     }
00760     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (CurrentSize == WsInfo-&gt;WorkingSetSize);
00761     <span class="keywordflow">return</span>;
00762 }
00763 
00764 ULONG
<a name="l00765"></a><a class="code" href="../../d7/d0/wstree_8c.html#a4">00765</a> <a class="code" href="../../d7/d0/wstree_8c.html#a4">MiLookupWsleHashIndex</a> (
00766     IN ULONG_PTR WsleEntry,
00767     IN <a class="code" href="../../d0/d8/struct__MMWSL.html">PMMWSL</a> WorkingSetList
00768     )
00769 
00770 {
00771     ULONG Hash;
00772     ULONG_PTR VirtualAddress;
00773     <a class="code" href="../../d3/d8/struct__MMWSLE__HASH.html">PMMWSLE_HASH</a> Table;
00774     ULONG Tries = 0;
00775 
00776     Table = WorkingSetList-&gt;HashTable;
00777     VirtualAddress = WsleEntry &amp; ~(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1);
00778 
00779     Hash = <a class="code" href="../../d4/d8/mi_8h.html#a191">MI_WSLE_HASH</a>(WsleEntry, WorkingSetList);
00780 
00781     <span class="keywordflow">while</span> (Table[Hash].<a class="code" href="../../d3/d8/struct__MMWSLE__HASH.html#o0">Key</a> != (ULONG_PTR)VirtualAddress) {
00782         Hash += 1;
00783         <span class="keywordflow">if</span> (Hash &gt;= WorkingSetList-&gt;HashTableSize) {
00784             Hash = 0;
00785             <span class="keywordflow">if</span> (Tries != 0) {
00786                 <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a> (MEMORY_MANAGEMENT,
00787                               0x41884,
00788                               (ULONG_PTR)VirtualAddress,
00789                               WsleEntry,
00790                               (ULONG_PTR)WorkingSetList);
00791             }
00792             Tries = 1;
00793         }
00794     }
00795     <span class="keywordflow">return</span> Hash;
00796 }
00797 
00798 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00799"></a><a class="code" href="../../d7/d0/wstree_8c.html#a10">00799</a> <a class="code" href="../../d7/d0/wstree_8c.html#a10">MiRemoveWsleFromFreeList</a> (
00800     IN ULONG Entry,
00801     IN <a class="code" href="../../d1/d8/struct__MMWSLE.html">PMMWSLE</a> Wsle,
00802     IN <a class="code" href="../../d0/d8/struct__MMWSL.html">PMMWSL</a> WorkingSetList
00803     )
00804 
00805 <span class="comment">/*++</span>
00806 <span class="comment"></span>
00807 <span class="comment">Routine Description:</span>
00808 <span class="comment"></span>
00809 <span class="comment">    This routine removes a working set list entry from the free list.</span>
00810 <span class="comment">    It is used when the entry required is not the first element</span>
00811 <span class="comment">    in the free list.</span>
00812 <span class="comment"></span>
00813 <span class="comment">Arguments:</span>
00814 <span class="comment"></span>
00815 <span class="comment">    Entry - Supplies the index of the entry to remove.</span>
00816 <span class="comment"></span>
00817 <span class="comment">    Wsle - Supplies a pointer to the array of WSLEs.</span>
00818 <span class="comment"></span>
00819 <span class="comment">    WorkingSetList - Supplies a pointer to the working set list.</span>
00820 <span class="comment"></span>
00821 <span class="comment">Return Value:</span>
00822 <span class="comment"></span>
00823 <span class="comment">    None.</span>
00824 <span class="comment"></span>
00825 <span class="comment">Environment:</span>
00826 <span class="comment"></span>
00827 <span class="comment">    Kernel mode, Working set lock and PFN lock held, APCs disabled.</span>
00828 <span class="comment"></span>
00829 <span class="comment">--*/</span>
00830 
00831 {
00832     <a class="code" href="../../d4/d8/mi_8h.html#a435">WSLE_NUMBER</a> Free;
00833     <a class="code" href="../../d4/d8/mi_8h.html#a435">WSLE_NUMBER</a> ParentFree;
00834 
00835     Free = WorkingSetList-&gt;FirstFree;
00836 
00837     <span class="keywordflow">if</span> (Entry == Free) {
00838         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((Wsle[Entry].u1.Long &gt;&gt; <a class="code" href="../../d4/d8/mi_8h.html#a9">MM_FREE_WSLE_SHIFT</a>) &lt;= WorkingSetList-&gt;LastInitializedWsle);
00839         WorkingSetList-&gt;FirstFree = (<a class="code" href="../../d4/d8/mi_8h.html#a435">WSLE_NUMBER</a>)(Wsle[Entry].u1.Long &gt;&gt; <a class="code" href="../../d4/d8/mi_8h.html#a9">MM_FREE_WSLE_SHIFT</a>);
00840 
00841     } <span class="keywordflow">else</span> {
00842         <span class="keywordflow">do</span> {
00843             ParentFree = Free;
00844             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Wsle[Free].u1.e1.Valid == 0);
00845             Free = (<a class="code" href="../../d4/d8/mi_8h.html#a435">WSLE_NUMBER</a>)(Wsle[Free].u1.Long &gt;&gt; <a class="code" href="../../d4/d8/mi_8h.html#a9">MM_FREE_WSLE_SHIFT</a>);
00846         } <span class="keywordflow">while</span> (Free != Entry);
00847 
00848         Wsle[ParentFree].u1.Long = Wsle[Entry].u1.Long;
00849     }
00850     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((WorkingSetList-&gt;FirstFree &lt;= WorkingSetList-&gt;LastInitializedWsle) ||
00851             (WorkingSetList-&gt;FirstFree == <a class="code" href="../../d4/d8/mi_8h.html#a10">WSLE_NULL_INDEX</a>));
00852     <span class="keywordflow">return</span>;
00853 }
00854 
00855 
00856 <span class="preprocessor">#if 0</span>
00857 <span class="preprocessor"></span>
00858 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00859 <a class="code" href="../../d7/d0/wstree_8c.html#a9">MiSwapWslEntries</a> (
00860     IN ULONG Entry,
00861     IN ULONG Parent,
00862     IN ULONG SwapEntry,
00863     IN <a class="code" href="../../d0/d8/struct__MMWSL.html">PMMWSL</a> WorkingSetList
00864     )
00865 
00866 <span class="comment">/*++</span>
00867 <span class="comment"></span>
00868 <span class="comment">Routine Description:</span>
00869 <span class="comment"></span>
00870 <span class="comment">    This function swaps the specified entry and updates its parent with</span>
00871 <span class="comment">    the specified swap entry.</span>
00872 <span class="comment"></span>
00873 <span class="comment">    The entry must be valid, i.e., the page is resident.  The swap entry</span>
00874 <span class="comment">    can be valid or on the free list.</span>
00875 <span class="comment"></span>
00876 <span class="comment">Arguments:</span>
00877 <span class="comment"></span>
00878 <span class="comment">    Entry - The index of the WSLE to swap.</span>
00879 <span class="comment"></span>
00880 <span class="comment">    Parent - The index of the parent of the WSLE to swap.</span>
00881 <span class="comment"></span>
00882 <span class="comment">    SwapEntry - The index to swap the entry with.</span>
00883 <span class="comment"></span>
00884 <span class="comment">Return Value:</span>
00885 <span class="comment"></span>
00886 <span class="comment">    None.</span>
00887 <span class="comment"></span>
00888 <span class="comment">Environment:</span>
00889 <span class="comment"></span>
00890 <span class="comment">    Kernel mode, working set mutex held, APCs disabled.</span>
00891 <span class="comment"></span>
00892 <span class="comment">--*/</span>
00893 
00894 {
00895 
00896     ULONG SwapParent;
00897     ULONG SavedRight;
00898     ULONG SavedLeft;
00899     ULONG Free;
00900     ULONG ParentFree;
00901     ULONG SavedLong;
00902     PVOID VirtualAddress;
00903     <a class="code" href="../../d1/d8/struct__MMWSLE.html">PMMWSLE</a> Wsle;
00904     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
00905     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
00906 
00907     Wsle = WorkingSetList-&gt;Wsle;
00908 
00909     <span class="keywordflow">if</span> (Wsle[SwapEntry].<a class="code" href="../../d1/d8/struct__MMWSLE.html#o3">u1</a>.e1.Valid == 0) {
00910 
00911         <span class="comment">//</span>
00912         <span class="comment">// This entry is not in use and must be removed from</span>
00913         <span class="comment">// the free list.</span>
00914         <span class="comment">//</span>
00915 
00916         Free = WorkingSetList-&gt;FirstFree;
00917 
00918         <span class="keywordflow">if</span> (SwapEntry == Free) {
00919             WorkingSetList-&gt;FirstFree = Entry;
00920             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((WorkingSetList-&gt;FirstFree &lt;= WorkingSetList-&gt;LastInitializedWsle) ||
00921                 (WorkingSetList-&gt;FirstFree == WSLE_NULL_INDEX));
00922 
00923         } <span class="keywordflow">else</span> {
00924 
00925             <span class="keywordflow">while</span> (Free != SwapEntry) {
00926                 ParentFree = Free;
00927                 Free = Wsle[Free].u2.s.LeftChild;
00928             }
00929 
00930             Wsle[ParentFree].u2.s.LeftChild = Entry;
00931         }
00932 
00933         <span class="comment">//</span>
00934         <span class="comment">// Swap the previous entry and the new unused entry.</span>
00935         <span class="comment">//</span>
00936 
00937         SavedLeft = Wsle[Entry].u2.s.LeftChild;
00938         Wsle[Entry].u2.s.LeftChild = Wsle[SwapEntry].u2.s.LeftChild;
00939         Wsle[SwapEntry].u2.s.LeftChild = SavedLeft;
00940         Wsle[SwapEntry].u2.s.RightChild = Wsle[Entry].u2.s.RightChild;
00941         Wsle[SwapEntry].<a class="code" href="../../d1/d8/struct__MMWSLE.html#o3">u1</a>.Long = Wsle[Entry].u1.Long;
00942         Wsle[Entry].u1.Long = 0;
00943 
00944         <span class="comment">//</span>
00945         <span class="comment">// Make the parent point to the new entry.</span>
00946         <span class="comment">//</span>
00947 
00948         <span class="keywordflow">if</span> (Parent == <a class="code" href="../../d4/d8/mi_8h.html#a10">WSLE_NULL_INDEX</a>) {
00949 
00950             <span class="comment">//</span>
00951             <span class="comment">// This entry is not in the tree.</span>
00952             <span class="comment">//</span>
00953 
00954             PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (Wsle[SwapEntry].u1.VirtualAddress);
00955             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
00956             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.WsIndex = SwapEntry;
00957             <span class="keywordflow">return</span>;
00958         }
00959 
00960         <span class="keywordflow">if</span> (Parent == Entry) {
00961 
00962             <span class="comment">//</span>
00963             <span class="comment">// This element is the root, update the root pointer.</span>
00964             <span class="comment">//</span>
00965 
00966             WorkingSetList-&gt;Root = SwapEntry;
00967 
00968         } <span class="keywordflow">else</span> {
00969 
00970             <span class="keywordflow">if</span> (Wsle[Parent].u2.s.LeftChild == Entry) {
00971                 Wsle[Parent].u2.s.LeftChild = SwapEntry;
00972             } <span class="keywordflow">else</span> {
00973                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Wsle[Parent].u2.s.RightChild == Entry);
00974 
00975                 Wsle[Parent].u2.s.RightChild = SwapEntry;
00976             }
00977         }
00978 
00979     } <span class="keywordflow">else</span> {
00980 
00981         <span class="keywordflow">if</span> ((Parent == <a class="code" href="../../d4/d8/mi_8h.html#a10">WSLE_NULL_INDEX</a>) &amp;&amp;
00982             (Wsle[SwapEntry].u2.BothPointers == 0)) {
00983 
00984             <span class="comment">//</span>
00985             <span class="comment">// Neither entry is in the tree, just swap their pointers.</span>
00986             <span class="comment">//</span>
00987 
00988             SavedLong = Wsle[SwapEntry].<a class="code" href="../../d1/d8/struct__MMWSLE.html#o3">u1</a>.Long;
00989             Wsle[SwapEntry].u1.Long = Wsle[Entry].u1.Long;
00990             Wsle[Entry].u1.Long = SavedLong;
00991 
00992             PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (Wsle[Entry].u1.VirtualAddress);
00993             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
00994             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.WsIndex = Entry;
00995 
00996             PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (Wsle[SwapEntry].u1.VirtualAddress);
00997             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
00998             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.WsIndex = SwapEntry;
00999 
01000             <span class="keywordflow">return</span>;
01001         }
01002 
01003         <span class="comment">//</span>
01004         <span class="comment">// The entry at FirstDynamic is valid; swap it with this one and</span>
01005         <span class="comment">// update both parents.</span>
01006         <span class="comment">//</span>
01007 
01008         SwapParent = WorkingSetList-&gt;Root;
01009 
01010         <span class="keywordflow">if</span> (SwapParent == SwapEntry) {
01011 
01012             <span class="comment">//</span>
01013             <span class="comment">// The entry we are swapping with is at the root.</span>
01014             <span class="comment">//</span>
01015 
01016             <span class="keywordflow">if</span> (Wsle[SwapEntry].u2.s.LeftChild == Entry) {
01017 
01018                 <span class="comment">//</span>
01019                 <span class="comment">// The entry we are going to swap is the left child of this</span>
01020                 <span class="comment">// entry.</span>
01021                 <span class="comment">//</span>
01022                 <span class="comment">//              R(SwapEntry)</span>
01023                 <span class="comment">//             / \</span>
01024                 <span class="comment">//      (entry)</span>
01025                 <span class="comment">//</span>
01026 
01027                 WorkingSetList-&gt;Root = Entry;
01028 
01029                 Wsle[SwapEntry].u2.s.LeftChild = Wsle[Entry].u2.s.LeftChild;
01030                 Wsle[Entry].u2.s.LeftChild = SwapEntry;
01031                 SavedRight = Wsle[SwapEntry].u2.s.RightChild;
01032                 Wsle[SwapEntry].u2.s.RightChild = Wsle[Entry].u2.s.RightChild;
01033                 Wsle[Entry].u2.s.RightChild = SavedRight;
01034 
01035                 SavedLong = Wsle[Entry].<a class="code" href="../../d1/d8/struct__MMWSLE.html#o3">u1</a>.Long;
01036                 Wsle[Entry].u1.Long = Wsle[SwapEntry].u1.Long;
01037                 Wsle[SwapEntry].u1.Long = SavedLong;
01038 
01039                 <span class="keywordflow">return</span>;
01040 
01041             } <span class="keywordflow">else</span> {
01042 
01043                 <span class="keywordflow">if</span> (Wsle[SwapEntry].u2.s.RightChild == Entry) {
01044 
01045                     <span class="comment">//</span>
01046                     <span class="comment">// The entry we are going to swap is the right child of this</span>
01047                     <span class="comment">// entry.</span>
01048                     <span class="comment">//</span>
01049                     <span class="comment">//              R(SwapEntry)</span>
01050                     <span class="comment">//             / \</span>
01051                     <span class="comment">//                (entry)</span>
01052                     <span class="comment">//</span>
01053 
01054                     WorkingSetList-&gt;Root = Entry;
01055 
01056                     Wsle[SwapEntry].u2.s.RightChild = Wsle[Entry].u2.s.RightChild;
01057                     Wsle[Entry].u2.s.RightChild = SwapEntry;
01058                     SavedLeft = Wsle[SwapEntry].u2.s.LeftChild;
01059                     Wsle[SwapEntry].u2.s.LeftChild = Wsle[Entry].u2.s.LeftChild;
01060                     Wsle[Entry].u2.s.LeftChild = SavedLeft;
01061 
01062 
01063                     SavedLong = Wsle[Entry].<a class="code" href="../../d1/d8/struct__MMWSLE.html#o3">u1</a>.Long;
01064                     Wsle[Entry].u1.Long = Wsle[SwapEntry].u1.Long;
01065                     Wsle[SwapEntry].u1.Long = SavedLong;
01066 
01067                     <span class="keywordflow">return</span>;
01068                 }
01069             }
01070 
01071             <span class="comment">//</span>
01072             <span class="comment">// The swap entry is the root, but the other entry is not</span>
01073             <span class="comment">// its child.</span>
01074             <span class="comment">//</span>
01075             <span class="comment">//</span>
01076             <span class="comment">//              R(SwapEntry)</span>
01077             <span class="comment">//             / \</span>
01078             <span class="comment">//            .....</span>
01079             <span class="comment">//                 Parent(Entry)</span>
01080             <span class="comment">//                  \</span>
01081             <span class="comment">//                   Entry (left or right)</span>
01082             <span class="comment">//</span>
01083             <span class="comment">//</span>
01084 
01085             WorkingSetList-&gt;Root = Entry;
01086 
01087             SavedRight = Wsle[SwapEntry].u2.s.RightChild;
01088             Wsle[SwapEntry].u2.s.RightChild = Wsle[Entry].u2.s.RightChild;
01089             Wsle[Entry].u2.s.RightChild = SavedRight;
01090             SavedLeft = Wsle[SwapEntry].u2.s.LeftChild;
01091             Wsle[SwapEntry].u2.s.LeftChild = Wsle[Entry].u2.s.LeftChild;
01092             Wsle[Entry].u2.s.LeftChild = SavedLeft;
01093 
01094             SavedLong = Wsle[Entry].<a class="code" href="../../d1/d8/struct__MMWSLE.html#o3">u1</a>.Long;
01095             Wsle[Entry].u1.Long = Wsle[SwapEntry].u1.Long;
01096             Wsle[SwapEntry].u1.Long = SavedLong;
01097 
01098             <span class="keywordflow">if</span> (Parent == <a class="code" href="../../d4/d8/mi_8h.html#a10">WSLE_NULL_INDEX</a>) {
01099 
01100                 <span class="comment">//</span>
01101                 <span class="comment">// This entry is not in the tree.</span>
01102                 <span class="comment">//</span>
01103 
01104                 PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (Wsle[SwapEntry].u1.VirtualAddress);
01105                 Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
01106                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.WsIndex = SwapEntry;
01107                 <span class="keywordflow">return</span>;
01108             }
01109 
01110             <span class="comment">//</span>
01111             <span class="comment">// Change the parent of the entry to point to the swap entry.</span>
01112             <span class="comment">//</span>
01113 
01114             <span class="keywordflow">if</span> (Wsle[Parent].u2.s.RightChild == Entry) {
01115                 Wsle[Parent].u2.s.RightChild = SwapEntry;
01116             } <span class="keywordflow">else</span> {
01117                 Wsle[Parent].u2.s.LeftChild = SwapEntry;
01118             }
01119 
01120             <span class="keywordflow">return</span>;
01121 
01122         }
01123 
01124         <span class="comment">//</span>
01125         <span class="comment">// The SwapEntry is not the root, find its parent.</span>
01126         <span class="comment">//</span>
01127 
01128         <span class="keywordflow">if</span> (Wsle[SwapEntry].u2.BothPointers == 0) {
01129 
01130             <span class="comment">//</span>
01131             <span class="comment">// Entry is not in tree, therefore no parent.</span>
01132 
01133             SwapParent = <a class="code" href="../../d4/d8/mi_8h.html#a10">WSLE_NULL_INDEX</a>;
01134 
01135         } <span class="keywordflow">else</span> {
01136 
01137             VirtualAddress = <a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a>(Wsle[SwapEntry].u1.VirtualAddress);
01138 
01139             <span class="keywordflow">for</span> (;;) {
01140 
01141                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (SwapParent != WSLE_NULL_INDEX);
01142 
01143                 <span class="keywordflow">if</span> (Wsle[SwapParent].u2.s.LeftChild == SwapEntry) {
01144                     <span class="keywordflow">break</span>;
01145                 }
01146                 <span class="keywordflow">if</span> (Wsle[SwapParent].u2.s.RightChild == SwapEntry) {
01147                     <span class="keywordflow">break</span>;
01148                 }
01149 
01150 
01151                 <span class="keywordflow">if</span> (VirtualAddress &lt; <a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a>(Wsle[SwapParent].u1.VirtualAddress)) {
01152                     SwapParent = Wsle[SwapParent].u2.s.LeftChild;
01153                 } <span class="keywordflow">else</span> {
01154                     SwapParent = Wsle[SwapParent].u2.s.RightChild;
01155                 }
01156             }
01157         }
01158 
01159         <span class="keywordflow">if</span> (Parent == WorkingSetList-&gt;Root) {
01160 
01161             <span class="comment">//</span>
01162             <span class="comment">// The entry is at the root.</span>
01163             <span class="comment">//</span>
01164 
01165             <span class="keywordflow">if</span> (Wsle[Entry].u2.s.LeftChild == SwapEntry) {
01166 
01167                 <span class="comment">//</span>
01168                 <span class="comment">// The entry we are going to swap is the left child of this</span>
01169                 <span class="comment">// entry.</span>
01170                 <span class="comment">//</span>
01171                 <span class="comment">//              R(Entry)</span>
01172                 <span class="comment">//             / \</span>
01173                 <span class="comment">//  (SwapEntry)</span>
01174                 <span class="comment">//</span>
01175 
01176                 WorkingSetList-&gt;Root = SwapEntry;
01177 
01178                 Wsle[Entry].u2.s.LeftChild = Wsle[SwapEntry].u2.s.LeftChild;
01179                 Wsle[SwapEntry].u2.s.LeftChild = Entry;
01180                 SavedRight = Wsle[Entry].u2.s.RightChild;
01181                 Wsle[Entry].u2.s.RightChild = Wsle[SwapEntry].u2.s.RightChild;
01182                 Wsle[SwapEntry].u2.s.RightChild = SavedRight;
01183 
01184                 SavedLong = Wsle[Entry].<a class="code" href="../../d1/d8/struct__MMWSLE.html#o3">u1</a>.Long;
01185                 Wsle[Entry].u1.Long = Wsle[SwapEntry].u1.Long;
01186                 Wsle[SwapEntry].u1.Long = SavedLong;
01187 
01188                 <span class="keywordflow">return</span>;
01189 
01190             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Wsle[SwapEntry].u2.s.RightChild == Entry) {
01191 
01192                 <span class="comment">//</span>
01193                 <span class="comment">// The entry we are going to swap is the right child of this</span>
01194                 <span class="comment">// entry.</span>
01195                 <span class="comment">//</span>
01196                 <span class="comment">//              R(SwapEntry)</span>
01197                 <span class="comment">//             / \</span>
01198                 <span class="comment">//                (entry)</span>
01199                 <span class="comment">//</span>
01200 
01201                 WorkingSetList-&gt;Root = Entry;
01202 
01203                 Wsle[SwapEntry].u2.s.RightChild = Wsle[Entry].u2.s.RightChild;
01204                 Wsle[Entry].u2.s.RightChild = SwapEntry;
01205                 SavedLeft = Wsle[SwapEntry].u2.s.LeftChild;
01206                 Wsle[SwapEntry].u2.s.LeftChild = Wsle[Entry].u2.s.LeftChild;
01207                 Wsle[Entry].u2.s.LeftChild = SavedLeft;
01208 
01209 
01210                 SavedLong = Wsle[Entry].<a class="code" href="../../d1/d8/struct__MMWSLE.html#o3">u1</a>.Long;
01211                 Wsle[Entry].u1.Long = Wsle[SwapEntry].u1.Long;
01212                 Wsle[SwapEntry].u1.Long = SavedLong;
01213 
01214                 <span class="keywordflow">return</span>;
01215             }
01216 
01217             <span class="comment">//</span>
01218             <span class="comment">// The swap entry is the root, but the other entry is not</span>
01219             <span class="comment">// its child.</span>
01220             <span class="comment">//</span>
01221             <span class="comment">//</span>
01222             <span class="comment">//              R(SwapEntry)</span>
01223             <span class="comment">//             / \</span>
01224             <span class="comment">//            .....</span>
01225             <span class="comment">//                 Parent(Entry)</span>
01226             <span class="comment">//                  \</span>
01227             <span class="comment">//                   Entry (left or right)</span>
01228             <span class="comment">//</span>
01229             <span class="comment">//</span>
01230 
01231             WorkingSetList-&gt;Root = Entry;
01232 
01233             SavedRight = Wsle[SwapEntry].u2.s.RightChild;
01234             Wsle[SwapEntry].u2.s.RightChild = Wsle[Entry].u2.s.RightChild;
01235             Wsle[Entry].u2.s.RightChild = SavedRight;
01236             SavedLeft = Wsle[SwapEntry].u2.s.LeftChild;
01237             Wsle[SwapEntry].u2.s.LeftChild = Wsle[Entry].u2.s.LeftChild;
01238             Wsle[Entry].u2.s.LeftChild = SavedLeft;
01239 
01240             SavedLong = Wsle[Entry].<a class="code" href="../../d1/d8/struct__MMWSLE.html#o3">u1</a>.Long;
01241             Wsle[Entry].u1.Long = Wsle[SwapEntry].u1.Long;
01242             Wsle[SwapEntry].u1.Long = SavedLong;
01243 
01244             <span class="keywordflow">if</span> (SwapParent == <a class="code" href="../../d4/d8/mi_8h.html#a10">WSLE_NULL_INDEX</a>) {
01245 
01246                 <span class="comment">//</span>
01247                 <span class="comment">// This entry is not in the tree.</span>
01248                 <span class="comment">//</span>
01249 
01250                 PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (Wsle[Entry].u1.VirtualAddress);
01251                 Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
01252                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.WsIndex == SwapEntry);
01253                 Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.WsIndex = Entry;
01254                 <span class="keywordflow">return</span>;
01255             }
01256 
01257             <span class="comment">//</span>
01258             <span class="comment">// Change the parent of the entry to point to the swap entry.</span>
01259             <span class="comment">//</span>
01260 
01261             <span class="keywordflow">if</span> (Wsle[SwapParent].u2.s.RightChild == SwapEntry) {
01262                 Wsle[SwapParent].u2.s.RightChild = Entry;
01263             } <span class="keywordflow">else</span> {
01264                 Wsle[SwapParent].u2.s.LeftChild = Entry;
01265             }
01266 
01267             <span class="keywordflow">return</span>;
01268 
01269         }
01270 
01271         <span class="comment">//</span>
01272         <span class="comment">// Neither entry is the root.</span>
01273         <span class="comment">//</span>
01274 
01275         <span class="keywordflow">if</span> (Parent == SwapEntry) {
01276 
01277             <span class="comment">//</span>
01278             <span class="comment">// The parent of the entry is the swap entry.</span>
01279             <span class="comment">//</span>
01280             <span class="comment">//</span>
01281             <span class="comment">//              R</span>
01282             <span class="comment">//            .....</span>
01283             <span class="comment">//</span>
01284             <span class="comment">//              (SwapParent)</span>
01285             <span class="comment">//              |</span>
01286             <span class="comment">//              (SwapEntry)</span>
01287             <span class="comment">//              |</span>
01288             <span class="comment">//              (Entry)</span>
01289             <span class="comment">//</span>
01290 
01291             <span class="comment">//</span>
01292             <span class="comment">// Update the parent pointer for the swapentry.</span>
01293             <span class="comment">//</span>
01294 
01295             <span class="keywordflow">if</span> (Wsle[SwapParent].u2.s.LeftChild == SwapEntry) {
01296                 Wsle[SwapParent].u2.s.LeftChild = Entry;
01297             } <span class="keywordflow">else</span> {
01298                 Wsle[SwapParent].u2.s.RightChild = Entry;
01299             }
01300 
01301             <span class="comment">//</span>
01302             <span class="comment">// Determine if this goes left or right.</span>
01303             <span class="comment">//</span>
01304 
01305             <span class="keywordflow">if</span> (Wsle[SwapEntry].u2.s.LeftChild == Entry) {
01306 
01307                 <span class="comment">//</span>
01308                 <span class="comment">// The entry we are going to swap is the left child of this</span>
01309                 <span class="comment">// entry.</span>
01310                 <span class="comment">//</span>
01311                 <span class="comment">//              R</span>
01312                 <span class="comment">//            .....</span>
01313                 <span class="comment">//</span>
01314                 <span class="comment">//             (SwapParent)</span>
01315                 <span class="comment">//</span>
01316                 <span class="comment">//             (SwapEntry)  [Parent(entry)]</span>
01317                 <span class="comment">//            / \</span>
01318                 <span class="comment">//     (entry)</span>
01319                 <span class="comment">//</span>
01320 
01321                 Wsle[SwapEntry].u2.s.LeftChild = Wsle[Entry].u2.s.LeftChild;
01322                 Wsle[Entry].u2.s.LeftChild = SwapEntry;
01323                 SavedRight = Wsle[SwapEntry].u2.s.RightChild;
01324                 Wsle[SwapEntry].u2.s.RightChild = Wsle[Entry].u2.s.RightChild;
01325                 Wsle[Entry].u2.s.RightChild = SavedRight;
01326 
01327                 SavedLong = Wsle[Entry].<a class="code" href="../../d1/d8/struct__MMWSLE.html#o3">u1</a>.Long;
01328                 Wsle[Entry].u1.Long = Wsle[SwapEntry].u1.Long;
01329                 Wsle[SwapEntry].u1.Long = SavedLong;
01330 
01331                 <span class="keywordflow">return</span>;
01332 
01333             } <span class="keywordflow">else</span> {
01334 
01335                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Wsle[SwapEntry].u2.s.RightChild == Entry);
01336 
01337                 <span class="comment">//</span>
01338                 <span class="comment">// The entry we are going to swap is the right child of this</span>
01339                 <span class="comment">// entry.</span>
01340                 <span class="comment">//</span>
01341                 <span class="comment">//              R</span>
01342                 <span class="comment">//            .....</span>
01343                 <span class="comment">//</span>
01344                 <span class="comment">//              (SwapParent)</span>
01345                 <span class="comment">//               \</span>
01346                 <span class="comment">//                (SwapEntry)</span>
01347                 <span class="comment">//               / \</span>
01348                 <span class="comment">//                  (entry)</span>
01349                 <span class="comment">//</span>
01350 
01351                 Wsle[SwapEntry].u2.s.RightChild = Wsle[Entry].u2.s.RightChild;
01352                 Wsle[Entry].u2.s.RightChild = SwapEntry;
01353                 SavedLeft = Wsle[SwapEntry].u2.s.LeftChild;
01354                 Wsle[SwapEntry].u2.s.LeftChild = Wsle[Entry].u2.s.LeftChild;
01355                 Wsle[Entry].u2.s.LeftChild = SavedLeft;
01356 
01357 
01358                 SavedLong = Wsle[Entry].<a class="code" href="../../d1/d8/struct__MMWSLE.html#o3">u1</a>.Long;
01359                 Wsle[Entry].u1.Long = Wsle[SwapEntry].u1.Long;
01360                 Wsle[SwapEntry].u1.Long = SavedLong;
01361 
01362                 <span class="keywordflow">return</span>;
01363             }
01364 
01365 
01366         }
01367         <span class="keywordflow">if</span> (SwapParent == Entry) {
01368 
01369 
01370             <span class="comment">//</span>
01371             <span class="comment">// The parent of the swap entry is the entry.</span>
01372             <span class="comment">//</span>
01373             <span class="comment">//              R</span>
01374             <span class="comment">//            .....</span>
01375             <span class="comment">//</span>
01376             <span class="comment">//              (Parent)</span>
01377             <span class="comment">//              |</span>
01378             <span class="comment">//              (Entry)</span>
01379             <span class="comment">//              |</span>
01380             <span class="comment">//              (SwapEntry)</span>
01381             <span class="comment">//</span>
01382 
01383             <span class="comment">//</span>
01384             <span class="comment">// Update the parent pointer for the entry.</span>
01385             <span class="comment">//</span>
01386 
01387             <span class="keywordflow">if</span> (Wsle[Parent].u2.s.LeftChild == Entry) {
01388                 Wsle[Parent].u2.s.LeftChild = SwapEntry;
01389             } <span class="keywordflow">else</span> {
01390                 Wsle[Parent].u2.s.RightChild = SwapEntry;
01391             }
01392 
01393             <span class="comment">//</span>
01394             <span class="comment">// Determine if this goes left or right.</span>
01395             <span class="comment">//</span>
01396 
01397             <span class="keywordflow">if</span> (Wsle[Entry].u2.s.LeftChild == SwapEntry) {
01398 
01399                 <span class="comment">//</span>
01400                 <span class="comment">// The entry we are going to swap is the left child of this</span>
01401                 <span class="comment">// entry.</span>
01402                 <span class="comment">//</span>
01403                 <span class="comment">//              R</span>
01404                 <span class="comment">//            .....</span>
01405                 <span class="comment">//</span>
01406                 <span class="comment">//              (Parent)</span>
01407                 <span class="comment">//              |</span>
01408                 <span class="comment">//              (Entry)</span>
01409                 <span class="comment">//              /</span>
01410                 <span class="comment">//   (SwapEntry)</span>
01411                 <span class="comment">//</span>
01412 
01413                 Wsle[Entry].u2.s.LeftChild = Wsle[SwapEntry].u2.s.LeftChild;
01414                 Wsle[SwapEntry].u2.s.LeftChild = Entry;
01415                 SavedRight = Wsle[Entry].u2.s.RightChild;
01416                 Wsle[Entry].u2.s.RightChild = Wsle[SwapEntry].u2.s.RightChild;
01417                 Wsle[SwapEntry].u2.s.RightChild = SavedRight;
01418 
01419                 SavedLong = Wsle[Entry].<a class="code" href="../../d1/d8/struct__MMWSLE.html#o3">u1</a>.Long;
01420                 Wsle[Entry].u1.Long = Wsle[SwapEntry].u1.Long;
01421                 Wsle[SwapEntry].u1.Long = SavedLong;
01422 
01423                 <span class="keywordflow">return</span>;
01424 
01425             } <span class="keywordflow">else</span> {
01426 
01427                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Wsle[Entry].u2.s.RightChild == SwapEntry);
01428 
01429                 <span class="comment">//</span>
01430                 <span class="comment">// The entry we are going to swap is the right child of this</span>
01431                 <span class="comment">// entry.</span>
01432                 <span class="comment">//</span>
01433                 <span class="comment">//              R(Entry)</span>
01434                 <span class="comment">//             / \</span>
01435                 <span class="comment">//                (SwapEntry)</span>
01436                 <span class="comment">//</span>
01437 
01438                 Wsle[Entry].u2.s.RightChild = Wsle[SwapEntry].u2.s.RightChild;
01439                 Wsle[SwapEntry].u2.s.RightChild = Entry;
01440                 SavedLeft = Wsle[SwapEntry].u2.s.LeftChild;
01441                 Wsle[SwapEntry].u2.s.LeftChild = Wsle[Entry].u2.s.LeftChild;
01442                 Wsle[Entry].u2.s.LeftChild = SavedLeft;
01443 
01444                 SavedLong = Wsle[Entry].<a class="code" href="../../d1/d8/struct__MMWSLE.html#o3">u1</a>.Long;
01445                 Wsle[Entry].u1.Long = Wsle[SwapEntry].u1.Long;
01446                 Wsle[SwapEntry].u1.Long = SavedLong;
01447 
01448                 <span class="keywordflow">return</span>;
01449             }
01450 
01451         }
01452 
01453         <span class="comment">//</span>
01454         <span class="comment">// Neither entry is the parent of the other.  Just swap them</span>
01455         <span class="comment">// and update the parent entries.</span>
01456         <span class="comment">//</span>
01457 
01458         <span class="keywordflow">if</span> (Parent == <a class="code" href="../../d4/d8/mi_8h.html#a10">WSLE_NULL_INDEX</a>) {
01459 
01460             <span class="comment">//</span>
01461             <span class="comment">// This entry is not in the tree.</span>
01462             <span class="comment">//</span>
01463 
01464             PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (Wsle[Entry].u1.VirtualAddress);
01465             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
01466             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.WsIndex == Entry);
01467             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.WsIndex = SwapEntry;
01468 
01469         } <span class="keywordflow">else</span> {
01470 
01471             <span class="keywordflow">if</span> (Wsle[Parent].u2.s.LeftChild == Entry) {
01472                 Wsle[Parent].u2.s.LeftChild = SwapEntry;
01473             } <span class="keywordflow">else</span> {
01474                 Wsle[Parent].u2.s.RightChild = SwapEntry;
01475             }
01476         }
01477 
01478         <span class="keywordflow">if</span> (SwapParent == <a class="code" href="../../d4/d8/mi_8h.html#a10">WSLE_NULL_INDEX</a>) {
01479 
01480             <span class="comment">//</span>
01481             <span class="comment">// This entry is not in the tree.</span>
01482             <span class="comment">//</span>
01483 
01484             PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (Wsle[SwapEntry].u1.VirtualAddress);
01485             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber);
01486             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.WsIndex == SwapEntry);
01487             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o5">u1</a>.WsIndex = Entry;
01488         } <span class="keywordflow">else</span> {
01489 
01490             <span class="keywordflow">if</span> (Wsle[SwapParent].u2.s.LeftChild == SwapEntry) {
01491                 Wsle[SwapParent].u2.s.LeftChild = Entry;
01492             } <span class="keywordflow">else</span> {
01493                 Wsle[SwapParent].u2.s.RightChild = Entry;
01494             }
01495         }
01496 
01497         SavedRight = Wsle[SwapEntry].u2.s.RightChild;
01498         Wsle[SwapEntry].u2.s.RightChild = Wsle[Entry].u2.s.RightChild;
01499         Wsle[Entry].u2.s.RightChild = SavedRight;
01500         SavedLeft = Wsle[SwapEntry].u2.s.LeftChild;
01501         Wsle[SwapEntry].u2.s.LeftChild = Wsle[Entry].u2.s.LeftChild;
01502         Wsle[Entry].u2.s.LeftChild = SavedLeft;
01503 
01504         SavedLong = Wsle[Entry].<a class="code" href="../../d1/d8/struct__MMWSLE.html#o3">u1</a>.Long;
01505         Wsle[Entry].u1.Long = Wsle[SwapEntry].u1.Long;
01506         Wsle[SwapEntry].u1.Long = SavedLong;
01507 
01508         <span class="keywordflow">return</span>;
01509     }
01510 }
01511 <span class="preprocessor">#endif //0</span>
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:42:29 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
