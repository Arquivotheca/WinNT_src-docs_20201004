<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: objsup.c File Reference</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>objsup.c File Reference</h1><code>#include "<a class="el" href="../../d1/d5/iop_8h-source.html">iop.h</a>"</code><br>

<p>
<a href="../../d4/d0/objsup_8c-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d3/d1/objsup_8c.html#a0">IopCloseFile</a> (IN <a class="el" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process OPTIONAL, IN PVOID Object, IN ULONG GrantedAccess, IN ULONG ProcessHandleCount, IN ULONG SystemHandleCount)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d3/d1/objsup_8c.html#a1">IopDeleteFile</a> (IN PVOID Object)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d3/d1/objsup_8c.html#a2">IopDeleteDriver</a> (IN PVOID Object)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d3/d1/objsup_8c.html#a3">IopDeleteDevice</a> (IN PVOID Object)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d3/d1/objsup_8c.html#a4">IopGetDevicePDO</a> (IN <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d3/d1/objsup_8c.html#a5">IopSetDeviceSecurityDescriptors</a> (IN <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject, IN PSECURITY_INFORMATION SecurityInformation, IN PSECURITY_DESCRIPTOR SecurityDescriptor, IN <a class="el" href="../../d5/d8/ex_8h.html#a96">POOL_TYPE</a> PoolType, IN PGENERIC_MAPPING GenericMapping, IN BOOLEAN DoAttachedDevices)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>NTSTATUS&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d3/d1/objsup_8c.html#a6">IopGetSetSecurityObject</a> (IN PVOID Object, IN <a class="el" href="../../d0/d5/se_8h.html#a19">SECURITY_OPERATION_CODE</a> OperationCode, IN PSECURITY_INFORMATION SecurityInformation, IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor, IN OUT PULONG CapturedLength, IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor, IN <a class="el" href="../../d5/d8/ex_8h.html#a96">POOL_TYPE</a> PoolType, IN PGENERIC_MAPPING GenericMapping)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a0" doxytag="objsup.c::IopCloseFile" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID IopCloseFile           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>Object</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>GrantedAccess</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>ProcessHandleCount</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN ULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>SystemHandleCount</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d4/d0/objsup_8c-source.html#l00036">36</a> of file <a class="el" href="../../d4/d0/objsup_8c-source.html">objsup.c</a>.
<p>
References <a class="el" href="../../d7/d6/halmips_8h-source.html#l00086">APC_LEVEL</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01517">_FILE_OBJECT::DeviceObject</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01179">_DEVICE_OBJECT::DriverObject</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01540">_FILE_OBJECT::Event</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01403">_DRIVER_OBJECT::FastIoDispatch</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00950">_FAST_IO_DISPATCH::FastIoUnlockAll</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02494">_IO_STACK_LOCATION::FileObject</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01602">_IRP::Flags</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01533">_FILE_OBJECT::Flags</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01501">FO_DIRECT_DEVICE_OPEN</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01508">FO_HANDLE_CREATED</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01491">FO_SYNCHRONOUS_IO</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02865">IoCallDriver</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l06632">IoFreeIrp()</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l06786">IoGetAttachedDevice()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l03398">IoGetNextIrpStackLocation</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l07247">IoGetRelatedDeviceObject()</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00595">IopAcquireFastLock</a>, <a class="el" href="../../d3/d3/internal_8c-source.html#l00181">IopAcquireFileObjectLock()</a>, <a class="el" href="../../d3/d3/internal_8c-source.html#l00336">IopAllocateIrpMustSucceed()</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00758">IopDequeueThreadIrp</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l01103">IopQueueThreadIrp</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l01157">IopReleaseFileObjectLock</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l12345">IopUpdateOtherOperationCount()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01635">_IRP::IoStatus</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01561">IRP_CLOSE_OPERATION</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00073">IRP_MJ_CLEANUP</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00072">IRP_MJ_LOCK_CONTROL</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00125">IRP_MN_UNLOCK_ALL</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01552">IRP_SYNCHRONOUS_API</a>, <a class="el" href="../../d5/d8/ke_8h-source.html#l01072">KeClearEvent</a>, <a class="el" href="../../d5/d8/ke_8h-source.html#l01066">KeInitializeEvent</a>, <a class="el" href="../../d9/d5/verifier_8c.html#a117">KeLowerIrql()</a>, <a class="el" href="../../d9/d5/verifier_8c.html#a116">KeRaiseIrql()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00624">KernelMode</a>, <a class="el" href="../../d2/d6/wait_8c-source.html#l00810">KeWaitForSingleObject()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01525">_FILE_OBJECT::LockOperation</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02028">_IO_STACK_LOCATION::MajorFunction</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02029">_IO_STACK_LOCATION::MinorFunction</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00514">ObReferenceObject</a>, <a class="el" href="../../d0/d2/struct__IRP.html#o24">_IRP::Overlay</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d2/d8/ps_8h-source.html#l00643">PsGetCurrentProcess</a>, <a class="el" href="../../d2/d8/ps_8h-source.html#l00645">PsGetCurrentThread</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01641">_IRP::RequestorMode</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01189">_DEVICE_OBJECT::StackSize</a>, <a class="el" href="../../d0/d2/struct__IRP.html#o38">_IRP::Tail</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01687">_IRP::UserEvent</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01686">_IRP::UserIosb</a>, <a class="el" href="../../d4/d9/ke_8h.html#a407a204">UserRequest</a>, and <a class="el" href="../../d2/d7/hal_8h.html#a212">VOID()</a>.
<p>
Referenced by <a class="el" href="../../d0/d5/ioinit_8c-source.html#l01936">IopCreateObjectTypes()</a>, and <a class="el" href="../../d4/d0/objsup_8c-source.html#l00417">IopDeleteFile()</a>.
<p>
<pre class="fragment"><div>00046                    :
00047 
00048     This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> invoked whenever a handle to a <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> deleted.  If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00049     handle being deleted <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> last handle to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a9">file</a> (the ProcessHandleCount
00050     parameter is one), then all locks <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> owned by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> specified
00051     process must be released.
00052 
00053     Likewise, <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> SystemHandleCount <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> one then <span class="keyword">this</span> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> last handle
00054     <span class="keywordflow">for</span> <span class="keyword">this</span> <span class="keywordflow">for</span> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> object across all processes.  For <span class="keyword">this</span> <span class="keywordflow">case</span>, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a>
00055     system <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> notified so that <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> can perform any necessary cleanup on <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00056     <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a>.
00057 
00058 Arguments:
00059 
00060     Process - <a class="code" href="../../d2/d1/bench_8h.html#a5">A</a> pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> process that closed <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> handle.
00061 
00062     Object - <a class="code" href="../../d2/d1/bench_8h.html#a5">A</a> pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> object that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> handle referenced.
00063 
00064     GrantedAccess - Access that was granted to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> object through <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> handle.
00065 
00066     ProcessHandleCount - <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> of handles outstanding to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> object <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00067         process specified by <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Process argument.  If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> count <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> one
00068         then <span class="keyword">this</span> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> last handle to <span class="keyword">this</span> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> by that process.
00069 
00070     SystemHandleCount - <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> of handles outstanding to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> object <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00071         entire system.  If <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> count <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> one then <span class="keyword">this</span> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> last handle
00072         to <span class="keyword">this</span> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> system.
00073 
00074 Return Value:
00075 
00076     None.
00077 
00078 --*/
00079 
00080 {
00081     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
00082     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
00083     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
00084     <a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html">PFAST_IO_DISPATCH</a> fastIoDispatch;
00085     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
00086     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> event;
00087     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> fileObject;
00088     KIRQL irql;
00089 
00090     UNREFERENCED_PARAMETER( Process );
00091     UNREFERENCED_PARAMETER( GrantedAccess );
00092 
00093     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00094 
00095     <span class="comment">//</span>
00096     <span class="comment">// If the handle count is not one then this is not the last close of</span>
00097     <span class="comment">// this file for the specified process so there is nothing to do.</span>
00098     <span class="comment">//</span>
00099 
00100     <span class="keywordflow">if</span> (ProcessHandleCount != 1) {
00101         <span class="keywordflow">return</span>;
00102     }
00103 
00104     fileObject = (<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>) Object;
00105 
00106     <span class="keywordflow">if</span> (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o10">LockOperation</a> &amp;&amp; SystemHandleCount != 1) {
00107 
00108         IO_STATUS_BLOCK localIoStatus;
00109 
00110         <span class="comment">//</span>
00111         <span class="comment">// This is the last handle for the specified process and the process</span>
00112         <span class="comment">// called the NtLockFile or NtUnlockFile system services at least once.</span>
00113         <span class="comment">// Also, this is not the last handle for this file object system-wide</span>
00114         <span class="comment">// so unlock all of the pending locks for this process.  Note that</span>
00115         <span class="comment">// this check causes an optimization so that if this is the last</span>
00116         <span class="comment">// system-wide handle to this file object the cleanup code will take</span>
00117         <span class="comment">// care of releasing any locks on the file rather than having to</span>
00118         <span class="comment">// send the file system two different packets to get them shut down.</span>
00119 
00120         <span class="comment">//</span>
00121         <span class="comment">// Get the address of the target device object and the Fast I/O dispatch</span>
00122         <span class="comment">//</span>
00123 
00124         <span class="keywordflow">if</span> (!(fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a161">FO_DIRECT_DEVICE_OPEN</a>)) {
00125             deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( fileObject );
00126         } <span class="keywordflow">else</span> {
00127             deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a66">IoGetAttachedDevice</a>( fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o2">DeviceObject</a> );
00128         }
00129         fastIoDispatch = deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o3">DriverObject</a>-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o10">FastIoDispatch</a>;
00130 
00131         <span class="comment">//</span>
00132         <span class="comment">// If this file is open for synchronous I/O, wait until this thread</span>
00133         <span class="comment">// owns it exclusively since there may still be a thread using it.</span>
00134         <span class="comment">// This occurs when a system service owns the file because it owns</span>
00135         <span class="comment">// the semaphore, but the I/O completion code has already dereferenced</span>
00136         <span class="comment">// the file object itself.  Without waiting here for the same semaphore</span>
00137         <span class="comment">// there would be a race condition in the service who owns it now. The</span>
00138         <span class="comment">// service needs to be able to access the object w/o it going away after</span>
00139         <span class="comment">// its wait for the file event is satisfied.</span>
00140         <span class="comment">//</span>
00141 
00142         <span class="keywordflow">if</span> (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>) {
00143 
00144             BOOLEAN interrupted;
00145 
00146             <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d6/iop_8h.html#a13">IopAcquireFastLock</a>( fileObject )) {
00147                 (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d0/d6/iop_8h.html#a147">IopAcquireFileObjectLock</a>( fileObject,
00148                                                  KernelMode,
00149                                                  FALSE,
00150                                                  &amp;interrupted );
00151             }
00152         }
00153 
00154         <span class="comment">//</span>
00155         <span class="comment">// Turbo unlock support.  If the fast Io Dispatch specifies a fast lock</span>
00156         <span class="comment">// routine then we'll first try and calling it with the specified lock</span>
00157         <span class="comment">// parameters.  If this is all successful then we do not need to do</span>
00158         <span class="comment">// the Irp based unlock all call.</span>
00159         <span class="comment">//</span>
00160 
00161         <span class="keywordflow">if</span> (fastIoDispatch &amp;&amp;
00162             fastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o8">FastIoUnlockAll</a> &amp;&amp;
00163             fastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o8">FastIoUnlockAll</a>( fileObject,
00164                                              <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>(),
00165                                              &amp;localIoStatus,
00166                                              deviceObject )) {
00167 
00168             NOTHING;
00169 
00170         } <span class="keywordflow">else</span> {
00171 
00172             <span class="comment">//</span>
00173             <span class="comment">// Initialize the local event that will be used to synchronize access</span>
00174             <span class="comment">// to the driver completing this I/O operation.</span>
00175             <span class="comment">//</span>
00176 
00177             <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;event, SynchronizationEvent, FALSE );
00178 
00179             <span class="comment">//</span>
00180             <span class="comment">// Reset the event in the file object.</span>
00181             <span class="comment">//</span>
00182 
00183             <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a>( &amp;fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o25">Event</a> );
00184 
00185             <span class="comment">//</span>
00186             <span class="comment">// Allocate and initialize the I/O Request Packet (IRP) for this</span>
00187             <span class="comment">// operation.</span>
00188             <span class="comment">//</span>
00189 
00190             irp = <a class="code" href="../../d0/d6/iop_8h.html#a149">IopAllocateIrpMustSucceed</a>( deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o13">StackSize</a> );
00191             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.OriginalFileObject = fileObject;
00192             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
00193             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o10">RequestorMode</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>;
00194 
00195             <span class="comment">//</span>
00196             <span class="comment">// Fill in the service independent parameters in the IRP.</span>
00197             <span class="comment">//</span>
00198 
00199             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = &amp;event;
00200             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = &amp;irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>;
00201             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a176">IRP_SYNCHRONOUS_API</a>;
00202             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00203 
00204             <span class="comment">//</span>
00205             <span class="comment">// Get a pointer to the stack location for the first driver.  This will</span>
00206             <span class="comment">// be used to pass the original function codes and parameters.  No</span>
00207             <span class="comment">// function-specific parameters are required for this operation.</span>
00208             <span class="comment">//</span>
00209 
00210             irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
00211             irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a30">IRP_MJ_LOCK_CONTROL</a>;
00212             irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o1">MinorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a54">IRP_MN_UNLOCK_ALL</a>;
00213             irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> = fileObject;
00214 
00215             <span class="comment">//</span>
00216             <span class="comment">//  Reference the fileobject again for the IRP (cleared on completion)</span>
00217             <span class="comment">//</span>
00218 
00219             <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a>( fileObject );
00220 
00221             <span class="comment">//</span>
00222             <span class="comment">// Insert the packet at the head of the IRP list for the thread.</span>
00223             <span class="comment">//</span>
00224 
00225             <a class="code" href="../../d0/d6/iop_8h.html#a21">IopQueueThreadIrp</a>( irp );
00226 
00227             <span class="comment">//</span>
00228             <span class="comment">// Invoke the driver at its appropriate dispatch entry with the IRP.</span>
00229             <span class="comment">//</span>
00230 
00231             status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( deviceObject, irp );
00232 
00233             <span class="comment">//</span>
00234             <span class="comment">// If no error was incurred, wait for the I/O operation to complete.</span>
00235             <span class="comment">//</span>
00236 
00237             <span class="keywordflow">if</span> (status == STATUS_PENDING) {
00238                 (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
00239                                               UserRequest,
00240                                               KernelMode,
00241                                               FALSE,
00242                                               (PLARGE_INTEGER) NULL );
00243             }
00244         }
00245 
00246         <span class="comment">//</span>
00247         <span class="comment">// If this operation was a synchronous I/O operation, release the</span>
00248         <span class="comment">// semaphore so that the file can be used by other threads.</span>
00249         <span class="comment">//</span>
00250 
00251         <span class="keywordflow">if</span> (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>) {
00252             <a class="code" href="../../d0/d6/iop_8h.html#a22">IopReleaseFileObjectLock</a>( fileObject );
00253         }
00254     }
00255 
00256     <span class="keywordflow">if</span> (SystemHandleCount == 1) {
00257 
00258         <span class="comment">//</span>
00259         <span class="comment">// The last handle to this file object for all of the processes in the</span>
00260         <span class="comment">// system has just been closed, so invoke the driver's "cleanup" handler</span>
00261         <span class="comment">// for this file.  This is the file system's opportunity to remove any</span>
00262         <span class="comment">// share access information for the file, to indicate that if the file</span>
00263         <span class="comment">// is opened for a caching operation and this is the last file object</span>
00264         <span class="comment">// to the file, then it can do whatever it needs with memory management</span>
00265         <span class="comment">// to cleanup any information.</span>
00266         <span class="comment">//</span>
00267         <span class="comment">// Begin by getting the address of the target device object.</span>
00268         <span class="comment">//</span>
00269 
00270         <span class="keywordflow">if</span> (!(fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a161">FO_DIRECT_DEVICE_OPEN</a>)) {
00271             deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( fileObject );
00272         } <span class="keywordflow">else</span> {
00273             deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a66">IoGetAttachedDevice</a>( fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o2">DeviceObject</a> );
00274         }
00275 
00276         <span class="comment">//</span>
00277         <span class="comment">// Ensure that the I/O system believes that this file has a handle</span>
00278         <span class="comment">// associated with it in case it doesn't actually get one from the</span>
00279         <span class="comment">// Object Manager.  This is done because sometimes the Object Manager</span>
00280         <span class="comment">// actually creates a handle, but the I/O system never finds out</span>
00281         <span class="comment">// about it so it attempts to send two cleanups for the same file.</span>
00282         <span class="comment">//</span>
00283 
00284         fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a168">FO_HANDLE_CREATED</a>;
00285 
00286         <span class="comment">//</span>
00287         <span class="comment">// If this file is open for synchronous I/O, wait until this thread</span>
00288         <span class="comment">// owns it exclusively since there may still be a thread using it.</span>
00289         <span class="comment">// This occurs when a system service owns the file because it owns</span>
00290         <span class="comment">// the semaphore, but the I/O completion code has already dereferenced</span>
00291         <span class="comment">// the file object itself.  Without waiting here for the same semaphore</span>
00292         <span class="comment">// there would be a race condition in the service who owns it now. The</span>
00293         <span class="comment">// service needs to be able to access the object w/o it going away after</span>
00294         <span class="comment">// its wait for the file event is satisfied.</span>
00295         <span class="comment">//</span>
00296 
00297         <span class="keywordflow">if</span> (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>) {
00298 
00299             BOOLEAN interrupted;
00300 
00301             <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d6/iop_8h.html#a13">IopAcquireFastLock</a>( fileObject )) {
00302                 (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d0/d6/iop_8h.html#a147">IopAcquireFileObjectLock</a>( fileObject,
00303                                                  KernelMode,
00304                                                  FALSE,
00305                                                  &amp;interrupted );
00306             }
00307         }
00308 
00309         <span class="comment">//</span>
00310         <span class="comment">// Initialize the local event that will be used to synchronize access</span>
00311         <span class="comment">// to the driver completing this I/O operation.</span>
00312         <span class="comment">//</span>
00313 
00314         <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;event, SynchronizationEvent, FALSE );
00315 
00316         <span class="comment">//</span>
00317         <span class="comment">// Reset the event in the file object.</span>
00318         <span class="comment">//</span>
00319 
00320         <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a>( &amp;fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o25">Event</a> );
00321 
00322         <span class="comment">//</span>
00323         <span class="comment">// Allocate and initialize the I/O Request Packet (IRP) for this</span>
00324         <span class="comment">// operation.</span>
00325         <span class="comment">//</span>
00326 
00327         irp = <a class="code" href="../../d0/d6/iop_8h.html#a149">IopAllocateIrpMustSucceed</a>( deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o13">StackSize</a> );
00328         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.OriginalFileObject = fileObject;
00329         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
00330         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o10">RequestorMode</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>;
00331 
00332         <span class="comment">//</span>
00333         <span class="comment">// Fill in the service independent parameters in the IRP.</span>
00334         <span class="comment">//</span>
00335 
00336         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = &amp;event;
00337         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = &amp;irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>;
00338         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00339         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a176">IRP_SYNCHRONOUS_API</a> | <a class="code" href="../../d0/d5/io_8h.html#a185">IRP_CLOSE_OPERATION</a>;
00340 
00341         <span class="comment">//</span>
00342         <span class="comment">// Get a pointer to the stack location for the first driver.  This will</span>
00343         <span class="comment">// be used to pass the original function codes and parameters.  No</span>
00344         <span class="comment">// function-specific parameters are required for this operation.</span>
00345         <span class="comment">//</span>
00346 
00347         irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
00348         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a31">IRP_MJ_CLEANUP</a>;
00349         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> = fileObject;
00350 
00351         <span class="comment">//</span>
00352         <span class="comment">// Insert the packet at the head of the IRP list for the thread.</span>
00353         <span class="comment">//</span>
00354 
00355         <a class="code" href="../../d0/d6/iop_8h.html#a21">IopQueueThreadIrp</a>( irp );
00356 
00357         <span class="comment">//</span>
00358         <span class="comment">// Update the operation count statistic for the current process for</span>
00359         <span class="comment">// operations other than read and write.</span>
00360         <span class="comment">//</span>
00361 
00362         <a class="code" href="../../d4/d6/iosubs_8c.html#a129">IopUpdateOtherOperationCount</a>();
00363 
00364         <span class="comment">//</span>
00365         <span class="comment">// Invoke the driver at its appropriate dispatch entry with the IRP.</span>
00366         <span class="comment">//</span>
00367 
00368         status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( deviceObject, irp );
00369 
00370         <span class="comment">//</span>
00371         <span class="comment">// If no error was incurred, wait for the I/O operation to complete.</span>
00372         <span class="comment">//</span>
00373 
00374         <span class="keywordflow">if</span> (status == STATUS_PENDING) {
00375             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
00376                                           UserRequest,
00377                                           KernelMode,
00378                                           FALSE,
00379                                           (PLARGE_INTEGER) NULL );
00380         }
00381 
00382         <span class="comment">//</span>
00383         <span class="comment">// The following code tears down the IRP by hand since it may not</span>
00384         <span class="comment">// either be possible to it to be completed (because this code was</span>
00385         <span class="comment">// invoked as APC_LEVEL in the first place - or because the reference</span>
00386         <span class="comment">// count on the object cannot be incremented due to this routine</span>
00387         <span class="comment">// being invoked by the delete file procedure below).  Cleanup IRPs</span>
00388         <span class="comment">// therefore use close sematics (the close operation flag is set</span>
00389         <span class="comment">// in the IRP) so that the I/O complete request routine itself sets</span>
00390         <span class="comment">// the event to the Signaled state.</span>
00391         <span class="comment">//</span>
00392 
00393         <a class="code" href="../../d9/d5/verifier_8c.html#a116">KeRaiseIrql</a>( APC_LEVEL, &amp;irql );
00394         <a class="code" href="../../d0/d6/iop_8h.html#a18">IopDequeueThreadIrp</a>( irp );
00395         <a class="code" href="../../d9/d5/verifier_8c.html#a117">KeLowerIrql</a>( irql );
00396 
00397         <span class="comment">//</span>
00398         <span class="comment">// Also, free the IRP.</span>
00399         <span class="comment">//</span>
00400 
00401         <a class="code" href="../../d4/d6/iosubs_8c.html#a63">IoFreeIrp</a>( irp );
00402 
00403         <span class="comment">//</span>
00404         <span class="comment">// If this operation was a synchronous I/O operation, release the</span>
00405         <span class="comment">// semaphore so that the file can be used by other threads.</span>
00406         <span class="comment">//</span>
00407 
00408         <span class="keywordflow">if</span> (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>) {
00409             <a class="code" href="../../d0/d6/iop_8h.html#a22">IopReleaseFileObjectLock</a>( fileObject );
00410         }
00411     }
00412 
00413     <span class="keywordflow">return</span>;
00414 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="objsup.c::IopDeleteDevice" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID IopDeleteDevice           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>Object</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d4/d0/objsup_8c-source.html#l00769">769</a> of file <a class="el" href="../../d4/d0/objsup_8c-source.html">objsup.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00147">ASSERTMSG</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01274">_DEVOBJ_EXTENSION::DeviceNode</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01210">_DEVICE_OBJECT::DeviceObjectExtension</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01179">_DEVICE_OBJECT::DriverObject</a>, <a class="el" href="../../d7/d2/cmwraper_8c-source.html#l00304">ExFreePool()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01070">_VPB::Flags</a>, <a class="el" href="../../d9/d0/pnpiop_8h.html#a284">IopDestroyDeviceNode()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00494">ObDereferenceObject</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01075">_VPB::ReferenceCount</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01186">_DEVICE_OBJECT::Vpb</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01055">VPB_LOCKED</a>, and <a class="el" href="../../d1/d4/io_8h-source.html#l01054">VPB_MOUNTED</a>.
<p>
Referenced by <a class="el" href="../../d0/d5/ioinit_8c-source.html#l01936">IopCreateObjectTypes()</a>.
<p>
<pre class="fragment"><div>00775                    :
00776 
00777     This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> invoked when <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> reference count <span class="keywordflow">for</span> a device object
00778     becomes zero.  That <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> last reference <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> device has gone away.
00779     This routine ensures that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> object <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> cleaned up and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> driver object
00780     <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> dereferenced.
00781 
00782 Arguments:
00783 
00784     Object - Pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> driver object whose reference count has gone
00785         to zero.
00786 
00787 Return value:
00788 
00789     None.
00790 
00791 --*/
00792 
00793 {
00794     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject = (<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>) Object;
00795     <a class="code" href="../../d7/d7/struct__VPB.html">PVPB</a> vpb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00796 
00797     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00798 
00799     <a class="code" href="../../d9/d0/pnpiop_8h.html#a284">IopDestroyDeviceNode</a>(deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o25">DeviceObjectExtension</a>-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o6">DeviceNode</a>);
00800 
00801 <span class="preprocessor">#if DBG</span>
00802 <span class="preprocessor"></span>    IopCheckDeviceNodeTree (deviceObject, NULL);
00803 <span class="preprocessor">#endif</span>
00804 <span class="preprocessor"></span>
00805     <span class="comment">//</span>
00806     <span class="comment">// If there's still a VPB attached then free it.</span>
00807     <span class="comment">//</span>
00808 
00809     vpb = InterlockedExchangePointer(&amp;(deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o10">Vpb</a>), vpb);
00810 
00811     <span class="keywordflow">if</span>(vpb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00812 
00813         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a8">ASSERTMSG</a>(<span class="stringliteral">"Unreferenced device object to be deleted is still in use"</span>,
00814                   ((vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o2">Flags</a> &amp; (VPB_MOUNTED | VPB_LOCKED)) == 0));
00815 
00816         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o7">ReferenceCount</a> == 0);
00817         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(vpb);
00818     }
00819     <span class="keywordflow">if</span> (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o3">DriverObject</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00820         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o3">DriverObject</a> );
00821     }
00822 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="objsup.c::IopDeleteDriver" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID IopDeleteDriver           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>Object</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d4/d0/objsup_8c-source.html#l00698">698</a> of file <a class="el" href="../../d4/d0/objsup_8c-source.html">objsup.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01350">_DRIVER_EXTENSION::ClientDriverExtension</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01366">_DRIVER_OBJECT::DeviceObject</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01378">_DRIVER_OBJECT::DriverExtension</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01385">_DRIVER_OBJECT::DriverName</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01377">_DRIVER_OBJECT::DriverSection</a>, <a class="el" href="../../d7/d2/cmwraper_8c-source.html#l00304">ExFreePool()</a>, <a class="el" href="../../d8/d0/genuedef_8c-source.html#l00009">extension</a>, <a class="el" href="../../d9/d7/sysload_8c-source.html#l02896">MmUnloadSystemImage()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, and <a class="el" href="../../d1/d4/io_8h-source.html#l01337">_DRIVER_EXTENSION::ServiceKeyName</a>.
<p>
Referenced by <a class="el" href="../../d0/d5/ioinit_8c-source.html#l01936">IopCreateObjectTypes()</a>.
<p>
<pre class="fragment"><div>00704                    :
00705 
00706     This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> invoked when <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> reference count <span class="keywordflow">for</span> a driver object
00707     becomes zero.  That <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>, <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> last reference <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> driver has gone away.
00708     This routine ensures that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> object <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> cleaned up and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> driver
00709     unloaded.
00710 
00711 Arguments:
00712 
00713     Object - Pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> driver object whose reference count has gone
00714         to zero.
00715 
00716 Return value:
00717 
00718     None.
00719 
00720 --*/
00721 
00722 {
00723     <a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html">PDRIVER_OBJECT</a> driverObject = (<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html">PDRIVER_OBJECT</a>) Object;
00724     <a class="code" href="../../d1/d4/struct__IO__CLIENT__EXTENSION.html">PIO_CLIENT_EXTENSION</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a6">extension</a>;
00725     <a class="code" href="../../d1/d4/struct__IO__CLIENT__EXTENSION.html">PIO_CLIENT_EXTENSION</a> nextExtension;
00726 
00727     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00728 
00729     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( !driverObject-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o2">DeviceObject</a> );
00730 
00731     <span class="comment">//</span>
00732     <span class="comment">// Free any client driver object extensions.</span>
00733     <span class="comment">//</span>
00734 
00735     <a class="code" href="../../d7/d1/genuedef_8c.html#a6">extension</a> = driverObject-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o7">DriverExtension</a>-&gt;<a class="code" href="../../d1/d9/struct__DRIVER__EXTENSION.html#o4">ClientDriverExtension</a>;
00736     <span class="keywordflow">while</span> (<a class="code" href="../../d7/d1/genuedef_8c.html#a6">extension</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00737 
00738         nextExtension = <a class="code" href="../../d7/d1/genuedef_8c.html#a6">extension</a>-&gt;NextExtension;
00739         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( extension );
00740         <a class="code" href="../../d7/d1/genuedef_8c.html#a6">extension</a> = nextExtension;
00741     }
00742 
00743     <span class="comment">//</span>
00744     <span class="comment">// If there is a driver section then unload the driver.</span>
00745     <span class="comment">//</span>
00746 
00747     <span class="keywordflow">if</span> (driverObject-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o6">DriverSection</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00748         <a class="code" href="../../d8/d8/sysload_8c.html#a59">MmUnloadSystemImage</a>( driverObject-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o6">DriverSection</a> );
00749     }
00750 
00751     <span class="comment">//</span>
00752     <span class="comment">// Free the pool associated with the name of the driver.</span>
00753     <span class="comment">//</span>
00754 
00755     <span class="keywordflow">if</span> (driverObject-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o8">DriverName</a>.Buffer) {
00756         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( driverObject-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o8">DriverName</a>.Buffer );
00757     }
00758 
00759     <span class="comment">//</span>
00760     <span class="comment">// Free the pool associated with the service key name of the driver.</span>
00761     <span class="comment">//</span>
00762 
00763     <span class="keywordflow">if</span> (driverObject-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o7">DriverExtension</a>-&gt;<a class="code" href="../../d1/d9/struct__DRIVER__EXTENSION.html#o3">ServiceKeyName</a>.Buffer) {
00764         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( driverObject-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o7">DriverExtension</a>-&gt;<a class="code" href="../../d1/d9/struct__DRIVER__EXTENSION.html#o3">ServiceKeyName</a>.Buffer );
00765     }
00766 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="objsup.c::IopDeleteFile" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID IopDeleteFile           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>Object</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d4/d0/objsup_8c-source.html#l00417">417</a> of file <a class="el" href="../../d4/d0/objsup_8c-source.html">objsup.c</a>.
<p>
References <a class="el" href="../../d7/d6/halmips_8h-source.html#l00086">APC_LEVEL</a>, <a class="el" href="../../d0/d2/struct__IRP.html#o7">_IRP::AssociatedIrp</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01541">_FILE_OBJECT::CompletionContext</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01517">_FILE_OBJECT::DeviceObject</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01162">DO_NEVER_LAST_DEVICE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01540">_FILE_OBJECT::Event</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00623">Executive</a>, <a class="el" href="../../d7/d2/cmwraper_8c-source.html#l00304">ExFreePool()</a>, <a class="el" href="../../d5/d8/ex_8h.html#a235">ExInterlockedAddUlong()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01534">_FILE_OBJECT::FileName</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02494">_IO_STACK_LOCATION::FileObject</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01184">_DEVICE_OBJECT::Flags</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01602">_IRP::Flags</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01533">_FILE_OBJECT::Flags</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01501">FO_DIRECT_DEVICE_OPEN</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01508">FO_HANDLE_CREATED</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01491">FO_SYNCHRONOUS_IO</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l00652">IoAllocateIrp()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02865">IoCallDriver</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l06632">IoFreeIrp()</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l06786">IoGetAttachedDevice()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l03398">IoGetNextIrpStackLocation</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l07247">IoGetRelatedDeviceObject()</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00595">IopAcquireFastLock</a>, <a class="el" href="../../d3/d3/internal_8c-source.html#l00181">IopAcquireFileObjectLock()</a>, <a class="el" href="../../d3/d3/internal_8c-source.html#l00336">IopAllocateIrpMustSucceed()</a>, <a class="el" href="../../d4/d0/objsup_8c-source.html#l00036">IopCloseFile()</a>, <a class="el" href="../../d4/d4/iodata_8c-source.html#l00054">IopDatabaseLock</a>, <a class="el" href="../../d3/d3/internal_8c-source.html#l04022">IopDecrementDeviceObjectRef()</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00758">IopDequeueThreadIrp</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l01103">IopQueueThreadIrp</a>, <a class="el" href="../../d4/d4/iodata_8c-source.html#l00042">IopVpbSpinLock</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01561">IRP_CLOSE_OPERATION</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00057">IRP_MJ_CLOSE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01552">IRP_SYNCHRONOUS_API</a>, <a class="el" href="../../d5/d8/ke_8h-source.html#l01072">KeClearEvent</a>, <a class="el" href="../../d5/d8/ke_8h-source.html#l01066">KeInitializeEvent</a>, <a class="el" href="../../d9/d5/verifier_8c.html#a117">KeLowerIrql()</a>, <a class="el" href="../../d9/d5/verifier_8c.html#a116">KeRaiseIrql()</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00624">KernelMode</a>, <a class="el" href="../../d2/d6/wait_8c-source.html#l00810">KeWaitForSingleObject()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02028">_IO_STACK_LOCATION::MajorFunction</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00494">ObDereferenceObject</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01482">_IO_COMPLETION_CONTEXT::Port</a>, <a class="el" href="../../d2/d8/ps_8h-source.html#l00645">PsGetCurrentThread</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01178">_DEVICE_OBJECT::ReferenceCount</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01075">_VPB::ReferenceCount</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01189">_DEVICE_OBJECT::StackSize</a>, <a class="el" href="../../d0/d2/struct__IRP.html#o38">_IRP::Tail</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01687">_IRP::UserEvent</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01686">_IRP::UserIosb</a>, <a class="el" href="../../d2/d7/hal_8h.html#a212">VOID()</a>, and <a class="el" href="../../d1/d4/io_8h-source.html#l01518">_FILE_OBJECT::Vpb</a>.
<p>
Referenced by <a class="el" href="../../d0/d5/ioinit_8c-source.html#l01936">IopCreateObjectTypes()</a>, and <a class="el" href="../../d5/d2/parse_8c-source.html#l00202">IopParseDevice()</a>.
<p>
<pre class="fragment"><div>00423                    :
00424 
00425     This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> invoked when <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> last handle to a specific <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> handle <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
00426     being closed and <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> object <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> going away.  It <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> responsibility
00427     of <span class="keyword">this</span> routine to perform <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> following <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a16">functions</a>:
00428 
00429         o  Notify <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> device driver that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> object <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> open on that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00430            <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> being closed.
00431 
00432         o  Dereference <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> user's error port <span class="keywordflow">for</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> object, <span class="keywordflow">if</span> there
00433            <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> one associated with <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> object.
00434 
00435         o  Decrement <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> device object reference count.
00436 
00437 Arguments:
00438 
00439     Object - Pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> object being deleted.
00440 
00441 Return Value:
00442 
00443     None.
00444 
00445 --*/
00446 
00447 {
00448     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
00449     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
00450     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
00451     IO_STATUS_BLOCK ioStatusBlock;
00452     KIRQL irql;
00453     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
00454     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> fileObject;
00455     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> event;
00456     <a class="code" href="../../d7/d7/struct__VPB.html">PVPB</a> vpb;
00457     BOOLEAN referenceCountDecremented;
00458 
00459     <span class="comment">//</span>
00460     <span class="comment">// Obtain a pointer to the file object.</span>
00461     <span class="comment">//</span>
00462 
00463     fileObject = (<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>) Object;
00464 
00465     <span class="comment">//</span>
00466     <span class="comment">// Get a pointer to the first device driver which should be notified that</span>
00467     <span class="comment">// this file is going away.  If the device driver field is NULL, then this</span>
00468     <span class="comment">// file is being shut down due to an error attempting to get it open in the</span>
00469     <span class="comment">// first place, so do not do any further processing.</span>
00470     <span class="comment">//</span>
00471 
00472     <span class="keywordflow">if</span> (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o2">DeviceObject</a>) {
00473         <span class="keywordflow">if</span> (!(fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a161">FO_DIRECT_DEVICE_OPEN</a>)) {
00474             deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( fileObject );
00475         } <span class="keywordflow">else</span> {
00476             deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a66">IoGetAttachedDevice</a>( fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o2">DeviceObject</a> );
00477         }
00478 
00479         <span class="comment">//</span>
00480         <span class="comment">// If this file has never had a file handle created for it, and yet</span>
00481         <span class="comment">// it exists, invoke the close file procedure so that the file system</span>
00482         <span class="comment">// gets the cleanup IRP it is expecting before sending the close IRP.</span>
00483         <span class="comment">//</span>
00484 
00485         <span class="keywordflow">if</span> (!(fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a168">FO_HANDLE_CREATED</a>)) {
00486             <a class="code" href="../../d3/d1/objsup_8c.html#a0">IopCloseFile</a>( (<a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a>) NULL,
00487                           Object,
00488                           0,
00489                           1,
00490                           1 );
00491         }
00492 
00493         <span class="comment">//</span>
00494         <span class="comment">// If this file is open for synchronous I/O, wait until this thread</span>
00495         <span class="comment">// owns it exclusively since there may still be a thread using it.</span>
00496         <span class="comment">// This occurs when a system service owns the file because it owns</span>
00497         <span class="comment">// the semaphore, but the I/O completion code has already dereferenced</span>
00498         <span class="comment">// the file object itself.  Without waiting here for the same semaphore</span>
00499         <span class="comment">// there would be a race condition in the service who owns it now.  The</span>
00500         <span class="comment">// service needs to be able to access the object w/o it going away after</span>
00501         <span class="comment">// its wait for the file event is satisfied.</span>
00502         <span class="comment">//</span>
00503 
00504         <span class="keywordflow">if</span> (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>) {
00505 
00506             BOOLEAN interrupted;
00507 
00508             <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d6/iop_8h.html#a13">IopAcquireFastLock</a>( fileObject )) {
00509                 (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d0/d6/iop_8h.html#a147">IopAcquireFileObjectLock</a>( fileObject,
00510                                                  KernelMode,
00511                                                  FALSE,
00512                                                  &amp;interrupted );
00513             }
00514         }
00515 
00516         <span class="comment">//</span>
00517         <span class="comment">// Reset a local event that can be used to wait for the device driver</span>
00518         <span class="comment">// to close the file.</span>
00519         <span class="comment">//</span>
00520 
00521         <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;event, SynchronizationEvent, FALSE );
00522 
00523         <span class="comment">//</span>
00524         <span class="comment">// Reset the event in the file object.</span>
00525         <span class="comment">//</span>
00526 
00527         <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a>( &amp;fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o25">Event</a> );
00528 
00529         <span class="comment">//</span>
00530         <span class="comment">// Allocate an I/O Request Packet (IRP) to be used in communicating with</span>
00531         <span class="comment">// the appropriate device driver that the file is being closed.  Notice</span>
00532         <span class="comment">// that the allocation of this packet is done without charging quota so</span>
00533         <span class="comment">// that the operation will not fail.  This is done because there is no</span>
00534         <span class="comment">// way to return an error to the caller at this point.</span>
00535         <span class="comment">//</span>
00536 
00537         irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a17">IoAllocateIrp</a>( deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o13">StackSize</a>, FALSE );
00538         <span class="keywordflow">if</span> (!irp) {
00539             irp = <a class="code" href="../../d0/d6/iop_8h.html#a149">IopAllocateIrpMustSucceed</a>( deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o13">StackSize</a> );
00540         }
00541 
00542         <span class="comment">//</span>
00543         <span class="comment">// Get a pointer to the stack location for the first driver.  This is</span>
00544         <span class="comment">// where the function codes and parameters are placed.</span>
00545         <span class="comment">//</span>
00546 
00547         irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
00548 
00549         <span class="comment">//</span>
00550         <span class="comment">// Fill in the IRP, indicating that this file object is being deleted.</span>
00551         <span class="comment">//</span>
00552 
00553         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a15">IRP_MJ_CLOSE</a>;
00554         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> = fileObject;
00555         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = &amp;ioStatusBlock;
00556         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = &amp;event;
00557         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.OriginalFileObject = fileObject;
00558         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
00559         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer = (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00560         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a185">IRP_CLOSE_OPERATION</a> | <a class="code" href="../../d0/d5/io_8h.html#a176">IRP_SYNCHRONOUS_API</a>;
00561 
00562         <span class="comment">//</span>
00563         <span class="comment">// Place this packet in the thread's I/O pending queue.</span>
00564         <span class="comment">//</span>
00565 
00566         <a class="code" href="../../d0/d6/iop_8h.html#a21">IopQueueThreadIrp</a>( irp );
00567 
00568         <span class="comment">//</span>
00569         <span class="comment">// Decrement the reference count on the VPB, if necessary.  We</span>
00570         <span class="comment">// have to do this BEFORE handing the Irp to the file system</span>
00571         <span class="comment">// because of a trick the file systems play with close, and</span>
00572         <span class="comment">// believe me, you really don't want to know what it is.</span>
00573         <span class="comment">//</span>
00574         <span class="comment">// Since there is not a error path here (close cannot fail),</span>
00575         <span class="comment">// and the file system is the only ome who can actually synchronize</span>
00576         <span class="comment">// with the actual completion of close processing, the file system</span>
00577         <span class="comment">// is the one responsible for Vpb deletion.</span>
00578         <span class="comment">//</span>
00579 
00580         vpb = fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o3">Vpb</a>;
00581 
00582         <span class="keywordflow">if</span> (vpb &amp;&amp; !(fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a161">FO_DIRECT_DEVICE_OPEN</a>)) {
00583             <a class="code" href="../../d5/d8/ex_8h.html#a235">ExInterlockedAddUlong</a>( &amp;vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o7">ReferenceCount</a>,
00584                                    0xffffffff,
00585                                    &amp;IopVpbSpinLock );
00586         }
00587 
00588         <span class="comment">//</span>
00589         <span class="comment">// If this device object has stated for a fact that it knows it will</span>
00590         <span class="comment">// never have the final non-zero reference count among the other</span>
00591         <span class="comment">// device objects associated with our driver object, then decrement</span>
00592         <span class="comment">// our reference count here BEFORE calling the file system.  This</span>
00593         <span class="comment">// is required because for a special class of device objects, the</span>
00594         <span class="comment">// file system may delete them.</span>
00595         <span class="comment">//</span>
00596 
00597         <span class="keywordflow">if</span> (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o2">DeviceObject</a>-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o8">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a131">DO_NEVER_LAST_DEVICE</a>) {
00598             <a class="code" href="../../d5/d8/ex_8h.html#a235">ExInterlockedAddUlong</a>( &amp;fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o2">DeviceObject</a>-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o2">ReferenceCount</a>,
00599                                    0xffffffff,
00600                                    &amp;IopDatabaseLock );
00601 
00602             referenceCountDecremented = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00603         } <span class="keywordflow">else</span> {
00604             referenceCountDecremented = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00605         }
00606 
00607         <span class="comment">//</span>
00608         <span class="comment">// Give the device driver the packet.  If this request does not work,</span>
00609         <span class="comment">// there is nothing that can be done about it.  This is unfortunate</span>
00610         <span class="comment">// because the driver may have had problems that it was about to</span>
00611         <span class="comment">// report about other operations (e.g., write behind failures, etc.)</span>
00612         <span class="comment">// that it can no longer report.  The reason is that this routine</span>
00613         <span class="comment">// is really initially invoked by NtClose, which has already closed</span>
00614         <span class="comment">// the caller's handle, and that's what the return status from close</span>
00615         <span class="comment">// indicates:  the handle has successfully been closed.</span>
00616         <span class="comment">//</span>
00617 
00618         status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( deviceObject, irp );
00619 
00620         <span class="keywordflow">if</span> (status == STATUS_PENDING) {
00621             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
00622                                           Executive,
00623                                           KernelMode,
00624                                           FALSE,
00625                                           (PLARGE_INTEGER) NULL );
00626         }
00627 
00628         <span class="comment">//</span>
00629         <span class="comment">// Perform any completion operations that need to be performed on</span>
00630         <span class="comment">// the IRP that was used for this request.  This is done here as</span>
00631         <span class="comment">// as opposed to in normal completion code because there is a race</span>
00632         <span class="comment">// condition between when this routine executes if it was invoked</span>
00633         <span class="comment">// from a special kernel APC (e.g., some IRP was just completed and</span>
00634         <span class="comment">// dereferenced this file object for the last time), and when the</span>
00635         <span class="comment">// special kernel APC because of this packet's completion executing.</span>
00636         <span class="comment">//</span>
00637         <span class="comment">// This problem is solved by not having to queue a special kernel</span>
00638         <span class="comment">// APC routine for completion of this packet.  Rather, it is treated</span>
00639         <span class="comment">// much like a synchronous paging I/O operation, except that the</span>
00640         <span class="comment">// packet is not even freed during I/O completion.  This is because</span>
00641         <span class="comment">// the packet is still in this thread's queue, and there is no way</span>
00642         <span class="comment">// to get it out except at APC_LEVEL.  Unfortunately, the part of</span>
00643         <span class="comment">// I/O completion that needs to dequeue the packet is running at</span>
00644         <span class="comment">// DISPATCH_LEVEL.</span>
00645         <span class="comment">//</span>
00646         <span class="comment">// Hence, the packet must be removed from the queue (synchronized,</span>
00647         <span class="comment">// of course), and then it must be freed.</span>
00648         <span class="comment">//</span>
00649 
00650         <a class="code" href="../../d9/d5/verifier_8c.html#a116">KeRaiseIrql</a>( APC_LEVEL, &amp;irql );
00651         <a class="code" href="../../d0/d6/iop_8h.html#a18">IopDequeueThreadIrp</a>( irp );
00652         <a class="code" href="../../d9/d5/verifier_8c.html#a117">KeLowerIrql</a>( irql );
00653 
00654         <a class="code" href="../../d4/d6/iosubs_8c.html#a63">IoFreeIrp</a>( irp );
00655 
00656         <span class="comment">//</span>
00657         <span class="comment">// Free the file name string buffer if there was one.</span>
00658         <span class="comment">//</span>
00659 
00660         <span class="keywordflow">if</span> (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>.Length != 0) {
00661             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>.Buffer );
00662         }
00663 
00664         <span class="comment">//</span>
00665         <span class="comment">// If there was an completion port associated w/this file object, dereference</span>
00666         <span class="comment">// it now, and deallocate the completion context pool.</span>
00667         <span class="comment">//</span>
00668 
00669         <span class="keywordflow">if</span> (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o26">CompletionContext</a>) {
00670             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o26">CompletionContext</a>-&gt;<a class="code" href="../../d2/d4/struct__IO__COMPLETION__CONTEXT.html#o0">Port</a> );
00671             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o26">CompletionContext</a> );
00672         }
00673 
00674         <span class="comment">//</span>
00675         <span class="comment">// Get a pointer to the real device object so its reference count</span>
00676         <span class="comment">// can be decremented.</span>
00677         <span class="comment">//</span>
00678 
00679         deviceObject = fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o2">DeviceObject</a>;
00680 
00681         <span class="comment">//</span>
00682         <span class="comment">// Decrement the reference count on the device object.  Note that</span>
00683         <span class="comment">// if the driver has been marked for an unload operation, and the</span>
00684         <span class="comment">// reference count goes to zero, then the driver may need to be</span>
00685         <span class="comment">// unloaded at this point.</span>
00686         <span class="comment">//</span>
00687         <span class="comment">// Note: only do this if the reference count was not already done</span>
00688         <span class="comment">// above.  The device object may be gone in this case.</span>
00689         <span class="comment">//</span>
00690 
00691         <span class="keywordflow">if</span> (!referenceCountDecremented) {
00692             <a class="code" href="../../d0/d6/iop_8h.html#a161">IopDecrementDeviceObjectRef</a>( deviceObject, FALSE );
00693         }
00694     }
00695 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="objsup.c::IopGetDevicePDO" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> IopGetDevicePDO           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>DeviceObject</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d4/d0/objsup_8c-source.html#l00826">826</a> of file <a class="el" href="../../d4/d0/objsup_8c-source.html">objsup.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01164">DO_BUS_ENUMERATED_DEVICE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01184">_DEVICE_OBJECT::Flags</a>, <a class="el" href="../../d0/d0/pnpiop_8h-source.html#l01266">IopAcquireEnumerationLock</a>, <a class="el" href="../../d4/d4/iodata_8c-source.html#l00054">IopDatabaseLock</a>, <a class="el" href="../../d3/d3/internal_8c-source.html#l03919">IopGetDeviceAttachmentBase()</a>, <a class="el" href="../../d0/d0/pnpiop_8h-source.html#l01276">IopReleaseEnumerationLock</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, and <a class="el" href="../../d5/d9/ob_8h-source.html#l00514">ObReferenceObject</a>.
<p>
Referenced by <a class="el" href="../../d4/d0/objsup_8c-source.html#l00975">IopGetSetSecurityObject()</a>.
<p>
<pre class="fragment"><div>00831                    :
00832 
00833     Call <span class="keyword">this</span> routine to obtain <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Base PDO <span class="keywordflow">for</span> a device object
00834 
00835 Arguments:
00836 
00837     DeviceObject - pointer to device object to get PDO <span class="keywordflow">for</span>
00838 
00839 ReturnValue:
00840 
00841     PDO <span class="keywordflow">if</span> DeviceObject <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> attached to a PDO, otherwise <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
00842     The returned PDO <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> reference-counted
00843 
00844 --*/
00845 {
00846     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceBaseObject;
00847     KIRQL irql;
00848 
00849     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(DeviceObject);
00850 
00851     <a class="code" href="../../d9/d0/pnpiop_8h.html#a95">IopAcquireEnumerationLock</a>(NULL);        <span class="comment">// ensure we have acquired P&amp;P locks</span>
00852 
00853     ExAcquireSpinLock(&amp;IopDatabaseLock,&amp;irql);
00854     deviceBaseObject = <a class="code" href="../../d0/d6/iop_8h.html#a173">IopGetDeviceAttachmentBase</a>(DeviceObject);
00855     <span class="keywordflow">if</span> ((deviceBaseObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o8">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a133">DO_BUS_ENUMERATED_DEVICE</a>) != 0) {
00856         <span class="comment">//</span>
00857         <span class="comment">// we have determined that this is attached to a PDO</span>
00858         <span class="comment">//</span>
00859         <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a>( deviceBaseObject );
00860 
00861     } <span class="keywordflow">else</span> {
00862         <span class="comment">//</span>
00863         <span class="comment">// not a PDO</span>
00864         <span class="comment">//</span>
00865         deviceBaseObject = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00866     }
00867     ExReleaseSpinLock(&amp;IopDatabaseLock,irql);
00868 
00869     <a class="code" href="../../d9/d0/pnpiop_8h.html#a96">IopReleaseEnumerationLock</a>(NULL);
00870 
00871     <span class="keywordflow">return</span> deviceBaseObject;
00872 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="objsup.c::IopGetSetSecurityObject" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS IopGetSetSecurityObject           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN PVOID&nbsp;</td>
          <td class="mdname" nowrap> <em>Object</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d0/d5/se_8h.html#a19">SECURITY_OPERATION_CODE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>OperationCode</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PSECURITY_INFORMATION&nbsp;</td>
          <td class="mdname" nowrap> <em>SecurityInformation</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT PSECURITY_DESCRIPTOR&nbsp;</td>
          <td class="mdname" nowrap> <em>SecurityDescriptor</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT PULONG&nbsp;</td>
          <td class="mdname" nowrap> <em>CapturedLength</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT PSECURITY_DESCRIPTOR *&nbsp;</td>
          <td class="mdname" nowrap> <em>ObjectsSecurityDescriptor</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d5/d8/ex_8h.html#a96">POOL_TYPE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>PoolType</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PGENERIC_MAPPING&nbsp;</td>
          <td class="mdname" nowrap> <em>GenericMapping</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d4/d0/objsup_8c-source.html#l00975">975</a> of file <a class="el" href="../../d4/d0/objsup_8c-source.html">objsup.c</a>.
<p>
References <a class="el" href="../../d0/d5/se_8h.html#a200a111">AssignSecurityDescriptor</a>, <a class="el" href="../../d0/d5/se_8h.html#a200a110">DeleteSecurityDescriptor</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01517">_FILE_OBJECT::DeviceObject</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01540">_FILE_OBJECT::Event</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l02475">ExAcquireResourceExclusive</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l02474">ExAcquireResourceShared</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00055">EXCEPTION_EXECUTE_HANDLER</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00623">Executive</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l02393">ExReleaseResource</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01534">_FILE_OBJECT::FileName</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02494">_IO_STACK_LOCATION::FileObject</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01523">_FILE_OBJECT::FinalStatus</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01602">_IRP::Flags</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01533">_FILE_OBJECT::Flags</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01492">FO_ALERTABLE_IO</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01501">FO_DIRECT_DEVICE_OPEN</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01498">FO_STREAM_FILE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01491">FO_SYNCHRONOUS_IO</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00037">IO_TYPE_DEVICE</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l00652">IoAllocateIrp()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02865">IoCallDriver</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l06786">IoGetAttachedDevice()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l03398">IoGetNextIrpStackLocation</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l07247">IoGetRelatedDeviceObject()</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l00595">IopAcquireFastLock</a>, <a class="el" href="../../d3/d3/internal_8c-source.html#l00181">IopAcquireFileObjectLock()</a>, <a class="el" href="../../d3/d3/internal_8c-source.html#l00284">IopAllocateIrpCleanup()</a>, <a class="el" href="../../d4/d0/objsup_8c-source.html#l00826">IopGetDevicePDO()</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l01103">IopQueueThreadIrp</a>, <a class="el" href="../../d1/d5/iop_8h-source.html#l01157">IopReleaseFileObjectLock</a>, <a class="el" href="../../d4/d4/iodata_8c-source.html#l00074">IopSecurityResource</a>, <a class="el" href="../../d4/d0/objsup_8c-source.html#l00877">IopSetDeviceSecurityDescriptors()</a>, <a class="el" href="../../d5/d5/iosubs_8c-source.html#l12345">IopUpdateOtherOperationCount()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00075">IRP_MJ_QUERY_SECURITY</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l00076">IRP_MJ_SET_SECURITY</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01552">IRP_SYNCHRONOUS_API</a>, <a class="el" href="../../d5/d8/ke_8h-source.html#l01072">KeClearEvent</a>, <a class="el" href="../../d5/d8/ke_8h-source.html#l01598">KeEnterCriticalRegion</a>, <a class="el" href="../../d5/d8/ke_8h-source.html#l01066">KeInitializeEvent</a>, <a class="el" href="../../d5/d8/ke_8h-source.html#l01628">KeLeaveCriticalRegion</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00624">KernelMode</a>, <a class="el" href="../../d2/d6/wait_8c-source.html#l00810">KeWaitForSingleObject()</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00174">KPROCESSOR_MODE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02028">_IO_STACK_LOCATION::MajorFunction</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00494">ObDereferenceObject</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00514">ObReferenceObject</a>, <a class="el" href="../../d0/d2/struct__IRP.html#o24">_IRP::Overlay</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l02069">_IO_STACK_LOCATION::Parameters</a>, <a class="el" href="../../d2/d8/ps_8h-source.html#l00645">PsGetCurrentThread</a>, <a class="el" href="../../d0/d5/se_8h.html#a200a109">QuerySecurityDescriptor</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01524">_FILE_OBJECT::RelatedFileObject</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01641">_IRP::RequestorMode</a>, <a class="el" href="../../d2/d4/seassign_8c-source.html#l00529">SeAssignWorldSecurityDescriptor()</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01204">_DEVICE_OBJECT::SecurityDescriptor</a>, <a class="el" href="../../d1/d5/semethod_8c-source.html#l00559">SeQuerySecurityDescriptorInfo()</a>, <a class="el" href="../../d0/d5/se_8h.html#a200a108">SetSecurityDescriptor</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01189">_DEVICE_OBJECT::StackSize</a>, <a class="el" href="../../d0/d2/struct__IRP.html#o38">_IRP::Tail</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01711">_IRP::UserBuffer</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01687">_IRP::UserEvent</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01686">_IRP::UserIosb</a>, and <a class="el" href="../../d2/d7/hal_8h.html#a212">VOID()</a>.
<p>
Referenced by <a class="el" href="../../d0/d5/ioinit_8c-source.html#l01936">IopCreateObjectTypes()</a>.
<p>
<pre class="fragment"><div>00988                    :
00989 
00990     This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> invoked to either query or set <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> security descriptor
00991     <span class="keywordflow">for</span> a <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a>, directory, volume, or device.  It implements these <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a16">functions</a>
00992     by either performing an in-line check <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a9">file</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a device or a
00993     volume, or an I/O <a class="code" href="../../d5/d4/kernel_2ddetrack_8c.html#a24">Request</a> Packet (<a class="code" href="../../d0/d2/struct__IRP.html">IRP</a>) is generated and given to the
00994     driver to perform the operation.
00995 
00996 Arguments:
00997 
00998     Object - Pointer to the file or device object representing the open object.
00999 
01000     SecurityInformation - Information about what is being done to or obtained
01001         from the object's security descriptor.
01002 
01003     SecurityDescriptor - Supplies the base security descriptor and returns
01004         the final security descriptor.  Note that if this buffer is coming
01005         from user space, it has already been probed by the object manager
01006         to length "CapturedLength", otherwise it points to kernel space and
01007         should not be probed.  It must, however, be referenced in a try
01008         clause.
01009 
01010     CapturedLength - For a query operation this specifies the size, in
01011         bytes, of the output security descriptor buffer and on return
01012         contains the number of bytes needed to store the complete security
01013         descriptor.  If the length needed is greater than the length
01014         supplied the operation will fail.  This parameter is ignored for
01015         the set and delete operations.  It is expected to point into
01016         system space, ie, it need not be probed and it will not change.
01017 
01018     ObjectsSecurityDescriptor - Supplies and returns the object's security
01019         descriptor.
01020 
01021     PoolType - Specifies from which type of pool memory is to be allocated.
01022 
01023     GenericMapping - Supplies the generic mapping for the object type.
01024 
01025 Return Value:
01026 
01027     The final status of the operation is returned as the function value.
01028 
01029 --*/
01030 
01031 {
01032     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
01033     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> fileObject;
01034     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
01035     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> devicePDO = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01036     BOOLEAN synchronousIo;
01037 
01038     UNREFERENCED_PARAMETER( ObjectsSecurityDescriptor );
01039     UNREFERENCED_PARAMETER( PoolType );
01040 
01041     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01042 
01043 
01044     <span class="comment">//</span>
01045     <span class="comment">// Begin by determining whether the security operation is to be performed</span>
01046     <span class="comment">// in this routine or by the driver.  This is based upon whether the</span>
01047     <span class="comment">// object represents a device object, or it represents a file object</span>
01048     <span class="comment">// to a device, or a file on the device. If the open is a direct device</span>
01049     <span class="comment">// open then use the device object.</span>
01050     <span class="comment">//</span>
01051 
01052     <span class="keywordflow">if</span> (((<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>) (Object))-&gt;Type == <a class="code" href="../../d0/d5/io_8h.html#a2">IO_TYPE_DEVICE</a>) {
01053         deviceObject = (<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>) Object;
01054         fileObject = (<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01055     } <span class="keywordflow">else</span> {
01056         fileObject = (<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>) Object;
01057         <span class="keywordflow">if</span> (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a161">FO_DIRECT_DEVICE_OPEN</a>) {
01058             deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a66">IoGetAttachedDevice</a>( fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o2">DeviceObject</a> );
01059         }
01060         <span class="keywordflow">else</span> {
01061                 deviceObject = fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o2">DeviceObject</a>;
01062         }
01063     }
01064 
01065     <span class="keywordflow">if</span> (!fileObject ||
01066         (!fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>.Length &amp;&amp; !fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o9">RelatedFileObject</a>) ||
01067         (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a161">FO_DIRECT_DEVICE_OPEN</a>)) {
01068 
01069         <span class="comment">//</span>
01070         <span class="comment">// This security operation is for the device itself, either through</span>
01071         <span class="comment">// a file object, or directly to the device object.  For the latter</span>
01072         <span class="comment">// case, assignment operations are also possible.  Also note that</span>
01073         <span class="comment">// this may be a stream file object, which do not have security.</span>
01074         <span class="comment">// The security for a stream file is actually represented by the</span>
01075         <span class="comment">// security descriptor on the file itself, or the volume, or the</span>
01076         <span class="comment">// device.</span>
01077         <span class="comment">//</span>
01078 
01079         <span class="keywordflow">if</span> (OperationCode == <a class="code" href="../../d0/d5/se_8h.html#a200a111">AssignSecurityDescriptor</a>) {
01080 
01081             <span class="comment">//</span>
01082             <span class="comment">// Simply assign the security descriptor to the device object,</span>
01083             <span class="comment">// if this is a device object.</span>
01084             <span class="comment">//</span>
01085 
01086             <span class="keywordflow">if</span> (fileObject == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> || !(fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a158">FO_STREAM_FILE</a>)) {
01087                 <a class="code" href="../../d4/d9/ke_8h.html#a28">KeEnterCriticalRegion</a>();
01088                 <a class="code" href="../../d5/d8/ex_8h.html#a70">ExAcquireResourceExclusive</a>( &amp;IopSecurityResource, TRUE );
01089                 deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o21">SecurityDescriptor</a> = SecurityDescriptor;
01090                 <a class="code" href="../../d5/d8/ex_8h.html#a66">ExReleaseResource</a>( &amp;IopSecurityResource );
01091                 <a class="code" href="../../d4/d9/ke_8h.html#a29">KeLeaveCriticalRegion</a>();
01092             }
01093             status = STATUS_SUCCESS;
01094 
01095         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (OperationCode == <a class="code" href="../../d0/d5/se_8h.html#a200a108">SetSecurityDescriptor</a>) {
01096 
01097             <span class="comment">//</span>
01098             <span class="comment">// This is a set operation.  The SecurityInformation parameter</span>
01099             <span class="comment">// determines what part of the SecurityDescriptor is going to</span>
01100             <span class="comment">// be applied to the ObjectsSecurityDescriptor.</span>
01101             <span class="comment">//</span>
01102 
01103             <span class="comment">//</span>
01104             <span class="comment">// if this deviceObject is attached to a PDO then we want</span>
01105             <span class="comment">// to modify the security on the PDO and apply it up the</span>
01106             <span class="comment">// device chain</span>
01107             <span class="comment">//</span>
01108             <span class="keywordflow">if</span> (fileObject == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> || !(fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a161">FO_DIRECT_DEVICE_OPEN</a>)) {
01109                 <span class="comment">//</span>
01110                 <span class="comment">// see if there is a PDO for this object, and obtain it</span>
01111                 <span class="comment">//</span>
01112                 devicePDO = <a class="code" href="../../d3/d1/objsup_8c.html#a4">IopGetDevicePDO</a>(deviceObject);
01113             } <span class="keywordflow">else</span> {
01114                 devicePDO = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01115             }
01116             <span class="keywordflow">if</span> (devicePDO) {
01117                 <span class="comment">//</span>
01118                 <span class="comment">// set PDO and all attached device objects</span>
01119                 <span class="comment">//</span>
01120                 status = <a class="code" href="../../d3/d1/objsup_8c.html#a5">IopSetDeviceSecurityDescriptors</a>(devicePDO,SecurityInformation,SecurityDescriptor,PoolType,GenericMapping,TRUE);
01121                 <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( devicePDO );
01122             } <span class="keywordflow">else</span> {
01123                 <span class="comment">//</span>
01124                 <span class="comment">// set this device object only</span>
01125                 <span class="comment">//</span>
01126                 status = <a class="code" href="../../d3/d1/objsup_8c.html#a5">IopSetDeviceSecurityDescriptors</a>(deviceObject,SecurityInformation,SecurityDescriptor,PoolType,GenericMapping,FALSE);
01127             }
01128 
01129         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (OperationCode == <a class="code" href="../../d0/d5/se_8h.html#a200a109">QuerySecurityDescriptor</a>) {
01130 
01131             <span class="comment">//</span>
01132             <span class="comment">// This is a get operation.  The SecurityInformation parameter</span>
01133             <span class="comment">// determines what part of the SecurityDescriptor is going to</span>
01134             <span class="comment">// be returned from the ObjectsSecurityDescriptor.</span>
01135             <span class="comment">//</span>
01136 
01137             <a class="code" href="../../d4/d9/ke_8h.html#a28">KeEnterCriticalRegion</a>();
01138             <a class="code" href="../../d5/d8/ex_8h.html#a69">ExAcquireResourceShared</a>( &amp;IopSecurityResource, TRUE );
01139             status = <a class="code" href="../../d0/d6/semethod_8c.html#a6">SeQuerySecurityDescriptorInfo</a>( SecurityInformation,
01140                                                     SecurityDescriptor,
01141                                                     CapturedLength,
01142                                                     &amp;deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o21">SecurityDescriptor</a> );
01143             <a class="code" href="../../d5/d8/ex_8h.html#a66">ExReleaseResource</a>( &amp;IopSecurityResource );
01144             <a class="code" href="../../d4/d9/ke_8h.html#a29">KeLeaveCriticalRegion</a>();
01145 
01146         } <span class="keywordflow">else</span> {
01147 
01148             <span class="comment">//</span>
01149             <span class="comment">// This is a delete operation.  Simply indicate that everything</span>
01150             <span class="comment">// worked just fine.</span>
01151             <span class="comment">//</span>
01152 
01153             status = STATUS_SUCCESS;
01154 
01155         }
01156 
01157     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (OperationCode == <a class="code" href="../../d0/d5/se_8h.html#a200a110">DeleteSecurityDescriptor</a>) {
01158 
01159         <span class="comment">//</span>
01160         <span class="comment">// This is a delete operation for the security descriptor on a file</span>
01161         <span class="comment">// object.  This function will be performed by the file system once</span>
01162         <span class="comment">// the FCB itself is deleted.  Simply indicate that the operation</span>
01163         <span class="comment">// was successful.</span>
01164         <span class="comment">//</span>
01165 
01166         status = STATUS_SUCCESS;
01167 
01168     } <span class="keywordflow">else</span> {
01169 
01170         <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
01171         IO_STATUS_BLOCK localIoStatus;
01172         <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> event;
01173         <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
01174         <a class="code" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> requestorMode;
01175 
01176         <span class="comment">//</span>
01177         <span class="comment">// This file object does not refer to the device itself.  Rather, it</span>
01178         <span class="comment">// refers to either a file or a directory on the device.  This means</span>
01179         <span class="comment">// that the request must be passed to the file system for processing.</span>
01180         <span class="comment">// Note that the only requests that are passed through in this manner</span>
01181         <span class="comment">// are SET or QUERY security operations.  DELETE operations have</span>
01182         <span class="comment">// already been taken care of above since the file system which just</span>
01183         <span class="comment">// drop the storage on the floor when it really needs to, and ASSIGN</span>
01184         <span class="comment">// operations are irrelevant to file systems since they never</span>
01185         <span class="comment">// generate one because they never assign the security descriptor</span>
01186         <span class="comment">// to the object in the first place, they just assign it to the FCB.</span>
01187         <span class="comment">//</span>
01188 
01189         requestorMode = KeGetPreviousMode();
01190 
01191         <span class="comment">//</span>
01192         <span class="comment">// Begin by referencing the object by pointer.   Note that the object</span>
01193         <span class="comment">// handle has already been checked for the appropriate access by the</span>
01194         <span class="comment">// object system caller.  This reference must be performed because</span>
01195         <span class="comment">// standard I/O completion will dereference the object.</span>
01196         <span class="comment">//</span>
01197 
01198         <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a>( fileObject );
01199 
01200         <span class="comment">//</span>
01201         <span class="comment">// Make a special check here to determine whether this is a synchronous</span>
01202         <span class="comment">// I/O operation.  If it is, then wait here until the file is owned by</span>
01203         <span class="comment">// the current thread.  If this is not a (serialized) synchronous I/O</span>
01204         <span class="comment">// operation, then initialize the local event.</span>
01205         <span class="comment">//</span>
01206 
01207         <span class="keywordflow">if</span> (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>) {
01208 
01209             BOOLEAN interrupted;
01210 
01211             <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d6/iop_8h.html#a13">IopAcquireFastLock</a>( fileObject )) {
01212                 status = <a class="code" href="../../d0/d6/iop_8h.html#a147">IopAcquireFileObjectLock</a>( fileObject,
01213                                                    requestorMode,
01214                                                    (BOOLEAN) ((fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; FO_ALERTABLE_IO) != 0),
01215                                                    &amp;interrupted );
01216                 <span class="keywordflow">if</span> (interrupted) {
01217                     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
01218                     <span class="keywordflow">return</span> status;
01219                 }
01220             }
01221             synchronousIo = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01222         } <span class="keywordflow">else</span> {
01223             <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;event, SynchronizationEvent, FALSE );
01224             synchronousIo = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01225         }
01226 
01227         <span class="comment">//</span>
01228         <span class="comment">// Set the file object to the Not-Signaled state.</span>
01229         <span class="comment">//</span>
01230 
01231         <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a>( &amp;fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o25">Event</a> );
01232 
01233         <span class="comment">//</span>
01234         <span class="comment">// Get the address of the target device object.</span>
01235         <span class="comment">//</span>
01236 
01237         deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( fileObject );
01238 
01239         <span class="comment">//</span>
01240         <span class="comment">// Allocate and initialize the I/O Request Packet (IRP) for this</span>
01241         <span class="comment">// operation.  The allocation is performed with an exception handler</span>
01242         <span class="comment">// in case the caller does not have enough quota to allocate the packet.</span>
01243 
01244         irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a17">IoAllocateIrp</a>( deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o13">StackSize</a>, TRUE );
01245         <span class="keywordflow">if</span> (!irp) {
01246 
01247             <span class="comment">//</span>
01248             <span class="comment">// An IRP could not be allocated.  Cleanup and return an</span>
01249             <span class="comment">// appropriate error status code.</span>
01250             <span class="comment">//</span>
01251 
01252             <a class="code" href="../../d0/d6/iop_8h.html#a148">IopAllocateIrpCleanup</a>( fileObject, (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) NULL );
01253 
01254             <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
01255         }
01256         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.OriginalFileObject = fileObject;
01257         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
01258         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o10">RequestorMode</a> = requestorMode;
01259 
01260         <span class="comment">//</span>
01261         <span class="comment">// Fill in the service independent parameters in the IRP.</span>
01262         <span class="comment">//</span>
01263 
01264         <span class="keywordflow">if</span> (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>) {
01265             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01266         } <span class="keywordflow">else</span> {
01267             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = &amp;event;
01268             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a176">IRP_SYNCHRONOUS_API</a>;
01269         }
01270         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = &amp;localIoStatus;
01271         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01272 
01273         <span class="comment">//</span>
01274         <span class="comment">// Get a pointer to the stack location for the first driver.  This will</span>
01275         <span class="comment">// be used to pass the original function codes and parameters.</span>
01276         <span class="comment">//</span>
01277 
01278         irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
01279 
01280         <span class="comment">//</span>
01281         <span class="comment">// Now determine whether this is a set or a query operation.</span>
01282         <span class="comment">//</span>
01283 
01284         <span class="keywordflow">if</span> (OperationCode == <a class="code" href="../../d0/d5/se_8h.html#a200a109">QuerySecurityDescriptor</a>) {
01285 
01286             <span class="comment">//</span>
01287             <span class="comment">// This is a query operation.  Fill in the appropriate fields in</span>
01288             <span class="comment">// the stack location for the packet, as well as the fixed part</span>
01289             <span class="comment">// of the packet.  Note that each of these parameters has been</span>
01290             <span class="comment">// captured as well, so there is no need to perform any probing.</span>
01291             <span class="comment">// The only exception is the UserBuffer memory may change, but</span>
01292             <span class="comment">// that is the file system's responsibility to check.  Note that</span>
01293             <span class="comment">// it has already been probed, so the pointer is at least not</span>
01294             <span class="comment">// in an address space that the caller should not be accessing</span>
01295             <span class="comment">// because of mode.</span>
01296             <span class="comment">//</span>
01297 
01298             irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a33">IRP_MJ_QUERY_SECURITY</a>;
01299             irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.QuerySecurity.SecurityInformation = *SecurityInformation;
01300             irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.QuerySecurity.Length = *CapturedLength;
01301             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o26">UserBuffer</a> = SecurityDescriptor;
01302 
01303         } <span class="keywordflow">else</span> {
01304 
01305             <span class="comment">//</span>
01306             <span class="comment">// This is a set operation.  Fill in the appropriate fields in</span>
01307             <span class="comment">// the stack location for the packet.  Note that access to the</span>
01308             <span class="comment">// SecurityInformation parameter is safe, as the parameter was</span>
01309             <span class="comment">// captured by the caller.  Likewise, the SecurityDescriptor</span>
01310             <span class="comment">// refers to a captured copy of the descriptor.</span>
01311             <span class="comment">//</span>
01312 
01313             irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a34">IRP_MJ_SET_SECURITY</a>;
01314             irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.SetSecurity.SecurityInformation = *SecurityInformation;
01315             irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.SetSecurity.SecurityDescriptor = SecurityDescriptor;
01316 
01317         }
01318 
01319         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> = fileObject;
01320 
01321         <span class="comment">//</span>
01322         <span class="comment">// Insert the packet at the head of the IRP list for the thread.</span>
01323         <span class="comment">//</span>
01324 
01325         <a class="code" href="../../d0/d6/iop_8h.html#a21">IopQueueThreadIrp</a>( irp );
01326 
01327         <span class="comment">//</span>
01328         <span class="comment">// Update the operation count statistic for the current process for</span>
01329         <span class="comment">// operations other than read and write.</span>
01330         <span class="comment">//</span>
01331 
01332         <a class="code" href="../../d4/d6/iosubs_8c.html#a129">IopUpdateOtherOperationCount</a>();
01333 
01334         <span class="comment">//</span>
01335         <span class="comment">// Everything has been properly set up, so simply invoke the driver.</span>
01336         <span class="comment">//</span>
01337 
01338         status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( deviceObject, irp );
01339 
01340         <span class="comment">//</span>
01341         <span class="comment">// If this operation was a synchronous I/O operation, check the return</span>
01342         <span class="comment">// status to determine whether or not to wait on the file object.  If</span>
01343         <span class="comment">// the file object is to be waited on, wait for the operation to be</span>
01344         <span class="comment">// completed and obtain the final status from the file object itself.</span>
01345         <span class="comment">//</span>
01346 
01347         <span class="keywordflow">if</span> (synchronousIo) {
01348             <span class="keywordflow">if</span> (status == STATUS_PENDING) {
01349                 (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o25">Event</a>,
01350                                               Executive,
01351                                               KernelMode,
01352                                               FALSE,
01353                                               (PLARGE_INTEGER) NULL );
01354                 status = fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o8">FinalStatus</a>;
01355             }
01356             <a class="code" href="../../d0/d6/iop_8h.html#a22">IopReleaseFileObjectLock</a>( fileObject );
01357 
01358         } <span class="keywordflow">else</span> {
01359 
01360             <span class="comment">//</span>
01361             <span class="comment">// This is a normal synchronous I/O operation, as opposed to a</span>
01362             <span class="comment">// serialized synchronous I/O operation.  For this case, wait</span>
01363             <span class="comment">// for the local event and return the final status information</span>
01364             <span class="comment">// back to the caller.</span>
01365             <span class="comment">//</span>
01366 
01367             <span class="keywordflow">if</span> (status == STATUS_PENDING) {
01368                 (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
01369                                               Executive,
01370                                               KernelMode,
01371                                               FALSE,
01372                                               (PLARGE_INTEGER) NULL );
01373                 status = localIoStatus.Status;
01374             }
01375         }
01376 
01377         <span class="comment">//</span>
01378         <span class="comment">// If this operation was just attempted on a file system or a device</span>
01379         <span class="comment">// driver of some kind that does not implement security, then return</span>
01380         <span class="comment">// a normal null security descriptor.</span>
01381         <span class="comment">//</span>
01382 
01383         <span class="keywordflow">if</span> (status == STATUS_INVALID_DEVICE_REQUEST) {
01384 
01385             <span class="comment">//</span>
01386             <span class="comment">// The file system does not implement a security policy.  Determine</span>
01387             <span class="comment">// what type of operation this was and implement the correct</span>
01388             <span class="comment">// semantics for the file system.</span>
01389             <span class="comment">//</span>
01390 
01391             <span class="keywordflow">if</span> (OperationCode == <a class="code" href="../../d0/d5/se_8h.html#a200a109">QuerySecurityDescriptor</a>) {
01392 
01393                 <span class="comment">//</span>
01394                 <span class="comment">// The operation is a query.  If the caller's buffer is too</span>
01395                 <span class="comment">// small, then indicate that this is the case and let him know</span>
01396                 <span class="comment">// what size buffer is required.  Otherwise, attempt to return</span>
01397                 <span class="comment">// a null security descriptor.</span>
01398                 <span class="comment">//</span>
01399 
01400                <span class="keywordflow">try</span> {
01401                     status = <a class="code" href="../../d1/d5/seassign_8c.html#a5">SeAssignWorldSecurityDescriptor</a>(
01402                                  SecurityDescriptor,
01403                                  CapturedLength,
01404                                  SecurityInformation
01405                                  );
01406 
01407                 } except( EXCEPTION_EXECUTE_HANDLER ) {
01408 
01409                     <span class="comment">//</span>
01410                     <span class="comment">// An exception was incurred while attempting to</span>
01411                     <span class="comment">// access the caller's buffer.  Clean everything</span>
01412                     <span class="comment">// up and return an appropriate status code.</span>
01413                     <span class="comment">//</span>
01414 
01415                     status = GetExceptionCode();
01416                 }
01417 
01418             } <span class="keywordflow">else</span> {
01419 
01420                 <span class="comment">//</span>
01421                 <span class="comment">// This was an operation other than a query.  Simply indicate</span>
01422                 <span class="comment">// that the operation was successful.</span>
01423                 <span class="comment">//</span>
01424 
01425                 status = STATUS_SUCCESS;
01426             }
01427 
01428         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (OperationCode == <a class="code" href="../../d0/d5/se_8h.html#a200a109">QuerySecurityDescriptor</a>) {
01429 
01430             <span class="comment">//</span>
01431             <span class="comment">// The final return status from the file system was something</span>
01432             <span class="comment">// other than invalid device request.  This means that the file</span>
01433             <span class="comment">// system actually implemented the query.  Copy the size of the</span>
01434             <span class="comment">// returned data, or the size of the buffer required in order</span>
01435             <span class="comment">// to query the security descriptor.  Note that once again the</span>
01436             <span class="comment">// assignment is performed inside of an exception handler in case</span>
01437             <span class="comment">// the caller's buffer is inaccessible.  Also note that in order</span>
01438             <span class="comment">// for the Information field of the I/O status block to be set,</span>
01439             <span class="comment">// the file system must return a warning status.  Return the</span>
01440             <span class="comment">// status that the caller expects if the buffer really is too</span>
01441             <span class="comment">// small.</span>
01442             <span class="comment">//</span>
01443 
01444             <span class="keywordflow">if</span> (status == STATUS_BUFFER_OVERFLOW) {
01445                 status = STATUS_BUFFER_TOO_SMALL;
01446             }
01447 
01448             <span class="keywordflow">try</span> {
01449 
01450                 *CapturedLength = (ULONG) localIoStatus.Information;
01451 
01452             } except( EXCEPTION_EXECUTE_HANDLER ) {
01453                 status = GetExceptionCode();
01454             }
01455         }
01456     }
01457 
01458     <span class="keywordflow">return</span> status;
01459 }
}
</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="objsup.c::IopSetDeviceSecurityDescriptors" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> NTSTATUS IopSetDeviceSecurityDescriptors           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>DeviceObject</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PSECURITY_INFORMATION&nbsp;</td>
          <td class="mdname" nowrap> <em>SecurityInformation</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PSECURITY_DESCRIPTOR&nbsp;</td>
          <td class="mdname" nowrap> <em>SecurityDescriptor</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN <a class="el" href="../../d5/d8/ex_8h.html#a96">POOL_TYPE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>PoolType</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PGENERIC_MAPPING&nbsp;</td>
          <td class="mdname" nowrap> <em>GenericMapping</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>DoAttachedDevices</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d4/d0/objsup_8c-source.html#l00877">877</a> of file <a class="el" href="../../d4/d0/objsup_8c-source.html">objsup.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d1/d4/io_8h-source.html#l01181">_DEVICE_OBJECT::AttachedDevice</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l02475">ExAcquireResourceExclusive</a>, <a class="el" href="../../d7/d2/cmwraper_8c-source.html#l00304">ExFreePool()</a>, <a class="el" href="../../d6/d7/ex_8h-source.html#l02393">ExReleaseResource</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d0/d0/pnpiop_8h-source.html#l01266">IopAcquireEnumerationLock</a>, <a class="el" href="../../d4/d4/iodata_8c-source.html#l00054">IopDatabaseLock</a>, <a class="el" href="../../d0/d0/pnpiop_8h-source.html#l01276">IopReleaseEnumerationLock</a>, <a class="el" href="../../d4/d4/iodata_8c-source.html#l00074">IopSecurityResource</a>, <a class="el" href="../../d5/d8/ke_8h-source.html#l01598">KeEnterCriticalRegion</a>, <a class="el" href="../../d5/d8/ke_8h-source.html#l01628">KeLeaveCriticalRegion</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00494">ObDereferenceObject</a>, <a class="el" href="../../d5/d9/ob_8h-source.html#l00514">ObReferenceObject</a>, <a class="el" href="../../d1/d5/semethod_8c-source.html#l00365">SeSetSecurityDescriptorInfo()</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
Referenced by <a class="el" href="../../d4/d0/objsup_8c-source.html#l00975">IopGetSetSecurityObject()</a>.
<p>
<pre class="fragment"><div>00887                    :
00888 
00889     Call <span class="keyword">this</span> routine to set device security descriptor
00890 
00891 Arguments:
00892 
00893     DeviceObject - pointer to base device object (first one to set)
00894     SecurityInformation )_ passed directly from <a class="code" href="../../d0/d6/iop_8h.html#a183">IopGetSetSecurityObject</a>
00895     SecurityDescriptor  )
00896     PoolType            )
00897     GenericMapping      )
00898     DoAttachedDevices - <span class="keywordflow">if</span> <span class="keyword">true</span>, iterate <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> AttachedDevice list
00899 
00900 ReturnValue:
00901 
00902     success, or error from first <a class="code" href="../../d8/d0/rtbatcr_8c.html#a1">failure</a>
00903 
00904 --*/
00905 {
00906     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> NewDeviceObject = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00907     PSECURITY_DESCRIPTOR OldSecurityDescriptor;
00908     KIRQL irql;
00909     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
00910     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> firsterr = STATUS_SUCCESS;
00911     BOOLEAN first = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00912 
00913     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(DeviceObject);
00914 
00915     <a class="code" href="../../d9/d0/pnpiop_8h.html#a95">IopAcquireEnumerationLock</a>(NULL);        <span class="comment">// ensure we have acquired P&amp;P locks</span>
00916     <span class="comment">//</span>
00917     <span class="comment">// pre-reference this object to match the dereference later</span>
00918     <span class="comment">//</span>
00919     <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a>( DeviceObject );
00920 
00921     <span class="keywordflow">do</span> {
00922         <a class="code" href="../../d4/d9/ke_8h.html#a28">KeEnterCriticalRegion</a>();
00923         <a class="code" href="../../d5/d8/ex_8h.html#a70">ExAcquireResourceExclusive</a>( &amp;IopSecurityResource, TRUE );
00924 
00925         OldSecurityDescriptor = DeviceObject-&gt;SecurityDescriptor;
00926 
00927         <span class="keywordflow">if</span> (OldSecurityDescriptor || first) {
00928             <span class="comment">//</span>
00929             <span class="comment">// always call this on the first object, only do it for others that have a security descriptor</span>
00930             <span class="comment">//</span>
00931             status = <a class="code" href="../../d0/d6/semethod_8c.html#a4">SeSetSecurityDescriptorInfo</a>( NULL,
00932                                                   SecurityInformation,
00933                                                   SecurityDescriptor,
00934                                                   &amp;DeviceObject-&gt;SecurityDescriptor,
00935                                                   PoolType,
00936                                                   GenericMapping );
00937 
00938             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(firsterr)) {
00939                 firsterr = status;
00940             }
00941             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
00942                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(OldSecurityDescriptor);
00943                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( OldSecurityDescriptor );
00944             }
00945             first = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00946         }
00947 
00948         <a class="code" href="../../d5/d8/ex_8h.html#a66">ExReleaseResource</a>( &amp;IopSecurityResource );
00949         <a class="code" href="../../d4/d9/ke_8h.html#a29">KeLeaveCriticalRegion</a>();
00950 
00951         <span class="comment">//</span>
00952         <span class="comment">// get next device on attachment chain</span>
00953         <span class="comment">//</span>
00954         ExAcquireSpinLock(&amp;IopDatabaseLock,&amp;irql);
00955         NewDeviceObject = DeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o5">AttachedDevice</a>;
00956         <span class="keywordflow">if</span> ( NewDeviceObject != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
00957             <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a>( NewDeviceObject );
00958         } <span class="keywordflow">else</span> {
00959             DoAttachedDevices = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00960         }
00961         ExReleaseSpinLock(&amp;IopDatabaseLock,irql);
00962 
00963         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( DeviceObject );
00964         DeviceObject = NewDeviceObject;
00965 
00966     } <span class="keywordflow">while</span>(DoAttachedDevices);
00967 
00968     <a class="code" href="../../d9/d0/pnpiop_8h.html#a96">IopReleaseEnumerationLock</a>(NULL);
00969 
00970     <span class="keywordflow">return</span> firsterr;    <span class="comment">// of the PDO / single object</span>
00971 }

</div></pre>    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:44:58 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
