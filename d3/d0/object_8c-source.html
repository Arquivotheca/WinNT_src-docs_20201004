<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: object.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>object.c</h1><a href="../../d2/d1/object_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/****************************Module*Header******************************\</span>
00002 <span class="comment">* Module Name: OBJECT.C</span>
00003 <span class="comment">*</span>
00004 <span class="comment">* Module Descripton: Object management functions.</span>
00005 <span class="comment">*</span>
00006 <span class="comment">* Warnings:</span>
00007 <span class="comment">*</span>
00008 <span class="comment">* Issues:</span>
00009 <span class="comment">*</span>
00010 <span class="comment">* Public Routines:</span>
00011 <span class="comment">*</span>
00012 <span class="comment">* Created:  18 March 1996</span>
00013 <span class="comment">* Author:   Srinivasan Chandrasekar    [srinivac]</span>
00014 <span class="comment">*</span>
00015 <span class="comment">* Copyright (c) 1996, 1997  Microsoft Corporation</span>
00016 <span class="comment">\***********************************************************************/</span>
00017 
00018 <span class="preprocessor">#include "<a class="code" href="../../d3/d4/mscms_8h.html">mscms.h</a>"</span>
00019 
00020 <span class="comment">//</span>
00021 <span class="comment">// Number of required and optional functions for CMMs to export</span>
00022 <span class="comment">//</span>
00023 
<a name="l00024"></a><a class="code" href="../../d2/d1/object_8c.html#a0">00024</a> <span class="preprocessor">#define NUM_REQ_FNS    10</span>
<a name="l00025"></a><a class="code" href="../../d2/d1/object_8c.html#a1">00025</a> <span class="preprocessor"></span><span class="preprocessor">#define NUM_OPT_FNS    6</span>
<a name="l00026"></a><a class="code" href="../../d2/d1/object_8c.html#a2">00026</a> <span class="preprocessor"></span><span class="preprocessor">#define NUM_PS_FNS     3</span>
00027 <span class="preprocessor"></span>
00028 
00029 <span class="comment">/******************************************************************************</span>
00030 <span class="comment"> *</span>
00031 <span class="comment"> *                            AllocateHeapObject</span>
00032 <span class="comment"> *</span>
00033 <span class="comment"> *  Function:</span>
00034 <span class="comment"> *       This functions allocates requested object on the process's heap,</span>
00035 <span class="comment"> *       and returns a handle to it.</span>
00036 <span class="comment"> *</span>
00037 <span class="comment"> *  Arguments:</span>
00038 <span class="comment"> *       objType  - type of object to allocate</span>
00039 <span class="comment"> *</span>
00040 <span class="comment"> *  Returns:</span>
00041 <span class="comment"> *       Handle to object if successful, NULL otherwise</span>
00042 <span class="comment"> *</span>
00043 <span class="comment"> ******************************************************************************/</span>
00044 
00045 HANDLE
<a name="l00046"></a><a class="code" href="../../d2/d1/object_8c.html#a3">00046</a> <a class="code" href="../../d2/d1/object_8c.html#a3">AllocateHeapObject</a>(
00047     OBJECTTYPE  objType
00048     )
00049 {
00050     <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a>    dwSize;
00051     POBJHEAD pObject;
00052 
00053     <span class="keywordflow">switch</span> (objType)
00054     {
00055     <span class="keywordflow">case</span> OBJ_PROFILE:
00056         dwSize = <span class="keyword">sizeof</span>(PROFOBJ);
00057         <span class="keywordflow">break</span>;
00058 
00059     <span class="keywordflow">case</span> OBJ_TRANSFORM:
00060         dwSize = <span class="keyword">sizeof</span>(TRANSFORMOBJ);
00061         <span class="keywordflow">break</span>;
00062 
00063     <span class="keywordflow">case</span> OBJ_CMM:
00064         dwSize = <span class="keyword">sizeof</span>(CMMOBJ);
00065         <span class="keywordflow">break</span>;
00066 
00067     <span class="keywordflow">default</span>:
00068         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a9">RIP</a>((__TEXT(<span class="stringliteral">"Allocating invalid object\n"</span>)));
00069         dwSize = 0;
00070         <span class="keywordflow">break</span>;
00071     }
00072 
00073     pObject = (POBJHEAD)<a class="code" href="../../d2/d1/object_8c.html#a7">MemAlloc</a>(dwSize);
00074 
00075     <span class="keywordflow">if</span> (!pObject)
00076     {
00077         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00078     }
00079 
00080     pObject-&gt;objType = objType;
00081 
00082     <span class="keywordflow">return</span>(PTRTOHDL(pObject));
00083 }
00084 
00085 
00086 <span class="comment">/******************************************************************************</span>
00087 <span class="comment"> *</span>
00088 <span class="comment"> *                            FreeHeapObject</span>
00089 <span class="comment"> *</span>
00090 <span class="comment"> *  Function:</span>
00091 <span class="comment"> *       This functions free an object on the process's heap</span>
00092 <span class="comment"> *</span>
00093 <span class="comment"> *  Arguments:</span>
00094 <span class="comment"> *       hObject  - handle to object to free</span>
00095 <span class="comment"> *</span>
00096 <span class="comment"> *  Returns:</span>
00097 <span class="comment"> *       No return value</span>
00098 <span class="comment"> *</span>
00099 <span class="comment"> ******************************************************************************/</span>
00100 
00101 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00102"></a><a class="code" href="../../d2/d1/object_8c.html#a4">00102</a> <a class="code" href="../../d2/d1/object_8c.html#a4">FreeHeapObject</a>(
00103     HANDLE hObject
00104     )
00105 {
00106     POBJHEAD pObject;
00107 
00108     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(hObject != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00109 
00110     pObject = (POBJHEAD)HDLTOPTR(hObject);
00111 
00112     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(pObject-&gt;dwUseCount == 0);
00113 
00114     pObject-&gt;objType = 0;       <span class="comment">// in case the handle gets reused</span>
00115 
00116     <a class="code" href="../../d2/d1/object_8c.html#a9">MemFree</a>((PVOID)pObject);
00117 }
00118 
00119 
00120 <span class="comment">/******************************************************************************</span>
00121 <span class="comment"> *</span>
00122 <span class="comment"> *                            ValidHandle</span>
00123 <span class="comment"> *</span>
00124 <span class="comment"> *  Function:</span>
00125 <span class="comment"> *       This functions checks if a given handle is a valid handle to</span>
00126 <span class="comment"> *       an object of the specified type</span>
00127 <span class="comment"> *</span>
00128 <span class="comment"> *  Arguments:</span>
00129 <span class="comment"> *       hObject  - handle to an object</span>
00130 <span class="comment"> *       objType  - type of object to the handle refers to</span>
00131 <span class="comment"> *</span>
00132 <span class="comment"> *  Returns:</span>
00133 <span class="comment"> *       TRUE is the handle is valid, FALSE otherwise.</span>
00134 <span class="comment"> *</span>
00135 <span class="comment"> ******************************************************************************/</span>
00136 
00137 <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a>
<a name="l00138"></a><a class="code" href="../../d2/d1/object_8c.html#a5">00138</a> <a class="code" href="../../d2/d1/object_8c.html#a5">ValidHandle</a>(
00139     HANDLE  hObject,
00140     OBJECTTYPE objType
00141     )
00142 {
00143     POBJHEAD pObject;
00144     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a>     rc;
00145 
00146     <span class="keywordflow">if</span> (!hObject)
00147     {
00148         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00149     }
00150 
00151     pObject = (POBJHEAD)HDLTOPTR(hObject);
00152 
00153     rc = !IsBadReadPtr(pObject, <span class="keyword">sizeof</span>(<a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a>)) &amp;&amp;
00154          (pObject-&gt;objType == objType);
00155 
00156     <span class="keywordflow">return</span> rc;
00157 }
00158 
00159 
00160 <span class="comment">/******************************************************************************</span>
00161 <span class="comment"> *</span>
00162 <span class="comment"> *                           ValidProfile</span>
00163 <span class="comment"> *</span>
00164 <span class="comment"> *  Function:</span>
00165 <span class="comment"> *       This function checks if a given profile is valid by doing some</span>
00166 <span class="comment"> *       sanity checks on it. It is not a fool prof check.</span>
00167 <span class="comment"> *</span>
00168 <span class="comment"> *  Arguments:</span>
00169 <span class="comment"> *       pProfObj  - pointer to profile object</span>
00170 <span class="comment"> *</span>
00171 <span class="comment"> *  Returns:</span>
00172 <span class="comment"> *       TRUE if it is a valid profile, FALSE otherwise</span>
00173 <span class="comment"> *</span>
00174 <span class="comment"> ******************************************************************************/</span>
00175 
<a name="l00176"></a><a class="code" href="../../d2/d1/object_8c.html#a6">00176</a> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a> <a class="code" href="../../d2/d1/object_8c.html#a6">ValidProfile</a>(
00177     PPROFOBJ pProfObj
00178     )
00179 {
00180     <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a> dwSize = FIX_ENDIAN(HEADER(pProfObj)-&gt;phSize);
00181 
00182     <span class="keywordflow">return</span> ((dwSize &lt;= pProfObj-&gt;dwMapSize) &amp;&amp;
00183             (HEADER(pProfObj)-&gt;phSignature == PROFILE_SIGNATURE) &amp;&amp;
00184             (dwSize &gt;= (<span class="keyword">sizeof</span>(PROFILEHEADER) + <span class="keyword">sizeof</span>(<a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a>))));
00185 }
00186 
00187 
00188 <span class="comment">/******************************************************************************</span>
00189 <span class="comment"> *</span>
00190 <span class="comment"> *                            MemAlloc</span>
00191 <span class="comment"> *</span>
00192 <span class="comment"> *  Function:</span>
00193 <span class="comment"> *       This functions allocates requested amount of zero initialized memory</span>
00194 <span class="comment"> *       from the process's heap and returns a pointer to it</span>
00195 <span class="comment"> *</span>
00196 <span class="comment"> *  Arguments:</span>
00197 <span class="comment"> *       dwSize  - amount of memory to allocate in bytes</span>
00198 <span class="comment"> *</span>
00199 <span class="comment"> *  Returns:</span>
00200 <span class="comment"> *       Pointer to memory if successful, NULL otherwise</span>
00201 <span class="comment"> *</span>
00202 <span class="comment"> ******************************************************************************/</span>
00203 
00204 PVOID
<a name="l00205"></a><a class="code" href="../../d2/d1/object_8c.html#a7">00205</a> <a class="code" href="../../d2/d1/object_8c.html#a7">MemAlloc</a>(
00206     DWORD dwSize
00207     )
00208 {
00209     <span class="keywordflow">if</span> (dwSize &gt; 0)
00210         <span class="keywordflow">return</span> (PVOID)GlobalAllocPtr(GHND | GMEM_ZEROINIT, dwSize);
00211     <span class="keywordflow">else</span>
00212         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00213 }
00214 
00215 
00216 <span class="comment">/******************************************************************************</span>
00217 <span class="comment"> *</span>
00218 <span class="comment"> *                            MemReAlloc</span>
00219 <span class="comment"> *</span>
00220 <span class="comment"> *  Function:</span>
00221 <span class="comment"> *       This functions reallocates a block of memory from the process's</span>
00222 <span class="comment"> *       heap and returns a pointer to it</span>
00223 <span class="comment"> *</span>
00224 <span class="comment"> *  Arguments:</span>
00225 <span class="comment"> *       pMemory    - pointer to original memory</span>
00226 <span class="comment"> *       dwNewSize  - new size to reallocate</span>
00227 <span class="comment"> *</span>
00228 <span class="comment"> *  Returns:</span>
00229 <span class="comment"> *       Pointer to memory if successful, NULL otherwise</span>
00230 <span class="comment"> *</span>
00231 <span class="comment"> ******************************************************************************/</span>
00232 
00233 PVOID
<a name="l00234"></a><a class="code" href="../../d2/d1/object_8c.html#a8">00234</a> <a class="code" href="../../d2/d1/object_8c.html#a8">MemReAlloc</a>(
00235     PVOID pMemory,
00236     DWORD dwNewSize
00237     )
00238 {
00239     <span class="keywordflow">return</span> (PVOID)GlobalReAllocPtr(pMemory, dwNewSize, GMEM_ZEROINIT);
00240 }
00241 
00242 
00243 <span class="comment">/******************************************************************************</span>
00244 <span class="comment"> *</span>
00245 <span class="comment"> *                            MemFree</span>
00246 <span class="comment"> *</span>
00247 <span class="comment"> *  Function:</span>
00248 <span class="comment"> *       This functions frees memory from the process's heap</span>
00249 <span class="comment"> *       and returns a handle to it.</span>
00250 <span class="comment"> *</span>
00251 <span class="comment"> *  Arguments:</span>
00252 <span class="comment"> *       pMemory  - pointer to memory to free</span>
00253 <span class="comment"> *</span>
00254 <span class="comment"> *  Returns:</span>
00255 <span class="comment"> *       No return value</span>
00256 <span class="comment"> *</span>
00257 <span class="comment"> ******************************************************************************/</span>
00258 
00259 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00260"></a><a class="code" href="../../d2/d1/object_8c.html#a9">00260</a> <a class="code" href="../../d2/d1/object_8c.html#a9">MemFree</a>(
00261     PVOID pMemory
00262     )
00263 {
00264     <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a> dwErr;
00265 
00266     <span class="comment">//</span>
00267     <span class="comment">// GlobalFree() resets last error, we get and set around it so we don't</span>
00268     <span class="comment">// lose anything we have set.</span>
00269     <span class="comment">//</span>
00270 
00271     dwErr = GetLastError();
00272     GlobalFreePtr(pMemory);
00273     <span class="keywordflow">if</span> (dwErr)
00274     {
00275         SetLastError(dwErr);
00276     }
00277 }
00278 
00279 
00280 <span class="comment">/******************************************************************************</span>
00281 <span class="comment"> *</span>
00282 <span class="comment"> *                            MyCopyMemory</span>
00283 <span class="comment"> *</span>
00284 <span class="comment"> *  Function:</span>
00285 <span class="comment"> *       This functions copies data from one place to another. It takes care</span>
00286 <span class="comment"> *       of overlapping cases. The reason we have our own function and not use</span>
00287 <span class="comment"> *       MoveMemory is that MoveMemory uses memmove which pulls in msvcrt.dll</span>
00288 <span class="comment"> *</span>
00289 <span class="comment"> *  Arguments:</span>
00290 <span class="comment"> *       pDest    - pointer to destination of copy</span>
00291 <span class="comment"> *       pSrc     - pointer to source</span>
00292 <span class="comment"> *       dwCount  - number of bytes to copy</span>
00293 <span class="comment"> *</span>
00294 <span class="comment"> *  Returns:</span>
00295 <span class="comment"> *       No return value</span>
00296 <span class="comment"> *</span>
00297 <span class="comment"> ******************************************************************************/</span>
00298 
00299 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00300"></a><a class="code" href="../../d2/d1/object_8c.html#a10">00300</a> <a class="code" href="../../d2/d1/object_8c.html#a10">MyCopyMemory</a>(
00301     PBYTE pDest,
00302     PBYTE pSrc,
00303     DWORD dwCount
00304     )
00305 {
00306     <span class="comment">//</span>
00307     <span class="comment">// Make sure overlapping cases are handled</span>
00308     <span class="comment">//</span>
00309 
00310     <span class="keywordflow">if</span> ((pSrc &lt; pDest) &amp;&amp; ((pSrc + dwCount) &gt;= pDest))
00311     {
00312         <span class="comment">//</span>
00313         <span class="comment">// Overlapping case, copy in reverse</span>
00314         <span class="comment">//</span>
00315 
00316         pSrc += dwCount - 1;
00317         pDest += dwCount - 1;
00318 
00319         <span class="keywordflow">while</span> (dwCount--)
00320         {
00321             *pDest-- = *pSrc--;
00322         }
00323 
00324     }
00325     <span class="keywordflow">else</span>
00326     {
00327         <span class="keywordflow">while</span> (dwCount--)
00328         {
00329             *pDest++ = *pSrc++;
00330         }
00331     }
00332 
00333     <span class="keywordflow">return</span>;
00334 }
00335 
00336 
00337 <span class="comment">/******************************************************************************</span>
00338 <span class="comment"> *</span>
00339 <span class="comment"> *                              ConvertToUnicode</span>
00340 <span class="comment"> *</span>
00341 <span class="comment"> *  Function:</span>
00342 <span class="comment"> *       This function converts a given Ansi string to Unicode. It optionally</span>
00343 <span class="comment"> *       allocates memory for the Unicode string which the calling program</span>
00344 <span class="comment"> *       needs to free.</span>
00345 <span class="comment"> *</span>
00346 <span class="comment"> *  Arguments:</span>
00347 <span class="comment"> *       pszAnsiStr      - pointer to Ansi string to convert</span>
00348 <span class="comment"> *       ppwszUnicodeStr - pointer to pointer to Unicode string</span>
00349 <span class="comment"> *       bAllocate       - If TRUE, allocate memory for Unicode string</span>
00350 <span class="comment"> *</span>
00351 <span class="comment"> *  Returns:</span>
00352 <span class="comment"> *       TRUE if successful, FALSE otherwise</span>
00353 <span class="comment"> *</span>
00354 <span class="comment"> ******************************************************************************/</span>
00355 
00356 <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a>
<a name="l00357"></a><a class="code" href="../../d2/d1/object_8c.html#a11">00357</a> <a class="code" href="../../d2/d1/object_8c.html#a11">ConvertToUnicode</a>(
00358     PCSTR  pszAnsiStr,
00359     PWSTR *ppwszUnicodeStr,
00360     BOOL   bAllocate
00361     )
00362 {
00363     <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a> dwLen;                    <span class="comment">// length of Unicode string</span>
00364 
00365     dwLen = (lstrlenA(pszAnsiStr) + 1) * <span class="keyword">sizeof</span>(WCHAR);
00366 
00367     <span class="comment">//</span>
00368     <span class="comment">// Allocate memory for Unicode string</span>
00369     <span class="comment">//</span>
00370 
00371     <span class="keywordflow">if</span> (bAllocate)
00372     {
00373         *ppwszUnicodeStr =  (PWSTR)<a class="code" href="../../d2/d1/object_8c.html#a7">MemAlloc</a>(dwLen);
00374         <span class="keywordflow">if</span> (! (*ppwszUnicodeStr))
00375         {
00376             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a4">WARNING</a>((__TEXT(<span class="stringliteral">"Error allocating memory for Unicode name\n"</span>)));
00377             SetLastError(ERROR_NOT_ENOUGH_MEMORY);
00378             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00379         }
00380     }
00381 
00382     <span class="comment">//</span>
00383     <span class="comment">// Convert Ansi string to Unicode</span>
00384     <span class="comment">//</span>
00385 
00386     <span class="keywordflow">if</span> (! MultiByteToWideChar(CP_ACP, 0, pszAnsiStr, -1,
00387             *ppwszUnicodeStr, dwLen))
00388     {
00389         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a4">WARNING</a>((__TEXT(<span class="stringliteral">"Error converting to Unicode name\n"</span>)));
00390         <a class="code" href="../../d2/d1/object_8c.html#a9">MemFree</a>(*ppwszUnicodeStr);
00391         *ppwszUnicodeStr = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00392         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00393     }
00394 
00395     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00396 }
00397 
00398 
00399 <span class="comment">/******************************************************************************</span>
00400 <span class="comment"> *</span>
00401 <span class="comment"> *                              ConvertToAnsi</span>
00402 <span class="comment"> *</span>
00403 <span class="comment"> *  Function:</span>
00404 <span class="comment"> *       This function converts a given Unicode string to Ansi. It optionally</span>
00405 <span class="comment"> *       allocates memory for the Ansi string which the calling program needs</span>
00406 <span class="comment"> *       to free.</span>
00407 <span class="comment"> *</span>
00408 <span class="comment"> *  Arguments:</span>
00409 <span class="comment"> *       pwszUnicodeStr  - pointer to Unicode string to convert</span>
00410 <span class="comment"> *       ppszAnsiStr     - pointer to pointer to Ansi string.</span>
00411 <span class="comment"> *       bAllocate       - If TRUE, allocate memory for Ansi string</span>
00412 <span class="comment"> *</span>
00413 <span class="comment"> *  Returns:</span>
00414 <span class="comment"> *       TRUE if successful, FALSE otherwise</span>
00415 <span class="comment"> *</span>
00416 <span class="comment"> ******************************************************************************/</span>
00417 
00418 <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a>
<a name="l00419"></a><a class="code" href="../../d2/d1/object_8c.html#a12">00419</a> <a class="code" href="../../d2/d1/object_8c.html#a12">ConvertToAnsi</a>(
00420     PCWSTR  pwszUnicodeStr,
00421     PSTR   *ppszAnsiStr,
00422     BOOL    bAllocate
00423     )
00424 {
00425     <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a> dwLen;                    <span class="comment">// length of Ansi string</span>
00426     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a>  bUsedDefaultChar;         <span class="comment">// if default characters were used in</span>
00427                                     <span class="comment">// converting Unicode to Ansi</span>
00428 
00429     dwLen = (lstrlenW(pwszUnicodeStr) + 1) * <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>);
00430 
00431     <span class="comment">//</span>
00432     <span class="comment">// Allocate memory for Ansi string</span>
00433     <span class="comment">//</span>
00434 
00435     <span class="keywordflow">if</span> (bAllocate)
00436     {
00437         *ppszAnsiStr = (PSTR)<a class="code" href="../../d2/d1/object_8c.html#a7">MemAlloc</a>(dwLen);
00438         <span class="keywordflow">if</span> (! (*ppszAnsiStr))
00439         {
00440             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a4">WARNING</a>((__TEXT(<span class="stringliteral">"Error allocating memory for ANSI name\n"</span>)));
00441             SetLastError(ERROR_NOT_ENOUGH_MEMORY);
00442             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00443         }
00444     }
00445 
00446     <span class="comment">//</span>
00447     <span class="comment">// Convert Unicode string to Ansi</span>
00448     <span class="comment">//</span>
00449 
00450     <span class="keywordflow">if</span> (! WideCharToMultiByte(CP_ACP, 0, pwszUnicodeStr, -1, *ppszAnsiStr,
00451             dwLen, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, &amp;bUsedDefaultChar) || bUsedDefaultChar)
00452     {
00453         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a4">WARNING</a>((__TEXT(<span class="stringliteral">"Error converting to Ansi name\n"</span>)));
00454         <a class="code" href="../../d2/d1/object_8c.html#a9">MemFree</a>(*ppszAnsiStr);
00455         *ppszAnsiStr = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00456         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00457     }
00458 
00459     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00460 }
00461 
00462 <span class="comment">/******************************************************************************</span>
00463 <span class="comment"> *</span>
00464 <span class="comment"> *                         ValidColorMatchingModule</span>
00465 <span class="comment"> *</span>
00466 <span class="comment"> *  Function:</span>
00467 <span class="comment"> *</span>
00468 <span class="comment"> *  Arguments:</span>
00469 <span class="comment"> *       cmmID   - ID identifing the CMM</span>
00470 <span class="comment"> *       pCMMDll - pointer to CMM module path and file name</span>
00471 <span class="comment"> *</span>
00472 <span class="comment"> *  Returns:</span>
00473 <span class="comment"> *</span>
00474 <span class="comment"> ******************************************************************************/</span>
00475 
00476 <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a>
<a name="l00477"></a><a class="code" href="../../d2/d1/object_8c.html#a13">00477</a> <a class="code" href="../../d2/d1/object_8c.html#a13">ValidColorMatchingModule</a>(
00478     DWORD cmmID,
00479     PTSTR pCMMDll
00480     )
00481 {
00482     HINSTANCE hInstance = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00483     <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a>    (WINAPI *pfnCMGetInfo)(<a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a>);
00484     FARPROC   pfnCMRequired;
00485     <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a>     i;
00486     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a>      rc = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;       <span class="comment">// Assume failure</span>
00487 
00488     <span class="comment">//</span>
00489     <span class="comment">// Load the CMM</span>
00490     <span class="comment">//</span>
00491 
00492     hInstance = LoadLibrary(pCMMDll);
00493 
00494     <span class="keywordflow">if</span> (!hInstance)
00495     {
00496         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a4">WARNING</a>((__TEXT(<span class="stringliteral">"Could not load CMM %s\n"</span>), pCMMDll));
00497         <span class="keywordflow">goto</span> EndValidColorMatchingModule;
00498     }
00499 
00500     (PVOID) pfnCMGetInfo = (PVOID) GetProcAddress(hInstance, <a class="code" href="../../d1/d6/ntgdi_2icm_2mscms_2globals_8c.html#a2">gszCMMReqFns</a>[0]);
00501 
00502     <span class="keywordflow">if</span> (!pfnCMGetInfo)
00503     {
00504         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a5">ERR</a>((__TEXT(<span class="stringliteral">"CMM does not export CMGetInfo\n"</span>)));
00505         <span class="keywordflow">goto</span> EndValidColorMatchingModule;
00506     }
00507 
00508     <span class="comment">//</span>
00509     <span class="comment">// Check if the CMM is the right version and reports the same ID</span>
00510     <span class="comment">//</span>
00511 
00512     <span class="keywordflow">if</span> ((pfnCMGetInfo(<a class="code" href="../../d8/d6/mscmm_2icm32_8c.html#a4">CMM_VERSION</a>) &lt; 0x00050000) ||
00513         (pfnCMGetInfo(<a class="code" href="../../d8/d6/mscmm_2icm32_8c.html#a1">CMM_IDENT</a>) != cmmID))
00514     {
00515         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a5">ERR</a>((__TEXT(<span class="stringliteral">"CMM %s not correct version or reports incorrect ID\n"</span>), pCMMDll));
00516         <span class="keywordflow">goto</span> EndValidColorMatchingModule;
00517     }
00518 
00519     <span class="comment">//</span>
00520     <span class="comment">// Check the remaining required functions is presented</span>
00521     <span class="comment">//</span>
00522 
00523     <span class="keywordflow">for</span> (i=1; i&lt;<a class="code" href="../../d2/d1/object_8c.html#a0">NUM_REQ_FNS</a>; i++)
00524     {
00525         pfnCMRequired = GetProcAddress(hInstance, <a class="code" href="../../d1/d6/ntgdi_2icm_2mscms_2globals_8c.html#a2">gszCMMReqFns</a>[i]);
00526         <span class="keywordflow">if</span> (!pfnCMRequired)
00527         {
00528             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a5">ERR</a>((__TEXT(<span class="stringliteral">"CMM %s does not export %s\n"</span>), pCMMDll, <a class="code" href="../../d1/d6/ntgdi_2icm_2mscms_2globals_8c.html#a2">gszCMMReqFns</a>[i]));
00529             <span class="keywordflow">goto</span> EndValidColorMatchingModule;
00530         }
00531     }
00532 
00533     rc = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00534 
00535 EndValidColorMatchingModule:
00536 
00537     <span class="keywordflow">if</span> (hInstance)
00538     {
00539         FreeLibrary(hInstance);
00540     }
00541 
00542     <span class="keywordflow">return</span> rc;
00543 }
00544 
00545 
00546 <span class="comment">/******************************************************************************</span>
00547 <span class="comment"> *</span>
00548 <span class="comment"> *                         GetColorMatchingModule</span>
00549 <span class="comment"> *</span>
00550 <span class="comment"> *  Function:</span>
00551 <span class="comment"> *       This functions returns a pointer to a CMMObject corresponding to</span>
00552 <span class="comment"> *       the ID given. It first looks a the list of CMM objects loaded</span>
00553 <span class="comment"> *       into memory, and if it doesn't find the right one, loads it.</span>
00554 <span class="comment"> *</span>
00555 <span class="comment"> *  Arguments:</span>
00556 <span class="comment"> *       cmmID   - ID identifing the CMM</span>
00557 <span class="comment"> *</span>
00558 <span class="comment"> *  Returns:</span>
00559 <span class="comment"> *       Pointer to the CMM object if successful, NULL otherwise</span>
00560 <span class="comment"> *</span>
00561 <span class="comment"> ******************************************************************************/</span>
00562 
00563 PCMMOBJ
<a name="l00564"></a><a class="code" href="../../d2/d1/object_8c.html#a14">00564</a> <a class="code" href="../../d2/d1/object_8c.html#a14">GetColorMatchingModule</a>(
00565     DWORD cmmID
00566     )
00567 {
00568     HANDLE    hCMMObj;
00569     PCMMOBJ   pCMMObj = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00570     FARPROC   *ppTemp;
00571     HINSTANCE hInstance = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00572     HKEY      hkCMM = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00573     <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a>     dwTaskID;
00574     TCHAR     szCMMID[5];
00575     <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a>     dwType, bufSize, i;
00576     TCHAR     szBuffer[<a class="code" href="../../d3/d9/arcinst_8c.html#a6">MAX_PATH</a>];
00577     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a>      rc = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;       <span class="comment">// Assume failure</span>
00578 
00579     <span class="comment">//</span>
00580     <span class="comment">// Check if we have already loaded this CMM</span>
00581     <span class="comment">//</span>
00582 
00583     dwTaskID = <a class="code" href="../../d4/d1/userk_8h.html#a19">GetCurrentProcessId</a>();
00584 
00585     EnterCriticalSection(&amp;<a class="code" href="../../d1/d6/ntgdi_2icm_2mscms_2globals_8c.html#a19">critsec</a>);     <span class="comment">// Critical section</span>
00586     pCMMObj = <a class="code" href="../../d1/d6/ntgdi_2icm_2mscms_2globals_8c.html#a0">gpCMMChain</a>;
00587 
00588     <span class="keywordflow">while</span> (pCMMObj)
00589     {
00590         <span class="keywordflow">if</span> ((pCMMObj-&gt;dwCMMID == cmmID) &amp;&amp; (pCMMObj-&gt;dwTaskID == dwTaskID))
00591         {
00592             pCMMObj-&gt;objHdr.dwUseCount++;
00593             <span class="keywordflow">break</span>;
00594         }
00595         pCMMObj = pCMMObj-&gt;pNext;
00596     }
00597     LeaveCriticalSection(&amp;<a class="code" href="../../d1/d6/ntgdi_2icm_2mscms_2globals_8c.html#a19">critsec</a>);     <span class="comment">// Critical section</span>
00598 
00599     <span class="keywordflow">if</span> (pCMMObj)
00600         <span class="keywordflow">return</span> pCMMObj;
00601 
00602     <span class="comment">//</span>
00603     <span class="comment">// CMM not already loaded - check to see if it is default CMM before</span>
00604     <span class="comment">// looking in the registry</span>
00605     <span class="comment">//</span>
00606 
00607     <span class="keywordflow">if</span> (cmmID == CMM_WINDOWS_DEFAULT)
00608     {
00609         hInstance = LoadLibrary(<a class="code" href="../../d1/d6/ntgdi_2icm_2mscms_2globals_8c.html#a18">gszDefaultCMM</a>);
00610         <span class="keywordflow">goto</span> AttemptedLoadingCMM;
00611     }
00612 
00613     <span class="comment">//</span>
00614     <span class="comment">// Not default CMM, look in the registry</span>
00615     <span class="comment">//</span>
00616 
00617     <span class="keywordflow">if</span> (RegOpenKey(HKEY_LOCAL_MACHINE, <a class="code" href="../../d1/d6/ntgdi_2icm_2mscms_2globals_8c.html#a7">gszICMatcher</a>, &amp;hkCMM) != ERROR_SUCCESS)
00618     {
00619         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00620     }
00621 
00622     <span class="comment">//</span>
00623     <span class="comment">// Make a string with the CMM ID</span>
00624     <span class="comment">//</span>
00625 
00626 <span class="preprocessor">#ifdef UNICODE</span>
00627 <span class="preprocessor"></span>    {
00628         <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a> temp = FIX_ENDIAN(cmmID);
00629 
00630         <span class="keywordflow">if</span> (!MultiByteToWideChar(CP_ACP, 0, (PSTR)&amp;temp, 4, szCMMID, 5))
00631         {
00632             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a4">WARNING</a>((__TEXT(<span class="stringliteral">"Could not convert cmmID %x to Unicode\n"</span>), temp));
00633             <span class="keywordflow">goto</span> EndGetColorMatchingModule;
00634         }
00635     }
00636 <span class="preprocessor">#else</span>
00637 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (i=0; i&lt;4; i++)
00638     {
00639         szCMMID[i] = ((PSTR)&amp;cmmID)[3-i];
00640     }
00641 <span class="preprocessor">#endif</span>
00642 <span class="preprocessor"></span>    szCMMID[4] = <span class="charliteral">'\0'</span>;
00643 
00644     <span class="comment">//</span>
00645     <span class="comment">// Get the file name of the CMM dll if registered</span>
00646     <span class="comment">//</span>
00647 
00648     bufSize = <a class="code" href="../../d3/d9/arcinst_8c.html#a6">MAX_PATH</a>;
00649     <span class="keywordflow">if</span> (RegQueryValueEx(hkCMM, (PTSTR)szCMMID, 0, &amp;dwType, (<a class="code" href="../../d9/d7/halvprnt_8c.html#a0">BYTE</a> *)szBuffer, &amp;bufSize) !=
00650         ERROR_SUCCESS)
00651     {
00652         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a4">WARNING</a>((__TEXT(<span class="stringliteral">"CMM %s not registered\n"</span>), szCMMID));
00653         <span class="keywordflow">goto</span> EndGetColorMatchingModule;
00654     }
00655 
00656     <span class="comment">//</span>
00657     <span class="comment">// Load the CMM</span>
00658     <span class="comment">//</span>
00659 
00660     hInstance = LoadLibrary(szBuffer);
00661 
00662 AttemptedLoadingCMM:
00663 
00664     <span class="keywordflow">if</span> (!hInstance)
00665     {
00666         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a4">WARNING</a>((__TEXT(<span class="stringliteral">"Could not load CMM %x\n"</span>), cmmID));
00667         <span class="keywordflow">goto</span> EndGetColorMatchingModule;
00668     }
00669 
00670     <span class="comment">//</span>
00671     <span class="comment">// Allocate a CMM object</span>
00672     <span class="comment">//</span>
00673 
00674     hCMMObj = <a class="code" href="../../d2/d1/object_8c.html#a3">AllocateHeapObject</a>(OBJ_CMM);
00675     <span class="keywordflow">if</span> (!hCMMObj)
00676     {
00677         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a5">ERR</a>((__TEXT(<span class="stringliteral">"Could not allocate CMM object\n"</span>)));
00678         <span class="keywordflow">goto</span> EndGetColorMatchingModule;
00679     }
00680 
00681     pCMMObj = (PCMMOBJ)HDLTOPTR(hCMMObj);
00682 
00683     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(pCMMObj != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00684 
00685     <span class="comment">//</span>
00686     <span class="comment">// Fill in the CMM object</span>
00687     <span class="comment">//</span>
00688 
00689     pCMMObj-&gt;objHdr.dwUseCount = 1;
00690     pCMMObj-&gt;dwCMMID = cmmID;
00691     pCMMObj-&gt;dwTaskID = dwTaskID;
00692     pCMMObj-&gt;hCMM = hInstance;
00693 
00694     ppTemp = (FARPROC *)&amp;pCMMObj-&gt;fns.pCMGetInfo;
00695     *ppTemp = GetProcAddress(hInstance, <a class="code" href="../../d1/d6/ntgdi_2icm_2mscms_2globals_8c.html#a2">gszCMMReqFns</a>[0]);
00696     ppTemp++;
00697 
00698     <span class="keywordflow">if</span> (!pCMMObj-&gt;fns.pCMGetInfo)
00699     {
00700         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a5">ERR</a>((__TEXT(<span class="stringliteral">"CMM does not export CMGetInfo\n"</span>)));
00701         <span class="keywordflow">goto</span> EndGetColorMatchingModule;
00702     }
00703 
00704     <span class="comment">//</span>
00705     <span class="comment">// Check if the CMM is the right version and reports the same ID</span>
00706     <span class="comment">//</span>
00707 
00708     <span class="keywordflow">if</span> (pCMMObj-&gt;fns.pCMGetInfo(<a class="code" href="../../d8/d6/mscmm_2icm32_8c.html#a4">CMM_VERSION</a>) &lt; 0x00050000 ||
00709         pCMMObj-&gt;fns.pCMGetInfo(<a class="code" href="../../d8/d6/mscmm_2icm32_8c.html#a1">CMM_IDENT</a>) != cmmID)
00710     {
00711         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a5">ERR</a>((__TEXT(<span class="stringliteral">"CMM not correct version or reports incorrect ID\n"</span>)));
00712         <span class="keywordflow">goto</span> EndGetColorMatchingModule;
00713     }
00714 
00715     <span class="comment">//</span>
00716     <span class="comment">// Load the remaining required functions</span>
00717     <span class="comment">//</span>
00718 
00719     <span class="keywordflow">for</span> (i=1; i&lt;<a class="code" href="../../d2/d1/object_8c.html#a0">NUM_REQ_FNS</a>; i++)
00720     {
00721         *ppTemp = GetProcAddress(hInstance, <a class="code" href="../../d1/d6/ntgdi_2icm_2mscms_2globals_8c.html#a2">gszCMMReqFns</a>[i]);
00722         <span class="keywordflow">if</span> (!*ppTemp)
00723         {
00724             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a5">ERR</a>((__TEXT(<span class="stringliteral">"CMM %s does not export %s\n"</span>), szCMMID, <a class="code" href="../../d1/d6/ntgdi_2icm_2mscms_2globals_8c.html#a2">gszCMMReqFns</a>[i]));
00725             <span class="keywordflow">goto</span> EndGetColorMatchingModule;
00726         }
00727         ppTemp++;
00728     }
00729 
00730     <span class="comment">//</span>
00731     <span class="comment">// Load the optional functions</span>
00732     <span class="comment">//</span>
00733 
00734     <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="../../d2/d1/object_8c.html#a1">NUM_OPT_FNS</a>; i++)
00735     {
00736         *ppTemp = GetProcAddress(hInstance, <a class="code" href="../../d1/d6/ntgdi_2icm_2mscms_2globals_8c.html#a3">gszCMMOptFns</a>[i]);
00737 
00738         <span class="comment">//</span>
00739         <span class="comment">// Even these functions are required for Windows default CMM</span>
00740         <span class="comment">//</span>
00741 
00742         <span class="keywordflow">if</span> (cmmID == CMM_WINDOWS_DEFAULT &amp;&amp; !*ppTemp)
00743         {
00744             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a5">ERR</a>((__TEXT(<span class="stringliteral">"Windows default CMM does not export %s\n"</span>), <a class="code" href="../../d1/d6/ntgdi_2icm_2mscms_2globals_8c.html#a3">gszCMMOptFns</a>[i]));
00745             <span class="keywordflow">goto</span> EndGetColorMatchingModule;
00746         }
00747         ppTemp++;
00748     }
00749 
00750     <span class="comment">//</span>
00751     <span class="comment">// Load the PS functions - these are optional even for the default CMM</span>
00752     <span class="comment">//</span>
00753 
00754     <span class="keywordflow">for</span> (i=0; i&lt;<a class="code" href="../../d2/d1/object_8c.html#a2">NUM_PS_FNS</a>; i++)
00755     {
00756         *ppTemp = GetProcAddress(hInstance, <a class="code" href="../../d1/d6/ntgdi_2icm_2mscms_2globals_8c.html#a4">gszPSFns</a>[i]);
00757         ppTemp++;
00758     }
00759 
00760     <span class="comment">//</span>
00761     <span class="comment">// If any of the PS Level2 fns is not exported, do not use this CMM</span>
00762     <span class="comment">// for any of the PS Level 2 functionality</span>
00763     <span class="comment">//</span>
00764 
00765     <span class="keywordflow">if</span> (!pCMMObj-&gt;fns.pCMGetPS2ColorSpaceArray ||
00766         !pCMMObj-&gt;fns.pCMGetPS2ColorRenderingIntent ||
00767         !pCMMObj-&gt;fns.pCMGetPS2ColorRenderingDictionary)
00768     {
00769         pCMMObj-&gt;fns.pCMGetPS2ColorSpaceArray = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00770         pCMMObj-&gt;fns.pCMGetPS2ColorRenderingIntent = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00771         pCMMObj-&gt;fns.pCMGetPS2ColorRenderingDictionary = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00772         pCMMObj-&gt;dwFlags |= CMM_DONT_USE_PS2_FNS;
00773     }
00774 
00775     <span class="comment">//</span>
00776     <span class="comment">// Add the CMM object to the chain at the beginning</span>
00777     <span class="comment">//</span>
00778 
00779     EnterCriticalSection(&amp;<a class="code" href="../../d1/d6/ntgdi_2icm_2mscms_2globals_8c.html#a19">critsec</a>);     <span class="comment">// Critical section</span>
00780     pCMMObj-&gt;pNext = <a class="code" href="../../d1/d6/ntgdi_2icm_2mscms_2globals_8c.html#a0">gpCMMChain</a>;
00781     <a class="code" href="../../d1/d6/ntgdi_2icm_2mscms_2globals_8c.html#a0">gpCMMChain</a> = pCMMObj;
00782     LeaveCriticalSection(&amp;<a class="code" href="../../d1/d6/ntgdi_2icm_2mscms_2globals_8c.html#a19">critsec</a>);     <span class="comment">// Critical section</span>
00783 
00784     rc = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;                          <span class="comment">// Success!</span>
00785 
00786 EndGetColorMatchingModule:
00787 
00788     <span class="keywordflow">if</span> (!rc)
00789     {
00790         <span class="keywordflow">if</span> (pCMMObj)
00791         {
00792             pCMMObj-&gt;objHdr.dwUseCount--;   <span class="comment">// decrement before freeing</span>
00793             <a class="code" href="../../d2/d1/object_8c.html#a4">FreeHeapObject</a>(hCMMObj);
00794             pCMMObj = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00795         }
00796         <span class="keywordflow">if</span> (hInstance)
00797         {
00798             FreeLibrary(hInstance);
00799         }
00800     }
00801 
00802     <span class="keywordflow">if</span> (hkCMM)
00803     {
00804         RegCloseKey(hkCMM);
00805     }
00806 
00807     <span class="keywordflow">return</span> pCMMObj;
00808 }
00809 
00810 
00811 <span class="comment">/******************************************************************************</span>
00812 <span class="comment"> *</span>
00813 <span class="comment"> *                         GetPreferredCMM</span>
00814 <span class="comment"> *</span>
00815 <span class="comment"> *  Function:</span>
00816 <span class="comment"> *       This functions returns a pointer to the app specified CMM to use</span>
00817 <span class="comment"> *</span>
00818 <span class="comment"> *  Arguments:</span>
00819 <span class="comment"> *       None</span>
00820 <span class="comment"> *</span>
00821 <span class="comment"> *  Returns:</span>
00822 <span class="comment"> *       Pointer to app specified CMM object on success, NULL otherwise</span>
00823 <span class="comment"> *</span>
00824 <span class="comment"> ******************************************************************************/</span>
00825 
<a name="l00826"></a><a class="code" href="../../d2/d1/object_8c.html#a15">00826</a> PCMMOBJ <a class="code" href="../../d2/d1/object_8c.html#a15">GetPreferredCMM</a>(
00827     )
00828 {
00829     PCMMOBJ pCMMObj;
00830 
00831     EnterCriticalSection(&amp;<a class="code" href="../../d1/d6/ntgdi_2icm_2mscms_2globals_8c.html#a19">critsec</a>);     <span class="comment">// Critical section</span>
00832     pCMMObj = <a class="code" href="../../d1/d6/ntgdi_2icm_2mscms_2globals_8c.html#a1">gpPreferredCMM</a>;
00833 
00834     <span class="keywordflow">if</span> (pCMMObj)
00835     {
00836         <span class="comment">//</span>
00837         <span class="comment">// Increment use count</span>
00838         <span class="comment">//</span>
00839 
00840         pCMMObj-&gt;objHdr.dwUseCount++;
00841     }
00842     LeaveCriticalSection(&amp;<a class="code" href="../../d1/d6/ntgdi_2icm_2mscms_2globals_8c.html#a19">critsec</a>);     <span class="comment">// Critical section</span>
00843 
00844     <span class="keywordflow">return</span> pCMMObj;
00845 }
00846 
00847 
00848 <span class="comment">/******************************************************************************</span>
00849 <span class="comment"> *</span>
00850 <span class="comment"> *                         ReleaseColorMatchingModule</span>
00851 <span class="comment"> *</span>
00852 <span class="comment"> *  Function:</span>
00853 <span class="comment"> *       This functions releases a CMM object. If the ref count goes to</span>
00854 <span class="comment"> *       zero, it unloads the CMM and frees all memory associated with it.</span>
00855 <span class="comment"> *</span>
00856 <span class="comment"> *  Arguments:</span>
00857 <span class="comment"> *       pCMMObj  - pointer to CMM object to release</span>
00858 <span class="comment"> *</span>
00859 <span class="comment"> *  Returns:</span>
00860 <span class="comment"> *       No return value</span>
00861 <span class="comment"> *</span>
00862 <span class="comment"> ******************************************************************************/</span>
00863 
00864 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00865"></a><a class="code" href="../../d2/d1/object_8c.html#a16">00865</a> <a class="code" href="../../d2/d1/object_8c.html#a16">ReleaseColorMatchingModule</a>(
00866     PCMMOBJ pCMMObj
00867     )
00868 {
00869     EnterCriticalSection(&amp;<a class="code" href="../../d1/d6/ntgdi_2icm_2mscms_2globals_8c.html#a19">critsec</a>);     <span class="comment">// Critical section</span>
00870 
00871     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(pCMMObj-&gt;objHdr.dwUseCount &gt; 0);
00872 
00873     pCMMObj-&gt;objHdr.dwUseCount--;
00874 
00875     <span class="keywordflow">if</span> (pCMMObj-&gt;objHdr.dwUseCount == 0)
00876     {
00877         <span class="comment">//</span>
00878         <span class="comment">// Unloading the CMM everytime a transform is freed might not be</span>
00879         <span class="comment">// very efficient. So for now, I am not going to unload it. When</span>
00880         <span class="comment">// the app terminates, kernel should unload all dll's loaded by</span>
00881         <span class="comment">// this app</span>
00882         <span class="comment">//</span>
00883     }
00884     LeaveCriticalSection(&amp;<a class="code" href="../../d1/d6/ntgdi_2icm_2mscms_2globals_8c.html#a19">critsec</a>);     <span class="comment">// Critical section</span>
00885 
00886     <span class="keywordflow">return</span>;
00887 }
00888 
00889 
00890 <span class="preprocessor">#ifdef DBG</span>
00891 <span class="preprocessor"></span>
00892 <span class="comment">/******************************************************************************</span>
00893 <span class="comment"> *</span>
00894 <span class="comment"> *                              MyDebugPrint</span>
00895 <span class="comment"> *</span>
00896 <span class="comment"> *  Function:</span>
00897 <span class="comment"> *       This function takes a format string and paramters, composes a string</span>
00898 <span class="comment"> *       and sends it out to the debug port. Available only in debug build.</span>
00899 <span class="comment"> *</span>
00900 <span class="comment"> *  Arguments:</span>
00901 <span class="comment"> *       pFormat  - pointer to format string</span>
00902 <span class="comment"> *       .......  - parameters based on the format string like printf()</span>
00903 <span class="comment"> *</span>
00904 <span class="comment"> *  Returns:</span>
00905 <span class="comment"> *       No return value</span>
00906 <span class="comment"> *</span>
00907 <span class="comment"> ******************************************************************************/</span>
00908 
00909 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00910 MyDebugPrintA(
00911     PSTR pFormat,
00912     ...
00913     )
00914 {
00915     <span class="keywordtype">char</span>     szBuffer[256];
00916     va_list  arglist;
00917 
00918     va_start(arglist, pFormat);
00919     <a class="code" href="../../d6/d0/wsprintf_8c.html#a5">wvsprintfA</a>(szBuffer, pFormat, arglist);
00920     va_end(arglist);
00921 
00922     OutputDebugStringA(szBuffer);
00923 
00924     <span class="keywordflow">return</span>;
00925 }
00926 
00927 
00928 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00929 MyDebugPrintW(
00930     PWSTR pFormat,
00931     ...
00932     )
00933 {
00934     WCHAR    szBuffer[256];
00935     va_list  arglist;
00936 
00937     va_start(arglist, pFormat);
00938     <a class="code" href="../../d6/d0/wsprintf_8c.html#a9">wvsprintfW</a>(szBuffer, pFormat, arglist);
00939     va_end(arglist);
00940 
00941     OutputDebugStringW(szBuffer);
00942 
00943     <span class="keywordflow">return</span>;
00944 }
00945 
00946 <span class="comment">/******************************************************************************</span>
00947 <span class="comment"> *</span>
00948 <span class="comment"> *                              StripDirPrefixA</span>
00949 <span class="comment"> *</span>
00950 <span class="comment"> *  Function:</span>
00951 <span class="comment"> *       This function takes a path name and returns a pointer to the filename</span>
00952 <span class="comment"> *       part. This is availabel only for the debug build.</span>
00953 <span class="comment"> *</span>
00954 <span class="comment"> *  Arguments:</span>
00955 <span class="comment"> *       pszPathName - path name of file (can be file name alone)</span>
00956 <span class="comment"> *</span>
00957 <span class="comment"> *  Returns:</span>
00958 <span class="comment"> *       A pointer to the file name</span>
00959 <span class="comment"> *</span>
00960 <span class="comment"> ******************************************************************************/</span>
00961 
00962 PSTR
00963 StripDirPrefixA(
00964     PSTR pszPathName
00965     )
00966 {
00967     <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a> dwLen = lstrlenA(pszPathName);
00968 
00969     pszPathName += dwLen - 1;       <span class="comment">// go to the end</span>
00970 
00971     <span class="keywordflow">while</span> (*pszPathName != <span class="charliteral">'\\'</span> &amp;&amp; dwLen--)
00972     {
00973         pszPathName--;
00974     }
00975 
00976     <span class="keywordflow">return</span> pszPathName + 1;
00977 }
00978 
00979 <span class="preprocessor">#endif</span>
00980 <span class="preprocessor"></span>
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:41:05 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
