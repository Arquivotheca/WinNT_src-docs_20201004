<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: largepag.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>largepag.c</h1><a href="../../d2/d1/largepag_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="preprocessor">#include "<a class="code" href="../../d0/d0/ki_8h.html">ki.h</a>"</span>
00002 <span class="preprocessor">#include "<a class="code" href="../../d1/d0/ki386_8h.html">ki386.h</a>"</span>
00003 
00004 PVOID
00005 <a class="code" href="../../d2/d1/largepag_8c.html#a1">Ki386AllocateContiguousMemory</a>(
00006     IN OUT <a class="code" href="../../d5/d0/struct__IDENTITY__MAP.html">PIDENTITY_MAP</a> IdentityMap,
00007     IN     ULONG Pages,
00008     IN     BOOLEAN Low4Meg
00009     );
00010 
00011 BOOLEAN
00012 <a class="code" href="../../d2/d1/largepag_8c.html#a2">Ki386IdentityMapMakeValid</a>(
00013     IN OUT <a class="code" href="../../d5/d0/struct__IDENTITY__MAP.html">PIDENTITY_MAP</a> IdentityMap,
00014     IN     PHARDWARE_PTE PageTableEntry,
00015     OUT    PVOID *Page OPTIONAL
00016     );
00017 
00018 BOOLEAN
00019 <a class="code" href="../../d2/d1/largepag_8c.html#a3">Ki386MapAddress</a>(
00020     IN OUT <a class="code" href="../../d5/d0/struct__IDENTITY__MAP.html">PIDENTITY_MAP</a> IdentityMap,
00021     IN     ULONG Va,
00022     IN     PHYSICAL_ADDRESS PhysicalAddress
00023     );
00024 
00025 PVOID
00026 <a class="code" href="../../d2/d1/largepag_8c.html#a4">Ki386ConvertPte</a>(
00027     IN OUT PHARDWARE_PTE Pte
00028     );
00029 
00030 PHYSICAL_ADDRESS
00031 <a class="code" href="../../d2/d1/largepag_8c.html#a5">Ki386BuildIdentityBuffer</a>(
00032     IN OUT <a class="code" href="../../d5/d0/struct__IDENTITY__MAP.html">PIDENTITY_MAP</a> IdentityMap,
00033     IN     PVOID StartVa,
00034     IN     ULONG Length,
00035     OUT    PULONG PagesToMap
00036     );
00037 
00038 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00039 <span class="preprocessor"></span>
00040 <span class="preprocessor">#pragma alloc_text(INIT,Ki386AllocateContiguousMemory)</span>
00041 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(INIT,Ki386BuildIdentityBuffer)</span>
00042 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(INIT,Ki386ClearIdentityMap)</span>
00043 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(INIT,Ki386ConvertPte)</span>
00044 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(INIT,Ki386CreateIdentityMap)</span>
00045 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(INIT,Ki386EnableTargetLargePage)</span>
00046 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(INIT,Ki386IdentityMapMakeValid)</span>
00047 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(INIT,Ki386MapAddress)</span>
00048 <span class="preprocessor"></span>
00049 <span class="preprocessor">#endif</span>
00050 <span class="preprocessor"></span>
<a name="l00051"></a><a class="code" href="../../d2/d1/largepag_8c.html#a0">00051</a> <span class="preprocessor">#define PTES_PER_PAGE (PAGE_SIZE / sizeof(HARDWARE_PTE))</span>
00052 <span class="preprocessor"></span>
00053 BOOLEAN
<a name="l00054"></a><a class="code" href="../../d2/d1/largepag_8c.html#a6">00054</a> <a class="code" href="../../d2/d1/largepag_8c.html#a6">Ki386CreateIdentityMap</a>(
00055     IN OUT <a class="code" href="../../d5/d0/struct__IDENTITY__MAP.html">PIDENTITY_MAP</a> IdentityMap,
00056     IN     PVOID StartVa,
00057     IN     PVOID EndVa
00058     )
00059 {
00060 <span class="comment">/*++</span>
00061 <span class="comment"></span>
00062 <span class="comment">    This function creates an identity mapping for a region of memory.</span>
00063 <span class="comment"></span>
00064 <span class="comment">    If the region of memory passed in includes memory that lies above</span>
00065 <span class="comment">    4G, then a new buffer is allocated below 4G.</span>
00066 <span class="comment"></span>
00067 <span class="comment">Arguments:</span>
00068 <span class="comment"></span>
00069 <span class="comment">    IdentityMap - Pointer to the structure which will be filled with the newly</span>
00070 <span class="comment">                  created top-level directory address.  It also provides</span>
00071 <span class="comment">                  storage for the pointers used in alloating and freeing the</span>
00072 <span class="comment">                  memory.</span>
00073 <span class="comment"></span>
00074 <span class="comment">    StartVa - Pointer to the first byte of the region of memory that is to be</span>
00075 <span class="comment">              memory mapped.</span>
00076 <span class="comment"></span>
00077 <span class="comment">    EndVa - Pointer to the byte immediately after the last byte of the region</span>
00078 <span class="comment">            that is to be memory mapped.</span>
00079 <span class="comment"></span>
00080 <span class="comment">Return Value:</span>
00081 <span class="comment"></span>
00082 <span class="comment">    TRUE if the function succeeds, FALSE otherwise.</span>
00083 <span class="comment"></span>
00084 <span class="comment">    Note - Ki386ClearIdentityMap() should be called even on FALSE return to</span>
00085 <span class="comment">    free any memory allocated.</span>
00086 <span class="comment">    </span>
00087 <span class="comment">--*/</span>
00088     
00089     ULONG pageDirectoryIndex;
00090     ULONG pagesToMap;
00091     PCHAR currentVa;
00092     ULONG length;
00093     BOOLEAN result;
00094     PHARDWARE_PTE pageDirectory;
00095     PHARDWARE_PTE pageDirectoryEntry;
00096     PHYSICAL_ADDRESS identityAddress;
00097 
00098 <span class="preprocessor">#if defined(_X86PAE_)</span>
00099 <span class="preprocessor"></span>
00100     ULONG pageDirectoryPointerTableIndex;
00101     PHARDWARE_PTE pageDirectoryPointerTable;
00102     PHARDWARE_PTE pageDirectoryPointerTableEntry;
00103 
00104 <span class="preprocessor">#endif</span>
00105 <span class="preprocessor"></span>
00106     <span class="comment">//</span>
00107     <span class="comment">// Initialize the IdentityMap structure to a known state.</span>
00108     <span class="comment">// </span>
00109 
00110     RtlZeroMemory( IdentityMap, <span class="keyword">sizeof</span>(<a class="code" href="../../d5/d0/struct__IDENTITY__MAP.html">IDENTITY_MAP</a>) );
00111     length = (PCHAR)EndVa - (PCHAR)StartVa;
00112 
00113     <span class="comment">//</span>
00114     <span class="comment">// Get the physical address of the input buffer (or suitable copy).</span>
00115     <span class="comment">//</span>
00116 
00117     identityAddress = <a class="code" href="../../d2/d1/largepag_8c.html#a5">Ki386BuildIdentityBuffer</a>( IdentityMap,
00118                                                 StartVa,
00119                                                 length,
00120                                                 &amp;pagesToMap );
00121     <span class="keywordflow">if</span>( identityAddress.QuadPart == 0) {
00122 
00123         <span class="comment">//</span>
00124         <span class="comment">// The input buffer was not contiguous or not below 4G, and a</span>
00125         <span class="comment">// suitable buffer could not be allocated.</span>
00126         <span class="comment">//</span>
00127 
00128         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00129     }
00130 
00131     IdentityMap-&gt;IdentityAddr = identityAddress.LowPart;
00132 
00133     <span class="comment">//</span>
00134     <span class="comment">// Set up the mappings.</span>
00135     <span class="comment">//</span>
00136 
00137     currentVa = StartVa;
00138     <span class="keywordflow">do</span> {
00139 
00140         <span class="comment">//</span>
00141         <span class="comment">// Map in the virtual address</span>
00142         <span class="comment">// </span>
00143 
00144         result = <a class="code" href="../../d2/d1/largepag_8c.html#a3">Ki386MapAddress</a>( IdentityMap,
00145                                   (ULONG)currentVa,
00146                                   identityAddress );
00147         <span class="keywordflow">if</span> (result == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00148             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00149         }
00150 
00151         <span class="comment">//</span>
00152         <span class="comment">// Map in the identity (physical) address</span>
00153         <span class="comment">// </span>
00154 
00155         result = <a class="code" href="../../d2/d1/largepag_8c.html#a3">Ki386MapAddress</a>( IdentityMap,
00156                                   identityAddress.LowPart,
00157                                   identityAddress );
00158         <span class="keywordflow">if</span> (result == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00159             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00160         }
00161 
00162         <span class="comment">//</span>
00163         <span class="comment">// Advance both the Va and identityAddress pointers in anticipation</span>
00164         <span class="comment">// of mapping in another page.</span>
00165         <span class="comment">//</span>
00166 
00167         currentVa += <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
00168         identityAddress.QuadPart += <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
00169         pagesToMap -= 1;
00170 
00171     } <span class="keywordflow">while</span> (pagesToMap &gt; 0);
00172 
00173     <span class="comment">//</span>
00174     <span class="comment">// Now go through the page directory pointer table and page directories,</span>
00175     <span class="comment">// converting virtual page frames to physical ones.</span>
00176     <span class="comment">//</span>
00177 
00178 <span class="preprocessor">#if defined(_X86PAE_)</span>
00179 <span class="preprocessor"></span>
00180     <span class="comment">//</span>
00181     <span class="comment">// This PAE-only outer loop walks the page directory pointer table entries</span>
00182     <span class="comment">// and processes each valid page directory referenced.</span>
00183     <span class="comment">// </span>
00184 
00185     pageDirectoryPointerTable = IdentityMap-&gt;TopLevelDirectory;
00186     <span class="keywordflow">for</span> (pageDirectoryPointerTableIndex = 0;
00187          pageDirectoryPointerTableIndex &lt; (1 &lt;&lt; <a class="code" href="../../d1/d0/ki386_8h.html#a1">PPI_BITS</a>);
00188          pageDirectoryPointerTableIndex++) {
00189 
00190         pageDirectoryPointerTableEntry =
00191             &amp;pageDirectoryPointerTable[ pageDirectoryPointerTableIndex ];
00192 
00193         <span class="keywordflow">if</span> (pageDirectoryPointerTableEntry-&gt;Valid == 0) {
00194             <span class="keywordflow">continue</span>;
00195         }
00196 
00197         pageDirectory =
00198             (PHARDWARE_PTE)<a class="code" href="../../d2/d1/largepag_8c.html#a4">Ki386ConvertPte</a>( pageDirectoryPointerTableEntry );
00199 
00200 <span class="preprocessor">#else</span>
00201 <span class="preprocessor"></span>        pageDirectory = IdentityMap-&gt;TopLevelDirectory;
00202 <span class="preprocessor">#endif</span>
00203 <span class="preprocessor"></span>
00204         <span class="keywordflow">for</span> (pageDirectoryIndex = 0;
00205              pageDirectoryIndex &lt; <a class="code" href="../../d2/d1/largepag_8c.html#a0">PTES_PER_PAGE</a>;
00206              pageDirectoryIndex++) {
00207 
00208             pageDirectoryEntry = &amp;pageDirectory[ pageDirectoryIndex ];
00209             <span class="keywordflow">if</span> (pageDirectoryEntry-&gt;Valid == 0) {
00210                 <span class="keywordflow">continue</span>;
00211             }
00212 
00213             <a class="code" href="../../d2/d1/largepag_8c.html#a4">Ki386ConvertPte</a>( pageDirectoryEntry );
00214         }
00215 
00216 <span class="preprocessor">#if defined(_X86PAE_)</span>
00217 <span class="preprocessor"></span>    }
00218 <span class="preprocessor">#endif</span>
00219 <span class="preprocessor"></span>
00220     identityAddress = <a class="code" href="../../d5/d6/iosup_8c.html#a68">MmGetPhysicalAddress</a>( IdentityMap-&gt;TopLevelDirectory );
00221     IdentityMap-&gt;IdentityCR3 = identityAddress.LowPart;
00222 
00223     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00224 }
00225 
00226 PVOID
<a name="l00227"></a><a class="code" href="../../d2/d1/largepag_8c.html#a1">00227</a> <a class="code" href="../../d2/d1/largepag_8c.html#a1">Ki386AllocateContiguousMemory</a>(
00228     IN OUT <a class="code" href="../../d5/d0/struct__IDENTITY__MAP.html">PIDENTITY_MAP</a> IdentityMap,
00229     IN     ULONG Pages,
00230     IN     BOOLEAN Low4Meg
00231     )
00232 <span class="comment">/*++</span>
00233 <span class="comment"></span>
00234 <span class="comment">    This function allocates page-aligned, physically contiguous memory.</span>
00235 <span class="comment">    The allocation is recorded in the IdentityMap structure, so that it</span>
00236 <span class="comment">    can be freed on cleanup.</span>
00237 <span class="comment"></span>
00238 <span class="comment">Arguments:</span>
00239 <span class="comment"></span>
00240 <span class="comment">    IdentityMap - Context pointer for this identity mapping.</span>
00241 <span class="comment"></span>
00242 <span class="comment">    Pages - Number of pages to allocate</span>
00243 <span class="comment"></span>
00244 <span class="comment">    Low4Meg - Indicates whether the allocation must be below 4M.</span>
00245 <span class="comment"></span>
00246 <span class="comment">Return Value:</span>
00247 <span class="comment"></span>
00248 <span class="comment">    Pointer to the new page on success, NULL otherwise.</span>
00249 <span class="comment">    </span>
00250 <span class="comment">--*/</span>
00251 {
00252     ULONG pageListIndex;
00253     PVOID page;
00254     ULONG allocationSize;
00255     PHYSICAL_ADDRESS highestAddress;
00256 
00257     <span class="keywordflow">if</span> (Low4Meg != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00258 
00259         <span class="comment">//</span>
00260         <span class="comment">// The caller has specified that a page must reside physically</span>
00261         <span class="comment">// below 4 MB.</span>
00262         <span class="comment">//</span>
00263 
00264         highestAddress.LowPart = 0xFFFFFFFF;
00265         highestAddress.HighPart = 0;
00266 
00267     } <span class="keywordflow">else</span> {
00268 
00269         <span class="comment">//</span>
00270         <span class="comment">// Memory can reside anywhere</span>
00271         <span class="comment">//</span>
00272 
00273         highestAddress.LowPart = 0xFFFFFFFF;
00274         highestAddress.HighPart = 0xFFFFFFFF;
00275     }
00276 
00277     allocationSize = Pages * <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
00278     page = <a class="code" href="../../d5/d6/iosup_8c.html#a60">MmAllocateContiguousMemory</a>( allocationSize, highestAddress );
00279     <span class="keywordflow">if</span> (page != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00280 
00281         <span class="comment">//</span>
00282         <span class="comment">// Record that this page was allocated so that it can be freed when</span>
00283         <span class="comment">// the IdentityMap structure is cleared.</span>
00284         <span class="comment">//</span>
00285     
00286         pageListIndex = IdentityMap-&gt;PagesAllocated;
00287         IdentityMap-&gt;PageList[ pageListIndex ] = page;
00288         IdentityMap-&gt;PagesAllocated++;
00289 
00290         <span class="comment">//</span>
00291         <span class="comment">// Initialize it.</span>
00292         <span class="comment">//</span>
00293 
00294         RtlZeroMemory( page, allocationSize );
00295     }
00296 
00297     <span class="keywordflow">return</span> page;
00298 }
00299 
00300 BOOLEAN
<a name="l00301"></a><a class="code" href="../../d2/d1/largepag_8c.html#a2">00301</a> <a class="code" href="../../d2/d1/largepag_8c.html#a2">Ki386IdentityMapMakeValid</a>(
00302     IN OUT <a class="code" href="../../d5/d0/struct__IDENTITY__MAP.html">PIDENTITY_MAP</a> IdentityMap,
00303     IN     PHARDWARE_PTE PageTableEntry,
00304     OUT    PVOID *Page OPTIONAL
00305     )
00306 <span class="comment">/*++</span>
00307 <span class="comment"></span>
00308 <span class="comment">    If the page table has the valid bit set, this function merely returns</span>
00309 <span class="comment">    the address referenced by the page table entry.</span>
00310 <span class="comment"></span>
00311 <span class="comment">    If the page table does not have the valid bit set, then another page</span>
00312 <span class="comment">    is allocated and inserted into the page table entry and the entry is</span>
00313 <span class="comment">    marked valid.</span>
00314 <span class="comment"></span>
00315 <span class="comment">    NOTE: At this point, PTE frames are virtual.  After the entire mapping</span>
00316 <span class="comment">          is built, we go through and convert all virtual frames to physical</span>
00317 <span class="comment">          ones.</span>
00318 <span class="comment"></span>
00319 <span class="comment">Arguments:</span>
00320 <span class="comment"></span>
00321 <span class="comment">    IdentityMap - Context pointer for this identity mapping.</span>
00322 <span class="comment"></span>
00323 <span class="comment">    PageTableEntry - Pointer to the page table entry.</span>
00324 <span class="comment"></span>
00325 <span class="comment">    Page - Virtual address now referenced by the PTE, whether it was</span>
00326 <span class="comment">           valid before or not.</span>
00327 <span class="comment"></span>
00328 <span class="comment">Return Value:</span>
00329 <span class="comment"></span>
00330 <span class="comment">    TRUE on success, FALSE otherwise.</span>
00331 <span class="comment">    </span>
00332 <span class="comment">--*/</span>
00333 {
00334     PVOID page;
00335 
00336     <span class="keywordflow">if</span> (PageTableEntry-&gt;Valid != 0) {
00337 
00338         <span class="comment">//</span>
00339         <span class="comment">// If it already is present, there is nothing to do except record</span>
00340         <span class="comment">// the virtual page number that is already there.</span>
00341         <span class="comment">//</span>
00342 
00343         page = (PVOID)((ULONG)(PageTableEntry-&gt;PageFrameNumber &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>));
00344 
00345     } <span class="keywordflow">else</span> {
00346 
00347         <span class="comment">//</span>
00348         <span class="comment">// The page table entry is not valid.  Allocate a new page table.</span>
00349         <span class="comment">// </span>
00350     
00351         page = <a class="code" href="../../d2/d1/largepag_8c.html#a1">Ki386AllocateContiguousMemory</a>( IdentityMap, 1, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00352         <span class="keywordflow">if</span> (page == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00353             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00354         }
00355     
00356         <span class="comment">//</span>
00357         <span class="comment">// Insert it into the page table entry and mark it valid.</span>
00358         <span class="comment">//</span>
00359         <span class="comment">// NOTE: Virtual page numbers are inserted into the page table</span>
00360         <span class="comment">//       structure as it is being built.  When it is finished, we walk</span>
00361         <span class="comment">//       the tables and convert all of the virtual page numbers to</span>
00362         <span class="comment">//       physical page numbers.</span>
00363         <span class="comment">//</span>
00364     
00365         PageTableEntry-&gt;PageFrameNumber = ((ULONG)page) &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
00366         PageTableEntry-&gt;Valid = 1;
00367     }
00368 
00369     <span class="keywordflow">if</span> (ARGUMENT_PRESENT( Page )) {
00370         *Page = page;
00371     }
00372 
00373     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00374 }           
00375 
00376 BOOLEAN
<a name="l00377"></a><a class="code" href="../../d2/d1/largepag_8c.html#a3">00377</a> <a class="code" href="../../d2/d1/largepag_8c.html#a3">Ki386MapAddress</a>(
00378     IN OUT <a class="code" href="../../d5/d0/struct__IDENTITY__MAP.html">PIDENTITY_MAP</a> IdentityMap,
00379     IN     ULONG Va,
00380     IN     PHYSICAL_ADDRESS PhysicalAddress
00381     )
00382 
00383 <span class="comment">/*++</span>
00384 <span class="comment"></span>
00385 <span class="comment">    Creates a new virtual-&gt;physical mapping in the identity map.</span>
00386 <span class="comment"></span>
00387 <span class="comment">Arguments:</span>
00388 <span class="comment"></span>
00389 <span class="comment">    IdentityMap - Context pointer for this identity mapping.</span>
00390 <span class="comment"></span>
00391 <span class="comment">    Va - Virtual address to map.</span>
00392 <span class="comment"></span>
00393 <span class="comment">    PhysicalAddress - Physical address to map.</span>
00394 <span class="comment"></span>
00395 <span class="comment">Return Value:</span>
00396 <span class="comment"></span>
00397 <span class="comment">    TRUE on success, FALSE otherwise.</span>
00398 <span class="comment">    </span>
00399 <span class="comment">--*/</span>
00400 {
00401     PHARDWARE_PTE pageTable;
00402     PHARDWARE_PTE pageTableEntry;
00403     PHARDWARE_PTE pageDirectory;
00404     PHARDWARE_PTE pageDirectoryEntry;
00405     PVOID table;
00406     ULONG index;
00407     BOOLEAN result;
00408 
00409 <span class="preprocessor">#if defined(_X86PAE_)</span>
00410 <span class="preprocessor"></span>    PHARDWARE_PTE pageDirectoryPointerTable;
00411     PHARDWARE_PTE pageDirectoryPointerTableEntry;
00412 <span class="preprocessor">#endif</span>
00413 <span class="preprocessor"></span>
00414     <span class="keywordflow">if</span> (IdentityMap-&gt;TopLevelDirectory == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00415 
00416         <span class="comment">//</span>
00417         <span class="comment">// Allocate a top-level directory structure, either a page directory</span>
00418         <span class="comment">// or a page directory pointer table.</span>
00419         <span class="comment">//</span>
00420 
00421         table = <a class="code" href="../../d2/d1/largepag_8c.html#a1">Ki386AllocateContiguousMemory</a>( IdentityMap, 1, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00422         <span class="keywordflow">if</span> (table == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00423             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00424         }
00425 
00426         IdentityMap-&gt;TopLevelDirectory = table;
00427     }
00428 
00429 <span class="preprocessor">#if defined(_X86PAE_)</span>
00430 <span class="preprocessor"></span>
00431     index = <a class="code" href="../../d1/d0/ki386_8h.html#a7">KiGetPpeIndex</a>( Va );
00432     pageDirectoryPointerTable = IdentityMap-&gt;TopLevelDirectory;
00433     pageDirectoryPointerTableEntry = &amp;pageDirectoryPointerTable[ index ];
00434 
00435     result = <a class="code" href="../../d2/d1/largepag_8c.html#a2">Ki386IdentityMapMakeValid</a>( IdentityMap,
00436                                         pageDirectoryPointerTableEntry,
00437                                         &amp;pageDirectory );
00438     <span class="keywordflow">if</span> (result == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00439         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00440     }
00441 
00442 <span class="preprocessor">#else</span>
00443 <span class="preprocessor"></span>
00444     pageDirectory = IdentityMap-&gt;TopLevelDirectory;
00445 
00446 <span class="preprocessor">#endif</span>
00447 <span class="preprocessor"></span>
00448     <span class="comment">//</span>
00449     <span class="comment">// Get a pointer to the appropriate page directory entry.  If it is</span>
00450     <span class="comment">// not valid, allocate a new page table and mark the page directory</span>
00451     <span class="comment">// entry valid and writeable.</span>
00452     <span class="comment">// </span>
00453 
00454     index = <a class="code" href="../../d1/d0/ki386_8h.html#a8">KiGetPdeIndex</a>( Va );
00455     pageDirectoryEntry = &amp;pageDirectory[ index ];
00456     result = <a class="code" href="../../d2/d1/largepag_8c.html#a2">Ki386IdentityMapMakeValid</a>( IdentityMap,
00457                                         pageDirectoryEntry,
00458                                         &amp;pageTable );
00459     <span class="keywordflow">if</span> (result == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00460         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00461     }
00462     pageDirectoryEntry-&gt;Write = 1;
00463 
00464     <span class="comment">//</span>
00465     <span class="comment">// Get a pointer to the appropriate page table entry and fill it in.</span>
00466     <span class="comment">// </span>
00467 
00468     index = <a class="code" href="../../d1/d0/ki386_8h.html#a9">KiGetPteIndex</a>( Va );
00469     pageTableEntry = &amp;pageTable[ index ];
00470 
00471 <span class="preprocessor">#if defined(_X86PAE_)</span>
00472 <span class="preprocessor"></span>    pageTableEntry-&gt;PageFrameNumber = PhysicalAddress.QuadPart &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
00473 <span class="preprocessor">#else</span>
00474 <span class="preprocessor"></span>    pageTableEntry-&gt;PageFrameNumber = PhysicalAddress.LowPart &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
00475 <span class="preprocessor">#endif</span>
00476 <span class="preprocessor"></span>    pageTableEntry-&gt;Valid = 1;
00477 
00478     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00479 }
00480 
00481 PVOID
<a name="l00482"></a><a class="code" href="../../d2/d1/largepag_8c.html#a4">00482</a> <a class="code" href="../../d2/d1/largepag_8c.html#a4">Ki386ConvertPte</a>(
00483     IN OUT PHARDWARE_PTE Pte
00484     )
00485 <span class="comment">/*++</span>
00486 <span class="comment"></span>
00487 <span class="comment">    Converts the virtual frame number in a PTE to a physical frame number.</span>
00488 <span class="comment"></span>
00489 <span class="comment">Arguments:</span>
00490 <span class="comment"></span>
00491 <span class="comment">    Pte - Pointer to the page table entry to convert.</span>
00492 <span class="comment"></span>
00493 <span class="comment">Return Value:</span>
00494 <span class="comment"></span>
00495 <span class="comment">    None.</span>
00496 <span class="comment">    </span>
00497 <span class="comment">--*/</span>
00498 {
00499     PVOID va;
00500     PHYSICAL_ADDRESS physicalAddress;
00501 
00502     va = (PVOID)(Pte-&gt;PageFrameNumber &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
00503     physicalAddress = <a class="code" href="../../d5/d6/iosup_8c.html#a68">MmGetPhysicalAddress</a>( va );
00504 
00505 <span class="preprocessor">#if defined(_X86PAE_)</span>
00506 <span class="preprocessor"></span>    Pte-&gt;PageFrameNumber = physicalAddress.QuadPart &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
00507 <span class="preprocessor">#else</span>
00508 <span class="preprocessor"></span>    Pte-&gt;PageFrameNumber = physicalAddress.LowPart &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
00509 <span class="preprocessor">#endif</span>
00510 <span class="preprocessor"></span>
00511     <span class="keywordflow">return</span> va;
00512 }
00513 
00514 PHYSICAL_ADDRESS
<a name="l00515"></a><a class="code" href="../../d2/d1/largepag_8c.html#a5">00515</a> <a class="code" href="../../d2/d1/largepag_8c.html#a5">Ki386BuildIdentityBuffer</a>(
00516     IN OUT <a class="code" href="../../d5/d0/struct__IDENTITY__MAP.html">PIDENTITY_MAP</a> IdentityMap,
00517     IN     PVOID StartVa,
00518     IN     ULONG Length,
00519     OUT    PULONG PagesToMap
00520     )
00521 {
00522 
00523 <span class="comment">/*++</span>
00524 <span class="comment"></span>
00525 <span class="comment">    This function checks to see if the physical memory backing a virtual</span>
00526 <span class="comment">    buffer is physically contiguous and lies completely below 4G.</span>
00527 <span class="comment"></span>
00528 <span class="comment">    If these requirements are met, then the physical address of StartVa is</span>
00529 <span class="comment">    returned.</span>
00530 <span class="comment"></span>
00531 <span class="comment">    If not, then a physically contiguous buffer is allocated, the contents</span>
00532 <span class="comment">    of the region is copied in, and its address is returned.</span>
00533 <span class="comment"></span>
00534 <span class="comment">Arguments:</span>
00535 <span class="comment"></span>
00536 <span class="comment">    IdentityMap - Pointer to the identity map building structure.</span>
00537 <span class="comment"></span>
00538 <span class="comment">    StartVa - Virtual address of the start of the region for which a</span>
00539 <span class="comment">              physically contiguous copy is desired.</span>
00540 <span class="comment"></span>
00541 <span class="comment">    Length - Length of the region for which a physically contiguous copy</span>
00542 <span class="comment">             is desired.</span>
00543 <span class="comment"></span>
00544 <span class="comment">--*/</span>
00545 
00546     ULONG pagesToMap;
00547     ULONG pagesRemaining;
00548     PCHAR nextVirtualAddress;
00549     PHYSICAL_ADDRESS nextPhysicalAddress;
00550     PHYSICAL_ADDRESS physicalAddress;
00551     PHYSICAL_ADDRESS firstPhysicalAddress;
00552     ULONG pageOffset;
00553     PCHAR identityBuffer;
00554 
00555     <span class="comment">//</span>
00556     <span class="comment">// Count the number of pages in the buffer, and record the physical</span>
00557     <span class="comment">// address of the start of the buffer.</span>
00558     <span class="comment">//</span>
00559 
00560     pagesToMap = <a class="code" href="../../d2/d1/mm_8h.html#a8">ADDRESS_AND_SIZE_TO_SPAN_PAGES</a>( StartVa, Length );
00561     nextVirtualAddress = StartVa;
00562     firstPhysicalAddress = <a class="code" href="../../d5/d6/iosup_8c.html#a68">MmGetPhysicalAddress</a>( StartVa );
00563     nextPhysicalAddress = firstPhysicalAddress;
00564 
00565     <span class="comment">//</span>
00566     <span class="comment">// Examine each page in the region.</span>
00567     <span class="comment">// </span>
00568 
00569     pagesRemaining = pagesToMap;
00570     <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00571         
00572         physicalAddress = <a class="code" href="../../d5/d6/iosup_8c.html#a68">MmGetPhysicalAddress</a>( nextVirtualAddress );
00573         <span class="keywordflow">if</span> (physicalAddress.QuadPart != nextPhysicalAddress.QuadPart) {
00574 
00575             <span class="comment">//</span>
00576             <span class="comment">// The buffer is not physically contiguous.</span>
00577             <span class="comment">//</span>
00578 
00579             <span class="keywordflow">break</span>;
00580         }
00581 
00582         <span class="keywordflow">if</span> (physicalAddress.HighPart != 0) {
00583 
00584             <span class="comment">//</span>
00585             <span class="comment">// The buffer does not lie entirely below 4G</span>
00586             <span class="comment">//</span>
00587 
00588             <span class="keywordflow">break</span>;
00589         }
00590 
00591         pagesRemaining -= 1;
00592         <span class="keywordflow">if</span> (pagesRemaining == 0) {
00593 
00594             <span class="comment">//</span>
00595             <span class="comment">// All of the pages in the buffer have been examined, and have</span>
00596             <span class="comment">// been found to meet the critera.  Return the physical address</span>
00597             <span class="comment">// of the start of the buffer.</span>
00598             <span class="comment">//</span>
00599 
00600             *PagesToMap = pagesToMap;
00601             <span class="keywordflow">return</span> firstPhysicalAddress;
00602         }
00603 
00604         nextVirtualAddress += <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
00605         nextPhysicalAddress.QuadPart += <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
00606     }
00607 
00608     <span class="comment">//</span>
00609     <span class="comment">// The buffer does not meet the criteria and so its contents must be</span>
00610     <span class="comment">// copied to a buffer that does.</span>
00611     <span class="comment">//</span>
00612 
00613     identityBuffer = <a class="code" href="../../d2/d1/largepag_8c.html#a1">Ki386AllocateContiguousMemory</a>( IdentityMap,
00614                                                     pagesToMap,
00615                                                     <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00616     <span class="keywordflow">if</span> (identityBuffer == 0) {
00617 
00618         <span class="comment">//</span>
00619         <span class="comment">// A contiguous region of the appropriate size could not be located</span>
00620         <span class="comment">// below 4G physical.</span>
00621         <span class="comment">// </span>
00622 
00623         physicalAddress.QuadPart = 0;
00624 
00625     } <span class="keywordflow">else</span> {
00626 
00627         <span class="comment">//</span>
00628         <span class="comment">// Got an appropriate physical buffer, now copy in the data</span>
00629         <span class="comment">//</span>
00630 
00631         pageOffset = (ULONG)StartVa &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>-1);
00632         identityBuffer += pageOffset;
00633     
00634         RtlCopyMemory( identityBuffer, StartVa, Length );
00635         physicalAddress = <a class="code" href="../../d5/d6/iosup_8c.html#a68">MmGetPhysicalAddress</a>( identityBuffer );
00636 
00637         *PagesToMap = pagesToMap;
00638     }
00639 
00640     <span class="keywordflow">return</span> physicalAddress;
00641 }
00642 
00643 
00644 
00645 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00646"></a><a class="code" href="../../d2/d1/largepag_8c.html#a7">00646</a> <a class="code" href="../../d2/d1/largepag_8c.html#a7">Ki386ClearIdentityMap</a>(
00647     IN <a class="code" href="../../d5/d0/struct__IDENTITY__MAP.html">PIDENTITY_MAP</a> IdentityMap
00648     )
00649 {
00650 <span class="comment">/*++</span>
00651 <span class="comment"></span>
00652 <span class="comment">    This function just frees the page directory and page tables created in </span>
00653 <span class="comment">    Ki386CreateIdentityMap().</span>
00654 <span class="comment"></span>
00655 <span class="comment">--*/</span>
00656 
00657     ULONG index;
00658     PVOID page;
00659 
00660     <span class="comment">//</span>
00661     <span class="comment">// IdentityMap-&gt;PageList is an array of addresses of pages allocated with</span>
00662     <span class="comment">// MmAllocateContiguousMemory().  Walk the array, freeing each page.</span>
00663     <span class="comment">// </span>
00664 
00665     <span class="keywordflow">for</span> (index = 0; index &lt; IdentityMap-&gt;PagesAllocated; index++) {
00666 
00667         page = IdentityMap-&gt;PageList[ index ];
00668         <a class="code" href="../../d5/d6/iosup_8c.html#a66">MmFreeContiguousMemory</a>( page );
00669     }
00670 }
00671 
00672 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00673"></a><a class="code" href="../../d2/d1/largepag_8c.html#a8">00673</a> <a class="code" href="../../d2/d1/largepag_8c.html#a8">Ki386EnableTargetLargePage</a>(
00674     IN <a class="code" href="../../d5/d0/struct__IDENTITY__MAP.html">PIDENTITY_MAP</a> IdentityMap
00675     )
00676 {
00677 <span class="comment">/*++</span>
00678 <span class="comment"></span>
00679 <span class="comment">    This function just passes info on to the assembly routine </span>
00680 <span class="comment">    Ki386EnableLargePage().</span>
00681 <span class="comment"></span>
00682 <span class="comment">--*/</span>
00683 
00684     <a class="code" href="../../d1/d0/ki386_8h.html#a16">Ki386EnableCurrentLargePage</a>(IdentityMap-&gt;IdentityAddr,
00685                                 IdentityMap-&gt;IdentityCR3);
00686 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:36 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
