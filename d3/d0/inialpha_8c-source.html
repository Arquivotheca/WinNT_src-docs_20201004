<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: inialpha.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>inialpha.c</h1><a href="../../d2/d1/inialpha_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1990  Microsoft Corporation</span>
00004 <span class="comment">Copyright (c) 1992  Digital Equipment Corporation</span>
00005 <span class="comment"></span>
00006 <span class="comment">Module Name:</span>
00007 <span class="comment"></span>
00008 <span class="comment">    inialpha.c</span>
00009 <span class="comment"></span>
00010 <span class="comment">Abstract:</span>
00011 <span class="comment"></span>
00012 <span class="comment">    This module contains the machine dependent initialization for the</span>
00013 <span class="comment">    memory management component.  It is specifically tailored to the</span>
00014 <span class="comment">    ALPHA architecture.</span>
00015 <span class="comment"></span>
00016 <span class="comment">Author:</span>
00017 <span class="comment"></span>
00018 <span class="comment">    Lou Perazzoli (loup) 3-Apr-1990</span>
00019 <span class="comment">    Joe Notarangelo  23-Apr-1992    ALPHA version</span>
00020 <span class="comment"></span>
00021 <span class="comment">Revision History:</span>
00022 <span class="comment"></span>
00023 <span class="comment">--*/</span>
00024 
00025 <span class="preprocessor">#include "<a class="code" href="../../d4/d8/mi_8h.html">mi.h</a>"</span>
00026 <span class="preprocessor">#include &lt;<a class="code" href="../../d0/d1/inbv_8h.html">inbv.h</a>&gt;</span>
00027 
00028 <span class="comment">//</span>
00029 <span class="comment">// Local definitions</span>
00030 <span class="comment">//</span>
00031 
<a name="l00032"></a><a class="code" href="../../d2/d1/inialpha_8c.html#a0">00032</a> <span class="preprocessor">#define _1MB  (0x100000)</span>
<a name="l00033"></a><a class="code" href="../../d2/d1/inialpha_8c.html#a1">00033</a> <span class="preprocessor"></span><span class="preprocessor">#define _16MB (0x1000000)</span>
<a name="l00034"></a><a class="code" href="../../d2/d1/inialpha_8c.html#a2">00034</a> <span class="preprocessor"></span><span class="preprocessor">#define _24MB (0x1800000)</span>
<a name="l00035"></a><a class="code" href="../../d2/d1/inialpha_8c.html#a3">00035</a> <span class="preprocessor"></span><span class="preprocessor">#define _32MB (0x2000000)</span>
00036 <span class="preprocessor"></span>
<a name="l00037"></a><a class="code" href="../../d2/d1/inialpha_8c.html#a4">00037</a> SIZE_T <a class="code" href="../../d2/d1/inialpha_8c.html#a4">MmExpandedNonPagedPoolInBytes</a>;
00038 
00039 
00040 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00041"></a><a class="code" href="../../d4/d8/mi_8h.html#a776">00041</a> <a class="code" href="../../d2/d3/initppc_8c.html#a1">MiInitMachineDependent</a> (
00042     IN <a class="code" href="../../d1/d2/struct__LOADER__PARAMETER__BLOCK.html">PLOADER_PARAMETER_BLOCK</a> LoaderBlock
00043     )
00044 
00045 <span class="comment">/*++</span>
00046 <span class="comment"></span>
00047 <span class="comment">Routine Description:</span>
00048 <span class="comment"></span>
00049 <span class="comment">    This routine performs the necessary operations to enable virtual</span>
00050 <span class="comment">    memory.  This includes building the page directory page, building</span>
00051 <span class="comment">    page table pages to map the code section, the data section, the'</span>
00052 <span class="comment">    stack section and the trap handler.</span>
00053 <span class="comment"></span>
00054 <span class="comment">    It also initializes the PFN database and populates the free list.</span>
00055 <span class="comment"></span>
00056 <span class="comment"></span>
00057 <span class="comment">Arguments:</span>
00058 <span class="comment"></span>
00059 <span class="comment">    None.</span>
00060 <span class="comment"></span>
00061 <span class="comment">Return Value:</span>
00062 <span class="comment"></span>
00063 <span class="comment">    None.</span>
00064 <span class="comment"></span>
00065 <span class="comment">Environment:</span>
00066 <span class="comment"></span>
00067 <span class="comment">    Kernel mode.</span>
00068 <span class="comment"></span>
00069 <span class="comment">--*/</span>
00070 
00071 {
00072     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> BasePfn;
00073     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> BottomPfn;
00074     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> TopPfn;
00075     BOOLEAN PfnInKseg0;
00076     ULONG LowMemoryReserved;
00077     ULONG i, j;
00078     ULONG HighPage;
00079     ULONG PagesLeft;
00080     ULONG PageNumber;
00081     ULONG PdePageNumber;
00082     ULONG PdePage;
00083     ULONG PageFrameIndex;
00084     ULONG NextPhysicalPage;
00085     ULONG PfnAllocation;
00086     ULONG NumberOfPages;
00087     <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> CurrentProcess;
00088     PVOID SpinLockPage;
00089     ULONG MostFreePage;
00090     ULONG MostFreeLowMem;
00091     PLIST_ENTRY NextMd;
00092     ULONG MaxPool;
00093     KIRQL OldIrql;
00094     <a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html">PMEMORY_ALLOCATION_DESCRIPTOR</a> FreeDescriptor;
00095     <a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html">PMEMORY_ALLOCATION_DESCRIPTOR</a> FreeDescriptorLowMem;
00096     <a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html">PMEMORY_ALLOCATION_DESCRIPTOR</a> MemoryDescriptor;
00097     <a class="code" href="../../d2/d4/struct__MMPTE.html">MMPTE</a> TempPte;
00098     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPde;
00099     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> PointerPte;
00100     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> LastPte;
00101     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> CacheStackPage;
00102     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> Pde;
00103     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> StartPde;
00104     <a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a> EndPde;
00105     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn1;
00106     <a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a> Pfn2;
00107     PULONG PointerLong;
00108     <a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a> <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>[256];
00109     <a class="code" href="../../d2/d2/struct__MMFREE__POOL__ENTRY.html">PMMFREE_POOL_ENTRY</a> Entry;
00110     PVOID NonPagedPoolStartVirtual;
00111     ULONG Range;
00112     ULONG RemovedLowPage;
00113     ULONG RemovedLowCount;
00114 
00115     RemovedLowPage = 0;
00116     RemovedLowCount = 0;
00117     LowMemoryReserved = 0;
00118     MostFreePage = 0;
00119     MostFreeLowMem = 0;
00120     FreeDescriptor = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00121     FreeDescriptorLowMem = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00122 
00123     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a151">MiGetPdeAddress</a> (PDE_BASE);
00124 
00125     PdePageNumber = PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber;
00126 
00127     <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>()-&gt;Pcb.DirectoryTableBase[0] = PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long;
00128 
00129     <a class="code" href="../../d3/d5/ppc_2flush_8c.html#a6">KeSweepDcache</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00130 
00131     <span class="comment">//</span>
00132     <span class="comment">// Get the lower bound of the free physical memory and the</span>
00133     <span class="comment">// number of physical pages by walking the memory descriptor lists.</span>
00134     <span class="comment">// In addition, find the memory descriptor with the most free pages</span>
00135     <span class="comment">// that begins at a physical address less than 16MB.  The 16 MB</span>
00136     <span class="comment">// boundary is necessary for allocating common buffers for use by</span>
00137     <span class="comment">// ISA devices that cannot address more than 24 bits.</span>
00138     <span class="comment">//</span>
00139 
00140     NextMd = LoaderBlock-&gt;MemoryDescriptorListHead.Flink;
00141 
00142     <span class="comment">//</span>
00143     <span class="comment">// When restoring a hibernation image, OS Loader needs to use "a few" extra</span>
00144     <span class="comment">// pages of LoaderFree memory.</span>
00145     <span class="comment">// This is not accounted for when reserving memory for hibernation below.</span>
00146     <span class="comment">// Start with a safety margin to allow for this plus modest future increase.</span>
00147     <span class="comment">//</span>
00148 
00149     <a class="code" href="../../d4/d8/mi_8h.html#a427">MmHiberPages</a> = 96;
00150 
00151     <span class="keywordflow">while</span> (NextMd != &amp;LoaderBlock-&gt;MemoryDescriptorListHead) {
00152 
00153         MemoryDescriptor = CONTAINING_RECORD(NextMd,
00154                                              <a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html">MEMORY_ALLOCATION_DESCRIPTOR</a>,
00155                                              ListEntry);
00156 
00157         HighPage = MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o2">BasePage</a> + MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a>-1;
00158 
00159         <span class="comment">//</span>
00160         <span class="comment">// This check results in /BURNMEMORY chunks not being counted.</span>
00161         <span class="comment">//</span>
00162         
00163         <span class="keywordflow">if</span> (MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o1">MemoryType</a> != <a class="code" href="../../d1/d9/arc_8h.html#a320a257">LoaderBad</a>) {
00164             <a class="code" href="../../d2/d1/mm_8h.html#a136">MmNumberOfPhysicalPages</a> += MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a>;
00165         }
00166         
00167         <span class="keywordflow">if</span> (MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o2">BasePage</a> &lt; <a class="code" href="../../d6/d8/sysinfo_8c.html#a6">MmLowestPhysicalPage</a>) {
00168             <a class="code" href="../../d6/d8/sysinfo_8c.html#a6">MmLowestPhysicalPage</a> = MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o2">BasePage</a>;
00169         }
00170         
00171         <span class="keywordflow">if</span> (HighPage &gt; <a class="code" href="../../d6/d8/sysinfo_8c.html#a7">MmHighestPhysicalPage</a>) {
00172             <a class="code" href="../../d6/d8/sysinfo_8c.html#a7">MmHighestPhysicalPage</a> = HighPage;
00173         }
00174         
00175         <span class="comment">//</span>
00176         <span class="comment">// Locate the largest free block starting below 16 megs</span>
00177         <span class="comment">// and the largest free block.</span>
00178         <span class="comment">//</span>
00179         
00180         <span class="keywordflow">if</span> ((MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o1">MemoryType</a> == <a class="code" href="../../d1/d9/arc_8h.html#a320a256">LoaderFree</a>) ||
00181             (MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o1">MemoryType</a> == <a class="code" href="../../d1/d9/arc_8h.html#a320a258">LoaderLoadedProgram</a>) ||
00182             (MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o1">MemoryType</a> == <a class="code" href="../../d1/d9/arc_8h.html#a320a259">LoaderFirmwareTemporary</a>) ||
00183             (MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o1">MemoryType</a> == <a class="code" href="../../d1/d9/arc_8h.html#a320a262">LoaderOsloaderStack</a>)) {
00184         
00185             <span class="comment">//</span>
00186             <span class="comment">// Every page that will be used as free memory that is not already</span>
00187             <span class="comment">// marked as LoaderFree must be counted so a hibernate can reserve</span>
00188             <span class="comment">// the proper amount.</span>
00189             <span class="comment">//</span>
00190             
00191             <span class="keywordflow">if</span> (MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o1">MemoryType</a> != <a class="code" href="../../d1/d9/arc_8h.html#a320a256">LoaderFree</a>) {
00192                 <a class="code" href="../../d4/d8/mi_8h.html#a427">MmHiberPages</a> += MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a>;
00193             }
00194             
00195             <span class="keywordflow">if</span> ((MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a> &gt; MostFreeLowMem) &amp;&amp;
00196                 (MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o2">BasePage</a> &lt; (<a class="code" href="../../d2/d1/inialpha_8c.html#a1">_16MB</a> &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>)) &amp;&amp;
00197                 (HighPage &lt; <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a8">MM_PAGES_IN_KSEG0</a>)) {
00198             
00199                     MostFreeLowMem = MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a>;
00200                     FreeDescriptorLowMem = MemoryDescriptor;
00201             
00202             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a> &gt; MostFreePage) {
00203             
00204                     MostFreePage = MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a>;
00205                     FreeDescriptor = MemoryDescriptor;
00206             }
00207         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o1">MemoryType</a> == <a class="code" href="../../d1/d9/arc_8h.html#a320a261">LoaderOsloaderHeap</a>) {
00208             <span class="comment">//</span>
00209             <span class="comment">// We do not want to use this memory yet as it still has important</span>
00210             <span class="comment">// data structures in it. But we still want to account for this in</span>
00211             <span class="comment">// the hibernation pages</span>
00212             <span class="comment">//</span>
00213             <a class="code" href="../../d4/d8/mi_8h.html#a427">MmHiberPages</a> += MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a>;
00214         }
00215 
00216         NextMd = MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o0">ListEntry</a>.Flink;
00217     }
00218 
00219     <span class="comment">//</span>
00220     <span class="comment">// Perform sanity checks on the results of walking the memory</span>
00221     <span class="comment">// descriptors.</span>
00222     <span class="comment">//</span>
00223 
00224     <span class="keywordflow">if</span> (<a class="code" href="../../d2/d1/mm_8h.html#a136">MmNumberOfPhysicalPages</a> &lt; 1024) {
00225         <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a> (INSTALL_MORE_MEMORY,
00226                       <a class="code" href="../../d2/d1/mm_8h.html#a136">MmNumberOfPhysicalPages</a>,
00227                       <a class="code" href="../../d6/d8/sysinfo_8c.html#a6">MmLowestPhysicalPage</a>,
00228                       <a class="code" href="../../d6/d8/sysinfo_8c.html#a7">MmHighestPhysicalPage</a>,
00229                       0);
00230     }
00231 
00232     <span class="keywordflow">if</span> (FreeDescriptorLowMem == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>){
00233         <a class="code" href="../../d0/d1/inbv_8h.html#a9">InbvDisplayString</a>(<span class="stringliteral">"MmInit *** FATAL ERROR *** no free descriptors that begin below physical address 16MB\n"</span>);
00234         <a class="code" href="../../d9/d1/bugcheck_8c.html#a13">KeBugCheck</a> (MEMORY_MANAGEMENT);
00235     }
00236 
00237     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a29">MmDynamicPfn</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00238 
00239         <span class="comment">//</span>
00240         <span class="comment">// Since a ~128mb PFN database is required to span the 32GB supported</span>
00241         <span class="comment">// by Alpha, require 256mb of memory to be present to support</span>
00242         <span class="comment">// this option.</span>
00243         <span class="comment">//</span>
00244 
00245         <span class="keywordflow">if</span> (<a class="code" href="../../d2/d1/mm_8h.html#a136">MmNumberOfPhysicalPages</a> &gt;= (256 * 1024 * 1024) / <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>) {
00246             <a class="code" href="../../d2/d3/dumpctl_8c.html#a16">MmHighestPossiblePhysicalPage</a> = 0x400000 - 1;
00247         }
00248         <span class="keywordflow">else</span> {
00249             <a class="code" href="../../d8/d0/cmdat3_8c.html#a29">MmDynamicPfn</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00250         }
00251     }
00252     <span class="keywordflow">else</span> {
00253         <a class="code" href="../../d2/d3/dumpctl_8c.html#a16">MmHighestPossiblePhysicalPage</a> = <a class="code" href="../../d6/d8/sysinfo_8c.html#a7">MmHighestPhysicalPage</a>;
00254     }
00255 
00256     <span class="comment">//</span>
00257     <span class="comment">// Used later to build nonpaged pool.</span>
00258     <span class="comment">//</span>
00259 
00260     NextPhysicalPage = FreeDescriptorLowMem-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o2">BasePage</a>;
00261     NumberOfPages = FreeDescriptorLowMem-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a>;
00262 
00263     <span class="comment">//</span>
00264     <span class="comment">// Build non-paged pool using the physical pages following the</span>
00265     <span class="comment">// data page in which to build the pool from.  Non-paged pool grows</span>
00266     <span class="comment">// from the high range of the virtual address space and expands</span>
00267     <span class="comment">// downward.</span>
00268     <span class="comment">//</span>
00269     <span class="comment">// At this time non-paged pool is constructed so virtual addresses</span>
00270     <span class="comment">// are also physically contiguous.</span>
00271     <span class="comment">//</span>
00272 
00273     <span class="keywordflow">if</span> ((<a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>) &gt;
00274                         (7 * (<a class="code" href="../../d2/d1/mm_8h.html#a136">MmNumberOfPhysicalPages</a> &gt;&gt; 3))) {
00275 
00276         <span class="comment">//</span>
00277         <span class="comment">// More than 7/8 of memory allocated to nonpagedpool, reset to 0.</span>
00278         <span class="comment">//</span>
00279 
00280         <a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> = 0;
00281     }
00282 
00283     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> &lt; <a class="code" href="../../d4/d8/mi_8h.html#a620">MmMinimumNonPagedPoolSize</a>) {
00284 
00285         <span class="comment">//</span>
00286         <span class="comment">// Calculate the size of nonpaged pool.  Use the minimum size,</span>
00287         <span class="comment">// then for every MB above 8mb add extra pages.</span>
00288         <span class="comment">//</span>
00289 
00290         <a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> = <a class="code" href="../../d4/d8/mi_8h.html#a620">MmMinimumNonPagedPoolSize</a>;
00291 
00292         <a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> +=
00293                          ((<a class="code" href="../../d2/d1/mm_8h.html#a136">MmNumberOfPhysicalPages</a> - 1024) /
00294                         (<a class="code" href="../../d2/d1/inialpha_8c.html#a0">_1MB</a> &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>) ) *
00295                         <a class="code" href="../../d4/d8/mi_8h.html#a622">MmMinAdditionNonPagedPoolPerMb</a>;
00296     }
00297 
00298     <span class="comment">//</span>
00299     <span class="comment">// Align to page size boundary.</span>
00300     <span class="comment">//</span>
00301 
00302     <a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> &amp;= ~(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1);
00303 
00304     <span class="comment">//</span>
00305     <span class="comment">// Limit initial nonpaged pool size to MM_MAX_INITIAL_NONPAGED_POOL</span>
00306     <span class="comment">//</span>
00307 
00308     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> &gt; <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a30">MM_MAX_INITIAL_NONPAGED_POOL</a>) {
00309         <a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a30">MM_MAX_INITIAL_NONPAGED_POOL</a>;
00310     }
00311 
00312     <span class="comment">//</span>
00313     <span class="comment">// If the non-paged pool that we want to allocate will not fit in</span>
00314     <span class="comment">// the free memory descriptor that we have available then recompute</span>
00315     <span class="comment">// the size of non-paged pool to be the size of the free memory</span>
00316     <span class="comment">// descriptor.  If the free memory descriptor cannot fit the</span>
00317     <span class="comment">// minimum non-paged pool size (MmMinimumNonPagedPoolSize) then we</span>
00318     <span class="comment">// cannot boot the operating system.</span>
00319     <span class="comment">//</span>
00320 
00321     <span class="keywordflow">if</span> ((<a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>) &gt; NumberOfPages) {
00322 
00323          <span class="comment">//</span>
00324          <span class="comment">// Reserve all of low memory for nonpaged pool.</span>
00325          <span class="comment">//</span>
00326 
00327          <a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> = NumberOfPages &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
00328          LowMemoryReserved = NextPhysicalPage;
00329 
00330          <span class="comment">//</span>
00331          <span class="comment">// Switch to backup descriptor for all other allocations.</span>
00332          <span class="comment">//</span>
00333 
00334          NextPhysicalPage = FreeDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o2">BasePage</a>;
00335          NumberOfPages = FreeDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a>;
00336 
00337          <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> &lt; <a class="code" href="../../d4/d8/mi_8h.html#a620">MmMinimumNonPagedPoolSize</a>) {
00338             <a class="code" href="../../d0/d1/inbv_8h.html#a9">InbvDisplayString</a>(<span class="stringliteral">"MmInit *** FATAL ERROR *** cannot allocate non-paged pool\n"</span>);
00339             <a class="code" href="../../d6/d9/heappage_8c.html#a68">sprintf</a>(<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>,
00340                     <span class="stringliteral">"Largest description = %d pages, require %d pages\n"</span>,
00341                     NumberOfPages,
00342                     <a class="code" href="../../d4/d8/mi_8h.html#a620">MmMinimumNonPagedPoolSize</a> &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
00343             <a class="code" href="../../d0/d1/inbv_8h.html#a9">InbvDisplayString</a> (<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> );
00344             <a class="code" href="../../d9/d1/bugcheck_8c.html#a13">KeBugCheck</a> (MEMORY_MANAGEMENT);
00345 
00346          }
00347     }
00348 
00349     <span class="comment">//</span>
00350     <span class="comment">// Calculate the maximum size of pool.</span>
00351     <span class="comment">//</span>
00352 
00353     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a21">MmMaximumNonPagedPoolInBytes</a> == 0) {
00354 
00355         <span class="comment">//</span>
00356         <span class="comment">// Calculate the size of nonpaged pool.</span>
00357         <span class="comment">// For every MB above 8mb add extra pages.</span>
00358         <span class="comment">//</span>
00359 
00360         <a class="code" href="../../d8/d5/kddata_8c.html#a21">MmMaximumNonPagedPoolInBytes</a> = <a class="code" href="../../d4/d8/mi_8h.html#a621">MmDefaultMaximumNonPagedPool</a>;
00361 
00362         <span class="comment">//</span>
00363         <span class="comment">// Make sure enough expansion for the PFN database exists.</span>
00364         <span class="comment">//</span>
00365 
00366         <a class="code" href="../../d8/d5/kddata_8c.html#a21">MmMaximumNonPagedPoolInBytes</a> += (ULONG)<a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a> (
00367                                       <a class="code" href="../../d6/d8/sysinfo_8c.html#a7">MmHighestPhysicalPage</a> * <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d3/struct__MMPFN.html">MMPFN</a>));
00368 
00369         <a class="code" href="../../d8/d5/kddata_8c.html#a21">MmMaximumNonPagedPoolInBytes</a> +=
00370                          ((<a class="code" href="../../d2/d1/mm_8h.html#a136">MmNumberOfPhysicalPages</a> - 1024) /
00371                          (<a class="code" href="../../d2/d1/inialpha_8c.html#a0">_1MB</a> &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>) ) *
00372                          <a class="code" href="../../d4/d8/mi_8h.html#a623">MmMaxAdditionNonPagedPoolPerMb</a>;
00373     }
00374 
00375     MaxPool = <a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> * 16 +
00376                                    (ULONG)<a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a> (
00377                                         <a class="code" href="../../d6/d8/sysinfo_8c.html#a7">MmHighestPhysicalPage</a> * <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d3/struct__MMPFN.html">MMPFN</a>));
00378 
00379     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a21">MmMaximumNonPagedPoolInBytes</a> &lt; MaxPool) {
00380         <a class="code" href="../../d8/d5/kddata_8c.html#a21">MmMaximumNonPagedPoolInBytes</a> = MaxPool;
00381     }
00382 
00383     <span class="comment">//</span>
00384     <span class="comment">// If the system is configured for maximum system PTEs then limit maximum</span>
00385     <span class="comment">// nonpaged pool to 128mb so the rest of the virtual address space can</span>
00386     <span class="comment">// be used for the PTEs.  Also push as much nonpaged pool as possible</span>
00387     <span class="comment">// into kseg0 to free up more PTEs.</span>
00388     <span class="comment">//</span>
00389 
00390     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a21">MmMaximumNonPagedPoolInBytes</a> &gt; <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a31">MM_MAX_ADDITIONAL_NONPAGED_POOL</a>) {
00391 
00392         ULONG InitialNonPagedPages;
00393         ULONG ExpansionPagesToMove;
00394         ULONG LowAvailPages;
00395 
00396         <span class="keywordflow">if</span> ((<a class="code" href="../../d4/d8/mi_8h.html#a633">MiRequestedSystemPtes</a> == (ULONG)-1) || (<a class="code" href="../../d4/d8/mi_8h.html#a581">MiHydra</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>)) {
00397             <a class="code" href="../../d8/d5/kddata_8c.html#a21">MmMaximumNonPagedPoolInBytes</a> = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a31">MM_MAX_ADDITIONAL_NONPAGED_POOL</a>;
00398 
00399             <span class="keywordflow">if</span> (LowMemoryReserved == 0) {
00400 
00401                 InitialNonPagedPages = (<a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
00402     
00403                 <span class="keywordflow">if</span> (InitialNonPagedPages + 1024 &lt; NumberOfPages) {
00404                     LowAvailPages = NumberOfPages - 1024 - InitialNonPagedPages;
00405         
00406                     ExpansionPagesToMove = (<a class="code" href="../../d8/d5/kddata_8c.html#a21">MmMaximumNonPagedPoolInBytes</a> &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>) - InitialNonPagedPages;
00407         
00408                     <span class="keywordflow">if</span> (ExpansionPagesToMove &gt; 32) {
00409                         ExpansionPagesToMove -= 32;
00410                         <span class="keywordflow">if</span> (LowAvailPages &gt; ExpansionPagesToMove) {
00411                             LowAvailPages = ExpansionPagesToMove;
00412                         }
00413             
00414                         <a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> += (LowAvailPages &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
00415                     }
00416                 }
00417             }
00418 
00419             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> == <a class="code" href="../../d8/d5/kddata_8c.html#a21">MmMaximumNonPagedPoolInBytes</a>) {
00420                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> &gt; (32 &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>));
00421                 <a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> -= (32 &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
00422             }
00423         }
00424     }
00425 
00426     <span class="comment">//</span>
00427     <span class="comment">// Limit maximum nonpaged pool to MM_MAX_ADDITIONAL_NONPAGED_POOL.</span>
00428     <span class="comment">//</span>
00429 
00430     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a21">MmMaximumNonPagedPoolInBytes</a> &gt; <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a31">MM_MAX_ADDITIONAL_NONPAGED_POOL</a>) {
00431 
00432         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a21">MmMaximumNonPagedPoolInBytes</a> &gt; <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a30">MM_MAX_INITIAL_NONPAGED_POOL</a> + <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a31">MM_MAX_ADDITIONAL_NONPAGED_POOL</a>) {
00433             <a class="code" href="../../d8/d5/kddata_8c.html#a21">MmMaximumNonPagedPoolInBytes</a> = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a30">MM_MAX_INITIAL_NONPAGED_POOL</a> + <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a31">MM_MAX_ADDITIONAL_NONPAGED_POOL</a>;
00434         }
00435 
00436         <span class="keywordflow">if</span> (LowMemoryReserved != 0) {
00437             <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a21">MmMaximumNonPagedPoolInBytes</a> &gt; <a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> + <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a31">MM_MAX_ADDITIONAL_NONPAGED_POOL</a>) {
00438                 <a class="code" href="../../d8/d5/kddata_8c.html#a21">MmMaximumNonPagedPoolInBytes</a> = <a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> + <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a31">MM_MAX_ADDITIONAL_NONPAGED_POOL</a>;
00439             }
00440             <a class="code" href="../../d2/d1/inialpha_8c.html#a4">MmExpandedNonPagedPoolInBytes</a> = <a class="code" href="../../d8/d5/kddata_8c.html#a21">MmMaximumNonPagedPoolInBytes</a> - <a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a>;
00441         }
00442         <span class="keywordflow">else</span> {
00443 
00444             <span class="keywordflow">if</span> ((<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a30">MM_MAX_INITIAL_NONPAGED_POOL</a> &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>) &gt;= NumberOfPages) {
00445 
00446                 <span class="comment">//</span>
00447                 <span class="comment">// Reserve all of low memory for nonpaged pool.</span>
00448                 <span class="comment">//</span>
00449                 
00450                 SIZE_T Diff;
00451 
00452                 Diff = <a class="code" href="../../d8/d5/kddata_8c.html#a21">MmMaximumNonPagedPoolInBytes</a> - <a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a>;
00453                 <span class="keywordflow">if</span> (Diff &gt; <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a31">MM_MAX_ADDITIONAL_NONPAGED_POOL</a>) {
00454                     Diff = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a31">MM_MAX_ADDITIONAL_NONPAGED_POOL</a>;
00455                 }
00456 
00457                 <a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> = NumberOfPages &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
00458                 <a class="code" href="../../d8/d5/kddata_8c.html#a21">MmMaximumNonPagedPoolInBytes</a> = <a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> + Diff;
00459                 LowMemoryReserved = NextPhysicalPage;
00460 
00461                 <span class="comment">//</span>
00462                 <span class="comment">// Switch to backup descriptor for all other allocations.</span>
00463                 <span class="comment">//</span>
00464                 
00465                 NextPhysicalPage = FreeDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o2">BasePage</a>;
00466                 NumberOfPages = FreeDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a>;
00467             }
00468             <span class="keywordflow">else</span> {
00469 
00470                 <a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a30">MM_MAX_INITIAL_NONPAGED_POOL</a>;
00471 
00472                 <span class="comment">//</span>
00473                 <span class="comment">// The pages must be subtracted from the low descriptor so</span>
00474                 <span class="comment">// they are not used for anything else or put on the freelist.</span>
00475                 <span class="comment">// But they must be added back in later when initializing PFNs</span>
00476                 <span class="comment">// for all the descriptor ranges.</span>
00477                 <span class="comment">//</span>
00478 
00479                 RemovedLowCount = (<a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
00480                 FreeDescriptorLowMem-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a> -= RemovedLowCount;
00481                 RemovedLowPage = FreeDescriptorLowMem-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o2">BasePage</a> + FreeDescriptorLowMem-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a>;
00482 
00483                 NumberOfPages = FreeDescriptorLowMem-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a>;
00484             }
00485 
00486             <a class="code" href="../../d2/d1/inialpha_8c.html#a4">MmExpandedNonPagedPoolInBytes</a> = <a class="code" href="../../d8/d5/kddata_8c.html#a21">MmMaximumNonPagedPoolInBytes</a> - <a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a>;
00487 
00488             <span class="keywordflow">if</span> (<a class="code" href="../../d2/d1/inialpha_8c.html#a4">MmExpandedNonPagedPoolInBytes</a> &gt; <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a31">MM_MAX_ADDITIONAL_NONPAGED_POOL</a>) {
00489                 <a class="code" href="../../d2/d1/inialpha_8c.html#a4">MmExpandedNonPagedPoolInBytes</a> = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a31">MM_MAX_ADDITIONAL_NONPAGED_POOL</a>;
00490             }
00491         }
00492     }
00493 
00494     <span class="keywordflow">if</span> (<a class="code" href="../../d2/d1/inialpha_8c.html#a4">MmExpandedNonPagedPoolInBytes</a>) {
00495         <a class="code" href="../../d8/d5/kddata_8c.html#a23">MmNonPagedPoolStart</a> = (PVOID)((ULONG)<a class="code" href="../../d8/d5/kddata_8c.html#a24">MmNonPagedPoolEnd</a>
00496                                           - <a class="code" href="../../d2/d1/inialpha_8c.html#a4">MmExpandedNonPagedPoolInBytes</a>);
00497     }
00498     <span class="keywordflow">else</span> {
00499         <a class="code" href="../../d8/d5/kddata_8c.html#a23">MmNonPagedPoolStart</a> = (PVOID)((ULONG)<a class="code" href="../../d8/d5/kddata_8c.html#a24">MmNonPagedPoolEnd</a>
00500                                           - (<a class="code" href="../../d8/d5/kddata_8c.html#a21">MmMaximumNonPagedPoolInBytes</a> - 1));
00501     }
00502 
00503     <a class="code" href="../../d8/d5/kddata_8c.html#a23">MmNonPagedPoolStart</a> = (PVOID)<a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a>(<a class="code" href="../../d8/d5/kddata_8c.html#a23">MmNonPagedPoolStart</a>);
00504     NonPagedPoolStartVirtual = <a class="code" href="../../d8/d5/kddata_8c.html#a23">MmNonPagedPoolStart</a>;
00505 
00506     <span class="comment">//</span>
00507     <span class="comment">// Calculate the starting PDE for the system PTE pool which is</span>
00508     <span class="comment">// right below the nonpaged pool.</span>
00509     <span class="comment">//</span>
00510 
00511     <a class="code" href="../../d8/d5/kddata_8c.html#a22">MmNonPagedSystemStart</a> = (PVOID)(((ULONG)<a class="code" href="../../d8/d5/kddata_8c.html#a23">MmNonPagedPoolStart</a> -
00512                                 ((<a class="code" href="../../d8/d0/cmdat3_8c.html#a23">MmNumberOfSystemPtes</a> + 1) * <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>)) &amp;
00513                                  (~<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a49">PAGE_DIRECTORY_MASK</a>));
00514 
00515     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d5/kddata_8c.html#a22">MmNonPagedSystemStart</a> &lt; <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a22">MM_LOWEST_NONPAGED_SYSTEM_START</a>) {
00516         <a class="code" href="../../d8/d5/kddata_8c.html#a22">MmNonPagedSystemStart</a> = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a22">MM_LOWEST_NONPAGED_SYSTEM_START</a>;
00517     }
00518 
00519     <a class="code" href="../../d8/d0/cmdat3_8c.html#a23">MmNumberOfSystemPtes</a> = (((ULONG)<a class="code" href="../../d8/d5/kddata_8c.html#a23">MmNonPagedPoolStart</a> -
00520                              (ULONG)<a class="code" href="../../d8/d5/kddata_8c.html#a22">MmNonPagedSystemStart</a>) &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>)-1;
00521     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a23">MmNumberOfSystemPtes</a> &gt; 1000);
00522 
00523     <span class="comment">//</span>
00524     <span class="comment">// Set the global bit for all PDEs in system space.</span>
00525     <span class="comment">//</span>
00526 
00527     StartPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a151">MiGetPdeAddress</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a11">MM_SYSTEM_SPACE_START</a>);
00528     EndPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a151">MiGetPdeAddress</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a25">MM_SYSTEM_SPACE_END</a>);
00529 
00530     <span class="keywordflow">while</span> (StartPde &lt;= EndPde) {
00531 
00532         <span class="keywordflow">if</span> (StartPde-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Global == 0) {
00533             TempPte = *StartPde;
00534             TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Global = 1;
00535             *StartPde = TempPte;
00536         }
00537 
00538         StartPde += 1;
00539     }
00540 
00541     <span class="keywordflow">if</span> (<a class="code" href="../../d4/d8/mi_8h.html#a581">MiHydra</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00542 
00543         <span class="comment">//</span>
00544         <span class="comment">// Clear the global bit for all session space addresses.</span>
00545         <span class="comment">//</span>
00546 
00547         StartPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a151">MiGetPdeAddress</a> (<a class="code" href="../../d4/d8/mi_8h.html#a748">MmSessionBase</a>);
00548         EndPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a151">MiGetPdeAddress</a> (<a class="code" href="../../d4/d8/mi_8h.html#a351">MI_SESSION_SPACE_END</a>);
00549 
00550         <span class="keywordflow">while</span> (StartPde &lt; EndPde) {
00551     
00552             <span class="keywordflow">if</span> (StartPde-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Global == 1) {
00553                 TempPte = *StartPde;
00554                 TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Global = 0;
00555                 *StartPde = TempPte;
00556             }
00557 
00558             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (StartPde-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Long == 0);
00559             StartPde += 1;
00560         }
00561     }
00562 
00563     StartPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a151">MiGetPdeAddress</a> (<a class="code" href="../../d8/d5/kddata_8c.html#a22">MmNonPagedSystemStart</a>);
00564 
00565     EndPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a151">MiGetPdeAddress</a> (<a class="code" href="../../d8/d5/kddata_8c.html#a24">MmNonPagedPoolEnd</a>);
00566 
00567     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((EndPde - StartPde) &lt; (LONG)NumberOfPages);
00568 
00569     TempPte = <a class="code" href="../../d4/d2/datalpha_8c.html#a2">ValidKernelPte</a>;
00570 
00571     <span class="keywordflow">while</span> (StartPde &lt;= EndPde) {
00572         <span class="keywordflow">if</span> (StartPde-&gt;u.Hard.Valid == 0) {
00573 
00574         <span class="comment">//</span>
00575         <span class="comment">// Map in a page directory page.</span>
00576         <span class="comment">//</span>
00577 
00578         TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber = NextPhysicalPage;
00579         NumberOfPages -= 1;
00580         NextPhysicalPage += 1;
00581 
00582         <span class="keywordflow">if</span> (NumberOfPages == 0) {
00583             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (NextPhysicalPage != (FreeDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o2">BasePage</a> +
00584                     FreeDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a>));
00585             NextPhysicalPage = FreeDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o2">BasePage</a>;
00586             NumberOfPages = FreeDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a>;
00587         }
00588         *StartPde = TempPte;
00589       }
00590       StartPde += 1;
00591     }
00592 
00593     <span class="comment">//</span>
00594     <span class="comment">// Zero the PTEs before non-paged pool.</span>
00595     <span class="comment">//</span>
00596 
00597     StartPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (<a class="code" href="../../d8/d5/kddata_8c.html#a22">MmNonPagedSystemStart</a>);
00598     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (<a class="code" href="../../d8/d5/kddata_8c.html#a23">MmNonPagedPoolStart</a>);
00599 
00600     RtlZeroMemory (StartPde, (ULONG)PointerPte - (ULONG)StartPde);
00601 
00602     <span class="comment">//</span>
00603     <span class="comment">// Fill in the PTEs for non-paged pool.</span>
00604     <span class="comment">//</span>
00605 
00606     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(<a class="code" href="../../d8/d5/kddata_8c.html#a23">MmNonPagedPoolStart</a>);
00607     LastPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>((ULONG)<a class="code" href="../../d8/d5/kddata_8c.html#a23">MmNonPagedPoolStart</a> +
00608                                         <a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> - 1);
00609 
00610     <span class="keywordflow">if</span> (<a class="code" href="../../d2/d1/inialpha_8c.html#a4">MmExpandedNonPagedPoolInBytes</a> == 0) {
00611         <span class="keywordflow">if</span> (!LowMemoryReserved) {
00612     
00613             <span class="keywordflow">if</span> (NumberOfPages &lt; (ULONG)(LastPte - PointerPte + 1)) {
00614     
00615                 <span class="comment">//</span>
00616                 <span class="comment">// Can't just switch descriptors here - the initial nonpaged</span>
00617                 <span class="comment">// pool is always mapped via KSEG0 and is thus required to be</span>
00618                 <span class="comment">// virtually and physically contiguous.</span>
00619                 <span class="comment">//</span>
00620     
00621                 <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a> (INSTALL_MORE_MEMORY,
00622                               <a class="code" href="../../d2/d1/mm_8h.html#a136">MmNumberOfPhysicalPages</a>,
00623                               NumberOfPages,
00624                               LastPte - PointerPte + 1,
00625                               1);
00626             }
00627             
00628             <span class="keywordflow">while</span> (PointerPte &lt;= LastPte) {
00629                 TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber = NextPhysicalPage;
00630                 NextPhysicalPage += 1;
00631                 NumberOfPages -= 1;
00632                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (NumberOfPages != 0);
00633                 *PointerPte = TempPte;
00634                 PointerPte += 1;
00635             }
00636     
00637         } <span class="keywordflow">else</span> {
00638     
00639             ULONG ReservedPage = FreeDescriptorLowMem-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o2">BasePage</a>;
00640     
00641             <span class="keywordflow">while</span> (PointerPte &lt;= LastPte) {
00642                 TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber = ReservedPage;
00643                 ReservedPage += 1;
00644                 *PointerPte = TempPte;
00645                 PointerPte += 1;
00646             }
00647         }
00648         LastPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> ((ULONG)<a class="code" href="../../d8/d5/kddata_8c.html#a23">MmNonPagedPoolStart</a> +
00649                                       <a class="code" href="../../d8/d5/kddata_8c.html#a21">MmMaximumNonPagedPoolInBytes</a> - 1);
00650     }
00651     <span class="keywordflow">else</span> {
00652         LastPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> ((ULONG)<a class="code" href="../../d8/d5/kddata_8c.html#a23">MmNonPagedPoolStart</a> +
00653                                       <a class="code" href="../../d2/d1/inialpha_8c.html#a4">MmExpandedNonPagedPoolInBytes</a> - 1);
00654     }
00655 
00656     <span class="comment">//</span>
00657     <span class="comment">// Zero the remaining PTEs for non-paged pool maximum.</span>
00658     <span class="comment">//</span>
00659 
00660     <span class="keywordflow">while</span> (PointerPte &lt;= LastPte) {
00661         *PointerPte = <a class="code" href="../../d4/d2/datalpha_8c.html#a1">ZeroKernelPte</a>;
00662         PointerPte += 1;
00663     }
00664 
00665     <span class="comment">//</span>
00666     <span class="comment">// Zero the remaining PTEs (if any).</span>
00667     <span class="comment">//</span>
00668 
00669     <span class="keywordflow">while</span> (((ULONG)PointerPte &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) != 0) {
00670         *PointerPte = <a class="code" href="../../d4/d2/datalpha_8c.html#a1">ZeroKernelPte</a>;
00671         PointerPte += 1;
00672     }
00673 
00674     <span class="keywordflow">if</span> (<a class="code" href="../../d2/d1/inialpha_8c.html#a4">MmExpandedNonPagedPoolInBytes</a>) {
00675 
00676         <span class="keywordflow">if</span> (LowMemoryReserved) {
00677             <a class="code" href="../../d8/d5/kddata_8c.html#a23">MmNonPagedPoolStart</a> = (PVOID)((LowMemoryReserved &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>) |
00678                                   <a class="code" href="../../d6/d7/halmips_8h.html#a443">KSEG0_BASE</a>);
00679         }
00680         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (RemovedLowPage) {
00681             <a class="code" href="../../d8/d5/kddata_8c.html#a23">MmNonPagedPoolStart</a> = (PVOID)((RemovedLowPage &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>) |
00682                                   <a class="code" href="../../d6/d7/halmips_8h.html#a443">KSEG0_BASE</a>);
00683         }
00684         <span class="keywordflow">else</span> {
00685             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00686         }
00687     }
00688     <span class="keywordflow">else</span> {
00689         PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (<a class="code" href="../../d8/d5/kddata_8c.html#a23">MmNonPagedPoolStart</a>);
00690         <a class="code" href="../../d8/d5/kddata_8c.html#a23">MmNonPagedPoolStart</a> = (PVOID)((PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>) |
00691                               <a class="code" href="../../d6/d7/halmips_8h.html#a443">KSEG0_BASE</a>);
00692     }
00693 
00694     <a class="code" href="../../d4/d8/mi_8h.html#a653">MmPageAlignedPoolBase</a>[<a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>] = <a class="code" href="../../d8/d5/kddata_8c.html#a23">MmNonPagedPoolStart</a>;
00695 
00696     <a class="code" href="../../d8/d5/kddata_8c.html#a16">MmSubsectionBase</a> = (ULONG)<a class="code" href="../../d8/d5/kddata_8c.html#a23">MmNonPagedPoolStart</a>;
00697 
00698     <span class="keywordflow">if</span> (<a class="code" href="../../d2/d1/inialpha_8c.html#a4">MmExpandedNonPagedPoolInBytes</a> == 0) {
00699         <span class="keywordflow">if</span> (NextPhysicalPage &lt; (MM_SUBSECTION_MAP &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>)) {
00700             <a class="code" href="../../d8/d5/kddata_8c.html#a16">MmSubsectionBase</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a443">KSEG0_BASE</a>;
00701         }
00702     }
00703 
00704     <a class="code" href="../../d4/d8/mi_8h.html#a580">MmSubsectionTopPage</a> = (((<a class="code" href="../../d8/d5/kddata_8c.html#a16">MmSubsectionBase</a> &amp; ~<a class="code" href="../../d6/d7/halmips_8h.html#a443">KSEG0_BASE</a>) + <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a147">MM_SUBSECTION_MAP</a>) &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
00705 
00706     <span class="comment">//</span>
00707     <span class="comment">// Non-paged pages now exist, build the pool structures.</span>
00708     <span class="comment">//</span>
00709 
00710     <span class="keywordflow">if</span> (<a class="code" href="../../d2/d1/inialpha_8c.html#a4">MmExpandedNonPagedPoolInBytes</a>) {
00711         <a class="code" href="../../d1/d6/allocpag_8c.html#a7">MmNonPagedPoolExpansionStart</a> = (PVOID)NonPagedPoolStartVirtual;
00712     }
00713     <span class="keywordflow">else</span> {
00714         <a class="code" href="../../d1/d6/allocpag_8c.html#a7">MmNonPagedPoolExpansionStart</a> = (PVOID)((PCHAR)NonPagedPoolStartVirtual +
00715                         <a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a>);
00716     }
00717 
00718     <a class="code" href="../../d4/d8/mi_8h.html#a778">MiInitializeNonPagedPool</a> ();
00719 
00720     <span class="comment">//</span>
00721     <span class="comment">// Before Non-paged pool can be used, the PFN database must</span>
00722     <span class="comment">// be built.  This is due to the fact that the start and end of</span>
00723     <span class="comment">// allocation bits for nonpaged pool are maintained in the</span>
00724     <span class="comment">// PFN elements for the corresponding pages.</span>
00725     <span class="comment">//</span>
00726 
00727     <span class="comment">//</span>
00728     <span class="comment">// Calculate the number of pages required from page zero to</span>
00729     <span class="comment">// the highest page.</span>
00730     <span class="comment">//</span>
00731     <span class="comment">// Get the number of secondary colors and add the array for tracking</span>
00732     <span class="comment">// secondary colors to the end of the PFN database.</span>
00733     <span class="comment">//</span>
00734 
00735     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a> == 0) {
00736         <a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a> = PCR-&gt;SecondLevelCacheSize;
00737     }
00738 
00739     <a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a> = <a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a> &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
00740 
00741     <span class="comment">//</span>
00742     <span class="comment">// Make sure value is power of two and within limits.</span>
00743     <span class="comment">//</span>
00744 
00745     <span class="keywordflow">if</span> (((<a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a> &amp; (<a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a> -1)) != 0) ||
00746         (<a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a> &lt; <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a61">MM_SECONDARY_COLORS_MIN</a>) ||
00747         (<a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a> &gt; <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a62">MM_SECONDARY_COLORS_MAX</a>)) {
00748 
00749         <a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a> = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a60">MM_SECONDARY_COLORS_DEFAULT</a>;
00750     }
00751 
00752     <a class="code" href="../../d4/d2/datalpha_8c.html#a22">MmSecondaryColorMask</a> = <a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a> - 1;
00753 
00754     PfnAllocation = 1 + ((((<a class="code" href="../../d2/d3/dumpctl_8c.html#a16">MmHighestPossiblePhysicalPage</a> + 1) * <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d8/mi_8h.html#a438">MMPFN</a>)) +
00755                         (<a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a> * <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d1/struct__MMCOLOR__TABLES.html">MMCOLOR_TABLES</a>)*2))
00756                             &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
00757 
00758     <span class="comment">//</span>
00759     <span class="comment">// If the number of pages remaining in the current descriptor is</span>
00760     <span class="comment">// greater than the number of pages needed for the PFN database,</span>
00761     <span class="comment">// and the descriptor is for memory below 1 gig, then allocate the</span>
00762     <span class="comment">// PFN database from the current free descriptor.</span>
00763     <span class="comment">// Note: FW creates a new memory descriptor for any memory above 1GB.</span>
00764     <span class="comment">// Thus we don't need to worry if the highest page will go beyond 1GB for</span>
00765     <span class="comment">// this memory descriptor.</span>
00766     <span class="comment">//</span>
00767 
00768 <span class="preprocessor">#ifndef PFN_CONSISTENCY</span>
00769 <span class="preprocessor"></span>    <span class="keywordflow">if</span> ((NumberOfPages &gt;= PfnAllocation) &amp;&amp;
00770         (NextPhysicalPage + NumberOfPages &lt;= <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a8">MM_PAGES_IN_KSEG0</a>)) {
00771 
00772         <span class="comment">//</span>
00773         <span class="comment">// Allocate the PFN database in kseg0.</span>
00774         <span class="comment">//</span>
00775         <span class="comment">// Compute the address of the PFN by allocating the appropriate</span>
00776         <span class="comment">// number of pages from the end of the free descriptor.</span>
00777         <span class="comment">//</span>
00778 
00779         PfnInKseg0 = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00780         HighPage = NextPhysicalPage + NumberOfPages;
00781         <a class="code" href="../../d2/d3/dumpctl_8c.html#a15">MmPfnDatabase</a> = (<a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a>)(<a class="code" href="../../d6/d7/halmips_8h.html#a443">KSEG0_BASE</a> |
00782                                  ((HighPage - PfnAllocation) &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>));
00783         RtlZeroMemory(<a class="code" href="../../d2/d3/dumpctl_8c.html#a15">MmPfnDatabase</a>, PfnAllocation * <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
00784 
00785         <span class="comment">//</span>
00786         <span class="comment">// Mark off the chunk of memory used for the PFN database.</span>
00787         <span class="comment">//</span>
00788 
00789         NumberOfPages -= PfnAllocation;
00790 
00791         <span class="keywordflow">if</span> (NextPhysicalPage &gt;= FreeDescriptorLowMem-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o2">BasePage</a> &amp;&amp;
00792             NextPhysicalPage &lt; (FreeDescriptorLowMem-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o2">BasePage</a> +
00793                                 FreeDescriptorLowMem-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a>)) {
00794 
00795             <span class="comment">//</span>
00796             <span class="comment">// We haven't used the other descriptor.</span>
00797             <span class="comment">//</span>
00798             
00799             FreeDescriptorLowMem-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a> -= PfnAllocation;
00800 
00801         } <span class="keywordflow">else</span> {
00802 
00803             FreeDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a> -= PfnAllocation;
00804         }
00805 
00806         <span class="comment">//</span>
00807         <span class="comment">// Allocate one PTE at the very top of the Mm virtual address space.</span>
00808         <span class="comment">// This provides protection against the caller of the first real</span>
00809         <span class="comment">// nonpaged expansion allocation in case he accidentally overruns his</span>
00810         <span class="comment">// pool block.  (We'll trap instead of corrupting the crashdump PTEs).</span>
00811         <span class="comment">// This also allows us to freely increment in MiFreePoolPages</span>
00812         <span class="comment">// without having to worry about a valid PTE just after the end of</span>
00813         <span class="comment">// the highest nonpaged pool allocation.</span>
00814         <span class="comment">//</span>
00815 
00816         <a class="code" href="../../d0/d9/sysptes_8c.html#a25">MiReserveSystemPtes</a> (1,
00817                              <a class="code" href="../../d4/d8/mi_8h.html#a1003a770">NonPagedPoolExpansion</a>,
00818                              0,
00819                              0,
00820                              <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
00821 
00822     } <span class="keywordflow">else</span> {
00823 
00824 <span class="preprocessor">#endif   // PFN_CONSISTENCY</span>
00825 <span class="preprocessor"></span>
00826         <span class="comment">//</span>
00827         <span class="comment">// Calculate the start of the Pfn database (it starts at physical</span>
00828         <span class="comment">// page zero, even if the lowest physical page is not zero).</span>
00829         <span class="comment">//</span>
00830 
00831         PfnInKseg0 = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00832         PointerPte = <a class="code" href="../../d0/d9/sysptes_8c.html#a25">MiReserveSystemPtes</a> (PfnAllocation,
00833                                           <a class="code" href="../../d4/d8/mi_8h.html#a1003a770">NonPagedPoolExpansion</a>,
00834                                           0,
00835                                           0,
00836                                           <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
00837 
00838 <span class="preprocessor">#if PFN_CONSISTENCY</span>
00839 <span class="preprocessor"></span>        MiPfnStartPte = PointerPte;
00840         MiPfnPtes = PfnAllocation;
00841 <span class="preprocessor">#endif</span>
00842 <span class="preprocessor"></span>
00843         <a class="code" href="../../d2/d3/dumpctl_8c.html#a15">MmPfnDatabase</a> = (<a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a>)(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPte));
00844 
00845         <span class="comment">//</span>
00846         <span class="comment">// Allocate one more PTE just below the PFN database.  This provides</span>
00847         <span class="comment">// protection against the caller of the first real nonpaged</span>
00848         <span class="comment">// expansion allocation in case he accidentally overruns his pool</span>
00849         <span class="comment">// block.  (We'll trap instead of corrupting the PFN database).</span>
00850         <span class="comment">// This also allows us to freely increment in MiFreePoolPages</span>
00851         <span class="comment">// without having to worry about a valid PTE just after the end of</span>
00852         <span class="comment">// the highest nonpaged pool allocation.</span>
00853         <span class="comment">//</span>
00854 
00855         <a class="code" href="../../d0/d9/sysptes_8c.html#a25">MiReserveSystemPtes</a> (1,
00856                              <a class="code" href="../../d4/d8/mi_8h.html#a1003a770">NonPagedPoolExpansion</a>,
00857                              0,
00858                              0,
00859                              <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
00860 
00861         <span class="comment">//</span>
00862         <span class="comment">// Go through the memory descriptors and for each physical page</span>
00863         <span class="comment">// make sure the PFN database has a valid PTE to map it.  This allows</span>
00864         <span class="comment">// machines with sparse physical memory to have a minimal PFN</span>
00865         <span class="comment">// database.</span>
00866         <span class="comment">//</span>
00867 
00868         NextMd = LoaderBlock-&gt;MemoryDescriptorListHead.Flink;
00869 
00870         <span class="keywordflow">while</span> (NextMd != &amp;LoaderBlock-&gt;MemoryDescriptorListHead) {
00871 
00872             MemoryDescriptor = CONTAINING_RECORD(NextMd,
00873                                                  <a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html">MEMORY_ALLOCATION_DESCRIPTOR</a>,
00874                                                  ListEntry);
00875 
00876             PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (<a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(
00877                                             MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o2">BasePage</a>));
00878 
00879             LastPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (((PCHAR)(<a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(
00880                                             MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o2">BasePage</a> +
00881                                             MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a>))) - 1);
00882 
00883             <span class="comment">//</span>
00884             <span class="comment">// If memory was temporarily removed to create the initial non</span>
00885             <span class="comment">// paged pool, account for it now so PFN entries are created for it.</span>
00886             <span class="comment">//</span>
00887 
00888             <span class="keywordflow">if</span> (MemoryDescriptor == FreeDescriptorLowMem) {
00889                 <span class="keywordflow">if</span> (RemovedLowPage) {
00890                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o2">BasePage</a> + MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a> == RemovedLowPage);
00891                     LastPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (((PCHAR)(<a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(
00892                                                     MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o2">BasePage</a> +
00893                                                     RemovedLowCount +
00894                                                     MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a>))) - 1);
00895                 }
00896             }
00897 
00898             <span class="keywordflow">while</span> (PointerPte &lt;= LastPte) {
00899 
00900                 <span class="keywordflow">if</span> (PointerPte-&gt;u.Hard.Valid == 0) {
00901                     TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber = NextPhysicalPage;
00902                     NextPhysicalPage += 1;
00903                     NumberOfPages -= 1;
00904                     <span class="keywordflow">if</span> (NumberOfPages == 0) {
00905                         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (NextPhysicalPage != (FreeDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o2">BasePage</a> +
00906                                 FreeDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a>));
00907                         NextPhysicalPage = FreeDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o2">BasePage</a>;
00908                         NumberOfPages = FreeDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a>;
00909                     }
00910                     *PointerPte = TempPte;
00911                     RtlZeroMemory (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPte),
00912                                    <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
00913                 }
00914                 PointerPte += 1;
00915             }
00916             NextMd = MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o0">ListEntry</a>.Flink;
00917         }
00918 <span class="preprocessor">#ifndef PFN_CONSISTENCY</span>
00919 <span class="preprocessor"></span>    }
00920 <span class="preprocessor">#endif // PFN_CONSISTENCY</span>
00921 <span class="preprocessor"></span>
00922     <span class="comment">//</span>
00923     <span class="comment">// Initialize support for colored pages.</span>
00924     <span class="comment">//</span>
00925 
00926     <a class="code" href="../../d4/d2/datalpha_8c.html#a20">MmFreePagesByColor</a>[0] = (<a class="code" href="../../d4/d1/struct__MMCOLOR__TABLES.html">PMMCOLOR_TABLES</a>)
00927                                 &amp;<a class="code" href="../../d2/d3/dumpctl_8c.html#a15">MmPfnDatabase</a>[<a class="code" href="../../d2/d3/dumpctl_8c.html#a16">MmHighestPossiblePhysicalPage</a> + 1];
00928 
00929     <a class="code" href="../../d4/d2/datalpha_8c.html#a20">MmFreePagesByColor</a>[1] = &amp;<a class="code" href="../../d4/d2/datalpha_8c.html#a20">MmFreePagesByColor</a>[0][<a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a>];
00930 
00931     <span class="comment">//</span>
00932     <span class="comment">// Make sure the PTEs are mapped.</span>
00933     <span class="comment">//</span>
00934 
00935     <span class="keywordflow">if</span> (!<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a>(<a class="code" href="../../d4/d2/datalpha_8c.html#a20">MmFreePagesByColor</a>[0])) {
00936 
00937         PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (&amp;<a class="code" href="../../d4/d2/datalpha_8c.html#a20">MmFreePagesByColor</a>[0][0]);
00938 
00939         LastPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (
00940                   (PVOID)((PCHAR)&amp;<a class="code" href="../../d4/d2/datalpha_8c.html#a20">MmFreePagesByColor</a>[1][<a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a>]-1));
00941 
00942         <span class="keywordflow">while</span> (PointerPte &lt;= LastPte) {
00943             <span class="keywordflow">if</span> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 0) {
00944                 TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber = NextPhysicalPage;
00945                 NextPhysicalPage += 1;
00946                 NumberOfPages -= 1;
00947                 <span class="keywordflow">if</span> (NumberOfPages == 0) {
00948                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (NextPhysicalPage != (FreeDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o2">BasePage</a> +
00949                                                  FreeDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a>));
00950                     NextPhysicalPage = FreeDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o2">BasePage</a>;
00951                     NumberOfPages = FreeDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a>;
00952                 }
00953                 *PointerPte = TempPte;
00954                 RtlZeroMemory (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPte),
00955                                <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
00956             }
00957             PointerPte += 1;
00958         }
00959     }
00960 
00961     <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a>; i += 1) {
00962         <a class="code" href="../../d4/d2/datalpha_8c.html#a20">MmFreePagesByColor</a>[<a class="code" href="../../d2/d1/mm_8h.html#a345a171">ZeroedPageList</a>][i].<a class="code" href="../../d4/d1/struct__MMCOLOR__TABLES.html#o0">Flink</a> = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a>;
00963         <a class="code" href="../../d4/d2/datalpha_8c.html#a20">MmFreePagesByColor</a>[<a class="code" href="../../d2/d1/mm_8h.html#a345a172">FreePageList</a>][i].<a class="code" href="../../d4/d1/struct__MMCOLOR__TABLES.html#o0">Flink</a> = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a>;
00964     }
00965 
00966 <span class="preprocessor">#if MM_MAXIMUM_NUMBER_OF_COLORS &gt; 1</span>
00967 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a55">MM_MAXIMUM_NUMBER_OF_COLORS</a>; i += 1) {
00968         <a class="code" href="../../d5/d2/datamips_8c.html#a9">MmFreePagesByPrimaryColor</a>[<a class="code" href="../../d2/d1/mm_8h.html#a345a171">ZeroedPageList</a>][i].<a class="code" href="../../d0/d4/struct__MMPFNLIST.html#o1">ListName</a> = <a class="code" href="../../d2/d1/mm_8h.html#a345a171">ZeroedPageList</a>;
00969         <a class="code" href="../../d5/d2/datamips_8c.html#a9">MmFreePagesByPrimaryColor</a>[<a class="code" href="../../d2/d1/mm_8h.html#a345a172">FreePageList</a>][i].<a class="code" href="../../d0/d4/struct__MMPFNLIST.html#o1">ListName</a> = <a class="code" href="../../d2/d1/mm_8h.html#a345a172">FreePageList</a>;
00970         <a class="code" href="../../d5/d2/datamips_8c.html#a9">MmFreePagesByPrimaryColor</a>[<a class="code" href="../../d2/d1/mm_8h.html#a345a171">ZeroedPageList</a>][i].<a class="code" href="../../d0/d4/struct__MMPFNLIST.html#o2">Flink</a> = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a>;
00971         <a class="code" href="../../d5/d2/datamips_8c.html#a9">MmFreePagesByPrimaryColor</a>[<a class="code" href="../../d2/d1/mm_8h.html#a345a172">FreePageList</a>][i].<a class="code" href="../../d0/d4/struct__MMPFNLIST.html#o2">Flink</a> = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a>;
00972         <a class="code" href="../../d5/d2/datamips_8c.html#a9">MmFreePagesByPrimaryColor</a>[<a class="code" href="../../d2/d1/mm_8h.html#a345a171">ZeroedPageList</a>][i].<a class="code" href="../../d0/d4/struct__MMPFNLIST.html#o3">Blink</a> = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a>;
00973         <a class="code" href="../../d5/d2/datamips_8c.html#a9">MmFreePagesByPrimaryColor</a>[<a class="code" href="../../d2/d1/mm_8h.html#a345a172">FreePageList</a>][i].<a class="code" href="../../d0/d4/struct__MMPFNLIST.html#o3">Blink</a> = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a0">MM_EMPTY_LIST</a>;
00974     }
00975 <span class="preprocessor">#endif</span>
00976 <span class="preprocessor"></span>
00977     <span class="comment">//</span>
00978     <span class="comment">// Go through the page table entries and for any page which is</span>
00979     <span class="comment">// valid, update the corresponding PFN database element.</span>
00980     <span class="comment">//</span>
00981 
00982     PointerPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a151">MiGetPdeAddress</a> (PTE_BASE);
00983 
00984     PdePage = PointerPde-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber;
00985     Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(PdePage);
00986     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o17">PteFrame</a> = PdePage;
00987     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> = PointerPde;
00988     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount += 1;
00989     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount = 1;
00990     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageLocation = <a class="code" href="../../d2/d1/mm_8h.html#a345a177">ActiveAndValid</a>;
00991     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageColor =
00992         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a132">MI_GET_COLOR_FROM_SECONDARY</a>(GET_PAGE_COLOR_FROM_PTE (PointerPde));
00993 
00994     <span class="comment">//</span>
00995     <span class="comment">// Add the pages which were used to construct nonpaged pool to</span>
00996     <span class="comment">// the PFN database.</span>
00997     <span class="comment">//</span>
00998 
00999     Pde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a151">MiGetPdeAddress</a> (<a class="code" href="../../d8/d5/kddata_8c.html#a22">MmNonPagedSystemStart</a>);
01000 
01001     EndPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a151">MiGetPdeAddress</a>(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a24">NON_PAGED_SYSTEM_END</a>);
01002 
01003     <span class="keywordflow">while</span> (Pde &lt;= EndPde) {
01004         <span class="keywordflow">if</span> (Pde-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1) {
01005             PdePage = Pde-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber;
01006             Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(PdePage);
01007             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o17">PteFrame</a> = PointerPde-&gt;u.Hard.PageFrameNumber;
01008             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> = Pde;
01009             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount += 1;
01010             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount = 1;
01011             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageLocation = <a class="code" href="../../d2/d1/mm_8h.html#a345a177">ActiveAndValid</a>;
01012             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageColor =
01013                 <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a132">MI_GET_COLOR_FROM_SECONDARY</a>(GET_PAGE_COLOR_FROM_PTE (Pde));
01014 
01015             PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (Pde);
01016             <span class="keywordflow">for</span> (j = 0 ; j &lt; <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a103">PTE_PER_PAGE</a>; j += 1) {
01017                 <span class="keywordflow">if</span> (PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Valid == 1) {
01018 
01019                     PageFrameIndex = PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber;
01020                     Pfn2 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(PageFrameIndex);
01021                     Pfn2-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o17">PteFrame</a> = PdePage;
01022                     Pfn2-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount += 1;
01023                     Pfn2-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount = 1;
01024                     Pfn2-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageLocation = <a class="code" href="../../d2/d1/mm_8h.html#a345a177">ActiveAndValid</a>;
01025 
01026                     Pfn2-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> =
01027                             (<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)(<a class="code" href="../../d6/d7/halmips_8h.html#a443">KSEG0_BASE</a> | (PageFrameIndex &lt;&lt; <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a52">PTE_SHIFT</a>));
01028 
01029                     Pfn2-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageColor =
01030                             <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a132">MI_GET_COLOR_FROM_SECONDARY</a>(GET_PAGE_COLOR_FROM_PTE (Pfn2-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a>));
01031                 }
01032                 PointerPte += 1;
01033             }
01034         }
01035         Pde += 1;
01036     }
01037 
01038     <span class="comment">//</span>
01039     <span class="comment">// Handle the initial nonpaged pool on expanded systems.</span>
01040     <span class="comment">//</span>
01041 
01042     <span class="keywordflow">if</span> (<a class="code" href="../../d2/d1/inialpha_8c.html#a4">MmExpandedNonPagedPoolInBytes</a>) {
01043         PageFrameIndex = (((ULONG_PTR)<a class="code" href="../../d8/d5/kddata_8c.html#a23">MmNonPagedPoolStart</a> &amp; ~<a class="code" href="../../d6/d7/halmips_8h.html#a443">KSEG0_BASE</a>) &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
01044         Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(PageFrameIndex);
01045         j = PageFrameIndex + (<a class="code" href="../../d8/d0/cmdat3_8c.html#a19">MmSizeOfNonPagedPoolInBytes</a> &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
01046         <span class="keywordflow">while</span> (PageFrameIndex &lt; j) {
01047             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o17">PteFrame</a> = PdePage;
01048             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount += 1;
01049             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount = 1;
01050             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageLocation = <a class="code" href="../../d2/d1/mm_8h.html#a345a177">ActiveAndValid</a>;
01051 
01052             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> =
01053                     (<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)(<a class="code" href="../../d6/d7/halmips_8h.html#a443">KSEG0_BASE</a> | (PageFrameIndex &lt;&lt; <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a52">PTE_SHIFT</a>));
01054 
01055             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageColor =
01056                     <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a132">MI_GET_COLOR_FROM_SECONDARY</a>(GET_PAGE_COLOR_FROM_PTE (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a>));
01057             PageFrameIndex += 1;
01058             Pfn1 += 1;
01059         }
01060     }
01061 
01062     <span class="comment">//</span>
01063     <span class="comment">// If page zero is still unused, mark it as in use. This is</span>
01064     <span class="comment">// temporary as we want to find bugs where a physical page</span>
01065     <span class="comment">// is specified as zero.</span>
01066     <span class="comment">//</span>
01067 
01068     Pfn1 = &amp;<a class="code" href="../../d2/d3/dumpctl_8c.html#a15">MmPfnDatabase</a>[<a class="code" href="../../d6/d8/sysinfo_8c.html#a6">MmLowestPhysicalPage</a>];
01069     <span class="keywordflow">if</span> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount == 0) {
01070 
01071         <span class="comment">//</span>
01072         <span class="comment">// Make the reference count non-zero and point it into a</span>
01073         <span class="comment">// page directory.</span>
01074         <span class="comment">//</span>
01075 
01076         Pde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a151">MiGetPdeAddress</a> (0xb0000000);
01077         PdePage = Pde-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber;
01078         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o17">PteFrame</a> = PdePageNumber;
01079         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> = Pde;
01080         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount += 1;
01081         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount = 1;
01082         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageLocation = <a class="code" href="../../d2/d1/mm_8h.html#a345a177">ActiveAndValid</a>;
01083         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageColor =
01084                 <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a132">MI_GET_COLOR_FROM_SECONDARY</a>(GET_PAGE_COLOR_FROM_PTE (Pde));
01085     }
01086 
01087     <span class="comment">// end of temporary set to physical page zero.</span>
01088 
01089     <span class="comment">//</span>
01090     <span class="comment">// Walk through the memory descriptors and add pages to the</span>
01091     <span class="comment">// free list in the PFN database.</span>
01092     <span class="comment">//</span>
01093 
01094     NextMd = LoaderBlock-&gt;MemoryDescriptorListHead.Flink;
01095 
01096     <span class="keywordflow">while</span> (NextMd != &amp;LoaderBlock-&gt;MemoryDescriptorListHead) {
01097 
01098         MemoryDescriptor = CONTAINING_RECORD(NextMd,
01099                                              <a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html">MEMORY_ALLOCATION_DESCRIPTOR</a>,
01100                                              ListEntry);
01101 
01102         i = MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o3">PageCount</a>;
01103         NextPhysicalPage = MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o2">BasePage</a>;
01104 
01105         <span class="keywordflow">switch</span> (MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o1">MemoryType</a>) {
01106             <span class="keywordflow">case</span> <a class="code" href="../../d1/d9/arc_8h.html#a320a257">LoaderBad</a>:
01107                 <span class="keywordflow">while</span> (i != 0) {
01108                     <a class="code" href="../../d7/d5/pfnlist_8c.html#a8">MiInsertPageInList</a> (<a class="code" href="../../d4/d8/mi_8h.html#a606">MmPageLocationList</a>[<a class="code" href="../../d2/d1/mm_8h.html#a345a176">BadPageList</a>],
01109                                         NextPhysicalPage);
01110                     i -= 1;
01111                     NextPhysicalPage += 1;
01112                 }
01113                 <span class="keywordflow">break</span>;
01114 
01115             <span class="keywordflow">case</span> <a class="code" href="../../d1/d9/arc_8h.html#a320a256">LoaderFree</a>:
01116             <span class="keywordflow">case</span> <a class="code" href="../../d1/d9/arc_8h.html#a320a258">LoaderLoadedProgram</a>:
01117             <span class="keywordflow">case</span> <a class="code" href="../../d1/d9/arc_8h.html#a320a259">LoaderFirmwareTemporary</a>:
01118             <span class="keywordflow">case</span> <a class="code" href="../../d1/d9/arc_8h.html#a320a262">LoaderOsloaderStack</a>:
01119 
01120                 Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (NextPhysicalPage);
01121                 <span class="keywordflow">while</span> (i != 0) {
01122                     <span class="keywordflow">if</span> (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount == 0) {
01123 
01124                         <span class="comment">//</span>
01125                         <span class="comment">// Set the PTE address to the physical page for</span>
01126                         <span class="comment">// virtual address alignment checking.</span>
01127                         <span class="comment">//</span>
01128 
01129                         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> =
01130                                         (<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)(NextPhysicalPage &lt;&lt; <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a52">PTE_SHIFT</a>);
01131 
01132                         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageColor =
01133                 <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a132">MI_GET_COLOR_FROM_SECONDARY</a>(GET_PAGE_COLOR_FROM_PTE (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a>));
01134                         <a class="code" href="../../d7/d5/pfnlist_8c.html#a8">MiInsertPageInList</a> (<a class="code" href="../../d4/d8/mi_8h.html#a606">MmPageLocationList</a>[<a class="code" href="../../d2/d1/mm_8h.html#a345a172">FreePageList</a>],
01135                                             NextPhysicalPage);
01136                     }
01137                     Pfn1 += 1;
01138                     i -= 1;
01139                     NextPhysicalPage += 1;
01140                 }
01141                 <span class="keywordflow">break</span>;
01142 
01143             <span class="keywordflow">default</span>:
01144 
01145                 PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (<a class="code" href="../../d6/d7/halmips_8h.html#a443">KSEG0_BASE</a> |
01146                                             (NextPhysicalPage &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>));
01147                 Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (NextPhysicalPage);
01148                 <span class="keywordflow">while</span> (i != 0) {
01149 
01150                     <span class="comment">//</span>
01151                     <span class="comment">// Set page as in use.</span>
01152                     <span class="comment">//</span>
01153 
01154                     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o17">PteFrame</a> = PdePageNumber;
01155                     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> = PointerPte;
01156                     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount += 1;
01157                     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount = 1;
01158                     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageLocation = <a class="code" href="../../d2/d1/mm_8h.html#a345a177">ActiveAndValid</a>;
01159                     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageColor =
01160                 <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a132">MI_GET_COLOR_FROM_SECONDARY</a>(GET_PAGE_COLOR_FROM_PTE (PointerPte));
01161 
01162                     Pfn1 += 1;
01163                     i -= 1;
01164                     NextPhysicalPage += 1;
01165                     PointerPte += 1;
01166                 }
01167 
01168                 <span class="keywordflow">break</span>;
01169         }
01170 
01171         NextMd = MemoryDescriptor-&gt;<a class="code" href="../../d2/d8/struct__MEMORY__ALLOCATION__DESCRIPTOR.html#o0">ListEntry</a>.Flink;
01172     }
01173 
01174     <span class="comment">//</span>
01175     <span class="comment">// Indicate that the PFN database is allocated in NonPaged pool.</span>
01176     <span class="comment">//</span>
01177     <span class="keywordflow">if</span> (PfnInKseg0 == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01178 
01179         <span class="comment">//</span>
01180         <span class="comment">// The PFN database is allocated in virtual memory</span>
01181         <span class="comment">//</span>
01182         <span class="comment">// Set the start and end of allocation.</span>
01183         <span class="comment">//</span>
01184 
01185         Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(&amp;<a class="code" href="../../d2/d3/dumpctl_8c.html#a15">MmPfnDatabase</a>[<a class="code" href="../../d6/d8/sysinfo_8c.html#a6">MmLowestPhysicalPage</a>])-&gt;u.Hard.PageFrameNumber);
01186         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.StartOfAllocation = 1;
01187         Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(&amp;<a class="code" href="../../d2/d3/dumpctl_8c.html#a15">MmPfnDatabase</a>[<a class="code" href="../../d2/d3/dumpctl_8c.html#a16">MmHighestPossiblePhysicalPage</a>])-&gt;u.Hard.PageFrameNumber);
01188         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.EndOfAllocation = 1;
01189 
01190     } <span class="keywordflow">else</span> {
01191 
01192         <span class="comment">//</span>
01193         <span class="comment">// The PFN database is allocated in KSEG0.</span>
01194         <span class="comment">//</span>
01195         <span class="comment">// Mark all PFN entries for the PFN pages in use.</span>
01196         <span class="comment">//</span>
01197 
01198         PageNumber = ((ULONG)<a class="code" href="../../d2/d3/dumpctl_8c.html#a15">MmPfnDatabase</a> - <a class="code" href="../../d6/d7/halmips_8h.html#a443">KSEG0_BASE</a>) &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
01199         Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(PageNumber);
01200         <span class="keywordflow">do</span> {
01201             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> = (<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)(PageNumber &lt;&lt; <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a52">PTE_SHIFT</a>);
01202             Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageColor =
01203                 <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a132">MI_GET_COLOR_FROM_SECONDARY</a>(GET_PAGE_COLOR_FROM_PTE (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a>));
01204             Pfn1 += 1;
01205             PfnAllocation -= 1;
01206         } <span class="keywordflow">while</span> (PfnAllocation != 0);
01207 
01208         <span class="comment">//</span>
01209         <span class="comment">// Scan the PFN database backward for pages that are completely zero.</span>
01210         <span class="comment">// These pages are unused and can be added to the free list</span>
01211         <span class="comment">//</span>
01212 
01213         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a29">MmDynamicPfn</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01214             BottomPfn = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(<a class="code" href="../../d6/d8/sysinfo_8c.html#a7">MmHighestPhysicalPage</a>);
01215             <span class="keywordflow">do</span> {
01216     
01217                 <span class="comment">//</span>
01218                 <span class="comment">// Compute the address of the start of the page that is next</span>
01219                 <span class="comment">// lower in memory and scan backwards until that page address</span>
01220                 <span class="comment">// is reached or just crossed.</span>
01221                 <span class="comment">//</span>
01222     
01223                 <span class="keywordflow">if</span> (((ULONG)BottomPfn &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) != 0) {
01224                     BasePfn = (<a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a>)((ULONG)BottomPfn &amp; ~(<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1));
01225                     TopPfn = BottomPfn + 1;
01226     
01227                 } <span class="keywordflow">else</span> {
01228                     BasePfn = (<a class="code" href="../../d4/d3/struct__MMPFN.html">PMMPFN</a>)((ULONG)BottomPfn - <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
01229                     TopPfn = BottomPfn;
01230                 }
01231     
01232                 <span class="keywordflow">while</span> (BottomPfn &gt; BasePfn) {
01233                     BottomPfn -= 1;
01234                 }
01235     
01236                 <span class="comment">//</span>
01237                 <span class="comment">// If the entire range over which the PFN entries span is</span>
01238                 <span class="comment">// completely zero and the PFN entry that maps the page is</span>
01239                 <span class="comment">// not in the range, then add the page to the appropriate</span>
01240                 <span class="comment">// free list.</span>
01241                 <span class="comment">//</span>
01242     
01243                 Range = (ULONG)TopPfn - (ULONG)BottomPfn;
01244                 <span class="keywordflow">if</span> (<a class="code" href="../../d2/d7/string_8c.html#a17">RtlCompareMemoryUlong</a>((PVOID)BottomPfn, Range, 0) == Range) {
01245     
01246                     <span class="comment">//</span>
01247                     <span class="comment">// Set the PTE address to the physical page for</span>
01248                     <span class="comment">// virtual address alignment checking.</span>
01249                     <span class="comment">//</span>
01250     
01251                     PageNumber = ((ULONG)BasePfn - <a class="code" href="../../d6/d7/halmips_8h.html#a443">KSEG0_BASE</a>) &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
01252                     Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(PageNumber);
01253     
01254                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount == 0);
01255     
01256                     PfnAllocation += 1;
01257     
01258                     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a> = (<a class="code" href="../../d2/d4/struct__MMPTE.html">PMMPTE</a>)(PageNumber &lt;&lt; <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a52">PTE_SHIFT</a>);
01259                     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageColor =
01260                         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a132">MI_GET_COLOR_FROM_SECONDARY</a>(GET_PAGE_COLOR_FROM_PTE (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o6">PteAddress</a>));
01261     
01262                     <a class="code" href="../../d7/d5/pfnlist_8c.html#a8">MiInsertPageInList</a>(<a class="code" href="../../d4/d8/mi_8h.html#a606">MmPageLocationList</a>[<a class="code" href="../../d2/d1/mm_8h.html#a345a172">FreePageList</a>],
01263                                        PageNumber);
01264                 }
01265 
01266             } <span class="keywordflow">while</span> (BottomPfn &gt; <a class="code" href="../../d2/d3/dumpctl_8c.html#a15">MmPfnDatabase</a>);
01267         }
01268     }
01269 
01270     <span class="comment">//</span>
01271     <span class="comment">// Indicate that nonpaged pool must succeed is allocated in</span>
01272     <span class="comment">// nonpaged pool.</span>
01273     <span class="comment">//</span>
01274 
01275     i = <a class="code" href="../../d4/d8/mi_8h.html#a627">MmSizeOfNonPagedMustSucceed</a>;
01276     Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a>(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a179">MI_CONVERT_PHYSICAL_TO_PFN</a> (<a class="code" href="../../d4/d8/mi_8h.html#a649">MmNonPagedMustSucceed</a>));
01277 
01278     <span class="keywordflow">while</span> ((LONG)i &gt; 0) {
01279         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.StartOfAllocation = 1;
01280         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.EndOfAllocation = 1;
01281         i -= <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
01282         Pfn1 += 1;
01283     }
01284 
01285     <a class="code" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock</a> (&amp;<a class="code" href="../../d4/d4/alpha_2splocks_8c.html#a15">MmSystemSpaceLock</a>);
01286     <a class="code" href="../../d4/d9/ke_8h.html#a354">KeInitializeSpinLock</a> (&amp;<a class="code" href="../../d7/d2/alpha_2initkr_8c.html#a2">MmPfnLock</a>);
01287 
01288     <span class="comment">//</span>
01289     <span class="comment">// Initialize the nonpaged available PTEs for mapping I/O space</span>
01290     <span class="comment">// and kernel stacks.</span>
01291     <span class="comment">//</span>
01292 
01293     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (<a class="code" href="../../d8/d5/kddata_8c.html#a22">MmNonPagedSystemStart</a>);
01294 
01295     <span class="comment">//</span>
01296     <span class="comment">// Since the initial nonpaged pool must always reside in KSEG0 (many changes</span>
01297     <span class="comment">// would be needed in this routine otherwise), reallocate the PTEs for it</span>
01298     <span class="comment">// to the pagable system PTE pool now.</span>
01299     <span class="comment">//</span>
01300 
01301     <a class="code" href="../../d8/d0/cmdat3_8c.html#a23">MmNumberOfSystemPtes</a> = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(<a class="code" href="../../d1/d6/allocpag_8c.html#a7">MmNonPagedPoolExpansionStart</a>) - PointerPte - 1;
01302 
01303     <a class="code" href="../../d0/d9/sysptes_8c.html#a27">MiInitializeSystemPtes</a> (PointerPte, <a class="code" href="../../d8/d0/cmdat3_8c.html#a23">MmNumberOfSystemPtes</a>, <a class="code" href="../../d4/d8/mi_8h.html#a1003a769">SystemPteSpace</a>);
01304 
01305     <span class="comment">//</span>
01306     <span class="comment">// Initialize the nonpaged pool.</span>
01307     <span class="comment">//</span>
01308 
01309     <a class="code" href="../../d5/d8/ex_8h.html#a215">InitializePool</a> (<a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, 0);
01310 
01311     <span class="comment">//</span>
01312     <span class="comment">// Initialize memory management structures for this process.</span>
01313     <span class="comment">//</span>
01314 
01315     <span class="comment">//</span>
01316     <span class="comment">// Build working set list.  System initialization has created</span>
01317     <span class="comment">// a PTE for hyperspace.</span>
01318     <span class="comment">//</span>
01319     <span class="comment">// Note, we can't remove a zeroed page as hyper space does not</span>
01320     <span class="comment">// exist and we map non-zeroed pages into hyper space to zero.</span>
01321     <span class="comment">//</span>
01322 
01323     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a151">MiGetPdeAddress</a>(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a63">HYPER_SPACE</a>);
01324 
01325     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (PointerPte-&gt;u.Hard.Valid == 1);
01326     PointerPte-&gt;u.Hard.Global = 0;
01327     PointerPte-&gt;u.Hard.Write = 1;
01328     PageFrameIndex = PointerPte-&gt;u.Hard.PageFrameNumber;
01329 
01330     <span class="comment">//</span>
01331     <span class="comment">// Point to the page table page we just created and zero it.</span>
01332     <span class="comment">//</span>
01333 
01334     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a63">HYPER_SPACE</a>);
01335     RtlZeroMemory ((PVOID)PointerPte, <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
01336 
01337     <span class="comment">//</span>
01338     <span class="comment">// Hyper space now exists, set the necessary variables.</span>
01339     <span class="comment">//</span>
01340 
01341     <a class="code" href="../../d4/d8/mi_8h.html#a615">MmFirstReservedMappingPte</a> = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a64">FIRST_MAPPING_PTE</a>);
01342     <a class="code" href="../../d4/d8/mi_8h.html#a616">MmLastReservedMappingPte</a> = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a66">LAST_MAPPING_PTE</a>);
01343 
01344     <a class="code" href="../../d4/d8/mi_8h.html#a672">MmWorkingSetList</a> = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a69">WORKING_SET_LIST</a>;
01345     <a class="code" href="../../d4/d8/mi_8h.html#a673">MmWsle</a> = (<a class="code" href="../../d1/d8/struct__MMWSLE.html">PMMWSLE</a>)((PUCHAR)<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a69">WORKING_SET_LIST</a> + <span class="keyword">sizeof</span>(<a class="code" href="../../d0/d8/struct__MMWSL.html">MMWSL</a>));
01346 
01347     <span class="comment">//</span>
01348     <span class="comment">// Initialize this process's memory management structures including</span>
01349     <span class="comment">// the working set list.</span>
01350     <span class="comment">//</span>
01351 
01352     <span class="comment">//</span>
01353     <span class="comment">// The PFN element for the page directory has already been initialized,</span>
01354     <span class="comment">// zero the reference count and the share count so they won't be</span>
01355     <span class="comment">// wrong.</span>
01356     <span class="comment">//</span>
01357 
01358     Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PdePageNumber);
01359 
01360     <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
01361 
01362     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount = 0;
01363     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount = 0;
01364 
01365     <span class="comment">//</span>
01366     <span class="comment">// The PFN element for the PDE which maps hyperspace has already</span>
01367     <span class="comment">// been initialized, zero the reference count and the share count</span>
01368     <span class="comment">// so they won't be wrong.</span>
01369     <span class="comment">//</span>
01370 
01371     Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PageFrameIndex);
01372     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount = 0;
01373     Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount = 0;
01374 
01375     CurrentProcess = <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a> ();
01376 
01377     <span class="comment">//</span>
01378     <span class="comment">// Get a page for the working set list and map it into the Page</span>
01379     <span class="comment">// directory at the page after hyperspace.</span>
01380     <span class="comment">//</span>
01381 
01382     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a63">HYPER_SPACE</a>);
01383     PageFrameIndex = <a class="code" href="../../d7/d5/pfnlist_8c.html#a15">MiRemoveAnyPage</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a124">MI_GET_PAGE_COLOR_FROM_PTE</a>(PointerPte));
01384 
01385     CurrentProcess-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o23">WorkingSetPage</a> = PageFrameIndex;
01386 
01387     TempPte.<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber = PageFrameIndex;
01388     PointerPde = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a151">MiGetPdeAddress</a> (<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a63">HYPER_SPACE</a>) + 1;
01389 
01390     <span class="comment">//</span>
01391     <span class="comment">// Assert that the double mapped pages have the same alignment.</span>
01392     <span class="comment">//</span>
01393 
01394     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((PointerPte-&gt;u.Long &amp; (0xF &lt;&lt; <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a52">PTE_SHIFT</a>)) ==
01395             (PointerPde-&gt;u.Long &amp; (0xF &lt;&lt; <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a52">PTE_SHIFT</a>)));
01396 
01397     *PointerPde = TempPte;
01398     PointerPde-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.Global = 0;
01399 
01400     PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a161">MiGetVirtualAddressMappedByPte</a> (PointerPde);
01401 
01402     KeFillEntryTb ((PHARDWARE_PTE)PointerPde,
01403                     PointerPte,
01404                     <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
01405 
01406     RtlZeroMemory ((PVOID)PointerPte, <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>);
01407 
01408     TempPte = *PointerPde;
01409     TempPte.u.Hard.Valid = 0;
01410     TempPte.u.Hard.Global = 0;
01411 
01412     <a class="code" href="../../d0/d6/ppc_2flushtb_8c.html#a2">KeFlushSingleTb</a> (PointerPte,
01413                      <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
01414                      <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01415                      (PHARDWARE_PTE)PointerPde,
01416                      TempPte.u.Hard);
01417 
01418     <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
01419 
01420     <span class="comment">//</span>
01421     <span class="comment">// Initialize hyperspace for this process.</span>
01422     <span class="comment">//</span>
01423 
01424     PointerPte = <a class="code" href="../../d4/d8/mi_8h.html#a615">MmFirstReservedMappingPte</a>;
01425     PointerPte-&gt;<a class="code" href="../../d2/d4/struct__MMPTE.html#o8">u</a>.Hard.PageFrameNumber = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a65">NUMBER_OF_MAPPING_PTES</a>;
01426 
01427     CurrentProcess-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o16">Vm</a>.<a class="code" href="../../d3/d6/struct__MMSUPPORT.html#o6">MaximumWorkingSetSize</a> = <a class="code" href="../../d4/d8/mi_8h.html#a740">MmSystemProcessWorkingSetMax</a>;
01428     CurrentProcess-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o16">Vm</a>.<a class="code" href="../../d3/d6/struct__MMSUPPORT.html#o5">MinimumWorkingSetSize</a> = <a class="code" href="../../d4/d8/mi_8h.html#a739">MmSystemProcessWorkingSetMin</a>;
01429 
01430     <a class="code" href="../../d4/d5/procsup_8c.html#a30">MmInitializeProcessAddressSpace</a> (CurrentProcess,
01431                                 (<a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a>)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
01432                                 (PVOID)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
01433                                 (PVOID)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
01434 
01435     *PointerPde = <a class="code" href="../../d4/d2/datalpha_8c.html#a1">ZeroKernelPte</a>;
01436 
01437     <span class="comment">//</span>
01438     <span class="comment">// Check to see if moving the secondary page structures to the end</span>
01439     <span class="comment">// of the PFN database is a waste of memory.  And if so, copy it</span>
01440     <span class="comment">// to paged pool.</span>
01441     <span class="comment">//</span>
01442     <span class="comment">// If the PFN database ends on a page aligned boundary and the</span>
01443     <span class="comment">// size of the two arrays is less than a page, free the page</span>
01444     <span class="comment">// and allocate nonpagedpool for this.</span>
01445     <span class="comment">//</span>
01446 
01447     <span class="keywordflow">if</span> ((((ULONG)<a class="code" href="../../d4/d2/datalpha_8c.html#a20">MmFreePagesByColor</a>[0] &amp; (<a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1)) == 0) &amp;&amp;
01448        ((<a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a> * 2 * <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d1/struct__MMCOLOR__TABLES.html">MMCOLOR_TABLES</a>)) &lt; <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>)) {
01449 
01450         <a class="code" href="../../d4/d1/struct__MMCOLOR__TABLES.html">PMMCOLOR_TABLES</a> <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a35">c</a>;
01451 
01452         <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a35">c</a> = <a class="code" href="../../d4/d2/datalpha_8c.html#a20">MmFreePagesByColor</a>[0];
01453 
01454         <a class="code" href="../../d4/d2/datalpha_8c.html#a20">MmFreePagesByColor</a>[0] = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a> (<a class="code" href="../../d5/d8/ex_8h.html#a329a175">NonPagedPoolMustSucceed</a>,
01455                                <a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a> * 2 * <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d1/struct__MMCOLOR__TABLES.html">MMCOLOR_TABLES</a>),
01456                                '  mM');
01457 
01458         <a class="code" href="../../d4/d2/datalpha_8c.html#a20">MmFreePagesByColor</a>[1] = &amp;<a class="code" href="../../d4/d2/datalpha_8c.html#a20">MmFreePagesByColor</a>[0][<a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a>];
01459 
01460         RtlMoveMemory (<a class="code" href="../../d4/d2/datalpha_8c.html#a20">MmFreePagesByColor</a>[0],
01461                        <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a35">c</a>,
01462                        <a class="code" href="../../d8/d0/cmdat3_8c.html#a25">MmSecondaryColors</a> * 2 * <span class="keyword">sizeof</span>(<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a202">MMCOLOR_TABLES</a>));
01463 
01464         <span class="comment">//</span>
01465         <span class="comment">// Free the page.</span>
01466         <span class="comment">//</span>
01467 
01468         <span class="keywordflow">if</span> (!<a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a178">MI_IS_PHYSICAL_ADDRESS</a>(<a class="code" href="../../d2/d0/nt6_2user32_8def.html#a35">c</a>)) {
01469             PointerPte = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a153">MiGetPteAddress</a>(<a class="code" href="../../d2/d0/nt6_2user32_8def.html#a35">c</a>);
01470             PageFrameIndex = PointerPte-&gt;u.Hard.PageFrameNumber;
01471             *PointerPte = <a class="code" href="../../d4/d2/datalpha_8c.html#a1">ZeroKernelPte</a>;
01472         } <span class="keywordflow">else</span> {
01473             PageFrameIndex = <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a179">MI_CONVERT_PHYSICAL_TO_PFN</a> (<a class="code" href="../../d2/d0/nt6_2user32_8def.html#a35">c</a>);
01474         }
01475 
01476         <a class="code" href="../../d4/d8/mi_8h.html#a127">LOCK_PFN</a> (OldIrql);
01477 
01478         Pfn1 = <a class="code" href="../../d4/d8/mi_8h.html#a111">MI_PFN_ELEMENT</a> (PageFrameIndex);
01479         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> ((Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount &lt;= 1) &amp;&amp; (Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount &lt;= 1));
01480         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o10">u2</a>.ShareCount = 0;
01481         Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e2.ReferenceCount = 0;
01482         <a class="code" href="../../d8/d8/alpha_2mialpha_8h.html#a120">MI_SET_PFN_DELETED</a> (Pfn1);
01483 <span class="preprocessor">#if DBG</span>
01484 <span class="preprocessor"></span>        Pfn1-&gt;<a class="code" href="../../d4/d3/struct__MMPFN.html#o15">u3</a>.e1.PageLocation = <a class="code" href="../../d2/d1/mm_8h.html#a345a173">StandbyPageList</a>;
01485 <span class="preprocessor">#endif //DBG</span>
01486 <span class="preprocessor"></span>        <a class="code" href="../../d7/d5/pfnlist_8c.html#a8">MiInsertPageInList</a> (<a class="code" href="../../d4/d8/mi_8h.html#a606">MmPageLocationList</a>[<a class="code" href="../../d2/d1/mm_8h.html#a345a172">FreePageList</a>], PageFrameIndex);
01487         <a class="code" href="../../d4/d8/mi_8h.html#a129">UNLOCK_PFN</a> (OldIrql);
01488     }
01489 
01490     <span class="keywordflow">return</span>;
01491 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:21 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
