<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: ntfs_rec.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>ntfs_rec.c</h1><a href="../../d2/d8/ntfs__rec_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1992  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    ntfs_rec.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module contains the mini-file system recognizer for NTFS.</span>
00012 <span class="comment"></span>
00013 <span class="comment">Author:</span>
00014 <span class="comment"></span>
00015 <span class="comment">    Darryl E. Havens (darrylh) 8-dec-1992</span>
00016 <span class="comment"></span>
00017 <span class="comment">Environment:</span>
00018 <span class="comment"></span>
00019 <span class="comment">    Kernel mode, local to I/O system</span>
00020 <span class="comment"></span>
00021 <span class="comment">Revision History:</span>
00022 <span class="comment"></span>
00023 <span class="comment"></span>
00024 <span class="comment">--*/</span>
00025 
00026 <span class="preprocessor">#include "<a class="code" href="../../d7/d7/fs__rec_8h.html">fs_rec.h</a>"</span>
00027 <span class="preprocessor">#include "<a class="code" href="../../d3/d8/ntfs__rec_8h.html">ntfs_rec.h</a>"</span>
00028 
00029 <span class="comment">//</span>
00030 <span class="comment">//  The local debug trace level</span>
00031 <span class="comment">//</span>
00032 
<a name="l00033"></a><a class="code" href="../../d2/d8/ntfs__rec_8c.html#a0">00033</a> <span class="preprocessor">#define Dbg                              (FSREC_DEBUG_LEVEL_NTFS)</span>
00034 <span class="preprocessor"></span>
00035 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00036 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,NtfsRecFsControl)</span>
00037 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,IsNtfsVolume)</span>
00038 <span class="preprocessor"></span><span class="preprocessor">#endif // ALLOC_PRAGMA</span>
00039 <span class="preprocessor"></span>
00040 
00041 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00042"></a><a class="code" href="../../d2/d8/ntfs__rec_8c.html#a1">00042</a> <a class="code" href="../../d2/d8/ntfs__rec_8c.html#a1">NtfsRecFsControl</a>(
00043     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
00044     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
00045     )
00046 
00047 <span class="comment">/*++</span>
00048 <span class="comment"></span>
00049 <span class="comment">Routine Description:</span>
00050 <span class="comment"></span>
00051 <span class="comment">    This function performs the mount and driver reload functions for this mini-</span>
00052 <span class="comment">    file system recognizer driver.</span>
00053 <span class="comment"></span>
00054 <span class="comment">Arguments:</span>
00055 <span class="comment"></span>
00056 <span class="comment">    DeviceObject - Pointer to this driver's device object.</span>
00057 <span class="comment"></span>
00058 <span class="comment">    Irp - Pointer to the I/O Request Packet (IRP) representing the function to</span>
00059 <span class="comment">        be performed.</span>
00060 <span class="comment"></span>
00061 <span class="comment">Return Value:</span>
00062 <span class="comment"></span>
00063 <span class="comment">    The function value is the final status of the operation.</span>
00064 <span class="comment"></span>
00065 <span class="comment"></span>
00066 <span class="comment">--*/</span>
00067 
00068 {
00069     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
00070     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
00071     <a class="code" href="../../d8/d3/struct__DEVICE__EXTENSION.html">PDEVICE_EXTENSION</a> deviceExtension;
00072     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> targetDevice;
00073     <a class="code" href="../../d9/d7/struct__PACKED__BOOT__SECTOR.html">PPACKED_BOOT_SECTOR</a> buffer;
00074     LARGE_INTEGER byteOffset;
00075     LARGE_INTEGER secondByteOffset;
00076     LARGE_INTEGER lastByteOffset;
00077     UNICODE_STRING driverName;
00078     ULONG bytesPerSector;
00079     LARGE_INTEGER numberOfSectors;
00080 
00081     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00082 
00083     <span class="comment">//</span>
00084     <span class="comment">// Begin by determining what function that is to be performed.</span>
00085     <span class="comment">//</span>
00086 
00087     deviceExtension = (<a class="code" href="../../d8/d3/struct__DEVICE__EXTENSION.html">PDEVICE_EXTENSION</a>) DeviceObject-&gt;DeviceExtension;
00088     irpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
00089 
00090     <span class="keywordflow">switch</span> ( irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o1">MinorFunction</a> ) {
00091 
00092     <span class="keywordflow">case</span> <a class="code" href="../../d0/d5/io_8h.html#a47">IRP_MN_MOUNT_VOLUME</a>:
00093 
00094         <span class="comment">//</span>
00095         <span class="comment">// Attempt to mount a volume:  Determine whether or not the volume in</span>
00096         <span class="comment">// question is an NTFS volume and, if so, let the I/O system know that it</span>
00097         <span class="comment">// is by returning a special status code so that this driver can get</span>
00098         <span class="comment">// called back to load the NTFS file system.</span>
00099         <span class="comment">//</span>
00100 
00101         status = STATUS_UNRECOGNIZED_VOLUME;
00102         
00103         <span class="comment">//</span>
00104         <span class="comment">// Attempt to determine whether or not the target volume being mounted</span>
00105         <span class="comment">// is an NTFS volume.</span>
00106         <span class="comment">//</span>
00107 
00108         targetDevice = irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.MountVolume.DeviceObject;
00109 
00110         <span class="keywordflow">if</span> (<a class="code" href="../../d7/d7/fs__rec_8h.html#a30">FsRecGetDeviceSectorSize</a>( targetDevice,
00111                                       &amp;bytesPerSector ) &amp;&amp;
00112             <a class="code" href="../../d7/d7/fs__rec_8h.html#a31">FsRecGetDeviceSectors</a>( targetDevice,
00113                                    bytesPerSector,
00114                                    &amp;numberOfSectors )) {
00115 
00116             byteOffset.QuadPart = 0;
00117             buffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00118             secondByteOffset.QuadPart = numberOfSectors.QuadPart &gt;&gt; 1;
00119             secondByteOffset.QuadPart *= (LONG) bytesPerSector;
00120             lastByteOffset.QuadPart = (numberOfSectors.QuadPart - 1) * (LONG) bytesPerSector;
00121 
00122             <span class="keywordflow">if</span> (<a class="code" href="../../d7/d7/fs__rec_8h.html#a32">FsRecReadBlock</a>( targetDevice,
00123                                 &amp;byteOffset,
00124                                 <span class="keyword">sizeof</span>( <a class="code" href="../../d9/d7/struct__PACKED__BOOT__SECTOR.html">PACKED_BOOT_SECTOR</a> ),
00125                                 bytesPerSector,
00126                                 (PVOID *)&amp;buffer,
00127                                 <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) &amp;&amp;
00128                 <a class="code" href="../../d3/d8/ntfs__rec_8h.html#a12">IsNtfsVolume</a>( buffer, bytesPerSector, &amp;numberOfSectors )) {
00129                     
00130                 status = STATUS_FS_DRIVER_REQUIRED;
00131             
00132             } <span class="keywordflow">else</span> {
00133 
00134                 <span class="keywordflow">if</span> (<a class="code" href="../../d7/d7/fs__rec_8h.html#a32">FsRecReadBlock</a>( targetDevice,
00135                                     &amp;secondByteOffset,
00136                                     <span class="keyword">sizeof</span>( <a class="code" href="../../d6/d1/fat__rec_8h.html#a13">PACKED_BOOT_SECTOR</a> ),
00137                                     bytesPerSector,
00138                                     (PVOID *)&amp;buffer,
00139                                     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) &amp;&amp;
00140                     <a class="code" href="../../d3/d8/ntfs__rec_8h.html#a12">IsNtfsVolume</a>( buffer, bytesPerSector, &amp;numberOfSectors )) {
00141 
00142                     status = STATUS_FS_DRIVER_REQUIRED;
00143 
00144                 } <span class="keywordflow">else</span> {
00145                     
00146                     <span class="keywordflow">if</span> (<a class="code" href="../../d7/d7/fs__rec_8h.html#a32">FsRecReadBlock</a>( targetDevice,
00147                                         &amp;lastByteOffset,
00148                                         <span class="keyword">sizeof</span>( <a class="code" href="../../d6/d1/fat__rec_8h.html#a13">PACKED_BOOT_SECTOR</a> ),
00149                                         bytesPerSector,
00150                                         (PVOID *)&amp;buffer,
00151                                         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) &amp;&amp;
00152                         <a class="code" href="../../d3/d8/ntfs__rec_8h.html#a12">IsNtfsVolume</a>( buffer, bytesPerSector, &amp;numberOfSectors )) {
00153                         
00154                         status = STATUS_FS_DRIVER_REQUIRED;
00155                     }
00156                 }
00157             }
00158             
00159             <span class="keywordflow">if</span> (buffer != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00160                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( buffer );
00161             }
00162         }
00163 
00164         <span class="keywordflow">break</span>;
00165 
00166     <span class="keywordflow">case</span> <a class="code" href="../../d0/d5/io_8h.html#a49">IRP_MN_LOAD_FILE_SYSTEM</a>:
00167 
00168         status = <a class="code" href="../../d7/d7/fs__rec_8h.html#a29">FsRecLoadFileSystem</a>( DeviceObject,
00169                                       <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Ntfs"</span> );
00170         <span class="keywordflow">break</span>;
00171 
00172     <span class="keywordflow">default</span>:
00173         status = STATUS_INVALID_DEVICE_REQUEST;
00174 
00175     }
00176 
00177     <span class="comment">//</span>
00178     <span class="comment">// Finally, complete the request and return the same status code to the</span>
00179     <span class="comment">// caller.</span>
00180     <span class="comment">//</span>
00181 
00182     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status = status;
00183     <a class="code" href="../../d0/d5/io_8h.html#a224">IoCompleteRequest</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, <a class="code" href="../../d7/d8/exboosts_8h.html#a3">IO_NO_INCREMENT</a> );
00184 
00185     <span class="keywordflow">return</span> status;
00186 }
00187 
00188 
00189 BOOLEAN
<a name="l00190"></a><a class="code" href="../../d3/d8/ntfs__rec_8h.html#a12">00190</a> <a class="code" href="../../d3/d8/ntfs__rec_8h.html#a12">IsNtfsVolume</a>(
00191     IN <a class="code" href="../../d9/d7/struct__PACKED__BOOT__SECTOR.html">PPACKED_BOOT_SECTOR</a> BootSector,
00192     IN ULONG BytesPerSector,
00193     IN PLARGE_INTEGER NumberOfSectors
00194     )
00195 
00196 <span class="comment">/*++</span>
00197 <span class="comment"></span>
00198 <span class="comment">Routine Description:</span>
00199 <span class="comment"></span>
00200 <span class="comment">    This routine looks at the buffer passed in which contains the NTFS boot</span>
00201 <span class="comment">    sector and determines whether or not it represents an NTFS volume.</span>
00202 <span class="comment"></span>
00203 <span class="comment">Arguments:</span>
00204 <span class="comment"></span>
00205 <span class="comment">    BootSector - Pointer to buffer containing a potential NTFS boot sector.</span>
00206 <span class="comment"></span>
00207 <span class="comment">    BytesPerSector - Supplies the number of bytes per sector for the drive.</span>
00208 <span class="comment"></span>
00209 <span class="comment">    NumberOfSectors - Supplies the number of sectors on the partition.</span>
00210 <span class="comment"></span>
00211 <span class="comment">Return Value:</span>
00212 <span class="comment"></span>
00213 <span class="comment">    The function returns TRUE if the buffer contains a recognizable NTFS boot</span>
00214 <span class="comment">    sector, otherwise it returns FALSE.</span>
00215 <span class="comment"></span>
00216 <span class="comment">--*/</span>
00217 
00218 {
00219     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00220 
00221     <span class="comment">//</span>
00222     <span class="comment">// Now perform all the checks, starting with the Name and Checksum.</span>
00223     <span class="comment">// The remaining checks should be obvious, including some fields which</span>
00224     <span class="comment">// must be 0 and other fields which must be a small power of 2.</span>
00225     <span class="comment">//</span>
00226 
00227     <span class="keywordflow">if</span> (BootSector-&gt;Oem[0] == <span class="charliteral">'N'</span> &amp;&amp;
00228         BootSector-&gt;Oem[1] == <span class="charliteral">'T'</span> &amp;&amp;
00229         BootSector-&gt;Oem[2] == <span class="charliteral">'F'</span> &amp;&amp;
00230         BootSector-&gt;Oem[3] == <span class="charliteral">'S'</span> &amp;&amp;
00231         BootSector-&gt;Oem[4] == <span class="charliteral">' '</span> &amp;&amp;
00232         BootSector-&gt;Oem[5] == <span class="charliteral">' '</span> &amp;&amp;
00233         BootSector-&gt;Oem[6] == <span class="charliteral">' '</span> &amp;&amp;
00234         BootSector-&gt;Oem[7] == <span class="charliteral">' '</span>
00235 
00236             &amp;&amp;
00237 
00238         <span class="comment">//</span>
00239         <span class="comment">// Check number of bytes per sector.  The low order byte of this</span>
00240         <span class="comment">// number must be zero (smallest sector size = 0x100) and the</span>
00241         <span class="comment">// high order byte shifted must equal the bytes per sector gotten</span>
00242         <span class="comment">// from the device and stored in the Vcb.  And just to be sure,</span>
00243         <span class="comment">// sector size must be less than page size.</span>
00244         <span class="comment">//</span>
00245 
00246         BootSector-&gt;PackedBpb.BytesPerSector[0] == 0
00247 
00248             &amp;&amp;
00249 
00250         ((ULONG) (BootSector-&gt;PackedBpb.BytesPerSector[1] &lt;&lt; 8) == BytesPerSector)
00251 
00252             &amp;&amp;
00253 
00254         BootSector-&gt;PackedBpb.BytesPerSector[1] &lt;&lt; 8 &lt;= <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>
00255 
00256             &amp;&amp;
00257 
00258         <span class="comment">//</span>
00259         <span class="comment">//  Sectors per cluster must be a power of 2.</span>
00260         <span class="comment">//</span>
00261 
00262         (BootSector-&gt;PackedBpb.SectorsPerCluster[0] == 0x1 ||
00263          BootSector-&gt;PackedBpb.SectorsPerCluster[0] == 0x2 ||
00264          BootSector-&gt;PackedBpb.SectorsPerCluster[0] == 0x4 ||
00265          BootSector-&gt;PackedBpb.SectorsPerCluster[0] == 0x8 ||
00266          BootSector-&gt;PackedBpb.SectorsPerCluster[0] == 0x10 ||
00267          BootSector-&gt;PackedBpb.SectorsPerCluster[0] == 0x20 ||
00268          BootSector-&gt;PackedBpb.SectorsPerCluster[0] == 0x40 ||
00269          BootSector-&gt;PackedBpb.SectorsPerCluster[0] == 0x80)
00270 
00271             &amp;&amp;
00272 
00273         <span class="comment">//</span>
00274         <span class="comment">//  These fields must all be zero.  For both Fat and HPFS, some of</span>
00275         <span class="comment">//  these fields must be nonzero.</span>
00276         <span class="comment">//</span>
00277 
00278         BootSector-&gt;PackedBpb.ReservedSectors[0] == 0 &amp;&amp;
00279         BootSector-&gt;PackedBpb.ReservedSectors[1] == 0 &amp;&amp;
00280         BootSector-&gt;PackedBpb.Fats[0] == 0 &amp;&amp;
00281         BootSector-&gt;PackedBpb.RootEntries[0] == 0 &amp;&amp;
00282         BootSector-&gt;PackedBpb.RootEntries[1] == 0 &amp;&amp;
00283         BootSector-&gt;PackedBpb.Sectors[0] == 0 &amp;&amp;
00284         BootSector-&gt;PackedBpb.Sectors[1] == 0 &amp;&amp;
00285         BootSector-&gt;PackedBpb.SectorsPerFat[0] == 0 &amp;&amp;
00286         BootSector-&gt;PackedBpb.SectorsPerFat[1] == 0 &amp;&amp;
00287         BootSector-&gt;PackedBpb.LargeSectors[0] == 0 &amp;&amp;
00288         BootSector-&gt;PackedBpb.LargeSectors[1] == 0 &amp;&amp;
00289         BootSector-&gt;PackedBpb.LargeSectors[2] == 0 &amp;&amp;
00290         BootSector-&gt;PackedBpb.LargeSectors[3] == 0
00291 
00292             &amp;&amp;
00293 
00294         <span class="comment">//</span>
00295         <span class="comment">//  Number of Sectors cannot be greater than the number of sectors</span>
00296         <span class="comment">//  on the partition.</span>
00297         <span class="comment">//</span>
00298 
00299         !( BootSector-&gt;NumberSectors.QuadPart &gt; NumberOfSectors-&gt;QuadPart )
00300 
00301             &amp;&amp;
00302 
00303         <span class="comment">//</span>
00304         <span class="comment">//  Check that both Lcn values are for sectors within the partition.</span>
00305         <span class="comment">//</span>
00306 
00307         !( BootSector-&gt;MftStartLcn.QuadPart *
00308                     BootSector-&gt;PackedBpb.SectorsPerCluster[0] &gt;
00309                 NumberOfSectors-&gt;QuadPart )
00310 
00311             &amp;&amp;
00312 
00313         !( BootSector-&gt;Mft2StartLcn.QuadPart *
00314                     BootSector-&gt;PackedBpb.SectorsPerCluster[0] &gt;
00315                 NumberOfSectors-&gt;QuadPart )
00316 
00317             &amp;&amp;
00318 
00319         <span class="comment">//</span>
00320         <span class="comment">//  Clusters per file record segment and default clusters for Index</span>
00321         <span class="comment">//  Allocation Buffers must be a power of 2.  A negative number indicates</span>
00322         <span class="comment">//  a shift value to get the actual size of the structure.</span>
00323         <span class="comment">//</span>
00324 
00325         ((BootSector-&gt;ClustersPerFileRecordSegment &gt;= -31 &amp;&amp;
00326           BootSector-&gt;ClustersPerFileRecordSegment &lt;= -9) ||
00327          BootSector-&gt;ClustersPerFileRecordSegment == 0x1 ||
00328          BootSector-&gt;ClustersPerFileRecordSegment == 0x2 ||
00329          BootSector-&gt;ClustersPerFileRecordSegment == 0x4 ||
00330          BootSector-&gt;ClustersPerFileRecordSegment == 0x8 ||
00331          BootSector-&gt;ClustersPerFileRecordSegment == 0x10 ||
00332          BootSector-&gt;ClustersPerFileRecordSegment == 0x20 ||
00333          BootSector-&gt;ClustersPerFileRecordSegment == 0x40)
00334 
00335             &amp;&amp;
00336 
00337         ((BootSector-&gt;DefaultClustersPerIndexAllocationBuffer &gt;= -31 &amp;&amp;
00338           BootSector-&gt;DefaultClustersPerIndexAllocationBuffer &lt;= -9) ||
00339          BootSector-&gt;DefaultClustersPerIndexAllocationBuffer == 0x1 ||
00340          BootSector-&gt;DefaultClustersPerIndexAllocationBuffer == 0x2 ||
00341          BootSector-&gt;DefaultClustersPerIndexAllocationBuffer == 0x4 ||
00342          BootSector-&gt;DefaultClustersPerIndexAllocationBuffer == 0x8 ||
00343          BootSector-&gt;DefaultClustersPerIndexAllocationBuffer == 0x10 ||
00344          BootSector-&gt;DefaultClustersPerIndexAllocationBuffer == 0x20 ||
00345          BootSector-&gt;DefaultClustersPerIndexAllocationBuffer == 0x40)) {
00346 
00347         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00348 
00349     } <span class="keywordflow">else</span> {
00350 
00351         <span class="comment">//</span>
00352         <span class="comment">// This does not appear to be an NTFS volume.</span>
00353         <span class="comment">//</span>
00354 
00355         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00356     }
00357 }
00358 
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:41:00 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
