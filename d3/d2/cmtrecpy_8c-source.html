<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: cmtrecpy.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>cmtrecpy.c</h1><a href="../../d2/d3/cmtrecpy_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1992  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    cmtrecpy.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This file contains code for CmpCopyTree, misc copy utility routines.</span>
00012 <span class="comment"></span>
00013 <span class="comment">Author:</span>
00014 <span class="comment"></span>
00015 <span class="comment">    Bryan M. Willman (bryanwi) 15-Jan-92</span>
00016 <span class="comment"></span>
00017 <span class="comment">Revision History:</span>
00018 <span class="comment"></span>
00019 <span class="comment">   Elliot Shmukler (t-ellios) 24-Aug-1998</span>
00020 <span class="comment">   </span>
00021 <span class="comment">      Added support for synchronizing two trees.</span>
00022 <span class="comment"></span>
00023 <span class="comment">--*/</span>
00024 
00025 <span class="preprocessor">#include    "<a class="code" href="../../d1/d2/cmp_8h.html">cmp.h</a>"</span>
00026 
00027 <span class="comment">//</span>
00028 <span class="comment">// Set this to true to enable tree sync debug outputs</span>
00029 <span class="comment">//</span>
00030 
<a name="l00031"></a><a class="code" href="../../d2/d3/cmtrecpy_8c.html#a0">00031</a> <span class="preprocessor">#define DEBUG_TREE_SYNC FALSE</span>
00032 <span class="preprocessor"></span>                          
00033 <span class="comment">//</span>
00034 <span class="comment">// stack used for directing nesting of tree copy.  gets us off</span>
00035 <span class="comment">// the kernel stack and thus allows for VERY deep nesting</span>
00036 <span class="comment">//</span>
00037 
<a name="l00038"></a><a class="code" href="../../d2/d3/cmtrecpy_8c.html#a1">00038</a> <span class="preprocessor">#define CMP_INITIAL_STACK_SIZE  1024        // ENTRIES</span>
00039 <span class="preprocessor"></span>
<a name="l00040"></a><a class="code" href="../../d4/d4/structCMP__COPY__STACK__ENTRY.html">00040</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00041"></a><a class="code" href="../../d4/d4/structCMP__COPY__STACK__ENTRY.html#o0">00041</a>     <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a> SourceCell;
<a name="l00042"></a><a class="code" href="../../d4/d4/structCMP__COPY__STACK__ENTRY.html#o1">00042</a>     <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a> TargetCell;
<a name="l00043"></a><a class="code" href="../../d4/d4/structCMP__COPY__STACK__ENTRY.html#o2">00043</a>     ULONG       i;
00044 } <a class="code" href="../../d4/d4/structCMP__COPY__STACK__ENTRY.html">CMP_COPY_STACK_ENTRY</a>, *<a class="code" href="../../d2/d3/cmtrecpy_8c.html#a2">PCMP_COPY_STACK_ENTRY</a>;
00045 
00046 BOOLEAN
00047 <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a3">CmpCopySyncTree2</a>(
00048     PCMP_COPY_STACK_ENTRY   CmpCopyStack,
00049     ULONG                   CmpCopyStackSize,
00050     ULONG                   CmpCopyStackTop,
00051     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>                  CmpSourceHive,
00052     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>                  CmpTargetHive,
00053     BOOLEAN                 CopyVolatile,
00054     CMP_COPY_TYPE           CopyType
00055     );
00056 
00057 BOOLEAN
00058 <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a4">CmpFreeKeyValues</a>(
00059     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a> Hive,
00060     HCELL_INDEX Cell,
00061     <a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html">PCM_KEY_NODE</a> Node
00062     );
00063 
00064 BOOLEAN
00065 <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a5">CmpSyncKeyValues</a>(
00066     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>  SourceHive,
00067     HCELL_INDEX SourceKeyCell,
00068     <a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html">PCM_KEY_NODE</a> SourceKeyNode,
00069     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>  TargetHive,
00070     HCELL_INDEX TargetKeyCell,
00071     <a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html">PCM_KEY_NODE</a> TargetKeyNode
00072     );
00073 
00074 BOOLEAN
00075 <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a6">CmpMergeKeyValues</a>(
00076     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>  SourceHive,
00077     HCELL_INDEX SourceKeyCell,
00078     <a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html">PCM_KEY_NODE</a> SourceKeyNode,
00079     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>  TargetHive,
00080     HCELL_INDEX TargetKeyCell,
00081     <a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html">PCM_KEY_NODE</a> TargetKeyNode
00082     );
00083 
00084 
00085 BOOLEAN
00086 <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a7">CmpSyncSubKeysAfterDelete</a>(
00087                           <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a> SourceHive,
00088                           <a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html">PCM_KEY_NODE</a> SourceCell,
00089                           <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a> TargetHive,
00090                           <a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html">PCM_KEY_NODE</a> TargetCell, 
00091                           WCHAR *NameBuffer);
00092 
00093 BOOLEAN
00094 <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a8">CmpMarkKeyValuesDirty</a>(
00095     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a> Hive,
00096     HCELL_INDEX Cell,
00097     <a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html">PCM_KEY_NODE</a> Node
00098     );
00099 
00100 BOOLEAN
00101 <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a9">CmpMarkKeyParentDirty</a>(
00102     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a> Hive,
00103     HCELL_INDEX Cell
00104     );
00105 
00106 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00107 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,CmpCopySyncTree)</span>
00108 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,CmpCopySyncTree2)</span>
00109 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,CmpCopyKeyPartial)</span>
00110 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,CmpCopyValue)</span>
00111 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,CmpCopyCell)</span>
00112 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,CmpFreeKeyValues)</span>
00113 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,CmpSyncKeyValues)</span>
00114 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,CmpMergeKeyValues)</span>
00115 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,CmpInitializeKeyNameString)</span>
00116 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,CmpInitializeValueNameString)</span>
00117 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,CmpSyncSubKeysAfterDelete)</span>
00118 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,CmpMarkKeyValuesDirty)</span>
00119 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,CmpMarkKeyParentDirty)</span>
00120 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00121 <span class="preprocessor"></span>
00122 <span class="comment">//</span>
00123 <span class="comment">// Routine to actually call to do a tree copy (or sync)</span>
00124 <span class="comment">//</span>
00125 
00126 BOOLEAN
<a name="l00127"></a><a class="code" href="../../d2/d3/cmtrecpy_8c.html#a10">00127</a> <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a10">CmpCopySyncTree</a>(
00128     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>          SourceHive,
00129     HCELL_INDEX     SourceCell,
00130     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>          TargetHive,
00131     HCELL_INDEX     TargetCell,
00132     BOOLEAN         CopyVolatile,
00133     CMP_COPY_TYPE   CopyType
00134     )
00135 <span class="comment">/*++</span>
00136 <span class="comment"></span>
00137 <span class="comment">Routine Description:</span>
00138 <span class="comment"></span>
00139 <span class="comment">    This routine can perform two distinct (yet similar) tasks:</span>
00140 <span class="comment">    a tree copy or a tree synchronization (sync). Which task</span>
00141 <span class="comment">    is performed is determined by the TreeSync parameter.</span>
00142 <span class="comment">    </span>
00143 <span class="comment">    For both operations:</span>
00144 <span class="comment">    --------------------</span>
00145 <span class="comment">    </span>
00146 <span class="comment">    The source root key and target root key must exist in advance.</span>
00147 <span class="comment">    These root nodes and their value entries will NOT be copied/synced.                </span>
00148 <span class="comment">    </span>
00149 <span class="comment">    NOTE:   Volatile keys are only copied/synced if the CopyVolatile</span>
00150 <span class="comment">            parameter is set to true.</span>
00151 <span class="comment"></span>
00152 <span class="comment">    </span>
00153 <span class="comment">    For a tree copy:</span>
00154 <span class="comment">    ----------------</span>
00155 <span class="comment">    </span>
00156 <span class="comment">    A tree is copied from source to destination. The subkeys</span>
00157 <span class="comment">    of the source root key and the full trees under those</span>
00158 <span class="comment">    subkeys will be copied to a new tree at target root key.</span>
00159 <span class="comment">                           </span>
00160 <span class="comment">    NOTE:   If this call fails part way through, it will NOT undo</span>
00161 <span class="comment">            any successfully completed key copies, thus a partial</span>
00162 <span class="comment">            tree copy CAN occur.</span>
00163 <span class="comment">            </span>
00164 <span class="comment">    For a tree sync:</span>
00165 <span class="comment">    ----------------</span>
00166 <span class="comment">    </span>
00167 <span class="comment">    The target tree is synchronized with the source tree. It is </span>
00168 <span class="comment">    assumed that for a certain period of the time the target tree</span>
00169 <span class="comment">    has remained unmodified while modifications may have been made</span>
00170 <span class="comment">    to the source tree. During a sync, any such modifications</span>
00171 <span class="comment">    to the source tree are made to the target tree. Thus, at the</span>
00172 <span class="comment">    end of a successful sync, the target tree is identical to the</span>
00173 <span class="comment">    source tree.</span>
00174 <span class="comment">    </span>
00175 <span class="comment">    Since only things that have changed in the source tree </span>
00176 <span class="comment">    are modified in the target tree, a sync operation is far</span>
00177 <span class="comment">    more efficient than the delete/copy operations necessary</span>
00178 <span class="comment">    to accomplish the same results.</span>
00179 <span class="comment">    </span>
00180 <span class="comment">    NOTE: It is assumed that no open handles are held</span>
00181 <span class="comment">          on any target tree keys. Registry in-memory data</span>
00182 <span class="comment">          structures may be corrupted if this is not true.</span>
00183 <span class="comment">        </span>
00184 <span class="comment">Arguments:</span>
00185 <span class="comment"></span>
00186 <span class="comment">    SourceHive - pointer to hive control structure for source</span>
00187 <span class="comment"></span>
00188 <span class="comment">    SourceCell - index of cell at root of tree to copy/sync</span>
00189 <span class="comment"></span>
00190 <span class="comment">    TargetHive - pointer to hive control structure for target</span>
00191 <span class="comment"></span>
00192 <span class="comment">    TargetCell - pointer to cell at root of target tree</span>
00193 <span class="comment">    </span>
00194 <span class="comment">    CopyVolatile - indicates whether volatile keys should be</span>
00195 <span class="comment">                   copied/synced.</span>
00196 <span class="comment">                   </span>
00197 <span class="comment">    CopyType - indicates the type of the copy operation:</span>
00198 <span class="comment">                Copy  - A copy is requested</span>
00199 <span class="comment">                Sync  - A sync is requested</span>
00200 <span class="comment">                Merge - A merge is requested i.e.:</span>
00201 <span class="comment">                    1. the target nodes that are not present on the source tree are not</span>
00202 <span class="comment">                    deleted.</span>
00203 <span class="comment">                    2. the target nodes that are present in the source tree gets overrided</span>
00204 <span class="comment">                    no matter what the LastWriteTime value is.</span>
00205 <span class="comment">Return Value:</span>
00206 <span class="comment"></span>
00207 <span class="comment">    BOOLEAN - Result code from call, among the following:</span>
00208 <span class="comment">        TRUE - it worked</span>
00209 <span class="comment">        FALSE - the tree copy/sync was not completed (though more than 0</span>
00210 <span class="comment">                keys may have been copied/synced)</span>
00211 <span class="comment"></span>
00212 <span class="comment">--*/</span>
00213 {
00214     BOOLEAN result;
00215     <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a2">PCMP_COPY_STACK_ENTRY</a>   CmpCopyStack;
00216 
00217     <a class="code" href="../../d1/d2/cmp_8h.html#a55">CMLOG</a>(<a class="code" href="../../d1/d2/cmp_8h.html#a22">CML_MAJOR</a>, <a class="code" href="../../d1/d2/cmp_8h.html#a32">CMS_SAVRES</a>) {
00218         KdPrint((<span class="stringliteral">"CmpCopyTree:\n"</span>));
00219     }
00220 
00221     CmpCopyStack = <a class="code" href="../../d5/d5/cc_8h.html#a10">ExAllocatePool</a>(
00222                         <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>,
00223                         <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d4/structCMP__COPY__STACK__ENTRY.html">CMP_COPY_STACK_ENTRY</a>)*<a class="code" href="../../d2/d3/cmtrecpy_8c.html#a1">CMP_INITIAL_STACK_SIZE</a>
00224                         );
00225     <span class="keywordflow">if</span> (CmpCopyStack == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00226         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00227     }
00228     CmpCopyStack[0].SourceCell = SourceCell;
00229     CmpCopyStack[0].TargetCell = TargetCell;
00230 
00231     result = <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a3">CmpCopySyncTree2</a>(
00232                 CmpCopyStack,
00233                 <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a1">CMP_INITIAL_STACK_SIZE</a>,
00234                 0,
00235                 SourceHive,
00236                 TargetHive,
00237                 CopyVolatile,
00238                 CopyType
00239                 );
00240 
00241     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(CmpCopyStack);
00242     <span class="keywordflow">return</span> result;
00243 }
00244 
00245 
00246 <span class="comment">//</span>
00247 <span class="comment">// Helper</span>
00248 <span class="comment">//</span>
00249 
00250 BOOLEAN
<a name="l00251"></a><a class="code" href="../../d2/d3/cmtrecpy_8c.html#a3">00251</a> <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a3">CmpCopySyncTree2</a>(
00252     PCMP_COPY_STACK_ENTRY   CmpCopyStack,
00253     ULONG                   CmpCopyStackSize,
00254     ULONG                   CmpCopyStackTop,
00255     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>                  CmpSourceHive,
00256     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>                  CmpTargetHive,
00257     BOOLEAN                 CopyVolatile,
00258     CMP_COPY_TYPE           CopyType
00259     )
00260 <span class="comment">/*++</span>
00261 <span class="comment"></span>
00262 <span class="comment">Routine Description:</span>
00263 <span class="comment"></span>
00264 <span class="comment">   This is a helper routine for CmpCopySyncTree. It accomplishes</span>
00265 <span class="comment">   the functionality described by that routine in a "virtually"</span>
00266 <span class="comment">   recursive manner which frees this routine from the limitations</span>
00267 <span class="comment">   of the Kernel stack.</span>
00268 <span class="comment">   </span>
00269 <span class="comment">   This routine should not be called directly. Use CmpCopySyncTree!.</span>
00270 <span class="comment">      </span>
00271 <span class="comment">Arguments:</span>
00272 <span class="comment"></span>
00273 <span class="comment">    (All of these are "virtual globals")</span>
00274 <span class="comment"></span>
00275 <span class="comment">    CmpCopyStack - "global" pointer to stack for frames</span>
00276 <span class="comment"></span>
00277 <span class="comment">    CmpCopyStackSize - alloced size of stack</span>
00278 <span class="comment"></span>
00279 <span class="comment">    CmpCopyStackTop - current top</span>
00280 <span class="comment"></span>
00281 <span class="comment">    CmpSourceHive, CmpTargetHive - source and target hives</span>
00282 <span class="comment">    </span>
00283 <span class="comment">    CopyVolatile, CopyType - same as CmpCopySyncTree.</span>
00284 <span class="comment"></span>
00285 <span class="comment"></span>
00286 <span class="comment">Return Value:</span>
00287 <span class="comment"></span>
00288 <span class="comment">    BOOLEAN - Result code from call, among the following:</span>
00289 <span class="comment">        TRUE - it worked</span>
00290 <span class="comment">        FALSE - the tree copy/sync was not completed (though more than 0</span>
00291 <span class="comment">                keys may have been copied/synced)</span>
00292 <span class="comment"></span>
00293 <span class="comment">--*/</span>
00294 {
00295     <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a2">PCMP_COPY_STACK_ENTRY</a>   Frame;
00296     <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a>             SourceChild;
00297     <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a>             NewSubKey;
00298 
00299     BOOLEAN                 Ret = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, SyncNeedsTreeCopy = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00300     UNICODE_STRING          <a class="code" href="../../d8/d0/rtbatcr_8c.html#a3">KeyName</a>;
00301     <a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html">PCM_KEY_NODE</a>            SourceChildCell, TargetChildCell;       
00302     <a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html">PCM_KEY_NODE</a>            SourceCell, TargetCell;
00303     ULONG                   SyncTreeCopyStackStart;
00304     WCHAR                   *NameBuffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00305     
00306     <span class="comment">// A merge is a particular case of a sync !!!</span>
00307     BOOLEAN                 TreeSync = (CopyType == <a class="code" href="../../d9/d0/cmdata_8h.html#a104a98">Sync</a> || CopyType == <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a91">Merge</a>)?<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>:<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00308 
00309     <a class="code" href="../../d1/d2/cmp_8h.html#a55">CMLOG</a>(<a class="code" href="../../d1/d2/cmp_8h.html#a23">CML_MINOR</a>, <a class="code" href="../../d1/d2/cmp_8h.html#a32">CMS_SAVRES</a>) {
00310         KdPrint((<span class="stringliteral">"CmpCopyTree2:\n"</span>));
00311     }
00312 
00313     <span class="keywordflow">if</span> (TreeSync) {
00314 
00315        <span class="comment">//</span>
00316        <span class="comment">// The sync operation involves some work with key names, </span>
00317        <span class="comment">// so we must allocate a buffer used for key name decompression.</span>
00318        <span class="comment">//</span>
00319 
00320        NameBuffer = <a class="code" href="../../d5/d5/cc_8h.html#a10">ExAllocatePool</a>(<a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>, <a class="code" href="../../d9/d0/cmdata_8h.html#a1">MAX_KEY_NAME_LENGTH</a>);
00321        <span class="keywordflow">if</span>(!NameBuffer) <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00322 
00323     } 
00324 
00325     <span class="comment">//</span>
00326     <span class="comment">// outer loop, apply to entire tree, emulate recursion here</span>
00327     <span class="comment">// jump to here is a virtual call</span>
00328     <span class="comment">//</span>
00329     Outer: <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00330 
00331         Frame = &amp;(CmpCopyStack[CmpCopyStackTop]);
00332 
00333         Frame-&gt;i = 0;
00334                         
00335     <span class="comment">//</span>
00336     <span class="comment">// inner loop, applies to one key</span>
00337     <span class="comment">// jump to here is a virtual return</span>
00338     <span class="comment">//</span>
00339         Inner: <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00340 
00341             SourceCell = (<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html">PCM_KEY_NODE</a>)<a class="code" href="../../d6/d0/hive_8h.html#a12">HvGetCell</a>(CmpSourceHive, Frame-&gt;SourceCell);
00342 
00343             SourceChild = <a class="code" href="../../d1/d2/cmp_8h.html#a304">CmpFindSubKeyByNumber</a>(CmpSourceHive,
00344                                                 SourceCell,
00345                                                 Frame-&gt;i);
00346             (Frame-&gt;i)++;
00347 
00348             <span class="keywordflow">if</span> ((SourceChild == <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>) || (!CopyVolatile &amp;&amp;
00349                                                (<a class="code" href="../../d0/d1/hivedata_8h.html#a19">HvGetCellType</a>(SourceChild) == <a class="code" href="../../d0/d1/hivedata_8h.html#a77a76">Volatile</a>))) {                                                           
00350 
00351                 <span class="comment">//</span>
00352                 <span class="comment">// we've stepped through all the children (or we are only</span>
00353                 <span class="comment">// interested in stable children and have just stepped through</span>
00354                 <span class="comment">// the stable children and into the volatile ones)</span>
00355                 <span class="comment">//                </span>
00356                 
00357                 <span class="keywordflow">if</span>(TreeSync &amp;&amp; (CopyType != <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a91">Merge</a>))
00358                 { 
00359                    <span class="comment">//</span>
00360                    <span class="comment">// If we are here during a sync, that means most of sync operations</span>
00361                    <span class="comment">// applied to the current SourceCell have been completed.</span>
00362                    <span class="comment">// That is, we have:</span>
00363                    <span class="comment">//   1) Synchronized SourceCell's values with its counterpart in the</span>
00364                    <span class="comment">//      target tree.</span>
00365                    <span class="comment">//   2) Synchronized any new SourceCell subkeys (subkeys present</span>
00366                    <span class="comment">//      in SourceCell but not its counterpart) by creating</span>
00367                    <span class="comment">//      and copying them to the proper place in the target tree.</span>
00368                    <span class="comment">//</span>
00369                    <span class="comment">// What this means is that SourceCell's counterpart in the target tree</span>
00370                    <span class="comment">// (TargetCell) now has at least as many subkeys as SourceCell.</span>
00371                    <span class="comment">//</span>
00372                    <span class="comment">// This implies that if TargetCell now has more subkeys that SourceCell</span>
00373                    <span class="comment">// than some subkeys of TargetCell are not present in the source tree</span>
00374                    <span class="comment">// (probably because those keys were deleted from the source tree </span>
00375                    <span class="comment">//  during the period between the previous sync and now).</span>
00376                    <span class="comment">//</span>
00377                    <span class="comment">// If such keys exist, then they must be delete them from TargetCell</span>
00378                    <span class="comment">// in order to complete the sync. We do this below.</span>
00379                    <span class="comment">//</span>
00380 
00381                    TargetCell = (<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html">PCM_KEY_NODE</a>)<a class="code" href="../../d6/d0/hive_8h.html#a12">HvGetCell</a>(CmpTargetHive, Frame-&gt;TargetCell);
00382 
00383                    <span class="comment">//</span>
00384                    <span class="comment">// Does TargetCell have more subkeys than SourceCell?</span>
00385                    <span class="comment">//</span>
00386 
00387                    <span class="keywordflow">if</span>((TargetCell-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o5">SubKeyCounts</a>[<a class="code" href="../../d0/d1/hivedata_8h.html#a77a75">Stable</a>] + 
00388                        TargetCell-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o5">SubKeyCounts</a>[<a class="code" href="../../d0/d1/hivedata_8h.html#a77a76">Volatile</a>]) &gt;
00389                       (SourceCell-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o5">SubKeyCounts</a>[<a class="code" href="../../d0/d1/hivedata_8h.html#a77a75">Stable</a>] + 
00390 
00391                        <span class="comment">// We only count the volatile keys if we are actually</span>
00392                        <span class="comment">// syncing them. Note, however, that we always use</span>
00393                        <span class="comment">// the volatile counts in TargetCell since we may</span>
00394                        <span class="comment">// be syncing to a volatile tree where all keys are volatile.</span>
00395                        
00396                        (CopyVolatile ? SourceCell-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o5">SubKeyCounts</a>[<a class="code" href="../../d0/d1/hivedata_8h.html#a77a76">Volatile</a>] : 0)))  
00397                            
00398                    {
00399 <span class="preprocessor">#if DEBUG_TREE_SYNC</span>
00400 <span class="preprocessor"></span>                      KdPrint((<span class="stringliteral">"CONFIG: SubKey Deletion from Source Cell #%lu.\n"</span>, 
00401                                Frame-&gt;SourceCell));
00402 <span class="preprocessor">#endif</span>
00403 <span class="preprocessor"></span>
00404                       <span class="comment">//</span>
00405                       <span class="comment">// Delete what should be deleted from TargetCell</span>
00406                       <span class="comment">//</span>
00407 
00408                       <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a7">CmpSyncSubKeysAfterDelete</a>(CmpSourceHive,
00409                                                 SourceCell, 
00410                                                 CmpTargetHive,
00411                                                 TargetCell,
00412                                                 NameBuffer);
00413                    }                                      
00414                 }
00415                   
00416                 <span class="keywordflow">break</span>;
00417             }           
00418                                                 
00419             <span class="keywordflow">if</span> (TreeSync) {
00420 
00421                <span class="comment">//</span>
00422                <span class="comment">// For a sync, we want to check if the current child (subkey)</span>
00423                <span class="comment">// of SourceCell is also a child of TargetCell - i.e. if</span>
00424                <span class="comment">// the subkey in question has a counterpart in the target tree.</span>
00425                <span class="comment">//</span>
00426                <span class="comment">// There is no guarantee that the counterpart's index number</span>
00427                <span class="comment">// will be the same so we must perform this check using</span>
00428                <span class="comment">// the subkey name.</span>
00429                <span class="comment">//</span>
00430 
00431                <span class="comment">//</span>
00432                <span class="comment">// Get the name of the current child</span>
00433                <span class="comment">//</span>
00434                      
00435                SourceChildCell = (<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html">PCM_KEY_NODE</a>)<a class="code" href="../../d6/d0/hive_8h.html#a12">HvGetCell</a>(CmpSourceHive,                                                               
00436                                                          SourceChild);                                         
00437                      
00438                <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a14">CmpInitializeKeyNameString</a>(SourceChildCell,
00439                                           &amp;<a class="code" href="../../d8/d0/rtbatcr_8c.html#a3">KeyName</a>, 
00440                                           NameBuffer);                     
00441 
00442                <span class="comment">//</span>
00443                <span class="comment">// Try to find the current child's counterpart in</span>
00444                <span class="comment">// in the target tree using the child's name.</span>
00445                <span class="comment">//</span>
00446                      
00447                NewSubKey = <a class="code" href="../../d1/d2/cmp_8h.html#a303">CmpFindSubKeyByName</a>(CmpTargetHive,
00448                                                (<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html">PCM_KEY_NODE</a>)<a class="code" href="../../d6/d0/hive_8h.html#a12">HvGetCell</a>(CmpTargetHive, 
00449                                                                        Frame-&gt;TargetCell),
00450                                                &amp;<a class="code" href="../../d8/d0/rtbatcr_8c.html#a3">KeyName</a>);
00451                                    
00452                      
00453                <span class="keywordflow">if</span> (NewSubKey != <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>) {
00454 
00455                   <span class="comment">//</span>
00456                   <span class="comment">// Found it, the current child (subkey) has a counterpart</span>
00457                   <span class="comment">// in the target tree. Thus, we just need to check if </span>
00458                   <span class="comment">// the counterpart's values are out of date and should</span>
00459                   <span class="comment">// be updated.</span>
00460                   <span class="comment">//</span>
00461 
00462                   TargetChildCell = (<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html">PCM_KEY_NODE</a>)<a class="code" href="../../d6/d0/hive_8h.html#a12">HvGetCell</a>(CmpTargetHive,
00463                                                             NewSubKey);
00464                         
00465                   <span class="comment">//</span>
00466                   <span class="comment">// Check if the current subkey has been modified</span>
00467                   <span class="comment">// more recently than its target tree counterpart.</span>
00468                   <span class="comment">// When we are doing a tree merge, always override the target.</span>
00469                   <span class="comment">//</span>
00470                         
00471                   <span class="keywordflow">if</span> ( (CopyType == <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a91">Merge</a>) ||
00472                       ((TargetChildCell-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o2">LastWriteTime</a>.QuadPart) &lt; 
00473                       (SourceChildCell-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o2">LastWriteTime</a>.QuadPart))) {
00474 
00475                      <span class="comment">//</span>
00476                      <span class="comment">// The counterpart is out of date. Its values</span>
00477                      <span class="comment">// must be synchornized with the current subkey.</span>
00478                      <span class="comment">//</span>
00479 <span class="preprocessor">#if DEBUG_TREE_SYNC</span>
00480 <span class="preprocessor"></span>                     KdPrint((<span class="stringliteral">"CONFIG: Target Refresh.\n"</span>));
00481                      KdPrint((<span class="stringliteral">"CONFIG: Source Cell %lu = %.*S\n"</span>, 
00482                               SourceChild,
00483                               <a class="code" href="../../d8/d0/rtbatcr_8c.html#a3">KeyName</a>.Length / <span class="keyword">sizeof</span>(WCHAR),
00484                               <a class="code" href="../../d8/d0/rtbatcr_8c.html#a3">KeyName</a>.Buffer));
00485 <span class="preprocessor">#endif</span>
00486 <span class="preprocessor"></span>
00487                      <span class="comment">//</span>
00488                      <span class="comment">// Sync up the key's values, sd, &amp; class                     </span>
00489                      <span class="comment">//</span>
00490 
00491                      <span class="keywordflow">if</span>(CopyType == <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a91">Merge</a>) {
00492                          <span class="keywordflow">if</span>(!<a class="code" href="../../d2/d3/cmtrecpy_8c.html#a6">CmpMergeKeyValues</a>(CmpSourceHive, SourceChild, SourceChildCell,
00493                                               CmpTargetHive, NewSubKey, TargetChildCell)) {
00494                             <span class="keywordflow">goto</span> CopyEnd;                              
00495                          }
00496                      } <span class="keywordflow">else</span> {
00497                          <span class="keywordflow">if</span>(!<a class="code" href="../../d2/d3/cmtrecpy_8c.html#a5">CmpSyncKeyValues</a>(CmpSourceHive, SourceChild, SourceChildCell,
00498                                               CmpTargetHive, NewSubKey, TargetChildCell)) {
00499                             <span class="keywordflow">goto</span> CopyEnd;                              
00500                         }
00501                      }
00502 
00503                      <span class="comment">//</span>
00504                      <span class="comment">// Sync the timestamps so that we don't do this again.</span>
00505                      <span class="comment">//</span>
00506 
00507                      TargetChildCell-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o2">LastWriteTime</a>.QuadPart =
00508                         SourceChildCell-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o2">LastWriteTime</a>.QuadPart;
00509                         
00510                   }
00511                            
00512                   <span class="comment">//</span>
00513                   <span class="comment">// If we are here, then the current subkey's target</span>
00514                   <span class="comment">// tree counterpart has been synchronized (or did not need</span>
00515                   <span class="comment">// to be). Transfer control to the code that will apply</span>
00516                   <span class="comment">// this function "recursively" to the current subkey in order</span>
00517                   <span class="comment">// to continue the sync.</span>
00518                   <span class="comment">//</span>
00519 
00520                   <span class="keywordflow">goto</span> NewKeyCreated;
00521                      
00522                }   
00523 
00524                <span class="comment">//</span>
00525                <span class="comment">// If we are here, it means that the current child (subkey)</span>
00526                <span class="comment">// does not have a counterpart in the target tree. This means</span>
00527                <span class="comment">// we have encountered a new subkey in the source tree and must</span>
00528                <span class="comment">// create it in the target tree. </span>
00529                <span class="comment">//</span>
00530                <span class="comment">// The standard copy code below will create this subkey. However,</span>
00531                <span class="comment">// we must also make sure that the tree under this subkey is properly</span>
00532                <span class="comment">// copied from source to target. The most efficient way of doing</span>
00533                <span class="comment">// this is to temporarily forget that we are in a sync operation</span>
00534                <span class="comment">// and merely perform a copy until the desired result is achieved.</span>
00535                <span class="comment">// </span>
00536 
00537 <span class="preprocessor">#if DEBUG_TREE_SYNC</span>
00538 <span class="preprocessor"></span>               KdPrint((<span class="stringliteral">"CONFIG: New SubKey.\n"</span>));
00539                KdPrint((<span class="stringliteral">"CONFIG: Source Cell %lu = %.*S\n"</span>, 
00540                         SourceChild,
00541                         <a class="code" href="../../d8/d0/rtbatcr_8c.html#a3">KeyName</a>.Length / <span class="keyword">sizeof</span>(WCHAR),
00542                         <a class="code" href="../../d8/d0/rtbatcr_8c.html#a3">KeyName</a>.Buffer));
00543 <span class="preprocessor">#endif</span>
00544 <span class="preprocessor"></span>
00545                <span class="comment">//</span>
00546                <span class="comment">// Indicate that we will just copy and not sync for a while</span>
00547                <span class="comment">//</span>
00548                                              
00549                SyncNeedsTreeCopy = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;                                          
00550                 
00551             }
00552 
00553             NewSubKey = <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a11">CmpCopyKeyPartial</a>(
00554                                           CmpSourceHive,
00555                                           SourceChild,
00556                                           CmpTargetHive,
00557                                           Frame-&gt;TargetCell,
00558                                           <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>
00559                                           );
00560 
00561                 
00562             <span class="keywordflow">if</span> (NewSubKey == <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>) {
00563                
00564                <span class="keywordflow">goto</span> CopyEnd;
00565             }
00566                 
00567             <span class="keywordflow">if</span> ( !  <a class="code" href="../../d1/d2/cmp_8h.html#a305">CmpAddSubKey</a>(
00568                                  CmpTargetHive,
00569                                  Frame-&gt;TargetCell,
00570                                  NewSubKey
00571                                  )
00572                  ) {
00573 
00574                <span class="keywordflow">goto</span> CopyEnd;
00575             }
00576 
00577             <span class="comment">//</span>
00578             <span class="comment">// Check if the sync operation determined that this</span>
00579             <span class="comment">// subtree should be copied</span>
00580             <span class="comment">//</span>
00581                 
00582             <span class="keywordflow">if</span>(TreeSync &amp;&amp; SyncNeedsTreeCopy) {
00583 
00584                <span class="comment">//</span>
00585                <span class="comment">// We have just created a new key in the target tree</span>
00586                <span class="comment">// with the above code. However, since this is a sync,</span>
00587                <span class="comment">// the parent of that new key has not been created by our</span>
00588                <span class="comment">// code and thus may not have been modified at all before</span>
00589                <span class="comment">// the creation of the new key. But this parent now </span>
00590                <span class="comment">// has a new child, and must therefore be marked as dirty.</span>
00591                <span class="comment">//</span>
00592                    
00593                <span class="keywordflow">if</span> (! <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a9">CmpMarkKeyParentDirty</a>(CmpTargetHive, NewSubKey)) {
00594 
00595                   <span class="keywordflow">goto</span> CopyEnd;
00596                }
00597                    
00598                <span class="comment">//</span>
00599                <span class="comment">// Record the stack level where we start the copy </span>
00600                <span class="comment">// (and temporarily abandon the sync)</span>
00601                <span class="comment">// so that we can return to the sync operation when this</span>
00602                <span class="comment">// stack level is reached again (i.e. when the tree</span>
00603                <span class="comment">// under the current subkey is fully copied)</span>
00604                <span class="comment">//</span>
00605 
00606                SyncTreeCopyStackStart = CmpCopyStackTop;
00607 
00608                <span class="comment">//</span>
00609                <span class="comment">// Pretend that this is not a sync in order</span>
00610                <span class="comment">// to simply start copying</span>
00611                <span class="comment">//</span>
00612 
00613                TreeSync = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00614             }
00615 
00616 NewKeyCreated:
00617                     
00618                     <span class="comment">//</span>
00619                     <span class="comment">// We succeeded in copying/syncing the subkey, apply</span>
00620                     <span class="comment">// ourselves to it</span>
00621                     <span class="comment">//</span>
00622                     CmpCopyStackTop++;
00623 
00624                     <span class="keywordflow">if</span> (CmpCopyStackTop &gt;= CmpCopyStackSize) {
00625 
00626                         <span class="comment">//</span>
00627                         <span class="comment">// if we're here, it means that the tree</span>
00628                         <span class="comment">// we're trying to copy is more than 1024</span>
00629                         <span class="comment">// COMPONENTS deep (from 2048 to 256k bytes)</span>
00630                         <span class="comment">// we could grow the stack, but this is pretty</span>
00631                         <span class="comment">// severe, so return FALSE and fail the copy</span>
00632                         <span class="comment">//</span>
00633                         
00634                         <span class="keywordflow">goto</span> CopyEnd;
00635                     }
00636 
00637                     CmpCopyStack[CmpCopyStackTop].SourceCell =
00638                             SourceChild;
00639 
00640                     CmpCopyStack[CmpCopyStackTop].TargetCell =
00641                             NewSubKey;
00642 
00643                     <span class="keywordflow">goto</span> Outer;
00644 
00645                     
00646         } <span class="comment">// Inner: while</span>
00647 
00648         <span class="keywordflow">if</span> (CmpCopyStackTop == 0) {            
00649             Ret = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00650             <span class="keywordflow">goto</span> CopyEnd;
00651         }
00652 
00653         CmpCopyStackTop--;
00654         Frame = &amp;(CmpCopyStack[CmpCopyStackTop]);
00655 
00656         <span class="comment">//</span>
00657         <span class="comment">// We have just completed working at a certain stack level.</span>
00658         <span class="comment">// This is a good time to check if we need to resume a temporarily</span>
00659         <span class="comment">// suspended sync operation.</span>
00660         <span class="comment">//</span>
00661 
00662         <span class="keywordflow">if</span>(SyncNeedsTreeCopy &amp;&amp; (CmpCopyStackTop == SyncTreeCopyStackStart))
00663         {
00664            <span class="comment">//</span>
00665            <span class="comment">// We've been copying a tree for a sync. But now, that tree is fully</span>
00666            <span class="comment">// copied. So, let's resume the sync once again.</span>
00667            <span class="comment">//</span>
00668 
00669            TreeSync = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;               
00670            SyncNeedsTreeCopy = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00671         }
00672 
00673 
00674         <span class="keywordflow">goto</span> Inner;
00675 
00676     } <span class="comment">// Outer: while</span>
00677 
00678 CopyEnd:
00679 
00680    <span class="keywordflow">if</span> (NameBuffer) <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(NameBuffer);
00681    <span class="keywordflow">return</span> Ret;
00682 }
00683 
00684 
00685 <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a>
<a name="l00686"></a><a class="code" href="../../d2/d3/cmtrecpy_8c.html#a11">00686</a> <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a11">CmpCopyKeyPartial</a>(
00687     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>  SourceHive,
00688     HCELL_INDEX SourceKeyCell,
00689     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>  TargetHive,
00690     HCELL_INDEX Parent,
00691     BOOLEAN CopyValues
00692     )
00693 <span class="comment">/*++</span>
00694 <span class="comment"></span>
00695 <span class="comment">Routine Description:</span>
00696 <span class="comment"></span>
00697 <span class="comment">    Copy a key body and all of its values, but NOT its subkeylist or</span>
00698 <span class="comment">    subkey entries.  SubKeyList.Count will be set to 0.</span>
00699 <span class="comment"></span>
00700 <span class="comment">Arguments:</span>
00701 <span class="comment"></span>
00702 <span class="comment">    SourceHive - pointer to hive control structure for source</span>
00703 <span class="comment"></span>
00704 <span class="comment">    SourceKeyCell - value entry being copied</span>
00705 <span class="comment"></span>
00706 <span class="comment">    TargetHive - pointer to hive control structure for target</span>
00707 <span class="comment"></span>
00708 <span class="comment">    Parent - parent value to set into newly created key body</span>
00709 <span class="comment"></span>
00710 <span class="comment">    CopyValues - if FALSE value entries will not be copied, if TRUE, they will</span>
00711 <span class="comment"></span>
00712 <span class="comment">Return Value:</span>
00713 <span class="comment"></span>
00714 <span class="comment">    HCELL_INDEX - Cell of body of new key entry, or HCELL_NIL</span>
00715 <span class="comment">        if some error.</span>
00716 <span class="comment"></span>
00717 <span class="comment">--*/</span>
00718 {
00719     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>    status;
00720     <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a> newkey = <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>;
00721     <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a> newclass = <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>;
00722     <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a> newsecurity = <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>;
00723     <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a> newlist = <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>;
00724     <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a> newvalue;
00725     BOOLEAN success = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00726     ULONG   i;
00727     <a class="code" href="../../d4/d9/struct__CELL__DATA.html">PCELL_DATA</a> psrckey;
00728     <a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html">PCM_KEY_NODE</a> ptarkey;
00729     <a class="code" href="../../d4/d9/struct__CELL__DATA.html">PCELL_DATA</a> psrclist;
00730     <a class="code" href="../../d4/d9/struct__CELL__DATA.html">PCELL_DATA</a> ptarlist;
00731     <a class="code" href="../../d4/d9/struct__CELL__DATA.html">PCELL_DATA</a> psrcsecurity;
00732     <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a> security;
00733     <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a> <span class="keyword">class</span>;
00734     ULONG   classlength;
00735     ULONG   count;
00736     ULONG   Type;
00737 
00738     <a class="code" href="../../d1/d2/cmp_8h.html#a55">CMLOG</a>(<a class="code" href="../../d1/d2/cmp_8h.html#a23">CML_MINOR</a>, <a class="code" href="../../d1/d2/cmp_8h.html#a32">CMS_SAVRES</a>) {
00739         KdPrint((<span class="stringliteral">"CmpCopyKeyPartial:\n"</span>));
00740         KdPrint((<span class="stringliteral">"\tSHive=%08lx SCell=%08lx\n"</span>,SourceHive,SourceKeyCell));
00741         KdPrint((<span class="stringliteral">"\tTHive=%08lx\n"</span>,TargetHive));
00742     }
00743 
00744 
00745     <span class="comment">//</span>
00746     <span class="comment">// get description of source</span>
00747     <span class="comment">//</span>
00748     <span class="keywordflow">if</span> (Parent == <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>) {
00749         <span class="comment">//</span>
00750         <span class="comment">// This is a root node we are creating, so don't make it volatile.</span>
00751         <span class="comment">//</span>
00752         Type = <a class="code" href="../../d0/d1/hivedata_8h.html#a77a75">Stable</a>;
00753     } <span class="keywordflow">else</span> {
00754         Type = <a class="code" href="../../d0/d1/hivedata_8h.html#a19">HvGetCellType</a>(Parent);
00755     }
00756     psrckey = <a class="code" href="../../d6/d0/hive_8h.html#a12">HvGetCell</a>(SourceHive, SourceKeyCell);
00757     security = psrckey-&gt;<a class="code" href="../../d4/d9/struct__CELL__DATA.html#o0">u</a>.<a class="code" href="../../d5/d9/union__CELL__DATA_1_1__u.html#o0">KeyNode</a>.<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o9">Security</a>;
00758     <span class="keyword">class </span>= psrckey-&gt;u.KeyNode.Class;
00759     classlength = psrckey-&gt;<a class="code" href="../../d4/d9/struct__CELL__DATA.html#o0">u</a>.<a class="code" href="../../d5/d9/union__CELL__DATA_1_1__u.html#o0">KeyNode</a>.<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o17">ClassLength</a>;
00760 
00761     <span class="comment">//</span>
00762     <span class="comment">// Allocate and copy the body</span>
00763     <span class="comment">//</span>
00764     newkey = <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a13">CmpCopyCell</a>(SourceHive, SourceKeyCell, TargetHive, Type);
00765     <span class="keywordflow">if</span> (newkey == <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>) {
00766         <span class="keywordflow">goto</span> DoFinally;
00767     }
00768 
00769     <span class="comment">//</span>
00770     <span class="comment">// Allocate and copy class</span>
00771     <span class="comment">//</span>
00772     <span class="keywordflow">if</span> (classlength &gt; 0) {
00773         newclass = <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a13">CmpCopyCell</a>(SourceHive, <span class="keyword">class</span>, TargetHive, Type);
00774         <span class="keywordflow">if</span> (newclass == <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>) {
00775             <span class="keywordflow">goto</span> DoFinally;
00776         }
00777     }
00778 
00779     <span class="comment">//</span>
00780     <span class="comment">// Fill in the target body</span>
00781     <span class="comment">//</span>
00782     ptarkey = (<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html">PCM_KEY_NODE</a>)<a class="code" href="../../d6/d0/hive_8h.html#a12">HvGetCell</a>(TargetHive, newkey);
00783 
00784     ptarkey-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o10">Class</a> = newclass;
00785     ptarkey-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o9">Security</a> = <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>;
00786     ptarkey-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o6">SubKeyLists</a>[<a class="code" href="../../d0/d1/hivedata_8h.html#a77a75">Stable</a>] = <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>;
00787     ptarkey-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o6">SubKeyLists</a>[<a class="code" href="../../d0/d1/hivedata_8h.html#a77a76">Volatile</a>] = <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>;
00788     ptarkey-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o5">SubKeyCounts</a>[<a class="code" href="../../d0/d1/hivedata_8h.html#a77a75">Stable</a>] = 0;
00789     ptarkey-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o5">SubKeyCounts</a>[<a class="code" href="../../d0/d1/hivedata_8h.html#a77a76">Volatile</a>] = 0;
00790     ptarkey-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o4">Parent</a> = Parent;
00791 
00792     ptarkey-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o1">Flags</a> = (psrckey-&gt;<a class="code" href="../../d4/d9/struct__CELL__DATA.html#o0">u</a>.<a class="code" href="../../d5/d9/union__CELL__DATA_1_1__u.html#o0">KeyNode</a>.<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o1">Flags</a> &amp; <a class="code" href="../../d9/d0/cmdata_8h.html#a32">KEY_COMP_NAME</a>);
00793     <span class="keywordflow">if</span> (Parent == <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>) {
00794         ptarkey-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o1">Flags</a> |= <a class="code" href="../../d9/d0/cmdata_8h.html#a29">KEY_HIVE_ENTRY</a> + <a class="code" href="../../d9/d0/cmdata_8h.html#a30">KEY_NO_DELETE</a>;
00795     }
00796 
00797     <span class="comment">//</span>
00798     <span class="comment">// Allocate and copy security</span>
00799     <span class="comment">//</span>
00800     psrcsecurity = <a class="code" href="../../d6/d0/hive_8h.html#a12">HvGetCell</a>(SourceHive, security);
00801 
00802     status = <a class="code" href="../../d7/d2/cmse_8c.html#a10">CmpAssignSecurityDescriptor</a>(TargetHive,
00803                                          newkey,
00804                                          ptarkey,
00805                                          &amp;(psrcsecurity-&gt;<a class="code" href="../../d4/d9/struct__CELL__DATA.html#o0">u</a>.<a class="code" href="../../d5/d9/union__CELL__DATA_1_1__u.html#o2">KeySecurity</a>.<a class="code" href="../../d6/d5/struct__CM__KEY__SECURITY.html#o6">Descriptor</a>));
00806     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
00807         <span class="keywordflow">goto</span> DoFinally;
00808     }
00809 
00810 
00811     <span class="comment">//</span>
00812     <span class="comment">// Set up the value list</span>
00813     <span class="comment">//</span>
00814     count = psrckey-&gt;<a class="code" href="../../d4/d9/struct__CELL__DATA.html#o0">u</a>.<a class="code" href="../../d5/d9/union__CELL__DATA_1_1__u.html#o0">KeyNode</a>.<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o7">ValueList</a>.<a class="code" href="../../d7/d9/struct__CHILD__LIST.html#o0">Count</a>;
00815 
00816     <span class="keywordflow">if</span> ((count == 0) || (CopyValues == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
00817         ptarkey-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o7">ValueList</a>.<a class="code" href="../../d7/d9/struct__CHILD__LIST.html#o1">List</a> = <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>;
00818         ptarkey-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o7">ValueList</a>.<a class="code" href="../../d7/d9/struct__CHILD__LIST.html#o0">Count</a> = 0;
00819         success = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00820     } <span class="keywordflow">else</span> {
00821 
00822         psrclist = <a class="code" href="../../d6/d0/hive_8h.html#a12">HvGetCell</a>(SourceHive, psrckey-&gt;<a class="code" href="../../d4/d9/struct__CELL__DATA.html#o0">u</a>.<a class="code" href="../../d5/d9/union__CELL__DATA_1_1__u.html#o0">KeyNode</a>.<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o7">ValueList</a>.<a class="code" href="../../d7/d9/struct__CHILD__LIST.html#o1">List</a>);
00823 
00824         newlist = <a class="code" href="../../d8/d0/hivecell_8c.html#a16">HvAllocateCell</a>(
00825                     TargetHive,
00826                     count * <span class="keyword">sizeof</span>(<a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a>),
00827                     Type
00828                     );
00829         <span class="keywordflow">if</span> (newlist == <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>) {
00830             <span class="keywordflow">goto</span> DoFinally;
00831         }
00832         ptarkey-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o7">ValueList</a>.<a class="code" href="../../d7/d9/struct__CHILD__LIST.html#o1">List</a> = newlist;
00833         ptarlist = <a class="code" href="../../d6/d0/hive_8h.html#a12">HvGetCell</a>(TargetHive, newlist);
00834 
00835 
00836         <span class="comment">//</span>
00837         <span class="comment">// Copy the values</span>
00838         <span class="comment">//</span>
00839         <span class="keywordflow">for</span> (i = 0; i &lt; count; i++) {
00840 
00841             newvalue = <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a12">CmpCopyValue</a>(
00842                             SourceHive,
00843                             psrclist-&gt;<a class="code" href="../../d4/d9/struct__CELL__DATA.html#o0">u</a>.<a class="code" href="../../d5/d9/union__CELL__DATA_1_1__u.html#o4">KeyList</a>[i],
00844                             TargetHive,
00845                             Type
00846                             );
00847 
00848             <span class="keywordflow">if</span> (newvalue != <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>) {
00849 
00850                 ptarlist-&gt;<a class="code" href="../../d4/d9/struct__CELL__DATA.html#o0">u</a>.<a class="code" href="../../d5/d9/union__CELL__DATA_1_1__u.html#o4">KeyList</a>[i] = newvalue;
00851 
00852             } <span class="keywordflow">else</span> {
00853 
00854                 <span class="keywordflow">for</span> (; i &gt; 0; i--) {
00855                     <a class="code" href="../../d8/d0/hivecell_8c.html#a17">HvFreeCell</a>(
00856                         TargetHive,
00857                         ptarlist-&gt;<a class="code" href="../../d4/d9/struct__CELL__DATA.html#o0">u</a>.<a class="code" href="../../d5/d9/union__CELL__DATA_1_1__u.html#o4">KeyList</a>[i - 1]
00858                         );
00859                 }
00860                 <span class="keywordflow">goto</span> DoFinally;
00861             }
00862         }
00863         success = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00864     }
00865 
00866 DoFinally:
00867     <span class="keywordflow">if</span> (success == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00868 
00869         <span class="keywordflow">if</span> (newlist != <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>) {
00870             <a class="code" href="../../d8/d0/hivecell_8c.html#a17">HvFreeCell</a>(TargetHive, newlist);
00871         }
00872 
00873         <span class="keywordflow">if</span> (newsecurity != <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>) {
00874             <a class="code" href="../../d8/d0/hivecell_8c.html#a17">HvFreeCell</a>(TargetHive, newsecurity);
00875         }
00876 
00877         <span class="keywordflow">if</span> (newclass != <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>) {
00878             <a class="code" href="../../d8/d0/hivecell_8c.html#a17">HvFreeCell</a>(TargetHive, newclass);
00879         }
00880 
00881         <span class="keywordflow">if</span> (newkey != <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>) {
00882             <a class="code" href="../../d8/d0/hivecell_8c.html#a17">HvFreeCell</a>(TargetHive, newkey);
00883         }
00884 
00885         <span class="keywordflow">return</span> <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>;
00886 
00887     } <span class="keywordflow">else</span> {
00888 
00889         <span class="keywordflow">return</span> newkey;
00890     }
00891 }
00892 
00893 
00894 <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a>
<a name="l00895"></a><a class="code" href="../../d2/d3/cmtrecpy_8c.html#a12">00895</a> <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a12">CmpCopyValue</a>(
00896     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>  SourceHive,
00897     HCELL_INDEX SourceValueCell,
00898     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>  TargetHive,
00899     HSTORAGE_TYPE   Type
00900     )
00901 <span class="comment">/*++</span>
00902 <span class="comment"></span>
00903 <span class="comment">Routine Description:</span>
00904 <span class="comment"></span>
00905 <span class="comment">    Copy a value entry.  Copies the body of a value entry and the</span>
00906 <span class="comment">    data.  Returns cell of new value entry.</span>
00907 <span class="comment"></span>
00908 <span class="comment">Arguments:</span>
00909 <span class="comment"></span>
00910 <span class="comment">    SourceHive - pointer to hive control structure for source</span>
00911 <span class="comment"></span>
00912 <span class="comment">    SourceValueCell - value entry being copied</span>
00913 <span class="comment"></span>
00914 <span class="comment">    TargetHive - pointer to hive control structure for target</span>
00915 <span class="comment"></span>
00916 <span class="comment">    Type - storage type to allocate for target (stable or volatile)</span>
00917 <span class="comment"></span>
00918 <span class="comment">Return Value:</span>
00919 <span class="comment"></span>
00920 <span class="comment">    HCELL_INDEX - Cell of body of new value entry, or HCELL_NIL</span>
00921 <span class="comment">        if some error.</span>
00922 <span class="comment"></span>
00923 <span class="comment">--*/</span>
00924 {
00925     <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a> newvalue;
00926     <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a> newdata;
00927     <a class="code" href="../../d4/d9/struct__CELL__DATA.html">PCELL_DATA</a> pvalue;
00928     ULONG       datalength;
00929     <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a> olddata;
00930     ULONG       tempdata;
00931     BOOLEAN     small;
00932 
00933     <a class="code" href="../../d1/d2/cmp_8h.html#a55">CMLOG</a>(<a class="code" href="../../d1/d2/cmp_8h.html#a23">CML_MINOR</a>, <a class="code" href="../../d1/d2/cmp_8h.html#a32">CMS_SAVRES</a>) {
00934         KdPrint((<span class="stringliteral">"CmpCopyValue:\n"</span>));
00935         KdPrint((<span class="stringliteral">"\tSHive=%08lx SCell=%08lx\n"</span>,SourceHive,SourceValueCell));
00936         KdPrint((<span class="stringliteral">"\tTargetHive=%08lx\n"</span>,TargetHive));
00937     }
00938 
00939     <span class="comment">//</span>
00940     <span class="comment">// get source data</span>
00941     <span class="comment">//</span>
00942     pvalue = <a class="code" href="../../d6/d0/hive_8h.html#a12">HvGetCell</a>(SourceHive, SourceValueCell);
00943     small = <a class="code" href="../../d9/d0/cmdata_8h.html#a38">CmpIsHKeyValueSmall</a>(datalength, pvalue-&gt;<a class="code" href="../../d4/d9/struct__CELL__DATA.html#o0">u</a>.<a class="code" href="../../d5/d9/union__CELL__DATA_1_1__u.html#o1">KeyValue</a>.<a class="code" href="../../d7/d5/struct__CM__KEY__VALUE.html#o2">DataLength</a>);
00944     olddata = pvalue-&gt;<a class="code" href="../../d4/d9/struct__CELL__DATA.html#o0">u</a>.<a class="code" href="../../d5/d9/union__CELL__DATA_1_1__u.html#o1">KeyValue</a>.<a class="code" href="../../d7/d5/struct__CM__KEY__VALUE.html#o3">Data</a>;
00945 
00946     <span class="comment">//</span>
00947     <span class="comment">// Copy body</span>
00948     <span class="comment">//</span>
00949     newvalue = <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a13">CmpCopyCell</a>(SourceHive, SourceValueCell, TargetHive, Type);
00950     <span class="keywordflow">if</span> (newvalue == <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>) {
00951         <span class="keywordflow">return</span> <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>;
00952     }
00953 
00954     <span class="comment">//</span>
00955     <span class="comment">// Copy data (if any)</span>
00956     <span class="comment">//</span>
00957     <span class="keywordflow">if</span> (datalength &gt; 0) {
00958 
00959         <span class="keywordflow">if</span> (datalength &gt; <a class="code" href="../../d9/d0/cmdata_8h.html#a36">CM_KEY_VALUE_SMALL</a>) {
00960 
00961             <span class="comment">//</span>
00962             <span class="comment">// there's data, and it's "big", so do standard copy</span>
00963             <span class="comment">//</span>
00964             newdata = <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a13">CmpCopyCell</a>(SourceHive, olddata, TargetHive, Type);
00965 
00966             <span class="keywordflow">if</span> (newdata == <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>) {
00967                 <a class="code" href="../../d8/d0/hivecell_8c.html#a17">HvFreeCell</a>(TargetHive, newvalue);
00968                 <span class="keywordflow">return</span> <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>;
00969             }
00970 
00971             pvalue = <a class="code" href="../../d6/d0/hive_8h.html#a12">HvGetCell</a>(TargetHive, newvalue);
00972             pvalue-&gt;<a class="code" href="../../d4/d9/struct__CELL__DATA.html#o0">u</a>.<a class="code" href="../../d5/d9/union__CELL__DATA_1_1__u.html#o1">KeyValue</a>.<a class="code" href="../../d7/d5/struct__CM__KEY__VALUE.html#o3">Data</a> = newdata;
00973             pvalue-&gt;<a class="code" href="../../d4/d9/struct__CELL__DATA.html#o0">u</a>.<a class="code" href="../../d5/d9/union__CELL__DATA_1_1__u.html#o1">KeyValue</a>.<a class="code" href="../../d7/d5/struct__CM__KEY__VALUE.html#o2">DataLength</a> = datalength;
00974 
00975         } <span class="keywordflow">else</span> {
00976 
00977             <span class="comment">//</span>
00978             <span class="comment">// the data is small, but may be stored in either large or</span>
00979             <span class="comment">// small format for historical reasons</span>
00980             <span class="comment">//</span>
00981             <span class="keywordflow">if</span> (small) {
00982 
00983                 <span class="comment">//</span>
00984                 <span class="comment">// data is already small, so just do a body to body copy</span>
00985                 <span class="comment">//</span>
00986                 tempdata = pvalue-&gt;<a class="code" href="../../d4/d9/struct__CELL__DATA.html#o0">u</a>.<a class="code" href="../../d5/d9/union__CELL__DATA_1_1__u.html#o1">KeyValue</a>.<a class="code" href="../../d7/d5/struct__CM__KEY__VALUE.html#o3">Data</a>;
00987 
00988             } <span class="keywordflow">else</span> {
00989 
00990                 <span class="comment">//</span>
00991                 <span class="comment">// data is stored externally in old cell, will be internal in new</span>
00992                 <span class="comment">//</span>
00993                 pvalue = <a class="code" href="../../d6/d0/hive_8h.html#a12">HvGetCell</a>(SourceHive, pvalue-&gt;<a class="code" href="../../d4/d9/struct__CELL__DATA.html#o0">u</a>.<a class="code" href="../../d5/d9/union__CELL__DATA_1_1__u.html#o1">KeyValue</a>.<a class="code" href="../../d7/d5/struct__CM__KEY__VALUE.html#o3">Data</a>);
00994                 tempdata = *((PULONG)pvalue);
00995             }
00996             pvalue = <a class="code" href="../../d6/d0/hive_8h.html#a12">HvGetCell</a>(TargetHive, newvalue);
00997             pvalue-&gt;<a class="code" href="../../d4/d9/struct__CELL__DATA.html#o0">u</a>.<a class="code" href="../../d5/d9/union__CELL__DATA_1_1__u.html#o1">KeyValue</a>.<a class="code" href="../../d7/d5/struct__CM__KEY__VALUE.html#o3">Data</a> = tempdata;
00998             pvalue-&gt;<a class="code" href="../../d4/d9/struct__CELL__DATA.html#o0">u</a>.<a class="code" href="../../d5/d9/union__CELL__DATA_1_1__u.html#o1">KeyValue</a>.<a class="code" href="../../d7/d5/struct__CM__KEY__VALUE.html#o2">DataLength</a> =
00999                 datalength + <a class="code" href="../../d9/d0/cmdata_8h.html#a35">CM_KEY_VALUE_SPECIAL_SIZE</a>;
01000 
01001         }
01002     }
01003 
01004     <span class="keywordflow">return</span> newvalue;
01005 }
01006 
01007 
01008 <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a>
<a name="l01009"></a><a class="code" href="../../d2/d3/cmtrecpy_8c.html#a13">01009</a> <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a13">CmpCopyCell</a>(
01010     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>  SourceHive,
01011     HCELL_INDEX SourceCell,
01012     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>  TargetHive,
01013     HSTORAGE_TYPE   Type
01014     )
01015 <span class="comment">/*++</span>
01016 <span class="comment"></span>
01017 <span class="comment">Routine Description:</span>
01018 <span class="comment"></span>
01019 <span class="comment">    Copy SourceHive.SourceCell to TargetHive.TargetCell.</span>
01020 <span class="comment"></span>
01021 <span class="comment">Arguments:</span>
01022 <span class="comment"></span>
01023 <span class="comment">    SourceHive - pointer to hive control structure for source</span>
01024 <span class="comment"></span>
01025 <span class="comment">    SourceCell - index of cell to copy from</span>
01026 <span class="comment"></span>
01027 <span class="comment">    TargetHive - pointer to hive control structure for target</span>
01028 <span class="comment"></span>
01029 <span class="comment">    Type - storage type (stable or volatile) of new cell</span>
01030 <span class="comment"></span>
01031 <span class="comment">Return Value:</span>
01032 <span class="comment"></span>
01033 <span class="comment">    HCELL_INDEX of new cell, or HCELL_NIL if failure.</span>
01034 <span class="comment"></span>
01035 <span class="comment">--*/</span>
01036 {
01037     PVOID   psource;
01038     PVOID   ptarget;
01039     ULONG   size;
01040     <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a> newcell;
01041 
01042     <a class="code" href="../../d1/d2/cmp_8h.html#a55">CMLOG</a>(<a class="code" href="../../d1/d2/cmp_8h.html#a23">CML_MINOR</a>, <a class="code" href="../../d1/d2/cmp_8h.html#a32">CMS_SAVRES</a>) {
01043         KdPrint((<span class="stringliteral">"CmpCopyCell:\n"</span>));
01044         KdPrint((<span class="stringliteral">"\tSourceHive=%08lx SourceCell=%08lx\n"</span>,SourceHive,SourceCell));
01045         KdPrint((<span class="stringliteral">"\tTargetHive=%08lx\n"</span>,TargetHive));
01046     }
01047 
01048     psource = <a class="code" href="../../d6/d0/hive_8h.html#a12">HvGetCell</a>(SourceHive, SourceCell);
01049     size = <a class="code" href="../../d8/d0/hivecell_8c.html#a15">HvGetCellSize</a>(SourceHive, psource);
01050 
01051     newcell = <a class="code" href="../../d8/d0/hivecell_8c.html#a16">HvAllocateCell</a>(TargetHive, size, Type);
01052     <span class="keywordflow">if</span> (newcell == <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>) {
01053         <span class="keywordflow">return</span> <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>;
01054     }
01055 
01056     ptarget = <a class="code" href="../../d6/d0/hive_8h.html#a12">HvGetCell</a>(TargetHive, newcell);
01057 
01058     RtlCopyMemory(ptarget, psource, size);
01059 
01060     <span class="keywordflow">return</span> newcell;
01061 }
01062 
01063 BOOLEAN
<a name="l01064"></a><a class="code" href="../../d2/d3/cmtrecpy_8c.html#a4">01064</a> <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a4">CmpFreeKeyValues</a>(
01065     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a> Hive,
01066     HCELL_INDEX Cell,
01067     <a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html">PCM_KEY_NODE</a> Node
01068     )
01069 <span class="comment">/*++</span>
01070 <span class="comment"></span>
01071 <span class="comment">Routine Description:</span>
01072 <span class="comment"></span>
01073 <span class="comment">   Free the cells associated with the value entries, the security descriptor,</span>
01074 <span class="comment">   and the class of a particular key.   </span>
01075 <span class="comment"></span>
01076 <span class="comment">Arguments:</span>
01077 <span class="comment"></span>
01078 <span class="comment">   Hive        - The hive of the key in question</span>
01079 <span class="comment">   Cell        - The cell of the key in question</span>
01080 <span class="comment">   Node        - The key body of the key in question</span>
01081 <span class="comment"></span>
01082 <span class="comment">Return Value:</span>
01083 <span class="comment"></span>
01084 <span class="comment">   TRUE if successful, FALSE otherwise.</span>
01085 <span class="comment"></span>
01086 <span class="comment">--*/</span>
01087 {    
01088     <a class="code" href="../../d4/d9/struct__CELL__DATA.html">PCELL_DATA</a>  plist;
01089     ULONG       i;
01090 
01091     <span class="comment">//</span>
01092     <span class="comment">// Mark all the value-related cells dirty </span>
01093     <span class="comment">//</span>
01094 
01095     <span class="keywordflow">if</span> (! <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a8">CmpMarkKeyValuesDirty</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>, <a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>, Node)) {
01096         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01097     }
01098     
01099     <span class="comment">//</span>
01100     <span class="comment">// Link nodes don't have things that we need to free</span>
01101     <span class="comment">//</span>
01102 
01103     <span class="keywordflow">if</span> (!(Node-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o1">Flags</a> &amp; <a class="code" href="../../d9/d0/cmdata_8h.html#a28">KEY_HIVE_EXIT</a>)) {
01104 
01105         <span class="comment">//</span>
01106         <span class="comment">// First, free the value entries</span>
01107         <span class="comment">//</span>
01108         <span class="keywordflow">if</span> (Node-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o7">ValueList</a>.<a class="code" href="../../d7/d9/struct__CHILD__LIST.html#o0">Count</a> &gt; 0) {
01109 
01110             <span class="comment">// Get value list</span>
01111             plist = <a class="code" href="../../d6/d0/hive_8h.html#a12">HvGetCell</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>, Node-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o7">ValueList</a>.<a class="code" href="../../d7/d9/struct__CHILD__LIST.html#o1">List</a>);
01112 
01113             <span class="comment">// Free each value</span>
01114             <span class="keywordflow">for</span> (i = 0; i &lt; Node-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o7">ValueList</a>.<a class="code" href="../../d7/d9/struct__CHILD__LIST.html#o0">Count</a>; i++) {
01115                 <a class="code" href="../../d9/d2/cmsubs2_8c.html#a3">CmpFreeValue</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>, plist-&gt;<a class="code" href="../../d4/d9/struct__CELL__DATA.html#o0">u</a>.<a class="code" href="../../d5/d9/union__CELL__DATA_1_1__u.html#o4">KeyList</a>[i]);
01116             }
01117 
01118             <span class="comment">// Free the value list</span>
01119             <a class="code" href="../../d8/d0/hivecell_8c.html#a17">HvFreeCell</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>, Node-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o7">ValueList</a>.<a class="code" href="../../d7/d9/struct__CHILD__LIST.html#o1">List</a>);
01120         }
01121 
01122         <span class="comment">//</span>
01123         <span class="comment">// Make this key value-less</span>
01124         <span class="comment">//</span>
01125 
01126         Node-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o7">ValueList</a>.<a class="code" href="../../d7/d9/struct__CHILD__LIST.html#o1">List</a> = <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>;
01127         Node-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o7">ValueList</a>.<a class="code" href="../../d7/d9/struct__CHILD__LIST.html#o0">Count</a> = 0;
01128 
01129         <span class="comment">//</span>
01130         <span class="comment">// Free the security descriptor</span>
01131         <span class="comment">//</span>
01132         <a class="code" href="../../d6/d3/cmwraper_8c.html#a12">CmpFreeSecurityDescriptor</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>, <a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>);
01133 
01134         <span class="comment">//</span>
01135         <span class="comment">// Free the Class information</span>
01136         <span class="comment">//</span>
01137 
01138         <span class="keywordflow">if</span> (Node-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o17">ClassLength</a> &gt; 0) {
01139             <a class="code" href="../../d8/d0/hivecell_8c.html#a17">HvFreeCell</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>, Node-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o10">Class</a>);
01140             Node-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o10">Class</a> = <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>;
01141             Node-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o17">ClassLength</a> = 0;
01142         }
01143         
01144     }
01145 
01146     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01147 }
01148 
01149 BOOLEAN
<a name="l01150"></a><a class="code" href="../../d6/d2/cmsavres_8c.html#a13">01150</a> <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a6">CmpMergeKeyValues</a>(
01151     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>  SourceHive,
01152     HCELL_INDEX SourceKeyCell,
01153     <a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html">PCM_KEY_NODE</a> SourceKeyNode,
01154     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>  TargetHive,
01155     HCELL_INDEX TargetKeyCell,
01156     <a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html">PCM_KEY_NODE</a> TargetKeyNode
01157     )
01158 <span class="comment">/*++</span>
01159 <span class="comment"></span>
01160 <span class="comment">Routine Description:</span>
01161 <span class="comment">    Merges the values from the two key-nodes provided.</span>
01162 <span class="comment">    Rules for the merge:</span>
01163 <span class="comment">    1. The target values are not touched!</span>
01164 <span class="comment">    2. Only values from the source that are not present in the </span>
01165 <span class="comment">    target are taken into account by this routine. They are added</span>
01166 <span class="comment">    to the target node value list "as they are".</span>
01167 <span class="comment"></span>
01168 <span class="comment">Arguments:</span>
01169 <span class="comment"></span>
01170 <span class="comment">   SourceHive     - Hive of the source key</span>
01171 <span class="comment">   SourceKeyCell  - The source key's cell</span>
01172 <span class="comment">   SourceKeyNode  - The source key's body</span>
01173 <span class="comment">   </span>
01174 <span class="comment">   TargetHive     - Hive of the target key</span>
01175 <span class="comment">   TargetKeyCell  - The target key's cell</span>
01176 <span class="comment">   TargetKeyNode  - The target key's body</span>
01177 <span class="comment"></span>
01178 <span class="comment">Return Value:</span>
01179 <span class="comment"></span>
01180 <span class="comment">   TRUE of successful, FALSE otherwise.</span>
01181 <span class="comment"></span>
01182 <span class="comment">--*/</span>
01183 {
01184     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>    status;    
01185     BOOLEAN success = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;    
01186     <a class="code" href="../../d4/d9/struct__CELL__DATA.html">PCELL_DATA</a> psrclist, ptarlist;
01187     <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a> newvalue, newlist = <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>;    
01188     ULONG i, count, Type;
01189     <a class="code" href="../../d7/d5/struct__CM__KEY__VALUE.html">PCM_KEY_VALUE</a> poldvalue;
01190     WCHAR *NameBuffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01191     UNICODE_STRING <a class="code" href="../../d1/d1/rtdelval_8c.html#a3">ValueName</a>;
01192 
01193 
01194     <span class="keywordflow">if</span>(TargetKeyNode-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o13">MaxValueNameLen</a> &lt; SourceKeyNode-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o13">MaxValueNameLen</a>) {
01195         TargetKeyNode-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o13">MaxValueNameLen</a> = SourceKeyNode-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o13">MaxValueNameLen</a>;
01196     }
01197 
01198     <span class="keywordflow">if</span>(TargetKeyNode-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o14">MaxValueDataLen</a> &lt; SourceKeyNode-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o14">MaxValueDataLen</a>) {
01199         TargetKeyNode-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o14">MaxValueDataLen</a> = SourceKeyNode-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o14">MaxValueDataLen</a>;
01200     }
01201 
01202     <span class="keywordflow">if</span>(TargetKeyNode-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o7">ValueList</a>.<a class="code" href="../../d7/d9/struct__CHILD__LIST.html#o0">Count</a> == 0) {
01203         <span class="comment">//</span>
01204         <span class="comment">// No Values in Target, do a sync</span>
01205         <span class="comment">//</span>
01206         <span class="keywordflow">return</span> <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a5">CmpSyncKeyValues</a>(SourceHive, SourceKeyCell, SourceKeyNode, TargetHive, TargetKeyCell, TargetKeyNode);
01207     }
01208     <span class="comment">//</span>
01209     <span class="comment">// Set up the value list</span>
01210     <span class="comment">//</span>
01211     count = SourceKeyNode-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o7">ValueList</a>.<a class="code" href="../../d7/d9/struct__CHILD__LIST.html#o0">Count</a>;
01212 
01213     <span class="keywordflow">if</span> (count == 0) {
01214 
01215         <span class="comment">// No values in source, no update to the list needed.</span>
01216         success = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01217     } <span class="keywordflow">else</span> {        
01218 
01219         NameBuffer = <a class="code" href="../../d5/d5/cc_8h.html#a10">ExAllocatePool</a>(<a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>, <a class="code" href="../../d9/d0/cmdata_8h.html#a3">MAX_KEY_VALUE_NAME_LENGTH</a>);
01220         <span class="keywordflow">if</span>(!NameBuffer) <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01221 
01222         <span class="comment">//</span>
01223         <span class="comment">// The type of the new cells will be the same as that</span>
01224         <span class="comment">// of the target cell.</span>
01225         <span class="comment">//</span>
01226 
01227         Type = <a class="code" href="../../d0/d1/hivedata_8h.html#a19">HvGetCellType</a>(TargetKeyCell);    
01228 
01229         <span class="comment">//</span>
01230         <span class="comment">// Reallocate the value list for target to fit the new size</span>
01231         <span class="comment">// Worst case: all values from the source node will be added </span>
01232         <span class="comment">// to the target node</span>
01233         <span class="comment">//</span>
01234 
01235         psrclist = <a class="code" href="../../d6/d0/hive_8h.html#a12">HvGetCell</a>(SourceHive, SourceKeyNode-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o7">ValueList</a>.<a class="code" href="../../d7/d9/struct__CHILD__LIST.html#o1">List</a>);
01236 
01237         newlist = <a class="code" href="../../d8/d0/hivecell_8c.html#a20">HvReallocateCell</a>(
01238                     TargetHive,
01239                     TargetKeyNode-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o7">ValueList</a>.<a class="code" href="../../d7/d9/struct__CHILD__LIST.html#o1">List</a>,
01240                     (TargetKeyNode-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o7">ValueList</a>.<a class="code" href="../../d7/d9/struct__CHILD__LIST.html#o0">Count</a> + count) * <span class="keyword">sizeof</span>(<a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a>)
01241                     );
01242 
01243         <span class="comment">// Growing up may fail</span>
01244         <span class="keywordflow">if</span> (newlist == <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>) {
01245             <span class="keywordflow">goto</span> EndValueMerge;
01246         }
01247         TargetKeyNode-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o7">ValueList</a>.<a class="code" href="../../d7/d9/struct__CHILD__LIST.html#o1">List</a> = newlist;
01248         ptarlist = <a class="code" href="../../d6/d0/hive_8h.html#a12">HvGetCell</a>(TargetHive, newlist);
01249 
01250 
01251         <span class="comment">//</span>
01252         <span class="comment">// Copy the values</span>
01253         <span class="comment">//</span>
01254         <span class="keywordflow">for</span> (i = 0; i &lt; count; i++) {
01255 
01256             poldvalue = (<a class="code" href="../../d7/d5/struct__CM__KEY__VALUE.html">PCM_KEY_VALUE</a>)<a class="code" href="../../d6/d0/hive_8h.html#a12">HvGetCell</a>(SourceHive, psrclist-&gt;<a class="code" href="../../d4/d9/struct__CELL__DATA.html#o0">u</a>.<a class="code" href="../../d5/d9/union__CELL__DATA_1_1__u.html#o4">KeyList</a>[i]);
01257             
01258             <span class="comment">//</span>
01259             <span class="comment">// get the name</span>
01260             <span class="comment">//</span>
01261             <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a15">CmpInitializeValueNameString</a>(poldvalue,&amp;<a class="code" href="../../d1/d1/rtdelval_8c.html#a3">ValueName</a>,NameBuffer);
01262 
01263 
01264             <span class="comment">//</span>
01265             <span class="comment">// check if this particular values doesn't exist in the target node already</span>
01266             <span class="comment">//</span>
01267             <span class="keywordflow">if</span>(<a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a> == <a class="code" href="../../d4/d3/cmtree_8c.html#a0">CmpFindNameInList</a>(TargetHive,&amp;(TargetKeyNode-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o7">ValueList</a>),&amp;<a class="code" href="../../d1/d1/rtdelval_8c.html#a3">ValueName</a>,<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
01268 
01269                 <span class="comment">//</span>
01270                 <span class="comment">// No, it doesn't, so add it</span>
01271                 <span class="comment">//</span>
01272                 newvalue = <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a12">CmpCopyValue</a>(
01273                                 SourceHive,
01274                                 psrclist-&gt;<a class="code" href="../../d4/d9/struct__CELL__DATA.html#o0">u</a>.<a class="code" href="../../d5/d9/union__CELL__DATA_1_1__u.html#o4">KeyList</a>[i],
01275                                 TargetHive,
01276                                 Type
01277                                 );
01278 
01279                 <span class="keywordflow">if</span> (newvalue != <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>) {
01280 
01281                     ptarlist-&gt;<a class="code" href="../../d4/d9/struct__CELL__DATA.html#o0">u</a>.<a class="code" href="../../d5/d9/union__CELL__DATA_1_1__u.html#o4">KeyList</a>[TargetKeyNode-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o7">ValueList</a>.<a class="code" href="../../d7/d9/struct__CHILD__LIST.html#o0">Count</a>++] = newvalue;
01282 
01283                 } <span class="keywordflow">else</span> {
01284 
01285                     <span class="comment">// Delete all the copied values on an error.</span>
01286 
01287                     <span class="keywordflow">for</span> (; i &gt; 0; i--) {
01288                         <a class="code" href="../../d8/d0/hivecell_8c.html#a17">HvFreeCell</a>(
01289                             TargetHive,
01290                             ptarlist-&gt;<a class="code" href="../../d4/d9/struct__CELL__DATA.html#o0">u</a>.<a class="code" href="../../d5/d9/union__CELL__DATA_1_1__u.html#o4">KeyList</a>[--TargetKeyNode-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o7">ValueList</a>.<a class="code" href="../../d7/d9/struct__CHILD__LIST.html#o0">Count</a>]
01291                             );
01292                     }
01293                     <span class="keywordflow">goto</span> EndValueMerge;
01294                 }
01295             }
01296         }
01297 
01298         <span class="comment">//</span>
01299         <span class="comment">// adjust the Value list to the new count. </span>
01300         <span class="comment">// This call shouldn't fail (the new size is smaller or in the worst case equal to the old one)</span>
01301         <span class="comment">//</span>
01302         newlist = <a class="code" href="../../d8/d0/hivecell_8c.html#a20">HvReallocateCell</a>(
01303                     TargetHive,
01304                     TargetKeyNode-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o7">ValueList</a>.<a class="code" href="../../d7/d9/struct__CHILD__LIST.html#o1">List</a>,
01305                     TargetKeyNode-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o7">ValueList</a>.<a class="code" href="../../d7/d9/struct__CHILD__LIST.html#o0">Count</a> * <span class="keyword">sizeof</span>(<a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a>)
01306                     );
01307 
01308         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(newlist != <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>);
01309         TargetKeyNode-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o7">ValueList</a>.<a class="code" href="../../d7/d9/struct__CHILD__LIST.html#o1">List</a> = newlist;
01310 
01311         success = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01312     }
01313 
01314 EndValueMerge:
01315     <span class="keywordflow">if</span> (NameBuffer) <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(NameBuffer);
01316 
01317     <span class="keywordflow">if</span> (success == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01318 
01319         <span class="comment">// Clean-up on failure</span>
01320         <span class="comment">// Revert to the original size</span>
01321         <span class="keywordflow">if</span> (newlist != <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>) {
01322             newlist = <a class="code" href="../../d8/d0/hivecell_8c.html#a20">HvReallocateCell</a>(
01323                         TargetHive,
01324                         TargetKeyNode-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o7">ValueList</a>.<a class="code" href="../../d7/d9/struct__CHILD__LIST.html#o1">List</a>,
01325                         TargetKeyNode-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o7">ValueList</a>.<a class="code" href="../../d7/d9/struct__CHILD__LIST.html#o0">Count</a> * <span class="keyword">sizeof</span>(<a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a>)
01326                         );
01327 
01328             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(newlist != <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>);
01329             TargetKeyNode-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o7">ValueList</a>.<a class="code" href="../../d7/d9/struct__CHILD__LIST.html#o1">List</a> = newlist;
01330         }
01331 
01332     }
01333 
01334     <span class="keywordflow">return</span> success;
01335 }
01336     
01337 BOOLEAN
<a name="l01338"></a><a class="code" href="../../d2/d3/cmtrecpy_8c.html#a5">01338</a> <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a5">CmpSyncKeyValues</a>(
01339     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>  SourceHive,
01340     HCELL_INDEX SourceKeyCell,
01341     <a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html">PCM_KEY_NODE</a> SourceKeyNode,
01342     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a>  TargetHive,
01343     HCELL_INDEX TargetKeyCell,
01344     <a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html">PCM_KEY_NODE</a> TargetKeyNode
01345     )
01346 <span class="comment">/*++</span>
01347 <span class="comment"></span>
01348 <span class="comment">Routine Description:</span>
01349 <span class="comment"></span>
01350 <span class="comment">    Synchronizes the value entries, security descriptor, and class of a </span>
01351 <span class="comment">    target key with that of a source key - ensuring that the keys are </span>
01352 <span class="comment">    identical with respect to the synchronized information.</span>
01353 <span class="comment"></span>
01354 <span class="comment">Arguments:</span>
01355 <span class="comment"></span>
01356 <span class="comment">   SourceHive     - Hive of the source key</span>
01357 <span class="comment">   SourceKeyCell  - The source key's cell</span>
01358 <span class="comment">   SourceKeyNode  - The source key's body</span>
01359 <span class="comment">   </span>
01360 <span class="comment">   TargetHive     - Hive of the target key</span>
01361 <span class="comment">   TargetKeyCell  - The target key's cell</span>
01362 <span class="comment">   TargetKeyNode  - The target key's body</span>
01363 <span class="comment"></span>
01364 <span class="comment">Return Value:</span>
01365 <span class="comment"></span>
01366 <span class="comment">   TRUE of successful, FALSE otherwise.</span>
01367 <span class="comment"></span>
01368 <span class="comment">--*/</span>
01369 {
01370     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>    status;    
01371     BOOLEAN success = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;    
01372     <a class="code" href="../../d4/d9/struct__CELL__DATA.html">PCELL_DATA</a> psrclist, ptarlist, psrcsecurity;
01373     <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a> newvalue, newlist = <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>, newclass = <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>, newsecurity = <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>;    
01374     ULONG i, count, Type;
01375 
01376     <span class="comment">//</span>
01377     <span class="comment">// First, free the target key's values, sd, and class info.</span>
01378     <span class="comment">//</span>
01379 
01380     <span class="keywordflow">if</span>(!<a class="code" href="../../d2/d3/cmtrecpy_8c.html#a4">CmpFreeKeyValues</a>(TargetHive, TargetKeyCell, TargetKeyNode))
01381        <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01382 
01383     <span class="comment">//</span>
01384     <span class="comment">// Now, copy the values, class, &amp; sd from the source cell</span>
01385     <span class="comment">//</span>
01386 
01387     <span class="comment">//</span>
01388     <span class="comment">// The type of the new cells will be the same as that</span>
01389     <span class="comment">// of the target cell.</span>
01390     <span class="comment">//</span>
01391 
01392     Type = <a class="code" href="../../d0/d1/hivedata_8h.html#a19">HvGetCellType</a>(TargetKeyCell);    
01393     
01394     <span class="comment">//</span>
01395     <span class="comment">// Allocate and copy class</span>
01396     <span class="comment">//</span>
01397     <span class="keywordflow">if</span> ((SourceKeyNode-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o17">ClassLength</a> &gt; 0) &amp;&amp; (SourceKeyNode-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o10">Class</a> != <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>)) {
01398         newclass = <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a13">CmpCopyCell</a>(SourceHive, SourceKeyNode-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o10">Class</a>, TargetHive, Type);
01399         <span class="keywordflow">if</span> (newclass == <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>) {
01400             <span class="keywordflow">goto</span> EndValueSync;
01401         }
01402         
01403         <span class="comment">// only if class is valid. Otherwise remains 0 (set by CmpFreeKeyValues)</span>
01404         TargetKeyNode-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o17">ClassLength</a> = SourceKeyNode-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o17">ClassLength</a>;
01405     }
01406 
01407     <span class="comment">//</span>
01408     <span class="comment">// Associate the new class with the target key</span>
01409     <span class="comment">// and prepare and security descriptor assignment.</span>
01410     <span class="comment">//</span>
01411 
01412     TargetKeyNode-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o10">Class</a> = newclass;
01413     TargetKeyNode-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o9">Security</a> = <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>;            
01414 
01415     <span class="comment">//</span>
01416     <span class="comment">// Allocate and assign security</span>
01417     <span class="comment">//</span>
01418     psrcsecurity = <a class="code" href="../../d6/d0/hive_8h.html#a12">HvGetCell</a>(SourceHive, SourceKeyNode-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o9">Security</a>);
01419 
01420     status = <a class="code" href="../../d7/d2/cmse_8c.html#a10">CmpAssignSecurityDescriptor</a>(TargetHive,
01421                                          TargetKeyCell,
01422                                          TargetKeyNode,
01423                                          &amp;(psrcsecurity-&gt;<a class="code" href="../../d4/d9/struct__CELL__DATA.html#o0">u</a>.<a class="code" href="../../d5/d9/union__CELL__DATA_1_1__u.html#o2">KeySecurity</a>.<a class="code" href="../../d6/d5/struct__CM__KEY__SECURITY.html#o6">Descriptor</a>));
01424     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
01425         <span class="keywordflow">goto</span> EndValueSync;
01426     }
01427 
01428     <span class="comment">//</span>
01429     <span class="comment">// Set up the value list</span>
01430     <span class="comment">//</span>
01431     count = SourceKeyNode-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o7">ValueList</a>.<a class="code" href="../../d7/d9/struct__CHILD__LIST.html#o0">Count</a>;
01432 
01433     <span class="keywordflow">if</span> (count == 0) {
01434 
01435         <span class="comment">// No values in source, no list needed.</span>
01436 
01437         TargetKeyNode-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o7">ValueList</a>.<a class="code" href="../../d7/d9/struct__CHILD__LIST.html#o1">List</a> = <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>;
01438         TargetKeyNode-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o7">ValueList</a>.<a class="code" href="../../d7/d9/struct__CHILD__LIST.html#o0">Count</a> = 0;
01439         success = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01440     } <span class="keywordflow">else</span> {        
01441 
01442         <span class="comment">// Allocate the value list for target</span>
01443 
01444         psrclist = <a class="code" href="../../d6/d0/hive_8h.html#a12">HvGetCell</a>(SourceHive, SourceKeyNode-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o7">ValueList</a>.<a class="code" href="../../d7/d9/struct__CHILD__LIST.html#o1">List</a>);
01445 
01446         newlist = <a class="code" href="../../d8/d0/hivecell_8c.html#a16">HvAllocateCell</a>(
01447                     TargetHive,
01448                     count * <span class="keyword">sizeof</span>(<a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a>),
01449                     Type
01450                     );
01451         <span class="keywordflow">if</span> (newlist == <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>) {
01452             <span class="keywordflow">goto</span> EndValueSync;
01453         }
01454         TargetKeyNode-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o7">ValueList</a>.<a class="code" href="../../d7/d9/struct__CHILD__LIST.html#o1">List</a> = newlist;
01455         ptarlist = <a class="code" href="../../d6/d0/hive_8h.html#a12">HvGetCell</a>(TargetHive, newlist);
01456 
01457 
01458         <span class="comment">//</span>
01459         <span class="comment">// Copy the values</span>
01460         <span class="comment">//</span>
01461         <span class="keywordflow">for</span> (i = 0; i &lt; count; i++) {
01462 
01463             newvalue = <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a12">CmpCopyValue</a>(
01464                             SourceHive,
01465                             psrclist-&gt;<a class="code" href="../../d4/d9/struct__CELL__DATA.html#o0">u</a>.<a class="code" href="../../d5/d9/union__CELL__DATA_1_1__u.html#o4">KeyList</a>[i],
01466                             TargetHive,
01467                             Type
01468                             );
01469 
01470             <span class="keywordflow">if</span> (newvalue != <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>) {
01471 
01472                 ptarlist-&gt;<a class="code" href="../../d4/d9/struct__CELL__DATA.html#o0">u</a>.<a class="code" href="../../d5/d9/union__CELL__DATA_1_1__u.html#o4">KeyList</a>[i] = newvalue;
01473 
01474             } <span class="keywordflow">else</span> {
01475 
01476                 <span class="comment">// Delete all the copied values on an error.</span>
01477 
01478                 <span class="keywordflow">for</span> (; i &gt; 0; i--) {
01479                     <a class="code" href="../../d8/d0/hivecell_8c.html#a17">HvFreeCell</a>(
01480                         TargetHive,
01481                         ptarlist-&gt;<a class="code" href="../../d4/d9/struct__CELL__DATA.html#o0">u</a>.<a class="code" href="../../d5/d9/union__CELL__DATA_1_1__u.html#o4">KeyList</a>[i - 1]
01482                         );
01483                 }
01484                 <span class="keywordflow">goto</span> EndValueSync;
01485             }
01486         }
01487 
01488         TargetKeyNode-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o7">ValueList</a>.<a class="code" href="../../d7/d9/struct__CHILD__LIST.html#o0">Count</a> = count;
01489         success = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01490     }
01491 
01492 EndValueSync:
01493     <span class="keywordflow">if</span> (success == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01494 
01495         <span class="comment">// Clean-up on failure</span>
01496 
01497         <span class="keywordflow">if</span> (newlist != <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>) {
01498             <a class="code" href="../../d8/d0/hivecell_8c.html#a17">HvFreeCell</a>(TargetHive, newlist);
01499         }
01500 
01501         <span class="keywordflow">if</span> (newsecurity != <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>) {
01502             <a class="code" href="../../d8/d0/hivecell_8c.html#a17">HvFreeCell</a>(TargetHive, newsecurity);
01503         }
01504 
01505         <span class="keywordflow">if</span> (newclass != <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>) {
01506             <a class="code" href="../../d8/d0/hivecell_8c.html#a17">HvFreeCell</a>(TargetHive, newclass);
01507         }
01508 
01509     }
01510 
01511     <span class="keywordflow">return</span> success;
01512 }
01513 
01514 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a> 
<a name="l01515"></a><a class="code" href="../../d2/d3/cmtrecpy_8c.html#a14">01515</a> <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a14">CmpInitializeKeyNameString</a>(<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html">PCM_KEY_NODE</a> Cell, 
01516                            PUNICODE_STRING KeyName,
01517                            WCHAR *NameBuffer
01518                            )
01519 <span class="comment">/*++</span>
01520 <span class="comment"></span>
01521 <span class="comment">Routine Description:</span>
01522 <span class="comment"></span>
01523 <span class="comment">   Initializes a UNICODE_STRING with the name of a given key.</span>
01524 <span class="comment">   </span>
01525 <span class="comment">   N.B. The initialized string's buffer is not meant</span>
01526 <span class="comment">         to be modified.   </span>
01527 <span class="comment"></span>
01528 <span class="comment">Arguments:</span>
01529 <span class="comment"></span>
01530 <span class="comment">   Cell       - The body of the key in question</span>
01531 <span class="comment">   KeyName    - The UNICODE_STRING to initialize</span>
01532 <span class="comment">   NameBuffer - A buffer MAX_KEY_NAME_LENGTH bytes in size </span>
01533 <span class="comment">                that will possibly be used as the UNICODE_STRING's </span>
01534 <span class="comment">                buffer.</span>
01535 <span class="comment"></span>
01536 <span class="comment">Return Value:</span>
01537 <span class="comment"></span>
01538 <span class="comment">   NONE.</span>
01539 <span class="comment"></span>
01540 <span class="comment">--*/</span>
01541 {                        
01542    <span class="comment">// is the name stored in compressed form?</span>
01543 
01544    <span class="keywordflow">if</span>(<a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>-&gt;Flags &amp; <a class="code" href="../../d9/d0/cmdata_8h.html#a32">KEY_COMP_NAME</a>) {
01545 
01546       <span class="comment">// Name is compressed. </span>
01547 
01548       <span class="comment">// Get the uncompressed length.</span>
01549                         
01550       <a class="code" href="../../d8/d0/rtbatcr_8c.html#a3">KeyName</a>-&gt;Length = <a class="code" href="../../d1/d2/cmp_8h.html#a320">CmpCompressedNameSize</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>-&gt;Name,
01551                                               <a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>-&gt;NameLength);
01552                         
01553       <span class="comment">// Decompress the name into a buffer.</span>
01554 
01555       <a class="code" href="../../d1/d2/cmp_8h.html#a318">CmpCopyCompressedName</a>(NameBuffer, 
01556                             <a class="code" href="../../d9/d0/cmdata_8h.html#a1">MAX_KEY_NAME_LENGTH</a>,
01557                             <a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>-&gt;Name,                                            
01558                             <a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>-&gt;NameLength);
01559 
01560       <span class="comment">//</span>
01561       <span class="comment">// Use the decompression buffer as the string buffer</span>
01562       <span class="comment">//</span>
01563                         
01564       <a class="code" href="../../d8/d0/rtbatcr_8c.html#a3">KeyName</a>-&gt;Buffer = NameBuffer;      
01565       <a class="code" href="../../d8/d0/rtbatcr_8c.html#a3">KeyName</a>-&gt;MaximumLength = <a class="code" href="../../d9/d0/cmdata_8h.html#a1">MAX_KEY_NAME_LENGTH</a>;
01566 
01567    } <span class="keywordflow">else</span> {
01568 
01569       <span class="comment">//</span>
01570       <span class="comment">// Name is not compressed. Just use the name string </span>
01571       <span class="comment">// from the key buffer as the string buffer.</span>
01572       <span class="comment">//</span>
01573                         
01574       <a class="code" href="../../d8/d0/rtbatcr_8c.html#a3">KeyName</a>-&gt;Length = <a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>-&gt;NameLength;                        
01575       <a class="code" href="../../d8/d0/rtbatcr_8c.html#a3">KeyName</a>-&gt;Buffer = <a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>-&gt;Name;
01576       <a class="code" href="../../d8/d0/rtbatcr_8c.html#a3">KeyName</a>-&gt;MaximumLength = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>-&gt;MaxNameLen;
01577                      
01578    }                                             
01579 }
01580 
01581 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a> 
<a name="l01582"></a><a class="code" href="../../d2/d3/cmtrecpy_8c.html#a15">01582</a> <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a15">CmpInitializeValueNameString</a>(<a class="code" href="../../d7/d5/struct__CM__KEY__VALUE.html">PCM_KEY_VALUE</a> Cell, 
01583                              PUNICODE_STRING ValueName,
01584                              WCHAR *NameBuffer
01585                              )
01586 <span class="comment">/*</span>
01587 <span class="comment">Routine Description:</span>
01588 <span class="comment"></span>
01589 <span class="comment">   Initializes a UNICODE_STRING with the name of a given value key.</span>
01590 <span class="comment">   </span>
01591 <span class="comment">   N.B. The initialized string's buffer is not meant</span>
01592 <span class="comment">         to be modified.   </span>
01593 <span class="comment"></span>
01594 <span class="comment">Arguments:</span>
01595 <span class="comment"></span>
01596 <span class="comment">   Cell       - The value key in question</span>
01597 <span class="comment">   ValueName    - The UNICODE_STRING to initialize</span>
01598 <span class="comment">   NameBuffer - A buffer MAX_KEY_NAME_LENGTH bytes in size </span>
01599 <span class="comment">                that will possibly be used as the UNICODE_STRING's </span>
01600 <span class="comment">                buffer.</span>
01601 <span class="comment"></span>
01602 <span class="comment">Return Value:</span>
01603 <span class="comment"></span>
01604 <span class="comment">   NONE.</span>
01605 <span class="comment">*/</span>
01606 
01607 {                        
01608    <span class="comment">// is the name stored in compressed form?</span>
01609 
01610    <span class="keywordflow">if</span>(<a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>-&gt;Flags &amp; <a class="code" href="../../d9/d0/cmdata_8h.html#a37">VALUE_COMP_NAME</a>) {
01611 
01612       <span class="comment">// Name is compressed. </span>
01613 
01614       <span class="comment">// Get the uncompressed length.</span>
01615                         
01616       <a class="code" href="../../d1/d1/rtdelval_8c.html#a3">ValueName</a>-&gt;Length = <a class="code" href="../../d1/d2/cmp_8h.html#a320">CmpCompressedNameSize</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>-&gt;Name,
01617                                               <a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>-&gt;NameLength);
01618                         
01619       <span class="comment">// Decompress the name into a buffer.</span>
01620 
01621       <a class="code" href="../../d1/d2/cmp_8h.html#a318">CmpCopyCompressedName</a>(NameBuffer, 
01622                             <a class="code" href="../../d9/d0/cmdata_8h.html#a3">MAX_KEY_VALUE_NAME_LENGTH</a>,
01623                             <a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>-&gt;Name,                                            
01624                             <a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>-&gt;NameLength);
01625 
01626       <span class="comment">//</span>
01627       <span class="comment">// Use the decompression buffer as the string buffer</span>
01628       <span class="comment">//</span>
01629                         
01630       <a class="code" href="../../d1/d1/rtdelval_8c.html#a3">ValueName</a>-&gt;Buffer = NameBuffer;      
01631       <a class="code" href="../../d1/d1/rtdelval_8c.html#a3">ValueName</a>-&gt;MaximumLength = <a class="code" href="../../d9/d0/cmdata_8h.html#a3">MAX_KEY_VALUE_NAME_LENGTH</a>;
01632 
01633    } <span class="keywordflow">else</span> {
01634 
01635       <span class="comment">//</span>
01636       <span class="comment">// Name is not compressed. Just use the name string </span>
01637       <span class="comment">// from the ValueName buffer as the string buffer.</span>
01638       <span class="comment">//</span>
01639                         
01640       <a class="code" href="../../d1/d1/rtdelval_8c.html#a3">ValueName</a>-&gt;Length = <a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>-&gt;NameLength;                        
01641       <a class="code" href="../../d1/d1/rtdelval_8c.html#a3">ValueName</a>-&gt;Buffer = <a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>-&gt;Name;
01642       <a class="code" href="../../d1/d1/rtdelval_8c.html#a3">ValueName</a>-&gt;MaximumLength = <a class="code" href="../../d1/d1/rtdelval_8c.html#a3">ValueName</a>-&gt;Length;
01643                      
01644    }                                             
01645 }
01646 
01647 BOOLEAN
<a name="l01648"></a><a class="code" href="../../d2/d3/cmtrecpy_8c.html#a7">01648</a> <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a7">CmpSyncSubKeysAfterDelete</a>(<a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a> SourceHive,
01649                           <a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html">PCM_KEY_NODE</a> SourceCell,
01650                           <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a> TargetHive,
01651                           <a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html">PCM_KEY_NODE</a> TargetCell,
01652                           WCHAR *NameBuffer)
01653 <span class="comment">/*++</span>
01654 <span class="comment"></span>
01655 <span class="comment">Routine Description:</span>
01656 <span class="comment"></span>
01657 <span class="comment">   This routine makes sure that any subkeys present in the target key</span>
01658 <span class="comment">   but not present in the source key are deleted from the target key</span>
01659 <span class="comment">   along with any trees under those subkeys.</span>
01660 <span class="comment">   </span>
01661 <span class="comment">   This routine is useful for synchronizing key deletion changes</span>
01662 <span class="comment">   in a source cell with a target cell. It is used in this way</span>
01663 <span class="comment">   from CmpCopySyncTree.</span>
01664 <span class="comment">   </span>
01665 <span class="comment">   NOTE: It is assumed that no open handles are held for the keys</span>
01666 <span class="comment">         being deleted. If this is not so, registry in-memory</span>
01667 <span class="comment">         data structures may become corrupted.</span>
01668 <span class="comment">   </span>
01669 <span class="comment">Arguments:</span>
01670 <span class="comment"></span>
01671 <span class="comment">   SourceHive  - The hive of the source key</span>
01672 <span class="comment">   SourceCell  - The body of the source key</span>
01673 <span class="comment">   TargetHive  - The hive of the target key</span>
01674 <span class="comment">   TargetCell  - The body of the target key</span>
01675 <span class="comment">   NameBuffer  - A buffer MAX_KEY_NAME_LENGTH bytes in size</span>
01676 <span class="comment"></span>
01677 <span class="comment">Return Value:</span>
01678 <span class="comment"></span>
01679 <span class="comment">   TRUE if successful, FALSE otherwise.</span>
01680 <span class="comment"></span>
01681 <span class="comment">--*/</span>
01682 {
01683    <a class="code" href="../../d0/d1/hivedata_8h.html#a49">HCELL_INDEX</a> TargetSubKey, SourceSubKey;
01684    ULONG i = 0;   
01685    <a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html">PCM_KEY_NODE</a> SubKeyCell;
01686    UNICODE_STRING SubKeyName;
01687 
01688    <span class="comment">//</span>
01689    <span class="comment">// Run through all of the target cell's subkeys</span>
01690    <span class="comment">//</span>
01691 
01692    <span class="keywordflow">while</span>((TargetSubKey = <a class="code" href="../../d1/d2/cmp_8h.html#a304">CmpFindSubKeyByNumber</a>(
01693                                                TargetHive,
01694                                                TargetCell,
01695                                                i)) != <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>)
01696    {
01697       
01698       <span class="comment">//</span>
01699       <span class="comment">// Check if the current subkey has a counterpart</span>
01700       <span class="comment">// subkey of the source cell.</span>
01701       <span class="comment">// (Note that we use similar techniques as in the code</span>
01702       <span class="comment">//  of CmpCopySyncTree2)</span>
01703       <span class="comment">//</span>
01704 
01705       SubKeyCell = (<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html">PCM_KEY_NODE</a>)<a class="code" href="../../d6/d0/hive_8h.html#a12">HvGetCell</a>(TargetHive, TargetSubKey);
01706 
01707       <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a14">CmpInitializeKeyNameString</a>(SubKeyCell,
01708                                  &amp;SubKeyName,
01709                                  NameBuffer);
01710 
01711       SourceSubKey = <a class="code" href="../../d1/d2/cmp_8h.html#a303">CmpFindSubKeyByName</a>(SourceHive, 
01712                                          SourceCell,
01713                                          &amp;SubKeyName);
01714 
01715       <span class="keywordflow">if</span>(SourceSubKey == <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>)
01716       { 
01717          <span class="comment">//</span>
01718          <span class="comment">// The current subkey has no counterpart, </span>
01719          <span class="comment">// it must therefore be deleted from the target cell.</span>
01720          <span class="comment">//</span>
01721 
01722 <span class="preprocessor">#if DEBUG_TREE_SYNC</span>
01723 <span class="preprocessor"></span>         KdPrint((<span class="stringliteral">"CONFIG: SubKey Deletion of %.*S\n"</span>,                         
01724                SubKeyName.Length / <span class="keyword">sizeof</span>(WCHAR),
01725                SubKeyName.Buffer));         
01726 <span class="preprocessor">#endif</span>
01727 <span class="preprocessor"></span>         
01728          <span class="keywordflow">if</span>(SubKeyCell-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o5">SubKeyCounts</a>[<a class="code" href="../../d0/d1/hivedata_8h.html#a77a75">Stable</a>] + SubKeyCell-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o5">SubKeyCounts</a>[<a class="code" href="../../d0/d1/hivedata_8h.html#a77a76">Volatile</a>])
01729          {
01730             <span class="comment">// The subkey we are deleting has subkeys - use delete tree to get rid of them            </span>
01731 
01732             <a class="code" href="../../d3/d3/cmtredel_8c.html#a0">CmpDeleteTree</a>(TargetHive, TargetSubKey);
01733 
01734 <span class="preprocessor">#if DEBUG_TREE_SYNC</span>
01735 <span class="preprocessor"></span>            KdPrint((<span class="stringliteral">"CONFIG: Delete TREE performed.\n"</span>));
01736 <span class="preprocessor">#endif</span>
01737 <span class="preprocessor"></span>         }
01738          
01739          <span class="comment">// The subkey we are deleting is now a leaf (or has always been one), </span>
01740          <span class="comment">// just delete it.</span>
01741 
01742          <span class="keywordflow">if</span>(!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d3/d3/cmtredel_8c.html#a1">CmpFreeKeyByCell</a>(TargetHive, TargetSubKey, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>)))
01743          {
01744             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01745          }
01746          
01747          <span class="comment">//</span>
01748          <span class="comment">// We have deleted a subkey, so *i* does not need to get incremented</span>
01749          <span class="comment">// here because it now refers to the next subkey.</span>
01750          <span class="comment">//         </span>
01751       }
01752       <span class="keywordflow">else</span>
01753       {
01754          <span class="comment">//</span>
01755          <span class="comment">// Counterpart found. No deletion necessary. Move on to the next subkey</span>
01756          <span class="comment">//</span>
01757 
01758          i++;
01759       }
01760    }
01761          
01762    <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01763 }
01764 
01765 
01766 BOOLEAN
<a name="l01767"></a><a class="code" href="../../d2/d3/cmtrecpy_8c.html#a8">01767</a> <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a8">CmpMarkKeyValuesDirty</a>(
01768     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a> Hive,
01769     HCELL_INDEX Cell,
01770     <a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html">PCM_KEY_NODE</a> Node
01771     )
01772 <span class="comment">/*++</span>
01773 <span class="comment"></span>
01774 <span class="comment">Routine Description:</span>
01775 <span class="comment"></span>
01776 <span class="comment">   </span>
01777 <span class="comment">   Marks the cells associated with a key's value entries, security descriptor,</span>
01778 <span class="comment">   and class information as dirty.</span>
01779 <span class="comment">                        </span>
01780 <span class="comment">Arguments:</span>
01781 <span class="comment"></span>
01782 <span class="comment">   Hive     - The hive of the key in question</span>
01783 <span class="comment">   Cell     - The cell of the key in question</span>
01784 <span class="comment">   Node     - The body of the key in question</span>
01785 <span class="comment"></span>
01786 <span class="comment"></span>
01787 <span class="comment">Return Value:</span>
01788 <span class="comment"></span>
01789 <span class="comment">   TRUE if successful, FALSE otherwise.</span>
01790 <span class="comment">   </span>
01791 <span class="comment">   A failure probably indicates that no log space was available.</span>
01792 <span class="comment"></span>
01793 <span class="comment">--*/</span>
01794 {    
01795     <a class="code" href="../../d4/d9/struct__CELL__DATA.html">PCELL_DATA</a>  plist, security, pvalue;
01796     ULONG       i, realsize;    
01797 
01798     <span class="keywordflow">if</span> (Node-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o1">Flags</a> &amp; <a class="code" href="../../d9/d0/cmdata_8h.html#a28">KEY_HIVE_EXIT</a>) {
01799 
01800         <span class="comment">//</span>
01801         <span class="comment">// If this is a link node, we are done.  Link nodes never have</span>
01802         <span class="comment">// classes, values, subkeys, or security descriptors.  Since</span>
01803         <span class="comment">// they always reside in the master hive, they're always volatile.</span>
01804         <span class="comment">//</span>
01805         <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
01806     }
01807 
01808     <span class="comment">//</span>
01809     <span class="comment">// mark cell itself</span>
01810     <span class="comment">//</span>
01811     <span class="keywordflow">if</span> (! <a class="code" href="../../d0/d2/hivesync_8c.html#a7">HvMarkCellDirty</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>, <a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>)) {
01812         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01813     }
01814 
01815     <span class="comment">//</span>
01816     <span class="comment">// Mark the class</span>
01817     <span class="comment">//</span>
01818     <span class="keywordflow">if</span> (Node-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o10">Class</a> != <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>) {
01819         <span class="keywordflow">if</span> (! <a class="code" href="../../d0/d2/hivesync_8c.html#a7">HvMarkCellDirty</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>, Node-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o10">Class</a>)) {
01820             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01821         }
01822     }
01823 
01824     <span class="comment">//</span>
01825     <span class="comment">// Mark security</span>
01826     <span class="comment">//</span>
01827     <span class="keywordflow">if</span> (Node-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o9">Security</a> != <a class="code" href="../../d0/d1/hivedata_8h.html#a6">HCELL_NIL</a>) {
01828         <span class="keywordflow">if</span> (! <a class="code" href="../../d0/d2/hivesync_8c.html#a7">HvMarkCellDirty</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>, Node-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o9">Security</a>)) {
01829             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01830         }
01831 
01832         security = <a class="code" href="../../d6/d0/hive_8h.html#a12">HvGetCell</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>, Node-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o9">Security</a>);
01833         <span class="keywordflow">if</span> (! (<a class="code" href="../../d0/d2/hivesync_8c.html#a7">HvMarkCellDirty</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>, security-&gt;<a class="code" href="../../d4/d9/struct__CELL__DATA.html#o0">u</a>.<a class="code" href="../../d5/d9/union__CELL__DATA_1_1__u.html#o2">KeySecurity</a>.<a class="code" href="../../d6/d5/struct__CM__KEY__SECURITY.html#o2">Flink</a>) &amp;&amp;
01834                <a class="code" href="../../d0/d2/hivesync_8c.html#a7">HvMarkCellDirty</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>, security-&gt;<a class="code" href="../../d4/d9/struct__CELL__DATA.html#o0">u</a>.<a class="code" href="../../d5/d9/union__CELL__DATA_1_1__u.html#o2">KeySecurity</a>.<a class="code" href="../../d6/d5/struct__CM__KEY__SECURITY.html#o3">Blink</a>)))
01835         {
01836             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01837         }
01838     }
01839 
01840     <span class="comment">//</span>
01841     <span class="comment">// Mark the value entries and their data</span>
01842     <span class="comment">//</span>
01843     <span class="keywordflow">if</span> (Node-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o7">ValueList</a>.<a class="code" href="../../d7/d9/struct__CHILD__LIST.html#o0">Count</a> &gt; 0) {
01844 
01845         <span class="comment">// Value list</span>
01846         <span class="keywordflow">if</span> (! <a class="code" href="../../d0/d2/hivesync_8c.html#a7">HvMarkCellDirty</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>, Node-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o7">ValueList</a>.<a class="code" href="../../d7/d9/struct__CHILD__LIST.html#o1">List</a>)) {
01847             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01848         }
01849         plist = <a class="code" href="../../d6/d0/hive_8h.html#a12">HvGetCell</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>, Node-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o7">ValueList</a>.<a class="code" href="../../d7/d9/struct__CHILD__LIST.html#o1">List</a>);
01850 
01851         <span class="keywordflow">for</span> (i = 0; i &lt; Node-&gt;<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o7">ValueList</a>.<a class="code" href="../../d7/d9/struct__CHILD__LIST.html#o0">Count</a>; i++) {
01852             <span class="keywordflow">if</span> (! <a class="code" href="../../d0/d2/hivesync_8c.html#a7">HvMarkCellDirty</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>, plist-&gt;<a class="code" href="../../d4/d9/struct__CELL__DATA.html#o0">u</a>.<a class="code" href="../../d5/d9/union__CELL__DATA_1_1__u.html#o4">KeyList</a>[i])) {
01853                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01854             }
01855 
01856             pvalue = <a class="code" href="../../d6/d0/hive_8h.html#a12">HvGetCell</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>, plist-&gt;<a class="code" href="../../d4/d9/struct__CELL__DATA.html#o0">u</a>.<a class="code" href="../../d5/d9/union__CELL__DATA_1_1__u.html#o4">KeyList</a>[i]);
01857             
01858             <span class="keywordflow">if</span> (!<a class="code" href="../../d9/d0/cmdata_8h.html#a38">CmpIsHKeyValueSmall</a>(realsize, pvalue-&gt;<a class="code" href="../../d4/d9/struct__CELL__DATA.html#o0">u</a>.<a class="code" href="../../d5/d9/union__CELL__DATA_1_1__u.html#o1">KeyValue</a>.<a class="code" href="../../d7/d5/struct__CM__KEY__VALUE.html#o2">DataLength</a>)) {
01859                 <span class="keywordflow">if</span> (! <a class="code" href="../../d0/d2/hivesync_8c.html#a7">HvMarkCellDirty</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>, pvalue-&gt;<a class="code" href="../../d4/d9/struct__CELL__DATA.html#o0">u</a>.<a class="code" href="../../d5/d9/union__CELL__DATA_1_1__u.html#o1">KeyValue</a>.<a class="code" href="../../d7/d5/struct__CM__KEY__VALUE.html#o3">Data</a>)) {
01860                     <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
01861                 }
01862             }
01863         }
01864     }
01865 
01866     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01867 }
01868 
01869 BOOLEAN
<a name="l01870"></a><a class="code" href="../../d2/d3/cmtrecpy_8c.html#a9">01870</a> <a class="code" href="../../d2/d3/cmtrecpy_8c.html#a9">CmpMarkKeyParentDirty</a>(
01871     <a class="code" href="../../d7/d7/struct__HHIVE.html">PHHIVE</a> Hive,
01872     HCELL_INDEX Cell
01873     )
01874 <span class="comment">/*++</span>
01875 <span class="comment"></span>
01876 <span class="comment">Routine Description:</span>
01877 <span class="comment"></span>
01878 <span class="comment">   Marks the parent of a given key and the parent's subkey list as dirty.</span>
01879 <span class="comment">   </span>
01880 <span class="comment">Arguments:</span>
01881 <span class="comment"></span>
01882 <span class="comment">   Hive     - The hive of the key in question.</span>
01883 <span class="comment">   Cell     - The cell of the key in question.</span>
01884 <span class="comment"></span>
01885 <span class="comment"></span>
01886 <span class="comment">Return Value:</span>
01887 <span class="comment"></span>
01888 <span class="comment">   TRUE if successful, FALSE otherwise.</span>
01889 <span class="comment">   </span>
01890 <span class="comment">   A failure probably indicates that no log space was available.</span>
01891 <span class="comment"></span>
01892 <span class="comment">--*/</span>
01893 {
01894 
01895     <a class="code" href="../../d4/d9/struct__CELL__DATA.html">PCELL_DATA</a> ptarget;
01896 
01897     <span class="comment">//</span>
01898     <span class="comment">// Map in the target</span>
01899     <span class="comment">//</span>
01900     ptarget = <a class="code" href="../../d6/d0/hive_8h.html#a12">HvGetCell</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>, <a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>);    
01901 
01902 
01903     <span class="keywordflow">if</span> (ptarget-&gt;<a class="code" href="../../d4/d9/struct__CELL__DATA.html#o0">u</a>.<a class="code" href="../../d5/d9/union__CELL__DATA_1_1__u.html#o0">KeyNode</a>.<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o1">Flags</a> &amp; <a class="code" href="../../d9/d0/cmdata_8h.html#a29">KEY_HIVE_ENTRY</a>) {
01904 
01905         <span class="comment">//</span>
01906         <span class="comment">// if this is an entry node, we are done.  our parent will</span>
01907         <span class="comment">// be in the master hive (and thus volatile)</span>
01908         <span class="comment">//</span>
01909         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01910     }
01911 
01912     <span class="comment">//</span>
01913     <span class="comment">// Mark the parent's Subkey list</span>
01914     <span class="comment">//</span>
01915     <span class="keywordflow">if</span> (! <a class="code" href="../../d1/d2/cmp_8h.html#a306">CmpMarkIndexDirty</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>, ptarget-&gt;<a class="code" href="../../d4/d9/struct__CELL__DATA.html#o0">u</a>.<a class="code" href="../../d5/d9/union__CELL__DATA_1_1__u.html#o0">KeyNode</a>.<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o4">Parent</a>, <a class="code" href="../../d1/d0/cmchek_8c.html#a7">Cell</a>)) {
01916         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01917     }
01918 
01919     <span class="comment">//</span>
01920     <span class="comment">// Mark the parent</span>
01921     <span class="comment">//</span>
01922     <span class="keywordflow">if</span> (! <a class="code" href="../../d0/d2/hivesync_8c.html#a7">HvMarkCellDirty</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a3">Hive</a>, ptarget-&gt;<a class="code" href="../../d4/d9/struct__CELL__DATA.html#o0">u</a>.<a class="code" href="../../d5/d9/union__CELL__DATA_1_1__u.html#o0">KeyNode</a>.<a class="code" href="../../d2/d5/struct__CM__KEY__NODE.html#o4">Parent</a>)) {
01923         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01924     }
01925 
01926     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01927 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:39:29 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
