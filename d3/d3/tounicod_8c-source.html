<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: tounicod.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>tounicod.c</h1><a href="../../d2/d4/tounicod_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/****************************** Module Header ******************************\</span>
00002 <span class="comment">* Module Name: tounicod.c</span>
00003 <span class="comment">*</span>
00004 <span class="comment">* Copyright (c) 1985 - 1999, Microsoft Corporation</span>
00005 <span class="comment">*</span>
00006 <span class="comment">* History:</span>
00007 <span class="comment">* 02-08-92 GregoryW      Created.</span>
00008 <span class="comment">\***************************************************************************/</span>
00009 
00010 <span class="preprocessor">#include "<a class="code" href="../../d0/d4/w32_2ntuser_2kernel_2precomp_8h.html">precomp.h</a>"</span>
00011 <span class="preprocessor">#pragma hdrstop</span>
00012 <span class="preprocessor"></span>
00013 <span class="comment">/*</span>
00014 <span class="comment"> *     "To a new truth there is nothing more hurtful than an old error."</span>
00015 <span class="comment"> *             - Johann Wolfgang von Goethe (1749-1832)</span>
00016 <span class="comment"> */</span>
00017 
00018 <span class="comment">/*</span>
00019 <span class="comment"> * macros used locally to make life easier</span>
00020 <span class="comment"> */</span>
<a name="l00021"></a><a class="code" href="../../d2/d4/tounicod_8c.html#a0">00021</a> <span class="preprocessor">#define ISCAPSLOCKON(pf) (TestKeyToggleBit(pf, VK_CAPITAL) != 0)</span>
<a name="l00022"></a><a class="code" href="../../d2/d4/tounicod_8c.html#a1">00022</a> <span class="preprocessor"></span><span class="preprocessor">#define ISNUMLOCKON(pf)  (TestKeyToggleBit(pf, VK_NUMLOCK) != 0)</span>
<a name="l00023"></a><a class="code" href="../../d2/d4/tounicod_8c.html#a2">00023</a> <span class="preprocessor"></span><span class="preprocessor">#define ISSHIFTDOWN(w)   (w &amp; 0x01)</span>
<a name="l00024"></a><a class="code" href="../../d2/d4/tounicod_8c.html#a3">00024</a> <span class="preprocessor"></span><span class="preprocessor">#define ISKANALOCKON(pf) (TestKeyToggleBit(pf, VK_KANA)    != 0)</span>
00025 <span class="preprocessor"></span>
00026 WCHAR <a class="code" href="../../d2/d4/tounicod_8c.html#a10">xxxClientCharToWchar</a>(
00027     IN WORD CodePage,
00028     IN WORD wch);
00029 
00030 <span class="comment">/***************************************************************************\</span>
00031 <span class="comment">* _ToUnicodeEx (API)</span>
00032 <span class="comment">*</span>
00033 <span class="comment">* This routine provides Unicode translation for the virtual key code</span>
00034 <span class="comment">* passed in.</span>
00035 <span class="comment">*</span>
00036 <span class="comment">* History:</span>
00037 <span class="comment">* 02-10-92 GregoryW    Created.</span>
00038 <span class="comment">* 01-23-95 GregoryW    Expanded from _ToUnicode to _ToUnicodeEx</span>
00039 <span class="comment">\***************************************************************************/</span>
<a name="l00040"></a><a class="code" href="../../d4/d1/userk_8h.html#a1658">00040</a> <span class="keywordtype">int</span> <a class="code" href="../../d4/d1/userk_8h.html#a1658">xxxToUnicodeEx</a>(
00041     UINT wVirtKey,
00042     UINT wScanCode,
00043     CONST BYTE *pbKeyState,
00044     LPWSTR pwszBuff,
00045     <span class="keywordtype">int</span> cchBuff,
00046     UINT wKeyFlags,
00047     HKL hkl)
00048 {
00049     <span class="keywordtype">int</span> i;
00050     <a class="code" href="../../d9/d7/halvprnt_8c.html#a0">BYTE</a> afKeyState[<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a825">CBKEYSTATE</a>];
00051     <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a> dwDummy;
00052 
00053     <span class="comment">/*</span>
00054 <span class="comment">     * pKeyState is an array of 256 bytes, each byte representing the</span>
00055 <span class="comment">     * following virtual key state: 0x80 means down, 0x01 means toggled.</span>
00056 <span class="comment">     * InternalToUnicode() takes an array of bits, so pKeyState needs to</span>
00057 <span class="comment">     * be translated. _ToAscii only a public api and rarely gets called,</span>
00058 <span class="comment">     * so this is no big deal.</span>
00059 <span class="comment">     */</span>
00060     <span class="keywordflow">for</span> (i = 0; i &lt; 256; i++, pbKeyState++) {
00061         <span class="keywordflow">if</span> (*pbKeyState &amp; 0x80) {
00062             <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a828">SetKeyDownBit</a>(afKeyState, i);
00063         } <span class="keywordflow">else</span> {
00064             <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a829">ClearKeyDownBit</a>(afKeyState, i);
00065         }
00066 
00067         <span class="keywordflow">if</span> (*pbKeyState &amp; 0x01) {
00068             <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a831">SetKeyToggleBit</a>(afKeyState, i);
00069         } <span class="keywordflow">else</span> {
00070             <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a832">ClearKeyToggleBit</a>(afKeyState, i);
00071         }
00072     }
00073 
00074     i = <a class="code" href="../../d4/d1/userk_8h.html#a1659">xxxInternalToUnicode</a>(wVirtKey, wScanCode, afKeyState, pwszBuff, cchBuff,
00075             wKeyFlags, &amp;dwDummy, hkl);
00076 
00077 
00078     <span class="keywordflow">return</span> i;
00079 }
00080 
<a name="l00081"></a><a class="code" href="../../d2/d4/tounicod_8c.html#a12">00081</a> <span class="keywordtype">int</span> <a class="code" href="../../d2/d4/tounicod_8c.html#a12">ComposeDeadKeys</a>(
00082     <a class="code" href="../../d4/d9/structtagKL.html">PKL</a> pkl,
00083     PDEADKEY pDeadKey,
00084     WCHAR wchTyped,
00085     WORD *pUniChar,
00086     INT cChar,
00087     BOOL bBreak)
00088 {
00089    <span class="comment">/*</span>
00090 <span class="comment">    * Attempt to compose this sequence:</span>
00091 <span class="comment">    */</span>
00092    <a class="code" href="../../d0/d5/perfuser_8c.html#a6">DWORD</a> dwBoth;
00093 
00094    TAGMSG4(DBGTAG_ToUnicode | RIP_THERESMORE,
00095            <span class="stringliteral">"ComposeDeadKeys dead '%C'(%x)+base '%C'(%x)"</span>,
00096            pkl-&gt;<a class="code" href="../../d4/d9/structtagKL.html#o9">wchDiacritic</a>, pkl-&gt;<a class="code" href="../../d4/d9/structtagKL.html#o9">wchDiacritic</a>,
00097            wchTyped, wchTyped);
00098    TAGMSG2(DBGTAG_ToUnicode | RIP_NONAME | RIP_THERESMORE,
00099            <span class="stringliteral">"cChar = %d, bBreak = %d"</span>, cChar, bBreak);
00100    UserAssert(pDeadKey);
00101 
00102    <span class="keywordflow">if</span> (cChar &lt; 1) {
00103        TAGMSG0(DBGTAG_ToUnicode | RIP_NONAME,
00104                <span class="stringliteral">"return 0 because cChar &lt; 1"</span>);
00105        <span class="keywordflow">return</span> 0;
00106    }
00107 
00108    <span class="comment">/*</span>
00109 <span class="comment">    * Use the layout's built-in table for dead char composition</span>
00110 <span class="comment">    */</span>
00111    dwBoth = MAKELONG(wchTyped, pkl-&gt;<a class="code" href="../../d4/d9/structtagKL.html#o9">wchDiacritic</a>);
00112 
00113    <span class="keywordflow">if</span> (pDeadKey != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00114        <span class="comment">/*</span>
00115 <span class="comment">        * Don't let character upstrokes erase the cached dead char: else</span>
00116 <span class="comment">        * if this was the dead char key again (being released after the</span>
00117 <span class="comment">        * AltGr is released) the dead char would be prematurely cleared.</span>
00118 <span class="comment">        */</span>
00119        <span class="keywordflow">if</span> (!bBreak) {
00120            pkl-&gt;<a class="code" href="../../d4/d9/structtagKL.html#o9">wchDiacritic</a> = 0;
00121        }
00122        <span class="keywordflow">while</span> (pDeadKey-&gt;dwBoth != 0) {
00123            <span class="keywordflow">if</span> (pDeadKey-&gt;dwBoth == dwBoth) {
00124                <span class="comment">/*</span>
00125 <span class="comment">                * found a composition</span>
00126 <span class="comment">                */</span>
00127                <span class="keywordflow">if</span> (pDeadKey-&gt;uFlags &amp; DKF_DEAD) {
00128                    <span class="comment">/*</span>
00129 <span class="comment">                    * Dead again! Save the new 'dead' key</span>
00130 <span class="comment">                    */</span>
00131                    <span class="keywordflow">if</span> (!bBreak) {
00132                        pkl-&gt;<a class="code" href="../../d4/d9/structtagKL.html#o9">wchDiacritic</a> = (WORD)pDeadKey-&gt;wchComposed;
00133                    }
00134                    TAGMSG2(DBGTAG_ToUnicode | RIP_NONAME,
00135                            <span class="stringliteral">"return -1 with dead char '%C'(%x)"</span>,
00136                            pkl-&gt;<a class="code" href="../../d4/d9/structtagKL.html#o9">wchDiacritic</a>, pkl-&gt;<a class="code" href="../../d4/d9/structtagKL.html#o9">wchDiacritic</a>);
00137                    <span class="keywordflow">return</span> -1;
00138                }
00139                *pUniChar = (WORD)pDeadKey-&gt;wchComposed;
00140                TAGMSG2(DBGTAG_ToUnicode | RIP_NONAME,
00141                        <span class="stringliteral">"return 1 with char '%C'(%x)"</span>,
00142                        *pUniChar, *pUniChar);
00143                <span class="keywordflow">return</span> 1;
00144            }
00145            pDeadKey++;
00146        }
00147    }
00148    *pUniChar++ = HIWORD(dwBoth);
00149    <span class="keywordflow">if</span> (cChar &gt; 1) {
00150        *pUniChar = LOWORD(dwBoth);
00151        TAGMSG4(DBGTAG_ToUnicode | RIP_NONAME,
00152                <span class="stringliteral">"return 2 with uncomposed chars '%C'(%x), '%C'(%x)"</span>,
00153                *(pUniChar-1), *(pUniChar-1), *pUniChar, *pUniChar);
00154        <span class="keywordflow">return</span> 2;
00155    }
00156    TAGMSG2(DBGTAG_ToUnicode | RIP_NONAME | RIP_THERESMORE,
00157            <span class="stringliteral">"return 1 - only one char '%C'(%x) because cChar is 1, '%C'(%x)"</span>,
00158            *(pUniChar-1), *(pUniChar-1));
00159    TAGMSG2(DBGTAG_ToUnicode | RIP_NONAME,
00160            <span class="stringliteral">"  the second char would have been '%C'(%x)"</span>,
00161            LOWORD(dwBoth), LOWORD(dwBoth));
00162    <span class="keywordflow">return</span> 1;
00163 }
00164 
00165 
00166 <span class="comment">/*</span>
00167 <span class="comment"> * TranslateInjectedVKey</span>
00168 <span class="comment"> *</span>
00169 <span class="comment"> * Returns the number of characters (cch) translated.</span>
00170 <span class="comment"> *</span>
00171 <span class="comment"> * Note on VK_PACKET:</span>
00172 <span class="comment"> * Currently, the only purpose of VK_PACKET is to inject a Unicode character</span>
00173 <span class="comment"> * into the input stream, but it is intended to be extensible to include other</span>
00174 <span class="comment"> * manipulations of the input stream (including the message loop so that IMEs</span>
00175 <span class="comment"> * can be involved).  For example, we might send commands to the IME or other</span>
00176 <span class="comment"> * parts of the system.</span>
00177 <span class="comment"> * For Unicode character injection, we tried widening virtual keys to 32 bits</span>
00178 <span class="comment"> * of the form nnnn00e7, where nnnn is 0x0000 - 0xFFFF (representing Unicode</span>
00179 <span class="comment"> * characters 0x0000 - 0xFFFF) See KEYEVENTF_UNICODE.</span>
00180 <span class="comment"> * But many apps truncate wParam to 16-bits (poorly ported from 16-bits?) and</span>
00181 <span class="comment"> * several AV with these VKs (indexing into a table by WM_KEYDOWN wParam?) so</span>
00182 <span class="comment"> * we have to cache the character in pti-&gt;wchInjected for TranslateMessage to</span>
00183 <span class="comment"> * pick up (cf. GetMessagePos, GetMessageExtraInfo and GetMessageTime)</span>
00184 <span class="comment"> */</span>
<a name="l00185"></a><a class="code" href="../../d2/d4/tounicod_8c.html#a13">00185</a> <span class="keywordtype">int</span> <a class="code" href="../../d2/d4/tounicod_8c.html#a13">TranslateInjectedVKey</a>(
00186     IN UINT uScanCode,
00187     OUT PWCHAR awchChars,
00188     IN UINT uiTMFlags)
00189 {
00190     UserAssert(<a class="code" href="../../d5/d9/ntrtlp_8h.html#a4">LOBYTE</a>(uScanCode) == 0);
00191     <span class="keywordflow">if</span> (!(uScanCode &amp; KBDBREAK) || (uiTMFlags &amp; TM_POSTCHARBREAKS)) {
00192         awchChars[0] = <a class="code" href="../../d4/d1/userk_8h.html#a9">PtiCurrent</a>()-&gt;wchInjected;
00193         <span class="keywordflow">return</span> 1;
00194     }
00195     <span class="keywordflow">return</span> 0;
00196 }
00197 
00198 
00199 
00200 <span class="keyword">enum</span> {
00201     <a class="code" href="../../d2/d4/tounicod_8c.html#a18a6">NUMPADCONV_OEMCP</a> = 0,
00202     <a class="code" href="../../d2/d4/tounicod_8c.html#a18a7">NUMPADCONV_HKLCP</a>,
00203     <a class="code" href="../../d2/d4/tounicod_8c.html#a18a8">NUMPADCONV_HEX_HKLCP</a>,
00204     <a class="code" href="../../d2/d4/tounicod_8c.html#a18a9">NUMPADCONV_HEX_UNICODE</a>,
00205 };
00206 
<a name="l00207"></a><a class="code" href="../../d2/d4/tounicod_8c.html#a4">00207</a> <span class="preprocessor">#define NUMPADSPC_INVALID   (-1)</span>
00208 <span class="preprocessor"></span>
<a name="l00209"></a><a class="code" href="../../d2/d4/tounicod_8c.html#a14">00209</a> <span class="keywordtype">int</span> <a class="code" href="../../d2/d4/tounicod_8c.html#a14">NumPadScanCodeToHex</a>(UINT uScanCode, UINT uVirKey)
00210 {
00211     <span class="keywordflow">if</span> (uScanCode &gt;= SCANCODE_NUMPAD_FIRST &amp;&amp; uScanCode &lt;= SCANCODE_NUMPAD_LAST) {
00212         <span class="keywordtype">int</span> digit = <a class="code" href="../../d7/d8/kbd_8c.html#a1">aVkNumpad</a>[uScanCode - SCANCODE_NUMPAD_FIRST];
00213 
00214         <span class="keywordflow">if</span> (digit != 0xff) {
00215             <span class="keywordflow">return</span> digit - VK_NUMPAD0;
00216         }
00217         <span class="keywordflow">return</span> <a class="code" href="../../d2/d4/tounicod_8c.html#a4">NUMPADSPC_INVALID</a>;
00218     }
00219 
00220     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a67">gfInNumpadHexInput</a> &amp; <a class="code" href="../../d4/d1/userk_8h.html#a489">NUMPAD_HEXMODE_HL</a>) {
00221         <span class="comment">//</span>
00222         <span class="comment">// Full keyboard</span>
00223         <span class="comment">//</span>
00224         <span class="keywordflow">if</span> (uVirKey &gt;= <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'A'</span> &amp;&amp; uVirKey &lt;= <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'F'</span>) {
00225             <span class="keywordflow">return</span> uVirKey - <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'A'</span> + 0xa;
00226         }
00227         <span class="keywordflow">if</span> (uVirKey &gt;= <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'0'</span> &amp;&amp; uVirKey &lt;= <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'9'</span>) {
00228             <span class="keywordflow">return</span> uVirKey - <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'0'</span>;
00229         }
00230     }
00231 
00232     <span class="keywordflow">return</span> <a class="code" href="../../d2/d4/tounicod_8c.html#a4">NUMPADSPC_INVALID</a>;
00233 }
00234 
00235 <span class="comment">/*</span>
00236 <span class="comment"> * IsDbcsExemptionForHighAnsi</span>
00237 <span class="comment"> *</span>
00238 <span class="comment"> * returns TRUE if Unicode to ANSI conversion should be</span>
00239 <span class="comment"> * done on CP 1252 (Latin-1).</span>
00240 <span class="comment"> *</span>
00241 <span class="comment"> * If this function is changed, winsrv's equivalent</span>
00242 <span class="comment"> * routine should be changed too.</span>
00243 <span class="comment"> */</span>
<a name="l00244"></a><a class="code" href="../../d2/d4/tounicod_8c.html#a15">00244</a> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a11">BOOL</a> <a class="code" href="../../d2/d4/tounicod_8c.html#a15">IsDbcsExemptionForHighAnsi</a>(
00245     WORD wCodePage,
00246     WORD wNumpadChar)
00247 {
00248     UserAssert(<a class="code" href="../../d5/d9/ntrtlp_8h.html#a5">HIBYTE</a>(wNumpadChar) == 0);
00249 
00250     <span class="keywordflow">if</span> (wCodePage == <a class="code" href="../../d1/d0/inc_2user_8h.html#a117">CP_JAPANESE</a> &amp;&amp; <a class="code" href="../../d1/d0/inc_2user_8h.html#a123">IS_JPN_1BYTE_KATAKANA</a>(wNumpadChar)) {
00251         <span class="comment">/*</span>
00252 <span class="comment">         * If hkl is JAPANESE and NumpadChar is in KANA range,</span>
00253 <span class="comment">         * NumpadChar should be handled by the input locale.</span>
00254 <span class="comment">         */</span>
00255         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00256     }
00257     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (wNumpadChar &gt;= 0x80 &amp;&amp; wNumpadChar &lt;= 0xff) {
00258         <span class="comment">/*</span>
00259 <span class="comment">         * Otherwise if NumpadChar is in High ANSI range,</span>
00260 <span class="comment">         * use 1252 for conversion.</span>
00261 <span class="comment">         */</span>
00262         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00263     }
00264 
00265     <span class="comment">/*</span>
00266 <span class="comment">     * None of the above.</span>
00267 <span class="comment">     * This case includes the compound Leading Byte and Trailing Byte,</span>
00268 <span class="comment">     * which is larger than 0xff.</span>
00269 <span class="comment">     */</span>
00270     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00271 }
00272 
00273 <span class="preprocessor">#undef MODIFIER_FOR_ALT_NUMPAD</span>
00274 <span class="preprocessor"></span>
<a name="l00275"></a><a class="code" href="../../d2/d4/tounicod_8c.html#a5">00275</a> <span class="preprocessor">#define MODIFIER_FOR_ALT_NUMPAD(wModBit) \</span>
00276 <span class="preprocessor">    ((((wModBits) &amp; ~KBDKANA) == KBDALT) || (((wModBits) &amp; ~KBDKANA) == (KBDALT | KBDSHIFT)))</span>
00277 <span class="preprocessor"></span>
00278 
<a name="l00279"></a><a class="code" href="../../d2/d4/tounicod_8c.html#a16">00279</a> <span class="keywordtype">int</span> <a class="code" href="../../d4/d1/userk_8h.html#a1659">xxxInternalToUnicode</a>(
00280     IN  UINT   uVirtKey,
00281     IN  UINT   uScanCode,
00282     CONST IN PBYTE pfvk,
00283     OUT PWCHAR awchChars,
00284     IN  INT    cChar,
00285     IN  UINT   uiTMFlags,
00286     OUT PDWORD pdwKeyFlags,
00287     IN  HKL    hkl)
00288 {
00289     WORD wModBits;
00290     WORD nShift;
00291     WCHAR *pUniChar;
00292     PVK_TO_WCHARS1 pVK;
00293     PVK_TO_WCHAR_TABLE pVKT;
00294     <span class="keyword">static</span> WORD NumpadChar;
00295     <span class="keyword">static</span> WORD VKLastDown;
00296     <span class="keyword">static</span> <a class="code" href="../../d9/d7/halvprnt_8c.html#a0">BYTE</a> ConvMode;   <span class="comment">// 0 == NUMPADCONV_OEMCP</span>
00297     <a class="code" href="../../d2/d8/structtagTHREADINFO.html">PTHREADINFO</a> ptiCurrent = <a class="code" href="../../d4/d1/userk_8h.html#a10">PtiCurrentShared</a>();
00298     <a class="code" href="../../d4/d9/structtagKL.html">PKL</a> pkl;
00299     PKBDTABLES pKbdTbl;
00300     PLIGATURE1 pLigature;
00301 
00302     *pdwKeyFlags = (uScanCode &amp; KBDBREAK);
00303 
00304     <span class="keywordflow">if</span> ((hkl == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp; ptiCurrent-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o4">spklActive</a>) {
00305         pkl = ptiCurrent-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o4">spklActive</a>;
00306         pKbdTbl = pkl-&gt;<a class="code" href="../../d4/d9/structtagKL.html#o5">spkf</a>-&gt;<a class="code" href="../../d1/d9/structtagKBDFILE.html#o4">pKbdTbl</a>;
00307     } <span class="keywordflow">else</span> {
00308         pkl = <a class="code" href="../../d4/d1/userk_8h.html#a1019">HKLtoPKL</a>(ptiCurrent, hkl);
00309         <span class="keywordflow">if</span> (!pkl) {
00310             <span class="keywordflow">return</span> 0;
00311         }
00312         pKbdTbl = pkl-&gt;<a class="code" href="../../d4/d9/structtagKL.html#o5">spkf</a>-&gt;<a class="code" href="../../d1/d9/structtagKBDFILE.html#o4">pKbdTbl</a>;
00313     }
00314     UserAssert(pkl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00315     UserAssert(pKbdTbl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00316 
00317     pUniChar = awchChars;
00318 
00319     uScanCode &amp;= (0xFF | KBDEXT);
00320 
00321     <span class="keywordflow">if</span> (*pdwKeyFlags &amp; KBDBREAK) {        <span class="comment">// break code processing</span>
00322         <span class="comment">/*</span>
00323 <span class="comment">         * Finalize number pad processing</span>
00324 <span class="comment">         *</span>
00325 <span class="comment">         */</span>
00326         <span class="keywordflow">if</span> (uVirtKey == VK_MENU) {
00327             <span class="keywordflow">if</span> (NumpadChar) {
00328                 <span class="keywordflow">if</span> (ConvMode == <a class="code" href="../../d2/d4/tounicod_8c.html#a18a9">NUMPADCONV_HEX_UNICODE</a>) {
00329                     *pUniChar = NumpadChar;
00330                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ConvMode == <a class="code" href="../../d2/d4/tounicod_8c.html#a18a6">NUMPADCONV_OEMCP</a> &amp;&amp;
00331                         (ptiCurrent-&gt;<a class="code" href="../../d2/d8/structtagTHREADINFO.html#o9">TIF_flags</a> &amp; <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a798">TIF_CSRSSTHREAD</a>)) {
00332                     <span class="comment">/*</span>
00333 <span class="comment">                     * Pass the OEM char to Console to be converted to Unicode</span>
00334 <span class="comment">                     * there, since we don't know the OEM codepage it is using.</span>
00335 <span class="comment">                     * Set ALTNUMPAD_BIT for console so it knows!</span>
00336 <span class="comment">                     */</span>
00337                     *pdwKeyFlags |= ALTNUMPAD_BIT;
00338                     *pUniChar = NumpadChar;
00339                 } <span class="keywordflow">else</span> {
00340                     <span class="comment">/*</span>
00341 <span class="comment">                     * Conversion based on OEMCP or current input language.</span>
00342 <span class="comment">                     */</span>
00343                     WORD wCodePage;
00344 
00345                     <span class="keywordflow">if</span> (ConvMode == <a class="code" href="../../d2/d4/tounicod_8c.html#a18a6">NUMPADCONV_OEMCP</a>) {
00346                         <span class="comment">// NlsOemCodePage is exported from ntoskrnl.exe.</span>
00347                         <span class="keyword">extern</span> <a class="code" href="../../d5/d6/chartran_8c.html#a2">__declspec</a>(dllimport) <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> <a class="code" href="../../d9/d6/nlsxlat_8c.html#a13">NlsOemCodePage</a>;
00348 
00349                         wCodePage = (WORD)<a class="code" href="../../d9/d6/nlsxlat_8c.html#a13">NlsOemCodePage</a>;
00350                     } <span class="keywordflow">else</span> {
00351                         wCodePage = pkl-&gt;<a class="code" href="../../d4/d9/structtagKL.html#o8">CodePage</a>;
00352                     }
00353                     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/inc_2user_8h.html#a121">IS_DBCS_CODEPAGE</a>(wCodePage)) {
00354                         <span class="keywordflow">if</span> (NumpadChar &amp; (WORD)~0xff) {
00355                             <span class="comment">/*</span>
00356 <span class="comment">                             * Might be a double byte character.</span>
00357 <span class="comment">                             * Let's swab it so that NumpadChar has LB in LOBYTE,</span>
00358 <span class="comment">                             * TB in HIBYTE.</span>
00359 <span class="comment">                             */</span>
00360                             NumpadChar = MAKEWORD(<a class="code" href="../../d5/d9/ntrtlp_8h.html#a5">HIBYTE</a>(NumpadChar), <a class="code" href="../../d5/d9/ntrtlp_8h.html#a4">LOBYTE</a>(NumpadChar));
00361                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d2/d4/tounicod_8c.html#a15">IsDbcsExemptionForHighAnsi</a>(wCodePage, NumpadChar)) {
00362                             <span class="comment">/*</span>
00363 <span class="comment">                             * FarEast hack:</span>
00364 <span class="comment">                             * treat characters in High ANSI area as if they are</span>
00365 <span class="comment">                             * the ones of Codepage 1252.</span>
00366 <span class="comment">                             */</span>
00367                             wCodePage = 1252;
00368                         }
00369                     } <span class="keywordflow">else</span> {
00370                         <span class="comment">/*</span>
00371 <span class="comment">                         * Backward compatibility:</span>
00372 <span class="comment">                         * Simulate the legacy modulo behavior for non-FarEast keyboard layouts.</span>
00373 <span class="comment">                         */</span>
00374                         NumpadChar &amp;= 0xff;
00375                     }
00376 
00377                     *pUniChar = <a class="code" href="../../d2/d4/tounicod_8c.html#a10">xxxClientCharToWchar</a>(wCodePage, NumpadChar);
00378                 }
00379 
00380                 <span class="comment">/*</span>
00381 <span class="comment">                 * Clear Alt-Numpad state, the ALT key-release generates 1 character.</span>
00382 <span class="comment">                 */</span>
00383                 VKLastDown = 0;
00384                 ConvMode = <a class="code" href="../../d2/d4/tounicod_8c.html#a18a6">NUMPADCONV_OEMCP</a>;
00385                 NumpadChar = 0;
00386                 <a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a67">gfInNumpadHexInput</a> &amp;= ~<a class="code" href="../../d4/d1/userk_8h.html#a489">NUMPAD_HEXMODE_HL</a>;
00387 
00388                 <span class="keywordflow">return</span> 1;
00389             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ConvMode != <a class="code" href="../../d2/d4/tounicod_8c.html#a18a6">NUMPADCONV_OEMCP</a>) {
00390                 ConvMode = <a class="code" href="../../d2/d4/tounicod_8c.html#a18a6">NUMPADCONV_OEMCP</a>;
00391             }
00392         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (uVirtKey == VKLastDown) {
00393             <span class="comment">/*</span>
00394 <span class="comment">             * The most recently depressed key has now come up: we are now</span>
00395 <span class="comment">             * ready to accept a new NumPad key for Alt-Numpad processing.</span>
00396 <span class="comment">             */</span>
00397             VKLastDown = 0;
00398         }
00399     }
00400 
00401     <span class="keywordflow">if</span> (!(*pdwKeyFlags &amp; KBDBREAK) || (uiTMFlags &amp; TM_POSTCHARBREAKS)) {
00402         <span class="comment">/*</span>
00403 <span class="comment">         * Get the character modification bits.</span>
00404 <span class="comment">         * The bit-mask (wModBits) encodes depressed modifier keys:</span>
00405 <span class="comment">         * these bits are commonly KBDSHIFT, KBDALT and/or KBDCTRL</span>
00406 <span class="comment">         * (representing Shift, Alt and Ctrl keys respectively)</span>
00407 <span class="comment">         */</span>
00408         wModBits = <a class="code" href="../../d3/d1/xlate_8c.html#a1">GetModifierBits</a>(pKbdTbl-&gt;pCharModifiers, pfvk);
00409 
00410         <span class="comment">/*</span>
00411 <span class="comment">         * If the current shift state is either Alt or Alt-Shift:</span>
00412 <span class="comment">         *</span>
00413 <span class="comment">         *   1. If a menu is currently displayed then clear the</span>
00414 <span class="comment">         *      alt bit from wModBits and proceed with normal</span>
00415 <span class="comment">         *      translation.</span>
00416 <span class="comment">         *</span>
00417 <span class="comment">         *   2. If this is a number pad key then do alt-&lt;numpad&gt;</span>
00418 <span class="comment">         *      calculations.</span>
00419 <span class="comment">         *</span>
00420 <span class="comment">         *   3. Otherwise, clear alt bit and proceed with normal</span>
00421 <span class="comment">         *      translation.</span>
00422 <span class="comment">         */</span>
00423 
00424         <span class="comment">/*</span>
00425 <span class="comment">         * Equivalent code is in xxxKeyEvent() to check the</span>
00426 <span class="comment">         * low level mode. If you change this code, you may</span>
00427 <span class="comment">         * need to change xxxKeyEvent() as well.</span>
00428 <span class="comment">         */</span>
00429         <span class="keywordflow">if</span> (!(*pdwKeyFlags &amp; KBDBREAK) &amp;&amp; <a class="code" href="../../d2/d4/tounicod_8c.html#a5">MODIFIER_FOR_ALT_NUMPAD</a>(wModBits)) {
00430             <span class="comment">/*</span>
00431 <span class="comment">             * If this is a numeric numpad key</span>
00432 <span class="comment">             */</span>
00433             <span class="keywordflow">if</span> ((uiTMFlags &amp; TM_INMENUMODE) == 0) {
00434                 <span class="keywordflow">if</span> (<a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a68">gfEnableHexNumpad</a> &amp;&amp; uScanCode == <a class="code" href="../../d4/d1/userk_8h.html#a487">SCANCODE_NUMPAD_DOT</a>) {
00435                     <span class="keywordflow">if</span> ((<a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a67">gfInNumpadHexInput</a> &amp; <a class="code" href="../../d4/d1/userk_8h.html#a489">NUMPAD_HEXMODE_HL</a>) == 0) {
00436                         <span class="comment">/*</span>
00437 <span class="comment">                         * If the first key is '.', then we're</span>
00438 <span class="comment">                         * entering hex input lang input mode.</span>
00439 <span class="comment">                         */</span>
00440                         ConvMode = <a class="code" href="../../d2/d4/tounicod_8c.html#a18a8">NUMPADCONV_HEX_HKLCP</a>;
00441                         <span class="comment">/*</span>
00442 <span class="comment">                         * Inidicate to the rest of the system</span>
00443 <span class="comment">                         * we're in Hex Alt+Numpad mode.</span>
00444 <span class="comment">                         */</span>
00445                         <a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a67">gfInNumpadHexInput</a> |= <a class="code" href="../../d4/d1/userk_8h.html#a489">NUMPAD_HEXMODE_HL</a>;
00446                         TAGMSG0(DBGTAG_ToUnicode, <span class="stringliteral">"NUMPADCONV_HEX_HKLCP"</span>);
00447                     } <span class="keywordflow">else</span> {
00448                         <span class="keywordflow">goto</span> ExitNumpadMode;
00449                     }
00450                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a68">gfEnableHexNumpad</a> &amp;&amp; uScanCode == <a class="code" href="../../d4/d1/userk_8h.html#a486">SCANCODE_NUMPAD_PLUS</a>) {
00451                     <span class="keywordflow">if</span> ((<a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a67">gfInNumpadHexInput</a> &amp; <a class="code" href="../../d4/d1/userk_8h.html#a489">NUMPAD_HEXMODE_HL</a>) == 0) {
00452                         <span class="comment">/*</span>
00453 <span class="comment">                         * If the first key is '+', then we're</span>
00454 <span class="comment">                         * entering hex UNICODE input mode.</span>
00455 <span class="comment">                         */</span>
00456                         ConvMode = <a class="code" href="../../d2/d4/tounicod_8c.html#a18a9">NUMPADCONV_HEX_UNICODE</a>;
00457                         <span class="comment">/*</span>
00458 <span class="comment">                         * Inidicate to the rest of the system</span>
00459 <span class="comment">                         * we're in Hex Alt+Numpad mode.</span>
00460 <span class="comment">                         */</span>
00461                         <a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a67">gfInNumpadHexInput</a> |= <a class="code" href="../../d4/d1/userk_8h.html#a489">NUMPAD_HEXMODE_HL</a>;
00462                         TAGMSG0(DBGTAG_ToUnicode, <span class="stringliteral">"NUMPADCONV_HEX_UNICODE"</span>);
00463                     } <span class="keywordflow">else</span> {
00464                         <span class="keywordflow">goto</span> ExitNumpadMode;
00465                     }
00466                 } <span class="keywordflow">else</span> {
00467                     <span class="keywordtype">int</span> digit = <a class="code" href="../../d2/d4/tounicod_8c.html#a14">NumPadScanCodeToHex</a>(uScanCode, uVirtKey);
00468 
00469                     <span class="keywordflow">if</span> (digit &lt; 0) {
00470                         <span class="keywordflow">goto</span> ExitNumpadMode;
00471                     }
00472 
00473                     <span class="comment">/*</span>
00474 <span class="comment">                     * Ignore repeats</span>
00475 <span class="comment">                     */</span>
00476                     <span class="keywordflow">if</span> (VKLastDown == uVirtKey) {
00477                         <span class="keywordflow">return</span> 0;
00478                     }
00479 
00480                     <span class="keywordflow">switch</span> (ConvMode) {
00481                     <span class="keywordflow">case</span> <a class="code" href="../../d2/d4/tounicod_8c.html#a18a8">NUMPADCONV_HEX_HKLCP</a>:
00482                     <span class="keywordflow">case</span> <a class="code" href="../../d2/d4/tounicod_8c.html#a18a9">NUMPADCONV_HEX_UNICODE</a>:
00483                         <span class="comment">/*</span>
00484 <span class="comment">                         * Input is treated as hex number.</span>
00485 <span class="comment">                         */</span>
00486                         TAGMSG1(DBGTAG_ToUnicode, <span class="stringliteral">"-&gt;NUMPADCONV_HEX_*: old NumpadChar=%02x\n"</span>, NumpadChar);
00487                         NumpadChar = NumpadChar * 0x10 + digit;
00488                         TAGMSG1(DBGTAG_ToUnicode, <span class="stringliteral">"&lt;-NUMPADCONV_HEX_*: new NumpadChar=%02x\n"</span>, NumpadChar);
00489                         <span class="keywordflow">break</span>;
00490                     <span class="keywordflow">default</span>:
00491                        <span class="comment">/*</span>
00492 <span class="comment">                        * Input is treated as decimal number.</span>
00493 <span class="comment">                        */</span>
00494                        NumpadChar = NumpadChar * 10 + digit;
00495 
00496                        <span class="comment">/*</span>
00497 <span class="comment">                        * Do Alt-Numpad0 processing</span>
00498 <span class="comment">                        */</span>
00499                        <span class="keywordflow">if</span> (NumpadChar == 0 &amp;&amp; digit == 0) {
00500                            ConvMode = <a class="code" href="../../d2/d4/tounicod_8c.html#a18a7">NUMPADCONV_HKLCP</a>;
00501                        }
00502                        <span class="keywordflow">break</span>;
00503                     }
00504                 }
00505                 VKLastDown = (WORD)uVirtKey;
00506             } <span class="keywordflow">else</span> {
00507 ExitNumpadMode:
00508                 <span class="comment">/*</span>
00509 <span class="comment">                 * Clear Alt-Numpad state and the ALT shift state.</span>
00510 <span class="comment">                 */</span>
00511                 VKLastDown = 0;
00512                 ConvMode = <a class="code" href="../../d2/d4/tounicod_8c.html#a18a6">NUMPADCONV_OEMCP</a>;
00513                 NumpadChar = 0;
00514                 wModBits &amp;= ~KBDALT;
00515                 <a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a67">gfInNumpadHexInput</a> &amp;= ~<a class="code" href="../../d4/d1/userk_8h.html#a489">NUMPAD_HEXMODE_HL</a>;
00516             }
00517         }
00518 
00519         <span class="comment">/*</span>
00520 <span class="comment">         * LShift/RSHift+Backspace -&gt; Left-to-Right and Right-to-Left marker</span>
00521 <span class="comment">         */</span>
00522         <span class="keywordflow">if</span> ((uVirtKey == VK_BACK) &amp;&amp; (pKbdTbl-&gt;fLocaleFlags &amp; KLLF_LRM_RLM)) {
00523             <span class="keywordflow">if</span> (<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a827">TestKeyDownBit</a>(pfvk, VK_LSHIFT)) {
00524                 *pUniChar = 0x200E; <span class="comment">// LRM</span>
00525                 <span class="keywordflow">return</span> 1;
00526             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a827">TestKeyDownBit</a>(pfvk, VK_RSHIFT)) {
00527                 *pUniChar = 0x200F; <span class="comment">// RLM</span>
00528                 <span class="keywordflow">return</span> 1;
00529             }
00530         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (((WORD)uVirtKey == VK_PACKET) &amp;&amp; (<a class="code" href="../../d5/d9/ntrtlp_8h.html#a4">LOBYTE</a>(uScanCode) == 0)) {
00531             <span class="keywordflow">return</span> <a class="code" href="../../d2/d4/tounicod_8c.html#a13">TranslateInjectedVKey</a>(uScanCode, awchChars, uiTMFlags);
00532         }
00533 
00534         <span class="comment">/*</span>
00535 <span class="comment">         * Scan through all the shift-state tables until a matching Virtual</span>
00536 <span class="comment">         * Key is found.</span>
00537 <span class="comment">         */</span>
00538         <span class="keywordflow">for</span> (pVKT = pKbdTbl-&gt;pVkToWcharTable; pVKT-&gt;pVkToWchars != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>; pVKT++) {
00539             pVK = pVKT-&gt;pVkToWchars;
00540             <span class="keywordflow">while</span> (pVK-&gt;VirtualKey != 0) {
00541                 <span class="keywordflow">if</span> (pVK-&gt;VirtualKey == (<a class="code" href="../../d9/d7/halvprnt_8c.html#a0">BYTE</a>)uVirtKey) {
00542                     <span class="keywordflow">goto</span> VK_Found;
00543                 }
00544                 pVK = (PVK_TO_WCHARS1)((<a class="code" href="../../d9/d7/halvprnt_8c.html#a1">PBYTE</a>)pVK + pVKT-&gt;cbSize);
00545             }
00546         }
00547 
00548         <span class="comment">/*</span>
00549 <span class="comment">         * Not found: virtual key is not a character.</span>
00550 <span class="comment">         */</span>
00551         <span class="keywordflow">goto</span> ReturnBadCharacter;
00552 
00553 VK_Found:
00554         <span class="comment">/*</span>
00555 <span class="comment">         * The virtual key has been found in table pVKT, at entry pVK</span>
00556 <span class="comment">         */</span>
00557 
00558         <span class="comment">/*</span>
00559 <span class="comment">         * If KanaLock affects this key and it is on: toggle KANA state</span>
00560 <span class="comment">         * only if no other state is on. "KANALOK" attributes only exist</span>
00561 <span class="comment">         * in Japanese keyboard layout, and only Japanese keyboard hardware</span>
00562 <span class="comment">         * can be "KANA" lock on state.</span>
00563 <span class="comment">         */</span>
00564         <span class="keywordflow">if</span> ((pVK-&gt;Attributes &amp; KANALOK) &amp;&amp; (<a class="code" href="../../d2/d4/tounicod_8c.html#a3">ISKANALOCKON</a>(pfvk))) {
00565             wModBits |= KBDKANA;
00566         } <span class="keywordflow">else</span>
00567         <span class="comment">/*</span>
00568 <span class="comment">         * If CapsLock affects this key and it is on: toggle SHIFT state</span>
00569 <span class="comment">         * only if no other state is on.</span>
00570 <span class="comment">         * (CapsLock doesn't affect SHIFT state if Ctrl or Alt are down).</span>
00571 <span class="comment">         * OR</span>
00572 <span class="comment">         * If CapsLockAltGr affects this key and it is on: toggle SHIFT</span>
00573 <span class="comment">         * state only if both Alt &amp; Control are down.</span>
00574 <span class="comment">         * (CapsLockAltGr only affects SHIFT if AltGr is being used).</span>
00575 <span class="comment">         */</span>
00576         <span class="keywordflow">if</span> ((pVK-&gt;Attributes &amp; CAPLOK) &amp;&amp; ((wModBits &amp; ~KBDSHIFT) == 0) &amp;&amp;
00577                 <a class="code" href="../../d2/d4/tounicod_8c.html#a0">ISCAPSLOCKON</a>(pfvk)) {
00578             wModBits ^= KBDSHIFT;
00579         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((pVK-&gt;Attributes &amp; CAPLOKALTGR) &amp;&amp;
00580                 ((wModBits &amp; (KBDALT | KBDCTRL)) == (KBDALT | KBDCTRL)) &amp;&amp;
00581                 <a class="code" href="../../d2/d4/tounicod_8c.html#a0">ISCAPSLOCKON</a>(pfvk)) {
00582             wModBits ^= KBDSHIFT;
00583         }
00584 
00585         <span class="comment">/*</span>
00586 <span class="comment">         * If SGCAPS affects this key and CapsLock is on: use the next entry</span>
00587 <span class="comment">         * in the table, but not is Ctrl or Alt are down.</span>
00588 <span class="comment">         * (SGCAPS is used in Swiss-German, Czech and Czech 101 layouts)</span>
00589 <span class="comment">         */</span>
00590         <span class="keywordflow">if</span> ((pVK-&gt;Attributes &amp; SGCAPS) &amp;&amp; ((wModBits &amp; ~KBDSHIFT) == 0) &amp;&amp;
00591                 <a class="code" href="../../d2/d4/tounicod_8c.html#a0">ISCAPSLOCKON</a>(pfvk)) {
00592             pVK = (PVK_TO_WCHARS1)((<a class="code" href="../../d9/d7/halvprnt_8c.html#a1">PBYTE</a>)pVK + pVKT-&gt;cbSize);
00593         }
00594 
00595         <span class="comment">/*</span>
00596 <span class="comment">         * Convert the shift-state bitmask into one of the enumerated</span>
00597 <span class="comment">         * logical shift states.</span>
00598 <span class="comment">         */</span>
00599         nShift = <a class="code" href="../../d3/d1/xlate_8c.html#a2">GetModificationNumber</a>(pKbdTbl-&gt;pCharModifiers, wModBits);
00600 
00601         <span class="keywordflow">if</span> (nShift == SHFT_INVALID) {
00602             <span class="comment">/*</span>
00603 <span class="comment">             * An invalid combination of Shifter Keys</span>
00604 <span class="comment">             */</span>
00605             <span class="keywordflow">goto</span> ReturnBadCharacter;
00606 
00607         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((nShift &lt; pVKT-&gt;nModifications) &amp;&amp;
00608                 (pVK-&gt;wch[nShift] != WCH_NONE)) {
00609             <span class="comment">/*</span>
00610 <span class="comment">             * There is an entry in the table for this combination of</span>
00611 <span class="comment">             * Shift State (nShift) and Virtual Key (uVirtKey).</span>
00612 <span class="comment">             */</span>
00613             <span class="keywordflow">if</span> (pVK-&gt;wch[nShift] == WCH_DEAD) {
00614                 <span class="comment">/*</span>
00615 <span class="comment">                 * It is a dead character: the next entry contains</span>
00616 <span class="comment">                 * its value.</span>
00617 <span class="comment">                 */</span>
00618                 pVK = (PVK_TO_WCHARS1)((<a class="code" href="../../d9/d7/halvprnt_8c.html#a1">PBYTE</a>)pVK + pVKT-&gt;cbSize);
00619 
00620                 <span class="comment">/*</span>
00621 <span class="comment">                 * If the previous char was not dead return a dead character.</span>
00622 <span class="comment">                 */</span>
00623                 <span class="keywordflow">if</span> (pkl-&gt;<a class="code" href="../../d4/d9/structtagKL.html#o9">wchDiacritic</a> == 0) {
00624                     TAGMSG2(DBGTAG_ToUnicode,
00625                             <span class="stringliteral">"xxxInternalToUnicode: new dead char '%C'(%x), goto ReturnDeadCharacter"</span>,
00626                             pVK-&gt;wch[nShift], pVK-&gt;wch[nShift]);
00627                     <span class="keywordflow">goto</span> ReturnDeadCharacter;
00628                 }
00629                 <span class="comment">/*</span>
00630 <span class="comment">                 * Else go to ReturnGoodCharacter which will attempt to</span>
00631 <span class="comment">                 * compose this dead character with the previous dead char.</span>
00632 <span class="comment">                 */</span>
00633                 <span class="comment">/*</span>
00634 <span class="comment">                 * N.B. NTBUG 6141</span>
00635 <span class="comment">                 * If dead key is hit twice in sequence, Win95/98 gives</span>
00636 <span class="comment">                 * two composed characters from dead chars...</span>
00637 <span class="comment">                 */</span>
00638                 TAGMSG4(DBGTAG_ToUnicode,
00639                         <span class="stringliteral">"xxxInternalToUnicode: 2 dead chars '%C'(%x)+'%C'(%x)"</span>,
00640                         pkl-&gt;<a class="code" href="../../d4/d9/structtagKL.html#o9">wchDiacritic</a>, pkl-&gt;<a class="code" href="../../d4/d9/structtagKL.html#o9">wchDiacritic</a>,
00641                         pVK-&gt;wch[nShift], pVK-&gt;wch[nShift]);
00642                 <span class="keywordflow">if</span> (<a class="code" href="../../d6/d3/queue_8c.html#a35">GetAppCompatFlags2</a>(<a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a101">VER40</a>) &amp; GACF2_NOCHAR_DEADKEY) {
00643                     <span class="comment">/*</span>
00644 <span class="comment">                     * AppCompat 377217: Publisher calls TranslateMessage and ToUnicode for</span>
00645 <span class="comment">                     * the same dead key when it's not expecting real characters.</span>
00646 <span class="comment">                     * On NT4, this resulted like "pushing the dead key in the stack and</span>
00647 <span class="comment">                     * no character is compossed", but on NT5 with fix to 6141,</span>
00648 <span class="comment">                     * two dead keys compose real characters clearing the internal</span>
00649 <span class="comment">                     * dead key cache. The app shouldn't call both TranslateMessage and ToUnicode</span>
00650 <span class="comment">                     * for the same key stroke in the first place -- in a way the app was working on</span>
00651 <span class="comment">                     * NT4 by just a thin luck.</span>
00652 <span class="comment">                     * In any case, since the app has been shipped broadly and hard to fix,</span>
00653 <span class="comment">                     * let's simulate the NT4 behavior here, but with just one level cache (not the</span>
00654 <span class="comment">                     * stack).</span>
00655 <span class="comment">                     */</span>
00656                     <span class="keywordflow">goto</span> ReturnDeadCharacter;
00657                 }
00658 
00659                 <span class="keywordflow">goto</span> ReturnGoodCharacter;
00660 
00661             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pVK-&gt;wch[nShift] == WCH_LGTR) {
00662                 <span class="comment">/*</span>
00663 <span class="comment">                 * It is a ligature.  Look in ligature table for a match.</span>
00664 <span class="comment">                 */</span>
00665                 <span class="keywordflow">if</span> ((GET_KBD_VERSION(pKbdTbl) == 0) || ((pLigature = pKbdTbl-&gt;pLigature) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
00666                     <span class="comment">/*</span>
00667 <span class="comment">                     * Hey, where's the table?</span>
00668 <span class="comment">                     */</span>
00669                     <a class="code" href="../../d4/d1/userk_8h.html#a1730">xxxMessageBeep</a>(0);
00670                     <span class="keywordflow">goto</span> ReturnBadCharacter;
00671                 }
00672 
00673                 <span class="keywordflow">while</span> (pLigature-&gt;VirtualKey != 0) {
00674                     <span class="keywordtype">int</span> iLig = 0;
00675                     <span class="keywordtype">int</span> cwchT = 0;
00676 
00677                     <span class="keywordflow">if</span> ((pLigature-&gt;VirtualKey == pVK-&gt;VirtualKey) &amp;&amp;
00678                             (pLigature-&gt;ModificationNumber == nShift)) {
00679                         <span class="comment">/*</span>
00680 <span class="comment">                         * Found the ligature!</span>
00681 <span class="comment">                         */</span>
00682                         <span class="keywordflow">while</span> ((iLig &lt; pKbdTbl-&gt;nLgMax) &amp;&amp; (cwchT &lt; cChar)) {
00683                             <span class="keywordflow">if</span> (pLigature-&gt;wch[iLig] == WCH_NONE) {
00684                                 <span class="comment">/*</span>
00685 <span class="comment">                                 * End of ligature.</span>
00686 <span class="comment">                                 */</span>
00687                                 <span class="keywordflow">return</span> cwchT;
00688                             }
00689                             <span class="keywordflow">if</span> (pkl-&gt;<a class="code" href="../../d4/d9/structtagKL.html#o9">wchDiacritic</a> != 0) {
00690                                 <span class="keywordtype">int</span> cComposed;
00691                                 <span class="comment">/*</span>
00692 <span class="comment">                                 * Attempt to compose the previous deadkey with current</span>
00693 <span class="comment">                                 * ligature character.  If this generates yet another</span>
00694 <span class="comment">                                 * dead key, go round again without adding to pUniChar</span>
00695 <span class="comment">                                 * or cwchT.</span>
00696 <span class="comment">                                 */</span>
00697                                 cComposed = <a class="code" href="../../d2/d4/tounicod_8c.html#a12">ComposeDeadKeys</a>(
00698                                             pkl,
00699                                             pKbdTbl-&gt;pDeadKey,
00700                                             pLigature-&gt;wch[iLig],
00701                                             pUniChar + cwchT,
00702                                             cChar - cwchT,
00703                                             *pdwKeyFlags &amp; KBDBREAK
00704                                             );
00705                                 <span class="keywordflow">if</span> (cComposed &gt; 0) {
00706                                     cwchT += cComposed;
00707                                 } <span class="keywordflow">else</span> {
00708                                     RIPMSG2(RIP_ERROR, <span class="comment">// we really don't expect this</span>
00709                                             <span class="stringliteral">"InternalToUnicode: dead+lig(%x)-&gt;dead(%x)"</span>,
00710                                             pLigature-&gt;wch[0], pkl-&gt;<a class="code" href="../../d4/d9/structtagKL.html#o9">wchDiacritic</a>);
00711                                 }
00712                             } <span class="keywordflow">else</span> {
00713                                 pUniChar[cwchT++] = pLigature-&gt;wch[iLig];
00714                             }
00715                             iLig++;
00716                         }
00717                         <span class="keywordflow">return</span> cwchT;
00718                     }
00719                     <span class="comment">/*</span>
00720 <span class="comment">                     * Not a match, try the next entry.</span>
00721 <span class="comment">                     */</span>
00722                     pLigature = (PLIGATURE1)((<a class="code" href="../../d9/d7/halvprnt_8c.html#a1">PBYTE</a>)pLigature + pKbdTbl-&gt;cbLgEntry);
00723                 }
00724                 <span class="comment">/*</span>
00725 <span class="comment">                 * No match found!</span>
00726 <span class="comment">                 */</span>
00727                 <a class="code" href="../../d4/d1/userk_8h.html#a1730">xxxMessageBeep</a>(0);
00728                 <span class="keywordflow">goto</span> ReturnBadCharacter;
00729             }
00730 
00731             <span class="comment">/*</span>
00732 <span class="comment">             * Match found: return the unshifted character</span>
00733 <span class="comment">             */</span>
00734             TAGMSG2(DBGTAG_ToUnicode,
00735                     <span class="stringliteral">"xxxInternalToUnicode: Match found '%C'(%x), goto ReturnGoodChar"</span>,
00736                     pVK-&gt;wch[nShift], pVK-&gt;wch[nShift]);
00737             <span class="keywordflow">goto</span> ReturnGoodCharacter;
00738 
00739         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((wModBits == KBDCTRL) || (wModBits == (KBDCTRL|KBDSHIFT)) ||
00740              (wModBits == (KBDKANA|KBDCTRL)) || (wModBits == (KBDKANA|KBDCTRL|KBDSHIFT))) {
00741             <span class="comment">/*</span>
00742 <span class="comment">             * There was no entry for this combination of Modification (nShift)</span>
00743 <span class="comment">             * and Virtual Key (uVirtKey).  It may still be an ASCII control</span>
00744 <span class="comment">             * character though:</span>
00745 <span class="comment">             */</span>
00746             <span class="keywordflow">if</span> ((uVirtKey &gt;= <span class="charliteral">'A'</span>) &amp;&amp; (uVirtKey &lt;= <span class="charliteral">'Z'</span>)) {
00747                 <span class="comment">/*</span>
00748 <span class="comment">                 * If the virtual key is in the range A-Z we can convert</span>
00749 <span class="comment">                 * it directly to a control character.  Otherwise, we</span>
00750 <span class="comment">                 * need to search the control key conversion table for</span>
00751 <span class="comment">                 * a match to the virtual key.</span>
00752 <span class="comment">                 */</span>
00753                 *pUniChar = (WORD)(uVirtKey &amp; 0x1f);
00754                 <span class="keywordflow">return</span> 1;
00755             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((uVirtKey &gt;= 0xFF61) &amp;&amp; (uVirtKey &lt;= 0xFF91)) {
00756                 <span class="comment">/*</span>
00757 <span class="comment">                 * If the virtual key is in range FF61-FF91 (halfwidth</span>
00758 <span class="comment">                 * katakana), we convert it to Virtual scan code with</span>
00759 <span class="comment">                 * KANA modifier.</span>
00760 <span class="comment">                 */</span>
00761                 *pUniChar = (WORD)(<a class="code" href="../../d4/d1/userk_8h.html#a1123">InternalVkKeyScanEx</a>((WCHAR)uVirtKey,pKbdTbl) &amp; 0x1f);
00762                 <span class="keywordflow">return</span> 1;
00763             }
00764         }
00765     }
00766 
00767 ReturnBadCharacter:
00768     <span class="comment">// pkl-&gt;wchDiacritic = 0;</span>
00769     <span class="keywordflow">return</span> 0;
00770 
00771 ReturnDeadCharacter:
00772     *pUniChar = pVK-&gt;wch[nShift];
00773 
00774     <span class="comment">/*</span>
00775 <span class="comment">     * Save 'dead' key: overwrite an existing one.</span>
00776 <span class="comment">     */</span>
00777     <span class="keywordflow">if</span> (!(*pdwKeyFlags &amp; KBDBREAK)) {
00778         pkl-&gt;<a class="code" href="../../d4/d9/structtagKL.html#o9">wchDiacritic</a> = *pUniChar;
00779     }
00780 
00781     UserAssert(pKbdTbl-&gt;pDeadKey);
00782 
00783     <span class="comment">/*</span>
00784 <span class="comment">     * return negative count for dead characters</span>
00785 <span class="comment">     */</span>
00786     <span class="keywordflow">return</span> -1;
00787 
00788 ReturnGoodCharacter:
00789     <span class="keywordflow">if</span> ((pKbdTbl-&gt;pDeadKey != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp; (pkl-&gt;<a class="code" href="../../d4/d9/structtagKL.html#o9">wchDiacritic</a> != 0)) {
00790         <span class="keywordflow">return</span> <a class="code" href="../../d2/d4/tounicod_8c.html#a12">ComposeDeadKeys</a>(
00791                   pkl,
00792                   pKbdTbl-&gt;pDeadKey,
00793                   pVK-&gt;wch[nShift],
00794                   pUniChar,
00795                   cChar,
00796                   *pdwKeyFlags &amp; KBDBREAK
00797                   );
00798     }
00799     *pUniChar = (WORD)pVK-&gt;wch[nShift];
00800     <span class="keywordflow">return</span> 1;
00801 }
00802 
<a name="l00803"></a><a class="code" href="../../d4/d1/userk_8h.html#a1123">00803</a> <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a13">SHORT</a> <a class="code" href="../../d4/d1/userk_8h.html#a1123">InternalVkKeyScanEx</a>(
00804     WCHAR wchChar,
00805     PKBDTABLES pKbdTbl)
00806 {
00807     PVK_TO_WCHARS1 pVK;
00808     PVK_TO_WCHAR_TABLE pVKT;
00809     <a class="code" href="../../d9/d7/halvprnt_8c.html#a0">BYTE</a> nShift;
00810     WORD wModBits;
00811     WORD wModNumCtrl, wModNumShiftCtrl;
00812     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a13">SHORT</a> shRetvalCtrl = 0;
00813     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a13">SHORT</a> shRetvalShiftCtrl = 0;
00814 
00815     <span class="keywordflow">if</span> (pKbdTbl == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00816         pKbdTbl = <a class="code" href="../../d3/d6/ntuser_2kernel_2globals_8c.html#a62">gspklBaseLayout</a>-&gt;<a class="code" href="../../d4/d9/structtagKL.html#o5">spkf</a>-&gt;<a class="code" href="../../d1/d9/structtagKBDFILE.html#o4">pKbdTbl</a>;
00817     }
00818 
00819     <span class="comment">/*</span>
00820 <span class="comment">     * Ctrl and Shift-Control combinations are less favored, so determine</span>
00821 <span class="comment">     * the values for nShift which we prefer not to use if at all possible.</span>
00822 <span class="comment">     * This is for compatibility with Windows 95/98, which only returns a</span>
00823 <span class="comment">     * Ctrl or Shift+Ctrl combo as a last resort. See bugs #78891 &amp; #229141</span>
00824 <span class="comment">     */</span>
00825     wModNumCtrl = <a class="code" href="../../d3/d1/xlate_8c.html#a2">GetModificationNumber</a>(pKbdTbl-&gt;pCharModifiers, KBDCTRL);
00826     wModNumShiftCtrl = <a class="code" href="../../d3/d1/xlate_8c.html#a2">GetModificationNumber</a>(pKbdTbl-&gt;pCharModifiers, KBDSHIFT | KBDCTRL);
00827 
00828     <span class="keywordflow">for</span> (pVKT = pKbdTbl-&gt;pVkToWcharTable; pVKT-&gt;pVkToWchars != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>; pVKT++) {
00829         <span class="keywordflow">for</span> (pVK = pVKT-&gt;pVkToWchars;
00830                 pVK-&gt;VirtualKey != 0;
00831                 pVK = (PVK_TO_WCHARS1)((<a class="code" href="../../d9/d7/halvprnt_8c.html#a1">PBYTE</a>)pVK + pVKT-&gt;cbSize)) {
00832             <span class="keywordflow">for</span> (nShift = 0; nShift &lt; pVKT-&gt;nModifications; nShift++) {
00833                 <span class="keywordflow">if</span> (pVK-&gt;wch[nShift] == wchChar) {
00834                     <span class="comment">/*</span>
00835 <span class="comment">                     * A matching character has been found!</span>
00836 <span class="comment">                     */</span>
00837                     <span class="keywordflow">if</span> (pVK-&gt;VirtualKey == 0xff) {
00838                         <span class="comment">/*</span>
00839 <span class="comment">                         * dead char: back up to previous line to get the VK.</span>
00840 <span class="comment">                         */</span>
00841                         pVK = (PVK_TO_WCHARS1)((<a class="code" href="../../d9/d7/halvprnt_8c.html#a1">PBYTE</a>)pVK - pVKT-&gt;cbSize);
00842                     }
00843 
00844                     <span class="comment">/*</span>
00845 <span class="comment">                     * If this is the first Ctrl or the first Shift+Ctrl match,</span>
00846 <span class="comment">                     * remember in case we don't find any better match.</span>
00847 <span class="comment">                     * In the meantime, keep on looking.</span>
00848 <span class="comment">                     */</span>
00849                     <span class="keywordflow">if</span> (nShift == wModNumCtrl) {
00850                         <span class="keywordflow">if</span> (shRetvalCtrl == 0) {
00851                             shRetvalCtrl = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a13">SHORT</a>)MAKEWORD(pVK-&gt;VirtualKey, KBDCTRL);
00852                         }
00853                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nShift == wModNumShiftCtrl) {
00854                         <span class="keywordflow">if</span> (shRetvalShiftCtrl == 0) {
00855                             shRetvalShiftCtrl = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a13">SHORT</a>)MAKEWORD(pVK-&gt;VirtualKey, KBDCTRL | KBDSHIFT);
00856                         }
00857                     } <span class="keywordflow">else</span> {
00858                         <span class="comment">/*</span>
00859 <span class="comment">                         * this seems like a very good match!</span>
00860 <span class="comment">                         */</span>
00861                         <span class="keywordflow">goto</span> GoodMatchFound;
00862                     }
00863                 }
00864             }
00865         }
00866     }
00867 
00868     <span class="comment">/*</span>
00869 <span class="comment">     * Didn't find a good match: use whatever Ctrl/Shift+Ctrl match was found</span>
00870 <span class="comment">     */</span>
00871     <span class="keywordflow">if</span> (shRetvalCtrl) {
00872         <span class="keywordflow">return</span> shRetvalCtrl;
00873     }
00874     <span class="keywordflow">if</span> (shRetvalShiftCtrl) {
00875         <span class="keywordflow">return</span> shRetvalShiftCtrl;
00876     }
00877 
00878     <span class="comment">/*</span>
00879 <span class="comment">     * May be a control character not explicitly in the layout tables</span>
00880 <span class="comment">     */</span>
00881     <span class="keywordflow">if</span> (wchChar &lt; 0x0020) {
00882         <span class="comment">/*</span>
00883 <span class="comment">         * Ctrl+char -&gt; char - 0x40</span>
00884 <span class="comment">         */</span>
00885         <span class="keywordflow">return</span> (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a13">SHORT</a>)MAKEWORD((wchChar + 0x40), KBDCTRL);
00886     }
00887     <span class="keywordflow">return</span> -1;
00888 
00889 GoodMatchFound:
00890     <span class="comment">/*</span>
00891 <span class="comment">     * Scan aModification[] to find nShift: the index will be a bitmask</span>
00892 <span class="comment">     * representing the Shifter Keys that need to be pressed to produce</span>
00893 <span class="comment">     * this Shift State.</span>
00894 <span class="comment">     */</span>
00895     <span class="keywordflow">for</span> (wModBits = 0;
00896          wModBits &lt;= pKbdTbl-&gt;pCharModifiers-&gt;wMaxModBits;
00897          wModBits++)
00898     {
00899         <span class="keywordflow">if</span> (pKbdTbl-&gt;pCharModifiers-&gt;ModNumber[wModBits] == nShift) {
00900             <span class="keywordflow">if</span> (pVK-&gt;VirtualKey == 0xff) {
00901                 <span class="comment">/*</span>
00902 <span class="comment">                 * The previous entry contains the actual virtual key in this case.</span>
00903 <span class="comment">                 */</span>
00904                 pVK = (PVK_TO_WCHARS1)((<a class="code" href="../../d9/d7/halvprnt_8c.html#a1">PBYTE</a>)pVK - pVKT-&gt;cbSize);
00905             }
00906             <span class="keywordflow">return</span> (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a13">SHORT</a>)MAKEWORD(pVK-&gt;VirtualKey, wModBits);
00907         }
00908     }
00909 
00910     <span class="comment">/*</span>
00911 <span class="comment">     * huh? should never reach here! (IanJa)</span>
00912 <span class="comment">     */</span>
00913     UserAssertMsg1(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, <span class="stringliteral">"InternalVkKeyScanEx error: wchChar = 0x%x"</span>, wchChar);
00914     <span class="keywordflow">return</span> -1;
00915 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:42:02 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
