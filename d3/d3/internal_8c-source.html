<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: internal.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>internal.c</h1><a href="../../d2/d4/internal_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1989-1993  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    internal.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module contains the internal subroutines used by the I/O system.</span>
00012 <span class="comment"></span>
00013 <span class="comment">Author:</span>
00014 <span class="comment"></span>
00015 <span class="comment">    Darryl E. Havens (darrylh) 18-Apr-1989</span>
00016 <span class="comment"></span>
00017 <span class="comment">Environment:</span>
00018 <span class="comment"></span>
00019 <span class="comment">    Kernel mode, local to I/O system</span>
00020 <span class="comment"></span>
00021 <span class="comment">Revision History:</span>
00022 <span class="comment"></span>
00023 <span class="comment"></span>
00024 <span class="comment">--*/</span>
00025 
00026 <span class="preprocessor">#include "<a class="code" href="../../d0/d6/iop_8h.html">iop.h</a>"</span>
00027 <span class="preprocessor">#pragma hdrstop</span>
00028 <span class="preprocessor"></span><span class="preprocessor">#include &lt;ioevent.h&gt;</span>
00029 
00030 <span class="comment">//PLJTMP</span>
00031 <span class="preprocessor">#if defined(_X86_)</span>
00032 <span class="preprocessor"></span><a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00033 <a class="code" href="../../d6/d9/assert_8c.html#a1">RtlAssert</a>(
00034     IN PVOID FailedAssertion,
00035     IN PVOID FileName,
00036     IN ULONG LineNumber,
00037     IN PCHAR Message OPTIONAL
00038     );
00039 <span class="preprocessor">#endif</span>
00040 <span class="preprocessor"></span><span class="comment">//PLJTMPend</span>
00041 
<a name="l00042"></a><a class="code" href="../../d2/d4/internal_8c.html#a0">00042</a> <span class="preprocessor">#define IsFileLocal( FileObject ) ( !((FileObject)-&gt;DeviceObject-&gt;Characteristics &amp; FILE_REMOTE_DEVICE) )</span>
00043 <span class="preprocessor"></span>
<a name="l00044"></a><a class="code" href="../../d2/d4/internal_8c.html#a6">00044</a> <span class="keyword">typedef</span> LINK_TRACKING_INFORMATION <a class="code" href="../../d2/d4/internal_8c.html#a5">FILE_VOLUMEID_WITH_TYPE</a>, *<a class="code" href="../../d2/d4/internal_8c.html#a6">PFILE_VOLUMEID_WITH_TYPE</a>;
00045 
<a name="l00046"></a><a class="code" href="../../d1/d2/struct__TRACKING__BUFFER.html">00046</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d1/d2/struct__TRACKING__BUFFER.html">_TRACKING_BUFFER</a> {
<a name="l00047"></a><a class="code" href="../../d1/d2/struct__TRACKING__BUFFER.html#o0">00047</a>     FILE_TRACKING_INFORMATION <a class="code" href="../../d1/d2/struct__TRACKING__BUFFER.html#o0">TrackingInformation</a>;
<a name="l00048"></a><a class="code" href="../../d1/d2/struct__TRACKING__BUFFER.html#o1">00048</a>     UCHAR <a class="code" href="../../d1/d2/struct__TRACKING__BUFFER.html#o1">Buffer</a>[256];
00049 } <a class="code" href="../../d1/d2/struct__TRACKING__BUFFER.html">TRACKING_BUFFER</a>, *<a class="code" href="../../d1/d2/struct__TRACKING__BUFFER.html">PTRACKING_BUFFER</a>;
00050 
<a name="l00051"></a><a class="code" href="../../d8/d3/struct__REMOTE__LINK__BUFFER.html">00051</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d8/d3/struct__REMOTE__LINK__BUFFER.html">_REMOTE_LINK_BUFFER</a> {
<a name="l00052"></a><a class="code" href="../../d8/d3/struct__REMOTE__LINK__BUFFER.html#o0">00052</a>     REMOTE_LINK_TRACKING_INFORMATION <a class="code" href="../../d8/d3/struct__REMOTE__LINK__BUFFER.html#o0">TrackingInformation</a>;
<a name="l00053"></a><a class="code" href="../../d8/d3/struct__REMOTE__LINK__BUFFER.html#o1">00053</a>     UCHAR <a class="code" href="../../d8/d3/struct__REMOTE__LINK__BUFFER.html#o1">Buffer</a>[256];
00054 } <a class="code" href="../../d8/d3/struct__REMOTE__LINK__BUFFER.html">REMOTE_LINK_BUFFER</a>, *<a class="code" href="../../d8/d3/struct__REMOTE__LINK__BUFFER.html">PREMOTE_LINK_BUFFER</a>;
00055 
<a name="l00056"></a><a class="code" href="../../d2/d4/internal_8c.html#a11">00056</a> <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> <a class="code" href="../../d2/d4/internal_8c.html#a11">IopDeadIrp</a>;
00057 
00058 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00059 <a class="code" href="../../d2/d4/internal_8c.html#a13">IopResurrectDriver</a>(
00060     <a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html">PDRIVER_OBJECT</a> DriverObject
00061     );
00062 
00063 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00064 <a class="code" href="../../d2/d4/internal_8c.html#a14">IopUserRundown</a>(
00065     IN <a class="code" href="../../d1/d5/struct__KAPC.html">PKAPC</a> Apc
00066     );
00067 
00068 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00069 <a class="code" href="../../d2/d4/internal_8c.html#a15">IopMarshalIds</a>(
00070     OUT PTRACKING_BUFFER TrackingBuffer,
00071     IN  PFILE_VOLUMEID_WITH_TYPE  TargetVolumeId,
00072     IN  PFILE_OBJECTID_BUFFER  TargetObjectId,
00073     IN  PFILE_TRACKING_INFORMATION TrackingInfo
00074     );
00075 
00076 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00077 <a class="code" href="../../d2/d4/internal_8c.html#a16">IopUnMarshalIds</a>(
00078     IN  FILE_TRACKING_INFORMATION * TrackingInformation,
00079     OUT FILE_VOLUMEID_WITH_TYPE * TargetVolumeId,
00080     OUT GUID * TargetObjectId,
00081     OUT GUID * TargetMachineId
00082     );
00083 
00084 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00085 <a class="code" href="../../d2/d4/internal_8c.html#a17">IopBootLogToFile</a>(
00086     PUNICODE_STRING String
00087     );
00088 
00089 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00090 <a class="code" href="../../d2/d4/internal_8c.html#a18">IopCopyBootLogRegistryToFile</a>(
00091     VOID
00092     );
00093 
00094 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00095 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopAbortRequest)</span>
00096 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopAcquireFileObjectLock)</span>
00097 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopAllocateIrpCleanup)</span>
00098 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopCancelAlertedRequest)</span>
00099 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopCheckGetQuotaBufferValidity)</span>
00100 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopConnectLinkTrackingPort)</span>
00101 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopDeallocateApc)</span>
00102 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopExceptionCleanup)</span>
00103 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopGetDriverNameFromKeyNode)</span>
00104 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopGetFileName)</span>
00105 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopGetRegistryKeyInformation)</span>
00106 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopGetRegistryValue)</span>
00107 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopGetRegistryValues)</span>
00108 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopGetSetObjectId)</span>
00109 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopGetVolumeId)</span>
00110 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopInvalidateVolumesForDevice)</span>
00111 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopIsSameMachine)</span>
00112 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopLoadDriver)</span>
00113 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopLoadFileSystemDriver)</span>
00114 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopLoadUnloadDriver)</span>
00115 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopMountVolume)</span>
00116 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopMarshalIds)</span>
00117 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopOpenLinkOrRenameTarget)</span>
00118 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopOpenRegistryKey)</span>
00119 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopQueryXxxInformation)</span>
00120 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopReadyDeviceObjects)</span>
00121 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopSendMessageToTrackService)</span>
00122 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopSetEaOrQuotaInformationFile)</span>
00123 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopSetRemoteLink)</span>
00124 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopSynchronousApiServiceTail)</span>
00125 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopSynchronousServiceTail)</span>
00126 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopTrackLink)</span>
00127 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopUnMarshalIds)</span>
00128 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopUserCompletion)</span>
00129 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopUserRundown)</span>
00130 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopXxxControlFile)</span>
00131 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopLookupBusStringFromID)</span>
00132 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopInitializeBootLogging)</span>
00133 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopBootLog)</span>
00134 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopCopyBootLogRegistryToFile)</span>
00135 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopBootLogToFile)</span>
00136 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00137 <span class="preprocessor"></span>
00138 
00139 
00140 
00141 
00142 
00143 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00144"></a><a class="code" href="../../d0/d6/iop_8h.html#a146">00144</a> <a class="code" href="../../d0/d6/iop_8h.html#a146">IopAbortRequest</a>(
00145     IN <a class="code" href="../../d1/d5/struct__KAPC.html">PKAPC</a> Apc
00146     )
00147 
00148 <span class="comment">/*++</span>
00149 <span class="comment"></span>
00150 <span class="comment">Routine Description:</span>
00151 <span class="comment"></span>
00152 <span class="comment">    This routine is invoked to abort an I/O request.  It is invoked during the</span>
00153 <span class="comment">    rundown of a thread.</span>
00154 <span class="comment"></span>
00155 <span class="comment">Arguments:</span>
00156 <span class="comment"></span>
00157 <span class="comment">    Apc - Pointer to the kernel APC structure.  This structure is contained</span>
00158 <span class="comment">        within the I/O Request Packet (IRP) itself.</span>
00159 <span class="comment"></span>
00160 <span class="comment">Return Value:</span>
00161 <span class="comment"></span>
00162 <span class="comment">    None.</span>
00163 <span class="comment"></span>
00164 <span class="comment">--*/</span>
00165 
00166 {
00167     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00168 
00169     <span class="comment">//</span>
00170     <span class="comment">// Invoke the normal special kernel APC routine.</span>
00171     <span class="comment">//</span>
00172 
00173     <a class="code" href="../../d0/d6/iop_8h.html#a157">IopCompleteRequest</a>( Apc,
00174                         &amp;Apc-&gt;NormalRoutine,
00175                         &amp;Apc-&gt;NormalContext,
00176                         &amp;Apc-&gt;SystemArgument1,
00177                         &amp;Apc-&gt;SystemArgument2 );
00178 }
00179 
00180 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00181"></a><a class="code" href="../../d0/d6/iop_8h.html#a147">00181</a> <a class="code" href="../../d0/d6/iop_8h.html#a147">IopAcquireFileObjectLock</a>(
00182     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00183     IN KPROCESSOR_MODE RequestorMode,
00184     IN BOOLEAN Alertable,
00185     OUT PBOOLEAN Interrupted
00186     )
00187 
00188 <span class="comment">/*++</span>
00189 <span class="comment"></span>
00190 <span class="comment">Routine Description:</span>
00191 <span class="comment"></span>
00192 <span class="comment">    This routine is invoked to acquire the lock for a file object whenever</span>
00193 <span class="comment">    there is contention and obtaining the fast lock for the file failed.</span>
00194 <span class="comment"></span>
00195 <span class="comment">Arguments:</span>
00196 <span class="comment"></span>
00197 <span class="comment">    FileObject - Pointer to the file object whose lock is to be acquired.</span>
00198 <span class="comment"></span>
00199 <span class="comment">    RequestorMode - Processor access mode of the caller.</span>
00200 <span class="comment"></span>
00201 <span class="comment">    Alertable - Indicates whether or not the lock should be obtained in an</span>
00202 <span class="comment">        alertable manner.</span>
00203 <span class="comment"></span>
00204 <span class="comment">    Interrupted - A variable to receive a BOOLEAN that indicates whether or</span>
00205 <span class="comment">        not the attempt to acquire the lock was interrupted by an alert or</span>
00206 <span class="comment">        an APC.</span>
00207 <span class="comment"></span>
00208 <span class="comment">Return Value:</span>
00209 <span class="comment"></span>
00210 <span class="comment">    The function status is the final status of the operation.</span>
00211 <span class="comment"></span>
00212 <span class="comment">--*/</span>
00213 {
00214     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
00215 
00216     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00217 
00218     <span class="comment">//</span>
00219     <span class="comment">// Assume that the function will not be interrupted by an alert or an</span>
00220     <span class="comment">// APC while attempting to acquire the lock.</span>
00221     <span class="comment">//</span>
00222 
00223     *Interrupted = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00224 
00225     <span class="comment">//</span>
00226     <span class="comment">// Loop attempting to acquire the lock for the file object.</span>
00227     <span class="comment">//</span>
00228 
00229     InterlockedIncrement (&amp;FileObject-&gt;Waiters);
00230 
00231     <span class="keywordflow">for</span> (;;) {
00232         <span class="keywordflow">if</span> (!FileObject-&gt;Busy) {
00233 
00234             <span class="comment">//</span>
00235             <span class="comment">// The file object appears to be un-owned, try to acquire it</span>
00236             <span class="comment">//</span>
00237 
00238             <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a13">IopAcquireFastLock</a> ( FileObject ) ) {
00239 
00240                 <span class="comment">//</span>
00241                 <span class="comment">// Object was acquired. Remove our count and return success</span>
00242                 <span class="comment">//</span>
00243 
00244                 InterlockedDecrement (&amp;FileObject-&gt;Waiters);
00245                 <span class="keywordflow">return</span> STATUS_SUCCESS;
00246             }
00247         }
00248 
00249         <span class="comment">//</span>
00250         <span class="comment">// Wait for the event that indicates that the thread that currently</span>
00251         <span class="comment">// owns the file object has released it.</span>
00252         <span class="comment">//</span>
00253 
00254         status = <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;FileObject-&gt;Lock,
00255                                         <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
00256                                         RequestorMode,
00257                                         Alertable,
00258                                         (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00259 
00260         <span class="comment">//</span>
00261         <span class="comment">// If the above wait was interrupted, then indicate so and return.</span>
00262         <span class="comment">// Before returning, however, check the state of the ownership of</span>
00263         <span class="comment">// the file object itself.  If it is not currently owned (the busy</span>
00264         <span class="comment">// flag is clear), then check to see whether or not there are any</span>
00265         <span class="comment">// other waiters.  If so, then set the event to the signaled state</span>
00266         <span class="comment">// again so that they wake up and check the state of the busy flag.</span>
00267         <span class="comment">//</span>
00268 
00269         <span class="keywordflow">if</span> (status == STATUS_USER_APC || status == STATUS_ALERTED) {
00270             InterlockedDecrement (&amp;FileObject-&gt;Waiters);
00271 
00272             <span class="keywordflow">if</span> (!FileObject-&gt;Busy  &amp;&amp;  FileObject-&gt;Waiters) {
00273                 <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>( &amp;FileObject-&gt;Lock, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00274 
00275             }
00276             *Interrupted = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00277             <span class="keywordflow">return</span> status;
00278         }
00279     }
00280 }
00281 
00282 
00283 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00284"></a><a class="code" href="../../d0/d6/iop_8h.html#a148">00284</a> <a class="code" href="../../d0/d6/iop_8h.html#a148">IopAllocateIrpCleanup</a>(
00285     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00286     IN <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> EventObject OPTIONAL
00287     )
00288 
00289 <span class="comment">/*++</span>
00290 <span class="comment"></span>
00291 <span class="comment">Routine Description:</span>
00292 <span class="comment"></span>
00293 <span class="comment">    This routine is invoked internally by those system services that attempt</span>
00294 <span class="comment">    to allocate an IRP and fail.  This routine cleans up the file object</span>
00295 <span class="comment">    and any event object that has been references and releases any locks</span>
00296 <span class="comment">    that were taken out.</span>
00297 <span class="comment"></span>
00298 <span class="comment">Arguments:</span>
00299 <span class="comment"></span>
00300 <span class="comment">    FileObject - Pointer to the file object being worked on.</span>
00301 <span class="comment"></span>
00302 <span class="comment">    EventObject - Optional pointer to a referenced event to be dereferenced.</span>
00303 <span class="comment"></span>
00304 <span class="comment">Return Value:</span>
00305 <span class="comment"></span>
00306 <span class="comment">    None.</span>
00307 <span class="comment"></span>
00308 <span class="comment">--*/</span>
00309 
00310 {
00311     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00312 
00313     <span class="comment">//</span>
00314     <span class="comment">// Begin by dereferencing the event, if one was specified.</span>
00315     <span class="comment">//</span>
00316 
00317     <span class="keywordflow">if</span> (ARGUMENT_PRESENT( EventObject )) {
00318         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( EventObject );
00319     }
00320 
00321     <span class="comment">//</span>
00322     <span class="comment">// Release the synchronization semaphore if it is currently held and</span>
00323     <span class="comment">// dereference the file object.</span>
00324     <span class="comment">//</span>
00325 
00326     <span class="keywordflow">if</span> (FileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>) {
00327         <a class="code" href="../../d0/d6/iop_8h.html#a22">IopReleaseFileObjectLock</a>( FileObject );
00328     }
00329 
00330     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( FileObject );
00331 
00332     <span class="keywordflow">return</span>;
00333 }
00334 
00335 <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>
<a name="l00336"></a><a class="code" href="../../d0/d6/iop_8h.html#a149">00336</a> <a class="code" href="../../d0/d6/iop_8h.html#a149">IopAllocateIrpMustSucceed</a>(
00337     IN CCHAR StackSize
00338     )
00339 
00340 <span class="comment">/*++</span>
00341 <span class="comment"></span>
00342 <span class="comment">Routine Description:</span>
00343 <span class="comment"></span>
00344 <span class="comment">    This routine is invoked to allocate an IRP when there are no appropriate</span>
00345 <span class="comment">    packets remaining on the look-aside list, and no memory was available</span>
00346 <span class="comment">    from the general non-paged pool, and yet, the code path requiring the</span>
00347 <span class="comment">    packet has no way of backing out and simply returning an error.  There-</span>
00348 <span class="comment">    fore, it must allocate an IRP.  Hence, this routine is called to allocate</span>
00349 <span class="comment">    that packet.</span>
00350 <span class="comment"></span>
00351 <span class="comment">Arguments:</span>
00352 <span class="comment"></span>
00353 <span class="comment">    StackSize - Supplies the number of IRP I/O stack locations that the</span>
00354 <span class="comment">        packet must have when allocated.</span>
00355 <span class="comment"></span>
00356 <span class="comment">Return Value:</span>
00357 <span class="comment"></span>
00358 <span class="comment">    A pointer to the allocated I/O Request Packet.</span>
00359 <span class="comment"></span>
00360 <span class="comment">--*/</span>
00361 
00362 {
00363     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
00364     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> packetSize;
00365 
00366     <span class="comment">//</span>
00367     <span class="comment">// Attempt to allocate the IRP normally and failing that, allocate the</span>
00368     <span class="comment">// IRP from nonpaged must succeed pool.</span>
00369     <span class="comment">//</span>
00370 
00371     irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a17">IoAllocateIrp</a>(StackSize, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00372     <span class="keywordflow">if</span> (!irp) {
00373         packetSize = <a class="code" href="../../d0/d5/io_8h.html#a245">IoSizeOfIrp</a>(StackSize);
00374         irp = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(<a class="code" href="../../d5/d8/ex_8h.html#a329a175">NonPagedPoolMustSucceed</a>, packetSize, ' prI');
00375         <a class="code" href="../../d4/d6/iosubs_8c.html#a80">IoInitializeIrp</a>(irp, packetSize, StackSize);
00376         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o17">AllocationFlags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a191">IRP_ALLOCATED_MUST_SUCCEED</a>;
00377     }
00378 
00379     <span class="keywordflow">return</span> irp;
00380 }
00381 
00382 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00383"></a><a class="code" href="../../d0/d6/iop_8h.html#a150">00383</a> <a class="code" href="../../d0/d6/iop_8h.html#a150">IopApcHardError</a>(
00384     IN PVOID StartContext
00385     )
00386 
00387 <span class="comment">/*++</span>
00388 <span class="comment"></span>
00389 <span class="comment">Routine Description:</span>
00390 <span class="comment"></span>
00391 <span class="comment">    This function is invoked when we need to do a hard error pop-up, but the</span>
00392 <span class="comment">    Irp's originating thread is at APC level, ie. IoPageRead.  We in a special</span>
00393 <span class="comment">    purpose thread that will go away when the user responds to the pop-up.</span>
00394 <span class="comment"></span>
00395 <span class="comment">Arguments:</span>
00396 <span class="comment"></span>
00397 <span class="comment">    StartContext - Startup context, contains a IOP_APC_HARD_ERROR_PACKET.</span>
00398 <span class="comment"></span>
00399 <span class="comment">Return Value:</span>
00400 <span class="comment"></span>
00401 <span class="comment">    None.</span>
00402 <span class="comment"></span>
00403 <span class="comment">--*/</span>
00404 
00405 {
00406     <a class="code" href="../../d5/d0/struct__IOP__APC__HARD__ERROR__PACKET.html">PIOP_APC_HARD_ERROR_PACKET</a> packet;
00407 
00408     packet = StartContext;
00409 
00410     <a class="code" href="../../d0/d6/iop_8h.html#a205">IopRaiseHardError</a>( packet-&gt;<a class="code" href="../../d5/d0/struct__IOP__APC__HARD__ERROR__PACKET.html#o1">Irp</a>, packet-&gt;<a class="code" href="../../d5/d0/struct__IOP__APC__HARD__ERROR__PACKET.html#o2">Vpb</a>, packet-&gt;<a class="code" href="../../d5/d0/struct__IOP__APC__HARD__ERROR__PACKET.html#o3">RealDeviceObject</a> );
00411 
00412     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( packet );
00413 }
00414 
00415 
00416 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00417"></a><a class="code" href="../../d0/d6/iop_8h.html#a151">00417</a> <a class="code" href="../../d0/d6/iop_8h.html#a151">IopCancelAlertedRequest</a>(
00418     IN <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> Event,
00419     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
00420     )
00421 
00422 <span class="comment">/*++</span>
00423 <span class="comment"></span>
00424 <span class="comment">Routine Description:</span>
00425 <span class="comment"></span>
00426 <span class="comment">    This routine is invoked when a synchronous I/O operation that is blocked in</span>
00427 <span class="comment">    the I/O system needs to be canceled because the thread making the request has</span>
00428 <span class="comment">    either been alerted because it is going away or because of a CTRL/C.  This</span>
00429 <span class="comment">    routine carefully attempts to work its way out of the current operation so</span>
00430 <span class="comment">    that local events or other local data will not be accessed once the service</span>
00431 <span class="comment">    being interrupted returns.</span>
00432 <span class="comment"></span>
00433 <span class="comment">Arguments:</span>
00434 <span class="comment"></span>
00435 <span class="comment">    Event - The address of a kernel event that will be set to the Signaled state</span>
00436 <span class="comment">        by I/O completion when the request is complete.</span>
00437 <span class="comment"></span>
00438 <span class="comment">    Irp - Pointer to the I/O Request Packet (IRP) representing the current request.</span>
00439 <span class="comment"></span>
00440 <span class="comment">Return Value:</span>
00441 <span class="comment"></span>
00442 <span class="comment">    None.</span>
00443 <span class="comment"></span>
00444 <span class="comment">--*/</span>
00445 
00446 {
00447     KIRQL irql;
00448     LARGE_INTEGER deltaTime;
00449     BOOLEAN canceled;
00450 
00451     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00452 
00453     <span class="comment">//</span>
00454     <span class="comment">// Begin by blocking special kernel APCs so that the request cannot</span>
00455     <span class="comment">// complete.</span>
00456     <span class="comment">//</span>
00457 
00458     <a class="code" href="../../d9/d5/verifier_8c.html#a116">KeRaiseIrql</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a52">APC_LEVEL</a>, &amp;irql );
00459 
00460     <span class="comment">//</span>
00461     <span class="comment">// Check the state of the event to determine whether or not the</span>
00462     <span class="comment">// packet has already been completed.</span>
00463     <span class="comment">//</span>
00464 
00465     <span class="keywordflow">if</span> (<a class="code" href="../../d2/d8/eventobj_8c.html#a6">KeReadStateEvent</a>( <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a> ) == 0) {
00466 
00467         <span class="comment">//</span>
00468         <span class="comment">// The packet has not been completed, so attempt to cancel it.</span>
00469         <span class="comment">//</span>
00470 
00471         canceled = <a class="code" href="../../d4/d6/iosubs_8c.html#a30">IoCancelIrp</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
00472 
00473         <a class="code" href="../../d9/d5/verifier_8c.html#a117">KeLowerIrql</a>( irql );
00474 
00475         <span class="keywordflow">if</span> (canceled) {
00476 
00477             <span class="comment">//</span>
00478             <span class="comment">// The packet had a cancel routine, so it was canceled.  Loop,</span>
00479             <span class="comment">// waiting for the packet to complete.  This should occur almost</span>
00480             <span class="comment">// immediately.</span>
00481             <span class="comment">//</span>
00482 
00483             deltaTime.QuadPart = - 10 * 1000 * 10;
00484 
00485             <span class="keywordflow">while</span> (<a class="code" href="../../d2/d8/eventobj_8c.html#a6">KeReadStateEvent</a>( <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a> ) == 0) {
00486 
00487                 <a class="code" href="../../d1/d7/wait_8c.html#a2">KeDelayExecutionThread</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, &amp;deltaTime );
00488 
00489             }
00490 
00491         } <span class="keywordflow">else</span> {
00492 
00493             <span class="comment">//</span>
00494             <span class="comment">// The packet did not have a cancel routine, so simply wait for</span>
00495             <span class="comment">// the event to be set to the Signaled state.  This will save</span>
00496             <span class="comment">// CPU time by not looping, since it is not known when the packet</span>
00497             <span class="comment">// will actually complete.  Note, however, that the cancel flag</span>
00498             <span class="comment">// is set in the packet, so should a driver examine the flag</span>
00499             <span class="comment">// at some point in the future, it will immediately stop</span>
00500             <span class="comment">// processing the request.</span>
00501             <span class="comment">//</span>
00502 
00503             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>,
00504                                           <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
00505                                           <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
00506                                           <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00507                                           (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00508 
00509         }
00510 
00511     } <span class="keywordflow">else</span> {
00512 
00513         <span class="comment">//</span>
00514         <span class="comment">// The packet has already been completed, so simply lower the</span>
00515         <span class="comment">// IRQL back to its original value and exit.</span>
00516         <span class="comment">//</span>
00517 
00518         <a class="code" href="../../d9/d5/verifier_8c.html#a117">KeLowerIrql</a>( irql );
00519 
00520     }
00521 }
00522 
00523 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00524"></a><a class="code" href="../../d0/d6/iop_8h.html#a153">00524</a> <a class="code" href="../../d0/d6/iop_8h.html#a153">IopCheckGetQuotaBufferValidity</a>(
00525     IN PFILE_GET_QUOTA_INFORMATION QuotaBuffer,
00526     IN ULONG QuotaLength,
00527     OUT PULONG_PTR ErrorOffset
00528     )
00529 
00530 <span class="comment">/*++</span>
00531 <span class="comment"></span>
00532 <span class="comment">Routine Description:</span>
00533 <span class="comment"></span>
00534 <span class="comment">    This routine checks the validity of the specified get quota buffer to</span>
00535 <span class="comment">    guarantee that its format is proper, no fields hang over, that it is</span>
00536 <span class="comment">    not recursive, etc.</span>
00537 <span class="comment"></span>
00538 <span class="comment">Arguments:</span>
00539 <span class="comment"></span>
00540 <span class="comment">    QuotaBuffer - Pointer to the buffer containing the get quota structure</span>
00541 <span class="comment">        array to be checked.</span>
00542 <span class="comment"></span>
00543 <span class="comment">    QuotaLength - Specifies the length of the quota buffer.</span>
00544 <span class="comment"></span>
00545 <span class="comment">    ErrorOffset - A variable to receive the offset of the offending entry</span>
00546 <span class="comment">        in the quota buffer if an error is incurred.  This variable is only</span>
00547 <span class="comment">        valid if an error occurs.</span>
00548 <span class="comment"></span>
00549 <span class="comment">Return Value:</span>
00550 <span class="comment"></span>
00551 <span class="comment">    The function value is STATUS_SUCCESS if the get quota buffer contains a</span>
00552 <span class="comment">    valid, properly formed list, otherwise STATUS_QUOTA_LIST_INCONSISTENT.</span>
00553 <span class="comment"></span>
00554 <span class="comment">--*/</span>
00555 
00556 {
00557 
00558 <span class="preprocessor">#define GET_OFFSET_LENGTH( CurrentSid, SidBase ) ( (ULONG) ((PCHAR) CurrentSid - (PCHAR) SidBase) )</span>
00559 <span class="preprocessor"></span>
00560     LONG tempLength;
00561     LONG entrySize;
00562     PFILE_GET_QUOTA_INFORMATION sids;
00563 
00564     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00565 
00566     <span class="comment">//</span>
00567     <span class="comment">// Walk the buffer and ensure that its format is valid.  That is, ensure</span>
00568     <span class="comment">// that it does not walk off the end of the buffer, is not recursive, etc.</span>
00569     <span class="comment">//</span>
00570 
00571     sids = QuotaBuffer;
00572     tempLength = QuotaLength;
00573 
00574     <span class="keywordflow">for</span> (;;) {
00575 
00576         <span class="comment">//</span>
00577         <span class="comment">// Ensure that the current entry is valid.</span>
00578         <span class="comment">//</span>
00579 
00580         <span class="keywordflow">if</span> ((tempLength &lt; (LONG) (FIELD_OFFSET(FILE_GET_QUOTA_INFORMATION, Sid.SubAuthority) +
00581                                   <span class="keyword">sizeof</span> (sids-&gt;Sid.SubAuthority))) ||
00582             !<a class="code" href="../../d8/d6/sertl_8c.html#a35">RtlValidSid</a>( &amp;sids-&gt;Sid)) {
00583 
00584             *ErrorOffset = <a class="code" href="../../d2/d4/internal_8c.html#a1">GET_OFFSET_LENGTH</a>( sids, QuotaBuffer );
00585             <span class="keywordflow">return</span> STATUS_QUOTA_LIST_INCONSISTENT;
00586         }
00587 
00588         <span class="comment">//</span>
00589         <span class="comment">// Get the size of the current entry in the buffer.</span>
00590         <span class="comment">//</span>
00591 
00592         entrySize = FIELD_OFFSET( FILE_GET_QUOTA_INFORMATION, Sid ) + <a class="code" href="../../d8/d6/sertl_8c.html#a45">RtlLengthSid</a>( (&amp;sids-&gt;Sid) );
00593 
00594         <span class="keywordflow">if</span> (sids-&gt;NextEntryOffset) {
00595 
00596             <span class="comment">//</span>
00597             <span class="comment">// There is another entry in the buffer and it must be longword</span>
00598             <span class="comment">// aligned.  Ensure that the offset indicates that it is.  If it</span>
00599             <span class="comment">// isn't, return an invalid parameter status.</span>
00600             <span class="comment">//</span>
00601 
00602             <span class="keywordflow">if</span> (entrySize &gt; (LONG) sids-&gt;NextEntryOffset ||
00603                 sids-&gt;NextEntryOffset &amp; (<span class="keyword">sizeof</span>( ULONG ) - 1)) {
00604                 *ErrorOffset = <a class="code" href="../../d2/d4/internal_8c.html#a1">GET_OFFSET_LENGTH</a>( sids, QuotaBuffer );
00605                 <span class="keywordflow">return</span> STATUS_QUOTA_LIST_INCONSISTENT;
00606 
00607             } <span class="keywordflow">else</span> {
00608 
00609                 <span class="comment">//</span>
00610                 <span class="comment">// There is another entry in the buffer, so account for the</span>
00611                 <span class="comment">// size of the current entry in the length and get a pointer</span>
00612                 <span class="comment">// to the next entry.</span>
00613                 <span class="comment">//</span>
00614 
00615                 tempLength -= sids-&gt;NextEntryOffset;
00616                 <span class="keywordflow">if</span> (tempLength &lt; 0) {
00617                     *ErrorOffset = <a class="code" href="../../d2/d4/internal_8c.html#a1">GET_OFFSET_LENGTH</a>( sids, QuotaBuffer );
00618                     <span class="keywordflow">return</span> STATUS_QUOTA_LIST_INCONSISTENT;
00619                 }
00620                 sids = (PFILE_GET_QUOTA_INFORMATION) ((PCHAR) sids + sids-&gt;NextEntryOffset);
00621             }
00622 
00623         } <span class="keywordflow">else</span> {
00624 
00625             <span class="comment">//</span>
00626             <span class="comment">// There are no other entries in the buffer.  Simply account for</span>
00627             <span class="comment">// the overall buffer length according to the size of the current</span>
00628             <span class="comment">// entry and exit the loop.</span>
00629             <span class="comment">//</span>
00630 
00631             tempLength -= entrySize;
00632             <span class="keywordflow">break</span>;
00633         }
00634     }
00635 
00636     <span class="comment">//</span>
00637     <span class="comment">// All of the entries in the buffer have been processed.  Check to see</span>
00638     <span class="comment">// whether the overall buffer length went negative.  If so, return an</span>
00639     <span class="comment">// error.</span>
00640     <span class="comment">//</span>
00641 
00642     <span class="keywordflow">if</span> (tempLength &lt; 0) {
00643         *ErrorOffset = <a class="code" href="../../d2/d4/internal_8c.html#a1">GET_OFFSET_LENGTH</a>( sids, QuotaBuffer );
00644         <span class="keywordflow">return</span> STATUS_QUOTA_LIST_INCONSISTENT;
00645     }
00646 
00647     <span class="comment">//</span>
00648     <span class="comment">// The format of the get quota buffer was correct, so simply return a</span>
00649     <span class="comment">// success status code.</span>
00650     <span class="comment">//</span>
00651 
00652     <span class="keywordflow">return</span> STATUS_SUCCESS;
00653 }
00654 
00655 
00656 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00657"></a><a class="code" href="../../d0/d6/iop_8h.html#a155">00657</a> <a class="code" href="../../d0/d6/iop_8h.html#a155">IopCompleteUnloadOrDelete</a>(
00658     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
00659     IN KIRQL Irql
00660     )
00661 
00662 <span class="comment">/*++</span>
00663 <span class="comment"></span>
00664 <span class="comment">Routine Description:</span>
00665 <span class="comment"></span>
00666 <span class="comment">    This routine is invoked when the reference count on a device object</span>
00667 <span class="comment">    transitions to a zero and the driver is mark for unload or device has</span>
00668 <span class="comment">    been marked for delete. This means that it may be possible to actually</span>
00669 <span class="comment">    unload the driver or delete the device object.  If all</span>
00670 <span class="comment">    of the devices have a reference count of zero, then the driver is</span>
00671 <span class="comment">    actually unloaded.  Note that in order to ensure that this routine is</span>
00672 <span class="comment">    not invoked twice, at the same time, on two different processors, the</span>
00673 <span class="comment">    I/O database spin lock is still held at this point.</span>
00674 <span class="comment"></span>
00675 <span class="comment">Arguments:</span>
00676 <span class="comment"></span>
00677 <span class="comment">    DeviceObject - Supplies a pointer to one of the driver's device objects,</span>
00678 <span class="comment">        namely the one whose reference count just went to zero.</span>
00679 <span class="comment"></span>
00680 <span class="comment">    Irql - Specifies the IRQL of the processor at the time that the I/O</span>
00681 <span class="comment">        database lock was acquired.</span>
00682 <span class="comment"></span>
00683 <span class="comment">Return Value:</span>
00684 <span class="comment"></span>
00685 <span class="comment">    None.</span>
00686 <span class="comment"></span>
00687 <span class="comment">--*/</span>
00688 
00689 {
00690     <a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html">PDRIVER_OBJECT</a> driverObject;
00691     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
00692     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> baseDeviceObject;
00693     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> attachedDeviceObject;
00694     <a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html">PDEVOBJ_EXTENSION</a> deviceExtension;
00695     <a class="code" href="../../d4/d4/struct__DEVICE__NODE.html">PDEVICE_NODE</a> deviceNode;
00696 
00697     BOOLEAN unload = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00698 
00699     driverObject = DeviceObject-&gt;DriverObject;
00700 
00701     <span class="keywordflow">if</span> (DeviceObject-&gt;DeviceObjectExtension-&gt;ExtensionFlags &amp; <a class="code" href="../../d0/d5/io_8h.html#a140">DOE_REMOVE_PENDING</a>) {
00702 
00703         <span class="comment">//</span>
00704         <span class="comment">// Run some tests to determine if it is an appropriate time to notify</span>
00705         <span class="comment">// PnP that all file objects in the attachment chain have gone away.</span>
00706         <span class="comment">//</span>
00707 
00708         baseDeviceObject = <a class="code" href="../../d0/d6/iop_8h.html#a173">IopGetDeviceAttachmentBase</a>( DeviceObject );
00709         deviceExtension = baseDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o25">DeviceObjectExtension</a>;
00710         deviceNode = (<a class="code" href="../../d4/d4/struct__DEVICE__NODE.html">PDEVICE_NODE</a>)deviceExtension-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o6">DeviceNode</a>;
00711 
00712         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(deviceNode != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00713 
00714         <span class="comment">//</span>
00715         <span class="comment">// baseDeviceObject is a PDO, this is a PnP stack.  See if</span>
00716         <span class="comment">// an IRP_MN_REMOVE_DEVICE is pending.</span>
00717         <span class="comment">//</span>
00718 
00719         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(deviceNode-&gt;<a class="code" href="../../d4/d4/struct__DEVICE__NODE.html#o6">Flags</a> &amp; <a class="code" href="../../d9/d0/pnpiop_8h.html#a32">DNF_REMOVE_PENDING_CLOSES</a>);
00720 
00721         <span class="comment">//</span>
00722         <span class="comment">// PnP wants to be notified as soon as all refcounts on all devices in</span>
00723         <span class="comment">// this attachment chain go away.</span>
00724         <span class="comment">//</span>
00725 
00726         attachedDeviceObject = baseDeviceObject;
00727         <span class="keywordflow">while</span> (attachedDeviceObject != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00728 
00729             <span class="keywordflow">if</span> (attachedDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o2">ReferenceCount</a> != 0) {
00730 
00731                 <span class="comment">//</span>
00732                 <span class="comment">// At least one device object in the attachment chain has</span>
00733                 <span class="comment">// an outstanding open.</span>
00734                 <span class="comment">//</span>
00735 
00736                 ExReleaseSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, Irql );
00737 
00738                 <span class="keywordflow">return</span>;
00739             }
00740             attachedDeviceObject = attachedDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o5">AttachedDevice</a>;
00741         }
00742 
00743         <span class="comment">//</span>
00744         <span class="comment">// Now one more time changing DOE_REMOVE_PENDING to</span>
00745         <span class="comment">// DOE_REMOVE_PROCESSED.</span>
00746         <span class="comment">//</span>
00747 
00748         attachedDeviceObject = baseDeviceObject;
00749         <span class="keywordflow">while</span> (attachedDeviceObject != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00750 
00751             deviceExtension = attachedDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o25">DeviceObjectExtension</a>;
00752 
00753             deviceExtension-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o5">ExtensionFlags</a> &amp;= ~<a class="code" href="../../d0/d5/io_8h.html#a140">DOE_REMOVE_PENDING</a>;
00754             deviceExtension-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o5">ExtensionFlags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a141">DOE_REMOVE_PROCESSED</a>;
00755 
00756             attachedDeviceObject = attachedDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o5">AttachedDevice</a>;
00757         }
00758 
00759         <span class="comment">//</span>
00760         <span class="comment">// It is time to give PnP the notification it was waiting for.  We have</span>
00761         <span class="comment">// to release the spinlock before doing so.</span>
00762         <span class="comment">//</span>
00763 
00764         ExReleaseSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, Irql );
00765 
00766         <a class="code" href="../../d9/d0/pnpiop_8h.html#a316">IopChainDereferenceComplete</a>( baseDeviceObject );
00767 
00768         <span class="keywordflow">return</span>;
00769     }
00770 
00771     <span class="keywordflow">if</span> (DeviceObject-&gt;DeviceObjectExtension-&gt;ExtensionFlags &amp; <a class="code" href="../../d0/d5/io_8h.html#a139">DOE_DELETE_PENDING</a>) {
00772 
00773         <span class="keywordflow">if</span> ((DeviceObject-&gt;DeviceObjectExtension-&gt;ExtensionFlags &amp;
00774             <a class="code" href="../../d0/d5/io_8h.html#a138">DOE_UNLOAD_PENDING</a>) == 0 ||
00775             driverObject-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o3">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a143">DRVO_UNLOAD_INVOKED</a>) {
00776 
00777             unload = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00778         }
00779 
00780         <span class="comment">//</span>
00781         <span class="comment">// If another device is attached to this device, inform the former's</span>
00782         <span class="comment">// driver that the device is being deleted.</span>
00783         <span class="comment">//</span>
00784 
00785         <span class="keywordflow">if</span> (DeviceObject-&gt;AttachedDevice) {
00786             <a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html">PFAST_IO_DISPATCH</a> fastIoDispatch = DeviceObject-&gt;AttachedDevice-&gt;DriverObject-&gt;FastIoDispatch;
00787             <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> attachedDevice = DeviceObject-&gt;AttachedDevice;
00788 
00789             <span class="comment">//</span>
00790             <span class="comment">// Increment the device reference count so the detach routine</span>
00791             <span class="comment">// does not recurse back to here.</span>
00792             <span class="comment">//</span>
00793 
00794             DeviceObject-&gt;ReferenceCount++;
00795 
00796             ExReleaseSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, Irql );
00797 
00798             <span class="keywordflow">if</span> (fastIoDispatch &amp;&amp;
00799                 fastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o0">SizeOfFastIoDispatch</a> &gt; FIELD_OFFSET( <a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html">FAST_IO_DISPATCH</a>, FastIoDetachDevice ) &amp;&amp;
00800                 fastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o13">FastIoDetachDevice</a>) {
00801                 (fastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o13">FastIoDetachDevice</a>)( attachedDevice, DeviceObject );
00802             }
00803 
00804             ExAcquireSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, &amp;Irql );
00805 
00806             <span class="comment">//</span>
00807             <span class="comment">// Restore the reference count value.</span>
00808             <span class="comment">//</span>
00809 
00810             DeviceObject-&gt;ReferenceCount--;
00811 
00812             <span class="keywordflow">if</span> (DeviceObject-&gt;AttachedDevice ||
00813                 DeviceObject-&gt;ReferenceCount != 0) {
00814 
00815 
00816                 ExReleaseSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, Irql );
00817                 <span class="keywordflow">return</span>;
00818             }
00819         }
00820 
00821         ExReleaseSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, Irql );
00822 
00823         <span class="comment">//</span>
00824         <span class="comment">// Deallocate the memory for the security descriptor that was allocated</span>
00825         <span class="comment">// for this device object.</span>
00826         <span class="comment">//</span>
00827 
00828         <span class="keywordflow">if</span> (DeviceObject-&gt;SecurityDescriptor != (PSECURITY_DESCRIPTOR) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00829             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( DeviceObject-&gt;SecurityDescriptor );
00830         }
00831 
00832         <span class="comment">//</span>
00833         <span class="comment">// Remove this device object from the driver object's list.</span>
00834         <span class="comment">//</span>
00835 
00836         <a class="code" href="../../d4/d6/iosubs_8c.html#a43">IopInsertRemoveDevice</a>( DeviceObject-&gt;DriverObject, DeviceObject, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00837 
00838         <span class="comment">//</span>
00839         <span class="comment">// Finally, dereference the object so it is deleted.</span>
00840         <span class="comment">//</span>
00841 
00842         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( DeviceObject );
00843 
00844         <span class="comment">//</span>
00845         <span class="comment">// Return if the unload does not need to be done.</span>
00846         <span class="comment">//</span>
00847 
00848         <span class="keywordflow">if</span> (!unload) {
00849             <span class="keywordflow">return</span>;
00850         }
00851 
00852         <span class="comment">//</span>
00853         <span class="comment">// Reacquire the spin lock make sure the unload routine does has</span>
00854         <span class="comment">// not been called.</span>
00855         <span class="comment">//</span>
00856 
00857         ExAcquireSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, &amp;Irql );
00858 
00859         <span class="keywordflow">if</span> (driverObject-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o3">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a143">DRVO_UNLOAD_INVOKED</a>) {
00860 
00861             <span class="comment">//</span>
00862             <span class="comment">// Some other thread is doing the unload, release the lock and return.</span>
00863             <span class="comment">//</span>
00864 
00865             ExReleaseSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, Irql );
00866             <span class="keywordflow">return</span>;
00867         }
00868     }
00869 
00870     <span class="comment">//</span>
00871     <span class="comment">// Scan the list of device objects for this driver, looking for a</span>
00872     <span class="comment">// non-zero reference count.  If any reference count is non-zero, then</span>
00873     <span class="comment">// the driver may not be unloaded.</span>
00874     <span class="comment">//</span>
00875 
00876     deviceObject = driverObject-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o2">DeviceObject</a>;
00877 
00878     <span class="keywordflow">while</span> (deviceObject) {
00879         <span class="keywordflow">if</span> (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o2">ReferenceCount</a> || deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o5">AttachedDevice</a> ||
00880             deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o25">DeviceObjectExtension</a>-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o5">ExtensionFlags</a> &amp; (<a class="code" href="../../d0/d5/io_8h.html#a139">DOE_DELETE_PENDING</a> | <a class="code" href="../../d0/d5/io_8h.html#a140">DOE_REMOVE_PENDING</a>)) {
00881             unload = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00882             <span class="keywordflow">break</span>;
00883         }
00884         deviceObject = deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o4">NextDevice</a>;
00885     }
00886 
00887     <span class="keywordflow">if</span> (unload) {
00888         driverObject-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o3">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a143">DRVO_UNLOAD_INVOKED</a>;
00889     }
00890 
00891     ExReleaseSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, Irql );
00892 
00893     <span class="comment">//</span>
00894     <span class="comment">// If the reference counts for all of the devices is zero, then this</span>
00895     <span class="comment">// driver can now be unloaded.</span>
00896     <span class="comment">//</span>
00897 
00898     <span class="keywordflow">if</span> (unload) {
00899         <a class="code" href="../../d0/d2/struct__LOAD__PACKET.html">LOAD_PACKET</a> loadPacket;
00900 
00901         <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;loadPacket.<a class="code" href="../../d0/d2/struct__LOAD__PACKET.html#o1">Event</a>, NotificationEvent, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00902         loadPacket.<a class="code" href="../../d0/d2/struct__LOAD__PACKET.html#o2">DriverObject</a> = driverObject;
00903         <a class="code" href="../../d5/d8/ex_8h.html#a55">ExInitializeWorkItem</a>( &amp;loadPacket.<a class="code" href="../../d0/d2/struct__LOAD__PACKET.html#o0">WorkQueueItem</a>,
00904                               <a class="code" href="../../d2/d4/internal_8c.html#a52">IopLoadUnloadDriver</a>,
00905                               &amp;loadPacket );
00906         <a class="code" href="../../d5/d8/ex_8h.html#a261">ExQueueWorkItem</a>( &amp;loadPacket.<a class="code" href="../../d0/d2/struct__LOAD__PACKET.html#o0">WorkQueueItem</a>, <a class="code" href="../../d5/d8/ex_8h.html#a332a206">DelayedWorkQueue</a> );
00907         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;loadPacket.<a class="code" href="../../d0/d2/struct__LOAD__PACKET.html#o1">Event</a>,
00908                                       <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
00909                                       <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
00910                                       <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00911                                       (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00912 
00913         <a class="code" href="../../d5/d0/obclose_8c.html#a3">ObMakeTemporaryObject</a>( driverObject );
00914         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( driverObject );
00915     }
00916 }
00917 
00918 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00919"></a><a class="code" href="../../d0/d6/iop_8h.html#a156">00919</a> <a class="code" href="../../d0/d6/iop_8h.html#a156">IopCompletePageWrite</a>(
00920     IN <a class="code" href="../../d1/d5/struct__KAPC.html">PKAPC</a> Apc,
00921     IN PKNORMAL_ROUTINE *NormalRoutine,
00922     IN PVOID *NormalContext,
00923     IN PVOID *SystemArgument1,
00924     IN PVOID *SystemArgument2
00925     )
00926 
00927 <span class="comment">/*++</span>
00928 <span class="comment"></span>
00929 <span class="comment">Routine Description:</span>
00930 <span class="comment"></span>
00931 <span class="comment">    This routine executes as a special kernel APC routine in the context of</span>
00932 <span class="comment">    the Modified Page Writer (MPW) system thread when an out-page operation</span>
00933 <span class="comment">    has completed.</span>
00934 <span class="comment"></span>
00935 <span class="comment">    This routine performs the following tasks:</span>
00936 <span class="comment"></span>
00937 <span class="comment">        o   The I/O status is copied.</span>
00938 <span class="comment"></span>
00939 <span class="comment">        o   The Modified Page Writer's APC routine is invoked.</span>
00940 <span class="comment"></span>
00941 <span class="comment">Arguments:</span>
00942 <span class="comment"></span>
00943 <span class="comment">    Apc - Supplies a pointer to kernel APC structure.</span>
00944 <span class="comment"></span>
00945 <span class="comment">    NormalRoutine - Supplies a pointer to a pointer to the normal function</span>
00946 <span class="comment">        that was specified when the APC was initialized.</span>
00947 <span class="comment"></span>
00948 <span class="comment">    NormalContext - Supplies a pointer to a pointer to an arbitrary data</span>
00949 <span class="comment">        structure that was specified when the APC was initialized.</span>
00950 <span class="comment"></span>
00951 <span class="comment">    SystemArgument1 - Supplies a pointer to an argument that contains an</span>
00952 <span class="comment">        argument that is unused by this routine.</span>
00953 <span class="comment"></span>
00954 <span class="comment">    SystemArgument2 - Supplies a pointer to an argument that contains an</span>
00955 <span class="comment">        argument that is unused by this routine.</span>
00956 <span class="comment"></span>
00957 <span class="comment">Return Value:</span>
00958 <span class="comment"></span>
00959 <span class="comment">    None.</span>
00960 <span class="comment"></span>
00961 <span class="comment">--*/</span>
00962 
00963 {
00964     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
00965     PIO_APC_ROUTINE apcRoutine;
00966     PVOID apcContext;
00967     PIO_STATUS_BLOCK ioStatus;
00968 
00969     UNREFERENCED_PARAMETER( NormalRoutine );
00970     UNREFERENCED_PARAMETER( NormalContext );
00971     UNREFERENCED_PARAMETER( SystemArgument1 );
00972     UNREFERENCED_PARAMETER( SystemArgument2 );
00973 
00974     <span class="comment">//</span>
00975     <span class="comment">// Begin by getting the address of the I/O Request Packet from the APC.</span>
00976     <span class="comment">//</span>
00977 
00978     irp = CONTAINING_RECORD( Apc, <a class="code" href="../../d0/d2/struct__IRP.html">IRP</a>, Tail.Apc );
00979 
00980     <span class="comment">//</span>
00981     <span class="comment">// If this I/O operation did not complete successfully through the</span>
00982     <span class="comment">// dispatch routine of the driver, then drop everything on the floor</span>
00983     <span class="comment">// now and return to the original call point in the MPW.</span>
00984     <span class="comment">//</span>
00985 
00986     <span class="keywordflow">if</span> (!irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o11">PendingReturned</a> &amp;&amp; <a class="code" href="../../d5/d6/stierr_8h.html#a3">NT_ERROR</a>( irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status )) {
00987         <a class="code" href="../../d4/d6/iosubs_8c.html#a63">IoFreeIrp</a>( irp );
00988         <span class="keywordflow">return</span>;
00989     }
00990 
00991     <span class="comment">//</span>
00992     <span class="comment">// Copy the I/O status from the IRP into the caller's I/O status block.</span>
00993     <span class="comment">//</span>
00994 
00995     *irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>;
00996 
00997     <span class="comment">//</span>
00998     <span class="comment">// Copy the pertinent information from the I/O Request Packet into locals</span>
00999     <span class="comment">// and free it.</span>
01000     <span class="comment">//</span>
01001 
01002     apcRoutine = irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcRoutine;
01003     apcContext = irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcContext;
01004     ioStatus = irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a>;
01005 
01006     <a class="code" href="../../d4/d6/iosubs_8c.html#a63">IoFreeIrp</a>( irp );
01007 
01008     <span class="comment">//</span>
01009     <span class="comment">// Finally, invoke the MPW's APC routine.</span>
01010     <span class="comment">//</span>
01011 
01012     apcRoutine( apcContext, ioStatus, 0 );
01013 
01014     <span class="keywordflow">return</span>;
01015 }
01016 
01017 
01018 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01019"></a><a class="code" href="../../d0/d6/iop_8h.html#a157">01019</a> <a class="code" href="../../d0/d6/iop_8h.html#a157">IopCompleteRequest</a>(
01020     IN <a class="code" href="../../d1/d5/struct__KAPC.html">PKAPC</a> Apc,
01021     IN PKNORMAL_ROUTINE *NormalRoutine,
01022     IN PVOID *NormalContext,
01023     IN PVOID *SystemArgument1,
01024     IN PVOID *SystemArgument2
01025     )
01026 
01027 <span class="comment">/*++</span>
01028 <span class="comment"></span>
01029 <span class="comment">Routine Description:</span>
01030 <span class="comment"></span>
01031 <span class="comment">    This routine executes as a special kernel APC routine in the context of</span>
01032 <span class="comment">    the thread which originally requested the I/O operation which is now</span>
01033 <span class="comment">    being completed.</span>
01034 <span class="comment"></span>
01035 <span class="comment">    This routine performs the following tasks:</span>
01036 <span class="comment"></span>
01037 <span class="comment">        o   A check is made to determine whether the specified request ended</span>
01038 <span class="comment">            with an error status.  If so, and the error code qualifies as one</span>
01039 <span class="comment">            which should be reported to an error port, then an error port is</span>
01040 <span class="comment">            looked for in the thread/process.   If one exists, then this routine</span>
01041 <span class="comment">            will attempt to set up an LPC to it.  Otherwise, it will attempt to</span>
01042 <span class="comment">            set up an LPC to the system error port.</span>
01043 <span class="comment"></span>
01044 <span class="comment">        o   Copy buffers.</span>
01045 <span class="comment"></span>
01046 <span class="comment">        o   Free MDLs.</span>
01047 <span class="comment"></span>
01048 <span class="comment">        o   Copy I/O status.</span>
01049 <span class="comment"></span>
01050 <span class="comment">        o   Set event, if any and dereference if appropriate.</span>
01051 <span class="comment"></span>
01052 <span class="comment">        o   Dequeue the IRP from the thread queue as pending I/O request.</span>
01053 <span class="comment"></span>
01054 <span class="comment">        o   Queue APC to thread, if any.</span>
01055 <span class="comment"></span>
01056 <span class="comment">        o   If no APC is to be queued, then free the packet now.</span>
01057 <span class="comment"></span>
01058 <span class="comment"></span>
01059 <span class="comment">Arguments:</span>
01060 <span class="comment"></span>
01061 <span class="comment">    Apc - Supplies a pointer to kernel APC structure.</span>
01062 <span class="comment"></span>
01063 <span class="comment">    NormalRoutine - Supplies a pointer to a pointer to the normal function</span>
01064 <span class="comment">        that was specified when the APC was initialied.</span>
01065 <span class="comment"></span>
01066 <span class="comment">    NormalContext - Supplies a pointer to a pointer to an arbitrary data</span>
01067 <span class="comment">        structure that was specified when the APC was initialized.</span>
01068 <span class="comment"></span>
01069 <span class="comment">    SystemArgument1 - Supplies a pointer to an argument that contains the</span>
01070 <span class="comment">        address of the original file object for this I/O operation.</span>
01071 <span class="comment"></span>
01072 <span class="comment">    SystemArgument2 - Supplies a pointer to an argument that contains an</span>
01073 <span class="comment">        argument that is used by this routine only in the case of STATUS_REPARSE.</span>
01074 <span class="comment"></span>
01075 <span class="comment">Return Value:</span>
01076 <span class="comment"></span>
01077 <span class="comment">    None.</span>
01078 <span class="comment"></span>
01079 <span class="comment">--*/</span>
01080 {
01081 <span class="preprocessor">#define SynchronousIo( Irp, FileObject ) (  \</span>
01082 <span class="preprocessor">    (Irp-&gt;Flags &amp; IRP_SYNCHRONOUS_API) ||   \</span>
01083 <span class="preprocessor">    (FileObject == NULL ? 0 : FileObject-&gt;Flags &amp; FO_SYNCHRONOUS_IO) )</span>
01084 <span class="preprocessor"></span>
01085     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
01086     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> mdl, nextMdl;
01087     <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a> thread;
01088     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> fileObject;
01089     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>    status;
01090 
01091     UNREFERENCED_PARAMETER( NormalRoutine );
01092     UNREFERENCED_PARAMETER( NormalContext );
01093 
01094     <span class="comment">//</span>
01095     <span class="comment">// Begin by getting the address of the I/O Request Packet.  Also, get</span>
01096     <span class="comment">// the address of the current thread and the address of the original file</span>
01097     <span class="comment">// object for this I/O operation.</span>
01098     <span class="comment">//</span>
01099 
01100     irp = CONTAINING_RECORD( Apc, <a class="code" href="../../d0/d2/struct__IRP.html">IRP</a>, Tail.Apc );
01101     thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
01102     fileObject = (<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>) *SystemArgument1;
01103 
01104     <a class="code" href="../../d7/d6/ioverifier_8h.html#a0">IOVP_COMPLETE_REQUEST</a>(Apc, SystemArgument1, SystemArgument2);
01105 
01106     <span class="comment">//</span>
01107     <span class="comment">// Ensure that the packet is not being completed with a minus one.  This</span>
01108     <span class="comment">// is apparently a common problem in some drivers, and has no meaning</span>
01109     <span class="comment">// as a status code.</span>
01110     <span class="comment">//</span>
01111 
01112     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status != 0xffffffff );
01113 
01114     <span class="comment">//</span>
01115     <span class="comment">// See if we need to do the name transmogrify work.</span>
01116     <span class="comment">//</span>
01117 
01118     <span class="keywordflow">if</span> ( *SystemArgument2 != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
01119 
01120         PREPARSE_DATA_BUFFER reparseBuffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01121 
01122         <span class="comment">//</span>
01123         <span class="comment">// The IO_REPARSE_TAG_MOUNT_POINT tag needs attention.</span>
01124         <span class="comment">//</span>
01125 
01126         <span class="keywordflow">if</span> ( irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status == STATUS_REPARSE &amp;&amp;
01127              irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information == IO_REPARSE_TAG_MOUNT_POINT ) {
01128 
01129             reparseBuffer = (PREPARSE_DATA_BUFFER) *SystemArgument2;
01130 
01131             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( reparseBuffer-&gt;ReparseTag == IO_REPARSE_TAG_MOUNT_POINT );
01132             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( reparseBuffer-&gt;ReparseDataLength &lt; MAXIMUM_REPARSE_DATA_BUFFER_SIZE );
01133             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( reparseBuffer-&gt;Reserved &lt; MAXIMUM_REPARSE_DATA_BUFFER_SIZE );
01134 
01135             <a class="code" href="../../d4/d6/iosubs_8c.html#a86">IopDoNameTransmogrify</a>( irp,
01136                                    fileObject,
01137                                    reparseBuffer );
01138         }
01139     }
01140 
01141     <span class="comment">//</span>
01142     <span class="comment">// Check to see whether there is any data in a system buffer which needs</span>
01143     <span class="comment">// to be copied to the caller's buffer.  If so, copy the data and then</span>
01144     <span class="comment">// free the system buffer if necessary.</span>
01145     <span class="comment">//</span>
01146 
01147     <span class="keywordflow">if</span> (irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a178">IRP_BUFFERED_IO</a>) {
01148 
01149         <span class="comment">//</span>
01150         <span class="comment">// Copy the data if this was an input operation.  Note that no copy</span>
01151         <span class="comment">// is performed if the status indicates that a verify operation is</span>
01152         <span class="comment">// required, or if the final status was an error-level severity.</span>
01153         <span class="comment">//</span>
01154 
01155         <span class="keywordflow">if</span> (irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a180">IRP_INPUT_OPERATION</a>  &amp;&amp;
01156             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status != STATUS_VERIFY_REQUIRED &amp;&amp;
01157             !<a class="code" href="../../d5/d6/stierr_8h.html#a3">NT_ERROR</a>( irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status )) {
01158 
01159             <span class="comment">//</span>
01160             <span class="comment">// Copy the information from the system buffer to the caller's</span>
01161             <span class="comment">// buffer.  This is done with an exception handler in case</span>
01162             <span class="comment">// the operation fails because the caller's address space</span>
01163             <span class="comment">// has gone away, or it's protection has been changed while</span>
01164             <span class="comment">// the service was executing.</span>
01165             <span class="comment">//</span>
01166 
01167             <span class="keywordflow">try</span> {
01168                 RtlCopyMemory( irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o26">UserBuffer</a>,
01169                                irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer,
01170                                irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information );
01171             } except(<a class="code" href="../../d0/d6/iop_8h.html#a169">IopExceptionFilter</a>(GetExceptionInformation(), &amp;status)) {
01172 
01173                 <span class="comment">//</span>
01174                 <span class="comment">// An exception occurred while attempting to copy the</span>
01175                 <span class="comment">// system buffer contents to the caller's buffer.  Set</span>
01176                 <span class="comment">// a new I/O completion status.</span>
01177                 <span class="comment">// If the status is a special one set by Mm then we need to </span>
01178                 <span class="comment">// return here and the operation will be retried in </span>
01179                 <span class="comment">// IoRetryIrpCompletions.</span>
01180                 <span class="comment">//</span>
01181 
01182                 <span class="keywordflow">if</span> (status == STATUS_MULTIPLE_FAULT_VIOLATION) {
01183                     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.OriginalFileObject = fileObject;  <span class="comment">/* Wiped out by APC  overlay */</span>
01184                     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a189">IRP_RETRY_IO_COMPLETION</a>;
01185                     <span class="keywordflow">return</span>;
01186                 }
01187                 irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status = GetExceptionCode();
01188             }
01189         }
01190 
01191         <span class="comment">//</span>
01192         <span class="comment">// Free the buffer if needed.</span>
01193         <span class="comment">//</span>
01194 
01195         <span class="keywordflow">if</span> (irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a179">IRP_DEALLOCATE_BUFFER</a>) {
01196             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer );
01197         }
01198     }
01199 
01200     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp;= ~(<a class="code" href="../../d0/d5/io_8h.html#a179">IRP_DEALLOCATE_BUFFER</a>|<a class="code" href="../../d0/d5/io_8h.html#a178">IRP_BUFFERED_IO</a>);
01201 
01202     <span class="comment">//</span>
01203     <span class="comment">// If there is an MDL (or MDLs) associated with this I/O request,</span>
01204     <span class="comment">// Free it (them) here.  This is accomplished by walking the MDL list</span>
01205     <span class="comment">// hanging off of the IRP and deallocating each MDL encountered.</span>
01206     <span class="comment">//</span>
01207 
01208     <span class="keywordflow">if</span> (irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a>) {
01209         <span class="keywordflow">for</span> (mdl = irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a>; mdl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>; mdl = nextMdl) {
01210             nextMdl = mdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o0">Next</a>;
01211             <a class="code" href="../../d4/d6/iosubs_8c.html#a65">IoFreeMdl</a>( mdl );
01212         }
01213     }
01214     
01215     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01216 
01217     <span class="comment">//</span>
01218     <span class="comment">// Check to see whether or not the I/O operation actually completed.  If</span>
01219     <span class="comment">// it did, then proceed normally.  Otherwise, cleanup everything and get</span>
01220     <span class="comment">// out of here.</span>
01221     <span class="comment">//</span>
01222 
01223     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a3">NT_ERROR</a>( irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status ) ||
01224         (<a class="code" href="../../d5/d6/stierr_8h.html#a3">NT_ERROR</a>( irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status ) &amp;&amp;
01225         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o11">PendingReturned</a> &amp;&amp;
01226         !<a class="code" href="../../d2/d4/internal_8c.html#a2">SynchronousIo</a>( irp, fileObject ))) {
01227 
01228         PVOID port = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01229         PVOID key;
01230         BOOLEAN createOperation = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01231 
01232         <span class="comment">//</span>
01233         <span class="comment">// If there is an I/O completion port object associated w/this request,</span>
01234         <span class="comment">// save it here so that the file object can be dereferenced.</span>
01235         <span class="comment">//</span>
01236 
01237         <span class="keywordflow">if</span> (fileObject &amp;&amp; fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o26">CompletionContext</a>) {
01238             port = fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o26">CompletionContext</a>-&gt;<a class="code" href="../../d2/d4/struct__IO__COMPLETION__CONTEXT.html#o0">Port</a>;
01239             key = fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o26">CompletionContext</a>-&gt;<a class="code" href="../../d2/d4/struct__IO__COMPLETION__CONTEXT.html#o1">Key</a>;
01240         }
01241 
01242         <span class="comment">//</span>
01243         <span class="comment">// Copy the I/O status from the IRP into the caller's I/O status</span>
01244         <span class="comment">// block. This is done using an exception handler in case the caller's</span>
01245         <span class="comment">// virtual address space for the I/O status block was deleted or</span>
01246         <span class="comment">// its protection was changed to readonly.  Note that if the I/O</span>
01247         <span class="comment">// status block cannot be written, the error is simply ignored since</span>
01248         <span class="comment">// there is no way to tell the caller that something went wrong.</span>
01249         <span class="comment">// This is, of course, by definition, since the I/O status block</span>
01250         <span class="comment">// is where the caller will attempt to look for errors in the first</span>
01251         <span class="comment">// place!</span>
01252         <span class="comment">//</span>
01253 
01254         <span class="keywordflow">try</span> {
01255 
01256             <span class="comment">//</span>
01257             <span class="comment">// Since HasOverlappedIoCompleted and GetOverlappedResult only</span>
01258             <span class="comment">// look at the Status field of the UserIosb to determine if the</span>
01259             <span class="comment">// IRP has completed, the Information field must be written</span>
01260             <span class="comment">// before the Status field.</span>
01261             <span class="comment">//</span>
01262 
01263 <span class="preprocessor">#if defined(_M_ALPHA) &amp;&amp; !defined(NT_UP)</span>
01264 <span class="preprocessor"></span><span class="preprocessor">#define MEMORY_BARRIER()    __MB()</span>
01265 <span class="preprocessor"></span><span class="preprocessor">#else</span>
01266 <span class="preprocessor"></span><span class="preprocessor">#define MEMORY_BARRIER()</span>
01267 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
01268 <span class="preprocessor"></span>
01269 <span class="preprocessor">#if defined(_WIN64)</span>
01270 <span class="preprocessor"></span>            PIO_STATUS_BLOCK32    UserIosb32;
01271 
01272             <span class="comment">//</span>
01273             <span class="comment">// If the caller passes a 32 bit IOSB the ApcRoutine has the LSB set to 1</span>
01274             <span class="comment">//</span>
01275             <span class="keywordflow">if</span> ((ULONG_PTR)(irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcRoutine) &amp; 1) {
01276                 UserIosb32 = (PIO_STATUS_BLOCK32)irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a>;
01277 
01278                 UserIosb32-&gt;Information = (ULONG)irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information;
01279                 <a class="code" href="../../d2/d4/internal_8c.html#a3">MEMORY_BARRIER</a>();
01280                 UserIosb32-&gt;Status = (<a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>)irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status;
01281             } <span class="keywordflow">else</span> {
01282                 irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a>-&gt;Information = irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information;
01283                 <a class="code" href="../../d2/d4/internal_8c.html#a3">MEMORY_BARRIER</a>();
01284                 irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a>-&gt;Status = irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status;
01285             }
01286 <span class="preprocessor">#else</span>
01287 <span class="preprocessor"></span>            irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a>-&gt;Information = irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information;
01288             <a class="code" href="../../d2/d4/internal_8c.html#a3">MEMORY_BARRIER</a>();
01289             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a>-&gt;Status = irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status;
01290 <span class="preprocessor">#endif  </span><span class="comment">/*_WIN64 */</span>
01291 
01292         } except(<a class="code" href="../../d0/d6/iop_8h.html#a169">IopExceptionFilter</a>(GetExceptionInformation(), &amp;status)) {
01293 
01294             <span class="comment">//</span>
01295             <span class="comment">// An exception was incurred attempting to write the caller's</span>
01296             <span class="comment">// I/O status block.  Simply continue executing as if nothing</span>
01297             <span class="comment">// ever happened since nothing can be done about it anyway.</span>
01298             <span class="comment">// If the status is a multiple fault status, this is a special</span>
01299             <span class="comment">// status sent by the Memory manager. Mark the IRP and return from</span>
01300             <span class="comment">// this routine. Mm will call us back later and we will retry this</span>
01301             <span class="comment">// operation (IoRetryIrpCompletions)</span>
01302             <span class="comment">//</span>
01303             <span class="keywordflow">if</span> (status == STATUS_MULTIPLE_FAULT_VIOLATION) {
01304                 irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.OriginalFileObject = fileObject;  <span class="comment">/* Wiped out by APC  overlay */</span>
01305                 irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a189">IRP_RETRY_IO_COMPLETION</a>;
01306                 <span class="keywordflow">return</span>;
01307             }
01308         }
01309 
01310 
01311         <span class="comment">//</span>
01312         <span class="comment">// Determine whether the caller supplied an event that needs to be set</span>
01313         <span class="comment">// to the Signaled state.  If so, then set it; otherwise, set the event</span>
01314         <span class="comment">// in the file object to the Signaled state.</span>
01315         <span class="comment">//</span>
01316         <span class="comment">// It is possible for the event to have been specified as a PKEVENT if</span>
01317         <span class="comment">// this was an I/O operation hand-built for an FSP or an FSD, or</span>
01318         <span class="comment">// some other types of operations such as synchronous I/O APIs.  In</span>
01319         <span class="comment">// any of these cases, the event was not referenced since it is not an</span>
01320         <span class="comment">// object manager event, so it should not be dereferenced.</span>
01321         <span class="comment">//</span>
01322         <span class="comment">// Also, it is possible for there not to be a file object for this IRP.</span>
01323         <span class="comment">// This occurs when an FSP is doing I/O operations to a device driver on</span>
01324         <span class="comment">// behalf of a process doing I/O to a file.  The file object cannot be</span>
01325         <span class="comment">// dereferenced if this is the case.  If this operation was a create</span>
01326         <span class="comment">// operation then the object should not be dereferenced either.  This</span>
01327         <span class="comment">// is because the reference count must be one or it will go away for</span>
01328         <span class="comment">// the caller (not much point in making an object that just got created</span>
01329         <span class="comment">// go away).</span>
01330         <span class="comment">//</span>
01331 
01332         <span class="keywordflow">if</span> (irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a>) {
01333             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>( irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a>, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01334             <span class="keywordflow">if</span> (fileObject) {
01335                 <span class="keywordflow">if</span> (!(irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a176">IRP_SYNCHRONOUS_API</a>)) {
01336                     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> );
01337                 }
01338                 <span class="keywordflow">if</span> (fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a> &amp;&amp; !(irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a187">IRP_OB_QUERY_NAME</a>)) {
01339                     (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>( &amp;fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o25">Event</a>, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01340                     fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o8">FinalStatus</a> = irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status;
01341                 }
01342                 <span class="keywordflow">if</span> (irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a182">IRP_CREATE_OPERATION</a>) {
01343                     createOperation = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01344                     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01345                 }
01346             }
01347         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fileObject) {
01348             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>( &amp;fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o25">Event</a>, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01349             fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o8">FinalStatus</a> = irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status;
01350             <span class="keywordflow">if</span> (irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a182">IRP_CREATE_OPERATION</a>) {
01351                 createOperation = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01352                 irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01353             }
01354         }
01355 
01356         <span class="comment">//</span>
01357         <span class="comment">// If this is normal I/O, update the transfer count for this process.</span>
01358         <span class="comment">//</span>
01359 
01360         <span class="keywordflow">if</span> (!(irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a182">IRP_CREATE_OPERATION</a>)) {
01361             <span class="keywordflow">if</span> (irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a183">IRP_READ_OPERATION</a>) {
01362                 <a class="code" href="../../d4/d6/iosubs_8c.html#a133">IopUpdateReadTransferCount</a>( (ULONG) irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information );
01363             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a184">IRP_WRITE_OPERATION</a>) {
01364                 <a class="code" href="../../d4/d6/iosubs_8c.html#a134">IopUpdateWriteTransferCount</a>( (ULONG) irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information );
01365             } <span class="keywordflow">else</span> {
01366                 <span class="comment">//</span>
01367                 <span class="comment">// If the information field contains a pointer then skip the update.</span>
01368                 <span class="comment">// Some PNP IRPs contain this.</span>
01369                 <span class="comment">//</span>
01370                 <span class="keywordflow">if</span> (!((ULONG) irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information &amp; 0x80000000)) {
01371                     <a class="code" href="../../d4/d6/iosubs_8c.html#a132">IopUpdateOtherTransferCount</a>( (ULONG) irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information );
01372                 }
01373             }
01374         }
01375 
01376         <span class="comment">//</span>
01377         <span class="comment">// Dequeue the packet from the thread's pending I/O request list.</span>
01378         <span class="comment">//</span>
01379 
01380         <a class="code" href="../../d0/d6/iop_8h.html#a18">IopDequeueThreadIrp</a>( irp );
01381 
01382         <span class="comment">//</span>
01383         <span class="comment">// If the caller requested an APC, queue it to the thread.  If not, then</span>
01384         <span class="comment">// simply free the packet now.</span>
01385         <span class="comment">//</span>
01386 
01387 <span class="preprocessor">#ifdef  _WIN64</span>
01388 <span class="preprocessor"></span>        <span class="comment">//</span>
01389         <span class="comment">// For 64 bit systems clear the LSB field of the ApcRoutine that indicates whether</span>
01390         <span class="comment">// the IOSB is a 32 bit IOSB or a 64 bit IOSB.</span>
01391         <span class="comment">//</span>
01392         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcRoutine =
01393           (PIO_APC_ROUTINE)((LONG_PTR)(irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcRoutine) &amp; ~1);
01394 <span class="preprocessor">#endif</span>
01395 <span class="preprocessor"></span>
01396         <span class="keywordflow">if</span> (irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcRoutine) {
01397             <a class="code" href="../../d5/d7/apcobj_8c.html#a1">KeInitializeApc</a>( &amp;irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Apc,
01398                              &amp;thread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o0">Tcb</a>,
01399                              <a class="code" href="../../d4/d9/ke_8h.html#a403a183">CurrentApcEnvironment</a>,
01400                              <a class="code" href="../../d2/d4/internal_8c.html#a70">IopUserCompletion</a>,
01401                              (<a class="code" href="../../d0/d9/ntosdef_8h.html#a43">PKRUNDOWN_ROUTINE</a>) <a class="code" href="../../d2/d4/internal_8c.html#a14">IopUserRundown</a>,
01402                              (<a class="code" href="../../d0/d9/ntosdef_8h.html#a41">PKNORMAL_ROUTINE</a>) irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcRoutine,
01403                              irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o10">RequestorMode</a>,
01404                              irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcContext );
01405 
01406             <a class="code" href="../../d5/d7/apcobj_8c.html#a3">KeInsertQueueApc</a>( &amp;irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Apc,
01407                               irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a>,
01408                               <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
01409                               2 );
01410 
01411         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (port &amp;&amp; irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcContext) {
01412 
01413             <span class="comment">//</span>
01414             <span class="comment">// If there is a completion context associated w/this I/O operation,</span>
01415             <span class="comment">// send the message to the port. Tag completion packet as an Irp.</span>
01416             <span class="comment">//</span>
01417 
01418             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.CompletionKey = key;
01419             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.PacketType = <a class="code" href="../../d0/d6/iop_8h.html#a241a141">IopCompletionPacketIrp</a>;
01420 
01421             <a class="code" href="../../d8/d3/queueobj_8c.html#a3">KeInsertQueue</a>( (<a class="code" href="../../d7/d7/struct__KQUEUE.html">PKQUEUE</a>) port,
01422                            &amp;irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.ListEntry );
01423 
01424         } <span class="keywordflow">else</span> {
01425 
01426             <span class="comment">//</span>
01427             <span class="comment">// Free the IRP now since it is no longer needed.</span>
01428             <span class="comment">//</span>
01429 
01430             <a class="code" href="../../d4/d6/iosubs_8c.html#a63">IoFreeIrp</a>( irp );
01431         }
01432 
01433         <span class="keywordflow">if</span> (fileObject &amp;&amp; !createOperation) {
01434 
01435             <span class="comment">//</span>
01436             <span class="comment">// Dereference the file object now.</span>
01437             <span class="comment">//</span>
01438 
01439             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
01440         }
01441 
01442     } <span class="keywordflow">else</span> {
01443 
01444         <span class="keywordflow">if</span> (irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o11">PendingReturned</a> &amp;&amp; fileObject) {
01445 
01446             <span class="comment">//</span>
01447             <span class="comment">// This is an I/O operation that completed as an error for</span>
01448             <span class="comment">// which a pending status was returned and the I/O operation</span>
01449             <span class="comment">// is synchronous.  For this case, the I/O system is waiting</span>
01450             <span class="comment">// on behalf of the caller.  If the reason that the I/O was</span>
01451             <span class="comment">// synchronous is that the file object was opened for synchronous</span>
01452             <span class="comment">// I/O, then the event associated with the file object is set</span>
01453             <span class="comment">// to the signaled state.  If the I/O operation was synchronous</span>
01454             <span class="comment">// because this is a synchronous API, then the event is set to</span>
01455             <span class="comment">// the signaled state.</span>
01456             <span class="comment">//</span>
01457             <span class="comment">// Note also that the status must be returned for both types</span>
01458             <span class="comment">// of synchronous I/O.  If this is a synchronous API, then the</span>
01459             <span class="comment">// I/O system supplies its own status block so it can simply</span>
01460             <span class="comment">// be written;  otherwise, the I/O system will obtain the final</span>
01461             <span class="comment">// status from the file object itself.</span>
01462             <span class="comment">//</span>
01463 
01464             <span class="keywordflow">if</span> (irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a176">IRP_SYNCHRONOUS_API</a>) {
01465                 *irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>;
01466                 <span class="keywordflow">if</span> (irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a>) {
01467                     (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>( irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a>, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01468                 } <span class="keywordflow">else</span> {
01469                     (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>( &amp;fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o25">Event</a>, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01470                 }
01471             } <span class="keywordflow">else</span> {
01472                 fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o8">FinalStatus</a> = irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status;
01473                 (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>( &amp;fileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o25">Event</a>, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01474             }
01475         }
01476 
01477         <span class="comment">//</span>
01478         <span class="comment">// The operation was incomplete.  Perform the general cleanup.  Note</span>
01479         <span class="comment">// that everything is basically dropped on the floor without doing</span>
01480         <span class="comment">// anything.  That is:</span>
01481         <span class="comment">//</span>
01482         <span class="comment">//     IoStatusBlock - Do nothing.</span>
01483         <span class="comment">//     Event - Dereference without setting to Signaled state.</span>
01484         <span class="comment">//     FileObject - Dereference without setting to Signaled state.</span>
01485         <span class="comment">//     ApcRoutine - Do nothing.</span>
01486         <span class="comment">//</span>
01487 
01488         <span class="keywordflow">if</span> (fileObject) {
01489             <span class="keywordflow">if</span> (!(irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a182">IRP_CREATE_OPERATION</a>)) {
01490                 <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
01491             }
01492         }
01493 
01494         <span class="keywordflow">if</span> (irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> &amp;&amp;
01495             fileObject &amp;&amp;
01496             !(irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a176">IRP_SYNCHRONOUS_API</a>)) {
01497             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> );
01498         }
01499 
01500         <a class="code" href="../../d0/d6/iop_8h.html#a18">IopDequeueThreadIrp</a>( irp );
01501         <a class="code" href="../../d4/d6/iosubs_8c.html#a63">IoFreeIrp</a>( irp );
01502     }
01503 }
01504 
01505 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01506"></a><a class="code" href="../../d0/d6/iop_8h.html#a158">01506</a> <a class="code" href="../../d0/d6/iop_8h.html#a158">IopConnectLinkTrackingPort</a>(
01507     IN PVOID Parameter
01508     )
01509 
01510 <span class="comment">/*++</span>
01511 <span class="comment"></span>
01512 <span class="comment">Routine Description:</span>
01513 <span class="comment"></span>
01514 <span class="comment">    This routine is invoked to connect to the user-mode link tracking service's</span>
01515 <span class="comment">    LPC port.  It makes a connection which establishes a handle to the port,</span>
01516 <span class="comment">    and then creates a referenced object pointer to the port.</span>
01517 <span class="comment"></span>
01518 <span class="comment">Arguments:</span>
01519 <span class="comment"></span>
01520 <span class="comment">    Parameter - Pointer to the link tracking packet.</span>
01521 <span class="comment"></span>
01522 <span class="comment">Return Value:</span>
01523 <span class="comment"></span>
01524 <span class="comment">    None.</span>
01525 <span class="comment"></span>
01526 <span class="comment"></span>
01527 <span class="comment">--*/</span>
01528 
01529 {
01530 <span class="preprocessor">    #define MESSAGE_SIZE    ( (2 * sizeof( FILE_VOLUMEID_WITH_TYPE )) + \</span>
01531 <span class="preprocessor">                            sizeof( FILE_OBJECTID_BUFFER ) +              \</span>
01532 <span class="preprocessor">                            sizeof( GUID ) + \</span>
01533 <span class="preprocessor">                            sizeof( NTSTATUS ) + \</span>
01534 <span class="preprocessor">                            sizeof( ULONG ) )</span>
01535 <span class="preprocessor"></span>
01536     <a class="code" href="../../d8/d1/struct__LINK__TRACKING__PACKET.html">PLINK_TRACKING_PACKET</a> ltp;
01537     HANDLE serviceHandle;
01538     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
01539 
01540     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01541     <span class="comment">//</span>
01542     <span class="comment">// Begin by getting a pointer to the link tracking packet.</span>
01543     <span class="comment">//</span>
01544 
01545     ltp = (<a class="code" href="../../d8/d1/struct__LINK__TRACKING__PACKET.html">PLINK_TRACKING_PACKET</a>) Parameter;
01546 
01547 
01548     <span class="comment">//</span>
01549     <span class="comment">// Ensure that the port has not already been opened.</span>
01550     <span class="comment">//</span>
01551 
01552     status = STATUS_SUCCESS;
01553     <span class="keywordflow">if</span> (!<a class="code" href="../../d3/d5/iodata_8c.html#a61">IopLinkTrackingServiceObject</a>) {
01554 
01555         UNICODE_STRING portName;
01556         ULONG maxMessageLength;
01557         SECURITY_QUALITY_OF_SERVICE dynamicQos;
01558 
01559         <span class="keywordflow">if</span> (<a class="code" href="../../d2/d8/eventobj_8c.html#a6">KeReadStateEvent</a>( <a class="code" href="../../d3/d5/iodata_8c.html#a62">IopLinkTrackingServiceEvent</a> )) {
01560 
01561             <span class="comment">//</span>
01562             <span class="comment">// Attempt to open a handle to the port.</span>
01563             <span class="comment">//</span>
01564 
01565             <span class="comment">//</span>
01566             <span class="comment">// Set up the security quality of service parameters to use over the</span>
01567             <span class="comment">// port.  Use the most efficient (least overhead) which is dynamic</span>
01568             <span class="comment">// rather than static tracking.</span>
01569             <span class="comment">//</span>
01570 
01571             dynamicQos.ImpersonationLevel = SecurityImpersonation;
01572             dynamicQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
01573             dynamicQos.EffectiveOnly = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01574 
01575             <span class="comment">//</span>
01576             <span class="comment">// Generate the string structure for describing the port.</span>
01577             <span class="comment">//</span>
01578 
01579             <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>( &amp;portName, <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"\\Security\\TRKWKS_PORT"</span> );
01580 
01581             status = <a class="code" href="../../d5/d6/lpcconn_8c.html#a1">NtConnectPort</a>( &amp;serviceHandle,
01582                                     &amp;portName,
01583                                     &amp;dynamicQos,
01584                                     (PPORT_VIEW) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
01585                                     (PREMOTE_PORT_VIEW) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
01586                                     &amp;maxMessageLength,
01587                                     (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
01588                                     (PULONG) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01589             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
01590                 <span class="keywordflow">if</span> (maxMessageLength &gt;= <a class="code" href="../../d2/d4/internal_8c.html#a4">MESSAGE_SIZE</a>) {
01591                     status = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a>( serviceHandle,
01592                                                         0,
01593                                                         <a class="code" href="../../d9/d8/ntos_8h.html#a5">LpcPortObjectType</a>,
01594                                                         <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
01595                                                         &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a61">IopLinkTrackingServiceObject</a>,
01596                                                         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01597                     <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>( serviceHandle );
01598                 } <span class="keywordflow">else</span> {
01599                     <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>( serviceHandle );
01600                     status = STATUS_INVALID_PARAMETER;
01601                 }
01602             }
01603 
01604         } <span class="keywordflow">else</span> {
01605 
01606             <span class="comment">//</span>
01607             <span class="comment">// The service has not been started so the port does not exist.</span>
01608             <span class="comment">//</span>
01609 
01610             status = STATUS_OBJECT_NAME_NOT_FOUND;
01611         }
01612     }
01613 
01614 
01615     <span class="comment">//</span>
01616     <span class="comment">// Return final status and wake the caller up.</span>
01617     <span class="comment">//</span>
01618     ltp-&gt;<a class="code" href="../../d8/d1/struct__LINK__TRACKING__PACKET.html#o2">FinalStatus</a> = status;
01619     <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>( &amp;ltp-&gt;<a class="code" href="../../d8/d1/struct__LINK__TRACKING__PACKET.html#o1">Event</a>, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01620 }
01621 
01622 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01623"></a><a class="code" href="../../d0/d6/iop_8h.html#a166">01623</a> <a class="code" href="../../d0/d6/iop_8h.html#a166">IopDisassociateThreadIrp</a>(
01624     VOID
01625     )
01626 
01627 <span class="comment">/*++</span>
01628 <span class="comment"></span>
01629 <span class="comment">Routine Description:</span>
01630 <span class="comment"></span>
01631 <span class="comment">    This routine is invoked when the I/O requests for a thread are being</span>
01632 <span class="comment">    cancelled, but there is a packet at the end of the thread's queue that</span>
01633 <span class="comment">    has not been completed for such a long period of time that it has timed</span>
01634 <span class="comment">    out.  It is this routine's responsibility to try to disassociate that</span>
01635 <span class="comment">    IRP with this thread.</span>
01636 <span class="comment"></span>
01637 <span class="comment">Arguments:</span>
01638 <span class="comment"></span>
01639 <span class="comment">    None.</span>
01640 <span class="comment"></span>
01641 <span class="comment">Return Value:</span>
01642 <span class="comment"></span>
01643 <span class="comment">    None.</span>
01644 <span class="comment"></span>
01645 <span class="comment">--*/</span>
01646 
01647 {
01648     KIRQL irql;
01649     KIRQL spIrql;
01650     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
01651     <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a> thread;
01652     PLIST_ENTRY entry;
01653     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
01654     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
01655     <a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html">PDRIVER_OBJECT</a> driverObject;
01656     WCHAR buffer[512];
01657     POBJECT_NAME_INFORMATION nameInformation;
01658     ULONG nameLength;
01659     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
01660     ULONG response;
01661     PIO_ERROR_LOG_PACKET errorLogEntry;
01662 
01663     <span class="comment">//</span>
01664     <span class="comment">// Begin by ensuring that the packet has not already been removed from</span>
01665     <span class="comment">// the thread's queue.</span>
01666     <span class="comment">//</span>
01667 
01668     <a class="code" href="../../d9/d5/verifier_8c.html#a116">KeRaiseIrql</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a52">APC_LEVEL</a>, &amp;irql );
01669 
01670     thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
01671 
01672     <span class="comment">//</span>
01673     <span class="comment">// If there are no packets on the IRP list, then simply return now.</span>
01674     <span class="comment">// All of the packets have been fully completed, so the caller will also</span>
01675     <span class="comment">// simply return to its caller.</span>
01676     <span class="comment">//</span>
01677 
01678     <span class="keywordflow">if</span> (IsListEmpty( &amp;thread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o18">IrpList</a> )) {
01679         <a class="code" href="../../d9/d5/verifier_8c.html#a117">KeLowerIrql</a>( irql );
01680         <span class="keywordflow">return</span>;
01681     }
01682 
01683     <span class="comment">//</span>
01684     <span class="comment">// Get a pointer to the first packet on the queue, and begin examining</span>
01685     <span class="comment">// it.  Note that because the processor is at raised IRQL, and because</span>
01686     <span class="comment">// the packet can only be removed in the context of the currently</span>
01687     <span class="comment">// executing thread, that it is not possible for the packet to be removed</span>
01688     <span class="comment">// from the list.  On the other hand, it IS possible for the packet to</span>
01689     <span class="comment">// be queued to the thread's APC list at this point, and this must be</span>
01690     <span class="comment">// blocked/synchronized in order to examine the request.</span>
01691     <span class="comment">//</span>
01692     <span class="comment">// Begin, therefore, by acquiring the I/O completion spinlock, so that</span>
01693     <span class="comment">// the packet can be safely examined.</span>
01694     <span class="comment">//</span>
01695 
01696     ExAcquireSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a24">IopCompletionLock</a>, &amp;spIrql );
01697 
01698     <span class="comment">//</span>
01699     <span class="comment">// Check to see whether or not the packet has been completed (that is,</span>
01700     <span class="comment">// queued to the current thread).  If not, change threads.</span>
01701     <span class="comment">//</span>
01702 
01703     entry = thread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o18">IrpList</a>.Flink;
01704     irp = CONTAINING_RECORD( entry, <a class="code" href="../../d0/d2/struct__IRP.html">IRP</a>, ThreadListEntry );
01705 
01706     <span class="keywordflow">if</span> (irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a> == irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o12">StackCount</a> + 2) {
01707 
01708         <span class="comment">//</span>
01709         <span class="comment">// The request has just gone through enough of completion that</span>
01710         <span class="comment">// queueing it to the thread is inevitable.  Simply release the</span>
01711         <span class="comment">// lock and return.</span>
01712         <span class="comment">//</span>
01713 
01714         ExReleaseSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a24">IopCompletionLock</a>, spIrql );
01715         <a class="code" href="../../d9/d5/verifier_8c.html#a117">KeLowerIrql</a>( irql );
01716         <span class="keywordflow">return</span>;
01717     }
01718 
01719     <span class="comment">//</span>
01720     <span class="comment">// The packet has been located, and it is not going through completion</span>
01721     <span class="comment">// at this point.  Switch threads, so that it will not complete through</span>
01722     <span class="comment">// this thread, remove the request from this thread's queue, and release</span>
01723     <span class="comment">// the spinlock.  Final processing of the IRP will occur when I/O</span>
01724     <span class="comment">// completion notices that there is no thread associated with the</span>
01725     <span class="comment">// request.  It will essentially drop the I/O on the floor.</span>
01726     <span class="comment">//</span>
01727     <span class="comment">// Also, while the request is still held, attempt to determine on which</span>
01728     <span class="comment">// device object the operation is being performed.</span>
01729     <span class="comment">//</span>
01730 
01735 
01736     <a class="code" href="../../d2/d4/internal_8c.html#a11">IopDeadIrp</a> = irp;
01737 
01738     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread = (<a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01739     entry = RemoveHeadList( &amp;thread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o18">IrpList</a> );
01740 
01741     <span class="comment">// Initialize the thread entry. Otherwise the assertion in IoFreeIrp</span>
01742     <span class="comment">// called via IopDeadIrp will fail.</span>
01743     InitializeListHead (&amp;(irp)-&gt;ThreadListEntry);
01744 
01745     irpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( irp );
01746     <span class="keywordflow">if</span> (irp-&gt;CurrentLocation &lt;= irp-&gt;StackCount) {
01747         deviceObject = irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o57">DeviceObject</a>;
01748     } <span class="keywordflow">else</span> {
01749         deviceObject = (<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01750     }
01751     ExReleaseSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a24">IopCompletionLock</a>, spIrql );
01752     <a class="code" href="../../d9/d5/verifier_8c.html#a117">KeLowerIrql</a>( irql );
01753 
01754     <span class="comment">//</span>
01755     <span class="comment">// If a device object could be identified then try to write to the event log about this</span>
01756     <span class="comment">// device object.</span>
01757     <span class="comment">//</span>
01758 
01759     <span class="keywordflow">if</span> (deviceObject) {
01760             errorLogEntry = <a class="code" href="../../d4/d6/iosubs_8c.html#a14">IoAllocateErrorLogEntry</a>(deviceObject, <span class="keyword">sizeof</span>(IO_ERROR_LOG_PACKET));
01761             <span class="keywordflow">if</span> (errorLogEntry) {
01762                 errorLogEntry-&gt;ErrorCode = IO_DRIVER_CANCEL_TIMEOUT;
01763                 <a class="code" href="../../d4/d6/iosubs_8c.html#a123">IoWriteErrorLogEntry</a>(errorLogEntry);
01764             }
01765     }
01766 
01767     <span class="keywordflow">return</span>;
01768 }
01769 
01770 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01771"></a><a class="code" href="../../d0/d6/iop_8h.html#a160">01771</a> <a class="code" href="../../d0/d6/iop_8h.html#a160">IopDeallocateApc</a>(
01772     IN <a class="code" href="../../d1/d5/struct__KAPC.html">PKAPC</a> Apc,
01773     IN PKNORMAL_ROUTINE *NormalRoutine,
01774     IN PVOID *NormalContext,
01775     IN PVOID *SystemArgument1,
01776     IN PVOID *SystemArgument2
01777     )
01778 
01779 <span class="comment">/*++</span>
01780 <span class="comment"></span>
01781 <span class="comment">Routine Description:</span>
01782 <span class="comment"></span>
01783 <span class="comment">    This routine is invoked to deallocate an APC that was used to queue a</span>
01784 <span class="comment">    request to a target thread.  It simple deallocates the APC.</span>
01785 <span class="comment"></span>
01786 <span class="comment">Arguments:</span>
01787 <span class="comment"></span>
01788 <span class="comment">    Apc - Supplies a pointer to kernel APC structure.</span>
01789 <span class="comment"></span>
01790 <span class="comment">    NormalRoutine - Supplies a pointer to a pointer to the normal function</span>
01791 <span class="comment">        that was specified when the APC was initialied.</span>
01792 <span class="comment"></span>
01793 <span class="comment">    NormalContext - Supplies a pointer to a pointer to an arbitrary data</span>
01794 <span class="comment">        structure that was specified when the APC was initialized.</span>
01795 <span class="comment"></span>
01796 <span class="comment">    SystemArgument1, SystemArgument2 - Supplies a set of two pointers to</span>
01797 <span class="comment">        two arguments that contain untyped data.</span>
01798 <span class="comment"></span>
01799 <span class="comment">Return Value:</span>
01800 <span class="comment"></span>
01801 <span class="comment">    None.</span>
01802 <span class="comment"></span>
01803 <span class="comment">--*/</span>
01804 
01805 {
01806     UNREFERENCED_PARAMETER( NormalRoutine );
01807     UNREFERENCED_PARAMETER( NormalContext );
01808     UNREFERENCED_PARAMETER( SystemArgument1 );
01809     UNREFERENCED_PARAMETER( SystemArgument2 );
01810 
01811     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01812 
01813     <span class="comment">//</span>
01814     <span class="comment">// Free the APC.</span>
01815     <span class="comment">//</span>
01816 
01817     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( Apc );
01818 }
01819 
01820 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01821"></a><a class="code" href="../../d0/d6/iop_8h.html#a168">01821</a> <a class="code" href="../../d0/d6/iop_8h.html#a168">IopDropIrp</a>(
01822     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
01823     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject
01824     )
01825 
01826 <span class="comment">/*++</span>
01827 <span class="comment"></span>
01828 <span class="comment">Routine Description:</span>
01829 <span class="comment"></span>
01830 <span class="comment">    This routine attempts to drop everything about the specified IRP on the</span>
01831 <span class="comment">    floor.</span>
01832 <span class="comment"></span>
01833 <span class="comment">Arguments:</span>
01834 <span class="comment"></span>
01835 <span class="comment">    Irp - Supplies the I/O Request Packet to be completed to the bit bucket.</span>
01836 <span class="comment"></span>
01837 <span class="comment">    FileObject - Supplies the file object for which the I/O Request Packet was</span>
01838 <span class="comment">        bound.</span>
01839 <span class="comment"></span>
01840 <span class="comment">Return Value:</span>
01841 <span class="comment"></span>
01842 <span class="comment">    None.</span>
01843 <span class="comment"></span>
01844 <span class="comment">--*/</span>
01845 
01846 {
01847     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> mdl;
01848     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> nextMdl;
01849 
01850     <span class="comment">//</span>
01851     <span class="comment">// Free the resources associated with the IRP.</span>
01852     <span class="comment">//</span>
01853 
01854     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a179">IRP_DEALLOCATE_BUFFER</a>) {
01855         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer );
01856     }
01857 
01858     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a>) {
01859         <span class="keywordflow">for</span> (mdl = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a>; mdl; mdl = nextMdl) {
01860             nextMdl = mdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o0">Next</a>;
01861             <a class="code" href="../../d4/d6/iosubs_8c.html#a65">IoFreeMdl</a>( mdl );
01862         }
01863     }
01864 
01865     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> &amp;&amp;
01866         FileObject &amp;&amp;
01867         !(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a176">IRP_SYNCHRONOUS_API</a>)) {
01868         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> );
01869     }
01870 
01871     <span class="keywordflow">if</span> (FileObject &amp;&amp; !(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a182">IRP_CREATE_OPERATION</a>)) {
01872         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( FileObject );
01873     }
01874 
01875     <span class="comment">//</span>
01876     <span class="comment">// Finally, free the IRP itself.</span>
01877     <span class="comment">//</span>
01878 
01879     <a class="code" href="../../d4/d6/iosubs_8c.html#a63">IoFreeIrp</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
01880 }
01881 
01882 LONG
<a name="l01883"></a><a class="code" href="../../d0/d6/iop_8h.html#a169">01883</a> <a class="code" href="../../d0/d6/iop_8h.html#a169">IopExceptionFilter</a>(
01884     IN PEXCEPTION_POINTERS ExceptionPointer,
01885     OUT PNTSTATUS ExceptionCode
01886     )
01887 
01888 <span class="comment">/*++</span>
01889 <span class="comment"></span>
01890 <span class="comment">Routine Description:</span>
01891 <span class="comment"></span>
01892 <span class="comment">    This routine is invoked when an exception occurs to determine whether or</span>
01893 <span class="comment">    not the exception was due to an error that caused an in-page error status</span>
01894 <span class="comment">    code exception to be raised.  If so, then this routine changes the code</span>
01895 <span class="comment">    in the exception record to the actual error code that was originally</span>
01896 <span class="comment">    raised.</span>
01897 <span class="comment"></span>
01898 <span class="comment">Arguments:</span>
01899 <span class="comment"></span>
01900 <span class="comment">    ExceptionPointer - Pointer to the exception record.</span>
01901 <span class="comment"></span>
01902 <span class="comment">    ExceptionCode - Variable to receive actual exception code.</span>
01903 <span class="comment"></span>
01904 <span class="comment">Return Value:</span>
01905 <span class="comment"></span>
01906 <span class="comment">    The function value indicates that the exception handler is to be executed.</span>
01907 <span class="comment"></span>
01908 <span class="comment">--*/</span>
01909 
01910 {
01911     <span class="comment">//</span>
01912     <span class="comment">// Simply check for an in-page error status code and, if the conditions</span>
01913     <span class="comment">// are right, replace it with the actual status code.</span>
01914     <span class="comment">//</span>
01915 
01916     *ExceptionCode = ExceptionPointer-&gt;ExceptionRecord-&gt;ExceptionCode;
01917     <span class="keywordflow">if</span> (*ExceptionCode == STATUS_IN_PAGE_ERROR &amp;&amp;
01918         ExceptionPointer-&gt;ExceptionRecord-&gt;NumberParameters &gt;= 3) {
01919         *ExceptionCode = (LONG) ExceptionPointer-&gt;ExceptionRecord-&gt;ExceptionInformation[2];
01920     }
01921 
01922     <span class="comment">//</span>
01923     <span class="comment">// Translate alignment warnings into alignment errors.</span>
01924     <span class="comment">//</span>
01925 
01926     <span class="keywordflow">if</span> (*ExceptionCode == STATUS_DATATYPE_MISALIGNMENT) {
01927         *ExceptionCode = STATUS_DATATYPE_MISALIGNMENT_ERROR;
01928     }
01929 
01930     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>;
01931 }
01932 
01933 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01934"></a><a class="code" href="../../d0/d6/iop_8h.html#a170">01934</a> <a class="code" href="../../d0/d6/iop_8h.html#a170">IopExceptionCleanup</a>(
01935     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
01936     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
01937     IN <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> EventObject OPTIONAL,
01938     IN <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> KernelEvent OPTIONAL
01939     )
01940 
01941 <span class="comment">/*++</span>
01942 <span class="comment"></span>
01943 <span class="comment">Routine Description:</span>
01944 <span class="comment"></span>
01945 <span class="comment">    This routine performs generalized cleanup for the I/O system services when</span>
01946 <span class="comment">    an exception occurs during caller parameter processing.  This routine</span>
01947 <span class="comment">    performs the following steps:</span>
01948 <span class="comment"></span>
01949 <span class="comment">        o   If a system buffer was allocated it is freed.</span>
01950 <span class="comment"></span>
01951 <span class="comment">        o   If an MDL was allocated it is freed.</span>
01952 <span class="comment"></span>
01953 <span class="comment">        o   The IRP is freed.</span>
01954 <span class="comment"></span>
01955 <span class="comment">        o   If the file object is opened for synchronous I/O, the semaphore</span>
01956 <span class="comment">            is released.</span>
01957 <span class="comment"></span>
01958 <span class="comment">        o   If an event object was referenced it is dereferenced.</span>
01959 <span class="comment"></span>
01960 <span class="comment">        o   If a kernel event was allocated, free it.</span>
01961 <span class="comment"></span>
01962 <span class="comment">        o   The file object is dereferenced.</span>
01963 <span class="comment"></span>
01964 <span class="comment">Arguments:</span>
01965 <span class="comment"></span>
01966 <span class="comment">    FileObject - Pointer to the file object currently being worked on.</span>
01967 <span class="comment"></span>
01968 <span class="comment">    Irp - Pointer to the IRP allocated to handle the I/O request.</span>
01969 <span class="comment"></span>
01970 <span class="comment">    EventObject - Optional pointer to a referenced event object.</span>
01971 <span class="comment"></span>
01972 <span class="comment">    KernelEvent - Optional pointer to an allocated kernel event.</span>
01973 <span class="comment"></span>
01974 <span class="comment">Return Value:</span>
01975 <span class="comment"></span>
01976 <span class="comment">    None.</span>
01977 <span class="comment"></span>
01978 <span class="comment">--*/</span>
01979 
01980 {
01981     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01982 
01983     <span class="comment">//</span>
01984     <span class="comment">// If a system buffer was allocated from nonpaged pool, free it.</span>
01985     <span class="comment">//</span>
01986 
01987     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01988         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer );
01989     }
01990 
01991     <span class="comment">//</span>
01992     <span class="comment">// If an MDL was allocated, free it.</span>
01993     <span class="comment">//</span>
01994 
01995     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01996         <a class="code" href="../../d4/d6/iosubs_8c.html#a65">IoFreeMdl</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a> );
01997     }
01998 
01999     <span class="comment">//</span>
02000     <span class="comment">// Free the I/O Request Packet.</span>
02001     <span class="comment">//</span>
02002 
02003     <a class="code" href="../../d4/d6/iosubs_8c.html#a63">IoFreeIrp</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
02004 
02005     <span class="comment">//</span>
02006     <span class="comment">// Finally, release the synchronization semaphore if it is currently</span>
02007     <span class="comment">// held, dereference the event if one was specified, free the kernel</span>
02008     <span class="comment">// event if one was allocated, and dereference the file object.</span>
02009     <span class="comment">//</span>
02010 
02011     <span class="keywordflow">if</span> (FileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>) {
02012         <a class="code" href="../../d0/d6/iop_8h.html#a22">IopReleaseFileObjectLock</a>( FileObject );
02013     }
02014 
02015     <span class="keywordflow">if</span> (ARGUMENT_PRESENT( EventObject )) {
02016         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( EventObject );
02017     }
02018 
02019     <span class="keywordflow">if</span> (ARGUMENT_PRESENT( KernelEvent )) {
02020         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( KernelEvent );
02021     }
02022 
02023     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( FileObject );
02024 
02025     <span class="keywordflow">return</span>;
02026 }
02027 
02028 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02029"></a><a class="code" href="../../d0/d6/iop_8h.html#a172">02029</a> <a class="code" href="../../d0/d6/iop_8h.html#a172">IopFreeIrpAndMdls</a>(
02030     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
02031     )
02032 
02033 <span class="comment">/*++</span>
02034 <span class="comment"></span>
02035 <span class="comment">Routine Description:</span>
02036 <span class="comment"></span>
02037 <span class="comment">    This routine frees the specified I/O Request Packet and all of its Memory</span>
02038 <span class="comment">    Descriptor Lists.</span>
02039 <span class="comment"></span>
02040 <span class="comment">Arguments:</span>
02041 <span class="comment"></span>
02042 <span class="comment">    Irp - Pointer to the I/O Request Packet to be freed.</span>
02043 <span class="comment"></span>
02044 <span class="comment">Return Value:</span>
02045 <span class="comment"></span>
02046 <span class="comment">    None.</span>
02047 <span class="comment"></span>
02048 <span class="comment">--*/</span>
02049 
02050 {
02051     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> mdl;
02052     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> nextMdl;
02053 
02054     <span class="comment">//</span>
02055     <span class="comment">// If there are any MDLs that need to be freed, free them now.</span>
02056     <span class="comment">//</span>
02057 
02058     <span class="keywordflow">for</span> (mdl = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a>; mdl != (<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>; mdl = nextMdl) {
02059         nextMdl = mdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o0">Next</a>;
02060         <a class="code" href="../../d4/d6/iosubs_8c.html#a65">IoFreeMdl</a>( mdl );
02061     }
02062 
02063     <span class="comment">//</span>
02064     <span class="comment">// Free the IRP.</span>
02065     <span class="comment">//</span>
02066 
02067     <a class="code" href="../../d4/d6/iosubs_8c.html#a63">IoFreeIrp</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
02068     <span class="keywordflow">return</span>;
02069 }
02070 
02071 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l02072"></a><a class="code" href="../../d0/d6/iop_8h.html#a175">02072</a> <a class="code" href="../../d0/d6/iop_8h.html#a175">IopGetDriverNameFromKeyNode</a>(
02073     IN HANDLE KeyHandle,
02074     OUT PUNICODE_STRING DriverName
02075     )
02076 
02077 <span class="comment">/*++</span>
02078 <span class="comment"></span>
02079 <span class="comment">Routine Description:</span>
02080 <span class="comment"></span>
02081 <span class="comment">    Given a handle to a driver service list key in the registry, return the</span>
02082 <span class="comment">    name that represents the Object Manager name space string that should</span>
02083 <span class="comment">    be used to locate/create the driver object.</span>
02084 <span class="comment"></span>
02085 <span class="comment">Arguments:</span>
02086 <span class="comment"></span>
02087 <span class="comment">    KeyHandle - Supplies a handle to driver service entry in the registry.</span>
02088 <span class="comment"></span>
02089 <span class="comment">    DriverName - Supplies a Unicode string descriptor variable in which the</span>
02090 <span class="comment">        name of the driver is returned.</span>
02091 <span class="comment"></span>
02092 <span class="comment">Return Value:</span>
02093 <span class="comment"></span>
02094 <span class="comment">    The function value is the final status of the operation.</span>
02095 <span class="comment"></span>
02096 <span class="comment">--*/</span>
02097 
02098 {
02099     PKEY_VALUE_FULL_INFORMATION keyValueInformation;
02100     PKEY_BASIC_INFORMATION keyBasicInformation;
02101     ULONG keyBasicLength;
02102     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
02103 
02104     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02105 
02106     <span class="comment">//</span>
02107     <span class="comment">// Get the optional object name for this driver from the value for this</span>
02108     <span class="comment">// key.  If one exists, then its name overrides the default name of the</span>
02109     <span class="comment">// driver.</span>
02110     <span class="comment">//</span>
02111 
02112     status = <a class="code" href="../../d6/d5/ioep_8h.html#a52">IopGetRegistryValue</a>( KeyHandle,
02113                                   <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"ObjectName"</span>,
02114                                   &amp;keyValueInformation );
02115 
02116     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
02117 
02118         PWSTR src, dst;
02119         ULONG i;
02120 
02121         <span class="comment">//</span>
02122         <span class="comment">// The driver entry specifies an object name.  This overrides the</span>
02123         <span class="comment">// default name for the driver.  Use this name to open the driver</span>
02124         <span class="comment">// object.</span>
02125         <span class="comment">//</span>
02126 
02127         <span class="keywordflow">if</span> (!keyValueInformation-&gt;DataLength) {
02128             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( keyValueInformation );
02129             <span class="keywordflow">return</span> STATUS_ILL_FORMED_SERVICE_ENTRY;
02130         }
02131 
02132         DriverName-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) (keyValueInformation-&gt;DataLength - <span class="keyword">sizeof</span>( WCHAR ));
02133         DriverName-&gt;MaximumLength = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) keyValueInformation-&gt;DataLength;
02134 
02135         src = (PWSTR) ((PUCHAR) keyValueInformation + keyValueInformation-&gt;DataOffset);
02136         dst = (PWSTR) keyValueInformation;
02137         <span class="keywordflow">for</span> (i = DriverName-&gt;Length; i; i--) {
02138             *dst++ = *src++;
02139         }
02140 
02141         DriverName-&gt;Buffer = (PWSTR) keyValueInformation;
02142 
02143     } <span class="keywordflow">else</span> {
02144 
02145         PULONG driverType;
02146         PWSTR baseObjectName;
02147         UNICODE_STRING remainderName;
02148 
02149         <span class="comment">//</span>
02150         <span class="comment">// The driver node does not specify an object name, so determine</span>
02151         <span class="comment">// what the default name for the driver object should be based on</span>
02152         <span class="comment">// the information in the key.</span>
02153         <span class="comment">//</span>
02154 
02155         status = <a class="code" href="../../d6/d5/ioep_8h.html#a52">IopGetRegistryValue</a>( KeyHandle,
02156                                       <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"Type"</span>,
02157                                       &amp;keyValueInformation );
02158         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status ) || !keyValueInformation-&gt;DataLength) {
02159 
02160             <span class="comment">//</span>
02161             <span class="comment">// There must be some type of "Type" associated with this driver,</span>
02162             <span class="comment">// either DRIVER or FILE_SYSTEM.  Otherwise, this node is ill-</span>
02163             <span class="comment">// formed.</span>
02164             <span class="comment">//</span>
02165 
02166             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
02167                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( keyValueInformation );
02168             }
02169 
02170             <span class="keywordflow">return</span> STATUS_ILL_FORMED_SERVICE_ENTRY;
02171         }
02172 
02173         <span class="comment">//</span>
02174         <span class="comment">// Now determine whether the type of this entry is a driver or a</span>
02175         <span class="comment">// file system.  Begin by assuming that it is a device driver.</span>
02176         <span class="comment">//</span>
02177 
02178         baseObjectName = <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"\\Driver\\"</span>;
02179         DriverName-&gt;Length = 8*2;
02180 
02181         driverType = (PULONG) ((PUCHAR) keyValueInformation + keyValueInformation-&gt;DataOffset);
02182 
02183         <span class="keywordflow">if</span> (*driverType == FileSystemType ||
02184             *driverType == RecognizerType) {
02185             baseObjectName = <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"\\FileSystem\\"</span>;
02186             DriverName-&gt;Length = 12*2;
02187         }
02188 
02189         <span class="comment">//</span>
02190         <span class="comment">// Get the name of the key that is being used to describe this</span>
02191         <span class="comment">// driver.  This will return just the last component of the name</span>
02192         <span class="comment">// string, which can be used to formulate the name of the driver.</span>
02193         <span class="comment">//</span>
02194 
02195         status = ZwQueryKey( KeyHandle,
02196                              KeyBasicInformation,
02197                              (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
02198                              0,
02199                              &amp;keyBasicLength );
02200 
02201         keyBasicInformation = <a class="code" href="../../d5/d5/cc_8h.html#a10">ExAllocatePool</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, keyBasicLength );
02202         <span class="keywordflow">if</span> (!keyBasicInformation) {
02203             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( keyValueInformation );
02204             <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
02205         }
02206 
02207         status = ZwQueryKey( KeyHandle,
02208                              KeyBasicInformation,
02209                              keyBasicInformation,
02210                              keyBasicLength,
02211                              &amp;keyBasicLength );
02212         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
02213             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( keyBasicInformation );
02214             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( keyValueInformation );
02215             <span class="keywordflow">return</span> status;
02216         }
02217 
02218         <span class="comment">//</span>
02219         <span class="comment">// Allocate a buffer from pool that is large enough to contain the</span>
02220         <span class="comment">// entire name string of the driver object.</span>
02221         <span class="comment">//</span>
02222 
02223         DriverName-&gt;MaximumLength = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) (DriverName-&gt;Length + keyBasicInformation-&gt;NameLength);
02224         DriverName-&gt;Buffer = <a class="code" href="../../d5/d5/cc_8h.html#a10">ExAllocatePool</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
02225                                             DriverName-&gt;MaximumLength );
02226         <span class="keywordflow">if</span> (!DriverName-&gt;Buffer) {
02227             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( keyBasicInformation );
02228             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( keyValueInformation );
02229             <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
02230         }
02231 
02232         <span class="comment">//</span>
02233         <span class="comment">// Now form the name of the object to be opened.</span>
02234         <span class="comment">//</span>
02235 
02236         DriverName-&gt;Length = 0;
02237         <a class="code" href="../../d6/d6/nls_8c.html#a45">RtlAppendUnicodeToString</a>( DriverName, baseObjectName );
02238         remainderName.Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) keyBasicInformation-&gt;NameLength;
02239         remainderName.MaximumLength = remainderName.Length;
02240         remainderName.Buffer = &amp;keyBasicInformation-&gt;Name[0];
02241         <a class="code" href="../../d6/d6/nls_8c.html#a46">RtlAppendUnicodeStringToString</a>( DriverName, &amp;remainderName );
02242         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( keyBasicInformation );
02243         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( keyValueInformation );
02244     }
02245 
02246     <span class="comment">//</span>
02247     <span class="comment">// Finally, simply return to the caller with the name filled in.  Note</span>
02248     <span class="comment">// that the caller must free the buffer pointed to by the Buffer field</span>
02249     <span class="comment">// of the Unicode string descriptor.</span>
02250     <span class="comment">//</span>
02251 
02252     <span class="keywordflow">return</span> STATUS_SUCCESS;
02253 }
02254 
02255 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l02256"></a><a class="code" href="../../d0/d6/iop_8h.html#a177">02256</a> <a class="code" href="../../d0/d6/iop_8h.html#a177">IopGetFileName</a>(
02257     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
02258     IN ULONG Length,
02259     OUT PVOID FileInformation,
02260     OUT PULONG ReturnedLength
02261     )
02262 
02263 <span class="comment">/*++</span>
02264 <span class="comment"></span>
02265 <span class="comment">Routine Description:</span>
02266 <span class="comment"></span>
02267 <span class="comment">    This routine is invoked to asynchronously obtain the name of a file object</span>
02268 <span class="comment">    when the file was opened for synchronous I/O, and the previous mode of the</span>
02269 <span class="comment">    caller was kernel mode, and the query was done through the Object Manager.</span>
02270 <span class="comment">    In this case, the situation is likely that the Lazy Writer has incurred a</span>
02271 <span class="comment">    write error, and it is attempting to obtain the name of the file so that it</span>
02272 <span class="comment">    can output a popup.  In doing so, a deadlock can occur because another</span>
02273 <span class="comment">    thread has locked the file object synchronous I/O lock.  Hence, this routine</span>
02274 <span class="comment">    obtains the name of the file w/o acquiring that lock.</span>
02275 <span class="comment"></span>
02276 <span class="comment">Arguments:</span>
02277 <span class="comment"></span>
02278 <span class="comment">    FileObject - A pointer to the file object whose name is to be queried.</span>
02279 <span class="comment"></span>
02280 <span class="comment">    Length - Supplies the length of the buffer to receive the name.</span>
02281 <span class="comment"></span>
02282 <span class="comment">    FileInformation - A pointer to the buffer to receive the name.</span>
02283 <span class="comment"></span>
02284 <span class="comment">    ReturnedLength - A variable to receive the length of the name returned.</span>
02285 <span class="comment"></span>
02286 <span class="comment">Return Value:</span>
02287 <span class="comment"></span>
02288 <span class="comment">    The status returned is the final completion status of the operation.</span>
02289 <span class="comment"></span>
02290 <span class="comment">--*/</span>
02291 
02292 {
02293 
02294     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
02295     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
02296     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
02297     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> event;
02298     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
02299     IO_STATUS_BLOCK localIoStatus;
02300 
02301     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02302 
02303     <span class="comment">//</span>
02304     <span class="comment">// Reference the file object here so that no special checks need be made</span>
02305     <span class="comment">// in I/O completion to determine whether or not to dereference the file</span>
02306     <span class="comment">// object.</span>
02307     <span class="comment">//</span>
02308 
02309     <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a>( FileObject );
02310 
02311     <span class="comment">//</span>
02312     <span class="comment">// Initialize an event that will be used to synchronize the completion of</span>
02313     <span class="comment">// the query operation.  Note that this is the only way to synchronize this</span>
02314     <span class="comment">// since the file object itself cannot be used since it was opened for</span>
02315     <span class="comment">// synchronous I/O and may be busy.</span>
02316     <span class="comment">//</span>
02317 
02318     <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;event, SynchronizationEvent, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
02319 
02320     <span class="comment">//</span>
02321     <span class="comment">// Get the address of the target device object.</span>
02322     <span class="comment">//</span>
02323 
02324     deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( FileObject );
02325 
02326     <span class="comment">//</span>
02327     <span class="comment">// Allocate and initialize the I/O Request Packet (IRP) for this operation.</span>
02328     <span class="comment">//</span>
02329 
02330     irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a17">IoAllocateIrp</a>( deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o13">StackSize</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
02331     <span class="keywordflow">if</span> (!irp) {
02332 
02333         <span class="comment">//</span>
02334         <span class="comment">// An IRP could not be allocated.  Cleanup and return an appropriate</span>
02335         <span class="comment">// error status code.</span>
02336         <span class="comment">//</span>
02337 
02338         <a class="code" href="../../d0/d6/iop_8h.html#a148">IopAllocateIrpCleanup</a>( FileObject, (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
02339         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
02340     }
02341 
02342     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.OriginalFileObject = FileObject;
02343     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
02344     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o10">RequestorMode</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>;
02345 
02346     <span class="comment">//</span>
02347     <span class="comment">// Fill in the service independent parameters in the IRP.  Note that the</span>
02348     <span class="comment">// setting of the special query name flag in the packet guarantees that the</span>
02349     <span class="comment">// standard completion for a synchronous file object will not occur because</span>
02350     <span class="comment">// this flag communicates to the I/O completion that it should not do so.</span>
02351     <span class="comment">//</span>
02352 
02353     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = &amp;event;
02354     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a176">IRP_SYNCHRONOUS_API</a> | <a class="code" href="../../d0/d5/io_8h.html#a187">IRP_OB_QUERY_NAME</a>;
02355     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = &amp;localIoStatus;
02356     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02357 
02358     <span class="comment">//</span>
02359     <span class="comment">// Get a pointer to the stack location for the first driver.  This will be</span>
02360     <span class="comment">// used to pass the original function codes and parameters.</span>
02361     <span class="comment">//</span>
02362 
02363     irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
02364     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a18">IRP_MJ_QUERY_INFORMATION</a>;
02365     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> = FileObject;
02366 
02367     <span class="comment">//</span>
02368     <span class="comment">// Set the system buffer address to the address of the caller's buffer and</span>
02369     <span class="comment">// set the flags so that the buffer is not deallocated.</span>
02370     <span class="comment">//</span>
02371 
02372     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer = FileInformation;
02373     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a178">IRP_BUFFERED_IO</a>;
02374 
02375     <span class="comment">//</span>
02376     <span class="comment">// Copy the caller's parameters to the service-specific portion of the</span>
02377     <span class="comment">// IRP.</span>
02378     <span class="comment">//</span>
02379 
02380     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.QueryFile.Length = Length;
02381     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.QueryFile.FileInformationClass = FileNameInformation;
02382 
02383     <span class="comment">//</span>
02384     <span class="comment">// Insert the packet at the head of the IRP list for the thread.</span>
02385     <span class="comment">//</span>
02386 
02387     <a class="code" href="../../d0/d6/iop_8h.html#a21">IopQueueThreadIrp</a>( irp );
02388 
02389     <span class="comment">//</span>
02390     <span class="comment">// Now simply invoke the driver at its dispatch entry with the IRP.</span>
02391     <span class="comment">//</span>
02392 
02393     status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( deviceObject, irp );
02394 
02395     <span class="comment">//</span>
02396     <span class="comment">// Now get the final status of the operation once the request completes</span>
02397     <span class="comment">// and return the length of the buffer written.</span>
02398     <span class="comment">//</span>
02399 
02400     <span class="keywordflow">if</span> (status == STATUS_PENDING) {
02401         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
02402                                       <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
02403                                       <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
02404                                       <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
02405                                       (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
02406         status = localIoStatus.Status;
02407     }
02408 
02409     *ReturnedLength = (ULONG) localIoStatus.Information;
02410     <span class="keywordflow">return</span> status;
02411 }
02412 
02413 BOOLEAN
<a name="l02414"></a><a class="code" href="../../d0/d6/iop_8h.html#a178">02414</a> <a class="code" href="../../d0/d6/iop_8h.html#a178">IopGetMountFlag</a>(
02415     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject
02416     )
02417 
02418 <span class="comment">/*++</span>
02419 <span class="comment"></span>
02420 <span class="comment">Routine Description:</span>
02421 <span class="comment"></span>
02422 <span class="comment">    This routine is invoked to determine whether or not the specified device</span>
02423 <span class="comment">    is mounted.</span>
02424 <span class="comment"></span>
02425 <span class="comment">Arguments:</span>
02426 <span class="comment"></span>
02427 <span class="comment">    DeviceObject - Supplies a pointer to the device object for which the mount</span>
02428 <span class="comment">        flag is tested.</span>
02429 <span class="comment"></span>
02430 <span class="comment">Return Value:</span>
02431 <span class="comment"></span>
02432 <span class="comment">    The function value is TRUE if the specified device is mounted, otherwise</span>
02433 <span class="comment">    FALSE.</span>
02434 <span class="comment"></span>
02435 <span class="comment"></span>
02436 <span class="comment">--*/</span>
02437 
02438 {
02439     KIRQL irql;
02440     BOOLEAN deviceMounted = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02441 
02442     <span class="comment">//</span>
02443     <span class="comment">// Check to see whether or not the device is mounted.  Note that the caller</span>
02444     <span class="comment">// has probably already looked to see whether or not the device has a VPB</span>
02445     <span class="comment">// outside of owning the lock, so simply get the lock and check it again</span>
02446     <span class="comment">// to start with, rather than checking to see whether or not the device</span>
02447     <span class="comment">// still has a VPB without holding the lock.</span>
02448     <span class="comment">//</span>
02449 
02450     ExAcquireFastLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a2">IopVpbSpinLock</a>, &amp;irql );
02451     <span class="keywordflow">if</span> (DeviceObject-&gt;Vpb) {
02452         <span class="keywordflow">if</span> (DeviceObject-&gt;Vpb-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a116">VPB_MOUNTED</a>) {
02453             deviceMounted = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02454         }
02455     }
02456     ExReleaseFastLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a2">IopVpbSpinLock</a>, irql );
02457 
02458     <span class="keywordflow">return</span> deviceMounted;
02459 }
02460 
02461 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l02462"></a><a class="code" href="../../d0/d6/iop_8h.html#a179">02462</a> <a class="code" href="../../d0/d6/iop_8h.html#a179">IopGetRegistryKeyInformation</a>(
02463     IN HANDLE KeyHandle,
02464     OUT PKEY_FULL_INFORMATION *Information
02465     )
02466 
02467 <span class="comment">/*++</span>
02468 <span class="comment"></span>
02469 <span class="comment">Routine Description:</span>
02470 <span class="comment"></span>
02471 <span class="comment">    This routine is invoked to retrieve the full key information for a</span>
02472 <span class="comment">    registry key.  This is done by querying the full key information</span>
02473 <span class="comment">    of the key with a zero-length buffer to determine the size of the data,</span>
02474 <span class="comment">    and then allocating a buffer and actually querying the data into the buffer.</span>
02475 <span class="comment"></span>
02476 <span class="comment">    It is the responsibility of the caller to free the buffer.</span>
02477 <span class="comment"></span>
02478 <span class="comment">Arguments:</span>
02479 <span class="comment"></span>
02480 <span class="comment">    KeyHandle - Supplies the key handle whose full key information is to</span>
02481 <span class="comment">        be queried</span>
02482 <span class="comment"></span>
02483 <span class="comment">    Information - Returns a pointer to the allocated data buffer.</span>
02484 <span class="comment"></span>
02485 <span class="comment">Return Value:</span>
02486 <span class="comment"></span>
02487 <span class="comment">    The function value is the final status of the query operation.</span>
02488 <span class="comment"></span>
02489 <span class="comment">--*/</span>
02490 
02491 {
02492     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
02493     PKEY_FULL_INFORMATION infoBuffer;
02494     ULONG keyInfoLength;
02495 
02496     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02497 
02498     <span class="comment">//</span>
02499     <span class="comment">// Figure out how big the data value is so that a buffer of the</span>
02500     <span class="comment">// appropriate size can be allocated.</span>
02501     <span class="comment">//</span>
02502 
02503     status = ZwQueryKey( KeyHandle,
02504                          KeyFullInformation,
02505                          (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
02506                          0,
02507                          &amp;keyInfoLength );
02508     <span class="keywordflow">if</span> (status != STATUS_BUFFER_OVERFLOW &amp;&amp;
02509         status != STATUS_BUFFER_TOO_SMALL) {
02510         <span class="keywordflow">return</span> status;
02511     }
02512 
02513     <span class="comment">//</span>
02514     <span class="comment">// Allocate a buffer large enough to contain the entire key data.</span>
02515     <span class="comment">//</span>
02516 
02517     infoBuffer = <a class="code" href="../../d5/d5/cc_8h.html#a10">ExAllocatePool</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, keyInfoLength );
02518     <span class="keywordflow">if</span> (!infoBuffer) {
02519         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
02520     }
02521 
02522     <span class="comment">//</span>
02523     <span class="comment">// Query the full key data for the key.</span>
02524     <span class="comment">//</span>
02525 
02526     status = ZwQueryKey( KeyHandle,
02527                          KeyFullInformation,
02528                          infoBuffer,
02529                          keyInfoLength,
02530                          &amp;keyInfoLength );
02531     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
02532         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( infoBuffer );
02533         <span class="keywordflow">return</span> status;
02534     }
02535 
02536     <span class="comment">//</span>
02537     <span class="comment">// Everything worked, so simply return the address of the allocated</span>
02538     <span class="comment">// buffer to the caller, who is now responsible for freeing it.</span>
02539     <span class="comment">//</span>
02540 
02541     *Information = infoBuffer;
02542     <span class="keywordflow">return</span> STATUS_SUCCESS;
02543 }
02544 
02545 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l02546"></a><a class="code" href="../../d6/d5/ioep_8h.html#a52">02546</a> <a class="code" href="../../d6/d5/ioep_8h.html#a52">IopGetRegistryValue</a>(
02547     IN HANDLE KeyHandle,
02548     IN PWSTR  ValueName,
02549     OUT PKEY_VALUE_FULL_INFORMATION *Information
02550     )
02551 
02552 <span class="comment">/*++</span>
02553 <span class="comment"></span>
02554 <span class="comment">Routine Description:</span>
02555 <span class="comment"></span>
02556 <span class="comment">    This routine is invoked to retrieve the data for a registry key's value.</span>
02557 <span class="comment">    This is done by querying the value of the key with a zero-length buffer</span>
02558 <span class="comment">    to determine the size of the value, and then allocating a buffer and</span>
02559 <span class="comment">    actually querying the value into the buffer.</span>
02560 <span class="comment"></span>
02561 <span class="comment">    It is the responsibility of the caller to free the buffer.</span>
02562 <span class="comment"></span>
02563 <span class="comment">Arguments:</span>
02564 <span class="comment"></span>
02565 <span class="comment">    KeyHandle - Supplies the key handle whose value is to be queried</span>
02566 <span class="comment"></span>
02567 <span class="comment">    ValueName - Supplies the null-terminated Unicode name of the value.</span>
02568 <span class="comment"></span>
02569 <span class="comment">    Information - Returns a pointer to the allocated data buffer.</span>
02570 <span class="comment"></span>
02571 <span class="comment">Return Value:</span>
02572 <span class="comment"></span>
02573 <span class="comment">    The function value is the final status of the query operation.</span>
02574 <span class="comment"></span>
02575 <span class="comment">--*/</span>
02576 
02577 {
02578     UNICODE_STRING unicodeString;
02579     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
02580     PKEY_VALUE_FULL_INFORMATION infoBuffer;
02581     ULONG keyValueLength;
02582 
02583     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02584 
02585     <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>( &amp;unicodeString, <a class="code" href="../../d1/d1/rtdelval_8c.html#a3">ValueName</a> );
02586 
02587     <span class="comment">//</span>
02588     <span class="comment">// Figure out how big the data value is so that a buffer of the</span>
02589     <span class="comment">// appropriate size can be allocated.</span>
02590     <span class="comment">//</span>
02591 
02592     status = ZwQueryValueKey( KeyHandle,
02593                               &amp;unicodeString,
02594                               KeyValueFullInformation,
02595                               (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
02596                               0,
02597                               &amp;keyValueLength );
02598     <span class="keywordflow">if</span> (status != STATUS_BUFFER_OVERFLOW &amp;&amp;
02599         status != STATUS_BUFFER_TOO_SMALL) {
02600         <span class="keywordflow">return</span> status;
02601     }
02602 
02603     <span class="comment">//</span>
02604     <span class="comment">// Allocate a buffer large enough to contain the entire key data value.</span>
02605     <span class="comment">//</span>
02606 
02607     infoBuffer = <a class="code" href="../../d5/d5/cc_8h.html#a10">ExAllocatePool</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, keyValueLength );
02608     <span class="keywordflow">if</span> (!infoBuffer) {
02609         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
02610     }
02611 
02612     <span class="comment">//</span>
02613     <span class="comment">// Query the data for the key value.</span>
02614     <span class="comment">//</span>
02615 
02616     status = ZwQueryValueKey( KeyHandle,
02617                               &amp;unicodeString,
02618                               KeyValueFullInformation,
02619                               infoBuffer,
02620                               keyValueLength,
02621                               &amp;keyValueLength );
02622     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
02623         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( infoBuffer );
02624         <span class="keywordflow">return</span> status;
02625     }
02626 
02627     <span class="comment">//</span>
02628     <span class="comment">// Everything worked, so simply return the address of the allocated</span>
02629     <span class="comment">// buffer to the caller, who is now responsible for freeing it.</span>
02630     <span class="comment">//</span>
02631 
02632     *Information = infoBuffer;
02633     <span class="keywordflow">return</span> STATUS_SUCCESS;
02634 }
02635 
02636 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l02637"></a><a class="code" href="../../d0/d6/iop_8h.html#a181">02637</a> <a class="code" href="../../d0/d6/iop_8h.html#a181">IopGetRegistryValues</a>(
02638     IN HANDLE KeyHandle,
02639     IN PKEY_VALUE_FULL_INFORMATION *ValueList
02640     )
02641 
02642 <span class="comment">/*++</span>
02643 <span class="comment"></span>
02644 <span class="comment">Routine Description:</span>
02645 <span class="comment"></span>
02646 <span class="comment">    This routine is invoked to retrieve the *three* types of data for a</span>
02647 <span class="comment">    registry key's.  This is done by calling the IopGetRegistryValue function</span>
02648 <span class="comment">    with the three valid key names.</span>
02649 <span class="comment"></span>
02650 <span class="comment">    It is the responsibility of the caller to free the three buffers.</span>
02651 <span class="comment"></span>
02652 <span class="comment">Arguments:</span>
02653 <span class="comment"></span>
02654 <span class="comment">    KeyHandle - Supplies the key handle whose value is to be queried</span>
02655 <span class="comment"></span>
02656 <span class="comment">    ValueList - Pointer to a buffer in which the three pointers to the value</span>
02657 <span class="comment">        entries will be stored.</span>
02658 <span class="comment"></span>
02659 <span class="comment">Return Value:</span>
02660 <span class="comment"></span>
02661 <span class="comment">    The function value is the final status of the query operation.</span>
02662 <span class="comment"></span>
02663 <span class="comment">Note:</span>
02664 <span class="comment"></span>
02665 <span class="comment">    The values are stored in the order represented by the I/O query device</span>
02666 <span class="comment">    data format.</span>
02667 <span class="comment"></span>
02668 <span class="comment">--*/</span>
02669 
02670 {
02671     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
02672 
02673     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02674 
02675     <span class="comment">//</span>
02676     <span class="comment">// Zero out all entries initially.</span>
02677     <span class="comment">//</span>
02678 
02679     *ValueList = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02680     *(ValueList + 1) = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02681     *(ValueList + 2) = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
02682 
02683     <span class="comment">//</span>
02684     <span class="comment">// Get the information for each of the three types of entries available.</span>
02685     <span class="comment">// Each time, check if an internal error occurred; If the object name was</span>
02686     <span class="comment">// not found, it only means not data was present, and this does not</span>
02687     <span class="comment">// constitute an error.</span>
02688     <span class="comment">//</span>
02689 
02690     status = <a class="code" href="../../d6/d5/ioep_8h.html#a52">IopGetRegistryValue</a>( KeyHandle,
02691                                   <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"Identifier"</span>,
02692                                   ValueList );
02693 
02694     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status ) &amp;&amp; (status != STATUS_OBJECT_NAME_NOT_FOUND)) {
02695         <span class="keywordflow">return</span> status;
02696     }
02697 
02698     status = <a class="code" href="../../d6/d5/ioep_8h.html#a52">IopGetRegistryValue</a>( KeyHandle,
02699                                   <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"Configuration Data"</span>,
02700                                   ++ValueList );
02701 
02702     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status ) &amp;&amp; (status != STATUS_OBJECT_NAME_NOT_FOUND)) {
02703         <span class="keywordflow">return</span> status;
02704     }
02705 
02706     status = <a class="code" href="../../d6/d5/ioep_8h.html#a52">IopGetRegistryValue</a>( KeyHandle,
02707                                   <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"Component Information"</span>,
02708                                   ++ValueList );
02709 
02710     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status ) &amp;&amp; (status != STATUS_OBJECT_NAME_NOT_FOUND)) {
02711         <span class="keywordflow">return</span> status;
02712     }
02713 
02714     <span class="keywordflow">return</span> STATUS_SUCCESS;
02715 }
02716 
02717 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l02718"></a><a class="code" href="../../d0/d6/iop_8h.html#a182">02718</a> <a class="code" href="../../d0/d6/iop_8h.html#a182">IopGetSetObjectId</a>(
02719     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
02720     IN OUT PVOID Buffer,
02721     IN ULONG Length,
02722     IN ULONG Function
02723     )
02724 
02725 <span class="comment">/*++</span>
02726 <span class="comment"></span>
02727 <span class="comment">Routine Description:</span>
02728 <span class="comment"></span>
02729 <span class="comment">    This routine is invoked to obtain or set the object ID for a file.  If</span>
02730 <span class="comment">    one does not exist for the file, then one is created, provided that the</span>
02731 <span class="comment">    underlying file system supports object IDs in the first place (query).</span>
02732 <span class="comment"></span>
02733 <span class="comment">Arguments:</span>
02734 <span class="comment"></span>
02735 <span class="comment">    FileObject - Supplies a pointer to the referenced file object whose ID is</span>
02736 <span class="comment">        to be returned or set.</span>
02737 <span class="comment"></span>
02738 <span class="comment">    Buffer - A variable to receive the object ID of the file (query) or that</span>
02739 <span class="comment">        contains the object ID that is to be set on the file.</span>
02740 <span class="comment"></span>
02741 <span class="comment">    Length - The length of the Buffer.</span>
02742 <span class="comment"></span>
02743 <span class="comment">    Function - The FSCTL to send.</span>
02744 <span class="comment">        FSCTL_LMR_GET_LINK_TRACKING_INFORMATION;</span>
02745 <span class="comment">        FSCTL_CREATE_OR_GET_OBJECT_ID;</span>
02746 <span class="comment">        FSCTL_GET_OBJECT_ID;</span>
02747 <span class="comment">        FSCTL_SET_OBJECT_ID_EXTENDED;</span>
02748 <span class="comment">        FSCTL_LMR_SET_LINK_TRACKING_INFORMATION;</span>
02749 <span class="comment">        FSCTL_SET_OBJECT_ID_EXTENDED;</span>
02750 <span class="comment">        FSCTL_SET_OBJECT_ID;</span>
02751 <span class="comment">        FSCTL_DELETE_OBJECT_ID;</span>
02752 <span class="comment"></span>
02753 <span class="comment">Return Value:</span>
02754 <span class="comment"></span>
02755 <span class="comment">    The status returned is the final completion status of the operation.</span>
02756 <span class="comment"></span>
02757 <span class="comment">--*/</span>
02758 
02759 {
02760     IO_STATUS_BLOCK ioStatus;
02761     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
02762     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
02763     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> event;
02764     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
02765     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
02766 
02767     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02768 
02769     <span class="comment">//</span>
02770     <span class="comment">// Initialize the event structure to synchronize completion of the I/O</span>
02771     <span class="comment">// request.</span>
02772     <span class="comment">//</span>
02773 
02774     <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;event,
02775                        NotificationEvent,
02776                        <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
02777 
02778     <span class="comment">//</span>
02779     <span class="comment">// Build an I/O Request Packet to be sent to the file system driver to get</span>
02780     <span class="comment">// the object ID.</span>
02781     <span class="comment">//</span>
02782 
02783     deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( FileObject );
02784 
02785     irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a25">IoBuildDeviceIoControlRequest</a>( Function,
02786                                          deviceObject,
02787                                          <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
02788                                          0,
02789                                          <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
02790                                          0,
02791                                          <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
02792                                          &amp;event,
02793                                          &amp;ioStatus );
02794     <span class="keywordflow">if</span> (!irp) {
02795         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
02796     }
02797 
02798     <span class="comment">//</span>
02799     <span class="comment">// Fill in the remainder of the IRP to retrieve the object ID for the</span>
02800     <span class="comment">// file.</span>
02801     <span class="comment">//</span>
02802 
02803     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a176">IRP_SYNCHRONOUS_API</a>;
02804     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o26">UserBuffer</a> = <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>;
02805     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer = <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>;
02806     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.OriginalFileObject = FileObject;
02807 
02808     irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
02809     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> = FileObject;
02810     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a26">IRP_MJ_FILE_SYSTEM_CONTROL</a>;
02811     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o1">MinorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a51">IRP_MN_KERNEL_CALL</a>;
02812 
02813     <span class="keywordflow">if</span> (Function == FSCTL_LMR_GET_LINK_TRACKING_INFORMATION ||
02814         Function == FSCTL_CREATE_OR_GET_OBJECT_ID ||
02815         Function == FSCTL_GET_OBJECT_ID ) {
02816         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.FileSystemControl.OutputBufferLength = Length;
02817     } <span class="keywordflow">else</span> {
02818         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.FileSystemControl.InputBufferLength = Length;
02819     }
02820 
02821     <span class="comment">//</span>
02822     <span class="comment">// Take out another reference to the file object to guarantee that it does</span>
02823     <span class="comment">// not get deleted.</span>
02824     <span class="comment">//</span>
02825 
02826     <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a>( FileObject );
02827 
02828     <span class="comment">//</span>
02829     <span class="comment">// Call the driver to get the request.</span>
02830     <span class="comment">//</span>
02831 
02832     status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( deviceObject, irp );
02833 
02834     <span class="comment">//</span>
02835     <span class="comment">// Synchronize completion of the request.</span>
02836     <span class="comment">//</span>
02837 
02838     <span class="keywordflow">if</span> (status == STATUS_PENDING) {
02839         status = <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
02840                                         <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
02841                                         <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
02842                                         <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
02843                                         (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
02844         status = ioStatus.Status;
02845     }
02846 
02847     <span class="keywordflow">return</span> status;
02848 }
02849 
02850 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l02851"></a><a class="code" href="../../d2/d4/internal_8c.html#a43">02851</a> <a class="code" href="../../d0/d6/iop_8h.html#a184">IopGetVolumeId</a>(
02852     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
02853     IN OUT PFILE_VOLUMEID_WITH_TYPE ObjectId,
02854     IN ULONG Length
02855     )
02856 
02857 <span class="comment">/*++</span>
02858 <span class="comment"></span>
02859 <span class="comment">Routine Description:</span>
02860 <span class="comment"></span>
02861 <span class="comment">    This routine is invoked by the I/O System link tracking code to obtain the</span>
02862 <span class="comment">    volume ID for a file that has been moved or is being moved between volumes</span>
02863 <span class="comment">    and potentially between systems.</span>
02864 <span class="comment"></span>
02865 <span class="comment">Arguments:</span>
02866 <span class="comment"></span>
02867 <span class="comment">    FileObject - Supplies the file object for the file.</span>
02868 <span class="comment"></span>
02869 <span class="comment">    ObjectId - A buffer to receive the volume object ID.</span>
02870 <span class="comment"></span>
02871 <span class="comment">    Length - Length of the buffer.</span>
02872 <span class="comment"></span>
02873 <span class="comment">Return Value:</span>
02874 <span class="comment"></span>
02875 <span class="comment">    The final function value is the final completion status of the operation.</span>
02876 <span class="comment"></span>
02877 <span class="comment">--*/</span>
02878 
02879 {
02880     IO_STATUS_BLOCK ioStatus;
02881     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
02882     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
02883     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> event;
02884     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
02885     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
02886     FILE_FS_OBJECTID_INFORMATION volumeId;
02887 
02888     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02889 
02890     <span class="comment">//</span>
02891     <span class="comment">// Initialize the event structure to synchronize completion of the I/O</span>
02892     <span class="comment">// request.</span>
02893     <span class="comment">//</span>
02894 
02895     <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;event,
02896                        NotificationEvent,
02897                        <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
02898 
02899     <span class="comment">//</span>
02900     <span class="comment">// Build an I/O Request Packet to be sent to the file system driver to get</span>
02901     <span class="comment">// the volume ID.</span>
02902     <span class="comment">//</span>
02903 
02904     deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( FileObject );
02905 
02906     irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a25">IoBuildDeviceIoControlRequest</a>( 0,
02907                                          deviceObject,
02908                                          <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
02909                                          0,
02910                                          <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
02911                                          0,
02912                                          <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
02913                                          &amp;event,
02914                                          &amp;ioStatus );
02915     <span class="keywordflow">if</span> (!irp) {
02916         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
02917     }
02918 
02919     <span class="comment">//</span>
02920     <span class="comment">// Fill in the remainder of the IRP to retrieve the volume ID for the</span>
02921     <span class="comment">// file.</span>
02922     <span class="comment">//</span>
02923 
02924     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a176">IRP_SYNCHRONOUS_API</a>;
02925     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o26">UserBuffer</a> = &amp;volumeId;
02926     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer = &amp;volumeId;
02927     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.OriginalFileObject = FileObject;
02928 
02929     irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
02930     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> = FileObject;
02931     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a23">IRP_MJ_QUERY_VOLUME_INFORMATION</a>;
02932     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.QueryVolume.Length = <span class="keyword">sizeof</span>( volumeId );
02933     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.QueryVolume.FsInformationClass = FileFsObjectIdInformation;
02934 
02935     <span class="comment">//</span>
02936     <span class="comment">// Take out another reference to the file object to guarantee that it does</span>
02937     <span class="comment">// not get deleted.</span>
02938     <span class="comment">//</span>
02939 
02940     <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a>( FileObject );
02941 
02942     <span class="comment">//</span>
02943     <span class="comment">// Call the driver to get the request.</span>
02944     <span class="comment">//</span>
02945 
02946     status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( deviceObject, irp );
02947 
02948     <span class="comment">//</span>
02949     <span class="comment">// Synchronize completion of the request.</span>
02950     <span class="comment">//</span>
02951 
02952     <span class="keywordflow">if</span> (status == STATUS_PENDING) {
02953         status = <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
02954                                         <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
02955                                         <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
02956                                         <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
02957                                         (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
02958         status = ioStatus.Status;
02959     }
02960 
02961     <span class="comment">//</span>
02962     <span class="comment">// If the file system returned the volume ID, copy it to the caller's</span>
02963     <span class="comment">// buffer and set the file system tracking type.</span>
02964     <span class="comment">//</span>
02965 
02966     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
02967         ObjectId-&gt;Type = NtfsLinkTrackingInformation;
02968         RtlCopyMemory( ObjectId-&gt;VolumeId,
02969                        &amp;volumeId.ObjectId,
02970                        <span class="keyword">sizeof</span>( GUID ) );
02971     }
02972 
02973     <span class="keywordflow">return</span> status;
02974 }
02975 
02976 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02977"></a><a class="code" href="../../d2/d4/internal_8c.html#a44">02977</a> <a class="code" href="../../d0/d6/iop_8h.html#a185">IopHardErrorThread</a>(
02978     IN PVOID StartContext
02979     )
02980 
02981 <span class="comment">/*++</span>
02982 <span class="comment"></span>
02983 <span class="comment">Routine Description:</span>
02984 <span class="comment"></span>
02985 <span class="comment">    This function waits for work on the IopHardErrorQueue, and all calls</span>
02986 <span class="comment">    IopRaiseInformationalHardError to actually perform the pop-ups.</span>
02987 <span class="comment"></span>
02988 <span class="comment">Arguments:</span>
02989 <span class="comment"></span>
02990 <span class="comment">    StartContext - Startup context; not used.</span>
02991 <span class="comment"></span>
02992 <span class="comment">Return Value:</span>
02993 <span class="comment"></span>
02994 <span class="comment">    None.</span>
02995 <span class="comment"></span>
02996 <span class="comment">--*/</span>
02997 
02998 {
02999     KIRQL oldIrql;
03000     PVOID entry;
03001     ULONG parameterPresent;
03002     ULONG_PTR errorParameter;
03003     ULONG errorResponse;
03004     BOOLEAN MoreEntries;
03005     <a class="code" href="../../d7/d0/struct__IOP__HARD__ERROR__PACKET.html">PIOP_HARD_ERROR_PACKET</a> hardErrorPacket;
03006 
03007     UNREFERENCED_PARAMETER( StartContext );
03008 
03009     <span class="comment">//</span>
03010     <span class="comment">// Loop, waiting forever for a hard error packet to be sent to this thread.</span>
03011     <span class="comment">// When one is placed onto the queue, wake up, process it, and continue</span>
03012     <span class="comment">// the loop.</span>
03013     <span class="comment">//</span>
03014 
03015     MoreEntries = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03016 
03017     <span class="keywordflow">do</span> {
03018 
03019         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a25">IopHardError</a>.<a class="code" href="../../d8/d0/struct__IOP__HARD__ERROR__QUEUE.html#o3">WorkQueueSemaphore</a>,
03020                                       <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
03021                                       <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
03022                                       <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
03023                                       (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
03024 
03025         ExAcquireFastLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a25">IopHardError</a>.<a class="code" href="../../d8/d0/struct__IOP__HARD__ERROR__QUEUE.html#o2">WorkQueueSpinLock</a>, &amp;oldIrql );
03026 
03027         <span class="comment">//</span>
03028         <span class="comment">// The work queue structures are now exclusively owned, so remove the</span>
03029         <span class="comment">// first packet from the head of the list.</span>
03030         <span class="comment">//</span>
03031 
03032         entry = RemoveHeadList( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a25">IopHardError</a>.<a class="code" href="../../d8/d0/struct__IOP__HARD__ERROR__QUEUE.html#o1">WorkQueue</a> );
03033 
03034         hardErrorPacket = CONTAINING_RECORD( entry,
03035                                              <a class="code" href="../../d7/d0/struct__IOP__HARD__ERROR__PACKET.html">IOP_HARD_ERROR_PACKET</a>,
03036                                              WorkQueueLinks );
03037 
03038         <a class="code" href="../../d3/d5/iodata_8c.html#a26">IopCurrentHardError</a> = hardErrorPacket;
03039 
03040         ExReleaseFastLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a25">IopHardError</a>.<a class="code" href="../../d8/d0/struct__IOP__HARD__ERROR__QUEUE.html#o2">WorkQueueSpinLock</a>, oldIrql );
03041 
03042         <span class="comment">//</span>
03043         <span class="comment">// Simply raise the hard error if the system is ready to accept one.</span>
03044         <span class="comment">//</span>
03045 
03046         errorParameter = (ULONG_PTR) &amp;hardErrorPacket-&gt;String;
03047         parameterPresent = (hardErrorPacket-&gt;String.Buffer != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
03048 
03049         <span class="keywordflow">if</span> (<a class="code" href="../../d6/d8/ex_2harderr_8c.html#a5">ExReadyForErrors</a>) {
03050             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d5/d8/ex_8h.html#a306">ExRaiseHardError</a>( hardErrorPacket-&gt;ErrorStatus,
03051                                      parameterPresent,
03052                                      parameterPresent,
03053                                      parameterPresent ? &amp;errorParameter : <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
03054                                      OptionOk,
03055                                      &amp;errorResponse );
03056         }
03057 
03058         <span class="comment">//</span>
03059         <span class="comment">//  If this was the last entry, exit the thread and mark it as so.</span>
03060         <span class="comment">//</span>
03061 
03062         ExAcquireFastLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a25">IopHardError</a>.<a class="code" href="../../d8/d0/struct__IOP__HARD__ERROR__QUEUE.html#o2">WorkQueueSpinLock</a>, &amp;oldIrql );
03063 
03064         <a class="code" href="../../d3/d5/iodata_8c.html#a26">IopCurrentHardError</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03065 
03066         <span class="keywordflow">if</span> ( IsListEmpty( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a25">IopHardError</a>.<a class="code" href="../../d8/d0/struct__IOP__HARD__ERROR__QUEUE.html#o1">WorkQueue</a> ) ) {
03067             <a class="code" href="../../d3/d5/iodata_8c.html#a25">IopHardError</a>.<a class="code" href="../../d8/d0/struct__IOP__HARD__ERROR__QUEUE.html#o4">ThreadStarted</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03068             MoreEntries = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03069         }
03070 
03071         ExReleaseFastLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a25">IopHardError</a>.<a class="code" href="../../d8/d0/struct__IOP__HARD__ERROR__QUEUE.html#o2">WorkQueueSpinLock</a>, oldIrql );
03072 
03073         <span class="comment">//</span>
03074         <span class="comment">// Now free the packet and the buffer, if one was specified.</span>
03075         <span class="comment">//</span>
03076 
03077         <span class="keywordflow">if</span> (hardErrorPacket-&gt;String.Buffer) {
03078             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( hardErrorPacket-&gt;String.Buffer );
03079         }
03080 
03081         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( hardErrorPacket );
03082 
03083     } <span class="keywordflow">while</span> ( MoreEntries );
03084 }
03085 
03086 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l03087"></a><a class="code" href="../../d0/d6/iop_8h.html#a188">03087</a> <a class="code" href="../../d0/d6/iop_8h.html#a188">IopInvalidDeviceRequest</a>(
03088     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
03089     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
03090     )
03091 
03092 <span class="comment">/*++</span>
03093 <span class="comment"></span>
03094 <span class="comment">Routine Description:</span>
03095 <span class="comment"></span>
03096 <span class="comment">    This function is the default dispatch routine for all driver entries</span>
03097 <span class="comment">    not implemented by drivers that have been loaded into the system.  Its</span>
03098 <span class="comment">    responsibility is simply to set the status in the packet to indicate</span>
03099 <span class="comment">    that the operation requested is invalid for this device type, and then</span>
03100 <span class="comment">    complete the packet.</span>
03101 <span class="comment"></span>
03102 <span class="comment">Arguments:</span>
03103 <span class="comment"></span>
03104 <span class="comment">    DeviceObject - Specifies the device object for which this request is</span>
03105 <span class="comment">        bound.  Ignored by this routine.</span>
03106 <span class="comment"></span>
03107 <span class="comment">    Irp - Specifies the address of the I/O Request Packet (IRP) for this</span>
03108 <span class="comment">        request.</span>
03109 <span class="comment"></span>
03110 <span class="comment">Return Value:</span>
03111 <span class="comment"></span>
03112 <span class="comment">    The final status is always STATUS_INVALID_DEVICE_REQUEST.</span>
03113 <span class="comment"></span>
03114 <span class="comment"></span>
03115 <span class="comment">--*/</span>
03116 
03117 {
03118     UNREFERENCED_PARAMETER( DeviceObject );
03119 
03120     <span class="comment">//</span>
03121     <span class="comment">// Simply store the appropriate status, complete the request, and return</span>
03122     <span class="comment">// the same status stored in the packet.</span>
03123     <span class="comment">//</span>
03124 
03125     <span class="keywordflow">if</span> ((<a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>))-&gt;MajorFunction == <a class="code" href="../../d0/d5/io_8h.html#a35">IRP_MJ_POWER</a>) {
03126         <a class="code" href="../../d1/d2/po_8h.html#a79">PoStartNextPowerIrp</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>);
03127     }
03128     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status = STATUS_INVALID_DEVICE_REQUEST;
03129     <a class="code" href="../../d0/d5/io_8h.html#a224">IoCompleteRequest</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, <a class="code" href="../../d7/d8/exboosts_8h.html#a3">IO_NO_INCREMENT</a> );
03130     <span class="keywordflow">return</span> STATUS_INVALID_DEVICE_REQUEST;
03131 }
03132 
03133 BOOLEAN
<a name="l03134"></a><a class="code" href="../../d0/d6/iop_8h.html#a190">03134</a> <a class="code" href="../../d0/d6/iop_8h.html#a190">IopIsSameMachine</a>(
03135     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> SourceFile,
03136     IN HANDLE TargetFile
03137     )
03138 
03139 <span class="comment">/*++</span>
03140 <span class="comment"></span>
03141 <span class="comment">Routine Description:</span>
03142 <span class="comment"></span>
03143 <span class="comment">    This routine is invoked to determine whether two file objects that represent</span>
03144 <span class="comment">    files on remote machines actually reside on the same physical system.</span>
03145 <span class="comment"></span>
03146 <span class="comment">Arguments:</span>
03147 <span class="comment"></span>
03148 <span class="comment">    SourceFile - Supplies the file object for the first file.</span>
03149 <span class="comment"></span>
03150 <span class="comment">    TargetFile - Supplies the file object for the second file.</span>
03151 <span class="comment"></span>
03152 <span class="comment">Return Value:</span>
03153 <span class="comment"></span>
03154 <span class="comment">    The final function value is TRUE if the files reside on the same machine,</span>
03155 <span class="comment">    otherwise FALSE is returned.</span>
03156 <span class="comment"></span>
03157 <span class="comment">--*/</span>
03158 
03159 {
03160     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
03161     <a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html">PFAST_IO_DISPATCH</a> fastIoDispatch;
03162     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status = STATUS_NOT_SAME_DEVICE;
03163     IO_STATUS_BLOCK ioStatus;
03164     HANDLE target = TargetFile;
03165 
03166     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
03167 
03168     <span class="comment">//</span>
03169     <span class="comment">// Simply invoke the device I/O control function to determine whether or</span>
03170     <span class="comment">// not the two files are on the same server.  If the fast I/O path does</span>
03171     <span class="comment">// not exist, or the function fails for any reason, then the two files are</span>
03172     <span class="comment">// assumed to not be on the same machine.  Note that this simply means</span>
03173     <span class="comment">// that there will be a performance penalty on open of the target, but</span>
03174     <span class="comment">// the above will only fail if the two files really aren't on the same</span>
03175     <span class="comment">// machine in the first place, or if there's a filter that doesn't under-</span>
03176     <span class="comment">// stand what is being done here.</span>
03177     <span class="comment">//</span>
03178 
03179     deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( SourceFile );
03180 
03181     fastIoDispatch = deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o3">DriverObject</a>-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o10">FastIoDispatch</a>;
03182     <span class="keywordflow">if</span> (fastIoDispatch &amp;&amp; fastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o10">FastIoDeviceControl</a>) {
03183         <span class="keywordflow">if</span> (fastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o10">FastIoDeviceControl</a>( SourceFile,
03184                                                  <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
03185                                                  (PVOID) &amp;target,
03186                                                  <span class="keyword">sizeof</span>( target ),
03187                                                  (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
03188                                                  0,
03189                                                  IOCTL_LMR_ARE_FILE_OBJECTS_ON_SAME_SERVER,
03190                                                  &amp;ioStatus,
03191                                                  deviceObject )) {
03192             status = ioStatus.Status;
03193         }
03194     }
03195 
03196     <span class="keywordflow">return</span> status == STATUS_SUCCESS;
03197 }
03198 
03199 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l03200"></a><a class="code" href="../../d0/d6/iop_8h.html#a191">03200</a> <a class="code" href="../../d0/d6/iop_8h.html#a191">IopLoadDriver</a>(
03201     IN HANDLE KeyHandle,
03202     IN BOOLEAN CheckForSafeBoot
03203     )
03204 
03205 <span class="comment">/*++</span>
03206 <span class="comment"></span>
03207 <span class="comment">Routine Description:</span>
03208 <span class="comment"></span>
03209 <span class="comment">    This routine is invoked to load a device or file system driver, either</span>
03210 <span class="comment">    during system initialization, or dynamically while the system is running.</span>
03211 <span class="comment"></span>
03212 <span class="comment">Arguments:</span>
03213 <span class="comment"></span>
03214 <span class="comment">    KeyHandle - Supplies a handle to the driver service node in the registry</span>
03215 <span class="comment">        that describes the driver to be loaded.</span>
03216 <span class="comment"></span>
03217 <span class="comment">Return Value:</span>
03218 <span class="comment"></span>
03219 <span class="comment">    The function value is the final status of the load operation.</span>
03220 <span class="comment"></span>
03221 <span class="comment">Notes:</span>
03222 <span class="comment"></span>
03223 <span class="comment">    Note that this routine closes the KeyHandle before returning.</span>
03224 <span class="comment"></span>
03225 <span class="comment"></span>
03226 <span class="comment">--*/</span>
03227 
03228 {
03229     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
03230     PLIST_ENTRY nextEntry;
03231     PLDR_DATA_TABLE_ENTRY driverEntry;
03232     PKEY_BASIC_INFORMATION keyBasicInformation = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03233     PKEY_VALUE_FULL_INFORMATION keyValueInformation = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03234     ULONG keyBasicLength;
03235     UNICODE_STRING baseName;
03236     UNICODE_STRING serviceName = {0, 0, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>};
03237     OBJECT_ATTRIBUTES objectAttributes;
03238     PVOID sectionPointer;
03239     UNICODE_STRING driverName;
03240     <a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html">PDRIVER_OBJECT</a> driverObject;
03241     PIMAGE_NT_HEADERS ntHeaders;
03242     PVOID imageBaseAddress;
03243     ULONG_PTR entryPoint;
03244     HANDLE driverHandle;
03245     ULONG i;
03246     POBJECT_NAME_INFORMATION registryPath;
03247 <span class="preprocessor">#if DBG</span>
03248 <span class="preprocessor"></span>    LARGE_INTEGER stime, etime;
03249     ULONG dtime;
03250 <span class="preprocessor">#endif</span>
03251 <span class="preprocessor"></span>
03252     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
03253 
03254     driverName.Buffer = (PWSTR) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03255 
03256     <span class="comment">//</span>
03257     <span class="comment">// Begin by formulating the name of the driver image file to be loaded.</span>
03258     <span class="comment">// Note that this is used to determine whether or not the driver has</span>
03259     <span class="comment">// already been loaded by the OS loader, not necessarily in actually</span>
03260     <span class="comment">// loading the driver image, since the node can override that name.</span>
03261     <span class="comment">//</span>
03262 
03263     status = <a class="code" href="../../d7/d7/ntapi_8c.html#a24">NtQueryKey</a>( KeyHandle,
03264                          KeyBasicInformation,
03265                          (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
03266                          0,
03267                          &amp;keyBasicLength );
03268     <span class="keywordflow">if</span> (status != STATUS_BUFFER_OVERFLOW &amp;&amp;
03269         status != STATUS_BUFFER_TOO_SMALL) {
03270         status = STATUS_ILL_FORMED_SERVICE_ENTRY;
03271         <span class="keywordflow">goto</span> IopLoadExit;
03272     }
03273 
03274     keyBasicInformation = <a class="code" href="../../d5/d5/cc_8h.html#a10">ExAllocatePool</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
03275                                           keyBasicLength + (4 * 2) );
03276     <span class="keywordflow">if</span> (!keyBasicInformation) {
03277         status = STATUS_INSUFFICIENT_RESOURCES;
03278         <span class="keywordflow">goto</span> IopLoadExit;
03279     }
03280 
03281     status = <a class="code" href="../../d7/d7/ntapi_8c.html#a24">NtQueryKey</a>( KeyHandle,
03282                          KeyBasicInformation,
03283                          keyBasicInformation,
03284                          keyBasicLength,
03285                          &amp;keyBasicLength );
03286     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
03287         <span class="keywordflow">goto</span> IopLoadExit;
03288     }
03289 
03290     <span class="comment">//</span>
03291     <span class="comment">// Create a Unicode string descriptor which forms the name of the</span>
03292     <span class="comment">// driver.</span>
03293     <span class="comment">//</span>
03294 
03295     baseName.Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) keyBasicInformation-&gt;NameLength;
03296     baseName.MaximumLength = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) (baseName.Length + (4 * 2));
03297     baseName.Buffer = &amp;keyBasicInformation-&gt;Name[0];
03298 <span class="comment">//#if _PNP_POWER_</span>
03299     serviceName.Buffer = <a class="code" href="../../d5/d5/cc_8h.html#a10">ExAllocatePool</a>(<a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>, baseName.Length + <span class="keyword">sizeof</span>(UNICODE_NULL));
03300     <span class="keywordflow">if</span> (serviceName.Buffer) {
03301         serviceName.Length = baseName.Length;
03302         serviceName.MaximumLength = serviceName.Length + <span class="keyword">sizeof</span>(UNICODE_NULL);
03303         RtlMoveMemory(serviceName.Buffer, baseName.Buffer, baseName.Length);
03304         serviceName.Buffer[serviceName.Length / <span class="keyword">sizeof</span>(WCHAR)] = UNICODE_NULL;
03305     }
03306 <span class="preprocessor">#if DBG</span>
03307 <span class="preprocessor"></span>      <span class="keywordflow">else</span> {
03308         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"IopLoadDriver: No memory available for Service Keyname\n"</span>);
03309     }
03310 <span class="preprocessor">#endif</span>
03311 <span class="preprocessor"></span><span class="comment">//#endif</span>
03312     <a class="code" href="../../d6/d6/nls_8c.html#a45">RtlAppendUnicodeToString</a>( &amp;baseName, <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">".SYS"</span> );
03313 
03314     <span class="keywordflow">if</span> (CheckForSafeBoot &amp;&amp; <a class="code" href="../../d8/d1/init_8h.html#a18">InitSafeBootMode</a>) {
03315 
03316         BOOLEAN GroupIsGood = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03317         UNICODE_STRING string;
03318         PKEY_VALUE_PARTIAL_INFORMATION keyValue;
03319         UCHAR nameBuffer[FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data) + 64];
03320         ULONG length;
03321 
03322         <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>( &amp;string, <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"Group"</span> );
03323         keyValue = (PKEY_VALUE_PARTIAL_INFORMATION)nameBuffer;
03324         RtlZeroMemory(nameBuffer, <span class="keyword">sizeof</span>(nameBuffer));
03325 
03326         status = <a class="code" href="../../d7/d7/ntapi_8c.html#a25">NtQueryValueKey</a>(
03327             KeyHandle,
03328             &amp;string,
03329             KeyValuePartialInformation,
03330             keyValue,
03331             <span class="keyword">sizeof</span>(nameBuffer),
03332             &amp;length
03333             );
03334         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
03335 
03336             string.Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(keyValue-&gt;DataLength - <span class="keyword">sizeof</span>(WCHAR));
03337             string.MaximumLength = string.Length;
03338             string.Buffer = (PWSTR)keyValue-&gt;Data;
03339 
03340             <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a223">IopSafebootDriverLoad</a>(&amp;string)) {
03341                 GroupIsGood = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03342             }
03343         }
03344 
03345         <span class="keywordflow">if</span> (!GroupIsGood &amp;&amp; !<a class="code" href="../../d0/d6/iop_8h.html#a223">IopSafebootDriverLoad</a>(&amp;baseName)) {
03346             <span class="comment">//</span>
03347             <span class="comment">// don't load the driver</span>
03348             <span class="comment">//</span>
03349 
03350             <a class="code" href="../../d2/d4/internal_8c.html#a75">IopBootLog</a>(&amp;baseName, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
03351 
03352             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"SAFEBOOT: skipping device = %wZ(%wZ)\n"</span>,&amp;baseName,&amp;string);
03353             <span class="keywordflow">return</span> STATUS_SUCCESS;
03354         }
03355 
03356     }
03357 
03358     <span class="comment">//</span>
03359     <span class="comment">// See if this driver has already been loaded by the boot loader.</span>
03360     <span class="comment">//</span>
03361 
03362     <span class="comment">//KeEnterCriticalRegion();</span>
03363     <a class="code" href="../../d5/d8/ex_8h.html#a69">ExAcquireResourceShared</a>( &amp;<a class="code" href="../../d1/d9/ps_8h.html#a57">PsLoadedModuleResource</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
03364     nextEntry = <a class="code" href="../../d1/d9/ps_8h.html#a56">PsLoadedModuleList</a>.Flink;
03365     <span class="keywordflow">while</span> (nextEntry != &amp;<a class="code" href="../../d1/d9/ps_8h.html#a56">PsLoadedModuleList</a>) {
03366 
03367         <span class="comment">//</span>
03368         <span class="comment">// Look at the next boot driver in the list.</span>
03369         <span class="comment">//</span>
03370 
03371         driverEntry = CONTAINING_RECORD( nextEntry,
03372                                          LDR_DATA_TABLE_ENTRY,
03373                                          InLoadOrderLinks );
03374 
03375         <span class="comment">//</span>
03376         <span class="comment">// If this is not the kernel image (ntoskrnl) and not the HAL (hal),</span>
03377         <span class="comment">// then this is a driver, so initialize it.</span>
03378         <span class="comment">//</span>
03379 
03380         <span class="keywordflow">if</span> ((driverEntry-&gt;Flags &amp; LDRP_ENTRY_PROCESSED) &amp;&amp;
03381             <a class="code" href="../../d2/d7/string_8c.html#a11">RtlEqualString</a>( (PSTRING) &amp;baseName,
03382                             (PSTRING) &amp;driverEntry-&gt;FullDllName,
03383                             <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> )) {
03384             status = STATUS_IMAGE_ALREADY_LOADED;
03385             <a class="code" href="../../d5/d8/ex_8h.html#a66">ExReleaseResource</a>( &amp;<a class="code" href="../../d1/d9/ps_8h.html#a57">PsLoadedModuleResource</a> );
03386             <span class="comment">//KeLeaveCriticalRegion();</span>
03387 
03388             <a class="code" href="../../d2/d4/internal_8c.html#a75">IopBootLog</a>(&amp;baseName, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
03389 
03390             <span class="keywordflow">goto</span> IopLoadExit;
03391         }
03392 
03393         nextEntry = nextEntry-&gt;Flink;
03394     }
03395     <a class="code" href="../../d5/d8/ex_8h.html#a66">ExReleaseResource</a>( &amp;<a class="code" href="../../d1/d9/ps_8h.html#a57">PsLoadedModuleResource</a> );
03396     <span class="comment">//KeLeaveCriticalRegion();</span>
03397 
03398     <span class="comment">//</span>
03399     <span class="comment">// This driver has not already been loaded by the OS loader.  Form the</span>
03400     <span class="comment">// full path name for this driver.  Begin by attempting to determine</span>
03401     <span class="comment">// whether or not the file has an image path.  If so, then use that,</span>
03402     <span class="comment">// otherwise, form one from the above driver name by putting the</span>
03403     <span class="comment">// appropriate path name in front of it.</span>
03404     <span class="comment">//</span>
03405 
03406     status = <a class="code" href="../../d6/d5/ioep_8h.html#a52">IopGetRegistryValue</a>( KeyHandle,
03407                                   <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"ImagePath"</span>,
03408                                   &amp;keyValueInformation );
03409 
03410     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status ) &amp;&amp; keyValueInformation-&gt;DataLength) {
03411 
03412         <span class="comment">//</span>
03413         <span class="comment">// The driver service node contained an image path name from which</span>
03414         <span class="comment">// the driver is to be loaded.</span>
03415         <span class="comment">//</span>
03416 
03417         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( keyBasicInformation );
03418         keyBasicInformation = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03419         baseName.Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) keyValueInformation-&gt;DataLength;
03420         <span class="keywordflow">if</span> (baseName.Length &gt; 0) {
03421             baseName.Length -= <span class="keyword">sizeof</span>( WCHAR );
03422         }
03423         baseName.MaximumLength = baseName.Length;
03424         baseName.Buffer = (PWSTR) ((PUCHAR) keyValueInformation + keyValueInformation-&gt;DataOffset);
03425 
03426         <span class="keywordflow">if</span> (baseName.Buffer[0] != <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>) {
03427 
03428             UNICODE_STRING prefixName;
03429             UNICODE_STRING tmpName;
03430             PWCHAR fileName;
03431 
03432             <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>( &amp;prefixName, <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"\\SystemRoot\\"</span> );
03433             fileName = <a class="code" href="../../d5/d5/cc_8h.html#a10">ExAllocatePool</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
03434                                        prefixName.Length + baseName.Length );
03435             <span class="keywordflow">if</span> (!fileName) {
03436                 status = STATUS_INSUFFICIENT_RESOURCES;
03437                 <span class="keywordflow">goto</span> IopLoadExit;
03438             }
03439 
03440             tmpName.Length = baseName.Length;
03441             tmpName.Buffer = baseName.Buffer;
03442             baseName.MaximumLength = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) (prefixName.Length + baseName.Length);
03443             baseName.Length = 0;
03444             baseName.Buffer = fileName;
03445 
03446             <a class="code" href="../../d6/d6/nls_8c.html#a46">RtlAppendUnicodeStringToString</a>( &amp;baseName, &amp;prefixName );
03447             <a class="code" href="../../d6/d6/nls_8c.html#a46">RtlAppendUnicodeStringToString</a>( &amp;baseName, &amp;tmpName );
03448 
03449             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( keyValueInformation );
03450             keyValueInformation = (PKEY_VALUE_FULL_INFORMATION) fileName;
03451         }
03452 
03453     } <span class="keywordflow">else</span> {
03454 
03455         UNICODE_STRING prefixName;
03456         UNICODE_STRING fileName;
03457 
03458         <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>( &amp;prefixName, <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"\\SystemRoot\\System32\\Drivers\\"</span> );
03459 
03460         <span class="comment">//</span>
03461         <span class="comment">// Ensure that the driver entry did not actually contain an image path</span>
03462         <span class="comment">// name, and if it did, free the appropriate pool because it was a key</span>
03463         <span class="comment">// without a value.</span>
03464         <span class="comment">//</span>
03465 
03466         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
03467             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( keyValueInformation );
03468         }
03469 
03470         <span class="comment">//</span>
03471         <span class="comment">// The driver entry did not contain an image path name, so the above</span>
03472         <span class="comment">// default name for the driver image is name of the file.  Form a</span>
03473         <span class="comment">// fully qualified path to get to the image file.</span>
03474         <span class="comment">//</span>
03475 
03476         keyValueInformation = <a class="code" href="../../d5/d5/cc_8h.html#a10">ExAllocatePool</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
03477                                               baseName.MaximumLength +
03478                                               prefixName.Length );
03479         <span class="keywordflow">if</span> (!keyValueInformation) {
03480             status = STATUS_INSUFFICIENT_RESOURCES;
03481             <span class="keywordflow">goto</span> IopLoadExit;
03482         }
03483 
03484         fileName.Length = baseName.Length;
03485         fileName.MaximumLength = baseName.MaximumLength;
03486         fileName.Buffer = baseName.Buffer;
03487 
03488         baseName.Length = 0;
03489         baseName.MaximumLength = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) (fileName.Length + prefixName.Length);
03490         baseName.Buffer = (PWSTR) keyValueInformation;
03491 
03492         <a class="code" href="../../d6/d6/nls_8c.html#a46">RtlAppendUnicodeStringToString</a>( &amp;baseName, &amp;prefixName );
03493         <a class="code" href="../../d6/d6/nls_8c.html#a46">RtlAppendUnicodeStringToString</a>( &amp;baseName, &amp;fileName );
03494 
03495         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( keyBasicInformation );
03496         keyBasicInformation = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03497     }
03498 
03499     <span class="comment">//</span>
03500     <span class="comment">// Now get the name of the driver object.</span>
03501     <span class="comment">//</span>
03502 
03503     status = <a class="code" href="../../d0/d6/iop_8h.html#a175">IopGetDriverNameFromKeyNode</a>( KeyHandle,
03504                                           &amp;driverName );
03505     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
03506         <span class="keywordflow">goto</span> IopLoadExit;
03507     }
03508 
03509     InitializeObjectAttributes( &amp;objectAttributes,
03510                                 &amp;driverName,
03511                                 OBJ_PERMANENT,
03512                                 (HANDLE) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
03513                                 (PSECURITY_DESCRIPTOR) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
03514 
03515     <span class="comment">//</span>
03516     <span class="comment">// Load the driver image into memory.  If this fails partway through</span>
03517     <span class="comment">// the operation, then it will automatically be unloaded.</span>
03518     <span class="comment">//</span>
03519 
03520     status = <a class="code" href="../../d8/d8/sysload_8c.html#a53">MmLoadSystemImage</a>( &amp;baseName,
03521                                 <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
03522                                 <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
03523                                 <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
03524                                 &amp;sectionPointer,
03525                                 (PVOID *) &amp;imageBaseAddress );
03526 
03527     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
03528 
03529         <span class="comment">//</span>
03530         <span class="comment">// If the image was not already loaded then exit.</span>
03531         <span class="comment">//</span>
03532 
03533         <span class="keywordflow">if</span> (status != STATUS_IMAGE_ALREADY_LOADED) {
03534 
03535             <a class="code" href="../../d2/d4/internal_8c.html#a75">IopBootLog</a>(&amp;baseName, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
03536 
03537             <span class="keywordflow">goto</span> IopLoadExit;
03538         }
03539 
03540         <span class="comment">//</span>
03541         <span class="comment">// Open the driver object.</span>
03542         <span class="comment">//</span>
03543 
03544         status = <a class="code" href="../../d7/d1/obref_8c.html#a2">ObOpenObjectByName</a>( &amp;objectAttributes,
03545                                      <a class="code" href="../../d3/d5/iodata_8c.html#a36">IoDriverObjectType</a>,
03546                                      <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
03547                                      <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
03548                                      0,
03549                                      <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
03550                                      &amp;driverHandle );
03551 
03552 
03553         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
03554 
03555             <a class="code" href="../../d2/d4/internal_8c.html#a75">IopBootLog</a>(&amp;baseName, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
03556 
03557             <span class="keywordflow">goto</span> IopLoadExit;
03558         }
03559 
03560         <span class="comment">//</span>
03561         <span class="comment">// Reference the handle and obtain a pointer to the driver object so that</span>
03562         <span class="comment">// the handle can be deleted without the object going away.</span>
03563         <span class="comment">//</span>
03564 
03565         status = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a>( driverHandle,
03566                                             0,
03567                                             <a class="code" href="../../d3/d5/iodata_8c.html#a36">IoDriverObjectType</a>,
03568                                             KeGetPreviousMode(),
03569                                             (PVOID *) &amp;driverObject,
03570                                             (<a class="code" href="../../d3/d5/struct__OBJECT__HANDLE__INFORMATION.html">POBJECT_HANDLE_INFORMATION</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
03571 
03572         <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>( driverHandle );
03573 
03574         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
03575             <a class="code" href="../../d2/d4/internal_8c.html#a75">IopBootLog</a>(&amp;baseName, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
03576             <span class="keywordflow">goto</span> IopLoadExit;
03577         }
03578 
03579         status = <a class="code" href="../../d2/d4/internal_8c.html#a13">IopResurrectDriver</a>( driverObject );
03580 
03581         <span class="comment">//</span>
03582         <span class="comment">// Regardless of the status the driver object should be dereferenced.</span>
03583         <span class="comment">// if the unload has already run then driver is almost gone. If</span>
03584         <span class="comment">// the driver has been resurrected then the I/O system still has its</span>
03585         <span class="comment">// original reference.</span>
03586         <span class="comment">//</span>
03587 
03588         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( driverObject );
03589         <a class="code" href="../../d2/d4/internal_8c.html#a75">IopBootLog</a>(&amp;baseName, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
03590         <span class="keywordflow">goto</span> IopLoadExit;
03591     } <span class="keywordflow">else</span> {
03592 
03593         ntHeaders = <a class="code" href="../../d8/d9/imagedir_8c.html#a0">RtlImageNtHeader</a>( imageBaseAddress );
03594 
03595         <span class="comment">//</span>
03596         <span class="comment">// Check should this driver be loaded.  If yes, the enum subkey</span>
03597         <span class="comment">// of the service will be prepared.</span>
03598         <span class="comment">//</span>
03599 
03600         status = <a class="code" href="../../d0/d2/pri__bld_2pnpsubs_8c.html#a5">IopPrepareDriverLoading</a> (&amp;serviceName, KeyHandle, ntHeaders);
03601         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
03602             <a class="code" href="../../d8/d8/sysload_8c.html#a59">MmUnloadSystemImage</a>(sectionPointer);
03603             <a class="code" href="../../d2/d4/internal_8c.html#a75">IopBootLog</a>(&amp;baseName, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
03604             <span class="keywordflow">goto</span> IopLoadExit;
03605         }
03606 
03607     }
03608 
03609     <span class="comment">//</span>
03610     <span class="comment">// The driver image has now been loaded into memory.  Create the driver</span>
03611     <span class="comment">// object that represents this image.</span>
03612     <span class="comment">//</span>
03613 
03614     status = <a class="code" href="../../d6/d0/obcreate_8c.html#a5">ObCreateObject</a>( KeGetPreviousMode(),
03615                              <a class="code" href="../../d3/d5/iodata_8c.html#a36">IoDriverObjectType</a>,
03616                              &amp;objectAttributes,
03617                              <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
03618                              (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
03619                              (ULONG) (<span class="keyword">sizeof</span>( <a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html">DRIVER_OBJECT</a> ) + <span class="keyword">sizeof</span> ( <a class="code" href="../../d1/d9/struct__DRIVER__EXTENSION.html">DRIVER_EXTENSION</a> )),
03620                              0,
03621                              0,
03622                              (PVOID *) &amp;driverObject );
03623 
03624     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
03625         <a class="code" href="../../d2/d4/internal_8c.html#a75">IopBootLog</a>(&amp;baseName, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
03626         <span class="keywordflow">goto</span> IopLoadExit;
03627     }
03628 
03629     <span class="comment">//</span>
03630     <span class="comment">// Initialize this driver object and insert it into the object table.</span>
03631     <span class="comment">//</span>
03632 
03633     RtlZeroMemory( driverObject, <span class="keyword">sizeof</span>( <a class="code" href="../../d0/d5/io_8h.html#a345">DRIVER_OBJECT</a> ) + <span class="keyword">sizeof</span> ( <a class="code" href="../../d0/d5/io_8h.html#a343">DRIVER_EXTENSION</a>) );
03634     driverObject-&gt;DriverExtension = (<a class="code" href="../../d1/d9/struct__DRIVER__EXTENSION.html">PDRIVER_EXTENSION</a>) (driverObject + 1);
03635     driverObject-&gt;DriverExtension-&gt;DriverObject = driverObject;
03636 
03637     <span class="keywordflow">for</span> (i = 0; i &lt;= <a class="code" href="../../d0/d5/io_8h.html#a42">IRP_MJ_MAXIMUM_FUNCTION</a>; i++) {
03638         driverObject-&gt;MajorFunction[i] = <a class="code" href="../../d2/d4/internal_8c.html#a45">IopInvalidDeviceRequest</a>;
03639     }
03640 
03641     driverObject-&gt;Type = <a class="code" href="../../d0/d5/io_8h.html#a3">IO_TYPE_DRIVER</a>;
03642     driverObject-&gt;Size = <span class="keyword">sizeof</span>( <a class="code" href="../../d0/d5/io_8h.html#a345">DRIVER_OBJECT</a> );
03643     ntHeaders = <a class="code" href="../../d8/d9/imagedir_8c.html#a0">RtlImageNtHeader</a>( imageBaseAddress );
03644     entryPoint = ntHeaders-&gt;OptionalHeader.AddressOfEntryPoint;
03645     entryPoint += (ULONG_PTR) imageBaseAddress;
03646     <span class="keywordflow">if</span> (!(ntHeaders-&gt;OptionalHeader.DllCharacteristics &amp; IMAGE_DLLCHARACTERISTICS_WDM_DRIVER)) {
03647         driverObject-&gt;Flags |= <a class="code" href="../../d0/d5/io_8h.html#a144">DRVO_LEGACY_DRIVER</a>;
03648     }
03649     driverObject-&gt;DriverInit = (<a class="code" href="../../d0/d5/io_8h.html#a284">PDRIVER_INITIALIZE</a>) entryPoint;
03650     driverObject-&gt;DriverSection = sectionPointer;
03651     driverObject-&gt;DriverStart = imageBaseAddress;
03652     driverObject-&gt;DriverSize = ntHeaders-&gt;OptionalHeader.SizeOfImage;
03653 
03654     status = <a class="code" href="../../d1/d1/obinsert_8c.html#a0">ObInsertObject</a>( driverObject,
03655                              (<a class="code" href="../../d2/d5/struct__ACCESS__STATE.html">PACCESS_STATE</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
03656                              FILE_READ_DATA,
03657                              0,
03658                              (PVOID *) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
03659                              &amp;driverHandle );
03660     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
03661         <a class="code" href="../../d2/d4/internal_8c.html#a75">IopBootLog</a>(&amp;baseName, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
03662         <span class="keywordflow">goto</span> IopLoadExit;
03663     }
03664 
03665     <span class="comment">//</span>
03666     <span class="comment">// Reference the handle and obtain a pointer to the driver object so that</span>
03667     <span class="comment">// the handle can be deleted without the object going away.</span>
03668     <span class="comment">//</span>
03669 
03670     status = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a>( driverHandle,
03671                                         0,
03672                                         <a class="code" href="../../d3/d5/iodata_8c.html#a36">IoDriverObjectType</a>,
03673                                         KeGetPreviousMode(),
03674                                         (PVOID *) &amp;driverObject,
03675                                         (<a class="code" href="../../d3/d5/struct__OBJECT__HANDLE__INFORMATION.html">POBJECT_HANDLE_INFORMATION</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
03676 
03677     <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>( driverHandle );
03678 
03679     <span class="comment">//</span>
03680     <span class="comment">// Load the Registry information in the appropriate fields of the device</span>
03681     <span class="comment">// object.</span>
03682     <span class="comment">//</span>
03683 
03684     driverObject-&gt;HardwareDatabase =
03685         &amp;<a class="code" href="../../d6/d0/cmdat_8c.html#a17">CmRegistryMachineHardwareDescriptionSystemName</a>;
03686 
03687     <span class="comment">//</span>
03688     <span class="comment">// Store the name of the device driver in the driver object so that it</span>
03689     <span class="comment">// can be easily found by the error log thread.</span>
03690     <span class="comment">//</span>
03691 
03692     driverObject-&gt;DriverName.Buffer = <a class="code" href="../../d5/d5/cc_8h.html#a10">ExAllocatePool</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>,
03693                                                       driverName.MaximumLength );
03694     <span class="keywordflow">if</span> (driverObject-&gt;DriverName.Buffer) {
03695         driverObject-&gt;DriverName.MaximumLength = driverName.MaximumLength;
03696         driverObject-&gt;DriverName.Length = driverName.Length;
03697 
03698         RtlCopyMemory( driverObject-&gt;DriverName.Buffer,
03699                        driverName.Buffer,
03700                        driverName.MaximumLength );
03701     }
03702 
03703     <span class="comment">//</span>
03704     <span class="comment">// Query the name of the registry path for this driver so that it can</span>
03705     <span class="comment">// be passed to the driver.</span>
03706     <span class="comment">//</span>
03707 
03708     registryPath = <a class="code" href="../../d5/d5/cc_8h.html#a10">ExAllocatePool</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> );
03709     <span class="keywordflow">if</span> (!registryPath) {
03710         <a class="code" href="../../d5/d0/obclose_8c.html#a3">ObMakeTemporaryObject</a>( driverObject );
03711         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( driverObject );
03712         status = STATUS_INSUFFICIENT_RESOURCES;
03713         <span class="keywordflow">goto</span> IopLoadExit;
03714     }
03715 
03716     status = <a class="code" href="../../d6/d1/obquery_8c.html#a5">NtQueryObject</a>( KeyHandle,
03717                             ObjectNameInformation,
03718                             registryPath,
03719                             <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>,
03720                             &amp;i );
03721     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
03722         <a class="code" href="../../d5/d0/obclose_8c.html#a3">ObMakeTemporaryObject</a>( driverObject );
03723         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( driverObject );
03724         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( registryPath );
03725         <span class="keywordflow">goto</span> IopLoadExit;
03726     }
03727 
03728 <span class="preprocessor">#if DBG</span>
03729 <span class="preprocessor"></span>    <a class="code" href="../../d7/d0/ke_2miscc_8c.html#a3">KeQuerySystemTime</a> (&amp;stime);
03730 <span class="preprocessor">#endif</span>
03731 <span class="preprocessor"></span>
03732     <span class="comment">//</span>
03733     <span class="comment">// Store the service key name of the device driver in the driver object</span>
03734     <span class="comment">//</span>
03735 
03736     <span class="keywordflow">if</span> (serviceName.Buffer) {
03737         driverObject-&gt;DriverExtension-&gt;ServiceKeyName.Buffer =
03738             <a class="code" href="../../d5/d5/cc_8h.html#a10">ExAllocatePool</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, serviceName.MaximumLength );
03739         <span class="keywordflow">if</span> (driverObject-&gt;DriverExtension-&gt;ServiceKeyName.Buffer) {
03740             driverObject-&gt;DriverExtension-&gt;ServiceKeyName.MaximumLength = serviceName.MaximumLength;
03741             driverObject-&gt;DriverExtension-&gt;ServiceKeyName.Length = serviceName.Length;
03742 
03743             RtlCopyMemory( driverObject-&gt;DriverExtension-&gt;ServiceKeyName.Buffer,
03744                            serviceName.Buffer,
03745                            serviceName.MaximumLength );
03746         }
03747     }
03748 
03749     <span class="comment">//</span>
03750     <span class="comment">// Now invoke the driver's initialization routine to initialize itself.</span>
03751     <span class="comment">//</span>
03752 
03753     <a class="code" href="../../d2/d1/mm_8h.html#a45">PERFINFO_DRIVER_INIT</a>(driverObject);
03754 
03755     status = driverObject-&gt;DriverInit( driverObject, &amp;registryPath-&gt;Name );
03756 
03757     <a class="code" href="../../d2/d1/mm_8h.html#a46">PERFINFO_DRIVER_INIT_COMPLETE</a>(driverObject);
03758 
03759 <span class="preprocessor">#if DBG</span>
03760 <span class="preprocessor"></span>
03761     <span class="comment">//</span>
03762     <span class="comment">// If DriverInit took longer than 5 seconds, print a message.</span>
03763     <span class="comment">//</span>
03764 
03765     <a class="code" href="../../d7/d0/ke_2miscc_8c.html#a3">KeQuerySystemTime</a> (&amp;etime);
03766     dtime  = (ULONG) ((etime.QuadPart - stime.QuadPart) / 1000000);
03767 
03768     <span class="keywordflow">if</span> (dtime &gt; 50) {
03769         <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( <span class="stringliteral">"IOLOAD: Driver %wZ took %d.%ds to %s\n"</span>,
03770             &amp;driverName,
03771             dtime/10,
03772             dtime%10,
03773             <a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status) ? <span class="stringliteral">"initialize"</span> : <span class="stringliteral">"fail initialization"</span>
03774             );
03775 
03776     }
03777 <span class="preprocessor">#endif</span>
03778 <span class="preprocessor"></span>
03779     <span class="comment">//</span>
03780     <span class="comment">// Workaround for broken NT 4.0 3D labs driver</span>
03781     <span class="comment">// They zero out some function table entries by mistake.</span>
03782 
03783     <span class="keywordflow">for</span> (i = 0; i &lt;= <a class="code" href="../../d0/d5/io_8h.html#a42">IRP_MJ_MAXIMUM_FUNCTION</a>; i++) {
03784         <span class="keywordflow">if</span> (driverObject-&gt;MajorFunction[i] == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03785             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(driverObject-&gt;MajorFunction[i] != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
03786             driverObject-&gt;MajorFunction[i] = <a class="code" href="../../d2/d4/internal_8c.html#a45">IopInvalidDeviceRequest</a>;
03787         }
03788     }
03789 
03790     <span class="comment">//</span>
03791     <span class="comment">// If DriverInit doesn't work, then simply unload the image and mark the driver</span>
03792     <span class="comment">// object as temporary.  This will cause everything to be deleted.</span>
03793     <span class="comment">//</span>
03794 
03795     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( registryPath );
03796 
03797     <span class="comment">//</span>
03798     <span class="comment">// If we load the driver because we think it is a legacy driver and</span>
03799     <span class="comment">// it does not create any device object in its DriverEntry.  We will</span>
03800     <span class="comment">// unload this driver.</span>
03801     <span class="comment">//</span>
03802 
03803     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status) &amp;&amp; !<a class="code" href="../../d0/d2/pri__bld_2pnpsubs_8c.html#a32">IopIsLegacyDriver</a>(driverObject)) {
03804         <span class="keywordflow">if</span> (driverObject-&gt;DeviceObject == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> &amp;&amp;
03805             serviceName.Buffer &amp;&amp;
03806             !<a class="code" href="../../d0/d2/pri__bld_2pnpsubs_8c.html#a19">IopIsAnyDeviceInstanceEnabled</a>(&amp;serviceName, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) &amp;&amp;
03807             !(driverObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a146">DRVO_REINIT_REGISTERED</a>)) {
03808             <a class="code" href="../../d0/d2/pri__bld_2pnpsubs_8c.html#a18">IopDriverLoadingFailed</a>(KeyHandle, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
03809             status = STATUS_PLUGPLAY_NO_DEVICE;
03810         } <span class="keywordflow">else</span> {
03811 
03812             <span class="comment">//</span>
03813             <span class="comment">// Start the devices controlled by the driver and enumerate them</span>
03814             <span class="comment">// At this point, we know there is at least one device controlled by the driver.</span>
03815             <span class="comment">//</span>
03816 
03817             <a class="code" href="../../d0/d2/pri__bld_2pnpsubs_8c.html#a34">IopDeleteLegacyKey</a>(driverObject);
03818             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/pnpdata_8c.html#a14">PnPInitialized</a>) {
03819                 status = <a class="code" href="../../d9/d0/pnpiop_8h.html#a287">IopStartDriverDevices</a>(driverObject);
03820             }
03821         }
03822         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
03823             <span class="keywordflow">if</span> (driverObject-&gt;DriverUnload) {
03824                 driverObject-&gt;Flags |= <a class="code" href="../../d0/d5/io_8h.html#a143">DRVO_UNLOAD_INVOKED</a>;
03825                 driverObject-&gt;DriverUnload(driverObject);
03826                 <a class="code" href="../../d2/d4/internal_8c.html#a75">IopBootLog</a>(&amp;baseName, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
03827             } <span class="keywordflow">else</span> {
03828 <span class="preprocessor">    #if DBG</span>
03829 <span class="preprocessor"></span>                <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"IopLoadDriver: A PnP driver %wZ does not support DriverUnload routine.\n"</span>, &amp;driverName);
03830                 <span class="comment">// ASSERT(0);</span>
03831 <span class="preprocessor">    #endif</span>
03832 <span class="preprocessor"></span>            }
03833         }
03834     }
03835 
03836     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
03837         <a class="code" href="../../d5/d0/obclose_8c.html#a3">ObMakeTemporaryObject</a>( driverObject );
03838         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( driverObject );
03839     } <span class="keywordflow">else</span> {
03840 
03841         <span class="comment">//</span>
03842         <span class="comment">// Free the memory occupied by the driver's initialization routines.</span>
03843         <span class="comment">//</span>
03844 
03845         <a class="code" href="../../d2/d4/internal_8c.html#a75">IopBootLog</a>(&amp;baseName, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
03846         <a class="code" href="../../d8/d8/sysload_8c.html#a55">MmFreeDriverInitialization</a>( driverObject-&gt;DriverSection );
03847         <a class="code" href="../../d0/d6/iop_8h.html#a207">IopReadyDeviceObjects</a>( driverObject );
03848     }
03849 
03850 IopLoadExit:
03851 
03852     <span class="comment">//</span>
03853     <span class="comment">// Free any pool that was allocated by this routine that has not yet</span>
03854     <span class="comment">// been freed.</span>
03855     <span class="comment">//</span>
03856 
03857     <span class="keywordflow">if</span> (driverName.Buffer != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03858         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( driverName.Buffer );
03859     }
03860 
03861     <span class="keywordflow">if</span> (keyValueInformation != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03862         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( keyValueInformation );
03863     }
03864 
03865     <span class="keywordflow">if</span> (keyBasicInformation != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03866         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( keyBasicInformation );
03867     }
03868 
03869     <span class="keywordflow">if</span> (serviceName.Buffer != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03870         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(serviceName.Buffer);
03871     }
03872 
03873     <span class="comment">//</span>
03874     <span class="comment">// If this routine is about to return a failure, then let the Configuration</span>
03875     <span class="comment">// Manager know about it.  But, if STATUS_PLUGPLAY_NO_DEVICE, the device was</span>
03876     <span class="comment">// disabled by hardware profile.  In this case we don't need to report it.</span>
03877     <span class="comment">//</span>
03878 
03879     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status ) &amp;&amp; (status != STATUS_PLUGPLAY_NO_DEVICE)) {
03880 
03881         <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> lStatus;
03882         PULONG errorControl;
03883 
03884         <span class="keywordflow">if</span> (status != STATUS_IMAGE_ALREADY_LOADED) {
03885 
03886             <span class="comment">//</span>
03887             <span class="comment">// If driver was loaded, do not call IopDriverLoadingFailed to change</span>
03888             <span class="comment">// the driver loading status.  Because, obviously, the driver is</span>
03889             <span class="comment">// running.</span>
03890             <span class="comment">//</span>
03891 
03892             <a class="code" href="../../d0/d2/pri__bld_2pnpsubs_8c.html#a18">IopDriverLoadingFailed</a>(KeyHandle, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
03893             lStatus = <a class="code" href="../../d6/d5/ioep_8h.html#a52">IopGetRegistryValue</a>( KeyHandle,
03894                                            <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"ErrorControl"</span>,
03895                                            &amp;keyValueInformation );
03896             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( lStatus ) || !keyValueInformation-&gt;DataLength) {
03897                 <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( lStatus )) {
03898                     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( keyValueInformation );
03899                 }
03900             } <span class="keywordflow">else</span> {
03901                 errorControl = (PULONG) ((PUCHAR) keyValueInformation + keyValueInformation-&gt;DataOffset);
03902                 <a class="code" href="../../d7/d9/cm_8h.html#a34">CmBootLastKnownGood</a>( *errorControl );
03903                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( keyValueInformation );
03904             }
03905         }
03906     }
03907 
03908     <span class="comment">//</span>
03909     <span class="comment">// Close the caller's handle and return the final status from the load</span>
03910     <span class="comment">// operation.</span>
03911     <span class="comment">//</span>
03912 
03913     <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>( KeyHandle );
03914     <span class="keywordflow">return</span> status;
03915 }
03916 
03917 
03918 <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>
<a name="l03919"></a><a class="code" href="../../d0/d6/iop_8h.html#a173">03919</a> <a class="code" href="../../d0/d6/iop_8h.html#a173">IopGetDeviceAttachmentBase</a>(
03920     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject
03921     )
03922 
03923 <span class="comment">/*++</span>
03924 <span class="comment"></span>
03925 <span class="comment">Routine Description:</span>
03926 <span class="comment"></span>
03927 <span class="comment">    This routine returns the lowest level device object associated with</span>
03928 <span class="comment">    the specified device.</span>
03929 <span class="comment"></span>
03930 <span class="comment">Arguments:</span>
03931 <span class="comment"></span>
03932 <span class="comment">    DeviceObject - Supplies a pointer to the device for which the bottom of</span>
03933 <span class="comment">        attachment chain is to be found.</span>
03934 <span class="comment"></span>
03935 <span class="comment">Return Value:</span>
03936 <span class="comment"></span>
03937 <span class="comment">    The function value is a reference to the lowest level device attached</span>
03938 <span class="comment">    to the specified device.  If the supplied device object is that device</span>
03939 <span class="comment">    object, then a pointer to it is returned.</span>
03940 <span class="comment"></span>
03941 <span class="comment">    N.B. Caller must own the IopDatabaseLock.</span>
03942 <span class="comment"></span>
03943 <span class="comment">--*/</span>
03944 
03945 {
03946     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> baseDeviceObject;
03947     <a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html">PDEVOBJ_EXTENSION</a> deviceExtension;
03948 
03949     <span class="comment">//</span>
03950     <span class="comment">// Descend down the attachment chain until we find a device object</span>
03951     <span class="comment">// that isn't attached to anything else.</span>
03952     <span class="comment">//</span>
03953 
03954     baseDeviceObject = DeviceObject;
03955     deviceExtension = baseDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o25">DeviceObjectExtension</a>;
03956     <span class="keywordflow">while</span> (deviceExtension-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o7">AttachedTo</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03957 
03958         baseDeviceObject = deviceExtension-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o7">AttachedTo</a>;
03959         deviceExtension = baseDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o25">DeviceObjectExtension</a>;
03960     }
03961 
03962     <span class="keywordflow">return</span> baseDeviceObject;
03963 }
03964 
03965 
03966 <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>
<a name="l03967"></a><a class="code" href="../../d0/d6/iop_8h.html#a174">03967</a> <a class="code" href="../../d0/d6/iop_8h.html#a174">IopGetDeviceAttachmentBaseRef</a>(
03968     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject
03969     )
03970 
03971 <span class="comment">/*++</span>
03972 <span class="comment"></span>
03973 <span class="comment">Routine Description:</span>
03974 <span class="comment"></span>
03975 <span class="comment">    This routine returns the lowest level device object associated with</span>
03976 <span class="comment">    the specified device.</span>
03977 <span class="comment"></span>
03978 <span class="comment">Arguments:</span>
03979 <span class="comment"></span>
03980 <span class="comment">    DeviceObject - Supplies a pointer to the device for which the bottom of</span>
03981 <span class="comment">        attachment chain is to be found.</span>
03982 <span class="comment"></span>
03983 <span class="comment">Return Value:</span>
03984 <span class="comment"></span>
03985 <span class="comment">    The function value is a reference to the lowest level device attached</span>
03986 <span class="comment">    to the specified device.  If the supplied device object is that device</span>
03987 <span class="comment">    object, then a pointer to it is returned.</span>
03988 <span class="comment"></span>
03989 <span class="comment">    A reference is taken on the returned device object.  It is the</span>
03990 <span class="comment">    responsibility of the caller to release it.</span>
03991 <span class="comment"></span>
03992 <span class="comment">--*/</span>
03993 
03994 {
03995     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> baseDeviceObject;
03996     KIRQL irql;
03997 
03998     <span class="comment">//</span>
03999     <span class="comment">// Any examination of attachment chain linkage must be done with</span>
04000     <span class="comment">// IopDatabaseLock taken.</span>
04001     <span class="comment">//</span>
04002 
04003     ExAcquireSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, &amp;irql );
04004 
04005     <span class="comment">//</span>
04006     <span class="comment">// Find the base of the attachment chain.</span>
04007     <span class="comment">//</span>
04008 
04009     baseDeviceObject = <a class="code" href="../../d0/d6/iop_8h.html#a173">IopGetDeviceAttachmentBase</a>( DeviceObject );
04010 
04011     <span class="comment">//</span>
04012     <span class="comment">// Reference the device object before releasing the database lock.</span>
04013     <span class="comment">//</span>
04014 
04015     <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a>( baseDeviceObject );
04016     ExReleaseSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, irql );
04017 
04018     <span class="keywordflow">return</span> baseDeviceObject;
04019 }
04020 
04021 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l04022"></a><a class="code" href="../../d0/d6/iop_8h.html#a161">04022</a> <a class="code" href="../../d0/d6/iop_8h.html#a161">IopDecrementDeviceObjectRef</a>(
04023     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
04024     IN BOOLEAN AlwaysUnload
04025     )
04026 
04027 <span class="comment">/*++</span>
04028 <span class="comment"></span>
04029 <span class="comment">Routine Description:</span>
04030 <span class="comment"></span>
04031 <span class="comment">    The routine decrements the reference count on a device object.  If the</span>
04032 <span class="comment">    reference count goes to zero and the device object is a candidate for deletion</span>
04033 <span class="comment">    then IopCompleteUnloadOrDelete is called.  A device object is subject for</span>
04034 <span class="comment">    deletion if the AlwaysUnload flag is true, or the device object is pending</span>
04035 <span class="comment">    deletion or the driver is pending unload.</span>
04036 <span class="comment"></span>
04037 <span class="comment">Arguments:</span>
04038 <span class="comment"></span>
04039 <span class="comment">    DeviceObject - Supplies the device object whose reference count is to be</span>
04040 <span class="comment">                   decremented.</span>
04041 <span class="comment"></span>
04042 <span class="comment">    AlwaysUnload - Indicates if the driver should be unloaded regardless of the</span>
04043 <span class="comment">                   state of the unload flag.</span>
04044 <span class="comment"></span>
04045 <span class="comment">Return Value:</span>
04046 <span class="comment"></span>
04047 <span class="comment">    None.</span>
04048 <span class="comment"></span>
04049 <span class="comment">--*/</span>
04050 {
04051     KIRQL irql;
04052 
04053     <span class="comment">//</span>
04054     <span class="comment">// Decrement the reference count on the device object.  If this is the last</span>
04055     <span class="comment">// last reason that this mini-file system recognizer needs to stay around,</span>
04056     <span class="comment">// then unload it.</span>
04057     <span class="comment">//</span>
04058 
04059     ExAcquireSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, &amp;irql );
04060 
04061     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( DeviceObject-&gt;ReferenceCount &gt; 0 );
04062 
04063     DeviceObject-&gt;ReferenceCount--;
04064 
04065     <span class="keywordflow">if</span> (!DeviceObject-&gt;ReferenceCount &amp;&amp; (AlwaysUnload ||
04066          DeviceObject-&gt;DeviceObjectExtension-&gt;ExtensionFlags &amp;
04067          (<a class="code" href="../../d0/d5/io_8h.html#a139">DOE_DELETE_PENDING</a> | <a class="code" href="../../d0/d5/io_8h.html#a138">DOE_UNLOAD_PENDING</a> | <a class="code" href="../../d0/d5/io_8h.html#a140">DOE_REMOVE_PENDING</a>))) {
04068 
04069         <a class="code" href="../../d0/d6/iop_8h.html#a155">IopCompleteUnloadOrDelete</a>( DeviceObject, irql );
04070     } <span class="keywordflow">else</span> {
04071         ExReleaseSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, irql );
04072     }
04073 
04074 }
04075 
04076 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l04077"></a><a class="code" href="../../d0/d6/iop_8h.html#a192">04077</a> <a class="code" href="../../d0/d6/iop_8h.html#a192">IopLoadFileSystemDriver</a>(
04078     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject
04079     )
04080 
04081 <span class="comment">/*++</span>
04082 <span class="comment"></span>
04083 <span class="comment">Routine Description:</span>
04084 <span class="comment"></span>
04085 <span class="comment">    This routine is invoked when a mini-file system recognizer driver recognizes</span>
04086 <span class="comment">    a volume as being a particular file system, but the driver for that file</span>
04087 <span class="comment">    system has not yet been loaded.  This function allows the mini-driver to</span>
04088 <span class="comment">    load the real file system, and remove itself from the system, so that the</span>
04089 <span class="comment">    real file system can mount the device in question.</span>
04090 <span class="comment"></span>
04091 <span class="comment">Arguments:</span>
04092 <span class="comment"></span>
04093 <span class="comment">    DeviceObject - Registered file system device object for the mini-driver.</span>
04094 <span class="comment"></span>
04095 <span class="comment">Return Value:</span>
04096 <span class="comment"></span>
04097 <span class="comment">    None.</span>
04098 <span class="comment"></span>
04099 <span class="comment">--*/</span>
04100 
04101 {
04102     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> event;
04103     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
04104     IO_STATUS_BLOCK ioStatus;
04105     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
04106     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
04107     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> attachedDevice;
04108 
04109     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
04110 
04111     attachedDevice = DeviceObject;
04112     <span class="keywordflow">while</span> (attachedDevice-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o5">AttachedDevice</a>) {
04113         attachedDevice = attachedDevice-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o5">AttachedDevice</a>;
04114     }
04115 
04116     <span class="comment">//</span>
04117     <span class="comment">// Begin by building an I/O Request Packet to have the mini-file system</span>
04118     <span class="comment">// driver load the real file system.</span>
04119     <span class="comment">//</span>
04120 
04121     <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;event, NotificationEvent, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
04122 
04123     irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a25">IoBuildDeviceIoControlRequest</a>( <a class="code" href="../../d0/d5/io_8h.html#a27">IRP_MJ_DEVICE_CONTROL</a>,
04124                                          attachedDevice,
04125                                          (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
04126                                          0,
04127                                          (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
04128                                          0,
04129                                          <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
04130                                          &amp;event,
04131                                          &amp;ioStatus );
04132     <span class="keywordflow">if</span> (irp) {
04133 
04134         <span class="comment">//</span>
04135         <span class="comment">// Change the actual major and minor function codes to be a file system</span>
04136         <span class="comment">// control with a minor function code of load FS driver.</span>
04137         <span class="comment">//</span>
04138 
04139         irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
04140         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a26">IRP_MJ_FILE_SYSTEM_CONTROL</a>;
04141         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o1">MinorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a49">IRP_MN_LOAD_FILE_SYSTEM</a>;
04142 
04143         <span class="comment">//</span>
04144         <span class="comment">// Now issue the request.</span>
04145         <span class="comment">//</span>
04146 
04147         status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( attachedDevice, irp );
04148         <span class="keywordflow">if</span> (status == STATUS_PENDING) {
04149             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
04150                                           <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
04151                                           <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
04152                                           <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
04153                                           (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
04154         }
04155     }
04156 
04157     <span class="comment">//</span>
04158     <span class="comment">// Decrement the reference count on the device object.  If this is the last</span>
04159     <span class="comment">// last reason that this mini-file system recognizer needs to stay around,</span>
04160     <span class="comment">// then unload it.</span>
04161     <span class="comment">//</span>
04162 
04163     <a class="code" href="../../d0/d6/iop_8h.html#a161">IopDecrementDeviceObjectRef</a>(DeviceObject, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
04164 
04165     <span class="keywordflow">return</span>;
04166 }
04167 
04168 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l04169"></a><a class="code" href="../../d0/d6/iop_8h.html#a193">04169</a> <a class="code" href="../../d0/d6/iop_8h.html#a193">IopLoadUnloadDriver</a>(
04170     IN PVOID Parameter
04171     )
04172 
04173 <span class="comment">/*++</span>
04174 <span class="comment"></span>
04175 <span class="comment">Routine Description:</span>
04176 <span class="comment"></span>
04177 <span class="comment">    This routine is executed as an EX worker thread routine when a driver is</span>
04178 <span class="comment">    to be loaded or unloaded dynamically.  It is used because some drivers</span>
04179 <span class="comment">    need to create system threads in the context of the system process, which</span>
04180 <span class="comment">    cannot be done in the context of the caller of the system service that</span>
04181 <span class="comment">    was invoked to load or unload the specified driver.</span>
04182 <span class="comment"></span>
04183 <span class="comment">Arguments:</span>
04184 <span class="comment"></span>
04185 <span class="comment">    Parameter - Pointer to the load packet describing what work is to be</span>
04186 <span class="comment">        done.</span>
04187 <span class="comment"></span>
04188 <span class="comment">Return Value:</span>
04189 <span class="comment"></span>
04190 <span class="comment">    None.</span>
04191 <span class="comment"></span>
04192 <span class="comment">--*/</span>
04193 
04194 {
04195     <a class="code" href="../../d0/d2/struct__LOAD__PACKET.html">PLOAD_PACKET</a> loadPacket;
04196     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
04197     HANDLE keyHandle;
04198 
04199     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
04200 
04201     <span class="comment">//</span>
04202     <span class="comment">// Begin by getting a pointer to the load packet.</span>
04203     <span class="comment">//</span>
04204 
04205     loadPacket = (<a class="code" href="../../d0/d2/struct__LOAD__PACKET.html">PLOAD_PACKET</a>) Parameter;
04206 
04207     <span class="comment">//</span>
04208     <span class="comment">// If the driver object field of the packet is non-NULL, then this is</span>
04209     <span class="comment">// a request to complete the unload of a driver.  Simply invoke the</span>
04210     <span class="comment">// driver's unload routine.  Note that the final status of the unload</span>
04211     <span class="comment">// is ignored, so it is not set here.</span>
04212     <span class="comment">//</span>
04213 
04214     <span class="keywordflow">if</span> (loadPacket-&gt;<a class="code" href="../../d0/d2/struct__LOAD__PACKET.html#o2">DriverObject</a>) {
04215 
04216         loadPacket-&gt;<a class="code" href="../../d0/d2/struct__LOAD__PACKET.html#o2">DriverObject</a>-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o13">DriverUnload</a>( loadPacket-&gt;<a class="code" href="../../d0/d2/struct__LOAD__PACKET.html#o2">DriverObject</a> );
04217         status = STATUS_SUCCESS;
04218 
04219     } <span class="keywordflow">else</span> {
04220 
04221         PLIST_ENTRY entry;
04222         <a class="code" href="../../d5/d3/struct__REINIT__PACKET.html">PREINIT_PACKET</a> reinitEntry;
04223 
04224         <span class="comment">//</span>
04225         <span class="comment">// The driver specified by the DriverServiceName is to be loaded.</span>
04226         <span class="comment">// Begin by opening the registry node for this driver.  Note</span>
04227         <span class="comment">// that if this is successful, then the load driver routine is</span>
04228         <span class="comment">// responsible for closing the handle.</span>
04229         <span class="comment">//</span>
04230 
04231         status = <a class="code" href="../../d0/d6/iop_8h.html#a198">IopOpenRegistryKey</a>( &amp;keyHandle,
04232                                      (HANDLE) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
04233                                      loadPacket-&gt;<a class="code" href="../../d0/d2/struct__LOAD__PACKET.html#o3">DriverServiceName</a>,
04234                                      KEY_READ,
04235                                      <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
04236         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
04237 
04238             <span class="comment">//</span>
04239             <span class="comment">// Invoke the internal common routine to perform the work.</span>
04240             <span class="comment">// This is the same routine that is used by the I/O system</span>
04241             <span class="comment">// initialization code to load drivers.</span>
04242             <span class="comment">//</span>
04243 
04244             status = <a class="code" href="../../d0/d6/iop_8h.html#a191">IopLoadDriver</a>( keyHandle, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
04245 
04246             <span class="comment">//</span>
04247             <span class="comment">// Walk the list reinitialization list in case this driver, or</span>
04248             <span class="comment">// some other driver, has requested to be invoked at a re-</span>
04249             <span class="comment">// initialization entry point.</span>
04250             <span class="comment">//</span>
04251 
04252             <span class="keywordflow">while</span> (entry = <a class="code" href="../../d5/d8/ex_8h.html#a239">ExInterlockedRemoveHeadList</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a11">IopDriverReinitializeQueueHead</a>, &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a> )) {
04253                 reinitEntry = CONTAINING_RECORD( entry, <a class="code" href="../../d5/d3/struct__REINIT__PACKET.html">REINIT_PACKET</a>, ListEntry );
04254 <span class="comment">//#if _PNP_POWER_</span>
04255                 reinitEntry-&gt;<a class="code" href="../../d5/d3/struct__REINIT__PACKET.html#o1">DriverObject</a>-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o7">DriverExtension</a>-&gt;<a class="code" href="../../d1/d9/struct__DRIVER__EXTENSION.html#o2">Count</a>++;
04256                 reinitEntry-&gt;<a class="code" href="../../d5/d3/struct__REINIT__PACKET.html#o1">DriverObject</a>-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o3">Flags</a> &amp;= ~<a class="code" href="../../d0/d5/io_8h.html#a146">DRVO_REINIT_REGISTERED</a>;
04257                 reinitEntry-&gt;<a class="code" href="../../d5/d3/struct__REINIT__PACKET.html#o2">DriverReinitializationRoutine</a>( reinitEntry-&gt;<a class="code" href="../../d5/d3/struct__REINIT__PACKET.html#o1">DriverObject</a>,
04258                                                             reinitEntry-&gt;<a class="code" href="../../d5/d3/struct__REINIT__PACKET.html#o3">Context</a>,
04259                                                             reinitEntry-&gt;<a class="code" href="../../d5/d3/struct__REINIT__PACKET.html#o1">DriverObject</a>-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o7">DriverExtension</a>-&gt;<a class="code" href="../../d1/d9/struct__DRIVER__EXTENSION.html#o2">Count</a> );
04260 <span class="comment">//#else</span>
04261 <span class="preprocessor">#if 0</span>
04262 <span class="preprocessor"></span>                reinitEntry-&gt;<a class="code" href="../../d5/d3/struct__REINIT__PACKET.html#o1">DriverObject</a>-&gt;Count++;
04263                 reinitEntry-&gt;<a class="code" href="../../d5/d3/struct__REINIT__PACKET.html#o2">DriverReinitializationRoutine</a>( reinitEntry-&gt;<a class="code" href="../../d5/d3/struct__REINIT__PACKET.html#o1">DriverObject</a>,
04264                                                             reinitEntry-&gt;<a class="code" href="../../d5/d3/struct__REINIT__PACKET.html#o3">Context</a>,
04265                                                             reinitEntry-&gt;<a class="code" href="../../d5/d3/struct__REINIT__PACKET.html#o1">DriverObject</a>-&gt;Count );
04266 <span class="preprocessor">#endif // _PNP_POWER_</span>
04267 <span class="preprocessor"></span>                <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( reinitEntry );
04268             }
04269         }
04270     }
04271 
04272     <span class="comment">//</span>
04273     <span class="comment">// Set the final status of the load or unload operation, and indicate to</span>
04274     <span class="comment">// the caller that the operation is now complete.</span>
04275     <span class="comment">//</span>
04276 
04277     loadPacket-&gt;<a class="code" href="../../d0/d2/struct__LOAD__PACKET.html#o4">FinalStatus</a> = status;
04278     (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>( &amp;loadPacket-&gt;<a class="code" href="../../d0/d2/struct__LOAD__PACKET.html#o1">Event</a>, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
04279 }
04280 
04281 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l04282"></a><a class="code" href="../../d0/d6/iop_8h.html#a195">04282</a> <a class="code" href="../../d0/d6/iop_8h.html#a195">IopMountVolume</a>(
04283     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
04284     IN BOOLEAN AllowRawMount,
04285     IN BOOLEAN DeviceLockAlreadyHeld,
04286     IN BOOLEAN Alertable
04287     )
04288 
04289 <span class="comment">/*++</span>
04290 <span class="comment"></span>
04291 <span class="comment">Routine Description:</span>
04292 <span class="comment"></span>
04293 <span class="comment">    This routine is used to mount a volume on the specified device.  The Volume</span>
04294 <span class="comment">    Parameter Block (VPB) for the specified device is a "clean" VPB.  That is,</span>
04295 <span class="comment">    it indicates that the volume has never been mounted.  It is up to the file</span>
04296 <span class="comment">    system that eventually mounts the volume to determine whether the volume is,</span>
04297 <span class="comment">    or has been, mounted elsewhere.</span>
04298 <span class="comment"></span>
04299 <span class="comment">Arguments:</span>
04300 <span class="comment"></span>
04301 <span class="comment">    DeviceObject - Pointer to device object on which the volume is to be</span>
04302 <span class="comment">        mounted.</span>
04303 <span class="comment"></span>
04304 <span class="comment">    AllowRawMount - This parameter tells us if we should continue our</span>
04305 <span class="comment">        filesystem search to include the Raw file system.  This flag will</span>
04306 <span class="comment">        only be passed in as TRUE as a result of a DASD open.</span>
04307 <span class="comment"></span>
04308 <span class="comment">    DeviceLockAlreadyHeld - If TRUE, then the caller has already acquired</span>
04309 <span class="comment">        the device lock and we should not attempt to acquire it.  This is</span>
04310 <span class="comment">        currently passed in as TRUE when called from IoVerifyVolume.</span>
04311 <span class="comment"></span>
04312 <span class="comment">Return Value:</span>
04313 <span class="comment"></span>
04314 <span class="comment">    The function value is a successful status code if a volume was successfully</span>
04315 <span class="comment">    mounted on the device.  Otherwise, an error code is returned.</span>
04316 <span class="comment"></span>
04317 <span class="comment"></span>
04318 <span class="comment">--*/</span>
04319 
04320 {
04321     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
04322     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> event;
04323     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
04324     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> fsDeviceObject;
04325     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> attachedDevice;
04326     PLIST_ENTRY entry;
04327     PLIST_ENTRY queueHeader;
04328     IO_STATUS_BLOCK ioStatus;
04329     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
04330     ULONG extraStack;
04331     LIST_ENTRY <a class="code" href="../../d0/d2/config_2test_2init386_8c.html#a0">dummy</a>;
04332     ULONG rawMountOnly;
04333 
04334     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
04335 
04336     <span class="comment">//</span>
04337     <span class="comment">// Obtain the lock for the device to be mounted.  This guarantees that</span>
04338     <span class="comment">// only one thread is attempting to mount (or verify) this particular</span>
04339     <span class="comment">// device at a time.</span>
04340     <span class="comment">//</span>
04341 
04342     <span class="keywordflow">if</span> (!DeviceLockAlreadyHeld) {
04343 
04344         status = <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;DeviceObject-&gt;DeviceLock,
04345                                         <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
04346                                         KeGetPreviousMode(),
04347                                         Alertable,
04348                                         (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
04349 
04350         <span class="comment">//</span>
04351         <span class="comment">// If the wait ended because of an alert or an APC, return now</span>
04352         <span class="comment">// without mounting the device.  Note that as the wait for the</span>
04353         <span class="comment">// event was unsuccessful, we do not set it on exit.</span>
04354         <span class="comment">//</span>
04355 
04356         <span class="keywordflow">if</span> (status == STATUS_ALERTED || status == STATUS_USER_APC) {
04357 
04358             <span class="keywordflow">return</span> status;
04359         }
04360     }
04361 
04362     <span class="comment">//</span>
04363     <span class="comment">// Now acquire the resource database lock for the I/O system to perform this</span>
04364     <span class="comment">// operation.  This resource protects access to the file system queue.</span>
04365     <span class="comment">//</span>
04366 
04367     <span class="comment">//KeEnterCriticalRegion();</span>
04368     (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d5/d8/ex_8h.html#a69">ExAcquireResourceShared</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a4">IopDatabaseResource</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
04369 
04370     <span class="comment">//</span>
04371     <span class="comment">// Check the 'mounted' flag of the VPB to ensure that it is still clear.</span>
04372     <span class="comment">// If it is, then no one has gotten in before this to mount the volume.</span>
04373     <span class="comment">// Attempt to mount the volume in this case.</span>
04374     <span class="comment">//</span>
04375 
04376     <span class="keywordflow">if</span> ((DeviceObject-&gt;Vpb-&gt;Flags &amp; (<a class="code" href="../../d0/d5/io_8h.html#a116">VPB_MOUNTED</a> | <a class="code" href="../../d0/d5/io_8h.html#a119">VPB_REMOVE_PENDING</a>)) == 0) {
04377 
04378         <span class="comment">//</span>
04379         <span class="comment">// This volume has never been mounted.  Initialize the event and set the</span>
04380         <span class="comment">// status to unsuccessful to set up for the loop.  Also if the device</span>
04381         <span class="comment">// has the verify bit set, clear it.</span>
04382         <span class="comment">//</span>
04383 
04384         <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;event, NotificationEvent, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
04385         status = STATUS_UNSUCCESSFUL;
04386         DeviceObject-&gt;Flags &amp;= ~<a class="code" href="../../d0/d5/io_8h.html#a122">DO_VERIFY_VOLUME</a>;
04387 
04388         <span class="comment">//</span>
04389         <span class="comment">// Get the actual device that this volume is to be mounted on.  This</span>
04390         <span class="comment">// device is the final device in the list of devices which are attached</span>
04391         <span class="comment">// to the specified real device.</span>
04392         <span class="comment">//</span>
04393 
04394         attachedDevice = DeviceObject;
04395         <span class="keywordflow">while</span> (attachedDevice-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o5">AttachedDevice</a>) {
04396             attachedDevice = attachedDevice-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o5">AttachedDevice</a>;
04397         }
04398 
04399         <span class="comment">//</span>
04400         <span class="comment">// Reference the device object so it cannot go away.</span>
04401         <span class="comment">//</span>
04402 
04403         <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a>( attachedDevice );
04404 
04405         <span class="comment">//</span>
04406         <span class="comment">// Determine which type of file system should be invoked based on</span>
04407         <span class="comment">// the device type of the device being mounted.</span>
04408         <span class="comment">//</span>
04409 
04410         <span class="keywordflow">if</span> (DeviceObject-&gt;DeviceType == FILE_DEVICE_DISK ||
04411             DeviceObject-&gt;DeviceType == FILE_DEVICE_VIRTUAL_DISK) {
04412             queueHeader = &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a6">IopDiskFileSystemQueueHead</a>;
04413         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (DeviceObject-&gt;DeviceType == FILE_DEVICE_CD_ROM) {
04414             queueHeader = &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a7">IopCdRomFileSystemQueueHead</a>;
04415         } <span class="keywordflow">else</span> {
04416             queueHeader = &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a9">IopTapeFileSystemQueueHead</a>;
04417         }
04418 
04419         rawMountOnly = (DeviceObject-&gt;Vpb-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a120">VPB_RAW_MOUNT</a>);
04420 
04421         <span class="comment">//</span>
04422         <span class="comment">// Now loop through each of the file systems which have been loaded in</span>
04423         <span class="comment">// the system to see whether anyone understands the media in the device.</span>
04424         <span class="comment">//</span>
04425 
04426         <span class="keywordflow">for</span> (entry = queueHeader-&gt;Flink;
04427              entry != queueHeader &amp;&amp; !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status );
04428              entry = entry-&gt;Flink) {
04429 
04430             <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> savedFsDeviceObject;
04431 
04432             <span class="comment">//</span>
04433             <span class="comment">// If this is the final entry (Raw file system), and it is also</span>
04434             <span class="comment">// not the first entry, and a raw mount is not permitted, then</span>
04435             <span class="comment">// break out of the loop at this point, as this volume cannot</span>
04436             <span class="comment">// be mounted for the caller's purposes.</span>
04437             <span class="comment">//</span>
04438 
04439             <span class="keywordflow">if</span> (!AllowRawMount &amp;&amp; entry-&gt;Flink == queueHeader &amp;&amp; entry != queueHeader-&gt;Flink) {
04440                 <span class="keywordflow">break</span>;
04441             }
04442 
04443             <span class="comment">//</span>
04444             <span class="comment">// If raw mount is the only one requested and this is not the last entry on the list</span>
04445             <span class="comment">// then skip.</span>
04446             <span class="comment">//</span>
04447             <span class="keywordflow">if</span> (rawMountOnly &amp;&amp; (entry-&gt;Flink != queueHeader)) {
04448                 <span class="keywordflow">continue</span>;
04449             }
04450 
04451             fsDeviceObject = CONTAINING_RECORD( entry, <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">DEVICE_OBJECT</a>, Queue.ListEntry );
04452             savedFsDeviceObject = fsDeviceObject;
04453 
04454             <span class="comment">//</span>
04455             <span class="comment">// It is possible that the file system has been attached to, so</span>
04456             <span class="comment">// walk the attached list for the file system.  The number of stack</span>
04457             <span class="comment">// locations that must be allocated in the IRP must include one for</span>
04458             <span class="comment">// the file system itself, and then one for each driver that is</span>
04459             <span class="comment">// attached to it.  Account for all of the stack locations required</span>
04460             <span class="comment">// to get through the mount process.</span>
04461             <span class="comment">//</span>
04462 
04463             extraStack = 1;
04464 
04465             <span class="keywordflow">while</span> (fsDeviceObject-&gt;AttachedDevice) {
04466                 fsDeviceObject = fsDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o5">AttachedDevice</a>;
04467                 extraStack++;
04468             }
04469 
04470             <span class="comment">//</span>
04471             <span class="comment">// Another file system has been found and the volume has still not</span>
04472             <span class="comment">// been mounted.  Attempt to mount the volume using this file</span>
04473             <span class="comment">// system.</span>
04474             <span class="comment">//</span>
04475             <span class="comment">// Begin by resetting the event being used for synchronization with</span>
04476             <span class="comment">// the I/O operation.</span>
04477             <span class="comment">//</span>
04478 
04479             <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a>( &amp;event );
04480 
04481             <span class="comment">//</span>
04482             <span class="comment">// Allocate and initialize an IRP for this mount operation.  Notice</span>
04483             <span class="comment">// that the flags for this operation appear the same as a page read</span>
04484             <span class="comment">// operation.  This is because the completion code for both of the</span>
04485             <span class="comment">// operations is exactly the same logic.</span>
04486             <span class="comment">//</span>
04487 
04488             irp = <a class="code" href="../../d0/d6/iop_8h.html#a149">IopAllocateIrpMustSucceed</a>( (CCHAR) (attachedDevice-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o13">StackSize</a> + extraStack) );
04489             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a175">IRP_MOUNT_COMPLETION</a> | <a class="code" href="../../d0/d5/io_8h.html#a181">IRP_SYNCHRONOUS_PAGING_IO</a>;
04490             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o10">RequestorMode</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>;
04491             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = &amp;event;
04492             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = &amp;ioStatus;
04493             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
04494             irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
04495             irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a26">IRP_MJ_FILE_SYSTEM_CONTROL</a>;
04496             irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o1">MinorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a47">IRP_MN_MOUNT_VOLUME</a>;
04497             irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o2">Flags</a> = AllowRawMount;
04498             irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.MountVolume.Vpb = DeviceObject-&gt;Vpb;
04499             irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.MountVolume.DeviceObject = attachedDevice;
04500 
04501             status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( fsDeviceObject, irp );
04502 
04503             <span class="comment">//</span>
04504             <span class="comment">// Wait for the I/O operation to complete.</span>
04505             <span class="comment">//</span>
04506 
04507             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
04508                 (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
04509                                               <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
04510                                               <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
04511                                               <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
04512                                               (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
04513             } <span class="keywordflow">else</span> {
04514 
04515                 <span class="comment">//</span>
04516                 <span class="comment">// Ensure that the proper status value gets picked up.</span>
04517                 <span class="comment">//</span>
04518 
04519                 ioStatus.Status = status;
04520                 ioStatus.Information = 0;
04521             }
04522 
04523             <span class="comment">//</span>
04524             <span class="comment">// If the operation was successful then set the VPB as mounted.</span>
04525             <span class="comment">//</span>
04526 
04527             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( ioStatus.Status )) {
04528                 status = ioStatus.Status;
04529                 DeviceObject-&gt;Vpb-&gt;Flags = <a class="code" href="../../d0/d5/io_8h.html#a116">VPB_MOUNTED</a>;
04530 
04531                 <span class="comment">//</span>
04532                 <span class="comment">// We explicitly propagate VPB_RAW_MOUNT as the previous</span>
04533                 <span class="comment">// statement that has been there for a long time in NT</span>
04534                 <span class="comment">// could be clearing other flags which should be cleared.</span>
04535                 <span class="comment">//</span>
04536                 <span class="keywordflow">if</span> (rawMountOnly) { 
04537                     DeviceObject-&gt;Vpb-&gt;Flags |= <a class="code" href="../../d0/d5/io_8h.html#a120">VPB_RAW_MOUNT</a>;
04538                 }
04539                 DeviceObject-&gt;Vpb-&gt;DeviceObject-&gt;StackSize = (UCHAR) (attachedDevice-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o13">StackSize</a> + 1);
04540 
04541             } <span class="keywordflow">else</span> {
04542 
04543                 <span class="comment">//</span>
04544                 <span class="comment">// The mount operation failed.  Make a special check here to</span>
04545                 <span class="comment">// determine whether or not a popup was enabled, and if so,</span>
04546                 <span class="comment">// check to see whether or not the operation was to be aborted.</span>
04547                 <span class="comment">// If so, bail out now and return the error to the caller.</span>
04548                 <span class="comment">//</span>
04549 
04550                 status = ioStatus.Status;
04551                 <span class="keywordflow">if</span> (<a class="code" href="../../d0/d5/io_8h.html#a232">IoIsErrorUserInduced</a>(status) &amp;&amp;
04552                     ioStatus.Information == <a class="code" href="../../d0/d6/iop_8h.html#a0">IOP_ABORT</a>) {
04553                     <span class="keywordflow">break</span>;
04554                 }
04555 
04556                 <span class="comment">//</span>
04557                 <span class="comment">// Also check to see whether or not this is a volume that has</span>
04558                 <span class="comment">// been recognized, but the file system for it needs to be</span>
04559                 <span class="comment">// loaded.  If so, drop the locks held at this point, tell the</span>
04560                 <span class="comment">// mini-file system recognizer to load the driver, and then</span>
04561                 <span class="comment">// reacquire the locks.</span>
04562                 <span class="comment">//</span>
04563 
04564                 <span class="keywordflow">if</span> (status == STATUS_FS_DRIVER_REQUIRED) {
04565 
04566                     <span class="comment">//</span>
04567                     <span class="comment">// Increment the number of reasons that this driver cannot</span>
04568                     <span class="comment">// be unloaded.  Note that this must be done while still</span>
04569                     <span class="comment">// holding the database resource.</span>
04570                     <span class="comment">//</span>
04571 
04572                     <a class="code" href="../../d5/d8/ex_8h.html#a235">ExInterlockedAddUlong</a>( &amp;savedFsDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o2">ReferenceCount</a>,
04573                                            1,
04574                                            &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a> );
04575 
04576                     <span class="comment">//</span>
04577                     <span class="comment">// Release the locks, load the new file system, and unload</span>
04578                     <span class="comment">// the recognizer.</span>
04579                     <span class="comment">//</span>
04580 
04581                     <a class="code" href="../../d5/d8/ex_8h.html#a66">ExReleaseResource</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a4">IopDatabaseResource</a> );
04582                     <span class="comment">//KeLeaveCriticalRegion();</span>
04583                     <span class="keywordflow">if</span> (!DeviceLockAlreadyHeld) {
04584                         <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>( &amp;DeviceObject-&gt;DeviceLock, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
04585                     }
04586                     <a class="code" href="../../d0/d6/iop_8h.html#a192">IopLoadFileSystemDriver</a>( savedFsDeviceObject );
04587 
04588                     <span class="comment">//</span>
04589                     <span class="comment">// Now reacquire the locks, in the correct order, and check</span>
04590                     <span class="comment">// to see if the volume has been mounted before we could</span>
04591                     <span class="comment">// get back.  If so, exit; otherwise, restart the file</span>
04592                     <span class="comment">// file system queue scan from the beginning.</span>
04593                     <span class="comment">//</span>
04594 
04595                     <span class="keywordflow">if</span> (!DeviceLockAlreadyHeld) {
04596                         status = <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;DeviceObject-&gt;DeviceLock,
04597                                                         <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
04598                                                         KeGetPreviousMode(),
04599                                                         Alertable,
04600                                                         (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
04601                         <span class="keywordflow">if</span> (status == STATUS_ALERTED || status == STATUS_USER_APC) {
04602 
04603                             <span class="comment">//</span>
04604                             <span class="comment">// The device was not mounted by us so</span>
04605                             <span class="comment">// drop the reference before returning.</span>
04606                             <span class="comment">//</span>
04607 
04608                             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( attachedDevice );
04609 
04610                             <span class="keywordflow">return</span> status;
04611                         }
04612                     }
04613 
04614                     <span class="comment">//KeEnterCriticalRegion();</span>
04615                     (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d5/d8/ex_8h.html#a69">ExAcquireResourceShared</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a4">IopDatabaseResource</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
04616 
04617                     <span class="keywordflow">if</span> (DeviceObject-&gt;Vpb-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a116">VPB_MOUNTED</a>) {
04618 
04619                         <span class="comment">//</span>
04620                         <span class="comment">//  This volume was mounted before we got back.</span>
04621                         <span class="comment">//</span>
04622 
04623                         status = STATUS_SUCCESS;
04624                         <span class="keywordflow">break</span>;
04625                     }
04626 
04627                     <span class="comment">//</span>
04628                     <span class="comment">// Reset the list back to the beginning and start over</span>
04629                     <span class="comment">// again.</span>
04630                     <span class="comment">//</span>
04631 
04632                     <a class="code" href="../../d0/d2/config_2test_2init386_8c.html#a0">dummy</a>.Flink = queueHeader-&gt;Flink;
04633                     entry = &amp;<a class="code" href="../../d0/d2/config_2test_2init386_8c.html#a0">dummy</a>;
04634                     status = STATUS_UNRECOGNIZED_VOLUME;
04635                 }
04636 
04637                 <span class="comment">//</span>
04638                 <span class="comment">// If the error wasn't STATUS_UNRECOGNIZED_VOLUME, and this</span>
04639                 <span class="comment">// request is not going to the Raw file system, then there</span>
04640                 <span class="comment">// is no reason to continue looping.</span>
04641                 <span class="comment">//</span>
04642 
04643                 <span class="keywordflow">if</span> (!AllowRawMount &amp;&amp; (status != STATUS_UNRECOGNIZED_VOLUME) &amp;&amp;
04644                     <a class="code" href="../../d1/d8/fsrtl_8h.html#a111">FsRtlIsTotalDeviceFailure</a>(status)) {
04645                     <span class="keywordflow">break</span>;
04646                 }
04647             }
04648         }
04649 
04650         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
04651 
04652             <span class="comment">//</span>
04653             <span class="comment">// The device was not mounted by us so</span>
04654             <span class="comment">// drop the reference.</span>
04655             <span class="comment">//</span>
04656 
04657             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( attachedDevice );
04658 
04659         }
04660 
04661     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>((DeviceObject-&gt;Vpb-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a119">VPB_REMOVE_PENDING</a>) != 0) {
04662 
04663         <span class="comment">//</span>
04664         <span class="comment">// Pnp is attempting to remove this volume.  Don't allow the mount.</span>
04665         <span class="comment">//</span>
04666 
04667         status = STATUS_DEVICE_DOES_NOT_EXIST;
04668 
04669     } <span class="keywordflow">else</span> {
04670 
04671         <span class="comment">//</span>
04672         <span class="comment">// The volume for this device has already been mounted.  Return a</span>
04673         <span class="comment">// success code.</span>
04674         <span class="comment">//</span>
04675 
04676         status = STATUS_SUCCESS;
04677     }
04678 
04679     <a class="code" href="../../d5/d8/ex_8h.html#a66">ExReleaseResource</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a4">IopDatabaseResource</a> );
04680     <span class="comment">//KeLeaveCriticalRegion();</span>
04681 
04682     <span class="comment">//</span>
04683     <span class="comment">// Release the I/O database resource lock and the synchronization event for</span>
04684     <span class="comment">// the device.</span>
04685     <span class="comment">//</span>
04686 
04687     <span class="keywordflow">if</span> (!DeviceLockAlreadyHeld) {
04688         <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>( &amp;DeviceObject-&gt;DeviceLock, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
04689     }
04690 
04691     <span class="comment">//</span>
04692     <span class="comment">// Finally, if the mount operation failed, and the target device is the</span>
04693     <span class="comment">// boot partition, then bugcheck the system.  It is not possible for the</span>
04694     <span class="comment">// system to run properly if the system's boot partition cannot be mounted.</span>
04695     <span class="comment">//</span>
04696     <span class="comment">// Note: Don't bugcheck if the system is already booted.</span>
04697     <span class="comment">//</span>
04698 
04699     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status ) &amp;&amp;
04700         DeviceObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a129">DO_SYSTEM_BOOT_PARTITION</a> &amp;&amp;
04701         <a class="code" href="../../d8/d1/init_8h.html#a21">InitializationPhase</a> &lt; 2) {
04702         <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a>( INACCESSIBLE_BOOT_DEVICE, (ULONG_PTR) DeviceObject, status, 0, 0 );
04703     }
04704 
04705     <span class="keywordflow">return</span> status;
04706 }
04707 
04708 
04709 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l04710"></a><a class="code" href="../../d0/d6/iop_8h.html#a189">04710</a> <a class="code" href="../../d0/d6/iop_8h.html#a189">IopInvalidateVolumesForDevice</a>(
04711     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject
04712     )
04713 
04714 <span class="comment">/*++</span>
04715 <span class="comment"></span>
04716 <span class="comment">Routine Description:</span>
04717 <span class="comment"></span>
04718 <span class="comment">    This routine is used to force filesystems to, as completely as possible, throw</span>
04719 <span class="comment">    out volumes which remain referenced for a given device.</span>
04720 <span class="comment">    </span>
04721 <span class="comment">Arguments:</span>
04722 <span class="comment"></span>
04723 <span class="comment">    DeviceObject - Pointer to device object for which volumes are to be</span>
04724 <span class="comment">        invalidated.</span>
04725 <span class="comment"></span>
04726 <span class="comment">Return Value:</span>
04727 <span class="comment"></span>
04728 <span class="comment">    The function value is a successful status code if all filesystems accepted the</span>
04729 <span class="comment">    operation.  Otherwise, an error code is returned.</span>
04730 <span class="comment"></span>
04731 <span class="comment">--*/</span>
04732 
04733 {
04734     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
04735     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> finalStatus;
04736     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> event;
04737     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
04738     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> fsDeviceObject;
04739     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> attachedDevice;
04740     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> storageFileObject;
04741     HANDLE storageHandle;
04742     PLIST_ENTRY entry;
04743     PLIST_ENTRY queueHeader;
04744     IO_STATUS_BLOCK ioStatus;
04745     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
04746 
04747     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
04748 
04749     <span class="comment">//</span>
04750     <span class="comment">// Now acquire the resource database lock for the I/O system to perform this</span>
04751     <span class="comment">// operation.  This resource protects access to the file system queue.</span>
04752     <span class="comment">//</span>
04753     
04754     <a class="code" href="../../d4/d9/ke_8h.html#a28">KeEnterCriticalRegion</a>();
04755     (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d5/d8/ex_8h.html#a69">ExAcquireResourceShared</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a4">IopDatabaseResource</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
04756 
04757     <span class="comment">//</span>
04758     <span class="comment">// Get the actual device that would be mounted on.  This device is the final</span>
04759     <span class="comment">// device in the list of devices which are attached to the specified real device.</span>
04760     <span class="comment">//</span>
04761 
04762     attachedDevice = DeviceObject;
04763     <span class="keywordflow">while</span> (attachedDevice-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o5">AttachedDevice</a>) {
04764         attachedDevice = attachedDevice-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o5">AttachedDevice</a>;
04765     }
04766 
04767     <span class="comment">//</span>
04768     <span class="comment">// Get a handle to this device for use in the fsctl.  The way we have to do</span>
04769     <span class="comment">// this is kind of loopy: note we wind up with two references to clean up.</span>
04770     <span class="comment">//</span>
04771     <span class="comment">// The only use of this fileobject/handle is to communicate the device to</span>
04772     <span class="comment">// invalidate volumes on.  It isn't used for anything else, and must not be.</span>
04773     <span class="comment">//</span>
04774 
04775     <span class="keywordflow">try</span> {
04776 
04777         storageFileObject = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04778         storageFileObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a49">IoCreateStreamFileObjectLite</a>( <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, attachedDevice );
04779         storageFileObject-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o3">Vpb</a> = attachedDevice-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o10">Vpb</a>;
04780         
04781         storageHandle = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04782         status = <a class="code" href="../../d7/d1/obref_8c.html#a3">ObOpenObjectByPointer</a>( storageFileObject,
04783                                         OBJ_KERNEL_HANDLE,
04784                                         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
04785                                         0,
04786                                         <a class="code" href="../../d5/d8/fssup_8c.html#a3">IoFileObjectType</a>,
04787                                         <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
04788                                         &amp;storageHandle );
04789 
04790     } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
04791           
04792         status = GetExceptionCode();
04793     }
04794     
04795     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
04796         
04797         <span class="comment">//</span>
04798         <span class="comment">// Determine which type of file system should be invoked based on</span>
04799         <span class="comment">// the device type of the device being invalidated.</span>
04800         <span class="comment">//</span>
04801 
04802         <span class="keywordflow">if</span> (DeviceObject-&gt;DeviceType == FILE_DEVICE_DISK ||
04803             DeviceObject-&gt;DeviceType == FILE_DEVICE_VIRTUAL_DISK) {
04804             queueHeader = &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a6">IopDiskFileSystemQueueHead</a>;
04805         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (DeviceObject-&gt;DeviceType == FILE_DEVICE_CD_ROM) {
04806             queueHeader = &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a7">IopCdRomFileSystemQueueHead</a>;
04807         } <span class="keywordflow">else</span> {
04808             queueHeader = &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a9">IopTapeFileSystemQueueHead</a>;
04809         }
04810 
04811         <span class="comment">//</span>
04812         <span class="comment">// Initialize the event and set the status to set up</span>
04813         <span class="comment">// for the loop.</span>
04814         <span class="comment">//</span>
04815 
04816         <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;event, NotificationEvent, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
04817         finalStatus = STATUS_SUCCESS;
04818 
04819         <span class="comment">//</span>
04820         <span class="comment">// Now loop through each of the file systems which have been loaded in</span>
04821         <span class="comment">// the system and ask them to invalidate volumes they have had mounted</span>
04822         <span class="comment">// on it.</span>
04823         <span class="comment">//</span>
04824 
04825         <span class="keywordflow">for</span> (entry = queueHeader-&gt;Flink;
04826              entry != queueHeader;
04827              entry = entry-&gt;Flink) {
04828 
04829             <span class="comment">//</span>
04830             <span class="comment">// If this is the final entry (Raw file system), then break out of the</span>
04831             <span class="comment">// loop at this point, as volumes cannot be invalidated for the caller's</span>
04832             <span class="comment">// purposes in Raw.</span>
04833             <span class="comment">//</span>
04834 
04835             <span class="keywordflow">if</span> (entry-&gt;Flink == queueHeader) {
04836                 <span class="keywordflow">break</span>;
04837             }
04838 
04839             fsDeviceObject = CONTAINING_RECORD( entry, <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">DEVICE_OBJECT</a>, Queue.ListEntry );
04840 
04841             <span class="comment">//</span>
04842             <span class="comment">// It is possible that the file system has been attached to, so</span>
04843             <span class="comment">// walk the attached list for the file system.</span>
04844             <span class="comment">//</span>
04845 
04846             <span class="keywordflow">while</span> (fsDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o5">AttachedDevice</a>) {
04847                 fsDeviceObject = fsDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o5">AttachedDevice</a>;
04848             }
04849 
04850             <span class="comment">//</span>
04851             <span class="comment">// Another file system has been found.  Attempt to invalidate volumes</span>
04852             <span class="comment">// using this file system.</span>
04853             <span class="comment">//</span>
04854             <span class="comment">// Begin by resetting the event being used for synchronization with</span>
04855             <span class="comment">// the I/O operation.</span>
04856             <span class="comment">//</span>
04857 
04858             <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a>( &amp;event );
04859 
04860             <span class="comment">//</span>
04861             <span class="comment">// Build an IRP for this operation.</span>
04862             <span class="comment">//</span>
04863 
04864             irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a25">IoBuildDeviceIoControlRequest</a>( FSCTL_INVALIDATE_VOLUMES,
04865                                                  fsDeviceObject,
04866                                                  &amp;storageHandle,
04867                                                  <span class="keyword">sizeof</span>(HANDLE),
04868                                                  <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
04869                                                  0,
04870                                                  <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
04871                                                  &amp;event,
04872                                                  &amp;ioStatus );
04873 
04874             <span class="keywordflow">if</span> (irp == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04875 
04876                 finalStatus = STATUS_INSUFFICIENT_RESOURCES;
04877                 <span class="keywordflow">break</span>;
04878             }
04879 
04880             irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
04881             irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a26">IRP_MJ_FILE_SYSTEM_CONTROL</a>;
04882 
04883             status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( fsDeviceObject, irp );
04884 
04885             <span class="comment">//</span>
04886             <span class="comment">// Wait for the I/O operation to complete.</span>
04887             <span class="comment">//</span>
04888 
04889             <span class="keywordflow">if</span> (status == STATUS_PENDING) {
04890                 (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
04891                                               <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
04892                                               <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
04893                                               <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
04894                                               (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
04895 
04896                 status = ioStatus.Status;
04897 
04898             } <span class="keywordflow">else</span> {
04899                 
04900                 <span class="comment">//</span>
04901                 <span class="comment">// Ensure that the proper status value gets picked up.</span>
04902                 <span class="comment">//</span>
04903 
04904                 ioStatus.Status = status;
04905                 ioStatus.Information = 0;
04906             }
04907 
04908             <span class="comment">//</span>
04909             <span class="comment">// Commute status' indicating the operation is not implemented</span>
04910             <span class="comment">// to success.  If a filesystem does not implement, it must not</span>
04911             <span class="comment">// hold volumes that are not mounted.</span>
04912             <span class="comment">//</span>
04913 
04914             <span class="keywordflow">if</span> (status == STATUS_INVALID_DEVICE_REQUEST ||
04915                 status == STATUS_NOT_IMPLEMENTED) {
04916                 
04917                 status = STATUS_SUCCESS;
04918             }
04919 
04920             <span class="comment">//</span>
04921             <span class="comment">//  Hand back the first failure we get, but plow on anyway.</span>
04922             <span class="comment">//</span>
04923             
04924             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( finalStatus ) &amp;&amp; !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
04925                 finalStatus = status;
04926             }
04927         }
04928 
04929         <span class="keywordflow">if</span> (storageFileObject) {
04930             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( storageFileObject );
04931             <span class="keywordflow">if</span> (storageHandle) {
04932                 ZwClose( storageHandle );
04933             }
04934         }
04935 
04936         status = finalStatus;
04937     }
04938 
04939     <a class="code" href="../../d5/d8/ex_8h.html#a66">ExReleaseResource</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a4">IopDatabaseResource</a> );
04940     <a class="code" href="../../d4/d9/ke_8h.html#a29">KeLeaveCriticalRegion</a>();
04941 
04942     <span class="keywordflow">return</span> status;
04943 }
04944 
04945 
04946 BOOLEAN
<a name="l04947"></a><a class="code" href="../../d0/d6/iop_8h.html#a196">04947</a> <a class="code" href="../../d0/d6/iop_8h.html#a196">IopNotifyPnpWhenChainDereferenced</a>(
04948     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> *PhysicalDeviceObjects,
04949     IN ULONG DeviceObjectCount,
04950     IN BOOLEAN Query,
04951     OUT <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> *VetoingDevice
04952     )
04953 
04954 <span class="comment">/*++</span>
04955 <span class="comment"></span>
04956 <span class="comment">Routine Description:</span>
04957 <span class="comment"></span>
04958 <span class="comment">    Called by PnP when processing a Surprise Removal or a Query Remove.</span>
04959 <span class="comment"></span>
04960 <span class="comment">    In the case of Surprise Removal this function will set DOE_REMOVE_PENDING</span>
04961 <span class="comment">    in the device extension flags of the each PDO and all its attached devices.</span>
04962 <span class="comment">    For each PDO (and its attachment chain) which currently has a zero</span>
04963 <span class="comment">    ReferenceCount DOE_REMOVE_PENDING is reset and DOE_REMOVE_PROCESSED is</span>
04964 <span class="comment">    set.  IopChainDereferenceComplete is then called to notify PnP that</span>
04965 <span class="comment">    this PDO is ready for removal.</span>
04966 <span class="comment"></span>
04967 <span class="comment">    Then as each remaining PDO and its attachment chain's ReferenceCount drops</span>
04968 <span class="comment">    to zero IopCheckUnloadOrDelete will call IopChainDereferenceComplete</span>
04969 <span class="comment">    (supplied by PnP).</span>
04970 <span class="comment"></span>
04971 <span class="comment">    In the case of Query Remove this function set DOE_REMOVE_PROCESSED on the</span>
04972 <span class="comment">    PDO and all its attached devices to prevent further opens.  It also checks</span>
04973 <span class="comment">    to see if the ReferenceCount for all the PDOs and their attached devices is</span>
04974 <span class="comment">    zero.  If so it leaves the DOE_REMOVE_PROCESSED set and returns FALSE.  If</span>
04975 <span class="comment">    not, it resets the DOE_REMOVE_PROCESSED on all the PDOs and their attached</span>
04976 <span class="comment">    devices and returns TRUE.</span>
04977 <span class="comment"></span>
04978 <span class="comment">Arguments:</span>
04979 <span class="comment"></span>
04980 <span class="comment">    PhysicalDeviceObjects   List of PDEVICE_OBJECTs for all of the PDOs to be</span>
04981 <span class="comment">                            checked.</span>
04982 <span class="comment"></span>
04983 <span class="comment">    DeviceObjectCount       Count of PDEVICE_OBJECTs in PhysicalDeviceObjects.</span>
04984 <span class="comment"></span>
04985 <span class="comment">    Query                   TRUE if this is for a Query Remove.</span>
04986 <span class="comment"></span>
04987 <span class="comment">    VetoingDevice           Only used for Query Remove, Set to first PDO with a</span>
04988 <span class="comment">                            ReferenceCount not equal to zero.  This is used to</span>
04989 <span class="comment">                            provide feedback to the user as to why the query</span>
04990 <span class="comment">                            may have failed.</span>
04991 <span class="comment"></span>
04992 <span class="comment"></span>
04993 <span class="comment">Return Value:</span>
04994 <span class="comment"></span>
04995 <span class="comment">    If Query is set then the return value is TRUE if there are outstanding</span>
04996 <span class="comment">    opens on any of the PDOs or the attached devices, otherwise FALSE is</span>
04997 <span class="comment">    returned.</span>
04998 <span class="comment"></span>
04999 <span class="comment">    If Query is NOT set then the return value is always TRUE.</span>
05000 <span class="comment"></span>
05001 <span class="comment">--*/</span>
05002 
05003 {
05004     <a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html">PDEVOBJ_EXTENSION</a> deviceExtension;
05005     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
05006     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> attachedDeviceObject;
05007     <a class="code" href="../../d4/d4/struct__DEVICE__NODE.html">PDEVICE_NODE</a> deviceNode;
05008     ULONG referenced;
05009     ULONG pass1SetFlag;
05010     ULONG pass1ClearFlag;
05011     LONG i;
05012     KIRQL irql;
05013 
05014     ExAcquireSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, &amp;irql );
05015 
05016     <span class="keywordflow">if</span> (Query) {
05017         pass1SetFlag = <a class="code" href="../../d0/d5/io_8h.html#a141">DOE_REMOVE_PROCESSED</a>;
05018         pass1ClearFlag = 0;
05019     } <span class="keywordflow">else</span> {
05020         pass1SetFlag = <a class="code" href="../../d0/d5/io_8h.html#a140">DOE_REMOVE_PENDING</a>;
05021         pass1ClearFlag = <a class="code" href="../../d0/d5/io_8h.html#a141">DOE_REMOVE_PROCESSED</a>;
05022     }
05023 
05024     <span class="keywordflow">for</span> (i = 0; i &lt; (LONG)DeviceObjectCount; i++) {
05025         deviceObject = PhysicalDeviceObjects[i];
05026         deviceExtension = deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o25">DeviceObjectExtension</a>;
05027 
05028         deviceNode = (<a class="code" href="../../d4/d4/struct__DEVICE__NODE.html">PDEVICE_NODE</a>)deviceExtension-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o6">DeviceNode</a>;
05029 
05030         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( deviceNode != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
05031 
05032         <span class="comment">//</span>
05033         <span class="comment">// Assume that at least one device object has a reference.  Walk the</span>
05034         <span class="comment">// entire chain marking them with DOE_REMOVE_PENDING.</span>
05035         <span class="comment">//</span>
05036 
05037         <span class="comment">//</span>
05038         <span class="comment">// We don't actually care how many aggregate references there actually</span>
05039         <span class="comment">// are.  All we're interested in is whether there are any.  So we'll OR</span>
05040         <span class="comment">// them together rather than adding them.  That way we don't have to do</span>
05041         <span class="comment">// testing or branching and we don't have to worry about overflow in the</span>
05042         <span class="comment">// highly unlikely event that there are a total of more references than</span>
05043         <span class="comment">// will fit in a ULONG.</span>
05044         <span class="comment">//</span>
05045 
05046         referenced = 0;
05047         attachedDeviceObject = deviceObject;
05048         <span class="keywordflow">do</span> {
05049             deviceExtension = attachedDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o25">DeviceObjectExtension</a>;
05050 
05051             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(deviceExtension != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
05052             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(!(deviceExtension-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o5">ExtensionFlags</a> &amp; pass1SetFlag));
05053 
05054 
05055             deviceExtension-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o5">ExtensionFlags</a> &amp;= ~pass1ClearFlag;
05056             deviceExtension-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o5">ExtensionFlags</a> |= pass1SetFlag;
05057             referenced |= attachedDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o2">ReferenceCount</a>;
05058 
05059             attachedDeviceObject = attachedDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o5">AttachedDevice</a>;
05060 
05061         } <span class="keywordflow">while</span> (attachedDeviceObject != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
05062 
05063         <span class="keywordflow">if</span> (!Query &amp;&amp; referenced == 0) {
05064 
05065             <span class="comment">//</span>
05066             <span class="comment">// There aren't any outstanding references, retraverse the chain and</span>
05067             <span class="comment">// mark them all DOE_REMOVE_PROCESSED.  This will still prevent any</span>
05068             <span class="comment">// opens or attaches from occuring but we won't call</span>
05069             <span class="comment">// IopChainDereferenceComplete in IopCompleteUnloadOrDelete.</span>
05070             <span class="comment">//</span>
05071 
05072             attachedDeviceObject = deviceObject;
05073             <span class="keywordflow">do</span> {
05074                 deviceExtension = attachedDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o25">DeviceObjectExtension</a>;
05075 
05076                 deviceExtension-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o5">ExtensionFlags</a> &amp;= ~<a class="code" href="../../d0/d5/io_8h.html#a140">DOE_REMOVE_PENDING</a>;
05077                 deviceExtension-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o5">ExtensionFlags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a141">DOE_REMOVE_PROCESSED</a>;
05078 
05079                 attachedDeviceObject = attachedDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o5">AttachedDevice</a>;
05080 
05081             } <span class="keywordflow">while</span> (attachedDeviceObject != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
05082 
05083             ExReleaseSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, irql );
05084 
05085             <a class="code" href="../../d9/d0/pnpiop_8h.html#a316">IopChainDereferenceComplete</a>( deviceObject );
05086 
05087             ExAcquireSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, &amp;irql );
05088         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Query &amp;&amp; referenced != 0) {
05089             <span class="keywordflow">break</span>;
05090         }
05091     }
05092 
05093     <span class="keywordflow">if</span> (Query &amp;&amp; referenced != 0) {
05094 
05095         <span class="keywordflow">if</span> (VetoingDevice != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05096             *VetoingDevice = deviceObject;
05097         }
05098 
05099         <span class="keywordflow">for</span> (; i &gt;= 0; i--) {
05100             deviceObject = PhysicalDeviceObjects[i];
05101             deviceExtension = deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o25">DeviceObjectExtension</a>;
05102 
05103             <span class="comment">//</span>
05104             <span class="comment">// There are outstanding references, retraverse the chain and</span>
05105             <span class="comment">// unset DOE_REMOVE_PROCESSED.</span>
05106             <span class="comment">//</span>
05107 
05108             attachedDeviceObject = deviceObject;
05109             <span class="keywordflow">do</span> {
05110                 deviceExtension = attachedDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o25">DeviceObjectExtension</a>;
05111 
05112                 deviceExtension-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o5">ExtensionFlags</a> &amp;= ~<a class="code" href="../../d0/d5/io_8h.html#a141">DOE_REMOVE_PROCESSED</a>;
05113 
05114                 attachedDeviceObject = attachedDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o5">AttachedDevice</a>;
05115 
05116             } <span class="keywordflow">while</span> (attachedDeviceObject != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
05117         }
05118     }
05119 
05120     ExReleaseSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, irql );
05121 
05122     <span class="keywordflow">return</span> !Query || referenced != 0;
05123 }
05124 
05125 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l05126"></a><a class="code" href="../../d0/d6/iop_8h.html#a197">05126</a> <a class="code" href="../../d0/d6/iop_8h.html#a197">IopOpenLinkOrRenameTarget</a>(
05127     OUT PHANDLE TargetHandle,
05128     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
05129     IN PVOID RenameBuffer,
05130     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject
05131     )
05132 
05133 <span class="comment">/*++</span>
05134 <span class="comment"></span>
05135 <span class="comment">Routine Description:</span>
05136 <span class="comment"></span>
05137 <span class="comment">    This routine is invoked by the rename, set link and set copy-on-write code</span>
05138 <span class="comment">    in the I/O system's NtSetInformationFile system service when the caller has</span>
05139 <span class="comment">    specified a fully qualified file name as the target of a rename, set link,</span>
05140 <span class="comment">    or set copy-on-write operation.  This routine attempts to open the parent</span>
05141 <span class="comment">    of the specified file and checks the following:</span>
05142 <span class="comment"></span>
05143 <span class="comment">        o   If the file itself exists, then the caller must have specified that</span>
05144 <span class="comment">            the target is to be replaced, otherwise an error is returned.</span>
05145 <span class="comment"></span>
05146 <span class="comment">        o   Ensures that the target file specification refers to the same volume</span>
05147 <span class="comment">            upon which the source file exists.</span>
05148 <span class="comment"></span>
05149 <span class="comment">Arguments:</span>
05150 <span class="comment"></span>
05151 <span class="comment">    TargetHandle - Supplies the address of a variable to return the handle to</span>
05152 <span class="comment">        the opened target file if no errors have occurred.</span>
05153 <span class="comment"></span>
05154 <span class="comment">    Irp - Supplies a pointer to the IRP that represents the current rename</span>
05155 <span class="comment">        request.</span>
05156 <span class="comment"></span>
05157 <span class="comment">    RenameBuffer - Supplies a pointer to the system intermediate buffer that</span>
05158 <span class="comment">        contains the caller's rename parameters.</span>
05159 <span class="comment"></span>
05160 <span class="comment">    FileObject - Supplies a pointer to the file object representing the file</span>
05161 <span class="comment">        being renamed.</span>
05162 <span class="comment"></span>
05163 <span class="comment">Return Value:</span>
05164 <span class="comment"></span>
05165 <span class="comment">    The function value is the final status of the operation.</span>
05166 <span class="comment"></span>
05167 <span class="comment">Note:</span>
05168 <span class="comment"></span>
05169 <span class="comment">    This function assumes that the layout of a rename, set link and set</span>
05170 <span class="comment">    copy-on-write information structure are exactly the same.</span>
05171 <span class="comment"></span>
05172 <span class="comment">--*/</span>
05173 
05174 {
05175     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
05176     IO_STATUS_BLOCK ioStatus;
05177     HANDLE handle;
05178     OBJECT_ATTRIBUTES objectAttributes;
05179     UNICODE_STRING newFileName;
05180     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
05181     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> targetFileObject;
05182     <a class="code" href="../../d3/d5/struct__OBJECT__HANDLE__INFORMATION.html">OBJECT_HANDLE_INFORMATION</a> handleInformation;
05183     PFILE_RENAME_INFORMATION renameBuffer = RenameBuffer;
05184 
05185     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
05186 
05187     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <span class="keyword">sizeof</span>( FILE_RENAME_INFORMATION ) ==
05188             <span class="keyword">sizeof</span>( FILE_LINK_INFORMATION ) );
05189     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( FIELD_OFFSET( FILE_RENAME_INFORMATION, ReplaceIfExists ) ==
05190             FIELD_OFFSET( FILE_LINK_INFORMATION, ReplaceIfExists ) );
05191     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( FIELD_OFFSET( FILE_RENAME_INFORMATION, RootDirectory ) ==
05192             FIELD_OFFSET( FILE_LINK_INFORMATION, RootDirectory ) );
05193     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( FIELD_OFFSET( FILE_RENAME_INFORMATION, FileNameLength ) ==
05194             FIELD_OFFSET( FILE_LINK_INFORMATION, FileNameLength ) );
05195     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( FIELD_OFFSET( FILE_RENAME_INFORMATION, <a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a> ) ==
05196             FIELD_OFFSET( FILE_LINK_INFORMATION, <a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a> ) );
05197 
05198     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <span class="keyword">sizeof</span>( FILE_RENAME_INFORMATION ) ==
05199             <span class="keyword">sizeof</span>( FILE_MOVE_CLUSTER_INFORMATION ) );
05200     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( FIELD_OFFSET( FILE_RENAME_INFORMATION, ReplaceIfExists ) ==
05201             FIELD_OFFSET( FILE_MOVE_CLUSTER_INFORMATION, ClusterCount ) );
05202     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( FIELD_OFFSET( FILE_RENAME_INFORMATION, RootDirectory ) ==
05203             FIELD_OFFSET( FILE_MOVE_CLUSTER_INFORMATION, RootDirectory ) );
05204     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( FIELD_OFFSET( FILE_RENAME_INFORMATION, FileNameLength ) ==
05205             FIELD_OFFSET( FILE_MOVE_CLUSTER_INFORMATION, FileNameLength ) );
05206     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( FIELD_OFFSET( FILE_RENAME_INFORMATION, <a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a> ) ==
05207             FIELD_OFFSET( FILE_MOVE_CLUSTER_INFORMATION, <a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a> ) );
05208 
05209     <span class="comment">//</span>
05210     <span class="comment">// A fully qualified file name was specified.  Begin by attempting to open</span>
05211     <span class="comment">// the parent directory of the specified target file.</span>
05212     <span class="comment">//</span>
05213 
05214     newFileName.Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) renameBuffer-&gt;FileNameLength;
05215     newFileName.MaximumLength = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) renameBuffer-&gt;FileNameLength;
05216     newFileName.Buffer = renameBuffer-&gt;FileName;
05217 
05218     InitializeObjectAttributes( &amp;objectAttributes,
05219                                 &amp;newFileName,
05220                                 FileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a167">FO_OPENED_CASE_SENSITIVE</a> ? 0 : OBJ_CASE_INSENSITIVE,
05221                                 renameBuffer-&gt;RootDirectory,
05222                                 (PSECURITY_DESCRIPTOR) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
05223 
05224     status = <a class="code" href="../../d4/d6/iosubs_8c.html#a46">IoCreateFile</a>( &amp;handle,
05225                            FILE_WRITE_DATA | SYNCHRONIZE,
05226                            &amp;objectAttributes,
05227                            &amp;ioStatus,
05228                            (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
05229                            0,
05230                            FILE_SHARE_READ | FILE_SHARE_WRITE,
05231                            FILE_OPEN,
05232                            FILE_OPEN_FOR_BACKUP_INTENT,
05233                            (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
05234                            0<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>,
05235                            <a class="code" href="../../d0/d5/io_8h.html#a600a406">CreateFileTypeNone</a>,
05236                            (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
05237                            <a class="code" href="../../d0/d5/io_8h.html#a107">IO_NO_PARAMETER_CHECKING</a> |
05238                            <a class="code" href="../../d0/d5/io_8h.html#a106">IO_OPEN_TARGET_DIRECTORY</a> |
05239                            <a class="code" href="../../d0/d5/io_8h.html#a104">IO_FORCE_ACCESS_CHECK</a> );
05240     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
05241         <span class="comment">//</span>
05242         <span class="comment">// The open operation for the target file's parent directory was</span>
05243         <span class="comment">// successful.  Check to see whether or not the file exists.</span>
05244         <span class="comment">//</span>
05245 
05246         irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
05247         <span class="keywordflow">if</span> (irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.SetFile.FileInformationClass == FileLinkInformation &amp;&amp;
05248             !renameBuffer-&gt;ReplaceIfExists &amp;&amp;
05249             ioStatus.Information == FILE_EXISTS) {
05250 
05251             <span class="comment">//</span>
05252             <span class="comment">// The target file exists, and the caller does not want to replace</span>
05253             <span class="comment">// it.  This is a name collision error so cleanup and return.</span>
05254             <span class="comment">//</span>
05255 
05256             <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>( handle );
05257             status = STATUS_OBJECT_NAME_COLLISION;
05258 
05259         } <span class="keywordflow">else</span> {
05260 
05261             <span class="comment">//</span>
05262             <span class="comment">// Everything up to this point is fine, so dereference the handle</span>
05263             <span class="comment">// to a pointer to the file object and ensure that the two file</span>
05264             <span class="comment">// specifications refer to the same device.</span>
05265             <span class="comment">//</span>
05266 
05267             status = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a>( handle,
05268                                               FILE_WRITE_DATA,
05269                                               <a class="code" href="../../d5/d8/fssup_8c.html#a3">IoFileObjectType</a>,
05270                                               <a class="code" href="../../d0/d9/ntosdef_8h.html#a76a70">UserMode</a>,
05271                                               (PVOID *) &amp;targetFileObject,
05272                                               &amp;handleInformation );
05273             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
05274 
05275                 <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( targetFileObject );
05276 
05277                 <span class="keywordflow">if</span> (<a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( targetFileObject) !=
05278                     <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( FileObject )) {
05279 
05280                     <span class="comment">//</span>
05281                     <span class="comment">// The two files refer to different devices.  Clean everything</span>
05282                     <span class="comment">// up and return an appropriate error.</span>
05283                     <span class="comment">//</span>
05284 
05285                     <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>( handle );
05286                     status = STATUS_NOT_SAME_DEVICE;
05287 
05288                 } <span class="keywordflow">else</span> {
05289 
05290                     <span class="comment">//</span>
05291                     <span class="comment">// Otherwise, everything worked, so allow the rename operation</span>
05292                     <span class="comment">// to continue.</span>
05293                     <span class="comment">//</span>
05294 
05295                     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.SetFile.FileObject = targetFileObject;
05296                     *TargetHandle = handle;
05297                     status = STATUS_SUCCESS;
05298 
05299                 }
05300 
05301             } <span class="keywordflow">else</span> {
05302 
05303                 <span class="comment">//</span>
05304                 <span class="comment">// There was an error referencing the handle to what should</span>
05305                 <span class="comment">// have been the target directory.  This generally means that</span>
05306                 <span class="comment">// there was a resource problem or the handle was invalid, etc.</span>
05307                 <span class="comment">// Simply attempt to close the handle and return the error.</span>
05308                 <span class="comment">//</span>
05309 
05310                 <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>( handle );
05311 
05312             }
05313 
05314         }
05315     }
05316 
05317     <span class="comment">//</span>
05318     <span class="comment">// Return the final status of the operation.</span>
05319     <span class="comment">//</span>
05320 
05321     <span class="keywordflow">return</span> status;
05322 }
05323 
05324 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l05325"></a><a class="code" href="../../d0/d6/iop_8h.html#a198">05325</a> <a class="code" href="../../d0/d6/iop_8h.html#a198">IopOpenRegistryKey</a>(
05326     OUT PHANDLE Handle,
05327     IN HANDLE BaseHandle OPTIONAL,
05328     IN PUNICODE_STRING KeyName,
05329     IN ACCESS_MASK DesiredAccess,
05330     IN BOOLEAN Create
05331     )
05332 
05333 <span class="comment">/*++</span>
05334 <span class="comment"></span>
05335 <span class="comment">Routine Description:</span>
05336 <span class="comment"></span>
05337 <span class="comment">    Opens or creates a VOLATILE registry key using the name passed in based</span>
05338 <span class="comment">    at the BaseHandle node.</span>
05339 <span class="comment"></span>
05340 <span class="comment">Arguments:</span>
05341 <span class="comment"></span>
05342 <span class="comment">    Handle - Pointer to the handle which will contain the registry key that</span>
05343 <span class="comment">        was opened.</span>
05344 <span class="comment"></span>
05345 <span class="comment">    BaseHandle - Handle to the base path from which the key must be opened.</span>
05346 <span class="comment"></span>
05347 <span class="comment">    KeyName - Name of the Key that must be opened/created.</span>
05348 <span class="comment"></span>
05349 <span class="comment">    DesiredAccess - Specifies the desired access that the caller needs to</span>
05350 <span class="comment">        the key.</span>
05351 <span class="comment"></span>
05352 <span class="comment">    Create - Determines if the key is to be created if it does not exist.</span>
05353 <span class="comment"></span>
05354 <span class="comment">Return Value:</span>
05355 <span class="comment"></span>
05356 <span class="comment">   The function value is the final status of the operation.</span>
05357 <span class="comment"></span>
05358 <span class="comment">--*/</span>
05359 
05360 {
05361     OBJECT_ATTRIBUTES objectAttributes;
05362     ULONG disposition;
05363 
05364     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
05365 
05366     <span class="comment">//</span>
05367     <span class="comment">// Initialize the object for the key.</span>
05368     <span class="comment">//</span>
05369 
05370     InitializeObjectAttributes( &amp;objectAttributes,
05371                                 <a class="code" href="../../d8/d0/rtbatcr_8c.html#a3">KeyName</a>,
05372                                 OBJ_CASE_INSENSITIVE,
05373                                 BaseHandle,
05374                                 (PSECURITY_DESCRIPTOR) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
05375 
05376     <span class="comment">//</span>
05377     <span class="comment">// Create the key or open it, as appropriate based on the caller's</span>
05378     <span class="comment">// wishes.</span>
05379     <span class="comment">//</span>
05380 
05381     <span class="keywordflow">if</span> (<a class="code" href="../../d4/d5/conimep_8h.html#a111">Create</a>) {
05382         <span class="keywordflow">return</span> ZwCreateKey( <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>,
05383                             DesiredAccess,
05384                             &amp;objectAttributes,
05385                             0,
05386                             (PUNICODE_STRING) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
05387                             REG_OPTION_VOLATILE,
05388                             &amp;disposition );
05389     } <span class="keywordflow">else</span> {
05390         <span class="keywordflow">return</span> ZwOpenKey( <a class="code" href="../../d7/d0/cmdat2_8c.html#a19">Handle</a>,
05391                           DesiredAccess,
05392                           &amp;objectAttributes );
05393     }
05394 }
05395 
05396 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l05397"></a><a class="code" href="../../d0/d6/iop_8h.html#a203">05397</a> <a class="code" href="../../d0/d6/iop_8h.html#a203">IopQueryXxxInformation</a>(
05398     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
05399     IN ULONG InformationClass,
05400     IN ULONG Length,
05401     OUT PVOID Information,
05402     OUT PULONG ReturnedLength,
05403     IN BOOLEAN FileInformation
05404     )
05405 
05406 <span class="comment">/*++</span>
05407 <span class="comment"></span>
05408 <span class="comment">Routine Description:</span>
05409 <span class="comment"></span>
05410 <span class="comment">    This routine returns the requested information about a specified file</span>
05411 <span class="comment">    or volume.  The information returned is determined by the class that</span>
05412 <span class="comment">    is specified, and it is placed into the caller's output buffer.</span>
05413 <span class="comment"></span>
05414 <span class="comment">Arguments:</span>
05415 <span class="comment"></span>
05416 <span class="comment">    FileObject - Supplies a pointer to the file object about which the requested</span>
05417 <span class="comment">        information is returned.</span>
05418 <span class="comment"></span>
05419 <span class="comment">    FsInformationClass - Specifies the type of information which should be</span>
05420 <span class="comment">        returned about the file/volume.</span>
05421 <span class="comment"></span>
05422 <span class="comment">    Length - Supplies the length of the buffer in bytes.</span>
05423 <span class="comment"></span>
05424 <span class="comment">    FsInformation - Supplies a buffer to receive the requested information</span>
05425 <span class="comment">        returned about the file.  This buffer must not be pageable and must</span>
05426 <span class="comment">        reside in system space.</span>
05427 <span class="comment"></span>
05428 <span class="comment">    ReturnedLength - Supplies a variable that is to receive the length of the</span>
05429 <span class="comment">        information written to the buffer.</span>
05430 <span class="comment"></span>
05431 <span class="comment">    FileInformation - Boolean that indicates whether the information requested</span>
05432 <span class="comment">        is for a file or a volume.</span>
05433 <span class="comment"></span>
05434 <span class="comment">Return Value:</span>
05435 <span class="comment"></span>
05436 <span class="comment">    The status returned is the final completion status of the operation.</span>
05437 <span class="comment"></span>
05438 <span class="comment">--*/</span>
05439 
05440 {
05441     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
05442     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
05443     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
05444     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> event;
05445     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
05446     IO_STATUS_BLOCK localIoStatus;
05447     BOOLEAN synchronousIo;
05448 
05449     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
05450 
05451     <span class="comment">//</span>
05452     <span class="comment">// Reference the file object here so that no special checks need be made</span>
05453     <span class="comment">// in I/O completion to determine whether or not to dereference the file</span>
05454     <span class="comment">// object.</span>
05455     <span class="comment">//</span>
05456 
05457     <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a>( FileObject );
05458 
05459     <span class="comment">//</span>
05460     <span class="comment">// Make a special check here to determine whether this is a synchronous</span>
05461     <span class="comment">// I/O operation.  If it is, then wait here until the file is owned by</span>
05462     <span class="comment">// the current thread.  If this is not a (serialized) synchronous I/O</span>
05463     <span class="comment">// operation, then initialize the local event.</span>
05464     <span class="comment">//</span>
05465 
05466     <span class="keywordflow">if</span> (FileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>) {
05467 
05468         BOOLEAN interrupted;
05469 
05470         <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d6/iop_8h.html#a13">IopAcquireFastLock</a>( FileObject )) {
05471             status = <a class="code" href="../../d0/d6/iop_8h.html#a147">IopAcquireFileObjectLock</a>( FileObject,
05472                                                <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
05473                                                (BOOLEAN) ((FileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a152">FO_ALERTABLE_IO</a>) != 0),
05474                                                &amp;interrupted );
05475             <span class="keywordflow">if</span> (interrupted) {
05476                 <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( FileObject );
05477                 <span class="keywordflow">return</span> status;
05478             }
05479         }
05480         <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a>( &amp;FileObject-&gt;Event );
05481         synchronousIo = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
05482     } <span class="keywordflow">else</span> {
05483         <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;event, SynchronizationEvent, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
05484         synchronousIo = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
05485     }
05486 
05487     <span class="comment">//</span>
05488     <span class="comment">// Get the address of the target device object.</span>
05489     <span class="comment">//</span>
05490 
05491     deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( FileObject );
05492 
05493     <span class="comment">//</span>
05494     <span class="comment">// Allocate and initialize the I/O Request Packet (IRP) for this operation.</span>
05495     <span class="comment">// The allocation is performed with an exception handler in case the</span>
05496     <span class="comment">// caller does not have enough quota to allocate the packet.</span>
05497     <span class="comment">//</span>
05498 
05499     irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a17">IoAllocateIrp</a>( deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o13">StackSize</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
05500     <span class="keywordflow">if</span> (!irp) {
05501 
05502         <span class="comment">//</span>
05503         <span class="comment">// An IRP could not be allocated.  Cleanup and return an appropriate</span>
05504         <span class="comment">// error status code.</span>
05505         <span class="comment">//</span>
05506 
05507         <a class="code" href="../../d0/d6/iop_8h.html#a148">IopAllocateIrpCleanup</a>( FileObject, (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
05508 
05509         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
05510     }
05511     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.OriginalFileObject = FileObject;
05512     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
05513     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o10">RequestorMode</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>;
05514 
05515     <span class="comment">//</span>
05516     <span class="comment">// Fill in the service independent parameters in the IRP.</span>
05517     <span class="comment">//</span>
05518 
05519     <span class="keywordflow">if</span> (synchronousIo) {
05520         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05521     } <span class="keywordflow">else</span> {
05522         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = &amp;event;
05523         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a176">IRP_SYNCHRONOUS_API</a>;
05524     }
05525     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = &amp;localIoStatus;
05526     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05527 
05528     <span class="comment">//</span>
05529     <span class="comment">// Get a pointer to the stack location for the first driver.  This will be</span>
05530     <span class="comment">// used to pass the original function codes and parameters.</span>
05531     <span class="comment">//</span>
05532 
05533     irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
05534     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = FileInformation ?
05535                            <a class="code" href="../../d0/d5/io_8h.html#a18">IRP_MJ_QUERY_INFORMATION</a> :
05536                            <a class="code" href="../../d0/d5/io_8h.html#a23">IRP_MJ_QUERY_VOLUME_INFORMATION</a>;
05537     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> = FileObject;
05538 
05539     <span class="comment">//</span>
05540     <span class="comment">// Set the system buffer address to the address of the caller's buffer and</span>
05541     <span class="comment">// set the flags so that the buffer is not deallocated.</span>
05542     <span class="comment">//</span>
05543 
05544     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer = Information;
05545     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a178">IRP_BUFFERED_IO</a>;
05546 
05547     <span class="comment">//</span>
05548     <span class="comment">// Copy the caller's parameters to the service-specific portion of the</span>
05549     <span class="comment">// IRP.</span>
05550     <span class="comment">//</span>
05551 
05552     <span class="keywordflow">if</span> (FileInformation) {
05553         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.QueryFile.Length = Length;
05554         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.QueryFile.FileInformationClass = InformationClass;
05555     } <span class="keywordflow">else</span> {
05556         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.QueryVolume.Length = Length;
05557         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.QueryVolume.FsInformationClass = InformationClass;
05558     }
05559 
05560     <span class="comment">//</span>
05561     <span class="comment">// Insert the packet at the head of the IRP list for the thread.</span>
05562     <span class="comment">//</span>
05563 
05564     <a class="code" href="../../d0/d6/iop_8h.html#a21">IopQueueThreadIrp</a>( irp );
05565 
05566     <span class="comment">//</span>
05567     <span class="comment">// Now simply invoke the driver at its dispatch entry with the IRP.</span>
05568     <span class="comment">//</span>
05569 
05570     status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( deviceObject, irp );
05571 
05572     <span class="comment">//</span>
05573     <span class="comment">// If this operation was a synchronous I/O operation, check the return</span>
05574     <span class="comment">// status to determine whether or not to wait on the file object.  If</span>
05575     <span class="comment">// the file object is to be waited on, wait for the operation to complete</span>
05576     <span class="comment">// and obtain the final status from the file object itself.</span>
05577     <span class="comment">//</span>
05578 
05579     <span class="keywordflow">if</span> (synchronousIo) {
05580         <span class="keywordflow">if</span> (status == STATUS_PENDING) {
05581             status = <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;FileObject-&gt;Event,
05582                                             <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
05583                                             <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
05584                                             (BOOLEAN) ((FileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a152">FO_ALERTABLE_IO</a>) != 0),
05585                                             (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
05586             <span class="keywordflow">if</span> (status == STATUS_ALERTED) {
05587                 <a class="code" href="../../d0/d6/iop_8h.html#a151">IopCancelAlertedRequest</a>( &amp;FileObject-&gt;Event, irp );
05588             }
05589             status = FileObject-&gt;FinalStatus;
05590         }
05591         <a class="code" href="../../d0/d6/iop_8h.html#a22">IopReleaseFileObjectLock</a>( FileObject );
05592 
05593     } <span class="keywordflow">else</span> {
05594 
05595         <span class="comment">//</span>
05596         <span class="comment">// This is a normal synchronous I/O operation, as opposed to a</span>
05597         <span class="comment">// serialized synchronous I/O operation.  For this case, wait</span>
05598         <span class="comment">// for the local event and copy the final status information</span>
05599         <span class="comment">// back to the caller.</span>
05600         <span class="comment">//</span>
05601 
05602         <span class="keywordflow">if</span> (status == STATUS_PENDING) {
05603             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
05604                                           <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
05605                                           <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
05606                                           <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
05607                                           (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
05608             status = localIoStatus.Status;
05609         }
05610     }
05611 
05612     *ReturnedLength = (ULONG) localIoStatus.Information;
05613     <span class="keywordflow">return</span> status;
05614 }
05615 
05616 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l05617"></a><a class="code" href="../../d0/d6/iop_8h.html#a205">05617</a> <a class="code" href="../../d0/d6/iop_8h.html#a205">IopRaiseHardError</a>(
05618     IN PVOID NormalContext,
05619     IN PVOID SystemArgument1,
05620     IN PVOID SystemArgument2
05621     )
05622 
05623 <span class="comment">/*++</span>
05624 <span class="comment"></span>
05625 <span class="comment">Routine Description:</span>
05626 <span class="comment"></span>
05627 <span class="comment">    This routine raises a hard error popup in the context of the current</span>
05628 <span class="comment">    thread.  The APC was used to get into the context of this thread so that</span>
05629 <span class="comment">    the popup would be sent to the appropriate port.</span>
05630 <span class="comment"></span>
05631 <span class="comment">Arguments:</span>
05632 <span class="comment"></span>
05633 <span class="comment">    NormalContext - Supplies a pointer to the I/O Request Packet (IRP) that</span>
05634 <span class="comment">        was initially used to request the operation that has failed.</span>
05635 <span class="comment"></span>
05636 <span class="comment">    SystemArgument1 - Supplies a pointer to the media's volume parameter block.</span>
05637 <span class="comment">        See IoRaiseHardError documentation for more information.</span>
05638 <span class="comment"></span>
05639 <span class="comment">    SystemArgument2 - Supplies a pointer to the real device object.  See</span>
05640 <span class="comment">        IoRaiseHardError documentation for more information.</span>
05641 <span class="comment"></span>
05642 <span class="comment">Return Value:</span>
05643 <span class="comment"></span>
05644 <span class="comment">    None.</span>
05645 <span class="comment"></span>
05646 <span class="comment">--*/</span>
05647 
05648 {
05649     ULONG_PTR parameters[2];
05650     ULONG numberOfParameters;
05651     ULONG parameterMask;
05652     ULONG response;
05653     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
05654     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp = (<a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>) NormalContext;
05655     <a class="code" href="../../d7/d7/struct__VPB.html">PVPB</a> vpb = (<a class="code" href="../../d7/d7/struct__VPB.html">PVPB</a>) SystemArgument1;
05656     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> realDeviceObject = (<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>) SystemArgument2;
05657 
05658     ULONG length;
05659     POBJECT_NAME_INFORMATION objectName;
05660 
05661     UNICODE_STRING labelName;
05662 
05663     <span class="comment">//</span>
05664     <span class="comment">// Determine the name of the device and the volume label of the offending</span>
05665     <span class="comment">// media.  Start by determining the size of the DeviceName, and allocate</span>
05666     <span class="comment">// enough storage for both the ObjectName structure and the string</span>
05667     <span class="comment">// because "that's the ways Steve's routine works".</span>
05668     <span class="comment">//</span>
05669 
05670     <a class="code" href="../../d6/d1/obquery_8c.html#a7">ObQueryNameString</a>( realDeviceObject, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, 0, &amp;length );
05671 
05672     <span class="keywordflow">if</span> ((objectName = <a class="code" href="../../d5/d5/cc_8h.html#a10">ExAllocatePool</a>(<a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>, length)) == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05673 
05674         status = STATUS_INSUFFICIENT_RESOURCES;
05675 
05676     } <span class="keywordflow">else</span> {
05677 
05678         status = STATUS_SUCCESS;
05679     }
05680 
05681     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status ) ||
05682         !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status = <a class="code" href="../../d6/d1/obquery_8c.html#a7">ObQueryNameString</a>( realDeviceObject,
05683                                                  objectName,
05684                                                  length,
05685                                                  &amp;response ) )) {
05686 
05687         <span class="comment">//</span>
05688         <span class="comment">// Allocation of the pool to put up this popup did not work or</span>
05689         <span class="comment">// something else failed, so there isn't really much that can be</span>
05690         <span class="comment">// done here.  Simply return an error back to the user.</span>
05691         <span class="comment">//</span>
05692 
05693         <span class="keywordflow">if</span> (objectName) {
05694             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( objectName );
05695         }
05696 
05697         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status = status;
05698         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information = 0;
05699 
05700         <a class="code" href="../../d0/d5/io_8h.html#a224">IoCompleteRequest</a>( irp, <a class="code" href="../../d7/d8/exboosts_8h.html#a5">IO_DISK_INCREMENT</a> );
05701 
05702         <span class="keywordflow">return</span>;
05703     }
05704 
05705     <span class="comment">//</span>
05706     <span class="comment">// The volume label has a max size of 32 characters (Unicode).  Convert</span>
05707     <span class="comment">// it to a Unicode string for output in the popup message.</span>
05708     <span class="comment">//</span>
05709 
05710     <span class="keywordflow">if</span> (vpb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> &amp;&amp; vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o2">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a116">VPB_MOUNTED</a>) {
05711 
05712         labelName.Buffer = &amp;vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o8">VolumeLabel</a>[0];
05713         labelName.Length = vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o3">VolumeLabelLength</a>;
05714         labelName.MaximumLength = <a class="code" href="../../d0/d5/io_8h.html#a121">MAXIMUM_VOLUME_LABEL_LENGTH</a>;
05715 
05716     } <span class="keywordflow">else</span> {
05717 
05718         <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>( &amp;labelName, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
05719     }
05720 
05721     <span class="comment">//</span>
05722     <span class="comment">// Different pop-ups have different printf formats.  Depending on the</span>
05723     <span class="comment">// specific error value, adjust the parameters.</span>
05724     <span class="comment">//</span>
05725 
05726     <span class="keywordflow">switch</span>( irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status ) {
05727 
05728     <span class="keywordflow">case</span> STATUS_MEDIA_WRITE_PROTECTED:
05729     <span class="keywordflow">case</span> STATUS_WRONG_VOLUME:
05730 
05731         numberOfParameters = 2;
05732         parameterMask = 3;
05733 
05734         parameters[0] = (ULONG_PTR) &amp;labelName;
05735         parameters[1] = (ULONG_PTR) &amp;objectName-&gt;Name;
05736 
05737         <span class="keywordflow">break</span>;
05738 
05739     <span class="keywordflow">case</span> STATUS_DEVICE_NOT_READY:
05740     <span class="keywordflow">case</span> STATUS_IO_TIMEOUT:
05741     <span class="keywordflow">case</span> STATUS_NO_MEDIA_IN_DEVICE:
05742     <span class="keywordflow">case</span> STATUS_UNRECOGNIZED_MEDIA:
05743 
05744         numberOfParameters = 1;
05745         parameterMask = 1;
05746 
05747         parameters[0] = (ULONG_PTR) &amp;objectName-&gt;Name;
05748         parameters[1] = 0;
05749 
05750         <span class="keywordflow">break</span>;
05751 
05752     <span class="keywordflow">default</span>:
05753 
05754         numberOfParameters = 0;
05755         parameterMask = 0;
05756 
05757     }
05758 
05759     <span class="comment">//</span>
05760     <span class="comment">// Simply raise the hard error.</span>
05761     <span class="comment">//</span>
05762 
05763     <span class="keywordflow">if</span> (<a class="code" href="../../d6/d8/ex_2harderr_8c.html#a5">ExReadyForErrors</a>) {
05764         status = <a class="code" href="../../d5/d8/ex_8h.html#a306">ExRaiseHardError</a>( irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status,
05765                                    numberOfParameters,
05766                                    parameterMask,
05767                                    parameters,
05768                                    OptionCancelTryContinue,
05769                                    &amp;response );
05770 
05771     } <span class="keywordflow">else</span> {
05772 
05773         status = STATUS_UNSUCCESSFUL;
05774         response = ResponseReturnToCaller;
05775     }
05776 
05777     <span class="comment">//</span>
05778     <span class="comment">// Free any pool or other resources that were allocated to output the</span>
05779     <span class="comment">// popup.</span>
05780     <span class="comment">//</span>
05781 
05782     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( objectName );
05783 
05784     <span class="comment">//</span>
05785     <span class="comment">// If there was a problem, or the user didn't want to retry, just</span>
05786     <span class="comment">// complete the request.  Otherwise simply call the driver entry</span>
05787     <span class="comment">// point and retry the IRP as if it had never been tried before.</span>
05788     <span class="comment">//</span>
05789 
05790     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status ) || response != ResponseTryAgain) {
05791 
05792         <span class="comment">//</span>
05793         <span class="comment">// Before completing the request, make one last check.  If this was</span>
05794         <span class="comment">// a mount request, and the reason for the failure was t/o, no media,</span>
05795         <span class="comment">// or unrecognized media, then set the Information field of the status</span>
05796         <span class="comment">// block to indicate whether or not an abort was performed.</span>
05797         <span class="comment">//</span>
05798 
05799         <span class="keywordflow">if</span> (response == ResponseCancel) {
05800             <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( irp );
05801             <span class="keywordflow">if</span> (irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> == <a class="code" href="../../d0/d5/io_8h.html#a26">IRP_MJ_FILE_SYSTEM_CONTROL</a> &amp;&amp;
05802                 irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o1">MinorFunction</a> == <a class="code" href="../../d0/d5/io_8h.html#a47">IRP_MN_MOUNT_VOLUME</a>) {
05803                 irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information = <a class="code" href="../../d0/d6/iop_8h.html#a0">IOP_ABORT</a>;
05804             } <span class="keywordflow">else</span> {
05805                 irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status = STATUS_REQUEST_ABORTED;
05806             }
05807         }
05808 
05809         <span class="comment">//</span>
05810         <span class="comment">// An error was incurred, so zero out the information field before</span>
05811         <span class="comment">// completing the request if this was an input operation.  Otherwise,</span>
05812         <span class="comment">// IopCompleteRequest will try to copy to the user's buffer.</span>
05813         <span class="comment">//</span>
05814 
05815         <span class="keywordflow">if</span> (irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a180">IRP_INPUT_OPERATION</a>) {
05816             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information = 0;
05817         }
05818 
05819         <a class="code" href="../../d0/d5/io_8h.html#a224">IoCompleteRequest</a>( irp, <a class="code" href="../../d7/d8/exboosts_8h.html#a5">IO_DISK_INCREMENT</a> );
05820 
05821     } <span class="keywordflow">else</span> {
05822 
05823         <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( irp );
05824         <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> fsDeviceObject = irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o57">DeviceObject</a>;
05825         <a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html">PDRIVER_OBJECT</a> driverObject = fsDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o3">DriverObject</a>;
05826 
05827         <span class="comment">//</span>
05828         <span class="comment">// Retry the request from the top.</span>
05829         <span class="comment">//</span>
05830 
05831         <a class="code" href="../../d2/d1/mm_8h.html#a47">PERFINFO_DRIVER_MAJORFUNCTION_CALL</a>(irp, irpSp, driverObject);
05832 
05833         driverObject-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o14">MajorFunction</a>[irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a>]( fsDeviceObject,
05834                                                            irp );
05835 
05836         <a class="code" href="../../d2/d1/mm_8h.html#a48">PERFINFO_DRIVER_MAJORFUNCTION_RETURN</a>(irp, irpSp, driverObject);
05837     }
05838 }
05839 
05840 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l05841"></a><a class="code" href="../../d0/d6/iop_8h.html#a206">05841</a> <a class="code" href="../../d0/d6/iop_8h.html#a206">IopRaiseInformationalHardError</a>(
05842     IN PVOID NormalContext,
05843     IN PVOID SystemArgument1,
05844     IN PVOID SystemArgument2
05845     )
05846 
05847 <span class="comment">/*++</span>
05848 <span class="comment"></span>
05849 <span class="comment">Routine Description:</span>
05850 <span class="comment"></span>
05851 <span class="comment">    This routine performs the actual pop-up.  It will called from either the</span>
05852 <span class="comment">    hard-error thread, or a APC routine in a user thread after exiting the</span>
05853 <span class="comment">    file system.</span>
05854 <span class="comment"></span>
05855 <span class="comment">Arguments:</span>
05856 <span class="comment"></span>
05857 <span class="comment">    NormalContext - Contains the information for the pop-up</span>
05858 <span class="comment"></span>
05859 <span class="comment">    SystemArgument1 - not used.</span>
05860 <span class="comment"></span>
05861 <span class="comment">    SystemArgument1 - not used.</span>
05862 <span class="comment"></span>
05863 <span class="comment">Return Value:</span>
05864 <span class="comment"></span>
05865 <span class="comment">    None.</span>
05866 <span class="comment"></span>
05867 <span class="comment">--*/</span>
05868 
05869 {
05870     ULONG parameterPresent;
05871     ULONG_PTR errorParameter;
05872     ULONG errorResponse;
05873     <a class="code" href="../../d7/d0/struct__IOP__HARD__ERROR__PACKET.html">PIOP_HARD_ERROR_PACKET</a> hardErrorPacket;
05874 
05875     UNREFERENCED_PARAMETER( SystemArgument1 );
05876     UNREFERENCED_PARAMETER( SystemArgument2 );
05877 
05878     hardErrorPacket = (<a class="code" href="../../d7/d0/struct__IOP__HARD__ERROR__PACKET.html">PIOP_HARD_ERROR_PACKET</a>) NormalContext;
05879 
05880     <span class="comment">//</span>
05881     <span class="comment">// Simply raise the hard error if the system is ready to accept one.</span>
05882     <span class="comment">//</span>
05883 
05884     errorParameter = (ULONG_PTR) &amp;hardErrorPacket-&gt;<a class="code" href="../../d7/d0/struct__IOP__HARD__ERROR__PACKET.html#o2">String</a>;
05885 
05886     parameterPresent = (hardErrorPacket-&gt;<a class="code" href="../../d7/d0/struct__IOP__HARD__ERROR__PACKET.html#o2">String</a>.Buffer != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
05887 
05888     <span class="keywordflow">if</span> (<a class="code" href="../../d6/d8/ex_2harderr_8c.html#a5">ExReadyForErrors</a>) {
05889         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d5/d8/ex_8h.html#a306">ExRaiseHardError</a>( hardErrorPacket-&gt;<a class="code" href="../../d7/d0/struct__IOP__HARD__ERROR__PACKET.html#o1">ErrorStatus</a>,
05890                                  parameterPresent,
05891                                  parameterPresent,
05892                                  parameterPresent ? &amp;errorParameter : <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
05893                                  OptionOk,
05894                                  &amp;errorResponse );
05895     }
05896 
05897     <span class="comment">//</span>
05898     <span class="comment">// Now free the packet and the buffer, if one was specified.</span>
05899     <span class="comment">//</span>
05900 
05901     <span class="keywordflow">if</span> (hardErrorPacket-&gt;<a class="code" href="../../d7/d0/struct__IOP__HARD__ERROR__PACKET.html#o2">String</a>.Buffer) {
05902         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( hardErrorPacket-&gt;<a class="code" href="../../d7/d0/struct__IOP__HARD__ERROR__PACKET.html#o2">String</a>.Buffer );
05903     }
05904 
05905     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( hardErrorPacket );
05906     InterlockedDecrement(&amp;<a class="code" href="../../d3/d5/iodata_8c.html#a25">IopHardError</a>.<a class="code" href="../../d8/d0/struct__IOP__HARD__ERROR__QUEUE.html#o5">NumPendingApcPopups</a>);
05907 }
05908 
05909 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l05910"></a><a class="code" href="../../d0/d6/iop_8h.html#a207">05910</a> <a class="code" href="../../d0/d6/iop_8h.html#a207">IopReadyDeviceObjects</a>(
05911     IN <a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html">PDRIVER_OBJECT</a> DriverObject
05912     )
05913 
05914 <span class="comment">/*++</span>
05915 <span class="comment"></span>
05916 <span class="comment">Routine Description:</span>
05917 <span class="comment"></span>
05918 <span class="comment">    This routine is invoked to mark all of the device objects owned by the</span>
05919 <span class="comment">    specified driver as having been fully initialized and therefore ready</span>
05920 <span class="comment">    for access by other drivers/clients.</span>
05921 <span class="comment"></span>
05922 <span class="comment">Arguments:</span>
05923 <span class="comment"></span>
05924 <span class="comment">    DriverObject - Supplies a pointer to the driver object for the driver</span>
05925 <span class="comment">        whose devices are to be marked as being "ready".</span>
05926 <span class="comment"></span>
05927 <span class="comment">Return Value:</span>
05928 <span class="comment"></span>
05929 <span class="comment">    None.</span>
05930 <span class="comment"></span>
05931 <span class="comment">--*/</span>
05932 
05933 {
05934     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject = DriverObject-&gt;DeviceObject;
05935 
05936     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
05937 
05938     <span class="comment">//</span>
05939     <span class="comment">// Loop through all of the driver's device objects, clearing the</span>
05940     <span class="comment">// DO_DEVICE_INITIALIZING flag.</span>
05941     <span class="comment">//</span>
05942 
05943     DriverObject-&gt;Flags |= <a class="code" href="../../d0/d5/io_8h.html#a147">DRVO_INITIALIZED</a>;
05944     <span class="keywordflow">while</span> (deviceObject) {
05945         deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o8">Flags</a> &amp;= ~<a class="code" href="../../d0/d5/io_8h.html#a128">DO_DEVICE_INITIALIZING</a>;
05946         deviceObject = deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o4">NextDevice</a>;
05947     }
05948 }
05949 
05950 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l05951"></a><a class="code" href="../../d2/d4/internal_8c.html#a13">05951</a> <a class="code" href="../../d2/d4/internal_8c.html#a13">IopResurrectDriver</a>(
05952     <a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html">PDRIVER_OBJECT</a> DriverObject
05953     )
05954 
05955 <span class="comment">/*++</span>
05956 <span class="comment"></span>
05957 <span class="comment">Routine Description:</span>
05958 <span class="comment"></span>
05959 <span class="comment">    This routine is invoked to clear unload pending flag on all of the device</span>
05960 <span class="comment">    objects owned by the specified driver, if the unload routine has not run.</span>
05961 <span class="comment">    This allows the driver to come back to life after a pending unload.</span>
05962 <span class="comment"></span>
05963 <span class="comment"></span>
05964 <span class="comment">Arguments:</span>
05965 <span class="comment"></span>
05966 <span class="comment">    DriverObject - Supplies a pointer to the driver object for the driver</span>
05967 <span class="comment">        whose devices are to be cleared.</span>
05968 <span class="comment"></span>
05969 <span class="comment">Return Value:</span>
05970 <span class="comment"></span>
05971 <span class="comment">    Status - Returns success if the driver's unload routine has not run;</span>
05972 <span class="comment">        otherwise STATUS_IMAGE_ALREADY_LOADED is returned.</span>
05973 <span class="comment"></span>
05974 <span class="comment">--*/</span>
05975 
05976 {
05977     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject = DriverObject-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o2">DeviceObject</a>;
05978     KIRQL irql;
05979 
05980     <span class="comment">//</span>
05981     <span class="comment">// Acquire the I/O spinlock that protects the device list and</span>
05982     <span class="comment">// driver flags.</span>
05983     <span class="comment">//</span>
05984 
05985     ExAcquireSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, &amp;irql );
05986 
05987     <span class="keywordflow">if</span> (DriverObject-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o3">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a143">DRVO_UNLOAD_INVOKED</a> || !deviceObject ||
05988         !(deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o25">DeviceObjectExtension</a>-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o5">ExtensionFlags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a138">DOE_UNLOAD_PENDING</a>)) {
05989 
05990         ExReleaseSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, irql );
05991         <span class="keywordflow">return</span> STATUS_IMAGE_ALREADY_LOADED;
05992     }
05993 
05994     <span class="comment">//</span>
05995     <span class="comment">// Loop through all of the driver's device objects, clearing the</span>
05996     <span class="comment">// DOE_UNLOAD_PENDING flag.</span>
05997     <span class="comment">//</span>
05998 
05999     <span class="keywordflow">while</span> (deviceObject) {
06000         deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o25">DeviceObjectExtension</a>-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o5">ExtensionFlags</a> &amp;= ~<a class="code" href="../../d0/d5/io_8h.html#a138">DOE_UNLOAD_PENDING</a>;
06001         deviceObject = deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o4">NextDevice</a>;
06002     }
06003 
06004     ExReleaseSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, irql );
06005     <span class="keywordflow">return</span> STATUS_SUCCESS;
06006 
06007 }
06008 
06009 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l06010"></a><a class="code" href="../../d2/d4/internal_8c.html#a15">06010</a> <a class="code" href="../../d2/d4/internal_8c.html#a15">IopMarshalIds</a>(
06011     OUT PTRACKING_BUFFER TrackingBuffer,
06012     IN  PFILE_VOLUMEID_WITH_TYPE  TargetVolumeId,
06013     IN  PFILE_OBJECTID_BUFFER  TargetObjectId,
06014     IN  PFILE_TRACKING_INFORMATION TrackingInfo
06015     )
06016 
06017 <span class="comment">/*++</span>
06018 <span class="comment"></span>
06019 <span class="comment">Routine Description:</span>
06020 <span class="comment"></span>
06021 <span class="comment">    This routine marshals the TargetVolumeId and TargetObjectId</span>
06022 <span class="comment">    into the supplied TrackingBuffer in a standard remotable format.</span>
06023 <span class="comment"></span>
06024 <span class="comment">    It also clears the DestinationFile handle to NULL, and sets the</span>
06025 <span class="comment">    ObjectInformationLength to the size of the marshalled data.</span>
06026 <span class="comment"></span>
06027 <span class="comment">Arguments:</span>
06028 <span class="comment"></span>
06029 <span class="comment">    TrackingBuffer - The buffer to receive the marshalled parameters.</span>
06030 <span class="comment"></span>
06031 <span class="comment">    TargetVolumeId - The volume id to marshal.</span>
06032 <span class="comment"></span>
06033 <span class="comment">    TargetObjectId - The object id to marshal.</span>
06034 <span class="comment"></span>
06035 <span class="comment">    TrackingInfo   - The additional tracking information to marshal.</span>
06036 <span class="comment"></span>
06037 <span class="comment">--*/</span>
06038 
06039 {
06040     ULONG ObjectInformationLength = 0;
06041 
06042     TrackingBuffer-&gt;TrackingInformation.DestinationFile = (HANDLE) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
06043 
06044     RtlZeroMemory( &amp;TrackingBuffer-&gt;TrackingInformation.ObjectInformation[ ObjectInformationLength ],
06045                    <span class="keyword">sizeof</span>(TargetVolumeId-&gt;Type) );
06046 
06047     RtlCopyMemory( &amp;TrackingBuffer-&gt;TrackingInformation.ObjectInformation[ ObjectInformationLength ],
06048                    &amp;TargetVolumeId-&gt;Type,
06049                    <span class="keyword">sizeof</span>(TargetVolumeId-&gt;Type) );
06050     ObjectInformationLength += <span class="keyword">sizeof</span>(TargetVolumeId-&gt;Type);
06051 
06052     RtlCopyMemory( &amp;TrackingBuffer-&gt;TrackingInformation.ObjectInformation[ ObjectInformationLength ],
06053                    &amp;TargetVolumeId-&gt;VolumeId[0],
06054                    <span class="keyword">sizeof</span>(TargetVolumeId-&gt;VolumeId) );
06055     ObjectInformationLength += <span class="keyword">sizeof</span>(TargetVolumeId-&gt;VolumeId);
06056 
06057     RtlCopyMemory( &amp;TrackingBuffer-&gt;TrackingInformation.ObjectInformation[ ObjectInformationLength ],
06058                    &amp;TargetObjectId-&gt;ObjectId[0],
06059                    <span class="keyword">sizeof</span>(TargetObjectId-&gt;ObjectId) );
06060     ObjectInformationLength += <span class="keyword">sizeof</span>(TargetObjectId-&gt;ObjectId);
06061 
06062     RtlCopyMemory( &amp;TrackingBuffer-&gt;TrackingInformation.ObjectInformation[ ObjectInformationLength ],
06063                    &amp;TrackingInfo-&gt;ObjectInformation[0],
06064                    TrackingInfo-&gt;ObjectInformationLength );
06065     ObjectInformationLength += TrackingInfo-&gt;ObjectInformationLength;
06066 
06067     TrackingBuffer-&gt;TrackingInformation.ObjectInformationLength = ObjectInformationLength;
06068 
06069 }
06070 
06071 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l06072"></a><a class="code" href="../../d2/d4/internal_8c.html#a16">06072</a> <a class="code" href="../../d2/d4/internal_8c.html#a16">IopUnMarshalIds</a>(
06073     IN  FILE_TRACKING_INFORMATION * TrackingInformation,
06074     OUT FILE_VOLUMEID_WITH_TYPE * TargetVolumeId,
06075     OUT GUID * TargetObjectId,
06076     OUT GUID * TargetMachineId
06077     )
06078 
06079 <span class="comment">/*++</span>
06080 <span class="comment"></span>
06081 <span class="comment">Routine Description:</span>
06082 <span class="comment"></span>
06083 <span class="comment">    This routine unmarshals the TargetVolumeId and TargetObjectId</span>
06084 <span class="comment">    from the supplied TrackingInformation from a standard remotable format.</span>
06085 <span class="comment"></span>
06086 <span class="comment">Arguments:</span>
06087 <span class="comment"></span>
06088 <span class="comment">    TrackingInformation - The buffer containing the marshalled parameters.</span>
06089 <span class="comment"></span>
06090 <span class="comment">    TargetVolumeId - Buffer to receive the volume id.</span>
06091 <span class="comment"></span>
06092 <span class="comment">    TargetObjectId - Buffer to receive the object id.</span>
06093 <span class="comment"></span>
06094 <span class="comment">    TargetMachineId - Buffer to receieve the machine id.</span>
06095 <span class="comment"></span>
06096 <span class="comment">--*/</span>
06097 
06098 {
06099     ULONG ObjectInformationLength = 0;
06100 
06101     RtlCopyMemory( &amp;TargetVolumeId-&gt;Type,
06102                    &amp;TrackingInformation-&gt;ObjectInformation[ ObjectInformationLength ],
06103                    <span class="keyword">sizeof</span>(TargetVolumeId-&gt;Type) );
06104     ObjectInformationLength += <span class="keyword">sizeof</span>(TargetVolumeId-&gt;Type);
06105 
06106 
06107     RtlCopyMemory( &amp;TargetVolumeId-&gt;VolumeId[0],
06108                    &amp;TrackingInformation-&gt;ObjectInformation[ ObjectInformationLength ],
06109                    <span class="keyword">sizeof</span>(TargetVolumeId-&gt;VolumeId) );
06110     ObjectInformationLength += <span class="keyword">sizeof</span>(TargetVolumeId-&gt;VolumeId);
06111 
06112     RtlCopyMemory( TargetObjectId,
06113                    &amp;TrackingInformation-&gt;ObjectInformation[ ObjectInformationLength ],
06114                    <span class="keyword">sizeof</span>(*TargetObjectId) );
06115     ObjectInformationLength += <span class="keyword">sizeof</span>(*TargetObjectId);
06116 
06117     <span class="keywordflow">if</span>( TrackingInformation-&gt;ObjectInformationLength &gt; ObjectInformationLength ) {
06118         RtlCopyMemory( TargetMachineId,
06119                        &amp;TrackingInformation-&gt;ObjectInformation[ ObjectInformationLength ],
06120                        <a class="code" href="../../d5/d4/acpitabl_8h.html#a69">min</a>( <span class="keyword">sizeof</span>(*TargetMachineId), TrackingInformation-&gt;ObjectInformationLength - ObjectInformationLength) );
06121         <span class="comment">// ObjectInformationLength += sizeof(GUID);</span>
06122     }
06123 }
06124 
06125 
06126 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l06127"></a><a class="code" href="../../d2/d4/internal_8c.html#a62">06127</a> <a class="code" href="../../d2/d4/internal_8c.html#a62">IopSendMessageToTrackService</a>(
06128     IN PFILE_VOLUMEID_WITH_TYPE SourceVolumeId,
06129     IN PFILE_OBJECTID_BUFFER SourceObjectId,
06130     IN PFILE_TRACKING_INFORMATION TargetObjectInformation
06131     )
06132 
06133 <span class="comment">/*++</span>
06134 <span class="comment"></span>
06135 <span class="comment">Routine Description:</span>
06136 <span class="comment"></span>
06137 <span class="comment">    This routine is invoked to send a message to the user-mode link tracking</span>
06138 <span class="comment">    service to inform it that a file has been moved so that it can track it</span>
06139 <span class="comment">    by its object ID.</span>
06140 <span class="comment"></span>
06141 <span class="comment">Arguments:</span>
06142 <span class="comment"></span>
06143 <span class="comment">    SourceVolumeId - Volume ID of the source file.</span>
06144 <span class="comment"></span>
06145 <span class="comment">    SourceObjectId - Object ID of the source file.</span>
06146 <span class="comment"></span>
06147 <span class="comment">    TargetObjectInformation - Volume ID, object ID of the target file.</span>
06148 <span class="comment"></span>
06149 <span class="comment">Return Value:</span>
06150 <span class="comment"></span>
06151 <span class="comment">    The final function value is the final completion status of the operation.</span>
06152 <span class="comment"></span>
06153 <span class="comment"></span>
06154 <span class="comment">--*/</span>
06155 
06156 {
06157     <span class="keyword">typedef</span> <span class="keyword">struct </span>_LINK_TRACKING_MESSAGE {
06158         <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
06159         ULONG <a class="code" href="../../d5/d4/kernel_2ddetrack_8c.html#a24">Request</a>;
06160         <a class="code" href="../../d2/d4/internal_8c.html#a5">FILE_VOLUMEID_WITH_TYPE</a> SourceVolumeId;    <span class="comment">// src vol type &amp; id</span>
06161         FILE_OBJECTID_BUFFER     SourceObjectId;    <span class="comment">// src obj id &amp; birth info</span>
06162         <a class="code" href="../../d2/d4/internal_8c.html#a5">FILE_VOLUMEID_WITH_TYPE</a> TargetVolumeId;    <span class="comment">// tgt vol type &amp; id</span>
06163         GUID TargetObjectId;                        <span class="comment">// tgt obj id</span>
06164         GUID TargetMachineId;
06165     } LINK_TRACKING_MESSAGE, *PLINK_TRACKING_MESSAGE;
06166 
06167     <span class="keyword">typedef</span> <span class="keyword">struct </span>_LINK_TRACKING_RESPONSE {
06168         <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
06169     } LINK_TRACKING_RESPONSE, *PLINK_TRACKING_RESPONSE;
06170 
06171     PPORT_MESSAGE portMessage;
06172     PPORT_MESSAGE portReplyMessage;
06173     <a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a> portReply[ 256 ];
06174     PLINK_TRACKING_MESSAGE requestMessage;
06175     PLINK_TRACKING_RESPONSE replyMessage;
06176     <a class="code" href="../../d8/d1/struct__LINK__TRACKING__PACKET.html">LINK_TRACKING_PACKET</a> ltp;
06177     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
06178     ULONG loopCount = 0;
06179 
06180     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
06181 
06182     <span class="comment">//</span>
06183     <span class="comment">// Begin by determining whether or not the LPC port to the link tracking</span>
06184     <span class="comment">// service has been opened.  If not, then attempt to open it now.</span>
06185     <span class="comment">//</span>
06186 
06187 retry:
06188 
06189     <span class="keywordflow">if</span> (!<a class="code" href="../../d3/d5/iodata_8c.html#a61">IopLinkTrackingServiceObject</a>) {
06190 
06191         <span class="comment">//</span>
06192         <span class="comment">// The port has not yet been opened.  Check to see whether or not</span>
06193         <span class="comment">// the service has been started.  If not, then get out now as there</span>
06194         <span class="comment">// will be no port if the service is not running.</span>
06195         <span class="comment">//</span>
06196 
06197         <span class="keywordflow">if</span> (!<a class="code" href="../../d2/d8/eventobj_8c.html#a6">KeReadStateEvent</a>( <a class="code" href="../../d3/d5/iodata_8c.html#a62">IopLinkTrackingServiceEvent</a> )) {
06198             <span class="keywordflow">return</span> STATUS_NO_TRACKING_SERVICE;
06199         }
06200 
06201                 <span class="keywordflow">for</span> (;; ) {
06202                         status = <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>(&amp;<a class="code" href="../../d3/d5/iodata_8c.html#a52">IopLinkTrackingPortObject</a>,
06203                                                                                   <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
06204                                                                                   KeGetPreviousMode(),
06205                                                                                   <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
06206                                                                                   (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
06207 
06208                         <span class="keywordflow">if</span> ((status == STATUS_USER_APC) || (status == STATUS_ALERTED)) {
06209                                 <span class="keywordflow">return</span> status;
06210                         }
06211 
06212                         <span class="comment">//</span>
06213                         <span class="comment">// There is no referenced object pointer to the</span>
06214                         <span class="comment">// link tracking port so open it.</span>
06215                         <span class="comment">//</span>
06216                         <span class="keywordflow">if</span> (!<a class="code" href="../../d3/d5/iodata_8c.html#a61">IopLinkTrackingServiceObject</a>)  {
06217                                 <a class="code" href="../../d5/d8/ex_8h.html#a55">ExInitializeWorkItem</a>(
06218                                         &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a53">IopLinkTrackingPacket</a>.<a class="code" href="../../d8/d1/struct__LINK__TRACKING__PACKET.html#o0">WorkQueueItem</a>,
06219                                         <a class="code" href="../../d2/d4/internal_8c.html#a29">IopConnectLinkTrackingPort</a>,
06220                                         &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a53">IopLinkTrackingPacket</a>);
06221                                 (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d2/d8/eventobj_8c.html#a7">KeResetEvent</a>(&amp;<a class="code" href="../../d3/d5/iodata_8c.html#a53">IopLinkTrackingPacket</a>.<a class="code" href="../../d8/d1/struct__LINK__TRACKING__PACKET.html#o1">Event</a>);
06222                                 <a class="code" href="../../d5/d8/ex_8h.html#a261">ExQueueWorkItem</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a53">IopLinkTrackingPacket</a>.<a class="code" href="../../d8/d1/struct__LINK__TRACKING__PACKET.html#o0">WorkQueueItem</a>,
06223                                                                         <a class="code" href="../../d5/d8/ex_8h.html#a332a206">DelayedWorkQueue</a> );
06224                                 status = <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>(
06225                                                         &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a53">IopLinkTrackingPacket</a>.<a class="code" href="../../d8/d1/struct__LINK__TRACKING__PACKET.html#o1">Event</a>,
06226                                                         <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
06227                                                         KeGetPreviousMode(),
06228                                                         <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
06229                                                         (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
06230 
06231                                 <span class="keywordflow">if</span> ((status == STATUS_USER_APC) || (status == STATUS_ALERTED)) {
06232                                         NOTHING;
06233                                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d3/d5/iodata_8c.html#a53">IopLinkTrackingPacket</a>.<a class="code" href="../../d8/d1/struct__LINK__TRACKING__PACKET.html#o2">FinalStatus</a> )) {
06234                                         status = <a class="code" href="../../d3/d5/iodata_8c.html#a53">IopLinkTrackingPacket</a>.<a class="code" href="../../d8/d1/struct__LINK__TRACKING__PACKET.html#o2">FinalStatus</a>;
06235                                 }
06236 
06237                                 <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>(&amp;<a class="code" href="../../d3/d5/iodata_8c.html#a52">IopLinkTrackingPortObject</a>,
06238                                                 0,
06239                                                 <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
06240                                 <span class="keywordflow">if</span> (status == STATUS_SUCCESS) {
06241                                                 <span class="keywordflow">break</span>;
06242                                 } <span class="keywordflow">else</span> {
06243                                         <span class="keywordflow">return</span> status;
06244                                 }
06245 
06246                         } <span class="keywordflow">else</span> {
06247                                 <span class="comment">//</span>
06248                                 <span class="comment">// The connection is established.</span>
06249                                 <span class="comment">//</span>
06250 
06251                                 <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>(&amp;<a class="code" href="../../d3/d5/iodata_8c.html#a52">IopLinkTrackingPortObject</a>,
06252                                                 0,
06253                                                 <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
06254                                 <span class="keywordflow">break</span>;
06255                         }
06256         }
06257     }
06258 
06259     <span class="comment">//</span>
06260     <span class="comment">// Form a message from the input parameters and send it to the caller.</span>
06261     <span class="comment">//</span>
06262 
06263     portMessage = <a class="code" href="../../d5/d5/cc_8h.html#a10">ExAllocatePool</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>,
06264                                   <span class="keyword">sizeof</span>( LINK_TRACKING_MESSAGE ) +
06265                                   <span class="keyword">sizeof</span>( PORT_MESSAGE ) );
06266     <span class="keywordflow">if</span> (!portMessage) {
06267         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
06268     }
06269 
06270     requestMessage = (PLINK_TRACKING_MESSAGE) (portMessage + 1);
06271     RtlZeroMemory( requestMessage, <span class="keyword">sizeof</span>(*requestMessage) );
06272 
06273     requestMessage-&gt;Status = STATUS_SUCCESS;
06274     requestMessage-&gt;Request = 0;
06275 
06276     RtlCopyMemory( &amp;requestMessage-&gt;SourceVolumeId,
06277                    SourceVolumeId,
06278                    <span class="keyword">sizeof</span>( <a class="code" href="../../d2/d4/internal_8c.html#a5">FILE_VOLUMEID_WITH_TYPE</a> ) );
06279 
06280     RtlCopyMemory( &amp;requestMessage-&gt;SourceObjectId,
06281                    SourceObjectId,
06282                    <span class="keyword">sizeof</span>( FILE_OBJECTID_BUFFER ) );
06283 
06284     <a class="code" href="../../d2/d4/internal_8c.html#a16">IopUnMarshalIds</a>(  TargetObjectInformation,
06285                    &amp;requestMessage-&gt;TargetVolumeId,
06286                    &amp;requestMessage-&gt;TargetObjectId,
06287                    &amp;requestMessage-&gt;TargetMachineId);
06288 
06289     portMessage-&gt;u1.s1.TotalLength = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) (<span class="keyword">sizeof</span>( PORT_MESSAGE ) +
06290                                               <span class="keyword">sizeof</span>( LINK_TRACKING_MESSAGE ));
06291     portMessage-&gt;u1.s1.DataLength = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) <span class="keyword">sizeof</span>( LINK_TRACKING_MESSAGE );
06292     portMessage-&gt;u2.ZeroInit = 0;
06293 
06294     status = <a class="code" href="../../d6/d7/lpcsend_8c.html#a3">LpcRequestWaitReplyPort</a>( <a class="code" href="../../d3/d5/iodata_8c.html#a61">IopLinkTrackingServiceObject</a>,
06295                                       portMessage,
06296                                       (PPORT_MESSAGE) &amp;portReply[0] );
06297     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
06298         <span class="keywordflow">if</span> (status == STATUS_PORT_DISCONNECTED) {
06299                         status = <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>(&amp;<a class="code" href="../../d3/d5/iodata_8c.html#a52">IopLinkTrackingPortObject</a>,
06300                                                                                                 <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
06301                                                                                                 KeGetPreviousMode(),
06302                                                                                                 <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
06303                                                                                                 (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
06304             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( <a class="code" href="../../d3/d5/iodata_8c.html#a61">IopLinkTrackingServiceObject</a> );
06305                         <a class="code" href="../../d3/d5/iodata_8c.html#a61">IopLinkTrackingServiceObject</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
06306                         <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>(&amp;<a class="code" href="../../d3/d5/iodata_8c.html#a52">IopLinkTrackingPortObject</a>,
06307                                 0,
06308                                 <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
06309             <span class="keywordflow">if</span> (!loopCount) {
06310                 loopCount += 1;
06311                 <span class="keywordflow">goto</span> retry;
06312             }
06313         }
06314     }
06315 
06316     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
06317         portReplyMessage = (PPORT_MESSAGE) &amp;portReply[0];
06318         replyMessage = (PLINK_TRACKING_RESPONSE) (portReplyMessage + 1);
06319         status = replyMessage-&gt;Status;
06320     }
06321 
06322     <span class="keywordflow">return</span> status;
06323 }
06324 
06325 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l06326"></a><a class="code" href="../../d0/d6/iop_8h.html#a208">06326</a> <a class="code" href="../../d0/d6/iop_8h.html#a208">IopSetEaOrQuotaInformationFile</a>(
06327     IN HANDLE FileHandle,
06328     OUT PIO_STATUS_BLOCK IoStatusBlock,
06329     IN PVOID Buffer,
06330     IN ULONG Length,
06331     IN BOOLEAN SetEa
06332     )
06333 
06334 <span class="comment">/*++</span>
06335 <span class="comment"></span>
06336 <span class="comment">Routine Description:</span>
06337 <span class="comment"></span>
06338 <span class="comment">    This routine is invoked by the NtSetEa[Quota]InformationFile system services</span>
06339 <span class="comment">    to either modify the EAs on a file or the quota entries on a volume.  All of</span>
06340 <span class="comment">    the specified entries in the buffer are made to the file or volume.</span>
06341 <span class="comment"></span>
06342 <span class="comment">Arguments:</span>
06343 <span class="comment"></span>
06344 <span class="comment">    FileHandle - Supplies a handle to the file/volume for which the entries are</span>
06345 <span class="comment">        to be applied.</span>
06346 <span class="comment"></span>
06347 <span class="comment">    IoStatusBlock - Address of the caller's I/O status block.</span>
06348 <span class="comment"></span>
06349 <span class="comment">    Buffer - Supplies a buffer containing the entries to be added/modified.</span>
06350 <span class="comment"></span>
06351 <span class="comment">    Length - Supplies the length, in bytes, of the buffer.</span>
06352 <span class="comment"></span>
06353 <span class="comment">    SetEa - A BOOLEAN that indicates whether to change the EAs on a file or</span>
06354 <span class="comment">        the quota entries on the volume.</span>
06355 <span class="comment"></span>
06356 <span class="comment">Return Value:</span>
06357 <span class="comment"></span>
06358 <span class="comment">    The status returned is the final completion status of the operation.</span>
06359 <span class="comment"></span>
06360 <span class="comment">--*/</span>
06361 
06362 {
06363     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
06364     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
06365     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> fileObject;
06366     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
06367     <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> event = (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
06368     <a class="code" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> requestorMode;
06369     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
06370     IO_STATUS_BLOCK localIoStatus;
06371     BOOLEAN synchronousIo;
06372 
06373     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
06374 
06375     <span class="comment">//</span>
06376     <span class="comment">// Get the previous mode;  i.e., the mode of the caller.</span>
06377     <span class="comment">//</span>
06378 
06379     requestorMode = KeGetPreviousMode();
06380 
06381     <span class="keywordflow">if</span> (requestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
06382 
06383         <span class="comment">//</span>
06384         <span class="comment">// The caller's access mode is user, so probe each of the arguments</span>
06385         <span class="comment">// and capture them as necessary.  If any failures occur, the condition</span>
06386         <span class="comment">// handler will be invoked to handle them.  It will simply cleanup and</span>
06387         <span class="comment">// return an access violation status code back to the system service</span>
06388         <span class="comment">// dispatcher.</span>
06389         <span class="comment">//</span>
06390 
06391         <span class="keywordflow">try</span> {
06392 
06393             <span class="comment">//</span>
06394             <span class="comment">// The IoStatusBlock parameter must be writeable by the caller.</span>
06395             <span class="comment">//</span>
06396 
06397             <a class="code" href="../../d5/d8/ex_8h.html#a31">ProbeForWriteIoStatus</a>( IoStatusBlock);
06398 
06399             <span class="comment">//</span>
06400             <span class="comment">// The Buffer parameter must be readable by the caller.</span>
06401             <span class="comment">//</span>
06402 
06403             <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, Length, <span class="keyword">sizeof</span>( ULONG ) );
06404 
06405         } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
06406 
06407             <span class="comment">//</span>
06408             <span class="comment">// An exception was incurred while probing the caller's parameters.</span>
06409             <span class="comment">// Cleanup and return an appropriate error status code.</span>
06410             <span class="comment">//</span>
06411 
06412             <span class="keywordflow">return</span> GetExceptionCode();
06413         }
06414     }
06415 
06416     <span class="comment">//</span>
06417     <span class="comment">// There were no blatant errors so far, so reference the file object so</span>
06418     <span class="comment">// the target device object can be found.  Note that if the handle does</span>
06419     <span class="comment">// not refer to a file object, or if the caller does not have the required</span>
06420     <span class="comment">// access to the file, then it will fail.</span>
06421     <span class="comment">//</span>
06422 
06423     status = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a>( FileHandle,
06424                                         SetEa ? FILE_WRITE_EA : FILE_WRITE_DATA,
06425                                         <a class="code" href="../../d5/d8/fssup_8c.html#a3">IoFileObjectType</a>,
06426                                         requestorMode,
06427                                         (PVOID *) &amp;fileObject,
06428                                         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
06429     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
06430         <span class="keywordflow">return</span> status;
06431     }
06432 
06433     <span class="comment">//</span>
06434     <span class="comment">// Make a special check here to determine whether this is a synchronous</span>
06435     <span class="comment">// I/O operation.  If it is, then wait here until the file is owned by</span>
06436     <span class="comment">// the current thread.  If this is not a (serialized) synchronous I/O</span>
06437     <span class="comment">// operation, then allocate and initialize the local event.</span>
06438     <span class="comment">//</span>
06439 
06440     <span class="keywordflow">if</span> (fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>) {
06441 
06442         BOOLEAN interrupted;
06443 
06444         <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d6/iop_8h.html#a13">IopAcquireFastLock</a>( fileObject )) {
06445             status = <a class="code" href="../../d0/d6/iop_8h.html#a147">IopAcquireFileObjectLock</a>( fileObject,
06446                                                requestorMode,
06447                                                (BOOLEAN) ((fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a152">FO_ALERTABLE_IO</a>) != 0),
06448                                                &amp;interrupted );
06449             <span class="keywordflow">if</span> (interrupted) {
06450                 <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
06451                 <span class="keywordflow">return</span> status;
06452             }
06453         }
06454         synchronousIo = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
06455     } <span class="keywordflow">else</span> {
06456 
06457         <span class="comment">//</span>
06458         <span class="comment">// This is a synchronous API being invoked for a file that is opened</span>
06459         <span class="comment">// for asynchronous I/O.  This means that this system service is</span>
06460         <span class="comment">// to synchronize the completion of the operation before returning</span>
06461         <span class="comment">// to the caller.  A local event is used to do this.</span>
06462         <span class="comment">//</span>
06463 
06464         event = <a class="code" href="../../d5/d5/cc_8h.html#a10">ExAllocatePool</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, <span class="keyword">sizeof</span>( <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> ) );
06465         <span class="keywordflow">if</span> (!event) {
06466             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
06467             <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
06468         }
06469         <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( event, SynchronizationEvent, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
06470         synchronousIo = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
06471     }
06472 
06473     <span class="comment">//</span>
06474     <span class="comment">// Set the file object to the Not-Signaled state.</span>
06475     <span class="comment">//</span>
06476 
06477     <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a>( &amp;fileObject-&gt;Event );
06478 
06479     <span class="comment">//</span>
06480     <span class="comment">// Get the address of the target device object.</span>
06481     <span class="comment">//</span>
06482 
06483     deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( fileObject );
06484 
06485     <span class="comment">//</span>
06486     <span class="comment">// Allocate and initialize the I/O Request Packet (IRP) for this operation.</span>
06487     <span class="comment">// The allocation is performed with an exception handler in case the</span>
06488     <span class="comment">// caller does not have enough quota to allocate the packet.</span>
06489 
06490     irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a17">IoAllocateIrp</a>( deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o13">StackSize</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
06491     <span class="keywordflow">if</span> (!irp) {
06492 
06493         <span class="comment">//</span>
06494         <span class="comment">// An IRP could not be allocated.  Cleanup and return an appropriate</span>
06495         <span class="comment">// error status code.</span>
06496         <span class="comment">//</span>
06497 
06498         <span class="keywordflow">if</span> (!(fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>)) {
06499             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( event );
06500         }
06501 
06502         <a class="code" href="../../d0/d6/iop_8h.html#a148">IopAllocateIrpCleanup</a>( fileObject, (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
06503 
06504         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
06505     }
06506     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.OriginalFileObject = fileObject;
06507     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
06508     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o10">RequestorMode</a> = requestorMode;
06509 
06510     <span class="comment">//</span>
06511     <span class="comment">// Fill in the service independent parameters in the IRP.</span>
06512     <span class="comment">//</span>
06513 
06514     <span class="keywordflow">if</span> (synchronousIo) {
06515         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
06516         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = IoStatusBlock;
06517     } <span class="keywordflow">else</span> {
06518         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = event;
06519         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = &amp;localIoStatus;
06520         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a176">IRP_SYNCHRONOUS_API</a>;
06521     }
06522     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
06523 
06524     <span class="comment">//</span>
06525     <span class="comment">// Get a pointer to the stack location for the first driver.  This will be</span>
06526     <span class="comment">// used to pass the original function codes and parameters.</span>
06527     <span class="comment">//</span>
06528 
06529     irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
06530     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = SetEa ? <a class="code" href="../../d0/d5/io_8h.html#a21">IRP_MJ_SET_EA</a> : <a class="code" href="../../d0/d5/io_8h.html#a39">IRP_MJ_SET_QUOTA</a>;
06531     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> = fileObject;
06532 
06533     <span class="comment">//</span>
06534     <span class="comment">// Now determine whether this driver expects to have data buffered to it</span>
06535     <span class="comment">// or whether it performs direct I/O.  This is based on the DO_BUFFERED_IO</span>
06536     <span class="comment">// flag in the device object.  if the flag is set, then a system buffer is</span>
06537     <span class="comment">// allocated and driver's data is copied to it.  If the DO_DIRECT_IO flag</span>
06538     <span class="comment">// is set in the device object, then a Memory Descriptor List (MDL) is</span>
06539     <span class="comment">// allocated and the caller's buffer is locked down using it.  Finally, if</span>
06540     <span class="comment">// the driver specifies neither of the flags, then simply pass the address</span>
06541     <span class="comment">// and length of the buffer and allow the driver to perform all of the</span>
06542     <span class="comment">// checking and buffering if any is required.</span>
06543     <span class="comment">//</span>
06544 
06545     <span class="keywordflow">if</span> (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o8">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a123">DO_BUFFERED_IO</a>) {
06546 
06547         PVOID systemBuffer;
06548         ULONG errorOffset;
06549 
06550         <span class="comment">//</span>
06551         <span class="comment">// The driver wishes the caller's buffer to be copied into an</span>
06552         <span class="comment">// intermediary buffer.  Allocate the system buffer and specify</span>
06553         <span class="comment">// that it should be deallocated on completion.  Also check to</span>
06554         <span class="comment">// ensure that the caller's EA list or quota list is valid.  All</span>
06555         <span class="comment">// of this is performed within an exception handler that will perform</span>
06556         <span class="comment">// cleanup if the operation fails.</span>
06557         <span class="comment">//</span>
06558 
06559         <span class="keywordflow">try</span> {
06560 
06561             <span class="comment">//</span>
06562             <span class="comment">// Allocate the intermediary system buffer and charge the caller</span>
06563             <span class="comment">// quota for its allocation.  Copy the caller's buffer into the</span>
06564             <span class="comment">// system buffer and check to ensure that it is valid.</span>
06565             <span class="comment">//</span>
06566 
06567             systemBuffer = <a class="code" href="../../d5/d5/cc_8h.html#a11">ExAllocatePoolWithQuota</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, Length );
06568 
06569             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer = systemBuffer;
06570 
06571             RtlCopyMemory( systemBuffer, <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, Length );
06572 
06573             <span class="keywordflow">if</span> (SetEa) {
06574                 status = <a class="code" href="../../d4/d6/iosubs_8c.html#a33">IoCheckEaBufferValidity</a>( systemBuffer,
06575                                                   Length,
06576                                                   &amp;errorOffset );
06577             } <span class="keywordflow">else</span> {
06578                 status = <a class="code" href="../../d4/d6/iosubs_8c.html#a37">IoCheckQuotaBufferValidity</a>( systemBuffer,
06579                                                      Length,
06580                                                      &amp;errorOffset );
06581             }
06582 
06583             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
06584                 IoStatusBlock-&gt;Status = status;
06585                 IoStatusBlock-&gt;Information = errorOffset;
06586                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( status );
06587             }
06588 
06589         } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
06590 
06591             <span class="comment">//</span>
06592             <span class="comment">// An exception was incurred while allocating the buffer, copying</span>
06593             <span class="comment">// the caller's data into it, or walking the buffer.  Determine</span>
06594             <span class="comment">// what happened, cleanup, and return an appropriate error status</span>
06595             <span class="comment">// code.</span>
06596             <span class="comment">//</span>
06597 
06598             <a class="code" href="../../d0/d6/iop_8h.html#a170">IopExceptionCleanup</a>( fileObject,
06599                                  irp,
06600                                  (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
06601                                  event );
06602 
06603             <span class="keywordflow">return</span> GetExceptionCode();
06604 
06605         }
06606 
06607         <span class="comment">//</span>
06608         <span class="comment">// Set the flags so that the completion code knows to deallocate the</span>
06609         <span class="comment">// buffer.</span>
06610         <span class="comment">//</span>
06611 
06612         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a178">IRP_BUFFERED_IO</a> | <a class="code" href="../../d0/d5/io_8h.html#a179">IRP_DEALLOCATE_BUFFER</a>;
06613 
06614     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o8">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a125">DO_DIRECT_IO</a>) {
06615 
06616         <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> mdl;
06617 
06618         <span class="comment">//</span>
06619         <span class="comment">// This is a direct I/O operation.  Allocate an MDL and invoke the</span>
06620         <span class="comment">// memory management routine to lock the buffer into memory.  This is</span>
06621         <span class="comment">// done using an exception handler that will perform cleanup if the</span>
06622         <span class="comment">// operation fails.</span>
06623         <span class="comment">//</span>
06624 
06625         mdl = (<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
06626 
06627         <span class="keywordflow">try</span> {
06628 
06629             <span class="comment">//</span>
06630             <span class="comment">// Allocate an MDL, charging quota for it, and hang it off of the</span>
06631             <span class="comment">// IRP.  Probe and lock the pages associated with the caller's</span>
06632             <span class="comment">// buffer for read access and fill in the MDL with the PFNs of those</span>
06633             <span class="comment">// pages.</span>
06634             <span class="comment">//</span>
06635 
06636             mdl = <a class="code" href="../../d4/d6/iosubs_8c.html#a19">IoAllocateMdl</a>( <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, Length, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, irp );
06637             <span class="keywordflow">if</span> (!mdl) {
06638                 <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INSUFFICIENT_RESOURCES );
06639             }
06640             <a class="code" href="../../d5/d6/iosup_8c.html#a41">MmProbeAndLockPages</a>( mdl, requestorMode, <a class="code" href="../../d2/d1/mm_8h.html#a344a168">IoReadAccess</a> );
06641 
06642         } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
06643 
06644             <span class="comment">//</span>
06645             <span class="comment">// An exception was incurred while either probing the caller's</span>
06646             <span class="comment">// buffer or allocating the MDL.  Determine what actually happened,</span>
06647             <span class="comment">// clean everything up, and return an appropriate error status code.</span>
06648             <span class="comment">//</span>
06649 
06650             <a class="code" href="../../d0/d6/iop_8h.html#a170">IopExceptionCleanup</a>( fileObject,
06651                                  irp,
06652                                  (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
06653                                  event );
06654 
06655             <span class="keywordflow">return</span> GetExceptionCode();
06656 
06657         }
06658 
06659     } <span class="keywordflow">else</span> {
06660 
06661         <span class="comment">//</span>
06662         <span class="comment">// Pass the address of the user's buffer so the driver has access to</span>
06663         <span class="comment">// it.  It is now the driver's responsibility to do everything.</span>
06664         <span class="comment">//</span>
06665 
06666         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o26">UserBuffer</a> = <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>;
06667 
06668     }
06669 
06670     <span class="comment">//</span>
06671     <span class="comment">// Copy the caller's parameters to the service-specific portion of the</span>
06672     <span class="comment">// IRP.</span>
06673     <span class="comment">//</span>
06674 
06675     <span class="keywordflow">if</span> (SetEa) {
06676         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.SetEa.Length = Length;
06677     } <span class="keywordflow">else</span> {
06678         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.SetQuota.Length = Length;
06679     }
06680 
06681     <span class="comment">//</span>
06682     <span class="comment">// Queue the packet, call the driver, and synchronize appropriately with</span>
06683     <span class="comment">// I/O completion.</span>
06684     <span class="comment">//</span>
06685 
06686     status = <a class="code" href="../../d0/d6/iop_8h.html#a212">IopSynchronousServiceTail</a>( deviceObject,
06687                                         irp,
06688                                         fileObject,
06689                                         <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
06690                                         requestorMode,
06691                                         synchronousIo,
06692                                         <a class="code" href="../../d0/d6/iop_8h.html#a240a140">OtherTransfer</a> );
06693 
06694     <span class="comment">//</span>
06695     <span class="comment">// If the file for this operation was not opened for synchronous I/O, then</span>
06696     <span class="comment">// synchronization of completion of the I/O operation has not yet occurred</span>
06697     <span class="comment">// since the allocated event must be used for synchronous APIs on files</span>
06698     <span class="comment">// opened for asynchronous I/O.  Synchronize the completion of the I/O</span>
06699     <span class="comment">// operation now.</span>
06700     <span class="comment">//</span>
06701 
06702     <span class="keywordflow">if</span> (!synchronousIo) {
06703 
06704         status = <a class="code" href="../../d0/d6/iop_8h.html#a211">IopSynchronousApiServiceTail</a>( status,
06705                                                event,
06706                                                irp,
06707                                                requestorMode,
06708                                                &amp;localIoStatus,
06709                                                IoStatusBlock );
06710     }
06711 
06712     <span class="keywordflow">return</span> status;
06713 }
06714 
06715 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l06716"></a><a class="code" href="../../d0/d6/iop_8h.html#a209">06716</a> <a class="code" href="../../d0/d6/iop_8h.html#a209">IopSetRemoteLink</a>(
06717     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
06718     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> DestinationFileObject OPTIONAL,
06719     IN PFILE_TRACKING_INFORMATION FileInformation OPTIONAL
06720     )
06721 
06722 <span class="comment">/*++</span>
06723 <span class="comment"></span>
06724 <span class="comment">Routine Description:</span>
06725 <span class="comment"></span>
06726 <span class="comment">    This routine is invoked to remote an NtSetInformationFile API call via an</span>
06727 <span class="comment">    FSCTL to the Redirector.  The call will cause the remote system to perform</span>
06728 <span class="comment">    the service call to track the link for a file which was just moved.</span>
06729 <span class="comment"></span>
06730 <span class="comment">Arguments:</span>
06731 <span class="comment"></span>
06732 <span class="comment">    FileObject - Supplies the file object for the file that was moved.</span>
06733 <span class="comment"></span>
06734 <span class="comment">    DestinationFileObject - Optionally supplies the file object for the new</span>
06735 <span class="comment">        destination location for the file.</span>
06736 <span class="comment"></span>
06737 <span class="comment">    FileInformation - Optionally supplies the volume and file object IDs of</span>
06738 <span class="comment">        the target file.</span>
06739 <span class="comment"></span>
06740 <span class="comment">Return Value:</span>
06741 <span class="comment"></span>
06742 <span class="comment">    The final function value is the final completion status of the operation.</span>
06743 <span class="comment"></span>
06744 <span class="comment">--*/</span>
06745 
06746 {
06747     <a class="code" href="../../d8/d3/struct__REMOTE__LINK__BUFFER.html">REMOTE_LINK_BUFFER</a> remoteBuffer;
06748     IO_STATUS_BLOCK ioStatus;
06749     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
06750     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
06751     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> event;
06752     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
06753     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
06754     ULONG length = 0;
06755 
06756     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
06757 
06758     <span class="comment">//</span>
06759     <span class="comment">// Initialize the event structure to synchronize completion of the I/O</span>
06760     <span class="comment">// request.</span>
06761     <span class="comment">//</span>
06762 
06763     <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;event,
06764                        NotificationEvent,
06765                        <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
06766 
06767     <span class="comment">//</span>
06768     <span class="comment">// Build an I/O Request Packet to be sent to the file system driver to get</span>
06769     <span class="comment">// the volume ID.</span>
06770     <span class="comment">//</span>
06771 
06772     deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( FileObject );
06773 
06774     irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a25">IoBuildDeviceIoControlRequest</a>( FSCTL_LMR_SET_LINK_TRACKING_INFORMATION,
06775                                          deviceObject,
06776                                          <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
06777                                          0,
06778                                          <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
06779                                          0,
06780                                          <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
06781                                          &amp;event,
06782                                          &amp;ioStatus );
06783     <span class="keywordflow">if</span> (!irp) {
06784         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
06785     }
06786 
06787     <span class="comment">//</span>
06788     <span class="comment">// Initialize the remote link buffer according to the input information.</span>
06789     <span class="comment">//</span>
06790 
06791     <span class="keywordflow">if</span> (DestinationFileObject) {
06792 
06793         <span class="comment">// The FileObject and DestinationFileObject are on the same machine</span>
06794         remoteBuffer.<a class="code" href="../../d8/d3/struct__REMOTE__LINK__BUFFER.html#o0">TrackingInformation</a>.TargetFileObject = DestinationFileObject;
06795 
06796         <span class="keywordflow">if</span> (FileInformation) {
06797             <span class="comment">// Copy the ObjectInformation from the FileInformation buffer into</span>
06798             <span class="comment">// the TargetLinkTrackingInformationBuffer.  Set 'length' to include</span>
06799             <span class="comment">// this buffer.</span>
06800 
06801             remoteBuffer.<a class="code" href="../../d8/d3/struct__REMOTE__LINK__BUFFER.html#o0">TrackingInformation</a>.TargetLinkTrackingInformationLength
06802                 = length = FileInformation-&gt;ObjectInformationLength;
06803             RtlCopyMemory( &amp;remoteBuffer.<a class="code" href="../../d8/d3/struct__REMOTE__LINK__BUFFER.html#o0">TrackingInformation</a>.TargetLinkTrackingInformationBuffer,
06804                            FileInformation-&gt;ObjectInformation,
06805                            length );
06806         } <span class="keywordflow">else</span> {
06807             <span class="comment">// We don't have any extra FileInformation.</span>
06808             remoteBuffer.<a class="code" href="../../d8/d3/struct__REMOTE__LINK__BUFFER.html#o0">TrackingInformation</a>.TargetLinkTrackingInformationLength = 0;
06809         }
06810 
06811         <span class="comment">// Increment the length to include the size of the non-optional fields in</span>
06812         <span class="comment">// REMOTE_LINK_TRACKING_INFORMATION.</span>
06813         length += <span class="keyword">sizeof</span>( <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> ) + <span class="keyword">sizeof</span>( ULONG );
06814 
06815     } <span class="keywordflow">else</span> {
06816         <span class="comment">// There's no DestinationFileObject, so all the necessary information is in the</span>
06817         <span class="comment">// FileInformation structure.</span>
06818         length = FileInformation-&gt;ObjectInformationLength + <span class="keyword">sizeof</span>( HANDLE ) + <span class="keyword">sizeof</span>( ULONG );
06819         RtlCopyMemory( &amp;remoteBuffer.<a class="code" href="../../d8/d3/struct__REMOTE__LINK__BUFFER.html#o0">TrackingInformation</a>,
06820                        FileInformation,
06821                        length );
06822         remoteBuffer.<a class="code" href="../../d8/d3/struct__REMOTE__LINK__BUFFER.html#o0">TrackingInformation</a>.TargetFileObject = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
06823     }
06824 
06825     <span class="comment">//</span>
06826     <span class="comment">// Fill in the remainder of the IRP to retrieve the object ID for the</span>
06827     <span class="comment">// file.</span>
06828     <span class="comment">//</span>
06829 
06830     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a176">IRP_SYNCHRONOUS_API</a>;
06831     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer = &amp;remoteBuffer;
06832     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.OriginalFileObject = FileObject;
06833 
06834     irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
06835     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> = FileObject;
06836     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a26">IRP_MJ_FILE_SYSTEM_CONTROL</a>;
06837     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o1">MinorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a51">IRP_MN_KERNEL_CALL</a>;
06838     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.FileSystemControl.InputBufferLength = length;
06839 
06840     <span class="comment">//</span>
06841     <span class="comment">// Take out another reference to the file object to guarantee that it does</span>
06842     <span class="comment">// not get deleted.</span>
06843     <span class="comment">//</span>
06844 
06845     <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a>( FileObject );
06846 
06847     <span class="comment">//</span>
06848     <span class="comment">// Call the driver to get the request.</span>
06849     <span class="comment">//</span>
06850 
06851     status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( deviceObject, irp );
06852 
06853     <span class="comment">//</span>
06854     <span class="comment">// Synchronize completion of the request.</span>
06855     <span class="comment">//</span>
06856 
06857     <span class="keywordflow">if</span> (status == STATUS_PENDING) {
06858         status = <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
06859                                         <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
06860                                         <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
06861                                         <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
06862                                         (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
06863         status = ioStatus.Status;
06864     }
06865 
06866     <span class="keywordflow">return</span> status;
06867 }
06868 
06869 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l06870"></a><a class="code" href="../../d0/d6/iop_8h.html#a210">06870</a> <a class="code" href="../../d0/d6/iop_8h.html#a210">IopStartApcHardError</a>(
06871     IN PVOID StartContext
06872     )
06873 
06874 <span class="comment">/*++</span>
06875 <span class="comment"></span>
06876 <span class="comment">Routine Description:</span>
06877 <span class="comment"></span>
06878 <span class="comment">    This function is invoked in an ExWorker thread when we need to do a</span>
06879 <span class="comment">    hard error pop-up, but the Irp's originating thread is at APC level,</span>
06880 <span class="comment">    ie. IoPageRead.  It starts a thread to hold the pop-up.</span>
06881 <span class="comment"></span>
06882 <span class="comment">Arguments:</span>
06883 <span class="comment"></span>
06884 <span class="comment">    StartContext - Startup context, contains a IOP_APC_HARD_ERROR_PACKET.</span>
06885 <span class="comment"></span>
06886 <span class="comment">Return Value:</span>
06887 <span class="comment"></span>
06888 <span class="comment">    None.</span>
06889 <span class="comment"></span>
06890 <span class="comment">--*/</span>
06891 
06892 {
06893     HANDLE thread;
06894     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
06895 
06896     <span class="comment">//</span>
06897     <span class="comment">//  Create the hard error pop-up thread.  If for whatever reason we</span>
06898     <span class="comment">//  can't do this then just complete the Irp with the error.</span>
06899     <span class="comment">//</span>
06900 
06901     status = <a class="code" href="../../d2/d8/ps_2create_8c.html#a11">PsCreateSystemThread</a>( &amp;thread,
06902                                    0,
06903                                    (POBJECT_ATTRIBUTES)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
06904                                    (HANDLE)0,
06905                                    (PCLIENT_ID)<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
06906                                    <a class="code" href="../../d2/d4/internal_8c.html#a23">IopApcHardError</a>,
06907                                    StartContext );
06908 
06909     <span class="keywordflow">if</span> ( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status ) ) {
06910 
06911 
06912         <a class="code" href="../../d0/d5/io_8h.html#a224">IoCompleteRequest</a>( ((<a class="code" href="../../d5/d0/struct__IOP__APC__HARD__ERROR__PACKET.html">PIOP_APC_HARD_ERROR_PACKET</a>)StartContext)-&gt;<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>,
06913                            <a class="code" href="../../d7/d8/exboosts_8h.html#a5">IO_DISK_INCREMENT</a> );
06914         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( StartContext );
06915         <span class="keywordflow">return</span>;
06916     }
06917 
06918     <span class="comment">//</span>
06919     <span class="comment">//  Close thread handle</span>
06920     <span class="comment">//</span>
06921 
06922     ZwClose(thread);
06923 }
06924 
06925 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l06926"></a><a class="code" href="../../d0/d6/iop_8h.html#a211">06926</a> <a class="code" href="../../d0/d6/iop_8h.html#a211">IopSynchronousApiServiceTail</a>(
06927     IN NTSTATUS ReturnedStatus,
06928     IN <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> Event,
06929     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
06930     IN KPROCESSOR_MODE RequestorMode,
06931     IN PIO_STATUS_BLOCK LocalIoStatus,
06932     OUT PIO_STATUS_BLOCK IoStatusBlock
06933     )
06934 
06935 <span class="comment">/*++</span>
06936 <span class="comment"></span>
06937 <span class="comment">Routine Description:</span>
06938 <span class="comment"></span>
06939 <span class="comment">    This routine is invoked when a synchronous API is invoked for a file</span>
06940 <span class="comment">    that has been opened for asynchronous I/O.  This function synchronizes</span>
06941 <span class="comment">    the completion of the I/O operation on the file.</span>
06942 <span class="comment"></span>
06943 <span class="comment">Arguments:</span>
06944 <span class="comment"></span>
06945 <span class="comment">    ReturnedStatus - Supplies the status that was returned from the call to</span>
06946 <span class="comment">        IoCallDriver.</span>
06947 <span class="comment"></span>
06948 <span class="comment">    Event - Address of the allocated kernel event to be used for synchronization</span>
06949 <span class="comment">        of the I/O operation.</span>
06950 <span class="comment"></span>
06951 <span class="comment">    Irp - Address of the I/O Request Packet submitted to the driver.</span>
06952 <span class="comment"></span>
06953 <span class="comment">    RequestorMode - Processor mode of the caller when the operation was</span>
06954 <span class="comment">        requested.</span>
06955 <span class="comment"></span>
06956 <span class="comment">    LocalIoStatus - Address of the I/O status block used to capture the final</span>
06957 <span class="comment">        status by the service itself.</span>
06958 <span class="comment"></span>
06959 <span class="comment">    IoStatusBlock - Address of the I/O status block supplied by the caller of</span>
06960 <span class="comment">        the system service.</span>
06961 <span class="comment"></span>
06962 <span class="comment">Return Value:</span>
06963 <span class="comment"></span>
06964 <span class="comment">    The function value is the final status of the operation.</span>
06965 <span class="comment"></span>
06966 <span class="comment"></span>
06967 <span class="comment">--*/</span>
06968 
06969 {
06970     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
06971 
06972     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
06973 
06974     <span class="comment">//</span>
06975     <span class="comment">// This is a normal synchronous I/O operation, as opposed to a</span>
06976     <span class="comment">// serialized synchronous I/O operation.  For this case, wait for</span>
06977     <span class="comment">// the local event and copy the final status information back to</span>
06978     <span class="comment">// the caller.</span>
06979     <span class="comment">//</span>
06980 
06981     status = ReturnedStatus;
06982 
06983     <span class="keywordflow">if</span> (status == STATUS_PENDING) {
06984 
06985         status = <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>,
06986                                         <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
06987                                         RequestorMode,
06988                                         <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
06989                                         (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
06990 
06991         <span class="keywordflow">if</span> (status == STATUS_ALERTED || status == STATUS_USER_APC) {
06992 
06993             <span class="comment">//</span>
06994             <span class="comment">// The wait request has ended either because the thread was</span>
06995             <span class="comment">// alerted or an APC was queued to this thread, because of</span>
06996             <span class="comment">// thread rundown or CTRL/C processing.  In either case, try</span>
06997             <span class="comment">// to bail out of this I/O request carefully so that the IRP</span>
06998             <span class="comment">// completes before this routine exists or the event will not</span>
06999             <span class="comment">// be around to set to the Signaled state.</span>
07000             <span class="comment">//</span>
07001 
07002             <a class="code" href="../../d0/d6/iop_8h.html#a151">IopCancelAlertedRequest</a>( <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
07003 
07004         }
07005 
07006         status = LocalIoStatus-&gt;Status;
07007     }
07008 
07009     <span class="keywordflow">try</span> {
07010 
07011         *IoStatusBlock = *LocalIoStatus;
07012 
07013     } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
07014 
07015         <span class="comment">//</span>
07016         <span class="comment">// An exception occurred attempting to write the caller's I/O</span>
07017         <span class="comment">// status block.  Simply change the final status of the operation</span>
07018         <span class="comment">// to the exception code.</span>
07019         <span class="comment">//</span>
07020 
07021         status = GetExceptionCode();
07022     }
07023 
07024     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a> );
07025 
07026     <span class="keywordflow">return</span> status;
07027 }
07028 
07029 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l07030"></a><a class="code" href="../../d0/d6/iop_8h.html#a212">07030</a> <a class="code" href="../../d0/d6/iop_8h.html#a212">IopSynchronousServiceTail</a>(
07031     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
07032     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
07033     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
07034     IN BOOLEAN DeferredIoCompletion,
07035     IN KPROCESSOR_MODE RequestorMode,
07036     IN BOOLEAN SynchronousIo,
07037     IN <a class="code" href="../../d0/d6/iop_8h.html#a25">TRANSFER_TYPE</a> TransferType
07038     )
07039 
07040 <span class="comment">/*++</span>
07041 <span class="comment"></span>
07042 <span class="comment">Routine Description:</span>
07043 <span class="comment"></span>
07044 <span class="comment">    This routine is invoked to complete the operation of a system service.</span>
07045 <span class="comment">    It queues the IRP to the thread's queue, updates the transfer count,</span>
07046 <span class="comment">    calls the driver, and finally synchronizes completion of the I/O.</span>
07047 <span class="comment"></span>
07048 <span class="comment">Arguments:</span>
07049 <span class="comment"></span>
07050 <span class="comment">    DeviceObject - Device on which the I/O is to occur.</span>
07051 <span class="comment"></span>
07052 <span class="comment">    Irp - I/O Request Packet representing the I/O operation.</span>
07053 <span class="comment"></span>
07054 <span class="comment">    FileObject - File object for this open instantiation.</span>
07055 <span class="comment"></span>
07056 <span class="comment">    DeferredIoCompletion - Indicates whether deferred completion is possible.</span>
07057 <span class="comment"></span>
07058 <span class="comment">    RequestorMode - Mode in which request was made.</span>
07059 <span class="comment"></span>
07060 <span class="comment">    SynchronousIo - Indicates whether the operation is to be synchronous.</span>
07061 <span class="comment"></span>
07062 <span class="comment">    TransferType - Type of transfer being performed: read, write, or other.</span>
07063 <span class="comment"></span>
07064 <span class="comment">Return Value:</span>
07065 <span class="comment"></span>
07066 <span class="comment">    The function value is the final status of the operation.</span>
07067 <span class="comment"></span>
07068 <span class="comment">--*/</span>
07069 
07070 {
07071     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
07072 
07073     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
07074 
07075     <span class="comment">//</span>
07076     <span class="comment">// Insert the packet at the head of the IRP list for the thread.</span>
07077     <span class="comment">//</span>
07078 
07079     <a class="code" href="../../d0/d6/iop_8h.html#a21">IopQueueThreadIrp</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
07080 
07081     <span class="comment">//</span>
07082     <span class="comment">// Update the operation count statistic for the current process.</span>
07083     <span class="comment">//</span>
07084 
07085     <span class="keywordflow">switch</span>( TransferType ) {
07086 
07087     <span class="keywordflow">case</span> <a class="code" href="../../d0/d6/iop_8h.html#a240a138">ReadTransfer</a>:
07088         <a class="code" href="../../d4/d6/iosubs_8c.html#a130">IopUpdateReadOperationCount</a>();
07089         <span class="keywordflow">break</span>;
07090 
07091     <span class="keywordflow">case</span> <a class="code" href="../../d0/d6/iop_8h.html#a240a139">WriteTransfer</a>:
07092         <a class="code" href="../../d4/d6/iosubs_8c.html#a131">IopUpdateWriteOperationCount</a>();
07093         <span class="keywordflow">break</span>;
07094 
07095     <span class="keywordflow">case</span> <a class="code" href="../../d0/d6/iop_8h.html#a240a140">OtherTransfer</a>:
07096         <a class="code" href="../../d4/d6/iosubs_8c.html#a129">IopUpdateOtherOperationCount</a>();
07097         <span class="keywordflow">break</span>;
07098     }
07099 
07100     <span class="comment">//</span>
07101     <span class="comment">// Now simply invoke the driver at its dispatch entry with the IRP.</span>
07102     <span class="comment">//</span>
07103 
07104     status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( DeviceObject, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
07105 
07106     <span class="comment">//</span>
07107     <span class="comment">// If deferred I/O completion is possible, check for pending returned</span>
07108     <span class="comment">// from the driver.  If the driver did not return pending, then the</span>
07109     <span class="comment">// packet has not actually been completed yet, so complete it here.</span>
07110     <span class="comment">//</span>
07111 
07112     <span class="keywordflow">if</span> (DeferredIoCompletion) {
07113 
07114         <span class="keywordflow">if</span> (status != STATUS_PENDING) {
07115 
07116             <span class="comment">//</span>
07117             <span class="comment">// The I/O operation was completed without returning a status of</span>
07118             <span class="comment">// pending.  This means that at this point, the IRP has not been</span>
07119             <span class="comment">// fully completed.  Complete it now.</span>
07120             <span class="comment">//</span>
07121 
07122             <a class="code" href="../../d0/d9/ntosdef_8h.html#a41">PKNORMAL_ROUTINE</a> normalRoutine;
07123             PVOID normalContext;
07124             KIRQL irql;
07125 
07126             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( !<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o11">PendingReturned</a> );
07127 
07128             <a class="code" href="../../d9/d5/verifier_8c.html#a116">KeRaiseIrql</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a52">APC_LEVEL</a>, &amp;irql );
07129             <a class="code" href="../../d0/d6/iop_8h.html#a157">IopCompleteRequest</a>( &amp;<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Apc,
07130                                 &amp;normalRoutine,
07131                                 &amp;normalContext,
07132                                 (PVOID *) &amp;FileObject,
07133                                 &amp;normalContext );
07134             <a class="code" href="../../d9/d5/verifier_8c.html#a117">KeLowerIrql</a>( irql );
07135         }
07136     }
07137 
07138     <span class="comment">//</span>
07139     <span class="comment">// If this operation was a synchronous I/O operation, check the return</span>
07140     <span class="comment">// status to determine whether or not to wait on the file object.  If</span>
07141     <span class="comment">// the file object is to be waited on, wait for the operation to complete</span>
07142     <span class="comment">// and obtain the final status from the file object itself.</span>
07143     <span class="comment">//</span>
07144 
07145     <span class="keywordflow">if</span> (<a class="code" href="../../d2/d4/internal_8c.html#a2">SynchronousIo</a>) {
07146 
07147         <span class="keywordflow">if</span> (status == STATUS_PENDING) {
07148 
07149             status = <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;FileObject-&gt;Event,
07150                                             <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
07151                                             RequestorMode,
07152                                             (BOOLEAN) ((FileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a152">FO_ALERTABLE_IO</a>) != 0),
07153                                             (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
07154 
07155             <span class="keywordflow">if</span> (status == STATUS_ALERTED || status == STATUS_USER_APC) {
07156 
07157                 <span class="comment">//</span>
07158                 <span class="comment">// The wait request has ended either because the thread was alerted</span>
07159                 <span class="comment">// or an APC was queued to this thread, because of thread rundown or</span>
07160                 <span class="comment">// CTRL/C processing.  In either case, try to bail out of this I/O</span>
07161                 <span class="comment">// request carefully so that the IRP completes before this routine</span>
07162                 <span class="comment">// exists so that synchronization with the file object will remain</span>
07163                 <span class="comment">// intact.</span>
07164                 <span class="comment">//</span>
07165 
07166                 <a class="code" href="../../d0/d6/iop_8h.html#a151">IopCancelAlertedRequest</a>( &amp;FileObject-&gt;Event, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
07167 
07168             }
07169 
07170             status = FileObject-&gt;FinalStatus;
07171 
07172         }
07173 
07174         <a class="code" href="../../d0/d6/iop_8h.html#a22">IopReleaseFileObjectLock</a>( FileObject );
07175 
07176     }
07177 
07178     <span class="keywordflow">return</span> status;
07179 }
07180 
07181 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l07182"></a><a class="code" href="../../d0/d6/iop_8h.html#a213">07182</a> <a class="code" href="../../d0/d6/iop_8h.html#a213">IopTimerDispatch</a>(
07183     IN <a class="code" href="../../d1/d6/struct__KDPC.html">PKDPC</a> Dpc,
07184     IN PVOID DeferredContext,
07185     IN PVOID SystemArgument1,
07186     IN PVOID SystemArgument2
07187     )
07188 
07189 <span class="comment">/*++</span>
07190 <span class="comment"></span>
07191 <span class="comment">Routine Description:</span>
07192 <span class="comment"></span>
07193 <span class="comment">    This routine scans the I/O system timer database and invokes each driver</span>
07194 <span class="comment">    that has enabled a timer in the list, once every second.</span>
07195 <span class="comment"></span>
07196 <span class="comment">Arguments:</span>
07197 <span class="comment"></span>
07198 <span class="comment">    Dpc - Supplies a pointer to a control object of type DPC.</span>
07199 <span class="comment"></span>
07200 <span class="comment">    DeferredContext - Optional deferred context;  not used.</span>
07201 <span class="comment"></span>
07202 <span class="comment">    SystemArgument1 - Optional argument 1;  not used.</span>
07203 <span class="comment"></span>
07204 <span class="comment">    SystemArgument2 - Optional argument 2;  not used.</span>
07205 <span class="comment"></span>
07206 <span class="comment">Return Value:</span>
07207 <span class="comment"></span>
07208 <span class="comment">    None.</span>
07209 <span class="comment"></span>
07210 <span class="comment">--*/</span>
07211 
07212 {
07213     PLIST_ENTRY timerEntry;
07214     <a class="code" href="../../d4/d9/struct__IO__TIMER.html">PIO_TIMER</a> timer;
07215     LARGE_INTEGER deltaTime;
07216     KIRQL irql;
07217     ULONG i;
07218 
07219     UNREFERENCED_PARAMETER( Dpc );
07220     UNREFERENCED_PARAMETER( DeferredContext );
07221     UNREFERENCED_PARAMETER( SystemArgument1 );
07222     UNREFERENCED_PARAMETER( SystemArgument2 );
07223 
07224     <span class="comment">//</span>
07225     <span class="comment">// Check to see whether or not there are any timers in the queue that</span>
07226     <span class="comment">// have been enabled.  If so, then walk the list and invoke all of the</span>
07227     <span class="comment">// drivers' routines.  Note that if the counter changes, which it can</span>
07228     <span class="comment">// because the spin lock is not owned, then a timer routine may be</span>
07229     <span class="comment">// missed.  However, this is acceptable, since the driver inserting the</span>
07230     <span class="comment">// entry could be context switched away from, etc.  Therefore, this is</span>
07231     <span class="comment">// not a critical resource for the most part.</span>
07232     <span class="comment">//</span>
07233 
07234     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d5/iodata_8c.html#a31">IopTimerCount</a>) {
07235 
07236         <span class="comment">//</span>
07237         <span class="comment">// There is at least one timer entry in the queue that is enabled.</span>
07238         <span class="comment">// Walk the queue and invoke each specified timer routine.</span>
07239         <span class="comment">//</span>
07240 
07241         ExAcquireSpinLock( &amp;<a class="code" href="../../d4/d4/alpha_2splocks_8c.html#a8">IopTimerLock</a>, &amp;irql );
07242         i = <a class="code" href="../../d3/d5/iodata_8c.html#a31">IopTimerCount</a>;
07243         timerEntry = <a class="code" href="../../d3/d5/iodata_8c.html#a28">IopTimerQueueHead</a>.Flink;
07244 
07245         <span class="comment">//</span>
07246         <span class="comment">// For each entry found that is enabled, invoke the driver's routine</span>
07247         <span class="comment">// with its specified context parameter.  The local count is used</span>
07248         <span class="comment">// to abort the queue traversal when there are more entries in the</span>
07249         <span class="comment">// queue, but they are not enabled.</span>
07250         <span class="comment">//</span>
07251 
07252         <span class="keywordflow">for</span> (timerEntry = <a class="code" href="../../d3/d5/iodata_8c.html#a28">IopTimerQueueHead</a>.Flink;
07253              (timerEntry != &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a28">IopTimerQueueHead</a>) &amp;&amp; i;
07254              timerEntry = timerEntry-&gt;Flink ) {
07255 
07256             timer = CONTAINING_RECORD( timerEntry, <a class="code" href="../../d4/d9/struct__IO__TIMER.html">IO_TIMER</a>, TimerList );
07257 
07258             <span class="keywordflow">if</span> (timer-&gt;<a class="code" href="../../d4/d9/struct__IO__TIMER.html#o1">TimerFlag</a>) {
07259                 timer-&gt;<a class="code" href="../../d4/d9/struct__IO__TIMER.html#o3">TimerRoutine</a>( timer-&gt;<a class="code" href="../../d4/d9/struct__IO__TIMER.html#o5">DeviceObject</a>, timer-&gt;<a class="code" href="../../d4/d9/struct__IO__TIMER.html#o4">Context</a> );
07260                 i--;
07261             }
07262         }
07263         ExReleaseSpinLock( &amp;<a class="code" href="../../d4/d4/alpha_2splocks_8c.html#a8">IopTimerLock</a>, irql );
07264     }
07265 }
07266 
07267 
07268 
07269 
07270 
07271 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l07272"></a><a class="code" href="../../d0/d6/iop_8h.html#a214">07272</a> <a class="code" href="../../d0/d6/iop_8h.html#a214">IopTrackLink</a>(
07273     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
07274     IN OUT PIO_STATUS_BLOCK IoStatusBlock,
07275     IN PFILE_TRACKING_INFORMATION FileInformation,
07276     IN ULONG Length,
07277     IN <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> Event,
07278     IN KPROCESSOR_MODE RequestorMode
07279     )
07280 
07281 <span class="comment">/*++</span>
07282 <span class="comment"></span>
07283 <span class="comment">Routine Description:</span>
07284 <span class="comment"></span>
07285 <span class="comment">    This routine is invoked to track a link.  It tracks the source file's Object</span>
07286 <span class="comment">    ID to the target file so that links to the source will follow to the new</span>
07287 <span class="comment">    location of the target.</span>
07288 <span class="comment"></span>
07289 <span class="comment">Arguments:</span>
07290 <span class="comment"></span>
07291 <span class="comment">    FileObject - Supplies a pointer to the referenced source file object.</span>
07292 <span class="comment"></span>
07293 <span class="comment">    IoStatusBlock - Pointer to the caller's I/O status block.</span>
07294 <span class="comment"></span>
07295 <span class="comment">    FileInformation - A buffer containing the parameters for the move that was</span>
07296 <span class="comment">        performed.</span>
07297 <span class="comment"></span>
07298 <span class="comment">    Length - Specifies the length of the FileInformation buffer.</span>
07299 <span class="comment"></span>
07300 <span class="comment">    Event - An event to be set to the Signaled state once the operation has been</span>
07301 <span class="comment">        performed, provided it was successful.</span>
07302 <span class="comment"></span>
07303 <span class="comment">    RequestorMode - Requestor mode of the caller.</span>
07304 <span class="comment"></span>
07305 <span class="comment">N.B. - Note that the presence of an event indicates that the source file was</span>
07306 <span class="comment">    opened for asynchronous I/O, otherwise it was opened for synchronous I/O.</span>
07307 <span class="comment"></span>
07308 <span class="comment">Return Value:</span>
07309 <span class="comment"></span>
07310 <span class="comment">    The status returned is the final completion status of the operation.</span>
07311 <span class="comment"></span>
07312 <span class="comment"></span>
07313 <span class="comment">--*/</span>
07314 
07315 {
07316     PFILE_TRACKING_INFORMATION trackingInfo = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
07317     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> dstFileObject = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
07318     <a class="code" href="../../d2/d4/internal_8c.html#a5">FILE_VOLUMEID_WITH_TYPE</a> SourceVolumeId;
07319     FILE_OBJECTID_BUFFER SourceObjectId;
07320     FILE_OBJECTID_BUFFER NormalizedObjectId;
07321     FILE_OBJECTID_BUFFER CrossVolumeObjectId;
07322     <a class="code" href="../../d2/d4/internal_8c.html#a5">FILE_VOLUMEID_WITH_TYPE</a> TargetVolumeId;
07323     FILE_OBJECTID_BUFFER TargetObjectId;
07324     <a class="code" href="../../d1/d2/struct__TRACKING__BUFFER.html">TRACKING_BUFFER</a> trackingBuffer;
07325     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
07326 
07327     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
07328 
07329     <span class="comment">//</span>
07330     <span class="comment">// Begin by capturing the caller's buffer, if required.</span>
07331     <span class="comment">//</span>
07332 
07333     <span class="keywordflow">if</span> (RequestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
07334 
07335         <span class="keywordflow">try</span> {
07336             trackingInfo = <a class="code" href="../../d5/d5/cc_8h.html#a11">ExAllocatePoolWithQuota</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>,
07337                                                     Length );
07338             RtlCopyMemory( trackingInfo, FileInformation, Length );
07339 
07340             <span class="keywordflow">if</span> (!trackingInfo-&gt;DestinationFile ||
07341                ((Length - FIELD_OFFSET( FILE_TRACKING_INFORMATION, ObjectInformation )) 
07342                 &lt; trackingInfo-&gt;ObjectInformationLength)) {
07343                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( trackingInfo );
07344                 <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
07345             }
07346 
07347         } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
07348 
07349             <span class="comment">//</span>
07350             <span class="comment">// An exception was incurred while allocating the intermediary</span>
07351             <span class="comment">// system buffer or while copying the caller's data into the</span>
07352             <span class="comment">// buffer.  Cleanup and return an appropriate error status code.</span>
07353             <span class="comment">//</span>
07354 
07355             <span class="keywordflow">if</span> (trackingInfo) {
07356                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( trackingInfo );
07357             }
07358 
07359             <span class="keywordflow">return</span> GetExceptionCode();
07360         }
07361     } <span class="keywordflow">else</span> {
07362         trackingInfo = FileInformation;
07363     }
07364 
07365     <span class="comment">//</span>
07366     <span class="comment">// If a destination file handle was specified, convert it to a pointer to</span>
07367     <span class="comment">// a file object.</span>
07368     <span class="comment">//</span>
07369 
07370     <span class="keywordflow">if</span> (trackingInfo-&gt;DestinationFile) {
07371         status = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a>( trackingInfo-&gt;DestinationFile,
07372                                             FILE_WRITE_DATA,
07373                                             <a class="code" href="../../d5/d8/fssup_8c.html#a3">IoFileObjectType</a>,
07374                                             RequestorMode,
07375                                             (PVOID *) &amp;dstFileObject,
07376                                             <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
07377         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
07378             <span class="keywordflow">if</span> (RequestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
07379                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( trackingInfo );
07380             }
07381             <span class="keywordflow">return</span> status;
07382         }
07383     }
07384 
07385     <span class="keywordflow">try</span> {
07386 
07387         <span class="comment">//</span>
07388         <span class="comment">// Determine whether this is a local or a remote link tracking</span>
07389         <span class="comment">// operation.</span>
07390         <span class="comment">//</span>
07391 
07392         <span class="keywordflow">if</span> (<a class="code" href="../../d2/d4/internal_8c.html#a0">IsFileLocal</a>( FileObject )) {
07393 
07394             <span class="comment">//</span>
07395             <span class="comment">// The source file, i.e., the one being moved, is a file local to</span>
07396             <span class="comment">// this system.  Determine the form of the target file and track</span>
07397             <span class="comment">// it accordingly.</span>
07398             <span class="comment">//</span>
07399 
07400             <span class="keywordflow">if</span> (trackingInfo-&gt;DestinationFile) {
07401 
07402                 <span class="keywordflow">if</span> (<a class="code" href="../../d2/d4/internal_8c.html#a0">IsFileLocal</a>( dstFileObject )) {
07403 
07404                     BOOLEAN IdSetOnTarget = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
07405 
07406                     <span class="comment">//</span>
07407                     <span class="comment">// The target file is specified as a handle and it is local.</span>
07408                     <span class="comment">// Simply perform the query and set locally.  Note that if</span>
07409                     <span class="comment">// the source file does not have an object ID, then no</span>
07410                     <span class="comment">// tracking will be performed, but it will appear as if the</span>
07411                     <span class="comment">// operation worked.</span>
07412                     <span class="comment">//</span>
07413 
07414                     status = <a class="code" href="../../d0/d6/iop_8h.html#a182">IopGetSetObjectId</a>( FileObject,
07415                                                 &amp;SourceObjectId,
07416                                                 <span class="keyword">sizeof</span>( SourceObjectId ),
07417                                                 FSCTL_GET_OBJECT_ID );
07418 
07419                     <span class="keywordflow">if</span> (status == STATUS_OBJECT_NAME_NOT_FOUND) {
07420                         <span class="keywordflow">return</span>(STATUS_SUCCESS);
07421                     }
07422 
07423                     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
07424                         <span class="keywordflow">return</span> status;
07425                     }
07426 
07427                     <span class="comment">//</span>
07428                     <span class="comment">// If the extended info field is zero then this file</span>
07429                     <span class="comment">// has no interesting tracking information.</span>
07430                     <span class="comment">//</span>
07431                     <span class="keywordflow">if</span> (<a class="code" href="../../d2/d7/string_8c.html#a17">RtlCompareMemoryUlong</a>(SourceObjectId.BirthObjectId,
07432                                        <span class="keyword">sizeof</span>(SourceObjectId.BirthObjectId),
07433                                        0) == <span class="keyword">sizeof</span>(SourceObjectId.BirthObjectId)) {
07434                             <span class="keywordflow">return</span> (STATUS_SUCCESS);
07435                     }
07436 
07437 
07438                     <span class="comment">//</span>
07439                     <span class="comment">// Get the volume ID of the source and destination</span>
07440                     <span class="comment">//</span>
07441 
07442                     status = <a class="code" href="../../d0/d6/iop_8h.html#a184">IopGetVolumeId</a>( dstFileObject,
07443                                              &amp;TargetVolumeId,
07444                                              <span class="keyword">sizeof</span>( TargetVolumeId ) );
07445                     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
07446                         <span class="keywordflow">return</span> status;
07447                     }
07448 
07449                     status = <a class="code" href="../../d0/d6/iop_8h.html#a184">IopGetVolumeId</a>( FileObject,
07450                                              &amp;SourceVolumeId,
07451                                              <span class="keyword">sizeof</span>( SourceVolumeId ) );
07452                     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
07453                         <span class="keywordflow">return</span> status;
07454                     }
07455 
07456                     <span class="comment">//</span>
07457                     <span class="comment">// Delete the ID from the source now, since the</span>
07458                     <span class="comment">// target may be on the same volume.  If there's a</span>
07459                     <span class="comment">// subsequent error, we'll try to restore it.</span>
07460                     <span class="comment">//</span>
07461 
07462                     status = <a class="code" href="../../d0/d6/iop_8h.html#a182">IopGetSetObjectId</a>( FileObject,
07463                                                 <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
07464                                                 0,
07465                                                 FSCTL_DELETE_OBJECT_ID );
07466                     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
07467                         <span class="keywordflow">return</span> status;
07468                     }
07469 
07470 
07471                     <span class="comment">//</span>
07472                     <span class="comment">// Set the ID on the target.  If it's a cross-volume</span>
07473                     <span class="comment">// move, set the bit that indicates same.</span>
07474                     <span class="comment">//</span>
07475 
07476                     CrossVolumeObjectId = TargetObjectId = SourceObjectId;
07477                     <span class="keywordflow">if</span>( !RtlEqualMemory( &amp;TargetVolumeId.VolumeId[0],
07478                                          &amp;SourceVolumeId.VolumeId[0],
07479                                          <span class="keyword">sizeof</span>(SourceVolumeId.VolumeId) )) {
07480                         CrossVolumeObjectId.BirthVolumeId[0] |= 1;
07481                     }
07482 
07483                     status = <a class="code" href="../../d0/d6/iop_8h.html#a182">IopGetSetObjectId</a>( dstFileObject,
07484                                                 &amp;CrossVolumeObjectId,
07485                                                 <span class="keyword">sizeof</span>( CrossVolumeObjectId ),
07486                                                 FSCTL_SET_OBJECT_ID );
07487 
07488                     <span class="keywordflow">if</span>( status == STATUS_DUPLICATE_NAME ||
07489                         status == STATUS_OBJECT_NAME_COLLISION ) {
07490 
07491                         <span class="comment">// This object ID is already in use on the target volume,</span>
07492                         <span class="comment">// or the dest file already has an object ID.</span>
07493                         <span class="comment">// Get the file's ID (or have NTFS generate a new one).</span>
07494 
07495                         status = <a class="code" href="../../d0/d6/iop_8h.html#a182">IopGetSetObjectId</a>( dstFileObject,
07496                                                     &amp;TargetObjectId,
07497                                                     <span class="keyword">sizeof</span>(TargetObjectId),
07498                                                     FSCTL_CREATE_OR_GET_OBJECT_ID );
07499                         <span class="keywordflow">if</span>( <a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status) ) {
07500 
07501                             <span class="comment">// Write the birth ID</span>
07502 
07503                             status = <a class="code" href="../../d0/d6/iop_8h.html#a182">IopGetSetObjectId</a>( dstFileObject,
07504                                                         &amp;CrossVolumeObjectId.ExtendedInfo[0],
07505                                                         <span class="keyword">sizeof</span>( CrossVolumeObjectId.ExtendedInfo ),
07506                                                         FSCTL_SET_OBJECT_ID_EXTENDED );
07507                         }
07508                     }
07509 
07510                     <span class="keywordflow">if</span>( <a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status) ) {
07511 
07512                         IdSetOnTarget = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
07513 
07514                         <span class="comment">// If this was a cross-volume move, notify the tracking service.</span>
07515 
07516                         <span class="keywordflow">if</span>( !RtlEqualMemory( &amp;TargetVolumeId.VolumeId[0],
07517                                              &amp;SourceVolumeId.VolumeId[0],
07518                                              <span class="keyword">sizeof</span>(SourceVolumeId.VolumeId) )) {
07519 
07520                             <a class="code" href="../../d2/d4/internal_8c.html#a15">IopMarshalIds</a>( &amp;trackingBuffer, &amp;TargetVolumeId, &amp;TargetObjectId, trackingInfo );
07521 
07522                             <span class="comment">// Bit 0 must be reset before notifying tracking service</span>
07523                             NormalizedObjectId = SourceObjectId;
07524                             NormalizedObjectId.BirthVolumeId[0] &amp;= 0xfe;
07525 
07526                             status = <a class="code" href="../../d2/d4/internal_8c.html#a62">IopSendMessageToTrackService</a>( &amp;SourceVolumeId,
07527                                                                    &amp;NormalizedObjectId,
07528                                                                    &amp;trackingBuffer.<a class="code" href="../../d1/d2/struct__TRACKING__BUFFER.html#o0">TrackingInformation</a> );
07529                         }
07530                     }
07531 
07532                     <span class="comment">//</span>
07533                     <span class="comment">// If there was an error after the ObjectID was deleted</span>
07534                     <span class="comment">// from the source.  Try to restore it before returning.</span>
07535                     <span class="comment">//</span>
07536 
07537                     <span class="keywordflow">if</span>( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status) ) {
07538                         <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> statusT = STATUS_SUCCESS;
07539 
07540                         <span class="keywordflow">if</span>( IdSetOnTarget ) {
07541 
07542                             <span class="keywordflow">if</span>( RtlEqualMemory( &amp;TargetObjectId.ObjectId,
07543                                                 &amp;SourceObjectId.ObjectId,
07544                                                 <span class="keyword">sizeof</span>(TargetObjectId.ObjectId) )) {
07545 
07546                                 <span class="comment">// This ID was set with FSCTL_SET_OBJECT_ID</span>
07547                                 statusT = <a class="code" href="../../d0/d6/iop_8h.html#a182">IopGetSetObjectId</a>( dstFileObject,
07548                                                              <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
07549                                                              0,
07550                                                              FSCTL_DELETE_OBJECT_ID );
07551 
07552                             } <span class="keywordflow">else</span> {
07553 
07554                                 <span class="comment">// Restore the target's extended data.</span>
07555 
07556                                 statusT = <a class="code" href="../../d0/d6/iop_8h.html#a182">IopGetSetObjectId</a>( dstFileObject,
07557                                                              &amp;TargetObjectId.ExtendedInfo[0],
07558                                                              <span class="keyword">sizeof</span>(TargetObjectId.ExtendedInfo),
07559                                                              FSCTL_SET_OBJECT_ID_EXTENDED );
07560                             }
07561                         }
07562 
07563                         <span class="keywordflow">if</span>( <a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( statusT )) {
07564 
07565                             <a class="code" href="../../d0/d6/iop_8h.html#a182">IopGetSetObjectId</a>( FileObject,
07566                                                &amp;SourceObjectId,
07567                                                <span class="keyword">sizeof</span>(SourceObjectId),
07568                                                FSCTL_SET_OBJECT_ID );
07569                         }
07570 
07571                         <span class="keywordflow">return</span> status;
07572                     }
07573 
07574 
07575                 } <span class="keywordflow">else</span> {    <span class="comment">// if (IsFileLocal( dstFileObject ))</span>
07576 
07577                     <span class="comment">//</span>
07578                     <span class="comment">// The source file is local, but the destination file object</span>
07579                     <span class="comment">// is remote.  For this case query the target file's object</span>
07580                     <span class="comment">// ID and notify the link tracking system that the file has</span>
07581                     <span class="comment">// been moved across systems.</span>
07582                     <span class="comment">//</span>
07583 
07584                     <span class="comment">//</span>
07585                     <span class="comment">// Begin by ensuring that the source file has an object ID</span>
07586                     <span class="comment">// already.  If not, then just make it appear as if the</span>
07587                     <span class="comment">// operation worked.</span>
07588                     <span class="comment">//</span>
07589 
07590                     status = <a class="code" href="../../d0/d6/iop_8h.html#a182">IopGetSetObjectId</a>( FileObject,
07591                                                 &amp;SourceObjectId,
07592                                                 <span class="keyword">sizeof</span>( SourceObjectId ),
07593                                                 FSCTL_GET_OBJECT_ID );
07594                     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
07595                         <span class="keywordflow">return</span> STATUS_SUCCESS;
07596                     }
07597 
07598 
07599                     <span class="comment">//</span>
07600                     <span class="comment">// If the extended info field is zero then this file</span>
07601                     <span class="comment">// has no interesting tracking information.</span>
07602                     <span class="comment">//</span>
07603                     <span class="keywordflow">if</span> (<a class="code" href="../../d2/d7/string_8c.html#a17">RtlCompareMemoryUlong</a>(&amp;SourceObjectId.BirthObjectId,
07604                                        <span class="keyword">sizeof</span>(SourceObjectId.BirthObjectId),
07605                                        0) == <span class="keyword">sizeof</span>(SourceObjectId.BirthObjectId)) {
07606                             <span class="keywordflow">return</span> (STATUS_SUCCESS);
07607                     }
07608 
07609                     <span class="comment">//</span>
07610                     <span class="comment">// Query the volume ID of the target.</span>
07611                     <span class="comment">//</span>
07612 
07613                     status = <a class="code" href="../../d0/d6/iop_8h.html#a182">IopGetSetObjectId</a>( dstFileObject,
07614                                                 &amp;TargetVolumeId,
07615                                                 <span class="keyword">sizeof</span>( <a class="code" href="../../d2/d4/internal_8c.html#a5">FILE_VOLUMEID_WITH_TYPE</a> ),
07616                                                 FSCTL_LMR_GET_LINK_TRACKING_INFORMATION );
07617                     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
07618                         <span class="keywordflow">return</span> status;
07619                     }
07620 
07621                     <span class="comment">//</span>
07622                     <span class="comment">// Query the object ID of the target.</span>
07623                     <span class="comment">//</span>
07624 
07625                     status = <a class="code" href="../../d0/d6/iop_8h.html#a182">IopGetSetObjectId</a>( dstFileObject,
07626                                                 &amp;TargetObjectId,
07627                                                 <span class="keyword">sizeof</span>( TargetObjectId ),
07628                                                 FSCTL_CREATE_OR_GET_OBJECT_ID );
07629                     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
07630                         <span class="keywordflow">return</span> status;
07631                     }
07632 
07633                     <span class="comment">//</span>
07634                     <span class="comment">// Notify the tracking system of the move.</span>
07635                     <span class="comment">//</span>
07636 
07637                     <a class="code" href="../../d2/d4/internal_8c.html#a15">IopMarshalIds</a>( &amp;trackingBuffer, &amp;TargetVolumeId, &amp;TargetObjectId, trackingInfo );
07638                     status = <a class="code" href="../../d0/d6/iop_8h.html#a214">IopTrackLink</a>( FileObject,
07639                                            IoStatusBlock,
07640                                            &amp;trackingBuffer.<a class="code" href="../../d1/d2/struct__TRACKING__BUFFER.html#o0">TrackingInformation</a>,
07641                                            FIELD_OFFSET( FILE_TRACKING_INFORMATION,
07642                                                 ObjectInformation ) +
07643                                                     trackingBuffer.<a class="code" href="../../d1/d2/struct__TRACKING__BUFFER.html#o0">TrackingInformation</a>.ObjectInformationLength,
07644                                            <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>,
07645                                            <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a> );
07646                     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
07647                         <span class="keywordflow">return</span> status;
07648                     }
07649 
07650                     <span class="comment">//</span>
07651                     <span class="comment">// Delete the ID from the source</span>
07652                     <span class="comment">//</span>
07653 
07654                     status = <a class="code" href="../../d0/d6/iop_8h.html#a182">IopGetSetObjectId</a>( FileObject,
07655                                                 <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
07656                                                 0,
07657                                                 FSCTL_DELETE_OBJECT_ID );
07658                     <span class="keywordflow">if</span>( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
07659                         <span class="keywordflow">return</span> status;
07660                     }
07661 
07662                     <span class="comment">//</span>
07663                     <span class="comment">// Set the Birth ID on the target, turning on the bit</span>
07664                     <span class="comment">// that indicates that this file has been involved in a cross-</span>
07665                     <span class="comment">// volume move.</span>
07666                     <span class="comment">//</span>
07667 
07668                     CrossVolumeObjectId = SourceObjectId;
07669                     CrossVolumeObjectId.BirthVolumeId[0] |= 1;
07670 
07671                     status = <a class="code" href="../../d0/d6/iop_8h.html#a182">IopGetSetObjectId</a>( dstFileObject,
07672                                                 &amp;CrossVolumeObjectId.ExtendedInfo[0],
07673                                                 <span class="keyword">sizeof</span>( CrossVolumeObjectId.ExtendedInfo ),
07674                                                 FSCTL_SET_OBJECT_ID_EXTENDED );
07675                     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
07676 
07677                         <span class="comment">// Try to restore the source</span>
07678                         <a class="code" href="../../d0/d6/iop_8h.html#a182">IopGetSetObjectId</a>( FileObject,
07679                                            &amp;SourceObjectId,
07680                                            <span class="keyword">sizeof</span>(SourceObjectId),
07681                                            FSCTL_SET_OBJECT_ID );
07682                         <span class="keywordflow">return</span> status;
07683                     }
07684 
07685 
07686                 }   <span class="comment">// if (IsFileLocal( dstFileObject ))</span>
07687 
07688             } <span class="keywordflow">else</span> {    <span class="comment">// if (trackingInfo-&gt;DestinationFile)</span>
07689 
07690                 <span class="comment">//</span>
07691                 <span class="comment">// A destination file handle was not specified.  Simply query</span>
07692                 <span class="comment">// the source file's object ID and call the link tracking code.</span>
07693                 <span class="comment">// Note that the function input buffer contains the volume ID</span>
07694                 <span class="comment">// and file object ID of the target.  Note also that it is</span>
07695                 <span class="comment">// assumed that the source file has an object ID.</span>
07696                 <span class="comment">//</span>
07697 
07698                 status = <a class="code" href="../../d0/d6/iop_8h.html#a184">IopGetVolumeId</a>( FileObject,
07699                                          &amp;SourceVolumeId,
07700                                          <span class="keyword">sizeof</span>( SourceVolumeId ) );
07701                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
07702                     <span class="keywordflow">return</span> status;
07703                 }
07704 
07705                 status = <a class="code" href="../../d0/d6/iop_8h.html#a182">IopGetSetObjectId</a>( FileObject,
07706                                             &amp;SourceObjectId,
07707                                             <span class="keyword">sizeof</span>( SourceObjectId ),
07708                                             FSCTL_GET_OBJECT_ID );
07709                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
07710                     <span class="keywordflow">return</span> status;
07711                 }
07712 
07713                 <span class="comment">//</span>
07714                 <span class="comment">// If the extended info field is zero then this file</span>
07715                 <span class="comment">// has no interesting tracking information.</span>
07716                 <span class="comment">//</span>
07717                 <span class="keywordflow">if</span> (<a class="code" href="../../d2/d7/string_8c.html#a17">RtlCompareMemoryUlong</a>(SourceObjectId.BirthObjectId,
07718                                        <span class="keyword">sizeof</span>(SourceObjectId.BirthObjectId),
07719                                        0) == <span class="keyword">sizeof</span>(SourceObjectId.BirthObjectId)) {
07720                             <span class="keywordflow">return</span> (STATUS_SUCCESS);
07721                 }
07722                 <span class="comment">//</span>
07723                 <span class="comment">// Inform the user-mode link tracking service that the file</span>
07724                 <span class="comment">// has been moved.</span>
07725                 <span class="comment">//</span>
07726 
07727                 NormalizedObjectId = SourceObjectId;
07728                 NormalizedObjectId.BirthVolumeId[0] &amp;= 0xfe;
07729 
07730                 status = <a class="code" href="../../d2/d4/internal_8c.html#a62">IopSendMessageToTrackService</a>( &amp;SourceVolumeId,
07731                                                        &amp;NormalizedObjectId,
07732                                                        FileInformation );
07733                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
07734                     <span class="keywordflow">return</span> status;
07735                 }
07736 
07737             }   <span class="comment">// if (trackingInfo-&gt;DestinationFile) ... else</span>
07738 
07739         } <span class="keywordflow">else</span> {    <span class="comment">// if (IsFileLocal( FileObject ))</span>
07740 
07741             <span class="comment">//</span>
07742             <span class="comment">// The source file is remote.  For this case, remote the operation</span>
07743             <span class="comment">// to the system on which the source file is located.  Begin by</span>
07744             <span class="comment">// ensuring that the source file actually has an object ID.  If</span>
07745             <span class="comment">// not, then get out now since there is nothing to be done.</span>
07746             <span class="comment">//</span>
07747 
07748             status = <a class="code" href="../../d0/d6/iop_8h.html#a182">IopGetSetObjectId</a>( FileObject,
07749                                         &amp;SourceObjectId,
07750                                         <span class="keyword">sizeof</span>( SourceObjectId ),
07751                                         FSCTL_GET_OBJECT_ID );
07752 
07753             <span class="keywordflow">if</span> (status == STATUS_OBJECT_NAME_NOT_FOUND)
07754             {
07755                 <span class="keywordflow">return</span> STATUS_SUCCESS;
07756             }
07757 
07758             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
07759                 <span class="keywordflow">return</span> status;
07760             }
07761 
07762             <span class="comment">//</span>
07763             <span class="comment">// If the extended info field is zero then this file</span>
07764             <span class="comment">// has no interesting tracking information.</span>
07765             <span class="comment">//</span>
07766             <span class="keywordflow">if</span> (<a class="code" href="../../d2/d7/string_8c.html#a17">RtlCompareMemoryUlong</a>(SourceObjectId.BirthObjectId,
07767                                       <span class="keyword">sizeof</span>(SourceObjectId.BirthObjectId),
07768                                       0) == <span class="keyword">sizeof</span>(SourceObjectId.BirthObjectId)) {
07769                 <span class="keywordflow">return</span> (STATUS_SUCCESS);
07770             }
07771             <span class="keywordflow">if</span> (trackingInfo-&gt;DestinationFile) {
07772 
07773                 <span class="comment">//</span>
07774                 <span class="comment">// A handle was specified for the destination file.  Determine</span>
07775                 <span class="comment">// whether it is local or remote.  If remote and both handles</span>
07776                 <span class="comment">// refer to the same machine, then ship the entire API to that</span>
07777                 <span class="comment">// machine and have it perform the operation.</span>
07778                 <span class="comment">//</span>
07779                 <span class="comment">// Otherwise, query the target file's object ID, and then redo</span>
07780                 <span class="comment">// the operation.  This will cause the API to be remoted to the</span>
07781                 <span class="comment">// machine where the source file resides.</span>
07782                 <span class="comment">//</span>
07783 
07784                 <span class="keywordflow">if</span> (<a class="code" href="../../d2/d4/internal_8c.html#a0">IsFileLocal</a>( dstFileObject )) {
07785 
07786                     <span class="comment">//</span>
07787                     <span class="comment">// The source is remote and the destination is local, so</span>
07788                     <span class="comment">// query the object ID of the target and recursively track</span>
07789                     <span class="comment">// the link from the source file's remote node.</span>
07790                     <span class="comment">//</span>
07791 
07792                     status = <a class="code" href="../../d0/d6/iop_8h.html#a184">IopGetVolumeId</a>( dstFileObject,
07793                                              &amp;TargetVolumeId,
07794                                              <span class="keyword">sizeof</span>( TargetVolumeId ) );
07795                     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
07796                         <span class="keywordflow">return</span> status;
07797                     }
07798 
07799                     status = <a class="code" href="../../d0/d6/iop_8h.html#a182">IopGetSetObjectId</a>( dstFileObject,
07800                                                 &amp;TargetObjectId,
07801                                                 <span class="keyword">sizeof</span>( TargetObjectId ),
07802                                                 FSCTL_CREATE_OR_GET_OBJECT_ID );
07803                     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
07804                         <span class="keywordflow">return</span> status;
07805                     }
07806 
07807 
07808                     <span class="comment">//</span>
07809                     <span class="comment">// Notify the tracking system of the move.</span>
07810                     <span class="comment">//</span>
07811 
07812                     <a class="code" href="../../d2/d4/internal_8c.html#a15">IopMarshalIds</a>( &amp;trackingBuffer, &amp;TargetVolumeId, &amp;TargetObjectId, trackingInfo );
07813 
07814                     status = <a class="code" href="../../d0/d6/iop_8h.html#a214">IopTrackLink</a>( FileObject,
07815                                            IoStatusBlock,
07816                                            &amp;trackingBuffer.<a class="code" href="../../d1/d2/struct__TRACKING__BUFFER.html#o0">TrackingInformation</a>,
07817                                            FIELD_OFFSET( FILE_TRACKING_INFORMATION,
07818                                                 ObjectInformation ) +
07819                                                     trackingBuffer.<a class="code" href="../../d1/d2/struct__TRACKING__BUFFER.html#o0">TrackingInformation</a>.ObjectInformationLength,
07820                                            <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>,
07821                                            <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a> );
07822                     <span class="keywordflow">if</span>( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status) ) {
07823                         <span class="keywordflow">return</span> status;
07824                     }
07825 
07826                     <span class="comment">//</span>
07827                     <span class="comment">//  Delete the ID from the source</span>
07828                     <span class="comment">//</span>
07829 
07830                     status = <a class="code" href="../../d0/d6/iop_8h.html#a182">IopGetSetObjectId</a>( FileObject,
07831                                                 <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
07832                                                 0,
07833                                                 FSCTL_DELETE_OBJECT_ID );
07834                     <span class="keywordflow">if</span>( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
07835                         <span class="keywordflow">return</span> status;
07836                     }
07837 
07838                     <span class="comment">//</span>
07839                     <span class="comment">// Set the birth ID on the target, also turning on the bit</span>
07840                     <span class="comment">// that indicates that this file has moved across volumes.</span>
07841                     <span class="comment">//</span>
07842 
07843                     CrossVolumeObjectId = SourceObjectId;
07844                     CrossVolumeObjectId.BirthVolumeId[0] |= 1;
07845 
07846                     status = <a class="code" href="../../d0/d6/iop_8h.html#a182">IopGetSetObjectId</a>( dstFileObject,
07847                                                 &amp;CrossVolumeObjectId.ExtendedInfo[0],
07848                                                 <span class="keyword">sizeof</span>( CrossVolumeObjectId.ExtendedInfo ),
07849                                                 FSCTL_SET_OBJECT_ID_EXTENDED );
07850 
07851                     <span class="keywordflow">if</span>( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
07852 
07853                         <a class="code" href="../../d0/d6/iop_8h.html#a182">IopGetSetObjectId</a>( FileObject,
07854                                            &amp;SourceObjectId,
07855                                            <span class="keyword">sizeof</span>(SourceObjectId),
07856                                            FSCTL_SET_OBJECT_ID );
07857                         <span class="keywordflow">return</span> status;
07858                     }
07859 
07860                 }   <span class="comment">// if (IsFileLocal( dstFileObject ))</span>
07861 
07862                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d6/iop_8h.html#a190">IopIsSameMachine</a>( FileObject, trackingInfo-&gt;DestinationFile)) {
07863 
07864                     <span class="comment">//</span>
07865                     <span class="comment">// The source and the target are remote from each other and from</span>
07866                     <span class="comment">// this machine.  Query the object ID of the target and recursively</span>
07867                     <span class="comment">// track the link from the source file's remote node.</span>
07868                     <span class="comment">//</span>
07869 
07870                     <span class="comment">//</span>
07871                     <span class="comment">// Query the volume ID of the target.</span>
07872                     <span class="comment">//</span>
07873 
07874                     status = <a class="code" href="../../d0/d6/iop_8h.html#a182">IopGetSetObjectId</a>( dstFileObject,
07875                                                 &amp;TargetVolumeId,
07876                                                 <span class="keyword">sizeof</span>( <a class="code" href="../../d2/d4/internal_8c.html#a5">FILE_VOLUMEID_WITH_TYPE</a> ),
07877                                                 FSCTL_LMR_GET_LINK_TRACKING_INFORMATION );
07878 
07879                     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
07880                         <span class="keywordflow">return</span> status;
07881                     }
07882 
07883                     <span class="comment">//</span>
07884                     <span class="comment">// Query the object ID of the target.</span>
07885                     <span class="comment">//</span>
07886 
07887                     status = <a class="code" href="../../d0/d6/iop_8h.html#a182">IopGetSetObjectId</a>( dstFileObject,
07888                                                 &amp;TargetObjectId,
07889                                                 <span class="keyword">sizeof</span>( TargetObjectId ),
07890                                                 FSCTL_CREATE_OR_GET_OBJECT_ID );
07891                     <span class="keywordflow">if</span>( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
07892                         <span class="keywordflow">return</span> status;
07893                     }
07894 
07895                     <span class="comment">//</span>
07896                     <span class="comment">// Notify the tracking system of the move.</span>
07897                     <span class="comment">//</span>
07898 
07899                     <a class="code" href="../../d2/d4/internal_8c.html#a15">IopMarshalIds</a>( &amp;trackingBuffer, &amp;TargetVolumeId, &amp;TargetObjectId, trackingInfo );
07900 
07901                     status = <a class="code" href="../../d0/d6/iop_8h.html#a214">IopTrackLink</a>( FileObject,
07902                                            IoStatusBlock,
07903                                            &amp;trackingBuffer.<a class="code" href="../../d1/d2/struct__TRACKING__BUFFER.html#o0">TrackingInformation</a>,
07904                                            FIELD_OFFSET( FILE_TRACKING_INFORMATION,
07905                                                 ObjectInformation ) +
07906                                                     trackingBuffer.<a class="code" href="../../d1/d2/struct__TRACKING__BUFFER.html#o0">TrackingInformation</a>.ObjectInformationLength,
07907                                            <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>,
07908                                            <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a> );
07909                     <span class="keywordflow">if</span>( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
07910                         <span class="keywordflow">return</span> status;
07911                     }
07912 
07913                     <span class="comment">//</span>
07914                     <span class="comment">// Set the birth ID on the target, turning on the bit that indicates</span>
07915                     <span class="comment">// that this file has moved across volumes.</span>
07916                     <span class="comment">//</span>
07917 
07918                     CrossVolumeObjectId = SourceObjectId;
07919                     CrossVolumeObjectId.BirthVolumeId[0] |= 1;
07920 
07921                     status = <a class="code" href="../../d0/d6/iop_8h.html#a182">IopGetSetObjectId</a>( dstFileObject,
07922                                                 &amp;CrossVolumeObjectId.ExtendedInfo[0],
07923                                                 <span class="keyword">sizeof</span>( CrossVolumeObjectId.ExtendedInfo ),
07924                                                 FSCTL_SET_OBJECT_ID_EXTENDED );
07925 
07926                     <span class="keywordflow">if</span>( !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
07927                         <a class="code" href="../../d0/d6/iop_8h.html#a182">IopGetSetObjectId</a>( FileObject,
07928                                            &amp;SourceObjectId,
07929                                            <span class="keyword">sizeof</span>(SourceObjectId),
07930                                            FSCTL_SET_OBJECT_ID );
07931                         <span class="keywordflow">return</span> status;
07932                     }
07933 
07934                 } <span class="keywordflow">else</span> {    <span class="comment">// else if (!IopIsSameMachine( FileObject, trackingInfo-&gt;DestinationFile))</span>
07935 
07936                     <span class="comment">//</span>
07937                     <span class="comment">// Both the source and the target are remote and they're</span>
07938                     <span class="comment">// both on the same remote machine.  For this case, remote</span>
07939                     <span class="comment">// the entire API using the file object pointers.</span>
07940                     <span class="comment">//</span>
07941 
07942                     status = <a class="code" href="../../d0/d6/iop_8h.html#a209">IopSetRemoteLink</a>( FileObject, dstFileObject, trackingInfo );
07943 
07944                 }   <span class="comment">// else if (!IopIsSameMachine( FileObject, trackingInfo-&gt;DestinationFile)) ... else</span>
07945 
07946             } <span class="keywordflow">else</span> {    <span class="comment">// if (trackingInfo-&gt;DestinationFile)</span>
07947 
07948                 <span class="comment">//</span>
07949                 <span class="comment">// The source file is remote and the object ID of the target is</span>
07950                 <span class="comment">// contained w/in the tracking buffer.  Simply remote the API</span>
07951                 <span class="comment">// to the remote machine using the source file object pointer</span>
07952                 <span class="comment">// and the object ID of the target in the buffer.</span>
07953                 <span class="comment">//</span>
07954 
07955                 status = <a class="code" href="../../d0/d6/iop_8h.html#a209">IopSetRemoteLink</a>( FileObject, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, FileInformation );
07956 
07957             }   <span class="comment">// if (trackingInfo-&gt;DestinationFile) ... else</span>
07958         }   <span class="comment">// if (IsFileLocal( FileObject )) ... else</span>
07959 
07960     } finally {
07961 
07962         <span class="comment">//</span>
07963         <span class="comment">// Ensure that everything has been cleaned up.</span>
07964         <span class="comment">//</span>
07965 
07966         <span class="keywordflow">if</span> (RequestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a> &amp;&amp; trackingInfo) {
07967             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( trackingInfo );
07968         }
07969 
07970         <span class="keywordflow">if</span> (dstFileObject ) {
07971             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( dstFileObject );
07972         }
07973 
07974         <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>( <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
07975     }
07976 
07977     <span class="keywordflow">return</span> status;
07978 }
07979 
07980 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l07981"></a><a class="code" href="../../d0/d6/iop_8h.html#a215">07981</a> <a class="code" href="../../d0/d6/iop_8h.html#a215">IopUserCompletion</a>(
07982     IN <a class="code" href="../../d1/d5/struct__KAPC.html">PKAPC</a> Apc,
07983     IN PKNORMAL_ROUTINE *NormalRoutine,
07984     IN PVOID *NormalContext,
07985     IN PVOID *SystemArgument1,
07986     IN PVOID *SystemArgument2
07987     )
07988 
07989 <span class="comment">/*++</span>
07990 <span class="comment"></span>
07991 <span class="comment">Routine Description:</span>
07992 <span class="comment"></span>
07993 <span class="comment">    This routine is invoked in the final processing of an IRP.  Everything has</span>
07994 <span class="comment">    been completed except that the caller's APC routine must be invoked.  The</span>
07995 <span class="comment">    system will do this as soon as this routine exits.  The only processing</span>
07996 <span class="comment">    remaining to be completed by the I/O system is to free the I/O Request</span>
07997 <span class="comment">    Packet itself.</span>
07998 <span class="comment"></span>
07999 <span class="comment">Arguments:</span>
08000 <span class="comment"></span>
08001 <span class="comment">    Apc - Supplies a pointer to kernel APC structure.</span>
08002 <span class="comment"></span>
08003 <span class="comment">    NormalRoutine - Supplies a pointer to a pointer to the normal function</span>
08004 <span class="comment">        that was specified when the APC was initialied.</span>
08005 <span class="comment"></span>
08006 <span class="comment">    NormalContext - Supplies a pointer to a pointer to an arbitrary data</span>
08007 <span class="comment">        structure that was specified when the APC was initialized.</span>
08008 <span class="comment"></span>
08009 <span class="comment">    SystemArgument1, SystemArgument2 - Supplies a set of two pointers to</span>
08010 <span class="comment">        two arguments that contain untyped data.</span>
08011 <span class="comment"></span>
08012 <span class="comment">Return Value:</span>
08013 <span class="comment"></span>
08014 <span class="comment">    None.</span>
08015 <span class="comment"></span>
08016 <span class="comment">Note:</span>
08017 <span class="comment"></span>
08018 <span class="comment">    If no other processing is ever needed, and the APC can be placed at the</span>
08019 <span class="comment">    beginning of the IRP, then this routine could be replaced by simply</span>
08020 <span class="comment">    specifying the address of the pool deallocation routine in the APC instead</span>
08021 <span class="comment">    of the address of this routine.</span>
08022 <span class="comment"></span>
08023 <span class="comment">Caution:</span>
08024 <span class="comment"></span>
08025 <span class="comment">    This routine is also invoked as a general purpose rundown routine for APCs.</span>
08026 <span class="comment">    Should this code ever need to directly access any of the other parameters</span>
08027 <span class="comment">    other than Apc, this routine will need to be split into two separate</span>
08028 <span class="comment">    routines.  The rundown routine should perform exactly the following code's</span>
08029 <span class="comment">    functionality.</span>
08030 <span class="comment"></span>
08031 <span class="comment">--*/</span>
08032 
08033 {
08034     UNREFERENCED_PARAMETER( NormalRoutine );
08035     UNREFERENCED_PARAMETER( NormalContext );
08036     UNREFERENCED_PARAMETER( SystemArgument1 );
08037     UNREFERENCED_PARAMETER( SystemArgument2 );
08038 
08039     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
08040 
08041     <span class="comment">//</span>
08042     <span class="comment">// Free the packet.</span>
08043     <span class="comment">//</span>
08044 
08045     <a class="code" href="../../d4/d6/iosubs_8c.html#a63">IoFreeIrp</a>( CONTAINING_RECORD( Apc, <a class="code" href="../../d0/d2/struct__IRP.html">IRP</a>, Tail.Apc ) );
08046 }
08047 
08048 
08049 
08050 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l08051"></a><a class="code" href="../../d2/d4/internal_8c.html#a14">08051</a> <a class="code" href="../../d2/d4/internal_8c.html#a14">IopUserRundown</a>(
08052     IN <a class="code" href="../../d1/d5/struct__KAPC.html">PKAPC</a> Apc
08053     )
08054 
08055 <span class="comment">/*++</span>
08056 <span class="comment"></span>
08057 <span class="comment">Routine Description:</span>
08058 <span class="comment"></span>
08059 <span class="comment">    This routine is invoked during thread termination as the rundown routine</span>
08060 <span class="comment">    for it simply calls IopUserCompletion.</span>
08061 <span class="comment"></span>
08062 <span class="comment">Arguments:</span>
08063 <span class="comment"></span>
08064 <span class="comment">    Apc - Supplies a pointer to kernel APC structure.</span>
08065 <span class="comment"></span>
08066 <span class="comment">Return Value:</span>
08067 <span class="comment"></span>
08068 <span class="comment">    None.</span>
08069 <span class="comment"></span>
08070 <span class="comment"></span>
08071 <span class="comment">--*/</span>
08072 
08073 {
08074     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
08075 
08076     <span class="comment">//</span>
08077     <span class="comment">// Free the packet.</span>
08078     <span class="comment">//</span>
08079 
08080     <a class="code" href="../../d4/d6/iosubs_8c.html#a63">IoFreeIrp</a>( CONTAINING_RECORD( Apc, <a class="code" href="../../d0/d2/struct__IRP.html">IRP</a>, Tail.Apc ) );
08081 }
08082 
08083 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l08084"></a><a class="code" href="../../d0/d6/iop_8h.html#a216">08084</a> <a class="code" href="../../d0/d6/iop_8h.html#a216">IopXxxControlFile</a>(
08085     IN HANDLE FileHandle,
08086     IN HANDLE Event OPTIONAL,
08087     IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
08088     IN PVOID ApcContext OPTIONAL,
08089     OUT PIO_STATUS_BLOCK IoStatusBlock,
08090     IN ULONG IoControlCode,
08091     IN PVOID InputBuffer OPTIONAL,
08092     IN ULONG InputBufferLength,
08093     OUT PVOID OutputBuffer OPTIONAL,
08094     IN ULONG OutputBufferLength,
08095     IN BOOLEAN DeviceIoControl
08096     )
08097 
08098 <span class="comment">/*++</span>
08099 <span class="comment"></span>
08100 <span class="comment">Routine Description:</span>
08101 <span class="comment"></span>
08102 <span class="comment">    This service builds descriptors or MDLs for the supplied buffer(s) and</span>
08103 <span class="comment">    passes the untyped data to the driver associated with the file handle.</span>
08104 <span class="comment">    handle.  It is up to the driver to check the input data and function</span>
08105 <span class="comment">    IoControlCode for validity, as well as to make the appropriate access</span>
08106 <span class="comment">    checks.</span>
08107 <span class="comment"></span>
08108 <span class="comment">Arguments:</span>
08109 <span class="comment"></span>
08110 <span class="comment">    FileHandle - Supplies a handle to the file on which the service is being</span>
08111 <span class="comment">        performed.</span>
08112 <span class="comment"></span>
08113 <span class="comment">    Event - Supplies an optional event to be set to the Signaled state when</span>
08114 <span class="comment">        the service is complete.</span>
08115 <span class="comment"></span>
08116 <span class="comment">    ApcRoutine - Supplies an optional APC routine to be executed when the</span>
08117 <span class="comment">        service is complete.</span>
08118 <span class="comment"></span>
08119 <span class="comment">    ApcContext - Supplies a context parameter to be passed to the ApcRoutine,</span>
08120 <span class="comment">        if an ApcRoutine was specified.</span>
08121 <span class="comment"></span>
08122 <span class="comment">    IoStatusBlock - Address of the caller's I/O status block.</span>
08123 <span class="comment"></span>
08124 <span class="comment">    IoControlCode - Subfunction code to determine exactly what operation is</span>
08125 <span class="comment">        being performed.</span>
08126 <span class="comment"></span>
08127 <span class="comment">    InputBuffer - Optionally supplies an input buffer to be passed to the</span>
08128 <span class="comment">        driver.  Whether or not the buffer is actually optional is dependent</span>
08129 <span class="comment">        on the IoControlCode.</span>
08130 <span class="comment"></span>
08131 <span class="comment">    InputBufferLength - Length of the InputBuffer in bytes.</span>
08132 <span class="comment"></span>
08133 <span class="comment">    OutputBuffer - Optionally supplies an output buffer to receive information</span>
08134 <span class="comment">        from the driver.  Whether or not the buffer is actually optional is</span>
08135 <span class="comment">        dependent on the IoControlCode.</span>
08136 <span class="comment"></span>
08137 <span class="comment">    OutputBufferLength - Length of the OutputBuffer in bytes.</span>
08138 <span class="comment"></span>
08139 <span class="comment">    DeviceIoControl - Determines whether this is a Device or File System</span>
08140 <span class="comment">        Control function.</span>
08141 <span class="comment"></span>
08142 <span class="comment">Return Value:</span>
08143 <span class="comment"></span>
08144 <span class="comment">    The status returned is success if the control operation was properly</span>
08145 <span class="comment">    queued to the I/O system.   Once the operation completes, the status</span>
08146 <span class="comment">    can be determined by examining the Status field of the I/O status block.</span>
08147 <span class="comment"></span>
08148 <span class="comment">--*/</span>
08149 
08150 {
08151     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
08152     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
08153     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> fileObject;
08154     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
08155     <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> eventObject = (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
08156     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
08157     ULONG method;
08158     <a class="code" href="../../d3/d5/struct__OBJECT__HANDLE__INFORMATION.html">OBJECT_HANDLE_INFORMATION</a> handleInformation;
08159     BOOLEAN synchronousIo;
08160     IO_STATUS_BLOCK localIoStatus;
08161     <a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html">PFAST_IO_DISPATCH</a> fastIoDispatch;
08162     <a class="code" href="../../d5/d8/ex_8h.html#a96">POOL_TYPE</a> poolType;
08163     PULONG majorFunction;
08164     <a class="code" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> requestorMode;
08165 
08166     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
08167 
08168     <span class="comment">//</span>
08169     <span class="comment">// Get the method that the buffers are being passed by.</span>
08170     <span class="comment">//</span>
08171 
08172     method = IoControlCode &amp; 3;
08173 
08174     <span class="comment">//</span>
08175     <span class="comment">// Check the caller's parameters based on the mode of the caller.</span>
08176     <span class="comment">//</span>
08177 
08178     requestorMode = KeGetPreviousMode();
08179 
08180     <span class="keywordflow">if</span> (requestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
08181 
08182         <span class="comment">//</span>
08183         <span class="comment">// The caller's access mode is not kernel so probe each of the arguments</span>
08184         <span class="comment">// and capture them as necessary.  If any failures occur, the condition</span>
08185         <span class="comment">// handler will be invoked to handle them.  It will simply cleanup and</span>
08186         <span class="comment">// return an access violation status code back to the system service</span>
08187         <span class="comment">// dispatcher.</span>
08188         <span class="comment">//</span>
08189 
08190         <span class="keywordflow">try</span> {
08191 
08192             <span class="comment">//</span>
08193             <span class="comment">// The IoStatusBlock parameter must be writeable by the caller.</span>
08194             <span class="comment">//</span>
08195 
08196             <a class="code" href="../../d5/d8/ex_8h.html#a32">ProbeForWriteIoStatusEx</a>( IoStatusBlock , ApcRoutine);
08197 
08198             <span class="comment">//</span>
08199             <span class="comment">// The output buffer can be used in any one of the following three ways,</span>
08200             <span class="comment">// if it is specified:</span>
08201             <span class="comment">//</span>
08202             <span class="comment">//     0) It can be a normal, buffered output buffer.</span>
08203             <span class="comment">//</span>
08204             <span class="comment">//     1) It can be a DMA input buffer.</span>
08205             <span class="comment">//</span>
08206             <span class="comment">//     2) It can be a DMA output buffer.</span>
08207             <span class="comment">//</span>
08208             <span class="comment">// Which way the buffer is to be used it based on the low-order two bits</span>
08209             <span class="comment">// of the IoControlCode.</span>
08210             <span class="comment">//</span>
08211             <span class="comment">// If the method is 0 we probe the output buffer for write access.</span>
08212             <span class="comment">// If the method is not 3 we probe the input buffer for read access.</span>
08213             <span class="comment">//</span>
08214 
08215             <span class="keywordflow">if</span> (method == 0) {
08216                 <span class="keywordflow">if</span> (ARGUMENT_PRESENT( OutputBuffer )) {
08217                     <a class="code" href="../../d5/d8/ex_8h.html#a259">ProbeForWrite</a>( OutputBuffer,
08218                                    OutputBufferLength,
08219                                    <span class="keyword">sizeof</span>( UCHAR ) );
08220                 } <span class="keywordflow">else</span> {
08221                     OutputBufferLength = 0;
08222                 }
08223             }
08224 
08225             <span class="keywordflow">if</span> (method != 3) {
08226                 <span class="keywordflow">if</span> (ARGUMENT_PRESENT( InputBuffer )) {
08227                     <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( InputBuffer,
08228                                   InputBufferLength,
08229                                   <span class="keyword">sizeof</span>( UCHAR ) );
08230                 } <span class="keywordflow">else</span> {
08231                     InputBufferLength = 0;
08232                 }
08233             }
08234 
08235         } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
08236 
08237             <span class="comment">//</span>
08238             <span class="comment">// An exception was incurred while attempting to probe or write</span>
08239             <span class="comment">// one of the caller's parameters.  Simply return an appropriate</span>
08240             <span class="comment">// error status code.</span>
08241             <span class="comment">//</span>
08242 
08243             <span class="keywordflow">return</span> GetExceptionCode();
08244 
08245         }
08246     }
08247 
08248     <span class="comment">//</span>
08249     <span class="comment">// There were no blatant errors so far, so reference the file object so</span>
08250     <span class="comment">// the target device object can be found.  Note that if the handle does</span>
08251     <span class="comment">// not refer to a file object, or if the caller does not have the required</span>
08252     <span class="comment">// access to the file, then it will fail.</span>
08253     <span class="comment">//</span>
08254 
08255     status = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a>( FileHandle,
08256                                         0<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>,
08257                                         <a class="code" href="../../d5/d8/fssup_8c.html#a3">IoFileObjectType</a>,
08258                                         requestorMode,
08259                                         (PVOID *) &amp;fileObject,
08260                                         &amp;handleInformation );
08261     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
08262         <span class="keywordflow">return</span> status;
08263     }
08264 
08265     <span class="comment">//</span>
08266     <span class="comment">// If this file has an I/O completion port associated w/it, then ensure</span>
08267     <span class="comment">// that the caller did not supply an APC routine, as the two are mutually</span>
08268     <span class="comment">// exclusive methods for I/O completion notification.</span>
08269     <span class="comment">//</span>
08270 
08271     <span class="keywordflow">if</span> (fileObject-&gt;CompletionContext &amp;&amp; <a class="code" href="../../d0/d6/iop_8h.html#a19">IopApcRoutinePresent</a>( ApcRoutine )) {
08272         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
08273         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
08274     }
08275 
08276     <span class="comment">//</span>
08277     <span class="comment">// Now check the access type for this control code to ensure that the</span>
08278     <span class="comment">// caller has the appropriate access to this file object to perform the</span>
08279     <span class="comment">// operation.</span>
08280     <span class="comment">//</span>
08281 
08282     <span class="keywordflow">if</span> (requestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
08283 
08284         ULONG accessMode = (IoControlCode &gt;&gt; 14) &amp; 3;
08285 
08286         <span class="keywordflow">if</span> (accessMode != FILE_ANY_ACCESS) {
08287 
08288             <span class="comment">//</span>
08289             <span class="comment">// This I/O control requires that the caller have read, write,</span>
08290             <span class="comment">// or read/write access to the object.  If this is not the case,</span>
08291             <span class="comment">// then cleanup and return an appropriate error status code.</span>
08292             <span class="comment">//</span>
08293 
08294             <span class="keywordflow">if</span> (<a class="code" href="../../d0/d5/se_8h.html#a9">SeComputeGrantedAccesses</a>( handleInformation.<a class="code" href="../../d3/d5/struct__OBJECT__HANDLE__INFORMATION.html#o1">GrantedAccess</a>, accessMode ) != accessMode ) {
08295                 <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
08296                 <span class="keywordflow">return</span> STATUS_ACCESS_DENIED;
08297             }
08298         }
08299     }
08300 
08301     <span class="comment">//</span>
08302     <span class="comment">// Get the address of the event object and set the event to the Not-</span>
08303     <span class="comment">// Signaled state, if an event was specified.  Note here, too, that if</span>
08304     <span class="comment">// the handle does not refer to an event, or if the event cannot be</span>
08305     <span class="comment">// written, then the reference will fail.</span>
08306     <span class="comment">//</span>
08307 
08308     <span class="keywordflow">if</span> (ARGUMENT_PRESENT( <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a> )) {
08309         status = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a>( <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>,
08310                                             EVENT_MODIFY_STATE,
08311                                             <a class="code" href="../../d7/d7/ntapi_8c.html#a3">ExEventObjectType</a>,
08312                                             requestorMode,
08313                                             (PVOID *) &amp;eventObject,
08314                                             <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
08315         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
08316             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
08317             <span class="keywordflow">return</span> status;
08318         } <span class="keywordflow">else</span> {
08319             <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a>( eventObject );
08320         }
08321     }
08322 
08323     <span class="comment">//</span>
08324     <span class="comment">// Make a special check here to determine whether this is a synchronous</span>
08325     <span class="comment">// I/O operation.  If it is, then wait here until the file is owned by</span>
08326     <span class="comment">// the current thread.</span>
08327     <span class="comment">//</span>
08328 
08329     <span class="keywordflow">if</span> (fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>) {
08330         BOOLEAN interrupted;
08331 
08332         <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d6/iop_8h.html#a13">IopAcquireFastLock</a>( fileObject )) {
08333             status = <a class="code" href="../../d0/d6/iop_8h.html#a147">IopAcquireFileObjectLock</a>( fileObject,
08334                                                requestorMode,
08335                                                (BOOLEAN) ((fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a152">FO_ALERTABLE_IO</a>) != 0),
08336                                                &amp;interrupted );
08337             <span class="keywordflow">if</span> (interrupted) {
08338                 <span class="keywordflow">if</span> (eventObject) {
08339                     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( eventObject );
08340                 }
08341                 <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
08342                 <span class="keywordflow">return</span> status;
08343             }
08344         }
08345         synchronousIo = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
08346     } <span class="keywordflow">else</span> {
08347         synchronousIo = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
08348     }
08349 
08350     <span class="comment">//</span>
08351     <span class="comment">// Get the address of the target device object.  If this file represents</span>
08352     <span class="comment">// a device that was opened directly, then simply use the device or its</span>
08353     <span class="comment">// attached device(s) directly.</span>
08354     <span class="comment">//</span>
08355 
08356     <span class="keywordflow">if</span> (!(fileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a161">FO_DIRECT_DEVICE_OPEN</a>)) {
08357         deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( fileObject );
08358     } <span class="keywordflow">else</span> {
08359         deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a66">IoGetAttachedDevice</a>( fileObject-&gt;DeviceObject );
08360     }
08361 
08362     <span class="keywordflow">if</span> (DeviceIoControl) {
08363 
08364         <span class="comment">//</span>
08365         <span class="comment">// Also get the address of the Fast I/O dispatch structure.</span>
08366         <span class="comment">//</span>
08367 
08368         fastIoDispatch = deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o3">DriverObject</a>-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o10">FastIoDispatch</a>;
08369 
08370         <span class="comment">//</span>
08371         <span class="comment">// Turbo device control support.  If the device has a fast I/O entry</span>
08372         <span class="comment">// point for DeviceIoControlFile, call the entry point and give it a</span>
08373         <span class="comment">// chance to try to complete the request.  Note if FastIoDeviceControl</span>
08374         <span class="comment">// returns FALSE or we get an I/O error, we simply fall through and</span>
08375         <span class="comment">// go the "long way" and create an Irp.</span>
08376         <span class="comment">//</span>
08377 
08378         <span class="keywordflow">if</span> (fastIoDispatch &amp;&amp; fastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o10">FastIoDeviceControl</a>) {
08379 
08380             <span class="comment">//</span>
08381             <span class="comment">// Before we actually call the fast I/O routine in the driver,</span>
08382             <span class="comment">// we must probe OutputBuffer if the method is 1 or 2.</span>
08383             <span class="comment">//</span>
08384 
08385             <span class="keywordflow">if</span> (requestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a> &amp;&amp; ARGUMENT_PRESENT(OutputBuffer)) {
08386 
08387                 <span class="keywordflow">try</span> {
08388 
08389                     <span class="keywordflow">if</span> (method == 1) {
08390                         <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( OutputBuffer,
08391                                       OutputBufferLength,
08392                                       <span class="keyword">sizeof</span>( UCHAR ) );
08393                     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (method == 2) {
08394                         <a class="code" href="../../d5/d8/ex_8h.html#a259">ProbeForWrite</a>( OutputBuffer,
08395                                        OutputBufferLength,
08396                                        <span class="keyword">sizeof</span>( UCHAR ) );
08397                     }
08398 
08399                 } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
08400 
08401                     <span class="comment">//</span>
08402                     <span class="comment">// An exception was incurred while attempting to probe</span>
08403                     <span class="comment">// the output buffer.  Clean up and return an</span>
08404                     <span class="comment">// appropriate error status code.</span>
08405                     <span class="comment">//</span>
08406 
08407                     <span class="keywordflow">if</span> (synchronousIo) {
08408                         <a class="code" href="../../d0/d6/iop_8h.html#a22">IopReleaseFileObjectLock</a>( fileObject );
08409                     }
08410 
08411                     <span class="keywordflow">if</span> (eventObject) {
08412                         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( eventObject );
08413                     }
08414 
08415                     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
08416 
08417                     <span class="keywordflow">return</span> GetExceptionCode();
08418                 }
08419             }
08420 
08421             <span class="comment">//</span>
08422             <span class="comment">// Call the driver's fast I/O routine.</span>
08423             <span class="comment">//</span>
08424 
08425             <span class="keywordflow">if</span> (fastIoDispatch-&gt;<a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html#o10">FastIoDeviceControl</a>( fileObject,
08426                                                      <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
08427                                                      InputBuffer,
08428                                                      InputBufferLength,
08429                                                      OutputBuffer,
08430                                                      OutputBufferLength,
08431                                                      IoControlCode,
08432                                                      &amp;localIoStatus,
08433                                                      deviceObject )) {
08434 
08435                 <span class="comment">//</span>
08436                 <span class="comment">// The driver successfully performed the I/O in it's</span>
08437                 <span class="comment">// fast device control routine.  Carefully return the</span>
08438                 <span class="comment">// I/O status.</span>
08439                 <span class="comment">//</span>
08440 
08441                 <span class="keywordflow">try</span> {
08442                     *IoStatusBlock = localIoStatus;
08443                 } except( <a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a> ) {
08444                     localIoStatus.Status = GetExceptionCode();
08445                     localIoStatus.Information = 0;
08446                 }
08447 
08448                 <span class="comment">//</span>
08449                 <span class="comment">// If an event was specified, set it.</span>
08450                 <span class="comment">//</span>
08451 
08452                 <span class="keywordflow">if</span> (ARGUMENT_PRESENT( <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a> )) {
08453                     <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>( eventObject, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
08454                     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( eventObject );
08455                 }
08456 
08457                 <span class="comment">//</span>
08458                 <span class="comment">// Note that the file object event need not be set to the</span>
08459                 <span class="comment">// Signaled state, as it is already set.  Release the</span>
08460                 <span class="comment">// file object lock, if necessary.</span>
08461                 <span class="comment">//</span>
08462 
08463                 <span class="keywordflow">if</span> (synchronousIo) {
08464                     <a class="code" href="../../d0/d6/iop_8h.html#a22">IopReleaseFileObjectLock</a>( fileObject );
08465                 }
08466 
08467                 <span class="comment">//</span>
08468                 <span class="comment">// If this file object has a completion port associated with it</span>
08469                 <span class="comment">// and this request has a non-NULL APC context then a completion</span>
08470                 <span class="comment">// message needs to be queued.</span>
08471                 <span class="comment">//</span>
08472 
08473                 <span class="keywordflow">if</span> (fileObject-&gt;CompletionContext &amp;&amp; ARGUMENT_PRESENT( ApcContext )) {
08474                     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d5/d4/complete_8c.html#a6">IoSetIoCompletion</a>( fileObject-&gt;CompletionContext-&gt;Port,
08475                                                        fileObject-&gt;CompletionContext-&gt;Key,
08476                                                        ApcContext,
08477                                                        localIoStatus.Status,
08478                                                        localIoStatus.Information,
08479                                                        <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> ))) {
08480                         localIoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
08481                     }
08482                 }
08483 
08484                 <span class="comment">//</span>
08485                 <span class="comment">// Cleanup and return.</span>
08486                 <span class="comment">//</span>
08487 
08488                 <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
08489                 <span class="keywordflow">return</span> localIoStatus.Status;
08490             }
08491         }
08492 
08493     }
08494 
08495     <span class="comment">//</span>
08496     <span class="comment">// Set the file object to the Not-Signaled state.</span>
08497     <span class="comment">//</span>
08498 
08499     <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a>( &amp;fileObject-&gt;Event );
08500 
08501     <span class="comment">//</span>
08502     <span class="comment">// Allocate and initialize the I/O Request Packet (IRP) for this operation.</span>
08503 
08504     irp = <a class="code" href="../../d0/d6/iop_8h.html#a16">IopAllocateIrp</a>( deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o13">StackSize</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
08505 
08506     <span class="keywordflow">if</span> (!irp) {
08507 
08508         <span class="comment">//</span>
08509         <span class="comment">// An IRP could not be allocated.  Cleanup and return an appropriate</span>
08510         <span class="comment">// error status code.</span>
08511         <span class="comment">//</span>
08512 
08513         <a class="code" href="../../d0/d6/iop_8h.html#a148">IopAllocateIrpCleanup</a>( fileObject, eventObject );
08514 
08515         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
08516     }
08517     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.OriginalFileObject = fileObject;
08518     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
08519     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.AuxiliaryBuffer = (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
08520     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o10">RequestorMode</a> = requestorMode;
08521     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o11">PendingReturned</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
08522     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o14">Cancel</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
08523     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o25">CancelRoutine</a> = (<a class="code" href="../../d0/d5/io_8h.html#a286">PDRIVER_CANCEL</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
08524 
08525     <span class="comment">//</span>
08526     <span class="comment">// Fill in the service independent parameters in the IRP.</span>
08527     <span class="comment">//</span>
08528 
08529     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = eventObject;
08530     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = IoStatusBlock;
08531     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcRoutine = ApcRoutine;
08532     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcContext = ApcContext;
08533 
08534     <span class="comment">//</span>
08535     <span class="comment">// Get a pointer to the stack location for the first driver.  This will be</span>
08536     <span class="comment">// used to pass the original function codes and parameters.  Note that</span>
08537     <span class="comment">// setting the major function here also sets:</span>
08538     <span class="comment">//</span>
08539     <span class="comment">//      MinorFunction = 0;</span>
08540     <span class="comment">//      Flags = 0;</span>
08541     <span class="comment">//      Control = 0;</span>
08542     <span class="comment">//</span>
08543 
08544     irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
08545     majorFunction = (PULONG) (&amp;irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a>);
08546     *majorFunction = DeviceIoControl ? <a class="code" href="../../d0/d5/io_8h.html#a27">IRP_MJ_DEVICE_CONTROL</a> : <a class="code" href="../../d0/d5/io_8h.html#a26">IRP_MJ_FILE_SYSTEM_CONTROL</a>;
08547     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> = fileObject;
08548 
08549     <span class="comment">//</span>
08550     <span class="comment">// Copy the caller's parameters to the service-specific portion of the</span>
08551     <span class="comment">// IRP for those parameters that are the same for all three methods.</span>
08552     <span class="comment">//</span>
08553 
08554     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.DeviceIoControl.OutputBufferLength = OutputBufferLength;
08555     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.DeviceIoControl.InputBufferLength = InputBufferLength;
08556     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.DeviceIoControl.IoControlCode = IoControlCode;
08557 
08558     <span class="comment">//</span>
08559     <span class="comment">// Set the pool type based on the type of function being performed.</span>
08560     <span class="comment">//</span>
08561 
08562     poolType = DeviceIoControl ? <a class="code" href="../../d5/d8/ex_8h.html#a329a177">NonPagedPoolCacheAligned</a> : <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>;
08563 
08564     <span class="comment">//</span>
08565     <span class="comment">// Based on the method that the buffer are being passed, either allocate</span>
08566     <span class="comment">// buffers or build MDLs.  Note that in some cases no probing has taken</span>
08567     <span class="comment">// place so the exception handler must catch access violations.</span>
08568     <span class="comment">//</span>
08569 
08570     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a> = (<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
08571     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer = (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
08572 
08573     <span class="keywordflow">switch</span> ( method ) {
08574 
08575     <span class="keywordflow">case</span> 0:
08576 
08577         <span class="comment">//</span>
08578         <span class="comment">// For this case, allocate a buffer that is large enough to contain</span>
08579         <span class="comment">// both the input and the output buffers.  Copy the input buffer to</span>
08580         <span class="comment">// the allocated buffer and set the appropriate IRP fields.</span>
08581         <span class="comment">//</span>
08582 
08583         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.DeviceIoControl.Type3InputBuffer = (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
08584 
08585         <span class="keywordflow">try</span> {
08586 
08587             <span class="keywordflow">if</span> (InputBufferLength || OutputBufferLength) {
08588                 irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer =
08589                     <a class="code" href="../../d5/d5/cc_8h.html#a11">ExAllocatePoolWithQuota</a>( poolType,
08590                                              (InputBufferLength &gt; OutputBufferLength) ? InputBufferLength : OutputBufferLength );
08591 
08592                 <span class="keywordflow">if</span> (ARGUMENT_PRESENT( InputBuffer )) {
08593                     RtlCopyMemory( irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer,
08594                                    InputBuffer,
08595                                    InputBufferLength );
08596                 }
08597                 irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a178">IRP_BUFFERED_IO</a> | <a class="code" href="../../d0/d5/io_8h.html#a179">IRP_DEALLOCATE_BUFFER</a>;
08598                 irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o26">UserBuffer</a> = OutputBuffer;
08599                 <span class="keywordflow">if</span> (ARGUMENT_PRESENT( OutputBuffer )) {
08600                     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a180">IRP_INPUT_OPERATION</a>;
08601                 }
08602             } <span class="keywordflow">else</span> {
08603                 irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = 0;
08604                 irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o26">UserBuffer</a> = (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
08605             }
08606 
08607         } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
08608 
08609             <span class="comment">//</span>
08610             <span class="comment">// An exception was incurred while either allocating the</span>
08611             <span class="comment">// the system buffer or moving the caller's data.  Determine</span>
08612             <span class="comment">// what actually happened, cleanup accordingly, and return</span>
08613             <span class="comment">// an appropriate error status code.</span>
08614             <span class="comment">//</span>
08615 
08616             <a class="code" href="../../d0/d6/iop_8h.html#a170">IopExceptionCleanup</a>( fileObject,
08617                                  irp,
08618                                  eventObject,
08619                                  (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
08620 
08621             <span class="keywordflow">return</span> GetExceptionCode();
08622         }
08623 
08624         <span class="keywordflow">break</span>;
08625 
08626     <span class="keywordflow">case</span> 1:
08627     <span class="keywordflow">case</span> 2:
08628 
08629         <span class="comment">//</span>
08630         <span class="comment">// For these two cases, allocate a buffer that is large enough to</span>
08631         <span class="comment">// contain the input buffer, if any, and copy the information to</span>
08632         <span class="comment">// the allocated buffer.  Then build an MDL for either read or write</span>
08633         <span class="comment">// access, depending on the method, for the output buffer.  Note</span>
08634         <span class="comment">// that the buffer length parameters have been jammed to zero for</span>
08635         <span class="comment">// users if the buffer parameter was not passed.  (Kernel callers</span>
08636         <span class="comment">// should be calling the service correctly in the first place.)</span>
08637         <span class="comment">//</span>
08638         <span class="comment">// Note also that it doesn't make a whole lot of sense to specify</span>
08639         <span class="comment">// either method #1 or #2 if the IOCTL does not require the caller</span>
08640         <span class="comment">// to specify an output buffer.</span>
08641         <span class="comment">//</span>
08642 
08643         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = 0;
08644         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.DeviceIoControl.Type3InputBuffer = (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
08645 
08646         <span class="keywordflow">try</span> {
08647 
08648             <span class="keywordflow">if</span> (InputBufferLength &amp;&amp; ARGUMENT_PRESENT( InputBuffer )) {
08649                 irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer =
08650                     <a class="code" href="../../d5/d5/cc_8h.html#a11">ExAllocatePoolWithQuota</a>( poolType,
08651                                              InputBufferLength );
08652                 RtlCopyMemory( irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer,
08653                                InputBuffer,
08654                                InputBufferLength );
08655                 irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a178">IRP_BUFFERED_IO</a> | <a class="code" href="../../d0/d5/io_8h.html#a179">IRP_DEALLOCATE_BUFFER</a>;
08656             }
08657 
08658             <span class="keywordflow">if</span> (OutputBufferLength != 0) {
08659                 irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a> = <a class="code" href="../../d4/d6/iosubs_8c.html#a19">IoAllocateMdl</a>( OutputBuffer,
08660                                                  OutputBufferLength,
08661                                                  <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
08662                                                  <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
08663                                                  irp  );
08664                 <span class="keywordflow">if</span> (irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
08665                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( STATUS_INSUFFICIENT_RESOURCES );
08666                 }
08667                 <a class="code" href="../../d5/d6/iosup_8c.html#a41">MmProbeAndLockPages</a>( irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a>,
08668                                      requestorMode,
08669                                      (<a class="code" href="../../d2/d1/mm_8h.html#a141">LOCK_OPERATION</a>) ((method == 1) ? <a class="code" href="../../d2/d1/mm_8h.html#a344a168">IoReadAccess</a> : <a class="code" href="../../d2/d1/mm_8h.html#a344a169">IoWriteAccess</a>) );
08670             }
08671 
08672         } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
08673 
08674             <span class="comment">//</span>
08675             <span class="comment">// An exception was incurred while either allocating the</span>
08676             <span class="comment">// system buffer, copying the caller's data, allocating the</span>
08677             <span class="comment">// MDL, or probing and locking the caller's buffer. Determine</span>
08678             <span class="comment">// what actually happened, cleanup accordingly, and return</span>
08679             <span class="comment">// an appropriate error status code.</span>
08680             <span class="comment">//</span>
08681 
08682             <a class="code" href="../../d0/d6/iop_8h.html#a170">IopExceptionCleanup</a>( fileObject,
08683                                  irp,
08684                                  eventObject,
08685                                  (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
08686 
08687             <span class="keywordflow">return</span> GetExceptionCode();
08688         }
08689 
08690         <span class="keywordflow">break</span>;
08691 
08692     <span class="keywordflow">case</span> 3:
08693 
08694         <span class="comment">//</span>
08695         <span class="comment">// For this case, do nothing.  Everything is up to the driver.</span>
08696         <span class="comment">// Simply give the driver a copy of the caller's parameters and</span>
08697         <span class="comment">// let the driver do everything itself.</span>
08698         <span class="comment">//</span>
08699 
08700         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = 0;
08701         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o26">UserBuffer</a> = OutputBuffer;
08702         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.DeviceIoControl.Type3InputBuffer = InputBuffer;
08703     }
08704 
08705     <span class="comment">//</span>
08706     <span class="comment">// Defer I/O completion for FSCTL requests, but not for IOCTL requests,</span>
08707     <span class="comment">// since file systems set pending properly but device driver do not.</span>
08708     <span class="comment">//</span>
08709 
08710     <span class="keywordflow">if</span> (!DeviceIoControl) {
08711         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a186">IRP_DEFER_IO_COMPLETION</a>;
08712     }
08713 
08714     <span class="comment">//</span>
08715     <span class="comment">// Queue the packet, call the driver, and synchronize appropriately with</span>
08716     <span class="comment">// I/O completion.</span>
08717     <span class="comment">//</span>
08718 
08719     <span class="keywordflow">return</span> <a class="code" href="../../d0/d6/iop_8h.html#a212">IopSynchronousServiceTail</a>( deviceObject,
08720                                       irp,
08721                                       fileObject,
08722                                       (BOOLEAN)!DeviceIoControl,
08723                                       requestorMode,
08724                                       synchronousIo,
08725                                       <a class="code" href="../../d0/d6/iop_8h.html#a240a140">OtherTransfer</a> );
08726 }
08727 
08728 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l08729"></a><a class="code" href="../../d0/d6/iop_8h.html#a194">08729</a> <a class="code" href="../../d0/d6/iop_8h.html#a194">IopLookupBusStringFromID</a> (
08730     IN  HANDLE KeyHandle,
08731     IN  INTERFACE_TYPE InterfaceType,
08732     OUT PWCHAR Buffer,
08733     IN  ULONG Length,
08734     OUT PULONG BusFlags OPTIONAL
08735     )
08736 <span class="comment">/*++</span>
08737 <span class="comment"></span>
08738 <span class="comment">Routine Description:</span>
08739 <span class="comment"></span>
08740 <span class="comment">    Translates INTERFACE_TYPE to its corresponding WCHAR[] string.</span>
08741 <span class="comment"></span>
08742 <span class="comment">Arguments:</span>
08743 <span class="comment"></span>
08744 <span class="comment">    KeyHandle - Supplies a handle to the opened registry key,</span>
08745 <span class="comment">        HKLM\System\CurrentControlSet\Control\SystemResources\BusValues.</span>
08746 <span class="comment"></span>
08747 <span class="comment">    InterfaceType - Supplies the interface type for which a descriptive</span>
08748 <span class="comment">        name is to be retrieved.</span>
08749 <span class="comment"></span>
08750 <span class="comment">    Buffer - Supplies a pointer to a unicode character buffer that will</span>
08751 <span class="comment">        receive the bus name.  Since this buffer is used in an</span>
08752 <span class="comment">        intermediate step to retrieve a KEY_VALUE_FULL_INFORMATION structure,</span>
08753 <span class="comment">        it must be large enough to contain this structure (including the</span>
08754 <span class="comment">        longest value name &amp; data length under KeyHandle).</span>
08755 <span class="comment"></span>
08756 <span class="comment">    Length - Supplies the length, in bytes, of the Buffer.</span>
08757 <span class="comment"></span>
08758 <span class="comment">    BusFlags - Optionally receives the flags specified in the second</span>
08759 <span class="comment">        DWORD of the matching REG_BINARY value.</span>
08760 <span class="comment"></span>
08761 <span class="comment">Return Value:</span>
08762 <span class="comment"></span>
08763 <span class="comment">    The function value is the final status of the operation.</span>
08764 <span class="comment"></span>
08765 <span class="comment">--*/</span>
08766 {
08767     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>                        status;
08768     ULONG                           <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>, junk, i, j;
08769     PULONG                          pl;
08770     PKEY_VALUE_FULL_INFORMATION     KeyInformation;
08771     WCHAR                           <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a35">c</a>;
08772 
08773     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
08774 
08775     <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0;
08776     KeyInformation = (PKEY_VALUE_FULL_INFORMATION) <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>;
08777 
08778     <span class="keywordflow">for</span> (; ;) {
08779         status = ZwEnumerateValueKey (
08780                         KeyHandle,
08781                         <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>++,
08782                         KeyValueFullInformation,
08783                         <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>,
08784                         Length,
08785                         &amp;junk
08786                         );
08787 
08788         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a> (status)) {
08789             <span class="keywordflow">return</span> status;
08790         }
08791 
08792         <span class="keywordflow">if</span> (KeyInformation-&gt;Type != REG_BINARY) {
08793             <span class="keywordflow">continue</span>;
08794         }
08795 
08796         pl = (PULONG) ((PUCHAR) KeyInformation + KeyInformation-&gt;DataOffset);
08797         <span class="keywordflow">if</span> ((ULONG) <a class="code" href="../../d4/d0/cmconfig_8c.html#a5">InterfaceType</a> != pl[0]) {
08798             <span class="keywordflow">continue</span>;
08799         }
08800 
08801         <span class="comment">//</span>
08802         <span class="comment">// Found a match - move the name to the start of the buffer</span>
08803         <span class="comment">//</span>
08804 
08805         <span class="keywordflow">if</span>(ARGUMENT_PRESENT(BusFlags)) {
08806             *BusFlags = pl[1];
08807         }
08808 
08809         j = KeyInformation-&gt;NameLength / <span class="keyword">sizeof</span> (WCHAR);
08810         <span class="keywordflow">for</span> (i=0; i &lt; j; i++) {
08811             <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a35">c</a> = KeyInformation-&gt;Name[i];
08812             <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>[i] = <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a35">c</a>;
08813         }
08814 
08815         <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>[i] = 0;
08816         <span class="keywordflow">return</span> STATUS_SUCCESS;
08817     }
08818 }
08819 
08820 
08821 BOOLEAN
<a name="l08822"></a><a class="code" href="../../d0/d6/iop_8h.html#a223">08822</a> <a class="code" href="../../d0/d6/iop_8h.html#a223">IopSafebootDriverLoad</a>(
08823     PUNICODE_STRING DriverId
08824     )
08825 <span class="comment">/*++</span>
08826 <span class="comment"></span>
08827 <span class="comment">Routine Description:</span>
08828 <span class="comment"></span>
08829 <span class="comment">    Checks to see if a driver or service is included</span>
08830 <span class="comment">    in the current safeboot registry section.</span>
08831 <span class="comment"></span>
08832 <span class="comment">Arguments:</span>
08833 <span class="comment"></span>
08834 <span class="comment">    DriverId - Specifies which driver is to be validated.</span>
08835 <span class="comment">        The string should contain a driver executable name</span>
08836 <span class="comment">        like foo.sys or a GUID for a pnp driver class.</span>
08837 <span class="comment"></span>
08838 <span class="comment">Return Value:</span>
08839 <span class="comment"></span>
08840 <span class="comment">    TRUE    - driver/service is in the registry</span>
08841 <span class="comment">    FALSE   - driver/service is NOT in the registry</span>
08842 <span class="comment"></span>
08843 <span class="comment">--*/</span>
08844 {
08845     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
08846     HANDLE hSafeBoot,hGuid;
08847     UNICODE_STRING safeBootKey;
08848     UNICODE_STRING SafeBootTypeString;
08849 
08850 
08851 
08852     <span class="comment">//</span>
08853     <span class="comment">// set the first part of the registry key name</span>
08854     <span class="comment">//</span>
08855 
08856     <span class="keywordflow">switch</span> (<a class="code" href="../../d8/d1/init_8h.html#a18">InitSafeBootMode</a>) {
08857         <span class="keywordflow">case</span> SAFEBOOT_MINIMAL:
08858             <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;SafeBootTypeString,SAFEBOOT_MINIMAL_STR_W);
08859             <span class="keywordflow">break</span>;
08860 
08861         <span class="keywordflow">case</span> SAFEBOOT_NETWORK:
08862             <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;SafeBootTypeString,SAFEBOOT_NETWORK_STR_W);
08863             <span class="keywordflow">break</span>;
08864 
08865         <span class="keywordflow">case</span> SAFEBOOT_DSREPAIR:
08866             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
08867 
08868         <span class="keywordflow">default</span>:
08869             KdPrint((<span class="stringliteral">"SAFEBOOT: invalid safeboot option = %d\n"</span>,<a class="code" href="../../d8/d1/init_8h.html#a18">InitSafeBootMode</a>));
08870             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
08871     }
08872 
08873     safeBootKey.Length = 0;
08874     safeBootKey.MaximumLength = DriverId-&gt;Length + SafeBootTypeString.Length + (4*<span class="keyword">sizeof</span>(WCHAR));
08875     safeBootKey.Buffer = (PWCHAR)<a class="code" href="../../d5/d5/cc_8h.html#a10">ExAllocatePool</a>(<a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>,safeBootKey.MaximumLength);
08876     <span class="keywordflow">if</span> (!safeBootKey.Buffer) {
08877         KdPrint((<span class="stringliteral">"SAFEBOOT: could not allocate pool\n"</span>));
08878         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
08879     }
08880 
08881     <a class="code" href="../../d6/d6/nls_8c.html#a44">RtlCopyUnicodeString</a>(&amp;safeBootKey,&amp;SafeBootTypeString);
08882     status = <a class="code" href="../../d6/d6/nls_8c.html#a45">RtlAppendUnicodeToString</a>(&amp;safeBootKey,<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"\\"</span>);
08883     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
08884         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (safeBootKey.Buffer);
08885         KdPrint((<span class="stringliteral">"SAFEBOOT: could not create registry key string = %x\n"</span>,status));
08886         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
08887     }
08888     status = <a class="code" href="../../d6/d6/nls_8c.html#a46">RtlAppendUnicodeStringToString</a>(&amp;safeBootKey,DriverId);
08889     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
08890         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (safeBootKey.Buffer);
08891         KdPrint((<span class="stringliteral">"SAFEBOOT: could not create registry key string = %x\n"</span>,status));
08892         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
08893     }
08894 
08895     status = <a class="code" href="../../d0/d6/iop_8h.html#a198">IopOpenRegistryKey</a> (
08896         &amp;hSafeBoot,
08897         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
08898         &amp;<a class="code" href="../../d6/d0/cmdat_8c.html#a28">CmRegistryMachineSystemCurrentControlSetControlSafeBoot</a>,
08899         KEY_ALL_ACCESS,
08900         <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>
08901         );
08902     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
08903         status = <a class="code" href="../../d0/d6/iop_8h.html#a198">IopOpenRegistryKey</a> (
08904             &amp;hGuid,
08905             hSafeBoot,
08906             &amp;safeBootKey,
08907             KEY_ALL_ACCESS,
08908             <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>
08909             );
08910         <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>(hSafeBoot);
08911         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status)) {
08912             <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>(hGuid);
08913             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(safeBootKey.Buffer);
08914             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
08915         }
08916     }
08917 
08918     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(safeBootKey.Buffer);
08919 
08920     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
08921 }
08922 
08923 
08924 
<a name="l08925"></a><a class="code" href="../../d2/d4/internal_8c.html#a12">08925</a> <span class="keyword">static</span> <a class="code" href="../../d6/d4/struct__BOOT__LOG__RECORD.html">PBOOT_LOG_RECORD</a> <a class="code" href="../../d2/d4/internal_8c.html#a12">BootLogRecord</a>;
08926 
08927 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l08928"></a><a class="code" href="../../d2/d4/internal_8c.html#a74">08928</a> <a class="code" href="../../d2/d4/internal_8c.html#a74">IopInitializeBootLogging</a>(
08929     <a class="code" href="../../d1/d2/struct__LOADER__PARAMETER__BLOCK.html">PLOADER_PARAMETER_BLOCK</a> LoaderBlock,
08930     PCHAR HeaderString
08931     )
08932 <span class="comment">/*++</span>
08933 <span class="comment"></span>
08934 <span class="comment">Routine Description:</span>
08935 <span class="comment"></span>
08936 <span class="comment">    Initializes strings for boot logging.</span>
08937 <span class="comment"></span>
08938 <span class="comment">Arguments:</span>
08939 <span class="comment"></span>
08940 <span class="comment">    LoaderBlock - the loader parameter block</span>
08941 <span class="comment"></span>
08942 <span class="comment">Return Value:</span>
08943 <span class="comment"></span>
08944 <span class="comment">    VOID</span>
08945 <span class="comment"></span>
08946 <span class="comment">--*/</span>
08947 {
08948     PLDR_DATA_TABLE_ENTRY DataTableEntry;
08949     PMESSAGE_RESOURCE_ENTRY MessageEntry;
08950     ULONG MsgId = 0;
08951     ANSI_STRING AnsiString;
08952     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
08953     PLIST_ENTRY nextEntry;
08954     PLDR_DATA_TABLE_ENTRY driverEntry;
08955 
08956 
08957     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
08958 
08959     <span class="keywordflow">if</span> (<a class="code" href="../../d2/d4/internal_8c.html#a12">BootLogRecord</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
08960         <span class="keywordflow">return</span>;
08961     }
08962 
08963     <a class="code" href="../../d2/d4/internal_8c.html#a12">BootLogRecord</a> = (<a class="code" href="../../d6/d4/struct__BOOT__LOG__RECORD.html">PBOOT_LOG_RECORD</a>) <a class="code" href="../../d5/d5/cc_8h.html#a10">ExAllocatePool</a>(<a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, <span class="keyword">sizeof</span>(<a class="code" href="../../d6/d4/struct__BOOT__LOG__RECORD.html">BOOT_LOG_RECORD</a>));
08964 
08965     <span class="keywordflow">if</span> (<a class="code" href="../../d2/d4/internal_8c.html#a12">BootLogRecord</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
08966         <span class="keywordflow">return</span>;
08967     }
08968 
08969     RtlZeroMemory(<a class="code" href="../../d2/d4/internal_8c.html#a12">BootLogRecord</a>, <span class="keyword">sizeof</span>(<a class="code" href="../../d0/d5/io_8h.html#a400">BOOT_LOG_RECORD</a>));
08970 
08971     <a class="code" href="../../d5/d8/ex_8h.html#a68">ExInitializeResource</a>(&amp;<a class="code" href="../../d2/d4/internal_8c.html#a12">BootLogRecord</a>-&gt;<a class="code" href="../../d6/d4/struct__BOOT__LOG__RECORD.html#o4">Resource</a>);
08972 
08973     <a class="code" href="../../d5/d8/ex_8h.html#a70">ExAcquireResourceExclusive</a>(&amp;<a class="code" href="../../d2/d4/internal_8c.html#a12">BootLogRecord</a>-&gt;<a class="code" href="../../d6/d4/struct__BOOT__LOG__RECORD.html#o4">Resource</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
08974 
08975     DataTableEntry = CONTAINING_RECORD(LoaderBlock-&gt;<a class="code" href="../../d1/d2/struct__LOADER__PARAMETER__BLOCK.html#o0">LoadOrderListHead</a>.Flink,
08976                                         LDR_DATA_TABLE_ENTRY,
08977                                         InLoadOrderLinks);
08978 
08979     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d0/d8/message_8c.html#a1">RtlFindMessage</a> (DataTableEntry-&gt;DllBase, 11, 0, BOOTLOG_LOADED, &amp;MessageEntry);
08980 
08981     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
08982         AnsiString.Buffer = MessageEntry-&gt;Text;
08983         AnsiString.Length = <a class="code" href="../../d2/d7/regtest_8c.html#a2">strlen</a>(MessageEntry-&gt;Text);
08984         AnsiString.MaximumLength = AnsiString.Length + 1;
08985 
08986         <a class="code" href="../../d6/d6/nls_8c.html#a21">RtlAnsiStringToUnicodeString</a>(&amp;<a class="code" href="../../d2/d4/internal_8c.html#a12">BootLogRecord</a>-&gt;<a class="code" href="../../d6/d4/struct__BOOT__LOG__RECORD.html#o0">LoadedString</a>, &amp;AnsiString, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
08987 
08988         <span class="comment">// whack the crlf at the end of the string</span>
08989 
08990         <span class="keywordflow">if</span> (<a class="code" href="../../d2/d4/internal_8c.html#a12">BootLogRecord</a>-&gt;<a class="code" href="../../d6/d4/struct__BOOT__LOG__RECORD.html#o0">LoadedString</a>.Length &gt; 2 * <span class="keyword">sizeof</span>(WCHAR)) {
08991             <a class="code" href="../../d2/d4/internal_8c.html#a12">BootLogRecord</a>-&gt;<a class="code" href="../../d6/d4/struct__BOOT__LOG__RECORD.html#o0">LoadedString</a>.Length -= 2 * <span class="keyword">sizeof</span>(WCHAR);
08992             <a class="code" href="../../d2/d4/internal_8c.html#a12">BootLogRecord</a>-&gt;<a class="code" href="../../d6/d4/struct__BOOT__LOG__RECORD.html#o0">LoadedString</a>.Buffer[<a class="code" href="../../d2/d4/internal_8c.html#a12">BootLogRecord</a>-&gt;<a class="code" href="../../d6/d4/struct__BOOT__LOG__RECORD.html#o0">LoadedString</a>.Length / <span class="keyword">sizeof</span>(WCHAR)] = UNICODE_NULL;
08993         }
08994     }
08995 
08996     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d0/d8/message_8c.html#a1">RtlFindMessage</a> (DataTableEntry-&gt;DllBase, 11, 0, BOOTLOG_NOT_LOADED, &amp;MessageEntry);
08997 
08998     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
08999         AnsiString.Buffer = MessageEntry-&gt;Text;
09000         AnsiString.Length = <a class="code" href="../../d2/d7/regtest_8c.html#a2">strlen</a>(MessageEntry-&gt;Text);
09001         AnsiString.MaximumLength = AnsiString.Length + 1;
09002 
09003         <a class="code" href="../../d6/d6/nls_8c.html#a21">RtlAnsiStringToUnicodeString</a>(&amp;<a class="code" href="../../d2/d4/internal_8c.html#a12">BootLogRecord</a>-&gt;<a class="code" href="../../d6/d4/struct__BOOT__LOG__RECORD.html#o1">NotLoadedString</a>, &amp;AnsiString, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
09004 
09005         <span class="comment">// whack the crlf at the end of the string</span>
09006 
09007         <span class="keywordflow">if</span> (<a class="code" href="../../d2/d4/internal_8c.html#a12">BootLogRecord</a>-&gt;<a class="code" href="../../d6/d4/struct__BOOT__LOG__RECORD.html#o1">NotLoadedString</a>.Length &gt; 2 * <span class="keyword">sizeof</span>(WCHAR)) {
09008             <a class="code" href="../../d2/d4/internal_8c.html#a12">BootLogRecord</a>-&gt;<a class="code" href="../../d6/d4/struct__BOOT__LOG__RECORD.html#o1">NotLoadedString</a>.Length -= 2 * <span class="keyword">sizeof</span>(WCHAR);
09009             <a class="code" href="../../d2/d4/internal_8c.html#a12">BootLogRecord</a>-&gt;<a class="code" href="../../d6/d4/struct__BOOT__LOG__RECORD.html#o1">NotLoadedString</a>.Buffer[<a class="code" href="../../d2/d4/internal_8c.html#a12">BootLogRecord</a>-&gt;<a class="code" href="../../d6/d4/struct__BOOT__LOG__RECORD.html#o1">NotLoadedString</a>.Length / <span class="keyword">sizeof</span>(WCHAR)] = UNICODE_NULL;
09010         }
09011     }
09012 
09013     <span class="comment">// The header string (copied from DebugString in Phase1Initialization) appears to have a leading null byte</span>
09014 
09015     HeaderString++;
09016 
09017     <a class="code" href="../../d2/d7/string_8c.html#a13">RtlCreateUnicodeStringFromAsciiz</a>(&amp;<a class="code" href="../../d2/d4/internal_8c.html#a12">BootLogRecord</a>-&gt;<a class="code" href="../../d6/d4/struct__BOOT__LOG__RECORD.html#o3">HeaderString</a>, HeaderString);
09018 
09019     <span class="comment">// Log the drivers loaded by the boot loader</span>
09020 
09021     <a class="code" href="../../d5/d8/ex_8h.html#a69">ExAcquireResourceShared</a>( &amp;<a class="code" href="../../d1/d9/ps_8h.html#a57">PsLoadedModuleResource</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
09022     nextEntry = <a class="code" href="../../d1/d9/ps_8h.html#a56">PsLoadedModuleList</a>.Flink;
09023     <span class="keywordflow">while</span> (nextEntry != &amp;<a class="code" href="../../d1/d9/ps_8h.html#a56">PsLoadedModuleList</a>) {
09024 
09025         <span class="comment">//</span>
09026         <span class="comment">// Look at the next boot driver in the list.</span>
09027         <span class="comment">//</span>
09028 
09029         driverEntry = CONTAINING_RECORD( nextEntry,
09030                                          LDR_DATA_TABLE_ENTRY,
09031                                          InLoadOrderLinks );
09032 
09033         <span class="keywordflow">if</span> (driverEntry-&gt;Flags &amp; LDRP_ENTRY_PROCESSED){
09034             <a class="code" href="../../d2/d4/internal_8c.html#a75">IopBootLog</a>(&amp;driverEntry-&gt;FullDllName, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
09035         }
09036 
09037         nextEntry = nextEntry-&gt;Flink;
09038     }
09039 
09040     <a class="code" href="../../d5/d8/ex_8h.html#a66">ExReleaseResource</a>( &amp;<a class="code" href="../../d1/d9/ps_8h.html#a57">PsLoadedModuleResource</a> );
09041 
09042     <a class="code" href="../../d5/d8/ex_8h.html#a66">ExReleaseResource</a>(&amp;<a class="code" href="../../d2/d4/internal_8c.html#a12">BootLogRecord</a>-&gt;<a class="code" href="../../d6/d4/struct__BOOT__LOG__RECORD.html#o4">Resource</a>);
09043 }
09044 
09045 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l09046"></a><a class="code" href="../../d2/d4/internal_8c.html#a75">09046</a> <a class="code" href="../../d2/d4/internal_8c.html#a75">IopBootLog</a>(
09047     PUNICODE_STRING LogEntry,
09048     BOOLEAN Loaded
09049     )
09050 <span class="comment">/*++</span>
09051 <span class="comment"></span>
09052 <span class="comment">Routine Description:</span>
09053 <span class="comment"></span>
09054 <span class="comment">    Create and write out a log entry.  Before NtInitializeRegistry is called, log entries are spooled</span>
09055 <span class="comment">    into the registry.  When NtInitalizeRegistry is called by the session manager, the</span>
09056 <span class="comment">    log file is created if necessary and truncated.  Log entries in the registry are</span>
09057 <span class="comment">    then copied into the log file and the registry entries are deleted.</span>
09058 <span class="comment"></span>
09059 <span class="comment">Arguments:</span>
09060 <span class="comment"></span>
09061 <span class="comment">    LogEntry - the text to log.</span>
09062 <span class="comment">    Loaded - indicates whether to prepend the "Loaded" string or the "Not Loaded" string.</span>
09063 <span class="comment"></span>
09064 <span class="comment">Return Value:</span>
09065 <span class="comment"></span>
09066 <span class="comment">    VOID</span>
09067 <span class="comment"></span>
09068 <span class="comment"></span>
09069 <span class="comment">--*/</span>
09070 {
09071     WCHAR NameBuffer[BOOTLOG_STRSIZE];
09072     UNICODE_STRING <a class="code" href="../../d8/d0/rtbatcr_8c.html#a3">KeyName</a>;
09073     UNICODE_STRING <a class="code" href="../../d1/d1/rtdelval_8c.html#a3">ValueName</a>;
09074     UNICODE_STRING CrLf;
09075     UNICODE_STRING <a class="code" href="../../d7/d0/cmdat2_8c.html#a32">Space</a>;
09076     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
09077 
09078     WCHAR MessageBuffer[BOOTLOG_STRSIZE];
09079     UNICODE_STRING MessageString = {
09080         0,
09081         BOOTLOG_STRSIZE,
09082         &amp;MessageBuffer[0]
09083     };
09084 
09085     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
09086 
09087     <span class="keywordflow">if</span> (<a class="code" href="../../d2/d4/internal_8c.html#a12">BootLogRecord</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
09088         <span class="keywordflow">return</span>;
09089     }
09090 
09091     <a class="code" href="../../d5/d8/ex_8h.html#a70">ExAcquireResourceExclusive</a>(&amp;<a class="code" href="../../d2/d4/internal_8c.html#a12">BootLogRecord</a>-&gt;<a class="code" href="../../d6/d4/struct__BOOT__LOG__RECORD.html#o4">Resource</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
09092 
09093     <span class="keywordflow">if</span> (Loaded) {
09094         <a class="code" href="../../d6/d6/nls_8c.html#a44">RtlCopyUnicodeString</a>(&amp;MessageString, &amp;<a class="code" href="../../d2/d4/internal_8c.html#a12">BootLogRecord</a>-&gt;<a class="code" href="../../d6/d4/struct__BOOT__LOG__RECORD.html#o0">LoadedString</a>);
09095     } <span class="keywordflow">else</span> {
09096         <a class="code" href="../../d6/d6/nls_8c.html#a44">RtlCopyUnicodeString</a>(&amp;MessageString, &amp;<a class="code" href="../../d2/d4/internal_8c.html#a12">BootLogRecord</a>-&gt;<a class="code" href="../../d6/d4/struct__BOOT__LOG__RECORD.html#o1">NotLoadedString</a>);
09097     }
09098 
09099     <span class="comment">// add a space after the message prefix</span>
09100 
09101     <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;<a class="code" href="../../d7/d0/cmdat2_8c.html#a32">Space</a>, <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">" "</span>);
09102 
09103     <a class="code" href="../../d6/d6/nls_8c.html#a46">RtlAppendUnicodeStringToString</a>(&amp;MessageString, &amp;<a class="code" href="../../d7/d0/cmdat2_8c.html#a32">Space</a>);
09104 
09105     <a class="code" href="../../d6/d6/nls_8c.html#a46">RtlAppendUnicodeStringToString</a>(&amp;MessageString, LogEntry);
09106 
09107     <span class="comment">// add a CR LF</span>
09108 
09109     <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;CrLf, <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"\r\n"</span>);
09110     <a class="code" href="../../d6/d6/nls_8c.html#a46">RtlAppendUnicodeStringToString</a>(&amp;MessageString, &amp;CrLf);
09111 
09112     swprintf(NameBuffer, <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"%d"</span>, <a class="code" href="../../d2/d4/internal_8c.html#a12">BootLogRecord</a>-&gt;<a class="code" href="../../d6/d4/struct__BOOT__LOG__RECORD.html#o5">NextKey</a>++);
09113 
09114     <a class="code" href="../../d6/d6/nls_8c.html#a47">RtlCreateUnicodeString</a>(&amp;<a class="code" href="../../d8/d0/rtbatcr_8c.html#a3">KeyName</a>, NameBuffer);
09115     <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;<a class="code" href="../../d1/d1/rtdelval_8c.html#a3">ValueName</a>, <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">""</span>);
09116 
09117     <span class="keywordflow">if</span> (!<a class="code" href="../../d2/d4/internal_8c.html#a12">BootLogRecord</a>-&gt;<a class="code" href="../../d6/d4/struct__BOOT__LOG__RECORD.html#o6">FileLogging</a>) {
09118         HANDLE hLogKey, hBootKey;
09119 
09120         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d0/d6/iop_8h.html#a198">IopOpenRegistryKey</a> (
09121             &amp;hBootKey,
09122             <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
09123             &amp;<a class="code" href="../../d6/d0/cmdat_8c.html#a30">CmRegistryMachineSystemCurrentControlSetControlBootLog</a>,
09124             KEY_ALL_ACCESS,
09125             <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>
09126             );
09127 
09128         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
09129             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d0/d6/iop_8h.html#a198">IopOpenRegistryKey</a> (
09130                 &amp;hLogKey,
09131                 hBootKey,
09132                 &amp;<a class="code" href="../../d8/d0/rtbatcr_8c.html#a3">KeyName</a>,
09133                 KEY_ALL_ACCESS,
09134                 <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>
09135                 );
09136             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
09137                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d8/d0/pnpioapi_8c.html#a67">IopSetRegistryStringValue</a>(
09138                     hLogKey,
09139                     &amp;<a class="code" href="../../d1/d1/rtdelval_8c.html#a3">ValueName</a>,
09140                     &amp;MessageString
09141                     );
09142                 ZwClose(hLogKey);
09143             }
09144             ZwClose(hBootKey);
09145         }
09146 
09147     } <span class="keywordflow">else</span> {
09148         <a class="code" href="../../d2/d4/internal_8c.html#a17">IopBootLogToFile</a>( &amp;MessageString );
09149     }
09150 
09151     <a class="code" href="../../d6/d6/nls_8c.html#a34">RtlFreeUnicodeString</a>(&amp;<a class="code" href="../../d8/d0/rtbatcr_8c.html#a3">KeyName</a>);
09152 
09153     <a class="code" href="../../d5/d8/ex_8h.html#a66">ExReleaseResource</a>(&amp;<a class="code" href="../../d2/d4/internal_8c.html#a12">BootLogRecord</a>-&gt;<a class="code" href="../../d6/d4/struct__BOOT__LOG__RECORD.html#o4">Resource</a>);
09154 }
09155 
09156 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l09157"></a><a class="code" href="../../d0/d5/io_8h.html#a584">09157</a> <a class="code" href="../../d2/d4/internal_8c.html#a18">IopCopyBootLogRegistryToFile</a>(
09158     VOID
09159     )
09160 <span class="comment">/*++</span>
09161 <span class="comment"></span>
09162 <span class="comment">Routine Description:</span>
09163 <span class="comment"></span>
09164 <span class="comment">    Copy the text in the registry entries into the log file and delete the registry entries.  Set the</span>
09165 <span class="comment">    flag that indicates direct logging to the log file.</span>
09166 <span class="comment"></span>
09167 <span class="comment">Arguments:</span>
09168 <span class="comment"></span>
09169 <span class="comment">    NONE</span>
09170 <span class="comment"></span>
09171 <span class="comment">Return Value:</span>
09172 <span class="comment"></span>
09173 <span class="comment">    VOID</span>
09174 <span class="comment"></span>
09175 <span class="comment"></span>
09176 <span class="comment">--*/</span>
09177 {
09178     UNICODE_STRING <a class="code" href="../../d8/d0/rtbatcr_8c.html#a3">KeyName</a>;
09179     WCHAR NameBuffer[BOOTLOG_STRSIZE];
09180     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
09181     HANDLE hLogKey, hBootKey;
09182     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
09183     PKEY_VALUE_FULL_INFORMATION Information;
09184     IO_STATUS_BLOCK IoStatus;
09185     LARGE_INTEGER LocalTime;
09186     TIME_FIELDS <a class="code" href="../../d6/d6/ttime_8c.html#a13">TimeFields</a>;
09187     <a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a> AnsiTimeBuffer[256];
09188     ANSI_STRING AnsiTimeString;
09189     UNICODE_STRING UnicodeTimeString;
09190     UNICODE_STRING LogString;
09191 
09192     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
09193 
09194     <span class="keywordflow">if</span> (<a class="code" href="../../d2/d4/internal_8c.html#a12">BootLogRecord</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
09195         <span class="keywordflow">return</span>;
09196     }
09197 
09198     <a class="code" href="../../d5/d8/ex_8h.html#a70">ExAcquireResourceExclusive</a>(&amp;<a class="code" href="../../d2/d4/internal_8c.html#a12">BootLogRecord</a>-&gt;<a class="code" href="../../d6/d4/struct__BOOT__LOG__RECORD.html#o4">Resource</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
09199 
09200     <a class="code" href="../../d2/d4/internal_8c.html#a17">IopBootLogToFile</a>(&amp;<a class="code" href="../../d2/d4/internal_8c.html#a12">BootLogRecord</a>-&gt;<a class="code" href="../../d6/d4/struct__BOOT__LOG__RECORD.html#o3">HeaderString</a>);
09201 
09202     <a class="code" href="../../d5/d8/ex_8h.html#a317">ExSystemTimeToLocalTime</a>(&amp;<a class="code" href="../../d4/d9/ke_8h.html#a124">KeBootTime</a>, &amp;LocalTime);
09203 
09204     <a class="code" href="../../d1/d2/time_8c.html#a26">RtlTimeToTimeFields</a>(&amp;LocalTime, &amp;<a class="code" href="../../d6/d6/ttime_8c.html#a13">TimeFields</a>);
09205 
09206     <a class="code" href="../../d6/d9/heappage_8c.html#a68">sprintf</a>(
09207         AnsiTimeBuffer,
09208         <span class="stringliteral">"%2d %2d %4d %02d:%02d:%02d.%03d\r\n"</span>,
09209         <a class="code" href="../../d6/d6/ttime_8c.html#a13">TimeFields</a>.Month,
09210         <a class="code" href="../../d6/d6/ttime_8c.html#a13">TimeFields</a>.Day,
09211         <a class="code" href="../../d6/d6/ttime_8c.html#a13">TimeFields</a>.Year,
09212         <a class="code" href="../../d6/d6/ttime_8c.html#a13">TimeFields</a>.Hour,
09213         <a class="code" href="../../d6/d6/ttime_8c.html#a13">TimeFields</a>.Minute,
09214         <a class="code" href="../../d6/d6/ttime_8c.html#a13">TimeFields</a>.Second,
09215         <a class="code" href="../../d6/d6/ttime_8c.html#a13">TimeFields</a>.Milliseconds
09216     );
09217 
09218     <a class="code" href="../../d2/d7/string_8c.html#a6">RtlInitAnsiString</a>(&amp;AnsiTimeString, AnsiTimeBuffer);
09219 
09220     <a class="code" href="../../d6/d6/nls_8c.html#a21">RtlAnsiStringToUnicodeString</a>(&amp;UnicodeTimeString, &amp;AnsiTimeString, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
09221 
09222     <a class="code" href="../../d2/d4/internal_8c.html#a17">IopBootLogToFile</a>(&amp;UnicodeTimeString);
09223 
09224     <a class="code" href="../../d6/d6/nls_8c.html#a34">RtlFreeUnicodeString</a>(&amp;UnicodeTimeString);
09225 
09226     <span class="comment">//</span>
09227     <span class="comment">// Read all of the strings in the registry and write them to the log file.</span>
09228     <span class="comment">// Delete the registry keys when done.</span>
09229     <span class="comment">//</span>
09230 
09231     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d0/d6/iop_8h.html#a198">IopOpenRegistryKey</a> (
09232         &amp;hBootKey,
09233         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
09234         &amp;<a class="code" href="../../d6/d0/cmdat_8c.html#a30">CmRegistryMachineSystemCurrentControlSetControlBootLog</a>,
09235         KEY_ALL_ACCESS,
09236         <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>
09237         );
09238 
09239     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
09240         <span class="keywordflow">for</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; <a class="code" href="../../d2/d4/internal_8c.html#a12">BootLogRecord</a>-&gt;<a class="code" href="../../d6/d4/struct__BOOT__LOG__RECORD.html#o5">NextKey</a>; <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>++) {
09241             swprintf(NameBuffer, <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"%d"</span>, <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>);
09242 
09243             <a class="code" href="../../d6/d6/nls_8c.html#a47">RtlCreateUnicodeString</a>(&amp;<a class="code" href="../../d8/d0/rtbatcr_8c.html#a3">KeyName</a>, NameBuffer);
09244 
09245             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d0/d6/iop_8h.html#a198">IopOpenRegistryKey</a> (
09246                 &amp;hLogKey,
09247                 hBootKey,
09248                 &amp;<a class="code" href="../../d8/d0/rtbatcr_8c.html#a3">KeyName</a>,
09249                 KEY_ALL_ACCESS,
09250                 <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>
09251                 );
09252 
09253             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
09254                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d5/ioep_8h.html#a52">IopGetRegistryValue</a>(
09255                     hLogKey,
09256                     <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">""</span>,
09257                     &amp;Information
09258                     );
09259 
09260                 <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)){
09261                     <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;LogString, (PWSTR) ((PUCHAR)Information + Information-&gt;DataOffset));
09262                     <a class="code" href="../../d2/d4/internal_8c.html#a17">IopBootLogToFile</a>(&amp;LogString);
09263                 }
09264                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(Information);
09265                 ZwDeleteKey(hLogKey);
09266                 ZwClose(hLogKey);
09267             }
09268         }
09269         ZwDeleteKey(hBootKey);
09270         ZwClose(hBootKey);
09271 
09272         <span class="comment">//</span>
09273         <span class="comment">// Write directly to the file from now on.</span>
09274         <span class="comment">//</span>
09275 
09276         <a class="code" href="../../d2/d4/internal_8c.html#a12">BootLogRecord</a>-&gt;<a class="code" href="../../d6/d4/struct__BOOT__LOG__RECORD.html#o6">FileLogging</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
09277     }
09278 
09279     <a class="code" href="../../d5/d8/ex_8h.html#a66">ExReleaseResource</a>(&amp;<a class="code" href="../../d2/d4/internal_8c.html#a12">BootLogRecord</a>-&gt;<a class="code" href="../../d6/d4/struct__BOOT__LOG__RECORD.html#o4">Resource</a>);
09280 }
09281 
09282 
09283 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l09284"></a><a class="code" href="../../d2/d4/internal_8c.html#a17">09284</a> <a class="code" href="../../d2/d4/internal_8c.html#a17">IopBootLogToFile</a>(
09285     PUNICODE_STRING String
09286     )
09287 <span class="comment">/*++</span>
09288 <span class="comment"></span>
09289 <span class="comment">Routine Description:</span>
09290 <span class="comment"></span>
09291 <span class="comment">    Write the buffer into the log file.</span>
09292 <span class="comment"></span>
09293 <span class="comment">Arguments:</span>
09294 <span class="comment"></span>
09295 <span class="comment">    Buffer - pointer to the string to write out.</span>
09296 <span class="comment">    Length - number of bytes to write</span>
09297 <span class="comment"></span>
09298 <span class="comment">Return Value:</span>
09299 <span class="comment"></span>
09300 <span class="comment">    The function status is the final status of the operation.</span>
09301 <span class="comment"></span>
09302 <span class="comment"></span>
09303 <span class="comment">--*/</span>
09304 {
09305     OBJECT_ATTRIBUTES ObjA;
09306     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
09307     IO_STATUS_BLOCK IoStatusBlock;
09308     HANDLE FileHandle;
09309     WCHAR UnicodeHeader = 0xfeff;
09310 
09311 
09312     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
09313 
09314     <span class="keywordflow">if</span> (<a class="code" href="../../d2/d4/internal_8c.html#a12">BootLogRecord</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
09315         <span class="keywordflow">return</span> STATUS_SUCCESS;
09316     }
09317 
09318     <a class="code" href="../../d5/d8/ex_8h.html#a70">ExAcquireResourceExclusive</a>(&amp;<a class="code" href="../../d2/d4/internal_8c.html#a12">BootLogRecord</a>-&gt;<a class="code" href="../../d6/d4/struct__BOOT__LOG__RECORD.html#o4">Resource</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
09319 
09320     <span class="keywordflow">if</span> (<a class="code" href="../../d2/d4/internal_8c.html#a12">BootLogRecord</a>-&gt;<a class="code" href="../../d6/d4/struct__BOOT__LOG__RECORD.html#o2">LogFileName</a>.Buffer == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
09321         <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>(&amp;<a class="code" href="../../d2/d4/internal_8c.html#a12">BootLogRecord</a>-&gt;<a class="code" href="../../d6/d4/struct__BOOT__LOG__RECORD.html#o2">LogFileName</a>, <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"\\SystemRoot\\ntbtlog.txt"</span>);
09322     }
09323 
09324     InitializeObjectAttributes(&amp;ObjA, &amp;<a class="code" href="../../d2/d4/internal_8c.html#a12">BootLogRecord</a>-&gt;<a class="code" href="../../d6/d4/struct__BOOT__LOG__RECORD.html#o2">LogFileName</a>, OBJ_CASE_INSENSITIVE, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
09325 
09326     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d9/restrfil_8c.html#a31">ZwCreateFile</a>(&amp;FileHandle,
09327                             GENERIC_WRITE,
09328                             &amp;ObjA,
09329                             &amp;IoStatusBlock,
09330                             <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
09331                             FILE_ATTRIBUTE_NORMAL,
09332                             FILE_SHARE_READ,
09333                             FILE_OPEN_IF,
09334                             FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE | FILE_SEQUENTIAL_ONLY,
09335                             <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
09336                             0
09337                             );
09338 
09339     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>) &amp;&amp; IoStatusBlock.Information == FILE_CREATED) {
09340 
09341         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwWriteFile(
09342                     FileHandle,
09343                     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
09344                     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
09345                     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
09346                     &amp;IoStatusBlock,
09347                     (PVOID) &amp;UnicodeHeader,
09348                     <span class="keyword">sizeof</span>(WCHAR),
09349                     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
09350                     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
09351                     );
09352 
09353     }
09354 
09355     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
09356 
09357         LARGE_INTEGER EndOfFile;
09358 
09359         EndOfFile.HighPart = 0xffffffff;
09360         EndOfFile.LowPart = FILE_WRITE_TO_END_OF_FILE;
09361 
09362         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwWriteFile(
09363                     FileHandle,
09364                     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
09365                     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
09366                     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
09367                     &amp;IoStatusBlock,
09368                     (PVOID) <a class="code" href="../../d4/d9/talloc_8c.html#a0">String</a>-&gt;Buffer,
09369                     <a class="code" href="../../d4/d9/talloc_8c.html#a0">String</a>-&gt;Length,
09370                     &amp;EndOfFile,
09371                     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
09372                     );
09373 
09374         ZwClose(FileHandle);
09375     }
09376 
09377     <a class="code" href="../../d5/d8/ex_8h.html#a66">ExReleaseResource</a>(&amp;<a class="code" href="../../d2/d4/internal_8c.html#a12">BootLogRecord</a>-&gt;<a class="code" href="../../d6/d4/struct__BOOT__LOG__RECORD.html#o4">Resource</a>);
09378 
09379     <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
09380 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:24 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
