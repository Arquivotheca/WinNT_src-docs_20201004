<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: alpha.h Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>alpha.h</h1><a href="../../d2/d7/alpha_8h.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1993  Digital Equipment Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">   alpha.h</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">   The Alpha hardware specific header file.</span>
00012 <span class="comment"></span>
00013 <span class="comment">Author:</span>
00014 <span class="comment"></span>
00015 <span class="comment">   Joe Notarangelo  31-Mar-1992   (based on mips.h by Dave Cutler)</span>
00016 <span class="comment"></span>
00017 <span class="comment">Revision History:</span>
00018 <span class="comment"></span>
00019 <span class="comment">    Jeff McLeman (mcleman) 21-Jul-1992</span>
00020 <span class="comment">      Add bus types for ISA and EISA</span>
00021 <span class="comment"></span>
00022 <span class="comment">    Thomas Van Baak (tvb) 9-Jul-1992</span>
00023 <span class="comment"></span>
00024 <span class="comment">        Created proper Alpha Exception and Trap structure definitions.</span>
00025 <span class="comment"></span>
00026 <span class="comment">--*/</span>
00027 
00028 <span class="preprocessor">#ifndef _ALPHAH_</span>
00029 <span class="preprocessor"></span><span class="preprocessor">#define _ALPHAH_</span>
00030 <span class="preprocessor"></span>
00031 
00032 <span class="comment">// begin_ntddk begin_wdm begin_nthal begin_ntndis</span>
00033 
00034 <span class="preprocessor">#if defined(_ALPHA_)</span>
00035 <span class="preprocessor"></span><span class="preprocessor">#ifdef __cplusplus</span>
00036 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00037 <span class="preprocessor">#endif</span>
00038 <span class="preprocessor"></span>
00039 <span class="comment">//</span>
00040 <span class="comment">// Types to use to contain PFNs and their counts.</span>
00041 <span class="comment">//</span>
00042 
00043 <span class="keyword">typedef</span> ULONG PFN_COUNT;
00044 
00045 <span class="keyword">typedef</span> LONG_PTR SPFN_NUMBER, *PSPFN_NUMBER;
00046 <span class="keyword">typedef</span> ULONG_PTR PFN_NUMBER, *PPFN_NUMBER;
00047 
00048 <span class="comment">//</span>
00049 <span class="comment">// Define maximum size of flush multiple TB request.</span>
00050 <span class="comment">//</span>
00051 
00052 <span class="preprocessor">#define FLUSH_MULTIPLE_MAXIMUM 16</span>
00053 <span class="preprocessor"></span>
00054 <span class="comment">//</span>
00055 <span class="comment">// Indicate that the Alpha compiler supports the pragma textout construct.</span>
00056 <span class="comment">//</span>
00057 
00058 <span class="preprocessor">#define ALLOC_PRAGMA 1</span>
00059 <span class="preprocessor"></span>
00060 <span class="comment">// end_ntndis</span>
00061 <span class="comment">//</span>
00062 <span class="comment">// Include the Alpha instruction definitions</span>
00063 <span class="comment">//</span>
00064 
00065 <span class="preprocessor">#include "alphaops.h"</span>
00066 
00067 <span class="comment">//</span>
00068 <span class="comment">// Include reference machine definitions.</span>
00069 <span class="comment">//</span>
00070 
00071 <span class="preprocessor">#include "alpharef.h"</span>
00072 
00073 <span class="comment">// end_ntddk end_wdm</span>
00074 
00075 <span class="comment">//</span>
00076 <span class="comment">// Define intrinsic PAL calls and their prototypes</span>
00077 <span class="comment">//</span>
00078 <span class="keywordtype">void</span> __di(<span class="keywordtype">void</span>);
00079 <span class="keywordtype">void</span> __MB(<span class="keywordtype">void</span>);
00080 <span class="keywordtype">void</span> __dtbis(<span class="keywordtype">void</span> *);
00081 <span class="keywordtype">void</span> __ei(<span class="keywordtype">void</span>);
00082 <span class="keywordtype">void</span> *__rdpcr(<span class="keywordtype">void</span>);
00083 <span class="keywordtype">void</span> *__rdthread(<span class="keywordtype">void</span>);
00084 <span class="keywordtype">void</span> __ssir(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>);
00085 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> __swpirql(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>);
00086 <span class="keywordtype">void</span> __tbia(<span class="keywordtype">void</span>);
00087 <span class="keywordtype">void</span> __tbis(<span class="keywordtype">void</span> *);
00088 <span class="keywordtype">void</span> __tbisasn(<span class="keywordtype">void</span> *, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>);
00089 
00090 <span class="preprocessor">#if defined(_M_ALPHA) || defined(_M_AXP64)</span>
00091 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic(__di)</span>
00092 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic(__MB)</span>
00093 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic(__dtbis)</span>
00094 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic(__ei)</span>
00095 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic(__rdpcr)</span>
00096 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic(__rdthread)</span>
00097 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic(__ssir)</span>
00098 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic(__swpirql)</span>
00099 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic(__tbia)</span>
00100 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic(__tbis)</span>
00101 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic(__tbisasn)</span>
00102 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00103 <span class="preprocessor"></span>
00104 <span class="comment">//</span>
00105 <span class="comment">// Define Alpha Axp Processor Ids.</span>
00106 <span class="comment">//</span>
00107 
00108 <span class="preprocessor">#if !defined(PROCESSOR_ALPHA_21064)</span>
00109 <span class="preprocessor"></span><span class="preprocessor">#define PROCESSOR_ALPHA_21064 (21064)</span>
00110 <span class="preprocessor"></span><span class="preprocessor">#endif // !PROCESSOR_ALPHA_21064</span>
00111 <span class="preprocessor"></span>
00112 <span class="preprocessor">#if !defined(PROCESSOR_ALPHA_21164)</span>
00113 <span class="preprocessor"></span><span class="preprocessor">#define PROCESSOR_ALPHA_21164 (21164)</span>
00114 <span class="preprocessor"></span><span class="preprocessor">#endif // !PROCESSOR_ALPHA_21164</span>
00115 <span class="preprocessor"></span>
00116 <span class="preprocessor">#if !defined(PROCESSOR_ALPHA_21066)</span>
00117 <span class="preprocessor"></span><span class="preprocessor">#define PROCESSOR_ALPHA_21066 (21066)</span>
00118 <span class="preprocessor"></span><span class="preprocessor">#endif // !PROCESSOR_ALPHA_21066</span>
00119 <span class="preprocessor"></span>
00120 <span class="preprocessor">#if !defined(PROCESSOR_ALPHA_21068)</span>
00121 <span class="preprocessor"></span><span class="preprocessor">#define PROCESSOR_ALPHA_21068 (21068)</span>
00122 <span class="preprocessor"></span><span class="preprocessor">#endif // !PROCESSOR_ALPHA_21068</span>
00123 <span class="preprocessor"></span>
00124 <span class="preprocessor">#if !defined(PROCESSOR_ALPHA_21164PC)</span>
00125 <span class="preprocessor"></span><span class="preprocessor">#define PROCESSOR_ALPHA_21164PC (21165)</span>
00126 <span class="preprocessor"></span><span class="preprocessor">#endif // !PROCESSOR_ALPHA_21164PC</span>
00127 <span class="preprocessor"></span>
00128 <span class="preprocessor">#if !defined(PROCESSOR_ALPHA_21264)</span>
00129 <span class="preprocessor"></span><span class="preprocessor">#define PROCESSOR_ALPHA_21264 (21264)</span>
00130 <span class="preprocessor"></span><span class="preprocessor">#endif // !PROCESSOR_ALPHA_21264</span>
00131 <span class="preprocessor"></span>
00132 <span class="comment">// end_nthal</span>
00133 
00134 <span class="comment">//</span>
00135 <span class="comment">// Define Processor Control Region Structure.</span>
00136 <span class="comment">//</span>
00137 
00138 <span class="keyword">typedef</span>
00139 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00140 (*PKTRAP_ROUTINE)(
00141     <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00142     );
00143 
00144 <span class="comment">// begin_ntddk begin_nthal</span>
00145 <span class="comment">//</span>
00146 <span class="comment">// Define macro to generate import names.</span>
00147 <span class="comment">//</span>
00148 
00149 <span class="preprocessor">#define IMPORT_NAME(name) __imp_##name</span>
00150 <span class="preprocessor"></span>
00151 <span class="comment">//</span>
00152 <span class="comment">// Define length of interrupt vector table.</span>
00153 <span class="comment">//</span>
00154 
00155 <span class="preprocessor">#define MAXIMUM_VECTOR 256</span>
00156 <span class="preprocessor"></span>
00157 <span class="comment">//</span>
00158 <span class="comment">// Define bus error routine type.</span>
00159 <span class="comment">//</span>
00160 
00161 <span class="keyword">struct </span>_EXCEPTION_RECORD;
00162 <span class="keyword">struct </span>_KEXCEPTION_FRAME;
00163 <span class="keyword">struct </span>_KTRAP_FRAME;
00164 
00165 <span class="keyword">typedef</span>
00166 BOOLEAN
00167 (*PKBUS_ERROR_ROUTINE) (
00168     IN <span class="keyword">struct </span>_EXCEPTION_RECORD *ExceptionRecord,
00169     IN <span class="keyword">struct </span>_KEXCEPTION_FRAME *ExceptionFrame,
00170     IN <span class="keyword">struct </span>_KTRAP_FRAME *TrapFrame
00171     );
00172 
00173 
00174 <span class="preprocessor">#define PCR_MINOR_VERSION 1</span>
00175 <span class="preprocessor"></span><span class="preprocessor">#define PCR_MAJOR_VERSION 1</span>
00176 <span class="preprocessor"></span>
00177 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KPCR {
00178 
00179 <span class="comment">//</span>
00180 <span class="comment">// Major and minor version numbers of the PCR.</span>
00181 <span class="comment">//</span>
00182 
00183     ULONG MinorVersion;
00184     ULONG MajorVersion;
00185 
00186 <span class="comment">//</span>
00187 <span class="comment">// Start of the architecturally defined section of the PCR. This section</span>
00188 <span class="comment">// may be directly addressed by vendor/platform specific PAL/HAL code and will</span>
00189 <span class="comment">// not change from version to version of NT.</span>
00190 
00191 <span class="comment">//</span>
00192 <span class="comment">// PALcode information.</span>
00193 <span class="comment">//</span>
00194 
00195     ULONGLONG PalBaseAddress;
00196     ULONG PalMajorVersion;
00197     ULONG PalMinorVersion;
00198     ULONG PalSequenceVersion;
00199     ULONG PalMajorSpecification;
00200     ULONG PalMinorSpecification;
00201 
00202 <span class="comment">//</span>
00203 <span class="comment">// Firmware restart information.</span>
00204 <span class="comment">//</span>
00205 
00206     ULONGLONG FirmwareRestartAddress;
00207     PVOID RestartBlock;
00208 
00209 <span class="comment">//</span>
00210 <span class="comment">// Reserved per-processor region for the PAL (3K-8 bytes).</span>
00211 <span class="comment">//</span>
00212 
00213     ULONGLONG PalReserved[383];
00214 
00215 <span class="comment">//</span>
00216 <span class="comment">// Alignment fixup count updated by PAL and read by kernel.</span>
00217 <span class="comment">//</span>
00218 
00219     ULONGLONG PalAlignmentFixupCount;
00220 
00221 <span class="comment">//</span>
00222 <span class="comment">// Panic Stack Address.</span>
00223 <span class="comment">//</span>
00224 
00225     PVOID PanicStack;
00226 
00227 <span class="comment">//</span>
00228 <span class="comment">// Processor parameters.</span>
00229 <span class="comment">//</span>
00230 
00231     ULONG ProcessorType;
00232     ULONG ProcessorRevision;
00233     ULONG PhysicalAddressBits;
00234     ULONG MaximumAddressSpaceNumber;
00235     ULONG PageSize;
00236     ULONG FirstLevelDcacheSize;
00237     ULONG FirstLevelDcacheFillSize;
00238     ULONG FirstLevelIcacheSize;
00239     ULONG FirstLevelIcacheFillSize;
00240 
00241 <span class="comment">//</span>
00242 <span class="comment">// System Parameters.</span>
00243 <span class="comment">//</span>
00244 
00245     ULONG FirmwareRevisionId;
00246     UCHAR SystemType[8];
00247     ULONG SystemVariant;
00248     ULONG SystemRevision;
00249     UCHAR SystemSerialNumber[16];
00250     ULONG CycleClockPeriod;
00251     ULONG SecondLevelCacheSize;
00252     ULONG SecondLevelCacheFillSize;
00253     ULONG ThirdLevelCacheSize;
00254     ULONG ThirdLevelCacheFillSize;
00255     ULONG FourthLevelCacheSize;
00256     ULONG FourthLevelCacheFillSize;
00257 
00258 <span class="comment">//</span>
00259 <span class="comment">// Pointer to processor control block.</span>
00260 <span class="comment">//</span>
00261 
00262     <span class="keyword">struct </span>_KPRCB *Prcb;
00263 
00264 <span class="comment">//</span>
00265 <span class="comment">// Processor identification.</span>
00266 <span class="comment">//</span>
00267 
00268     CCHAR Number;
00269     KAFFINITY <a class="code" href="../../d0/d0/ki_8h.html#a7">SetMember</a>;
00270 
00271 <span class="comment">//</span>
00272 <span class="comment">// Reserved per-processor region for the HAL (.5K bytes).</span>
00273 <span class="comment">//</span>
00274 
00275     ULONGLONG HalReserved[64];
00276 
00277 <span class="comment">//</span>
00278 <span class="comment">// IRQL mapping tables.</span>
00279 <span class="comment">//</span>
00280 
00281     ULONG IrqlTable[8];
00282 
00283 <span class="preprocessor">#define SFW_IMT_ENTRIES 4</span>
00284 <span class="preprocessor"></span><span class="preprocessor">#define HDW_IMT_ENTRIES 128</span>
00285 <span class="preprocessor"></span>
00286     <span class="keyword">struct </span>_IRQLMASK {
00287         <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> IrqlTableIndex;   <span class="comment">// synchronization irql level</span>
00288         <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> IDTIndex;         <span class="comment">// vector in IDT</span>
00289     } IrqlMask[SFW_IMT_ENTRIES + HDW_IMT_ENTRIES];
00290 
00291 <span class="comment">//</span>
00292 <span class="comment">// Interrupt Dispatch Table (IDT).</span>
00293 <span class="comment">//</span>
00294 
00295     PKINTERRUPT_ROUTINE InterruptRoutine[MAXIMUM_VECTOR];
00296 
00297 <span class="comment">//</span>
00298 <span class="comment">// Reserved vectors mask, these vectors cannot be attached to via</span>
00299 <span class="comment">// standard interrupt objects.</span>
00300 <span class="comment">//</span>
00301 
00302     ULONG ReservedVectors;
00303 
00304 <span class="comment">//</span>
00305 <span class="comment">// Complement of processor affinity mask.</span>
00306 <span class="comment">//</span>
00307 
00308     KAFFINITY NotMember;
00309 
00310     ULONG InterruptInProgress;
00311     ULONG DpcRequested;
00312 
00313 <span class="comment">//</span>
00314 <span class="comment">// Pointer to machine check handler</span>
00315 <span class="comment">//</span>
00316 
00317     PKBUS_ERROR_ROUTINE MachineCheckError;
00318 
00319 <span class="comment">//</span>
00320 <span class="comment">// DPC Stack.</span>
00321 <span class="comment">//</span>
00322 
00323     PVOID DpcStack;
00324 
00325 <span class="comment">//</span>
00326 <span class="comment">// End of the architecturally defined section of the PCR. This section</span>
00327 <span class="comment">// may be directly addressed by vendor/platform specific HAL code and will</span>
00328 <span class="comment">// not change from version to version of NT.  Some of these values are</span>
00329 <span class="comment">// reserved for chip-specific palcode.</span>
00330 <span class="comment">// end_ntddk end_nthal</span>
00331 <span class="comment">//</span>
00332 
00333 <span class="comment">//</span>
00334 <span class="comment">// Start of the operating system release dependent section of the PCR.</span>
00335 <span class="comment">// This section may change from release to release and should not be</span>
00336 <span class="comment">// addressed by vendor/platform specific HAL code.</span>
00337 
00338     ULONG Spare1;
00339 
00340 <span class="comment">//</span>
00341 <span class="comment">// Current process id.</span>
00342 <span class="comment">//</span>
00343 
00344     ULONG CurrentPid;
00345 
00346 <span class="comment">//</span>
00347 <span class="comment">// Spare field.</span>
00348 <span class="comment">//</span>
00349 
00350     ULONG <a class="code" href="../../d4/d9/ke_8h.html#a407a219">Spare2</a>;
00351 
00352 <span class="comment">//</span>
00353 <span class="comment">// System service dispatch start and end address used by get/set context.</span>
00354 <span class="comment">//</span>
00355 
00356     ULONG_PTR SystemServiceDispatchStart;
00357     ULONG_PTR SystemServiceDispatchEnd;
00358 
00359 <span class="comment">//</span>
00360 <span class="comment">// Pointer to Idle thread.</span>
00361 <span class="comment">//</span>
00362 
00363     <span class="keyword">struct </span><a class="code" href="../../d1/d8/struct__KTHREAD.html">_KTHREAD</a> *IdleThread;
00364 
00365 
00366 } KPCR, *PKPCR; <span class="comment">// ntddk nthal</span>
00367 
00368 <span class="comment">//</span>
00369 <span class="comment">// Define Processor Status Register structure</span>
00370 <span class="comment">//</span>
00371 
00372 <span class="keyword">typedef</span> <span class="keyword">struct </span>_PSR {
00373     ULONG <a class="code" href="../../d0/d9/ntosdef_8h.html#a40">MODE</a>: 1;
00374     ULONG INTERRUPT_ENABLE: 1;
00375     ULONG IRQL: 3;
00376 } <a class="code" href="../../d9/d2/festate_8h.html#a2">PSR</a>, *PPSR;
00377 
00378 <span class="comment">//</span>
00379 <span class="comment">// Define Interrupt Enable Register structure</span>
00380 <span class="comment">//</span>
00381 
00382 <span class="keyword">typedef</span> <span class="keyword">struct </span>_IE {
00383     ULONG SoftwareInterruptEnables: 2;
00384     ULONG HardwareInterruptEnables: 6;
00385 } IE, *PIE;
00386 
00387 <span class="preprocessor">#define HARDWARE_PTE_DIRTY_MASK     0x4</span>
00388 <span class="preprocessor"></span>
00389 
00390 <span class="preprocessor">#if defined(_AXP64_)</span>
00391 <span class="preprocessor"></span>
00392 <span class="preprocessor">#define _HARDWARE_PTE_WORKING_SET_BITS  14</span>
00393 <span class="preprocessor"></span>
00394 <span class="keyword">typedef</span> <span class="keyword">struct </span>_HARDWARE_PTE {
00395     ULONGLONG Valid : 1;
00396     ULONGLONG <a class="code" href="../../d1/d9/arc_8h.html#a313a149">Reserved1</a> : 1;
00397     ULONGLONG FaultOnWrite : 1;
00398     ULONGLONG <a class="code" href="../../d1/d9/arc_8h.html#a313a160">Reserved2</a> : 1;
00399     ULONGLONG Global : 1;
00400     ULONGLONG GranularityHint : 2;
00401     ULONGLONG Reserved3 : 1;
00402     ULONGLONG KernelReadAccess : 1;
00403     ULONGLONG UserReadAccess : 1;
00404     ULONGLONG Reserved4 : 2;
00405     ULONGLONG KernelWriteAccess : 1;
00406     ULONGLONG UserWriteAccess : 1;
00407     ULONGLONG Reserved5 : 2;
00408     ULONGLONG Write : 1;
00409     ULONGLONG CopyOnWrite: 1;
00410     ULONGLONG SoftwareWsIndex : <a class="code" href="../../d2/d9/miia64_8h.html#a200">_HARDWARE_PTE_WORKING_SET_BITS</a>;
00411     ULONGLONG PageFrameNumber : 32;
00412 } HARDWARE_PTE, *PHARDWARE_PTE;
00413 
00414 <span class="comment">//</span>
00415 <span class="comment">// Define initialize page directory base</span>
00416 <span class="comment">//</span>
00417 
00418 <span class="preprocessor">#define INITIALIZE_DIRECTORY_TABLE_BASE(dirbase, pfn)  \</span>
00419 <span class="preprocessor">    *((PULONGLONG)(dirbase)) = 0;                      \</span>
00420 <span class="preprocessor">    ((PHARDWARE_PTE)(dirbase))-&gt;PageFrameNumber = pfn; \</span>
00421 <span class="preprocessor">    ((PHARDWARE_PTE)(dirbase))-&gt;Write = 1;             \</span>
00422 <span class="preprocessor">    ((PHARDWARE_PTE)(dirbase))-&gt;KernelReadAccess = 1;  \</span>
00423 <span class="preprocessor">    ((PHARDWARE_PTE)(dirbase))-&gt;KernelWriteAccess = 1; \</span>
00424 <span class="preprocessor">    ((PHARDWARE_PTE)(dirbase))-&gt;Global = 0;            \</span>
00425 <span class="preprocessor">    ((PHARDWARE_PTE)(dirbase))-&gt;FaultOnWrite = 0;      \</span>
00426 <span class="preprocessor">    ((PHARDWARE_PTE)(dirbase))-&gt;Valid = 1;</span>
00427 <span class="preprocessor"></span>
00428 <span class="preprocessor">#else</span>
00429 <span class="preprocessor"></span>
00430 <span class="keyword">typedef</span> <span class="keyword">struct </span>_HARDWARE_PTE {
00431     ULONG Valid: 1;
00432     ULONG <a class="code" href="../../d6/d0/ctaccess_8c.html#a53">Owner</a>: 1;
00433     ULONG Dirty: 1;
00434     ULONG reserved: 1;
00435     ULONG Global: 1;
00436     ULONG GranularityHint: 2;
00437     ULONG Write: 1;
00438     ULONG CopyOnWrite: 1;
00439     ULONG PageFrameNumber: 23;
00440 } HARDWARE_PTE, *PHARDWARE_PTE;
00441 
00442 <span class="comment">//</span>
00443 <span class="comment">// Define initialize page directory base</span>
00444 <span class="comment">//</span>
00445 
00446 <span class="preprocessor">#define INITIALIZE_DIRECTORY_TABLE_BASE(dirbase, pfn) \</span>
00447 <span class="preprocessor">        ((PHARDWARE_PTE)(dirbase))-&gt;PageFrameNumber = pfn; \</span>
00448 <span class="preprocessor">        ((PHARDWARE_PTE)(dirbase))-&gt;Global = 0; \</span>
00449 <span class="preprocessor">        ((PHARDWARE_PTE)(dirbase))-&gt;Dirty = 1; \</span>
00450 <span class="preprocessor">        ((PHARDWARE_PTE)(dirbase))-&gt;Valid = 1;</span>
00451 <span class="preprocessor"></span>
00452 <span class="preprocessor">#endif</span>
00453 <span class="preprocessor"></span>
00454 
00455 <span class="comment">// begin_nthal</span>
00456 <span class="comment">//</span>
00457 <span class="comment">// Define some constants for bus type</span>
00458 <span class="comment">//</span>
00459 
00460 <span class="preprocessor">#define MACHINE_TYPE_ISA 0</span>
00461 <span class="preprocessor"></span><span class="preprocessor">#define MACHINE_TYPE_EISA 2</span>
00462 <span class="preprocessor"></span>
00463 <span class="comment">//</span>
00464 <span class="comment">//  Define pointer to Processor Control Registers</span>
00465 <span class="comment">//</span>
00466 
00467 <span class="preprocessor">#define PCR ((PKPCR)__rdpcr())</span>
00468 <span class="preprocessor"></span>
00469 <span class="comment">// begin_ntddk</span>
00470 
00471 <span class="preprocessor">#if defined(_AXP64_)</span>
00472 <span class="preprocessor"></span>
00473 <span class="preprocessor">#define KI_USER_SHARED_DATA 0xffffffffff000000UI64</span>
00474 <span class="preprocessor"></span>
00475 <span class="preprocessor">#else</span>
00476 <span class="preprocessor"></span>
00477 <span class="preprocessor">#define KI_USER_SHARED_DATA 0xff000000UL</span>
00478 <span class="preprocessor"></span>
00479 <span class="preprocessor">#endif</span>
00480 <span class="preprocessor"></span>
00481 <span class="preprocessor">#define SharedUserData ((KUSER_SHARED_DATA * const) KI_USER_SHARED_DATA)</span>
00482 <span class="preprocessor"></span>
00483 <span class="comment">// begin_wdm</span>
00484 <span class="comment">//</span>
00485 <span class="comment">// length of dispatch code in interrupt template</span>
00486 <span class="comment">//</span>
00487 <span class="preprocessor">#define DISPATCH_LENGTH 4</span>
00488 <span class="preprocessor"></span>
00489 <span class="comment">//</span>
00490 <span class="comment">// Define IRQL levels across the architecture.</span>
00491 <span class="comment">//</span>
00492 
00493 <span class="preprocessor">#define PASSIVE_LEVEL   0</span>
00494 <span class="preprocessor"></span><span class="preprocessor">#define LOW_LEVEL       0</span>
00495 <span class="preprocessor"></span><span class="preprocessor">#define APC_LEVEL       1</span>
00496 <span class="preprocessor"></span><span class="preprocessor">#define DISPATCH_LEVEL  2</span>
00497 <span class="preprocessor"></span><span class="preprocessor">#define HIGH_LEVEL      7</span>
00498 <span class="preprocessor"></span><span class="preprocessor">#define SYNCH_LEVEL (IPI_LEVEL-1)</span>
00499 <span class="preprocessor"></span>
00500 <span class="comment">// end_ntddk end_wdm end_nthal</span>
00501 
00502 <span class="preprocessor">#define KiProfileIrql PROFILE_LEVEL     // enable portable code</span>
00503 <span class="preprocessor"></span>
00504 <span class="comment">//</span>
00505 <span class="comment">// Define interrupt levels that cannot be connected</span>
00506 <span class="comment">//</span>
00507 
00508 <span class="preprocessor">#define ILLEGAL_LEVEL  ( (1&lt;&lt;0) | (1&lt;&lt;APC_LEVEL) | (1&lt;&lt;DISPATCH_LEVEL) | \</span>
00509 <span class="preprocessor">                         (1&lt;&lt;CLOCK_LEVEL) | (1&lt;&lt;IPI_LEVEL) )</span>
00510 <span class="preprocessor"></span><span class="comment">//</span>
00511 <span class="comment">// Sanitize FPCR and PSR based on processor mode.</span>
00512 <span class="comment">//</span>
00513 <span class="comment">// ## tvb&amp;jn - need to replace these with proper macros.</span>
00514 <span class="comment">//</span>
00515 
00516 <span class="preprocessor">#define SANITIZE_FPCR(fpcr, mode) (fpcr)</span>
00517 <span class="preprocessor"></span>
00518 <span class="comment">//</span>
00519 <span class="comment">// Define SANITIZE_PSR for Alpha.</span>
00520 <span class="comment">//</span>
00521 <span class="comment">// If kernel mode, then caller specifies  psr</span>
00522 <span class="comment">//</span>
00523 <span class="comment">// If user mode, then</span>
00524 <span class="comment">//      force mode bit to user (1)</span>
00525 <span class="comment">//      force interrupt enable bit to true (1)</span>
00526 <span class="comment">//      force irql to 0</span>
00527 <span class="comment">//</span>
00528 <span class="comment">// In both cases insure that extraneous bits are not set</span>
00529 <span class="comment">//</span>
00530 
00531 <span class="preprocessor">#define SANITIZE_PSR(psr, mode) \</span>
00532 <span class="preprocessor">    ( ((mode) == KernelMode) ?  \</span>
00533 <span class="preprocessor">        (psr &amp; 0x3f) :          \</span>
00534 <span class="preprocessor">        (0x3) )</span>
00535 <span class="preprocessor"></span>
00536 <span class="comment">// begin_nthal</span>
00537 <span class="comment">//</span>
00538 <span class="comment">// Exception frame</span>
00539 <span class="comment">//</span>
00540 <span class="comment">//  This frame is established when handling an exception. It provides a place</span>
00541 <span class="comment">//  to save all nonvolatile registers. The volatile registers will already</span>
00542 <span class="comment">//  have been saved in a trap frame.</span>
00543 <span class="comment">//</span>
00544 <span class="comment">//  The layout of the record conforms to a standard call frame since it is</span>
00545 <span class="comment">//  used as such. Thus it contains a place to save a return address and is</span>
00546 <span class="comment">//  padded so that it is EXACTLY a multiple of 32 bytes in length.</span>
00547 <span class="comment">//</span>
00548 <span class="comment">//</span>
00549 <span class="comment">//  N.B - the 32-byte alignment is more stringent than required by the</span>
00550 <span class="comment">//  calling standard (which requires 16-byte alignment), the 32-byte alignment</span>
00551 <span class="comment">//  is established for performance reasons in the interaction with the PAL.</span>
00552 <span class="comment">//</span>
00553 
00554 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KEXCEPTION_FRAME {
00555 
00556     ULONGLONG IntRa;    <span class="comment">// return address register, ra</span>
00557 
00558     ULONGLONG FltF2;    <span class="comment">// nonvolatile floating registers, f2 - f9</span>
00559     ULONGLONG FltF3;
00560     ULONGLONG FltF4;
00561     ULONGLONG FltF5;
00562     ULONGLONG FltF6;
00563     ULONGLONG FltF7;
00564     ULONGLONG FltF8;
00565     ULONGLONG FltF9;
00566 
00567     ULONGLONG IntS0;    <span class="comment">//  nonvolatile integer registers, s0 - s5</span>
00568     ULONGLONG IntS1;
00569     ULONGLONG IntS2;
00570     ULONGLONG IntS3;
00571     ULONGLONG IntS4;
00572     ULONGLONG IntS5;
00573     ULONGLONG IntFp;    <span class="comment">// frame pointer register, fp/s6</span>
00574 
00575     ULONGLONG SwapReturn;
00576     ULONG Psr;          <span class="comment">// processor status</span>
00577     ULONG Fill[5];      <span class="comment">// padding for 32-byte stack frame alignment</span>
00578                         <span class="comment">// N.B. - Ulongs from the filler section are used</span>
00579                         <span class="comment">//        in ctxsw.s - do not delete</span>
00580 
00581 } KEXCEPTION_FRAME, *PKEXCEPTION_FRAME;
00582 
00583 <span class="comment">//</span>
00584 <span class="comment">// Trap Frame</span>
00585 <span class="comment">//</span>
00586 <span class="comment">//  This frame is established when handling a trap. It provides a place to</span>
00587 <span class="comment">//  save all volatile registers. The nonvolatile registers are saved in an</span>
00588 <span class="comment">//  exception frame or through the normal C calling conventions for saved</span>
00589 <span class="comment">//  registers.</span>
00590 <span class="comment">//</span>
00591 <span class="comment">//  The layout of the record conforms to a standard call frame since it is</span>
00592 <span class="comment">//  used as such. Thus it contains a place to save a return address and is</span>
00593 <span class="comment">//  padded so that it is EXACTLY a multiple of 32 bytes in length.</span>
00594 <span class="comment">//</span>
00595 <span class="comment">//</span>
00596 <span class="comment">//  N.B - the 32-byte alignment is more stringent than required by the</span>
00597 <span class="comment">//  calling standard (which requires 16-byte alignment), the 32-byte alignment</span>
00598 <span class="comment">//  is established for performance reasons in the interaction with the PAL.</span>
00599 <span class="comment">//</span>
00600 
00601 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KTRAP_FRAME {
00602 
00603     <span class="comment">//</span>
00604     <span class="comment">// Fields saved in the PALcode.</span>
00605     <span class="comment">//</span>
00606 
00607     ULONGLONG IntSp;    <span class="comment">// $30: stack pointer register, sp</span>
00608     ULONGLONG Fir;      <span class="comment">// (fault instruction) continuation address</span>
00609     ULONG Psr;          <span class="comment">// processor status</span>
00610     ULONG Fill1[1];     <span class="comment">// unused</span>
00611     ULONGLONG IntFp;    <span class="comment">// $15: frame pointer register, fp/s6</span>
00612 
00613     ULONGLONG IntA0;    <span class="comment">// $16: argument registers, a0 - a3</span>
00614     ULONGLONG IntA1;    <span class="comment">// $17:</span>
00615     ULONGLONG IntA2;    <span class="comment">// $18:</span>
00616     ULONGLONG IntA3;    <span class="comment">// $19:</span>
00617 
00618     ULONGLONG IntRa;    <span class="comment">// $26: return address register, ra</span>
00619     ULONGLONG IntGp;    <span class="comment">// $29: global pointer register, gp</span>
00620     UCHAR ExceptionRecord[(<span class="keyword">sizeof</span>(EXCEPTION_RECORD) + 15) &amp; (~15)];
00621 
00622     <span class="comment">//</span>
00623     <span class="comment">// Volatile integer registers, s0 - s5 are nonvolatile.</span>
00624     <span class="comment">//</span>
00625 
00626     ULONGLONG IntV0;    <span class="comment">//  $0: return value register, v0</span>
00627     ULONGLONG IntT0;    <span class="comment">//  $1: temporary registers, t0 - t7</span>
00628     ULONGLONG IntT1;    <span class="comment">//  $2:</span>
00629     ULONGLONG IntT2;    <span class="comment">//  $3:</span>
00630     ULONGLONG IntT3;    <span class="comment">//  $4:</span>
00631     ULONGLONG IntT4;    <span class="comment">//  $5:</span>
00632     ULONGLONG IntT5;    <span class="comment">//  $6:</span>
00633     ULONGLONG IntT6;    <span class="comment">//  $7:</span>
00634     ULONGLONG IntT7;    <span class="comment">//  $8:</span>
00635 
00636     ULONGLONG IntT8;    <span class="comment">// $22: temporary registers, t8 - t11</span>
00637     ULONGLONG IntT9;    <span class="comment">// $23:</span>
00638     ULONGLONG IntT10;   <span class="comment">// $24:</span>
00639     ULONGLONG IntT11;   <span class="comment">// $25:</span>
00640 
00641     ULONGLONG IntT12;   <span class="comment">// $27: temporary register, t12</span>
00642     ULONGLONG IntAt;    <span class="comment">// $28: assembler temporary register, at</span>
00643 
00644     ULONGLONG IntA4;    <span class="comment">// $20: remaining argument registers a4 - a5</span>
00645     ULONGLONG IntA5;    <span class="comment">// $21:</span>
00646 
00647     <span class="comment">//</span>
00648     <span class="comment">// Volatile floating point registers, f2 - f9 are nonvolatile.</span>
00649     <span class="comment">//</span>
00650 
00651     ULONGLONG FltF0;    <span class="comment">// $f0:</span>
00652     ULONGLONG Fpcr;     <span class="comment">// floating point control register</span>
00653     ULONGLONG FltF1;    <span class="comment">// $f1:</span>
00654 
00655     ULONGLONG FltF10;   <span class="comment">// $f10: temporary registers, $f10 - $f30</span>
00656     ULONGLONG FltF11;   <span class="comment">// $f11:</span>
00657     ULONGLONG FltF12;   <span class="comment">// $f12:</span>
00658     ULONGLONG FltF13;   <span class="comment">// $f13:</span>
00659     ULONGLONG FltF14;   <span class="comment">// $f14:</span>
00660     ULONGLONG FltF15;   <span class="comment">// $f15:</span>
00661     ULONGLONG FltF16;   <span class="comment">// $f16:</span>
00662     ULONGLONG FltF17;   <span class="comment">// $f17:</span>
00663     ULONGLONG FltF18;   <span class="comment">// $f18:</span>
00664     ULONGLONG FltF19;   <span class="comment">// $f19:</span>
00665     ULONGLONG FltF20;   <span class="comment">// $f20:</span>
00666     ULONGLONG FltF21;   <span class="comment">// $f21:</span>
00667     ULONGLONG FltF22;   <span class="comment">// $f22:</span>
00668     ULONGLONG FltF23;   <span class="comment">// $f23:</span>
00669     ULONGLONG FltF24;   <span class="comment">// $f24:</span>
00670     ULONGLONG FltF25;   <span class="comment">// $f25:</span>
00671     ULONGLONG FltF26;   <span class="comment">// $f26:</span>
00672     ULONGLONG FltF27;   <span class="comment">// $f27:</span>
00673     ULONGLONG FltF28;   <span class="comment">// $f28:</span>
00674     ULONGLONG FltF29;   <span class="comment">// $f29:</span>
00675     ULONGLONG FltF30;   <span class="comment">// $f30:</span>
00676 
00677     ULONG OldIrql;      <span class="comment">// Previous Irql.</span>
00678     ULONG PreviousMode; <span class="comment">// Previous Mode.</span>
00679     ULONG_PTR TrapFrame; <span class="comment">//</span>
00680     ULONG Fill2[3];     <span class="comment">// padding for 32-byte stack frame alignment</span>
00681 
00682 } KTRAP_FRAME, *PKTRAP_FRAME;
00683 
00684 <span class="preprocessor">#define KTRAP_FRAME_LENGTH ((sizeof(KTRAP_FRAME) + 15) &amp; ~15)</span>
00685 <span class="preprocessor"></span><span class="preprocessor">#define KTRAP_FRAME_ALIGN (16)</span>
00686 <span class="preprocessor"></span><span class="preprocessor">#define KTRAP_FRAME_ROUND (KTRAP_FRAME_ALIGN - 1)</span>
00687 <span class="preprocessor"></span>
00688 <span class="comment">//</span>
00689 <span class="comment">// Firmware Frame</span>
00690 <span class="comment">//</span>
00691 <span class="comment">//  The firmware frame is similar to the trap frame, but is built by the PAL</span>
00692 <span class="comment">//  code that is active when the OS Loader is running. It does not contain an</span>
00693 <span class="comment">//  exception record or NT style exception information.</span>
00694 <span class="comment">//</span>
00695 <span class="comment">//  Type field defintions and parameters.</span>
00696 <span class="comment">//</span>
00697 
00698 <span class="preprocessor">#define FW_EXC_MCHK 0xdec0              // p1=icPerrStat, p2=dcPerrStat</span>
00699 <span class="preprocessor"></span><span class="preprocessor">#define FW_EXC_ARITH 0xdec1             // p1=excSum, p2=excMask</span>
00700 <span class="preprocessor"></span><span class="preprocessor">#define FW_EXC_INTERRUPT 0xdec2         // p1=isr, p2=ipl, p3=intid</span>
00701 <span class="preprocessor"></span><span class="preprocessor">#define FW_EXC_DFAULT 0xdec3            // p1=sp</span>
00702 <span class="preprocessor"></span><span class="preprocessor">#define FW_EXC_ITBMISS 0xdec4           // none</span>
00703 <span class="preprocessor"></span><span class="preprocessor">#define FW_EXC_ITBACV 0xdec5            // none</span>
00704 <span class="preprocessor"></span><span class="preprocessor">#define FW_EXC_NDTBMISS 0xdec6          // p1=sp</span>
00705 <span class="preprocessor"></span><span class="preprocessor">#define FW_EXC_PDTBMISS 0xdec7          // p1=sp</span>
00706 <span class="preprocessor"></span><span class="preprocessor">#define FW_EXC_UNALIGNED 0xdec8         // p1=sp</span>
00707 <span class="preprocessor"></span><span class="preprocessor">#define FW_EXC_OPCDEC 0xdec9            // p1=sp</span>
00708 <span class="preprocessor"></span><span class="preprocessor">#define FW_EXC_FEN 0xdeca               // p1=icsr</span>
00709 <span class="preprocessor"></span><span class="preprocessor">#define FW_EXC_HALT 0xdecb              // not used</span>
00710 <span class="preprocessor"></span><span class="preprocessor">#define FW_EXC_BPT 0xdecc               // p1=0 - user, p1=1 - kernel, p1=type - call kdbg</span>
00711 <span class="preprocessor"></span><span class="preprocessor">#define FW_EXC_GENTRAP 0xdecd           // p1=gentrap code</span>
00712 <span class="preprocessor"></span><span class="preprocessor">#define FW_EXC_HALT_INTERRUPT 0xdece    // p1=isr, p2=ipl, p3=intid</span>
00713 <span class="preprocessor"></span>
00714 <span class="keyword">typedef</span> <span class="keyword">struct </span>_FIRMWARE_FRAME {
00715     ULONGLONG Type;
00716     ULONGLONG Param1;
00717     ULONGLONG Param2;
00718     ULONGLONG Param3;
00719     ULONGLONG Param4;
00720     ULONGLONG Param5;
00721     ULONGLONG Psr;
00722     ULONGLONG Mmcsr;
00723     ULONGLONG Va;
00724     ULONGLONG Fir;
00725     ULONGLONG IntV0;
00726     ULONGLONG IntT0;
00727     ULONGLONG IntT1;
00728     ULONGLONG IntT2;
00729     ULONGLONG IntT3;
00730     ULONGLONG IntT4;
00731     ULONGLONG IntT5;
00732     ULONGLONG IntT6;
00733     ULONGLONG IntT7;
00734     ULONGLONG IntS0;
00735     ULONGLONG IntS1;
00736     ULONGLONG IntS2;
00737     ULONGLONG IntS3;
00738     ULONGLONG IntS4;
00739     ULONGLONG IntS5;
00740     ULONGLONG IntFp;
00741     ULONGLONG IntA0;
00742     ULONGLONG IntA1;
00743     ULONGLONG IntA2;
00744     ULONGLONG IntA3;
00745     ULONGLONG IntA4;
00746     ULONGLONG IntA5;
00747     ULONGLONG IntT8;
00748     ULONGLONG IntT9;
00749     ULONGLONG IntT10;
00750     ULONGLONG IntT11;
00751     ULONGLONG IntRa;
00752     ULONGLONG IntT12;
00753     ULONGLONG IntAt;
00754     ULONGLONG IntGp;
00755     ULONGLONG IntSp;
00756     ULONGLONG IntZero;
00757     ULONGLONG FltF0;
00758     ULONGLONG FltF1;
00759     ULONGLONG FltF2;
00760     ULONGLONG FltF3;
00761     ULONGLONG FltF4;
00762     ULONGLONG FltF5;
00763     ULONGLONG FltF6;
00764     ULONGLONG FltF7;
00765     ULONGLONG FltF8;
00766     ULONGLONG FltF9;
00767     ULONGLONG FltF10;
00768     ULONGLONG FltF11;
00769     ULONGLONG FltF12;
00770     ULONGLONG FltF13;
00771     ULONGLONG FltF14;
00772     ULONGLONG FltF15;
00773     ULONGLONG FltF16;
00774     ULONGLONG FltF17;
00775     ULONGLONG FltF18;
00776     ULONGLONG FltF19;
00777     ULONGLONG FltF20;
00778     ULONGLONG FltF21;
00779     ULONGLONG FltF22;
00780     ULONGLONG FltF23;
00781     ULONGLONG FltF24;
00782     ULONGLONG FltF25;
00783     ULONGLONG FltF26;
00784     ULONGLONG FltF27;
00785     ULONGLONG FltF28;
00786     ULONGLONG FltF29;
00787     ULONGLONG FltF30;
00788     ULONGLONG FltF31;
00789 } FIRMWARE_FRAME, *PFIRMWARE_FRAME;
00790 
00791 <span class="preprocessor">#define FIRMWARE_FRAME_LENGTH sizeof(FIRMWARE_FRAME)</span>
00792 <span class="preprocessor"></span>
00793 <span class="comment">//</span>
00794 <span class="comment">// The frame saved by KiCallUserMode is defined here to allow</span>
00795 <span class="comment">// the kernel debugger to trace the entire kernel stack</span>
00796 <span class="comment">// when usermode callouts are pending.</span>
00797 <span class="comment">//</span>
00798 
00799 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KCALLOUT_FRAME {
00800     ULONGLONG   F2;   <span class="comment">// saved floating registers f2 - f9</span>
00801     ULONGLONG   F3;
00802     ULONGLONG   F4;
00803     ULONGLONG   F5;
00804     ULONGLONG   F6;
00805     ULONGLONG   F7;
00806     ULONGLONG   F8;
00807     ULONGLONG   F9;
00808     ULONGLONG   S0;   <span class="comment">// saved integer registers s0 - s5</span>
00809     ULONGLONG   S1;
00810     ULONGLONG   S2;
00811     ULONGLONG   S3;
00812     ULONGLONG   S4;
00813     ULONGLONG   S5;
00814     ULONGLONG   FP;
00815     ULONGLONG   CbStk;  <span class="comment">// saved callback stack address</span>
00816     ULONGLONG   InStk;  <span class="comment">// saved initial stack address</span>
00817     ULONGLONG   TrFr;   <span class="comment">// saved callback trap frame address</span>
00818     ULONGLONG   <a class="code" href="../../d6/d7/halmips_8h.html#a409">TrFir</a>;
00819     ULONGLONG   Ra;     <span class="comment">// saved return address</span>
00820     ULONGLONG   A0;     <span class="comment">// saved argument registers a0-a2</span>
00821     ULONGLONG   <a class="code" href="../../d1/d1/bench_8c.html#a6">A1</a>;
00822 } KCALLOUT_FRAME, *PKCALLOUT_FRAME;
00823 
00824 <span class="keyword">typedef</span> <span class="keyword">struct </span>_UCALLOUT_FRAME {
00825     PVOID <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>;
00826     ULONG Length;
00827     ULONG ApiNumber;
00828     ULONG Pad;
00829     ULONGLONG Sp;
00830     ULONGLONG Ra;
00831 } UCALLOUT_FRAME, *PUCALLOUT_FRAME;
00832 
00833 <span class="comment">//</span>
00834 <span class="comment">// Define Machine Check Status code that is passed in the exception</span>
00835 <span class="comment">// record for a machine check exception.</span>
00836 <span class="comment">//</span>
00837 
00838 <span class="keyword">typedef</span> <span class="keyword">struct </span>_MCHK_STATUS {
00839     ULONG Correctable: 1;
00840     ULONG Retryable: 1;
00841 } MCHK_STATUS, *PMCHK_STATUS;
00842 
00843 <span class="comment">//</span>
00844 <span class="comment">// Define the MCES register (Machine Check Error Summary).</span>
00845 <span class="comment">//</span>
00846 
00847 <span class="keyword">typedef</span> <span class="keyword">struct </span>_MCES {
00848     ULONG MachineCheck: 1;
00849     ULONG SystemCorrectable: 1;
00850     ULONG ProcessorCorrectable: 1;
00851     ULONG DisableProcessorCorrectable: 1;
00852     ULONG DisableSystemCorrectable: 1;
00853     ULONG DisableMachineChecks: 1;
00854 } MCES, *PMCES;
00855 
00856 <span class="comment">// end_nthal</span>
00857 
00858 <span class="comment">// begin_ntddk begin_wdm</span>
00859 <span class="comment">//</span>
00860 <span class="comment">// Non-volatile floating point state</span>
00861 <span class="comment">//</span>
00862 
00863 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KFLOATING_SAVE {
00864     ULONGLONG   Fpcr;
00865     ULONGLONG   SoftFpcr;
00866     ULONG       <a class="code" href="../../d1/d9/arc_8h.html#a313a149">Reserved1</a>;              <span class="comment">// These reserved words are here to make it</span>
00867     ULONG       <a class="code" href="../../d1/d9/arc_8h.html#a313a160">Reserved2</a>;              <span class="comment">// the same size as i386/WDM.</span>
00868     ULONG       Reserved3;
00869     ULONG       Reserved4;
00870 } KFLOATING_SAVE, *PKFLOATING_SAVE;
00871 
00872 <span class="comment">// end_ntddk end_wdm</span>
00873 <span class="comment">//</span>
00874 <span class="comment">// Define Alpha status code aliases. These are internal to PALcode and</span>
00875 <span class="comment">// kernel trap handling.</span>
00876 <span class="comment">//</span>
00877 
00878 <span class="preprocessor">#define STATUS_ALPHA_FLOATING_NOT_IMPLEMENTED    STATUS_ILLEGAL_FLOAT_CONTEXT</span>
00879 <span class="preprocessor"></span><span class="preprocessor">#define STATUS_ALPHA_ARITHMETIC_EXCEPTION    STATUS_FLOAT_STACK_CHECK</span>
00880 <span class="preprocessor"></span><span class="preprocessor">#define STATUS_ALPHA_GENTRAP    STATUS_INSTRUCTION_MISALIGNMENT</span>
00881 <span class="preprocessor"></span>
00882 <span class="comment">//</span>
00883 <span class="comment">// Define status code for bad virtual address.  This status differs from</span>
00884 <span class="comment">// those above in that it will be forwarded to the offending code.  In lieu</span>
00885 <span class="comment">// of defining a new status code, we wlll alias this to an access violation.</span>
00886 <span class="comment">// Code can distinguish this error from an access violation by checking</span>
00887 <span class="comment">// the number of parameters: a standard access violation has 2 parameters,</span>
00888 <span class="comment">// while a non-canonical virtual address access violation will have 3</span>
00889 <span class="comment">// parameters (the third parameter is the upper 32-bits of the non-canonical</span>
00890 <span class="comment">// virtual address.</span>
00891 <span class="comment">//</span>
00892 
00893 <span class="preprocessor">#define STATUS_ALPHA_BAD_VIRTUAL_ADDRESS    STATUS_ACCESS_VIOLATION</span>
00894 <span class="preprocessor"></span>
00895 <span class="comment">// begin_nthal</span>
00896 <span class="comment">//</span>
00897 <span class="comment">// Define the halt reason codes.</span>
00898 <span class="comment">//</span>
00899 
00900 <span class="preprocessor">#define AXP_HALT_REASON_HALT 0</span>
00901 <span class="preprocessor"></span><span class="preprocessor">#define AXP_HALT_REASON_REBOOT 1</span>
00902 <span class="preprocessor"></span><span class="preprocessor">#define AXP_HALT_REASON_RESTART 2</span>
00903 <span class="preprocessor"></span><span class="preprocessor">#define AXP_HALT_REASON_POWERFAIL 3</span>
00904 <span class="preprocessor"></span><span class="preprocessor">#define AXP_HALT_REASON_POWEROFF 4</span>
00905 <span class="preprocessor"></span><span class="preprocessor">#define AXP_HALT_REASON_PALMCHK 6</span>
00906 <span class="preprocessor"></span><span class="preprocessor">#define AXP_HALT_REASON_DBLMCHK 7</span>
00907 <span class="preprocessor"></span>
00908 <span class="comment">//</span>
00909 <span class="comment">// Processor State frame: Before a processor freezes itself, it</span>
00910 <span class="comment">// dumps the processor state to the processor state frame for</span>
00911 <span class="comment">// debugger to examine.  This is used by KeFreezeExecution and</span>
00912 <span class="comment">// KeUnfreezeExecution routines.</span>
00913 <span class="comment">// (from mips.h)BUGBUG shielint Need to fill in the actual structure.</span>
00914 <span class="comment">//</span>
00915 
00916 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KPROCESSOR_STATE {
00917     <span class="keyword">struct </span>_CONTEXT ContextFrame;
00918 } KPROCESSOR_STATE, *PKPROCESSOR_STATE;
00919 
00920 <span class="comment">// begin_ntddk</span>
00921 <span class="comment">//</span>
00922 <span class="comment">// Processor Control Block (PRCB)</span>
00923 <span class="comment">//</span>
00924 
00925 <span class="preprocessor">#define PRCB_MINOR_VERSION 1</span>
00926 <span class="preprocessor"></span><span class="preprocessor">#define PRCB_MAJOR_VERSION 2</span>
00927 <span class="preprocessor"></span><span class="preprocessor">#define PRCB_BUILD_DEBUG        0x0001</span>
00928 <span class="preprocessor"></span><span class="preprocessor">#define PRCB_BUILD_UNIPROCESSOR 0x0002</span>
00929 <span class="preprocessor"></span>
00930 <span class="keyword">typedef</span> <span class="keyword">struct </span>_KPRCB {
00931 
00932 <span class="comment">//</span>
00933 <span class="comment">// Major and minor version numbers of the PCR.</span>
00934 <span class="comment">//</span>
00935 
00936     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> MinorVersion;
00937     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> MajorVersion;
00938 
00939 <span class="comment">//</span>
00940 <span class="comment">// Start of the architecturally defined section of the PRCB. This section</span>
00941 <span class="comment">// may be directly addressed by vendor/platform specific HAL code and will</span>
00942 <span class="comment">// not change from version to version of NT.</span>
00943 <span class="comment">//</span>
00944 
00945     <span class="keyword">struct </span><a class="code" href="../../d1/d8/struct__KTHREAD.html">_KTHREAD</a> *CurrentThread;
00946     <span class="keyword">struct </span><a class="code" href="../../d1/d8/struct__KTHREAD.html">_KTHREAD</a> *NextThread;
00947     <span class="keyword">struct </span><a class="code" href="../../d1/d8/struct__KTHREAD.html">_KTHREAD</a> *IdleThread;
00948     CCHAR Number;
00949     CCHAR Reserved;
00950     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> BuildType;
00951     KAFFINITY <a class="code" href="../../d0/d0/ki_8h.html#a7">SetMember</a>;
00952     <span class="keyword">struct </span><a class="code" href="../../d5/d4/struct__RESTART__BLOCK.html">_RESTART_BLOCK</a> *RestartBlock;
00953 
00954 <span class="comment">//</span>
00955 <span class="comment">// End of the architecturally defined section of the PRCB. This section</span>
00956 <span class="comment">// may be directly addressed by vendor/platform specific HAL code and will</span>
00957 <span class="comment">// not change from version to version of NT.</span>
00958 <span class="comment">//</span>
00959 <span class="comment">// end_ntddk end_nthal</span>
00960 
00961     ULONG InterruptCount;
00962     ULONG DpcTime;
00963     ULONG InterruptTime;
00964     ULONG KernelTime;
00965     ULONG UserTime;
00966     <a class="code" href="../../d1/d6/struct__KDPC.html">KDPC</a> QuantumEndDpc;
00967 
00968 <span class="comment">//</span>
00969 <span class="comment">// Address of PCR.</span>
00970 <span class="comment">//</span>
00971 
00972     PKPCR Pcr;
00973 
00974 <span class="comment">//</span>
00975 <span class="comment">// MP Information.</span>
00976 <span class="comment">//</span>
00977 
00978     PVOID <a class="code" href="../../d4/d9/ke_8h.html#a407a219">Spare2</a>;
00979     PVOID <a class="code" href="../../d4/d9/ke_8h.html#a407a220">Spare3</a>;
00980     <span class="keyword">volatile</span> ULONG IpiFrozen;
00981     <span class="keyword">struct </span>_KPROCESSOR_STATE ProcessorState;
00982     ULONG LastDpcCount;
00983     ULONG DpcBypassCount;
00984     ULONG SoftwareInterrupts;
00985     PKTRAP_FRAME InterruptTrapFrame;
00986     ULONG ApcBypassCount;
00987     ULONG DispatchInterruptCount;
00988     ULONG DebugDpcTime;
00989     PVOID Spares[6];
00990 
00991 <span class="comment">//</span>
00992 <span class="comment">// Spares.</span>
00993 <span class="comment">//</span>
00994 
00995     PVOID MoreSpares[3];
00996     <a class="code" href="../../d1/d7/struct__KIPI__COUNTS.html">PKIPI_COUNTS</a> IpiCounts;
00997 
00998 <span class="comment">//</span>
00999 <span class="comment">// Per-processor data for various hot code which resides in the</span>
01000 <span class="comment">// kernel image.  We give each processor it's own copy of the data</span>
01001 <span class="comment">// to lessen the caching impact of sharing the data between multiple</span>
01002 <span class="comment">// processors.</span>
01003 <span class="comment">//</span>
01004 
01005 <span class="comment">//</span>
01006 <span class="comment">//  Spares (formerly fsrtl filelock free lists)</span>
01007 <span class="comment">//</span>
01008 
01009     PVOID SpareHotData[2];
01010 
01011 <span class="comment">//</span>
01012 <span class="comment">// Cache manager performance counters.</span>
01013 <span class="comment">//</span>
01014 
01015     ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a44">CcFastReadNoWait</a>;
01016     ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a45">CcFastReadWait</a>;
01017     ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a47">CcFastReadNotPossible</a>;
01018     ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a61">CcCopyReadNoWait</a>;
01019     ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a62">CcCopyReadWait</a>;
01020     ULONG <a class="code" href="../../d5/d2/cachedat_8c.html#a63">CcCopyReadNoWaitMiss</a>;
01021 
01022 <span class="comment">//</span>
01023 <span class="comment">// Kernel performance counters.</span>
01024 <span class="comment">//</span>
01025 
01026     ULONG KeAlignmentFixupCount;
01027     ULONG KeContextSwitches;
01028     ULONG <a class="code" href="../../d5/d9/kernldat_8c.html#a13">KeDcacheFlushCount</a>;
01029     ULONG KeExceptionDispatchCount;
01030     ULONG KeFirstLevelTbFills;
01031     ULONG KeFloatingEmulationCount;
01032     ULONG <a class="code" href="../../d5/d9/kernldat_8c.html#a14">KeIcacheFlushCount</a>;
01033     ULONG KeSecondLevelTbFills;
01034     ULONG KeSystemCalls;
01035     ULONG KeByteWordEmulationCount;
01036 
01037 <span class="comment">//</span>
01038 <span class="comment">//  Reserved for future counters.</span>
01039 <span class="comment">//</span>
01040 
01041     ULONG ReservedCounter[1];
01042 
01043 <span class="comment">//</span>
01044 <span class="comment">// I/O system per processor single entry lookaside lists.</span>
01045 <span class="comment">//</span>
01046 
01047     PVOID SmallIrpFreeEntry;
01048     PVOID LargeIrpFreeEntry;
01049     PVOID MdlFreeEntry;
01050 
01051 <span class="comment">//</span>
01052 <span class="comment">// Object manager per processor single entry lookaside lists.</span>
01053 <span class="comment">//</span>
01054 
01055     PVOID CreateInfoFreeEntry;
01056     PVOID NameBufferFreeEntry;
01057 
01058 <span class="comment">//</span>
01059 <span class="comment">// Cache manager per processor single entry lookaside lists.</span>
01060 <span class="comment">//</span>
01061 
01062     PVOID SharedCacheMapEntry;
01063 
01064 <span class="comment">//</span>
01065 <span class="comment">//  Spares (formerly fsrtl filelock free lists)</span>
01066 <span class="comment">//</span>
01067 
01068     PVOID MoreSpareHotData[2];
01069 
01070 <span class="comment">//</span>
01071 <span class="comment">// Nonpaged per processor lookaside lists.</span>
01072 <span class="comment">//</span>
01073 
01074     <a class="code" href="../../d5/d9/struct__PP__LOOKASIDE__LIST.html">PP_LOOKASIDE_LIST</a> PPLookasideList[16];
01075 
01076 <span class="comment">//</span>
01077 <span class="comment">// Nonpaged per processor small pool lookaside lists.</span>
01078 <span class="comment">//</span>
01079 
01080     <a class="code" href="../../d5/d9/struct__PP__LOOKASIDE__LIST.html">PP_LOOKASIDE_LIST</a> PPNPagedLookasideList[<a class="code" href="../../d0/d9/ntosdef_8h.html#a2">POOL_SMALL_LISTS</a>];
01081 
01082 <span class="comment">//</span>
01083 <span class="comment">// Paged per processor small pool lookaside lists.</span>
01084 <span class="comment">//</span>
01085 
01086     <a class="code" href="../../d5/d9/struct__PP__LOOKASIDE__LIST.html">PP_LOOKASIDE_LIST</a> PPPagedLookasideList[<a class="code" href="../../d0/d9/ntosdef_8h.html#a2">POOL_SMALL_LISTS</a>];
01087 
01088 <span class="comment">//</span>
01089 <span class="comment">// Per processor lock queue entries.</span>
01090 <span class="comment">//</span>
01091 
01092     <a class="code" href="../../d0/d8/struct__KSPIN__LOCK__QUEUE.html">KSPIN_LOCK_QUEUE</a> LockQueue[16];
01093 
01094 <span class="comment">//</span>
01095 <span class="comment">// Reserved Pad.</span>
01096 <span class="comment">//</span>
01097 
01098 <span class="preprocessor">#if !defined(_AXP64_)</span>
01099 <span class="preprocessor"></span>
01100     UCHAR ReservedPad[16 * 8];
01101 
01102 <span class="preprocessor">#endif</span>
01103 <span class="preprocessor"></span>
01104 <span class="comment">//</span>
01105 <span class="comment">// MP interprocessor request packet and summary.</span>
01106 <span class="comment">//</span>
01107 <span class="comment">// N.B. This is carefully aligned to be on a cache line boundary.</span>
01108 <span class="comment">//</span>
01109 
01110     <span class="keyword">volatile</span> PVOID CurrentPacket[3];
01111     <span class="keyword">volatile</span> KAFFINITY TargetSet;
01112     <span class="keyword">volatile</span> <a class="code" href="../../d0/d9/ntosdef_8h.html#a55">PKIPI_WORKER</a> WorkerRoutine;
01113     ULONG CachePad1[11];
01114 
01115 <span class="comment">//</span>
01116 <span class="comment">// N.B. These two longwords must be on a quadword boundary and adjacent.</span>
01117 <span class="comment">//</span>
01118 
01119     <span class="keyword">volatile</span> ULONGLONG RequestSummary;
01120 
01121 <span class="comment">//</span>
01122 <span class="comment">// Spare counters.</span>
01123 <span class="comment">//</span>
01124 
01125     ULONG <a class="code" href="../../d4/d9/ke_8h.html#a407a221">Spare4</a>[14];
01126     ULONG DpcInterruptRequested;
01127     ULONG <a class="code" href="../../d4/d9/ke_8h.html#a407a222">Spare5</a>[17];
01128     ULONG CachePad2[2];
01129     ULONG MaximumDpcQueueDepth;
01130     ULONG MinimumDpcRate;
01131     ULONG AdjustDpcThreshold;
01132     ULONG DpcRequestRate;
01133     LARGE_INTEGER StartCount;
01134 <span class="comment">//</span>
01135 <span class="comment">// DPC list head, spinlock, and count.</span>
01136 <span class="comment">//</span>
01137 
01138     LIST_ENTRY DpcListHead;
01139     KSPIN_LOCK DpcLock;
01140     ULONG DpcCount;
01141     ULONG QuantumEnd;
01142     ULONG DpcRoutineActive;
01143     ULONG DpcQueueDepth;
01144 
01145     BOOLEAN SkipTick;
01146 
01147 <span class="comment">//</span>
01148 <span class="comment">// Processor's power state</span>
01149 <span class="comment">//</span>
01150     PROCESSOR_POWER_STATE PowerState;
01151 
01152 } KPRCB, *PKPRCB, *RESTRICTED_POINTER PRKPRCB;      <span class="comment">// ntddk nthal</span>
01153 
01154 <span class="comment">// begin_ntddk begin_wdm begin_nthal begin_ntndis</span>
01155 <span class="comment">//</span>
01156 <span class="comment">// I/O space read and write macros.</span>
01157 <span class="comment">//</span>
01158 <span class="comment">//  These have to be actual functions on Alpha, because we need</span>
01159 <span class="comment">//  to shift the VA and OR in the BYTE ENABLES.</span>
01160 <span class="comment">//</span>
01161 <span class="comment">//  These can become INLINEs if we require that ALL Alpha systems shift</span>
01162 <span class="comment">//  the same number of bits and have the SAME byte enables.</span>
01163 <span class="comment">//</span>
01164 <span class="comment">//  The READ/WRITE_REGISTER_* calls manipulate I/O registers in MEMORY space?</span>
01165 <span class="comment">//</span>
01166 <span class="comment">//  The READ/WRITE_PORT_* calls manipulate I/O registers in PORT space?</span>
01167 <span class="comment">//</span>
01168 
01169 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
01170 UCHAR
01171 READ_REGISTER_UCHAR(
01172     PUCHAR Register
01173     );
01174 
01175 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
01176 <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>
01177 READ_REGISTER_USHORT(
01178     PUSHORT Register
01179     );
01180 
01181 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
01182 ULONG
01183 READ_REGISTER_ULONG(
01184     PULONG Register
01185     );
01186 
01187 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
01188 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01189 READ_REGISTER_BUFFER_UCHAR(
01190     PUCHAR  Register,
01191     PUCHAR  Buffer,
01192     ULONG   Count
01193     );
01194 
01195 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
01196 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01197 READ_REGISTER_BUFFER_USHORT(
01198     PUSHORT Register,
01199     PUSHORT Buffer,
01200     ULONG   Count
01201     );
01202 
01203 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
01204 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01205 READ_REGISTER_BUFFER_ULONG(
01206     PULONG  Register,
01207     PULONG  Buffer,
01208     ULONG   Count
01209     );
01210 
01211 
01212 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
01213 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01214 WRITE_REGISTER_UCHAR(
01215     PUCHAR Register,
01216     UCHAR   Value
01217     );
01218 
01219 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
01220 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01221 WRITE_REGISTER_USHORT(
01222     PUSHORT Register,
01223     USHORT  Value
01224     );
01225 
01226 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
01227 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01228 WRITE_REGISTER_ULONG(
01229     PULONG Register,
01230     ULONG   Value
01231     );
01232 
01233 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
01234 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01235 WRITE_REGISTER_BUFFER_UCHAR(
01236     PUCHAR  Register,
01237     PUCHAR  Buffer,
01238     ULONG   Count
01239     );
01240 
01241 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
01242 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01243 WRITE_REGISTER_BUFFER_USHORT(
01244     PUSHORT Register,
01245     PUSHORT Buffer,
01246     ULONG   Count
01247     );
01248 
01249 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
01250 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01251 WRITE_REGISTER_BUFFER_ULONG(
01252     PULONG  Register,
01253     PULONG  Buffer,
01254     ULONG   Count
01255     );
01256 
01257 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
01258 UCHAR
01259 READ_PORT_UCHAR(
01260     PUCHAR Port
01261     );
01262 
01263 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
01264 <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>
01265 READ_PORT_USHORT(
01266     PUSHORT Port
01267     );
01268 
01269 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
01270 ULONG
01271 READ_PORT_ULONG(
01272     PULONG  Port
01273     );
01274 
01275 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
01276 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01277 READ_PORT_BUFFER_UCHAR(
01278     PUCHAR  Port,
01279     PUCHAR  Buffer,
01280     ULONG   Count
01281     );
01282 
01283 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
01284 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01285 READ_PORT_BUFFER_USHORT(
01286     PUSHORT Port,
01287     PUSHORT Buffer,
01288     ULONG   Count
01289     );
01290 
01291 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
01292 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01293 READ_PORT_BUFFER_ULONG(
01294     PULONG  Port,
01295     PULONG  Buffer,
01296     ULONG   Count
01297     );
01298 
01299 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
01300 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01301 WRITE_PORT_UCHAR(
01302     PUCHAR  Port,
01303     UCHAR   Value
01304     );
01305 
01306 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
01307 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01308 WRITE_PORT_USHORT(
01309     PUSHORT Port,
01310     USHORT  Value
01311     );
01312 
01313 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
01314 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01315 WRITE_PORT_ULONG(
01316     PULONG  Port,
01317     ULONG   Value
01318     );
01319 
01320 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
01321 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01322 WRITE_PORT_BUFFER_UCHAR(
01323     PUCHAR  Port,
01324     PUCHAR  Buffer,
01325     ULONG   Count
01326     );
01327 
01328 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
01329 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01330 WRITE_PORT_BUFFER_USHORT(
01331     PUSHORT Port,
01332     PUSHORT Buffer,
01333     ULONG   Count
01334     );
01335 
01336 <a class="code" href="../../d0/d9/ntosdef_8h.html#a30">NTHALAPI</a>
01337 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01338 WRITE_PORT_BUFFER_ULONG(
01339     PULONG  Port,
01340     PULONG  Buffer,
01341     ULONG   Count
01342     );
01343 
01344 <span class="comment">// end_ntndis end_wdm</span>
01345 <span class="comment">//</span>
01346 <span class="comment">// Define Interlocked operation result values.</span>
01347 <span class="comment">//</span>
01348 
01349 <span class="preprocessor">#define RESULT_ZERO 0</span>
01350 <span class="preprocessor"></span><span class="preprocessor">#define RESULT_NEGATIVE 1</span>
01351 <span class="preprocessor"></span><span class="preprocessor">#define RESULT_POSITIVE 2</span>
01352 <span class="preprocessor"></span>
01353 <span class="comment">//</span>
01354 <span class="comment">// Interlocked result type is portable, but its values are machine specific.</span>
01355 <span class="comment">// Constants for value are in i386.h, mips.h, etc.</span>
01356 <span class="comment">//</span>
01357 
01358 <span class="keyword">typedef</span> <span class="keyword">enum</span> _INTERLOCKED_RESULT {
01359     ResultNegative = RESULT_NEGATIVE,
01360     ResultZero     = RESULT_ZERO,
01361     ResultPositive = RESULT_POSITIVE
01362 } INTERLOCKED_RESULT;
01363 
01364 <span class="comment">//</span>
01365 <span class="comment">// Convert portable interlock interfaces to architecture specific interfaces.</span>
01366 <span class="comment">//</span>
01367 
01368 <span class="preprocessor">#define ExInterlockedIncrementLong(Addend, Lock) \</span>
01369 <span class="preprocessor">    ExAlphaInterlockedIncrementLong(Addend)</span>
01370 <span class="preprocessor"></span>
01371 <span class="preprocessor">#define ExInterlockedDecrementLong(Addend, Lock) \</span>
01372 <span class="preprocessor">    ExAlphaInterlockedDecrementLong(Addend)</span>
01373 <span class="preprocessor"></span>
01374 <span class="preprocessor">#define ExInterlockedExchangeAddLargeInteger(Target, Value, Lock) \</span>
01375 <span class="preprocessor">    ExpInterlockedExchangeAddLargeInteger(Target, Value)</span>
01376 <span class="preprocessor"></span>
01377 <span class="preprocessor">#define ExInterlockedExchangeUlong(Target, Value, Lock) \</span>
01378 <span class="preprocessor">    ExAlphaInterlockedExchangeUlong(Target, Value)</span>
01379 <span class="preprocessor"></span>
01380 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01381 INTERLOCKED_RESULT
01382 ExAlphaInterlockedIncrementLong (
01383     IN PLONG Addend
01384     );
01385 
01386 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01387 INTERLOCKED_RESULT
01388 ExAlphaInterlockedDecrementLong (
01389     IN PLONG Addend
01390     );
01391 
01392 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01393 LARGE_INTEGER
01394 ExpInterlockedExchangeAddLargeInteger (
01395     IN PLARGE_INTEGER Addend,
01396     IN LARGE_INTEGER Increment
01397     );
01398 
01399 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01400 ULONG
01401 ExAlphaInterlockedExchangeUlong (
01402     IN PULONG Target,
01403     IN ULONG Value
01404     );
01405 
01406 <span class="comment">//  begin_wdm</span>
01407 
01408 <span class="preprocessor">#if defined(_M_ALPHA) &amp;&amp; !defined(RC_INVOKED)</span>
01409 <span class="preprocessor"></span>
01410 <span class="preprocessor">#define InterlockedIncrement _InterlockedIncrement</span>
01411 <span class="preprocessor"></span><span class="preprocessor">#define InterlockedDecrement _InterlockedDecrement</span>
01412 <span class="preprocessor"></span><span class="preprocessor">#define InterlockedExchange _InterlockedExchange</span>
01413 <span class="preprocessor"></span><span class="preprocessor">#define InterlockedExchangeAdd _InterlockedExchangeAdd</span>
01414 <span class="preprocessor"></span>
01415 LONG
01416 InterlockedIncrement (
01417     IN OUT PLONG Addend
01418     );
01419 
01420 LONG
01421 InterlockedDecrement (
01422     IN OUT PLONG Addend
01423     );
01424 
01425 LONG
01426 InterlockedExchange (
01427     IN OUT PLONG Target,
01428     LONG Value
01429     );
01430 
01431 <span class="preprocessor">#if defined(_M_AXP64)</span>
01432 <span class="preprocessor"></span>
01433 <span class="preprocessor">#define InterlockedCompareExchange _InterlockedCompareExchange</span>
01434 <span class="preprocessor"></span><span class="preprocessor">#define InterlockedCompareExchange64 _InterlockedCompareExchange64</span>
01435 <span class="preprocessor"></span><span class="preprocessor">#define InterlockedExchangePointer _InterlockedExchangePointer</span>
01436 <span class="preprocessor"></span><span class="preprocessor">#define InterlockedCompareExchangePointer _InterlockedCompareExchangePointer</span>
01437 <span class="preprocessor"></span><span class="preprocessor">#define InterlockedExchange64 _InterlockedExchange64</span>
01438 <span class="preprocessor"></span>
01439 LONG
01440 InterlockedCompareExchange (
01441     IN OUT PLONG Destination,
01442     IN LONG ExChange,
01443     IN LONG Comperand
01444     );
01445 
01446 LONGLONG
01447 InterlockedCompareExchange64 (
01448     IN OUT PLONGLONG Destination,
01449     IN LONGLONG ExChange,
01450     IN LONGLONG Comperand
01451     );
01452 
01453 PVOID
01454 InterlockedExchangePointer (
01455     IN OUT PVOID *Target,
01456     IN PVOID Value
01457     );
01458 
01459 PVOID
01460 InterlockedCompareExchangePointer (
01461     IN OUT PVOID *Destination,
01462     IN PVOID ExChange,
01463     IN PVOID Comperand
01464     );
01465 
01466 LONGLONG
01467 InterlockedExchange64(
01468     IN OUT PLONGLONG Target,
01469     IN LONGLONG Value
01470     );
01471 
01472 <span class="preprocessor">#pragma intrinsic(_InterlockedCompareExchange64)</span>
01473 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic(_InterlockedExchangePointer)</span>
01474 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic(_InterlockedCompareExchangePointer)</span>
01475 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic(_InterlockedExchange64)</span>
01476 <span class="preprocessor"></span>
01477 <span class="preprocessor">#else</span>
01478 <span class="preprocessor"></span>
01479 <span class="preprocessor">#define InterlockedExchangePointer(Target, Value) \</span>
01480 <span class="preprocessor">    (PVOID)InterlockedExchange((PLONG)(Target), (LONG)(Value))</span>
01481 <span class="preprocessor"></span>
01482 <span class="preprocessor">#define InterlockedCompareExchange(Destination, ExChange, Comperand) \</span>
01483 <span class="preprocessor">    (LONG)_InterlockedCompareExchange((PVOID *)(Destination), (PVOID)(ExChange), (PVOID)(Comperand))</span>
01484 <span class="preprocessor"></span>
01485 <span class="preprocessor">#define InterlockedCompareExchangePointer(Destination, ExChange, Comperand) \</span>
01486 <span class="preprocessor">    _InterlockedCompareExchange(Destination, ExChange, Comperand)</span>
01487 <span class="preprocessor"></span>
01488 PVOID
01489 _InterlockedCompareExchange (
01490     IN OUT PVOID *Destination,
01491     IN PVOID ExChange,
01492     IN PVOID Comperand
01493     );
01494 
01495 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01496 LONGLONG
01497 ExpInterlockedCompareExchange64 (
01498     IN OUT PLONGLONG Destination,
01499     IN PLONGLONG Exchange,
01500     IN PLONGLONG Comperand
01501     );
01502 
01503 <span class="preprocessor">#endif</span>
01504 <span class="preprocessor"></span>
01505 LONG
01506 InterlockedExchangeAdd(
01507     IN OUT PLONG Addend,
01508     IN LONG Value
01509     );
01510 
01511 <span class="preprocessor">#pragma intrinsic(_InterlockedIncrement)</span>
01512 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic(_InterlockedDecrement)</span>
01513 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic(_InterlockedExchange)</span>
01514 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic(_InterlockedExchangeAdd)</span>
01515 <span class="preprocessor"></span><span class="preprocessor">#pragma intrinsic(_InterlockedCompareExchange)</span>
01516 <span class="preprocessor"></span>
01517 <span class="preprocessor">#endif</span>
01518 <span class="preprocessor"></span>
01519 <span class="comment">// there is a lot of other stuff that could go in here</span>
01520 <span class="comment">//   probe macros</span>
01521 <span class="comment">//   others</span>
01522 <span class="comment">// end_ntddk end_wdm end_nthal</span>
01523 <span class="comment">//</span>
01524 <span class="comment">// Intrinsic interlocked functions.</span>
01525 <span class="comment">//</span>
01526 
01527 
01528 <span class="comment">// begin_ntddk begin_wdm begin_nthal begin_ntndis</span>
01529 
01530 <span class="comment">//</span>
01531 <span class="comment">// Define the page size for the Alpha ev4 and lca as 8k.</span>
01532 <span class="comment">//</span>
01533 
01534 <span class="preprocessor">#define PAGE_SIZE 0x2000</span>
01535 <span class="preprocessor"></span>
01536 <span class="comment">//</span>
01537 <span class="comment">// Define the number of trailing zeroes in a page aligned virtual address.</span>
01538 <span class="comment">// This is used as the shift count when shifting virtual addresses to</span>
01539 <span class="comment">// virtual page numbers.</span>
01540 <span class="comment">//</span>
01541 
01542 <span class="preprocessor">#define PAGE_SHIFT 13L</span>
01543 <span class="preprocessor"></span>
01544 <span class="comment">// end_ntddk end_wdm end_nthal end_ntndis</span>
01545 
01546 <span class="comment">//</span>
01547 <span class="comment">// Define the number of bits to shift to right justify the Page Directory Index</span>
01548 <span class="comment">// field of a PTE.</span>
01549 <span class="comment">//</span>
01550 
01551 <span class="preprocessor">#if defined(_AXP64_)</span>
01552 <span class="preprocessor"></span>
01553 <span class="preprocessor">#define PDI_SHIFT 23</span>
01554 <span class="preprocessor"></span><span class="preprocessor">#define PDI1_SHIFT 33</span>
01555 <span class="preprocessor"></span><span class="preprocessor">#define PDI2_SHIFT 23</span>
01556 <span class="preprocessor"></span><span class="preprocessor">#define PDI_MASK 0x3ff</span>
01557 <span class="preprocessor"></span>
01558 <span class="preprocessor">#else</span>
01559 <span class="preprocessor"></span>
01560 <span class="preprocessor">#define PDI_SHIFT 24</span>
01561 <span class="preprocessor"></span>
01562 <span class="preprocessor">#endif</span>
01563 <span class="preprocessor"></span>
01564 <span class="comment">//</span>
01565 <span class="comment">// Define the number of bits to shift to right justify the Page Table Index</span>
01566 <span class="comment">// field of a PTE.</span>
01567 <span class="comment">//</span>
01568 
01569 <span class="preprocessor">#define PTI_SHIFT 13</span>
01570 <span class="preprocessor"></span>
01571 <span class="comment">//</span>
01572 <span class="comment">// Define the maximum address space number allowable for the architecture.</span>
01573 <span class="comment">//</span>
01574 
01575 <span class="preprocessor">#define ALPHA_AXP_MAXIMUM_ASN 0xffffffff</span>
01576 <span class="preprocessor"></span>
01577 <span class="comment">// begin_ntddk begin_nthal</span>
01578 
01579 <span class="comment">//</span>
01580 <span class="comment">// The highest user address reserves 64K bytes for a guard page. This is so</span>
01581 <span class="comment">// the probing of addresses from kernel mode only have to check the</span>
01582 <span class="comment">// starting address for structures of 64K bytes or less.</span>
01583 <span class="comment">//</span>
01584 
01585 <span class="preprocessor">#if defined(_AXP64_)</span>
01586 <span class="preprocessor"></span>
01587 <span class="preprocessor">#define MM_HIGHEST_USER_ADDRESS (PVOID)0x3FFFFFEFFFF // highest user address</span>
01588 <span class="preprocessor"></span><span class="preprocessor">#define MM_USER_PROBE_ADDRESS          0x3FFFFFF0000UI64 // guard page address</span>
01589 <span class="preprocessor"></span><span class="preprocessor">#define MM_SYSTEM_RANGE_START   (PVOID)0xFFFFFC0000000000 // start of system space</span>
01590 <span class="preprocessor"></span>
01591 <span class="preprocessor">#else</span>
01592 <span class="preprocessor"></span>
01593 <span class="preprocessor">#define MM_HIGHEST_USER_ADDRESS (PVOID)0x7FFEFFFF // highest user address</span>
01594 <span class="preprocessor"></span><span class="preprocessor">#define MM_USER_PROBE_ADDRESS 0x7FFF0000 // starting address of guard page</span>
01595 <span class="preprocessor"></span><span class="preprocessor">#define MM_SYSTEM_RANGE_START (PVOID)KSEG0_BASE // start of system space</span>
01596 <span class="preprocessor"></span>
01597 <span class="preprocessor">#endif</span>
01598 <span class="preprocessor"></span>
01599 
01600 <span class="comment">//</span>
01601 <span class="comment">// The following definitions are required for the debugger data block.</span>
01602 <span class="comment">//</span>
01603 
01604 <span class="keyword">extern</span> PVOID <a class="code" href="../../d0/d9/miglobal_8c.html#a0">MmHighestUserAddress</a>;
01605 <span class="keyword">extern</span> PVOID <a class="code" href="../../d0/d9/miglobal_8c.html#a1">MmSystemRangeStart</a>;
01606 <span class="keyword">extern</span> ULONG_PTR <a class="code" href="../../d0/d9/miglobal_8c.html#a2">MmUserProbeAddress</a>;
01607 
01608 <span class="comment">//</span>
01609 <span class="comment">// The lowest user address reserves the low 64k.</span>
01610 <span class="comment">//</span>
01611 
01612 <span class="preprocessor">#define MM_LOWEST_USER_ADDRESS  (PVOID)0x00010000</span>
01613 <span class="preprocessor"></span>
01614 <span class="comment">// begin_wdm</span>
01615 
01616 <span class="preprocessor">#define MmGetProcedureAddress(Address) (Address)</span>
01617 <span class="preprocessor"></span><span class="preprocessor">#define MmLockPagableCodeSection(Address) MmLockPagableDataSection(Address)</span>
01618 <span class="preprocessor"></span>
01619 <span class="comment">// end_ntddk end_wdm end_nthal</span>
01620 
01621 <span class="comment">//</span>
01622 <span class="comment">// Define the page table base and the page directory base for</span>
01623 <span class="comment">// the TB miss routines and memory management.</span>
01624 <span class="comment">//</span>
01625 
01626 <span class="preprocessor">#if defined(_AXP64_)</span>
01627 <span class="preprocessor"></span>
01628 <span class="preprocessor">#define PDE_TBASE 0xFFFFFE0180600000UI64 // first level PDR address</span>
01629 <span class="preprocessor"></span><span class="preprocessor">#define PDE_SELFMAP 0xFFFFFE0180601800UI64 // first level PDR self map address</span>
01630 <span class="preprocessor"></span><span class="preprocessor">#define PDE_UBASE 0xFFFFFE0180000000UI64 // user second level PDR address</span>
01631 <span class="preprocessor"></span><span class="preprocessor">#define PDE_KBASE 0xFFFFFE01807FE000UI64 // kernel second level PDR address</span>
01632 <span class="preprocessor"></span><span class="preprocessor">#define PDE_BASE PDE_KBASE              // kernel second level PDR address</span>
01633 <span class="preprocessor"></span><span class="preprocessor">#define PTE_BASE 0xFFFFFE0000000000UI64 // page table address</span>
01634 <span class="preprocessor"></span><span class="preprocessor">#define PDE64_BASE 0xFFFFFE0180600000UI64 // first level PDR address</span>
01635 <span class="preprocessor"></span><span class="preprocessor">#define PTE64_BASE 0xFFFFFE0000000000UI64 // page table address</span>
01636 <span class="preprocessor"></span><span class="preprocessor">#define VA_SHIFT (63 - 42)              // address sign extend shift count</span>
01637 <span class="preprocessor"></span>
01638 <span class="preprocessor">#else</span>
01639 <span class="preprocessor"></span>
01640 <span class="preprocessor">#define PDE_BASE (ULONG)0xC0180000      // first level PDR address</span>
01641 <span class="preprocessor"></span><span class="preprocessor">#define PDE_SELFMAP (ULONG)0xC0180300   // first level PDR self map address</span>
01642 <span class="preprocessor"></span><span class="preprocessor">#define PTE_BASE (ULONG)0xC0000000      // page table address</span>
01643 <span class="preprocessor"></span><span class="preprocessor">#define PDE64_BASE (ULONG)0xC0184000    // first level 64-bit PDR address</span>
01644 <span class="preprocessor"></span><span class="preprocessor">#define PTE64_BASE (ULONG)0xC2000000    // 64-bit page table address</span>
01645 <span class="preprocessor"></span>
01646 <span class="preprocessor">#endif</span>
01647 <span class="preprocessor"></span>
01648 <span class="comment">//</span>
01649 <span class="comment">// Generate kernel segment physical address.</span>
01650 <span class="comment">//</span>
01651 
01652 <span class="preprocessor">#if defined(_AXP64_)</span>
01653 <span class="preprocessor"></span>
01654 <span class="preprocessor">#define KSEG_ADDRESS(FrameNumber) \</span>
01655 <span class="preprocessor">    ((PVOID)(KSEG43_BASE | ((ULONG_PTR)(FrameNumber) &lt;&lt; PAGE_SHIFT)))</span>
01656 <span class="preprocessor"></span>
01657 <span class="preprocessor">#else</span>
01658 <span class="preprocessor"></span>
01659 <span class="preprocessor">#define KSEG_ADDRESS(FrameNumber) \</span>
01660 <span class="preprocessor">    ((PVOID)(KSEG0_BASE | ((ULONG)(FrameNumber) &lt;&lt; PAGE_SHIFT)))</span>
01661 <span class="preprocessor"></span>
01662 <span class="preprocessor">#endif</span>
01663 <span class="preprocessor"></span>
01664 <span class="comment">// begin_ntddk begin_wdm</span>
01665 <span class="comment">//</span>
01666 <span class="comment">// The lowest address for system space.</span>
01667 <span class="comment">//</span>
01668 
01669 <span class="preprocessor">#if defined(_AXP64_)</span>
01670 <span class="preprocessor"></span>
01671 <span class="preprocessor">#define MM_LOWEST_SYSTEM_ADDRESS (PVOID)0xFFFFFE0200000000</span>
01672 <span class="preprocessor"></span>
01673 <span class="preprocessor">#else</span>
01674 <span class="preprocessor"></span>
01675 <span class="preprocessor">#define MM_LOWEST_SYSTEM_ADDRESS (PVOID)0xC0800000</span>
01676 <span class="preprocessor"></span>
01677 <span class="preprocessor">#endif</span>
01678 <span class="preprocessor"></span>
01679 <span class="comment">// end_ntddk end_wdm</span>
01680 
01681 <span class="preprocessor">#if defined(_AXP64_)</span>
01682 <span class="preprocessor"></span>
01683 <span class="preprocessor">#define SYSTEM_BASE 0xFFFFFE0200000000  // start of system space (no typecast)</span>
01684 <span class="preprocessor"></span>
01685 <span class="preprocessor">#else</span>
01686 <span class="preprocessor"></span>
01687 <span class="preprocessor">#define SYSTEM_BASE 0xc0800000          // start of system space (no typecast)</span>
01688 <span class="preprocessor"></span>
01689 <span class="preprocessor">#endif</span>
01690 <span class="preprocessor"></span>
01691 <span class="comment">// begin_nthal begin_ntddk begin_wdm</span>
01692 
01693 <span class="comment">//</span>
01694 <span class="comment">// Define prototypes to access PCR values</span>
01695 <span class="comment">//</span>
01696 
01697 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01698 KIRQL
01699 KeGetCurrentIrql();
01700 
01701 <span class="comment">// end_nthal end_ntddk end_wdm</span>
01702 
01703 <span class="preprocessor">#define KeGetCurrentThread() ((struct _KTHREAD *) __rdthread())</span>
01704 <span class="preprocessor"></span>
01705 <span class="comment">// begin_ntddk begin_wdm</span>
01706 
01707 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01708 <a class="code" href="../../d2/d0/ke_2i386_2misc_8c.html#a13">KeSaveFloatingPointState</a> (
01709     OUT PKFLOATING_SAVE     FloatSave
01710     );
01711 
01712 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
01713 <a class="code" href="../../d2/d0/ke_2i386_2misc_8c.html#a14">KeRestoreFloatingPointState</a> (
01714     IN PKFLOATING_SAVE      FloatSave
01715     );
01716 
01717 <span class="comment">// end_ntddk end_wdm</span>
01718 <span class="comment">// begin_nthal</span>
01719 
01720 <span class="preprocessor">#define KeGetPreviousMode() (KeGetCurrentThread()-&gt;PreviousMode)</span>
01721 <span class="preprocessor"></span>
01722 <span class="preprocessor">#define KeGetDcacheFillSize() PCR-&gt;FirstLevelDcacheFillSize</span>
01723 <span class="preprocessor"></span>
01724 <span class="comment">//</span>
01725 <span class="comment">// Test if executing DPC.</span>
01726 <span class="comment">//</span>
01727 
01728 BOOLEAN
01729 KeIsExecutingDpc (
01730     VOID
01731     );
01732 
01733 <span class="comment">//</span>
01734 <span class="comment">// Return interrupt trap frame</span>
01735 <span class="comment">//</span>
01736 PKTRAP_FRAME
01737 <a class="code" href="../../d3/d4/alpha_2intobj_8c.html#a3">KeGetInterruptTrapFrame</a>(
01738     VOID
01739     );
01740 
01741 <span class="comment">// begin_ntddk</span>
01742 <span class="comment">//</span>
01743 <span class="comment">// Get address of current PRCB.</span>
01744 <span class="comment">//</span>
01745 
01746 <span class="preprocessor">#define KeGetCurrentPrcb() (PCR-&gt;Prcb)</span>
01747 <span class="preprocessor"></span>
01748 <span class="comment">//</span>
01749 <span class="comment">// Get current processor number.</span>
01750 <span class="comment">//</span>
01751 
01752 <span class="preprocessor">#define KeGetCurrentProcessorNumber() KeGetCurrentPrcb()-&gt;Number</span>
01753 <span class="preprocessor"></span>
01754 <span class="comment">// end_ntddk</span>
01755 
01756 <span class="comment">//</span>
01757 <span class="comment">// Define interface to get pcr address</span>
01758 <span class="comment">//</span>
01759 
01760 PKPCR <a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a1">KeGetPcr</a>(VOID);
01761 
01762 <span class="comment">// end_nthal</span>
01763 
01764 <span class="comment">//</span>
01765 <span class="comment">// Data cache, instruction cache, I/O buffer, and write buffer flush routine</span>
01766 <span class="comment">// prototypes.</span>
01767 <span class="comment">//</span>
01768 
01769 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01770 <a class="code" href="../../d3/d5/ppc_2flush_8c.html#a6">KeSweepDcache</a> (
01771     IN BOOLEAN AllProcessors
01772     );
01773 
01774 <span class="preprocessor">#define KeSweepCurrentDcache() \</span>
01775 <span class="preprocessor">    HalSweepDcache();</span>
01776 <span class="preprocessor"></span>
01777 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01778 <a class="code" href="../../d3/d5/ppc_2flush_8c.html#a7">KeSweepIcache</a> (
01779     IN BOOLEAN AllProcessors
01780     );
01781 
01782 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01783 <a class="code" href="../../d3/d5/ppc_2flush_8c.html#a8">KeSweepIcacheRange</a> (
01784     IN BOOLEAN AllProcessors,
01785     IN PVOID BaseAddress,
01786     IN ULONG_PTR Length
01787     );
01788 
01789 <span class="preprocessor">#define KeSweepCurrentIcache() \</span>
01790 <span class="preprocessor">    HalSweepIcache();</span>
01791 <span class="preprocessor"></span>
01792 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01793 KeFlushIcacheRange (
01794     IN BOOLEAN AllProcessors,
01795     IN PVOID BaseAddress,
01796     IN ULONG_PTR Length
01797     );
01798 
01799 <span class="comment">// begin_ntddk begin_wdm begin_ntndis begin_nthal</span>
01800 <span class="comment">//</span>
01801 <span class="comment">// Cache and write buffer flush functions.</span>
01802 <span class="comment">//</span>
01803 
01804 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01805 <a class="code" href="../../d3/d5/ppc_2flush_8c.html#a9">KeFlushIoBuffers</a> (
01806     IN <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> Mdl,
01807     IN BOOLEAN ReadOperation,
01808     IN BOOLEAN DmaOperation
01809     );
01810 
01811 <span class="comment">// end_ntddk end_wdm end_ntndis</span>
01812 
01813 <span class="comment">//</span>
01814 <span class="comment">// Clock, profile, and interprocessor interrupt functions.</span>
01815 <span class="comment">//</span>
01816 
01817 <span class="keyword">struct </span>_KEXCEPTION_FRAME;
01818 <span class="keyword">struct </span>_KTRAP_FRAME;
01819 
01820 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01821 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01822 KeIpiInterrupt (
01823     IN <span class="keyword">struct</span> _KTRAP_FRAME *TrapFrame
01824     );
01825 
01826 <span class="preprocessor">#define KeYieldProcessor()</span>
01827 <span class="preprocessor"></span>
01828 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01829 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01830 <a class="code" href="../../d1/d9/clock_8c.html#a5">KeProfileInterrupt</a> (
01831     VOID
01832     );
01833 
01834 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01835 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01836 <a class="code" href="../../d1/d9/clock_8c.html#a6">KeProfileInterruptWithSource</a> (
01837     IN KPROFILE_SOURCE ProfileSource
01838     );
01839 
01840 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01841 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01842 <a class="code" href="../../d1/d9/clock_8c.html#a3">KeUpdateRunTime</a> (
01843     VOID
01844     );
01845 
01846 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
01847 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01848 <a class="code" href="../../d1/d9/clock_8c.html#a2">KeUpdateSystemTime</a> (
01849     IN ULONG TimeIncrement
01850     );
01851 
01852 <span class="comment">//</span>
01853 <span class="comment">// The following function prototypes are exported for use in MP HALs.</span>
01854 <span class="comment">//</span>
01855 
01856 
01857 <span class="preprocessor">#if defined(NT_UP)</span>
01858 <span class="preprocessor"></span>
01859 <span class="preprocessor">#define KiAcquireSpinLock(SpinLock)</span>
01860 <span class="preprocessor"></span>
01861 <span class="preprocessor">#else</span>
01862 <span class="preprocessor"></span>
01863 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01864 KiAcquireSpinLock (
01865     IN PKSPIN_LOCK SpinLock
01866     );
01867 
01868 <span class="preprocessor">#endif</span>
01869 <span class="preprocessor"></span>
01870 <span class="preprocessor">#if defined(NT_UP)</span>
01871 <span class="preprocessor"></span>
01872 <span class="preprocessor">#define KiReleaseSpinLock(SpinLock)</span>
01873 <span class="preprocessor"></span>
01874 <span class="preprocessor">#else</span>
01875 <span class="preprocessor"></span>
01876 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01877 KiReleaseSpinLock (
01878     IN PKSPIN_LOCK SpinLock
01879     );
01880 
01881 <span class="preprocessor">#endif</span>
01882 <span class="preprocessor"></span>
01883 <span class="comment">// end_nthal</span>
01884 
01885 <span class="comment">//</span>
01886 <span class="comment">// KeTestSpinLock may be used to spin at low IRQL until the lock is</span>
01887 <span class="comment">// available.  The IRQL must then be raised and the lock acquired with</span>
01888 <span class="comment">// KeTryToAcquireSpinLock.  If that fails, lower the IRQL and start again.</span>
01889 <span class="comment">//</span>
01890 
01891 <span class="preprocessor">#if defined(NT_UP)</span>
01892 <span class="preprocessor"></span>
01893 <span class="preprocessor">#define KeTestSpinLock(SpinLock) (TRUE)</span>
01894 <span class="preprocessor"></span>
01895 <span class="preprocessor">#else</span>
01896 <span class="preprocessor"></span>
01897 BOOLEAN
01898 KeTestSpinLock (
01899     IN PKSPIN_LOCK SpinLock
01900     );
01901 
01902 <span class="preprocessor">#endif</span>
01903 <span class="preprocessor"></span>
01904 
01905 <span class="comment">//</span>
01906 <span class="comment">// Fill TB entry.</span>
01907 <span class="comment">//</span>
01908 
01909 <span class="preprocessor">#define KeFillEntryTb(Pte, Virtual, Invalid) \</span>
01910 <span class="preprocessor">    if (Invalid != FALSE) { \</span>
01911 <span class="preprocessor">        KeFlushSingleTb(Virtual, FALSE, FALSE, Pte, *Pte); \</span>
01912 <span class="preprocessor">    }</span>
01913 <span class="preprocessor"></span>
01914 <span class="comment">//</span>
01915 <span class="comment">// Define machine-specific external references.</span>
01916 <span class="comment">//</span>
01917 
01918 <span class="keyword">extern</span> ULONG KiInterruptTemplate[];
01919 
01920 <span class="comment">//</span>
01921 <span class="comment">// Define machine-dependent function prototypes.</span>
01922 <span class="comment">//</span>
01923 
01924 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01925 KeFlushDcache (
01926     IN BOOLEAN AllProcessors,
01927     IN PVOID BaseAddress OPTIONAL,
01928     IN ULONG Length
01929     );
01930 
01931 ULONG
01932 <a class="code" href="../../d2/d9/ppc_2exceptn_8c.html#a12">KiCopyInformation</a> (
01933     IN OUT PEXCEPTION_RECORD ExceptionRecord1,
01934     IN PEXCEPTION_RECORD ExceptionRecord2
01935     );
01936 
01937 BOOLEAN
01938 <a class="code" href="../../d2/d2/byteem_8c.html#a2">KiEmulateByteWord</a>(
01939     IN OUT PEXCEPTION_RECORD ExceptionRecord,
01940     IN OUT <span class="keyword">struct</span> _KEXCEPTION_FRAME *ExceptionFrame,
01941     IN OUT <span class="keyword">struct</span> _KTRAP_FRAME *TrapFrame
01942     );
01943 
01944 BOOLEAN
01945 <a class="code" href="../../d3/d4/mips_2floatem_8c.html#a32">KiEmulateFloating</a> (
01946     IN OUT PEXCEPTION_RECORD ExceptionRecord,
01947     IN OUT <span class="keyword">struct</span> _KEXCEPTION_FRAME *ExceptionFrame,
01948     IN OUT <span class="keyword">struct</span> _KTRAP_FRAME *TrapFrame,
01949     IN OUT PSW_FPCR SoftwareFpcr
01950     );
01951 
01952 BOOLEAN
01953 <a class="code" href="../../d7/d5/ppc_2alignem_8c.html#a18">KiEmulateReference</a> (
01954     IN OUT PEXCEPTION_RECORD ExceptionRecord,
01955     IN OUT <span class="keyword">struct</span> _KEXCEPTION_FRAME *ExceptionFrame,
01956     IN OUT <span class="keyword">struct</span> _KTRAP_FRAME *TrapFrame,
01957     IN BOOLEAN QuadwordOnly
01958     );
01959 
01960 BOOLEAN
01961 <a class="code" href="../../d8/d5/trigger_8c.html#a11">KiFloatingException</a> (
01962     IN OUT PEXCEPTION_RECORD ExceptionRecord,
01963     IN OUT <span class="keyword">struct</span> _KEXCEPTION_FRAME *ExceptionFrame,
01964     IN OUT <span class="keyword">struct</span> _KTRAP_FRAME *TrapFrame,
01965     IN BOOLEAN ImpreciseTrap,
01966     OUT PULONG SoftFpcrCopy
01967     );
01968 
01969 ULONGLONG
01970 <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a0">KiGetRegisterValue</a> (
01971     IN ULONG Register,
01972     IN <span class="keyword">struct</span> _KEXCEPTION_FRAME *ExceptionFrame,
01973     IN <span class="keyword">struct</span> _KTRAP_FRAME *TrapFrame
01974     );
01975 
01976 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01977 <a class="code" href="../../d8/d5/trigger_8c.html#a12">KiSetFloatingStatus</a> (
01978     IN OUT PEXCEPTION_RECORD ExceptionRecord
01979     );
01980 
01981 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01982 <a class="code" href="../../d8/d5/ppc_2getsetrg_8c.html#a1">KiSetRegisterValue</a> (
01983     IN ULONG Register,
01984     IN ULONGLONG Value,
01985     OUT <span class="keyword">struct</span> _KEXCEPTION_FRAME *ExceptionFrame,
01986     OUT <span class="keyword">struct</span> _KTRAP_FRAME *TrapFrame
01987     );
01988 
01989 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
01990 <a class="code" href="../../d9/d4/intsupc_8c.html#a3">KiRequestSoftwareInterrupt</a> (
01991     KIRQL RequestIrql
01992     );
01993 
01994 <span class="comment">//</span>
01995 <span class="comment">// Define query system time macro.</span>
01996 <span class="comment">//</span>
01997 
01998 <span class="preprocessor">#if _AXP64_</span>
01999 <span class="preprocessor"></span><span class="preprocessor">    #define KiQuerySystemTime(CurrentTime)     \</span>
02000 <span class="preprocessor">        while (TRUE) {                                                             \</span>
02001 <span class="preprocessor">            (CurrentTime)-&gt;HighPart = SharedUserData-&gt;SystemHigh1Time;             \</span>
02002 <span class="preprocessor">            (CurrentTime)-&gt;LowPart = SharedUserData-&gt;SystemLowTime;                \</span>
02003 <span class="preprocessor">            if ((CurrentTime)-&gt;HighPart == SharedUserData-&gt;SystemHigh2Time) break; \</span>
02004 <span class="preprocessor">        }</span>
02005 <span class="preprocessor"></span><span class="preprocessor">#else</span>
02006 <span class="preprocessor"></span><span class="preprocessor">    #define KiQuerySystemTime(CurrentTime)     \</span>
02007 <span class="preprocessor">        *(PULONGLONG)(CurrentTime) = SharedUserData-&gt;SystemTime</span>
02008 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
02009 <span class="preprocessor"></span>
02010 <span class="comment">//</span>
02011 <span class="comment">// Define query tick count macro.</span>
02012 <span class="comment">//</span>
02013 
02014 <span class="preprocessor">#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_)</span>
02015 <span class="preprocessor"></span>
02016 <span class="comment">//  begin_wdm begin_ntddk</span>
02017 
02018 <span class="preprocessor">#define KeQueryTickCount(CurrentCount ) \</span>
02019 <span class="preprocessor">    *(PULONGLONG)(CurrentCount) = **((volatile ULONGLONG **)(&amp;KeTickCount));</span>
02020 <span class="preprocessor"></span>
02021 <span class="comment">//  end_wdm end_ntddk</span>
02022 
02023 <span class="preprocessor">#else</span>
02024 <span class="preprocessor"></span>
02025 <span class="comment">// begin_nthal</span>
02026 <span class="preprocessor">#define KiQueryTickCount(CurrentCount) \</span>
02027 <span class="preprocessor">    *(PULONGLONG)(CurrentCount) = KeTickCount;</span>
02028 <span class="preprocessor"></span>
02029 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
02030 <a class="code" href="../../d7/d0/ke_2miscc_8c.html#a4">KeQueryTickCount</a> (
02031     OUT PLARGE_INTEGER CurrentCount
02032     );
02033 
02034 <span class="comment">// end_nthal</span>
02035 <span class="preprocessor">#endif</span>
02036 <span class="preprocessor"></span>
02037 <span class="preprocessor">#define KiQueryLowTickCount() (ULONG)KeTickCount</span>
02038 <span class="preprocessor"></span>
02039 <span class="preprocessor">#define KiQueryInterruptTime(CurrentTime) \</span>
02040 <span class="preprocessor">    *(PULONGLONG)(CurrentTime) = SharedUserData-&gt;InterruptTime</span>
02041 <span class="preprocessor"></span>
02042 <span class="comment">//</span>
02043 <span class="comment">// Define executive macros for acquiring and releasing executive spinlocks.</span>
02044 <span class="comment">// These macros can ONLY be used by executive components and NOT by drivers.</span>
02045 <span class="comment">// Drivers MUST use the kernel interfaces since they must be MP enabled on</span>
02046 <span class="comment">// all systems.</span>
02047 <span class="comment">//</span>
02048 <span class="comment">// KeRaiseIrql is one instruction shorter than KeAcquireSpinLock on Alpha UP.</span>
02049 <span class="comment">// KeLowerIrql is one instruction shorter than KeReleaseSpinLock.</span>
02050 <span class="comment">//</span>
02051 
02052 <span class="preprocessor">#if defined(NT_UP) &amp;&amp; !defined(_NTDDK_) &amp;&amp; !defined(_NTIFS_)</span>
02053 <span class="preprocessor"></span><span class="preprocessor">#define ExAcquireSpinLock(Lock, OldIrql) KeRaiseIrql(DISPATCH_LEVEL, (OldIrql))</span>
02054 <span class="preprocessor"></span><span class="preprocessor">#define ExReleaseSpinLock(Lock, OldIrql) KeLowerIrql((OldIrql))</span>
02055 <span class="preprocessor"></span><span class="preprocessor">#define ExAcquireSpinLockAtDpcLevel(Lock)</span>
02056 <span class="preprocessor"></span><span class="preprocessor">#define ExReleaseSpinLockFromDpcLevel(Lock)</span>
02057 <span class="preprocessor"></span><span class="preprocessor">#else</span>
02058 <span class="preprocessor"></span>
02059 <span class="comment">//  begin_wdm begin_ntddk</span>
02060 
02061 <span class="preprocessor">#define ExAcquireSpinLock(Lock, OldIrql) KeAcquireSpinLock((Lock), (OldIrql))</span>
02062 <span class="preprocessor"></span><span class="preprocessor">#define ExReleaseSpinLock(Lock, OldIrql) KeReleaseSpinLock((Lock), (OldIrql))</span>
02063 <span class="preprocessor"></span><span class="preprocessor">#define ExAcquireSpinLockAtDpcLevel(Lock) KeAcquireSpinLockAtDpcLevel(Lock)</span>
02064 <span class="preprocessor"></span><span class="preprocessor">#define ExReleaseSpinLockFromDpcLevel(Lock) KeReleaseSpinLockFromDpcLevel(Lock)</span>
02065 <span class="preprocessor"></span>
02066 <span class="comment">//  end_wdm end_ntddk</span>
02067 
02068 <span class="preprocessor">#endif</span>
02069 <span class="preprocessor"></span>
02070 <span class="comment">//</span>
02071 <span class="comment">// The acquire and release fast lock macros disable and enable interrupts</span>
02072 <span class="comment">// on UP nondebug systems. On MP or debug systems, the spinlock routines</span>
02073 <span class="comment">// are used.</span>
02074 <span class="comment">//</span>
02075 <span class="comment">// N.B. Extreme caution should be observed when using these routines.</span>
02076 <span class="comment">//</span>
02077 
02078 <span class="preprocessor">#if defined(_M_ALPHA)</span>
02079 <span class="preprocessor"></span>
02080 <span class="preprocessor">#define _disable() __di()</span>
02081 <span class="preprocessor"></span><span class="preprocessor">#define _enable() __ei()</span>
02082 <span class="preprocessor"></span>
02083 <span class="preprocessor">#endif</span>
02084 <span class="preprocessor"></span>
02085 <span class="preprocessor">#if defined(NT_UP) &amp;&amp; !DBG</span>
02086 <span class="preprocessor"></span><span class="preprocessor">#define ExAcquireFastLock(Lock, OldIrql) \</span>
02087 <span class="preprocessor">    ExAcquireSpinLock(Lock, OldIrql)</span>
02088 <span class="preprocessor"></span><span class="preprocessor">#else</span>
02089 <span class="preprocessor"></span><span class="preprocessor">#define ExAcquireFastLock(Lock, OldIrql) \</span>
02090 <span class="preprocessor">    ExAcquireSpinLock(Lock, OldIrql)</span>
02091 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
02092 <span class="preprocessor"></span>
02093 <span class="preprocessor">#if defined(NT_UP) &amp;&amp; !DBG</span>
02094 <span class="preprocessor"></span><span class="preprocessor">#define ExReleaseFastLock(Lock, OldIrql) \</span>
02095 <span class="preprocessor">    ExReleaseSpinLock(Lock, OldIrql)</span>
02096 <span class="preprocessor"></span><span class="preprocessor">#else</span>
02097 <span class="preprocessor"></span><span class="preprocessor">#define ExReleaseFastLock(Lock, OldIrql) \</span>
02098 <span class="preprocessor">    ExReleaseSpinLock(Lock, OldIrql)</span>
02099 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
02100 <span class="preprocessor"></span>
02101 
02102 <span class="comment">//</span>
02103 <span class="comment">// Alpha function definitions</span>
02104 <span class="comment">//</span>
02105 
02106 <span class="comment">//++</span>
02107 <span class="comment">//</span>
02108 <span class="comment">// BOOLEAN</span>
02109 <span class="comment">// KiIsThreadNumericStateSaved(</span>
02110 <span class="comment">//     IN PKTHREAD Address</span>
02111 <span class="comment">//     )</span>
02112 <span class="comment">//</span>
02113 <span class="comment">//  This call is used on a not running thread to see if it's numeric</span>
02114 <span class="comment">//  state has been saved in its context information.  On Alpha the</span>
02115 <span class="comment">//  numeric state is always saved.</span>
02116 <span class="comment">//</span>
02117 <span class="comment">//--</span>
02118 
02119 <span class="preprocessor">#define KiIsThreadNumericStateSaved(a) TRUE</span>
02120 <span class="preprocessor"></span>
02121 <span class="comment">//++</span>
02122 <span class="comment">//</span>
02123 <span class="comment">// VOID</span>
02124 <span class="comment">// KiRundownThread(</span>
02125 <span class="comment">//     IN PKTHREAD Address</span>
02126 <span class="comment">//     )</span>
02127 <span class="comment">//</span>
02128 <span class="comment">//--</span>
02129 
02130 <span class="preprocessor">#define KiRundownThread(a)</span>
02131 <span class="preprocessor"></span>
02132 <span class="comment">//</span>
02133 <span class="comment">// Alpha Feature bit definitions</span>
02134 <span class="comment">//</span>
02135 <span class="preprocessor">#define KF_BYTE         0x00000001</span>
02136 <span class="preprocessor"></span>
02137 <span class="comment">//</span>
02138 <span class="comment">// Define macro to test if x86 feature is present.</span>
02139 <span class="comment">//</span>
02140 <span class="comment">// N.B. All x86 features test TRUE on Alpha systems.</span>
02141 <span class="comment">//</span>
02142 
02143 <span class="preprocessor">#define Isx86FeaturePresent(_f_) TRUE</span>
02144 <span class="preprocessor"></span>
02145 <span class="comment">// begin_ntddk begin_wdm begin_nthal begin_ntndis</span>
02146 <span class="preprocessor">#ifdef __cplusplus</span>
02147 <span class="preprocessor"></span>}   <span class="comment">// extern "C"</span>
02148 <span class="preprocessor">#endif</span>
02149 <span class="preprocessor"></span><span class="preprocessor">#endif // _ALPHA_</span>
02150 <span class="preprocessor"></span><span class="comment">// end_ntddk end_wdm end_nthal end_ntndis</span>
02151 
02152 <span class="preprocessor">#endif // _ALPHAH_</span>
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:39:15 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
