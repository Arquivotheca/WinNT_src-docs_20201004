<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: kdcpuapi.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>kdcpuapi.c</h1><a href="../../d2/d5/i386_2kdcpuapi_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1990  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    kdcpuapi.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module implements CPU specific remote debug APIs.</span>
00012 <span class="comment"></span>
00013 <span class="comment">Author:</span>
00014 <span class="comment"></span>
00015 <span class="comment">    Mark Lucovsky (markl) 04-Sep-1990</span>
00016 <span class="comment"></span>
00017 <span class="comment">Revision History:</span>
00018 <span class="comment"></span>
00019 <span class="comment">    24-sep-90   bryanwi</span>
00020 <span class="comment"></span>
00021 <span class="comment">        Port to the x86.</span>
00022 <span class="comment"></span>
00023 <span class="comment">--*/</span>
00024 
00025 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00026 
00027 <span class="preprocessor">#include "<a class="code" href="../../d1/d7/4_2kdp_8h.html">kdp.h</a>"</span>
<a name="l00028"></a><a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a0">00028</a> <span class="preprocessor">#define END_OF_CONTROL_SPACE    (sizeof(KPROCESSOR_STATE))</span>
00029 <span class="preprocessor"></span>
<a name="l00030"></a><a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a1">00030</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a1">KdpCurrentSymbolStart</a>, <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a2">KdpCurrentSymbolEnd</a>;
<a name="l00031"></a><a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a3">00031</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a3">KdSpecialCalls</a>[];
<a name="l00032"></a><a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a4">00032</a> <span class="keyword">extern</span> ULONG <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a4">KdNumberOfSpecialCalls</a>;
00033 
00034 LONG
00035 <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a5">KdpLevelChange</a> (
00036     ULONG Pc,
00037     PCONTEXT ContextRecord,
00038     PBOOLEAN SpecialCall
00039     );
00040 
00041 LONG
00042 <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a6">regValue</a>(
00043     UCHAR reg,
00044     PCONTEXT ContextRecord
00045     );
00046 
00047 BOOLEAN
00048 <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a7">KdpIsSpecialCall</a> (
00049     ULONG Pc,
00050     PCONTEXT ContextRecord,
00051     UCHAR opcode,
00052     UCHAR ModRM
00053     );
00054 
00055 ULONG
00056 <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a8">KdpGetReturnAddress</a> (
00057     PCONTEXT ContextRecord
00058     );
00059 
00060 ULONG
00061 <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a9">KdpGetCallNextOffset</a> (
00062     ULONG Pc,
00063     PCONTEXT ContextRecord
00064     );
00065 
00066 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00067 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpLevelChange)</span>
00068 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, regValue)</span>
00069 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpIsSpecialCall)</span>
00070 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpGetReturnAddress)</span>
00071 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpSetLoadState)</span>
00072 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpSetStateChange)</span>
00073 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpGetStateChange)</span>
00074 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpReadControlSpace)</span>
00075 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpWriteControlSpace)</span>
00076 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpReadIoSpace)</span>
00077 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpWriteIoSpace)</span>
00078 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpReadMachineSpecificRegister)</span>
00079 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpWriteMachineSpecificRegister)</span>
00080 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGEKD, KdpGetCallNextOffset)</span>
00081 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00082 <span class="preprocessor"></span>
00083 <span class="comment">/**** KdpIsTryFinallyReturn - detect finally optimization</span>
00084 <span class="comment">*</span>
00085 <span class="comment">*  Input:</span>
00086 <span class="comment">*       pc - program counter of instruction to check</span>
00087 <span class="comment">*       ContextRecord - machine specific context</span>
00088 <span class="comment">*</span>
00089 <span class="comment">*  Output:</span>
00090 <span class="comment">*       returns TRUE if this is a try-finally returning to the same</span>
00091 <span class="comment">*       scope</span>
00092 <span class="comment">***************************************************************************/</span>
00093 
00094 
00095 BOOLEAN
<a name="l00096"></a><a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a10">00096</a> <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a10">KdpIsTryFinallyReturn</a> (
00097     ULONG Pc,
00098     PCONTEXT ContextRecord
00099     )
00100 {
00101     ULONG retaddr;
00102     ULONG calldisp;
00103     UCHAR inst;
00104 
00105     <span class="comment">//</span>
00106     <span class="comment">//  The complier generates code for a try-finally that involves having</span>
00107     <span class="comment">//  a ret instruction that does not match with a call instruction.</span>
00108     <span class="comment">//  This ret never returns a value (ie, it's a c3 return and not a</span>
00109     <span class="comment">//  c2).  It always returns into the current symbol scope.  It is never</span>
00110     <span class="comment">//  preceeded by a leave, which (hopefully) should differentiate it</span>
00111     <span class="comment">//  from recursive returns.  Check for this, and if we find it count</span>
00112     <span class="comment">//  it as *0* level change.</span>
00113     <span class="comment">//</span>
00114     <span class="comment">//  As an optimization, the compiler will often change:</span>
00115     <span class="comment">//      CALL</span>
00116     <span class="comment">//      RET</span>
00117     <span class="comment">//  into:</span>
00118     <span class="comment">//      JMP</span>
00119     <span class="comment">//  In either case, we figure out the return address.  It's the first 4 bytes</span>
00120     <span class="comment">//  on the stack.</span>
00121     <span class="comment">//</span>
00122 
00123     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>( (PCHAR)&amp;retaddr, (PCHAR)ContextRecord-&gt;Esp, 4 );
00124 
00125 <span class="comment">//  DPRINT(( "Start %x return %x end %x\n", KdpCurrentSymbolStart, retaddr, KdpCurrentSymbolEnd ));</span>
00126 
00127     <span class="keywordflow">if</span> ( (<a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a1">KdpCurrentSymbolStart</a> &lt; retaddr) &amp;&amp; (retaddr &lt; <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a2">KdpCurrentSymbolEnd</a>) ) {
00128 
00129         <span class="comment">//</span>
00130         <span class="comment">//  Well, things aren't this nice.  We may have transferred but not yet</span>
00131         <span class="comment">//  updated the start/end.  This case occurs in a call to a thunk.  We</span>
00132         <span class="comment">//  look to see if the instruction before the return address is a call.</span>
00133         <span class="comment">//  Gross and not 100% reliable.</span>
00134         <span class="comment">//</span>
00135 
00136         <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>( (PCHAR)&amp;inst, (PCHAR)retaddr - 5, 1 );
00137         <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>( (PCHAR)&amp;calldisp, (PCHAR)retaddr - 4, 4 );
00138 
00139         <span class="keywordflow">if</span> (inst == 0xe8 &amp;&amp; calldisp + retaddr == Pc) {
00140 <span class="comment">//  DPRINT(( "call to thunk @ %x\n", Pc ));</span>
00141             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00142         }
00143 
00144         <span class="comment">//</span>
00145         <span class="comment">//  returning to the current function.  Either a finally</span>
00146         <span class="comment">//  or a recursive return.  Check for a leave.  This is not 100%</span>
00147         <span class="comment">//  reliable since we are betting on an instruction longer than a byte</span>
00148         <span class="comment">//  and not ending with 0xc9.</span>
00149         <span class="comment">//</span>
00150 
00151         <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>( (PCHAR)&amp;inst, (PCHAR)Pc-1, 1 );
00152 
00153         <span class="keywordflow">if</span> ( inst != 0xc9 ) {
00154             <span class="comment">// not a leave.  Assume a try-finally.</span>
00155 <span class="comment">//  DPRINT(( "transfer at %x is try-finally\n", Pc ));</span>
00156             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00157         }
00158     }
00159 
00160     <span class="comment">//</span>
00161     <span class="comment">//  This appears to be a true RET instruction</span>
00162     <span class="comment">//</span>
00163 
00164     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00165 }
00166 
00167 <span class="comment">/**** KdpLevelChange - say how the instruction affects the call level</span>
00168 <span class="comment">*</span>
00169 <span class="comment">*  Input:</span>
00170 <span class="comment">*       pc - program counter of instruction to check</span>
00171 <span class="comment">*       ContextRecord - machine specific context</span>
00172 <span class="comment">*       SpecialCall - pointer to returned boolean indicating if the</span>
00173 <span class="comment">*           instruction is a transfer to a special routine</span>
00174 <span class="comment">*</span>
00175 <span class="comment">*  Output:</span>
00176 <span class="comment">*       returns -1 for a level pop, 1 for a push and 0 if it is</span>
00177 <span class="comment">*       unchanged.</span>
00178 <span class="comment">*  NOTE: This function belongs in some other file.  I should move it.</span>
00179 <span class="comment">***************************************************************************/</span>
00180 
00181 
00182 LONG
<a name="l00183"></a><a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a5">00183</a> <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a5">KdpLevelChange</a> (
00184     ULONG Pc,
00185     PCONTEXT ContextRecord,
00186     PBOOLEAN SpecialCall
00187     )
00188 {
00189     UCHAR membuf[2];
00190     ULONG Addr;
00191 
00192     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>( (PCHAR)membuf, (PCHAR)Pc, 2 );
00193 
00194     <span class="keywordflow">switch</span> (membuf[0]) {
00195     <span class="keywordflow">case</span> 0xe8:  <span class="comment">//  CALL direct w/32 bit displacement</span>
00196         <span class="comment">//</span>
00197         <span class="comment">//  For try/finally, the compiler may, in addition to the push/ret trick</span>
00198         <span class="comment">//  below, use a call to the finally thunk.  Since we treat a RET to</span>
00199         <span class="comment">//  within the same symbol scope as not changing levels, we will also</span>
00200         <span class="comment">//  treat such a call as not changing levels either</span>
00201         <span class="comment">//</span>
00202 
00203         <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>( (PCHAR)&amp;Addr, (PCHAR)Pc+1, 4 );
00204         Addr += Pc + 5;
00205 
00206         <span class="keywordflow">if</span> ((<a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a1">KdpCurrentSymbolStart</a> &lt;= Addr) &amp;&amp; (Addr &lt; <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a2">KdpCurrentSymbolEnd</a>)) {
00207             *SpecialCall = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00208             <span class="keywordflow">return</span> 0;
00209         }
00210 
00211 
00212     <span class="keywordflow">case</span> 0x9a:  <span class="comment">//  CALL segmented 16:32</span>
00213 
00214         *SpecialCall = <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a7">KdpIsSpecialCall</a>( Pc, ContextRecord, membuf[0], membuf[1] );
00215         <span class="keywordflow">return</span> 1;
00216 
00217     <span class="keywordflow">case</span> 0xff:
00218         <span class="comment">//</span>
00219         <span class="comment">//  This is a compound instruction.  Dispatch on operation</span>
00220         <span class="comment">//</span>
00221         <span class="keywordflow">switch</span> (membuf[1] &amp; 0x38) {
00222         <span class="keywordflow">case</span> 0x10:  <span class="comment">//  CALL with mod r/m</span>
00223             *SpecialCall = <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a7">KdpIsSpecialCall</a>( Pc, ContextRecord, membuf[0], membuf[1] );
00224             <span class="keywordflow">return</span> 1;
00225         <span class="keywordflow">case</span> 0x20:  <span class="comment">//  JMP with mod r/m</span>
00226             *SpecialCall = <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a7">KdpIsSpecialCall</a>( Pc, ContextRecord, membuf[0], membuf[1] );
00227 
00228             <span class="comment">//</span>
00229             <span class="comment">//  If this is a try/finally, we'd like to treat it as call since the</span>
00230             <span class="comment">//  return inside the destination will bring us back to this context.</span>
00231             <span class="comment">//  However, if it is a jmp to a special routine, we must treat it</span>
00232             <span class="comment">//  as a no-level change operation since we won't see the special</span>
00233             <span class="comment">//  routines's return.</span>
00234             <span class="comment">//</span>
00235             <span class="comment">//  If it is not a try/finally, we'd like to treat it as a no-level</span>
00236             <span class="comment">//  change, unless again, it is a transfer to a special call which</span>
00237             <span class="comment">//  views this as a level up.</span>
00238             <span class="comment">//</span>
00239 
00240             <span class="keywordflow">if</span> (<a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a10">KdpIsTryFinallyReturn</a>( Pc, ContextRecord )) {
00241                 <span class="keywordflow">if</span> (*SpecialCall) {
00242                     <span class="comment">//</span>
00243                     <span class="comment">//  We won't see the return, so pretend it is just</span>
00244                     <span class="comment">//  inline code</span>
00245                     <span class="comment">//</span>
00246 
00247                     <span class="keywordflow">return</span> 0;
00248 
00249                 } <span class="keywordflow">else</span> {
00250                     <span class="comment">//</span>
00251                     <span class="comment">//  The destinations return will bring us back to this</span>
00252                     <span class="comment">//  context</span>
00253                     <span class="comment">//</span>
00254 
00255                     <span class="keywordflow">return</span> 1;
00256                 }
00257             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*SpecialCall) {
00258                 <span class="comment">//</span>
00259                 <span class="comment">//  We won't see the return but we are, indeed, doing one.</span>
00260                 <span class="comment">//</span>
00261                 <span class="keywordflow">return</span> -1;
00262             } <span class="keywordflow">else</span> {
00263                 <span class="keywordflow">return</span> 0;
00264             }
00265 
00266         <span class="keywordflow">default</span>:
00267             *SpecialCall = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00268             <span class="keywordflow">return</span> 0;
00269         }
00270 
00271     <span class="keywordflow">case</span> 0xc3:  <span class="comment">//  RET</span>
00272 
00273         <span class="comment">//</span>
00274         <span class="comment">//  If we are a try/finally ret, then we indicate that it is NOT a level</span>
00275         <span class="comment">//  change</span>
00276         <span class="comment">//</span>
00277 
00278         <span class="keywordflow">if</span> (<a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a10">KdpIsTryFinallyReturn</a>( Pc, ContextRecord )) {
00279             *SpecialCall = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00280             <span class="keywordflow">return</span> 0;
00281         }
00282 
00283     <span class="keywordflow">case</span> 0xc2:  <span class="comment">//  RET  w/16 bit esp change</span>
00284     <span class="keywordflow">case</span> 0xca:  <span class="comment">//  RETF w/16 bit esp change</span>
00285     <span class="keywordflow">case</span> 0xcb:  <span class="comment">//  RETF</span>
00286         *SpecialCall = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00287         <span class="keywordflow">return</span> -1;
00288 
00289     <span class="keywordflow">default</span>:
00290         *SpecialCall = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00291         <span class="keywordflow">return</span> 0;
00292     }
00293 
00294 } <span class="comment">// KdpLevelChange</span>
00295 
00296 LONG
<a name="l00297"></a><a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a6">00297</a> <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a6">regValue</a>(
00298     UCHAR reg,
00299     PCONTEXT ContextRecord
00300     )
00301 {
00302     <span class="keywordflow">switch</span> (reg) {
00303     <span class="keywordflow">case</span> 0x0:
00304         <span class="keywordflow">return</span>(ContextRecord-&gt;Eax);
00305         <span class="keywordflow">break</span>;
00306     <span class="keywordflow">case</span> 0x1:
00307         <span class="keywordflow">return</span>(ContextRecord-&gt;Ecx);
00308         <span class="keywordflow">break</span>;
00309     <span class="keywordflow">case</span> 0x2:
00310         <span class="keywordflow">return</span>(ContextRecord-&gt;Edx);
00311         <span class="keywordflow">break</span>;
00312     <span class="keywordflow">case</span> 0x3:
00313         <span class="keywordflow">return</span>(ContextRecord-&gt;Ebx);
00314         <span class="keywordflow">break</span>;
00315     <span class="keywordflow">case</span> 0x4:
00316         <span class="keywordflow">return</span>(ContextRecord-&gt;Esp);
00317         <span class="keywordflow">break</span>;
00318     <span class="keywordflow">case</span> 0x5:
00319         <span class="keywordflow">return</span>(ContextRecord-&gt;Ebp);
00320         <span class="keywordflow">break</span>;
00321     <span class="keywordflow">case</span> 0x6:
00322         <span class="keywordflow">return</span>(ContextRecord-&gt;Esi);
00323         <span class="keywordflow">break</span>;
00324     <span class="keywordflow">case</span> 0x7:
00325         <span class="keywordflow">return</span>(ContextRecord-&gt;Edi);
00326         <span class="keywordflow">break</span>;
00327     }
00328     <span class="keywordflow">return</span> 0; <span class="comment">// Bash compiler warning</span>
00329 }
00330 
00331 BOOLEAN
<a name="l00332"></a><a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a7">00332</a> <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a7">KdpIsSpecialCall</a> (
00333     ULONG Pc,
00334     PCONTEXT ContextRecord,
00335     UCHAR opcode,
00336     UCHAR modRM
00337     )
00338 
00339 <span class="comment">/*++</span>
00340 <span class="comment"></span>
00341 <span class="comment">Routine Description:</span>
00342 <span class="comment"></span>
00343 <span class="comment">    Check to see if the instruction at pc is a call to one of the</span>
00344 <span class="comment">    SpecialCall routines.</span>
00345 <span class="comment"></span>
00346 <span class="comment">Argument:</span>
00347 <span class="comment"></span>
00348 <span class="comment">    Pc - program counter of instruction in question.</span>
00349 <span class="comment"></span>
00350 <span class="comment">--*/</span>
00351 {
00352     UCHAR sib;
00353     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> twoBytes;
00354     ULONG callAddr;
00355     ULONG addrAddr;
00356     LONG offset;
00357     ULONG i;
00358     <span class="keywordtype">char</span> d8;
00359 
00360     <span class="keywordflow">if</span> ( opcode == 0xe8 ) {
00361 
00362         <span class="comment">//</span>
00363         <span class="comment">// Signed offset from pc</span>
00364         <span class="comment">//</span>
00365 
00366         <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>( (PCHAR)&amp;offset, (PCHAR)Pc+1, 4 );
00367 
00368         callAddr = Pc + offset + 5; <span class="comment">// +5 for instr len.</span>
00369 
00370     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( opcode == 0xff ) {
00371 
00372         <span class="keywordflow">if</span> ( ((modRM &amp; 0x38) != 0x10) &amp;&amp; ((modRM &amp; 0x38) != 0x20) ) {
00373             <span class="comment">// not call or jump</span>
00374             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00375         }
00376         <span class="keywordflow">if</span> ( (modRM &amp; 0x08) == 0x08 ) {
00377             <span class="comment">// m16:16 or m16:32 -- we don't handle this</span>
00378             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00379         }
00380 
00381         <span class="keywordflow">if</span> ( (modRM &amp; 0xc0) == 0xc0 ) {
00382 
00383             <span class="comment">/* Direct register addressing */</span>
00384             callAddr = <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a6">regValue</a>( (UCHAR)(modRM&amp;0x7), ContextRecord );
00385 
00386         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( (modRM &amp; 0xc7) == 0x05 ) {
00387             <span class="comment">//</span>
00388             <span class="comment">// Calls across dll boundaries involve a call into a jump table,</span>
00389             <span class="comment">// wherein the jump address is set to the real called routine at DLL</span>
00390             <span class="comment">// load time.  Check to see if we're calling such an instruction,</span>
00391             <span class="comment">// and if so, compute its target address and set callAddr there.</span>
00392             <span class="comment">//</span>
00393             <span class="comment">//  ff15 or ff25 -- call or jump indirect with disp32.  Get</span>
00394             <span class="comment">//  address of address</span>
00395             <span class="comment">//</span>
00396             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>( (PCHAR)&amp;addrAddr, (PCHAR)Pc+2, 4 );
00397 
00398             <span class="comment">//</span>
00399             <span class="comment">//  Get real destination address</span>
00400             <span class="comment">//</span>
00401             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>( (PCHAR)&amp;callAddr, (PCHAR)addrAddr, 4 );
00402 <span class="comment">//  DPRINT(( "Indirect call/jmp @ %x\n", Pc ));</span>
00403         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( (modRM &amp; 0x7) == 0x4 ) {
00404 
00405             LONG indexValue;
00406 
00407             <span class="comment">/* sib byte present */</span>
00408             <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>( (PCHAR)&amp;sib, (PCHAR)Pc+2, 1 );
00409             indexValue = <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a6">regValue</a>( (UCHAR)((sib &amp; 0x31) &gt;&gt; 3), ContextRecord );
00410             <span class="keywordflow">switch</span> ( sib&amp;0xc0 ) {
00411             <span class="keywordflow">case</span> 0x0:  <span class="comment">/* x1 */</span>
00412                 <span class="keywordflow">break</span>;
00413             <span class="keywordflow">case</span> 0x40:
00414                 indexValue *= 2;
00415                 <span class="keywordflow">break</span>;
00416             <span class="keywordflow">case</span> 0x80:
00417                 indexValue *= 4;
00418                 <span class="keywordflow">break</span>;
00419             <span class="keywordflow">case</span> 0xc0:
00420                 indexValue *= 8;
00421                 <span class="keywordflow">break</span>;
00422             } <span class="comment">/* switch */</span>
00423 
00424             <span class="keywordflow">switch</span> ( modRM &amp; 0xc0 ) {
00425 
00426             <span class="keywordflow">case</span> 0x0: <span class="comment">/* no displacement */</span>
00427                 <span class="keywordflow">if</span> ( (sib &amp; 0x7) == 0x5 ) {
00428 <span class="comment">//                  DPRINT(("funny call #1 at %x\n", Pc));</span>
00429                     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00430                 }
00431                 callAddr = indexValue + <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a6">regValue</a>((UCHAR)(sib&amp;0x7), ContextRecord );
00432                 <span class="keywordflow">break</span>;
00433 
00434             <span class="keywordflow">case</span> 0x40:
00435                 <span class="keywordflow">if</span> ( (sib &amp; 0x6) == 0x4 ) {
00436 <span class="comment">//                  DPRINT(("Funny call #2\n")); /* calling into the stack */</span>
00437                     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00438                 }
00439                 <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>( &amp;d8, (PCHAR)Pc+3,1 );
00440                 callAddr = indexValue + d8 +
00441                                     <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a6">regValue</a>((UCHAR)(sib&amp;0x7), ContextRecord );
00442                 <span class="keywordflow">break</span>;
00443 
00444             <span class="keywordflow">case</span> 0x80:
00445                 <span class="keywordflow">if</span> ( (sib &amp; 0x6) == 0x4 ) {
00446 <span class="comment">//                  DPRINT(("Funny call #3\n")); /* calling into the stack */</span>
00447                     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00448                 }
00449                 <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>( (PCHAR)&amp;offset, (PCHAR)Pc+3, 4 );
00450                 callAddr = indexValue + offset +
00451                                     <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a6">regValue</a>((UCHAR)(sib&amp;0x7), ContextRecord );
00452                 <span class="keywordflow">break</span>;
00453 
00454             <span class="keywordflow">case</span> 0xc0:
00455                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00456                 <span class="keywordflow">break</span>;
00457 
00458             }
00459 
00460         } <span class="keywordflow">else</span> {
00461             <span class="comment">//KdPrint(( "undecoded call at %x\n",</span>
00462             <span class="comment">//            CONTEXT_TO_PROGRAM_COUNTER(ContextRecord) ));</span>
00463             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00464         }
00465 
00466     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( opcode == 0x9a ) {
00467 
00468         <span class="comment">/* Absolute address call (best I can tell, cc doesn't generate this) */</span>
00469         <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>( (PCHAR)&amp;callAddr, (PCHAR)Pc+1, 4 );
00470 
00471     } <span class="keywordflow">else</span> {
00472         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00473     }
00474 
00475     <span class="comment">//</span>
00476     <span class="comment">// Calls across dll boundaries involve a call into a jump table,</span>
00477     <span class="comment">// wherein the jump address is set to the real called routine at DLL</span>
00478     <span class="comment">// load time.  Check to see if we're calling such an instruction,</span>
00479     <span class="comment">// and if so, compute its target address and set callAddr there.</span>
00480     <span class="comment">//</span>
00481 
00482 <span class="preprocessor">#if 0</span>
00483 <span class="preprocessor"></span>    <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>( (PCHAR)&amp;twoBytes, (PCHAR)callAddr, 2 );
00484     <span class="keywordflow">if</span> ( twoBytes == 0x25ff ) { <span class="comment">/* i386 is little-Endian; really 0xff25 */</span>
00485 
00486         <span class="comment">//</span>
00487         <span class="comment">// This is a 'jmp dword ptr [mem]' instruction, which is the sort of</span>
00488         <span class="comment">// jump used for a dll-boundary crossing call.  Fixup callAddr.</span>
00489         <span class="comment">//</span>
00490 
00491         <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>( (PCHAR)&amp;addrAddr, (PCHAR)callAddr+2, 4 );
00492         <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>( (PCHAR)&amp;callAddr, (PCHAR)addrAddr, 4 );
00493     }
00494 <span class="preprocessor">#endif</span>
00495 <span class="preprocessor"></span>
00496     <span class="keywordflow">for</span> ( i = 0; i &lt; <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a4">KdNumberOfSpecialCalls</a>; i++ ) {
00497         <span class="keywordflow">if</span> ( <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a3">KdSpecialCalls</a>[i] == callAddr ) {
00498             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00499         }
00500     }
00501     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00502 
00503 }
00504 
00505 <span class="comment">/*</span>
00506 <span class="comment"> * Find the return address of the current function.  Only works when</span>
00507 <span class="comment"> * locals haven't yet been pushed (ie, on the first instruction of the</span>
00508 <span class="comment"> * function).</span>
00509 <span class="comment"> */</span>
00510 
00511 ULONG
<a name="l00512"></a><a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a8">00512</a> <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a8">KdpGetReturnAddress</a> (
00513     PCONTEXT ContextRecord
00514     )
00515 {
00516     ULONG retaddr;
00517 
00518     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>((PCHAR)(&amp;retaddr), (PCHAR)(ContextRecord-&gt;Esp), 4 );
00519     <span class="keywordflow">return</span> retaddr;
00520 
00521 } <span class="comment">// KdpGetReturnAddress</span>
00522 
00523 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00524"></a><a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a11">00524</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a113">KdpSetLoadState</a>(
00525     IN PDBGKD_WAIT_STATE_CHANGE WaitStateChange,
00526     IN PCONTEXT ContextRecord
00527     )
00528 
00529 <span class="comment">/*++</span>
00530 <span class="comment"></span>
00531 <span class="comment">Routine Description:</span>
00532 <span class="comment"></span>
00533 <span class="comment">    Fill in the Wait_State_Change message record for the load symbol case.</span>
00534 <span class="comment"></span>
00535 <span class="comment">Arguments:</span>
00536 <span class="comment"></span>
00537 <span class="comment">    WaitStateChange - Supplies pointer to record to fill in</span>
00538 <span class="comment"></span>
00539 <span class="comment">    ContextRecord - Supplies a pointer to a context record.</span>
00540 <span class="comment"></span>
00541 <span class="comment">Return Value:</span>
00542 <span class="comment"></span>
00543 <span class="comment">    None.</span>
00544 <span class="comment"></span>
00545 <span class="comment">--*/</span>
00546 
00547 {
00548 
00549     ULONG <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>;
00550     PVOID <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a>;
00551     PKPRCB Prcb;
00552 
00553     <span class="comment">//</span>
00554     <span class="comment">// Store the special x86 register into the control report structure.</span>
00555     <span class="comment">//</span>
00556 
00557     Prcb = <a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a2">KeGetCurrentPrcb</a>();
00558     WaitStateChange-&gt;ControlReport.Dr6 = Prcb-&gt;ProcessorState.SpecialRegisters.KernelDr6;
00559     WaitStateChange-&gt;ControlReport.Dr7 = Prcb-&gt;ProcessorState.SpecialRegisters.KernelDr7;
00560 
00561     <span class="comment">//</span>
00562     <span class="comment">// Copy the immediate instruction stream into the control report structure.</span>
00563     <span class="comment">//</span>
00564 
00565     <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> = <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>((PCHAR)(&amp;(WaitStateChange-&gt;ControlReport.InstructionStream[0])),
00566                           (PCHAR)(WaitStateChange-&gt;ProgramCounter),
00567                           DBGKD_MAXSTREAM);
00568 
00569     WaitStateChange-&gt;ControlReport.InstructionCount = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>;
00570 
00571     <span class="comment">//</span>
00572     <span class="comment">// Clear breakpoints in the copied instruction stream. If any breakpoints</span>
00573     <span class="comment">// are cleared, then recopy the instruction stream.</span>
00574     <span class="comment">//</span>
00575 
00576     <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a> = (PVOID)((PUCHAR)(WaitStateChange-&gt;ProgramCounter) + <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> - 1);
00577     <span class="keywordflow">if</span> (<a class="code" href="../../d1/d7/4_2kdp_8h.html#a106">KdpDeleteBreakpointRange</a>(WaitStateChange-&gt;ProgramCounter, <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a>) != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00578         <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>(&amp;(WaitStateChange-&gt;ControlReport.InstructionStream[0]),
00579                       WaitStateChange-&gt;ProgramCounter,
00580                       <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>);
00581     }
00582 
00583     <span class="comment">//</span>
00584     <span class="comment">// Store the segment registers into the control report structure and set the</span>
00585     <span class="comment">// control flags.</span>
00586     <span class="comment">//</span>
00587 
00588     WaitStateChange-&gt;ControlReport.SegCs = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(ContextRecord-&gt;SegCs);
00589     WaitStateChange-&gt;ControlReport.SegDs = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(ContextRecord-&gt;SegDs);
00590     WaitStateChange-&gt;ControlReport.SegEs = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(ContextRecord-&gt;SegEs);
00591     WaitStateChange-&gt;ControlReport.SegFs = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(ContextRecord-&gt;SegFs);
00592     WaitStateChange-&gt;ControlReport.EFlags = ContextRecord-&gt;EFlags;
00593     WaitStateChange-&gt;ControlReport.ReportFlags = REPORT_INCLUDES_SEGS;
00594 
00595     <span class="comment">//</span>
00596     <span class="comment">//  Copy context record into wait state change structure.</span>
00597     <span class="comment">//</span>
00598 
00599     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>((PCHAR)(&amp;WaitStateChange-&gt;Context),
00600                   (PCHAR)ContextRecord,
00601                   <span class="keyword">sizeof</span>(CONTEXT));
00602 
00603     <span class="keywordflow">return</span>;
00604 }
00605 
00606 
00607 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00608"></a><a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a12">00608</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a114">KdpSetStateChange</a>(
00609     IN PDBGKD_WAIT_STATE_CHANGE WaitStateChange,
00610     IN PEXCEPTION_RECORD ExceptionRecord,
00611     IN PCONTEXT ContextRecord,
00612     IN BOOLEAN SecondChance
00613     )
00614 
00615 <span class="comment">/*++</span>
00616 <span class="comment"></span>
00617 <span class="comment">Routine Description:</span>
00618 <span class="comment"></span>
00619 <span class="comment">    Fill in the Wait_State_Change message record.</span>
00620 <span class="comment"></span>
00621 <span class="comment">Arguments:</span>
00622 <span class="comment"></span>
00623 <span class="comment">    WaitStateChange - Supplies pointer to record to fill in</span>
00624 <span class="comment"></span>
00625 <span class="comment">    ExceptionRecord - Supplies a pointer to an exception record.</span>
00626 <span class="comment"></span>
00627 <span class="comment">    ContextRecord - Supplies a pointer to a context record.</span>
00628 <span class="comment"></span>
00629 <span class="comment">    SecondChance - Supplies a boolean value that determines whether this is</span>
00630 <span class="comment">        the first or second chance for the exception.</span>
00631 <span class="comment"></span>
00632 <span class="comment">Return Value:</span>
00633 <span class="comment"></span>
00634 <span class="comment">    None.</span>
00635 <span class="comment"></span>
00636 <span class="comment">--*/</span>
00637 
00638 {
00639     PKPRCB Prcb;
00640     BOOLEAN status;
00641 
00642     <span class="comment">//</span>
00643     <span class="comment">//  Set up description of event, including exception record</span>
00644     <span class="comment">//</span>
00645 
00646     WaitStateChange-&gt;NewState = DbgKdExceptionStateChange;
00647     WaitStateChange-&gt;ProcessorLevel = <a class="code" href="../../d4/d9/ke_8h.html#a135">KeProcessorLevel</a>;
00648     WaitStateChange-&gt;Processor = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a2">KeGetCurrentPrcb</a>()-&gt;Number;
00649     WaitStateChange-&gt;NumberProcessors = (ULONG)<a class="code" href="../../d4/d9/ke_8h.html#a133">KeNumberProcessors</a>;
00650     WaitStateChange-&gt;Thread = (PVOID)<a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a3">KeGetCurrentThread</a>();
00651     WaitStateChange-&gt;ProgramCounter = (PVOID)CONTEXT_TO_PROGRAM_COUNTER(ContextRecord);
00652     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a111">KdpQuickMoveMemory</a>(
00653         (PCHAR)&amp;WaitStateChange-&gt;u.Exception.ExceptionRecord,
00654         (PCHAR)ExceptionRecord,
00655         <span class="keyword">sizeof</span>(EXCEPTION_RECORD)
00656         );
00657     WaitStateChange-&gt;u.Exception.FirstChance = !SecondChance;
00658 
00659     <span class="comment">//</span>
00660     <span class="comment">//  Copy instruction stream immediately following location of event</span>
00661     <span class="comment">//</span>
00662 
00663     WaitStateChange-&gt;ControlReport.InstructionCount =
00664         (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>(
00665             (PCHAR)(&amp;(WaitStateChange-&gt;ControlReport.InstructionStream[0])),
00666             (PCHAR)(WaitStateChange-&gt;ProgramCounter),
00667             DBGKD_MAXSTREAM
00668             );
00669 
00670     <span class="comment">//</span>
00671     <span class="comment">//  Copy context record immediately following instruction stream</span>
00672     <span class="comment">//</span>
00673 
00674     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>(
00675         (PCHAR)(&amp;WaitStateChange-&gt;Context),
00676         (PCHAR)ContextRecord,
00677         <span class="keyword">sizeof</span>(*ContextRecord)
00678         );
00679 
00680     <span class="comment">//</span>
00681     <span class="comment">//  Clear breakpoints in copied area</span>
00682     <span class="comment">//</span>
00683 
00684     status = <a class="code" href="../../d1/d7/4_2kdp_8h.html#a106">KdpDeleteBreakpointRange</a>(
00685         WaitStateChange-&gt;ProgramCounter,
00686         (PVOID)((PUCHAR)WaitStateChange-&gt;ProgramCounter +
00687             WaitStateChange-&gt;ControlReport.InstructionCount - 1)
00688         );
00689 
00690     <span class="comment">//</span>
00691     <span class="comment">//  If there were any breakpoints cleared, recopy the area without them</span>
00692     <span class="comment">//</span>
00693 
00694     <span class="keywordflow">if</span> (status == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00695         <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>(
00696             &amp;(WaitStateChange-&gt;ControlReport.InstructionStream[0]),
00697             WaitStateChange-&gt;ProgramCounter,
00698             WaitStateChange-&gt;ControlReport.InstructionCount
00699             );
00700     }
00701 
00702 
00703     <span class="comment">//</span>
00704     <span class="comment">//  Special registers for the x86</span>
00705     <span class="comment">//</span>
00706     Prcb = <a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a2">KeGetCurrentPrcb</a>();
00707 
00708     WaitStateChange-&gt;ControlReport.Dr6 =
00709         Prcb-&gt;ProcessorState.SpecialRegisters.KernelDr6;
00710 
00711     WaitStateChange-&gt;ControlReport.Dr7 =
00712         Prcb-&gt;ProcessorState.SpecialRegisters.KernelDr7;
00713 
00714     WaitStateChange-&gt;ControlReport.SegCs  = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(ContextRecord-&gt;SegCs);
00715     WaitStateChange-&gt;ControlReport.SegDs  = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(ContextRecord-&gt;SegDs);
00716     WaitStateChange-&gt;ControlReport.SegEs  = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(ContextRecord-&gt;SegEs);
00717     WaitStateChange-&gt;ControlReport.SegFs  = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(ContextRecord-&gt;SegFs);
00718     WaitStateChange-&gt;ControlReport.EFlags = ContextRecord-&gt;EFlags;
00719 
00720     WaitStateChange-&gt;ControlReport.ReportFlags = REPORT_INCLUDES_SEGS;
00721 
00722 }
00723 
00724 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00725"></a><a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a13">00725</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a115">KdpGetStateChange</a>(
00726     IN PDBGKD_MANIPULATE_STATE ManipulateState,
00727     IN PCONTEXT ContextRecord
00728     )
00729 
00730 <span class="comment">/*++</span>
00731 <span class="comment"></span>
00732 <span class="comment">Routine Description:</span>
00733 <span class="comment"></span>
00734 <span class="comment">    Extract continuation control data from Manipulate_State message</span>
00735 <span class="comment"></span>
00736 <span class="comment">Arguments:</span>
00737 <span class="comment"></span>
00738 <span class="comment">    ManipulateState - supplies pointer to Manipulate_State packet</span>
00739 <span class="comment"></span>
00740 <span class="comment">    ContextRecord - Supplies a pointer to a context record.</span>
00741 <span class="comment"></span>
00742 <span class="comment">Return Value:</span>
00743 <span class="comment"></span>
00744 <span class="comment">    None.</span>
00745 <span class="comment"></span>
00746 <span class="comment">--*/</span>
00747 
00748 {
00749     PKPRCB Prcb;
00750     ULONG  Processor;
00751 
00752     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(ManipulateState-&gt;u.Continue2.ContinueStatus) == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00753 
00754         <span class="comment">//</span>
00755         <span class="comment">// If NT_SUCCESS returns TRUE, then the debugger is doing a</span>
00756         <span class="comment">// continue, and it makes sense to apply control changes.</span>
00757         <span class="comment">// Otherwise the debugger is saying that it doesn't know what</span>
00758         <span class="comment">// to do with this exception, so control values are ignored.</span>
00759         <span class="comment">//</span>
00760 
00761         <span class="keywordflow">if</span> (ManipulateState-&gt;u.Continue2.ControlSet.TraceFlag == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00762             ContextRecord-&gt;EFlags |= 0x100<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>;
00763 
00764         } <span class="keywordflow">else</span> {
00765             ContextRecord-&gt;EFlags &amp;= ~0x100<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>;
00766 
00767         }
00768 
00769         <span class="keywordflow">for</span> (Processor = 0; Processor &lt; (ULONG)<a class="code" href="../../d4/d9/ke_8h.html#a133">KeNumberProcessors</a>; Processor++) {
00770             Prcb = <a class="code" href="../../d4/d9/ke_8h.html#a139">KiProcessorBlock</a>[Processor];
00771 
00772             Prcb-&gt;ProcessorState.SpecialRegisters.KernelDr7 =
00773                 ManipulateState-&gt;u.Continue2.ControlSet.Dr7;
00774 
00775             Prcb-&gt;ProcessorState.SpecialRegisters.KernelDr6 = 0<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>;
00776         }
00777         <span class="keywordflow">if</span> (ManipulateState-&gt;u.Continue2.ControlSet.CurrentSymbolStart != 1) {
00778             <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a1">KdpCurrentSymbolStart</a> = ManipulateState-&gt;u.Continue2.ControlSet.CurrentSymbolStart;
00779             <a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a2">KdpCurrentSymbolEnd</a> = ManipulateState-&gt;u.Continue2.ControlSet.CurrentSymbolEnd;
00780         }
00781     }
00782 }
00783 
00784 
00785 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00786"></a><a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a14">00786</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a132">KdpReadControlSpace</a>(
00787     IN PDBGKD_MANIPULATE_STATE m,
00788     IN PSTRING AdditionalData,
00789     IN PCONTEXT Context
00790     )
00791 
00792 <span class="comment">/*++</span>
00793 <span class="comment"></span>
00794 <span class="comment">Routine Description:</span>
00795 <span class="comment"></span>
00796 <span class="comment">    This function is called in response of a read control space state</span>
00797 <span class="comment">    manipulation message.  Its function is to read implementation</span>
00798 <span class="comment">    specific system data.</span>
00799 <span class="comment"></span>
00800 <span class="comment">    IMPLEMENTATION NOTE:</span>
00801 <span class="comment"></span>
00802 <span class="comment">        On the X86, control space is defined as follows:</span>
00803 <span class="comment"></span>
00804 <span class="comment">            0:  Base of KPROCESSOR_STATE structure. (KPRCB.ProcessorState)</span>
00805 <span class="comment">                    This includes CONTEXT record,</span>
00806 <span class="comment">                    followed by a SPECIAL_REGISTERs record</span>
00807 <span class="comment"></span>
00808 <span class="comment">Arguments:</span>
00809 <span class="comment"></span>
00810 <span class="comment">    m - Supplies the state manipulation message.</span>
00811 <span class="comment"></span>
00812 <span class="comment">    AdditionalData - Supplies any additional data for the message.</span>
00813 <span class="comment"></span>
00814 <span class="comment">    Context - Supplies the current context.</span>
00815 <span class="comment"></span>
00816 <span class="comment">Return Value:</span>
00817 <span class="comment"></span>
00818 <span class="comment">    None.</span>
00819 <span class="comment"></span>
00820 <span class="comment">--*/</span>
00821 
00822 {
00823     PDBGKD_READ_MEMORY a = &amp;m-&gt;u.ReadMemory;
00824     STRING MessageHeader;
00825     ULONG Length, <a class="code" href="../../d4/d1/genmips_8c.html#a17">t</a>;
00826     PVOID StartAddr;
00827 
00828     MessageHeader.Length = <span class="keyword">sizeof</span>(*m);
00829     MessageHeader.Buffer = (PCHAR)m;
00830 
00831     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(AdditionalData-&gt;Length == 0);
00832 
00833     <span class="keywordflow">if</span> (a-&gt;TransferCount &gt; (PACKET_MAX_SIZE - <span class="keyword">sizeof</span>(DBGKD_MANIPULATE_STATE))) {
00834         Length = PACKET_MAX_SIZE - <span class="keyword">sizeof</span>(DBGKD_MANIPULATE_STATE);
00835     } <span class="keywordflow">else</span> {
00836         Length = a-&gt;TransferCount;
00837     }
00838     <span class="keywordflow">if</span> ((a-&gt;TargetBaseAddress &lt; (PVOID)<a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a0">END_OF_CONTROL_SPACE</a>) &amp;&amp;
00839         (m-&gt;Processor &lt; (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d4/d9/ke_8h.html#a133">KeNumberProcessors</a>)) {
00840         <a class="code" href="../../d4/d1/genmips_8c.html#a17">t</a> = (ULONG)<a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a0">END_OF_CONTROL_SPACE</a> - (ULONG)(a-&gt;TargetBaseAddress);
00841         <span class="keywordflow">if</span> (<a class="code" href="../../d4/d1/genmips_8c.html#a17">t</a> &lt; Length) {
00842             Length = <a class="code" href="../../d4/d1/genmips_8c.html#a17">t</a>;
00843         }
00844         StartAddr = (PVOID)((ULONG)a-&gt;TargetBaseAddress +
00845                             (ULONG)&amp;(<a class="code" href="../../d4/d9/ke_8h.html#a139">KiProcessorBlock</a>[m-&gt;Processor]-&gt;ProcessorState));
00846         AdditionalData-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>(
00847                                     AdditionalData-&gt;Buffer,
00848                                     StartAddr,
00849                                     Length
00850                                     );
00851 
00852         <span class="keywordflow">if</span> (Length == AdditionalData-&gt;Length) {
00853             m-&gt;ReturnStatus = STATUS_SUCCESS;
00854         } <span class="keywordflow">else</span> {
00855             m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
00856         }
00857         a-&gt;ActualBytesRead = AdditionalData-&gt;Length;
00858 
00859     } <span class="keywordflow">else</span> {
00860         AdditionalData-&gt;Length = 0;
00861         m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
00862         a-&gt;ActualBytesRead = 0;
00863     }
00864 
00865     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(
00866         PACKET_TYPE_KD_STATE_MANIPULATE,
00867         &amp;MessageHeader,
00868         AdditionalData
00869         );
00870     UNREFERENCED_PARAMETER(Context);
00871 }
00872 
00873 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00874"></a><a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a15">00874</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a133">KdpWriteControlSpace</a>(
00875     IN PDBGKD_MANIPULATE_STATE m,
00876     IN PSTRING AdditionalData,
00877     IN PCONTEXT Context
00878     )
00879 
00880 <span class="comment">/*++</span>
00881 <span class="comment"></span>
00882 <span class="comment">Routine Description:</span>
00883 <span class="comment"></span>
00884 <span class="comment">    This function is called in response of a write control space state</span>
00885 <span class="comment">    manipulation message.  Its function is to write implementation</span>
00886 <span class="comment">    specific system data.</span>
00887 <span class="comment"></span>
00888 <span class="comment">    Control space for x86 is as defined above.</span>
00889 <span class="comment"></span>
00890 <span class="comment">Arguments:</span>
00891 <span class="comment"></span>
00892 <span class="comment">    m - Supplies the state manipulation message.</span>
00893 <span class="comment"></span>
00894 <span class="comment">    AdditionalData - Supplies any additional data for the message.</span>
00895 <span class="comment"></span>
00896 <span class="comment">    Context - Supplies the current context.</span>
00897 <span class="comment"></span>
00898 <span class="comment">Return Value:</span>
00899 <span class="comment"></span>
00900 <span class="comment">    None.</span>
00901 <span class="comment"></span>
00902 <span class="comment">--*/</span>
00903 
00904 {
00905     PDBGKD_WRITE_MEMORY a = &amp;m-&gt;u.WriteMemory;
00906     ULONG Length;
00907     STRING MessageHeader;
00908     PVOID StartAddr;
00909 
00910     MessageHeader.Length = <span class="keyword">sizeof</span>(*m);
00911     MessageHeader.Buffer = (PCHAR)m;
00912 
00913     <span class="keywordflow">if</span> ((((PUCHAR)a-&gt;TargetBaseAddress + a-&gt;TransferCount) &lt;=
00914         (PUCHAR)<a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a0">END_OF_CONTROL_SPACE</a>) &amp;&amp; (m-&gt;Processor &lt; (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d4/d9/ke_8h.html#a133">KeNumberProcessors</a>)) {
00915 
00916         StartAddr = (PVOID)((ULONG)a-&gt;TargetBaseAddress +
00917                             (ULONG)&amp;(<a class="code" href="../../d4/d9/ke_8h.html#a139">KiProcessorBlock</a>[m-&gt;Processor]-&gt;ProcessorState));
00918 
00919         Length = <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>(
00920                             StartAddr,
00921                             AdditionalData-&gt;Buffer,
00922                             AdditionalData-&gt;Length
00923                             );
00924 
00925         <span class="keywordflow">if</span> (Length == AdditionalData-&gt;Length) {
00926             m-&gt;ReturnStatus = STATUS_SUCCESS;
00927         } <span class="keywordflow">else</span> {
00928             m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
00929         }
00930         a-&gt;ActualBytesWritten = Length;
00931 
00932     } <span class="keywordflow">else</span> {
00933         AdditionalData-&gt;Length = 0;
00934         m-&gt;ReturnStatus = STATUS_UNSUCCESSFUL;
00935         a-&gt;ActualBytesWritten = 0;
00936     }
00937 
00938     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(
00939         PACKET_TYPE_KD_STATE_MANIPULATE,
00940         &amp;MessageHeader,
00941         AdditionalData
00942         );
00943     UNREFERENCED_PARAMETER(Context);
00944 }
00945 
00946 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00947"></a><a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a16">00947</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a134">KdpReadIoSpace</a>(
00948     IN PDBGKD_MANIPULATE_STATE m,
00949     IN PSTRING AdditionalData,
00950     IN PCONTEXT Context
00951     )
00952 
00953 <span class="comment">/*++</span>
00954 <span class="comment"></span>
00955 <span class="comment">Routine Description:</span>
00956 <span class="comment"></span>
00957 <span class="comment">    This function is called in response of a read io space state</span>
00958 <span class="comment">    manipulation message.  Its function is to read system io</span>
00959 <span class="comment">    locations.</span>
00960 <span class="comment"></span>
00961 <span class="comment">Arguments:</span>
00962 <span class="comment"></span>
00963 <span class="comment">    m - Supplies the state manipulation message.</span>
00964 <span class="comment"></span>
00965 <span class="comment">    AdditionalData - Supplies any additional data for the message.</span>
00966 <span class="comment"></span>
00967 <span class="comment">    Context - Supplies the current context.</span>
00968 <span class="comment"></span>
00969 <span class="comment">Return Value:</span>
00970 <span class="comment"></span>
00971 <span class="comment">    None.</span>
00972 <span class="comment"></span>
00973 <span class="comment">--*/</span>
00974 
00975 {
00976     PDBGKD_READ_WRITE_IO a = &amp;m-&gt;u.ReadWriteIo;
00977     STRING MessageHeader;
00978 
00979     MessageHeader.Length = <span class="keyword">sizeof</span>(*m);
00980     MessageHeader.Buffer = (PCHAR)m;
00981 
00982     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(AdditionalData-&gt;Length == 0);
00983 
00984     m-&gt;ReturnStatus = STATUS_SUCCESS;
00985 
00986     <span class="comment">//</span>
00987     <span class="comment">// Check Size and Alignment</span>
00988     <span class="comment">//</span>
00989 
00990     <span class="keywordflow">switch</span> ( a-&gt;DataSize ) {
00991         <span class="keywordflow">case</span> 1:
00992             a-&gt;DataValue = (ULONG)READ_PORT_UCHAR(a-&gt;IoAddress);
00993             <span class="keywordflow">break</span>;
00994         <span class="keywordflow">case</span> 2:
00995             <span class="keywordflow">if</span> ((ULONG)a-&gt;IoAddress &amp; 1 ) {
00996                 m-&gt;ReturnStatus = STATUS_DATATYPE_MISALIGNMENT;
00997             } <span class="keywordflow">else</span> {
00998                 a-&gt;DataValue = (ULONG)READ_PORT_USHORT(a-&gt;IoAddress);
00999             }
01000             <span class="keywordflow">break</span>;
01001         <span class="keywordflow">case</span> 4:
01002             <span class="keywordflow">if</span> ((ULONG)a-&gt;IoAddress &amp; 3 ) {
01003                 m-&gt;ReturnStatus = STATUS_DATATYPE_MISALIGNMENT;
01004             } <span class="keywordflow">else</span> {
01005                 a-&gt;DataValue = READ_PORT_ULONG(a-&gt;IoAddress);
01006             }
01007             <span class="keywordflow">break</span>;
01008         <span class="keywordflow">default</span>:
01009             m-&gt;ReturnStatus = STATUS_INVALID_PARAMETER;
01010     }
01011 
01012     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(
01013         PACKET_TYPE_KD_STATE_MANIPULATE,
01014         &amp;MessageHeader,
01015         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
01016         );
01017     UNREFERENCED_PARAMETER(Context);
01018 }
01019 
01020 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01021"></a><a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a17">01021</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a136">KdpWriteIoSpace</a>(
01022     IN PDBGKD_MANIPULATE_STATE m,
01023     IN PSTRING AdditionalData,
01024     IN PCONTEXT Context
01025     )
01026 
01027 <span class="comment">/*++</span>
01028 <span class="comment"></span>
01029 <span class="comment">Routine Description:</span>
01030 <span class="comment"></span>
01031 <span class="comment">    This function is called in response of a write io space state</span>
01032 <span class="comment">    manipulation message.  Its function is to write to system io</span>
01033 <span class="comment">    locations.</span>
01034 <span class="comment"></span>
01035 <span class="comment">Arguments:</span>
01036 <span class="comment"></span>
01037 <span class="comment">    m - Supplies the state manipulation message.</span>
01038 <span class="comment"></span>
01039 <span class="comment">    AdditionalData - Supplies any additional data for the message.</span>
01040 <span class="comment"></span>
01041 <span class="comment">    Context - Supplies the current context.</span>
01042 <span class="comment"></span>
01043 <span class="comment">Return Value:</span>
01044 <span class="comment"></span>
01045 <span class="comment">    None.</span>
01046 <span class="comment"></span>
01047 <span class="comment">--*/</span>
01048 
01049 {
01050     PDBGKD_READ_WRITE_IO a = &amp;m-&gt;u.ReadWriteIo;
01051     STRING MessageHeader;
01052 
01053     MessageHeader.Length = <span class="keyword">sizeof</span>(*m);
01054     MessageHeader.Buffer = (PCHAR)m;
01055 
01056     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(AdditionalData-&gt;Length == 0);
01057 
01058     m-&gt;ReturnStatus = STATUS_SUCCESS;
01059 
01060     <span class="comment">//</span>
01061     <span class="comment">// Check Size and Alignment</span>
01062     <span class="comment">//</span>
01063 
01064     <span class="keywordflow">switch</span> ( a-&gt;DataSize ) {
01065         <span class="keywordflow">case</span> 1:
01066             WRITE_PORT_UCHAR(a-&gt;IoAddress, (UCHAR)a-&gt;DataValue);
01067             <span class="keywordflow">break</span>;
01068         <span class="keywordflow">case</span> 2:
01069             <span class="keywordflow">if</span> ((ULONG)a-&gt;IoAddress &amp; 1 ) {
01070                 m-&gt;ReturnStatus = STATUS_DATATYPE_MISALIGNMENT;
01071             } <span class="keywordflow">else</span> {
01072                 WRITE_PORT_USHORT(a-&gt;IoAddress, (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)a-&gt;DataValue);
01073             }
01074             <span class="keywordflow">break</span>;
01075         <span class="keywordflow">case</span> 4:
01076             <span class="keywordflow">if</span> ((ULONG)a-&gt;IoAddress &amp; 3 ) {
01077                 m-&gt;ReturnStatus = STATUS_DATATYPE_MISALIGNMENT;
01078             } <span class="keywordflow">else</span> {
01079                 WRITE_PORT_ULONG(a-&gt;IoAddress, a-&gt;DataValue);
01080             }
01081             <span class="keywordflow">break</span>;
01082         <span class="keywordflow">default</span>:
01083             m-&gt;ReturnStatus = STATUS_INVALID_PARAMETER;
01084     }
01085 
01086     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(
01087         PACKET_TYPE_KD_STATE_MANIPULATE,
01088         &amp;MessageHeader,
01089         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
01090         );
01091     UNREFERENCED_PARAMETER(Context);
01092 }
01093 
01094 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01095"></a><a class="code" href="../../d0/d7/kdp_8h.html#a122">01095</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a135">KdpReadMachineSpecificRegister</a>(
01096     IN PDBGKD_MANIPULATE_STATE m,
01097     IN PSTRING AdditionalData,
01098     IN PCONTEXT Context
01099     )
01100 
01101 <span class="comment">/*++</span>
01102 <span class="comment"></span>
01103 <span class="comment">Routine Description:</span>
01104 <span class="comment"></span>
01105 <span class="comment">    This function is called in response of a read MSR</span>
01106 <span class="comment">    manipulation message.  Its function is to read the MSR.</span>
01107 <span class="comment"></span>
01108 <span class="comment">Arguments:</span>
01109 <span class="comment"></span>
01110 <span class="comment">    m - Supplies the state manipulation message.</span>
01111 <span class="comment"></span>
01112 <span class="comment">    AdditionalData - Supplies any additional data for the message.</span>
01113 <span class="comment"></span>
01114 <span class="comment">    Context - Supplies the current context.</span>
01115 <span class="comment"></span>
01116 <span class="comment">Return Value:</span>
01117 <span class="comment"></span>
01118 <span class="comment">    None.</span>
01119 <span class="comment"></span>
01120 <span class="comment">--*/</span>
01121 
01122 {
01123     PDBGKD_READ_WRITE_MSR a = &amp;m-&gt;u.ReadWriteMsr;
01124     STRING MessageHeader;
01125     LARGE_INTEGER l;
01126 
01127     MessageHeader.Length = <span class="keyword">sizeof</span>(*m);
01128     MessageHeader.Buffer = (PCHAR)m;
01129 
01130     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(AdditionalData-&gt;Length == 0);
01131 
01132     m-&gt;ReturnStatus = STATUS_SUCCESS;
01133 
01134     <span class="keywordflow">try</span> {
01135         l.QuadPart = <a class="code" href="../../d5/d3/i386_8h.html#a52">RDMSR</a>(a-&gt;Msr);
01136     } except (<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
01137         l.QuadPart = 0;
01138         m-&gt;ReturnStatus = STATUS_NO_SUCH_DEVICE;
01139     }
01140 
01141     a-&gt;DataValueLow  = l.LowPart;
01142     a-&gt;DataValueHigh = l.HighPart;
01143 
01144     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(
01145         PACKET_TYPE_KD_STATE_MANIPULATE,
01146         &amp;MessageHeader,
01147         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
01148         );
01149     UNREFERENCED_PARAMETER(Context);
01150 }
01151 
01152 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01153"></a><a class="code" href="../../d0/d7/kdp_8h.html#a124">01153</a> <a class="code" href="../../d1/d7/4_2kdp_8h.html#a137">KdpWriteMachineSpecificRegister</a>(
01154     IN PDBGKD_MANIPULATE_STATE m,
01155     IN PSTRING AdditionalData,
01156     IN PCONTEXT Context
01157     )
01158 
01159 <span class="comment">/*++</span>
01160 <span class="comment"></span>
01161 <span class="comment">Routine Description:</span>
01162 <span class="comment"></span>
01163 <span class="comment">    This function is called in response of a write of a MSR</span>
01164 <span class="comment">    manipulation message.  Its function is to write to the MSR</span>
01165 <span class="comment"></span>
01166 <span class="comment">Arguments:</span>
01167 <span class="comment"></span>
01168 <span class="comment">    m - Supplies the state manipulation message.</span>
01169 <span class="comment"></span>
01170 <span class="comment">    AdditionalData - Supplies any additional data for the message.</span>
01171 <span class="comment"></span>
01172 <span class="comment">    Context - Supplies the current context.</span>
01173 <span class="comment"></span>
01174 <span class="comment">Return Value:</span>
01175 <span class="comment"></span>
01176 <span class="comment">    None.</span>
01177 <span class="comment"></span>
01178 <span class="comment">--*/</span>
01179 
01180 {
01181     PDBGKD_READ_WRITE_MSR a = &amp;m-&gt;u.ReadWriteMsr;
01182     STRING MessageHeader;
01183     LARGE_INTEGER l;
01184 
01185     MessageHeader.Length = <span class="keyword">sizeof</span>(*m);
01186     MessageHeader.Buffer = (PCHAR)m;
01187 
01188     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(AdditionalData-&gt;Length == 0);
01189 
01190     m-&gt;ReturnStatus = STATUS_SUCCESS;
01191 
01192     l.HighPart = a-&gt;DataValueHigh;
01193     l.LowPart = a-&gt;DataValueLow;
01194 
01195     <span class="keywordflow">try</span> {
01196         <a class="code" href="../../d5/d3/i386_8h.html#a53">WRMSR</a> (a-&gt;Msr, l.QuadPart);
01197     } except (<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
01198         m-&gt;ReturnStatus = STATUS_NO_SUCH_DEVICE;
01199     }
01200 
01201     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a116">KdpSendPacket</a>(
01202         PACKET_TYPE_KD_STATE_MANIPULATE,
01203         &amp;MessageHeader,
01204         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
01205         );
01206     UNREFERENCED_PARAMETER(Context);
01207 }
01208 
01209 <span class="comment">/*** KdpGetCallNextOffset - compute "next" instruction on a call-like instruction</span>
01210 <span class="comment">*</span>
01211 <span class="comment">*   Purpose:</span>
01212 <span class="comment">*       Compute how many bytes are in a call-type instruction</span>
01213 <span class="comment">*       so that a breakpoint can be set upon this instruction's</span>
01214 <span class="comment">*       return.  Treat indirect jmps as if they were call/ret/ret</span>
01215 <span class="comment">*</span>
01216 <span class="comment">*   Returns:</span>
01217 <span class="comment">*       offset to "next" instruction, or 0 if it wasn't a call instruction.</span>
01218 <span class="comment">*</span>
01219 <span class="comment">*************************************************************************/</span>
01220 
01221 ULONG
<a name="l01222"></a><a class="code" href="../../d2/d5/i386_2kdcpuapi_8c.html#a9">01222</a> <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a9">KdpGetCallNextOffset</a> (
01223     ULONG Pc,
01224     PCONTEXT ContextRecord
01225     )
01226 {
01227     UCHAR membuf[2];
01228     UCHAR opcode;
01229     ULONG sib;
01230     ULONG disp;
01231 
01232     <a class="code" href="../../d1/d7/4_2kdp_8h.html#a110">KdpMoveMemory</a>( membuf, (PVOID)Pc, 2 );
01233     opcode = membuf[0];
01234 
01235     <span class="keywordflow">if</span> ( opcode == 0xe8 ) {         <span class="comment">//  CALL 32 bit disp</span>
01236         <span class="keywordflow">return</span> Pc+5;
01237     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( opcode == 0x9a ) {  <span class="comment">//  CALL 16:32</span>
01238         <span class="keywordflow">return</span> Pc+7;
01239     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( opcode == 0xff ) {
01240         <span class="keywordflow">if</span> ( membuf[1] == 0x25) {   <span class="comment">//  JMP indirect</span>
01241             <span class="keywordflow">return</span> <a class="code" href="../../d6/d5/4_2i386_2kdcpuapi_8c.html#a8">KdpGetReturnAddress</a>( ContextRecord );
01242         }
01243         sib = ((membuf[1] &amp; 0x07) == 0x04) ? 1 : 0;
01244         disp = (membuf[1] &amp; 0xc0) &gt;&gt; 6;
01245         <span class="keywordflow">switch</span> (disp) {
01246         <span class="keywordflow">case</span> 0:
01247             <span class="keywordflow">if</span> ( (membuf[1] &amp; 0x07) == 0x05 ) {
01248                 disp = 4; <span class="comment">// disp32 alone</span>
01249             } <span class="keywordflow">else</span> {
01250                 <span class="comment">// disp = 0; // no displacement with reg or sib</span>
01251             }
01252             <span class="keywordflow">break</span>;
01253         <span class="keywordflow">case</span> 1:
01254             <span class="comment">// disp = 1; // disp8 with reg or sib</span>
01255             <span class="keywordflow">break</span>;
01256         <span class="keywordflow">case</span> 2:
01257             disp = 4; <span class="comment">// disp32 with reg or sib</span>
01258             <span class="keywordflow">break</span>;
01259         <span class="keywordflow">case</span> 3:
01260             disp = 0; <span class="comment">// direct register addressing (e.g., call esi)</span>
01261             <span class="keywordflow">break</span>;
01262         }
01263         <span class="keywordflow">return</span> Pc + 2 + sib + disp;
01264     }
01265 
01266     <span class="keywordflow">return</span> 0;
01267 
01268 } <span class="comment">// KdpGetCallNextOffset</span>
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:34 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
