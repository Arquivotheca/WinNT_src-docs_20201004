<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: capture.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>capture.c</h1><a href="../../d2/d5/se_2capture_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1989  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    Capture.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This Module implements the security data structure capturing routines.</span>
00012 <span class="comment">    There are corresponding Release routines for the data structures that</span>
00013 <span class="comment">    are captured into allocated pool.</span>
00014 <span class="comment"></span>
00015 <span class="comment">Author:</span>
00016 <span class="comment"></span>
00017 <span class="comment">    Gary Kimura     (GaryKi)    9-Nov-1989</span>
00018 <span class="comment">    Jim Kelly       (JimK)      1-Feb-1990</span>
00019 <span class="comment"></span>
00020 <span class="comment">Environment:</span>
00021 <span class="comment"></span>
00022 <span class="comment">    Kernel Mode</span>
00023 <span class="comment"></span>
00024 <span class="comment">Revision History:</span>
00025 <span class="comment"></span>
00026 <span class="comment">--*/</span>
00027 
00028 <span class="preprocessor">#include "<a class="code" href="../../d6/d6/sep_8h.html">sep.h</a>"</span>
00029 <span class="preprocessor">#include &lt;sertlp.h&gt;</span>
00030 
00031 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00032 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,SeCaptureSecurityDescriptor)</span>
00033 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,SeReleaseSecurityDescriptor)</span>
00034 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,SeCaptureSecurityQos)</span>
00035 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,SeCaptureSid)</span>
00036 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,SeReleaseSid)</span>
00037 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,SeCaptureAcl)</span>
00038 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,SeReleaseAcl)</span>
00039 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,SeCaptureLuidAndAttributesArray)</span>
00040 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,SeReleaseLuidAndAttributesArray)</span>
00041 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,SeCaptureSidAndAttributesArray)</span>
00042 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,SeReleaseSidAndAttributesArray)</span>
00043 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,SeComputeQuotaInformationSize)</span>
00044 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,SepCopyProxyData)</span>
00045 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,SepProbeAndCaptureQosData)</span>
00046 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,SepFreeProxyData)</span>
00047 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00048 <span class="preprocessor"></span>
<a name="l00049"></a><a class="code" href="../../d2/d5/se_2capture_8c.html#a0">00049</a> <span class="preprocessor">#define LongAligned( ptr )  (LongAlignPtr(ptr) == (ptr))</span>
00050 <span class="preprocessor"></span>
00051 
00052 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00053"></a><a class="code" href="../../d2/d5/se_2capture_8c.html#a1">00053</a> <a class="code" href="../../d2/d5/se_2capture_8c.html#a1">SeCaptureSecurityDescriptor</a> (
00054     IN PSECURITY_DESCRIPTOR InputSecurityDescriptor,
00055     IN KPROCESSOR_MODE RequestorMode,
00056     IN POOL_TYPE PoolType,
00057     IN BOOLEAN ForceCapture,
00058     OUT PSECURITY_DESCRIPTOR *OutputSecurityDescriptor
00059     )
00060 
00061 <span class="comment">/*++</span>
00062 <span class="comment"></span>
00063 <span class="comment">Routine Description:</span>
00064 <span class="comment"></span>
00065 <span class="comment">    This routine probes and captures a copy of the security descriptor based</span>
00066 <span class="comment">    upon the following tests.</span>
00067 <span class="comment"></span>
00068 <span class="comment">    if the requestor mode is not kernel mode then</span>
00069 <span class="comment"></span>
00070 <span class="comment">        probe and capture the input descriptor</span>
00071 <span class="comment">        (the captured descriptor is self-relative)</span>
00072 <span class="comment"></span>
00073 <span class="comment">    if the requstor mode is kernel mode then</span>
00074 <span class="comment"></span>
00075 <span class="comment">        if force capture is true then</span>
00076 <span class="comment"></span>
00077 <span class="comment">            do not probe the input descriptor, but do capture it.</span>
00078 <span class="comment">            (the captured descriptor is self-relative)</span>
00079 <span class="comment"></span>
00080 <span class="comment">        else</span>
00081 <span class="comment"></span>
00082 <span class="comment">            do nothing</span>
00083 <span class="comment">            (the input descriptor is expected to be self-relative)</span>
00084 <span class="comment"></span>
00085 <span class="comment">Arguments:</span>
00086 <span class="comment"></span>
00087 <span class="comment">    InputSecurityDescriptor - Supplies the security descriptor to capture.</span>
00088 <span class="comment">    This parameter is assumed to have been provided by the mode specified</span>
00089 <span class="comment">    in RequestorMode.</span>
00090 <span class="comment"></span>
00091 <span class="comment">    RequestorMode - Specifies the caller's access mode.</span>
00092 <span class="comment"></span>
00093 <span class="comment">    PoolType - Specifies which pool type to allocate the captured</span>
00094 <span class="comment">        descriptor from</span>
00095 <span class="comment"></span>
00096 <span class="comment">    ForceCapture - Specifies whether the input descriptor should always be</span>
00097 <span class="comment">        captured</span>
00098 <span class="comment"></span>
00099 <span class="comment">    OutputSecurityDescriptor - Supplies the address of a pointer to the</span>
00100 <span class="comment">        output security descriptor.  The captured descriptor will be</span>
00101 <span class="comment">        self-relative format.</span>
00102 <span class="comment"></span>
00103 <span class="comment">Return Value:</span>
00104 <span class="comment"></span>
00105 <span class="comment">    STATUS_SUCCESS if the operation is successful.</span>
00106 <span class="comment"></span>
00107 <span class="comment">    STATUS_INVALID_SID - An SID within the security descriptor is not</span>
00108 <span class="comment">        a valid SID.</span>
00109 <span class="comment"></span>
00110 <span class="comment">    STATUS_INVALID_ACL - An ACL within the security descriptor is not</span>
00111 <span class="comment">        a valid ACL.</span>
00112 <span class="comment"></span>
00113 <span class="comment">    STATUS_UNKNOWN_REVISION - The revision level of the security descriptor</span>
00114 <span class="comment">        is not one known to this revision of the capture routine.</span>
00115 <span class="comment">--*/</span>
00116 
00117 {
00118     SECURITY_DESCRIPTOR Captured;
00119     SECURITY_DESCRIPTOR_RELATIVE *PIOutputSecurityDescriptor;
00120     PCHAR DescriptorOffset;
00121 
00122     ULONG SaclSize;
00123     ULONG NewSaclSize;
00124 
00125     ULONG DaclSize;
00126     ULONG NewDaclSize;
00127 
00128     ULONG OwnerSubAuthorityCount;
00129     ULONG OwnerSize;
00130     ULONG NewOwnerSize;
00131 
00132     ULONG GroupSubAuthorityCount;
00133     ULONG GroupSize;
00134     ULONG NewGroupSize;
00135 
00136     ULONG <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
00137 
00138     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00139 
00140     <span class="comment">//</span>
00141     <span class="comment">//  if the security descriptor is null then there is really nothing to</span>
00142     <span class="comment">//  capture</span>
00143     <span class="comment">//</span>
00144 
00145     <span class="keywordflow">if</span> (InputSecurityDescriptor == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00146 
00147         (*OutputSecurityDescriptor) = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00148 
00149         <span class="keywordflow">return</span> STATUS_SUCCESS;
00150 
00151     }
00152 
00153     <span class="comment">//</span>
00154     <span class="comment">//  check if the requestors mode is kernel mode and we are not</span>
00155     <span class="comment">//  to force a capture</span>
00156     <span class="comment">//</span>
00157 
00158     <span class="keywordflow">if</span> ((RequestorMode == <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) &amp;&amp; (ForceCapture == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
00159 
00160         <span class="comment">//</span>
00161         <span class="comment">//  Yes it is so we don't need to do any work and can simply</span>
00162         <span class="comment">//  return a pointer to the input descriptor</span>
00163         <span class="comment">//</span>
00164 
00165         (*OutputSecurityDescriptor) = InputSecurityDescriptor;
00166 
00167         <span class="keywordflow">return</span> STATUS_SUCCESS;
00168 
00169     }
00170 
00171 
00172     <span class="comment">//</span>
00173     <span class="comment">//  We need to probe and capture the descriptor.</span>
00174     <span class="comment">//  To do this we need to probe the main security descriptor record</span>
00175     <span class="comment">//  first.</span>
00176     <span class="comment">//</span>
00177 
00178     <span class="keywordflow">if</span> (RequestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
00179 
00180         <span class="comment">//</span>
00181         <span class="comment">// Capture of UserMode SecurityDescriptor.</span>
00182         <span class="comment">//</span>
00183 
00184         <span class="keywordflow">try</span> {
00185 
00186             <span class="comment">//</span>
00187             <span class="comment">// Probe the main record of the input SecurityDescriptor</span>
00188             <span class="comment">//</span>
00189 
00190             <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( InputSecurityDescriptor,
00191                           <span class="keyword">sizeof</span>(SECURITY_DESCRIPTOR_RELATIVE),
00192                           <span class="keyword">sizeof</span>(ULONG) );
00193 
00194             <span class="comment">//</span>
00195             <span class="comment">//  Capture the SecurityDescriptor main record.</span>
00196             <span class="comment">//</span>
00197 
00198             RtlCopyMemory( (&amp;Captured),
00199                           InputSecurityDescriptor,
00200                           <span class="keyword">sizeof</span>(SECURITY_DESCRIPTOR_RELATIVE) );
00201 
00202             <span class="comment">//</span>
00203             <span class="comment">// Verify the alignment is correct for absolute case. This is</span>
00204             <span class="comment">// only needed when pointer are 64 bits.</span>
00205             <span class="comment">//</span>
00206 
00207             <span class="keywordflow">if</span> (!(Captured.Control &amp; SE_SELF_RELATIVE)) {
00208 
00209                <span class="keywordflow">if</span> ((ULONG_PTR) InputSecurityDescriptor &amp; (<span class="keyword">sizeof</span>(ULONG_PTR) - 1)) {
00210                    <a class="code" href="../../d5/d8/ex_8h.html#a304">ExRaiseDatatypeMisalignment</a>();
00211                }
00212             }
00213 
00214 
00215         } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00216             <span class="keywordflow">return</span> GetExceptionCode();
00217         }
00218 
00219     } <span class="keywordflow">else</span> {
00220 
00221         <span class="comment">//</span>
00222         <span class="comment">//  Force capture of kernel mode SecurityDescriptor.</span>
00223         <span class="comment">//</span>
00224         <span class="comment">//  Capture the SecurityDescriptor main record.</span>
00225         <span class="comment">//  It doesn't need probing because requestor mode is kernel.</span>
00226         <span class="comment">//</span>
00227 
00228         RtlCopyMemory( (&amp;Captured),
00229                       InputSecurityDescriptor,
00230                       <span class="keyword">sizeof</span>(SECURITY_DESCRIPTOR_RELATIVE) );
00231 
00232     }
00233 
00234     <span class="comment">//</span>
00235     <span class="comment">// Make sure it is a revision we recognize</span>
00236     <span class="comment">//</span>
00237 
00238     <span class="keywordflow">if</span> (Captured.Revision != SECURITY_DESCRIPTOR_REVISION) {
00239        <span class="keywordflow">return</span> STATUS_UNKNOWN_REVISION;
00240     }
00241 
00242 
00243     <span class="comment">//</span>
00244     <span class="comment">// In case the input security descriptor is self-relative, change the</span>
00245     <span class="comment">// captured main record to appear as an absolute form so we can use</span>
00246     <span class="comment">// common code for both cases below.</span>
00247     <span class="comment">//</span>
00248     <span class="comment">// Note that the fields of Captured are left pointing to user</span>
00249     <span class="comment">// space addresses.  Treat them carefully.</span>
00250     <span class="comment">//</span>
00251 
00252     <span class="keywordflow">try</span> {
00253 
00254         Captured.Owner = RtlpOwnerAddrSecurityDescriptor(
00255             (SECURITY_DESCRIPTOR *)InputSecurityDescriptor
00256             );
00257         Captured.Group = RtlpGroupAddrSecurityDescriptor(
00258             (SECURITY_DESCRIPTOR *)InputSecurityDescriptor
00259             );
00260         Captured.Sacl  = RtlpSaclAddrSecurityDescriptor (
00261             (SECURITY_DESCRIPTOR *)InputSecurityDescriptor
00262             );
00263         Captured.Dacl  = RtlpDaclAddrSecurityDescriptor (
00264             (SECURITY_DESCRIPTOR *)InputSecurityDescriptor
00265             );
00266         Captured.Control &amp;= ~SE_SELF_RELATIVE;
00267 
00268     } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00269         <span class="keywordflow">return</span> GetExceptionCode();
00270     }
00271 
00272 
00273 
00274     <span class="comment">//</span>
00275     <span class="comment">//  Indicate the size we are going to need to allocate for the captured</span>
00276     <span class="comment">//  acls</span>
00277     <span class="comment">//</span>
00278 
00279     SaclSize = 0;
00280     DaclSize = 0;
00281 
00282     NewSaclSize = 0;
00283     NewDaclSize = 0;
00284     NewGroupSize = 0;
00285     NewOwnerSize = 0;
00286 
00287     <span class="comment">//</span>
00288     <span class="comment">//  Probe (if necessary) and capture each of the components of a</span>
00289     <span class="comment">//  SECURITY_DESCRIPTOR.</span>
00290     <span class="comment">//</span>
00291 
00292     <span class="comment">//</span>
00293     <span class="comment">//  System ACL first</span>
00294     <span class="comment">//</span>
00295 
00296     <span class="keywordflow">if</span> ((Captured.Control &amp; SE_SACL_PRESENT) &amp;&amp;
00297         (Captured.Sacl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) ) {
00298 
00299         <span class="keywordflow">if</span> (RequestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
00300 
00301             <span class="keywordflow">try</span> {
00302                 SaclSize = <a class="code" href="../../d5/d8/ex_8h.html#a16">ProbeAndReadUshort</a>( &amp;(Captured.Sacl-&gt;AclSize) );
00303                 <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( Captured.Sacl,
00304                               SaclSize,
00305                               <span class="keyword">sizeof</span>(ULONG) );
00306             } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00307                 <span class="keywordflow">return</span> GetExceptionCode();
00308             }
00309 
00310         } <span class="keywordflow">else</span> {
00311 
00312             SaclSize = Captured.Sacl-&gt;AclSize;
00313 
00314         }
00315 
00316         NewSaclSize = (ULONG)LongAlignSize( SaclSize );
00317 
00318     } <span class="keywordflow">else</span> {
00319         <span class="comment">//</span>
00320         <span class="comment">// Force the SACL to null if the bit is off</span>
00321         <span class="comment">//</span>
00322         Captured.Sacl = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00323     }
00324 
00325     <span class="comment">//</span>
00326     <span class="comment">//  Discretionary ACL</span>
00327     <span class="comment">//</span>
00328 
00329     <span class="keywordflow">if</span> ((Captured.Control &amp; SE_DACL_PRESENT) &amp;&amp;
00330         (Captured.Dacl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) ) {
00331 
00332         <span class="keywordflow">if</span> (RequestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
00333 
00334             <span class="keywordflow">try</span> {
00335                 DaclSize = <a class="code" href="../../d5/d8/ex_8h.html#a16">ProbeAndReadUshort</a>( &amp;(Captured.Dacl-&gt;AclSize) );
00336                 <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( Captured.Dacl,
00337                               DaclSize,
00338                               <span class="keyword">sizeof</span>(ULONG) );
00339             } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00340                 <span class="keywordflow">return</span> GetExceptionCode();
00341             }
00342 
00343         } <span class="keywordflow">else</span> {
00344 
00345             DaclSize = Captured.Dacl-&gt;AclSize;
00346 
00347         }
00348 
00349         NewDaclSize = (ULONG)LongAlignSize( DaclSize );
00350 
00351     } <span class="keywordflow">else</span> {
00352         <span class="comment">//</span>
00353         <span class="comment">// Force the DACL to null if it is not present</span>
00354         <span class="comment">//</span>
00355         Captured.Dacl = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00356     }
00357 
00358     <span class="comment">//</span>
00359     <span class="comment">//  Owner SID</span>
00360     <span class="comment">//</span>
00361 
00362     <span class="keywordflow">if</span> (Captured.Owner != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)  {
00363 
00364         <span class="keywordflow">if</span> (RequestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
00365 
00366             <span class="keywordflow">try</span> {
00367                 OwnerSubAuthorityCount =
00368                     <a class="code" href="../../d5/d8/ex_8h.html#a14">ProbeAndReadUchar</a>( &amp;(((SID *)(Captured.Owner))-&gt;SubAuthorityCount) );
00369                 OwnerSize = <a class="code" href="../../d8/d6/sertl_8c.html#a38">RtlLengthRequiredSid</a>( OwnerSubAuthorityCount );
00370                 <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( Captured.Owner,
00371                               OwnerSize,
00372                               <span class="keyword">sizeof</span>(ULONG) );
00373             } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00374                 <span class="keywordflow">return</span> GetExceptionCode();
00375             }
00376 
00377         } <span class="keywordflow">else</span> {
00378 
00379             OwnerSubAuthorityCount = ((SID *)(Captured.Owner))-&gt;SubAuthorityCount;
00380             OwnerSize = <a class="code" href="../../d8/d6/sertl_8c.html#a38">RtlLengthRequiredSid</a>( OwnerSubAuthorityCount );
00381 
00382         }
00383 
00384         NewOwnerSize = (ULONG)LongAlignSize( OwnerSize );
00385 
00386     }
00387 
00388     <span class="comment">//</span>
00389     <span class="comment">//  Group SID</span>
00390     <span class="comment">//</span>
00391 
00392     <span class="keywordflow">if</span> (Captured.Group != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)  {
00393 
00394         <span class="keywordflow">if</span> (RequestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
00395 
00396             <span class="keywordflow">try</span> {
00397                 GroupSubAuthorityCount =
00398                     <a class="code" href="../../d5/d8/ex_8h.html#a14">ProbeAndReadUchar</a>( &amp;(((SID *)(Captured.Group))-&gt;SubAuthorityCount) );
00399                 GroupSize = <a class="code" href="../../d8/d6/sertl_8c.html#a38">RtlLengthRequiredSid</a>( GroupSubAuthorityCount );
00400                 <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( Captured.Group,
00401                               GroupSize,
00402                               <span class="keyword">sizeof</span>(ULONG) );
00403             } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00404                 <span class="keywordflow">return</span> GetExceptionCode();
00405             }
00406 
00407         } <span class="keywordflow">else</span> {
00408 
00409             GroupSubAuthorityCount = ((SID *)(Captured.Group))-&gt;SubAuthorityCount;
00410             GroupSize = <a class="code" href="../../d8/d6/sertl_8c.html#a38">RtlLengthRequiredSid</a>( GroupSubAuthorityCount );
00411 
00412         }
00413 
00414         NewGroupSize = (ULONG)LongAlignSize( GroupSize );
00415 
00416     }
00417 
00418 
00419 
00420     <span class="comment">//</span>
00421     <span class="comment">//  Now allocate enough pool to hold the descriptor</span>
00422     <span class="comment">//</span>
00423 
00424     <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> = <span class="keyword">sizeof</span>(SECURITY_DESCRIPTOR_RELATIVE) +
00425            NewSaclSize +
00426            NewDaclSize +
00427            NewOwnerSize +
00428            NewGroupSize;
00429 
00430     (PIOutputSecurityDescriptor) = (SECURITY_DESCRIPTOR_RELATIVE *)<a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( PoolType,
00431                                                                                  <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>,
00432                                                                                  'cSeS' );
00433 
00434     <span class="keywordflow">if</span> ( PIOutputSecurityDescriptor == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
00435         <span class="keywordflow">return</span>( STATUS_INSUFFICIENT_RESOURCES );
00436     }
00437 
00438     (*OutputSecurityDescriptor) = (PSECURITY_DESCRIPTOR)PIOutputSecurityDescriptor;
00439     DescriptorOffset = (PCHAR)(PIOutputSecurityDescriptor);
00440 
00441 
00442     <span class="comment">//</span>
00443     <span class="comment">//  Copy the main security descriptor record over</span>
00444     <span class="comment">//</span>
00445 
00446     RtlCopyMemory( DescriptorOffset,
00447                   &amp;Captured,
00448                   <span class="keyword">sizeof</span>(SECURITY_DESCRIPTOR_RELATIVE) );
00449     DescriptorOffset += <span class="keyword">sizeof</span>(SECURITY_DESCRIPTOR_RELATIVE);
00450 
00451     <span class="comment">//</span>
00452     <span class="comment">// Indicate the output descriptor is self-relative</span>
00453     <span class="comment">//</span>
00454 
00455     PIOutputSecurityDescriptor-&gt;Control |= SE_SELF_RELATIVE;
00456 
00457     <span class="comment">//</span>
00458     <span class="comment">//  If there is a System Acl, copy it over and set</span>
00459     <span class="comment">//  the output descriptor's offset to point to the newly captured copy.</span>
00460     <span class="comment">//</span>
00461 
00462     <span class="keywordflow">if</span> ((Captured.Control &amp; SE_SACL_PRESENT) &amp;&amp; (Captured.Sacl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
00463 
00464 
00465         <span class="keywordflow">try</span> {
00466             RtlCopyMemory( DescriptorOffset,
00467                           Captured.Sacl,
00468                           SaclSize );
00469 
00470 
00471         } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00472             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( PIOutputSecurityDescriptor );
00473             <span class="keywordflow">return</span> GetExceptionCode();
00474         }
00475 
00476         <span class="keywordflow">if</span> ((RequestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) &amp;&amp;
00477             (!<a class="code" href="../../d6/d6/sep_8h.html#a47">SepCheckAcl</a>( (PACL) DescriptorOffset, SaclSize )) ) {
00478 
00479             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( PIOutputSecurityDescriptor );
00480             <span class="keywordflow">return</span> STATUS_INVALID_ACL;
00481         }
00482 
00483         <span class="comment">//</span>
00484         <span class="comment">// Change pointer to offset</span>
00485         <span class="comment">//</span>
00486 
00487         PIOutputSecurityDescriptor-&gt;Sacl =
00488             RtlPointerToOffset( PIOutputSecurityDescriptor,
00489                                 DescriptorOffset,
00490                                 );
00491 
00492         ((PACL) DescriptorOffset)-&gt;AclSize = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) NewSaclSize;
00493         DescriptorOffset += NewSaclSize;
00494     } <span class="keywordflow">else</span> {
00495         PIOutputSecurityDescriptor-&gt;Sacl = 0;
00496     }
00497 
00498     <span class="comment">//</span>
00499     <span class="comment">//  If there is a Discretionary Acl, copy it over and set</span>
00500     <span class="comment">//  the output descriptor's offset to point to the newly captured copy.</span>
00501     <span class="comment">//</span>
00502 
00503     <span class="keywordflow">if</span> ((Captured.Control &amp; SE_DACL_PRESENT) &amp;&amp; (Captured.Dacl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
00504 
00505 
00506         <span class="keywordflow">try</span> {
00507             RtlCopyMemory( DescriptorOffset,
00508                           Captured.Dacl,
00509                           DaclSize );
00510         } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00511             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( PIOutputSecurityDescriptor );
00512             <span class="keywordflow">return</span> GetExceptionCode();
00513         }
00514 
00515         <span class="keywordflow">if</span> ((RequestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) &amp;&amp;
00516             (!<a class="code" href="../../d6/d6/sep_8h.html#a47">SepCheckAcl</a>( (PACL) DescriptorOffset, DaclSize )) ) {
00517 
00518             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( PIOutputSecurityDescriptor );
00519             <span class="keywordflow">return</span> STATUS_INVALID_ACL;
00520         }
00521 
00522         <span class="comment">//</span>
00523         <span class="comment">// Change pointer to offset</span>
00524         <span class="comment">//</span>
00525 
00526         PIOutputSecurityDescriptor-&gt;Dacl =
00527                    RtlPointerToOffset(
00528                         PIOutputSecurityDescriptor,
00529                         DescriptorOffset
00530                         );
00531 
00532         ((PACL) DescriptorOffset)-&gt;AclSize = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) NewDaclSize;
00533         DescriptorOffset += NewDaclSize;
00534     } <span class="keywordflow">else</span> {
00535         PIOutputSecurityDescriptor-&gt;Dacl = 0;
00536     }
00537 
00538     <span class="comment">//</span>
00539     <span class="comment">//  If there is an Owner SID, copy it over and set</span>
00540     <span class="comment">//  the output descriptor's offset to point to the newly captured copy.</span>
00541     <span class="comment">//</span>
00542 
00543     <span class="keywordflow">if</span> (Captured.Owner != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00544 
00545 
00546         <span class="keywordflow">try</span> {
00547             RtlCopyMemory( DescriptorOffset,
00548                           Captured.Owner,
00549                           OwnerSize );
00550             ((SID *) (DescriptorOffset))-&gt;SubAuthorityCount = (UCHAR) OwnerSubAuthorityCount;
00551 
00552         } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00553             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( PIOutputSecurityDescriptor );
00554             <span class="keywordflow">return</span> GetExceptionCode();
00555         }
00556 
00557         <span class="keywordflow">if</span> ((RequestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) &amp;&amp;
00558             (!<a class="code" href="../../d8/d6/sertl_8c.html#a35">RtlValidSid</a>( (PSID) DescriptorOffset )) ) {
00559 
00560             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( PIOutputSecurityDescriptor );
00561             <span class="keywordflow">return</span> STATUS_INVALID_SID;
00562         }
00563 
00564         <span class="comment">//</span>
00565         <span class="comment">// Change pointer to offset</span>
00566         <span class="comment">//</span>
00567 
00568         PIOutputSecurityDescriptor-&gt;Owner =
00569                     RtlPointerToOffset(
00570                         PIOutputSecurityDescriptor,
00571                         DescriptorOffset
00572                         );
00573 
00574         DescriptorOffset += NewOwnerSize;
00575 
00576     } <span class="keywordflow">else</span> {
00577         PIOutputSecurityDescriptor-&gt;Owner = 0;
00578     }
00579 
00580     <span class="comment">//</span>
00581     <span class="comment">//  If there is a group SID, copy it over and set</span>
00582     <span class="comment">//  the output descriptor's offset to point to the newly captured copy.</span>
00583     <span class="comment">//</span>
00584 
00585     <span class="keywordflow">if</span> (Captured.Group != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00586 
00587 
00588         <span class="keywordflow">try</span> {
00589             RtlCopyMemory( DescriptorOffset,
00590                           Captured.Group,
00591                           GroupSize );
00592 
00593             ((SID *) DescriptorOffset)-&gt;SubAuthorityCount = (UCHAR) GroupSubAuthorityCount;
00594         } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00595             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( PIOutputSecurityDescriptor );
00596             <span class="keywordflow">return</span> GetExceptionCode();
00597         }
00598 
00599         <span class="keywordflow">if</span> ((RequestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) &amp;&amp;
00600             (!<a class="code" href="../../d8/d6/sertl_8c.html#a35">RtlValidSid</a>( (PSID) DescriptorOffset )) ) {
00601 
00602             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( PIOutputSecurityDescriptor );
00603             <span class="keywordflow">return</span> STATUS_INVALID_SID;
00604         }
00605 
00606         <span class="comment">//</span>
00607         <span class="comment">// Change pointer to offset</span>
00608         <span class="comment">//</span>
00609 
00610         PIOutputSecurityDescriptor-&gt;Group =
00611                     RtlPointerToOffset(
00612                         PIOutputSecurityDescriptor,
00613                         DescriptorOffset
00614                         );
00615 
00616         DescriptorOffset += NewGroupSize;
00617     } <span class="keywordflow">else</span> {
00618         PIOutputSecurityDescriptor-&gt;Group = 0;
00619     }
00620 
00621     <span class="comment">//</span>
00622     <span class="comment">//  And return to our caller</span>
00623     <span class="comment">//</span>
00624 
00625     <span class="keywordflow">return</span> STATUS_SUCCESS;
00626 
00627 }
00628 
00629 
00630 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00631"></a><a class="code" href="../../d2/d5/se_2capture_8c.html#a2">00631</a> <a class="code" href="../../d2/d5/se_2capture_8c.html#a2">SeReleaseSecurityDescriptor</a> (
00632     IN PSECURITY_DESCRIPTOR CapturedSecurityDescriptor,
00633     IN KPROCESSOR_MODE RequestorMode,
00634     IN BOOLEAN ForceCapture
00635     )
00636 
00637 <span class="comment">/*++</span>
00638 <span class="comment"></span>
00639 <span class="comment">Routine Description:</span>
00640 <span class="comment"></span>
00641 <span class="comment">    This routine releases a previously captured security descriptor.</span>
00642 <span class="comment">    Only</span>
00643 <span class="comment"></span>
00644 <span class="comment">Arguments:</span>
00645 <span class="comment"></span>
00646 <span class="comment">    CapturedSecurityDescriptor - Supplies the security descriptor to release.</span>
00647 <span class="comment"></span>
00648 <span class="comment">    RequestorMode - The processor mode specified when the descriptor was</span>
00649 <span class="comment">        captured.</span>
00650 <span class="comment"></span>
00651 <span class="comment">    ForceCapture - The ForceCapture value specified when the descriptor was</span>
00652 <span class="comment">        captured.</span>
00653 <span class="comment"></span>
00654 <span class="comment">Return Value:</span>
00655 <span class="comment"></span>
00656 <span class="comment">    None.</span>
00657 <span class="comment"></span>
00658 <span class="comment">--*/</span>
00659 
00660 {
00661     <span class="comment">//</span>
00662     <span class="comment">// We only have something to deallocate if the requestor was user</span>
00663     <span class="comment">// mode or kernel mode requesting ForceCapture.</span>
00664     <span class="comment">//</span>
00665 
00666     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00667 
00668     <span class="keywordflow">if</span> ( ((RequestorMode == <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) &amp;&amp; (ForceCapture == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>)) ||
00669           (RequestorMode == <a class="code" href="../../d0/d9/ntosdef_8h.html#a76a70">UserMode</a> ) ) {
00670         <span class="keywordflow">if</span> ( CapturedSecurityDescriptor ) {
00671             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(CapturedSecurityDescriptor);
00672             }
00673     }
00674 
00675     <span class="keywordflow">return</span>;
00676 
00677 }
00678 
00679 
00680 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00681"></a><a class="code" href="../../d6/d6/sep_8h.html#a73">00681</a> <a class="code" href="../../d6/d6/sep_8h.html#a73">SepCopyProxyData</a> (
00682     OUT PSECURITY_TOKEN_PROXY_DATA * DestProxyData,
00683     IN PSECURITY_TOKEN_PROXY_DATA SourceProxyData
00684     )
00685 
00686 <span class="comment">/*++</span>
00687 <span class="comment"></span>
00688 <span class="comment">Routine Description:</span>
00689 <span class="comment"></span>
00690 <span class="comment">    This routine copies a token proxy data structure from one token to another.</span>
00691 <span class="comment"></span>
00692 <span class="comment">Arguments:</span>
00693 <span class="comment"></span>
00694 <span class="comment">    DestProxyData - Receives a pointer to a new proxy data structure.</span>
00695 <span class="comment"></span>
00696 <span class="comment">    SourceProxyData - Supplies a pointer to an already existing proxy data structure.</span>
00697 <span class="comment"></span>
00698 <span class="comment">Return Value:</span>
00699 <span class="comment"></span>
00700 <span class="comment">    STATUS_INSUFFICIENT_RESOURCES on failure.</span>
00701 <span class="comment"></span>
00702 <span class="comment">--*/</span>
00703 
00704 {
00705 
00706     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00707 
00708     *DestProxyData = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>, <span class="keyword">sizeof</span>( SECURITY_TOKEN_PROXY_DATA ), 'dPoT' );
00709 
00710     <span class="keywordflow">if</span> (*DestProxyData == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00711         <span class="keywordflow">return</span>( STATUS_INSUFFICIENT_RESOURCES );
00712     }
00713 
00714 
00715 
00716     (*DestProxyData)-&gt;PathInfo.Buffer = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>, SourceProxyData-&gt;PathInfo.Length, 'dPoT' );
00717 
00718     <span class="keywordflow">if</span> ((*DestProxyData)-&gt;PathInfo.Buffer == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00719         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( *DestProxyData );
00720         *DestProxyData = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00721         <span class="keywordflow">return</span>( STATUS_INSUFFICIENT_RESOURCES );
00722     }
00723 
00724     (*DestProxyData)-&gt;Length = SourceProxyData-&gt;Length;
00725     (*DestProxyData)-&gt;ProxyClass = SourceProxyData-&gt;ProxyClass;
00726     (*DestProxyData)-&gt;PathInfo.MaximumLength =
00727         (*DestProxyData)-&gt;PathInfo.Length = SourceProxyData-&gt;PathInfo.Length;
00728     (*DestProxyData)-&gt;ContainerMask = SourceProxyData-&gt;ContainerMask;
00729     (*DestProxyData)-&gt;ObjectMask = SourceProxyData-&gt;ObjectMask;
00730 
00731     <a class="code" href="../../d6/d6/nls_8c.html#a44">RtlCopyUnicodeString</a>( &amp;(*DestProxyData)-&gt;PathInfo, &amp;SourceProxyData-&gt;PathInfo );
00732 
00733     <span class="keywordflow">return</span>( STATUS_SUCCESS );
00734 }
00735 
00736 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00737"></a><a class="code" href="../../d6/d6/sep_8h.html#a74">00737</a> <a class="code" href="../../d6/d6/sep_8h.html#a74">SepFreeProxyData</a> (
00738     IN PSECURITY_TOKEN_PROXY_DATA ProxyData
00739     )
00740 
00741 <span class="comment">/*++</span>
00742 <span class="comment"></span>
00743 <span class="comment">Routine Description:</span>
00744 <span class="comment"></span>
00745 <span class="comment">    This routine frees a SECURITY_TOKEN_PROXY_DATA structure and all sub structures.</span>
00746 <span class="comment"></span>
00747 <span class="comment">Arguments:</span>
00748 <span class="comment"></span>
00749 <span class="comment">    ProxyData - Supplies a pointer to an existing proxy data structure.</span>
00750 <span class="comment"></span>
00751 <span class="comment">Return Value:</span>
00752 <span class="comment"></span>
00753 <span class="comment">    None.</span>
00754 <span class="comment"></span>
00755 <span class="comment">--*/</span>
00756 {
00757     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00758 
00759     <span class="keywordflow">if</span> (ProxyData != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00760 
00761         <span class="keywordflow">if</span> (ProxyData-&gt;PathInfo.Buffer != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00762             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( ProxyData-&gt;PathInfo.Buffer );
00763         }
00764 
00765         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( ProxyData );
00766     }
00767 }
00768 
00769 
00770 
00771 
00772 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00773"></a><a class="code" href="../../d6/d6/sep_8h.html#a75">00773</a> <a class="code" href="../../d6/d6/sep_8h.html#a75">SepProbeAndCaptureQosData</a>(
00774     IN PSECURITY_ADVANCED_QUALITY_OF_SERVICE CapturedSecurityQos
00775     )
00776 
00777 <span class="comment">/*++</span>
00778 <span class="comment"></span>
00779 <span class="comment">Routine Description:</span>
00780 <span class="comment"></span>
00781 <span class="comment">    This routine probes and captures the imbedded structures in a</span>
00782 <span class="comment">    Security Quality of Service structure.</span>
00783 <span class="comment"></span>
00784 <span class="comment">    This routine assumes that it is being called under an existing</span>
00785 <span class="comment">    try-except clause.</span>
00786 <span class="comment"></span>
00787 <span class="comment">Arguments:</span>
00788 <span class="comment"></span>
00789 <span class="comment">    CapturedSecurityQos - Points to the captured body of a QOS</span>
00790 <span class="comment">        structure.  The pointers in this structure are presumed</span>
00791 <span class="comment">        not to be probed or captured at this point.</span>
00792 <span class="comment"></span>
00793 <span class="comment">Return Value:</span>
00794 <span class="comment"></span>
00795 <span class="comment">    STATUS_SUCCESS indicates no exceptions were encountered.</span>
00796 <span class="comment"></span>
00797 <span class="comment">    Any access violations encountered will be returned.</span>
00798 <span class="comment"></span>
00799 <span class="comment">--*/</span>
00800 {
00801     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00802     PSECURITY_TOKEN_PROXY_DATA CapturedProxyData;
00803     PSECURITY_TOKEN_AUDIT_DATA CapturedAuditData;
00804     SECURITY_TOKEN_PROXY_DATA StackProxyData;
00805     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00806 
00807     CapturedProxyData = CapturedSecurityQos-&gt;ProxyData;
00808     CapturedSecurityQos-&gt;ProxyData = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00809     CapturedAuditData = CapturedSecurityQos-&gt;AuditData;
00810     CapturedSecurityQos-&gt;AuditData = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00811 
00812     <span class="keywordflow">if</span> (ARGUMENT_PRESENT( CapturedProxyData )) {
00813 
00814         <span class="comment">//</span>
00815         <span class="comment">// Make sure the body of the proxy data is ok to read.</span>
00816         <span class="comment">//</span>
00817 
00818         <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>(
00819             CapturedProxyData,
00820             <span class="keyword">sizeof</span>(SECURITY_TOKEN_PROXY_DATA),
00821             <span class="keyword">sizeof</span>(ULONG)
00822             );
00823 
00824         StackProxyData = *CapturedProxyData;
00825 
00826         <span class="keywordflow">if</span> (StackProxyData.Length != <span class="keyword">sizeof</span>( SECURITY_TOKEN_PROXY_DATA )) {
00827             <span class="keywordflow">return</span>( STATUS_INVALID_PARAMETER );
00828         }
00829 
00830 
00831         <span class="comment">//</span>
00832         <span class="comment">// Probe the passed pathinfo buffer</span>
00833         <span class="comment">//</span>
00834 
00835         <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>(
00836             StackProxyData.PathInfo.Buffer,
00837             StackProxyData.PathInfo.Length,
00838             <span class="keyword">sizeof</span>( UCHAR )
00839             );
00840 
00841         <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d6/sep_8h.html#a73">SepCopyProxyData</a>( &amp;CapturedSecurityQos-&gt;ProxyData, &amp;StackProxyData );
00842 
00843         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>)) {
00844 
00845             <span class="keywordflow">if</span> (CapturedSecurityQos-&gt;ProxyData != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00846                 <a class="code" href="../../d6/d6/sep_8h.html#a74">SepFreeProxyData</a>( CapturedSecurityQos-&gt;ProxyData );
00847                 CapturedSecurityQos-&gt;ProxyData = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00848             }
00849 
00850             <span class="keywordflow">return</span>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
00851         }
00852 
00853     }
00854 
00855     <span class="keywordflow">if</span> (ARGUMENT_PRESENT( CapturedAuditData )) {
00856 
00857         PSECURITY_TOKEN_AUDIT_DATA LocalAuditData;
00858 
00859         <span class="comment">//</span>
00860         <span class="comment">// Probe the audit data structure and make sure it looks ok</span>
00861         <span class="comment">//</span>
00862 
00863         <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>(
00864             CapturedAuditData,
00865             <span class="keyword">sizeof</span>( SECURITY_TOKEN_AUDIT_DATA ),
00866             <span class="keyword">sizeof</span>( ULONG )
00867             );
00868 
00869 
00870         LocalAuditData = <a class="code" href="../../d5/d5/cc_8h.html#a10">ExAllocatePool</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>, <span class="keyword">sizeof</span>( SECURITY_TOKEN_AUDIT_DATA ));
00871 
00872         <span class="keywordflow">if</span> (LocalAuditData == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00873 
00874             <span class="comment">//</span>
00875             <span class="comment">// Cleanup any proxy data we may have allocated.</span>
00876             <span class="comment">//</span>
00877 
00878             <a class="code" href="../../d6/d6/sep_8h.html#a74">SepFreeProxyData</a>( CapturedSecurityQos-&gt;ProxyData );
00879             CapturedSecurityQos-&gt;ProxyData = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00880 
00881             <span class="keywordflow">return</span>( STATUS_INSUFFICIENT_RESOURCES );
00882 
00883         }
00884 
00885         <span class="comment">//</span>
00886         <span class="comment">// Copy the data to the local buffer. Note: we do this in this</span>
00887         <span class="comment">// order so that if the final assignment fails the caller will</span>
00888         <span class="comment">// still be able to free the allocated pool.</span>
00889         <span class="comment">//</span>
00890 
00891         CapturedSecurityQos-&gt;AuditData = LocalAuditData;
00892 
00893         *CapturedSecurityQos-&gt;AuditData = *CapturedAuditData;
00894 
00895         <span class="keywordflow">if</span> ( LocalAuditData-&gt;Length != <span class="keyword">sizeof</span>( SECURITY_TOKEN_AUDIT_DATA ) ) {
00896             <a class="code" href="../../d6/d6/sep_8h.html#a74">SepFreeProxyData</a>( CapturedSecurityQos-&gt;ProxyData );
00897             CapturedSecurityQos-&gt;ProxyData = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00898             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(CapturedSecurityQos-&gt;AuditData);
00899             CapturedSecurityQos-&gt;AuditData = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00900             <span class="keywordflow">return</span>( STATUS_INVALID_PARAMETER );
00901         }
00902     }
00903 
00904     <span class="keywordflow">return</span>( STATUS_SUCCESS );
00905 
00906 }
00907 
00908 
00909 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00910"></a><a class="code" href="../../d2/d5/se_2capture_8c.html#a6">00910</a> <a class="code" href="../../d2/d5/se_2capture_8c.html#a6">SeFreeCapturedSecurityQos</a>(
00911     IN PVOID SecurityQos
00912     )
00913 
00914 <span class="comment">/*++</span>
00915 <span class="comment"></span>
00916 <span class="comment">Routine Description:</span>
00917 <span class="comment"></span>
00918 <span class="comment">    This routine frees the data associated with a captured SecurityQos</span>
00919 <span class="comment">    structure.  It does not free the body of the structure, just whatever</span>
00920 <span class="comment">    its internal fields point to.</span>
00921 <span class="comment"></span>
00922 <span class="comment">Arguments:</span>
00923 <span class="comment"></span>
00924 <span class="comment">    SecurityQos - Points to a captured security QOS structure.</span>
00925 <span class="comment"></span>
00926 <span class="comment">Return Value:</span>
00927 <span class="comment"></span>
00928 <span class="comment">    None.</span>
00929 <span class="comment"></span>
00930 <span class="comment">--*/</span>
00931 
00932 {
00933     PSECURITY_ADVANCED_QUALITY_OF_SERVICE IAdvancedSecurityQos;
00934 
00935     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00936 
00937     IAdvancedSecurityQos = (PSECURITY_ADVANCED_QUALITY_OF_SERVICE)<a class="code" href="../../d7/d0/ctlnpqos_8c.html#a14">SecurityQos</a>;
00938 
00939     <span class="keywordflow">if</span> (IAdvancedSecurityQos-&gt;Length == <span class="keyword">sizeof</span>( SECURITY_ADVANCED_QUALITY_OF_SERVICE )) {
00940 
00941         <span class="keywordflow">if</span> (IAdvancedSecurityQos-&gt;AuditData != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00942             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( IAdvancedSecurityQos-&gt;AuditData );
00943         }
00944 
00945         <a class="code" href="../../d6/d6/sep_8h.html#a74">SepFreeProxyData</a>( IAdvancedSecurityQos-&gt;ProxyData );
00946     }
00947 
00948     <span class="keywordflow">return</span>;
00949 }
00950 
00951 
00952 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00953"></a><a class="code" href="../../d2/d5/se_2capture_8c.html#a7">00953</a> <a class="code" href="../../d2/d5/se_2capture_8c.html#a7">SeCaptureSecurityQos</a> (
00954     IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
00955     IN KPROCESSOR_MODE RequestorMode,
00956     OUT PBOOLEAN SecurityQosPresent,
00957     OUT PSECURITY_ADVANCED_QUALITY_OF_SERVICE CapturedSecurityQos
00958 )
00959 <span class="comment">/*++</span>
00960 <span class="comment"></span>
00961 <span class="comment">Routine Description:</span>
00962 <span class="comment"></span>
00963 <span class="comment">    This routine probes and captures a copy of any security quality</span>
00964 <span class="comment">    of service parameters that might have been provided via the</span>
00965 <span class="comment">    ObjectAttributes argument.</span>
00966 <span class="comment"></span>
00967 <span class="comment">Arguments:</span>
00968 <span class="comment"></span>
00969 <span class="comment">    ObjectAttributes - The object attributes from which the QOS</span>
00970 <span class="comment">        information is to be retrieved.</span>
00971 <span class="comment"></span>
00972 <span class="comment">    RequestorMode - Indicates the processor mode by which the access</span>
00973 <span class="comment">        is being requested.</span>
00974 <span class="comment"></span>
00975 <span class="comment">    SecurityQosPresent - Receives a boolean value indicating whether</span>
00976 <span class="comment">        or not the optional security QOS information was available</span>
00977 <span class="comment">        and copied.</span>
00978 <span class="comment"></span>
00979 <span class="comment">    CapturedSecurityQos - Receives the security QOS information if available.</span>
00980 <span class="comment"></span>
00981 <span class="comment">Return Value:</span>
00982 <span class="comment"></span>
00983 <span class="comment">    STATUS_SUCCESS indicates no exceptions were encountered.</span>
00984 <span class="comment"></span>
00985 <span class="comment">    Any access violations encountered will be returned.</span>
00986 <span class="comment"></span>
00987 <span class="comment">--*/</span>
00988 
00989 {
00990 
00991     PSECURITY_QUALITY_OF_SERVICE LocalSecurityQos;
00992     ULONG LocalQosLength;
00993     PSECURITY_ADVANCED_QUALITY_OF_SERVICE LocalAdvancedSecurityQos;
00994     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00995     BOOLEAN CapturedQos;
00996 
00997     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00998 
00999     CapturedQos =  <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01000     <span class="comment">//</span>
01001     <span class="comment">//  Set default return</span>
01002     <span class="comment">//</span>
01003 
01004     (*SecurityQosPresent) = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01005 
01006     <span class="comment">//</span>
01007     <span class="comment">//  check if the requestors mode is kernel mode</span>
01008     <span class="comment">//</span>
01009 
01010     <span class="keywordflow">if</span> (RequestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
01011         <span class="keywordflow">try</span> {
01012 
01013             <span class="keywordflow">if</span> ( ARGUMENT_PRESENT(<a class="code" href="../../d7/d0/ctlnpqos_8c.html#a4">ObjectAttributes</a>) ) {
01014 
01015                 <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( <a class="code" href="../../d7/d0/ctlnpqos_8c.html#a4">ObjectAttributes</a>,
01016                               <span class="keyword">sizeof</span>(OBJECT_ATTRIBUTES),
01017                               <span class="keyword">sizeof</span>(ULONG)
01018                               );
01019 
01020                 LocalSecurityQos =
01021                     (PSECURITY_QUALITY_OF_SERVICE)<a class="code" href="../../d7/d0/ctlnpqos_8c.html#a4">ObjectAttributes</a>-&gt;SecurityQualityOfService;
01022 
01023                 <span class="keywordflow">if</span> ( ARGUMENT_PRESENT(LocalSecurityQos) ) {
01024 
01025                     <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>(
01026                         LocalSecurityQos,
01027                         <span class="keyword">sizeof</span>(SECURITY_QUALITY_OF_SERVICE),
01028                         <span class="keyword">sizeof</span>(ULONG)
01029                         );
01030 
01031                     LocalQosLength = LocalSecurityQos-&gt;Length;
01032 
01033                     <span class="comment">//</span>
01034                     <span class="comment">// Check the length and see if this is a QOS or Advanced QOS</span>
01035                     <span class="comment">// structure.</span>
01036                     <span class="comment">//</span>
01037 
01038                     <span class="keywordflow">if</span> (LocalQosLength == <span class="keyword">sizeof</span>( SECURITY_QUALITY_OF_SERVICE )) {
01039 
01040                         <span class="comment">//</span>
01041                         <span class="comment">// It's a downlevel QOS, copy what's there and leave.</span>
01042                         <span class="comment">//</span>
01043 
01044                         (*SecurityQosPresent) = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01045                         RtlMoveMemory( CapturedSecurityQos, LocalSecurityQos, <span class="keyword">sizeof</span>( SECURITY_QUALITY_OF_SERVICE ));
01046                         CapturedSecurityQos-&gt;ProxyData = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01047                         CapturedSecurityQos-&gt;AuditData = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01048                         CapturedSecurityQos-&gt;Length = LocalQosLength;
01049 
01050                     } <span class="keywordflow">else</span> {
01051 
01052                         <span class="keywordflow">if</span> (LocalQosLength == <span class="keyword">sizeof</span>( SECURITY_ADVANCED_QUALITY_OF_SERVICE )) {
01053 
01054                             LocalAdvancedSecurityQos =
01055                                 (PSECURITY_ADVANCED_QUALITY_OF_SERVICE)<a class="code" href="../../d7/d0/ctlnpqos_8c.html#a4">ObjectAttributes</a>-&gt;SecurityQualityOfService;
01056 
01057                                 <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>(
01058                                     LocalAdvancedSecurityQos,
01059                                     <span class="keyword">sizeof</span>(SECURITY_ADVANCED_QUALITY_OF_SERVICE),
01060                                     <span class="keyword">sizeof</span>(ULONG)
01061                                     );
01062 
01063                             (*SecurityQosPresent) = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01064                             *CapturedSecurityQos = *LocalAdvancedSecurityQos;
01065                             CapturedSecurityQos-&gt;Length = LocalQosLength;
01066 
01067                             <span class="comment">//</span>
01068                             <span class="comment">// Capture the proxy and audit data, if necessary.</span>
01069                             <span class="comment">//</span>
01070 
01071                             <span class="keywordflow">if</span> ( ARGUMENT_PRESENT(CapturedSecurityQos-&gt;ProxyData) || ARGUMENT_PRESENT( CapturedSecurityQos-&gt;AuditData ) ) {
01072 
01073                                 CapturedQos = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01074                                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d6/d6/sep_8h.html#a75">SepProbeAndCaptureQosData</a>( CapturedSecurityQos );
01075 
01076                                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
01077 
01078                                     <span class="keywordflow">return</span>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> );
01079                                 }
01080                             }
01081 
01082                         } <span class="keywordflow">else</span> {
01083 
01084                             <span class="keywordflow">return</span>( STATUS_INVALID_PARAMETER );
01085                         }
01086                     }
01087 
01088                 } <span class="comment">// end_if</span>
01089 
01090 
01091             } <span class="comment">// end_if</span>
01092 
01093         } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
01094 
01095 
01096             <span class="comment">//</span>
01097             <span class="comment">// If we captured any proxy data, we need to free it now.</span>
01098             <span class="comment">//</span>
01099 
01100             <span class="keywordflow">if</span> ( CapturedQos ) {
01101 
01102                 <a class="code" href="../../d6/d6/sep_8h.html#a74">SepFreeProxyData</a>( CapturedSecurityQos-&gt;ProxyData );
01103 
01104                 <span class="keywordflow">if</span> ( CapturedSecurityQos-&gt;AuditData != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
01105                     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( CapturedSecurityQos-&gt;AuditData );
01106                 }
01107             }
01108 
01109             <span class="keywordflow">return</span> GetExceptionCode();
01110         } <span class="comment">// end_try</span>
01111 
01112 
01113     } <span class="keywordflow">else</span> {
01114 
01115         <span class="keywordflow">if</span> ( ARGUMENT_PRESENT(<a class="code" href="../../d7/d0/ctlnpqos_8c.html#a4">ObjectAttributes</a>) ) {
01116             <span class="keywordflow">if</span> ( ARGUMENT_PRESENT(<a class="code" href="../../d7/d0/ctlnpqos_8c.html#a4">ObjectAttributes</a>-&gt;SecurityQualityOfService) ) {
01117                 (*SecurityQosPresent) = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01118 
01119                 <span class="keywordflow">if</span> (((PSECURITY_QUALITY_OF_SERVICE)(<a class="code" href="../../d7/d0/ctlnpqos_8c.html#a4">ObjectAttributes</a>-&gt;SecurityQualityOfService))-&gt;Length == <span class="keyword">sizeof</span>( SECURITY_QUALITY_OF_SERVICE )) {
01120 
01121                     RtlMoveMemory( CapturedSecurityQos, <a class="code" href="../../d7/d0/ctlnpqos_8c.html#a4">ObjectAttributes</a>-&gt;SecurityQualityOfService, <span class="keyword">sizeof</span>( SECURITY_QUALITY_OF_SERVICE ));
01122                     CapturedSecurityQos-&gt;ProxyData = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01123                     CapturedSecurityQos-&gt;AuditData = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01124 
01125                 } <span class="keywordflow">else</span> {
01126 
01127                     (*CapturedSecurityQos) =
01128                         (*(SECURITY_ADVANCED_QUALITY_OF_SERVICE *)(<a class="code" href="../../d7/d0/ctlnpqos_8c.html#a4">ObjectAttributes</a>-&gt;SecurityQualityOfService));
01129                 }
01130 
01131 
01132             } <span class="comment">// end_if</span>
01133         } <span class="comment">// end_if</span>
01134 
01135     } <span class="comment">// end_if</span>
01136 
01137     <span class="keywordflow">return</span> STATUS_SUCCESS;
01138 }
01139 
01140 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01141"></a><a class="code" href="../../d2/d5/se_2capture_8c.html#a8">01141</a> <a class="code" href="../../d2/d5/se_2capture_8c.html#a8">SeCaptureSid</a> (
01142     IN PSID InputSid,
01143     IN KPROCESSOR_MODE RequestorMode,
01144     IN PVOID CaptureBuffer OPTIONAL,
01145     IN ULONG CaptureBufferLength,
01146     IN POOL_TYPE PoolType,
01147     IN BOOLEAN ForceCapture,
01148     OUT PSID *CapturedSid
01149 )
01150 <span class="comment">/*++</span>
01151 <span class="comment"></span>
01152 <span class="comment">Routine Description:</span>
01153 <span class="comment"></span>
01154 <span class="comment">    This routine probes and captures a copy of the specified SID.</span>
01155 <span class="comment">    The SID is either captured into a provided buffer, or pool</span>
01156 <span class="comment">    allocated to receive the SID.</span>
01157 <span class="comment"></span>
01158 <span class="comment"></span>
01159 <span class="comment">    if the requestor mode is not kernel mode then</span>
01160 <span class="comment"></span>
01161 <span class="comment">        probe and capture the input SID</span>
01162 <span class="comment"></span>
01163 <span class="comment">    if the requstor mode is kernel mode then</span>
01164 <span class="comment"></span>
01165 <span class="comment">        if force capture is true then</span>
01166 <span class="comment"></span>
01167 <span class="comment">            do not probe the input SID, but do capture it</span>
01168 <span class="comment"></span>
01169 <span class="comment">        else</span>
01170 <span class="comment"></span>
01171 <span class="comment">            return address of original, but don't copy</span>
01172 <span class="comment"></span>
01173 <span class="comment">Arguments:</span>
01174 <span class="comment"></span>
01175 <span class="comment">    InputSid - Supplies the SID to capture.  This parameter is assumed</span>
01176 <span class="comment">        to have been provided by the mode specified in RequestorMode.</span>
01177 <span class="comment"></span>
01178 <span class="comment">    RequestorMode - Specifies the caller's access mode.</span>
01179 <span class="comment"></span>
01180 <span class="comment">    CaptureBuffer - Specifies a buffer into which the SID is to be</span>
01181 <span class="comment">        captured.  If this parameter is not provided, pool will be allocated</span>
01182 <span class="comment">        to hold the captured data.</span>
01183 <span class="comment"></span>
01184 <span class="comment">    CaptureBufferLength - Indicates the length, in bytes, of the capture</span>
01185 <span class="comment">        buffer.</span>
01186 <span class="comment"></span>
01187 <span class="comment">    PoolType - Specifies which pool type to allocate to capture the</span>
01188 <span class="comment">        SID into.  This parameter is ignored if CaptureBuffer is provided.</span>
01189 <span class="comment"></span>
01190 <span class="comment">    ForceCapture - Specifies whether the SID should be captured even if</span>
01191 <span class="comment">        requestor mode is kernel.</span>
01192 <span class="comment"></span>
01193 <span class="comment">    CapturedSid - Supplies the address of a pointer to an SID.</span>
01194 <span class="comment">        The pointer will be set to point to the captured (or uncaptured) SID.</span>
01195 <span class="comment"></span>
01196 <span class="comment">    AlignedSidSize - Supplies the address of a ULONG to receive the length</span>
01197 <span class="comment">        of the SID rounded up to the next longword boundary.</span>
01198 <span class="comment"></span>
01199 <span class="comment">Return Value:</span>
01200 <span class="comment"></span>
01201 <span class="comment">    STATUS_SUCCESS indicates the capture was successful.</span>
01202 <span class="comment"></span>
01203 <span class="comment">    STATUS_BUFFER_TOO_SMALL - indicates the buffer provided to capture the SID</span>
01204 <span class="comment">        into wasn't large enough to hold the SID.</span>
01205 <span class="comment"></span>
01206 <span class="comment">    Any access violations encountered will be returned.</span>
01207 <span class="comment"></span>
01208 <span class="comment">--*/</span>
01209 
01210 {
01211 
01212 
01213 
01214     ULONG GetSidSubAuthorityCount;
01215     ULONG SidSize;
01216 
01217     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01218 
01219     <span class="comment">//</span>
01220     <span class="comment">//  check if the requestors mode is kernel mode and we are not</span>
01221     <span class="comment">//  to force a capture.</span>
01222     <span class="comment">//</span>
01223 
01224     <span class="keywordflow">if</span> ((RequestorMode == <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) &amp;&amp; (ForceCapture == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
01225 
01226         <span class="comment">//</span>
01227         <span class="comment">//  We don't need to do any work and can simply</span>
01228         <span class="comment">//  return a pointer to the input SID</span>
01229         <span class="comment">//</span>
01230 
01231         (*CapturedSid) = InputSid;
01232 
01233         <span class="keywordflow">return</span> STATUS_SUCCESS;
01234     }
01235 
01236 
01237     <span class="comment">//</span>
01238     <span class="comment">// Get the length needed to hold the SID</span>
01239     <span class="comment">//</span>
01240 
01241     <span class="keywordflow">if</span> (RequestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
01242 
01243         <span class="keywordflow">try</span> {
01244             GetSidSubAuthorityCount =
01245                 <a class="code" href="../../d5/d8/ex_8h.html#a14">ProbeAndReadUchar</a>( &amp;(((SID *)(InputSid))-&gt;SubAuthorityCount) );
01246             SidSize = <a class="code" href="../../d8/d6/sertl_8c.html#a38">RtlLengthRequiredSid</a>( GetSidSubAuthorityCount );
01247             <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( InputSid,
01248                           SidSize,
01249                           <span class="keyword">sizeof</span>(ULONG) );
01250         } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
01251             <span class="keywordflow">return</span> GetExceptionCode();
01252         }
01253 
01254     } <span class="keywordflow">else</span> {
01255 
01256         GetSidSubAuthorityCount = ((SID *)(InputSid))-&gt;SubAuthorityCount;
01257         SidSize = <a class="code" href="../../d8/d6/sertl_8c.html#a38">RtlLengthRequiredSid</a>( GetSidSubAuthorityCount );
01258 
01259     }
01260 
01261 
01262     <span class="comment">//</span>
01263     <span class="comment">// If a buffer was provided, compare lengths.</span>
01264     <span class="comment">// Otherwise, allocate a buffer.</span>
01265     <span class="comment">//</span>
01266 
01267     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(CaptureBuffer)) {
01268 
01269         <span class="keywordflow">if</span> (SidSize &gt; CaptureBufferLength) {
01270             <span class="keywordflow">return</span> STATUS_BUFFER_TOO_SMALL;
01271         } <span class="keywordflow">else</span> {
01272 
01273             (*CapturedSid) = CaptureBuffer;
01274         }
01275 
01276     } <span class="keywordflow">else</span> {
01277 
01278         (*CapturedSid) = (PSID)<a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(PoolType, SidSize, 'iSeS');
01279 
01280         <span class="keywordflow">if</span> ( *CapturedSid == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
01281             <span class="keywordflow">return</span>( STATUS_INSUFFICIENT_RESOURCES );
01282         }
01283 
01284     }
01285 
01286     <span class="comment">//</span>
01287     <span class="comment">// Now copy the SID and validate it</span>
01288     <span class="comment">//</span>
01289 
01290     <span class="keywordflow">try</span> {
01291 
01292         RtlMoveMemory( (*CapturedSid), InputSid, SidSize );
01293         ((SID *)(*CapturedSid))-&gt;SubAuthorityCount = (UCHAR) GetSidSubAuthorityCount;
01294 
01295     } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
01296         <span class="keywordflow">if</span> (!ARGUMENT_PRESENT(CaptureBuffer)) {
01297             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( (*CapturedSid) );
01298             *CapturedSid = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01299         }
01300 
01301         <span class="keywordflow">return</span> GetExceptionCode();
01302     }
01303 
01304     <span class="keywordflow">if</span> ((!<a class="code" href="../../d8/d6/sertl_8c.html#a35">RtlValidSid</a>( (*CapturedSid) )) ) {
01305 
01306         <span class="keywordflow">if</span> (!ARGUMENT_PRESENT(CaptureBuffer)) {
01307             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( (*CapturedSid) );
01308             *CapturedSid = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01309         }
01310 
01311         <span class="keywordflow">return</span> STATUS_INVALID_SID;
01312     }
01313 
01314     <span class="keywordflow">return</span> STATUS_SUCCESS;
01315 
01316 }
01317 
01318 
01319 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01320"></a><a class="code" href="../../d2/d5/se_2capture_8c.html#a9">01320</a> <a class="code" href="../../d2/d5/se_2capture_8c.html#a9">SeReleaseSid</a> (
01321     IN PSID CapturedSid,
01322     IN KPROCESSOR_MODE RequestorMode,
01323     IN BOOLEAN ForceCapture
01324     )
01325 
01326 <span class="comment">/*++</span>
01327 <span class="comment"></span>
01328 <span class="comment">Routine Description:</span>
01329 <span class="comment"></span>
01330 <span class="comment">    This routine releases a previously captured SID.</span>
01331 <span class="comment"></span>
01332 <span class="comment">    This routine should NOT be called if the SID was captured into a</span>
01333 <span class="comment">    provided CaptureBuffer (see SeCaptureSid).</span>
01334 <span class="comment"></span>
01335 <span class="comment">Arguments:</span>
01336 <span class="comment"></span>
01337 <span class="comment">    CapturedSid - Supplies the SID to release.</span>
01338 <span class="comment"></span>
01339 <span class="comment">    RequestorMode - The processor mode specified when the SID was captured.</span>
01340 <span class="comment"></span>
01341 <span class="comment">    ForceCapture - The ForceCapture value specified when the SID was</span>
01342 <span class="comment">        captured.</span>
01343 <span class="comment"></span>
01344 <span class="comment">Return Value:</span>
01345 <span class="comment"></span>
01346 <span class="comment">    None.</span>
01347 <span class="comment"></span>
01348 <span class="comment">--*/</span>
01349 
01350 {
01351     <span class="comment">//</span>
01352     <span class="comment">// We only have something to deallocate if the requestor was user</span>
01353     <span class="comment">// mode or kernel mode requesting ForceCapture.</span>
01354     <span class="comment">//</span>
01355 
01356     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01357 
01358     <span class="keywordflow">if</span> ( ((RequestorMode == <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) &amp;&amp; (ForceCapture == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>)) ||
01359           (RequestorMode == <a class="code" href="../../d0/d9/ntosdef_8h.html#a76a70">UserMode</a> ) ) {
01360 
01361         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(CapturedSid);
01362 
01363     }
01364 
01365     <span class="keywordflow">return</span>;
01366 
01367 }
01368 
01369 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01370"></a><a class="code" href="../../d2/d5/se_2capture_8c.html#a10">01370</a> <a class="code" href="../../d2/d5/se_2capture_8c.html#a10">SeCaptureAcl</a> (
01371     IN PACL InputAcl,
01372     IN KPROCESSOR_MODE RequestorMode,
01373     IN PVOID CaptureBuffer OPTIONAL,
01374     IN ULONG CaptureBufferLength,
01375     IN POOL_TYPE PoolType,
01376     IN BOOLEAN ForceCapture,
01377     OUT PACL *CapturedAcl,
01378     OUT PULONG AlignedAclSize
01379     )
01380 
01381 <span class="comment">/*++</span>
01382 <span class="comment"></span>
01383 <span class="comment">Routine Description:</span>
01384 <span class="comment"></span>
01385 <span class="comment">    This routine probes and captures a copy of the specified ACL.</span>
01386 <span class="comment">    The ACL is either captured into a provided buffer, or pool</span>
01387 <span class="comment">    allocated to receive the ACL.</span>
01388 <span class="comment"></span>
01389 <span class="comment">    Any ACL captured will have its structure validated.</span>
01390 <span class="comment"></span>
01391 <span class="comment"></span>
01392 <span class="comment">    if the requestor mode is not kernel mode then</span>
01393 <span class="comment"></span>
01394 <span class="comment">        probe and capture the input ACL</span>
01395 <span class="comment"></span>
01396 <span class="comment">    if the requstor mode is kernel mode then</span>
01397 <span class="comment"></span>
01398 <span class="comment">        if force capture is true then</span>
01399 <span class="comment"></span>
01400 <span class="comment">            do not probe the input ACL, but do capture it</span>
01401 <span class="comment"></span>
01402 <span class="comment">        else</span>
01403 <span class="comment"></span>
01404 <span class="comment">            return address of original, but don't copy</span>
01405 <span class="comment"></span>
01406 <span class="comment">Arguments:</span>
01407 <span class="comment"></span>
01408 <span class="comment">    InputAcl - Supplies the ACL to capture.  This parameter is assumed</span>
01409 <span class="comment">        to have been provided by the mode specified in RequestorMode.</span>
01410 <span class="comment"></span>
01411 <span class="comment">    RequestorMode - Specifies the caller's access mode.</span>
01412 <span class="comment"></span>
01413 <span class="comment">    CaptureBuffer - Specifies a buffer into which the ACL is to be</span>
01414 <span class="comment">        captured.  If this parameter is not provided, pool will be allocated</span>
01415 <span class="comment">        to hold the captured data.</span>
01416 <span class="comment"></span>
01417 <span class="comment">    CaptureBufferLength - Indicates the length, in bytes, of the capture</span>
01418 <span class="comment">        buffer.</span>
01419 <span class="comment"></span>
01420 <span class="comment">    PoolType - Specifies which pool type to allocate to capture the</span>
01421 <span class="comment">        ACL into.  This parameter is ignored if CaptureBuffer is provided.</span>
01422 <span class="comment"></span>
01423 <span class="comment">    ForceCapture - Specifies whether the ACL should be captured even if</span>
01424 <span class="comment">        requestor mode is kernel.</span>
01425 <span class="comment"></span>
01426 <span class="comment">    CapturedAcl - Supplies the address of a pointer to an ACL.</span>
01427 <span class="comment">        The pointer will be set to point to the captured (or uncaptured) ACL.</span>
01428 <span class="comment"></span>
01429 <span class="comment">    AlignedAclSize - Supplies the address of a ULONG to receive the length</span>
01430 <span class="comment">        of the ACL rounded up to the next longword boundary.</span>
01431 <span class="comment"></span>
01432 <span class="comment">Return Value:</span>
01433 <span class="comment"></span>
01434 <span class="comment">    STATUS_SUCCESS indicates the capture was successful.</span>
01435 <span class="comment"></span>
01436 <span class="comment">    STATUS_BUFFER_TOO_SMALL - indicates the buffer provided to capture the ACL</span>
01437 <span class="comment">        into wasn't large enough to hold the ACL.</span>
01438 <span class="comment"></span>
01439 <span class="comment">    Any access violations encountered will be returned.</span>
01440 <span class="comment"></span>
01441 <span class="comment">--*/</span>
01442 
01443 {
01444 
01445     ULONG AclSize;
01446 
01447     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01448 
01449     <span class="comment">//</span>
01450     <span class="comment">//  check if the requestors mode is kernel mode and we are not</span>
01451     <span class="comment">//  to force a capture.</span>
01452     <span class="comment">//</span>
01453 
01454     <span class="keywordflow">if</span> ((RequestorMode == <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) &amp;&amp; (ForceCapture == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
01455 
01456         <span class="comment">//</span>
01457         <span class="comment">//  We don't need to do any work and can simply</span>
01458         <span class="comment">//  return a pointer to the input ACL</span>
01459         <span class="comment">//</span>
01460 
01461         (*CapturedAcl) = InputAcl;
01462 
01463         <span class="keywordflow">return</span> STATUS_SUCCESS;
01464     }
01465 
01466 
01467     <span class="comment">//</span>
01468     <span class="comment">// Get the length needed to hold the ACL</span>
01469     <span class="comment">//</span>
01470 
01471     <span class="keywordflow">if</span> (RequestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
01472 
01473         <span class="keywordflow">try</span> {
01474 
01475             AclSize = <a class="code" href="../../d5/d8/ex_8h.html#a16">ProbeAndReadUshort</a>( &amp;(InputAcl-&gt;AclSize) );
01476 
01477             <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( InputAcl,
01478                           AclSize,
01479                           <span class="keyword">sizeof</span>(ULONG) );
01480 
01481         } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
01482             <span class="keywordflow">return</span> GetExceptionCode();
01483         }
01484 
01485     } <span class="keywordflow">else</span> {
01486 
01487         AclSize = InputAcl-&gt;AclSize;
01488 
01489     }
01490 
01491     <span class="comment">//</span>
01492     <span class="comment">// If the passed pointer is non-null, it has better at least</span>
01493     <span class="comment">// point to a well formed ACL</span>
01494     <span class="comment">//</span>
01495 
01496     <span class="keywordflow">if</span> (AclSize &lt; <span class="keyword">sizeof</span>(ACL)) {
01497         <span class="keywordflow">return</span>( STATUS_INVALID_ACL );
01498     }
01499 
01500     (*AlignedAclSize) = (ULONG)LongAlignSize( AclSize );
01501 
01502 
01503     <span class="comment">//</span>
01504     <span class="comment">// If a buffer was provided, compare lengths.</span>
01505     <span class="comment">// Otherwise, allocate a buffer.</span>
01506     <span class="comment">//</span>
01507 
01508     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(CaptureBuffer)) {
01509 
01510         <span class="keywordflow">if</span> (AclSize &gt; CaptureBufferLength) {
01511             <span class="keywordflow">return</span> STATUS_BUFFER_TOO_SMALL;
01512         } <span class="keywordflow">else</span> {
01513 
01514             (*CapturedAcl) = CaptureBuffer;
01515         }
01516 
01517     } <span class="keywordflow">else</span> {
01518 
01519         (*CapturedAcl) = (PACL)<a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(PoolType, AclSize, 'cAeS');
01520 
01521         <span class="keywordflow">if</span> ( *CapturedAcl == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
01522             <span class="keywordflow">return</span>( STATUS_INSUFFICIENT_RESOURCES );
01523         }
01524 
01525     }
01526 
01527     <span class="comment">//</span>
01528     <span class="comment">// Now copy the ACL and validate it</span>
01529     <span class="comment">//</span>
01530 
01531     <span class="keywordflow">try</span> {
01532 
01533         RtlMoveMemory( (*CapturedAcl), InputAcl, AclSize );
01534 
01535     } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
01536         <span class="keywordflow">if</span> (!ARGUMENT_PRESENT(CaptureBuffer)) {
01537             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( (*CapturedAcl) );
01538         }
01539 
01540         *CapturedAcl = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01541         <span class="keywordflow">return</span> GetExceptionCode();
01542     }
01543 
01544     <span class="keywordflow">if</span> ( (!<a class="code" href="../../d6/d6/sep_8h.html#a47">SepCheckAcl</a>( (*CapturedAcl), AclSize )) ) {
01545 
01546         <span class="keywordflow">if</span> (!ARGUMENT_PRESENT(CaptureBuffer)) {
01547             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( (*CapturedAcl) );
01548         }
01549 
01550         *CapturedAcl = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01551         <span class="keywordflow">return</span> STATUS_INVALID_ACL;
01552     }
01553 
01554     <span class="keywordflow">return</span> STATUS_SUCCESS;
01555 
01556 }
01557 
01558 
01559 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01560"></a><a class="code" href="../../d2/d5/se_2capture_8c.html#a11">01560</a> <a class="code" href="../../d2/d5/se_2capture_8c.html#a11">SeReleaseAcl</a> (
01561     IN PACL CapturedAcl,
01562     IN KPROCESSOR_MODE RequestorMode,
01563     IN BOOLEAN ForceCapture
01564     )
01565 
01566 <span class="comment">/*++</span>
01567 <span class="comment"></span>
01568 <span class="comment">Routine Description:</span>
01569 <span class="comment"></span>
01570 <span class="comment">    This routine releases a previously captured ACL.</span>
01571 <span class="comment"></span>
01572 <span class="comment">    This routine should NOT be called if the ACL was captured into a</span>
01573 <span class="comment">    provided CaptureBuffer (see SeCaptureAcl).</span>
01574 <span class="comment"></span>
01575 <span class="comment">Arguments:</span>
01576 <span class="comment"></span>
01577 <span class="comment">    CapturedAcl - Supplies the ACL to release.</span>
01578 <span class="comment"></span>
01579 <span class="comment">    RequestorMode - The processor mode specified when the ACL was captured.</span>
01580 <span class="comment"></span>
01581 <span class="comment">    ForceCapture - The ForceCapture value specified when the ACL was</span>
01582 <span class="comment">        captured.</span>
01583 <span class="comment"></span>
01584 <span class="comment">Return Value:</span>
01585 <span class="comment"></span>
01586 <span class="comment">    None.</span>
01587 <span class="comment"></span>
01588 <span class="comment">--*/</span>
01589 
01590 {
01591     <span class="comment">//</span>
01592     <span class="comment">// We only have something to deallocate if the requestor was user</span>
01593     <span class="comment">// mode or kernel mode requesting ForceCapture.</span>
01594     <span class="comment">//</span>
01595 
01596     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01597 
01598     <span class="keywordflow">if</span> ( ((RequestorMode == <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) &amp;&amp; (ForceCapture == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>)) ||
01599           (RequestorMode == <a class="code" href="../../d0/d9/ntosdef_8h.html#a76a70">UserMode</a> ) ) {
01600 
01601         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(CapturedAcl);
01602 
01603     }
01604 
01605 }
01606 
01607 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01608"></a><a class="code" href="../../d2/d5/se_2capture_8c.html#a12">01608</a> <a class="code" href="../../d2/d5/se_2capture_8c.html#a12">SeCaptureLuidAndAttributesArray</a> (
01609     IN PLUID_AND_ATTRIBUTES InputArray,
01610     IN ULONG ArrayCount,
01611     IN KPROCESSOR_MODE RequestorMode,
01612     IN PVOID CaptureBuffer OPTIONAL,
01613     IN ULONG CaptureBufferLength,
01614     IN POOL_TYPE PoolType,
01615     IN BOOLEAN ForceCapture,
01616     OUT PLUID_AND_ATTRIBUTES *CapturedArray,
01617     OUT PULONG AlignedArraySize
01618     )
01619 
01620 <span class="comment">/*++</span>
01621 <span class="comment"></span>
01622 <span class="comment">Routine Description:</span>
01623 <span class="comment"></span>
01624 <span class="comment">    This routine probes and captures a copy of the specified</span>
01625 <span class="comment">    LUID_AND_ATTRIBUTES array.</span>
01626 <span class="comment"></span>
01627 <span class="comment">    The array is either captured into a provided buffer, or pool</span>
01628 <span class="comment">    allocated to receive the array.</span>
01629 <span class="comment"></span>
01630 <span class="comment"></span>
01631 <span class="comment">    if the requestor mode is not kernel mode then</span>
01632 <span class="comment"></span>
01633 <span class="comment">        probe and capture the input array</span>
01634 <span class="comment"></span>
01635 <span class="comment">    if the requstor mode is kernel mode then</span>
01636 <span class="comment"></span>
01637 <span class="comment">        if force capture is true then</span>
01638 <span class="comment"></span>
01639 <span class="comment">            do not probe the input array, but do capture it</span>
01640 <span class="comment"></span>
01641 <span class="comment">        else</span>
01642 <span class="comment"></span>
01643 <span class="comment">            return address of original, but don't copy</span>
01644 <span class="comment"></span>
01645 <span class="comment">Arguments:</span>
01646 <span class="comment"></span>
01647 <span class="comment">    InputArray - Supplies the array to capture.  This parameter is assumed</span>
01648 <span class="comment">        to have been provided by the mode specified in RequestorMode.</span>
01649 <span class="comment"></span>
01650 <span class="comment">    ArrayCount - Indicates the number of elements in the array to capture.</span>
01651 <span class="comment"></span>
01652 <span class="comment">    RequestorMode - Specifies the caller's access mode.</span>
01653 <span class="comment"></span>
01654 <span class="comment">    CaptureBuffer - Specifies a buffer into which the array is to be</span>
01655 <span class="comment">        captured.  If this parameter is not provided, pool will be allocated</span>
01656 <span class="comment">        to hold the captured data.</span>
01657 <span class="comment"></span>
01658 <span class="comment">    CaptureBufferLength - Indicates the length, in bytes, of the capture</span>
01659 <span class="comment">        buffer.</span>
01660 <span class="comment"></span>
01661 <span class="comment">    PoolType - Specifies which pool type to allocate to capture the</span>
01662 <span class="comment">        array into.  This parameter is ignored if CaptureBuffer is provided.</span>
01663 <span class="comment"></span>
01664 <span class="comment">    ForceCapture - Specifies whether the array should be captured even if</span>
01665 <span class="comment">        requestor mode is kernel.</span>
01666 <span class="comment"></span>
01667 <span class="comment">    CapturedArray - Supplies the address of a pointer to an array.</span>
01668 <span class="comment">        The pointer will be set to point to the captured (or uncaptured) array.</span>
01669 <span class="comment"></span>
01670 <span class="comment">    AlignedArraySize - Supplies the address of a ULONG to receive the length</span>
01671 <span class="comment">        of the array rounded up to the next longword boundary.</span>
01672 <span class="comment"></span>
01673 <span class="comment">Return Value:</span>
01674 <span class="comment"></span>
01675 <span class="comment">    STATUS_SUCCESS indicates the capture was successful.</span>
01676 <span class="comment"></span>
01677 <span class="comment">    STATUS_BUFFER_TOO_SMALL - indicates the buffer provided to capture the array</span>
01678 <span class="comment">        into wasn't large enough to hold the array.</span>
01679 <span class="comment"></span>
01680 <span class="comment">    Any access violations encountered will be returned.</span>
01681 <span class="comment"></span>
01682 <span class="comment">--*/</span>
01683 
01684 {
01685 
01686     ULONG ArraySize;
01687 
01688     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01689 
01690     <span class="comment">//</span>
01691     <span class="comment">// Make sure the array isn't empty</span>
01692     <span class="comment">//</span>
01693 
01694     <span class="keywordflow">if</span> (ArrayCount == 0) {
01695         (*CapturedArray) = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01696         (*AlignedArraySize) = 0;
01697         <span class="keywordflow">return</span> STATUS_SUCCESS;
01698     }
01699 
01700     <span class="comment">//</span>
01701     <span class="comment">// If there are too many LUIDs, return failure</span>
01702     <span class="comment">//</span>
01703 
01704     <span class="keywordflow">if</span> (ArrayCount &gt; <a class="code" href="../../d6/d6/sep_8h.html#a13">SEP_MAX_PRIVILEGE_COUNT</a>) {
01705         <span class="keywordflow">return</span>(STATUS_INVALID_PARAMETER);
01706     }
01707 
01708     <span class="comment">//</span>
01709     <span class="comment">//  check if the requestors mode is kernel mode and we are not</span>
01710     <span class="comment">//  to force a capture.</span>
01711     <span class="comment">//</span>
01712 
01713     <span class="keywordflow">if</span> ((RequestorMode == <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) &amp;&amp; (ForceCapture == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
01714 
01715         <span class="comment">//</span>
01716         <span class="comment">//  We don't need to do any work and can simply</span>
01717         <span class="comment">//  return a pointer to the input array</span>
01718         <span class="comment">//</span>
01719 
01720         (*CapturedArray) = <a class="code" href="../../d6/d2/aug98_2dll32_2getcrd_8c.html#a77">InputArray</a>;
01721 
01722         <span class="keywordflow">return</span> STATUS_SUCCESS;
01723     }
01724 
01725 
01726     <span class="comment">//</span>
01727     <span class="comment">// Get the length needed to hold the array</span>
01728     <span class="comment">//</span>
01729 
01730     ArraySize = ArrayCount * (ULONG)<span class="keyword">sizeof</span>(LUID_AND_ATTRIBUTES);
01731     (*AlignedArraySize) = (ULONG)LongAlignSize( ArraySize );
01732 
01733     <span class="keywordflow">if</span> (RequestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
01734 
01735         <span class="keywordflow">try</span> {
01736 
01737 
01738             <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( <a class="code" href="../../d6/d2/aug98_2dll32_2getcrd_8c.html#a77">InputArray</a>,
01739                           ArraySize,
01740                           <span class="keyword">sizeof</span>(ULONG) );
01741 
01742         } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
01743             <span class="keywordflow">return</span> GetExceptionCode();
01744         }
01745 
01746     }
01747 
01748 
01749 
01750     <span class="comment">//</span>
01751     <span class="comment">// If a buffer was provided, compare lengths.</span>
01752     <span class="comment">// Otherwise, allocate a buffer.</span>
01753     <span class="comment">//</span>
01754 
01755     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(CaptureBuffer)) {
01756 
01757         <span class="keywordflow">if</span> (ArraySize &gt; CaptureBufferLength) {
01758             <span class="keywordflow">return</span> STATUS_BUFFER_TOO_SMALL;
01759         } <span class="keywordflow">else</span> {
01760 
01761             (*CapturedArray) = CaptureBuffer;
01762         }
01763 
01764     } <span class="keywordflow">else</span> {
01765 
01766         (*CapturedArray) =
01767             (PLUID_AND_ATTRIBUTES)<a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(PoolType, ArraySize, 'uLeS');
01768 
01769         <span class="keywordflow">if</span> ( *CapturedArray == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
01770             <span class="keywordflow">return</span>( STATUS_INSUFFICIENT_RESOURCES );
01771         }
01772 
01773     }
01774 
01775     <span class="comment">//</span>
01776     <span class="comment">// Now copy the array</span>
01777     <span class="comment">//</span>
01778 
01779     <span class="keywordflow">try</span> {
01780 
01781         RtlMoveMemory( (*CapturedArray), <a class="code" href="../../d6/d2/aug98_2dll32_2getcrd_8c.html#a77">InputArray</a>, ArraySize );
01782 
01783     } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
01784         <span class="keywordflow">if</span> (!ARGUMENT_PRESENT(CaptureBuffer)) {
01785             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( (*CapturedArray) );
01786         }
01787 
01788         <span class="keywordflow">return</span> GetExceptionCode();
01789     }
01790 
01791     <span class="keywordflow">return</span> STATUS_SUCCESS;
01792 
01793 }
01794 
01795 
01796 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01797"></a><a class="code" href="../../d2/d5/se_2capture_8c.html#a13">01797</a> <a class="code" href="../../d2/d5/se_2capture_8c.html#a13">SeReleaseLuidAndAttributesArray</a> (
01798     IN PLUID_AND_ATTRIBUTES CapturedArray,
01799     IN KPROCESSOR_MODE RequestorMode,
01800     IN BOOLEAN ForceCapture
01801     )
01802 
01803 <span class="comment">/*++</span>
01804 <span class="comment"></span>
01805 <span class="comment">Routine Description:</span>
01806 <span class="comment"></span>
01807 <span class="comment">    This routine releases a previously captured array of LUID_AND_ATTRIBUTES.</span>
01808 <span class="comment"></span>
01809 <span class="comment">    This routine should NOT be called if the array was captured into a</span>
01810 <span class="comment">    provided CaptureBuffer (see SeCaptureLuidAndAttributesArray).</span>
01811 <span class="comment"></span>
01812 <span class="comment">Arguments:</span>
01813 <span class="comment"></span>
01814 <span class="comment">    CapturedArray - Supplies the array to release.</span>
01815 <span class="comment"></span>
01816 <span class="comment">    RequestorMode - The processor mode specified when the array was captured.</span>
01817 <span class="comment"></span>
01818 <span class="comment">    ForceCapture - The ForceCapture value specified when the array was</span>
01819 <span class="comment">        captured.</span>
01820 <span class="comment"></span>
01821 <span class="comment">Return Value:</span>
01822 <span class="comment"></span>
01823 <span class="comment">    None.</span>
01824 <span class="comment"></span>
01825 <span class="comment">--*/</span>
01826 
01827 {
01828     <span class="comment">//</span>
01829     <span class="comment">// We only have something to deallocate if the requestor was user</span>
01830     <span class="comment">// mode or kernel mode requesting ForceCapture.</span>
01831     <span class="comment">//</span>
01832 
01833     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01834 
01835     <span class="keywordflow">if</span> ( ((RequestorMode == <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) &amp;&amp; (ForceCapture == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>)) ||
01836           (RequestorMode == <a class="code" href="../../d0/d9/ntosdef_8h.html#a76a70">UserMode</a> )) {
01837         <span class="comment">//</span>
01838         <span class="comment">// the capture routine returns success with a null pointer for zero elements.</span>
01839         <span class="comment">//</span>
01840         <span class="keywordflow">if</span> (CapturedArray != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)
01841            <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(CapturedArray);
01842 
01843     }
01844 
01845     <span class="keywordflow">return</span>;
01846 
01847 }
01848 
01849 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01850"></a><a class="code" href="../../d2/d5/se_2capture_8c.html#a14">01850</a> <a class="code" href="../../d2/d5/se_2capture_8c.html#a14">SeCaptureSidAndAttributesArray</a> (
01851     IN PSID_AND_ATTRIBUTES InputArray,
01852     IN ULONG ArrayCount,
01853     IN KPROCESSOR_MODE RequestorMode,
01854     IN PVOID CaptureBuffer OPTIONAL,
01855     IN ULONG CaptureBufferLength,
01856     IN POOL_TYPE PoolType,
01857     IN BOOLEAN ForceCapture,
01858     OUT PSID_AND_ATTRIBUTES *CapturedArray,
01859     OUT PULONG AlignedArraySize
01860     )
01861 
01862 <span class="comment">/*++</span>
01863 <span class="comment"></span>
01864 <span class="comment">Routine Description:</span>
01865 <span class="comment"></span>
01866 <span class="comment">    This routine probes and captures a copy of the specified</span>
01867 <span class="comment">    SID_AND_ATTRIBUTES array, along with the SID values pointed</span>
01868 <span class="comment">    to.</span>
01869 <span class="comment"></span>
01870 <span class="comment">    The array is either captured into a provided buffer, or pool</span>
01871 <span class="comment">    allocated to receive the array.</span>
01872 <span class="comment"></span>
01873 <span class="comment">    The format of the captured information is an array of SID_AND_ATTRIBUTES</span>
01874 <span class="comment">    data structures followed by the SID values.  THIS MAY NOT BE THE CASE</span>
01875 <span class="comment">    FOR KERNEL MODE UNLESS A FORCE CAPTURE IS SPECIFIED.</span>
01876 <span class="comment"></span>
01877 <span class="comment"></span>
01878 <span class="comment">    if the requestor mode is not kernel mode then</span>
01879 <span class="comment"></span>
01880 <span class="comment">        probe and capture the input array</span>
01881 <span class="comment"></span>
01882 <span class="comment">    if the requstor mode is kernel mode then</span>
01883 <span class="comment"></span>
01884 <span class="comment">        if force capture is true then</span>
01885 <span class="comment"></span>
01886 <span class="comment">            do not probe the input array, but do capture it</span>
01887 <span class="comment"></span>
01888 <span class="comment">        else</span>
01889 <span class="comment"></span>
01890 <span class="comment">            return address of original, but don't copy</span>
01891 <span class="comment"></span>
01892 <span class="comment">Arguments:</span>
01893 <span class="comment"></span>
01894 <span class="comment">    InputArray - Supplies the array to capture.  This parameter is assumed</span>
01895 <span class="comment">        to have been provided by the mode specified in RequestorMode.</span>
01896 <span class="comment"></span>
01897 <span class="comment">    ArrayCount - Indicates the number of elements in the array to capture.</span>
01898 <span class="comment"></span>
01899 <span class="comment">    RequestorMode - Specifies the caller's access mode.</span>
01900 <span class="comment"></span>
01901 <span class="comment">    CaptureBuffer - Specifies a buffer into which the array is to be</span>
01902 <span class="comment">        captured.  If this parameter is not provided, pool will be allocated</span>
01903 <span class="comment">        to hold the captured data.</span>
01904 <span class="comment"></span>
01905 <span class="comment">    CaptureBufferLength - Indicates the length, in bytes, of the capture</span>
01906 <span class="comment">        buffer.</span>
01907 <span class="comment"></span>
01908 <span class="comment">    PoolType - Specifies which pool type to allocate to capture the</span>
01909 <span class="comment">        array into.  This parameter is ignored if CaptureBuffer is provided.</span>
01910 <span class="comment"></span>
01911 <span class="comment">    ForceCapture - Specifies whether the array should be captured even if</span>
01912 <span class="comment">        requestor mode is kernel.</span>
01913 <span class="comment"></span>
01914 <span class="comment">    CapturedArray - Supplies the address of a pointer to an array.</span>
01915 <span class="comment">        The pointer will be set to point to the captured (or uncaptured) array.</span>
01916 <span class="comment"></span>
01917 <span class="comment">    AlignedArraySize - Supplies the address of a ULONG to receive the length</span>
01918 <span class="comment">        of the array rounded up to the next longword boundary.</span>
01919 <span class="comment"></span>
01920 <span class="comment">Return Value:</span>
01921 <span class="comment"></span>
01922 <span class="comment">    STATUS_SUCCESS indicates the capture was successful.</span>
01923 <span class="comment"></span>
01924 <span class="comment">    STATUS_BUFFER_TOO_SMALL - indicates the buffer provided to capture the array</span>
01925 <span class="comment">        into wasn't large enough to hold the array.</span>
01926 <span class="comment"></span>
01927 <span class="comment">    Any access violations encountered will be returned.</span>
01928 <span class="comment"></span>
01929 <span class="comment">--*/</span>
01930 
01931 {
01932 
01933 <span class="keyword">typedef</span> <span class="keyword">struct </span>_TEMP_ARRAY_ELEMENT {
01934     PISID  Sid;
01935     ULONG SidLength;
01936 } TEMP_ARRAY_ELEMENT;
01937 
01938 
01939     TEMP_ARRAY_ELEMENT *TempArray;
01940 
01941     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> CompletionStatus = STATUS_SUCCESS;
01942 
01943     ULONG ArraySize;
01944     ULONG AlignedLengthRequired;
01945 
01946     ULONG NextIndex;
01947 
01948     PSID_AND_ATTRIBUTES NextElement;
01949     PVOID NextBufferLocation;
01950 
01951     ULONG GetSidSubAuthorityCount;
01952     ULONG SidSize;
01953     ULONG AlignedSidSize;
01954 
01955     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01956 
01957     <span class="comment">//</span>
01958     <span class="comment">// Make sure the array isn't empty</span>
01959     <span class="comment">//</span>
01960 
01961     <span class="keywordflow">if</span> (ArrayCount == 0) {
01962         (*CapturedArray) = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01963         (*AlignedArraySize) = 0;
01964         <span class="keywordflow">return</span> STATUS_SUCCESS;
01965     }
01966 
01967     <span class="comment">//</span>
01968     <span class="comment">// Check there aren't too many SIDs</span>
01969     <span class="comment">//</span>
01970 
01971     <span class="keywordflow">if</span> (ArrayCount &gt; <a class="code" href="../../d6/d6/sep_8h.html#a12">SEP_MAX_GROUP_COUNT</a>) {
01972         <span class="keywordflow">return</span>(STATUS_INVALID_PARAMETER);
01973     }
01974     <span class="comment">//</span>
01975     <span class="comment">//  check if the requestor's mode is kernel mode and we are not</span>
01976     <span class="comment">//  to force a capture.</span>
01977     <span class="comment">//</span>
01978 
01979     <span class="keywordflow">if</span> ((RequestorMode == <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) &amp;&amp; (ForceCapture == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
01980 
01981         <span class="comment">//</span>
01982         <span class="comment">//  We don't need to do any work and can simply</span>
01983         <span class="comment">//  return a pointer to the input array</span>
01984         <span class="comment">//</span>
01985 
01986         (*CapturedArray) = <a class="code" href="../../d6/d2/aug98_2dll32_2getcrd_8c.html#a77">InputArray</a>;
01987 
01988         <span class="keywordflow">return</span> STATUS_SUCCESS;
01989     }
01990 
01991 
01992     <span class="comment">//</span>
01993     <span class="comment">// ---------- For RequestorMode == UserMode ----------------------</span>
01994     <span class="comment">//</span>
01995     <span class="comment">// the algorithm for capturing an SID_AND_ATTRIBUTES array is somewhat</span>
01996     <span class="comment">// convoluted to avoid problems that could occur if the data is</span>
01997     <span class="comment">// being changed while being captured.</span>
01998     <span class="comment">//</span>
01999     <span class="comment">// The algorithm uses two loops.</span>
02000     <span class="comment">//</span>
02001     <span class="comment">//    Allocate a temporary buffer to house the fixed length data.</span>
02002     <span class="comment">//</span>
02003     <span class="comment">//    1st loop:</span>
02004     <span class="comment">//          For each SID:</span>
02005     <span class="comment">//              Capture the Pointers to the SID and the length of the SID.</span>
02006     <span class="comment">//</span>
02007     <span class="comment">//    Allocate a buffer large enough to hold all of the data.</span>
02008     <span class="comment">//</span>
02009     <span class="comment">//    2nd loop:</span>
02010     <span class="comment">//          For each SID:</span>
02011     <span class="comment">//               Capture the Attributes.</span>
02012     <span class="comment">//               Capture the SID.</span>
02013     <span class="comment">//               Set the pointer to the SID.</span>
02014     <span class="comment">//</span>
02015     <span class="comment">//    Deallocate temporary buffer.</span>
02016     <span class="comment">//</span>
02017     <span class="comment">// ------------ For RequestorMode == KernelMode --------------------</span>
02018     <span class="comment">//</span>
02019     <span class="comment">// There is no need to capture the length and address of the SIDs</span>
02020     <span class="comment">// in the first loop (since the kernel can be trusted not to change</span>
02021     <span class="comment">// them while they are being copied.)  So for kernel mode, the first</span>
02022     <span class="comment">// loop just adds up the length needed.  Kernel mode, thus, avoids</span>
02023     <span class="comment">// having to allocate a temporary buffer.</span>
02024     <span class="comment">//</span>
02025 
02026     <span class="comment">//</span>
02027     <span class="comment">// Get the length needed to hold the array elements.</span>
02028     <span class="comment">//</span>
02029 
02030     ArraySize = ArrayCount * (ULONG)<span class="keyword">sizeof</span>(SID_AND_ATTRIBUTES);
02031     AlignedLengthRequired = (ULONG)LongAlignSize( ArraySize );
02032 
02033     <span class="keywordflow">if</span> (RequestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
02034 
02035         <span class="comment">//</span>
02036         <span class="comment">// Allocate a temporary array to capture the array elements into</span>
02037         <span class="comment">//</span>
02038 
02039         TempArray =
02040             (TEMP_ARRAY_ELEMENT *)<a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(PoolType, AlignedLengthRequired, 'aTeS');
02041 
02042         <span class="keywordflow">if</span> ( TempArray == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
02043             <span class="keywordflow">return</span>( STATUS_INSUFFICIENT_RESOURCES );
02044         }
02045 
02046 
02047         <span class="keywordflow">try</span> {
02048 
02049             <span class="comment">//</span>
02050             <span class="comment">// Make sure we can read each SID_AND_ATTRIBUTE</span>
02051             <span class="comment">//</span>
02052 
02053             <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( <a class="code" href="../../d6/d2/aug98_2dll32_2getcrd_8c.html#a77">InputArray</a>,
02054                           ArraySize,
02055                           <span class="keyword">sizeof</span>(ULONG) );
02056 
02057             <span class="comment">//</span>
02058             <span class="comment">// Probe and capture the length and address of each SID</span>
02059             <span class="comment">//</span>
02060 
02061             NextIndex = 0;
02062             <span class="keywordflow">while</span> (NextIndex &lt; ArrayCount) {
02063                 PSID TempSid;
02064 
02065                 TempSid = <a class="code" href="../../d6/d2/aug98_2dll32_2getcrd_8c.html#a77">InputArray</a>[NextIndex].Sid;
02066                 GetSidSubAuthorityCount =
02067                     <a class="code" href="../../d5/d8/ex_8h.html#a14">ProbeAndReadUchar</a>( &amp;((PISID)TempSid)-&gt;SubAuthorityCount);
02068 
02069                 <span class="keywordflow">if</span> (GetSidSubAuthorityCount &gt; SID_MAX_SUB_AUTHORITIES) {
02070                     CompletionStatus = STATUS_INVALID_SID;
02071                     <span class="keywordflow">break</span>;
02072                 }
02073 
02074                 TempArray[NextIndex].Sid = ((PISID)(TempSid));
02075                 TempArray[NextIndex].SidLength =
02076                     <a class="code" href="../../d8/d6/sertl_8c.html#a38">RtlLengthRequiredSid</a>( GetSidSubAuthorityCount );
02077 
02078                 <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( TempArray[NextIndex].Sid,
02079                               TempArray[NextIndex].SidLength,
02080                               <span class="keyword">sizeof</span>(ULONG) );
02081 
02082                 AlignedLengthRequired +=
02083                     (ULONG)LongAlignSize( TempArray[NextIndex].SidLength );
02084 
02085                 NextIndex += 1;
02086 
02087             }  <span class="comment">//end while</span>
02088 
02089         } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
02090 
02091             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( TempArray );
02092             <span class="keywordflow">return</span> GetExceptionCode();
02093         }
02094 
02095         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(CompletionStatus)) {
02096             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( TempArray );
02097             <span class="keywordflow">return</span>(CompletionStatus);
02098         }
02099 
02100     } <span class="keywordflow">else</span> {
02101 
02102         <span class="comment">//</span>
02103         <span class="comment">// No need to capture anything.</span>
02104         <span class="comment">// But, we do need to add up the lengths of the SIDs</span>
02105         <span class="comment">// so we can allocate a buffer (or check the size of one provided).</span>
02106         <span class="comment">//</span>
02107 
02108         NextIndex = 0;
02109 
02110         <span class="keywordflow">while</span> (NextIndex &lt; ArrayCount) {
02111 
02112             GetSidSubAuthorityCount =
02113                 ((PISID)(<a class="code" href="../../d6/d2/aug98_2dll32_2getcrd_8c.html#a77">InputArray</a>[NextIndex].Sid))-&gt;SubAuthorityCount;
02114 
02115             AlignedLengthRequired +=
02116                 (ULONG)LongAlignSize(<a class="code" href="../../d8/d6/sertl_8c.html#a38">RtlLengthRequiredSid</a>(GetSidSubAuthorityCount));
02117 
02118             NextIndex += 1;
02119 
02120         }  <span class="comment">//end while</span>
02121 
02122     }
02123 
02124 
02125     <span class="comment">//</span>
02126     <span class="comment">// Now we know how much memory we need.</span>
02127     <span class="comment">// Return this value in the output parameter.</span>
02128     <span class="comment">//</span>
02129 
02130     (*AlignedArraySize) = AlignedLengthRequired;
02131 
02132     <span class="comment">//</span>
02133     <span class="comment">// If a buffer was provided, make sure it is long enough.</span>
02134     <span class="comment">// Otherwise, allocate a buffer.</span>
02135     <span class="comment">//</span>
02136 
02137     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(CaptureBuffer)) {
02138 
02139         <span class="keywordflow">if</span> (AlignedLengthRequired &gt; CaptureBufferLength) {
02140 
02141             <span class="keywordflow">if</span> (RequestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
02142                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( TempArray );
02143             }
02144 
02145             <span class="keywordflow">return</span> STATUS_BUFFER_TOO_SMALL;
02146 
02147         } <span class="keywordflow">else</span> {
02148 
02149             (*CapturedArray) = CaptureBuffer;
02150         }
02151 
02152     } <span class="keywordflow">else</span> {
02153 
02154         (*CapturedArray) =
02155             (PSID_AND_ATTRIBUTES)<a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(PoolType, AlignedLengthRequired, 'aSeS');
02156 
02157         <span class="keywordflow">if</span> ( *CapturedArray == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
02158                 <span class="keywordflow">if</span> (RequestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
02159                     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( TempArray );
02160                 }
02161             <span class="keywordflow">return</span>( STATUS_INSUFFICIENT_RESOURCES );
02162         }
02163     }
02164 
02165 
02166     <span class="comment">//</span>
02167     <span class="comment">// Now copy everything.</span>
02168     <span class="comment">// This is done by copying all the SID_AND_ATTRIBUTES and then</span>
02169     <span class="comment">// copying each individual SID.</span>
02170     <span class="comment">//</span>
02171     <span class="comment">// All SIDs have already been probed for READ access.  We just</span>
02172     <span class="comment">// need to copy them.</span>
02173     <span class="comment">//</span>
02174     <span class="comment">//</span>
02175 
02176     <span class="keywordflow">if</span> (RequestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
02177         <span class="keywordflow">try</span> {
02178 
02179             <span class="comment">//</span>
02180             <span class="comment">//  Copy the SID_AND_ATTRIBUTES array elements</span>
02181             <span class="comment">//  This really only sets the attributes, since we</span>
02182             <span class="comment">//  over-write the SID pointer field later on.</span>
02183             <span class="comment">//</span>
02184 
02185             NextBufferLocation = (*CapturedArray);
02186             RtlMoveMemory( NextBufferLocation, <a class="code" href="../../d6/d2/aug98_2dll32_2getcrd_8c.html#a77">InputArray</a>, ArraySize );
02187             NextBufferLocation = (PVOID)((ULONG_PTR)NextBufferLocation +
02188                                          (ULONG)LongAlignSize(ArraySize) );
02189 
02190             <span class="comment">//</span>
02191             <span class="comment">//  Now go through and copy each referenced SID.</span>
02192             <span class="comment">//  Validate each SID as it is copied.</span>
02193             <span class="comment">//</span>
02194 
02195             NextIndex = 0;
02196             NextElement = (*CapturedArray);
02197             <span class="keywordflow">while</span> (  (NextIndex &lt; ArrayCount) &amp;&amp;
02198                      (CompletionStatus == STATUS_SUCCESS) ) {
02199 
02200 
02201                 RtlMoveMemory( NextBufferLocation,
02202                     TempArray[NextIndex].Sid,
02203                     TempArray[NextIndex].SidLength );
02204 
02205 
02206                 NextElement[NextIndex].Sid = (PSID)NextBufferLocation;
02207                 NextBufferLocation =
02208                     (PVOID)((ULONG_PTR)NextBufferLocation +
02209                             (ULONG)LongAlignSize(TempArray[NextIndex].SidLength));
02210 
02211                 <span class="comment">//</span>
02212                 <span class="comment">// Verify the sid is valid and its length didn't change</span>
02213                 <span class="comment">//</span>
02214 
02215                 <span class="keywordflow">if</span> (!<a class="code" href="../../d8/d6/sertl_8c.html#a35">RtlValidSid</a>(NextElement[NextIndex].Sid) ) {
02216                     CompletionStatus = STATUS_INVALID_SID;
02217                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d8/d6/sertl_8c.html#a45">RtlLengthSid</a>(NextElement[NextIndex].Sid) != TempArray[NextIndex].SidLength) {
02218                     CompletionStatus = STATUS_INVALID_SID;
02219                 }
02220 
02221 
02222                 NextIndex += 1;
02223 
02224             }  <span class="comment">//end while</span>
02225 
02226 
02227         } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
02228 
02229             <span class="keywordflow">if</span> (!ARGUMENT_PRESENT(CaptureBuffer)) {
02230                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( (*CapturedArray) );
02231             }
02232 
02233             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( TempArray );
02234 
02235             <span class="keywordflow">return</span> GetExceptionCode();
02236         }
02237     } <span class="keywordflow">else</span> {
02238 
02239         <span class="comment">//</span>
02240         <span class="comment">// Requestor mode is kernel mode -</span>
02241         <span class="comment">// don't need protection, probing, and validating</span>
02242         <span class="comment">//</span>
02243 
02244         <span class="comment">//</span>
02245         <span class="comment">//  Copy the SID_AND_ATTRIBUTES array elements</span>
02246         <span class="comment">//  This really only sets the attributes, since we</span>
02247         <span class="comment">//  over-write the SID pointer field later on.</span>
02248         <span class="comment">//</span>
02249 
02250         NextBufferLocation = (*CapturedArray);
02251         RtlMoveMemory( NextBufferLocation, <a class="code" href="../../d6/d2/aug98_2dll32_2getcrd_8c.html#a77">InputArray</a>, ArraySize );
02252         NextBufferLocation = (PVOID)( (ULONG_PTR)NextBufferLocation +
02253                                       (ULONG)LongAlignSize(ArraySize));
02254 
02255         <span class="comment">//</span>
02256         <span class="comment">//  Now go through and copy each referenced SID</span>
02257         <span class="comment">//</span>
02258 
02259         NextIndex = 0;
02260         NextElement = (*CapturedArray);
02261         <span class="keywordflow">while</span> (NextIndex &lt; ArrayCount) {
02262 
02263             GetSidSubAuthorityCount =
02264                 ((PISID)(NextElement[NextIndex].Sid))-&gt;SubAuthorityCount;
02265 
02266             RtlMoveMemory(
02267                 NextBufferLocation,
02268                 NextElement[NextIndex].Sid,
02269                 <a class="code" href="../../d8/d6/sertl_8c.html#a38">RtlLengthRequiredSid</a>(GetSidSubAuthorityCount) );
02270                 SidSize = <a class="code" href="../../d8/d6/sertl_8c.html#a38">RtlLengthRequiredSid</a>( GetSidSubAuthorityCount );
02271                 AlignedSidSize = (ULONG)LongAlignSize(SidSize);
02272 
02273             NextElement[NextIndex].Sid = (PSID)NextBufferLocation;
02274 
02275             NextIndex += 1;
02276             NextBufferLocation = (PVOID)((ULONG_PTR)NextBufferLocation +
02277                                                    AlignedSidSize);
02278 
02279         }  <span class="comment">//end while</span>
02280 
02281     }
02282 
02283     <span class="keywordflow">if</span> (RequestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
02284         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( TempArray );
02285     }
02286 
02287     <span class="keywordflow">if</span> (!ARGUMENT_PRESENT(CaptureBuffer) &amp;&amp; !<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(CompletionStatus)) {
02288         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( (*CapturedArray) );
02289         *CapturedArray = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ;
02290     }
02291 
02292     <span class="keywordflow">return</span> CompletionStatus;
02293 }
02294 
02295 
02296 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02297"></a><a class="code" href="../../d2/d5/se_2capture_8c.html#a15">02297</a> <a class="code" href="../../d2/d5/se_2capture_8c.html#a15">SeReleaseSidAndAttributesArray</a> (
02298     IN PSID_AND_ATTRIBUTES CapturedArray,
02299     IN KPROCESSOR_MODE RequestorMode,
02300     IN BOOLEAN ForceCapture
02301     )
02302 
02303 <span class="comment">/*++</span>
02304 <span class="comment"></span>
02305 <span class="comment">Routine Description:</span>
02306 <span class="comment"></span>
02307 <span class="comment">    This routine releases a previously captured array of SID_AND_ATTRIBUTES.</span>
02308 <span class="comment"></span>
02309 <span class="comment">    This routine should NOT be called if the array was captured into a</span>
02310 <span class="comment">    provided CaptureBuffer (see SeCaptureSidAndAttributesArray).</span>
02311 <span class="comment"></span>
02312 <span class="comment">Arguments:</span>
02313 <span class="comment"></span>
02314 <span class="comment">    CapturedArray - Supplies the array to release.</span>
02315 <span class="comment"></span>
02316 <span class="comment">    RequestorMode - The processor mode specified when the array was captured.</span>
02317 <span class="comment"></span>
02318 <span class="comment">    ForceCapture - The ForceCapture value specified when the array was</span>
02319 <span class="comment">        captured.</span>
02320 <span class="comment"></span>
02321 <span class="comment">Return Value:</span>
02322 <span class="comment"></span>
02323 <span class="comment">    None.</span>
02324 <span class="comment"></span>
02325 <span class="comment">--*/</span>
02326 
02327 {
02328     <span class="comment">//</span>
02329     <span class="comment">// We only have something to deallocate if the requestor was user</span>
02330     <span class="comment">// mode or kernel mode requesting ForceCapture.</span>
02331     <span class="comment">//</span>
02332 
02333     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02334 
02335     <span class="keywordflow">if</span> ( ((RequestorMode == <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) &amp;&amp; (ForceCapture == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>)) ||
02336           (RequestorMode == <a class="code" href="../../d0/d9/ntosdef_8h.html#a76a70">UserMode</a> ) ) {
02337 
02338         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(CapturedArray);
02339 
02340     }
02341 
02342     <span class="keywordflow">return</span>;
02343 
02344 }
02345 
02346 
02347 
02348 
02349 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l02350"></a><a class="code" href="../../d2/d5/se_2capture_8c.html#a16">02350</a> <a class="code" href="../../d2/d5/se_2capture_8c.html#a16">SeComputeQuotaInformationSize</a>(
02351     IN PSECURITY_DESCRIPTOR SecurityDescriptor,
02352     OUT PULONG Size
02353     )
02354 
02355 <span class="comment">/*++</span>
02356 <span class="comment"></span>
02357 <span class="comment">Routine Description:</span>
02358 <span class="comment"></span>
02359 <span class="comment">    This routine computes the size of the Group and DACL for the</span>
02360 <span class="comment">    passed security descriptor.</span>
02361 <span class="comment"></span>
02362 <span class="comment">    This quantity will later be used in calculating the amount</span>
02363 <span class="comment">    of quota to charge for this object.</span>
02364 <span class="comment"></span>
02365 <span class="comment">Arguments:</span>
02366 <span class="comment"></span>
02367 <span class="comment">    SecurityDescriptor - Supplies a pointer to the security descriptor</span>
02368 <span class="comment">        to be examined.</span>
02369 <span class="comment"></span>
02370 <span class="comment">    Size - Returns the size in bytes of the sum of the Group and Dacl</span>
02371 <span class="comment">        fields of the security descriptor.</span>
02372 <span class="comment"></span>
02373 <span class="comment">Return Value:</span>
02374 <span class="comment"></span>
02375 <span class="comment">    STATUS_SUCCESS - The operation was successful.</span>
02376 <span class="comment"></span>
02377 <span class="comment">    STATUS_INVALID_REVISION - The passed security descriptor was of</span>
02378 <span class="comment">        an unknown revision.</span>
02379 <span class="comment"></span>
02380 <span class="comment">--*/</span>
02381 
02382 {
02383     PISECURITY_DESCRIPTOR ISecurityDescriptor;
02384 
02385     PSID <a class="code" href="../../d6/d0/ctaccess_8c.html#a54">Group</a>;
02386     PACL <a class="code" href="../../d6/d0/ctaccess_8c.html#a55">Dacl</a>;
02387 
02388     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02389 
02390     ISecurityDescriptor = (PISECURITY_DESCRIPTOR)SecurityDescriptor;
02391     *<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> = 0;
02392 
02393     <span class="keywordflow">if</span> (ISecurityDescriptor-&gt;Revision != SECURITY_DESCRIPTOR_REVISION) {
02394         <span class="keywordflow">return</span>( STATUS_UNKNOWN_REVISION );
02395     }
02396 
02397     <a class="code" href="../../d6/d0/ctaccess_8c.html#a54">Group</a> = RtlpGroupAddrSecurityDescriptor( ISecurityDescriptor );
02398 
02399     <a class="code" href="../../d6/d0/ctaccess_8c.html#a55">Dacl</a> = RtlpDaclAddrSecurityDescriptor( ISecurityDescriptor );
02400 
02401     <span class="keywordflow">if</span> (<a class="code" href="../../d6/d0/ctaccess_8c.html#a54">Group</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02402         *<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> += (ULONG)LongAlignSize(<a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>( <a class="code" href="../../d6/d0/ctaccess_8c.html#a54">Group</a> ));
02403     }
02404 
02405     <span class="keywordflow">if</span> (<a class="code" href="../../d6/d0/ctaccess_8c.html#a55">Dacl</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02406         *<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> += (ULONG)LongAlignSize(<a class="code" href="../../d6/d0/ctaccess_8c.html#a55">Dacl</a>-&gt;AclSize);
02407     }
02408 
02409     <span class="keywordflow">return</span>( STATUS_SUCCESS );
02410 }
02411 
02412 
02413 BOOLEAN
<a name="l02414"></a><a class="code" href="../../d2/d5/se_2capture_8c.html#a17">02414</a> <a class="code" href="../../d2/d5/se_2capture_8c.html#a17">SeValidSecurityDescriptor</a>(
02415     IN ULONG Length,
02416     IN PSECURITY_DESCRIPTOR SecurityDescriptor
02417     )
02418 
02419 <span class="comment">/*++</span>
02420 <span class="comment"></span>
02421 <span class="comment">Routine Description:</span>
02422 <span class="comment"></span>
02423 <span class="comment">    Validates a security descriptor for structural correctness.  The idea is to make</span>
02424 <span class="comment">    sure that the security descriptor may be passed to other kernel callers, without</span>
02425 <span class="comment">    fear that they're going to choke while manipulating it.</span>
02426 <span class="comment"></span>
02427 <span class="comment">    This routine does not enforce policy (e.g., ACL/ACE revision information).  It is</span>
02428 <span class="comment">    entirely possible for a security descriptor to be approved by this routine, only</span>
02429 <span class="comment">    to be later found to be invalid by some later routine.</span>
02430 <span class="comment"></span>
02431 <span class="comment">    This routine is designed to be used by callers who have a security descriptor in</span>
02432 <span class="comment">    kernel memory.  Callers wishing to validate a security descriptor passed from user</span>
02433 <span class="comment">    mode should call RtlValidSecurityDescriptor.</span>
02434 <span class="comment"></span>
02435 <span class="comment">Arguments:</span>
02436 <span class="comment"></span>
02437 <span class="comment">    Length - Length in bytes of passed Security Descriptor.</span>
02438 <span class="comment"></span>
02439 <span class="comment">    SecurityDescriptor - Points to the Security Descriptor (in kernel memory) to be</span>
02440 <span class="comment">        validatated.</span>
02441 <span class="comment"></span>
02442 <span class="comment">Return Value:</span>
02443 <span class="comment"></span>
02444 <span class="comment">    TRUE - The passed security descriptor is correctly structured</span>
02445 <span class="comment">    FALSE - The passed security descriptor is badly formed</span>
02446 <span class="comment"></span>
02447 <span class="comment">--*/</span>
02448 
02449 {
02450     PISECURITY_DESCRIPTOR_RELATIVE ISecurityDescriptor =
02451         (PISECURITY_DESCRIPTOR_RELATIVE)SecurityDescriptor;
02452     PISID OwnerSid;
02453     PISID GroupSid;
02454     PACE_HEADER Ace;
02455     PISID Sid;
02456     PISID Sid2;
02457     PACL <a class="code" href="../../d6/d0/ctaccess_8c.html#a55">Dacl</a>;
02458     PACL Sacl;
02459     ULONG i;
02460 
02461     <span class="keywordflow">if</span> (Length &lt; <span class="keyword">sizeof</span>(SECURITY_DESCRIPTOR_RELATIVE)) {
02462         <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
02463     }
02464 
02465     <span class="comment">//</span>
02466     <span class="comment">// Check the revision information.</span>
02467     <span class="comment">//</span>
02468 
02469     <span class="keywordflow">if</span> (ISecurityDescriptor-&gt;Revision != SECURITY_DESCRIPTOR_REVISION) {
02470         <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
02471     }
02472 
02473     <span class="comment">//</span>
02474     <span class="comment">// Make sure the passed SecurityDescriptor is in self-relative form</span>
02475     <span class="comment">//</span>
02476 
02477     <span class="keywordflow">if</span> (!(ISecurityDescriptor-&gt;Control &amp; SE_SELF_RELATIVE)) {
02478         <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
02479     }
02480 
02481     <span class="comment">//</span>
02482     <span class="comment">// Check the owner.  A valid SecurityDescriptor must have an owner.</span>
02483     <span class="comment">// It must also be long aligned.</span>
02484     <span class="comment">//</span>
02485 
02486     <span class="keywordflow">if</span> ((ISecurityDescriptor-&gt;Owner == 0) ||
02487         (!<a class="code" href="../../d2/d4/acledit_8c.html#a2">LongAligned</a>((PVOID)(ULONG_PTR)(ULONG)ISecurityDescriptor-&gt;Owner)) ||
02488         (ISecurityDescriptor-&gt;Owner &gt; Length) ||
02489         (Length - ISecurityDescriptor-&gt;Owner &lt; <span class="keyword">sizeof</span>(SID))) {
02490 
02491         <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
02492     }
02493 
02494     <span class="comment">//</span>
02495     <span class="comment">// It is safe to reference the owner's SubAuthorityCount, compute the</span>
02496     <span class="comment">// expected length of the SID</span>
02497     <span class="comment">//</span>
02498 
02499     OwnerSid = (PSID)RtlOffsetToPointer( ISecurityDescriptor, ISecurityDescriptor-&gt;Owner );
02500 
02501     <span class="keywordflow">if</span> (OwnerSid-&gt;Revision != SID_REVISION) {
02502         <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
02503     }
02504 
02505     <span class="keywordflow">if</span> (OwnerSid-&gt;SubAuthorityCount &gt; SID_MAX_SUB_AUTHORITIES) {
02506         <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
02507     }
02508 
02509     <span class="keywordflow">if</span> (Length - ISecurityDescriptor-&gt;Owner &lt; (ULONG) <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(OwnerSid)) {
02510         <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
02511     }
02512 
02513     <span class="comment">//</span>
02514     <span class="comment">// The owner appears to be a structurally valid SID that lies within</span>
02515     <span class="comment">// the bounds of the security descriptor.  Do the same for the Group</span>
02516     <span class="comment">// if there is one.</span>
02517     <span class="comment">//</span>
02518 
02519     <span class="keywordflow">if</span> (ISecurityDescriptor-&gt;Group != 0) {
02520 
02521         <span class="comment">//</span>
02522         <span class="comment">// Check alignment</span>
02523         <span class="comment">//</span>
02524 
02525         <span class="keywordflow">if</span> (!<a class="code" href="../../d2/d4/acledit_8c.html#a2">LongAligned</a>( (PVOID)(ULONG_PTR)(ULONG)ISecurityDescriptor-&gt;Group)) {
02526             <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
02527         }
02528 
02529         <span class="keywordflow">if</span> (ISecurityDescriptor-&gt;Group &gt; Length) {
02530             <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
02531         }
02532 
02533         <span class="keywordflow">if</span> (Length - ISecurityDescriptor-&gt;Group &lt; <span class="keyword">sizeof</span> (SID)) {
02534             <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
02535         }
02536 
02537         <span class="comment">//</span>
02538         <span class="comment">// It is safe to reference the Group's SubAuthorityCount, compute the</span>
02539         <span class="comment">// expected length of the SID</span>
02540         <span class="comment">//</span>
02541 
02542         GroupSid = (PSID)RtlOffsetToPointer( ISecurityDescriptor, ISecurityDescriptor-&gt;Group );
02543 
02544         <span class="keywordflow">if</span> (GroupSid-&gt;Revision != SID_REVISION) {
02545             <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
02546         }
02547 
02548         <span class="keywordflow">if</span> (GroupSid-&gt;SubAuthorityCount &gt; SID_MAX_SUB_AUTHORITIES) {
02549             <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
02550         }
02551 
02552         <span class="keywordflow">if</span> (Length - ISecurityDescriptor-&gt;Group &lt; (ULONG) <a class="code" href="../../d0/d5/se_8h.html#a10">SeLengthSid</a>(GroupSid)) {
02553             <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
02554         }
02555     }
02556 
02557     <span class="comment">//</span>
02558     <span class="comment">// Validate the DACL.  A structurally valid SecurityDescriptor may not necessarily</span>
02559     <span class="comment">// have a DACL.</span>
02560     <span class="comment">//</span>
02561 
02562     <span class="keywordflow">if</span> (ISecurityDescriptor-&gt;Dacl != 0) {
02563 
02564         <span class="comment">//</span>
02565         <span class="comment">// Check alignment</span>
02566         <span class="comment">//</span>
02567 
02568         <span class="keywordflow">if</span> (!<a class="code" href="../../d2/d4/acledit_8c.html#a2">LongAligned</a>( (PVOID)(ULONG_PTR)(ULONG)ISecurityDescriptor-&gt;Dacl)) {
02569             <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
02570         }
02571 
02572         <span class="comment">//</span>
02573         <span class="comment">// Make sure the DACL structure is within the bounds of the security descriptor.</span>
02574         <span class="comment">//</span>
02575 
02576         <span class="keywordflow">if</span> ((ISecurityDescriptor-&gt;Dacl &gt; Length) ||
02577             (Length - ISecurityDescriptor-&gt;Dacl &lt; <span class="keyword">sizeof</span>(ACL))) {
02578             <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
02579         }
02580 
02581         <a class="code" href="../../d6/d0/ctaccess_8c.html#a55">Dacl</a> = (PACL) RtlOffsetToPointer( ISecurityDescriptor, ISecurityDescriptor-&gt;Dacl );
02582 
02583 
02584         <span class="comment">//</span>
02585         <span class="comment">// Make sure the DACL length fits within the bounds of the security descriptor.</span>
02586         <span class="comment">//</span>
02587 
02588         <span class="keywordflow">if</span> (Length - ISecurityDescriptor-&gt;Dacl &lt; <a class="code" href="../../d6/d0/ctaccess_8c.html#a55">Dacl</a>-&gt;AclSize) {
02589             <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
02590         }
02591 
02592         <span class="comment">//</span>
02593         <span class="comment">// Make sure the ACL is structurally valid.</span>
02594         <span class="comment">//</span>
02595 
02596         <span class="keywordflow">if</span> (!<a class="code" href="../../d2/d4/acledit_8c.html#a7">RtlValidAcl</a>( <a class="code" href="../../d6/d0/ctaccess_8c.html#a55">Dacl</a> )) {
02597             <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
02598         }
02599     }
02600 
02601     <span class="comment">//</span>
02602     <span class="comment">// Validate the SACL.  A structurally valid SecurityDescriptor may not</span>
02603     <span class="comment">// have a SACL.</span>
02604     <span class="comment">//</span>
02605 
02606     <span class="keywordflow">if</span> (ISecurityDescriptor-&gt;Sacl != 0) {
02607 
02608         <span class="comment">//</span>
02609         <span class="comment">// Check alignment</span>
02610         <span class="comment">//</span>
02611 
02612         <span class="keywordflow">if</span> (!<a class="code" href="../../d2/d4/acledit_8c.html#a2">LongAligned</a>( (PVOID)(ULONG_PTR)(ULONG)ISecurityDescriptor-&gt;Sacl)) {
02613             <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
02614         }
02615 
02616         <span class="comment">//</span>
02617         <span class="comment">// Make sure the SACL structure is within the bounds of the security descriptor.</span>
02618         <span class="comment">//</span>
02619 
02620         <span class="keywordflow">if</span> ((ISecurityDescriptor-&gt;Sacl &gt; Length) ||
02621             (Length - ISecurityDescriptor-&gt;Sacl &lt; <span class="keyword">sizeof</span>(ACL))) {
02622             <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
02623         }
02624 
02625         <span class="comment">//</span>
02626         <span class="comment">// Make sure the Sacl structure is within the bounds of the security descriptor.</span>
02627         <span class="comment">//</span>
02628 
02629         Sacl = (PACL)RtlOffsetToPointer( ISecurityDescriptor, ISecurityDescriptor-&gt;Sacl );
02630 
02631 
02632         <span class="keywordflow">if</span> (Length - ISecurityDescriptor-&gt;Sacl &lt; Sacl-&gt;AclSize) {
02633             <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
02634         }
02635 
02636         <span class="comment">//</span>
02637         <span class="comment">// Make sure the ACL is structurally valid.</span>
02638         <span class="comment">//</span>
02639 
02640         <span class="keywordflow">if</span> (!<a class="code" href="../../d2/d4/acledit_8c.html#a7">RtlValidAcl</a>( Sacl )) {
02641             <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
02642         }
02643     }
02644 
02645     <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
02646 }
02647 
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:39:21 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
