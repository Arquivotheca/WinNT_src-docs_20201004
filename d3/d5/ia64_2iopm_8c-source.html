<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: iopm.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>iopm.c</h1><a href="../../d2/d6/ia64_2iopm_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1991  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    iopm.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module implements interfaces that support manipulation of i386</span>
00012 <span class="comment">    i/o access maps (IOPMs).</span>
00013 <span class="comment"></span>
00014 <span class="comment">    These entry points only exist on i386 and IA64 machines.</span>
00015 <span class="comment"></span>
00016 <span class="comment">Author:</span>
00017 <span class="comment"></span>
00018 <span class="comment">    Bryan M. Willman (bryanwi) 18-Sep-91</span>
00019 <span class="comment"></span>
00020 <span class="comment">Environment:</span>
00021 <span class="comment"></span>
00022 <span class="comment">    Kernel mode only.</span>
00023 <span class="comment"></span>
00024 <span class="comment">Revision History:</span>
00025 <span class="comment"></span>
00026 <span class="comment">    Charles Spirakis (intel): 25 Jul 1996 - Don't have TSS anymore,</span>
00027 <span class="comment">        so don't need TSS handling or any synchronization of the TSS.</span>
00028 <span class="comment"></span>
00029 <span class="comment">--*/</span>
00030 
00031 <span class="preprocessor">#include "<a class="code" href="../../d0/d0/ki_8h.html">ki.h</a>"</span>
00032 
00033 BOOLEAN <a class="code" href="../../d2/d6/ia64_2iopm_8c.html#a1">KiIA32SetPortMemory</a>(<a class="code" href="../../d5/d7/struct__KPROCESS.html">PKPROCESS</a> Process);
00034 
00035 <span class="comment">//</span>
00036 <span class="comment">// For IA64, only need to worry about synchronization for SetIoAccessMap</span>
00037 <span class="comment">// since there is no longer a TSS and no worry about partial TSS states</span>
00038 <span class="comment">// (and no need for any IPI's to do updates...)</span>
00039 <span class="comment">//</span>
00040 
00041 <span class="comment">//</span>
00042 <span class="comment">// Holds all of the possible IO maps (currently 1)</span>
00043 <span class="comment">//</span>
<a name="l00044"></a><a class="code" href="../../d2/d6/ia64_2iopm_8c.html#a0">00044</a> <span class="keyword">static</span> PKIO_ACCESS_MAP <a class="code" href="../../d2/d6/ia64_2iopm_8c.html#a0">VdmIoMaps</a>[IOPM_COUNT];
00045 
00046 
00047 BOOLEAN
<a name="l00048"></a><a class="code" href="../../d2/d6/ia64_2iopm_8c.html#a2">00048</a> <a class="code" href="../../d2/d6/ia64_2iopm_8c.html#a2">KeIA32SetIoAccessMap</a> (
00049     ULONG MapNumber,
00050     PKIO_ACCESS_MAP IoAccessMap
00051     )
00052 
00053 <span class="comment">/*++</span>
00054 <span class="comment"></span>
00055 <span class="comment">Routine Description:</span>
00056 <span class="comment"></span>
00057 <span class="comment">    The specified i/o access map will be set to match the</span>
00058 <span class="comment">    definition specified by IoAccessMap (i.e. enable/disable</span>
00059 <span class="comment">    those ports) before the call returns.  The change will take</span>
00060 <span class="comment">    effect on all processors.</span>
00061 <span class="comment"></span>
00062 <span class="comment">    KeIA32SetIoAccessMap does not give any process enhanced I/O</span>
00063 <span class="comment">    access, it merely defines a particular access map.</span>
00064 <span class="comment"></span>
00065 <span class="comment">Arguments:</span>
00066 <span class="comment"></span>
00067 <span class="comment">    MapNumber - Number of access map to set.  Map 0 is fixed.</span>
00068 <span class="comment"></span>
00069 <span class="comment">    IoAccessMap - Pointer to bitvector (64K bits, 8K bytes) which</span>
00070 <span class="comment">           defines the specified access map.  Must be in</span>
00071 <span class="comment">           non-paged pool.</span>
00072 <span class="comment"></span>
00073 <span class="comment">Return Value:</span>
00074 <span class="comment"></span>
00075 <span class="comment">    TRUE if successful.  FALSE if failure (attempt to set a map</span>
00076 <span class="comment">    which does not exist, attempt to set map 0)</span>
00077 <span class="comment"></span>
00078 <span class="comment">--*/</span>
00079 
00080 {
00081 
00082     <a class="code" href="../../d5/d7/struct__KPROCESS.html">PKPROCESS</a> CurrentProcess;
00083     KIRQL OldIrql;
00084     PVOID pt;
00085     PUCHAR p;
00086     ULONG i;
00087     BOOLEAN res;
00088 
00089     <span class="comment">//</span>
00090     <span class="comment">// Reject illegal requests</span>
00091     <span class="comment">//</span>
00092 
00093     <span class="keywordflow">if</span> ((MapNumber &gt; IOPM_COUNT) || (MapNumber == IO_ACCESS_MAP_NONE)) {
00094         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00095     }
00096 
00097     <span class="comment">//</span>
00098     <span class="comment">// If the map N hasn't been allocated, then allocate it now.</span>
00099     <span class="comment">// Don't need to ever free this since it is a system wide</span>
00100     <span class="comment">// resource... Once allocated, stays till reboot.</span>
00101     <span class="comment">// This implies we might want to allocate it early, but we can</span>
00102     <span class="comment">// deal with that later...</span>
00103     <span class="comment">//</span>
00104 
00105     <span class="keywordflow">if</span> (<a class="code" href="../../d2/d6/ia64_2iopm_8c.html#a0">VdmIoMaps</a>[MapNumber - 1] == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00106         <span class="comment">// Allocate a little extra to handle wrap-around...</span>
00107         p = (PUCHAR) <a class="code" href="../../d5/d5/cc_8h.html#a10">ExAllocatePool</a>(<a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, PIOPM_SIZE);
00108         <span class="keywordflow">if</span> (p == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00109             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00110         }
00111 
00112         <span class="comment">//</span>
00113         <span class="comment">// And set it all to "no-access"</span>
00114                 <span class="comment">// (and don't forget the little extra)</span>
00115         <span class="comment">//</span>
00116                 RtlFillMemory((PVOID) p, PIOPM_SIZE, 0x0ff);
00117 
00118         <a class="code" href="../../d2/d6/ia64_2iopm_8c.html#a0">VdmIoMaps</a>[MapNumber - 1] = p;
00119     }
00120 
00121     <span class="comment">//</span>
00122     <span class="comment">// Acquire the context swap lock so a context switch will not occur.</span>
00123     <span class="comment">//</span>
00124     <span class="comment">// BUGBUG: Is this really needed?</span>
00125     <span class="comment">//</span>
00126 
00127     <a class="code" href="../../d0/d0/ki_8h.html#a11">KiLockContextSwap</a>(&amp;OldIrql);
00128 
00129     <span class="comment">//</span>
00130     <span class="comment">// Copy the IOPM map and load the map for the current process.</span>
00131     <span class="comment">//</span>
00132 
00133     pt = <a class="code" href="../../d2/d6/ia64_2iopm_8c.html#a0">VdmIoMaps</a>[MapNumber-1];
00134     RtlMoveMemory(pt, (PVOID)IoAccessMap, IOPM_SIZE);
00135     CurrentProcess = <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>();
00136 
00137     CurrentProcess-&gt;IOCurMap = MapNumber;
00138 
00139         <span class="comment">//</span>
00140         <span class="comment">// BUGBUG: Need to set the EFLAGS.iopl to 3 for this process</span>
00141         <span class="comment">// and all threads in the process as well?</span>
00142         <span class="comment">//</span>
00143 
00144     res = <a class="code" href="../../d2/d6/ia64_2iopm_8c.html#a1">KiIA32SetPortMemory</a>(CurrentProcess);
00145 
00146     <span class="comment">//</span>
00147     <span class="comment">// Restore IRQL and unlock the context swap lock.</span>
00148     <span class="comment">//</span>
00149 
00150     <a class="code" href="../../d0/d0/ki_8h.html#a12">KiUnlockContextSwap</a>(OldIrql);
00151     <span class="keywordflow">return</span> res;
00152 }
00153 
00154 
00155 BOOLEAN
<a name="l00156"></a><a class="code" href="../../d2/d6/ia64_2iopm_8c.html#a3">00156</a> <a class="code" href="../../d2/d6/ia64_2iopm_8c.html#a3">KeIA32QueryIoAccessMap</a> (
00157     ULONG MapNumber,
00158     PKIO_ACCESS_MAP IoAccessMap
00159     )
00160 
00161 <span class="comment">/*++</span>
00162 <span class="comment"></span>
00163 <span class="comment">Routine Description:</span>
00164 <span class="comment"></span>
00165 <span class="comment">    The specified i/o access map will be dumped into the buffer.</span>
00166 <span class="comment">    map 0 is a constant, but will be dumped anyway.</span>
00167 <span class="comment"></span>
00168 <span class="comment">Arguments:</span>
00169 <span class="comment"></span>
00170 <span class="comment">    MapNumber - Number of access map to set.  map 0 is fixed.</span>
00171 <span class="comment"></span>
00172 <span class="comment">    IoAccessMap - Pointer to buffer (64K bits, 8K bytes) which</span>
00173 <span class="comment">           is to receive the definition of the access map.</span>
00174 <span class="comment">           Must be in non-paged pool.</span>
00175 <span class="comment"></span>
00176 <span class="comment">Return Value:</span>
00177 <span class="comment"></span>
00178 <span class="comment">    TRUE if successful.  FALSE if failure (attempt to query a map</span>
00179 <span class="comment">    which does not exist)</span>
00180 <span class="comment"></span>
00181 <span class="comment">--*/</span>
00182 
00183 {
00184     PVOID Map;
00185     KIRQL OldIrql;
00186 
00187     <span class="comment">//</span>
00188     <span class="comment">// Reject illegal requests</span>
00189     <span class="comment">//</span>
00190 
00191     <span class="keywordflow">if</span> (MapNumber &gt; IOPM_COUNT) {
00192         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00193     }
00194 
00195     <span class="comment">//</span>
00196     <span class="comment">// BUGBUG: Do we care if a context switch occurs? What if someone</span>
00197     <span class="comment">// else is modifying map N? (just an issue with MP systems...)</span>
00198     <span class="comment">//</span>
00199 
00200     <span class="comment">//</span>
00201     <span class="comment">// Copy out the map</span>
00202     <span class="comment">//</span>
00203 
00204     <span class="keywordflow">if</span> (MapNumber == IO_ACCESS_MAP_NONE) {
00205 
00206         <span class="comment">//</span>
00207         <span class="comment">// no access case, simply return a map of all 1s</span>
00208         <span class="comment">//</span>
00209                 RtlFillMemory((PVOID) IoAccessMap, IOPM_SIZE, 0x0ff);
00210 
00211     } <span class="keywordflow">else</span> {
00212 
00213         <span class="comment">//</span>
00214         <span class="comment">// normal case, just copy the bits</span>
00215         <span class="comment">//</span>
00216 
00217         Map = <a class="code" href="../../d2/d6/ia64_2iopm_8c.html#a0">VdmIoMaps</a>[MapNumber-1];
00218         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Map != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00219         RtlMoveMemory((PVOID)IoAccessMap, Map, IOPM_SIZE);
00220     }
00221 
00222     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00223 }
00224 
00225 
00226 BOOLEAN
<a name="l00227"></a><a class="code" href="../../d2/d6/ia64_2iopm_8c.html#a4">00227</a> <a class="code" href="../../d2/d6/ia64_2iopm_8c.html#a4">KeIA32IoSetAccessProcess</a> (
00228     <a class="code" href="../../d5/d7/struct__KPROCESS.html">PKPROCESS</a> Process,
00229     ULONG MapNumber
00230     )
00231 <span class="comment">/*++</span>
00232 <span class="comment"></span>
00233 <span class="comment">Routine Description:</span>
00234 <span class="comment"></span>
00235 <span class="comment">    Set the i/o access map which controls user mode i/o access</span>
00236 <span class="comment">    for a particular process.</span>
00237 <span class="comment"></span>
00238 <span class="comment">Arguments:</span>
00239 <span class="comment"></span>
00240 <span class="comment">    Process - Pointer to kernel process object describing the</span>
00241 <span class="comment">    process which for which a map is to be set.</span>
00242 <span class="comment"></span>
00243 <span class="comment">    MapNumber - Number of the map to set.  Value of map is</span>
00244 <span class="comment">    defined by KeIA32IoSetAccessProcess.  Setting MapNumber</span>
00245 <span class="comment">    to IO_ACCESS_MAP_NONE will disallow any user mode i/o</span>
00246 <span class="comment">    access from the process.</span>
00247 <span class="comment"></span>
00248 <span class="comment">Return Value:</span>
00249 <span class="comment"></span>
00250 <span class="comment">    TRUE if success, FALSE if failure (illegal MapNumber)</span>
00251 <span class="comment"></span>
00252 <span class="comment">--*/</span>
00253 
00254 {
00255     <span class="comment">//</span>
00256     <span class="comment">// Reject illegal requests</span>
00257     <span class="comment">//</span>
00258 
00259     <span class="keywordflow">if</span> (MapNumber &gt; IOPM_COUNT) {
00260         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00261     }
00262 
00263     <span class="comment">//</span>
00264     <span class="comment">// Store new offset in process object,  compute current set of</span>
00265     <span class="comment">// active processors for process, if this cpu is one, set IOPM.</span>
00266     <span class="comment">//</span>
00267 
00268     Process-&gt;IOCurMap = MapNumber;
00269     <span class="keywordflow">if</span> (Process-&gt;IOCurMap == IO_ACCESS_MAP_NONE) {
00270         <span class="comment">//</span>
00271         <span class="comment">// BUGBUG: Need to set the EFLAGS.iopl back to 0 for this process</span>
00272         <span class="comment">// And all its threads?</span>
00273         <span class="comment">//</span>
00274         }
00275         <span class="keywordflow">else</span> {
00276         <span class="comment">//</span>
00277         <span class="comment">// BUGBUG: Need to set the EFLAGS.iopl to 3 for this process</span>
00278         <span class="comment">// And all its threads?</span>
00279         <span class="comment">//</span>
00280         }
00281 
00282     <span class="keywordflow">return</span> (<a class="code" href="../../d2/d6/ia64_2iopm_8c.html#a1">KiIA32SetPortMemory</a>(Process));
00283 }
00284 
00285 
00286 BOOLEAN
<a name="l00287"></a><a class="code" href="../../d2/d6/ia64_2iopm_8c.html#a5">00287</a> <a class="code" href="../../d2/d6/ia64_2iopm_8c.html#a5">KeIA32PortIsAccessable</a>(
00288     <a class="code" href="../../d5/d7/struct__KPROCESS.html">PKPROCESS</a> Process,
00289     ULONG Port,
00290     ULONG Size
00291     )
00292 <span class="comment">/*++</span>
00293 <span class="comment"></span>
00294 <span class="comment">Routine Description:</span>
00295 <span class="comment"></span>
00296 <span class="comment">    Checks to see if a particular port is accessable by a particular process</span>
00297 <span class="comment"></span>
00298 <span class="comment">Arguments:</span>
00299 <span class="comment"></span>
00300 <span class="comment">    Process - Pointer to kernel process object</span>
00301 <span class="comment"></span>
00302 <span class="comment">    Port - port number to check</span>
00303 <span class="comment"></span>
00304 <span class="comment">    Size - size of access (1, 2 or 4 bytes)</span>
00305 <span class="comment"></span>
00306 <span class="comment">Return Value:</span>
00307 <span class="comment"></span>
00308 <span class="comment">    TRUE if port is accessable, false if port is not</span>
00309 <span class="comment"></span>
00310 <span class="comment">--*/</span>
00311 {
00312     ULONG byte;
00313     ULONG bit;
00314     ULONG val;
00315     ULONG ToTest;
00316     PUCHAR ioBits;
00317 
00318     <span class="keywordflow">if</span> (Process-&gt;IOCurMap == IO_ACCESS_MAP_NONE) {
00319         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00320     }
00321 
00322     <span class="comment">//</span>
00323     <span class="comment">// Make sure everything is legit...</span>
00324     <span class="comment">//</span>
00325     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Process-&gt;IOCurMap &lt;= IOPM_COUNT);
00326     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a> (Port &lt; (64 * 1024));
00327     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> == 1) || (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> == 2) || (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> == 4));
00328 
00329     ioBits = <a class="code" href="../../d2/d6/ia64_2iopm_8c.html#a0">VdmIoMaps</a>[Process-&gt;IOCurMap - 1];
00330 
00331     <span class="comment">//</span>
00332     <span class="comment">// Get the byte to be tested</span>
00333     <span class="comment">//</span>
00334     byte = Port &gt;&gt; 3;
00335 
00336     <span class="comment">//</span>
00337     <span class="comment">// This handles boundary conditions...</span>
00338     <span class="comment">//</span>
00339     ToTest = ioBits[byte] | (ioBits[byte + 1] &lt;&lt; 8);
00340 
00341     <span class="comment">//</span>
00342     <span class="comment">// And get the specific bit</span>
00343     <span class="comment">//</span>
00344     bit = Port &amp; 0x07;
00345 
00346     <span class="comment">//</span>
00347     <span class="comment">// Really want Size to be 1, 2, or 3 so we can use it for shifting and</span>
00348     <span class="comment">// we want val to be a mask for the port access</span>
00349     <span class="comment">// (2^Size -1 == mask for size of port access)...</span>
00350     <span class="comment">//</span>
00351     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> == 4) {
00352         val = 7 &lt;&lt; bit;
00353     }
00354     <span class="keywordflow">else</span> {
00355         val = ((1 &lt;&lt; <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>) - 1) &lt;&lt; bit;
00356     }
00357 
00358     <span class="keywordflow">return</span> (! (ToTest &amp; val));
00359 }
00360 
00361 
00362 BOOLEAN
<a name="l00363"></a><a class="code" href="../../d2/d6/ia64_2iopm_8c.html#a1">00363</a> <a class="code" href="../../d2/d6/ia64_2iopm_8c.html#a1">KiIA32SetPortMemory</a>(
00364     <a class="code" href="../../d5/d7/struct__KPROCESS.html">PKPROCESS</a> Process
00365     )
00366 <span class="comment">/*++</span>
00367 <span class="comment"></span>
00368 <span class="comment">Routine Description:</span>
00369 <span class="comment"></span>
00370 <span class="comment">    Based on the IO access allowed for a particular process, set the memory</span>
00371 <span class="comment">    map accordingly...</span>
00372 <span class="comment"></span>
00373 <span class="comment">Arguments:</span>
00374 <span class="comment"></span>
00375 <span class="comment">    Process - Pointer to kernel process object</span>
00376 <span class="comment"></span>
00377 <span class="comment">Return Value:</span>
00378 <span class="comment"></span>
00379 <span class="comment">    TRUE if able to setup the memory pages</span>
00380 <span class="comment"></span>
00381 <span class="comment">Notes:</span>
00382 <span class="comment">        It would be a lot faster to use a bit searching algorithm</span>
00383 <span class="comment">        looking for the first 0 bit (accessible) instead of </span>
00384 <span class="comment">        doing 8192 calls to the memory system... Of course, we may</span>
00385 <span class="comment">        do this infrequently enough that it may not matter...</span>
00386 <span class="comment"></span>
00387 <span class="comment">--*/</span>
00388 {
00389     PUCHAR ioBits;
00390     ULONG i;
00391     PVOID VirtualPort;
00392 
00393     <span class="keywordflow">if</span> (Process-&gt;IOCurMap == IO_ACCESS_MAP_NONE) {
00394         <span class="comment">// Unmap all of the IOBASE memory?</span>
00395         <span class="comment">// Or set them all as Inaccesable?</span>
00396 
00397         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00398     }
00399 
00400     ioBits = <a class="code" href="../../d2/d6/ia64_2iopm_8c.html#a0">VdmIoMaps</a>[Process-&gt;IOCurMap - 1];
00401 
00402     <span class="keywordflow">for</span> (i = 0; i &lt; IOPM_SIZE; i++) {
00403         <span class="comment">// VirtualPort = (i &lt;&lt; SHIFT_8K) + IOBASE;</span>
00404         <span class="keywordflow">if</span> ((*ioBits &amp; 0x000f) == 0) {
00405             <span class="comment">// These four ports can be set read/writable</span>
00406             <span class="comment">// Call memory manager to set read/writable + IO special</span>
00407         }
00408         <span class="keywordflow">else</span> {
00409             <span class="comment">// Call memory manager to set as inaccessable/unmap</span>
00410         }
00411 
00412         <span class="comment">// VirtualPort = (i &lt;&lt; SHIFT_8K) + IOBASE + (4K_PAGE);</span>
00413         <span class="keywordflow">if</span> ((*ioBits++ &amp; 0x00f0) == 0) {
00414             <span class="comment">// These four ports can be set read/writable</span>
00415             <span class="comment">// Call memory manager to set read/writable + IO special</span>
00416         }
00417         <span class="keywordflow">else</span> {
00418             <span class="comment">// Call memory manager to set as inaccessable/unmap</span>
00419         }
00420     }
00421 
00422     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00423 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:30 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
