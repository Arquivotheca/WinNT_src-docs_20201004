<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: allocsup.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>allocsup.c</h1><a href="../../d2/d6/allocsup_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1996  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    AllocSup.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module implements mappings to physical blocks on UDF media.  The basic</span>
00012 <span class="comment">    structure used here is the Pcb, which contains lookup information for each</span>
00013 <span class="comment">    partition reference in the volume.</span>
00014 <span class="comment"></span>
00015 <span class="comment">Author:</span>
00016 <span class="comment"></span>
00017 <span class="comment">    Dan Lovinger    [DanLo]   5-Sep-1996</span>
00018 <span class="comment"></span>
00019 <span class="comment">Revision History:</span>
00020 <span class="comment"></span>
00021 <span class="comment">--*/</span>
00022 
00023 <span class="preprocessor">#include "UdfProcs.h"</span>
00024 
00025 <span class="comment">//</span>
00026 <span class="comment">//  The Bug check file id for this module</span>
00027 <span class="comment">//</span>
00028 
<a name="l00029"></a><a class="code" href="../../d2/d6/allocsup_8c.html#a0">00029</a> <span class="preprocessor">#define BugCheckFileId                   (UDFS_BUG_CHECK_ALLOCSUP)</span>
00030 <span class="preprocessor"></span>
00031 <span class="comment">//</span>
00032 <span class="comment">//  The local debug trace level</span>
00033 <span class="comment">//</span>
00034 
<a name="l00035"></a><a class="code" href="../../d2/d6/allocsup_8c.html#a1">00035</a> <span class="preprocessor">#define Dbg                              (UDFS_DEBUG_LEVEL_ALLOCSUP)</span>
00036 <span class="preprocessor"></span>
00037 <span class="comment">//</span>
00038 <span class="comment">//  Local support routines.</span>
00039 <span class="comment">//</span>
00040 
00041 <a class="code" href="../../d4/d9/struct__PCB.html">PPCB</a>
00042 <a class="code" href="../../d2/d6/allocsup_8c.html#a2">UdfCreatePcb</a> (
00043     IN ULONG NumberOfPartitions
00044     );
00045 
00046 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
00047 <a class="code" href="../../d2/d6/allocsup_8c.html#a3">UdfLoadSparingTables</a>(
00048     <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00049     <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb,
00050     <a class="code" href="../../d4/d9/struct__PCB.html">PPCB</a> Pcb,
00051     ULONG Reference
00052     );
00053 
00054 
00055 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00056 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfAddToPcb)</span>
00057 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfCompletePcb)</span>
00058 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfCreatePcb)</span>
00059 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfDeletePcb)</span>
00060 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfEquivalentPcb)</span>
00061 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfInitializePcb)</span>
00062 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfLookupAllocation)</span>
00063 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfLookupMetaVsnOfExtent)</span>
00064 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, UdfLookupPsnOfExtent)</span>
00065 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00066 <span class="preprocessor"></span>
00067 
00068 BOOLEAN
<a name="l00069"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a146">00069</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a146">UdfLookupAllocation</a> (
00070     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00071     IN <a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a> Fcb,
00072     IN LONGLONG FileOffset,
00073     OUT PLONGLONG DiskOffset,
00074     OUT PULONG ByteCount
00075     )
00076 
00077 <span class="comment">/*++</span>
00078 <span class="comment"></span>
00079 <span class="comment">Routine Description:</span>
00080 <span class="comment"></span>
00081 <span class="comment">    This routine looks through the mapping information for the file</span>
00082 <span class="comment">    to find the logical diskoffset and number of bytes at that offset.</span>
00083 <span class="comment"></span>
00084 <span class="comment">    This routine assumes we are looking up a valid range in the file.  If</span>
00085 <span class="comment">    a mapping does not exist,</span>
00086 <span class="comment"></span>
00087 <span class="comment">Arguments:</span>
00088 <span class="comment"></span>
00089 <span class="comment">    Fcb - Fcb representing this stream.</span>
00090 <span class="comment"></span>
00091 <span class="comment">    FileOffset - Lookup the allocation beginning at this point.</span>
00092 <span class="comment"></span>
00093 <span class="comment">    DiskOffset - Address to store the logical disk offset.</span>
00094 <span class="comment"></span>
00095 <span class="comment">    ByteCount - Address to store the number of contiguous bytes beginning</span>
00096 <span class="comment">        at DiskOffset above.</span>
00097 <span class="comment"></span>
00098 <span class="comment">Return Value:</span>
00099 <span class="comment"></span>
00100 <span class="comment">    BOOLEAN - whether the extent is unrecorded data</span>
00101 <span class="comment"></span>
00102 <span class="comment">--*/</span>
00103 
00104 {
00105     <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb;
00106 
00107     BOOLEAN Recorded = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00108 
00109     BOOLEAN Result;
00110 
00111     LARGE_INTEGER LocalPsn;
00112     LARGE_INTEGER LocalSectorCount;
00113 
00114     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00115 
00116     <span class="comment">//</span>
00117     <span class="comment">//  Check inputs</span>
00118     <span class="comment">//</span>
00119 
00120     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
00121     <a class="code" href="../../d1/d8/udfdata_8h.html#a14">ASSERT_FCB</a>( Fcb );
00122 
00123     <span class="comment">//</span>
00124     <span class="comment">//  We will never be looking up the allocations of embedded objects.</span>
00125     <span class="comment">//</span>
00126 
00127     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( Fcb-&gt;FcbState, <a class="code" href="../../d6/d8/udfstruc_8h.html#a16">FCB_STATE_EMBEDDED_DATA</a> ));
00128 
00129     Vcb = Fcb-&gt;Vcb;
00130 
00131     LocalPsn.QuadPart = LocalSectorCount.QuadPart = 0;
00132 
00133     <span class="comment">//</span>
00134     <span class="comment">//  Lookup the entry containing this file offset.</span>
00135     <span class="comment">//</span>
00136 
00137     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( Fcb-&gt;FcbState, <a class="code" href="../../d6/d8/udfstruc_8h.html#a15">FCB_STATE_VMCB_MAPPING</a> )) {
00138 
00139         <span class="comment">//</span>
00140         <span class="comment">//  Map this offset into the metadata stream.</span>
00141         <span class="comment">//</span>
00142 
00143         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d3/d8/udfprocs_8h.html#a43">SectorOffset</a>( Vcb, FileOffset ) == 0 );
00144 
00145         Result = <a class="code" href="../../d6/d6/vmcbsup_8c.html#a9">UdfVmcbVbnToLbn</a>( &amp;Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o24">Vmcb</a>,
00146                                   <a class="code" href="../../d3/d8/fsrtlp_8h.html#a13">SectorsFromBytes</a>( Vcb, FileOffset ),
00147                                   &amp;LocalPsn.LowPart,
00148                                   &amp;LocalSectorCount.LowPart );
00149 
00150         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( Result );
00151 
00152     } <span class="keywordflow">else</span> {
00153 
00154         <span class="comment">//</span>
00155         <span class="comment">//  Map this offset in a regular stream.</span>
00156         <span class="comment">//</span>
00157 
00158         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( Fcb-&gt;FcbState, <a class="code" href="../../d6/d8/udfstruc_8h.html#a17">FCB_STATE_MCB_INITIALIZED</a> ));
00159 
00160         Result = <a class="code" href="../../d1/d8/fsrtl_8h.html#a145">FsRtlLookupLargeMcbEntry</a>( &amp;Fcb-&gt;Mcb,
00161                                            <a class="code" href="../../d3/d8/udfprocs_8h.html#a40">LlSectorsFromBytes</a>( Vcb, FileOffset ),
00162                                            &amp;LocalPsn.QuadPart,
00163                                            &amp;LocalSectorCount.QuadPart,
00164                                            <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00165                                            <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00166                                            <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00167     }
00168 
00169     <span class="comment">//</span>
00170     <span class="comment">//  If within the Mcb then we use the data out of this entry and are nearly done.</span>
00171     <span class="comment">//</span>
00172 
00173     <span class="keywordflow">if</span> (Result) {
00174 
00175         <span class="keywordflow">if</span> ( LocalPsn.QuadPart == -1 ) {
00176 
00177             <span class="comment">//</span>
00178             <span class="comment">//  Regular files can have holey allocations which represent unrecorded extents.  For</span>
00179             <span class="comment">//  such extents which are sandwiched in between recorded extents of the file, the Mcb</span>
00180             <span class="comment">//  package tells us that it found a valid mapping but that it doesn't correspond to</span>
00181             <span class="comment">//  any extents on the media yet.  In this case, simply fake the disk offset.  The</span>
00182             <span class="comment">//  returned sector count is accurate.</span>
00183             <span class="comment">//</span>
00184 
00185             *DiskOffset = 0;
00186 
00187             Recorded = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00188 
00189         } <span class="keywordflow">else</span> {
00190 
00191             <span class="comment">//</span>
00192             <span class="comment">//  Now mimic the effects of physical sector sparing.  This may shrink the size of the</span>
00193             <span class="comment">//  returned run if sparing interrupted the extent on disc.</span>
00194             <span class="comment">//</span>
00195 
00196             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( LocalPsn.HighPart == 0 );
00197 
00198             <span class="keywordflow">if</span> (Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o3">Pcb</a>-&gt;<a class="code" href="../../d4/d9/struct__PCB.html#o4">SparingMcb</a>) {
00199 
00200                 LONGLONG SparingPsn;
00201                 LONGLONG SparingSectorCount;
00202 
00203                 <span class="keywordflow">if</span> (<a class="code" href="../../d1/d8/fsrtl_8h.html#a145">FsRtlLookupLargeMcbEntry</a>( Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o3">Pcb</a>-&gt;<a class="code" href="../../d4/d9/struct__PCB.html#o4">SparingMcb</a>,
00204                                               LocalPsn.LowPart,
00205                                               &amp;SparingPsn,
00206                                               &amp;SparingSectorCount,
00207                                               <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00208                                               <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
00209                                               <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> )) {
00210 
00211                     <span class="comment">//</span>
00212                     <span class="comment">//  Only emit noise if we will really change anything as a result</span>
00213                     <span class="comment">//  of the sparing table.</span>
00214                     <span class="comment">//</span>
00215 
00216                     <span class="keywordflow">if</span> (SparingPsn != -1 ||
00217                         SparingSectorCount &lt; LocalSectorCount.QuadPart) {
00218 
00219                         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfLookupAllocation, spared [%x, +%x) onto [%x, +%x)\n"</span>,
00220                                              LocalPsn.LowPart,
00221                                              LocalSectorCount.LowPart,
00222                                              (ULONG) SparingPsn,
00223                                              (ULONG) SparingSectorCount ));
00224                     }
00225 
00226                     <span class="comment">//</span>
00227                     <span class="comment">//  If we did not land in a hole, map the sector.</span>
00228                     <span class="comment">//</span>
00229 
00230                     <span class="keywordflow">if</span> (SparingPsn != -1) {
00231 
00232                         LocalPsn.QuadPart = SparingPsn;
00233                     }
00234 
00235                     <span class="comment">//</span>
00236                     <span class="comment">//  The returned sector count now reduces the previous sector count.</span>
00237                     <span class="comment">//  If we landed in a hole, this indicates that the trailing edge of</span>
00238                     <span class="comment">//  the extent is spared, if not this indicates that the leading</span>
00239                     <span class="comment">//  edge is spared.</span>
00240                     <span class="comment">//</span>
00241 
00242                     <span class="keywordflow">if</span> (SparingSectorCount &lt; LocalSectorCount.QuadPart) {
00243 
00244                         LocalSectorCount.QuadPart = SparingSectorCount;
00245                     }
00246                 }
00247             }
00248 
00249             *DiskOffset = <a class="code" href="../../d3/d8/udfprocs_8h.html#a39">LlBytesFromSectors</a>( Vcb, LocalPsn.QuadPart ) + <a class="code" href="../../d3/d8/udfprocs_8h.html#a43">SectorOffset</a>( Vcb, FileOffset );
00250 
00251             <span class="comment">//</span>
00252             <span class="comment">//  Now we can apply method 2 fixups, which will again interrupt the size of the extent.</span>
00253             <span class="comment">//</span>
00254 
00255             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o7">VcbState</a>, <a class="code" href="../../d6/d8/udfstruc_8h.html#a8">VCB_STATE_METHOD_2_FIXUP</a> )) {
00256 
00257                 LARGE_INTEGER SectorsToRunout;
00258 
00259                 SectorsToRunout.QuadPart= <a class="code" href="../../d9/d7/udf_8h.html#a10">UdfMethod2NextRunoutInSectors</a>( Vcb, *DiskOffset );
00260 
00261                 <span class="keywordflow">if</span> (SectorsToRunout.QuadPart &lt; LocalSectorCount.QuadPart) {
00262 
00263                     LocalSectorCount.QuadPart = SectorsToRunout.QuadPart;
00264                 }
00265 
00266                 *DiskOffset = <a class="code" href="../../d9/d7/udf_8h.html#a8">UdfMethod2TransformByteOffset</a>( Vcb, *DiskOffset );
00267             }
00268         }
00269 
00270     } <span class="keywordflow">else</span> {
00271 
00272         <span class="comment">//</span>
00273         <span class="comment">//  We know that prior to this call the system has restricted IO to points within the</span>
00274         <span class="comment">//  the file data.  Since we failed to find a mapping this is an unrecorded extent at</span>
00275         <span class="comment">//  the end of the file, so just conjure up a proper representation.</span>
00276         <span class="comment">//</span>
00277 
00278         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( FileOffset &lt; Fcb-&gt;FileSize.QuadPart );
00279 
00280         *DiskOffset = 0;
00281 
00282         LocalSectorCount.QuadPart = <a class="code" href="../../d3/d8/udfprocs_8h.html#a40">LlSectorsFromBytes</a>( Vcb, Fcb-&gt;FileSize.QuadPart ) -
00283                                     <a class="code" href="../../d3/d8/udfprocs_8h.html#a40">LlSectorsFromBytes</a>( Vcb, FileOffset ) +
00284                                     1;
00285 
00286         Recorded = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00287     }
00288 
00289     <span class="comment">//</span>
00290     <span class="comment">//  Restrict to MAXULONG bytes of allocation</span>
00291     <span class="comment">//</span>
00292 
00293     <span class="keywordflow">if</span> (LocalSectorCount.QuadPart &gt; <a class="code" href="../../d3/d8/fsrtlp_8h.html#a13">SectorsFromBytes</a>( Vcb, MAXULONG )) {
00294 
00295         *ByteCount = MAXULONG;
00296 
00297     } <span class="keywordflow">else</span> {
00298 
00299         *ByteCount = <a class="code" href="../../d3/d8/fsrtlp_8h.html#a14">BytesFromSectors</a>( Vcb, LocalSectorCount.LowPart );
00300     }
00301 
00302     *ByteCount -= <a class="code" href="../../d3/d8/udfprocs_8h.html#a43">SectorOffset</a>( Vcb, FileOffset );
00303 
00304     <span class="keywordflow">return</span> Recorded;
00305 }
00306 
00307 
00308 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00309"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a147">00309</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a147">UdfDeletePcb</a> (
00310     IN <a class="code" href="../../d4/d9/struct__PCB.html">PPCB</a> Pcb
00311     )
00312 
00313 <span class="comment">/*++</span>
00314 <span class="comment"></span>
00315 <span class="comment">Routine Description:</span>
00316 <span class="comment"></span>
00317 <span class="comment">    This routine deallocates a Pcb and all ancilliary structures.</span>
00318 <span class="comment"></span>
00319 <span class="comment">Arguments:</span>
00320 <span class="comment"></span>
00321 <span class="comment">    Pcb - Pcb being deleted</span>
00322 <span class="comment"></span>
00323 <span class="comment">Return Value:</span>
00324 <span class="comment"></span>
00325 <span class="comment">    None</span>
00326 <span class="comment"></span>
00327 <span class="comment">--*/</span>
00328 
00329 {
00330     <a class="code" href="../../d2/d9/struct__tagPARTITION.html">PPARTITION</a> Partition;
00331 
00332     <span class="keywordflow">if</span> (Pcb-&gt;SparingMcb) {
00333 
00334         <a class="code" href="../../d1/d8/fsrtl_8h.html#a140">FsRtlUninitializeLargeMcb</a>( Pcb-&gt;SparingMcb );
00335         <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>( &amp;Pcb-&gt;SparingMcb );
00336     }
00337 
00338     <span class="keywordflow">for</span> (Partition = Pcb-&gt;Partition;
00339          Partition &lt; &amp;Pcb-&gt;Partition[Pcb-&gt;Partitions];
00340          Partition++) {
00341 
00342         <span class="keywordflow">switch</span> (Partition-&gt;Type) {
00343 
00344             <span class="keywordflow">case</span> <a class="code" href="../../d6/d8/udfstruc_8h.html#a129a115">Physical</a>:
00345 
00346                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>( &amp;Partition-&gt;Physical.PartitionDescriptor );
00347                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>( &amp;Partition-&gt;Physical.SparingMap );                
00348 
00349                 <span class="keywordflow">break</span>;
00350 
00351             <span class="keywordflow">case</span> <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a2">Virtual</a>:
00352             <span class="keywordflow">case</span> <a class="code" href="../../d6/d8/udfstruc_8h.html#a129a114">Uninitialized</a>:
00353                 <span class="keywordflow">break</span>;
00354 
00355             <span class="keywordflow">default</span>:
00356 
00357                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00358                 <span class="keywordflow">break</span>;
00359         }
00360     }
00361 
00362     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( Pcb );
00363 }
00364 
00365 
00366 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00367"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a148">00367</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a148">UdfInitializePcb</a> (
00368     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00369     IN <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb,
00370     IN OUT <a class="code" href="../../d4/d9/struct__PCB.html">PPCB</a> *Pcb,
00371     IN <a class="code" href="../../d6/d2/structNSR__LVOL.html">PNSR_LVOL</a> LVD
00372     )
00373 
00374 <span class="comment">/*++</span>
00375 <span class="comment"></span>
00376 <span class="comment">Routine Description:</span>
00377 <span class="comment"></span>
00378 <span class="comment">    This routine walks through the partition map of a Logical Volume Descriptor</span>
00379 <span class="comment">    and builds an intializing Pcb from it.  The Pcb will be ready to be used</span>
00380 <span class="comment">    in searching for the partition descriptors of a volume.</span>
00381 <span class="comment"></span>
00382 <span class="comment">Arguments:</span>
00383 <span class="comment"></span>
00384 <span class="comment">    Vcb - The volume this Pcb will pertain to</span>
00385 <span class="comment"></span>
00386 <span class="comment">    Pcb - Caller's pointer to the Pcb</span>
00387 <span class="comment"></span>
00388 <span class="comment">    LVD - The Logical Volume Descriptor being used</span>
00389 <span class="comment"></span>
00390 <span class="comment">Return Value:</span>
00391 <span class="comment"></span>
00392 <span class="comment">    STATUS_SUCCESS if the partition map is good and the Pcb is built</span>
00393 <span class="comment"></span>
00394 <span class="comment">    STATUS_DISK_CORRUPT_ERROR if corrupt maps are found</span>
00395 <span class="comment"></span>
00396 <span class="comment">    STATUS_UNRECOGNIZED_VOLUME if noncompliant maps are found</span>
00397 <span class="comment"></span>
00398 <span class="comment">--*/</span>
00399 
00400 {
00401     <a class="code" href="../../d0/d9/struct__PARTMAP__UDF__GENERIC.html">PPARTMAP_UDF_GENERIC</a> Map;
00402     <a class="code" href="../../d2/d9/struct__tagPARTITION.html">PPARTITION</a> Partition;
00403 
00404     BOOLEAN Found;
00405 
00406     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00407 
00408     <span class="comment">//</span>
00409     <span class="comment">//  Check the input parameters</span>
00410     <span class="comment">//</span>
00411 
00412     <a class="code" href="../../d1/d8/udfdata_8h.html#a25">ASSERT_OPTIONAL_PCB</a>( *Pcb );
00413 
00414     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
00415                  <span class="stringliteral">"UdfInitializePcb, Lvd %08x\n"</span>,
00416                  LVD ));
00417 
00418     <span class="comment">//</span>
00419     <span class="comment">//  Delete a pre-existing (partially initialized from a failed</span>
00420     <span class="comment">//  crawl of a VDS) Pcb.</span>
00421     <span class="comment">//</span>
00422 
00423     <span class="keywordflow">if</span> (*Pcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00424 
00425         <a class="code" href="../../d3/d8/udfprocs_8h.html#a147">UdfDeletePcb</a>( *Pcb );
00426         *Pcb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00427     }
00428 
00429     *Pcb = <a class="code" href="../../d2/d6/allocsup_8c.html#a2">UdfCreatePcb</a>( LVD-&gt;MapTableCount );
00430 
00431     <span class="comment">//</span>
00432     <span class="comment">//  Walk the table of partition maps intializing the Pcb for the descriptor</span>
00433     <span class="comment">//  initialization pass.</span>
00434     <span class="comment">//</span>
00435 
00436     <span class="keywordflow">for</span> (Map = (<a class="code" href="../../d0/d9/struct__PARTMAP__UDF__GENERIC.html">PPARTMAP_UDF_GENERIC</a>) LVD-&gt;MapTable,
00437          Partition = (*Pcb)-&gt;Partition;
00438 
00439          Partition &lt; &amp;(*Pcb)-&gt;Partition[(*Pcb)-&gt;Partitions];
00440 
00441          Map = <a class="code" href="../../d2/d7/notify_8c.html#a7">Add2Ptr</a>( Map, Map-&gt;<a class="code" href="../../d0/d9/struct__PARTMAP__UDF__GENERIC.html#o1">Length</a>, <a class="code" href="../../d0/d9/struct__PARTMAP__UDF__GENERIC.html">PPARTMAP_UDF_GENERIC</a> ),
00442          Partition++) {
00443 
00444         <span class="comment">//</span>
00445         <span class="comment">//  Now check that this LVD can actually contain this map entry.  First check that</span>
00446         <span class="comment">//  the descriptor can contain the first few fields, then check that it can hold</span>
00447         <span class="comment">//  all of the bytes claimed by the descriptor.</span>
00448         <span class="comment">//</span>
00449 
00450         <span class="keywordflow">if</span> (<a class="code" href="../../d2/d7/notify_8c.html#a7">Add2Ptr</a>( Map, <span class="keyword">sizeof</span>( <a class="code" href="../../d9/d3/structPARTMAP__GENERIC.html">PARTMAP_GENERIC</a> ), PCHAR ) &gt; <a class="code" href="../../d2/d7/notify_8c.html#a7">Add2Ptr</a>( LVD, <a class="code" href="../../d0/d7/iso13346_8h.html#a80">ISONsrLvolSize</a>( LVD ), PCHAR ) ||
00451             <a class="code" href="../../d2/d7/notify_8c.html#a7">Add2Ptr</a>( Map, Map-&gt;<a class="code" href="../../d0/d9/struct__PARTMAP__UDF__GENERIC.html#o1">Length</a>,               PCHAR ) &gt; <a class="code" href="../../d2/d7/notify_8c.html#a7">Add2Ptr</a>( LVD, <a class="code" href="../../d0/d7/iso13346_8h.html#a80">ISONsrLvolSize</a>( LVD ), PCHAR )) {
00452 
00453             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
00454                          <span class="stringliteral">"UdfInitializePcb, map at +%04x beyond Lvd size %04x\n"</span>,
00455                          (PCHAR) Map - (PCHAR) LVD,
00456                          <a class="code" href="../../d0/d7/iso13346_8h.html#a80">ISONsrLvolSize</a>( LVD )));
00457 
00458             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
00459                          <span class="stringliteral">"UdfInitializePcb -&gt; STATUS_DISK_CORRUPT_ERROR\n"</span> ));
00460 
00461             <span class="keywordflow">return</span> STATUS_DISK_CORRUPT_ERROR;
00462         }
00463 
00464         <span class="comment">//</span>
00465         <span class="comment">//  Now load up this map entry.</span>
00466         <span class="comment">//</span>
00467 
00468         <span class="keywordflow">switch</span> (Map-&gt;<a class="code" href="../../d0/d9/struct__PARTMAP__UDF__GENERIC.html#o0">Type</a>) {
00469 
00470             <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/iso13346_8h.html#a82">PARTMAP_TYPE_PHYSICAL</a>:
00471 
00472                 {
00473                     <a class="code" href="../../d0/d4/structPARTMAP__PHYSICAL.html">PPARTMAP_PHYSICAL</a> MapPhysical = (<a class="code" href="../../d0/d4/structPARTMAP__PHYSICAL.html">PPARTMAP_PHYSICAL</a>) Map;
00474 
00475                     <span class="comment">//</span>
00476                     <span class="comment">//  Type 1 - Physical Partition</span>
00477                     <span class="comment">//</span>
00478 
00479                     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
00480                                  <span class="stringliteral">"UdfInitializePcb, map reference %02x is Physical (Partition # %08x)\n"</span>,
00481                                  (Partition - (*Pcb)-&gt;Partition)/<span class="keyword">sizeof</span>(<a class="code" href="../../d2/d9/struct__tagPARTITION.html">PARTITION</a>),
00482                                  MapPhysical-&gt;<a class="code" href="../../d0/d4/structPARTMAP__PHYSICAL.html#o3">Partition</a> ));
00483 
00484                     <span class="comment">//</span>
00485                     <span class="comment">//  It must be the case that the volume the partition is on is the first</span>
00486                     <span class="comment">//  one since we only do single disc UDF.  This will have already been</span>
00487                     <span class="comment">//  checked by the caller.</span>
00488                     <span class="comment">//</span>
00489 
00490                     <span class="keywordflow">if</span> (MapPhysical-&gt;<a class="code" href="../../d0/d4/structPARTMAP__PHYSICAL.html#o2">VolSetSeq</a> &gt; 1) {
00491 
00492                         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
00493                                      <span class="stringliteral">"UdfInitializePcb, ... but physical partition resides on volume set volume # %08x (&gt; 1)!\n"</span>,
00494                                      MapPhysical-&gt;<a class="code" href="../../d0/d4/structPARTMAP__PHYSICAL.html#o2">VolSetSeq</a> ));
00495 
00496                         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
00497                                      <span class="stringliteral">"UdfInitializePcb -&gt; STATUS_DISK_CORRUPT_ERROR\n"</span> ));
00498 
00499                         <span class="keywordflow">return</span> STATUS_DISK_CORRUPT_ERROR;
00500                     }
00501 
00502                     <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( (*Pcb)-&gt;Flags, <a class="code" href="../../d6/d8/udfstruc_8h.html#a1">PCB_FLAG_PHYSICAL_PARTITION</a> );
00503                     Partition-&gt;Type = <a class="code" href="../../d6/d8/udfstruc_8h.html#a129a115">Physical</a>;
00504                     Partition-&gt;Physical.<a class="code" href="../../d2/d9/struct__tagPARTITION.html#o6">PartitionNumber</a> = MapPhysical-&gt;<a class="code" href="../../d0/d4/structPARTMAP__PHYSICAL.html#o3">Partition</a>;
00505                 }
00506 
00507                 <span class="keywordflow">break</span>;
00508 
00509             <span class="keywordflow">case</span> <a class="code" href="../../d0/d7/iso13346_8h.html#a83">PARTMAP_TYPE_PROXY</a>:
00510 
00511                 <span class="comment">//</span>
00512                 <span class="comment">//  Type 2 - a Proxy Partition, something not explicitly physical.</span>
00513                 <span class="comment">//</span>
00514 
00515                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
00516                              <span class="stringliteral">"UdfInitializePcb, map reference %02x is a proxy\n"</span>,
00517                              (Partition - (*Pcb)-&gt;Partition)/<span class="keyword">sizeof</span>(<a class="code" href="../../d2/d9/struct__tagPARTITION.html">PARTITION</a>)));
00518 
00519                 <span class="comment">//</span>
00520                 <span class="comment">//  Handle the various types of proxy partitions we recognize</span>
00521                 <span class="comment">//</span>
00522 
00523                 <span class="keywordflow">if</span> (<a class="code" href="../../d3/d8/udfprocs_8h.html#a230">UdfDomainIdentifierContained</a>( &amp;Map-&gt;<a class="code" href="../../d0/d9/struct__PARTMAP__UDF__GENERIC.html#o3">PartID</a>,
00524                                                   &amp;<a class="code" href="../../d0/d8/udfdata_8c.html#a12">UdfVirtualPartitionDomainIdentifier</a>,
00525                                                   <a class="code" href="../../d9/d7/udf_8h.html#a3">UDF_VERSION_150</a>,
00526                                                   <a class="code" href="../../d9/d7/udf_8h.html#a4">UDF_VERSION_RECOGNIZED</a> )) {
00527 
00528                     {
00529                         <a class="code" href="../../d1/d9/struct__PARTMAP__VIRTUAL.html">PPARTMAP_VIRTUAL</a> MapVirtual = (<a class="code" href="../../d1/d9/struct__PARTMAP__VIRTUAL.html">PPARTMAP_VIRTUAL</a>) Map;
00530 
00531                         <span class="comment">//</span>
00532                         <span class="comment">//  Only one of these guys can exist, since there can be only one VAT per media surface.</span>
00533                         <span class="comment">//</span>
00534 
00535                         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( (*Pcb)-&gt;Flags, <a class="code" href="../../d6/d8/udfstruc_8h.html#a2">PCB_FLAG_VIRTUAL_PARTITION</a> )) {
00536 
00537                             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
00538                                          <span class="stringliteral">"UdfInitializePcb, ... but this is a second virtual partition!?!!\n"</span> ));
00539 
00540                             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
00541                                          <span class="stringliteral">"UdfInitializePcb -&gt; STATUS_UNCRECOGNIZED_VOLUME\n"</span> ));
00542 
00543                             <span class="keywordflow">return</span> STATUS_UNRECOGNIZED_VOLUME;
00544                         }
00545 
00546                         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
00547                                      <span class="stringliteral">"UdfInitializePcb, ... Virtual (Partition # %08x)\n"</span>,
00548                                      MapVirtual-&gt;<a class="code" href="../../d1/d9/struct__PARTMAP__VIRTUAL.html#o5">Partition</a> ));
00549 
00550                         <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( (*Pcb)-&gt;Flags, <a class="code" href="../../d6/d8/udfstruc_8h.html#a2">PCB_FLAG_VIRTUAL_PARTITION</a> );
00551                         Partition-&gt;Type = <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a2">Virtual</a>;
00552 
00553                         <span class="comment">//</span>
00554                         <span class="comment">//  We will convert the partition number to a partition reference</span>
00555                         <span class="comment">//  before returning.</span>
00556                         <span class="comment">//</span>
00557 
00558                         Partition-&gt;Virtual.RelatedReference = MapVirtual-&gt;<a class="code" href="../../d1/d9/struct__PARTMAP__VIRTUAL.html#o5">Partition</a>;
00559                     }
00560 
00561                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d3/d8/udfprocs_8h.html#a230">UdfDomainIdentifierContained</a>( &amp;Map-&gt;<a class="code" href="../../d0/d9/struct__PARTMAP__UDF__GENERIC.html#o3">PartID</a>,
00562                                                          &amp;<a class="code" href="../../d0/d8/udfdata_8c.html#a16">UdfSparablePartitionDomainIdentifier</a>,
00563                                                          <a class="code" href="../../d9/d7/udf_8h.html#a3">UDF_VERSION_150</a>,
00564                                                          <a class="code" href="../../d9/d7/udf_8h.html#a4">UDF_VERSION_RECOGNIZED</a> )) {
00565 
00566                     {
00567                         <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00568                         <a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html">PPARTMAP_SPARABLE</a> MapSparable = (<a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html">PPARTMAP_SPARABLE</a>) Map;
00569 
00570                         <span class="comment">//</span>
00571                         <span class="comment">//  It must be the case that the volume the partition is on is the first</span>
00572                         <span class="comment">//  one since we only do single disc UDF.  This will have already been</span>
00573                         <span class="comment">//  checked by the caller.</span>
00574                         <span class="comment">//</span>
00575 
00576                         <span class="keywordflow">if</span> (MapSparable-&gt;<a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o4">VolSetSeq</a> &gt; 1) {
00577 
00578                             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
00579                                          <span class="stringliteral">"UdfInitializePcb, ... but sparable partition resides on volume set volume # %08x (&gt; 1)!\n"</span>,
00580                                          MapSparable-&gt;<a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o4">VolSetSeq</a> ));
00581 
00582                             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
00583                                          <span class="stringliteral">"UdfInitializePcb -&gt; STATUS_DISK_CORRUPT_ERROR\n"</span> ));
00584 
00585                             <span class="keywordflow">return</span> STATUS_DISK_CORRUPT_ERROR;
00586                         }
00587 
00588                         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
00589                                      <span class="stringliteral">"UdfInitializePcb, ... Sparable (Partition # %08x)\n"</span>,
00590                                      MapSparable-&gt;<a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o5">Partition</a> ));
00591 
00592                         <span class="comment">//</span>
00593                         <span class="comment">//  We pretend that sparable partitions are basically the same as</span>
00594                         <span class="comment">//  physical partitions.  Since we are not r/w (and will never be</span>
00595                         <span class="comment">//  on media that requires host-based sparing in any case), this</span>
00596                         <span class="comment">//  is a good simplification.</span>
00597                         <span class="comment">//</span>
00598 
00599                         <a class="code" href="../../d5/d5/cc_8h.html#a60">SetFlag</a>( (*Pcb)-&gt;Flags, <a class="code" href="../../d6/d8/udfstruc_8h.html#a3">PCB_FLAG_SPARABLE_PARTITION</a> );
00600                         Partition-&gt;Type = <a class="code" href="../../d6/d8/udfstruc_8h.html#a129a115">Physical</a>;
00601                         Partition-&gt;Physical.<a class="code" href="../../d2/d9/struct__tagPARTITION.html#o6">PartitionNumber</a> = MapSparable-&gt;<a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o5">Partition</a>;
00602 
00603                         <span class="comment">//</span>
00604                         <span class="comment">//  Save this map for use when the partition descriptor is found.</span>
00605                         <span class="comment">//  We can't load the sparing table at this time because we have</span>
00606                         <span class="comment">//  to turn the Lbn-&gt;Psn mapping into a Psn-&gt;Psn mapping.  UDF</span>
00607                         <span class="comment">//  believes that the way sparing will be used in concert with</span>
00608                         <span class="comment">//  the Lbn-&gt;Psn mapping engine (like UdfLookupPsnOfExtent).</span>
00609                         <span class="comment">//</span>
00610                         <span class="comment">//  Unfortunately, this would be a bit painful at this time.</span>
00611                         <span class="comment">//  The users of UdfLookupPsnOfExtent would need to iterate</span>
00612                         <span class="comment">//  over a new interface (not so bad) but the Vmcb package</span>
00613                         <span class="comment">//  would need to be turned inside out so that it didn't do</span>
00614                         <span class="comment">//  the page-filling alignment of blocks in the metadata</span>
00615                         <span class="comment">//  stream - instead, UdfLookupMetaVsnOfExtent would need to</span>
00616                         <span class="comment">//  do this itself.  I choose to lay the sparing engine into</span>
00617                         <span class="comment">//  the read path and raw sector read engine instead.</span>
00618                         <span class="comment">//</span>
00619 
00620                         Partition-&gt;Physical.SparingMap = <a class="code" href="../../d1/d8/fsrtl_8h.html#a37">FsRtlAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>,
00621                                                                                    <span class="keyword">sizeof</span>(<a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html">PARTMAP_SPARABLE</a>),
00622                                                                                    <a class="code" href="../../d1/d7/udfs_2nodetype_8h.html#a86">TAG_NSR_FSD</a>);
00623                         RtlCopyMemory( Partition-&gt;Physical.SparingMap,
00624                                        MapSparable,
00625                                        <span class="keyword">sizeof</span>(<a class="code" href="../../d9/d7/udf_8h.html#a72">PARTMAP_SPARABLE</a>));
00626                     }
00627 
00628                 } <span class="keywordflow">else</span> {
00629 
00630                     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
00631                                  <span class="stringliteral">"UdfInitializePcb, ... but we don't recognize this proxy!\n"</span> ));
00632 
00633                     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
00634                                  <span class="stringliteral">"UdfInitializePcb -&gt; STATUS_UNRECOGNIZED_VOLUME\n"</span> ));
00635 
00636                     <span class="keywordflow">return</span> STATUS_UNRECOGNIZED_VOLUME;
00637                 }
00638 
00639                 <span class="keywordflow">break</span>;
00640 
00641             <span class="keywordflow">default</span>:
00642 
00643                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
00644                              <span class="stringliteral">"UdfInitializePcb, map reference %02x is of unknown type %02x\n"</span>,
00645                              Map-&gt;<a class="code" href="../../d0/d9/struct__PARTMAP__UDF__GENERIC.html#o0">Type</a> ));
00646 
00647                 <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
00648                              <span class="stringliteral">"UdfInitializePcb -&gt; STATUS_UNRECOGNIZED_VOLUME\n"</span> ));
00649 
00650                 <span class="keywordflow">return</span> STATUS_UNRECOGNIZED_VOLUME;
00651                 <span class="keywordflow">break</span>;
00652         }
00653     }
00654 
00655     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( (*Pcb)-&gt;Flags, <a class="code" href="../../d6/d8/udfstruc_8h.html#a1">PCB_FLAG_PHYSICAL_PARTITION</a> | <a class="code" href="../../d6/d8/udfstruc_8h.html#a3">PCB_FLAG_SPARABLE_PARTITION</a> )) {
00656 
00657         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
00658                      <span class="stringliteral">"UdfInitializePcb, no physical partition seen on this logical volume!\n"</span> ));
00659 
00660         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
00661                      <span class="stringliteral">"UdfInitializePcb -&gt; STATUS_UNRECOGNIZED_VOLUME\n"</span> ));
00662 
00663         <span class="keywordflow">return</span> STATUS_UNRECOGNIZED_VOLUME;
00664     }
00665 
00666     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( (*Pcb)-&gt;Flags, <a class="code" href="../../d6/d8/udfstruc_8h.html#a2">PCB_FLAG_VIRTUAL_PARTITION</a> )) {
00667 
00668         <a class="code" href="../../d2/d9/struct__tagPARTITION.html">PPARTITION</a> Host;
00669 
00670         <span class="comment">//</span>
00671         <span class="comment">//  Confirm the validity of any type 2 virtual maps on this volume</span>
00672         <span class="comment">//  and convert partition numbers to partition references that will</span>
00673         <span class="comment">//  immediately index an element of the Pcb.</span>
00674         <span class="comment">//</span>
00675 
00676         <span class="keywordflow">for</span> (Partition = (*Pcb)-&gt;Partition;
00677              Partition &lt; &amp;(*Pcb)-&gt;Partition[(*Pcb)-&gt;Partitions];
00678              Partition++) {
00679 
00680             <span class="keywordflow">if</span> (Partition-&gt;Type == <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a2">Virtual</a>) {
00681 
00682                 <span class="comment">//</span>
00683                 <span class="comment">//  Go find the partition this thing is talking about</span>
00684                 <span class="comment">//</span>
00685 
00686                 Found = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00687 
00688                 <span class="keywordflow">for</span> (Host = (*Pcb)-&gt;Partition;
00689                      Host &lt; &amp;(*Pcb)-&gt;Partition[(*Pcb)-&gt;Partitions];
00690                      Host++) {
00691 
00692                     <span class="keywordflow">if</span> (Host-&gt;Type == <a class="code" href="../../d6/d8/udfstruc_8h.html#a129a115">Physical</a> &amp;&amp;
00693                         Host-&gt;Physical.<a class="code" href="../../d2/d9/struct__tagPARTITION.html#o6">PartitionNumber</a> ==
00694                         Partition-&gt;Virtual.RelatedReference) {
00695 
00696                         Partition-&gt;Virtual.RelatedReference =
00697                             (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(Host - (*Pcb)-&gt;Partition)/<span class="keyword">sizeof</span>(<a class="code" href="../../d2/d9/struct__tagPARTITION.html">PARTITION</a>);
00698                         Found = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00699                         <span class="keywordflow">break</span>;
00700                     }
00701                 }
00702 
00703                 <span class="comment">//</span>
00704                 <span class="comment">//  Failure to find a physical partition for this virtual guy</span>
00705                 <span class="comment">//  is not a good sign.</span>
00706                 <span class="comment">//</span>
00707 
00708                 <span class="keywordflow">if</span> (!Found) {
00709 
00710                     <span class="keywordflow">return</span> STATUS_DISK_CORRUPT_ERROR;
00711                 }
00712             }
00713         }
00714     }
00715 
00716     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
00717              <span class="stringliteral">"UdfInitializePcb -&gt; STATUS_SUCCESS\n"</span> ));
00718 
00719     <span class="keywordflow">return</span> STATUS_SUCCESS;
00720 }
00721 
00722 
00723 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00724"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a149">00724</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a149">UdfAddToPcb</a> (
00725     IN <a class="code" href="../../d4/d9/struct__PCB.html">PPCB</a> Pcb,
00726     IN <a class="code" href="../../d7/d2/structNSR__PART.html">PNSR_PART</a> PartitionDescriptor
00727 )
00728 
00729 <span class="comment">/*++</span>
00730 <span class="comment"></span>
00731 <span class="comment">Routine Description:</span>
00732 <span class="comment"></span>
00733 <span class="comment">    This routine possibly adds a partition descriptor into a Pcb if it</span>
00734 <span class="comment">    turns out to be of higher precendence than a descriptor already</span>
00735 <span class="comment">    present.  Used in building a Pcb already initialized in preperation</span>
00736 <span class="comment">    for UdfCompletePcb.</span>
00737 <span class="comment"></span>
00738 <span class="comment">Arguments:</span>
00739 <span class="comment"></span>
00740 <span class="comment">    Vcb - Vcb of the volume the Pcb describes</span>
00741 <span class="comment"></span>
00742 <span class="comment">    Pcb - Pcb being filled in</span>
00743 <span class="comment"></span>
00744 <span class="comment">Return Value:</span>
00745 <span class="comment"></span>
00746 <span class="comment">    None. An old partition descriptor may be returned in the input field.</span>
00747 <span class="comment"></span>
00748 <span class="comment">--*/</span>
00749 
00750 {
00751     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> Reference;
00752 
00753     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00754 
00755     <span class="comment">//</span>
00756     <span class="comment">//  Check inputs</span>
00757     <span class="comment">//</span>
00758 
00759     <a class="code" href="../../d1/d8/udfdata_8h.html#a24">ASSERT_PCB</a>( Pcb );
00760     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( PartitionDescriptor );
00761 
00762     <span class="keywordflow">for</span> (Reference = 0;
00763          Reference &lt; Pcb-&gt;Partitions;
00764          Reference++) {
00765 
00766         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfAddToPcb,  considering partition reference %d (type %d)\n"</span>, (ULONG)Reference, Pcb-&gt;Partition[Reference].Type));
00767         
00768         <span class="keywordflow">switch</span> (Pcb-&gt;Partition[Reference].Type) {
00769 
00770             <span class="keywordflow">case</span> <a class="code" href="../../d6/d8/udfstruc_8h.html#a129a115">Physical</a>:
00771 
00772                 <span class="comment">//</span>
00773                 <span class="comment">//  Now possibly store this descriptor in the Pcb if it is</span>
00774                 <span class="comment">//  the partition number for this partition reference.</span>
00775                 <span class="comment">//</span>
00776 
00777                 <span class="keywordflow">if</span> (Pcb-&gt;Partition[Reference].Physical.PartitionNumber == PartitionDescriptor-&gt;Number) {
00778 
00779                     <span class="comment">//</span>
00780                     <span class="comment">//  It seems to be legal (if questionable) for multiple partition maps to reference </span>
00781                     <span class="comment">//  the same partition descriptor.  So we make a copy of the descriptor for each </span>
00782                     <span class="comment">//  referencing partitionmap to make life easier when it comes to freeing it.</span>
00783                     <span class="comment">//</span>
00784 
00785                     <a class="code" href="../../d3/d8/udfprocs_8h.html#a176">UdfStoreVolumeDescriptorIfPrevailing</a>( (<a class="code" href="../../d4/d3/structNSR__VD__GENERIC.html">PNSR_VD_GENERIC</a> *) &amp;Pcb-&gt;Partition[Reference].Physical.PartitionDescriptor,
00786                                                           (<a class="code" href="../../d4/d3/structNSR__VD__GENERIC.html">PNSR_VD_GENERIC</a>) PartitionDescriptor );
00787                 }
00788                 
00789                 <span class="keywordflow">break</span>;
00790 
00791             <span class="keywordflow">case</span> <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a2">Virtual</a>:
00792                 <span class="keywordflow">break</span>;
00793 
00794             <span class="keywordflow">default</span>:
00795 
00796                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00797                 <span class="keywordflow">break</span>;
00798         }
00799     }
00800 }
00801 
00802 
00803 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00804"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a150">00804</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a150">UdfCompletePcb</a> (
00805     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00806     IN <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb,
00807     IN <a class="code" href="../../d4/d9/struct__PCB.html">PPCB</a> Pcb
00808     )
00809 
00810 <span class="comment">/*++</span>
00811 <span class="comment"></span>
00812 <span class="comment">Routine Description:</span>
00813 <span class="comment"></span>
00814 <span class="comment">    This routine completes initialization of a Pcb which has been filled</span>
00815 <span class="comment">    in with partition descriptors.  Initialization-time data such as the</span>
00816 <span class="comment">    physical partition descriptors will be returned to the system.</span>
00817 <span class="comment"></span>
00818 <span class="comment">Arguments:</span>
00819 <span class="comment"></span>
00820 <span class="comment">    Vcb - Vcb of the volume the Pcb describes</span>
00821 <span class="comment"></span>
00822 <span class="comment">    Pcb - Pcb being completed</span>
00823 <span class="comment"></span>
00824 <span class="comment">Return Value:</span>
00825 <span class="comment"></span>
00826 <span class="comment">    NTSTATUS according to whether intialization completion was succesful</span>
00827 <span class="comment"></span>
00828 <span class="comment">--*/</span>
00829 
00830 {
00831     ULONG Reference;
00832 
00833     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00834 
00835     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00836 
00837     <span class="comment">//</span>
00838     <span class="comment">//  Check inputs</span>
00839     <span class="comment">//</span>
00840 
00841     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
00842     <a class="code" href="../../d1/d8/udfdata_8h.html#a12">ASSERT_VCB</a>( Vcb );
00843     <a class="code" href="../../d1/d8/udfdata_8h.html#a24">ASSERT_PCB</a>( Pcb );
00844 
00845     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfCompletePcb, Vcb %08x Pcb %08x\n"</span>, Vcb, Pcb ));
00846 
00847     <span class="comment">//</span>
00848     <span class="comment">//  Complete intialization all physical partitions</span>
00849     <span class="comment">//</span>
00850 
00851     <span class="keywordflow">for</span> (Reference = 0;
00852          Reference &lt; Pcb-&gt;Partitions;
00853          Reference++) {
00854 
00855         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfCompletePcb, Examining Ref %u (type %u)!\n"</span>, Reference, Pcb-&gt;Partition[Reference].Type));
00856 
00857         <span class="keywordflow">switch</span> (Pcb-&gt;Partition[Reference].Type) {
00858 
00859             <span class="keywordflow">case</span> <a class="code" href="../../d6/d8/udfstruc_8h.html#a129a115">Physical</a>:
00860 
00861                 <span class="keywordflow">if</span> (Pcb-&gt;Partition[Reference].Physical.PartitionDescriptor == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00862 
00863                     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
00864                                  <span class="stringliteral">"UdfCompletePcb, ... but didn't find Partition# %u!\n"</span>,
00865                                  Pcb-&gt;Partition[Reference].Physical.PartitionNumber ));
00866 
00867                     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfCompletePcb -&gt; STATUS_DISK_CORRUPT_ERROR\n"</span> ));
00868 
00869                     <span class="keywordflow">return</span> STATUS_DISK_CORRUPT_ERROR;
00870                 }
00871 
00872                 Pcb-&gt;Partition[Reference].Physical.Start =
00873                     Pcb-&gt;Partition[Reference].Physical.PartitionDescriptor-&gt;Start;
00874                 Pcb-&gt;Partition[Reference].Physical.Length =
00875                     Pcb-&gt;Partition[Reference].Physical.PartitionDescriptor-&gt;Length;
00876 
00877 
00878                 <span class="comment">//</span>
00879                 <span class="comment">//  Retrieve the sparing information at this point if appropriate.</span>
00880                 <span class="comment">//  We have to do this when we can map logical -&gt; physical blocks.</span>
00881                 <span class="comment">//</span>
00882 
00883                 <span class="keywordflow">if</span> (Pcb-&gt;Partition[Reference].Physical.SparingMap) {
00884 
00885                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d2/d6/allocsup_8c.html#a3">UdfLoadSparingTables</a>( IrpContext,
00886                                                    Vcb,
00887                                                    Pcb,
00888                                                    Reference );
00889 
00890                     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
00891 
00892                         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
00893                                      <span class="stringliteral">"UdfCompletePcb -&gt; %08x\n"</span>, <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> ));
00894                         <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00895                     }
00896                 }
00897 
00898                 <span class="comment">//</span>
00899                 <span class="comment">//  We will not need the descriptor or sparing map anymore, so drop them.  </span>
00900                 <span class="comment">//</span>
00901 
00902                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>( &amp;Pcb-&gt;Partition[Reference].Physical.PartitionDescriptor );
00903                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>( &amp;Pcb-&gt;Partition[Reference].Physical.SparingMap );
00904                 <span class="keywordflow">break</span>;
00905 
00906             <span class="keywordflow">case</span> <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a2">Virtual</a>:
00907                 <span class="keywordflow">break</span>;
00908 
00909             <span class="keywordflow">default</span>:
00910 
00911                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00912                 <span class="keywordflow">break</span>;
00913         }
00914     }
00915 
00916     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfCompletePcb -&gt; STATUS_SUCCESS\n"</span> ));
00917 
00918     <span class="keywordflow">return</span> STATUS_SUCCESS;
00919 }
00920 
00921 
00922 BOOLEAN
<a name="l00923"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a151">00923</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a151">UdfEquivalentPcb</a> (
00924     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
00925     IN <a class="code" href="../../d4/d9/struct__PCB.html">PPCB</a> Pcb1,
00926     IN <a class="code" href="../../d4/d9/struct__PCB.html">PPCB</a> Pcb2
00927     )
00928 
00929 <span class="comment">/*++</span>
00930 <span class="comment"></span>
00931 <span class="comment">Routine Description:</span>
00932 <span class="comment"></span>
00933 <span class="comment">    This routine compares two completed Pcbs to see if they appear equivalent.</span>
00934 <span class="comment"></span>
00935 <span class="comment">Arguments:</span>
00936 <span class="comment"></span>
00937 <span class="comment">    Pcb1 - Pcb being compared</span>
00938 <span class="comment"></span>
00939 <span class="comment">    Pcb2 - Pcb being compared</span>
00940 <span class="comment"></span>
00941 <span class="comment">Return Value:</span>
00942 <span class="comment"></span>
00943 <span class="comment">    BOOLEAN according to whether they are equivalent (TRUE, else FALSE)</span>
00944 <span class="comment"></span>
00945 <span class="comment">--*/</span>
00946 
00947 {
00948     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>;
00949 
00950     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00951 
00952     <span class="comment">//</span>
00953     <span class="comment">//  Check input.</span>
00954     <span class="comment">//</span>
00955 
00956     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
00957 
00958     <span class="keywordflow">if</span> (Pcb1-&gt;Partitions != Pcb2-&gt;Partitions) {
00959 
00960         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00961     }
00962 
00963     <span class="keywordflow">for</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0;
00964          <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt; Pcb1-&gt;Partitions;
00965          <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>++) {
00966 
00967         <span class="comment">//</span>
00968         <span class="comment">//  First check that the partitions are of the same type.</span>
00969         <span class="comment">//</span>
00970 
00971         <span class="keywordflow">if</span> (Pcb1-&gt;Partition[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].Type != Pcb2-&gt;Partition[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].Type) {
00972 
00973             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00974         }
00975 
00976         <span class="comment">//</span>
00977         <span class="comment">//  Now the map content must be the same ...</span>
00978         <span class="comment">//</span>
00979 
00980         <span class="keywordflow">switch</span> (Pcb1-&gt;Partition[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].Type) {
00981 
00982             <span class="keywordflow">case</span> <a class="code" href="../../d6/d8/udfstruc_8h.html#a129a115">Physical</a>:
00983 
00984                 <span class="keywordflow">if</span> (Pcb1-&gt;Partition[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].Physical.PartitionNumber != Pcb2-&gt;Partition[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].Physical.PartitionNumber ||
00985                     Pcb1-&gt;Partition[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].Physical.Length != Pcb2-&gt;Partition[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].Physical.Length ||
00986                     Pcb1-&gt;Partition[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].Physical.Start != Pcb2-&gt;Partition[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].Physical.Start) {
00987 
00988                     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00989                 }
00990                 <span class="keywordflow">break</span>;
00991 
00992             <span class="keywordflow">case</span> <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a2">Virtual</a>:
00993 
00994                 <span class="keywordflow">if</span> (Pcb1-&gt;Partition[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].Virtual.RelatedReference != Pcb2-&gt;Partition[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>].Virtual.RelatedReference) {
00995 
00996                     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00997                 }
00998                 <span class="keywordflow">break</span>;
00999 
01000             <span class="keywordflow">default</span>:
01001 
01002                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
01003                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01004                 <span class="keywordflow">break</span>;
01005         }
01006     }
01007 
01008     <span class="comment">//</span>
01009     <span class="comment">//  All map elements were equivalent.</span>
01010     <span class="comment">//</span>
01011 
01012     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01013 }
01014 
01015 
01016 ULONG
<a name="l01017"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a152">01017</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a152">UdfLookupPsnOfExtent</a> (
01018     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01019     IN <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb,
01020     IN USHORT Reference,
01021     IN ULONG Lbn,
01022     IN ULONG Len
01023     )
01024 
01025 <span class="comment">/*++</span>
01026 <span class="comment"></span>
01027 <span class="comment">Routine Description:</span>
01028 <span class="comment"></span>
01029 <span class="comment">    This routine maps the input logical block extent on a given partition to</span>
01030 <span class="comment">    a starting physical sector.  It doubles as a bounds checker - if the routine</span>
01031 <span class="comment">    does not raise, the caller is guaranteed that the extent lies within the</span>
01032 <span class="comment">    partition.</span>
01033 <span class="comment"></span>
01034 <span class="comment">Arguments:</span>
01035 <span class="comment"></span>
01036 <span class="comment">    Vcb - Vcb of logical volume</span>
01037 <span class="comment"></span>
01038 <span class="comment">    Reference - Partition reference to use in the mapping</span>
01039 <span class="comment"></span>
01040 <span class="comment">    Lbn - Logical block number</span>
01041 <span class="comment"></span>
01042 <span class="comment">    Len - Length of extent in bytes</span>
01043 <span class="comment"></span>
01044 <span class="comment">Return Value:</span>
01045 <span class="comment"></span>
01046 <span class="comment">    ULONG physical sector number</span>
01047 <span class="comment"></span>
01048 <span class="comment">--*/</span>
01049 
01050 {
01051     <a class="code" href="../../d4/d9/struct__PCB.html">PPCB</a> Pcb = Vcb-&gt;Pcb;
01052     ULONG Psn;
01053 
01054     <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> Bcb;
01055     LARGE_INTEGER <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>;
01056     PULONG MappedLbn;
01057 
01058     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01059 
01060     <span class="comment">//</span>
01061     <span class="comment">//  Check inputs</span>
01062     <span class="comment">//</span>
01063 
01064     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
01065     <a class="code" href="../../d1/d8/udfdata_8h.html#a12">ASSERT_VCB</a>( Vcb );
01066     <a class="code" href="../../d1/d8/udfdata_8h.html#a24">ASSERT_PCB</a>( Pcb );
01067 
01068     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfLookupPsnOfExtent, [%04x/%08x, +%08x)\n"</span>, Reference, Lbn, Len ));
01069 
01070     <span class="keywordflow">if</span> (Reference &lt; Pcb-&gt;<a class="code" href="../../d4/d9/struct__PCB.html#o2">Partitions</a>) {
01071 
01072         <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01073 
01074             <span class="keywordflow">switch</span> (Pcb-&gt;<a class="code" href="../../d4/d9/struct__PCB.html#o5">Partition</a>[Reference].Type) {
01075 
01076                 <span class="keywordflow">case</span> <a class="code" href="../../d6/d8/udfstruc_8h.html#a129a115">Physical</a>:
01077 
01078                     <span class="comment">//</span>
01079                     <span class="comment">//  Check that the input extent lies inside the partition.  Calculate the</span>
01080                     <span class="comment">//  Lbn of the last block and see that it is interior.</span>
01081                     <span class="comment">//</span>
01082 
01083                     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d8/udfprocs_8h.html#a41">SectorsFromBlocks</a>( Vcb, Lbn ) + <a class="code" href="../../d3/d8/fsrtlp_8h.html#a13">SectorsFromBytes</a>( Vcb, Len ) &gt;
01084                         Pcb-&gt;<a class="code" href="../../d4/d9/struct__PCB.html#o5">Partition</a>[Reference].Physical.<a class="code" href="../../d2/d9/struct__tagPARTITION.html#o3">Length</a>) {
01085 
01086                         <span class="keywordflow">goto</span> NoGood;
01087                     }
01088 
01089                     Psn = Pcb-&gt;<a class="code" href="../../d4/d9/struct__PCB.html#o5">Partition</a>[Reference].Physical.Start + <a class="code" href="../../d3/d8/udfprocs_8h.html#a41">SectorsFromBlocks</a>( Vcb, Lbn );
01090 
01091                     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfLookupPsnOfExtent -&gt; %08x\n"</span>, Psn ));
01092                     <span class="keywordflow">return</span> Psn;
01093 
01094                 <span class="keywordflow">case</span> <a class="code" href="../../d5/d9/alpha_2exdsptch_8c.html#a2">Virtual</a>:
01095 
01096                     <span class="comment">//</span>
01097                     <span class="comment">//  Bounds check.  Per UDF 2.00 2.3.10 and implied in UDF 1.50, virtual</span>
01098                     <span class="comment">//  extent lengths cannot be greater than one block in size.</span>
01099                     <span class="comment">//</span>
01100 
01101                     <span class="keywordflow">if</span> (Lbn + <a class="code" href="../../d3/d8/udfprocs_8h.html#a50">BlocksFromBytes</a>( Vcb, Len ) &gt; Pcb-&gt;<a class="code" href="../../d4/d9/struct__PCB.html#o5">Partition</a>[Reference].Virtual.<a class="code" href="../../d2/d9/struct__tagPARTITION.html#o3">Length</a> ||
01102                         Len &gt; <a class="code" href="../../d3/d8/udfprocs_8h.html#a54">BlockSize</a>( Vcb )) {
01103 
01104                         <span class="keywordflow">goto</span> NoGood;
01105                     }
01106 
01107                     <span class="keywordflow">try</span> {
01108 
01109                         <span class="comment">//</span>
01110                         <span class="comment">//  Calculate the location of the mapping element in the VAT</span>
01111                         <span class="comment">//  and retrieve.</span>
01112                         <span class="comment">//</span>
01113 
01114                         <a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>.QuadPart = Lbn * <span class="keyword">sizeof</span>(ULONG);
01115 
01116                         <a class="code" href="../../d4/d2/cache_8h.html#a88">CcMapData</a>( Vcb-&gt;VatFcb-&gt;FileObject,
01117                                    &amp;<a class="code" href="../../d4/d9/heapdbg_8c.html#a3">Offset</a>,
01118                                    <span class="keyword">sizeof</span>(ULONG),
01119                                    <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
01120                                    &amp;Bcb,
01121                                    &amp;MappedLbn );
01122 
01123                         <span class="comment">//</span>
01124                         <span class="comment">//  Now rewrite the inputs in terms of the virtual mapping.  We</span>
01125                         <span class="comment">//  will reloop to perform the logical -&gt; physical mapping.</span>
01126                         <span class="comment">//</span>
01127 
01128                         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>,
01129                                      <span class="stringliteral">"UdfLookupPsnOfExtent, Mapping V %04x/%08x -&gt; L %04x/%08x\n"</span>,
01130                                      Reference,
01131                                      Lbn,
01132                                      Pcb-&gt;<a class="code" href="../../d4/d9/struct__PCB.html#o5">Partition</a>[Reference].Virtual.RelatedReference,
01133                                      *MappedLbn ));
01134 
01135                         Lbn = *MappedLbn;
01136                         Reference = Pcb-&gt;<a class="code" href="../../d4/d9/struct__PCB.html#o5">Partition</a>[Reference].Virtual.RelatedReference;
01137 
01138                     } finally {
01139 
01140                         <a class="code" href="../../d8/d3/lfsdata_8h.html#a3">DebugUnwind</a>( <a class="code" href="../../d2/d6/allocsup_8c.html#a10">UdfLookupPsnOfExtent</a> );
01141 
01142                         <a class="code" href="../../d3/d8/udfprocs_8h.html#a69">UdfUnpinData</a>( IrpContext, &amp;Bcb );
01143                     }
01144 
01145                     <span class="comment">//</span>
01146                     <span class="comment">//  An Lbn of ~0 in the VAT is defined to indicate that the sector is unused,</span>
01147                     <span class="comment">//  so we should never see such a thing.</span>
01148                     <span class="comment">//</span>
01149 
01150                     <span class="keywordflow">if</span> (Lbn == ~0) {
01151 
01152                         <span class="keywordflow">goto</span> NoGood;
01153                     }
01154 
01155                     <span class="keywordflow">break</span>;
01156 
01157                 <span class="keywordflow">default</span>:
01158 
01159                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
01160                     <span class="keywordflow">break</span>;
01161             }
01162         }
01163     }
01164 
01165     NoGood:
01166 
01167     <span class="comment">//</span>
01168     <span class="comment">//  Some people have misinterpreted a partition number to equal a</span>
01169     <span class="comment">//  partition reference, or perhaps this is just corrupt media.</span>
01170     <span class="comment">//</span>
01171 
01172     <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, STATUS_FILE_CORRUPT_ERROR );
01173 }
01174 
01175 
01176 ULONG
<a name="l01177"></a><a class="code" href="../../d3/d8/udfprocs_8h.html#a153">01177</a> <a class="code" href="../../d3/d8/udfprocs_8h.html#a153">UdfLookupMetaVsnOfExtent</a> (
01178     IN <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01179     IN <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb,
01180     IN USHORT Reference,
01181     IN ULONG Lbn,
01182     IN ULONG Len,
01183     IN BOOLEAN ExactEnd
01184     )
01185 
01186 <span class="comment">/*++</span>
01187 <span class="comment"></span>
01188 <span class="comment">Routine Description:</span>
01189 <span class="comment"></span>
01190 <span class="comment">    This routine maps the input logical block extent on a given partition to</span>
01191 <span class="comment">    a starting virtual block in the metadata stream.  If a mapping does not</span>
01192 <span class="comment">    exist, one will be created and the metadata stream extended.</span>
01193 <span class="comment"></span>
01194 <span class="comment">Arguments:</span>
01195 <span class="comment"></span>
01196 <span class="comment">    Vcb - Vcb of logical volume</span>
01197 <span class="comment"></span>
01198 <span class="comment">    Reference - Partition reference to use in the mapping</span>
01199 <span class="comment"></span>
01200 <span class="comment">    Lbn - Logical block number</span>
01201 <span class="comment"></span>
01202 <span class="comment">    Len - Length of extent in bytes</span>
01203 <span class="comment">    </span>
01204 <span class="comment">    ExactEnd - Indicates the extension policy if these blocks are not mapped.</span>
01205 <span class="comment"></span>
01206 <span class="comment">Return Value:</span>
01207 <span class="comment"></span>
01208 <span class="comment">    ULONG virtual sector number</span>
01209 <span class="comment"></span>
01210 <span class="comment">    Raised status if the Lbn extent is split across multiple Vbn extents.</span>
01211 <span class="comment"></span>
01212 <span class="comment">--*/</span>
01213 
01214 {
01215     ULONG Vsn;
01216     ULONG Psn;
01217     ULONG SectorCount;
01218 
01219     BOOLEAN Result;
01220 
01221     BOOLEAN UnwindExtension = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01222     LONGLONG UnwindAllocationSize;
01223 
01224     <a class="code" href="../../d7/d9/struct__FCB.html">PFCB</a> Fcb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01225 
01226     <span class="comment">//</span>
01227     <span class="comment">//  Check inputs</span>
01228     <span class="comment">//</span>
01229 
01230     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
01231     <a class="code" href="../../d1/d8/udfdata_8h.html#a12">ASSERT_VCB</a>( Vcb );
01232 
01233     <span class="comment">//</span>
01234     <span class="comment">//  The extent must be an integral number of logical blocks in length.</span>
01235     <span class="comment">//</span>
01236 
01237     <span class="keywordflow">if</span> (Len == 0 || <a class="code" href="../../d3/d8/udfprocs_8h.html#a55">BlockOffset</a>( Vcb, Len )) {
01238 
01239         <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, STATUS_FILE_CORRUPT_ERROR );
01240     }
01241 
01242 
01243     <span class="comment">//</span>
01244     <span class="comment">//  Get the physical mapping of the extent.  The Mcb package operates on ULONG/ULONG</span>
01245     <span class="comment">//  keys and values so we must render our 48bit address into 32.  We can do this since</span>
01246     <span class="comment">//  this is a single surface implementation, and it is guaranteed that a surface cannot</span>
01247     <span class="comment">//  contain more than MAXULONG physical sectors.</span>
01248     <span class="comment">//</span>
01249 
01250     Psn = <a class="code" href="../../d3/d8/udfprocs_8h.html#a152">UdfLookupPsnOfExtent</a>( IrpContext,
01251                                 Vcb,
01252                                 Reference,
01253                                 Lbn,
01254                                 Len );
01255 
01256     <span class="comment">//</span>
01257     <span class="comment">//  Use try-finally for cleanup</span>
01258     <span class="comment">//</span>
01259 
01260     <span class="keywordflow">try</span> {
01261 
01262         <span class="comment">//</span>
01263         <span class="comment">//  We must safely establish a mapping and extend the metadata stream so that cached</span>
01264         <span class="comment">//  reads can occur on this new extent.</span>
01265         <span class="comment">//</span>
01266 
01267         Fcb = Vcb-&gt;MetadataFcb;
01268         <a class="code" href="../../d3/d8/udfprocs_8h.html#a90">UdfLockFcb</a>( IrpContext, Fcb );
01269         
01270         Result = <a class="code" href="../../d6/d6/vmcbsup_8c.html#a10">UdfVmcbLbnToVbn</a>( &amp;Vcb-&gt;Vmcb,
01271                                   Psn,
01272                                   &amp;Vsn,
01273                                   &amp;SectorCount );
01274 
01275         <span class="keywordflow">if</span> (Result) {
01276 
01277             <span class="comment">//</span>
01278             <span class="comment">//  If the mapping covers the extent, we can give this back.</span>
01279             <span class="comment">//</span>
01280 
01281             <span class="keywordflow">if</span> (<a class="code" href="../../d3/d8/udfprocs_8h.html#a53">BlocksFromSectors</a>( Vcb, SectorCount ) &gt;= <a class="code" href="../../d3/d8/udfprocs_8h.html#a50">BlocksFromBytes</a>( Vcb, Len )) {
01282 
01283                 <a class="code" href="../../d3/d8/udfprocs_8h.html#a64">try_leave</a>( NOTHING );
01284 
01285             }
01286 
01287             <span class="comment">//</span>
01288             <span class="comment">//  It is a fatal error if the extent we are mapping is not wholly contained</span>
01289             <span class="comment">//  by an extent of Vsns in the Vmcb.  This will indicate that some structure</span>
01290             <span class="comment">//  is trying to overlap another.</span>
01291             <span class="comment">//</span>
01292 
01293             <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, STATUS_FILE_CORRUPT_ERROR );
01294         }
01295 
01296         <span class="comment">//</span>
01297         <span class="comment">//  Add the new mapping.  We know that it is being added to the end of the stream.</span>
01298         <span class="comment">//</span>
01299 
01300         <a class="code" href="../../d6/d6/vmcbsup_8c.html#a11">UdfAddVmcbMapping</a>( &amp;Vcb-&gt;Vmcb,
01301                            Psn,
01302                            <a class="code" href="../../d3/d8/fsrtlp_8h.html#a13">SectorsFromBytes</a>( Vcb, Len ),
01303                            ExactEnd,
01304                            &amp;Vsn,
01305                            &amp;SectorCount );
01306 
01307         UnwindAllocationSize = Fcb-&gt;AllocationSize.QuadPart;
01308         UnwindExtension = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01309 
01310         Fcb-&gt;AllocationSize.QuadPart =
01311         Fcb-&gt;FileSize.QuadPart =
01312         Fcb-&gt;ValidDataLength.QuadPart = <a class="code" href="../../d3/d8/udfprocs_8h.html#a39">LlBytesFromSectors</a>( Vcb, Vsn + SectorCount);
01313 
01314         <a class="code" href="../../d4/d2/cache_8h.html#a60">CcSetFileSizes</a>( Fcb-&gt;FileObject, (<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html">PCC_FILE_SIZES</a>) &amp;Fcb-&gt;AllocationSize );
01315         UnwindExtension = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01316 
01317         <span class="comment">//</span>
01318         <span class="comment">//  We do not need to purge the cache maps since the Vmcb will always be</span>
01319         <span class="comment">//  page aligned, and thus any reads will have filled it with valid data.</span>
01320         <span class="comment">//</span>
01321 
01322     } finally {
01323 
01324         <span class="keywordflow">if</span> (UnwindExtension) {
01325 
01326             ULONG FirstZappedVsn;
01327 
01328             <span class="comment">//</span>
01329             <span class="comment">//  Strip off the additional mappings we made.</span>
01330             <span class="comment">//</span>
01331 
01332             Fcb-&gt;AllocationSize.QuadPart =
01333             Fcb-&gt;FileSize.QuadPart =
01334             Fcb-&gt;ValidDataLength.QuadPart = UnwindAllocationSize;
01335 
01336             FirstZappedVsn = <a class="code" href="../../d3/d8/fsrtlp_8h.html#a13">SectorsFromBytes</a>( Vcb, UnwindAllocationSize );
01337 
01338             <a class="code" href="../../d6/d6/vmcbsup_8c.html#a12">UdfRemoveVmcbMapping</a>( &amp;Vcb-&gt;Vmcb,
01339                                   FirstZappedVsn,
01340                                   Vsn + SectorCount - FirstZappedVsn );
01341 
01342             <a class="code" href="../../d4/d2/cache_8h.html#a60">CcSetFileSizes</a>( Fcb-&gt;FileObject, (<a class="code" href="../../d1/d9/struct__CC__FILE__SIZES.html">PCC_FILE_SIZES</a>) &amp;Fcb-&gt;AllocationSize );
01343         }
01344 
01345         <span class="keywordflow">if</span> (Fcb) { <a class="code" href="../../d3/d8/udfprocs_8h.html#a91">UdfUnlockFcb</a>( IrpContext, Fcb ); }
01346     }
01347 
01348     <span class="keywordflow">return</span> Vsn;
01349 }
01350 
01351 
01352 <span class="comment">//</span>
01353 <span class="comment">//  Local support routine.</span>
01354 <span class="comment">//</span>
01355 
01356 <a class="code" href="../../d4/d9/struct__PCB.html">PPCB</a>
<a name="l01357"></a><a class="code" href="../../d2/d6/allocsup_8c.html#a2">01357</a> <a class="code" href="../../d2/d6/allocsup_8c.html#a2">UdfCreatePcb</a> (
01358     IN ULONG NumberOfPartitions
01359     )
01360 
01361 <span class="comment">/*++</span>
01362 <span class="comment"></span>
01363 <span class="comment">Routine Description:</span>
01364 <span class="comment"></span>
01365 <span class="comment">    This routine creates a new Pcb of the indicated size.</span>
01366 <span class="comment"></span>
01367 <span class="comment">Arguments:</span>
01368 <span class="comment"></span>
01369 <span class="comment">    NumberOfPartitions - Number of partitions this Pcb will describe</span>
01370 <span class="comment"></span>
01371 <span class="comment">Return Value:</span>
01372 <span class="comment"></span>
01373 <span class="comment">    PPCB - the Pcb created</span>
01374 <span class="comment"></span>
01375 <span class="comment">--*/</span>
01376 
01377 {
01378     <a class="code" href="../../d4/d9/struct__PCB.html">PPCB</a> Pcb;
01379     ULONG <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> = <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d9/struct__PCB.html">PCB</a>) + <span class="keyword">sizeof</span>(<a class="code" href="../../d2/d9/struct__tagPARTITION.html">PARTITION</a>)*NumberOfPartitions;
01380 
01381     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01382 
01383     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( NumberOfPartitions );
01384     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( NumberOfPartitions &lt; MAXUSHORT );
01385 
01386     Pcb = (<a class="code" href="../../d4/d9/struct__PCB.html">PPCB</a>) <a class="code" href="../../d1/d8/fsrtl_8h.html#a37">FsRtlAllocatePoolWithTag</a>( <a class="code" href="../../d3/d8/udfprocs_8h.html#a65">UdfPagedPool</a>,
01387                                            <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>,
01388                                            <a class="code" href="../../d1/d7/udfs_2nodetype_8h.html#a82">TAG_PCB</a> );
01389 
01390     RtlZeroMemory( Pcb, <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> );
01391 
01392     Pcb-&gt;<a class="code" href="../../d4/d9/struct__PCB.html#o0">NodeTypeCode</a> = <a class="code" href="../../d1/d7/udfs_2nodetype_8h.html#a10">UDFS_NTC_PCB</a>;
01393     Pcb-&gt;<a class="code" href="../../d4/d9/struct__PCB.html#o1">NodeByteSize</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
01394 
01395     Pcb-&gt;<a class="code" href="../../d4/d9/struct__PCB.html#o2">Partitions</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)NumberOfPartitions;
01396 
01397     <span class="keywordflow">return</span> Pcb;
01398 }
01399 
01400 
01401 <span class="comment">//</span>
01402 <span class="comment">//  Internal support routine</span>
01403 <span class="comment">//</span>
01404 
01405 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01406"></a><a class="code" href="../../d2/d6/allocsup_8c.html#a3">01406</a> <a class="code" href="../../d2/d6/allocsup_8c.html#a3">UdfLoadSparingTables</a>(
01407     <a class="code" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext,
01408     <a class="code" href="../../d7/d5/struct__VCB.html">PVCB</a> Vcb,
01409     <a class="code" href="../../d4/d9/struct__PCB.html">PPCB</a> Pcb,
01410     ULONG Reference
01411     )
01412 
01413 <span class="comment">/*++</span>
01414 <span class="comment"></span>
01415 <span class="comment">Routine Description:</span>
01416 <span class="comment"></span>
01417 <span class="comment">    This routine reads the sparing tables for a partition and fills</span>
01418 <span class="comment">    in the sparing Mcb.</span>
01419 <span class="comment"></span>
01420 <span class="comment">Arguments:</span>
01421 <span class="comment"></span>
01422 <span class="comment">    Vcb - the volume hosting the spared partition</span>
01423 <span class="comment"></span>
01424 <span class="comment">    Pcb - the partion block corresponding to the volume</span>
01425 <span class="comment"></span>
01426 <span class="comment">    Reference - the partition reference being pulled in</span>
01427 <span class="comment"></span>
01428 <span class="comment">Return Value:</span>
01429 <span class="comment"></span>
01430 <span class="comment">    NTSTATUS according to whether the sparing tables were loaded</span>
01431 <span class="comment"></span>
01432 <span class="comment">--*/</span>
01433 
01434 {
01435     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
01436 
01437     ULONG SparingTable;
01438     PULONG SectorBuffer;
01439     ULONG Psn;
01440 
01441     ULONG RemainingBytes;
01442     ULONG ByteOffset;
01443     ULONG TotalBytes;
01444 
01445     BOOLEAN Complete;
01446 
01447     <a class="code" href="../../d5/d5/struct__SPARING__TABLE__HEADER.html">PSPARING_TABLE_HEADER</a> <a class="code" href="../../d3/d3/dumpuser_8c.html#a17">Header</a>;
01448     <a class="code" href="../../d4/d5/struct__SPARING__TABLE__ENTRY.html">PSPARING_TABLE_ENTRY</a> Entry;
01449 
01450     <a class="code" href="../../d2/d9/struct__tagPARTITION.html">PPARTITION</a> Partition = &amp;Pcb-&gt;<a class="code" href="../../d4/d9/struct__PCB.html#o5">Partition</a>[Reference];
01451     <a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html">PPARTMAP_SPARABLE</a> Map = Partition-&gt;Physical.SparingMap;
01452 
01453     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
01454     <a class="code" href="../../d1/d8/udfdata_8h.html#a12">ASSERT_VCB</a>( Vcb );
01455 
01456     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( Map != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01457 
01458     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfLoadSparingTables, Vcb %08x, PcbPartition %08x, Map @ %08x\n"</span>, Vcb, Partition, Map ));
01459 
01460     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfLoadSparingTables, Map sez: PacketLen %u, NTables %u, TableSize %u\n"</span>,
01461                          Map-&gt;<a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o6">PacketLength</a>,
01462                          Map-&gt;<a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o7">NumSparingTables</a>,
01463                          Map-&gt;<a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o9">TableSize</a>));
01464 
01465 
01466     <span class="comment">//</span>
01467     <span class="comment">//  Check that the sparale map appears sane.  If there are no sparing tables that</span>
01468     <span class="comment">//  is pretty OK, and it'll wind up looking like a regular physical partition.</span>
01469     <span class="comment">//</span>
01470 
01471     <span class="keywordflow">if</span> (Map-&gt;<a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o7">NumSparingTables</a> == 0) {
01472 
01473         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>((  0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfLoadSparingTables, no sparing tables claimed!\n"</span> ));
01474         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfLoadSparingTables -&gt; STATUS_SUCCESS\n"</span> ));
01475         <span class="keywordflow">return</span> STATUS_SUCCESS;
01476     }
01477 
01478     <span class="keywordflow">if</span> (Map-&gt;<a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o7">NumSparingTables</a> &gt; <span class="keyword">sizeof</span>(Map-&gt;<a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o10">TableLocation</a>)/<span class="keyword">sizeof</span>(ULONG)) {
01479 
01480         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>((  0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfLoadSparingTables, too many claimed tables to fit! (max %u)\n"</span>,
01481                               <span class="keyword">sizeof</span>(Map-&gt;<a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o10">TableLocation</a>)/<span class="keyword">sizeof</span>(ULONG)));
01482         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfLoadSparingTables -&gt; STATUS_DISK_CORRUPT_ERROR\n"</span> ));
01483         <span class="keywordflow">return</span>  STATUS_DISK_CORRUPT_ERROR;
01484     }
01485 
01486     <span class="keywordflow">if</span> (Map-&gt;<a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o6">PacketLength</a> != <a class="code" href="../../d9/d7/udf_8h.html#a61">UDF_SPARING_PACKET_LENGTH</a>) {
01487 
01488         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>((  0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfLoadSparingTables, packet size is %u (not %u!\n"</span>,
01489                               Map-&gt;<a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o6">PacketLength</a>,
01490                               <a class="code" href="../../d9/d7/udf_8h.html#a61">UDF_SPARING_PACKET_LENGTH</a> ));
01491         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfLoadSparingTables -&gt; STATUS_DISK_CORRUPT_ERROR\n"</span> ));
01492         <span class="keywordflow">return</span>  STATUS_DISK_CORRUPT_ERROR;
01493     }
01494 
01495     <span class="keywordflow">if</span> (Map-&gt;<a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o9">TableSize</a> &lt; <span class="keyword">sizeof</span>(<a class="code" href="../../d5/d5/struct__SPARING__TABLE__HEADER.html">SPARING_TABLE_HEADER</a>) ||
01496         (Map-&gt;<a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o9">TableSize</a> - <span class="keyword">sizeof</span>(<a class="code" href="../../d5/d5/struct__SPARING__TABLE__HEADER.html">SPARING_TABLE_HEADER</a>)) % <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/struct__SPARING__TABLE__ENTRY.html">SPARING_TABLE_ENTRY</a>) != 0) {
01497 
01498         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>((  0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfLoadSparingTables, sparing table size is too small or unaligned!\n"</span> ));
01499         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfLoadSparingTables -&gt; STATUS_DISK_CORRUPT_ERROR\n"</span> ));
01500         <span class="keywordflow">return</span>  STATUS_DISK_CORRUPT_ERROR;
01501     }
01502 
01503 <span class="preprocessor">#ifdef UDF_SANITY</span>
01504 <span class="preprocessor"></span>    <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfLoadSparingTables"</span> ));
01505     <span class="keywordflow">for</span> (SparingTable = 0; SparingTable &lt; Map-&gt;<a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o7">NumSparingTables</a>; SparingTable++) {
01506 
01507         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">", Table %u @ %x"</span>, SparingTable, Map-&gt;<a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o10">TableLocation</a>[SparingTable] ));
01508     }
01509     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"\n"</span> ));
01510 <span class="preprocessor">#endif</span>
01511 <span class="preprocessor"></span>
01512     <span class="comment">//</span>
01513     <span class="comment">//  If a sparing mcb doesn't exist, manufacture one.</span>
01514     <span class="comment">//</span>
01515 
01516     <span class="keywordflow">if</span> (Pcb-&gt;<a class="code" href="../../d4/d9/struct__PCB.html#o4">SparingMcb</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01517 
01518         Pcb-&gt;<a class="code" href="../../d4/d9/struct__PCB.html#o4">SparingMcb</a> = <a class="code" href="../../d1/d8/fsrtl_8h.html#a37">FsRtlAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>, <span class="keyword">sizeof</span>(<a class="code" href="../../d0/d9/struct__LARGE__MCB.html">LARGE_MCB</a>), <a class="code" href="../../d1/d7/udfs_2nodetype_8h.html#a85">TAG_SPARING_MCB</a> );
01519         <a class="code" href="../../d1/d8/fsrtl_8h.html#a139">FsRtlInitializeLargeMcb</a>( Pcb-&gt;<a class="code" href="../../d4/d9/struct__PCB.html#o4">SparingMcb</a>, <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a> );
01520     }
01521 
01522     SectorBuffer = <a class="code" href="../../d1/d8/fsrtl_8h.html#a37">FsRtlAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>, <a class="code" href="../../d1/d7/udfs_2nodetype_8h.html#a86">TAG_NSR_FSD</a> );
01523 
01524     <span class="comment">//</span>
01525     <span class="comment">//  Now loop across the sparing tables and pull the data in.</span>
01526     <span class="comment">//</span>
01527 
01528     <span class="keywordflow">try</span> {
01529 
01530         <span class="keywordflow">for</span> (Complete = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, SparingTable = 0;
01531 
01532              SparingTable &lt; Map-&gt;<a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o7">NumSparingTables</a>;
01533 
01534              SparingTable++) {
01535 
01536             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>((  0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfLoadSparingTables, loading sparing table %u!\n"</span>,
01537                                   SparingTable ));
01538 
01539             ByteOffset = 0;
01540             TotalBytes = 0;
01541             RemainingBytes = 0;
01542 
01543             <span class="keywordflow">do</span> {
01544 
01545                 <span class="keywordflow">if</span> (RemainingBytes == 0) {
01546 
01547                     (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d3/d8/udfprocs_8h.html#a160">UdfReadSectors</a>( IrpContext,
01548                                            <a class="code" href="../../d3/d8/fsrtlp_8h.html#a14">BytesFromSectors</a>( Vcb, Map-&gt;<a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o10">TableLocation</a>[SparingTable] ) + ByteOffset,
01549                                            <a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a>( Vcb ),
01550                                            <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01551                                            SectorBuffer,
01552                                            Vcb-&gt;<a class="code" href="../../d7/d5/struct__VCB.html#o4">TargetDeviceObject</a> );
01553 
01554                     <span class="comment">//</span>
01555                     <span class="comment">//  Verify the descriptor at the head of the sparing table.  If it is not</span>
01556                     <span class="comment">//  valid, we just break out for a chance at the next table, if any.</span>
01557                     <span class="comment">//</span>
01558 
01559                     <span class="keywordflow">if</span> (ByteOffset == 0) {
01560 
01561                         <a class="code" href="../../d3/d3/dumpuser_8c.html#a17">Header</a> = (<a class="code" href="../../d5/d5/struct__SPARING__TABLE__HEADER.html">PSPARING_TABLE_HEADER</a>) SectorBuffer;
01562 
01563                         <span class="keywordflow">if</span> (!<a class="code" href="../../d3/d8/udfprocs_8h.html#a219">UdfVerifyDescriptor</a>( IrpContext,
01564                                                   &amp;<a class="code" href="../../d3/d3/dumpuser_8c.html#a17">Header</a>-&gt;Destag,
01565                                                   0,
01566                                                   <a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a>( Vcb ),
01567                                                   <a class="code" href="../../d3/d3/dumpuser_8c.html#a17">Header</a>-&gt;Destag.Lbn,
01568                                                   <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> )) {
01569 
01570                             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>((  0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfLoadSparingTables, sparing table %u didn't verify destag!\n"</span>,
01571                                                   SparingTable ));
01572                             <span class="keywordflow">break</span>;
01573                         }
01574 
01575                         <span class="keywordflow">if</span> (!<a class="code" href="../../d3/d8/udfprocs_8h.html#a231">UdfUdfIdentifierContained</a>( &amp;<a class="code" href="../../d3/d3/dumpuser_8c.html#a17">Header</a>-&gt;RegID,
01576                                                         &amp;<a class="code" href="../../d0/d8/udfdata_8c.html#a18">UdfSparingTableIdentifier</a>,
01577                                                         <a class="code" href="../../d9/d7/udf_8h.html#a3">UDF_VERSION_150</a>,
01578                                                         <a class="code" href="../../d9/d7/udf_8h.html#a4">UDF_VERSION_RECOGNIZED</a>,
01579                                                         <a class="code" href="../../d9/d7/udf_8h.html#a33">OSCLASS_INVALID</a>,
01580                                                         <a class="code" href="../../d9/d7/udf_8h.html#a34">OSIDENTIFIER_INVALID</a>)) {
01581 
01582                             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>((  0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfLoadSparingTables, sparing table %u didn't verify regid!\n"</span>,
01583                                                   SparingTable ));
01584                             <span class="keywordflow">break</span>;
01585                         }
01586 
01587                         <span class="comment">//</span>
01588                         <span class="comment">//  Calculate the total number bytes this map spans and check it against what</span>
01589                         <span class="comment">//  we were told the sparing table sizes are.</span>
01590                         <span class="comment">//</span>
01591 
01592                         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfLoadSparingTables, Sparing table %u has %u entries\n"</span>,
01593                                              SparingTable,
01594                                              <a class="code" href="../../d3/d3/dumpuser_8c.html#a17">Header</a>-&gt;TableEntries ));
01595 
01596                         TotalBytes = <span class="keyword">sizeof</span>(<a class="code" href="../../d5/d5/struct__SPARING__TABLE__HEADER.html">SPARING_TABLE_HEADER</a>) + <a class="code" href="../../d3/d3/dumpuser_8c.html#a17">Header</a>-&gt;TableEntries * <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/struct__SPARING__TABLE__ENTRY.html">SPARING_TABLE_ENTRY</a>);
01597 
01598                         <span class="keywordflow">if</span> (Map-&gt;<a class="code" href="../../d9/d8/struct__PARTMAP__SPARABLE.html#o9">TableSize</a> &lt; TotalBytes) {
01599 
01600                             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>((  0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfLoadSparingTables, sparing table #ents %u overflows allocation!\n"</span>,
01601                                                   <a class="code" href="../../d3/d3/dumpuser_8c.html#a17">Header</a>-&gt;TableEntries ));
01602                             <span class="keywordflow">break</span>;
01603                         }
01604 
01605                         <span class="comment">//</span>
01606                         <span class="comment">//  So far so good, advance past the header.</span>
01607                         <span class="comment">//</span>
01608 
01609                         ByteOffset = <span class="keyword">sizeof</span>(<a class="code" href="../../d5/d5/struct__SPARING__TABLE__HEADER.html">SPARING_TABLE_HEADER</a>);
01610                         Entry = <a class="code" href="../../d2/d7/notify_8c.html#a7">Add2Ptr</a>( SectorBuffer, <span class="keyword">sizeof</span>(<a class="code" href="../../d5/d5/struct__SPARING__TABLE__HEADER.html">SPARING_TABLE_HEADER</a>), <a class="code" href="../../d4/d5/struct__SPARING__TABLE__ENTRY.html">PSPARING_TABLE_ENTRY</a> );
01611 
01612                     } <span class="keywordflow">else</span> {
01613 
01614                         <span class="comment">//</span>
01615                         <span class="comment">//  Pick up in the new sector.</span>
01616                         <span class="comment">//</span>
01617 
01618                         Entry = (<a class="code" href="../../d4/d5/struct__SPARING__TABLE__ENTRY.html">PSPARING_TABLE_ENTRY</a>) SectorBuffer;
01619                     }
01620 
01621                     RemainingBytes = <a class="code" href="../../d3/d8/udfprocs_8h.html#a3">Min</a>( <a class="code" href="../../d3/d8/udfprocs_8h.html#a42">SectorSize</a>( Vcb ), TotalBytes - ByteOffset );
01622                 }
01623 
01624                 <span class="comment">//</span>
01625                 <span class="comment">//  Add the mapping.  Since sparing tables are an Lbn-&gt;Psn mapping,</span>
01626                 <span class="comment">//  very odd, and I want to simplify things by putting the sparing</span>
01627                 <span class="comment">//  in right at IO dispatch, translate this to a Psn-&gt;Psn mapping.</span>
01628                 <span class="comment">//</span>
01629 
01630                 <span class="keywordflow">if</span> (Entry-&gt;<a class="code" href="../../d4/d5/struct__SPARING__TABLE__ENTRY.html#o0">Original</a> != <a class="code" href="../../d9/d7/udf_8h.html#a59">UDF_SPARING_AVALIABLE</a> &amp;&amp;
01631                     Entry-&gt;<a class="code" href="../../d4/d5/struct__SPARING__TABLE__ENTRY.html#o0">Original</a> != <a class="code" href="../../d9/d7/udf_8h.html#a60">UDF_SPARING_DEFECTIVE</a>) {
01632 
01633                     Psn = Partition-&gt;Physical.Start + <a class="code" href="../../d3/d8/udfprocs_8h.html#a41">SectorsFromBlocks</a>( Vcb, Entry-&gt;<a class="code" href="../../d4/d5/struct__SPARING__TABLE__ENTRY.html#o0">Original</a> );
01634 
01635                     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>((  0, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfLoadSparingTables, mapping from Psn %x (Lbn %x) -&gt; Psn %x\n"</span>,
01636                                           Psn,
01637                                           Entry-&gt;<a class="code" href="../../d4/d5/struct__SPARING__TABLE__ENTRY.html#o0">Original</a>,
01638                                           Entry-&gt;<a class="code" href="../../d4/d5/struct__SPARING__TABLE__ENTRY.html#o1">Mapped</a> ));
01639 
01640                     <a class="code" href="../../d1/d8/fsrtl_8h.html#a143">FsRtlAddLargeMcbEntry</a>( Pcb-&gt;<a class="code" href="../../d4/d9/struct__PCB.html#o4">SparingMcb</a>,
01641                                            Psn,
01642                                            Entry-&gt;<a class="code" href="../../d4/d5/struct__SPARING__TABLE__ENTRY.html#o1">Mapped</a>,
01643                                            <a class="code" href="../../d9/d7/udf_8h.html#a61">UDF_SPARING_PACKET_LENGTH</a> );
01644                 }
01645 
01646                 <span class="comment">//</span>
01647                 <span class="comment">//  Advance to the next, and drop out if we've hit the end.</span>
01648                 <span class="comment">//</span>
01649 
01650                 ByteOffset += <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/struct__SPARING__TABLE__ENTRY.html">SPARING_TABLE_ENTRY</a>);
01651                 RemainingBytes -= <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d5/struct__SPARING__TABLE__ENTRY.html">SPARING_TABLE_ENTRY</a>);
01652                 Entry++;
01653 
01654             } <span class="keywordflow">while</span> ( ByteOffset &lt; TotalBytes );
01655         }
01656 
01657     } finally {
01658 
01659         <a class="code" href="../../d8/d3/lfsdata_8h.html#a3">DebugUnwind</a>( <a class="code" href="../../d2/d6/allocsup_8c.html#a3">UdfLoadSparingTables</a> );
01660 
01661         <a class="code" href="../../d3/d8/udfprocs_8h.html#a124">UdfFreePool</a>( &amp;SectorBuffer );
01662     }
01663 
01664     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, <a class="code" href="../../d9/d5/cdfs__rec_8c.html#a0">Dbg</a>, <span class="stringliteral">"UdfLoadSparingTables -&gt; STATUS_SUCCESS\n"</span> ));
01665 
01666     <span class="keywordflow">return</span> STATUS_SUCCESS;
01667 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:39:14 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
