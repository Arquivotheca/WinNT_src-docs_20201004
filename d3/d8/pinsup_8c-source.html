<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: pinsup.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>pinsup.c</h1><a href="../../d2/d9/pinsup_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1990  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    pinsup.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module implements the pointer-based Pin support routines for the</span>
00012 <span class="comment">    Cache subsystem.</span>
00013 <span class="comment"></span>
00014 <span class="comment">Author:</span>
00015 <span class="comment"></span>
00016 <span class="comment">    Tom Miller      [TomM]      4-June-1990</span>
00017 <span class="comment"></span>
00018 <span class="comment">Revision History:</span>
00019 <span class="comment"></span>
00020 <span class="comment">--*/</span>
00021 
00022 <span class="preprocessor">#include "<a class="code" href="../../d5/d5/cc_8h.html">cc.h</a>"</span>
00023 
00024 <span class="comment">//</span>
00025 <span class="comment">//  Define our debug constant</span>
00026 <span class="comment">//</span>
00027 
<a name="l00028"></a><a class="code" href="../../d2/d9/pinsup_8c.html#a0">00028</a> <span class="preprocessor">#define me 0x00000008</span>
00029 <span class="preprocessor"></span>
00030 <span class="preprocessor">#if LIST_DBG</span>
00031 <span class="preprocessor"></span>
00032 <span class="preprocessor">#define SetCallersAddress(BCB) {                            \</span>
00033 <span class="preprocessor">    RtlGetCallersAddress( &amp;(BCB)-&gt;CallerAddress,            \</span>
00034 <span class="preprocessor">                          &amp;(BCB)-&gt;CallersCallerAddress );   \</span>
00035 <span class="preprocessor">}</span>
00036 <span class="preprocessor"></span>
00037 <span class="preprocessor">#endif</span>
00038 <span class="preprocessor"></span>
00039 <span class="comment">//</span>
00040 <span class="comment">//  Internal routines</span>
00041 <span class="comment">//</span>
00042 
00043 <a class="code" href="../../d6/d4/struct__OBCB.html">POBCB</a>
00044 <a class="code" href="../../d2/d9/pinsup_8c.html#a1">CcAllocateObcb</a> (
00045     IN PLARGE_INTEGER FileOffset,
00046     IN ULONG Length,
00047     IN <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> FirstBcb
00048     );
00049 
00050 
00051 BOOLEAN
<a name="l00052"></a><a class="code" href="../../d4/d2/cache_8h.html#a88">00052</a> <a class="code" href="../../d4/d2/cache_8h.html#a88">CcMapData</a> (
00053     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00054     IN PLARGE_INTEGER FileOffset,
00055     IN ULONG Length,
00056     IN BOOLEAN Wait,
00057     OUT PVOID *Bcb,
00058     OUT PVOID *Buffer
00059     )
00060 
00061 <span class="comment">/*++</span>
00062 <span class="comment"></span>
00063 <span class="comment">Routine Description:</span>
00064 <span class="comment"></span>
00065 <span class="comment">    This routine attempts to map the specified file data in the cache.</span>
00066 <span class="comment">    A pointer is returned to the desired data in the cache.</span>
00067 <span class="comment"></span>
00068 <span class="comment">    If the caller does not want to block on this call, then</span>
00069 <span class="comment">    Wait should be supplied as FALSE.  If Wait was supplied as FALSE and</span>
00070 <span class="comment">    it is currently impossible to supply the requested data without</span>
00071 <span class="comment">    blocking, then this routine will return FALSE.  However, if the</span>
00072 <span class="comment">    data is immediately accessible in the cache and no blocking is</span>
00073 <span class="comment">    required, this routine returns TRUE with a pointer to the data.</span>
00074 <span class="comment"></span>
00075 <span class="comment">    Note that a call to this routine with Wait supplied as TRUE is</span>
00076 <span class="comment">    considerably faster than a call with Wait supplies as FALSE, because</span>
00077 <span class="comment">    in the Wait TRUE case we only have to make sure the data is mapped</span>
00078 <span class="comment">    in order to return.</span>
00079 <span class="comment"></span>
00080 <span class="comment">    It is illegal to modify data that is only mapped, and can in fact lead</span>
00081 <span class="comment">    to serious problems.  It is impossible to check for this in all cases,</span>
00082 <span class="comment">    however CcSetDirtyPinnedData may implement some Assertions to check for</span>
00083 <span class="comment">    this.  If the caller wishes to modify data that it has only mapped, then</span>
00084 <span class="comment">    it must *first* call CcPinMappedData.</span>
00085 <span class="comment"></span>
00086 <span class="comment">    In any case, the caller MUST subsequently call CcUnpinData.</span>
00087 <span class="comment">    Naturally if CcPinRead or CcPreparePinWrite were called multiple</span>
00088 <span class="comment">    times for the same data, CcUnpinData must be called the same number</span>
00089 <span class="comment">    of times.</span>
00090 <span class="comment"></span>
00091 <span class="comment">    The returned Buffer pointer is valid until the data is unpinned, at</span>
00092 <span class="comment">    which point it is invalid to use the pointer further.  This buffer pointer</span>
00093 <span class="comment">    will remain valid if CcPinMappedData is called.</span>
00094 <span class="comment"></span>
00095 <span class="comment">    Note that under some circumstances (like Wait supplied as FALSE or more</span>
00096 <span class="comment">    than a page is requested), this routine may actually pin the data, however</span>
00097 <span class="comment">    it is not necessary, and in fact not correct, for the caller to be concerned</span>
00098 <span class="comment">    about this.</span>
00099 <span class="comment"></span>
00100 <span class="comment">Arguments:</span>
00101 <span class="comment"></span>
00102 <span class="comment">    FileObject - Pointer to the file object for a file which was</span>
00103 <span class="comment">                 opened with NO_INTERMEDIATE_BUFFERING clear, i.e., for</span>
00104 <span class="comment">                 which CcInitializeCacheMap was called by the file system.</span>
00105 <span class="comment"></span>
00106 <span class="comment">    FileOffset - Byte offset in file for desired data.</span>
00107 <span class="comment"></span>
00108 <span class="comment">    Length - Length of desired data in bytes.</span>
00109 <span class="comment"></span>
00110 <span class="comment">    Wait - FALSE if caller may not block, TRUE otherwise (see description</span>
00111 <span class="comment">           above)</span>
00112 <span class="comment"></span>
00113 <span class="comment">    Bcb - On the first call this returns a pointer to a Bcb</span>
00114 <span class="comment">          parameter which must be supplied as input on all subsequent</span>
00115 <span class="comment">          calls, for this buffer</span>
00116 <span class="comment"></span>
00117 <span class="comment">    Buffer - Returns pointer to desired data, valid until the buffer is</span>
00118 <span class="comment">             unpinned or freed.  This pointer will remain valid if CcPinMappedData</span>
00119 <span class="comment">             is called.</span>
00120 <span class="comment"></span>
00121 <span class="comment">Return Value:</span>
00122 <span class="comment"></span>
00123 <span class="comment">    FALSE - if Wait was supplied as FALSE and the data was not delivered</span>
00124 <span class="comment"></span>
00125 <span class="comment">    TRUE - if the data is being delivered</span>
00126 <span class="comment"></span>
00127 <span class="comment">--*/</span>
00128 
00129 {
00130     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
00131     LARGE_INTEGER BeyondLastByte;
00132     ULONG ReceivedLength;
00133     ULONG SavedState;
00134     <span class="keyword">volatile</span> UCHAR ch;
00135     ULONG PageCount = <a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a>((ULongToPtr(FileOffset-&gt;LowPart)), Length);
00136     <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a> Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
00137 
00138     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcMapData\n"</span>, 0 );
00139 
00140     <a class="code" href="../../d2/d1/mm_8h.html#a19">MmSavePageFaultReadAhead</a>( Thread, &amp;SavedState );
00141 
00142     <span class="comment">//</span>
00143     <span class="comment">//  Increment performance counters</span>
00144     <span class="comment">//</span>
00145 
00146     <span class="keywordflow">if</span> (Wait) {
00147 
00148         <a class="code" href="../../d5/d2/cachedat_8c.html#a53">CcMapDataWait</a> += 1;
00149 
00150         <span class="comment">//</span>
00151         <span class="comment">//  Initialize the indirect pointer to our miss counter.</span>
00152         <span class="comment">//</span>
00153 
00154         <a class="code" href="../../d5/d2/cachedat_8c.html#a75">CcMissCounter</a> = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a55">CcMapDataWaitMiss</a>;
00155 
00156     } <span class="keywordflow">else</span> {
00157         <a class="code" href="../../d5/d2/cachedat_8c.html#a52">CcMapDataNoWait</a> += 1;
00158     }
00159 
00160     <span class="comment">//</span>
00161     <span class="comment">//  Get pointer to SharedCacheMap.</span>
00162     <span class="comment">//</span>
00163 
00164     SharedCacheMap = *(<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> *)((PCHAR)FileObject-&gt;SectionObjectPointer
00165                                             + <span class="keyword">sizeof</span>(PVOID));
00166 
00167     <span class="comment">//</span>
00168     <span class="comment">//  Call local routine to Map or Access the file data.  If we cannot map</span>
00169     <span class="comment">//  the data because of a Wait condition, return FALSE.</span>
00170     <span class="comment">//</span>
00171 
00172     <span class="keywordflow">if</span> (Wait) {
00173 
00174         *<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = <a class="code" href="../../d5/d3/vacbsup_8c.html#a15">CcGetVirtualAddress</a>( SharedCacheMap,
00175                                        *FileOffset,
00176                                        (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a> *)Bcb,
00177                                        &amp;ReceivedLength );
00178 
00179         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( ReceivedLength &gt;= Length );
00180 
00181     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a175">CcPinFileData</a>( FileObject,
00182                                FileOffset,
00183                                Length,
00184                                <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00185                                <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00186                                Wait,
00187                                (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> *)Bcb,
00188                                <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>,
00189                                &amp;BeyondLastByte )) {
00190 
00191         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcMapData -&gt; FALSE\n"</span>, 0 );
00192 
00193         <a class="code" href="../../d5/d2/cachedat_8c.html#a54">CcMapDataNoWaitMiss</a> += 1;
00194 
00195         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00196 
00197     } <span class="keywordflow">else</span> {
00198 
00199         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( (BeyondLastByte.QuadPart - FileOffset-&gt;QuadPart) &gt;= Length );
00200 
00201 <span class="preprocessor">#if LIST_DBG</span>
00202 <span class="preprocessor"></span>        {
00203             KIRQL OldIrql;
00204             <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> BcbTemp = (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)*Bcb;
00205 
00206             ExAcquireSpinLock( &amp;<a class="code" href="../../d5/d5/cc_8h.html#a122">CcBcbSpinLock</a>, &amp;OldIrql );
00207 
00208             <span class="keywordflow">if</span> (BcbTemp-&gt;CcBcbLinks.Flink == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00209 
00210                 InsertTailList( &amp;CcBcbList, &amp;BcbTemp-&gt;CcBcbLinks );
00211                 CcBcbCount += 1;
00212                 ExReleaseSpinLock( &amp;<a class="code" href="../../d5/d5/cc_8h.html#a122">CcBcbSpinLock</a>, OldIrql );
00213                 SetCallersAddress( BcbTemp );
00214 
00215             } <span class="keywordflow">else</span> {
00216                 ExReleaseSpinLock( &amp;<a class="code" href="../../d5/d5/cc_8h.html#a122">CcBcbSpinLock</a>, OldIrql );
00217             }
00218 
00219         }
00220 <span class="preprocessor">#endif</span>
00221 <span class="preprocessor"></span>
00222     }
00223 
00224     <span class="comment">//</span>
00225     <span class="comment">//  Now let's just sit here and take the miss(es) like a man (and count them).</span>
00226     <span class="comment">//</span>
00227 
00228     <span class="keywordflow">try</span> {
00229 
00230         <span class="comment">//</span>
00231         <span class="comment">//  Loop to touch each page</span>
00232         <span class="comment">//</span>
00233 
00234         BeyondLastByte.LowPart = 0;
00235 
00236         <span class="keywordflow">while</span> (PageCount != 0) {
00237 
00238             <a class="code" href="../../d2/d1/mm_8h.html#a20">MmSetPageFaultReadAhead</a>( Thread, PageCount - 1 );
00239 
00240             ch = *((<span class="keyword">volatile</span> UCHAR *)(*Buffer) + BeyondLastByte.LowPart);
00241 
00242             BeyondLastByte.LowPart += <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>;
00243             PageCount -= 1;
00244         }
00245 
00246     } finally {
00247 
00248         <a class="code" href="../../d2/d1/mm_8h.html#a21">MmResetPageFaultReadAhead</a>( Thread, SavedState );
00249 
00250         <span class="keywordflow">if</span> (AbnormalTermination() &amp;&amp; (*Bcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)) {
00251             <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)*Bcb, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, <a class="code" href="../../d5/d5/cc_8h.html#a211a171">UNPIN</a> );
00252             *Bcb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00253         }
00254     }
00255 
00256     <a class="code" href="../../d5/d2/cachedat_8c.html#a75">CcMissCounter</a> = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a43">CcThrowAway</a>;
00257 
00258     <span class="comment">//</span>
00259     <span class="comment">// Increment the pointer as a reminder that it is read only.</span>
00260     <span class="comment">//</span>
00261 
00262     *(PCHAR *)Bcb += 1;
00263 
00264     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcMapData -&gt; TRUE\n"</span>, 0 );
00265 
00266     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00267 }
00268 
00269 
00270 BOOLEAN
<a name="l00271"></a><a class="code" href="../../d4/d2/cache_8h.html#a89">00271</a> <a class="code" href="../../d4/d2/cache_8h.html#a89">CcPinMappedData</a> (
00272     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00273     IN PLARGE_INTEGER FileOffset,
00274     IN ULONG Length,
00275     IN ULONG Flags,
00276     IN OUT PVOID *Bcb
00277     )
00278 
00279 <span class="comment">/*++</span>
00280 <span class="comment"></span>
00281 <span class="comment">Routine Description:</span>
00282 <span class="comment"></span>
00283 <span class="comment">    This routine attempts to pin data that was previously only mapped.</span>
00284 <span class="comment">    If the routine determines that in fact it was necessary to actually</span>
00285 <span class="comment">    pin the data when CcMapData was called, then this routine does not</span>
00286 <span class="comment">    have to do anything.</span>
00287 <span class="comment"></span>
00288 <span class="comment">    If the caller does not want to block on this call, then</span>
00289 <span class="comment">    Wait should be supplied as FALSE.  If Wait was supplied as FALSE and</span>
00290 <span class="comment">    it is currently impossible to supply the requested data without</span>
00291 <span class="comment">    blocking, then this routine will return FALSE.  However, if the</span>
00292 <span class="comment">    data is immediately accessible in the cache and no blocking is</span>
00293 <span class="comment">    required, this routine returns TRUE with a pointer to the data.</span>
00294 <span class="comment"></span>
00295 <span class="comment">    If the data is not returned in the first call, the caller</span>
00296 <span class="comment">    may request the data later with Wait = TRUE.  It is not required</span>
00297 <span class="comment">    that the caller request the data later.</span>
00298 <span class="comment"></span>
00299 <span class="comment">    If the caller subsequently modifies the data, it should call</span>
00300 <span class="comment">    CcSetDirtyPinnedData.</span>
00301 <span class="comment"></span>
00302 <span class="comment">    In any case, the caller MUST subsequently call CcUnpinData.</span>
00303 <span class="comment">    Naturally if CcPinRead or CcPreparePinWrite were called multiple</span>
00304 <span class="comment">    times for the same data, CcUnpinData must be called the same number</span>
00305 <span class="comment">    of times.</span>
00306 <span class="comment"></span>
00307 <span class="comment">    Note there are no performance counters in this routine, as the misses</span>
00308 <span class="comment">    will almost always occur on the map above, and there will seldom be a</span>
00309 <span class="comment">    miss on this conversion.</span>
00310 <span class="comment"></span>
00311 <span class="comment">Arguments:</span>
00312 <span class="comment"></span>
00313 <span class="comment">    FileObject - Pointer to the file object for a file which was</span>
00314 <span class="comment">                 opened with NO_INTERMEDIATE_BUFFERING clear, i.e., for</span>
00315 <span class="comment">                 which CcInitializeCacheMap was called by the file system.</span>
00316 <span class="comment"></span>
00317 <span class="comment">    FileOffset - Byte offset in file for desired data.</span>
00318 <span class="comment"></span>
00319 <span class="comment">    Length - Length of desired data in bytes.</span>
00320 <span class="comment"></span>
00321 <span class="comment">    Flags - (PIN_WAIT, PIN_EXCLUSIVE, PIN_NO_READ, etc. as defined in cache.h)</span>
00322 <span class="comment">            If the caller specifies PIN_NO_READ and PIN_EXCLUSIVE, then he must</span>
00323 <span class="comment">            guarantee that no one else will be attempting to map the view, if he</span>
00324 <span class="comment">            wants to guarantee that the Bcb is not mapped (view may be purged).</span>
00325 <span class="comment">            If the caller specifies PIN_NO_READ without PIN_EXCLUSIVE, the data</span>
00326 <span class="comment">            may or may not be mapped in the return Bcb.</span>
00327 <span class="comment"></span>
00328 <span class="comment">    Bcb - On the first call this returns a pointer to a Bcb</span>
00329 <span class="comment">          parameter which must be supplied as input on all subsequent</span>
00330 <span class="comment">          calls, for this buffer</span>
00331 <span class="comment"></span>
00332 <span class="comment">Return Value:</span>
00333 <span class="comment"></span>
00334 <span class="comment">    FALSE - if Wait was not set and the data was not delivered</span>
00335 <span class="comment"></span>
00336 <span class="comment">    TRUE - if the data is being delivered</span>
00337 <span class="comment"></span>
00338 <span class="comment">--*/</span>
00339 
00340 {
00341     PVOID <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>;
00342     LARGE_INTEGER BeyondLastByte;
00343     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
00344     LARGE_INTEGER LocalFileOffset = *FileOffset;
00345     <a class="code" href="../../d6/d4/struct__OBCB.html">POBCB</a> MyBcb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00346     <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> *CurrentBcbPtr = (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> *)&amp;MyBcb;
00347     BOOLEAN Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00348 
00349     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcPinMappedData\n"</span>, 0 );
00350 
00351     <span class="comment">//</span>
00352     <span class="comment">// If the Bcb is no longer ReadOnly, then just return.</span>
00353     <span class="comment">//</span>
00354 
00355     <span class="keywordflow">if</span> ((*(PULONG)Bcb &amp; 1) == 0) {
00356         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00357     }
00358 
00359     <span class="comment">//</span>
00360     <span class="comment">// Remove the Read Only flag</span>
00361     <span class="comment">//</span>
00362 
00363     *(PCHAR *)Bcb -= 1;
00364 
00365     <span class="comment">//</span>
00366     <span class="comment">//  Get pointer to SharedCacheMap.</span>
00367     <span class="comment">//</span>
00368 
00369     SharedCacheMap = *(<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> *)((PCHAR)FileObject-&gt;SectionObjectPointer
00370                                             + <span class="keyword">sizeof</span>(PVOID));
00371 
00372     <span class="comment">//</span>
00373     <span class="comment">//  We only count the calls to this routine, since they are almost guaranteed</span>
00374     <span class="comment">//  to be hits.</span>
00375     <span class="comment">//</span>
00376 
00377     <a class="code" href="../../d5/d2/cachedat_8c.html#a56">CcPinMappedDataCount</a> += 1;
00378 
00379     <span class="comment">//</span>
00380     <span class="comment">//  Guarantee we will put the flag back if required.</span>
00381     <span class="comment">//</span>
00382 
00383     <span class="keywordflow">try</span> {
00384 
00385         <span class="keywordflow">if</span> (((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)*Bcb)-&gt;NodeTypeCode != <a class="code" href="../../d5/d5/cc_8h.html#a14">CACHE_NTC_BCB</a>) {
00386 
00387             <span class="comment">//</span>
00388             <span class="comment">//  Form loop to handle occassional overlapped Bcb case.</span>
00389             <span class="comment">//</span>
00390 
00391             <span class="keywordflow">do</span> {
00392 
00393                 <span class="comment">//</span>
00394                 <span class="comment">//  If we have already been through the loop, then adjust</span>
00395                 <span class="comment">//  our file offset and length from the last time.</span>
00396                 <span class="comment">//</span>
00397 
00398                 <span class="keywordflow">if</span> (MyBcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00399 
00400                     <span class="comment">//</span>
00401                     <span class="comment">//  If this is the second time through the loop, then it is time</span>
00402                     <span class="comment">//  to handle the overlap case and allocate an OBCB.</span>
00403                     <span class="comment">//</span>
00404 
00405                     <span class="keywordflow">if</span> (CurrentBcbPtr == (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> *)&amp;MyBcb) {
00406 
00407                         MyBcb = <a class="code" href="../../d2/d9/pinsup_8c.html#a1">CcAllocateObcb</a>( FileOffset, Length, (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)MyBcb );
00408 
00409                         <span class="comment">//</span>
00410                         <span class="comment">//  Set CurrentBcbPtr to point at the first entry in</span>
00411                         <span class="comment">//  the vector (which is already filled in), before</span>
00412                         <span class="comment">//  advancing it below.</span>
00413                         <span class="comment">//</span>
00414 
00415                         CurrentBcbPtr = &amp;MyBcb-&gt;Bcbs[0];
00416                     }
00417 
00418                     Length -= (ULONG)(BeyondLastByte.QuadPart - LocalFileOffset.QuadPart);
00419                     LocalFileOffset.QuadPart = BeyondLastByte.QuadPart;
00420                     CurrentBcbPtr += 1;
00421                 }
00422 
00423                 <span class="comment">//</span>
00424                 <span class="comment">//  Call local routine to Map or Access the file data.  If we cannot map</span>
00425                 <span class="comment">//  the data because of a Wait condition, return FALSE.</span>
00426                 <span class="comment">//</span>
00427 
00428                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a175">CcPinFileData</a>( FileObject,
00429                                     &amp;LocalFileOffset,
00430                                     Length,
00431                                     (BOOLEAN)!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a78">MODIFIED_WRITE_DISABLED</a>),
00432                                     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00433                                     Flags,
00434                                     CurrentBcbPtr,
00435                                     &amp;<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>,
00436                                     &amp;BeyondLastByte )) {
00437 
00438                     <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>( Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00439                 }
00440 
00441             <span class="comment">//</span>
00442             <span class="comment">//  Continue looping if we did not get everything.</span>
00443             <span class="comment">//</span>
00444 
00445             } <span class="keywordflow">while</span>((BeyondLastByte.QuadPart - LocalFileOffset.QuadPart) &lt; Length);
00446 
00447             <span class="comment">//</span>
00448             <span class="comment">//  Free the Vacb before going on.</span>
00449             <span class="comment">//</span>
00450 
00451             <a class="code" href="../../d5/d3/vacbsup_8c.html#a16">CcFreeVirtualAddress</a>( (<a class="code" href="../../d2/d5/struct__VACB.html">PVACB</a>)*Bcb );
00452 
00453             *Bcb = MyBcb;
00454 
00455             <span class="comment">//</span>
00456             <span class="comment">//  Debug routines used to insert and remove Bcbs from the global list</span>
00457             <span class="comment">//</span>
00458 
00459 <span class="preprocessor">#if LIST_DBG</span>
00460 <span class="preprocessor"></span>            {
00461                 KIRQL OldIrql;
00462                 <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> BcbTemp = (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)*Bcb;
00463 
00464                 ExAcquireSpinLock( &amp;<a class="code" href="../../d5/d5/cc_8h.html#a122">CcBcbSpinLock</a>, &amp;OldIrql );
00465 
00466                 <span class="keywordflow">if</span> (BcbTemp-&gt;CcBcbLinks.Flink == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00467 
00468                     InsertTailList( &amp;CcBcbList, &amp;BcbTemp-&gt;CcBcbLinks );
00469                     CcBcbCount += 1;
00470                     ExReleaseSpinLock( &amp;<a class="code" href="../../d5/d5/cc_8h.html#a122">CcBcbSpinLock</a>, OldIrql );
00471                     SetCallersAddress( BcbTemp );
00472 
00473                 } <span class="keywordflow">else</span> {
00474                     ExReleaseSpinLock( &amp;<a class="code" href="../../d5/d5/cc_8h.html#a122">CcBcbSpinLock</a>, OldIrql );
00475                 }
00476 
00477             }
00478 <span class="preprocessor">#endif</span>
00479 <span class="preprocessor"></span>        }
00480 
00481         <span class="comment">//</span>
00482         <span class="comment">//  If he really has a Bcb, all we have to do is acquire it shared since he is</span>
00483         <span class="comment">//  no longer ReadOnly.</span>
00484         <span class="comment">//</span>
00485 
00486         <span class="keywordflow">else</span> {
00487 
00488             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d8/ex_8h.html#a270">ExAcquireSharedStarveExclusive</a>( &amp;((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)*Bcb)-&gt;<a class="code" href="../../d4/d0/tex_8c.html#a21">Resource</a>, <a class="code" href="../../d5/d5/cc_8h.html#a59">BooleanFlagOn</a>(Flags, <a class="code" href="../../d4/d2/cache_8h.html#a6">PIN_WAIT</a>))) {
00489 
00490                 <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>( Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00491             }
00492         }
00493 
00494         Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00495 
00496     try_exit: NOTHING;
00497     }
00498     finally {
00499 
00500         <span class="keywordflow">if</span> (!Result) {
00501 
00502             <span class="comment">//</span>
00503             <span class="comment">//  Put the Read Only flag back</span>
00504             <span class="comment">//</span>
00505 
00506             *(PCHAR *)Bcb += 1;
00507 
00508             <span class="comment">//</span>
00509             <span class="comment">//  We may have gotten partway through</span>
00510             <span class="comment">//</span>
00511 
00512             <span class="keywordflow">if</span> (MyBcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00513                 <a class="code" href="../../d4/d2/cache_8h.html#a92">CcUnpinData</a>( MyBcb );
00514             }
00515         }
00516 
00517         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcPinMappedData -&gt; %02lx\n"</span>, Result );
00518     }
00519     <span class="keywordflow">return</span> Result;
00520 }
00521 
00522 
00523 BOOLEAN
<a name="l00524"></a><a class="code" href="../../d4/d2/cache_8h.html#a87">00524</a> <a class="code" href="../../d4/d2/cache_8h.html#a87">CcPinRead</a> (
00525     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00526     IN PLARGE_INTEGER FileOffset,
00527     IN ULONG Length,
00528     IN ULONG Flags,
00529     OUT PVOID *Bcb,
00530     OUT PVOID *Buffer
00531     )
00532 
00533 <span class="comment">/*++</span>
00534 <span class="comment"></span>
00535 <span class="comment">Routine Description:</span>
00536 <span class="comment"></span>
00537 <span class="comment">    This routine attempts to pin the specified file data in the cache.</span>
00538 <span class="comment">    A pointer is returned to the desired data in the cache.  This routine</span>
00539 <span class="comment">    is intended for File System support and is not intended to be called</span>
00540 <span class="comment">    from Dpc level.</span>
00541 <span class="comment"></span>
00542 <span class="comment">    If the caller does not want to block on this call, then</span>
00543 <span class="comment">    Wait should be supplied as FALSE.  If Wait was supplied as FALSE and</span>
00544 <span class="comment">    it is currently impossible to supply the requested data without</span>
00545 <span class="comment">    blocking, then this routine will return FALSE.  However, if the</span>
00546 <span class="comment">    data is immediately accessible in the cache and no blocking is</span>
00547 <span class="comment">    required, this routine returns TRUE with a pointer to the data.</span>
00548 <span class="comment"></span>
00549 <span class="comment">    If the data is not returned in the first call, the caller</span>
00550 <span class="comment">    may request the data later with Wait = TRUE.  It is not required</span>
00551 <span class="comment">    that the caller request the data later.</span>
00552 <span class="comment"></span>
00553 <span class="comment">    If the caller subsequently modifies the data, it should call</span>
00554 <span class="comment">    CcSetDirtyPinnedData.</span>
00555 <span class="comment"></span>
00556 <span class="comment">    In any case, the caller MUST subsequently call CcUnpinData.</span>
00557 <span class="comment">    Naturally if CcPinRead or CcPreparePinWrite were called multiple</span>
00558 <span class="comment">    times for the same data, CcUnpinData must be called the same number</span>
00559 <span class="comment">    of times.</span>
00560 <span class="comment"></span>
00561 <span class="comment">    The returned Buffer pointer is valid until the data is unpinned, at</span>
00562 <span class="comment">    which point it is invalid to use the pointer further.</span>
00563 <span class="comment"></span>
00564 <span class="comment">Arguments:</span>
00565 <span class="comment"></span>
00566 <span class="comment">    FileObject - Pointer to the file object for a file which was</span>
00567 <span class="comment">                 opened with NO_INTERMEDIATE_BUFFERING clear, i.e., for</span>
00568 <span class="comment">                 which CcInitializeCacheMap was called by the file system.</span>
00569 <span class="comment"></span>
00570 <span class="comment">    FileOffset - Byte offset in file for desired data.</span>
00571 <span class="comment"></span>
00572 <span class="comment">    Length - Length of desired data in bytes.</span>
00573 <span class="comment"></span>
00574 <span class="comment">    Flags - (PIN_WAIT, PIN_EXCLUSIVE, PIN_NO_READ, etc. as defined in cache.h)</span>
00575 <span class="comment">            If the caller specifies PIN_NO_READ and PIN_EXCLUSIVE, then he must</span>
00576 <span class="comment">            guarantee that no one else will be attempting to map the view, if he</span>
00577 <span class="comment">            wants to guarantee that the Bcb is not mapped (view may be purged).</span>
00578 <span class="comment">            If the caller specifies PIN_NO_READ without PIN_EXCLUSIVE, the data</span>
00579 <span class="comment">            may or may not be mapped in the return Bcb.</span>
00580 <span class="comment"></span>
00581 <span class="comment">    Bcb - On the first call this returns a pointer to a Bcb</span>
00582 <span class="comment">          parameter which must be supplied as input on all subsequent</span>
00583 <span class="comment">          calls, for this buffer</span>
00584 <span class="comment"></span>
00585 <span class="comment">    Buffer - Returns pointer to desired data, valid until the buffer is</span>
00586 <span class="comment">             unpinned or freed.</span>
00587 <span class="comment"></span>
00588 <span class="comment">Return Value:</span>
00589 <span class="comment"></span>
00590 <span class="comment">    FALSE - if Wait was not set and the data was not delivered</span>
00591 <span class="comment"></span>
00592 <span class="comment">    TRUE - if the data is being delivered</span>
00593 <span class="comment"></span>
00594 <span class="comment">--*/</span>
00595 
00596 {
00597     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
00598     PVOID LocalBuffer;
00599     LARGE_INTEGER BeyondLastByte;
00600     LARGE_INTEGER LocalFileOffset = *FileOffset;
00601     <a class="code" href="../../d6/d4/struct__OBCB.html">POBCB</a> MyBcb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00602     <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> *CurrentBcbPtr = (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> *)&amp;MyBcb;
00603     BOOLEAN Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00604 
00605     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcPinRead\n"</span>, 0 );
00606 
00607     <span class="comment">//</span>
00608     <span class="comment">//  Increment performance counters</span>
00609     <span class="comment">//</span>
00610 
00611     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(Flags, <a class="code" href="../../d4/d2/cache_8h.html#a6">PIN_WAIT</a>)) {
00612 
00613         <a class="code" href="../../d5/d2/cachedat_8c.html#a58">CcPinReadWait</a> += 1;
00614 
00615         <span class="comment">//</span>
00616         <span class="comment">//  Initialize the indirect pointer to our miss counter.</span>
00617         <span class="comment">//</span>
00618 
00619         <a class="code" href="../../d5/d2/cachedat_8c.html#a75">CcMissCounter</a> = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a60">CcPinReadWaitMiss</a>;
00620 
00621     } <span class="keywordflow">else</span> {
00622         <a class="code" href="../../d5/d2/cachedat_8c.html#a57">CcPinReadNoWait</a> += 1;
00623     }
00624 
00625     <span class="comment">//</span>
00626     <span class="comment">//  Get pointer to SharedCacheMap.</span>
00627     <span class="comment">//</span>
00628 
00629     SharedCacheMap = *(<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> *)((PCHAR)FileObject-&gt;SectionObjectPointer
00630                                             + <span class="keyword">sizeof</span>(PVOID));
00631 
00632     <span class="keywordflow">try</span> {
00633 
00634         <span class="comment">//</span>
00635         <span class="comment">//  Form loop to handle occassional overlapped Bcb case.</span>
00636         <span class="comment">//</span>
00637 
00638         <span class="keywordflow">do</span> {
00639 
00640             <span class="comment">//</span>
00641             <span class="comment">//  If we have already been through the loop, then adjust</span>
00642             <span class="comment">//  our file offset and length from the last time.</span>
00643             <span class="comment">//</span>
00644 
00645             <span class="keywordflow">if</span> (MyBcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00646 
00647                 <span class="comment">//</span>
00648                 <span class="comment">//  If this is the second time through the loop, then it is time</span>
00649                 <span class="comment">//  to handle the overlap case and allocate an OBCB.</span>
00650                 <span class="comment">//</span>
00651 
00652                 <span class="keywordflow">if</span> (CurrentBcbPtr == (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> *)&amp;MyBcb) {
00653 
00654                     MyBcb = <a class="code" href="../../d2/d9/pinsup_8c.html#a1">CcAllocateObcb</a>( FileOffset, Length, (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)MyBcb );
00655 
00656                     <span class="comment">//</span>
00657                     <span class="comment">//  Set CurrentBcbPtr to point at the first entry in</span>
00658                     <span class="comment">//  the vector (which is already filled in), before</span>
00659                     <span class="comment">//  advancing it below.</span>
00660                     <span class="comment">//</span>
00661 
00662                     CurrentBcbPtr = &amp;MyBcb-&gt;Bcbs[0];
00663 
00664                     <span class="comment">//</span>
00665                     <span class="comment">//  Also on second time through, return starting Buffer</span>
00666                     <span class="comment">//</span>
00667 
00668                     *<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = LocalBuffer;
00669                 }
00670 
00671                 Length -= (ULONG)(BeyondLastByte.QuadPart - LocalFileOffset.QuadPart);
00672                 LocalFileOffset.QuadPart = BeyondLastByte.QuadPart;
00673                 CurrentBcbPtr += 1;
00674             }
00675 
00676             <span class="comment">//</span>
00677             <span class="comment">//  Call local routine to Map or Access the file data.  If we cannot map</span>
00678             <span class="comment">//  the data because of a Wait condition, return FALSE.</span>
00679             <span class="comment">//</span>
00680 
00681             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a175">CcPinFileData</a>( FileObject,
00682                                 &amp;LocalFileOffset,
00683                                 Length,
00684                                 (BOOLEAN)!<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>(SharedCacheMap-&gt;<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html#o18">Flags</a>, <a class="code" href="../../d5/d5/cc_8h.html#a78">MODIFIED_WRITE_DISABLED</a>),
00685                                 <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00686                                 Flags,
00687                                 CurrentBcbPtr,
00688                                 &amp;LocalBuffer,
00689                                 &amp;BeyondLastByte )) {
00690 
00691                 <a class="code" href="../../d5/d2/cachedat_8c.html#a59">CcPinReadNoWaitMiss</a> += 1;
00692 
00693                 <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>( Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00694             }
00695 
00696         <span class="comment">//</span>
00697         <span class="comment">//  Continue looping if we did not get everything.</span>
00698         <span class="comment">//</span>
00699 
00700         } <span class="keywordflow">while</span>((BeyondLastByte.QuadPart - LocalFileOffset.QuadPart) &lt; Length);
00701 
00702         *Bcb = MyBcb;
00703 
00704         <span class="comment">//</span>
00705         <span class="comment">//  Debug routines used to insert and remove Bcbs from the global list</span>
00706         <span class="comment">//</span>
00707 
00708 <span class="preprocessor">#if LIST_DBG</span>
00709 <span class="preprocessor"></span>
00710         {
00711             KIRQL OldIrql;
00712             <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> BcbTemp = (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)*Bcb;
00713 
00714             ExAcquireSpinLock( &amp;<a class="code" href="../../d5/d5/cc_8h.html#a122">CcBcbSpinLock</a>, &amp;OldIrql );
00715 
00716             <span class="keywordflow">if</span> (BcbTemp-&gt;CcBcbLinks.Flink == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00717 
00718                 InsertTailList( &amp;CcBcbList, &amp;BcbTemp-&gt;CcBcbLinks );
00719                 CcBcbCount += 1;
00720                 ExReleaseSpinLock( &amp;<a class="code" href="../../d5/d5/cc_8h.html#a122">CcBcbSpinLock</a>, OldIrql );
00721                 SetCallersAddress( BcbTemp );
00722 
00723             } <span class="keywordflow">else</span> {
00724                 ExReleaseSpinLock( &amp;<a class="code" href="../../d5/d5/cc_8h.html#a122">CcBcbSpinLock</a>, OldIrql );
00725             }
00726 
00727         }
00728 
00729 <span class="preprocessor">#endif</span>
00730 <span class="preprocessor"></span>
00731         <span class="comment">//</span>
00732         <span class="comment">//  In the normal (nonoverlapping) case we return the</span>
00733         <span class="comment">//  correct buffer address here.</span>
00734         <span class="comment">//</span>
00735 
00736         <span class="keywordflow">if</span> (CurrentBcbPtr == (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> *)&amp;MyBcb) {
00737             *<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = LocalBuffer;
00738         }
00739 
00740         Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00741 
00742     try_exit: NOTHING;
00743     }
00744     finally {
00745 
00746         <a class="code" href="../../d5/d2/cachedat_8c.html#a75">CcMissCounter</a> = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a43">CcThrowAway</a>;
00747 
00748         <span class="keywordflow">if</span> (!Result) {
00749 
00750             <span class="comment">//</span>
00751             <span class="comment">//  We may have gotten partway through</span>
00752             <span class="comment">//</span>
00753 
00754             <span class="keywordflow">if</span> (MyBcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00755                 <a class="code" href="../../d4/d2/cache_8h.html#a92">CcUnpinData</a>( MyBcb );
00756             }
00757         }
00758 
00759         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcPinRead -&gt; %02lx\n"</span>, Result );
00760     }
00761 
00762     <span class="keywordflow">return</span> Result;
00763 }
00764 
00765 
00766 BOOLEAN
<a name="l00767"></a><a class="code" href="../../d4/d2/cache_8h.html#a90">00767</a> <a class="code" href="../../d4/d2/cache_8h.html#a90">CcPreparePinWrite</a> (
00768     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00769     IN PLARGE_INTEGER FileOffset,
00770     IN ULONG Length,
00771     IN BOOLEAN Zero,
00772     IN ULONG Flags,
00773     OUT PVOID *Bcb,
00774     OUT PVOID *Buffer
00775     )
00776 
00777 <span class="comment">/*++</span>
00778 <span class="comment"></span>
00779 <span class="comment">Routine Description:</span>
00780 <span class="comment"></span>
00781 <span class="comment">    This routine attempts to lock the specified file data in the cache</span>
00782 <span class="comment">    and return a pointer to it along with the correct</span>
00783 <span class="comment">    I/O status.  Pages to be completely overwritten may be satisfied</span>
00784 <span class="comment">    with emtpy pages.</span>
00785 <span class="comment"></span>
00786 <span class="comment">    If not all of the pages can be prepared, and Wait was supplied as</span>
00787 <span class="comment">    FALSE, then this routine will return FALSE, and its outputs will</span>
00788 <span class="comment">    be meaningless.  The caller may request the data later with</span>
00789 <span class="comment">    Wait = TRUE.  However, it is not required that the caller request</span>
00790 <span class="comment">    the data later.</span>
00791 <span class="comment"></span>
00792 <span class="comment">    If Wait is supplied as TRUE, and all of the pages can be prepared</span>
00793 <span class="comment">    without blocking, this call will return TRUE immediately.  Otherwise,</span>
00794 <span class="comment">    this call will block until all of the pages can be prepared, and</span>
00795 <span class="comment">    then return TRUE.</span>
00796 <span class="comment"></span>
00797 <span class="comment">    When this call returns with TRUE, the caller may immediately begin</span>
00798 <span class="comment">    to transfer data into the buffers via the Buffer pointer.  The</span>
00799 <span class="comment">    buffer will already be marked dirty.</span>
00800 <span class="comment"></span>
00801 <span class="comment">    The caller MUST subsequently call CcUnpinData.</span>
00802 <span class="comment">    Naturally if CcPinRead or CcPreparePinWrite were called multiple</span>
00803 <span class="comment">    times for the same data, CcUnpinData must be called the same number</span>
00804 <span class="comment">    of times.</span>
00805 <span class="comment"></span>
00806 <span class="comment">    The returned Buffer pointer is valid until the data is unpinned, at</span>
00807 <span class="comment">    which point it is invalid to use the pointer further.</span>
00808 <span class="comment"></span>
00809 <span class="comment">Arguments:</span>
00810 <span class="comment"></span>
00811 <span class="comment">    FileObject - Pointer to the file object for a file which was</span>
00812 <span class="comment">                 opened with NO_INTERMEDIATE_BUFFERING clear, i.e., for</span>
00813 <span class="comment">                 which CcInitializeCacheMap was called by the file system.</span>
00814 <span class="comment"></span>
00815 <span class="comment">    FileOffset - Byte offset in file for desired data.</span>
00816 <span class="comment"></span>
00817 <span class="comment">    Length - Length of desired data in bytes.</span>
00818 <span class="comment"></span>
00819 <span class="comment">    Zero - If supplied as TRUE, the buffer will be zeroed on return.</span>
00820 <span class="comment"></span>
00821 <span class="comment">    Flags - (PIN_WAIT, PIN_EXCLUSIVE, PIN_NO_READ, etc. as defined in cache.h)</span>
00822 <span class="comment">            If the caller specifies PIN_NO_READ and PIN_EXCLUSIVE, then he must</span>
00823 <span class="comment">            guarantee that no one else will be attempting to map the view, if he</span>
00824 <span class="comment">            wants to guarantee that the Bcb is not mapped (view may be purged).</span>
00825 <span class="comment">            If the caller specifies PIN_NO_READ without PIN_EXCLUSIVE, the data</span>
00826 <span class="comment">            may or may not be mapped in the return Bcb.</span>
00827 <span class="comment"></span>
00828 <span class="comment">    Bcb - This returns a pointer to a Bcb parameter which must be</span>
00829 <span class="comment">          supplied as input to CcPinWriteComplete.</span>
00830 <span class="comment"></span>
00831 <span class="comment">    Buffer - Returns pointer to desired data, valid until the buffer is</span>
00832 <span class="comment">             unpinned or freed.</span>
00833 <span class="comment"></span>
00834 <span class="comment">Return Value:</span>
00835 <span class="comment"></span>
00836 <span class="comment">    FALSE - if Wait was not set and the data was not delivered</span>
00837 <span class="comment"></span>
00838 <span class="comment">    TRUE - if the pages are being delivered</span>
00839 <span class="comment"></span>
00840 <span class="comment">--*/</span>
00841 
00842 {
00843     <a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> SharedCacheMap;
00844     PVOID LocalBuffer;
00845     LARGE_INTEGER BeyondLastByte;
00846     LARGE_INTEGER LocalFileOffset = *FileOffset;
00847     <a class="code" href="../../d6/d4/struct__OBCB.html">POBCB</a> MyBcb = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00848     <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> *CurrentBcbPtr = (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> *)&amp;MyBcb;
00849     ULONG OriginalLength = Length;
00850     BOOLEAN Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00851 
00852     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcPreparePinWrite\n"</span>, 0 );
00853 
00854     <span class="comment">//</span>
00855     <span class="comment">//  Get pointer to SharedCacheMap.</span>
00856     <span class="comment">//</span>
00857 
00858     SharedCacheMap = *(<a class="code" href="../../d0/d3/struct__SHARED__CACHE__MAP.html">PSHARED_CACHE_MAP</a> *)((PCHAR)FileObject-&gt;SectionObjectPointer
00859                                             + <span class="keyword">sizeof</span>(PVOID));
00860 
00861     <span class="keywordflow">try</span> {
00862 
00863         <span class="comment">//</span>
00864         <span class="comment">//  Form loop to handle occassional overlapped Bcb case.</span>
00865         <span class="comment">//</span>
00866 
00867         <span class="keywordflow">do</span> {
00868 
00869             <span class="comment">//</span>
00870             <span class="comment">//  If we have already been through the loop, then adjust</span>
00871             <span class="comment">//  our file offset and length from the last time.</span>
00872             <span class="comment">//</span>
00873 
00874             <span class="keywordflow">if</span> (MyBcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00875 
00876                 <span class="comment">//</span>
00877                 <span class="comment">//  If this is the second time through the loop, then it is time</span>
00878                 <span class="comment">//  to handle the overlap case and allocate an OBCB.</span>
00879                 <span class="comment">//</span>
00880 
00881                 <span class="keywordflow">if</span> (CurrentBcbPtr == (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> *)&amp;MyBcb) {
00882 
00883                     MyBcb = <a class="code" href="../../d2/d9/pinsup_8c.html#a1">CcAllocateObcb</a>( FileOffset, Length, (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)MyBcb );
00884 
00885                     <span class="comment">//</span>
00886                     <span class="comment">//  Set CurrentBcbPtr to point at the first entry in</span>
00887                     <span class="comment">//  the vector (which is already filled in), before</span>
00888                     <span class="comment">//  advancing it below.</span>
00889                     <span class="comment">//</span>
00890 
00891                     CurrentBcbPtr = &amp;MyBcb-&gt;Bcbs[0];
00892 
00893                     <span class="comment">//</span>
00894                     <span class="comment">//  Also on second time through, return starting Buffer</span>
00895                     <span class="comment">//</span>
00896 
00897                     *<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = LocalBuffer;
00898                 }
00899 
00900                 Length -= (ULONG)(BeyondLastByte.QuadPart - LocalFileOffset.QuadPart);
00901                 LocalFileOffset.QuadPart = BeyondLastByte.QuadPart;
00902                 CurrentBcbPtr += 1;
00903             }
00904 
00905             <span class="comment">//</span>
00906             <span class="comment">//  Call local routine to Map or Access the file data.  If we cannot map</span>
00907             <span class="comment">//  the data because of a Wait condition, return FALSE.</span>
00908             <span class="comment">//</span>
00909 
00910             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d5/cc_8h.html#a175">CcPinFileData</a>( FileObject,
00911                                 &amp;LocalFileOffset,
00912                                 Length,
00913                                 <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
00914                                 <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
00915                                 Flags,
00916                                 CurrentBcbPtr,
00917                                 &amp;LocalBuffer,
00918                                 &amp;BeyondLastByte )) {
00919 
00920                 <a class="code" href="../../d5/d5/cc_8h.html#a90">try_return</a>( Result = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00921             }
00922 
00923         <span class="comment">//</span>
00924         <span class="comment">//  Continue looping if we did not get everything.</span>
00925         <span class="comment">//</span>
00926 
00927         } <span class="keywordflow">while</span>((BeyondLastByte.QuadPart - LocalFileOffset.QuadPart) &lt; Length);
00928 
00929         *Bcb = MyBcb;
00930 
00931         <span class="comment">//</span>
00932         <span class="comment">//  Debug routines used to insert and remove Bcbs from the global list</span>
00933         <span class="comment">//</span>
00934 
00935 <span class="preprocessor">#if LIST_DBG</span>
00936 <span class="preprocessor"></span>
00937         {
00938             KIRQL OldIrql;
00939             <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> BcbTemp = (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)*Bcb;
00940 
00941             ExAcquireSpinLock( &amp;<a class="code" href="../../d5/d5/cc_8h.html#a122">CcBcbSpinLock</a>, &amp;OldIrql );
00942 
00943             <span class="keywordflow">if</span> (BcbTemp-&gt;CcBcbLinks.Flink == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00944 
00945                 InsertTailList( &amp;CcBcbList, &amp;BcbTemp-&gt;CcBcbLinks );
00946                 CcBcbCount += 1;
00947                 ExReleaseSpinLock( &amp;<a class="code" href="../../d5/d5/cc_8h.html#a122">CcBcbSpinLock</a>, OldIrql );
00948                 SetCallersAddress( BcbTemp );
00949 
00950             } <span class="keywordflow">else</span> {
00951                 ExReleaseSpinLock( &amp;<a class="code" href="../../d5/d5/cc_8h.html#a122">CcBcbSpinLock</a>, OldIrql );
00952             }
00953 
00954         }
00955 
00956 <span class="preprocessor">#endif</span>
00957 <span class="preprocessor"></span>
00958         <span class="comment">//</span>
00959         <span class="comment">//  In the normal (nonoverlapping) case we return the</span>
00960         <span class="comment">//  correct buffer address here.</span>
00961         <span class="comment">//</span>
00962 
00963         <span class="keywordflow">if</span> (CurrentBcbPtr == (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> *)&amp;MyBcb) {
00964             *<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a> = LocalBuffer;
00965         }
00966 
00967         <span class="keywordflow">if</span> (<a class="code" href="../../d6/d6/ttime_8c.html#a0">Zero</a>) {
00968             RtlZeroMemory( *<a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, OriginalLength );
00969         }
00970 
00971         <a class="code" href="../../d4/d2/cache_8h.html#a91">CcSetDirtyPinnedData</a>( MyBcb, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00972 
00973         Result = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00974 
00975     try_exit: NOTHING;
00976     }
00977     finally {
00978 
00979         <a class="code" href="../../d5/d2/cachedat_8c.html#a75">CcMissCounter</a> = &amp;<a class="code" href="../../d5/d2/cachedat_8c.html#a43">CcThrowAway</a>;
00980 
00981         <span class="keywordflow">if</span> (!Result) {
00982 
00983             <span class="comment">//</span>
00984             <span class="comment">//  We may have gotten partway through</span>
00985             <span class="comment">//</span>
00986 
00987             <span class="keywordflow">if</span> (MyBcb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00988                 <a class="code" href="../../d4/d2/cache_8h.html#a92">CcUnpinData</a>( MyBcb );
00989             }
00990         }
00991 
00992         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcPreparePinWrite -&gt; %02lx\n"</span>, Result );
00993     }
00994 
00995     <span class="keywordflow">return</span> Result;
00996 }
00997 
00998 
00999 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01000"></a><a class="code" href="../../d4/d2/cache_8h.html#a92">01000</a> <a class="code" href="../../d4/d2/cache_8h.html#a92">CcUnpinData</a> (
01001     IN PVOID Bcb
01002     )
01003 
01004 <span class="comment">/*++</span>
01005 <span class="comment"></span>
01006 <span class="comment">Routine Description:</span>
01007 <span class="comment"></span>
01008 <span class="comment">    This routine must be called at IPL0, some time after calling CcPinRead</span>
01009 <span class="comment">    or CcPreparePinWrite.  It performs any cleanup that is necessary.</span>
01010 <span class="comment"></span>
01011 <span class="comment">Arguments:</span>
01012 <span class="comment"></span>
01013 <span class="comment">    Bcb - Bcb parameter returned from the last call to CcPinRead.</span>
01014 <span class="comment"></span>
01015 <span class="comment">Return Value:</span>
01016 <span class="comment"></span>
01017 <span class="comment">    None.</span>
01018 <span class="comment"></span>
01019 <span class="comment">--*/</span>
01020 
01021 {
01022     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcUnpinData:\n"</span>, 0 );
01023     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    &gt;Bcb = %08lx\n"</span>, Bcb );
01024 
01025     <span class="comment">//</span>
01026     <span class="comment">//  Test for ReadOnly and unpin accordingly.</span>
01027     <span class="comment">//</span>
01028 
01029     <span class="keywordflow">if</span> (((ULONG_PTR)Bcb &amp; 1) != 0) {
01030 
01031         <span class="comment">//</span>
01032         <span class="comment">//  Remove the Read Only flag</span>
01033         <span class="comment">//</span>
01034 
01035         (PCHAR)Bcb -= 1;
01036 
01037         <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, <a class="code" href="../../d5/d5/cc_8h.html#a211a171">UNPIN</a> );
01038 
01039     } <span class="keywordflow">else</span> {
01040 
01041         <span class="comment">//</span>
01042         <span class="comment">//  Handle the overlapped Bcb case.</span>
01043         <span class="comment">//</span>
01044 
01045         <span class="keywordflow">if</span> (((<a class="code" href="../../d6/d4/struct__OBCB.html">POBCB</a>)Bcb)-&gt;NodeTypeCode == <a class="code" href="../../d5/d5/cc_8h.html#a17">CACHE_NTC_OBCB</a>) {
01046 
01047             <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> *BcbPtrPtr = &amp;((<a class="code" href="../../d6/d4/struct__OBCB.html">POBCB</a>)Bcb)-&gt;Bcbs[0];
01048 
01049             <span class="comment">//</span>
01050             <span class="comment">//  Loop to free all Bcbs with recursive calls</span>
01051             <span class="comment">//  (rather than dealing with RO for this uncommon case).</span>
01052             <span class="comment">//</span>
01053 
01054             <span class="keywordflow">while</span> (*BcbPtrPtr != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01055                 <a class="code" href="../../d4/d2/cache_8h.html#a92">CcUnpinData</a>(*(BcbPtrPtr++));
01056             }
01057 
01058             <span class="comment">//</span>
01059             <span class="comment">//  Then free the pool for the Obcb</span>
01060             <span class="comment">//</span>
01061 
01062             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( Bcb );
01063 
01064         <span class="comment">//</span>
01065         <span class="comment">//  Otherwise, it is a normal Bcb</span>
01066         <span class="comment">//</span>
01067 
01068         } <span class="keywordflow">else</span> {
01069             <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, <a class="code" href="../../d5/d5/cc_8h.html#a211a171">UNPIN</a> );
01070         }
01071     }
01072 
01073     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcUnPinData -&gt; VOID\n"</span>, 0 );
01074 }
01075 
01076 
01077 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01078"></a><a class="code" href="../../d4/d2/cache_8h.html#a93">01078</a> <a class="code" href="../../d4/d2/cache_8h.html#a93">CcSetBcbOwnerPointer</a> (
01079     IN PVOID Bcb,
01080     IN PVOID OwnerPointer
01081     )
01082 
01083 <span class="comment">/*++</span>
01084 <span class="comment"></span>
01085 <span class="comment">Routine Description:</span>
01086 <span class="comment"></span>
01087 <span class="comment">    This routine may be called to set the resource owner for the Bcb resource,</span>
01088 <span class="comment">    for cases where another thread will do the unpin *and* the current thread</span>
01089 <span class="comment">    may exit.</span>
01090 <span class="comment"></span>
01091 <span class="comment">Arguments:</span>
01092 <span class="comment"></span>
01093 <span class="comment">    Bcb - Bcb parameter returned from the last call to CcPinRead.</span>
01094 <span class="comment"></span>
01095 <span class="comment">    OwnerPointer - A valid resource owner pointer, which means a pointer to</span>
01096 <span class="comment">                   an allocated system address, with the low-order two bits</span>
01097 <span class="comment">                   set.  The address may not be deallocated until after the</span>
01098 <span class="comment">                   unpin call.</span>
01099 <span class="comment"></span>
01100 <span class="comment">Return Value:</span>
01101 <span class="comment"></span>
01102 <span class="comment">    None.</span>
01103 <span class="comment"></span>
01104 <span class="comment">--*/</span>
01105 
01106 {
01107     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(((ULONG_PTR)Bcb &amp; 1) == 0);
01108 
01109     <span class="comment">//</span>
01110     <span class="comment">//  Handle the overlapped Bcb case.</span>
01111     <span class="comment">//</span>
01112 
01113     <span class="keywordflow">if</span> (((<a class="code" href="../../d6/d4/struct__OBCB.html">POBCB</a>)Bcb)-&gt;NodeTypeCode == <a class="code" href="../../d5/d5/cc_8h.html#a17">CACHE_NTC_OBCB</a>) {
01114 
01115         <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> *BcbPtrPtr = &amp;((<a class="code" href="../../d6/d4/struct__OBCB.html">POBCB</a>)Bcb)-&gt;Bcbs[0];
01116 
01117         <span class="comment">//</span>
01118         <span class="comment">//  Loop to set owner for all Bcbs.</span>
01119         <span class="comment">//</span>
01120 
01121         <span class="keywordflow">while</span> (*BcbPtrPtr != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01122             <a class="code" href="../../d5/d8/ex_8h.html#a275">ExSetResourceOwnerPointer</a>( &amp;(*BcbPtrPtr)-&gt;Resource, OwnerPointer );
01123             BcbPtrPtr++;
01124         }
01125 
01126     <span class="comment">//</span>
01127     <span class="comment">//  Otherwise, it is a normal Bcb</span>
01128     <span class="comment">//</span>
01129 
01130     } <span class="keywordflow">else</span> {
01131 
01132         <span class="comment">//</span>
01133         <span class="comment">//  Handle normal case.</span>
01134         <span class="comment">//</span>
01135 
01136         <a class="code" href="../../d5/d8/ex_8h.html#a275">ExSetResourceOwnerPointer</a>( &amp;((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb)-&gt;<a class="code" href="../../d4/d0/tex_8c.html#a21">Resource</a>, OwnerPointer );
01137     }
01138 }
01139 
01140 
01141 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01142"></a><a class="code" href="../../d4/d2/cache_8h.html#a94">01142</a> <a class="code" href="../../d4/d2/cache_8h.html#a94">CcUnpinDataForThread</a> (
01143     IN PVOID Bcb,
01144     IN ERESOURCE_THREAD ResourceThreadId
01145     )
01146 
01147 <span class="comment">/*++</span>
01148 <span class="comment"></span>
01149 <span class="comment">Routine Description:</span>
01150 <span class="comment"></span>
01151 <span class="comment">    This routine must be called at IPL0, some time after calling CcPinRead</span>
01152 <span class="comment">    or CcPreparePinWrite.  It performs any cleanup that is necessary,</span>
01153 <span class="comment">    releasing the Bcb resource for the given thread.</span>
01154 <span class="comment"></span>
01155 <span class="comment">Arguments:</span>
01156 <span class="comment"></span>
01157 <span class="comment">    Bcb - Bcb parameter returned from the last call to CcPinRead.</span>
01158 <span class="comment"></span>
01159 <span class="comment">Return Value:</span>
01160 <span class="comment"></span>
01161 <span class="comment">    None.</span>
01162 <span class="comment"></span>
01163 <span class="comment">--*/</span>
01164 
01165 {
01166     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(+1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcUnpinDataForThread:\n"</span>, 0 );
01167     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    &gt;Bcb = %08lx\n"</span>, Bcb );
01168     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>( 0, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"    &gt;ResoureceThreadId = %08lx\n"</span>, ResoureceThreadId );
01169 
01170     <span class="comment">//</span>
01171     <span class="comment">//  Test for ReadOnly and unpin accordingly.</span>
01172     <span class="comment">//</span>
01173 
01174     <span class="keywordflow">if</span> (((ULONG_PTR)Bcb &amp; 1) != 0) {
01175 
01176         <span class="comment">//</span>
01177         <span class="comment">//  Remove the Read Only flag</span>
01178         <span class="comment">//</span>
01179 
01180         (PCHAR)Bcb -= 1;
01181 
01182         <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, <a class="code" href="../../d5/d5/cc_8h.html#a211a171">UNPIN</a> );
01183 
01184     } <span class="keywordflow">else</span> {
01185 
01186         <span class="comment">//</span>
01187         <span class="comment">//  Handle the overlapped Bcb case.</span>
01188         <span class="comment">//</span>
01189 
01190         <span class="keywordflow">if</span> (((<a class="code" href="../../d6/d4/struct__OBCB.html">POBCB</a>)Bcb)-&gt;NodeTypeCode == <a class="code" href="../../d5/d5/cc_8h.html#a17">CACHE_NTC_OBCB</a>) {
01191 
01192             <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> *BcbPtrPtr = &amp;((<a class="code" href="../../d6/d4/struct__OBCB.html">POBCB</a>)Bcb)-&gt;Bcbs[0];
01193 
01194             <span class="comment">//</span>
01195             <span class="comment">//  Loop to free all Bcbs with recursive calls</span>
01196             <span class="comment">//  (rather than dealing with RO for this uncommon case).</span>
01197             <span class="comment">//</span>
01198 
01199             <span class="keywordflow">while</span> (*BcbPtrPtr != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01200                 <a class="code" href="../../d4/d2/cache_8h.html#a94">CcUnpinDataForThread</a>( *(BcbPtrPtr++), ResourceThreadId );
01201             }
01202 
01203             <span class="comment">//</span>
01204             <span class="comment">//  Then free the pool for the Obcb</span>
01205             <span class="comment">//</span>
01206 
01207             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( Bcb );
01208 
01209         <span class="comment">//</span>
01210         <span class="comment">//  Otherwise, it is a normal Bcb</span>
01211         <span class="comment">//</span>
01212 
01213         } <span class="keywordflow">else</span> {
01214 
01215             <span class="comment">//</span>
01216             <span class="comment">//  If not readonly, we can release the resource for the thread first,</span>
01217             <span class="comment">//  and then call CcUnpinFileData.  Release resource first in case</span>
01218             <span class="comment">//  Bcb gets deallocated.</span>
01219             <span class="comment">//</span>
01220 
01221             <a class="code" href="../../d5/d8/ex_8h.html#a71">ExReleaseResourceForThread</a>( &amp;((<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb)-&gt;<a class="code" href="../../d4/d0/tex_8c.html#a21">Resource</a>, ResourceThreadId );
01222             <a class="code" href="../../d5/d5/cc_8h.html#a176">CcUnpinFileData</a>( (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)Bcb, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, <a class="code" href="../../d5/d5/cc_8h.html#a211a171">UNPIN</a> );
01223         }
01224     }
01225     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(-1, <a class="code" href="../../d6/d2/cachesub_8c.html#a1">me</a>, <span class="stringliteral">"CcUnpinDataForThread -&gt; VOID\n"</span>, 0 );
01226 }
01227 
01228 
01229 <a class="code" href="../../d6/d4/struct__OBCB.html">POBCB</a>
<a name="l01230"></a><a class="code" href="../../d2/d9/pinsup_8c.html#a1">01230</a> <a class="code" href="../../d2/d9/pinsup_8c.html#a1">CcAllocateObcb</a> (
01231     IN PLARGE_INTEGER FileOffset,
01232     IN ULONG Length,
01233     IN <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> FirstBcb
01234     )
01235 
01236 <span class="comment">/*++</span>
01237 <span class="comment"></span>
01238 <span class="comment">Routine Description:</span>
01239 <span class="comment"></span>
01240 <span class="comment">    This routine is called by the various pinning routines to allocate and</span>
01241 <span class="comment">    initialize an overlap Bcb.</span>
01242 <span class="comment"></span>
01243 <span class="comment">Arguments:</span>
01244 <span class="comment"></span>
01245 <span class="comment">    FileOffset - Starting file offset for the Obcb (An Obcb starts with a</span>
01246 <span class="comment">                 public structure, which someone could use)</span>
01247 <span class="comment"></span>
01248 <span class="comment">    Length - Length of the range covered by the Obcb</span>
01249 <span class="comment"></span>
01250 <span class="comment">    FirstBcb - First Bcb already created, which only covers the start of</span>
01251 <span class="comment">               the desired range (low order bit may be set to indicate ReadOnly)</span>
01252 <span class="comment"></span>
01253 <span class="comment">Return Value:</span>
01254 <span class="comment"></span>
01255 <span class="comment">    Pointer to the allocated Obcb</span>
01256 <span class="comment"></span>
01257 <span class="comment">--*/</span>
01258 
01259 {
01260     ULONG LengthToAllocate;
01261     <a class="code" href="../../d6/d4/struct__OBCB.html">POBCB</a> Obcb;
01262     <a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a> Bcb = (<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)((ULONG_PTR)FirstBcb &amp; ~1);
01263 
01264     <span class="comment">//</span>
01265     <span class="comment">//  Allocate according to the worst case, assuming that we</span>
01266     <span class="comment">//  will need as many additional Bcbs as there are pages</span>
01267     <span class="comment">//  remaining. Also throw in one more pointer to guarantee</span>
01268     <span class="comment">//  users of the OBCB can always terminate on NULL.</span>
01269     <span class="comment">//</span>
01270     <span class="comment">//  We remove fron consideration the range described by the</span>
01271     <span class="comment">//  first Bcb (note that the range of the Obcb is not strictly</span>
01272     <span class="comment">//  starting at the first Bcb) and add in locations for the first</span>
01273     <span class="comment">//  bcb and the null.</span>
01274     <span class="comment">//</span>
01275 
01276     LengthToAllocate = FIELD_OFFSET(<a class="code" href="../../d6/d4/struct__OBCB.html">OBCB</a>, Bcbs) + (2 * <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>)) +
01277                        ((Length -
01278                          (Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o2">ByteLength</a> -
01279                           (FileOffset-&gt;HighPart?
01280                            (ULONG)(FileOffset-&gt;QuadPart - Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o3">FileOffset</a>.QuadPart) :
01281                            FileOffset-&gt;LowPart - Bcb-&gt;<a class="code" href="../../d4/d3/struct__BCB.html#o3">FileOffset</a>.LowPart)) +
01282                          <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1) / <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a>) * <span class="keyword">sizeof</span>(<a class="code" href="../../d4/d3/struct__BCB.html">PBCB</a>);
01283 
01284     Obcb = <a class="code" href="../../d1/d8/fsrtl_8h.html#a37">FsRtlAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, LengthToAllocate, 'bOcC' );
01285     RtlZeroMemory( Obcb, LengthToAllocate );
01286     Obcb-&gt;<a class="code" href="../../d6/d4/struct__OBCB.html#o0">NodeTypeCode</a> = <a class="code" href="../../d5/d5/cc_8h.html#a17">CACHE_NTC_OBCB</a>;
01287     Obcb-&gt;<a class="code" href="../../d6/d4/struct__OBCB.html#o1">NodeByteSize</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)LengthToAllocate;
01288     Obcb-&gt;<a class="code" href="../../d6/d4/struct__OBCB.html#o2">ByteLength</a> = Length;
01289     Obcb-&gt;<a class="code" href="../../d6/d4/struct__OBCB.html#o3">FileOffset</a> = *FileOffset;
01290     Obcb-&gt;<a class="code" href="../../d6/d4/struct__OBCB.html#o4">Bcbs</a>[0] = FirstBcb;
01291 
01292     <span class="keywordflow">return</span> Obcb;
01293 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:41:15 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
