<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: iosubs.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>iosubs.c</h1><a href="../../d4/d6/iosubs_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1989  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    iosubs.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    This module contains the subroutines for the I/O system.</span>
00012 <span class="comment"></span>
00013 <span class="comment">Author:</span>
00014 <span class="comment"></span>
00015 <span class="comment">    Darryl E. Havens (darrylh) 16-Apr-1989</span>
00016 <span class="comment"></span>
00017 <span class="comment">Environment:</span>
00018 <span class="comment"></span>
00019 <span class="comment">    Kernel mode</span>
00020 <span class="comment"></span>
00021 <span class="comment">Revision History:</span>
00022 <span class="comment"></span>
00023 <span class="comment"></span>
00024 <span class="comment">--*/</span>
00025 
00026 <span class="preprocessor">#include "<a class="code" href="../../d0/d6/iop_8h.html">iop.h</a>"</span>
00027 
00028 <span class="comment">//</span>
00029 <span class="comment">// This is the overall system device configuration record.</span>
00030 <span class="comment">//</span>
00031 
<a name="l00032"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a7">00032</a> <span class="keyword">static</span> <a class="code" href="../../d6/d8/struct__CONFIGURATION__INFORMATION.html">CONFIGURATION_INFORMATION</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a7">ConfigurationInformation</a> = {
00033     0,                                 <span class="comment">// DiskCount</span>
00034     0,                                 <span class="comment">// FloppyCount</span>
00035     0,                                 <span class="comment">// CdRomCount</span>
00036     0,                                 <span class="comment">// TapeCount</span>
00037     0,                                 <span class="comment">// ScsiPortCount</span>
00038     0,                                 <span class="comment">// SerialCount</span>
00039     0,                                 <span class="comment">// ParallelCount</span>
00040     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,                             <span class="comment">// Primary ATDISK IO address claimed</span>
00041     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,                             <span class="comment">// Secondary ATDISK IO address claimed</span>
00042     <span class="keyword">sizeof</span>(<a class="code" href="../../d6/d8/struct__CONFIGURATION__INFORMATION.html">CONFIGURATION_INFORMATION</a>), <span class="comment">// Version</span>
00043     0                                  <span class="comment">// MediumChangerCount</span>
00044 };
00045 
00046 <span class="comment">//</span>
00047 <span class="comment">// This value may be overridden by the registry.</span>
00048 <span class="comment">//</span>
00049 
<a name="l00050"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a8">00050</a> LOGICAL <a class="code" href="../../d8/d0/cmdat3_8c.html#a55">IoCountOperations</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00051 
00052 <span class="preprocessor">#ifdef ALLOC_PRAGMA</span>
00053 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoAttachDevice)</span>
00054 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoCancelThreadIo)</span>
00055 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoCheckDesiredAccess)</span>
00056 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoCheckEaBufferValidity)</span>
00057 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoCheckFunctionAccess)</span>
00058 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoCheckQuotaBufferValidity)</span>
00059 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoCheckShareAccess)</span>
00060 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoConnectInterrupt)</span>
00061 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoCreateController)</span>
00062 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoCreateDevice)</span>
00063 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoCreateFile)</span>
00064 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoCreateNotificationEvent)</span>
00065 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoCreateStreamFileObject)</span>
00066 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoCreateSymbolicLink)</span>
00067 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoCreateSynchronizationEvent)</span>
00068 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoCreateUnprotectedSymbolicLink)</span>
00069 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoDeleteController)</span>
00070 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoDeleteSymbolicLink)</span>
00071 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoDisconnectInterrupt)</span>
00072 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoEnqueueIrp)</span>
00073 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoFastQueryNetworkAttributes)</span>
00074 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoGetConfigurationInformation)</span>
00075 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoGetDeviceObjectPointer)</span>
00076 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoInitializeTimer)</span>
00077 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoQueryFileInformation)</span>
00078 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoQueryVolumeInformation)</span>
00079 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoPageFileCreated)</span>
00080 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoRegisterBootDriverReinitialization)</span>
00081 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoRegisterDriverReinitialization)</span>
00082 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoRegisterFileSystem)</span>
00083 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoRegisterFsRegistrationChange)</span>
00084 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoRegisterLastChanceShutdownNotification)</span>
00085 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoRegisterShutdownNotification)</span>
00086 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoRemoveShareAccess)</span>
00087 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoSetInformation)</span>
00088 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoSetShareAccess)</span>
00089 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoUnregisterFileSystem)</span>
00090 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoUnregisterFsRegistrationChange)</span>
00091 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoUpdateShareAccess)</span>
00092 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoVerifyVolume)</span>
00093 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IopCreateVpb)</span>
00094 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE, IoCancelFileOpen)</span>
00095 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGELK, IoShutdownSystem)</span>
00096 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGELK, IoUnregisterShutdownNotification)</span>
00097 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00098 <span class="preprocessor"></span>
00099 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00100"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a9">00100</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a9">IoAcquireCancelSpinLock</a>(
00101     OUT PKIRQL Irql
00102     )
00103 
00104 <span class="comment">/*++</span>
00105 <span class="comment"></span>
00106 <span class="comment">Routine Description:</span>
00107 <span class="comment"></span>
00108 <span class="comment">    This routine is invoked to acquire the cancel spin lock.  This spin lock</span>
00109 <span class="comment">    must be acquired before setting the address of a cancel routine in an</span>
00110 <span class="comment">    IRP.</span>
00111 <span class="comment"></span>
00112 <span class="comment">Arguments:</span>
00113 <span class="comment"></span>
00114 <span class="comment">    Irql - Address of a variable to receive the old IRQL.</span>
00115 <span class="comment"></span>
00116 <span class="comment">Return Value:</span>
00117 <span class="comment"></span>
00118 <span class="comment">    None.</span>
00119 <span class="comment"></span>
00120 <span class="comment">--*/</span>
00121 
00122 {
00123     KIRQL oldIrql;
00124 
00125     <span class="comment">//</span>
00126     <span class="comment">// Simply acquire the cancel spin lock and return.</span>
00127     <span class="comment">//</span>
00128 
00129     ExAcquireSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a1">IopCancelSpinLock</a>, &amp;oldIrql );
00130     *Irql = oldIrql;
00131 }
00132 
00133 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00134"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a10">00134</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a10">IoAcquireVpbSpinLock</a>(
00135     OUT PKIRQL Irql
00136     )
00137 
00138 <span class="comment">/*++</span>
00139 <span class="comment"></span>
00140 <span class="comment">Routine Description:</span>
00141 <span class="comment"></span>
00142 <span class="comment">    This routine is invoked to acquire the Volume Parameter Block (VPB) spin</span>
00143 <span class="comment">    lock.  This spin lock must be acquired before accessing the mount flag,</span>
00144 <span class="comment">    reference count, and device object fields of a VPB.</span>
00145 <span class="comment"></span>
00146 <span class="comment">Arguments:</span>
00147 <span class="comment"></span>
00148 <span class="comment">    Irql - Address of a variable to receive the old IRQL.</span>
00149 <span class="comment"></span>
00150 <span class="comment">Return Value:</span>
00151 <span class="comment"></span>
00152 <span class="comment">    None.</span>
00153 <span class="comment"></span>
00154 <span class="comment">--*/</span>
00155 
00156 {
00157     KIRQL oldIrql;
00158 
00159     <span class="comment">//</span>
00160     <span class="comment">// Simply acquire the IopLoadFileSystemDriverVPB spin lock and return.</span>
00161     <span class="comment">//</span>
00162 
00163     ExAcquireSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a2">IopVpbSpinLock</a>, &amp;oldIrql );
00164     *Irql = oldIrql;
00165 }
00166 
00167 
00168 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00169"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a11">00169</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a11">IoAllocateAdapterChannel</a>(
00170     IN <a class="code" href="../../d7/d5/struct__ADAPTER__OBJECT.html">PADAPTER_OBJECT</a> AdapterObject,
00171     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
00172     IN ULONG NumberOfMapRegisters,
00173     IN PDRIVER_CONTROL ExecutionRoutine,
00174     IN PVOID Context
00175     )
00176 
00177 <span class="comment">/*++</span>
00178 <span class="comment"></span>
00179 <span class="comment">Routine Description:</span>
00180 <span class="comment"></span>
00181 <span class="comment">    This routine allocates the adapter channel specified by the adapter object.</span>
00182 <span class="comment">    This is accomplished by calling HalAllocateAdapterChannel which does all of</span>
00183 <span class="comment">    the work.</span>
00184 <span class="comment"></span>
00185 <span class="comment">Arguments:</span>
00186 <span class="comment"></span>
00187 <span class="comment">    AdapterObject - Pointer to the adapter control object to allocate to the</span>
00188 <span class="comment">        driver.</span>
00189 <span class="comment"></span>
00190 <span class="comment">    DeviceObject - Pointer to the driver's device object that represents the</span>
00191 <span class="comment">        device allocating the adapter.</span>
00192 <span class="comment"></span>
00193 <span class="comment">    NumberOfMapRegisters - The number of map registers that are to be allocated</span>
00194 <span class="comment">        from the channel, if any.</span>
00195 <span class="comment"></span>
00196 <span class="comment">    ExecutionRoutine - The address of the driver's execution routine that is</span>
00197 <span class="comment">        invoked once the adapter channel (and possibly map registers) have been</span>
00198 <span class="comment">        allocated.</span>
00199 <span class="comment"></span>
00200 <span class="comment">    Context - An untyped longword context parameter passed to the driver's</span>
00201 <span class="comment">        execution routine.</span>
00202 <span class="comment"></span>
00203 <span class="comment">Return Value:</span>
00204 <span class="comment"></span>
00205 <span class="comment">    Returns STATUS_SUCESS unless too many map registers are requested.</span>
00206 <span class="comment"></span>
00207 <span class="comment">Notes:</span>
00208 <span class="comment"></span>
00209 <span class="comment">    Note that this routine MUST be invoked at DISPATCH_LEVEL or above.</span>
00210 <span class="comment"></span>
00211 <span class="comment">--*/</span>
00212 
00213 {
00214 <span class="preprocessor">#if !defined(NO_LEGACY_DRIVERS)</span>
00215 <span class="preprocessor"></span>    <a class="code" href="../../d8/d7/struct__WAIT__CONTEXT__BLOCK.html">PWAIT_CONTEXT_BLOCK</a> wcb;
00216 
00217     wcb = &amp;DeviceObject-&gt;Queue.Wcb;
00218 
00219     wcb-&gt;<a class="code" href="../../d8/d7/struct__WAIT__CONTEXT__BLOCK.html#o4">DeviceObject</a> = DeviceObject;
00220     wcb-&gt;<a class="code" href="../../d8/d7/struct__WAIT__CONTEXT__BLOCK.html#o5">CurrentIrp</a> = DeviceObject-&gt;CurrentIrp;
00221     wcb-&gt;<a class="code" href="../../d8/d7/struct__WAIT__CONTEXT__BLOCK.html#o2">DeviceContext</a> = Context;
00222 
00223     <span class="keywordflow">return</span>( <a class="code" href="../../d2/d7/hal_8h.html#a226">HalAllocateAdapterChannel</a>( AdapterObject,
00224                                        wcb,
00225                                        NumberOfMapRegisters,
00226                                        ExecutionRoutine ) );
00227 <span class="preprocessor">#else</span>
00228 <span class="preprocessor"></span>    <span class="keywordflow">return</span>( (*((<a class="code" href="../../d7/d6/struct__DMA__ADAPTER.html">PDMA_ADAPTER</a>)AdapterObject)-&gt;DmaOperations-&gt;
00229              AllocateAdapterChannel)( (<a class="code" href="../../d7/d6/struct__DMA__ADAPTER.html">PDMA_ADAPTER</a>)AdapterObject,
00230                                       DeviceObject,
00231                                       NumberOfMapRegisters,
00232                                       ExecutionRoutine,
00233                                       Context) );
00234 
00235 <span class="preprocessor">#endif // NO_LEGACY_DRIVERS</span>
00236 <span class="preprocessor"></span>}
00237 
00238 
00239 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00240"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a12">00240</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a12">IoAllocateController</a>(
00241     IN <a class="code" href="../../d1/d8/struct__CONTROLLER__OBJECT.html">PCONTROLLER_OBJECT</a> ControllerObject,
00242     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
00243     IN PDRIVER_CONTROL ExecutionRoutine,
00244     IN PVOID Context
00245     )
00246 
00247 <span class="comment">/*++</span>
00248 <span class="comment"></span>
00249 <span class="comment">Routine Description:</span>
00250 <span class="comment"></span>
00251 <span class="comment">    This routine allocates the controller specified by the controller object.</span>
00252 <span class="comment">    This is accomplished by placing the device object of the driver that wants</span>
00253 <span class="comment">    to allocate the controller on the controller's queue.  If the queue is</span>
00254 <span class="comment">    already "busy", then the controller has already been allocated, so the</span>
00255 <span class="comment">    device object is simply placed onto the queue and waits until the controller</span>
00256 <span class="comment">    becomes free.</span>
00257 <span class="comment"></span>
00258 <span class="comment">    Once the controller becomes free (or if it already is), then the driver's</span>
00259 <span class="comment">    execution routine is invoked.</span>
00260 <span class="comment"></span>
00261 <span class="comment">Arguments:</span>
00262 <span class="comment"></span>
00263 <span class="comment">    ControllerObject - Pointer to the controller object to allocate to the</span>
00264 <span class="comment">        driver.</span>
00265 <span class="comment"></span>
00266 <span class="comment">    DeviceObject - Pointer to the driver's device object that represents the</span>
00267 <span class="comment">        device allocating the controller.</span>
00268 <span class="comment"></span>
00269 <span class="comment">    ExecutionRoutine - The address of the driver's execution routine that is</span>
00270 <span class="comment">        invoked once the controller has been allocated.</span>
00271 <span class="comment"></span>
00272 <span class="comment">    Context - An untyped longword context parameter passed to the driver's</span>
00273 <span class="comment">        execution routine.</span>
00274 <span class="comment"></span>
00275 <span class="comment">Return Value:</span>
00276 <span class="comment"></span>
00277 <span class="comment">    None.</span>
00278 <span class="comment"></span>
00279 <span class="comment">Notes:</span>
00280 <span class="comment"></span>
00281 <span class="comment">    Note that this routine MUST be invoked at DISPATCH_LEVEL or above.</span>
00282 <span class="comment"></span>
00283 <span class="comment">--*/</span>
00284 
00285 {
00286     <a class="code" href="../../d0/d5/io_8h.html#a321">IO_ALLOCATION_ACTION</a> action;
00287 
00288     <span class="comment">//</span>
00289     <span class="comment">// Initialize the device object's wait context block in case this device</span>
00290     <span class="comment">// must wait before being able to allocate the controller.</span>
00291     <span class="comment">//</span>
00292 
00293     DeviceObject-&gt;Queue.Wcb.DeviceRoutine = ExecutionRoutine;
00294     DeviceObject-&gt;Queue.Wcb.DeviceContext = Context;
00295 
00296     <span class="comment">//</span>
00297     <span class="comment">// Allocate the controller object for this particular device.  If the</span>
00298     <span class="comment">// controller cannot be allocated because it has already been allocated</span>
00299     <span class="comment">// to another device, then return to the caller now;  otherwise,</span>
00300     <span class="comment">// continue.</span>
00301     <span class="comment">//</span>
00302 
00303     <span class="keywordflow">if</span> (!<a class="code" href="../../d7/d7/devquobj_8c.html#a2">KeInsertDeviceQueue</a>( &amp;ControllerObject-&gt;DeviceWaitQueue,
00304                               &amp;DeviceObject-&gt;Queue.Wcb.WaitQueueEntry )) {
00305 
00306         <span class="comment">//</span>
00307         <span class="comment">// The controller was not busy so it has been allocated.  Simply</span>
00308         <span class="comment">// invoke the driver's execution routine now.</span>
00309         <span class="comment">//</span>
00310 
00311         action = ExecutionRoutine( DeviceObject,
00312                                    DeviceObject-&gt;CurrentIrp,
00313                                    0,
00314                                    Context );
00315 
00316         <span class="comment">//</span>
00317         <span class="comment">// If the driver would like to have the controller deallocated,</span>
00318         <span class="comment">// then deallocate it now.</span>
00319         <span class="comment">//</span>
00320 
00321         <span class="keywordflow">if</span> (action == <a class="code" href="../../d0/d5/io_8h.html#a601a410">DeallocateObject</a>) {
00322             <a class="code" href="../../d4/d6/iosubs_8c.html#a62">IoFreeController</a>( ControllerObject );
00323         }
00324     }
00325 }
00326 
00327 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00328"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a13">00328</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a13">IoAllocateDriverObjectExtension</a>(
00329     IN <a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html">PDRIVER_OBJECT</a> DriverObject,
00330     IN PVOID ClientIdentificationAddress,
00331     IN ULONG DriverObjectExtensionSize,
00332     OUT PVOID *DriverObjectExtension
00333     )
00334 
00335 <span class="comment">/*++</span>
00336 <span class="comment"></span>
00337 <span class="comment">Routine Description:</span>
00338 <span class="comment">    This routine allocates per driver storage for helper or class drivers</span>
00339 <span class="comment">    which may support several different mini-drivers.  The storage is tagged</span>
00340 <span class="comment">    with a client identification address which is used to retrieve a pointer</span>
00341 <span class="comment">    to the storage.  The client id must be unique.</span>
00342 <span class="comment"></span>
00343 <span class="comment">    The allocated storage is freed when the driver object is deleted.</span>
00344 <span class="comment"></span>
00345 <span class="comment">Arguments:</span>
00346 <span class="comment"></span>
00347 <span class="comment">    DriverObject - The driver object to which the extension is to be</span>
00348 <span class="comment">        associated.</span>
00349 <span class="comment"></span>
00350 <span class="comment">    ClientIdentificationAddress - Unique identifier used to retrieve the</span>
00351 <span class="comment">        extension.</span>
00352 <span class="comment"></span>
00353 <span class="comment">    DriverObjectExtensionSize - Specifies the size in bytes of the extension.</span>
00354 <span class="comment"></span>
00355 <span class="comment">    DriverObjectExtension - Returns a pointer to the allocated extension.</span>
00356 <span class="comment"></span>
00357 <span class="comment">Return Value:</span>
00358 <span class="comment"></span>
00359 <span class="comment">    Returns the status of the operation.  Failure cases are</span>
00360 <span class="comment">    STATUS_INSUFFICIENT_RESOURCES and STATUS_OBJECT_NAME_COLLISION.</span>
00361 <span class="comment"></span>
00362 <span class="comment">--*/</span>
00363 
00364 {
00365     KIRQL irql;
00366     BOOLEAN inserted = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00367     <a class="code" href="../../d1/d4/struct__IO__CLIENT__EXTENSION.html">PIO_CLIENT_EXTENSION</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a6">extension</a>;
00368     <a class="code" href="../../d1/d4/struct__IO__CLIENT__EXTENSION.html">PIO_CLIENT_EXTENSION</a> newExtension;
00369 
00370     *DriverObjectExtension = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00371 
00372     newExtension = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
00373                                           DriverObjectExtensionSize +
00374                                           <span class="keyword">sizeof</span>( <a class="code" href="../../d1/d4/struct__IO__CLIENT__EXTENSION.html">IO_CLIENT_EXTENSION</a> ),
00375                                           'virD');
00376 
00377     <span class="keywordflow">if</span> (newExtension == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00378         <span class="keywordflow">return</span>(STATUS_INSUFFICIENT_RESOURCES);
00379     }
00380 
00381     RtlZeroMemory( newExtension,
00382                     DriverObjectExtensionSize +
00383                     <span class="keyword">sizeof</span>( <a class="code" href="../../d0/d5/io_8h.html#a330">IO_CLIENT_EXTENSION</a> )
00384                     );
00385 
00386     newExtension-&gt;<a class="code" href="../../d1/d4/struct__IO__CLIENT__EXTENSION.html#o1">ClientIdentificationAddress</a> = ClientIdentificationAddress;
00387 
00388     ExAcquireFastLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, &amp;irql );
00389     <a class="code" href="../../d7/d1/genuedef_8c.html#a6">extension</a> = DriverObject-&gt;DriverExtension-&gt;ClientDriverExtension;
00390     <span class="keywordflow">while</span> (<a class="code" href="../../d7/d1/genuedef_8c.html#a6">extension</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00391 
00392         <span class="keywordflow">if</span> (<a class="code" href="../../d7/d1/genuedef_8c.html#a6">extension</a>-&gt;ClientIdentificationAddress == ClientIdentificationAddress) {
00393             <span class="keywordflow">break</span>;
00394         }
00395 
00396         <a class="code" href="../../d7/d1/genuedef_8c.html#a6">extension</a> = <a class="code" href="../../d7/d1/genuedef_8c.html#a6">extension</a>-&gt;NextExtension;
00397     }
00398 
00399     <span class="keywordflow">if</span> (<a class="code" href="../../d7/d1/genuedef_8c.html#a6">extension</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00400 
00401         <span class="comment">//</span>
00402         <span class="comment">// The client id does not exist.  Insert the new extension in the</span>
00403         <span class="comment">// list.</span>
00404         <span class="comment">//</span>
00405 
00406         newExtension-&gt;<a class="code" href="../../d1/d4/struct__IO__CLIENT__EXTENSION.html#o0">NextExtension</a> =
00407             DriverObject-&gt;DriverExtension-&gt;ClientDriverExtension;
00408         DriverObject-&gt;DriverExtension-&gt;ClientDriverExtension = newExtension;
00409         inserted = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00410     }
00411 
00412     ExReleaseFastLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, irql );
00413 
00414     <span class="keywordflow">if</span> (!inserted) {
00415         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( newExtension );
00416         <span class="keywordflow">return</span>(STATUS_OBJECT_NAME_COLLISION);
00417     }
00418 
00419     <span class="comment">//</span>
00420     <span class="comment">// Return a pointer to the client's data area.</span>
00421     <span class="comment">//</span>
00422 
00423     *DriverObjectExtension = newExtension + 1;
00424     <span class="keywordflow">return</span>(STATUS_SUCCESS);
00425 }
00426 
00427 PVOID
<a name="l00428"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a14">00428</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a14">IoAllocateErrorLogEntry</a>(
00429     IN PVOID IoObject,
00430     IN UCHAR EntrySize
00431     )
00432 
00433 <span class="comment">/*++</span>
00434 <span class="comment"></span>
00435 <span class="comment">Routine Description:</span>
00436 <span class="comment"></span>
00437 <span class="comment">    This routine allocates and initializes an error log entry buffer and returns</span>
00438 <span class="comment">    a pointer to the data entry portion of the buffer.</span>
00439 <span class="comment"></span>
00440 <span class="comment">Arguments:</span>
00441 <span class="comment"></span>
00442 <span class="comment">    IoObject - Pointer to driver's device object or driver object.</span>
00443 <span class="comment"></span>
00444 <span class="comment">    EntrySize - Size of entry to be allocated, in bytes.  The maximum size is</span>
00445 <span class="comment">        specified by ERROR_LOG_MAXIMUM_SIZE.</span>
00446 <span class="comment"></span>
00447 <span class="comment">Return Value:</span>
00448 <span class="comment"></span>
00449 <span class="comment">    Pointer to the body of the allocated error log entry, or NULL, if there are</span>
00450 <span class="comment">    no free entries in the system.</span>
00451 <span class="comment"></span>
00452 <span class="comment">Note:</span>
00453 <span class="comment"></span>
00454 <span class="comment">    This routine assumes that the caller wants an error log entry within the</span>
00455 <span class="comment">    bounds of the maximum size.</span>
00456 <span class="comment"></span>
00457 <span class="comment">--*/</span>
00458 
00459 {
00460     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
00461     <a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html">PDRIVER_OBJECT</a> driverObject;
00462 
00463     <span class="comment">//</span>
00464     <span class="comment">// Make sure that a I/O object pointer was passed in.</span>
00465     <span class="comment">//</span>
00466 
00467     <span class="keywordflow">if</span> (IoObject == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00468         <span class="keywordflow">return</span>(<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00469     }
00470 
00471     <span class="comment">//</span>
00472     <span class="comment">// Assume for a moment this is a device object.</span>
00473     <span class="comment">//</span>
00474 
00475     deviceObject = IoObject;
00476 
00477     <span class="comment">//</span>
00478     <span class="comment">// Determine if this is a driver object or device object or if we</span>
00479     <span class="comment">// are allocating a generic error log entry.   This is determined</span>
00480     <span class="comment">// from the Type field of the object passed in.</span>
00481     <span class="comment">//</span>
00482 
00483     <span class="keywordflow">if</span> (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o0">Type</a> == <a class="code" href="../../d0/d5/io_8h.html#a2">IO_TYPE_DEVICE</a>) {
00484 
00485         driverObject = deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o3">DriverObject</a>;
00486 
00487     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o0">Type</a> == <a class="code" href="../../d0/d5/io_8h.html#a3">IO_TYPE_DRIVER</a>) {
00488 
00489         driverObject = (<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html">PDRIVER_OBJECT</a>) IoObject;
00490         deviceObject = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00491 
00492     } <span class="keywordflow">else</span> {
00493 
00494         <span class="keywordflow">return</span>(<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00495 
00496     }
00497 
00498     <span class="keywordflow">return</span> (<a class="code" href="../../d4/d6/iosubs_8c.html#a16">IopAllocateErrorLogEntry</a>(
00499                 deviceObject,
00500                 driverObject,
00501                 EntrySize));
00502 
00503 }
00504 
00505 PVOID
<a name="l00506"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a15">00506</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a15">IoAllocateGenericErrorLogEntry</a>(
00507     IN  UCHAR   EntrySize
00508     )
00509 
00510 <span class="comment">/*++</span>
00511 <span class="comment"></span>
00512 <span class="comment">Routine Description:</span>
00513 <span class="comment"></span>
00514 <span class="comment">    This routine allocates and initializes an error log entry buffer and returns</span>
00515 <span class="comment">    a pointer to the data entry portion of the buffer. It's expected to be</span>
00516 <span class="comment">    called from inside the kernel where there may not be a driver object</span>
00517 <span class="comment">    or a device object.</span>
00518 <span class="comment"></span>
00519 <span class="comment">Arguments:</span>
00520 <span class="comment"></span>
00521 <span class="comment"></span>
00522 <span class="comment">    EntrySize - Size of entry to be allocated, in bytes.  The maximum size is</span>
00523 <span class="comment">        specified by ERROR_LOG_MAXIMUM_SIZE.</span>
00524 <span class="comment"></span>
00525 <span class="comment">Return Value:</span>
00526 <span class="comment"></span>
00527 <span class="comment">    Pointer to the body of the allocated error log entry, or NULL, if there are</span>
00528 <span class="comment">    no free entries in the system.</span>
00529 <span class="comment"></span>
00530 <span class="comment">Note:</span>
00531 <span class="comment"></span>
00532 <span class="comment">    This routine assumes that the caller wants an error log entry within the</span>
00533 <span class="comment">    bounds of the maximum size.</span>
00534 <span class="comment"></span>
00535 <span class="comment">--*/</span>
00536 
00537 {
00538     <span class="keywordflow">return</span>(<a class="code" href="../../d4/d6/iosubs_8c.html#a16">IopAllocateErrorLogEntry</a>(<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, EntrySize));
00539 }
00540 
00541 PVOID
<a name="l00542"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a16">00542</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a16">IopAllocateErrorLogEntry</a>(
00543     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject,
00544     IN <a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html">PDRIVER_OBJECT</a> driverObject,
00545     IN UCHAR EntrySize
00546     )
00547 {
00548     <a class="code" href="../../d8/d5/struct__ERROR__LOG__ENTRY.html">PERROR_LOG_ENTRY</a> elEntry;
00549     PVOID returnValue;
00550     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
00551     KIRQL oldIrql;
00552     ULONG size;
00553 
00554     <span class="comment">//</span>
00555     <span class="comment">// Make sure the packet is large enough but not too large.</span>
00556     <span class="comment">//</span>
00557 
00558     <span class="keywordflow">if</span> (EntrySize &lt; <span class="keyword">sizeof</span>(IO_ERROR_LOG_PACKET) ||
00559         EntrySize &gt; ERROR_LOG_MAXIMUM_SIZE) {
00560 
00561         <span class="keywordflow">return</span>(<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00562     }
00563 
00564     <span class="comment">//</span>
00565     <span class="comment">// Round entry size to a PVOID size boundary.</span>
00566     <span class="comment">//</span>
00567 
00568     EntrySize = (UCHAR) ((EntrySize + <span class="keyword">sizeof</span>(PVOID) - 1) &amp; ~(<span class="keyword">sizeof</span>(PVOID) - 1));
00569 
00570     <span class="comment">//</span>
00571     <span class="comment">// Calculate the size of the entry needed.</span>
00572     <span class="comment">//</span>
00573 
00574     size = <span class="keyword">sizeof</span>(<a class="code" href="../../d8/d5/struct__ERROR__LOG__ENTRY.html">ERROR_LOG_ENTRY</a>) + EntrySize;
00575 
00576     <span class="comment">//</span>
00577     <span class="comment">// Make sure that there are not too many outstanding packets.</span>
00578     <span class="comment">//</span>
00579 
00580     ExAcquireSpinLock(&amp;<a class="code" href="../../d4/d4/alpha_2splocks_8c.html#a7">IopErrorLogAllocationLock</a>, &amp;oldIrql);
00581 
00582     <span class="keywordflow">try</span>{
00583 
00584         <span class="keywordflow">if</span> (<a class="code" href="../../d3/d5/iodata_8c.html#a22">IopErrorLogAllocation</a> &gt; <a class="code" href="../../d0/d6/iop_8h.html#a1">IOP_MAXIMUM_LOG_ALLOCATION</a>) {
00585 
00586             <span class="comment">//</span>
00587             <span class="comment">// Fail the request.</span>
00588             <span class="comment">//</span>
00589 
00590             <span class="keywordflow">return</span>(<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00591         }
00592 
00593         <span class="comment">//</span>
00594         <span class="comment">// Increase the outstanding allocation.</span>
00595         <span class="comment">//</span>
00596 
00597         <a class="code" href="../../d3/d5/iodata_8c.html#a22">IopErrorLogAllocation</a> += size;
00598 
00599         <span class="comment">//</span>
00600         <span class="comment">// Allocate the packet.</span>
00601         <span class="comment">//</span>
00602 
00603         elEntry = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, size, 'rEoI' );
00604 
00605         <span class="keywordflow">if</span> (elEntry == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00606 
00607             <span class="comment">//</span>
00608             <span class="comment">// Drop the allocation and return.</span>
00609             <span class="comment">//</span>
00610 
00611             <a class="code" href="../../d3/d5/iodata_8c.html#a22">IopErrorLogAllocation</a> -= size;
00612 
00613             <span class="keywordflow">return</span>(<a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
00614         }
00615 
00616         <span class="comment">//</span>
00617         <span class="comment">// Reference the device object and driver object. So they don't</span>
00618         <span class="comment">// go away before the name gets pulled out.</span>
00619         <span class="comment">//</span>
00620 
00621         <span class="keywordflow">if</span> (deviceObject != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00622 
00623             <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a>( deviceObject );
00624         }
00625 
00626         <span class="keywordflow">if</span> (driverObject != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00627 
00628             <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a>( driverObject );
00629         }
00630 
00631         <span class="comment">//</span>
00632         <span class="comment">// Initialize the fields.</span>
00633         <span class="comment">//</span>
00634 
00635         RtlZeroMemory(elEntry, size);
00636 
00637         elEntry-&gt;<a class="code" href="../../d8/d5/struct__ERROR__LOG__ENTRY.html#o0">Type</a> = <a class="code" href="../../d0/d5/io_8h.html#a10">IO_TYPE_ERROR_LOG</a>;
00638         elEntry-&gt;<a class="code" href="../../d8/d5/struct__ERROR__LOG__ENTRY.html#o1">Size</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) size;
00639         elEntry-&gt;<a class="code" href="../../d8/d5/struct__ERROR__LOG__ENTRY.html#o3">DeviceObject</a> = deviceObject;
00640         elEntry-&gt;<a class="code" href="../../d8/d5/struct__ERROR__LOG__ENTRY.html#o4">DriverObject</a> = driverObject;
00641 
00642         returnValue = elEntry+1;
00643 
00644     } finally {
00645         ExReleaseSpinLock(&amp;<a class="code" href="../../d4/d4/alpha_2splocks_8c.html#a7">IopErrorLogAllocationLock</a>, oldIrql);
00646     }                   
00647 
00648     <span class="keywordflow">return</span> returnValue;
00649 }
00650 
00651 <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>
<a name="l00652"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a17">00652</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a17">IoAllocateIrp</a>(
00653     IN CCHAR StackSize,
00654     IN BOOLEAN ChargeQuota
00655     )
00656 {
00657     <span class="keywordflow">return</span> (<a class="code" href="../../d0/d6/iop_8h.html#a136">pIoAllocateIrp</a>(StackSize, ChargeQuota));
00658 }
00659 
00660 
00661 <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>
<a name="l00662"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a18">00662</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a18">IopAllocateIrpPrivate</a>(
00663     IN CCHAR StackSize,
00664     IN BOOLEAN ChargeQuota
00665     )
00666 
00667 <span class="comment">/*++</span>
00668 <span class="comment"></span>
00669 <span class="comment">Routine Description:</span>
00670 <span class="comment"></span>
00671 <span class="comment">    This routine allocates an I/O Request Packet from the system nonpaged pool.</span>
00672 <span class="comment">    The packet will be allocated to contain StackSize stack locations.  The IRP</span>
00673 <span class="comment">    will also be initialized.</span>
00674 <span class="comment"></span>
00675 <span class="comment">Arguments:</span>
00676 <span class="comment"></span>
00677 <span class="comment">    StackSize - Specifies the maximum number of stack locations required.</span>
00678 <span class="comment"></span>
00679 <span class="comment">    ChargeQuota - Specifies whether quota should be charged against thread.</span>
00680 <span class="comment"></span>
00681 <span class="comment">Return Value:</span>
00682 <span class="comment"></span>
00683 <span class="comment">    The function value is the address of the allocated/initialized IRP,</span>
00684 <span class="comment">    or NULL if one could not be allocated.</span>
00685 <span class="comment"></span>
00686 <span class="comment">--*/</span>
00687 
00688 {
00689     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> allocateSize;
00690     UCHAR fixedSize;
00691     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
00692     UCHAR lookasideAllocation;
00693     <a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html">PNPAGED_LOOKASIDE_LIST</a> lookasideList;
00694     UCHAR mustSucceed;
00695     <a class="code" href="../../d5/d8/ex_8h.html#a108">PP_NPAGED_LOOKASIDE_NUMBER</a> number;
00696     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> packetSize;
00697     PKPRCB prcb;
00698 
00699     <span class="comment">//</span>
00700     <span class="comment">// If the size of the packet required is less than or equal to those on</span>
00701     <span class="comment">// the lookaside lists, then attempt to allocate the packet from the</span>
00702     <span class="comment">// lookaside lists.</span>
00703     <span class="comment">//</span>
00704 
00705     irp = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00706     fixedSize = 0;
00707     mustSucceed = 0;
00708     packetSize = <a class="code" href="../../d0/d5/io_8h.html#a245">IoSizeOfIrp</a>(StackSize);
00709     allocateSize = packetSize;
00710     <span class="keywordflow">if</span> ((StackSize &lt;= (CCHAR)<a class="code" href="../../d8/d0/cmdat3_8c.html#a56">IopLargeIrpStackLocations</a>) &amp;&amp;
00711         ((ChargeQuota == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) || (<a class="code" href="../../d0/d6/iop_8h.html#a130">IopLookasideIrpFloat</a> &lt; <a class="code" href="../../d0/d6/iop_8h.html#a131">IopLookasideIrpLimit</a>))) {
00712         fixedSize = <a class="code" href="../../d0/d5/io_8h.html#a192">IRP_ALLOCATED_FIXED_SIZE</a>;
00713         number = <a class="code" href="../../d5/d8/ex_8h.html#a331a197">LookasideSmallIrpList</a>;
00714         <span class="keywordflow">if</span> (StackSize != 1) {
00715             allocateSize = <a class="code" href="../../d0/d5/io_8h.html#a245">IoSizeOfIrp</a>((CCHAR)<a class="code" href="../../d8/d0/cmdat3_8c.html#a56">IopLargeIrpStackLocations</a>);
00716             number = <a class="code" href="../../d5/d8/ex_8h.html#a331a198">LookasideLargeIrpList</a>;
00717         }
00718 
00719         prcb = <a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a2">KeGetCurrentPrcb</a>();
00720         lookasideList = prcb-&gt;PPLookasideList[number].P;
00721         lookasideList-&gt;<a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html#o0">L</a>.<a class="code" href="../../d6/d1/struct__GENERAL__LOOKASIDE.html#o3">TotalAllocates</a> += 1;
00722         irp = (<a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>)<a class="code" href="../../d5/d8/ex_8h.html#a242">ExInterlockedPopEntrySList</a>(&amp;lookasideList-&gt;<a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html#o0">L</a>.<a class="code" href="../../d6/d1/struct__GENERAL__LOOKASIDE.html#o0">ListHead</a>,
00723                                                &amp;lookasideList-&gt;<a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html#o1">Lock</a>);
00724 
00725         <span class="keywordflow">if</span> (irp == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00726             lookasideList-&gt;<a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html#o0">L</a>.<a class="code" href="../../d6/d1/struct__GENERAL__LOOKASIDE.html#o4">AllocateMisses</a> += 1;
00727             lookasideList = prcb-&gt;PPLookasideList[number].<a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html#o0">L</a>;
00728             lookasideList-&gt;<a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html#o0">L</a>.<a class="code" href="../../d6/d1/struct__GENERAL__LOOKASIDE.html#o3">TotalAllocates</a> += 1;
00729             irp = (<a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>)<a class="code" href="../../d5/d8/ex_8h.html#a242">ExInterlockedPopEntrySList</a>(&amp;lookasideList-&gt;<a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html#o0">L</a>.<a class="code" href="../../d6/d1/struct__GENERAL__LOOKASIDE.html#o0">ListHead</a>,
00730                                                    &amp;lookasideList-&gt;<a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html#o1">Lock</a>);
00731         }
00732     }
00733 
00734     <span class="comment">//</span>
00735     <span class="comment">// If an IRP was not allocated from the lookaside list, then allocate</span>
00736     <span class="comment">// the packet from nonpaged pool and charge quota if requested.</span>
00737     <span class="comment">//</span>
00738 
00739     lookasideAllocation = 0;
00740     <span class="keywordflow">if</span> (!irp) {
00741         <span class="keywordflow">if</span> (fixedSize != 0) {
00742             lookasideList-&gt;<a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html#o0">L</a>.<a class="code" href="../../d6/d1/struct__GENERAL__LOOKASIDE.html#o4">AllocateMisses</a> += 1;
00743         }
00744 
00745         <span class="comment">//</span>
00746         <span class="comment">// There are no free packets on the lookaside list, or the packet is</span>
00747         <span class="comment">// too large to be allocated from one of the lists, so it must be</span>
00748         <span class="comment">// allocated from nonpaged pool. If quota is to be charged, charge it</span>
00749         <span class="comment">// against the current process. Otherwise, allocate the pool normally.</span>
00750         <span class="comment">//</span>
00751 
00752         <span class="keywordflow">if</span> (ChargeQuota) {
00753             <span class="keywordflow">try</span> {
00754                 irp = <a class="code" href="../../d5/d8/ex_8h.html#a5">ExAllocatePoolWithQuotaTag</a>(<a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, allocateSize,' prI');
00755 
00756             } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
00757                 NOTHING;
00758             }
00759 
00760         } <span class="keywordflow">else</span> {
00761 
00762             <span class="comment">//</span>
00763             <span class="comment">// Attempt to allocate the pool from non-paged pool.  If this</span>
00764             <span class="comment">// fails, and the caller's previous mode was kernel then allocate</span>
00765             <span class="comment">// the pool as must succeed.</span>
00766             <span class="comment">//</span>
00767 
00768             irp = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(<a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, allocateSize, ' prI');
00769             <span class="keywordflow">if</span> (!irp) {
00770                 mustSucceed = <a class="code" href="../../d0/d5/io_8h.html#a191">IRP_ALLOCATED_MUST_SUCCEED</a>;
00771                 <span class="keywordflow">if</span> (KeGetPreviousMode() == <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a> ) {
00772                     irp = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(<a class="code" href="../../d5/d8/ex_8h.html#a329a175">NonPagedPoolMustSucceed</a>,
00773                                                 allocateSize,
00774                                                 ' prI');
00775                 }
00776             }
00777         }
00778 
00779         <span class="keywordflow">if</span> (!irp) {
00780             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00781         }
00782 
00783     } <span class="keywordflow">else</span> {
00784         <span class="keywordflow">if</span> (ChargeQuota != <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
00785             lookasideAllocation = <a class="code" href="../../d0/d5/io_8h.html#a193">IRP_LOOKASIDE_ALLOCATION</a>;
00786             InterlockedIncrement( &amp;<a class="code" href="../../d0/d6/iop_8h.html#a130">IopLookasideIrpFloat</a> );
00787         }
00788         ChargeQuota = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00789     }
00790 
00791     <span class="comment">//</span>
00792     <span class="comment">// Initialize the packet.</span>
00793     <span class="comment">//</span>
00794 
00795     <a class="code" href="../../d0/d6/iop_8h.html#a20">IopInitializeIrp</a>(irp, packetSize, StackSize);
00796     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o17">AllocationFlags</a> = (fixedSize | lookasideAllocation | mustSucceed);
00797     <span class="keywordflow">if</span> (ChargeQuota) {
00798         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o17">AllocationFlags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a190">IRP_QUOTA_CHARGED</a>;
00799     }
00800 
00801     <span class="keywordflow">return</span> irp;
00802 }
00803 
00804 <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>
<a name="l00805"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a19">00805</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a19">IoAllocateMdl</a>(
00806     IN PVOID VirtualAddress,
00807     IN ULONG Length,
00808     IN BOOLEAN SecondaryBuffer,
00809     IN BOOLEAN ChargeQuota,
00810     IN OUT <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp OPTIONAL
00811     )
00812 
00813 <span class="comment">/*++</span>
00814 <span class="comment"></span>
00815 <span class="comment">Routine Description:</span>
00816 <span class="comment"></span>
00817 <span class="comment">    This routine allocates a Memory Descriptor List (MDL) large enough to map</span>
00818 <span class="comment">    the buffer specified by the VirtualAddress and Length parameters.  If the</span>
00819 <span class="comment">    routine is given a pointer to an Irp, then it will chain the MDL to the</span>
00820 <span class="comment">    IRP in the appropriate way.</span>
00821 <span class="comment"></span>
00822 <span class="comment">    If this routine is not given a pointer to an Irp it is up to the caller to</span>
00823 <span class="comment">    set the MDL address in the IRP that the MDL is being allocated for.</span>
00824 <span class="comment"></span>
00825 <span class="comment">    Note that the header information of the MDL will also be initialized.</span>
00826 <span class="comment"></span>
00827 <span class="comment">Arguments:</span>
00828 <span class="comment"></span>
00829 <span class="comment">    VirtualAddress - Starting virtual address of the buffer to be mapped.</span>
00830 <span class="comment"></span>
00831 <span class="comment">    Length - Length, in bytes, of the buffer to be mapped.</span>
00832 <span class="comment"></span>
00833 <span class="comment">    SecondaryBuffer - Indicates whether this is a chained buffer.</span>
00834 <span class="comment"></span>
00835 <span class="comment">    ChargeQuota - Indicates whether quota should be charged if MDL allocated.</span>
00836 <span class="comment"></span>
00837 <span class="comment">        N.B. This parameter is ignored.</span>
00838 <span class="comment"></span>
00839 <span class="comment">    Irp - Optional pointer to IRP that MDL is being allocated for.</span>
00840 <span class="comment"></span>
00841 <span class="comment">Return Value:</span>
00842 <span class="comment"></span>
00843 <span class="comment">    A pointer to the allocated MDL, or NULL if one could not be allocated.</span>
00844 <span class="comment">    Note that if no MDL could be allocated because there was not enough quota,</span>
00845 <span class="comment">    then it is up to the caller to catch the raised exception.</span>
00846 <span class="comment"></span>
00847 <span class="comment">--*/</span>
00848 
00849 {
00850     ULONG allocateSize;
00851     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> fixedSize;
00852     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> mdl;
00853     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> mustSucceed;
00854     ULONG size;
00855     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> tmpMdlPtr;
00856 
00857     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(Length);
00858 
00859     <span class="comment">//</span>
00860     <span class="comment">// If the requested length is greater than 2Gb, then we're not going</span>
00861     <span class="comment">// to be able to map the memory, so fail the request.</span>
00862     <span class="comment">//</span>
00863 
00864     <span class="keywordflow">if</span> (Length &amp; 0x80000000) {
00865         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00866     }
00867 
00868     <span class="comment">//</span>
00869     <span class="comment">// Allocate an MDL from the lookaside list or pool as appropriate.</span>
00870     <span class="comment">//</span>
00871 
00872     mdl = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00873     fixedSize = 0;
00874     mustSucceed = 0;
00875     size = <a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a>(VirtualAddress, Length);
00876     <span class="keywordflow">if</span> (size &gt; <a class="code" href="../../d0/d6/iop_8h.html#a12">IOP_FIXED_SIZE_MDL_PFNS</a>) {
00877         allocateSize = <span class="keyword">sizeof</span>(<a class="code" href="../../d6/d7/struct__MDL.html">MDL</a>) + (<span class="keyword">sizeof</span>(PFN_NUMBER) * size);
00878         <span class="keywordflow">if</span> (allocateSize &gt; MAXUSHORT) {
00879             <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00880         }
00881 
00882     } <span class="keywordflow">else</span> {
00883         fixedSize = <a class="code" href="../../d0/d9/ntosdef_8h.html#a15">MDL_ALLOCATED_FIXED_SIZE</a>;
00884         allocateSize =  <span class="keyword">sizeof</span>(<a class="code" href="../../d6/d7/struct__MDL.html">MDL</a>) + (<span class="keyword">sizeof</span>(PFN_NUMBER) * <a class="code" href="../../d0/d6/iop_8h.html#a12">IOP_FIXED_SIZE_MDL_PFNS</a>);
00885         mdl = (<a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a>)<a class="code" href="../../d5/d8/ex_8h.html#a254">ExAllocateFromPPNPagedLookasideList</a>(<a class="code" href="../../d5/d8/ex_8h.html#a331a199">LookasideMdlList</a>);
00886     }
00887 
00888     <span class="keywordflow">if</span> (!mdl) {
00889         mdl = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(<a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, allocateSize, ' ldM');
00890         <span class="keywordflow">if</span> (!mdl) {
00891             <span class="keywordflow">if</span> (KeGetPreviousMode() == <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
00892                 mustSucceed = <a class="code" href="../../d0/d9/ntosdef_8h.html#a26">MDL_ALLOCATED_MUST_SUCCEED</a>;
00893                 mdl = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(<a class="code" href="../../d5/d8/ex_8h.html#a329a175">NonPagedPoolMustSucceed</a>,
00894                                             allocateSize,
00895                                             ' ldM' );
00896             }
00897 
00898             <span class="keywordflow">if</span> (!mdl) {
00899                 <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00900             }
00901         }
00902     }
00903 
00904     <span class="comment">//</span>
00905     <span class="comment">// Now fill in the header of the MDL.</span>
00906     <span class="comment">//</span>
00907 
00908     <a class="code" href="../../d2/d1/mm_8h.html#a24">MmInitializeMdl</a>(mdl, VirtualAddress, Length);
00909     mdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o2">MdlFlags</a> |= (fixedSize | mustSucceed);
00910 
00911     <span class="comment">//</span>
00912     <span class="comment">// Finally, if an IRP was specified, store the address of the MDL</span>
00913     <span class="comment">// based on whether or not this is a secondary buffer.</span>
00914     <span class="comment">//</span>
00915 
00916     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>) {
00917         <span class="keywordflow">if</span> (!SecondaryBuffer) {
00918             <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a> = mdl;
00919 
00920         } <span class="keywordflow">else</span> {
00921             tmpMdlPtr = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a>;
00922             <span class="keywordflow">while</span> (tmpMdlPtr-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o0">Next</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00923                 tmpMdlPtr = tmpMdlPtr-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o0">Next</a>;
00924             }
00925 
00926             tmpMdlPtr-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o0">Next</a> = mdl;
00927         }
00928     }
00929 
00930     <span class="keywordflow">return</span> mdl;
00931 }
00932 
00933 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l00934"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a20">00934</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a20">IoAsynchronousPageWrite</a>(
00935     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
00936     IN <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MemoryDescriptorList,
00937     IN PLARGE_INTEGER StartingOffset,
00938     IN PIO_APC_ROUTINE ApcRoutine,
00939     IN PVOID ApcContext,
00940     OUT PIO_STATUS_BLOCK IoStatusBlock,
00941     OUT <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> *Irp OPTIONAL
00942     )
00943 
00944 <span class="comment">/*++</span>
00945 <span class="comment"></span>
00946 <span class="comment">Routine Description:</span>
00947 <span class="comment"></span>
00948 <span class="comment">    This routine provides a special, fast interface for the Modified Page Writer</span>
00949 <span class="comment">    (MPW) to write pages to the disk quickly and with very little overhead.  All</span>
00950 <span class="comment">    of the special handling for this request is recognized by setting the</span>
00951 <span class="comment">    IRP_PAGING_IO flag in the IRP flags word.</span>
00952 <span class="comment"></span>
00953 <span class="comment">Arguments:</span>
00954 <span class="comment"></span>
00955 <span class="comment">    FileObject - A pointer to a referenced file object describing which file</span>
00956 <span class="comment">        the write should be performed on.</span>
00957 <span class="comment"></span>
00958 <span class="comment">    MemoryDescriptorList - An MDL which describes the physical pages that the</span>
00959 <span class="comment">        pages should be written to the disk.  All of the pages have been locked</span>
00960 <span class="comment">        in memory.  The MDL also describes the length of the write operation.</span>
00961 <span class="comment"></span>
00962 <span class="comment">    StartingOffset - Pointer to the offset in the file from which the write</span>
00963 <span class="comment">        should take place.</span>
00964 <span class="comment"></span>
00965 <span class="comment">    ApcRoutine - The address of a kernel APC routine which should be executed</span>
00966 <span class="comment">        after the write operation has completed.</span>
00967 <span class="comment"></span>
00968 <span class="comment">    ApcContext - A context parameter which should be supplied to the kernel APC</span>
00969 <span class="comment">        routine when it executes.</span>
00970 <span class="comment"></span>
00971 <span class="comment">    IoStatusBlock - A pointer to the I/O status block in which the final status</span>
00972 <span class="comment">        and information should be stored.</span>
00973 <span class="comment"></span>
00974 <span class="comment">    Irp - If specified, allows the caller to squirrel away a pointer to the Irp.</span>
00975 <span class="comment"></span>
00976 <span class="comment">Return Value:</span>
00977 <span class="comment"></span>
00978 <span class="comment">    The function value is the final status of the queue request to the I/O</span>
00979 <span class="comment">    system subcomponents.</span>
00980 <span class="comment"></span>
00981 <span class="comment"></span>
00982 <span class="comment">--*/</span>
00983 
00984 {
00985     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
00986     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
00987     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
00988     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
00989 
00990     <span class="comment">//</span>
00991     <span class="comment">// Begin by getting a pointer to the device object that the file resides</span>
00992     <span class="comment">// on.</span>
00993     <span class="comment">//</span>
00994 
00995     deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( FileObject );
00996 
00997     <span class="comment">//</span>
00998     <span class="comment">// Allocate an I/O Request Packet (IRP) for this out-page operation.</span>
00999     <span class="comment">//</span>
01000 
01001     irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a17">IoAllocateIrp</a>( deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o13">StackSize</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01002     <span class="keywordflow">if</span> (!irp) {
01003         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
01004     }
01005 
01006     <span class="comment">//</span>
01007     <span class="comment">//  If specified, let the caller know what Irp is responsible for this</span>
01008     <span class="comment">//  transfer.  While this is mainly for debugging purposes, it is</span>
01009     <span class="comment">//  absolutely essential to debug certain types of problems, and is</span>
01010     <span class="comment">//  very cheap, thus is included in the FREE build as well.</span>
01011     <span class="comment">//</span>
01012 
01013     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>)) {
01014         *<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> = irp;
01015     }
01016 
01017     <span class="comment">//</span>
01018     <span class="comment">// Get a pointer to the first stack location in the packet.  This location</span>
01019     <span class="comment">// will be used to pass the function codes and parameters to the first</span>
01020     <span class="comment">// driver.</span>
01021     <span class="comment">//</span>
01022 
01023     irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
01024 
01025     <span class="comment">//</span>
01026     <span class="comment">// Fill in the IRP according to this request.</span>
01027     <span class="comment">//</span>
01028 
01029     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a> = MemoryDescriptorList;
01030     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a174">IRP_PAGING_IO</a> | <a class="code" href="../../d0/d5/io_8h.html#a173">IRP_NOCACHE</a>;
01031     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
01032     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.OriginalFileObject = FileObject;
01033     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o26">UserBuffer</a> = (PVOID) ((PCHAR) MemoryDescriptorList-&gt;StartVa + MemoryDescriptorList-&gt;ByteOffset);
01034     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o10">RequestorMode</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>;
01035     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = IoStatusBlock;
01036     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcRoutine = ApcRoutine;
01037     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcContext = ApcContext;
01038 
01039     <span class="comment">//</span>
01040     <span class="comment">// Fill in the normal write parameters.</span>
01041     <span class="comment">//</span>
01042 
01043     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a17">IRP_MJ_WRITE</a>;
01044     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Write.Length = MemoryDescriptorList-&gt;ByteCount;
01045     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Write.ByteOffset = *StartingOffset;
01046     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> = FileObject;
01047 
01048     <span class="comment">//</span>
01049     <span class="comment">// Queue the packet to the appropriate driver based on whether or not there</span>
01050     <span class="comment">// is a VPB associated with the device.</span>
01051     <span class="comment">//</span>
01052 
01053     status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( deviceObject, irp );
01054 
01055     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a3">NT_ERROR</a>( status )) {
01056         IoStatusBlock-&gt;Status = status;
01057         IoStatusBlock-&gt;Information = 0;
01058         ApcRoutine( ApcContext, IoStatusBlock, 0 );
01059         status = STATUS_PENDING;
01060     }
01061 
01062     <span class="keywordflow">return</span> status;
01063 }
01064 
01065 
01066 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01067"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a21">01067</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a21">IoAttachDevice</a>(
01068     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> SourceDevice,
01069     IN PUNICODE_STRING TargetDevice,
01070     OUT <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> *AttachedDevice
01071     )
01072 
01073 <span class="comment">/*++</span>
01074 <span class="comment"></span>
01075 <span class="comment">Routine Description:</span>
01076 <span class="comment"></span>
01077 <span class="comment">    This routine "attaches" a device to another device.  That is, it associates</span>
01078 <span class="comment">    the source device to a target device which enables the I/O system to ensure</span>
01079 <span class="comment">    that the target device a) exists, and b) cannot be unloaded until the source</span>
01080 <span class="comment">    device has detached.  Also, requests bound for the target device are given</span>
01081 <span class="comment">    to the source device first, where applicable.</span>
01082 <span class="comment"></span>
01083 <span class="comment">Arguments:</span>
01084 <span class="comment"></span>
01085 <span class="comment">    SourceDevice - Pointer to device object to be attached to the target.</span>
01086 <span class="comment"></span>
01087 <span class="comment">    TargetDevice - Supplies the name of the target device to which the attach</span>
01088 <span class="comment">        is to occur.</span>
01089 <span class="comment"></span>
01090 <span class="comment">    AttachedDevice - Returns a pointer to the device to which the attach</span>
01091 <span class="comment">        occurred.  This is the device object that the source driver should</span>
01092 <span class="comment">        use to communicate with the target driver.</span>
01093 <span class="comment"></span>
01094 <span class="comment">Return Value:</span>
01095 <span class="comment"></span>
01096 <span class="comment">    The function value is the final status of the operation.</span>
01097 <span class="comment"></span>
01098 <span class="comment">--*/</span>
01099 
01100 {
01101     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
01102     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> targetDevice;
01103     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> fileObject;
01104     OBJECT_ATTRIBUTES objectAttributes;
01105     HANDLE fileHandle;
01106     IO_STATUS_BLOCK ioStatus;
01107 
01108     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01109 
01110     <span class="comment">//</span>
01111     <span class="comment">// Attempt to open the target device for attach access.  This ensures that</span>
01112     <span class="comment">// the device itself will be opened, with all of the special considerations</span>
01113     <span class="comment">// thereof.</span>
01114     <span class="comment">//</span>
01115 
01116     InitializeObjectAttributes( &amp;objectAttributes,
01117                                 TargetDevice,
01118                                 0,
01119                                 (HANDLE) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
01120                                 (PSECURITY_DESCRIPTOR) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01121 
01122     status = <a class="code" href="../../d6/d9/restrfil_8c.html#a33">ZwOpenFile</a>( &amp;fileHandle,
01123                          FILE_READ_ATTRIBUTES,
01124                          &amp;objectAttributes,
01125                          &amp;ioStatus,
01126                          0,
01127                          FILE_NON_DIRECTORY_FILE | <a class="code" href="../../d0/d5/io_8h.html#a112">IO_ATTACH_DEVICE_API</a> );
01128 
01129     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
01130 
01131         <span class="comment">//</span>
01132         <span class="comment">// The open operation was successful.  Dereference the file handle</span>
01133         <span class="comment">// and obtain a pointer to the device object for the handle.</span>
01134         <span class="comment">//</span>
01135 
01136         status = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a>( fileHandle,
01137                                             0,
01138                                             <a class="code" href="../../d5/d8/fssup_8c.html#a3">IoFileObjectType</a>,
01139                                             <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
01140                                             (PVOID *) &amp;fileObject,
01141                                             <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01142         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
01143 
01144             <span class="comment">//</span>
01145             <span class="comment">// Get a pointer to the device object for this file, and close</span>
01146             <span class="comment">// the handle.</span>
01147             <span class="comment">//</span>
01148 
01149             targetDevice = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( fileObject );
01150             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) ZwClose( fileHandle );
01151 
01152         } <span class="keywordflow">else</span> {
01153 
01154             <span class="keywordflow">return</span> status;
01155         }
01156 
01157     } <span class="keywordflow">else</span> {
01158 
01159         <span class="keywordflow">return</span> status;
01160 
01161     }
01162 
01163     <span class="comment">//</span>
01164     <span class="comment">// Set the attached device pointer so that the driver being attached to</span>
01165     <span class="comment">// cannot unload until the detach occurs, and so that attempts to open the</span>
01166     <span class="comment">// device object go through the attached driver.  Note that the reference</span>
01167     <span class="comment">// count is not incremented since exclusive drivers can only be opened once</span>
01168     <span class="comment">// and this would count as an open.  At that point, both device objects</span>
01169     <span class="comment">// would become useless.</span>
01170     <span class="comment">//</span>
01171 
01172     *AttachedDevice = <a class="code" href="../../d4/d6/iosubs_8c.html#a23">IoAttachDeviceToDeviceStack</a>( SourceDevice, targetDevice );
01173     <span class="keywordflow">if</span>(!*AttachedDevice) {
01174         status = STATUS_NO_SUCH_DEVICE;
01175     }
01176 
01177     <span class="comment">//</span>
01178     <span class="comment">// Finally, dereference the file object.  This decrements the reference</span>
01179     <span class="comment">// count for the target device so that when the detach occurs the device</span>
01180     <span class="comment">// can go away if necessary.</span>
01181     <span class="comment">//</span>
01182 
01183     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
01184 
01185     <span class="comment">//</span>
01186     <span class="comment">// Return the final status of the operation.</span>
01187     <span class="comment">//</span>
01188 
01189     <span class="keywordflow">return</span> status;
01190 }
01191 
01192 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l01193"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a22">01193</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a22">IoAttachDeviceByPointer</a>(
01194     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> SourceDevice,
01195     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> TargetDevice
01196     )
01197 
01198 <span class="comment">/*++</span>
01199 <span class="comment"></span>
01200 <span class="comment">Routine Description:</span>
01201 <span class="comment"></span>
01202 <span class="comment">    This routine attaches the source device object to the target device</span>
01203 <span class="comment">    object.</span>
01204 <span class="comment"></span>
01205 <span class="comment">Arguments:</span>
01206 <span class="comment"></span>
01207 <span class="comment">    SourceDevice - Specifies the device object that is to be attached to</span>
01208 <span class="comment">        the target device.</span>
01209 <span class="comment"></span>
01210 <span class="comment">    TargetDevice - Specifies the device object to which the attachment is</span>
01211 <span class="comment">        to take place.</span>
01212 <span class="comment"></span>
01213 <span class="comment">Return Value:</span>
01214 <span class="comment"></span>
01215 <span class="comment">    The function value is the final status of the attach operation.</span>
01216 <span class="comment"></span>
01217 <span class="comment">Note:</span>
01218 <span class="comment"></span>
01219 <span class="comment">    THIS FUNCTION IS OBSOLETE!!! see IoAttachDeviceToDeviceStack</span>
01220 <span class="comment"></span>
01221 <span class="comment">--*/</span>
01222 
01223 {
01224     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
01225     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
01226 
01227     <span class="comment">//</span>
01228     <span class="comment">// Get a pointer to the topmost device object in the stack of devices,</span>
01229     <span class="comment">// beginning with the TargetDevice.</span>
01230     <span class="comment">//</span>
01231 
01232     deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a23">IoAttachDeviceToDeviceStack</a>( SourceDevice, TargetDevice );
01233     <span class="keywordflow">if</span>( deviceObject == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ){
01234         status = STATUS_NO_SUCH_DEVICE;
01235     } <span class="keywordflow">else</span> {
01236         status = STATUS_SUCCESS;
01237     }
01238 
01239     <span class="keywordflow">return</span> status;
01240 }
01241 
01242 <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>
<a name="l01243"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a23">01243</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a23">IoAttachDeviceToDeviceStack</a>(
01244     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> SourceDevice,
01245     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> TargetDevice
01246     )
01247 
01248 <span class="comment">/*++</span>
01249 <span class="comment"></span>
01250 <span class="comment">Routine Description:</span>
01251 <span class="comment"></span>
01252 <span class="comment">    This routine attaches the source device object to the target device</span>
01253 <span class="comment">    object and returns a pointer to the actual device attached to, if</span>
01254 <span class="comment">    successful.</span>
01255 <span class="comment"></span>
01256 <span class="comment">Arguments:</span>
01257 <span class="comment"></span>
01258 <span class="comment">    SourceDevice - Specifies the device object that is to be attached to</span>
01259 <span class="comment">        the target device.</span>
01260 <span class="comment"></span>
01261 <span class="comment">    TargetDevice - Specifies the device object to which the attachment is</span>
01262 <span class="comment">        to occur.</span>
01263 <span class="comment"></span>
01264 <span class="comment">Return Value:</span>
01265 <span class="comment"></span>
01266 <span class="comment">    If successful, this function returns a pointer to the device object to</span>
01267 <span class="comment">    which the attachment actually occurred.</span>
01268 <span class="comment"></span>
01269 <span class="comment">    If unsuccessful, this function returns NULL.  (This could happen if the</span>
01270 <span class="comment">    device currently at the top of the attachment chain is being unloaded,</span>
01271 <span class="comment">    deleted or initialized.)</span>
01272 <span class="comment"></span>
01273 <span class="comment">--*/</span>
01274 
01275 {
01276     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
01277     <a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html">PDEVOBJ_EXTENSION</a> sourceExtension;
01278     KIRQL irql;
01279 
01280     <span class="comment">//</span>
01281     <span class="comment">// Retrieve a pointer to the source device object's extension outside</span>
01282     <span class="comment">// of the IopDatabaseLock, since it isn't protected by that.</span>
01283     <span class="comment">//</span>
01284 
01285     sourceExtension = SourceDevice-&gt;DeviceObjectExtension;
01286 
01287     <span class="comment">//</span>
01288     <span class="comment">// Get a pointer to the topmost device object in the stack of devices,</span>
01289     <span class="comment">// beginning with the TargetDevice, and attach to it.</span>
01290     <span class="comment">//</span>
01291 
01292     ExAcquireFastLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, &amp;irql );
01293 
01294     <span class="comment">//</span>
01295     <span class="comment">// Tell the Special IRP code the stack has changed. Code that will reexamine</span>
01296     <span class="comment">// the stack takes the database lock, so we can place the call here. This</span>
01297     <span class="comment">// also allows us to assert correct behavoir *before* the stack is built up.</span>
01298     <span class="comment">//</span>
01299 
01300     <a class="code" href="../../d7/d6/ioverifier_8h.html#a4">IOV_ATTACH_DEVICE_TO_DEVICE_STACK</a>(SourceDevice, TargetDevice);
01301 
01302     deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a66">IoGetAttachedDevice</a>( TargetDevice );
01303 
01304     <span class="comment">//</span>
01305     <span class="comment">// Make sure that the SourceDevice object isn't already attached to</span>
01306     <span class="comment">// something else, this is now illegal.</span>
01307     <span class="comment">//</span>
01308 
01309     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( sourceExtension-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o7">AttachedTo</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01310 
01311     <span class="comment">//</span>
01312     <span class="comment">// Now attach to the device, provided that it is not being unloaded,</span>
01313     <span class="comment">// deleted or initializing.</span>
01314     <span class="comment">//</span>
01315 
01316     <span class="keywordflow">if</span> (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o8">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a128">DO_DEVICE_INITIALIZING</a> ||
01317         deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o25">DeviceObjectExtension</a>-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o5">ExtensionFlags</a> &amp;
01318         (<a class="code" href="../../d0/d5/io_8h.html#a138">DOE_UNLOAD_PENDING</a> | <a class="code" href="../../d0/d5/io_8h.html#a139">DOE_DELETE_PENDING</a> | <a class="code" href="../../d0/d5/io_8h.html#a140">DOE_REMOVE_PENDING</a> | <a class="code" href="../../d0/d5/io_8h.html#a141">DOE_REMOVE_PROCESSED</a>)) {
01319 
01320         <span class="comment">//</span>
01321         <span class="comment">// The device currently at the top of the attachment chain is being</span>
01322         <span class="comment">// unloaded, deleted or initialized.</span>
01323         <span class="comment">//</span>
01324 
01325         deviceObject = (<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01326 
01327     } <span class="keywordflow">else</span> {
01328 
01329         <span class="comment">//</span>
01330         <span class="comment">// Perform the attachment.  First update the device previously at the</span>
01331         <span class="comment">// top of the attachment chain.</span>
01332         <span class="comment">//</span>
01333         deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o5">AttachedDevice</a> = SourceDevice;
01334         deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o24">Spare1</a>++;
01335 
01336         <span class="comment">//</span>
01337         <span class="comment">// Now update the new top-of-attachment-chain.</span>
01338         <span class="comment">//</span>
01339 
01340         SourceDevice-&gt;StackSize = (UCHAR) (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o13">StackSize</a> + 1);
01341         SourceDevice-&gt;AlignmentRequirement = deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o17">AlignmentRequirement</a>;
01342         SourceDevice-&gt;SectorSize = deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a>;
01343 
01344         <span class="keywordflow">if</span> (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o25">DeviceObjectExtension</a>-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o5">ExtensionFlags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a142">DOE_START_PENDING</a>)  {
01345             SourceDevice-&gt;DeviceObjectExtension-&gt;ExtensionFlags |= <a class="code" href="../../d0/d5/io_8h.html#a142">DOE_START_PENDING</a>;
01346         }
01347 
01348         <span class="comment">//</span>
01349         <span class="comment">// Attachment chain is doubly-linked.</span>
01350         <span class="comment">//</span>
01351 
01352         sourceExtension-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o7">AttachedTo</a> = deviceObject;
01353     }
01354     ExReleaseFastLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, irql );
01355 
01356     <span class="keywordflow">return</span> deviceObject;
01357 }
01358 
01359 <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>
<a name="l01360"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a24">01360</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a24">IoBuildAsynchronousFsdRequest</a>(
01361     IN ULONG MajorFunction,
01362     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
01363     IN OUT PVOID Buffer OPTIONAL,
01364     IN ULONG Length OPTIONAL,
01365     IN PLARGE_INTEGER StartingOffset OPTIONAL,
01366     IN PIO_STATUS_BLOCK IoStatusBlock OPTIONAL
01367     )
01368 
01369 <span class="comment">/*++</span>
01370 <span class="comment"></span>
01371 <span class="comment">Routine Description:</span>
01372 <span class="comment"></span>
01373 <span class="comment">    This routine builds an I/O Request Packet (IRP) suitable for a File System</span>
01374 <span class="comment">    Driver (FSD) to use in requesting an I/O operation from a device driver.</span>
01375 <span class="comment">    The request must be one of the following request codes:</span>
01376 <span class="comment"></span>
01377 <span class="comment">        IRP_MJ_READ</span>
01378 <span class="comment">        IRP_MJ_WRITE</span>
01379 <span class="comment">        IRP_MJ_FLUSH_BUFFERS</span>
01380 <span class="comment">        IRP_MJ_SHUTDOWN</span>
01381 <span class="comment">        IRP_MJ_POWER</span>
01382 <span class="comment"></span>
01383 <span class="comment">    This routine provides a simple, fast interface to the device driver w/o</span>
01384 <span class="comment">    having to put the knowledge of how to build an IRP into all of the FSDs</span>
01385 <span class="comment">    (and device drivers) in the system.</span>
01386 <span class="comment"></span>
01387 <span class="comment">Arguments:</span>
01388 <span class="comment"></span>
01389 <span class="comment">    MajorFunction - Function to be performed;  see previous list.</span>
01390 <span class="comment"></span>
01391 <span class="comment">    DeviceObject - Pointer to device object on which the I/O will be performed.</span>
01392 <span class="comment"></span>
01393 <span class="comment">    Buffer - Pointer to buffer to get data from or write data into.  This</span>
01394 <span class="comment">        parameter is required for read/write, but not for flush or shutdown</span>
01395 <span class="comment">        functions.</span>
01396 <span class="comment"></span>
01397 <span class="comment">    Length - Length of buffer in bytes.  This parameter is required for</span>
01398 <span class="comment">        read/write, but not for flush or shutdown functions.</span>
01399 <span class="comment"></span>
01400 <span class="comment">    StartingOffset - Pointer to the offset on the disk to read/write from/to.</span>
01401 <span class="comment">        This parameter is required for read/write, but not for flush or</span>
01402 <span class="comment">        shutdown functions.</span>
01403 <span class="comment"></span>
01404 <span class="comment">    IoStatusBlock - Pointer to the I/O status block for completion status</span>
01405 <span class="comment">        information.  This parameter is optional since most asynchronous FSD</span>
01406 <span class="comment">        requests will be synchronized by using completion routines, and so the</span>
01407 <span class="comment">        I/O status block will not be written.</span>
01408 <span class="comment"></span>
01409 <span class="comment">Return Value:</span>
01410 <span class="comment"></span>
01411 <span class="comment">    The function value is a pointer to the IRP representing the specified</span>
01412 <span class="comment">    request.</span>
01413 <span class="comment"></span>
01414 <span class="comment">--*/</span>
01415 
01416 {
01417     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
01418     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
01419 
01420     <span class="comment">//</span>
01421     <span class="comment">// Begin by allocating the IRP for this request.  Do not charge quota to</span>
01422     <span class="comment">// the current process for this IRP.</span>
01423     <span class="comment">//</span>
01424 
01425     irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a17">IoAllocateIrp</a>( DeviceObject-&gt;StackSize, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01426     <span class="keywordflow">if</span> (!irp) {
01427         <span class="keywordflow">return</span> irp;
01428     }
01429 
01430     <span class="comment">//</span>
01431     <span class="comment">// Set current thread for IoSetHardErrorOrVerifyDevice.</span>
01432     <span class="comment">//</span>
01433 
01434     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
01435 
01436     <span class="comment">//</span>
01437     <span class="comment">// Get a pointer to the stack location of the first driver which will be</span>
01438     <span class="comment">// invoked.  This is where the function codes and the parameters are set.</span>
01439     <span class="comment">//</span>
01440 
01441     irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
01442 
01443     <span class="comment">//</span>
01444     <span class="comment">// Set the major function code.</span>
01445     <span class="comment">//</span>
01446 
01447     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = (UCHAR) MajorFunction;
01448 
01449     <span class="keywordflow">if</span> (MajorFunction != <a class="code" href="../../d0/d5/io_8h.html#a22">IRP_MJ_FLUSH_BUFFERS</a> &amp;&amp;
01450         MajorFunction != <a class="code" href="../../d0/d5/io_8h.html#a29">IRP_MJ_SHUTDOWN</a> &amp;&amp;
01451         MajorFunction != <a class="code" href="../../d0/d5/io_8h.html#a40">IRP_MJ_PNP</a> &amp;&amp;
01452         MajorFunction != <a class="code" href="../../d0/d5/io_8h.html#a35">IRP_MJ_POWER</a>) {
01453 
01454         <span class="comment">//</span>
01455         <span class="comment">// Now allocate a buffer or lock the pages of the caller's buffer into</span>
01456         <span class="comment">// memory based on whether the target device performs direct or buffered</span>
01457         <span class="comment">// I/O operations.</span>
01458         <span class="comment">//</span>
01459 
01460         <span class="keywordflow">if</span> (DeviceObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a123">DO_BUFFERED_IO</a>) {
01461 
01462             <span class="comment">//</span>
01463             <span class="comment">// The target device supports buffered I/O operations.  Allocate a</span>
01464             <span class="comment">// system buffer and, if this is a write, fill it in.  Otherwise,</span>
01465             <span class="comment">// the copy will be done into the caller's buffer in the completion</span>
01466             <span class="comment">// code.  Also note that the system buffer should be deallocated on</span>
01467             <span class="comment">// completion.  Also, set the parameters based on whether this is a</span>
01468             <span class="comment">// read or a write operation.</span>
01469             <span class="comment">//</span>
01470 
01471             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a177">NonPagedPoolCacheAligned</a>,
01472                                                                      Length,
01473                                                                      '  oI' );
01474             <span class="keywordflow">if</span> (irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01475                 <a class="code" href="../../d4/d6/iosubs_8c.html#a63">IoFreeIrp</a>( irp );
01476                 <span class="keywordflow">return</span> (<a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01477             }
01478 
01479             <span class="keywordflow">if</span> (MajorFunction == <a class="code" href="../../d0/d5/io_8h.html#a17">IRP_MJ_WRITE</a>) {
01480                 RtlCopyMemory( irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer, <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>, Length );
01481                 irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a178">IRP_BUFFERED_IO</a> | <a class="code" href="../../d0/d5/io_8h.html#a179">IRP_DEALLOCATE_BUFFER</a>;
01482             } <span class="keywordflow">else</span> {
01483                 irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a178">IRP_BUFFERED_IO</a> | <a class="code" href="../../d0/d5/io_8h.html#a179">IRP_DEALLOCATE_BUFFER</a> | <a class="code" href="../../d0/d5/io_8h.html#a180">IRP_INPUT_OPERATION</a>;
01484                 irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o26">UserBuffer</a> = <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>;
01485             }
01486 
01487         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (DeviceObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a125">DO_DIRECT_IO</a>) {
01488 
01489             <span class="comment">//</span>
01490             <span class="comment">// The target device supports direct I/O operations.  Allocate</span>
01491             <span class="comment">// an MDL large enough to map the buffer and lock the pages into</span>
01492             <span class="comment">// memory.</span>
01493             <span class="comment">//</span>
01494 
01495             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a> = <a class="code" href="../../d4/d6/iosubs_8c.html#a19">IoAllocateMdl</a>( <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>,
01496                                              Length,
01497                                              <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01498                                              <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01499                                              (<a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01500             <span class="keywordflow">if</span> (irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01501                 <a class="code" href="../../d4/d6/iosubs_8c.html#a63">IoFreeIrp</a>( irp );
01502                 <span class="keywordflow">return</span> (<a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01503             }
01504 
01505             <span class="keywordflow">try</span> {
01506                 <a class="code" href="../../d5/d6/iosup_8c.html#a41">MmProbeAndLockPages</a>( irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a>,
01507                                      <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
01508                                      (<a class="code" href="../../d2/d1/mm_8h.html#a141">LOCK_OPERATION</a>) (MajorFunction == <a class="code" href="../../d0/d5/io_8h.html#a16">IRP_MJ_READ</a> ? <a class="code" href="../../d2/d1/mm_8h.html#a344a169">IoWriteAccess</a> : <a class="code" href="../../d2/d1/mm_8h.html#a344a168">IoReadAccess</a>) );
01509             } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
01510                   <span class="keywordflow">if</span> (irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01511                       <a class="code" href="../../d4/d6/iosubs_8c.html#a65">IoFreeMdl</a>( irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a> );
01512                   }
01513                   <a class="code" href="../../d4/d6/iosubs_8c.html#a63">IoFreeIrp</a>( irp );
01514                   <span class="keywordflow">return</span> (<a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01515             }
01516 
01517         } <span class="keywordflow">else</span> {
01518 
01519             <span class="comment">//</span>
01520             <span class="comment">// The operation is neither buffered nor direct.  Simply pass the</span>
01521             <span class="comment">// address of the buffer in the packet to the driver.</span>
01522             <span class="comment">//</span>
01523 
01524             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o26">UserBuffer</a> = <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>;
01525         }
01526 
01527         <span class="comment">//</span>
01528         <span class="comment">// Set the parameters according to whether this is a read or a write</span>
01529         <span class="comment">// operation.  Notice that these parameters must be set even if the</span>
01530         <span class="comment">// driver has not specified buffered or direct I/O.</span>
01531         <span class="comment">//</span>
01532 
01533         <span class="keywordflow">if</span> (MajorFunction == <a class="code" href="../../d0/d5/io_8h.html#a17">IRP_MJ_WRITE</a>) {
01534             irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Write.Length = Length;
01535             irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Write.ByteOffset = *StartingOffset;
01536         } <span class="keywordflow">else</span> {
01537             irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Read.Length = Length;
01538             irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Read.ByteOffset = *StartingOffset;
01539         }
01540     }
01541 
01542     <span class="comment">//</span>
01543     <span class="comment">// Finally, set the address of the I/O status block and return a pointer</span>
01544     <span class="comment">// to the IRP.</span>
01545     <span class="comment">//</span>
01546 
01547     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = IoStatusBlock;
01548     <span class="keywordflow">return</span> irp;
01549 }
01550 
01551 <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>
<a name="l01552"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a25">01552</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a25">IoBuildDeviceIoControlRequest</a>(
01553     IN ULONG IoControlCode,
01554     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
01555     IN PVOID InputBuffer OPTIONAL,
01556     IN ULONG InputBufferLength,
01557     OUT PVOID OutputBuffer OPTIONAL,
01558     IN ULONG OutputBufferLength,
01559     IN BOOLEAN InternalDeviceIoControl,
01560     IN <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> Event,
01561     OUT PIO_STATUS_BLOCK IoStatusBlock
01562     )
01563 
01564 <span class="comment">/*++</span>
01565 <span class="comment"></span>
01566 <span class="comment">Routine Description:</span>
01567 <span class="comment"></span>
01568 <span class="comment">    This routine builds an I/O Request Packet (IRP) that can be used to</span>
01569 <span class="comment">    perform a synchronous internal or normal device I/O control function.</span>
01570 <span class="comment"></span>
01571 <span class="comment">Arguments:</span>
01572 <span class="comment"></span>
01573 <span class="comment">    IoControlCode - Specifies the device I/O control code that is to be</span>
01574 <span class="comment">        performed by the target device driver.</span>
01575 <span class="comment"></span>
01576 <span class="comment">    DeviceObject - Specifies the target device on which the I/O control</span>
01577 <span class="comment">        function is to be performed.</span>
01578 <span class="comment"></span>
01579 <span class="comment">    InputBuffer - Optional pointer to an input buffer that is to be passed</span>
01580 <span class="comment">        to the device driver.</span>
01581 <span class="comment"></span>
01582 <span class="comment">    InputBufferLength - Length of the InputBuffer in bytes.  If the Input-</span>
01583 <span class="comment">        Buffer parameter is not passed, this parameter must be zero.</span>
01584 <span class="comment"></span>
01585 <span class="comment">    OutputBuffer - Optional pointer to an output buffer that is to be passed</span>
01586 <span class="comment">        to the device driver.</span>
01587 <span class="comment"></span>
01588 <span class="comment">    OutputBufferLength - Length of the OutputBuffer in bytes.  If the</span>
01589 <span class="comment">        OutputBuffer parameter is not passed, this parameter must be zero.</span>
01590 <span class="comment"></span>
01591 <span class="comment">    InternalDeviceIoControl - A BOOLEAN parameter that specifies whether</span>
01592 <span class="comment">        the packet that gets generated should have a major function code</span>
01593 <span class="comment">        of IRP_MJ_INTERNAL_DEVICE_CONTROL (the parameter is TRUE), or</span>
01594 <span class="comment">        IRP_MJ_DEVICE_CONTROL (the parameter is FALSE).</span>
01595 <span class="comment"></span>
01596 <span class="comment">    Event - Supplies a pointer to a kernel event that is to be set to the</span>
01597 <span class="comment">        Signaled state when the I/O operation is complete.  Note that the</span>
01598 <span class="comment">        Event must already be set to the Not-Signaled state.</span>
01599 <span class="comment"></span>
01600 <span class="comment">    IoStatusBlock - Supplies a pointer to an I/O status block that is to</span>
01601 <span class="comment">        be filled in with the final status of the operation once it</span>
01602 <span class="comment">        completes.</span>
01603 <span class="comment"></span>
01604 <span class="comment">Return Value:</span>
01605 <span class="comment"></span>
01606 <span class="comment">    The function value is a pointer to the generated IRP suitable for calling</span>
01607 <span class="comment">    the target device driver.</span>
01608 <span class="comment"></span>
01609 <span class="comment">--*/</span>
01610 
01611 {
01612     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
01613     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
01614     ULONG method;
01615 
01616     <span class="comment">//</span>
01617     <span class="comment">// Begin by allocating the IRP for this request.  Do not charge quota to</span>
01618     <span class="comment">// the current process for this IRP.</span>
01619     <span class="comment">//</span>
01620 
01621     irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a17">IoAllocateIrp</a>( DeviceObject-&gt;StackSize, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
01622     <span class="keywordflow">if</span> (!irp) {
01623         <span class="keywordflow">return</span> irp;
01624     }
01625 
01626     <span class="comment">//</span>
01627     <span class="comment">// Get a pointer to the stack location of the first driver which will be</span>
01628     <span class="comment">// invoked.  This is where the function codes and the parameters are set.</span>
01629     <span class="comment">//</span>
01630 
01631     irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
01632 
01633     <span class="comment">//</span>
01634     <span class="comment">// Set the major function code based on the type of device I/O control</span>
01635     <span class="comment">// function the caller has specified.</span>
01636     <span class="comment">//</span>
01637 
01638     <span class="keywordflow">if</span> (InternalDeviceIoControl) {
01639         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a28">IRP_MJ_INTERNAL_DEVICE_CONTROL</a>;
01640     } <span class="keywordflow">else</span> {
01641         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a27">IRP_MJ_DEVICE_CONTROL</a>;
01642     }
01643 
01644     <span class="comment">//</span>
01645     <span class="comment">// Copy the caller's parameters to the service-specific portion of the</span>
01646     <span class="comment">// IRP for those parameters that are the same for all four methods.</span>
01647     <span class="comment">//</span>
01648 
01649     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.DeviceIoControl.OutputBufferLength = OutputBufferLength;
01650     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.DeviceIoControl.InputBufferLength = InputBufferLength;
01651     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.DeviceIoControl.IoControlCode = IoControlCode;
01652 
01653     <span class="comment">//</span>
01654     <span class="comment">// Get the method bits from the I/O control code to determine how the</span>
01655     <span class="comment">// buffers are to be passed to the driver.</span>
01656     <span class="comment">//</span>
01657 
01658     method = IoControlCode &amp; 3;
01659 
01660     <span class="comment">//</span>
01661     <span class="comment">// Based on the method that the buffers are being passed, either allocate</span>
01662     <span class="comment">// buffers or build MDLs or do nothing.</span>
01663     <span class="comment">//</span>
01664 
01665     <span class="keywordflow">switch</span> ( method ) {
01666 
01667     <span class="keywordflow">case</span> 0:
01668 
01669         <span class="comment">//</span>
01670         <span class="comment">// For this case, allocate a buffer that is large enough to contain</span>
01671         <span class="comment">// both the input and the output buffers.  Copy the input buffer</span>
01672         <span class="comment">// to the allocated buffer and set the appropriate IRP fields.</span>
01673         <span class="comment">//</span>
01674 
01675         <span class="keywordflow">if</span> (InputBufferLength != 0 || OutputBufferLength != 0) {
01676             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a177">NonPagedPoolCacheAligned</a>,
01677                                                                      InputBufferLength &gt; OutputBufferLength ? InputBufferLength : OutputBufferLength,
01678                                                                      '  oI' );
01679             <span class="keywordflow">if</span> (irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01680                 <a class="code" href="../../d4/d6/iosubs_8c.html#a63">IoFreeIrp</a>( irp );
01681                 <span class="keywordflow">return</span> (<a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01682             }
01683             <span class="keywordflow">if</span> (ARGUMENT_PRESENT( InputBuffer )) {
01684                 RtlCopyMemory( irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer,
01685                                InputBuffer,
01686                                InputBufferLength );
01687             }
01688             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a178">IRP_BUFFERED_IO</a> | <a class="code" href="../../d0/d5/io_8h.html#a179">IRP_DEALLOCATE_BUFFER</a>;
01689             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o26">UserBuffer</a> = OutputBuffer;
01690             <span class="keywordflow">if</span> (ARGUMENT_PRESENT( OutputBuffer )) {
01691                 irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a180">IRP_INPUT_OPERATION</a>;
01692             }
01693         } <span class="keywordflow">else</span> {
01694             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = 0;
01695             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o26">UserBuffer</a> = (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01696         }
01697 
01698         <span class="keywordflow">break</span>;
01699 
01700     <span class="keywordflow">case</span> 1:
01701     <span class="keywordflow">case</span> 2:
01702 
01703         <span class="comment">//</span>
01704         <span class="comment">// For these two cases, allocate a buffer that is large enough to</span>
01705         <span class="comment">// contain the input buffer, if any, and copy the information to</span>
01706         <span class="comment">// the allocated buffer.  Then build an MDL for either read or write</span>
01707         <span class="comment">// access, depending on the method, for the output buffer.  Note</span>
01708         <span class="comment">// that an output buffer must have been specified.</span>
01709         <span class="comment">//</span>
01710 
01711         <span class="keywordflow">if</span> (ARGUMENT_PRESENT( InputBuffer )) {
01712             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a177">NonPagedPoolCacheAligned</a>,
01713                                                                      InputBufferLength,
01714                                                                      '  oI' );
01715             <span class="keywordflow">if</span> (irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01716                 <a class="code" href="../../d4/d6/iosubs_8c.html#a63">IoFreeIrp</a>( irp );
01717                 <span class="keywordflow">return</span> (<a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01718             }
01719             RtlCopyMemory( irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer,
01720                            InputBuffer,
01721                            InputBufferLength );
01722             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a178">IRP_BUFFERED_IO</a> | <a class="code" href="../../d0/d5/io_8h.html#a179">IRP_DEALLOCATE_BUFFER</a>;
01723         } <span class="keywordflow">else</span> {
01724             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = 0;
01725         }
01726 
01727         <span class="keywordflow">if</span> (ARGUMENT_PRESENT( OutputBuffer )) {
01728             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a> = <a class="code" href="../../d4/d6/iosubs_8c.html#a19">IoAllocateMdl</a>( OutputBuffer,
01729                                              OutputBufferLength,
01730                                              <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01731                                              <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
01732                                              (<a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
01733             <span class="keywordflow">if</span> (irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01734                 <span class="keywordflow">if</span> (ARGUMENT_PRESENT( InputBuffer )) {
01735                     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer );
01736                 }
01737                 <a class="code" href="../../d4/d6/iosubs_8c.html#a63">IoFreeIrp</a>( irp );
01738                 <span class="keywordflow">return</span> (<a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01739             }
01740 
01741             <span class="keywordflow">try</span> {
01742 
01743                 <a class="code" href="../../d5/d6/iosup_8c.html#a41">MmProbeAndLockPages</a>( irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a>,
01744                                      <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
01745                                      (<a class="code" href="../../d2/d1/mm_8h.html#a141">LOCK_OPERATION</a>) ((method == 1) ? <a class="code" href="../../d2/d1/mm_8h.html#a344a168">IoReadAccess</a> : <a class="code" href="../../d2/d1/mm_8h.html#a344a169">IoWriteAccess</a>) );
01746 
01747             } except (<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
01748 
01749                   <span class="keywordflow">if</span> (irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01750                       <a class="code" href="../../d4/d6/iosubs_8c.html#a65">IoFreeMdl</a>( irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a> );
01751                   }
01752 
01753                   <span class="keywordflow">if</span> (ARGUMENT_PRESENT( InputBuffer )) {
01754                       <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer );
01755                   }
01756 
01757                   <a class="code" href="../../d4/d6/iosubs_8c.html#a63">IoFreeIrp</a>( irp );
01758                   <span class="keywordflow">return</span> (<a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01759             }
01760         }
01761 
01762         <span class="keywordflow">break</span>;
01763 
01764     <span class="keywordflow">case</span> 3:
01765 
01766         <span class="comment">//</span>
01767         <span class="comment">// For this case, do nothing.  Everything is up to the driver.</span>
01768         <span class="comment">// Simply give the driver a copy of the caller's parameters and</span>
01769         <span class="comment">// let the driver do everything itself.</span>
01770         <span class="comment">//</span>
01771 
01772         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o26">UserBuffer</a> = OutputBuffer;
01773         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.DeviceIoControl.Type3InputBuffer = InputBuffer;
01774     }
01775 
01776     <span class="comment">//</span>
01777     <span class="comment">// Finally, set the address of the I/O status block and the address of</span>
01778     <span class="comment">// the kernel event object.  Note that I/O completion will not attempt</span>
01779     <span class="comment">// to dereference the event since there is no file object associated</span>
01780     <span class="comment">// with this operation.</span>
01781     <span class="comment">//</span>
01782 
01783     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = IoStatusBlock;
01784     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>;
01785 
01786     <span class="comment">//</span>
01787     <span class="comment">// Also set the address of the current thread in the packet so the</span>
01788     <span class="comment">// completion code will have a context to execute in.  The IRP also</span>
01789     <span class="comment">// needs to be queued to the thread since the caller is going to set</span>
01790     <span class="comment">// the file object pointer.</span>
01791     <span class="comment">//</span>
01792 
01793     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
01794     <a class="code" href="../../d0/d6/iop_8h.html#a21">IopQueueThreadIrp</a>( irp );
01795 
01796     <span class="comment">//</span>
01797     <span class="comment">// Simply return a pointer to the packet.</span>
01798     <span class="comment">//</span>
01799 
01800     <span class="keywordflow">return</span> irp;
01801 }
01802 
01803 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01804"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a26">01804</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a26">IoBuildPartialMdl</a>(
01805     IN <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> SourceMdl,
01806     IN OUT <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> TargetMdl,
01807     IN PVOID VirtualAddress,
01808     IN ULONG Length
01809     )
01810 
01811 <span class="comment">/*++</span>
01812 <span class="comment"></span>
01813 <span class="comment">Routine Description:</span>
01814 <span class="comment"></span>
01815 <span class="comment">    This routine maps a portion of a buffer as described by an MDL.  The</span>
01816 <span class="comment">    portion of the buffer to be mapped is specified via a virtual address</span>
01817 <span class="comment">    and an optional length.  If the length is not supplied, then the</span>
01818 <span class="comment">    remainder of the buffer is mapped.</span>
01819 <span class="comment"></span>
01820 <span class="comment">Arguments:</span>
01821 <span class="comment"></span>
01822 <span class="comment">    SourceMdl - MDL for the current buffer.</span>
01823 <span class="comment"></span>
01824 <span class="comment">    TargetMdl - MDL to map the specified portion of the buffer.</span>
01825 <span class="comment"></span>
01826 <span class="comment">    VirtualAddress - Base of the buffer to begin mapping.</span>
01827 <span class="comment"></span>
01828 <span class="comment">    Length - Length of buffer to be mapped;  if zero, remainder.</span>
01829 <span class="comment"></span>
01830 <span class="comment">Return Value:</span>
01831 <span class="comment"></span>
01832 <span class="comment">    None.</span>
01833 <span class="comment"></span>
01834 <span class="comment">Notes:</span>
01835 <span class="comment"></span>
01836 <span class="comment">    This routine assumes that the target MDL is large enough to map the</span>
01837 <span class="comment">    desired portion of the buffer.  If the target is not large enough</span>
01838 <span class="comment">    then an exception will be raised.</span>
01839 <span class="comment"></span>
01840 <span class="comment">    It is also assumed that the remaining length of the buffer to be mapped</span>
01841 <span class="comment">    is non-zero.</span>
01842 <span class="comment"></span>
01843 <span class="comment">--*/</span>
01844 
01845 {
01846     ULONG_PTR baseVa;
01847     ULONG offset;
01848     ULONG newLength;
01849     ULONG pageOffset;
01850     PPFN_NUMBER basePointer;
01851     PPFN_NUMBER copyPointer;
01852 
01853     <span class="comment">//</span>
01854     <span class="comment">// Calculate the base address of the buffer that the source Mdl maps.</span>
01855     <span class="comment">// Then, determine the length of the buffer to be mapped, if not</span>
01856     <span class="comment">// specified.</span>
01857     <span class="comment">//</span>
01858 
01859     baseVa = (ULONG_PTR) <a class="code" href="../../d2/d1/mm_8h.html#a15">MmGetMdlBaseVa</a>( SourceMdl );
01860     offset = (ULONG) ((ULONG_PTR)VirtualAddress - baseVa) - <a class="code" href="../../d2/d1/mm_8h.html#a14">MmGetMdlByteOffset</a>(SourceMdl);
01861 
01862     <span class="keywordflow">if</span> (Length == 0) {
01863         newLength = <a class="code" href="../../d2/d1/mm_8h.html#a13">MmGetMdlByteCount</a>( SourceMdl ) - offset;
01864     } <span class="keywordflow">else</span> {
01865         newLength = Length;
01866         <span class="comment">//if (newLength &gt; (MmGetMdlByteCount(SourceMdl) - offset)) {</span>
01867         <span class="comment">//    KeBugCheck( TARGET_MDL_TOO_SMALL );</span>
01868         <span class="comment">//}</span>
01869     }
01870 
01871     <span class="comment">//</span>
01872     <span class="comment">// Initialize the target MDL header.  Note that the original size of</span>
01873     <span class="comment">// the MDL structure itself is left unchanged.</span>
01874     <span class="comment">//</span>
01875 
01876     <span class="comment">//ASSERT ((SourceMdl-&gt;MdlFlags &amp; MDL_PARTIAL) == 0);</span>
01877     TargetMdl-&gt;Process = SourceMdl-&gt;Process;
01878 
01879     TargetMdl-&gt;StartVa = (PVOID) <a class="code" href="../../d2/d1/mm_8h.html#a7">PAGE_ALIGN</a>( VirtualAddress );
01880     pageOffset = ((ULONG)((ULONG_PTR) TargetMdl-&gt;StartVa - (ULONG_PTR) SourceMdl-&gt;StartVa)) &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
01881 
01882 
01883     TargetMdl-&gt;ByteCount = newLength;
01884     TargetMdl-&gt;ByteOffset = <a class="code" href="../../d2/d1/mm_8h.html#a6">BYTE_OFFSET</a>( VirtualAddress );
01885     newLength = <a class="code" href="../../d2/d1/mm_8h.html#a9">COMPUTE_PAGES_SPANNED</a>( VirtualAddress, newLength );
01886     <span class="keywordflow">if</span> (((TargetMdl-&gt;Size - <span class="keyword">sizeof</span>( <a class="code" href="../../d6/d7/struct__MDL.html">MDL</a> )) / <span class="keyword">sizeof</span> (PFN_NUMBER)) &lt; newLength ) {
01887         <a class="code" href="../../d9/d1/bugcheck_8c.html#a13">KeBugCheck</a>( TARGET_MDL_TOO_SMALL );
01888     }
01889 
01890     <span class="comment">//</span>
01891     <span class="comment">// Set the MdlFlags in the target MDL.  Clear all flags but</span>
01892     <span class="comment">// carry across the allocation information, page read and the</span>
01893     <span class="comment">// system mapped info.</span>
01894     <span class="comment">//</span>
01895 
01896     TargetMdl-&gt;MdlFlags &amp;= (<a class="code" href="../../d0/d9/ntosdef_8h.html#a15">MDL_ALLOCATED_FIXED_SIZE</a> | <a class="code" href="../../d0/d9/ntosdef_8h.html#a26">MDL_ALLOCATED_MUST_SUCCEED</a>);
01897     TargetMdl-&gt;MdlFlags |= SourceMdl-&gt;MdlFlags &amp; (<a class="code" href="../../d0/d9/ntosdef_8h.html#a14">MDL_SOURCE_IS_NONPAGED_POOL</a> |
01898                                                   <a class="code" href="../../d0/d9/ntosdef_8h.html#a12">MDL_MAPPED_TO_SYSTEM_VA</a> |
01899                                                   <a class="code" href="../../d0/d9/ntosdef_8h.html#a18">MDL_IO_PAGE_READ</a>);
01900     TargetMdl-&gt;MdlFlags |= <a class="code" href="../../d0/d9/ntosdef_8h.html#a16">MDL_PARTIAL</a>;
01901 
01902 <span class="preprocessor">#if DBG</span>
01903 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (TargetMdl-&gt;MdlFlags &amp; <a class="code" href="../../d0/d9/ntosdef_8h.html#a12">MDL_MAPPED_TO_SYSTEM_VA</a>) {
01904         TargetMdl-&gt;MdlFlags |= <a class="code" href="../../d0/d9/ntosdef_8h.html#a20">MDL_PARENT_MAPPED_SYSTEM_VA</a>;
01905     }
01906 <span class="preprocessor">#endif //DBG</span>
01907 <span class="preprocessor"></span>
01908     <span class="comment">//</span>
01909     <span class="comment">// Preserved the mapped system address.</span>
01910     <span class="comment">//</span>
01911 
01912     TargetMdl-&gt;MappedSystemVa = (PUCHAR)SourceMdl-&gt;MappedSystemVa + offset;
01913 
01914     <span class="comment">//</span>
01915     <span class="comment">// Determine the base address of the first PFN in the source MDL that</span>
01916     <span class="comment">// needs to be copied to the target.  Then, copy as many PFNs as are</span>
01917     <span class="comment">// needed.</span>
01918     <span class="comment">//</span>
01919 
01920     basePointer = <a class="code" href="../../d2/d1/mm_8h.html#a11">MmGetMdlPfnArray</a>(SourceMdl);
01921     basePointer += pageOffset;
01922     copyPointer = <a class="code" href="../../d2/d1/mm_8h.html#a11">MmGetMdlPfnArray</a>(TargetMdl);
01923 
01924     <span class="keywordflow">while</span> (newLength &gt; 0) {
01925         *copyPointer = *basePointer;
01926         copyPointer++;
01927         basePointer++;
01928         newLength--;
01929     }
01930 }
01931 
01932 <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>
<a name="l01933"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a27">01933</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a27">IoBuildSynchronousFsdRequest</a>(
01934     IN ULONG MajorFunction,
01935     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
01936     IN OUT PVOID Buffer OPTIONAL,
01937     IN ULONG Length OPTIONAL,
01938     IN PLARGE_INTEGER StartingOffset OPTIONAL,
01939     IN <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> Event,
01940     OUT PIO_STATUS_BLOCK IoStatusBlock
01941     )
01942 
01943 <span class="comment">/*++</span>
01944 <span class="comment"></span>
01945 <span class="comment">Routine Description:</span>
01946 <span class="comment"></span>
01947 <span class="comment">    This routine builds an I/O Request Packet (IRP) suitable for a File System</span>
01948 <span class="comment">    Driver (FSD) to use in requesting an I/O operation from a device driver.</span>
01949 <span class="comment">    The request must be one of the following request codes:</span>
01950 <span class="comment"></span>
01951 <span class="comment">        IRP_MJ_READ</span>
01952 <span class="comment">        IRP_MJ_WRITE</span>
01953 <span class="comment">        IRP_MJ_FLUSH_BUFFERS</span>
01954 <span class="comment">        IRP_MJ_SHUTDOWN</span>
01955 <span class="comment"></span>
01956 <span class="comment">    This routine provides a simple, fast interface to the device driver w/o</span>
01957 <span class="comment">    having to put the knowledge of how to build an IRP into all of the FSDs</span>
01958 <span class="comment">    (and device drivers) in the system.</span>
01959 <span class="comment"></span>
01960 <span class="comment">    The IRP created by this function causes the I/O system to complete the</span>
01961 <span class="comment">    request by setting the specified event to the Signaled state.</span>
01962 <span class="comment"></span>
01963 <span class="comment">Arguments:</span>
01964 <span class="comment"></span>
01965 <span class="comment">    MajorFunction - Function to be performed;  see previous list.</span>
01966 <span class="comment"></span>
01967 <span class="comment">    DeviceObject - Pointer to device object on which the I/O will be performed.</span>
01968 <span class="comment"></span>
01969 <span class="comment">    Buffer - Pointer to buffer to get data from or write data into.  This</span>
01970 <span class="comment">        parameter is required for read/write, but not for flush or shutdown</span>
01971 <span class="comment">        functions.</span>
01972 <span class="comment"></span>
01973 <span class="comment">    Length - Length of buffer in bytes.  This parameter is required for</span>
01974 <span class="comment">        read/write, but not for flush or shutdown functions.</span>
01975 <span class="comment"></span>
01976 <span class="comment">    StartingOffset - Pointer to the offset on the disk to read/write from/to.</span>
01977 <span class="comment">        This parameter is required for read/write, but not for flush or</span>
01978 <span class="comment">        shutdown functions.</span>
01979 <span class="comment"></span>
01980 <span class="comment">    Event - Pointer to a kernel event structure for synchronization.  The event</span>
01981 <span class="comment">        will be set to the Signaled state when the I/O has completed.</span>
01982 <span class="comment"></span>
01983 <span class="comment">    IoStatusBlock - Pointer to I/O status block for completion status info.</span>
01984 <span class="comment"></span>
01985 <span class="comment">Return Value:</span>
01986 <span class="comment"></span>
01987 <span class="comment">    The function value is a pointer to the IRP representing the specified</span>
01988 <span class="comment">    request.</span>
01989 <span class="comment"></span>
01990 <span class="comment">--*/</span>
01991 
01992 {
01993     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
01994 
01995     <span class="comment">//</span>
01996     <span class="comment">// Do all of the real work in real IRP build routine.</span>
01997     <span class="comment">//</span>
01998 
01999     irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a24">IoBuildAsynchronousFsdRequest</a>( MajorFunction,
02000                                          DeviceObject,
02001                                          <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>,
02002                                          Length,
02003                                          StartingOffset,
02004                                          IoStatusBlock );
02005     <span class="keywordflow">if</span> (irp == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
02006         <span class="keywordflow">return</span> irp;
02007     }
02008 
02009     <span class="comment">//</span>
02010     <span class="comment">// Now fill in the event to the completion code will do the right thing.</span>
02011     <span class="comment">// Notice that because there is no FileObject, the I/O completion code</span>
02012     <span class="comment">// will not attempt to dereference the event.</span>
02013     <span class="comment">//</span>
02014 
02015     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>;
02016 
02017     <span class="comment">//</span>
02018     <span class="comment">// There will be a file object associated w/this packet, so it must be</span>
02019     <span class="comment">// queued to the thread.</span>
02020     <span class="comment">//</span>
02021 
02022     <a class="code" href="../../d0/d6/iop_8h.html#a21">IopQueueThreadIrp</a>( irp );
02023     <span class="keywordflow">return</span> irp;
02024 }
02025 
02026 <span class="preprocessor">#if DBG &amp;&amp; PNP_IO_TRACE</span>
02027 <span class="preprocessor"></span>PCHAR pnpmf[] = {
02028         <span class="stringliteral">"START_DEVICE"</span>,
02029         <span class="stringliteral">"QUERY_REMOVE_DEVICE"</span>,
02030         <span class="stringliteral">"REMOVE_DEVICE"</span>,
02031         <span class="stringliteral">"CANCEL_REMOVE_DEVICE"</span>,
02032         <span class="stringliteral">"STOP_DEVICE"</span>,
02033         <span class="stringliteral">"QUERY_STOP_DEVICE"</span>,
02034         <span class="stringliteral">"CANCEL_STOP_DEVICE"</span>,
02035         <span class="stringliteral">"QUERY_DEVICE_RELATIONS"</span>,
02036         <span class="stringliteral">"QUERY_INTERFACE"</span>,
02037         <span class="stringliteral">"QUERY_CAPABILITIES"</span>,
02038         <span class="stringliteral">"QUERY_RESOURCES"</span>,
02039         <span class="stringliteral">"QUERY_RESOURCE_REQUIREMENTS"</span>,
02040         <span class="stringliteral">"QUERY_DEVICE_TEXT"</span>,
02041         <span class="stringliteral">"FILTER_RESOURCE_REQUIREMENTS"</span>,
02042         <span class="stringliteral">"obsolete minor function!!!"</span>,
02043         <span class="stringliteral">"READ_CONFIG"</span>,
02044         <span class="stringliteral">"WRITE_CONFIG"</span>,
02045         <span class="stringliteral">"EJECT"</span>,
02046         <span class="stringliteral">"SET_LOCK"</span>,
02047         <span class="stringliteral">"QUERY_ID"</span>,
02048         <span class="stringliteral">"QUERY_PNP_DEVICE_STATE"</span>,
02049         <span class="stringliteral">"QUERY_BUS_INFORMATION"</span>,
02050         <span class="stringliteral">"USAGE_NOTIFICATION"</span>
02051         };
02052 PCHAR pnpUsageMf[] = {
02053     <span class="stringliteral">"*** Undefined ***"</span>,
02054     <span class="stringliteral">"Paging"</span>,
02055     <span class="stringliteral">"Hibernation"</span>,
02056     <span class="stringliteral">"DumpFile"</span>
02057 };
02058 <span class="preprocessor">#endif</span>
02059 <span class="preprocessor"></span>
02060 
02061 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
02062 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l02063"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a28">02063</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a28">IopfCallDriver</a>(
02064     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
02065     IN OUT <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
02066     )
02067 
02068 <span class="comment">/*++</span>
02069 <span class="comment"></span>
02070 <span class="comment">Routine Description:</span>
02071 <span class="comment"></span>
02072 <span class="comment">    This routine is invoked to pass an I/O Request Packet (IRP) to another</span>
02073 <span class="comment">    driver at its dispatch routine.</span>
02074 <span class="comment"></span>
02075 <span class="comment">Arguments:</span>
02076 <span class="comment"></span>
02077 <span class="comment">    DeviceObject - Pointer to device object to which the IRP should be passed.</span>
02078 <span class="comment"></span>
02079 <span class="comment">    Irp - Pointer to IRP for request.</span>
02080 <span class="comment"></span>
02081 <span class="comment">Return Value:</span>
02082 <span class="comment"></span>
02083 <span class="comment">    Return status from driver's dispatch routine.</span>
02084 <span class="comment"></span>
02085 <span class="comment">--*/</span>
02086 
02087 {
02088     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
02089     <a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html">PDRIVER_OBJECT</a> driverObject;
02090     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
02091 
02092     <span class="comment">//</span>
02093     <span class="comment">// Ensure that this is really an I/O Request Packet.</span>
02094     <span class="comment">//</span>
02095 
02096     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o0">Type</a> == <a class="code" href="../../d0/d5/io_8h.html#a5">IO_TYPE_IRP</a> );
02097 
02098     <span class="comment">//</span>
02099     <span class="comment">// Update the IRP stack to point to the next location.</span>
02100     <span class="comment">//</span>
02101     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a>--;
02102 
02103     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a> &lt;= 0) {
02104         <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a>( NO_MORE_IRP_STACK_LOCATIONS, (ULONG_PTR) <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, 0, 0, 0 );
02105     }
02106 
02107     irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
02108     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.CurrentStackLocation = irpSp;
02109 
02110     <span class="comment">//</span>
02111     <span class="comment">// Save a pointer to the device object for this request so that it can</span>
02112     <span class="comment">// be used later in completion.</span>
02113     <span class="comment">//</span>
02114 
02115     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o57">DeviceObject</a> = DeviceObject;
02116 
02117     <span class="comment">//</span>
02118     <span class="comment">// Invoke the driver at its dispatch routine entry point.</span>
02119     <span class="comment">//</span>
02120 
02121     driverObject = DeviceObject-&gt;DriverObject;
02122 
02123     <a class="code" href="../../d2/d1/mm_8h.html#a47">PERFINFO_DRIVER_MAJORFUNCTION_CALL</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, irpSp, driverObject);
02124 
02125     status = driverObject-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o14">MajorFunction</a>[irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a>]( DeviceObject,
02126                                                               <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
02127 
02128     <a class="code" href="../../d2/d1/mm_8h.html#a48">PERFINFO_DRIVER_MAJORFUNCTION_RETURN</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, irpSp, driverObject);
02129 
02130     <span class="keywordflow">return</span> status;
02131 }
02132 
02133 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
02134 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l02135"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a29">02135</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a29">IofCallDriver</a>(
02136     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
02137     IN OUT <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
02138     )
02139 {
02140     <span class="comment">//</span>
02141     <span class="comment">// This routine will either jump immediately to IopfCallDriver, or rather</span>
02142     <span class="comment">// IovCallDriver.</span>
02143     <span class="comment">//</span>
02144     <span class="keywordflow">return</span> <a class="code" href="../../d0/d6/iop_8h.html#a133">pIofCallDriver</a>(DeviceObject, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>);
02145 }
02146 
02147 
02148 BOOLEAN
<a name="l02149"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a30">02149</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a30">IoCancelIrp</a>(
02150     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
02151     )
02152 
02153 <span class="comment">/*++</span>
02154 <span class="comment"></span>
02155 <span class="comment">Routine Description:</span>
02156 <span class="comment"></span>
02157 <span class="comment">    This routine is invoked to cancel an individual I/O Request Packet.</span>
02158 <span class="comment">    It acquires the cancel spin lock, sets the cancel flag in the IRP, and</span>
02159 <span class="comment">    then invokes the cancel routine specified by the appropriate field in</span>
02160 <span class="comment">    the IRP, if a routine was specified.  It is expected that the cancel</span>
02161 <span class="comment">    routine will relaease the cancel spinlock.  If there is no cancel routine,</span>
02162 <span class="comment">    then the cancel spin lock is released.</span>
02163 <span class="comment"></span>
02164 <span class="comment">Arguments:</span>
02165 <span class="comment"></span>
02166 <span class="comment">    Irp - Supplies a pointer to the IRP to be cancelled.</span>
02167 <span class="comment"></span>
02168 <span class="comment">Return Value:</span>
02169 <span class="comment"></span>
02170 <span class="comment">    The function value is TRUE if the IRP was in a cancelable state (it</span>
02171 <span class="comment">    had a cancel routine), else FALSE is returned.</span>
02172 <span class="comment"></span>
02173 <span class="comment">Notes:</span>
02174 <span class="comment"></span>
02175 <span class="comment">    It is assumed that the caller has taken the necessary action to ensure</span>
02176 <span class="comment">    that the packet cannot be fully completed before invoking this routine.</span>
02177 <span class="comment"></span>
02178 <span class="comment">--*/</span>
02179 
02180 {
02181     <a class="code" href="../../d0/d5/io_8h.html#a286">PDRIVER_CANCEL</a> cancelRoutine;
02182     KIRQL irql;
02183     BOOLEAN returnValue;
02184 
02185 
02186     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o0">Type</a> == <a class="code" href="../../d0/d5/io_8h.html#a5">IO_TYPE_IRP</a> );
02187 
02188     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a132">IopVerifierOn</a>) {
02189         <span class="keywordflow">if</span> (<a class="code" href="../../d7/d6/ioverifier_8h.html#a5">IOV_CANCEL_IRP</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, &amp;returnValue)) {
02190             <span class="keywordflow">return</span> returnValue;
02191         }
02192     }
02193 
02194     <span class="comment">//</span>
02195     <span class="comment">// Acquire the cancel spin lock.</span>
02196     <span class="comment">//</span>
02197 
02198     <a class="code" href="../../d4/d6/iosubs_8c.html#a9">IoAcquireCancelSpinLock</a>( &amp;irql );
02199 
02200     <span class="comment">//</span>
02201     <span class="comment">// Set the cancel flag in the IRP.</span>
02202     <span class="comment">//</span>
02203 
02204     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o14">Cancel</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02205 
02206     <span class="comment">//</span>
02207     <span class="comment">// Obtain the address of the cancel routine, and if one was specified,</span>
02208     <span class="comment">// invoke it.</span>
02209     <span class="comment">//</span>
02210 
02211     cancelRoutine = (<a class="code" href="../../d0/d5/io_8h.html#a286">PDRIVER_CANCEL</a>) InterlockedExchangePointer( (PVOID *) &amp;<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o25">CancelRoutine</a>,
02212                                                                  <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
02213 
02214     <span class="keywordflow">if</span> (cancelRoutine) {
02215         <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a> &gt; (CCHAR) (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o12">StackCount</a> + 1)) {
02216             <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a>( CANCEL_STATE_IN_COMPLETED_IRP, (ULONG_PTR) <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, 0, 0, 0 );
02217         }
02218         <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o15">CancelIrql</a> = irql;
02219 
02220         cancelRoutine( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.CurrentStackLocation-&gt;DeviceObject,
02221                        <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
02222         <span class="comment">//</span>
02223         <span class="comment">// The cancel spinlock should have been released by the cancel routine.</span>
02224         <span class="comment">//</span>
02225 
02226         <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
02227 
02228     } <span class="keywordflow">else</span> {
02229 
02230         <span class="comment">//</span>
02231         <span class="comment">// There was no cancel routine, so release the cancel spinlock and</span>
02232         <span class="comment">// return indicating the Irp was not currently cancelable.</span>
02233         <span class="comment">//</span>
02234 
02235         <a class="code" href="../../d4/d6/iosubs_8c.html#a101">IoReleaseCancelSpinLock</a>( irql );
02236 
02237         <span class="keywordflow">return</span>(<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
02238     }
02239 }
02240 
02241 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l02242"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a31">02242</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a31">IoCancelThreadIo</a>(
02243     IN <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a> Thread
02244     )
02245 
02246 <span class="comment">/*++</span>
02247 <span class="comment"></span>
02248 <span class="comment">Routine Description:</span>
02249 <span class="comment"></span>
02250 <span class="comment">    This routine cancels all of the I/O operations for the specified thread.</span>
02251 <span class="comment">    This is accomplished by walking the list of IRPs in the thread IRP list</span>
02252 <span class="comment">    and canceling each one individually.  No other I/O operations can be</span>
02253 <span class="comment">    started for the thread since this routine has control of the thread itself.</span>
02254 <span class="comment"></span>
02255 <span class="comment">Arguments:</span>
02256 <span class="comment"></span>
02257 <span class="comment">    Tcb - Pointer to the Thread Control Block for the thread.</span>
02258 <span class="comment"></span>
02259 <span class="comment">Return Value:</span>
02260 <span class="comment"></span>
02261 <span class="comment">    None.</span>
02262 <span class="comment"></span>
02263 <span class="comment">--*/</span>
02264 
02265 {
02266     PLIST_ENTRY header;
02267     PLIST_ENTRY entry;
02268     KIRQL irql;
02269     <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a> thread;
02270     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
02271     ULONG count;
02272     LARGE_INTEGER interval;
02273 
02274     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02275 
02276     DBG_UNREFERENCED_PARAMETER( Thread );
02277 
02278     thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
02279 
02280     <span class="comment">//</span>
02281     <span class="comment">// Raise the IRQL so that the IrpList cannot be modified by a completion</span>
02282     <span class="comment">// APC.</span>
02283     <span class="comment">//</span>
02284 
02285     <a class="code" href="../../d9/d5/verifier_8c.html#a116">KeRaiseIrql</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a52">APC_LEVEL</a>, &amp;irql );
02286 
02287     header = &amp;thread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o18">IrpList</a>;
02288     entry = thread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o18">IrpList</a>.Flink;
02289 
02290     <span class="comment">//</span>
02291     <span class="comment">// Walk the list of pending IRPs, canceling each of them.</span>
02292     <span class="comment">//</span>
02293 
02294     <span class="keywordflow">while</span> (header != entry) {
02295         irp = CONTAINING_RECORD( entry, <a class="code" href="../../d0/d2/struct__IRP.html">IRP</a>, ThreadListEntry );
02296         <a class="code" href="../../d4/d6/iosubs_8c.html#a30">IoCancelIrp</a>( irp );
02297         entry = entry-&gt;Flink;
02298     }
02299 
02300     <span class="comment">//</span>
02301     <span class="comment">// Wait for the requests to complete.  Note that waiting may eventually</span>
02302     <span class="comment">// timeout, in which case more work must be done.</span>
02303     <span class="comment">//</span>
02304 
02305     count = 0;
02306     interval.QuadPart = -10 * 1000 * 100;
02307 
02308     <span class="keywordflow">while</span> (!IsListEmpty( &amp;Thread-&gt;IrpList )) {
02309 
02310         <span class="comment">//</span>
02311         <span class="comment">// Lower the IRQL so that the thread APC can fire which will complete</span>
02312         <span class="comment">// the requests.  Delay execution for a time and let the request</span>
02313         <span class="comment">// finish.  The delay time is 100ms.</span>
02314         <span class="comment">//</span>
02315 
02316         <a class="code" href="../../d9/d5/verifier_8c.html#a117">KeLowerIrql</a>( irql );
02317         <a class="code" href="../../d1/d7/wait_8c.html#a2">KeDelayExecutionThread</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>, &amp;interval );
02318 
02319         <span class="keywordflow">if</span> (count++ &gt; 3000) {
02320 
02321             <span class="comment">//</span>
02322             <span class="comment">// This I/O request has timed out, as it has not been completed</span>
02323             <span class="comment">// for a full 5 minutes. Attempt to remove the packet's association</span>
02324             <span class="comment">// with this thread.  Note that by not resetting the count, the</span>
02325             <span class="comment">// next time through the loop the next packet, if there is one,</span>
02326             <span class="comment">// which has also timed out, will be dealt with, although it</span>
02327             <span class="comment">// will be given another 100ms to complete.</span>
02328             <span class="comment">//</span>
02329 
02330             <a class="code" href="../../d0/d6/iop_8h.html#a166">IopDisassociateThreadIrp</a>();
02331         }
02332 
02333         <a class="code" href="../../d9/d5/verifier_8c.html#a116">KeRaiseIrql</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a52">APC_LEVEL</a>, &amp;irql );
02334     }
02335 
02336     <a class="code" href="../../d9/d5/verifier_8c.html#a117">KeLowerIrql</a>( irql );
02337 }
02338 
02339 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l02340"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a32">02340</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a32">IoCheckDesiredAccess</a>(
02341     IN OUT PACCESS_MASK DesiredAccess,
02342     IN ACCESS_MASK GrantedAccess
02343     )
02344 
02345 <span class="comment">/*++</span>
02346 <span class="comment"></span>
02347 <span class="comment">Routine Description:</span>
02348 <span class="comment"></span>
02349 <span class="comment">    This routine is invoked to determine whether or not the granted access</span>
02350 <span class="comment">    to a file allows the access specified by a desired access.</span>
02351 <span class="comment"></span>
02352 <span class="comment">Arguments:</span>
02353 <span class="comment"></span>
02354 <span class="comment">    DesiredAccess - Pointer to a variable containing the access desired to</span>
02355 <span class="comment">        the file.</span>
02356 <span class="comment"></span>
02357 <span class="comment">    GrantedAccess - Access currently granted to the file.</span>
02358 <span class="comment"></span>
02359 <span class="comment">Return Value:</span>
02360 <span class="comment"></span>
02361 <span class="comment">    The final status of the access check is the function value.  If the</span>
02362 <span class="comment">    accessor has the access to the file, then STATUS_SUCCESS is returned;</span>
02363 <span class="comment">    otherwise, STATUS_ACCESS_DENIED is returned.</span>
02364 <span class="comment"></span>
02365 <span class="comment">    Also, the DesiredAccess is returned with no generic mapping.</span>
02366 <span class="comment"></span>
02367 <span class="comment">--*/</span>
02368 
02369 {
02370     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02371 
02372     <span class="comment">//</span>
02373     <span class="comment">// Convert the desired access to a non-generic access mask.</span>
02374     <span class="comment">//</span>
02375 
02376     <a class="code" href="../../d8/d6/sertl_8c.html#a70">RtlMapGenericMask</a>( DesiredAccess,
02377                        &amp;<a class="code" href="../../d5/d8/fssup_8c.html#a3">IoFileObjectType</a>-&gt;<a class="code" href="../../d3/d6/struct__OBJECT__TYPE.html#o9">TypeInfo</a>.<a class="code" href="../../d5/d6/struct__OBJECT__TYPE__INITIALIZER.html#o4">GenericMapping</a> );
02378 
02379     <span class="comment">//</span>
02380     <span class="comment">// Determine whether the desired access to the file is allowed, given</span>
02381     <span class="comment">// the current granted access.</span>
02382     <span class="comment">//</span>
02383 
02384     <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d5/se_8h.html#a8">SeComputeDeniedAccesses</a>( GrantedAccess, *DesiredAccess )) {
02385         <span class="keywordflow">return</span> STATUS_SUCCESS;
02386     } <span class="keywordflow">else</span> {
02387         <span class="keywordflow">return</span> STATUS_ACCESS_DENIED;
02388     }
02389 }
02390 
02391 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l02392"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a33">02392</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a33">IoCheckEaBufferValidity</a>(
02393     IN PFILE_FULL_EA_INFORMATION EaBuffer,
02394     IN ULONG EaLength,
02395     OUT PULONG ErrorOffset
02396     )
02397 
02398 <span class="comment">/*++</span>
02399 <span class="comment"></span>
02400 <span class="comment">Routine Description:</span>
02401 <span class="comment"></span>
02402 <span class="comment">    This routine checks the validity of the specified EA buffer to guarantee</span>
02403 <span class="comment">    that its format is proper, no fields hang over, that it is not recursive,</span>
02404 <span class="comment">    etc.</span>
02405 <span class="comment"></span>
02406 <span class="comment">Arguments:</span>
02407 <span class="comment"></span>
02408 <span class="comment">    EaBuffer - Pointer to the buffer containing the EAs to be checked.</span>
02409 <span class="comment"></span>
02410 <span class="comment">    EaLength - Specifies the length of EaBuffer.</span>
02411 <span class="comment"></span>
02412 <span class="comment">    ErrorOffset - A variable to receive the offset of the offending entry</span>
02413 <span class="comment">        in the EA buffer if an error is incurred.  This variable is only</span>
02414 <span class="comment">        valid if an error occurs.</span>
02415 <span class="comment"></span>
02416 <span class="comment">Return Value:</span>
02417 <span class="comment"></span>
02418 <span class="comment">    The function value is STATUS_SUCCESS if the EA buffer contains a valid,</span>
02419 <span class="comment">    properly formed list, otherwise STATUS_EA_LIST_INCONSISTENT.</span>
02420 <span class="comment"></span>
02421 <span class="comment">--*/</span>
02422 
02423 #define <a class="code" href="../../d4/d6/iosubs_8c.html#a0">ALIGN_LONG</a>( Address ) ( (ULONG) ((Address + 3) &amp; ~3) )
02424 
02425 <span class="preprocessor">#define GET_OFFSET_LENGTH( CurrentEa, EaBase ) (    \</span>
02426 <span class="preprocessor">    (ULONG) ((PCHAR) CurrentEa - (PCHAR) EaBase) )</span>
02427 <span class="preprocessor"></span>
02428 {
02429     LONG tempLength;
02430     ULONG entrySize;
02431     PFILE_FULL_EA_INFORMATION eas;
02432 
02433     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02434 
02435     <span class="comment">//</span>
02436     <span class="comment">// Walk the buffer and ensure that its format is valid.  That is, ensure</span>
02437     <span class="comment">// that it does not walk off the end of the buffer, is not recursive,</span>
02438     <span class="comment">// etc.</span>
02439     <span class="comment">//</span>
02440 
02441     eas = EaBuffer;
02442     tempLength = EaLength;
02443 
02444     <span class="keywordflow">for</span> (;;) {
02445 
02446         <span class="comment">//</span>
02447         <span class="comment">// Get the size of the current entry in the buffer.  The minimum</span>
02448         <span class="comment">// size of the entry is the fixed size part of the structure plus</span>
02449         <span class="comment">// the length of the name, a single termination character byte which</span>
02450         <span class="comment">// must be present (a 0), plus the length of the value.  If this</span>
02451         <span class="comment">// is not the last entry, then there will also be pad bytes to get</span>
02452         <span class="comment">// to the next longword boundary.</span>
02453         <span class="comment">//</span>
02454 
02455         <span class="comment">//</span>
02456         <span class="comment">// Start by checking that the fixed size lies within the stated length.</span>
02457         <span class="comment">//</span>
02458 
02459         <span class="keywordflow">if</span> (tempLength &lt; FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0])) {
02460 
02461             *ErrorOffset = <a class="code" href="../../d2/d4/internal_8c.html#a1">GET_OFFSET_LENGTH</a>( eas, EaBuffer );
02462             <span class="keywordflow">return</span> STATUS_EA_LIST_INCONSISTENT;
02463         }
02464 
02465         entrySize = FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0] ) +
02466                         eas-&gt;EaNameLength + 1 + eas-&gt;EaValueLength;
02467 
02468         <span class="comment">//</span>
02469         <span class="comment">// Confirm that the full length lies within the stated buffer length.</span>
02470         <span class="comment">//</span>
02471 
02472         <span class="keywordflow">if</span> ((ULONG) tempLength &lt; entrySize) {
02473 
02474             *ErrorOffset = <a class="code" href="../../d2/d4/internal_8c.html#a1">GET_OFFSET_LENGTH</a>( eas, EaBuffer );
02475             <span class="keywordflow">return</span> STATUS_EA_LIST_INCONSISTENT;
02476         }
02477 
02478         <span class="comment">//</span>
02479         <span class="comment">// Confirm that there is a NULL terminator after the name.</span>
02480         <span class="comment">//</span>
02481 
02482         <span class="keywordflow">if</span> (eas-&gt;EaName[eas-&gt;EaNameLength] != <span class="charliteral">'\0'</span>) {
02483 
02484             *ErrorOffset = <a class="code" href="../../d2/d4/internal_8c.html#a1">GET_OFFSET_LENGTH</a>( eas, EaBuffer );
02485             <span class="keywordflow">return</span> STATUS_EA_LIST_INCONSISTENT;
02486         }
02487 
02488         <span class="keywordflow">if</span> (eas-&gt;NextEntryOffset) {
02489 
02490             <span class="comment">//</span>
02491             <span class="comment">// There is another entry in the buffer and it must be longword</span>
02492             <span class="comment">// aligned.  Ensure that the offset indicates that it is.  If it</span>
02493             <span class="comment">// isn't, return invalid parameter.</span>
02494             <span class="comment">//</span>
02495 
02496             <span class="keywordflow">if</span> (<a class="code" href="../../d4/d6/iosubs_8c.html#a0">ALIGN_LONG</a>( entrySize ) != eas-&gt;NextEntryOffset ||
02497                 (LONG) eas-&gt;NextEntryOffset &lt; 0) {
02498                 *ErrorOffset = <a class="code" href="../../d2/d4/internal_8c.html#a1">GET_OFFSET_LENGTH</a>( eas, EaBuffer );
02499                 <span class="keywordflow">return</span> STATUS_EA_LIST_INCONSISTENT;
02500 
02501             } <span class="keywordflow">else</span> {
02502 
02503                 <span class="comment">//</span>
02504                 <span class="comment">// There is another entry in the buffer, so account for the</span>
02505                 <span class="comment">// size of the current entry in the length and get a pointer</span>
02506                 <span class="comment">// to the next entry.</span>
02507                 <span class="comment">//</span>
02508 
02509                 tempLength -= eas-&gt;NextEntryOffset;
02510                 <span class="keywordflow">if</span> (tempLength &lt; 0) {
02511                     *ErrorOffset = <a class="code" href="../../d2/d4/internal_8c.html#a1">GET_OFFSET_LENGTH</a>( eas, EaBuffer );
02512                     <span class="keywordflow">return</span> STATUS_EA_LIST_INCONSISTENT;
02513                 }
02514                 eas = (PFILE_FULL_EA_INFORMATION) ((PCHAR) eas + eas-&gt;NextEntryOffset);
02515 
02516             }
02517 
02518         } <span class="keywordflow">else</span> {
02519 
02520             <span class="comment">//</span>
02521             <span class="comment">// There are no other entries in the buffer.  Simply account for</span>
02522             <span class="comment">// the overall buffer length according to the size of the current</span>
02523             <span class="comment">// entry and exit the loop.</span>
02524             <span class="comment">//</span>
02525 
02526             tempLength -= entrySize;
02527             <span class="keywordflow">break</span>;
02528 
02529         }
02530     }
02531 
02532     <span class="comment">//</span>
02533     <span class="comment">// All of the entries in the buffer have been processed.  Check to see</span>
02534     <span class="comment">// whether the overall buffer length went negative.  If so, return an</span>
02535     <span class="comment">// error.</span>
02536     <span class="comment">//</span>
02537 
02538     <span class="keywordflow">if</span> (tempLength &lt; 0) {
02539         *ErrorOffset = <a class="code" href="../../d2/d4/internal_8c.html#a1">GET_OFFSET_LENGTH</a>( eas, EaBuffer );
02540         <span class="keywordflow">return</span> STATUS_EA_LIST_INCONSISTENT;
02541     }
02542 
02543     <span class="keywordflow">return</span> STATUS_SUCCESS;
02544 }
02545 
02546 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l02547"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a34">02547</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a34">IoCheckFunctionAccess</a>(
02548     IN ACCESS_MASK GrantedAccess,
02549     IN UCHAR MajorFunction,
02550     IN UCHAR MinorFunction,
02551     IN ULONG IoControlCode,
02552     IN PVOID Arg1 OPTIONAL,
02553     IN PVOID Arg2 OPTIONAL
02554     )
02555 
02556 <span class="comment">/*++</span>
02557 <span class="comment"></span>
02558 <span class="comment">Routine Description:</span>
02559 <span class="comment"></span>
02560 <span class="comment">    This routine checks the parameters and access for the function and</span>
02561 <span class="comment">    parameters specified by the input parameters against the current access</span>
02562 <span class="comment">    to the file as described by the GrantedAccess mask parameter.  If the</span>
02563 <span class="comment">    caller has the access to the file, then a successful status code is</span>
02564 <span class="comment">    returned.  Otherwise, an error status code is returned as the function</span>
02565 <span class="comment">    value.</span>
02566 <span class="comment"></span>
02567 <span class="comment">Arguments:</span>
02568 <span class="comment"></span>
02569 <span class="comment">    GrantedAccess - Access granted to the file for the caller.</span>
02570 <span class="comment"></span>
02571 <span class="comment">    MajorFunction - Major function code for the operation being performed.</span>
02572 <span class="comment"></span>
02573 <span class="comment">    MinorFunction - Minor function code for the operation being performed.</span>
02574 <span class="comment"></span>
02575 <span class="comment">    IoControlCode - I/O function control code for a device or file system I/O</span>
02576 <span class="comment">        code.  Used only for those two function types.</span>
02577 <span class="comment"></span>
02578 <span class="comment">    Arg1 - Optional argument that depends on the major function. Its</span>
02579 <span class="comment">         FileInformationClass if the major function code indicates a query or set</span>
02580 <span class="comment">         file information function is being performed. It points to Security Info</span>
02581 <span class="comment">         if major function code is IRP_MJ_*_SECURITY.</span>
02582 <span class="comment"></span>
02583 <span class="comment">    Arg2 - Optional second argument that depends on the major function. Currently its</span>
02584 <span class="comment">        FsInformationClass.This parameter MUST be supplied if the major function</span>
02585 <span class="comment">        code indicates that a query or set file system information function is</span>
02586 <span class="comment">        being performed.</span>
02587 <span class="comment"></span>
02588 <span class="comment">Return Value:</span>
02589 <span class="comment"></span>
02590 <span class="comment">    The final status of the access check is the function value.  If the</span>
02591 <span class="comment">    accessor has the access to the file, then STATUS_SUCCESS is returned;</span>
02592 <span class="comment">    otherwise, STATUS_ACCESS_DENIED is returned.</span>
02593 <span class="comment"></span>
02594 <span class="comment">Note:</span>
02595 <span class="comment"></span>
02596 <span class="comment">    The GrantedAccess mask may not contain any generic mappings.  That is,</span>
02597 <span class="comment">    the IoCheckDesiredAccess function must have been previously invoked to</span>
02598 <span class="comment">    return a full mask.</span>
02599 <span class="comment"></span>
02600 <span class="comment">--*/</span>
02601 
02602 {
02603     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status = STATUS_SUCCESS;
02604     PFILE_INFORMATION_CLASS FileInformationClass;
02605     PFS_INFORMATION_CLASS FsInformationClass;
02606     SECURITY_INFORMATION SecurityInformation;
02607     ACCESS_MASK DesiredAccess;
02608 
02609     UNREFERENCED_PARAMETER( MinorFunction );
02610 
02611     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02612 
02613     <span class="comment">//</span>
02614     <span class="comment">// Determine the major function being performed.  If the function code</span>
02615     <span class="comment">// is invalid, then return an error.</span>
02616     <span class="comment">//</span>
02617 
02618     FileInformationClass = (PFILE_INFORMATION_CLASS)Arg1;
02619     FsInformationClass = (PFS_INFORMATION_CLASS)Arg2;
02620 
02621     <span class="keywordflow">switch</span>( MajorFunction ) {
02622 
02623     <span class="keywordflow">case</span> <a class="code" href="../../d0/d5/io_8h.html#a13">IRP_MJ_CREATE</a>:
02624     <span class="keywordflow">case</span> <a class="code" href="../../d0/d5/io_8h.html#a15">IRP_MJ_CLOSE</a>:
02625 
02626         <span class="keywordflow">break</span>;
02627 
02628     <span class="keywordflow">case</span> <a class="code" href="../../d0/d5/io_8h.html#a16">IRP_MJ_READ</a>:
02629 
02630         <span class="keywordflow">if</span> (<a class="code" href="../../d0/d5/se_8h.html#a8">SeComputeDeniedAccesses</a>( GrantedAccess, FILE_READ_DATA )) {
02631             status = STATUS_ACCESS_DENIED;
02632         }
02633         <span class="keywordflow">break</span>;
02634 
02635     <span class="keywordflow">case</span> <a class="code" href="../../d0/d5/io_8h.html#a17">IRP_MJ_WRITE</a>:
02636 
02637         <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d5/se_8h.html#a9">SeComputeGrantedAccesses</a>( GrantedAccess, FILE_WRITE_DATA | FILE_APPEND_DATA )) {
02638             status = STATUS_ACCESS_DENIED;
02639         }
02640         <span class="keywordflow">break</span>;
02641 
02642     <span class="keywordflow">case</span> <a class="code" href="../../d0/d5/io_8h.html#a18">IRP_MJ_QUERY_INFORMATION</a>:
02643 
02644         <span class="keywordflow">if</span> (<a class="code" href="../../d3/d5/iodata_8c.html#a66">IopQueryOperationAccess</a>[*FileInformationClass] != 0) {
02645             <span class="keywordflow">if</span> (<a class="code" href="../../d0/d5/se_8h.html#a8">SeComputeDeniedAccesses</a>( GrantedAccess, <a class="code" href="../../d3/d5/iodata_8c.html#a66">IopQueryOperationAccess</a>[*FileInformationClass] )) {
02646                 status = STATUS_ACCESS_DENIED;
02647             }
02648         }
02649         <span class="keywordflow">break</span>;
02650 
02651     <span class="keywordflow">case</span> <a class="code" href="../../d0/d5/io_8h.html#a19">IRP_MJ_SET_INFORMATION</a>:
02652 
02653         <span class="keywordflow">if</span> (<a class="code" href="../../d3/d5/iodata_8c.html#a67">IopSetOperationAccess</a>[*FileInformationClass] != 0) {
02654             <span class="keywordflow">if</span> (<a class="code" href="../../d0/d5/se_8h.html#a8">SeComputeDeniedAccesses</a>( GrantedAccess, <a class="code" href="../../d3/d5/iodata_8c.html#a67">IopSetOperationAccess</a>[*FileInformationClass] )) {
02655                 status = STATUS_ACCESS_DENIED;
02656             }
02657         }
02658         <span class="keywordflow">break</span>;
02659 
02660     <span class="keywordflow">case</span> <a class="code" href="../../d0/d5/io_8h.html#a20">IRP_MJ_QUERY_EA</a>:
02661 
02662         <span class="keywordflow">if</span> (<a class="code" href="../../d0/d5/se_8h.html#a8">SeComputeDeniedAccesses</a>( GrantedAccess, FILE_READ_EA )) {
02663             status = STATUS_ACCESS_DENIED;
02664         }
02665         <span class="keywordflow">break</span>;
02666 
02667     <span class="keywordflow">case</span> <a class="code" href="../../d0/d5/io_8h.html#a21">IRP_MJ_SET_EA</a>:
02668 
02669         <span class="keywordflow">if</span> (<a class="code" href="../../d0/d5/se_8h.html#a8">SeComputeDeniedAccesses</a>( GrantedAccess, FILE_WRITE_EA )) {
02670             status = STATUS_ACCESS_DENIED;
02671         }
02672         <span class="keywordflow">break</span>;
02673 
02674     <span class="keywordflow">case</span> <a class="code" href="../../d0/d5/io_8h.html#a22">IRP_MJ_FLUSH_BUFFERS</a>:
02675 
02676         <span class="keywordflow">if</span> (<a class="code" href="../../d0/d5/se_8h.html#a8">SeComputeDeniedAccesses</a>( GrantedAccess, FILE_WRITE_DATA )) {
02677             status = STATUS_ACCESS_DENIED;
02678         }
02679         <span class="keywordflow">break</span>;
02680 
02681     <span class="keywordflow">case</span> <a class="code" href="../../d0/d5/io_8h.html#a23">IRP_MJ_QUERY_VOLUME_INFORMATION</a>:
02682 
02683         <span class="keywordflow">if</span> (<a class="code" href="../../d0/d5/se_8h.html#a8">SeComputeDeniedAccesses</a>( GrantedAccess, <a class="code" href="../../d3/d5/iodata_8c.html#a70">IopQueryFsOperationAccess</a>[*FsInformationClass] )) {
02684             status = STATUS_ACCESS_DENIED;
02685         }
02686         <span class="keywordflow">break</span>;
02687 
02688     <span class="keywordflow">case</span> <a class="code" href="../../d0/d5/io_8h.html#a24">IRP_MJ_SET_VOLUME_INFORMATION</a>:
02689 
02690         <span class="keywordflow">if</span> (<a class="code" href="../../d0/d5/se_8h.html#a8">SeComputeDeniedAccesses</a>( GrantedAccess, <a class="code" href="../../d3/d5/iodata_8c.html#a71">IopSetFsOperationAccess</a>[*FsInformationClass] )) {
02691             status = STATUS_ACCESS_DENIED;
02692         }
02693         <span class="keywordflow">break</span>;
02694 
02695     <span class="keywordflow">case</span> <a class="code" href="../../d0/d5/io_8h.html#a25">IRP_MJ_DIRECTORY_CONTROL</a>:
02696 
02697         <span class="keywordflow">if</span> (<a class="code" href="../../d0/d5/se_8h.html#a8">SeComputeDeniedAccesses</a>( GrantedAccess, FILE_LIST_DIRECTORY )) {
02698             status = STATUS_ACCESS_DENIED;
02699         }
02700         <span class="keywordflow">break</span>;
02701 
02702     <span class="keywordflow">case</span> <a class="code" href="../../d0/d5/io_8h.html#a26">IRP_MJ_FILE_SYSTEM_CONTROL</a>:
02703     <span class="keywordflow">case</span> <a class="code" href="../../d0/d5/io_8h.html#a27">IRP_MJ_DEVICE_CONTROL</a>:
02704     <span class="keywordflow">case</span> <a class="code" href="../../d0/d5/io_8h.html#a28">IRP_MJ_INTERNAL_DEVICE_CONTROL</a>:
02705 
02706         {
02707             ULONG accessMode = (IoControlCode &gt;&gt; 14) &amp; 3;
02708 
02709             <span class="keywordflow">if</span> (accessMode != FILE_ANY_ACCESS) {
02710 
02711                 <span class="comment">//</span>
02712                 <span class="comment">// This I/O control requires that the caller have read, write,</span>
02713                 <span class="comment">// or read/write access to the object.  If this is not the case,</span>
02714                 <span class="comment">// then cleanup and return an appropriate error status code.</span>
02715                 <span class="comment">//</span>
02716 
02717                 <span class="keywordflow">if</span> (!(<a class="code" href="../../d0/d5/se_8h.html#a9">SeComputeGrantedAccesses</a>( GrantedAccess, accessMode ))) {
02718                     status = STATUS_ACCESS_DENIED;
02719                 }
02720             }
02721 
02722         }
02723         <span class="keywordflow">break</span>;
02724 
02725     <span class="keywordflow">case</span> <a class="code" href="../../d0/d5/io_8h.html#a30">IRP_MJ_LOCK_CONTROL</a>:
02726 
02727         <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d5/se_8h.html#a9">SeComputeGrantedAccesses</a>( GrantedAccess, FILE_READ_DATA | FILE_WRITE_DATA )) {
02728             status = STATUS_ACCESS_DENIED;
02729         }
02730         <span class="keywordflow">break</span>;
02731 
02732     <span class="keywordflow">case</span> <a class="code" href="../../d0/d5/io_8h.html#a34">IRP_MJ_SET_SECURITY</a>:
02733 
02734         SecurityInformation = *((PSECURITY_INFORMATION)Arg1);
02735         <a class="code" href="../../d0/d6/semethod_8c.html#a1">SeSetSecurityAccessMask</a>(SecurityInformation, &amp;DesiredAccess);
02736 
02737         <span class="keywordflow">if</span> (<a class="code" href="../../d0/d5/se_8h.html#a8">SeComputeDeniedAccesses</a>( GrantedAccess, DesiredAccess )) {
02738             status = STATUS_ACCESS_DENIED;
02739         }
02740         <span class="keywordflow">break</span>;
02741 
02742     <span class="keywordflow">case</span> <a class="code" href="../../d0/d5/io_8h.html#a33">IRP_MJ_QUERY_SECURITY</a>:
02743 
02744         SecurityInformation = *((PSECURITY_INFORMATION)Arg1);
02745         <a class="code" href="../../d0/d6/semethod_8c.html#a2">SeQuerySecurityAccessMask</a>(SecurityInformation, &amp;DesiredAccess);
02746 
02747         <span class="keywordflow">if</span> (<a class="code" href="../../d0/d5/se_8h.html#a8">SeComputeDeniedAccesses</a>( GrantedAccess, DesiredAccess )) {
02748             status = STATUS_ACCESS_DENIED;
02749         }
02750         <span class="keywordflow">break</span>;
02751     <span class="keywordflow">default</span>:
02752 
02753         status = STATUS_INVALID_DEVICE_REQUEST;
02754     }
02755     <span class="keywordflow">return</span> status;
02756 }
02757 
02758 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
02759 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l02760"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a35">02760</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a35">IoCheckQuerySetFileInformation</a>(
02761     IN FILE_INFORMATION_CLASS FileInformationClass,
02762     IN ULONG Length,
02763     IN BOOLEAN SetOperation
02764     )
02765 
02766 <span class="comment">/*++</span>
02767 <span class="comment"></span>
02768 <span class="comment">Routine Description:</span>
02769 <span class="comment"></span>
02770 <span class="comment">    This routine checks the validity of the parameters for either a query or a</span>
02771 <span class="comment">    set file information operation.  It is used primarily by network servers</span>
02772 <span class="comment">    running in kernel mode since no such parameter validity checking is done</span>
02773 <span class="comment">    in the normal path.</span>
02774 <span class="comment"></span>
02775 <span class="comment">Arguments:</span>
02776 <span class="comment"></span>
02777 <span class="comment">    FileInformationClass - Specifies the information class to check checked.</span>
02778 <span class="comment"></span>
02779 <span class="comment">    Length - Specifies the length of the buffer supplied.</span>
02780 <span class="comment"></span>
02781 <span class="comment">    SetOperation - Specifies that the operation was a set file information as</span>
02782 <span class="comment">        opposed to a query operation.</span>
02783 <span class="comment"></span>
02784 <span class="comment">Return Value:</span>
02785 <span class="comment"></span>
02786 <span class="comment">    The function value is STATUS_SUCCESS if the parameters were valid,</span>
02787 <span class="comment">    otherwise an appropriate error is returned.</span>
02788 <span class="comment"></span>
02789 <span class="comment">--*/</span>
02790 
02791 {
02792     PCHAR operationLength;
02793 
02794     <span class="comment">//</span>
02795     <span class="comment">// The file information class itself must be w/in the valid range of file</span>
02796     <span class="comment">// information classes, otherwise this is an invalid information class.</span>
02797     <span class="comment">//</span>
02798 
02799     <span class="keywordflow">if</span> ((ULONG) FileInformationClass &gt;= FileMaximumInformation) {
02800         <span class="keywordflow">return</span> STATUS_INVALID_INFO_CLASS;
02801     }
02802 
02803     <span class="comment">//</span>
02804     <span class="comment">// Determine whether this is a query or a set operation and act accordingly.</span>
02805     <span class="comment">//</span>
02806 
02807     operationLength = SetOperation ? <a class="code" href="../../d3/d5/iodata_8c.html#a64">IopSetOperationLength</a> : <a class="code" href="../../d3/d5/iodata_8c.html#a63">IopQueryOperationLength</a>;
02808 
02809     <span class="keywordflow">if</span> (!operationLength[FileInformationClass]) {
02810         <span class="keywordflow">return</span> STATUS_INVALID_INFO_CLASS;
02811     }
02812     <span class="keywordflow">if</span> (Length &lt; (ULONG) operationLength[FileInformationClass]) {
02813         <span class="keywordflow">return</span> STATUS_INFO_LENGTH_MISMATCH;
02814     }
02815 
02816     <span class="keywordflow">return</span> STATUS_SUCCESS;
02817 }
02818 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
02819 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l02820"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a36">02820</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a36">IoCheckQuerySetVolumeInformation</a>(
02821     IN FS_INFORMATION_CLASS FsInformationClass,
02822     IN ULONG Length,
02823     IN BOOLEAN SetOperation
02824     )
02825 
02826 <span class="comment">/*++</span>
02827 <span class="comment"></span>
02828 <span class="comment">Routine Description:</span>
02829 <span class="comment"></span>
02830 <span class="comment">    This routine checks the validity of the parameters for either a query or a</span>
02831 <span class="comment">    set volume information operation.  It is used primarily by network servers</span>
02832 <span class="comment">    running in kernel mode since no such parameter validity checking is done</span>
02833 <span class="comment">    in the normal path.</span>
02834 <span class="comment"></span>
02835 <span class="comment">Arguments:</span>
02836 <span class="comment"></span>
02837 <span class="comment">    FsInformationClass - Specifies the information class to check.</span>
02838 <span class="comment"></span>
02839 <span class="comment">    Length - Specifies the length of the buffer supplied.</span>
02840 <span class="comment"></span>
02841 <span class="comment">    SetOperation - Specifies that the operation was a set volume information as</span>
02842 <span class="comment">        opposed to a query operation.</span>
02843 <span class="comment"></span>
02844 <span class="comment">Return Value:</span>
02845 <span class="comment"></span>
02846 <span class="comment">    The function value is STATUS_SUCCESS if the parameters were valid,</span>
02847 <span class="comment">    otherwise an appropriate error is returned.</span>
02848 <span class="comment"></span>
02849 <span class="comment">--*/</span>
02850 
02851 {
02852     PCHAR operationLength;
02853 
02854     operationLength = SetOperation ? <a class="code" href="../../d3/d5/iodata_8c.html#a69">IopSetFsOperationLength</a> : <a class="code" href="../../d3/d5/iodata_8c.html#a68">IopQueryFsOperationLength</a>;
02855 
02856     <span class="comment">//</span>
02857     <span class="comment">// The volume information class itself must be w/in the valid range of file</span>
02858     <span class="comment">// information classes, otherwise this is an invalid information class.</span>
02859     <span class="comment">//</span>
02860     <span class="keywordflow">if</span> ((ULONG) FsInformationClass &gt;= FileFsMaximumInformation ||
02861         operationLength[ FsInformationClass ] == 0 ) {
02862 
02863         <span class="keywordflow">return</span> STATUS_INVALID_INFO_CLASS;
02864     }
02865 
02866     <span class="keywordflow">if</span> (Length &lt; (ULONG) operationLength[FsInformationClass]) {
02867         <span class="keywordflow">return</span> STATUS_INFO_LENGTH_MISMATCH;
02868     }
02869 
02870     <span class="keywordflow">return</span> STATUS_SUCCESS;
02871 }
02872 
02873 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l02874"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a37">02874</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a37">IoCheckQuotaBufferValidity</a>(
02875     IN PFILE_QUOTA_INFORMATION QuotaBuffer,
02876     IN ULONG QuotaLength,
02877     OUT PULONG ErrorOffset
02878     )
02879 
02880 <span class="comment">/*++</span>
02881 <span class="comment"></span>
02882 <span class="comment">Routine Description:</span>
02883 <span class="comment"></span>
02884 <span class="comment">    This routine checks the validity of the specified quota buffer to guarantee</span>
02885 <span class="comment">    that its format is proper, no fields hang over, that it is not recursive,</span>
02886 <span class="comment">    etc.</span>
02887 <span class="comment"></span>
02888 <span class="comment">Arguments:</span>
02889 <span class="comment"></span>
02890 <span class="comment">    QuotaBuffer - Pointer to the buffer containing the quota entries to be</span>
02891 <span class="comment">        checked.</span>
02892 <span class="comment"></span>
02893 <span class="comment">    QuotaLength - Specifies the length of the QuotaBuffer.</span>
02894 <span class="comment"></span>
02895 <span class="comment">    ErrorOffset - A variable to receive the offset of the offending entry in</span>
02896 <span class="comment">        the quota buffer if an error is incurred.  This variable is only valid</span>
02897 <span class="comment">        if an error occurs.</span>
02898 <span class="comment"></span>
02899 <span class="comment">Return Value:</span>
02900 <span class="comment"></span>
02901 <span class="comment">    The function value is STATUS_SUCCESS if the quota buffer contains a valid,</span>
02902 <span class="comment">    properly formed list, otherwise STATUS_QUOTA_LIST_INCONSISTENT.</span>
02903 <span class="comment"></span>
02904 <span class="comment">--*/</span>
02905 
02906 #<span class="keywordflow">if</span> defined(_X86_)
02907 #define <a class="code" href="../../d4/d6/iosubs_8c.html#a2">REQUIRED_QUOTA_ALIGNMENT</a> <span class="keyword">sizeof</span>( ULONG )
02908 <span class="preprocessor">#else</span>
02909 <span class="preprocessor"></span><span class="preprocessor">#define REQUIRED_QUOTA_ALIGNMENT sizeof( ULONGLONG )</span>
02910 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
02911 <span class="preprocessor"></span>
02912 <span class="preprocessor">#define ALIGN_QUAD( Address ) ( (ULONG) ((Address + 7) &amp; ~7) )</span>
02913 <span class="preprocessor"></span>
02914 <span class="preprocessor">#define GET_OFFSET_LENGTH( CurrentEntry, QuotaBase ) (\</span>
02915 <span class="preprocessor">    (ULONG) ((PCHAR) CurrentEntry - (PCHAR) QuotaBase) )</span>
02916 <span class="preprocessor"></span>
02917 {
02918     LONG tempLength;
02919     ULONG entrySize;
02920     PFILE_QUOTA_INFORMATION quotas;
02921 
02922     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
02923 
02924     <span class="comment">//</span>
02925     <span class="comment">// Walk the buffer and ensure that its format is valid.  That is, ensure</span>
02926     <span class="comment">// that it does not walk off the end of the buffer, is not recursive,</span>
02927     <span class="comment">// etc.</span>
02928     <span class="comment">//</span>
02929 
02930     quotas = QuotaBuffer;
02931     tempLength = QuotaLength;
02932 
02933     <span class="comment">//</span>
02934     <span class="comment">// Ensure the buffer has the correct alignment.</span>
02935     <span class="comment">//</span>
02936 
02937     <span class="keywordflow">if</span> ((ULONG_PTR) quotas &amp; (<a class="code" href="../../d4/d6/iosubs_8c.html#a2">REQUIRED_QUOTA_ALIGNMENT</a> - 1)) {
02938         *ErrorOffset = 0;
02939         <span class="keywordflow">return</span> STATUS_DATATYPE_MISALIGNMENT;
02940     }
02941 
02942     <span class="keywordflow">for</span> (;;) {
02943 
02944         ULONG sidLength;
02945 
02946         <span class="comment">//</span>
02947         <span class="comment">// Get the size of the current entry in the buffer.  The minimum size</span>
02948         <span class="comment">// of the entry is the fixed size part of the structure plus the actual</span>
02949         <span class="comment">// length of the SID.  If this is not the last entry, then there will</span>
02950         <span class="comment">// also be pad bytes to get to the next longword boundary.  Likewise,</span>
02951         <span class="comment">// ensure that the SID itself is valid.</span>
02952         <span class="comment">//</span>
02953 
02954         <span class="keywordflow">if</span> (tempLength &lt; FIELD_OFFSET( FILE_QUOTA_INFORMATION, Sid ) ||
02955             !<a class="code" href="../../d8/d6/sertl_8c.html#a35">RtlValidSid</a>( &amp;quotas-&gt;Sid )) {
02956             <span class="keywordflow">goto</span> error_exit;
02957         }
02958 
02959         sidLength = <a class="code" href="../../d8/d6/sertl_8c.html#a45">RtlLengthSid</a>( (&amp;quotas-&gt;Sid) );
02960         entrySize = FIELD_OFFSET( FILE_QUOTA_INFORMATION, Sid ) + sidLength;
02961 
02962         <span class="comment">//</span>
02963         <span class="comment">// Confirm that the full length lies within the stated buffer length.</span>
02964         <span class="comment">//</span>
02965 
02966         <span class="keywordflow">if</span> ((ULONG) tempLength &lt; entrySize ||
02967             quotas-&gt;SidLength != sidLength) {
02968             <span class="keywordflow">goto</span> error_exit;
02969         }
02970 
02971         <span class="keywordflow">if</span> (quotas-&gt;NextEntryOffset) {
02972 
02973             <span class="comment">//</span>
02974             <span class="comment">// There is another entry in the buffer and it must be longword</span>
02975             <span class="comment">// aligned.  Ensure that the offset indicates that it is.  If it</span>
02976             <span class="comment">// is not, return error status code.</span>
02977             <span class="comment">//</span>
02978 
02979             <span class="keywordflow">if</span> (entrySize &gt; quotas-&gt;NextEntryOffset ||
02980                 quotas-&gt;NextEntryOffset &amp; (<a class="code" href="../../d4/d6/iosubs_8c.html#a2">REQUIRED_QUOTA_ALIGNMENT</a> - 1) ||
02981                 (LONG) quotas-&gt;NextEntryOffset &lt; 0) {
02982                 <span class="keywordflow">goto</span> error_exit;
02983 
02984             } <span class="keywordflow">else</span> {
02985 
02986                 <span class="comment">//</span>
02987                 <span class="comment">// There is another entry in the buffer, so account for the size</span>
02988                 <span class="comment">// of the current entry in the length and get a pointer to the</span>
02989                 <span class="comment">// next entry.</span>
02990                 <span class="comment">//</span>
02991 
02992                 tempLength -= quotas-&gt;NextEntryOffset;
02993                 <span class="keywordflow">if</span> (tempLength &lt; 0) {
02994                     <span class="keywordflow">goto</span> error_exit;
02995                 }
02996                 quotas = (PFILE_QUOTA_INFORMATION) ((PCHAR) quotas + quotas-&gt;NextEntryOffset);
02997             }
02998 
02999         } <span class="keywordflow">else</span> {
03000 
03001             <span class="comment">//</span>
03002             <span class="comment">// There are no more entries in the buffer.  Simply account for the</span>
03003             <span class="comment">// overall buffer length according to the size of the current</span>
03004             <span class="comment">// entry and exit the loop.</span>
03005             <span class="comment">//</span>
03006 
03007             tempLength -= entrySize;
03008             <span class="keywordflow">break</span>;
03009         }
03010     }
03011 
03012     <span class="comment">//</span>
03013     <span class="comment">// All of the entries in the buffer have been processed.  Check to see</span>
03014     <span class="comment">// whether the overall buffer length went negative.  If so, return an</span>
03015     <span class="comment">// error.</span>
03016     <span class="comment">//</span>
03017 
03018     <span class="keywordflow">if</span> (tempLength &lt; 0) {
03019         <span class="keywordflow">goto</span> error_exit;
03020     }
03021 
03022     <span class="keywordflow">return</span> STATUS_SUCCESS;
03023 
03024 error_exit:
03025 
03026     *ErrorOffset = <a class="code" href="../../d2/d4/internal_8c.html#a1">GET_OFFSET_LENGTH</a>( quotas, QuotaBuffer );
03027     <span class="keywordflow">return</span> STATUS_QUOTA_LIST_INCONSISTENT;
03028 
03029 }
03030 
03031 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l03032"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a38">03032</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a38">IoCheckShareAccess</a>(
03033     IN ACCESS_MASK DesiredAccess,
03034     IN ULONG DesiredShareAccess,
03035     IN OUT <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
03036     IN OUT <a class="code" href="../../d9/d2/struct__SHARE__ACCESS.html">PSHARE_ACCESS</a> ShareAccess,
03037     IN BOOLEAN Update
03038     )
03039 
03040 <span class="comment">/*++</span>
03041 <span class="comment"></span>
03042 <span class="comment">Routine Description:</span>
03043 <span class="comment"></span>
03044 <span class="comment">    This routine is invoked to determine whether or not a new accessor to</span>
03045 <span class="comment">    a file actually has shared access to it.  The check is made according</span>
03046 <span class="comment">    to:</span>
03047 <span class="comment"></span>
03048 <span class="comment">        1)  How the file is currently opened.</span>
03049 <span class="comment"></span>
03050 <span class="comment">        2)  What types of shared accesses are currently specified.</span>
03051 <span class="comment"></span>
03052 <span class="comment">        3)  The desired and shared accesses that the new open is requesting.</span>
03053 <span class="comment"></span>
03054 <span class="comment">    If the open should succeed, then the access information about how the</span>
03055 <span class="comment">    file is currently opened is updated, according to the Update parameter.</span>
03056 <span class="comment"></span>
03057 <span class="comment">Arguments:</span>
03058 <span class="comment"></span>
03059 <span class="comment">    DesiredAccess - Desired access of current open request.</span>
03060 <span class="comment"></span>
03061 <span class="comment">    DesiredShareAccess - Shared access requested by current open request.</span>
03062 <span class="comment"></span>
03063 <span class="comment">    FileObject - Pointer to the file object of the current open request.</span>
03064 <span class="comment"></span>
03065 <span class="comment">    ShareAccess - Pointer to the share access structure that describes how</span>
03066 <span class="comment">        the file is currently being accessed.</span>
03067 <span class="comment"></span>
03068 <span class="comment">    Update - Specifies whether or not the share access information for the</span>
03069 <span class="comment">        file is to be updated.</span>
03070 <span class="comment"></span>
03071 <span class="comment">Return Value:</span>
03072 <span class="comment"></span>
03073 <span class="comment">    The final status of the access check is the function value.  If the</span>
03074 <span class="comment">    accessor has access to the file, STATUS_SUCCESS is returned.  Otherwise,</span>
03075 <span class="comment">    STATUS_SHARING_VIOLATION is returned.</span>
03076 <span class="comment"></span>
03077 <span class="comment">Note:</span>
03078 <span class="comment"></span>
03079 <span class="comment">    Note that the ShareAccess parameter must be locked against other accesses</span>
03080 <span class="comment">    from other threads while this routine is executing.  Otherwise the counts</span>
03081 <span class="comment">    will be out-of-synch.</span>
03082 <span class="comment"></span>
03083 <span class="comment">--*/</span>
03084 
03085 {
03086     ULONG ocount;
03087 
03088     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
03089 
03090     <span class="comment">//</span>
03091     <span class="comment">// Set the access type in the file object for the current accessor.</span>
03092     <span class="comment">// Note that reading and writing attributes are not included in the</span>
03093     <span class="comment">// access check.</span>
03094     <span class="comment">//</span>
03095 
03096     FileObject-&gt;ReadAccess = (BOOLEAN) ((DesiredAccess &amp; (FILE_EXECUTE
03097         | FILE_READ_DATA)) != 0);
03098     FileObject-&gt;WriteAccess = (BOOLEAN) ((DesiredAccess &amp; (FILE_WRITE_DATA
03099         | FILE_APPEND_DATA)) != 0);
03100     FileObject-&gt;DeleteAccess = (BOOLEAN) ((DesiredAccess &amp; DELETE) != 0);
03101 
03102     <span class="comment">//</span>
03103     <span class="comment">// There is no more work to do unless the user specified one of the</span>
03104     <span class="comment">// sharing modes above.</span>
03105     <span class="comment">//</span>
03106 
03107     <span class="keywordflow">if</span> (FileObject-&gt;ReadAccess ||
03108         FileObject-&gt;WriteAccess ||
03109         FileObject-&gt;DeleteAccess) {
03110 
03111         FileObject-&gt;SharedRead = (BOOLEAN) ((DesiredShareAccess &amp; FILE_SHARE_READ) != 0);
03112         FileObject-&gt;SharedWrite = (BOOLEAN) ((DesiredShareAccess &amp; FILE_SHARE_WRITE) != 0);
03113         FileObject-&gt;SharedDelete = (BOOLEAN) ((DesiredShareAccess &amp; FILE_SHARE_DELETE) != 0);
03114 
03115         <span class="comment">//</span>
03116         <span class="comment">// Now check to see whether or not the desired accesses are compatible</span>
03117         <span class="comment">// with the way that the file is currently open.</span>
03118         <span class="comment">//</span>
03119 
03120         ocount = ShareAccess-&gt;OpenCount;
03121 
03122         <span class="keywordflow">if</span> ( (FileObject-&gt;ReadAccess &amp;&amp; (ShareAccess-&gt;SharedRead &lt; ocount))
03123              ||
03124              (FileObject-&gt;WriteAccess &amp;&amp; (ShareAccess-&gt;SharedWrite &lt; ocount))
03125              ||
03126              (FileObject-&gt;DeleteAccess &amp;&amp; (ShareAccess-&gt;SharedDelete &lt; ocount))
03127              ||
03128              ((ShareAccess-&gt;Readers != 0) &amp;&amp; !FileObject-&gt;SharedRead)
03129              ||
03130              ((ShareAccess-&gt;Writers != 0) &amp;&amp; !FileObject-&gt;SharedWrite)
03131              ||
03132              ((ShareAccess-&gt;Deleters != 0) &amp;&amp; !FileObject-&gt;SharedDelete)
03133            ) {
03134 
03135             <span class="comment">//</span>
03136             <span class="comment">// The check failed.  Simply return to the caller indicating that the</span>
03137             <span class="comment">// current open cannot access the file.</span>
03138             <span class="comment">//</span>
03139 
03140             <span class="keywordflow">return</span> STATUS_SHARING_VIOLATION;
03141 
03142         <span class="comment">//</span>
03143         <span class="comment">// The check was successful.  Update the counter information in the</span>
03144         <span class="comment">// shared access structure for this open request if the caller</span>
03145         <span class="comment">// specified that it should be updated.</span>
03146         <span class="comment">//</span>
03147 
03148         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Update) {
03149 
03150             ShareAccess-&gt;OpenCount++;
03151 
03152             ShareAccess-&gt;Readers += FileObject-&gt;ReadAccess;
03153             ShareAccess-&gt;Writers += FileObject-&gt;WriteAccess;
03154             ShareAccess-&gt;Deleters += FileObject-&gt;DeleteAccess;
03155 
03156             ShareAccess-&gt;SharedRead += FileObject-&gt;SharedRead;
03157             ShareAccess-&gt;SharedWrite += FileObject-&gt;SharedWrite;
03158             ShareAccess-&gt;SharedDelete += FileObject-&gt;SharedDelete;
03159         }
03160     }
03161     <span class="keywordflow">return</span> STATUS_SUCCESS;
03162 }
03163 
03164 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
03165 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l03166"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a39">03166</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a39">IofCompleteRequest</a>(
03167     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
03168     IN CCHAR PriorityBoost
03169     )
03170 {
03171     <span class="comment">//</span>
03172     <span class="comment">// This routine will either jump immediately to IopfCompleteRequest, or</span>
03173     <span class="comment">// rather IovCompleteRequest.</span>
03174     <span class="comment">//</span>
03175     <a class="code" href="../../d0/d6/iop_8h.html#a134">pIofCompleteRequest</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, <a class="code" href="../../d0/d6/iop_8h.html#a36">PriorityBoost</a>);
03176 }
03177 
03178 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
03179 <a class="code" href="../../d0/d0/client_2nt6_2user_8h.html#a0">FASTCALL</a>
<a name="l03180"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a40">03180</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a40">IopfCompleteRequest</a>(
03181     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
03182     IN CCHAR PriorityBoost
03183     )
03184 
03185 <span class="comment">/*++</span>
03186 <span class="comment"></span>
03187 <span class="comment">Routine Description:</span>
03188 <span class="comment"></span>
03189 <span class="comment">    This routine is invoked to complete an I/O request.  It is invoked by the</span>
03190 <span class="comment">    driver in its DPC routine to perform the final completion of the IRP.  The</span>
03191 <span class="comment">    functions performed by this routine are as follows.</span>
03192 <span class="comment"></span>
03193 <span class="comment">        1.  A check is made to determine whether the packet's stack locations</span>
03194 <span class="comment">            have been exhausted.  If not, then the stack location pointer is set</span>
03195 <span class="comment">            to the next location and if there is a routine to be invoked, then</span>
03196 <span class="comment">            it will be invoked.  This continues until there are either no more</span>
03197 <span class="comment">            routines which are interested or the packet runs out of stack.</span>
03198 <span class="comment"></span>
03199 <span class="comment">            If a routine is invoked to complete the packet for a specific driver</span>
03200 <span class="comment">            which needs to perform work a lot of work or the work needs to be</span>
03201 <span class="comment">            performed in the context of another process, then the routine will</span>
03202 <span class="comment">            return an alternate success code of STATUS_MORE_PROCESSING_REQUIRED.</span>
03203 <span class="comment">            This indicates that this completion routine should simply return to</span>
03204 <span class="comment">            its caller because the operation will be "completed" by this routine</span>
03205 <span class="comment">            again sometime in the future.</span>
03206 <span class="comment"></span>
03207 <span class="comment">        2.  A check is made to determine whether this IRP is an associated IRP.</span>
03208 <span class="comment">            If it is, then the count on the master IRP is decremented.  If the</span>
03209 <span class="comment">            count for the master becomes zero, then the master IRP will be</span>
03210 <span class="comment">            completed according to the steps below taken for a normal IRP being</span>
03211 <span class="comment">            completed.  If the count is still non-zero, then this IRP (the one</span>
03212 <span class="comment">            being completed) will simply be deallocated.</span>
03213 <span class="comment"></span>
03214 <span class="comment">        3.  If this is paging I/O or a close operation, then simply write the</span>
03215 <span class="comment">            I/O status block and set the event to the signaled state, and</span>
03216 <span class="comment">            dereference the event.  If this is paging I/O, deallocate the IRP</span>
03217 <span class="comment">            as well.</span>
03218 <span class="comment"></span>
03219 <span class="comment">        4.  Unlock the pages, if any, specified by the MDL by calling</span>
03220 <span class="comment">            MmUnlockPages.</span>
03221 <span class="comment"></span>
03222 <span class="comment">        5.  A check is made to determine whether or not completion of the</span>
03223 <span class="comment">            request can be deferred until later.  If it can be, then this</span>
03224 <span class="comment">            routine simply exits and leaves it up to the originator of the</span>
03225 <span class="comment">            request to fully complete the IRP.  By not initializing and queueing</span>
03226 <span class="comment">            the special kernel APC to the calling thread (which is the current</span>
03227 <span class="comment">            thread by definition), a lot of interrupt and queueing processing</span>
03228 <span class="comment">            can be avoided.</span>
03229 <span class="comment"></span>
03230 <span class="comment"></span>
03231 <span class="comment">        6.  The final rundown routine is invoked to queue the request packet to</span>
03232 <span class="comment">            the target (requesting) thread as a special kernel mode APC.</span>
03233 <span class="comment"></span>
03234 <span class="comment">Arguments:</span>
03235 <span class="comment"></span>
03236 <span class="comment">    Irp - Pointer to the I/O Request Packet to complete.</span>
03237 <span class="comment"></span>
03238 <span class="comment">    PriorityBoost - Supplies the amount of priority boost that is to be given</span>
03239 <span class="comment">        to the target thread when the special kernel APC is queued.</span>
03240 <span class="comment"></span>
03241 <span class="comment">Return Value:</span>
03242 <span class="comment"></span>
03243 <span class="comment">    None.</span>
03244 <span class="comment"></span>
03245 <span class="comment">--*/</span>
03246 
03247 #define <a class="code" href="../../d4/d6/iosubs_8c.html#a5">ZeroIrpStackLocation</a>( IrpSp ) {         \
03248     (IrpSp)-&gt;MinorFunction = 0;                 \
03249     (IrpSp)-&gt;Flags = 0;                         \
03250     (IrpSp)-&gt;Control = 0 ;                      \
03251     (IrpSp)-&gt;Parameters.Others.Argument1 = 0;   \
03252     (IrpSp)-&gt;Parameters.Others.Argument2 = 0;   \
03253     (IrpSp)-&gt;Parameters.Others.Argument3 = 0;   \
03254     (IrpSp)-&gt;Parameters.Others.Argument4 = 0;   \
03255     (IrpSp)-&gt;FileObject = (<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>; }
03256 
03257 {
03258     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> masterIrp;
03259     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
03260     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> stackPointer;
03261     <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> mdl;
03262     <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a> thread;
03263     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> fileObject;
03264     KIRQL irql;
03265     PVOID saveAuxiliaryPointer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03266 
03267     <span class="comment">//</span>
03268     <span class="comment">// Begin by ensuring that this packet has not already been completed</span>
03269     <span class="comment">// by someone.</span>
03270     <span class="comment">//</span>
03271 
03272     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a> &gt; (CCHAR) (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o12">StackCount</a> + 1) ||
03273         <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o0">Type</a> != <a class="code" href="../../d0/d5/io_8h.html#a5">IO_TYPE_IRP</a>) {
03274         <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a>( MULTIPLE_IRP_COMPLETE_REQUESTS, (ULONG_PTR) Irp, __LINE__, 0, 0 );
03275     }
03276 
03277     <span class="comment">//</span>
03278     <span class="comment">// Ensure that the packet being completed really is still an IRP.</span>
03279     <span class="comment">//</span>
03280 
03281     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o0">Type</a> == IO_TYPE_IRP );
03282 
03283     <span class="comment">//</span>
03284     <span class="comment">// Ensure that no one believes that this request is still in a cancelable</span>
03285     <span class="comment">// state.</span>
03286     <span class="comment">//</span>
03287 
03288     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( !<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o25">CancelRoutine</a> );
03289 
03290     <span class="comment">//</span>
03291     <span class="comment">// Ensure that the packet is not being completed with a thoroughly</span>
03292     <span class="comment">// confusing status code.  Actually completing a packet with a pending</span>
03293     <span class="comment">// status probably means that someone forgot to set the real status in</span>
03294     <span class="comment">// the packet.</span>
03295     <span class="comment">//</span>
03296 
03297     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status != STATUS_PENDING );
03298 
03299     <span class="comment">//</span>
03300     <span class="comment">// Ensure that the packet is not being completed with a minus one.  This</span>
03301     <span class="comment">// is apparently a common problem in some drivers, and has no meaning</span>
03302     <span class="comment">// as a status code.</span>
03303     <span class="comment">//</span>
03304 
03305     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status != 0xffffffff );
03306 
03307     <span class="comment">//</span>
03308     <span class="comment">// Ensure that if this is a paging I/O operation, and it failed, that the</span>
03309     <span class="comment">// reason for the failure isn't because quota was exceeded.</span>
03310     <span class="comment">//</span>
03311 
03312     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( !(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; IRP_PAGING_IO &amp;&amp; <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status == STATUS_QUOTA_EXCEEDED ) );
03313 
03314     <span class="comment">//</span>
03315     <span class="comment">// Now check to see whether this is the last driver that needs to be</span>
03316     <span class="comment">// invoked for this packet.  If not, then bump the stack and check to</span>
03317     <span class="comment">// see whether the driver wishes to see the completion.  As each stack</span>
03318     <span class="comment">// location is examined, invoke any routine which needs to be invoked.</span>
03319     <span class="comment">// If the routine returns STATUS_MORE_PROCESSING_REQUIRED, then stop the</span>
03320     <span class="comment">// processing of this packet.</span>
03321     <span class="comment">//</span>
03322 
03323     <span class="keywordflow">for</span> (stackPointer = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( Irp ),
03324          <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a>++,
03325          <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.CurrentStackLocation++;
03326          <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a> &lt;= (CCHAR) (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o12">StackCount</a> + 1);
03327          stackPointer++,
03328          <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a>++,
03329          <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.CurrentStackLocation++) {
03330 
03331         <span class="comment">//</span>
03332         <span class="comment">// A stack location was located.  Check to see whether or not it</span>
03333         <span class="comment">// has a completion routine and if so, whether or not it should be</span>
03334         <span class="comment">// invoked.</span>
03335         <span class="comment">//</span>
03336         <span class="comment">// Begin by saving the pending returned flag in the current stack</span>
03337         <span class="comment">// location in the fixed part of the IRP.</span>
03338         <span class="comment">//</span>
03339 
03340         <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o11">PendingReturned</a> = stackPointer-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o3">Control</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a194">SL_PENDING_RETURNED</a>;
03341 
03342         <span class="keywordflow">if</span> ( (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status ) &amp;&amp;
03343              stackPointer-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o3">Control</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a196">SL_INVOKE_ON_SUCCESS</a>) ||
03344              (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status ) &amp;&amp;
03345              stackPointer-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o3">Control</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a197">SL_INVOKE_ON_ERROR</a>) ||
03346              (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o14">Cancel</a> &amp;&amp;
03347              stackPointer-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o3">Control</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a195">SL_INVOKE_ON_CANCEL</a>)
03348            ) {
03349 
03350             <span class="comment">//</span>
03351             <span class="comment">// This driver has specified a completion routine.  Invoke the</span>
03352             <span class="comment">// routine passing it a pointer to its device object and the</span>
03353             <span class="comment">// IRP that is being completed.</span>
03354             <span class="comment">//</span>
03355 
03356             <a class="code" href="../../d4/d6/iosubs_8c.html#a5">ZeroIrpStackLocation</a>( stackPointer );
03357 
03358             <a class="code" href="../../d2/d1/mm_8h.html#a43">PERFINFO_DRIVER_COMPLETIONROUTINE_CALL</a>(Irp, stackPointer);
03359 
03360             status = stackPointer-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o116">CompletionRoutine</a>( (<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>) (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a> == (CCHAR) (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o12">StackCount</a> + 1) ?
03361                                                       (<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>) NULL :
03362                                                       <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( Irp )-&gt;DeviceObject),
03363                                                       Irp,
03364                                                       stackPointer-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o117">Context</a> );
03365 
03366             <a class="code" href="../../d2/d1/mm_8h.html#a44">PERFINFO_DRIVER_COMPLETIONROUTINE_RETURN</a>(Irp, stackPointer);
03367 
03368             <span class="keywordflow">if</span> (status == STATUS_MORE_PROCESSING_REQUIRED) {
03369 
03370                 <span class="comment">//</span>
03371                 <span class="comment">// Note:  Notice that if the driver has returned the above</span>
03372                 <span class="comment">//        status value, it may have already DEALLOCATED the</span>
03373                 <span class="comment">//        packet!  Therefore, do NOT touch any part of the</span>
03374                 <span class="comment">//        IRP in the following code.</span>
03375                 <span class="comment">//</span>
03376 
03377                 <span class="keywordflow">return</span>;
03378             }
03379 
03380         } <span class="keywordflow">else</span> {
03381             <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o11">PendingReturned</a> &amp;&amp; <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a> &lt;= <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o12">StackCount</a>) {
03382                 <a class="code" href="../../d0/d5/io_8h.html#a234">IoMarkIrpPending</a>( Irp );
03383             }
03384             <a class="code" href="../../d4/d6/iosubs_8c.html#a5">ZeroIrpStackLocation</a>( stackPointer );
03385         }
03386     }
03387 
03388     <span class="comment">//</span>
03389     <span class="comment">// Check to see whether this is an associated IRP.  If so, then decrement</span>
03390     <span class="comment">// the count in the master IRP.  If the count is decremented to zero,</span>
03391     <span class="comment">// then complete the master packet as well.</span>
03392     <span class="comment">//</span>
03393 
03394     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a177">IRP_ASSOCIATED_IRP</a>) {
03395         ULONG count;
03396         masterIrp = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.MasterIrp;
03397         count = <a class="code" href="../../d5/d8/ex_8h.html#a235">ExInterlockedAddUlong</a>( (PULONG) &amp;masterIrp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.IrpCount,
03398                                        0xffffffff,
03399                                        &amp;IopDatabaseLock );
03400 
03401         <span class="comment">//</span>
03402         <span class="comment">// Deallocate this packet and any MDLs that are associated with it</span>
03403         <span class="comment">// by either doing direct deallocations if they were allocated from</span>
03404         <span class="comment">// a zone or by queueing the packet to a thread to perform the</span>
03405         <span class="comment">// deallocation.</span>
03406         <span class="comment">//</span>
03407         <span class="comment">// Also, check the count of the master IRP to determine whether or not</span>
03408         <span class="comment">// the count has gone to zero.  If not, then simply get out of here.</span>
03409         <span class="comment">// Otherwise, complete the master packet.</span>
03410         <span class="comment">//</span>
03411 
03412         <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread = masterIrp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread;
03413         <a class="code" href="../../d0/d6/iop_8h.html#a172">IopFreeIrpAndMdls</a>( Irp );
03414         <span class="keywordflow">if</span> (count == 1) {
03415             <a class="code" href="../../d0/d5/io_8h.html#a224">IoCompleteRequest</a>( masterIrp, PriorityBoost );
03416         }
03417         <span class="keywordflow">return</span>;
03418     }
03419 
03420     <span class="comment">//</span>
03421     <span class="comment">// Check to see if we have a name junction. If so set the stage to</span>
03422     <span class="comment">// transmogrify the reparse point data in IopCompleteRequest.</span>
03423     <span class="comment">//</span>
03424 
03425     <span class="keywordflow">if</span> ((<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status == STATUS_REPARSE )  &amp;&amp;
03426         (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information &gt; IO_REPARSE_TAG_RESERVED_RANGE)) {
03427 
03428         <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information == IO_REPARSE_TAG_MOUNT_POINT) {
03429 
03430             <span class="comment">//</span>
03431             <span class="comment">// For name junctions, we save the pointer to the auxiliary</span>
03432             <span class="comment">// buffer and use it below.</span>
03433             <span class="comment">//</span>
03434 
03435             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.AuxiliaryBuffer != NULL );
03436 
03437             saveAuxiliaryPointer = (PVOID) <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.AuxiliaryBuffer;
03438 
03439             <span class="comment">//</span>
03440             <span class="comment">// We NULL the entry to avoid its de-allocation at this time.</span>
03441             <span class="comment">// This buffer get deallocated in IopDoNameTransmogrify</span>
03442             <span class="comment">//</span>
03443 
03444             <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.AuxiliaryBuffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03445         } <span class="keywordflow">else</span> {
03446 
03447             <span class="comment">//</span>
03448             <span class="comment">// Fail the request. A driver needed to act on this IRP prior</span>
03449             <span class="comment">// to getting to this point.</span>
03450             <span class="comment">//</span>
03451 
03452             <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status = STATUS_IO_REPARSE_TAG_NOT_HANDLED;
03453         }
03454     }
03455 
03456     <span class="comment">//</span>
03457     <span class="comment">// Check the auxiliary buffer pointer in the packet and if a buffer was</span>
03458     <span class="comment">// allocated, deallocate it now.  Note that this buffer must be freed</span>
03459     <span class="comment">// here since the pointer is overlayed with the APC that will be used</span>
03460     <span class="comment">// to get to the requesting thread's context.</span>
03461     <span class="comment">//</span>
03462 
03463     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.AuxiliaryBuffer) {
03464         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.AuxiliaryBuffer );
03465         <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.AuxiliaryBuffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03466     }
03467 
03468     <span class="comment">//</span>
03469     <span class="comment">// Check to see if this is paging I/O or a close operation.  If either,</span>
03470     <span class="comment">// then special processing must be performed.  The reasons that special</span>
03471     <span class="comment">// processing must be performed is different based on the type of</span>
03472     <span class="comment">// operation being performed.  The biggest reasons for special processing</span>
03473     <span class="comment">// on paging operations are that using a special kernel APC for an in-</span>
03474     <span class="comment">// page operation cannot work since the special kernel APC can incur</span>
03475     <span class="comment">// another pagefault.  Likewise, all paging I/O uses MDLs that belong</span>
03476     <span class="comment">// to the memory manager, not the I/O system.</span>
03477     <span class="comment">//</span>
03478     <span class="comment">// Close operations are special because the close may have been invoked</span>
03479     <span class="comment">// because of a special kernel APC (some IRP was completed which caused</span>
03480     <span class="comment">// the reference count on the object to become zero while in the I/O</span>
03481     <span class="comment">// system's special kernel APC routine).  Therefore, a special kernel APC</span>
03482     <span class="comment">// cannot be used since it cannot execute until the close APC finishes.</span>
03483     <span class="comment">//</span>
03484     <span class="comment">// The special steps are as follows for a synchronous paging operation</span>
03485     <span class="comment">// and close are:</span>
03486     <span class="comment">//</span>
03487     <span class="comment">//     1.  Copy the I/O status block (it is in SVAS, nonpaged).</span>
03488     <span class="comment">//     2.  Signal the event</span>
03489     <span class="comment">//     3.  If paging I/O, deallocate the IRP</span>
03490     <span class="comment">//</span>
03491     <span class="comment">// The special steps taken for asynchronous paging operations (out-pages)</span>
03492     <span class="comment">// are as follows:</span>
03493     <span class="comment">//</span>
03494     <span class="comment">//     1.  Initialize a special kernel APC just for page writes.</span>
03495     <span class="comment">//     1.  Queue the special kernel APC.</span>
03496     <span class="comment">//</span>
03497     <span class="comment">// It should also be noted that the logic for completing a Mount request</span>
03498     <span class="comment">// operation is exactly the same as a Page Read.  No assumptions should be</span>
03499     <span class="comment">// made here about this being a Page Read operation w/o carefully checking</span>
03500     <span class="comment">// to ensure that they are also true for a Mount.  That is:</span>
03501     <span class="comment">//</span>
03502     <span class="comment">//     IRP_PAGING_IO  and  IRP_MOUNT_COMPLETION</span>
03503     <span class="comment">//</span>
03504     <span class="comment">// are the same flag in the IRP.</span>
03505     <span class="comment">//</span>
03506     <span class="comment">// Also note that the last time the IRP is touched for a close operation</span>
03507     <span class="comment">// must be just before the event is set to the signaled state.  Once this</span>
03508     <span class="comment">// occurs, the IRP can be deallocated by the thread waiting for the event.</span>
03509     <span class="comment">//</span>
03510 
03511     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; (<a class="code" href="../../d0/d5/io_8h.html#a174">IRP_PAGING_IO</a> | <a class="code" href="../../d0/d5/io_8h.html#a185">IRP_CLOSE_OPERATION</a>)) {
03512         <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; (<a class="code" href="../../d0/d5/io_8h.html#a181">IRP_SYNCHRONOUS_PAGING_IO</a> | <a class="code" href="../../d0/d5/io_8h.html#a185">IRP_CLOSE_OPERATION</a>)) {
03513             ULONG flags;
03514 
03515             flags = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a181">IRP_SYNCHRONOUS_PAGING_IO</a>;
03516             *<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>;
03517             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a>, PriorityBoost, FALSE );
03518             <span class="keywordflow">if</span> (flags) {
03519                 <a class="code" href="../../d4/d6/iosubs_8c.html#a63">IoFreeIrp</a>( Irp );
03520             }
03521         } <span class="keywordflow">else</span> {
03522             thread = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread;
03523             <a class="code" href="../../d5/d7/apcobj_8c.html#a1">KeInitializeApc</a>( &amp;<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Apc,
03524                              &amp;thread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o0">Tcb</a>,
03525                              <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o16">ApcEnvironment</a>,
03526                              IopCompletePageWrite,
03527                              (PKRUNDOWN_ROUTINE) NULL,
03528                              (PKNORMAL_ROUTINE) NULL,
03529                              KernelMode,
03530                              (PVOID) NULL );
03531             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d5/d7/apcobj_8c.html#a3">KeInsertQueueApc</a>( &amp;<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Apc,
03532                                      (PVOID) NULL,
03533                                      (PVOID) NULL,
03534                                      PriorityBoost );
03535         }
03536         <span class="keywordflow">return</span>;
03537     }
03538 
03539     <span class="comment">//</span>
03540     <span class="comment">// Check to see whether any pages need to be unlocked.</span>
03541     <span class="comment">//</span>
03542 
03543     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03544 
03545         <span class="comment">//</span>
03546         <span class="comment">// Unlock any pages that may be described by MDLs.</span>
03547         <span class="comment">//</span>
03548 
03549         mdl = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a>;
03550         <span class="keywordflow">while</span> (mdl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03551             <a class="code" href="../../d5/d6/iosup_8c.html#a45">MmUnlockPages</a>( mdl );
03552             mdl = mdl-&gt;<a class="code" href="../../d6/d7/struct__MDL.html#o0">Next</a>;
03553         }
03554     }
03555 
03556     <span class="comment">//</span>
03557     <span class="comment">// Make a final check here to determine whether or not this is a</span>
03558     <span class="comment">// synchronous I/O operation that is being completed in the context</span>
03559     <span class="comment">// of the original requestor.  If so, then an optimal path through</span>
03560     <span class="comment">// I/O completion can be taken.</span>
03561     <span class="comment">//</span>
03562 
03563     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a186">IRP_DEFER_IO_COMPLETION</a> &amp;&amp; !<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o11">PendingReturned</a>) {
03564 
03565         <span class="keywordflow">if</span> ((<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status == STATUS_REPARSE )  &amp;&amp;
03566             (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information == IO_REPARSE_TAG_MOUNT_POINT)) {
03567 
03568             <span class="comment">//</span>
03569             <span class="comment">// For name junctions we reinstate the address of the appropriate</span>
03570             <span class="comment">// buffer. It is freed in parse.c</span>
03571             <span class="comment">//</span>
03572 
03573             <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.AuxiliaryBuffer = saveAuxiliaryPointer;
03574         }
03575 
03576         <span class="keywordflow">return</span>;
03577     }
03578 
03579     <span class="comment">//</span>
03580     <span class="comment">// Finally, initialize the IRP as an APC structure and queue the special</span>
03581     <span class="comment">// kernel APC to the target thread.</span>
03582     <span class="comment">//</span>
03583 
03584     thread = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread;
03585     fileObject = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.OriginalFileObject;
03586 
03587     <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o14">Cancel</a>) {
03588 
03589         <a class="code" href="../../d5/d7/apcobj_8c.html#a1">KeInitializeApc</a>( &amp;<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Apc,
03590                          &amp;thread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o0">Tcb</a>,
03591                          <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o16">ApcEnvironment</a>,
03592                          IopCompleteRequest,
03593                          IopAbortRequest,
03594                          (PKNORMAL_ROUTINE) NULL,
03595                          KernelMode,
03596                          (PVOID) NULL );
03597 
03598         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d5/d7/apcobj_8c.html#a3">KeInsertQueueApc</a>( &amp;<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Apc,
03599                                  fileObject,
03600                                  (PVOID) saveAuxiliaryPointer,
03601                                  PriorityBoost );
03602     } <span class="keywordflow">else</span> {
03603 
03604         <span class="comment">//</span>
03605         <span class="comment">// This request has been cancelled.  Ensure that access to the thread</span>
03606         <span class="comment">// is synchronized, otherwise it may go away while attempting to get</span>
03607         <span class="comment">// through the remainder of completion for this request.  This happens</span>
03608         <span class="comment">// when the thread times out waiting for the request to be completed</span>
03609         <span class="comment">// once it has been cancelled.</span>
03610         <span class="comment">//</span>
03611         <span class="comment">// Note that it is safe to capture the thread pointer above, w/o having</span>
03612         <span class="comment">// the lock because the cancel flag was not set at that point, and</span>
03613         <span class="comment">// the code that disassociates IRPs must set the flag before looking to</span>
03614         <span class="comment">// see whether or not the packet has been completed, and this packet</span>
03615         <span class="comment">// will appear to be completed because it no longer belongs to a driver.</span>
03616         <span class="comment">//</span>
03617 
03618         ExAcquireSpinLock( &amp;IopCompletionLock, &amp;irql );
03619 
03620         thread = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread;
03621 
03622         <span class="keywordflow">if</span> (thread) {
03623 
03624             <a class="code" href="../../d5/d7/apcobj_8c.html#a1">KeInitializeApc</a>( &amp;<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Apc,
03625                              &amp;thread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o0">Tcb</a>,
03626                              <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o16">ApcEnvironment</a>,
03627                              IopCompleteRequest,
03628                              IopAbortRequest,
03629                              (PKNORMAL_ROUTINE) NULL,
03630                              KernelMode,
03631                              (PVOID) NULL );
03632 
03633             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d5/d7/apcobj_8c.html#a3">KeInsertQueueApc</a>( &amp;<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Apc,
03634                                      fileObject,
03635                                      (PVOID) saveAuxiliaryPointer,
03636                                      PriorityBoost );
03637 
03638             ExReleaseSpinLock( &amp;IopCompletionLock, irql );
03639 
03640         } <span class="keywordflow">else</span> {
03641 
03642             <span class="comment">//</span>
03643             <span class="comment">// This request has been aborted from completing in the caller's</span>
03644             <span class="comment">// thread.  This can only occur if the packet was cancelled, and</span>
03645             <span class="comment">// the driver did not complete the request, so it was timed out.</span>
03646             <span class="comment">// Attempt to drop things on the floor, since the originating thread</span>
03647             <span class="comment">// has probably exited at this point.</span>
03648             <span class="comment">//</span>
03649 
03650             ExReleaseSpinLock( &amp;IopCompletionLock, irql );
03651 
03652             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o14">Cancel</a> );
03653 
03654             <span class="comment">//</span>
03655             <span class="comment">// Drop the IRP on the floor.</span>
03656             <span class="comment">//</span>
03657 
03658             <a class="code" href="../../d0/d6/iop_8h.html#a168">IopDropIrp</a>( Irp, fileObject );
03659 
03660         }
03661     }
03662 }
03663 
03664 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l03665"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a41">03665</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a41">IoConnectInterrupt</a>(
03666     OUT <a class="code" href="../../d0/d7/struct__KINTERRUPT.html">PKINTERRUPT</a> *InterruptObject,
03667     IN PKSERVICE_ROUTINE ServiceRoutine,
03668     IN PVOID ServiceContext,
03669     IN PKSPIN_LOCK SpinLock OPTIONAL,
03670     IN ULONG Vector,
03671     IN KIRQL Irql,
03672     IN KIRQL SynchronizeIrql,
03673     IN KINTERRUPT_MODE InterruptMode,
03674     IN BOOLEAN ShareVector,
03675     IN KAFFINITY ProcessorEnableMask,
03676     IN BOOLEAN FloatingSave
03677     )
03678 
03679 <span class="comment">/*++</span>
03680 <span class="comment"></span>
03681 <span class="comment">Routine Description:</span>
03682 <span class="comment"></span>
03683 <span class="comment">    This routine allocates, initializes, and connects interrupt objects for</span>
03684 <span class="comment">    all of the processors specified in the processor enable mask.</span>
03685 <span class="comment"></span>
03686 <span class="comment">Arguments:</span>
03687 <span class="comment"></span>
03688 <span class="comment">    InterruptObject - Address of a variable to receive a pointer to the first</span>
03689 <span class="comment">        interrupt object allocated and initialized.</span>
03690 <span class="comment"></span>
03691 <span class="comment">    ServiceRoutine - Address of the interrupt service routine (ISR) that should</span>
03692 <span class="comment">        be executed when the interrupt occurs.</span>
03693 <span class="comment"></span>
03694 <span class="comment">    ServiceContext - Supplies a pointer to the context information required</span>
03695 <span class="comment">        by the ISR.</span>
03696 <span class="comment"></span>
03697 <span class="comment">    SpinLock - Supplies a pointer to a spin lock to be used when synchronizing</span>
03698 <span class="comment">        with the ISR.</span>
03699 <span class="comment"></span>
03700 <span class="comment">    Vector - Supplies the vector upon which the interrupt occurs.</span>
03701 <span class="comment"></span>
03702 <span class="comment">    Irql - Supplies the IRQL upon which the interrupt occurs.</span>
03703 <span class="comment"></span>
03704 <span class="comment">    SynchronizeIrql - The request priority that the interrupt should be</span>
03705 <span class="comment">        synchronized with.</span>
03706 <span class="comment"></span>
03707 <span class="comment">    InterruptMode - Specifies the interrupt mode of the device.</span>
03708 <span class="comment"></span>
03709 <span class="comment">    ShareVector - Supplies a boolean value that specifies whether the</span>
03710 <span class="comment">        vector can be shared with other interrupt objects or not.  If FALSE</span>
03711 <span class="comment">        then the vector may not be shared, if TRUE it may be.</span>
03712 <span class="comment">        Latched.</span>
03713 <span class="comment"></span>
03714 <span class="comment">    ProcessorEnableMask - Specifies a bit-vector for each processor on which</span>
03715 <span class="comment">        the interrupt is to be connected.  A value of one in the bit position</span>
03716 <span class="comment">        cooresponding to the processor number indicates that the interrupt</span>
03717 <span class="comment">        should be allowed on that processor.  At least one bit must be set.</span>
03718 <span class="comment"></span>
03719 <span class="comment">    FloatingSave - A BOOLEAN that specifies whether or not the machine's</span>
03720 <span class="comment">        floating point state should be saved before invoking the ISR.</span>
03721 <span class="comment"></span>
03722 <span class="comment">Return Value:</span>
03723 <span class="comment"></span>
03724 <span class="comment">    The function value is the final function status.  The three status values</span>
03725 <span class="comment">    that this routine can itself return are:</span>
03726 <span class="comment"></span>
03727 <span class="comment">        STATUS_SUCCESS - Everything worked successfully.</span>
03728 <span class="comment">        STATUS_INVALID_PARAMETER - No processors were specified.</span>
03729 <span class="comment">        STATUS_INSUFFICIENT_RESOURCES - There was not enough nonpaged pool.</span>
03730 <span class="comment"></span>
03731 <span class="comment">--*/</span>
03732 
03733 {
03734     CCHAR count;
03735     BOOLEAN builtinUsed;
03736     <a class="code" href="../../d0/d7/struct__KINTERRUPT.html">PKINTERRUPT</a> interruptObject;
03737     ULONG processorMask;
03738     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
03739     <a class="code" href="../../d3/d4/struct__IO__INTERRUPT__STRUCTURE.html">PIO_INTERRUPT_STRUCTURE</a> interruptStructure;
03740     PKSPIN_LOCK spinLock;
03741 
03742     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
03743 
03744     <span class="comment">//</span>
03745     <span class="comment">// Initialize the return pointer and assume success.</span>
03746     <span class="comment">//</span>
03747 
03748     *<a class="code" href="../../d4/d9/ke_8h.html#a402a179">InterruptObject</a> = (<a class="code" href="../../d0/d7/struct__KINTERRUPT.html">PKINTERRUPT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03749     status = STATUS_SUCCESS;
03750 
03751     <span class="comment">//</span>
03752     <span class="comment">// Determine how much memory is to be allocated based on how many</span>
03753     <span class="comment">// processors this system may have and how many bits are set in the</span>
03754     <span class="comment">// processor enable mask.</span>
03755     <span class="comment">//</span>
03756 
03757     processorMask = ProcessorEnableMask &amp; <a class="code" href="../../d4/d9/ke_8h.html#a123">KeActiveProcessors</a>;
03758     count = 0;
03759 
03760     <span class="keywordflow">while</span> (processorMask) {
03761         <span class="keywordflow">if</span> (processorMask &amp; 1) {
03762             count++;
03763         }
03764         processorMask &gt;&gt;= 1;
03765     }
03766 
03767     <span class="comment">//</span>
03768     <span class="comment">// If any interrupt objects are to be allocated and initialized, allocate</span>
03769     <span class="comment">// the memory now.</span>
03770     <span class="comment">//</span>
03771 
03772     <span class="keywordflow">if</span> (count) {
03773         interruptStructure = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
03774                                                     ((count - 1) * <span class="keyword">sizeof</span>( <a class="code" href="../../d0/d7/struct__KINTERRUPT.html">KINTERRUPT</a> )) +
03775                                                     <span class="keyword">sizeof</span>( <a class="code" href="../../d3/d4/struct__IO__INTERRUPT__STRUCTURE.html">IO_INTERRUPT_STRUCTURE</a> ),
03776                                                     'nioI' );
03777         <span class="keywordflow">if</span> (interruptStructure == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
03778             status = STATUS_INSUFFICIENT_RESOURCES;
03779         }
03780     } <span class="keywordflow">else</span> {
03781         status = STATUS_INVALID_PARAMETER;
03782     }
03783 
03784     <span class="comment">//</span>
03785     <span class="comment">// If the caller specified a spin lock to be used for the interrupt object,</span>
03786     <span class="comment">// use it.  Otherwise, provide one by using the one in the structure that</span>
03787     <span class="comment">// was just allocated.</span>
03788     <span class="comment">//</span>
03789 
03790     <span class="keywordflow">if</span> (ARGUMENT_PRESENT( SpinLock )) {
03791         spinLock = SpinLock;
03792     } <span class="keywordflow">else</span> {
03793         spinLock = &amp;interruptStructure-&gt;<a class="code" href="../../d3/d4/struct__IO__INTERRUPT__STRUCTURE.html#o2">SpinLock</a>;
03794     }
03795 
03796     <span class="comment">//</span>
03797     <span class="comment">// If the pool allocation was successful, initialize and connect the</span>
03798     <span class="comment">// interrupt objects to the appropriate processors.</span>
03799     <span class="comment">//</span>
03800 
03801     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
03802 
03803         <span class="comment">//</span>
03804         <span class="comment">// Return the address of the first interrupt object in case an</span>
03805         <span class="comment">// interrupt is pending for the device when it is initially connected</span>
03806         <span class="comment">// and the driver must synchronize its execution with the ISR.</span>
03807         <span class="comment">//</span>
03808 
03809         *<a class="code" href="../../d4/d9/ke_8h.html#a402a179">InterruptObject</a> = &amp;interruptStructure-&gt;<a class="code" href="../../d3/d4/struct__IO__INTERRUPT__STRUCTURE.html#o0">InterruptObject</a>;
03810 
03811         <span class="comment">//</span>
03812         <span class="comment">// Begin by getting a pointer to the start of the memory to be used</span>
03813         <span class="comment">// for interrupt objects other than the builtin object.</span>
03814         <span class="comment">//</span>
03815 
03816         interruptObject = (<a class="code" href="../../d0/d7/struct__KINTERRUPT.html">PKINTERRUPT</a>) (interruptStructure + 1);
03817         builtinUsed = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
03818         processorMask = ProcessorEnableMask &amp; <a class="code" href="../../d4/d9/ke_8h.html#a123">KeActiveProcessors</a>;
03819 
03820         <span class="comment">//</span>
03821         <span class="comment">// Now zero the interrupt structure itself so that if something goes</span>
03822         <span class="comment">// wrong it can be backed out.</span>
03823         <span class="comment">//</span>
03824 
03825         RtlZeroMemory( interruptStructure, <span class="keyword">sizeof</span>( <a class="code" href="../../d3/d4/struct__IO__INTERRUPT__STRUCTURE.html">IO_INTERRUPT_STRUCTURE</a> ) );
03826 
03827         <span class="comment">//</span>
03828         <span class="comment">// For each entry in the processor enable mask that is set, connect</span>
03829         <span class="comment">// and initialize an interrupt object.  The first bit that is set</span>
03830         <span class="comment">// uses the builtin interrupt object, and all others use the pointers</span>
03831         <span class="comment">// that follow it.</span>
03832         <span class="comment">//</span>
03833 
03834         <span class="keywordflow">for</span> (count = 0; processorMask; count++, processorMask &gt;&gt;= 1) {
03835             <span class="keywordflow">if</span> (processorMask &amp; 1) {
03836                 <a class="code" href="../../d7/d4/ppc_2intobj_8c.html#a0">KeInitializeInterrupt</a>( builtinUsed ?
03837                                        interruptObject :
03838                                        &amp;interruptStructure-&gt;<a class="code" href="../../d3/d4/struct__IO__INTERRUPT__STRUCTURE.html#o0">InterruptObject</a>,
03839                                        ServiceRoutine,
03840                                        ServiceContext,
03841                                        spinLock,
03842                                        Vector,
03843                                        Irql,
03844                                        SynchronizeIrql,
03845                                        InterruptMode,
03846                                        ShareVector,
03847                                        count,
03848                                        FloatingSave );
03849 
03850                 <span class="keywordflow">if</span> (!<a class="code" href="../../d7/d4/ppc_2intobj_8c.html#a1">KeConnectInterrupt</a>( builtinUsed ?
03851                                          interruptObject :
03852                                          &amp;interruptStructure-&gt;<a class="code" href="../../d3/d4/struct__IO__INTERRUPT__STRUCTURE.html#o0">InterruptObject</a> )) {
03853 
03854                     <span class="comment">//</span>
03855                     <span class="comment">// An error occurred while attempting to connect the</span>
03856                     <span class="comment">// interrupt.  This means that the driver either specified</span>
03857                     <span class="comment">// the wrong type of interrupt mode, or attempted to connect</span>
03858                     <span class="comment">// to some processor that didn't exist, or whatever.  In</span>
03859                     <span class="comment">// any case, the problem turns out to be an invalid</span>
03860                     <span class="comment">// parameter was specified.  Simply back everything out</span>
03861                     <span class="comment">// and return an error status.</span>
03862                     <span class="comment">//</span>
03863                     <span class="comment">// Note that if the builtin entry was used, then the entire</span>
03864                     <span class="comment">// structure needs to be walked as there are entries that</span>
03865                     <span class="comment">// were successfully connected.  Otherwise, the first</span>
03866                     <span class="comment">// attempt to connect failed, so simply free everything</span>
03867                     <span class="comment">// in-line.</span>
03868                     <span class="comment">//</span>
03869 
03870                     <span class="keywordflow">if</span> (builtinUsed) {
03871                         <a class="code" href="../../d4/d6/iosubs_8c.html#a59">IoDisconnectInterrupt</a>( &amp;interruptStructure-&gt;<a class="code" href="../../d3/d4/struct__IO__INTERRUPT__STRUCTURE.html#o0">InterruptObject</a> );
03872                     } <span class="keywordflow">else</span> {
03873                         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( interruptStructure );
03874                     }
03875                     status = STATUS_INVALID_PARAMETER;
03876                     <span class="keywordflow">break</span>;
03877                 }
03878 
03879 
03880                 <span class="comment">//</span>
03881                 <span class="comment">// If the builtin entry has been used, then the interrupt</span>
03882                 <span class="comment">// object just connected was one of the pointers, so fill</span>
03883                 <span class="comment">// it in with the address of the memory actually used.</span>
03884                 <span class="comment">//</span>
03885 
03886                 <span class="keywordflow">if</span> (builtinUsed) {
03887                     interruptStructure-&gt;<a class="code" href="../../d3/d4/struct__IO__INTERRUPT__STRUCTURE.html#o1">InterruptArray</a>[count] = interruptObject++;
03888 
03889                 } <span class="keywordflow">else</span> {
03890 
03891                     <span class="comment">//</span>
03892                     <span class="comment">// Otherwise, the builtin entry was used, so indicate</span>
03893                     <span class="comment">// that it is no longer valid to use and start using</span>
03894                     <span class="comment">// the pointers instead.</span>
03895                     <span class="comment">//</span>
03896 
03897                     builtinUsed = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
03898                 }
03899 
03900             }
03901         }
03902     }
03903 
03904     <span class="comment">//</span>
03905     <span class="comment">// Finally, reset the address of the interrupt object if the function</span>
03906     <span class="comment">// failed and return the final status of the operation.</span>
03907     <span class="comment">//</span>
03908 
03909     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
03910         *<a class="code" href="../../d4/d9/ke_8h.html#a402a179">InterruptObject</a> = (<a class="code" href="../../d0/d7/struct__KINTERRUPT.html">PKINTERRUPT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03911     }
03912 
03913     <span class="keywordflow">return</span> status;
03914 }
03915 
03916 <a class="code" href="../../d1/d8/struct__CONTROLLER__OBJECT.html">PCONTROLLER_OBJECT</a>
<a name="l03917"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a42">03917</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a42">IoCreateController</a>(
03918     IN ULONG Size
03919     )
03920 
03921 <span class="comment">/*++</span>
03922 <span class="comment"></span>
03923 <span class="comment">Routine Description:</span>
03924 <span class="comment"></span>
03925 <span class="comment">    This routine creates a controller object that can be used to synchronize</span>
03926 <span class="comment">    access to a physical device controller from two or more devices.</span>
03927 <span class="comment"></span>
03928 <span class="comment">Arguments:</span>
03929 <span class="comment"></span>
03930 <span class="comment">    Size - Size of the adapter extension in bytes.</span>
03931 <span class="comment"></span>
03932 <span class="comment">Return Value:</span>
03933 <span class="comment"></span>
03934 <span class="comment">    A pointer to the controller object that was created or a NULL pointer.</span>
03935 <span class="comment"></span>
03936 <span class="comment">--*/</span>
03937 
03938 {
03939     OBJECT_ATTRIBUTES objectAttributes;
03940     <a class="code" href="../../d1/d8/struct__CONTROLLER__OBJECT.html">PCONTROLLER_OBJECT</a> controllerObject;
03941     HANDLE handle;
03942     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
03943 
03944     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
03945 
03946     <span class="comment">//</span>
03947     <span class="comment">// Initialize the object attributes structure in preparation for creating</span>
03948     <span class="comment">// the controller object.</span>
03949     <span class="comment">//</span>
03950 
03951     InitializeObjectAttributes( &amp;objectAttributes,
03952                                 (PUNICODE_STRING) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
03953                                 0,
03954                                 (HANDLE) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
03955                                 (PSECURITY_DESCRIPTOR) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
03956 
03957     <span class="comment">//</span>
03958     <span class="comment">// Create the controller object itself.</span>
03959     <span class="comment">//</span>
03960 
03961     status = <a class="code" href="../../d6/d0/obcreate_8c.html#a5">ObCreateObject</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
03962                              <a class="code" href="../../d3/d5/iodata_8c.html#a33">IoControllerObjectType</a>,
03963                              &amp;objectAttributes,
03964                              <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
03965                              (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
03966                              (ULONG) <span class="keyword">sizeof</span>( <a class="code" href="../../d1/d8/struct__CONTROLLER__OBJECT.html">CONTROLLER_OBJECT</a> ) + <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>,
03967                              0,
03968                              0,
03969                              (PVOID *) &amp;controllerObject );
03970     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
03971 
03972         <span class="comment">//</span>
03973         <span class="comment">// Insert the controller object into the table.</span>
03974         <span class="comment">//</span>
03975 
03976         status = <a class="code" href="../../d1/d1/obinsert_8c.html#a0">ObInsertObject</a>( controllerObject,
03977                                  <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
03978                                  FILE_READ_DATA | FILE_WRITE_DATA,
03979                                  1,
03980                                  (PVOID *) &amp;controllerObject,
03981                                  &amp;handle );
03982 
03983         <span class="comment">//</span>
03984         <span class="comment">// If the insert operation fails, set return value to NULL.</span>
03985         <span class="comment">//</span>
03986 
03987         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
03988             controllerObject = (<a class="code" href="../../d1/d8/struct__CONTROLLER__OBJECT.html">PCONTROLLER_OBJECT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
03989         } <span class="keywordflow">else</span> {
03990 
03991             <span class="comment">//</span>
03992             <span class="comment">// The insert completed successfully.  Close the handle so that if</span>
03993             <span class="comment">// the driver is unloaded, the controller object can go away.</span>
03994             <span class="comment">//</span>
03995 
03996             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>( handle );
03997 
03998             <span class="comment">//</span>
03999             <span class="comment">// Zero the memory for the controller object.</span>
04000             <span class="comment">//</span>
04001 
04002             RtlZeroMemory( controllerObject, <span class="keyword">sizeof</span>( <a class="code" href="../../d0/d5/io_8h.html#a337">CONTROLLER_OBJECT</a> ) + <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> );
04003 
04004             <span class="comment">//</span>
04005             <span class="comment">// Set the type and size of this controller object.</span>
04006             <span class="comment">//</span>
04007 
04008             controllerObject-&gt;Type = <a class="code" href="../../d0/d5/io_8h.html#a1">IO_TYPE_CONTROLLER</a>;
04009             controllerObject-&gt;Size = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) (<span class="keyword">sizeof</span>( <a class="code" href="../../d0/d5/io_8h.html#a337">CONTROLLER_OBJECT</a> ) + <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>);
04010             controllerObject-&gt;ControllerExtension = (PVOID) (controllerObject + 1);
04011 
04012             <span class="comment">//</span>
04013             <span class="comment">// Finally, initialize the controller's device queue.</span>
04014             <span class="comment">//</span>
04015 
04016             <a class="code" href="../../d7/d7/devquobj_8c.html#a1">KeInitializeDeviceQueue</a>( &amp;controllerObject-&gt;DeviceWaitQueue );
04017         }
04018     } <span class="keywordflow">else</span> {
04019         controllerObject = (<a class="code" href="../../d1/d8/struct__CONTROLLER__OBJECT.html">PCONTROLLER_OBJECT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04020     }
04021 
04022     <span class="keywordflow">return</span> controllerObject;
04023 }
04024 
04025 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l04026"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a43">04026</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a43">IopInsertRemoveDevice</a>(
04027     IN <a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html">PDRIVER_OBJECT</a> DriverObject,
04028     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
04029     IN BOOLEAN Insert
04030     )
04031 
04032 {
04033     KIRQL irql;
04034 
04035     ExAcquireSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, &amp;irql );
04036     <span class="keywordflow">if</span> (Insert) {
04037         DeviceObject-&gt;NextDevice = DriverObject-&gt;DeviceObject;
04038         DriverObject-&gt;DeviceObject = DeviceObject;
04039         }
04040     <span class="keywordflow">else</span> {
04041         <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> *prevPoint;
04042 
04043         prevPoint = &amp;DeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o3">DriverObject</a>-&gt;<a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html#o2">DeviceObject</a>;
04044         <span class="keywordflow">while</span> (*prevPoint != DeviceObject) {
04045             prevPoint = &amp;(*prevPoint)-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o4">NextDevice</a>;
04046         }
04047         *prevPoint = DeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o4">NextDevice</a>;
04048     }
04049     ExReleaseSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, irql );
04050 }
04051 
04052 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l04053"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a44">04053</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a44">IopCreateVpb</a> (
04054     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject
04055     )
04056 {
04057     <a class="code" href="../../d7/d7/struct__VPB.html">PVPB</a> Vpb;
04058 
04059     Vpb = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(
04060                 <a class="code" href="../../d5/d8/ex_8h.html#a329a175">NonPagedPoolMustSucceed</a>,
04061                 <span class="keyword">sizeof</span>( <a class="code" href="../../d7/d7/struct__VPB.html">VPB</a> ),
04062                 ' bpV'
04063                 );
04064 
04065     RtlZeroMemory (Vpb, <span class="keyword">sizeof</span>(<a class="code" href="../../d0/d5/io_8h.html#a332">VPB</a>));
04066     Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o0">Type</a> = <a class="code" href="../../d0/d5/io_8h.html#a9">IO_TYPE_VPB</a>;
04067     Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o1">Size</a> = <span class="keyword">sizeof</span>( <a class="code" href="../../d0/d5/io_8h.html#a332">VPB</a> );
04068     Vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o5">RealDevice</a> = DeviceObject;
04069     DeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o10">Vpb</a> = Vpb;
04070 }
04071 
04072 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l04073"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a45">04073</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a45">IoCreateDevice</a>(
04074     IN <a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html">PDRIVER_OBJECT</a> DriverObject,
04075     IN ULONG DeviceExtensionSize,
04076     IN PUNICODE_STRING DeviceName OPTIONAL,
04077     IN DEVICE_TYPE DeviceType,
04078     IN ULONG DeviceCharacteristics,
04079     IN BOOLEAN Exclusive,
04080     OUT <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> *DeviceObject
04081     )
04082 
04083 <span class="comment">/*++</span>
04084 <span class="comment"></span>
04085 <span class="comment">Routine Description:</span>
04086 <span class="comment"></span>
04087 <span class="comment">    This routine creates a device object and links it into the I/O database.</span>
04088 <span class="comment"></span>
04089 <span class="comment">Arguments:</span>
04090 <span class="comment"></span>
04091 <span class="comment">    DriverObject - A pointer to the driver object for this device.</span>
04092 <span class="comment"></span>
04093 <span class="comment">    DeviceExtensionSize - Size, in bytes, of extension to device object;</span>
04094 <span class="comment">        i.e., the size of the driver-specific data for this device object.</span>
04095 <span class="comment"></span>
04096 <span class="comment">    DeviceName - Optional name that should be associated with this device.</span>
04097 <span class="comment">        If the DeviceCharacteristics has the FILE_AUTOGENERATED_DEVICE_NAME</span>
04098 <span class="comment">        flag set, this parameter is ignored.</span>
04099 <span class="comment"></span>
04100 <span class="comment">    DeviceType - The type of device that the device object should represent.</span>
04101 <span class="comment"></span>
04102 <span class="comment">    DeviceCharacteristics - The characteristics for the device.</span>
04103 <span class="comment"></span>
04104 <span class="comment">    Exclusive - Indicates that the device object should be created with using</span>
04105 <span class="comment">        the exclusive object attribute.</span>
04106 <span class="comment"></span>
04107 <span class="comment">        NOTE: This flag should not be used for WDM drivers.  Since only the</span>
04108 <span class="comment">        PDO is named, it is the only device object in a devnode attachment</span>
04109 <span class="comment">        stack that is openable.  However, since this device object is created</span>
04110 <span class="comment">        by the underlying bus driver (which has no knowledge about what type</span>
04111 <span class="comment">        of device this is), there is no way to know whether this flag should</span>
04112 <span class="comment">        be set.  Therefore, this parameter should always be FALSE for WDM</span>
04113 <span class="comment">        drivers.  Drivers attached to the PDO (e.g., the function driver) must</span>
04114 <span class="comment">        enforce any exclusivity rules.</span>
04115 <span class="comment"></span>
04116 <span class="comment">    DeviceObject - Pointer to the device object pointer we will return.</span>
04117 <span class="comment"></span>
04118 <span class="comment">Return Value:</span>
04119 <span class="comment"></span>
04120 <span class="comment">    The function value is the final status of the operation.</span>
04121 <span class="comment"></span>
04122 <span class="comment"></span>
04123 <span class="comment">--*/</span>
04124 
04125 {
04126     OBJECT_ATTRIBUTES objectAttributes;
04127     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
04128     <a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html">PDEVOBJ_EXTENSION</a> deviceObjectExt;
04129     HANDLE handle;
04130     BOOLEAN deviceHasName;
04131     <a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a> localSecurityDescriptor[SECURITY_DESCRIPTOR_MIN_LENGTH];
04132     PSECURITY_DESCRIPTOR securityDescriptor;
04133     PACL acl;
04134     PACE_HEADER ace;
04135     PSID sid;
04136     PACCESS_MASK mask;
04137     ULONG i;
04138     ULONG RoundedSize;
04139     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
04140     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> sectorSize = 0;
04141     LONG nextUniqueDeviceObjectNumber;
04142     UNICODE_STRING autoGeneratedDeviceName;
04143     BOOLEAN retryWithNewName = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04144     WCHAR deviceNameBuffer[17];             <span class="comment">// "\Device\xxxxxxxx"</span>
04145 
04146     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
04147 
04148     acl = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04149 
04150     <span class="comment">//</span>
04151     <span class="comment">// Enclose the creation of the device object in a do/while, in the rare</span>
04152     <span class="comment">// event where we have to retry because some other driver is using our</span>
04153     <span class="comment">// naming scheme for auto-generated device object names.</span>
04154     <span class="comment">//</span>
04155 
04156     <span class="keywordflow">do</span> {
04157 
04158         <span class="keywordflow">if</span> (DeviceCharacteristics &amp; FILE_AUTOGENERATED_DEVICE_NAME) {
04159 
04160             <span class="comment">//</span>
04161             <span class="comment">// The caller has requested that we automatically generate a device</span>
04162             <span class="comment">// object name.  Retrieve the next available number to use for this</span>
04163             <span class="comment">// purpose, and create a name of the form "\Device&lt;n&gt;", where &lt;n&gt;</span>
04164             <span class="comment">// is the (8 hexadecimal digit) character representation of the unique</span>
04165             <span class="comment">// number we retrieve.</span>
04166             <span class="comment">//</span>
04167 
04168             nextUniqueDeviceObjectNumber = InterlockedIncrement( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a50">IopUniqueDeviceObjectNumber</a> );
04169             swprintf( deviceNameBuffer, <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"\\Device\\%08lx"</span>, nextUniqueDeviceObjectNumber );
04170 
04171             <span class="keywordflow">if</span> (retryWithNewName) {
04172 
04173                 <span class="comment">//</span>
04174                 <span class="comment">// We've already done this once (hence, the unicode device name string</span>
04175                 <span class="comment">// is all set up, as is all the security information).  Thus, we can</span>
04176                 <span class="comment">// skip down to where we re-attempt the creation of the device object</span>
04177                 <span class="comment">// using our new name.</span>
04178                 <span class="comment">//</span>
04179 
04180                 retryWithNewName = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
04181                 <span class="keywordflow">goto</span> attemptDeviceObjectCreation;
04182 
04183             } <span class="keywordflow">else</span> {
04184 
04185                 <span class="comment">//</span>
04186                 <span class="comment">// Set the DeviceName parameter to point to our unicode string, just as</span>
04187                 <span class="comment">// if the caller had specified it (note, we explicitly ignore anything</span>
04188                 <span class="comment">// the caller passes us for device name if the FILE_AUTOGENERATED_DEVICE_NAME</span>
04189                 <span class="comment">// characteristic is specified.</span>
04190                 <span class="comment">//</span>
04191 
04192                 <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>( &amp;autoGeneratedDeviceName, deviceNameBuffer );
04193                 DeviceName = &amp;autoGeneratedDeviceName;
04194             }
04195         }
04196 
04197         <span class="comment">//</span>
04198         <span class="comment">// Remember whether or not this device was created with a name so that</span>
04199         <span class="comment">// it can be deallocated later.</span>
04200         <span class="comment">//</span>
04201 
04202         deviceHasName = (BOOLEAN) (ARGUMENT_PRESENT( DeviceName ) ? <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> : <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
04203 
04204         <span class="comment">//</span>
04205         <span class="comment">// Detmermine whether or not this device needs to have a security descriptor</span>
04206         <span class="comment">// placed on it that allows read/write access, or whether the system default</span>
04207         <span class="comment">// should be used.  Disks, virtual disks, and file systems simply use the</span>
04208         <span class="comment">// system default descriptor.  All others allow read/write access.</span>
04209         <span class="comment">//</span>
04210         <span class="comment">// NOTE: This routine assumes that it is in the system's security context.</span>
04211         <span class="comment">//       In particular, it assumes that the Default DACL is the system's</span>
04212         <span class="comment">//       Default DACL.  If this assumption changes in future releases,</span>
04213         <span class="comment">//       then use of the Default DACL below should be reviewed for</span>
04214         <span class="comment">//       appropriateness.</span>
04215         <span class="comment">//</span>
04216 
04217         <span class="comment">//</span>
04218         <span class="comment">// If the device is a pnp device then wait until it registers a device</span>
04219         <span class="comment">// class before doing the default setup.</span>
04220         <span class="comment">//</span>
04221 
04222         securityDescriptor = <a class="code" href="../../d4/d6/iosubs_8c.html#a127">IopCreateDefaultDeviceSecurityDescriptor</a>(
04223                                 DeviceType,
04224                                 DeviceCharacteristics,
04225                                 deviceHasName,
04226                                 localSecurityDescriptor,
04227                                 &amp;acl,
04228                                 <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>);
04229 
04230         <span class="keywordflow">switch</span> ( DeviceType ) {
04231 
04232         <span class="keywordflow">case</span> FILE_DEVICE_DISK_FILE_SYSTEM:
04233 
04234             sectorSize = 512;
04235             <span class="keywordflow">break</span>;
04236 
04237         <span class="keywordflow">case</span> FILE_DEVICE_CD_ROM_FILE_SYSTEM:
04238 
04239             sectorSize = 2048;
04240             <span class="keywordflow">break</span>;
04241 
04242         <span class="keywordflow">case</span> FILE_DEVICE_DISK:
04243         <span class="keywordflow">case</span> FILE_DEVICE_VIRTUAL_DISK:
04244 
04245             sectorSize = 512;
04246             <span class="keywordflow">break</span>;
04247         }
04248 
04249 attemptDeviceObjectCreation:
04250         <span class="comment">//</span>
04251         <span class="comment">// Initialize the object attributes structure in preparation for creating</span>
04252         <span class="comment">// device object.  Note that the device may be created as an exclusive</span>
04253         <span class="comment">// device so that only one open can be done to it at a time.  This saves</span>
04254         <span class="comment">// single user devices from having drivers that implement special code to</span>
04255         <span class="comment">// make sure that only one connection is ever valid at any given time.</span>
04256         <span class="comment">//</span>
04257 
04258         InitializeObjectAttributes( &amp;objectAttributes,
04259                                     DeviceName,
04260                                     0,
04261                                     (HANDLE) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
04262                                     securityDescriptor );
04263 
04264 
04265         <span class="keywordflow">if</span> (Exclusive) {
04266             objectAttributes.Attributes |= OBJ_EXCLUSIVE;
04267         } <span class="keywordflow">else</span> {
04268             objectAttributes.Attributes |= 0;
04269         }
04270 
04271         <span class="keywordflow">if</span> (deviceHasName) {
04272             objectAttributes.Attributes |= OBJ_PERMANENT;
04273         }
04274 
04275         <span class="comment">//</span>
04276         <span class="comment">// Create the device object itself.</span>
04277         <span class="comment">//</span>
04278 
04279         RoundedSize = (<span class="keyword">sizeof</span>( <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">DEVICE_OBJECT</a> ) + DeviceExtensionSize)
04280                        % <span class="keyword">sizeof</span> (LONGLONG);
04281         <span class="keywordflow">if</span> (RoundedSize) {
04282             RoundedSize = <span class="keyword">sizeof</span> (LONGLONG) - RoundedSize;
04283         }
04284 
04285         RoundedSize += DeviceExtensionSize;
04286 
04287         status = <a class="code" href="../../d6/d0/obcreate_8c.html#a5">ObCreateObject</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
04288                                  <a class="code" href="../../d3/d5/iodata_8c.html#a35">IoDeviceObjectType</a>,
04289                                  &amp;objectAttributes,
04290                                  <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
04291                                  (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
04292                                  (ULONG) <span class="keyword">sizeof</span>( <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">DEVICE_OBJECT</a> ) + <span class="keyword">sizeof</span> ( <a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html">DEVOBJ_EXTENSION</a> ) +
04293                                          RoundedSize,
04294                                  0,
04295                                  0,
04296                                  (PVOID *) &amp;deviceObject );
04297 
04298         <span class="keywordflow">if</span> ((status == STATUS_OBJECT_NAME_COLLISION) &amp;&amp;
04299             (DeviceCharacteristics &amp; FILE_AUTOGENERATED_DEVICE_NAME)) {
04300 
04301             <span class="comment">//</span>
04302             <span class="comment">// Some other driver is using our naming scheme, and we've picked a</span>
04303             <span class="comment">// device name already in use.  Try again, with a new number.</span>
04304             <span class="comment">//</span>
04305 
04306             retryWithNewName = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
04307         }
04308 
04309     } <span class="keywordflow">while</span> (retryWithNewName);
04310 
04311     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
04312 
04313         <span class="comment">//</span>
04314         <span class="comment">// Creating the device object was not successful.  Clean everything</span>
04315         <span class="comment">// up and indicate that the object was not created.</span>
04316         <span class="comment">//</span>
04317 
04318         deviceObject = (<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04319 
04320     } <span class="keywordflow">else</span> {
04321 
04322         <span class="comment">//</span>
04323         <span class="comment">// The device was successfully created.  Initialize the object so</span>
04324         <span class="comment">// that it can be inserted into the object table.  Begin by zeroing</span>
04325         <span class="comment">// the memory for the device object.</span>
04326         <span class="comment">//</span>
04327 
04328         RtlZeroMemory( deviceObject,
04329                        <span class="keyword">sizeof</span>( <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">DEVICE_OBJECT</a> ) + <span class="keyword">sizeof</span> ( <a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html">DEVOBJ_EXTENSION</a> ) +
04330                        RoundedSize );
04331 
04332         <span class="comment">//</span>
04333         <span class="comment">// Fill in deviceObject &amp; deviceObjectExtension cross pointers</span>
04334         <span class="comment">//</span>
04335 
04336         deviceObjectExt = (<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html">PDEVOBJ_EXTENSION</a>)  (((PCHAR) deviceObject) +
04337                             <span class="keyword">sizeof</span> (<a class="code" href="../../d0/d5/io_8h.html#a339">DEVICE_OBJECT</a>) + RoundedSize);
04338 
04339         deviceObjectExt-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o2">DeviceObject</a> = deviceObject;
04340         deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o25">DeviceObjectExtension</a> = deviceObjectExt;
04341 
04342         <span class="comment">//</span>
04343         <span class="comment">// Initialize deviceObjectExt</span>
04344         <span class="comment">// Note: the size of a Device Object Extension is initialized specifically</span>
04345         <span class="comment">// to ZERO so no driver will depend on it.</span>
04346         <span class="comment">//</span>
04347 
04348         deviceObjectExt-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o0">Type</a> = <a class="code" href="../../d0/d5/io_8h.html#a12">IO_TYPE_DEVICE_OBJECT_EXTENSION</a>;
04349         deviceObjectExt-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o1">Size</a> = 0;
04350 
04351         <a class="code" href="../../d1/d2/po_8h.html#a61">PoInitializeDeviceObject</a>(deviceObjectExt);
04352 
04353         <span class="comment">//</span>
04354         <span class="comment">// Set the type and size of this device object.</span>
04355         <span class="comment">//</span>
04356 
04357         deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o0">Type</a> = <a class="code" href="../../d0/d5/io_8h.html#a2">IO_TYPE_DEVICE</a>;
04358         deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o1">Size</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) (<span class="keyword">sizeof</span>( <a class="code" href="../../d0/d5/io_8h.html#a339">DEVICE_OBJECT</a> ) + DeviceExtensionSize);
04359 
04360         <span class="comment">//</span>
04361         <span class="comment">// Set the device type field in the object so that later code can</span>
04362         <span class="comment">// check the type.  Likewise, set the device characteristics.</span>
04363         <span class="comment">//</span>
04364 
04365         deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o12">DeviceType</a> = DeviceType;
04366         deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o9">Characteristics</a> = DeviceCharacteristics;
04367 
04368         <span class="comment">//</span>
04369         <span class="comment">// If this device is either a tape or a disk, allocate a Volume</span>
04370         <span class="comment">// Parameter Block (VPB) which indicates that the volume has</span>
04371         <span class="comment">// never been mounted, and set the device object's VPB pointer to</span>
04372         <span class="comment">// it.</span>
04373         <span class="comment">//</span>
04374 
04375         <span class="keywordflow">if</span> ((DeviceType == FILE_DEVICE_DISK) ||
04376             (DeviceType == FILE_DEVICE_TAPE) ||
04377             (DeviceType == FILE_DEVICE_CD_ROM) ||
04378             (DeviceType == FILE_DEVICE_VIRTUAL_DISK)) {
04379 
04380             <a class="code" href="../../d4/d6/iosubs_8c.html#a44">IopCreateVpb</a> (deviceObject);
04381             <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o22">DeviceLock</a>,
04382                                SynchronizationEvent,
04383                                <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
04384         }
04385 
04386         <span class="comment">//</span>
04387         <span class="comment">// Initialize the remainder of the device object.</span>
04388         <span class="comment">//</span>
04389         deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o17">AlignmentRequirement</a> = HalGetDmaAlignmentRequirement() - 1;
04390         deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o23">SectorSize</a> = sectorSize;
04391         deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o8">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a128">DO_DEVICE_INITIALIZING</a>;
04392 
04393         <span class="keywordflow">if</span> (Exclusive) {
04394             deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o8">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a124">DO_EXCLUSIVE</a>;
04395         }
04396         <span class="keywordflow">if</span> (deviceHasName) {
04397             deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o8">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a127">DO_DEVICE_HAS_NAME</a>;
04398         }
04399 
04400         <span class="keywordflow">if</span>(DeviceExtensionSize) {
04401             deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o11">DeviceExtension</a> = deviceObject + 1;
04402         } <span class="keywordflow">else</span> {
04403             deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o11">DeviceExtension</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04404         }
04405 
04406         deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o13">StackSize</a> = 1;
04407         <span class="keywordflow">switch</span> ( DeviceType ) {
04408 
04409         <span class="keywordflow">case</span> FILE_DEVICE_CD_ROM_FILE_SYSTEM:
04410         <span class="keywordflow">case</span> FILE_DEVICE_DISK_FILE_SYSTEM:
04411         <span class="keywordflow">case</span> FILE_DEVICE_FILE_SYSTEM:
04412         <span class="keywordflow">case</span> FILE_DEVICE_NETWORK_FILE_SYSTEM:
04413         <span class="keywordflow">case</span> FILE_DEVICE_TAPE_FILE_SYSTEM:
04414 
04415             <span class="comment">//</span>
04416             <span class="comment">// This device represents a file system of some sort.  Simply</span>
04417             <span class="comment">// initialize the queue list head in the device object.</span>
04418             <span class="comment">//</span>
04419 
04420             InitializeListHead( &amp;deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o16">Queue</a>.ListEntry );
04421             <span class="keywordflow">break</span>;
04422 
04423         <span class="keywordflow">default</span>:
04424 
04425             <span class="comment">//</span>
04426             <span class="comment">// This is a real device of some sort.  Allocate a spin lock</span>
04427             <span class="comment">// and initialize the device queue object in the device object.</span>
04428             <span class="comment">//</span>
04429 
04430             <a class="code" href="../../d7/d7/devquobj_8c.html#a1">KeInitializeDeviceQueue</a>( &amp;deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o18">DeviceQueue</a> );
04431             <span class="keywordflow">break</span>;
04432         }
04433 
04434         <span class="comment">//</span>
04435         <span class="comment">// Insert the device object into the table.</span>
04436         <span class="comment">//</span>
04437 
04438         status = <a class="code" href="../../d1/d1/obinsert_8c.html#a0">ObInsertObject</a>( deviceObject,
04439                                  <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
04440                                  FILE_READ_DATA | FILE_WRITE_DATA,
04441                                  1,
04442                                  (PVOID *) &amp;deviceObject,
04443                                  &amp;handle );
04444 
04445         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
04446 
04447             <span class="comment">//</span>
04448             <span class="comment">// Reference the driver object.   When the device object goes</span>
04449             <span class="comment">// away the reference will be removed.  This prevents the</span>
04450             <span class="comment">// driver object and driver image from going away while the</span>
04451             <span class="comment">// device object is in the pending delete state.</span>
04452             <span class="comment">//</span>
04453 
04454             <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a>( DriverObject );
04455 
04456             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>((DriverObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a143">DRVO_UNLOAD_INVOKED</a>) == 0);
04457 
04458             <span class="comment">//</span>
04459             <span class="comment">// The insert completed successfully.  Link the device object</span>
04460             <span class="comment">// and driver objects together.  Close the handle so that if</span>
04461             <span class="comment">// the driver is unloaded, the device object can go away.</span>
04462             <span class="comment">//</span>
04463 
04464             deviceObject-&gt;DriverObject = DriverObject;
04465 
04466             <a class="code" href="../../d4/d6/iosubs_8c.html#a43">IopInsertRemoveDevice</a>( DriverObject, deviceObject, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
04467             <span class="keywordflow">if</span> (deviceObject-&gt;Vpb) {
04468                 <a class="code" href="../../d1/d2/po_8h.html#a70">PoVolumeDevice</a>(deviceObject);
04469             }
04470 
04471             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>( handle );
04472 
04473         } <span class="keywordflow">else</span> {
04474 
04475             <span class="comment">//</span>
04476             <span class="comment">// The insert operation failed.  Fortunately it dropped the</span>
04477             <span class="comment">// reference count on the device - since that was the last one</span>
04478             <span class="comment">// all the cleanup should be done for us.</span>
04479             <span class="comment">//</span>
04480 
04481             <span class="comment">//</span>
04482             <span class="comment">// indicate that no device object was created.</span>
04483             <span class="comment">//</span>
04484 
04485             deviceObject = (<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04486         }
04487     }
04488 
04489     <span class="comment">//</span>
04490     <span class="comment">// Free the DACL if we allocated it...</span>
04491     <span class="comment">//</span>
04492 
04493     <span class="keywordflow">if</span> (acl != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04494         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( acl );
04495     }
04496 
04497     *DeviceObject = deviceObject;
04498     <span class="keywordflow">return</span> status;
04499 }
04500 
04501 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l04502"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a46">04502</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a46">IoCreateFile</a>(
04503     OUT PHANDLE FileHandle,
04504     IN ACCESS_MASK DesiredAccess,
04505     IN POBJECT_ATTRIBUTES ObjectAttributes,
04506     OUT PIO_STATUS_BLOCK IoStatusBlock,
04507     IN PLARGE_INTEGER AllocationSize OPTIONAL,
04508     IN ULONG FileAttributes,
04509     IN ULONG ShareAccess,
04510     IN ULONG Disposition,
04511     IN ULONG CreateOptions,
04512     IN PVOID EaBuffer OPTIONAL,
04513     IN ULONG EaLength,
04514     IN CREATE_FILE_TYPE CreateFileType,
04515     IN PVOID ExtraCreateParameters OPTIONAL,
04516     IN ULONG Options
04517     )
04518 
04519 <span class="comment">/*++</span>
04520 <span class="comment"></span>
04521 <span class="comment">Routine Description:</span>
04522 <span class="comment"></span>
04523 <span class="comment">    This is the common routine for both NtCreateFile and NtOpenFile to allow</span>
04524 <span class="comment">    a user to create or open a file.  This procedure is also used internally</span>
04525 <span class="comment">    by kernel mode components, such as the network server, to perform the</span>
04526 <span class="comment">    same type of operation, but allows kernel mode code to force checking</span>
04527 <span class="comment">    arguments and access to the file, rather than bypassing these checks</span>
04528 <span class="comment">    because the code is running in kernel mode.</span>
04529 <span class="comment"></span>
04530 <span class="comment">Arguments:</span>
04531 <span class="comment"></span>
04532 <span class="comment">    FileHandle - A pointer to a variable to receive the handle to the open</span>
04533 <span class="comment">        file.</span>
04534 <span class="comment"></span>
04535 <span class="comment">    DesiredAccess - Supplies the types of access that the caller would like</span>
04536 <span class="comment">        to the file.</span>
04537 <span class="comment"></span>
04538 <span class="comment">    ObjectAttributes - Supplies the attributes to be used for the file object</span>
04539 <span class="comment">        (name, SECURITY_DESCRIPTOR, etc.)</span>
04540 <span class="comment"></span>
04541 <span class="comment">    IoStatusBlock - Specifies the address of the caller's I/O status block.</span>
04542 <span class="comment"></span>
04543 <span class="comment">    AllocationSize - Initial size that should be allocated to the file.</span>
04544 <span class="comment">        This parameter only has an affect if the file is created.  Further,</span>
04545 <span class="comment">        if not specified, then it is taken to mean zero.</span>
04546 <span class="comment"></span>
04547 <span class="comment">    FileAttributes - Specifies the attributes that should be set on the file,</span>
04548 <span class="comment">        if it is created.</span>
04549 <span class="comment"></span>
04550 <span class="comment">    ShareAccess - Supplies the types of share access that the caller would</span>
04551 <span class="comment">        like to the file.</span>
04552 <span class="comment"></span>
04553 <span class="comment">    Disposition - Supplies the method for handling the create/open.</span>
04554 <span class="comment"></span>
04555 <span class="comment">    CreateOptions - Caller options for how to perform the create/open.</span>
04556 <span class="comment"></span>
04557 <span class="comment">    EaBuffer - Optionally specifies a set of EAs to be applied to the file</span>
04558 <span class="comment">        if it is created.</span>
04559 <span class="comment"></span>
04560 <span class="comment">    EaLength - Supplies the length of the EaBuffer.</span>
04561 <span class="comment"></span>
04562 <span class="comment">    CreateFileType - The type of file to create.</span>
04563 <span class="comment"></span>
04564 <span class="comment">    ExtraCreateParameters - Optionally specifies a pointer to extra create</span>
04565 <span class="comment">        parameters.  The format of the parameters depends on the value of</span>
04566 <span class="comment">        CreateFileType.</span>
04567 <span class="comment"></span>
04568 <span class="comment">    Options - Specifies the options that are to be used during generation</span>
04569 <span class="comment">        of the create IRP.</span>
04570 <span class="comment"></span>
04571 <span class="comment">Return Value:</span>
04572 <span class="comment"></span>
04573 <span class="comment">    The function value is the final status of the create/open operation.</span>
04574 <span class="comment"></span>
04575 <span class="comment">Warning:</span>
04576 <span class="comment"></span>
04577 <span class="comment">    If a pointer to ExtraCreateParameters is passed the data must be</span>
04578 <span class="comment">    readable from kernel mode.</span>
04579 <span class="comment"></span>
04580 <span class="comment"></span>
04581 <span class="comment">--*/</span>
04582 
04583 {
04584     <a class="code" href="../../d0/d9/ntosdef_8h.html#a39">KPROCESSOR_MODE</a> requestorMode;
04585     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
04586     HANDLE handle;
04587     <a class="code" href="../../d3/d7/struct__OPEN__PACKET.html">OPEN_PACKET</a> openPacket;
04588     BOOLEAN SuccessfulIoParse;
04589     LARGE_INTEGER initialAllocationSize;
04590 
04591     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
04592 
04593     <span class="comment">//</span>
04594     <span class="comment">// Get the previous mode;  i.e., the mode of the caller.</span>
04595     <span class="comment">//</span>
04596 
04597     requestorMode = KeGetPreviousMode();
04598 
04599     <span class="keywordflow">if</span> (Options &amp; <a class="code" href="../../d0/d5/io_8h.html#a107">IO_NO_PARAMETER_CHECKING</a>) {
04600         requestorMode = <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>;
04601     }
04602 
04603     <span class="keywordflow">if</span> (requestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a> || Options &amp; <a class="code" href="../../d0/d5/io_8h.html#a110">IO_CHECK_CREATE_PARAMETERS</a>) {
04604 
04605         <span class="comment">//</span>
04606         <span class="comment">// Check for any invalid parameters.</span>
04607         <span class="comment">//</span>
04608 
04609         <span class="keywordflow">if</span> (
04610 
04611             <span class="comment">//</span>
04612             <span class="comment">// Check that no invalid file attributes flags were specified.</span>
04613             <span class="comment">//</span>
04614 
04615 <span class="comment">//          (FileAttributes &amp; ~FILE_ATTRIBUTE_VALID_SET_FLAGS)</span>
04616             (<a class="code" href="../../d2/d2/rtload_8c.html#a5">FileAttributes</a> &amp; ~FILE_ATTRIBUTE_VALID_FLAGS)
04617 
04618             ||
04619 
04620             <span class="comment">//</span>
04621             <span class="comment">// Check that no invalid share access flags were specified.</span>
04622             <span class="comment">//</span>
04623 
04624             (ShareAccess &amp; ~FILE_SHARE_VALID_FLAGS)
04625 
04626             ||
04627 
04628             <span class="comment">//</span>
04629             <span class="comment">// Ensure that the disposition value is in range.</span>
04630             <span class="comment">//</span>
04631 
04632             (Disposition &gt; FILE_MAXIMUM_DISPOSITION)
04633 
04634             ||
04635 
04636             <span class="comment">//</span>
04637             <span class="comment">// Check that no invalid create options were specified.</span>
04638             <span class="comment">//</span>
04639 
04640             (CreateOptions &amp; ~FILE_VALID_OPTION_FLAGS)
04641 
04642             ||
04643 
04644             <span class="comment">//</span>
04645             <span class="comment">// If the caller specified synchronous I/O, then ensure that</span>
04646             <span class="comment">// (s)he also asked for synchronize desired access to the</span>
04647             <span class="comment">// file.</span>
04648             <span class="comment">//</span>
04649 
04650             (CreateOptions &amp; (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT) &amp;&amp;
04651             (!(DesiredAccess &amp; SYNCHRONIZE)))
04652 
04653             ||
04654 
04655             <span class="comment">//</span>
04656             <span class="comment">// Also, if the caller specified that the file is to be deleted</span>
04657             <span class="comment">// on close, then ensure that delete is specified as one of the</span>
04658             <span class="comment">// desired accesses requested.</span>
04659             <span class="comment">//</span>
04660 
04661             (CreateOptions &amp; FILE_DELETE_ON_CLOSE &amp;&amp;
04662             (!(DesiredAccess &amp; DELETE)))
04663 
04664             ||
04665 
04666             <span class="comment">//</span>
04667             <span class="comment">// Likewise, ensure that if one of the synchronous I/O modes</span>
04668             <span class="comment">// is specified that the other one is not specified as well.</span>
04669             <span class="comment">//</span>
04670 
04671             ((CreateOptions &amp; (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT)) ==
04672                               (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT))
04673 
04674             ||
04675 
04676             <span class="comment">//</span>
04677             <span class="comment">// If this create or open is for a directory operation, check</span>
04678             <span class="comment">// that all of the other flags, dispositions, and desired</span>
04679             <span class="comment">// access parameters were also specified correctly.</span>
04680             <span class="comment">//</span>
04681             <span class="comment">// These are as follows:</span>
04682             <span class="comment">//</span>
04683             <span class="comment">//     o  No other flags other than the synchronous I/O flags,</span>
04684             <span class="comment">//        write-through, or open by file ID are set.</span>
04685             <span class="comment">//</span>
04686             <span class="comment">//     o  The disposition value is one of create, open, or</span>
04687             <span class="comment">//        open-if.</span>
04688             <span class="comment">//</span>
04689             <span class="comment">//     o  No non-directory accesses have been specified.</span>
04690             <span class="comment">//</span>
04691 
04692             ((CreateOptions &amp; FILE_DIRECTORY_FILE)
04693              &amp;&amp; !(CreateOptions &amp; FILE_NON_DIRECTORY_FILE)
04694              &amp;&amp; ((CreateOptions &amp; ~(FILE_DIRECTORY_FILE |
04695                                     FILE_SYNCHRONOUS_IO_ALERT |
04696                                     FILE_SYNCHRONOUS_IO_NONALERT |
04697                                     FILE_WRITE_THROUGH |
04698                                     FILE_COMPLETE_IF_OPLOCKED |
04699                                     FILE_OPEN_FOR_BACKUP_INTENT |
04700                                     FILE_DELETE_ON_CLOSE |
04701                                     FILE_OPEN_FOR_FREE_SPACE_QUERY |
04702                                     FILE_OPEN_BY_FILE_ID |
04703                                     FILE_OPEN_REPARSE_POINT))
04704                  || ((Disposition != FILE_CREATE)
04705                      &amp;&amp; (Disposition != FILE_OPEN)
04706                      &amp;&amp; (Disposition != FILE_OPEN_IF))
04707                 )
04708             )
04709 
04710             ||
04711 
04712             <span class="comment">//</span>
04713             <span class="comment">//  FILE_COMPLETE_IF_OPLOCK and FILE_RESERVE_OPFILTER are</span>
04714             <span class="comment">//  incompatible options.</span>
04715             <span class="comment">//</span>
04716 
04717             ((CreateOptions &amp; FILE_COMPLETE_IF_OPLOCKED) &amp;&amp;
04718              (CreateOptions &amp; FILE_RESERVE_OPFILTER))
04719 
04720             ||
04721 
04722             <span class="comment">//</span>
04723             <span class="comment">// Finally, if the no intermediate buffering option was</span>
04724             <span class="comment">// specified, ensure that the caller did not also request</span>
04725             <span class="comment">// append access to the file.</span>
04726             <span class="comment">//</span>
04727 
04728             (CreateOptions &amp; FILE_NO_INTERMEDIATE_BUFFERING &amp;&amp;
04729             (DesiredAccess &amp; FILE_APPEND_DATA)) ) {
04730 
04731             <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
04732         }
04733 
04734         <span class="comment">//</span>
04735         <span class="comment">// Check the file type specific creation parameters.</span>
04736         <span class="comment">//</span>
04737 
04738         <span class="keywordflow">if</span> (CreateFileType == <a class="code" href="../../d0/d5/io_8h.html#a600a406">CreateFileTypeNone</a>) {
04739 
04740             NOTHING;
04741 
04742         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (CreateFileType == <a class="code" href="../../d0/d5/io_8h.html#a600a407">CreateFileTypeNamedPipe</a>) {
04743 
04744             <span class="keywordflow">if</span> (!ARGUMENT_PRESENT( ExtraCreateParameters ) ) {
04745 
04746                 <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
04747 
04748             } <span class="keywordflow">else</span> {
04749 
04750                 <a class="code" href="../../d3/d1/struct__NAMED__PIPE__CREATE__PARAMETERS.html">PNAMED_PIPE_CREATE_PARAMETERS</a> NamedPipeCreateParameters;
04751 
04752                 NamedPipeCreateParameters = ExtraCreateParameters;
04753 
04754                 <span class="comment">//</span>
04755                 <span class="comment">// Check the parameters for creating a named pipe to</span>
04756                 <span class="comment">// ensure that no invalid parameters were passed.</span>
04757                 <span class="comment">//</span>
04758 
04759                 <span class="keywordflow">if</span> (
04760 
04761                     <span class="comment">//</span>
04762                     <span class="comment">// Check the NamedPipeType field to ensure that it</span>
04763                     <span class="comment">// is within range.</span>
04764                     <span class="comment">//</span>
04765 
04766                     (NamedPipeCreateParameters-&gt;<a class="code" href="../../d3/d1/struct__NAMED__PIPE__CREATE__PARAMETERS.html#o0">NamedPipeType</a> &gt;
04767                         FILE_PIPE_MESSAGE_TYPE)
04768 
04769                     ||
04770 
04771                     <span class="comment">//</span>
04772                     <span class="comment">// Check the ReadMode field to ensure that it is</span>
04773                     <span class="comment">// within range.</span>
04774                     <span class="comment">//</span>
04775 
04776                     (NamedPipeCreateParameters-&gt;<a class="code" href="../../d3/d1/struct__NAMED__PIPE__CREATE__PARAMETERS.html#o1">ReadMode</a> &gt;
04777                         FILE_PIPE_MESSAGE_MODE)
04778 
04779                     ||
04780 
04781                     <span class="comment">//</span>
04782                     <span class="comment">// Check the CompletionMode field to ensure that</span>
04783                     <span class="comment">// it is within range.</span>
04784                     <span class="comment">//</span>
04785 
04786                     (NamedPipeCreateParameters-&gt;<a class="code" href="../../d3/d1/struct__NAMED__PIPE__CREATE__PARAMETERS.html#o2">CompletionMode</a> &gt;
04787                         FILE_PIPE_COMPLETE_OPERATION)
04788 
04789                     ||
04790 
04791                     <span class="comment">//</span>
04792                     <span class="comment">// Check the ShareAccess parameter to ensure that</span>
04793                     <span class="comment">// it does not specify shared delete access.  The</span>
04794                     <span class="comment">// Named Pipe File System itself will need to ensure</span>
04795                     <span class="comment">// that at least one of SHARE_READ or SHARE_WRITE</span>
04796                     <span class="comment">// is specified if the first instance of the pipe</span>
04797                     <span class="comment">// is being created.</span>
04798                     <span class="comment">//</span>
04799 
04800                     (ShareAccess &amp; FILE_SHARE_DELETE)
04801 
04802                     ||
04803 
04804                     <span class="comment">//</span>
04805                     <span class="comment">// Check the Disposition parameter to ensure that</span>
04806                     <span class="comment">// is does not specify anything other than create,</span>
04807                     <span class="comment">// open, or open if.</span>
04808                     <span class="comment">//</span>
04809 
04810                     (Disposition &lt; FILE_OPEN || Disposition &gt; FILE_OPEN_IF)
04811 
04812                     ||
04813 
04814                     <span class="comment">//</span>
04815                     <span class="comment">// Finally, check the CreateOptions parameter to</span>
04816                     <span class="comment">// ensure that it does not contain any invalid</span>
04817                     <span class="comment">// options for named pipes.</span>
04818                     <span class="comment">//</span>
04819 
04820                     (CreateOptions &amp; ~FILE_VALID_PIPE_OPTION_FLAGS)) {
04821                     <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
04822                 }
04823 
04824             }
04825 
04826         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (CreateFileType == <a class="code" href="../../d0/d5/io_8h.html#a600a408">CreateFileTypeMailslot</a>) {
04827 
04828             <span class="keywordflow">if</span> (!ARGUMENT_PRESENT( ExtraCreateParameters ) ) {
04829 
04830                 <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
04831 
04832             } <span class="keywordflow">else</span> {
04833 
04834                 <a class="code" href="../../d2/d6/struct__MAILSLOT__CREATE__PARAMETERS.html">PMAILSLOT_CREATE_PARAMETERS</a> mailslotCreateParameters;
04835 
04836                 mailslotCreateParameters = ExtraCreateParameters;
04837 
04838                 <span class="comment">//</span>
04839                 <span class="comment">// Check the parameters for creating a mailslot to ensure</span>
04840                 <span class="comment">// that no invalid parameters were passed.</span>
04841                 <span class="comment">//</span>
04842 
04843                 <span class="keywordflow">if</span> (
04844 
04845                     <span class="comment">//</span>
04846                     <span class="comment">// Check the ShareAccess parameter to ensure that</span>
04847                     <span class="comment">// it does not specify shared delete access.</span>
04848                     <span class="comment">//</span>
04849 
04850                     (ShareAccess &amp; FILE_SHARE_DELETE)
04851 
04852                     ||
04853 
04854                     <span class="comment">//</span>
04855                     <span class="comment">// Check the ShareAccess parameter to ensure that</span>
04856                     <span class="comment">// shared write access is specified.</span>
04857                     <span class="comment">//</span>
04858 
04859                     !(ShareAccess &amp; ~FILE_SHARE_WRITE)
04860 
04861                     ||
04862 
04863                     <span class="comment">//</span>
04864                     <span class="comment">// Check the Disposition parameter to ensure that</span>
04865                     <span class="comment">// it specifies that the file is to be created.</span>
04866                     <span class="comment">//</span>
04867 
04868                     (Disposition != FILE_CREATE)
04869 
04870                     ||
04871 
04872                     <span class="comment">//</span>
04873                     <span class="comment">// Check the CreateOptions parameter to ensure that</span>
04874                     <span class="comment">// it does not contain any options that are invalid</span>
04875                     <span class="comment">// for mailslots.</span>
04876                     <span class="comment">//</span>
04877 
04878                     (CreateOptions &amp; ~FILE_VALID_MAILSLOT_OPTION_FLAGS)) {
04879                     <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
04880                 }
04881             }
04882         }
04883     }
04884 
04885     <span class="keywordflow">if</span> (requestorMode != <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
04886 
04887         <span class="comment">//</span>
04888         <span class="comment">// The caller's access mode is not kernel so probe each of the</span>
04889         <span class="comment">// arguments and capture them as necessary.  If any failures occur,</span>
04890         <span class="comment">// the condition handler will be invoked to handle them.  It will</span>
04891         <span class="comment">// simply cleanup and return an access violation status code back</span>
04892         <span class="comment">// to the system service dispatcher.</span>
04893         <span class="comment">//</span>
04894 
04895         openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o11">EaBuffer</a> = (PFILE_FULL_EA_INFORMATION) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04896 
04897         <span class="keywordflow">try</span> {
04898 
04899             <span class="comment">//</span>
04900             <span class="comment">// The FileHandle parameter must be writeable by the caller.</span>
04901             <span class="comment">// Probe it for a write operation.</span>
04902             <span class="comment">//</span>
04903 
04904             <a class="code" href="../../d5/d8/ex_8h.html#a49">ProbeAndWriteHandle</a>( FileHandle, 0<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a> );
04905 
04906             <span class="comment">//</span>
04907             <span class="comment">// The IoStatusBlock parameter must be writeable by the caller.</span>
04908             <span class="comment">//</span>
04909 
04910             <a class="code" href="../../d5/d8/ex_8h.html#a31">ProbeForWriteIoStatus</a>( IoStatusBlock );
04911 
04912             <span class="comment">//</span>
04913             <span class="comment">// The AllocationSize parameter must be readable by the caller</span>
04914             <span class="comment">// if it is present.  If so, probe and capture it.</span>
04915             <span class="comment">//</span>
04916 
04917             <span class="keywordflow">if</span> (ARGUMENT_PRESENT( AllocationSize )) {
04918                 <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( AllocationSize,
04919                               <span class="keyword">sizeof</span>( LARGE_INTEGER ),
04920                               <span class="keyword">sizeof</span>( ULONG ) );
04921                 initialAllocationSize = *AllocationSize;
04922             } <span class="keywordflow">else</span> {
04923                 initialAllocationSize.QuadPart = 0;
04924             }
04925 
04926         } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
04927 
04928             <span class="comment">//</span>
04929             <span class="comment">// An exception was incurred while attempting to access the</span>
04930             <span class="comment">// caller's parameters.  Simply return the reason for the</span>
04931             <span class="comment">// exception as the service status.</span>
04932             <span class="comment">//</span>
04933 
04934             <span class="keywordflow">return</span> GetExceptionCode();
04935         }
04936 
04937         <span class="comment">//</span>
04938         <span class="comment">// Finally, if an EaBuffer was specified, ensure that it is readable</span>
04939         <span class="comment">// from the caller's mode and capture it.</span>
04940         <span class="comment">//</span>
04941 
04942         <span class="keywordflow">if</span> (ARGUMENT_PRESENT( EaBuffer ) &amp;&amp; EaLength) {
04943 
04944             ULONG errorOffset;
04945 
04946             <span class="keywordflow">try</span> {
04947 
04948                 <a class="code" href="../../d5/d8/ex_8h.html#a11">ProbeForRead</a>( EaBuffer, EaLength, <span class="keyword">sizeof</span>( ULONG ) );
04949                 openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o11">EaBuffer</a> = <a class="code" href="../../d5/d8/ex_8h.html#a5">ExAllocatePoolWithQuotaTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
04950                                                                   EaLength,
04951                                                                   'aEoI' );
04952                 openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o12">EaLength</a> = EaLength;
04953                 RtlCopyMemory( openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o11">EaBuffer</a>, EaBuffer, EaLength );
04954 
04955                 <span class="comment">//</span>
04956                 <span class="comment">// Walk the buffer and ensure that its format is valid.  Note</span>
04957                 <span class="comment">// that has been probed.</span>
04958                 <span class="comment">//</span>
04959 
04960                 status = <a class="code" href="../../d4/d6/iosubs_8c.html#a33">IoCheckEaBufferValidity</a>( openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o11">EaBuffer</a>,
04961                                                   EaLength,
04962                                                   &amp;errorOffset );
04963 
04964                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
04965                     IoStatusBlock-&gt;Status = status;
04966                     IoStatusBlock-&gt;Information = errorOffset;
04967                     <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( status );
04968                 }
04969 
04970             } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
04971 
04972                 <span class="comment">//</span>
04973                 <span class="comment">// An exception was incurred while attempting to access the</span>
04974                 <span class="comment">// caller's parameters.  Check to see whether or not an EA</span>
04975                 <span class="comment">// buffer was allocated and deallocate if so.</span>
04976                 <span class="comment">//</span>
04977 
04978                 <span class="keywordflow">if</span> (openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o11">EaBuffer</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
04979                     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o11">EaBuffer</a> );
04980                 }
04981 
04982                 <span class="keywordflow">return</span> GetExceptionCode();
04983 
04984             }
04985 
04986         } <span class="keywordflow">else</span> {
04987 
04988             <span class="comment">//</span>
04989             <span class="comment">// No EAs were specified.</span>
04990             <span class="comment">//</span>
04991 
04992             openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o11">EaBuffer</a> = (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
04993             openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o12">EaLength</a> = 0<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>;
04994         }
04995 
04996     } <span class="keywordflow">else</span> {
04997 
04998         <span class="comment">//</span>
04999         <span class="comment">// The caller's mode is kernel.  Copy the input parameters to their</span>
05000         <span class="comment">// expected locations for later use.  Also, put move attach device</span>
05001         <span class="comment">// flag where it belongs.</span>
05002         <span class="comment">//</span>
05003 
05004         <span class="keywordflow">if</span> (CreateOptions &amp; <a class="code" href="../../d0/d5/io_8h.html#a112">IO_ATTACH_DEVICE_API</a>) {
05005             Options |= <a class="code" href="../../d0/d5/io_8h.html#a111">IO_ATTACH_DEVICE</a>;
05006             CreateOptions &amp;= ~<a class="code" href="../../d0/d5/io_8h.html#a112">IO_ATTACH_DEVICE_API</a>;
05007 
05008         }
05009 
05010         <span class="keywordflow">if</span> (ARGUMENT_PRESENT( AllocationSize )) {
05011             initialAllocationSize = *AllocationSize;
05012         } <span class="keywordflow">else</span> {
05013             initialAllocationSize.QuadPart = 0;
05014         }
05015 
05016         <span class="keywordflow">if</span> (ARGUMENT_PRESENT( EaBuffer ) &amp;&amp; EaLength) {
05017 
05018             ULONG errorOffset;
05019 
05020             openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o11">EaBuffer</a> = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
05021                                                          EaLength,
05022                                                          'aEoI' );
05023             <span class="keywordflow">if</span> (!openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o11">EaBuffer</a>) {
05024                 <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
05025             }
05026             openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o12">EaLength</a> = EaLength;
05027             RtlCopyMemory( openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o11">EaBuffer</a>, EaBuffer, EaLength );
05028 
05029             <span class="comment">//</span>
05030             <span class="comment">// Walk the buffer and ensure that its format is valid.  Note</span>
05031             <span class="comment">// that has been probed.</span>
05032             <span class="comment">//</span>
05033 
05034             status = <a class="code" href="../../d4/d6/iosubs_8c.html#a33">IoCheckEaBufferValidity</a>( openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o11">EaBuffer</a>,
05035                                               EaLength,
05036                                               &amp;errorOffset );
05037 
05038             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
05039                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o11">EaBuffer</a>);
05040                 IoStatusBlock-&gt;Status = status;
05041                 IoStatusBlock-&gt;Information = errorOffset;
05042                 <span class="keywordflow">return</span> status;
05043             }
05044 
05045         } <span class="keywordflow">else</span> {
05046             openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o11">EaBuffer</a> = (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05047             openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o12">EaLength</a> = 0<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>;
05048         }
05049     }
05050 
05051     <span class="comment">//</span>
05052     <span class="comment">// Now fill in an Open Packet (OP) to be used in calling the device object</span>
05053     <span class="comment">// parse routine.  This packet will allow information to be passed between</span>
05054     <span class="comment">// this routine and the parse routine so that a common context may be kept.</span>
05055     <span class="comment">// For most services this would be done with an I/O Request Packet (IRP),</span>
05056     <span class="comment">// but this cannot be done here because the number of stack entries which</span>
05057     <span class="comment">// need to be allocated in the IRP is not yet known.</span>
05058     <span class="comment">//</span>
05059 
05060     openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o0">Type</a> = <a class="code" href="../../d0/d5/io_8h.html#a7">IO_TYPE_OPEN_PACKET</a>;
05061     openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o1">Size</a> = <span class="keyword">sizeof</span>( <a class="code" href="../../d3/d7/struct__OPEN__PACKET.html">OPEN_PACKET</a> );
05062     openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o5">ParseCheck</a> = 0<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>;
05063     openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o7">AllocationSize</a> = initialAllocationSize;
05064     openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o8">CreateOptions</a> = CreateOptions;
05065     openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o9">FileAttributes</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) <a class="code" href="../../d2/d2/rtload_8c.html#a5">FileAttributes</a>;
05066     openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o10">ShareAccess</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) ShareAccess;
05067     openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o14">Disposition</a> = Disposition;
05068     openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o19">Override</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
05069     openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o20">QueryOnly</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
05070     openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o21">DeleteOnly</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
05071     openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o13">Options</a> = Options;
05072     openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o6">RelatedFileObject</a> = (<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05073     openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o17">CreateFileType</a> = CreateFileType;
05074     openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o18">ExtraCreateParameters</a> = ExtraCreateParameters;
05075 
05076     <span class="comment">//</span>
05077     <span class="comment">// Assume that the operation is going to be successful.</span>
05078     <span class="comment">//</span>
05079 
05080     openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o3">FinalStatus</a> = STATUS_SUCCESS;
05081 
05082     <span class="comment">//</span>
05083     <span class="comment">// Zero the file object field in the OP so the parse routine knows that</span>
05084     <span class="comment">// this is the first time through.  For reparse operations it will continue</span>
05085     <span class="comment">// to use the same file object that it allocated the first time.</span>
05086     <span class="comment">//</span>
05087 
05088     openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o2">FileObject</a> = (<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05089 
05090     <span class="comment">//</span>
05091     <span class="comment">// Update the open count for this process.</span>
05092     <span class="comment">//</span>
05093 
05094     <a class="code" href="../../d4/d6/iosubs_8c.html#a129">IopUpdateOtherOperationCount</a>();
05095 
05096     <span class="comment">//</span>
05097     <span class="comment">// Attempt to open the file object by name.  This will yield the handle</span>
05098     <span class="comment">// that the user is to use as his handle to the file in all subsequent</span>
05099     <span class="comment">// calls, if it works.</span>
05100     <span class="comment">//</span>
05101     <span class="comment">// This call performs a whole lot of the work for actually getting every-</span>
05102     <span class="comment">// thing set up for the I/O system.  The object manager will take the name</span>
05103     <span class="comment">// of the file and will translate it until it reaches a device object (or</span>
05104     <span class="comment">// it fails).  If the former, then it will invoke the parse routine set up</span>
05105     <span class="comment">// by the I/O system for device objects.  This routine will actually end</span>
05106     <span class="comment">// up creating the file object, allocating an IRP, filling it in, and then</span>
05107     <span class="comment">// invoking the driver's dispatch routine with the packet.</span>
05108     <span class="comment">//</span>
05109 
05110     status = <a class="code" href="../../d7/d1/obref_8c.html#a2">ObOpenObjectByName</a>( <a class="code" href="../../d7/d0/ctlnpqos_8c.html#a4">ObjectAttributes</a>,
05111                                  (<a class="code" href="../../d3/d6/struct__OBJECT__TYPE.html">POBJECT_TYPE</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
05112                                  requestorMode,
05113                                  <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
05114                                  DesiredAccess,
05115                                  &amp;openPacket,
05116                                  &amp;handle );
05117 
05118     <span class="comment">//</span>
05119     <span class="comment">// If an EA buffer was allocated, deallocate it now before attempting to</span>
05120     <span class="comment">// determine whether or not the operation was successful so that it can be</span>
05121     <span class="comment">// done in one place rather than in two places.</span>
05122     <span class="comment">//</span>
05123 
05124     <span class="keywordflow">if</span> (openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o11">EaBuffer</a>) {
05125         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o11">EaBuffer</a> );
05126     }
05127 
05128     <span class="comment">//</span>
05129     <span class="comment">// Check the status of the open.  If it was not successful, cleanup and</span>
05130     <span class="comment">// get out.  Notice that it is also possible, because this code does not</span>
05131     <span class="comment">// explicitly request that a particular type of object (because the Object</span>
05132     <span class="comment">// Manager does not check when a parse routine is present and because the</span>
05133     <span class="comment">// name first refers to a device object and then a file object), a check</span>
05134     <span class="comment">// must be made here to ensure that what was returned was really a file</span>
05135     <span class="comment">// object.  The check is to see whether the device object parse routine</span>
05136     <span class="comment">// believes that it successfully returned a pointer to a file object.  If</span>
05137     <span class="comment">// it does, then OK;  otherwise, something went wrong somewhere.</span>
05138     <span class="comment">//</span>
05139 
05140     SuccessfulIoParse = (BOOLEAN) (openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o5">ParseCheck</a> == <a class="code" href="../../d0/d6/iop_8h.html#a3">OPEN_PACKET_PATTERN</a>);
05141 
05142     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status ) || !SuccessfulIoParse) {
05143 
05144         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
05145 
05146             <span class="comment">//</span>
05147             <span class="comment">// The operation was successful as far as the object system is</span>
05148             <span class="comment">// concerned, but the I/O system device parse routine was never</span>
05149             <span class="comment">// successfully completed so this operation has actually completed</span>
05150             <span class="comment">// with an error because of an object mismatch.  Therefore, this is</span>
05151             <span class="comment">// the wrong type of object so dereference whatever was actually</span>
05152             <span class="comment">// referenced by closing the handle that was created for it.</span>
05153             <span class="comment">// We have to do a ZwClose as this handle can be a kernel handle if</span>
05154             <span class="comment">// IoCreateFile was called by a driver.</span>
05155             <span class="comment">//</span>
05156 
05157             ZwClose( handle );
05158             status = STATUS_OBJECT_TYPE_MISMATCH;
05159         }
05160 
05161         <span class="comment">//</span>
05162         <span class="comment">// If the final status according to the device parse routine</span>
05163         <span class="comment">// indicates that the operation was not successful, then use that</span>
05164         <span class="comment">// routine's final status because it is more descriptive than the</span>
05165         <span class="comment">// status which was returned by the object manager.</span>
05166         <span class="comment">//</span>
05167 
05168         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o3">FinalStatus</a> )) {
05169             status = openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o3">FinalStatus</a>;
05170 
05171             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a2">NT_WARNING</a>( status )) {
05172 
05173                 <span class="keywordflow">try</span> {
05174 
05175                     IoStatusBlock-&gt;Status = openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o3">FinalStatus</a>;
05176                     IoStatusBlock-&gt;Information = openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o4">Information</a>;
05177 
05178                 } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
05179 
05180                     status = GetExceptionCode();
05181 
05182                 }
05183 
05184             }
05185 
05186         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o2">FileObject</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> &amp;&amp; !SuccessfulIoParse) {
05187 
05188             <span class="comment">//</span>
05189             <span class="comment">// Otherwise, one of two things occurred:</span>
05190             <span class="comment">//</span>
05191             <span class="comment">//     1)  The parse routine was invoked at least once and a</span>
05192             <span class="comment">//         reparse was performed but the parse routine did not</span>
05193             <span class="comment">//         actually complete.</span>
05194             <span class="comment">//</span>
05195             <span class="comment">//     2)  The parse routine was successful so everything worked</span>
05196             <span class="comment">//         but the object manager incurred an error after the</span>
05197             <span class="comment">//         parse routine completed.</span>
05198             <span class="comment">//</span>
05199             <span class="comment">// For case #1, there is an outstanding file object that still</span>
05200             <span class="comment">// exists.  This must be cleaned up.</span>
05201             <span class="comment">//</span>
05202             <span class="comment">// For case #2, nothing must be done as the object manager has</span>
05203             <span class="comment">// already dereferenced the file object.  Note that this code is</span>
05204             <span class="comment">// not invoked if the parse routine completed with a successful</span>
05205             <span class="comment">// status return (SuccessfulIoParse is TRUE).</span>
05206             <span class="comment">//</span>
05207 
05208             <span class="keywordflow">if</span> (openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o2">FileObject</a>-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>.Length != 0) {
05209                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o2">FileObject</a>-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o19">FileName</a>.Buffer );
05210             }
05211             openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o2">FileObject</a>-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o2">DeviceObject</a> = (<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05212             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o2">FileObject</a> );
05213         }
05214 
05215         <span class="comment">//</span>
05216         <span class="comment">// When an NTFS file junction or an NTFS directory junction is traversed</span>
05217         <span class="comment">// OBJ_MAX_REPARSE_ATTEMPTS namy times, the object manager gives up and</span>
05218         <span class="comment">// returns the code STATUS_OBJECT_NAME_NOT_FOUND.</span>
05219         <span class="comment">//</span>
05220         <span class="comment">// This can happen in the following cases:</span>
05221         <span class="comment">//</span>
05222         <span class="comment">//      1) One encounters a legal chain of directory junctions that happen</span>
05223         <span class="comment">//         to be longer than the value of the above constant.</span>
05224         <span class="comment">//</span>
05225         <span class="comment">//      2) One encounters a self-referential file or directory junction that</span>
05226         <span class="comment">//         is, in effect, a tight name cycle.</span>
05227         <span class="comment">//</span>
05228         <span class="comment">//      3) One encounters a name cycle composed of several NTFS junctions.</span>
05229         <span class="comment">//</span>
05230         <span class="comment">// To improve on this return code see if  openPacket.Information  is</span>
05231         <span class="comment">// the trace of an NTFS name junction.</span>
05232         <span class="comment">//</span>
05233 
05234         <span class="keywordflow">if</span> ((status == STATUS_OBJECT_NAME_NOT_FOUND) &amp;&amp;
05235             (openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o4">Information</a> == IO_REPARSE_TAG_MOUNT_POINT)) {
05236 
05237             status = STATUS_REPARSE_POINT_NOT_RESOLVED;
05238         }
05239 
05240     } <span class="keywordflow">else</span> {
05241 
05242         <span class="comment">//</span>
05243         <span class="comment">// At this point, the open/create operation has been successfully</span>
05244         <span class="comment">// completed.  There is a handle to the file object, which has been</span>
05245         <span class="comment">// created, and the file object has been signaled.</span>
05246         <span class="comment">//</span>
05247         <span class="comment">// The remaining work to be done is to complete the operation.  This is</span>
05248         <span class="comment">// performed as follows:</span>
05249         <span class="comment">//</span>
05250         <span class="comment">//    1.  The file object has been signaled, so no work needs to be done</span>
05251         <span class="comment">//        for it.</span>
05252         <span class="comment">//</span>
05253         <span class="comment">//    2.  The file handle is returned to the user.</span>
05254         <span class="comment">//</span>
05255         <span class="comment">//    3.  The I/O status block is written with the final status.</span>
05256         <span class="comment">//</span>
05257 
05258         openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o2">FileObject</a>-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o18">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a168">FO_HANDLE_CREATED</a>;
05259 
05260         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o2">FileObject</a>-&gt;<a class="code" href="../../d9/d1/struct__FILE__OBJECT.html#o0">Type</a> == <a class="code" href="../../d0/d5/io_8h.html#a4">IO_TYPE_FILE</a> );
05261 
05262         <span class="keywordflow">try</span> {
05263 
05264             <span class="comment">//</span>
05265             <span class="comment">// Return the file handle.</span>
05266             <span class="comment">//</span>
05267 
05268             *FileHandle = handle;
05269 
05270             <span class="comment">//</span>
05271             <span class="comment">// Write the I/O status into the caller's buffer.</span>
05272             <span class="comment">//</span>
05273 
05274             IoStatusBlock-&gt;Information = openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o4">Information</a>;
05275             IoStatusBlock-&gt;Status = openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o3">FinalStatus</a>;
05276             status = openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o3">FinalStatus</a>;
05277 
05278         } except(<a class="code" href="../../d6/d7/halmips_8h.html#a33">EXCEPTION_EXECUTE_HANDLER</a>) {
05279 
05280             status = GetExceptionCode();
05281 
05282         }
05283 
05284     }
05285 
05286     <span class="comment">//</span>
05287     <span class="comment">// If the parse routine successfully created a file object then</span>
05288     <span class="comment">// derefence it here.</span>
05289     <span class="comment">//</span>
05290 
05291     <span class="keywordflow">if</span> (SuccessfulIoParse &amp;&amp; openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o2">FileObject</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
05292         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o2">FileObject</a> );
05293     }
05294 
05295     <span class="keywordflow">return</span> status;
05296 }
05297 
05298 <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>
<a name="l05299"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a47">05299</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a47">IoCreateNotificationEvent</a>(
05300     IN PUNICODE_STRING EventName,
05301     OUT PHANDLE EventHandle
05302     )
05303 
05304 <span class="comment">/*++</span>
05305 <span class="comment"></span>
05306 <span class="comment">Routine Description:</span>
05307 <span class="comment"></span>
05308 <span class="comment">    This routine creates a named notification event for use in notifying</span>
05309 <span class="comment">    different system components or drivers that an event occurred.</span>
05310 <span class="comment"></span>
05311 <span class="comment">Arguments:</span>
05312 <span class="comment"></span>
05313 <span class="comment">    EventName - Supplies the full name of the event.</span>
05314 <span class="comment"></span>
05315 <span class="comment">    EventHandle - Supplies a location to return a handle to the event.</span>
05316 <span class="comment"></span>
05317 <span class="comment">Return Value:</span>
05318 <span class="comment"></span>
05319 <span class="comment">    The function value is a pointer to the created/opened event, or NULL if</span>
05320 <span class="comment">    the event could not be created/opened.</span>
05321 <span class="comment"></span>
05322 <span class="comment">--*/</span>
05323 
05324 {
05325     OBJECT_ATTRIBUTES objectAttributes;
05326     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
05327     HANDLE eventHandle;
05328     <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> eventObject;
05329 
05330     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
05331 
05332     <span class="comment">//</span>
05333     <span class="comment">// Begin by initializing the object attributes.</span>
05334     <span class="comment">//</span>
05335 
05336     InitializeObjectAttributes( &amp;objectAttributes,
05337                                 <a class="code" href="../../d7/d0/ctlnpqos_8c.html#a5">EventName</a>,
05338                                 OBJ_OPENIF,
05339                                 (HANDLE) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
05340                                 (PSECURITY_DESCRIPTOR) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
05341 
05342     <span class="comment">//</span>
05343     <span class="comment">// Now create or open the event.</span>
05344     <span class="comment">//</span>
05345 
05346     status = ZwCreateEvent( &amp;eventHandle,
05347                             EVENT_ALL_ACCESS,
05348                             &amp;objectAttributes,
05349                             NotificationEvent,
05350                             <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
05351     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
05352         <span class="keywordflow">return</span> (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05353     }
05354 
05355     <span class="comment">//</span>
05356     <span class="comment">// Reference the object by its handle to get a pointer that can be returned</span>
05357     <span class="comment">// to the caller.</span>
05358     <span class="comment">//</span>
05359 
05360     (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a>( eventHandle,
05361                                       0,
05362                                       <a class="code" href="../../d7/d7/ntapi_8c.html#a3">ExEventObjectType</a>,
05363                                       <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
05364                                       (PVOID *) &amp;eventObject,
05365                                       <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
05366     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( eventObject );
05367 
05368     <span class="comment">//</span>
05369     <span class="comment">// Return the handle and the pointer to the event.</span>
05370     <span class="comment">//</span>
05371 
05372     *<a class="code" href="../../d7/d0/ctlnpqos_8c.html#a7">EventHandle</a> = eventHandle;
05373 
05374     <span class="keywordflow">return</span> eventObject;
05375 }
05376 
05377 <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>
<a name="l05378"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a48">05378</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a48">IoCreateStreamFileObject</a>(
05379     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject OPTIONAL,
05380     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject OPTIONAL
05381     )
05382 
05383 <span class="comment">/*++</span>
05384 <span class="comment"></span>
05385 <span class="comment">Routine Description:</span>
05386 <span class="comment"></span>
05387 <span class="comment">    This routine is invoked to create a new file object that represents an</span>
05388 <span class="comment">    alternate data stream for an existing file object.  The input file object</span>
05389 <span class="comment">    represents the file object that already exists for a file, and the newly</span>
05390 <span class="comment">    created stream file object is used to access other parts of the file</span>
05391 <span class="comment">    other than the data.  Some uses of stream file objects are the EAs or</span>
05392 <span class="comment">    the SECURITY_DESCRIPTORs on the file.  The stream file object allows</span>
05393 <span class="comment">    the file system to cache these parts of the file just as if they were</span>
05394 <span class="comment">    an entire to themselves.</span>
05395 <span class="comment"></span>
05396 <span class="comment">    It is also possible to use stream file objects to represent virtual</span>
05397 <span class="comment">    volume files.  This allows various parts of the on-disk structure to</span>
05398 <span class="comment">    be viewed as a virtual file and therefore be cached using the same logic</span>
05399 <span class="comment">    in the file system.  For this case, the device object pointer is used</span>
05400 <span class="comment">    to create the file object.</span>
05401 <span class="comment"></span>
05402 <span class="comment">Arguments:</span>
05403 <span class="comment"></span>
05404 <span class="comment">    FileObject - Pointer to the file object to which the new stream file</span>
05405 <span class="comment">        is related.  This pointer is optional.</span>
05406 <span class="comment"></span>
05407 <span class="comment">    DeviceObject - Pointer to the device object on which the stream file</span>
05408 <span class="comment">        is to be opened.  This pointer is not optional if the FileObject</span>
05409 <span class="comment">        pointer is not specified.</span>
05410 <span class="comment"></span>
05411 <span class="comment">Return Value:</span>
05412 <span class="comment"></span>
05413 <span class="comment">    The function value is a pointer to the newly created stream file object.</span>
05414 <span class="comment"></span>
05415 <span class="comment">--*/</span>
05416 
05417 {
05418     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> newFileObject;
05419     OBJECT_ATTRIBUTES objectAttributes;
05420     HANDLE handle;
05421     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
05422 
05423     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
05424 
05425     <span class="comment">//</span>
05426     <span class="comment">// Begin by getting the device object from either the file object or</span>
05427     <span class="comment">// the device object parameter.</span>
05428     <span class="comment">//</span>
05429 
05430     <span class="keywordflow">if</span> (ARGUMENT_PRESENT( FileObject )) {
05431         DeviceObject = FileObject-&gt;DeviceObject;
05432     }
05433 
05434     <span class="comment">//</span>
05435     <span class="comment">// Increment the reference count for the target device object.  Note</span>
05436     <span class="comment">// that no check is made to determine whether or not the device driver</span>
05437     <span class="comment">// is attempting to unload since this is an implicit open of a pseudo-</span>
05438     <span class="comment">// file that is being made, not a real file open request.  In essence,</span>
05439     <span class="comment">// no new file is really being opened.</span>
05440     <span class="comment">//</span>
05441 
05442     <a class="code" href="../../d5/d8/ex_8h.html#a235">ExInterlockedAddUlong</a>( &amp;DeviceObject-&gt;ReferenceCount, 1, &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a> );
05443 
05444     <span class="comment">//</span>
05445     <span class="comment">// Initialize the object attributes that will be used to create the file</span>
05446     <span class="comment">// object.</span>
05447     <span class="comment">//</span>
05448 
05449     InitializeObjectAttributes( &amp;objectAttributes,
05450                                 (PUNICODE_STRING) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
05451                                 0,
05452                                 (HANDLE) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
05453                                 (PSECURITY_DESCRIPTOR) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
05454 
05455     <span class="comment">//</span>
05456     <span class="comment">// Create the new file object.</span>
05457     <span class="comment">//</span>
05458 
05459     status = <a class="code" href="../../d6/d0/obcreate_8c.html#a5">ObCreateObject</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
05460                              <a class="code" href="../../d5/d8/fssup_8c.html#a3">IoFileObjectType</a>,
05461                              &amp;objectAttributes,
05462                              0,
05463                              (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
05464                              (ULONG) <span class="keyword">sizeof</span>( <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">FILE_OBJECT</a> ),
05465                              (ULONG) <span class="keyword">sizeof</span>( <a class="code" href="../../d0/d5/io_8h.html#a353">FILE_OBJECT</a> ),
05466                              0,
05467                              (PVOID *) &amp;newFileObject );
05468 
05469     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
05470         <a class="code" href="../../d0/d6/iop_8h.html#a161">IopDecrementDeviceObjectRef</a>( DeviceObject, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
05471         <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( status );
05472     }
05473 
05474     <span class="comment">//</span>
05475     <span class="comment">// Initialize the common fields of the file object.</span>
05476     <span class="comment">//</span>
05477 
05478     RtlZeroMemory( newFileObject, <span class="keyword">sizeof</span>( <a class="code" href="../../d0/d5/io_8h.html#a353">FILE_OBJECT</a> ) );
05479     newFileObject-&gt;Type = <a class="code" href="../../d0/d5/io_8h.html#a4">IO_TYPE_FILE</a>;
05480     newFileObject-&gt;Size = <span class="keyword">sizeof</span>( <a class="code" href="../../d0/d5/io_8h.html#a353">FILE_OBJECT</a> );
05481     newFileObject-&gt;DeviceObject = DeviceObject;
05482     newFileObject-&gt;Flags = <a class="code" href="../../d0/d5/io_8h.html#a158">FO_STREAM_FILE</a>;
05483     <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;newFileObject-&gt;Event, SynchronizationEvent, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
05484 
05485     <span class="comment">//</span>
05486     <span class="comment">// Insert the device object into the table.  Note that this is done w/a</span>
05487     <span class="comment">// pointer bias so that the object cannot go away if some random user</span>
05488     <span class="comment">// application closes the handle before this code is finished w/it.</span>
05489     <span class="comment">//</span>
05490 
05491     status = <a class="code" href="../../d1/d1/obinsert_8c.html#a0">ObInsertObject</a>( newFileObject,
05492                              <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
05493                              FILE_READ_DATA,
05494                              1,
05495                              (PVOID *) &amp;newFileObject,
05496                              &amp;handle );
05497 
05498     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
05499         <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( status );
05500     }
05501 
05502     <span class="comment">//</span>
05503     <span class="comment">// The insert completed successfully.  Update the bookkeeping so that the</span>
05504     <span class="comment">// fact that there is a handle is reflected.</span>
05505     <span class="comment">//</span>
05506 
05507     newFileObject-&gt;Flags |= <a class="code" href="../../d0/d5/io_8h.html#a168">FO_HANDLE_CREATED</a>;
05508     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( newFileObject-&gt;Type == <a class="code" href="../../d0/d5/io_8h.html#a4">IO_TYPE_FILE</a> );
05509 
05510     <span class="comment">//</span>
05511     <span class="comment">// Synchronize here with the file system to make sure that</span>
05512     <span class="comment">// volumes don't go away while en route to the FS.</span>
05513     <span class="comment">//</span>
05514 
05515     <span class="keywordflow">if</span> (DeviceObject-&gt;Vpb) {
05516 
05517         <a class="code" href="../../d5/d8/ex_8h.html#a235">ExInterlockedAddUlong</a>( &amp;DeviceObject-&gt;Vpb-&gt;ReferenceCount,
05518                                1,
05519                                &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a2">IopVpbSpinLock</a> );
05520     }
05521 
05522     <span class="comment">//</span>
05523     <span class="comment">// Finally, close the handle to the file. and clear the forward cluster</span>
05524     <span class="comment">//</span>
05525 
05526     status = <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>( handle );
05527 
05528     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status ) );
05529 
05530     <span class="keywordflow">return</span> newFileObject;
05531 }
05532 
05533 
05534 <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a>
<a name="l05535"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a49">05535</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a49">IoCreateStreamFileObjectLite</a>(
05536     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject OPTIONAL,
05537     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject OPTIONAL
05538     )
05539 
05540 <span class="comment">/*++</span>
05541 <span class="comment"></span>
05542 <span class="comment">Routine Description:</span>
05543 <span class="comment"></span>
05544 <span class="comment">    This routine is invoked to create a new file object that represents an</span>
05545 <span class="comment">    alternate data stream for an existing file object.  The input file object</span>
05546 <span class="comment">    represents the file object that already exists for a file, and the newly</span>
05547 <span class="comment">    created stream file object is used to access other parts of the file</span>
05548 <span class="comment">    other than the data.  Some uses of stream file objects are the EAs or</span>
05549 <span class="comment">    the SECURITY_DESCRIPTORs on the file.  The stream file object allows</span>
05550 <span class="comment">    the file system to cache these parts of the file just as if they were</span>
05551 <span class="comment">    an entire to themselves.</span>
05552 <span class="comment"></span>
05553 <span class="comment">    It is also possible to use stream file objects to represent virtual</span>
05554 <span class="comment">    volume files.  This allows various parts of the on-disk structure to</span>
05555 <span class="comment">    be viewed as a virtual file and therefore be cached using the same logic</span>
05556 <span class="comment">    in the file system.  For this case, the device object pointer is used</span>
05557 <span class="comment">    to create the file object.</span>
05558 <span class="comment"></span>
05559 <span class="comment">    This call differs from IoCreateStreamFileObject in that it performs no</span>
05560 <span class="comment">    handle management and does not result in a call to the file system</span>
05561 <span class="comment">    cleanup entry.</span>
05562 <span class="comment"></span>
05563 <span class="comment">Arguments:</span>
05564 <span class="comment"></span>
05565 <span class="comment">    FileObject - Pointer to the file object to which the new stream file</span>
05566 <span class="comment">        is related.  This pointer is optional.</span>
05567 <span class="comment"></span>
05568 <span class="comment">    DeviceObject - Pointer to the device object on which the stream file</span>
05569 <span class="comment">        is to be opened.  This pointer is not optional if the FileObject</span>
05570 <span class="comment">        pointer is not specified.</span>
05571 <span class="comment"></span>
05572 <span class="comment">Return Value:</span>
05573 <span class="comment"></span>
05574 <span class="comment">    The function value is a pointer to the newly created stream file object.</span>
05575 <span class="comment"></span>
05576 <span class="comment">--*/</span>
05577 
05578 {
05579     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> newFileObject;
05580     OBJECT_ATTRIBUTES objectAttributes;
05581     HANDLE handle;
05582     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
05583 
05584     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
05585 
05586     <span class="comment">//</span>
05587     <span class="comment">// Begin by getting the device object from either the file object or</span>
05588     <span class="comment">// the device object parameter.</span>
05589     <span class="comment">//</span>
05590 
05591     <span class="keywordflow">if</span> (ARGUMENT_PRESENT( FileObject )) {
05592         DeviceObject = FileObject-&gt;DeviceObject;
05593     }
05594 
05595     <span class="comment">//</span>
05596     <span class="comment">// if the driver has been marked for an unload or deleted operation, and</span>
05597     <span class="comment">// the reference count goes to zero, then the driver may need to be</span>
05598     <span class="comment">// unloaded or deleted at this point.</span>
05599     <span class="comment">// file that is being made, not a real file open request.  In essence,</span>
05600     <span class="comment">// no new file is really being opened.</span>
05601     <span class="comment">//</span>
05602 
05603     <a class="code" href="../../d5/d8/ex_8h.html#a235">ExInterlockedAddUlong</a>( &amp;DeviceObject-&gt;ReferenceCount, 1, &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a> );
05604 
05605     <span class="comment">//</span>
05606     <span class="comment">// Initialize the object attributes that will be used to create the file</span>
05607     <span class="comment">// object.</span>
05608     <span class="comment">//</span>
05609 
05610     InitializeObjectAttributes( &amp;objectAttributes,
05611                                 (PUNICODE_STRING) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
05612                                 0,
05613                                 (HANDLE) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
05614                                 (PSECURITY_DESCRIPTOR) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
05615 
05616     <span class="comment">//</span>
05617     <span class="comment">// Create the new file object.</span>
05618     <span class="comment">//</span>
05619 
05620     status = <a class="code" href="../../d6/d0/obcreate_8c.html#a5">ObCreateObject</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
05621                              <a class="code" href="../../d5/d8/fssup_8c.html#a3">IoFileObjectType</a>,
05622                              &amp;objectAttributes,
05623                              0,
05624                              (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
05625                              (ULONG) <span class="keyword">sizeof</span>( <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">FILE_OBJECT</a> ),
05626                              (ULONG) <span class="keyword">sizeof</span>( <a class="code" href="../../d0/d5/io_8h.html#a353">FILE_OBJECT</a> ),
05627                              0,
05628                              (PVOID *) &amp;newFileObject );
05629 
05630     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
05631         <a class="code" href="../../d0/d6/iop_8h.html#a161">IopDecrementDeviceObjectRef</a>( DeviceObject, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
05632         <a class="code" href="../../d5/d8/ex_8h.html#a303">ExRaiseStatus</a>( status );
05633     }
05634 
05635     <span class="comment">//</span>
05636     <span class="comment">// Initialize the common fields of the file object.</span>
05637     <span class="comment">//</span>
05638 
05639     RtlZeroMemory( newFileObject, <span class="keyword">sizeof</span>( <a class="code" href="../../d0/d5/io_8h.html#a353">FILE_OBJECT</a> ) );
05640     newFileObject-&gt;Type = <a class="code" href="../../d0/d5/io_8h.html#a4">IO_TYPE_FILE</a>;
05641     newFileObject-&gt;Size = <span class="keyword">sizeof</span>( <a class="code" href="../../d0/d5/io_8h.html#a353">FILE_OBJECT</a> );
05642     newFileObject-&gt;DeviceObject = DeviceObject;
05643     newFileObject-&gt;Flags = <a class="code" href="../../d0/d5/io_8h.html#a158">FO_STREAM_FILE</a>;
05644     <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;newFileObject-&gt;Event, SynchronizationEvent, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
05645 
05646     <span class="comment">//</span>
05647     <span class="comment">//  Clean up from the creation.</span>
05648     <span class="comment">//</span>
05649 
05650     <a class="code" href="../../d6/d0/obcreate_8c.html#a13">ObFreeObjectCreateInfoBuffer</a>(<a class="code" href="../../d4/d0/ob_8h.html#a8">OBJECT_TO_OBJECT_HEADER</a>(newFileObject)-&gt;ObjectCreateInfo);
05651     <a class="code" href="../../d4/d0/ob_8h.html#a8">OBJECT_TO_OBJECT_HEADER</a>(newFileObject)-&gt;ObjectCreateInfo = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05652 
05653     newFileObject-&gt;Flags |= <a class="code" href="../../d0/d5/io_8h.html#a168">FO_HANDLE_CREATED</a>;
05654     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( newFileObject-&gt;Type == <a class="code" href="../../d0/d5/io_8h.html#a4">IO_TYPE_FILE</a> );
05655 
05656     <span class="comment">//</span>
05657     <span class="comment">// Synchronize here with the file system to make sure that</span>
05658     <span class="comment">// volumes don't go away while en route to the FS.</span>
05659     <span class="comment">//</span>
05660 
05661     <span class="keywordflow">if</span> (DeviceObject-&gt;Vpb) {
05662 
05663         <a class="code" href="../../d5/d8/ex_8h.html#a235">ExInterlockedAddUlong</a>( &amp;DeviceObject-&gt;Vpb-&gt;ReferenceCount,
05664                                1,
05665                                &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a2">IopVpbSpinLock</a> );
05666     }
05667 
05668     <span class="keywordflow">return</span> newFileObject;
05669 }
05670 
05671 
05672 
05673 
05674 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l05675"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a50">05675</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a50">IoCreateSymbolicLink</a>(
05676     IN PUNICODE_STRING SymbolicLinkName,
05677     IN PUNICODE_STRING DeviceName
05678     )
05679 
05680 <span class="comment">/*++</span>
05681 <span class="comment"></span>
05682 <span class="comment">Routine Description:</span>
05683 <span class="comment"></span>
05684 <span class="comment">    This routine is invoked to assign a symbolic link name to a device.</span>
05685 <span class="comment"></span>
05686 <span class="comment">Arguments:</span>
05687 <span class="comment"></span>
05688 <span class="comment">    SymbolicLinkName - Supplies the symbolic link name as a Unicode string.</span>
05689 <span class="comment"></span>
05690 <span class="comment">    DeviceName - Supplies the name to which the symbolic link name refers.</span>
05691 <span class="comment"></span>
05692 <span class="comment">Return Value:</span>
05693 <span class="comment"></span>
05694 <span class="comment">    The function value is the final status of the operation.</span>
05695 <span class="comment"></span>
05696 <span class="comment">--*/</span>
05697 
05698 {
05699     OBJECT_ATTRIBUTES objectAttributes;
05700     HANDLE linkHandle;
05701     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
05702 
05703     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
05704 
05705     <span class="comment">//</span>
05706     <span class="comment">// Begin by initializing the object attributes for the symbolic link.</span>
05707     <span class="comment">//</span>
05708 
05709     InitializeObjectAttributes( &amp;objectAttributes,
05710                                 SymbolicLinkName,
05711                                 OBJ_PERMANENT | OBJ_CASE_INSENSITIVE,
05712                                 (HANDLE) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
05713                                 <a class="code" href="../../d0/d5/se_8h.html#a68">SePublicDefaultUnrestrictedSd</a> );
05714 
05715     <span class="comment">//</span>
05716     <span class="comment">// Note that the following assignment can fail (because it is not system</span>
05717     <span class="comment">// initialization time and therefore the \ARCname directory does not</span>
05718     <span class="comment">// exist - if this is really a call to IoAssignArcName), but that is fine.</span>
05719     <span class="comment">//</span>
05720 
05721     status = ZwCreateSymbolicLinkObject( &amp;linkHandle,
05722                                          SYMBOLIC_LINK_ALL_ACCESS,
05723                                          &amp;objectAttributes,
05724                                          DeviceName );
05725     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
05726         ZwClose( linkHandle );
05727     }
05728 
05729     <span class="keywordflow">return</span> status;
05730 }
05731 
05732 <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>
<a name="l05733"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a51">05733</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a51">IoCreateSynchronizationEvent</a>(
05734     IN PUNICODE_STRING EventName,
05735     OUT PHANDLE EventHandle
05736     )
05737 
05738 <span class="comment">/*++</span>
05739 <span class="comment"></span>
05740 <span class="comment">Routine Description:</span>
05741 <span class="comment"></span>
05742 <span class="comment">    This routine creates a named synchronization event for use in serialization</span>
05743 <span class="comment">    of access to hardware between two otherwise non-related drivers.  The event</span>
05744 <span class="comment">    is created if it does not already exist, otherwise it is simply opened.</span>
05745 <span class="comment"></span>
05746 <span class="comment">Arguments:</span>
05747 <span class="comment"></span>
05748 <span class="comment">    EventName - Supplies the full name of the event.</span>
05749 <span class="comment"></span>
05750 <span class="comment">    EventHandle - Supplies a location to return a handle to the event.</span>
05751 <span class="comment"></span>
05752 <span class="comment">Return Value:</span>
05753 <span class="comment"></span>
05754 <span class="comment">    The function value is a pointer to the created/opened event, or NULL if</span>
05755 <span class="comment">    the event could not be created/opened.</span>
05756 <span class="comment"></span>
05757 <span class="comment">--*/</span>
05758 
05759 {
05760     OBJECT_ATTRIBUTES objectAttributes;
05761     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
05762     HANDLE eventHandle;
05763     <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> eventObject;
05764 
05765     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
05766 
05767     <span class="comment">//</span>
05768     <span class="comment">// Begin by initializing the object attributes.</span>
05769     <span class="comment">//</span>
05770 
05771     InitializeObjectAttributes( &amp;objectAttributes,
05772                                 <a class="code" href="../../d7/d0/ctlnpqos_8c.html#a5">EventName</a>,
05773                                 OBJ_OPENIF,
05774                                 (HANDLE) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
05775                                 (PSECURITY_DESCRIPTOR) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
05776 
05777     <span class="comment">//</span>
05778     <span class="comment">// Now create or open the event.</span>
05779     <span class="comment">//</span>
05780 
05781     status = ZwCreateEvent( &amp;eventHandle,
05782                             EVENT_ALL_ACCESS,
05783                             &amp;objectAttributes,
05784                             SynchronizationEvent,
05785                             <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
05786     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
05787         <span class="keywordflow">return</span> (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
05788     }
05789 
05790     <span class="comment">//</span>
05791     <span class="comment">// Reference the object by its handle to get a pointer that can be returned</span>
05792     <span class="comment">// to the caller.</span>
05793     <span class="comment">//</span>
05794 
05795     (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a>( eventHandle,
05796                                       0,
05797                                       <a class="code" href="../../d7/d7/ntapi_8c.html#a3">ExEventObjectType</a>,
05798                                       <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
05799                                       (PVOID *) &amp;eventObject,
05800                                       <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
05801     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( eventObject );
05802 
05803     <span class="comment">//</span>
05804     <span class="comment">// Return the handle and the pointer to the event.</span>
05805     <span class="comment">//</span>
05806 
05807     *<a class="code" href="../../d7/d0/ctlnpqos_8c.html#a7">EventHandle</a> = eventHandle;
05808 
05809     <span class="keywordflow">return</span> eventObject;
05810 }
05811 
05812 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l05813"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a52">05813</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a52">IoCreateUnprotectedSymbolicLink</a>(
05814     IN PUNICODE_STRING SymbolicLinkName,
05815     IN PUNICODE_STRING DeviceName
05816     )
05817 
05818 <span class="comment">/*++</span>
05819 <span class="comment"></span>
05820 <span class="comment">Routine Description:</span>
05821 <span class="comment"></span>
05822 <span class="comment">    This routine is invoked to assign an unprotected symbolic link name to</span>
05823 <span class="comment">    a device.  That is, a symbolic link that can be dynamically reassigned</span>
05824 <span class="comment">    without any special authorization.</span>
05825 <span class="comment"></span>
05826 <span class="comment"></span>
05827 <span class="comment">    NOTE:  This routine will NOT over-ride inheritable protection that</span>
05828 <span class="comment">           the symbolic link might pick up.  It simply prevents the caller's</span>
05829 <span class="comment">            default token protection from being assigned.</span>
05830 <span class="comment"></span>
05831 <span class="comment"></span>
05832 <span class="comment">Arguments:</span>
05833 <span class="comment"></span>
05834 <span class="comment">    SymbolicLinkName - Supplies the symbolic link name as a Unicode string.</span>
05835 <span class="comment"></span>
05836 <span class="comment">    DeviceName - Supplies the name to which the symbolic link name refers.</span>
05837 <span class="comment"></span>
05838 <span class="comment">Return Value:</span>
05839 <span class="comment"></span>
05840 <span class="comment">    The function value is the final status of the operation.</span>
05841 <span class="comment"></span>
05842 <span class="comment">--*/</span>
05843 
05844 {
05845     OBJECT_ATTRIBUTES objectAttributes;
05846     HANDLE linkHandle;
05847     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
05848     SECURITY_DESCRIPTOR securityDescriptor;
05849 
05850     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
05851 
05852     <span class="comment">//</span>
05853     <span class="comment">// Create a security descriptor that has all access.</span>
05854     <span class="comment">//</span>
05855 
05856     status = <a class="code" href="../../d8/d6/sertl_8c.html#a53">RtlCreateSecurityDescriptor</a>( &amp;securityDescriptor,
05857                                           SECURITY_DESCRIPTOR_REVISION1 );
05858     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
05859         <span class="keywordflow">return</span> status;
05860     }
05861 
05862     status = <a class="code" href="../../d8/d6/sertl_8c.html#a60">RtlSetDaclSecurityDescriptor</a> ( &amp;securityDescriptor,
05863                                             <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
05864                                             <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
05865                                             <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );     <span class="comment">//does not over-ride inheritable protection</span>
05866     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
05867         <span class="keywordflow">return</span> status;
05868     }
05869 
05870     <span class="comment">//</span>
05871     <span class="comment">// Initialize the object attributes for the symbolic link.</span>
05872     <span class="comment">//</span>
05873 
05874         InitializeObjectAttributes( &amp;objectAttributes,
05875                                 SymbolicLinkName,
05876                                 OBJ_PERMANENT | OBJ_CASE_INSENSITIVE,
05877                                 (HANDLE) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
05878                                 &amp;securityDescriptor );
05879 
05880     <span class="comment">//</span>
05881     <span class="comment">// Note that the following assignment can fail (because it is not system</span>
05882     <span class="comment">// initialization time and therefore the \ARCname directory does not</span>
05883     <span class="comment">// exist - if this is really a call to IoAssignArcName), but that is fine.</span>
05884     <span class="comment">//</span>
05885 
05886     status = ZwCreateSymbolicLinkObject( &amp;linkHandle,
05887                                          SYMBOLIC_LINK_ALL_ACCESS,
05888                                          &amp;objectAttributes,
05889                                          DeviceName );
05890     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
05891         ZwClose( linkHandle );
05892     }
05893 
05894     <span class="keywordflow">return</span> status;
05895 }
05896 
05897 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l05898"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a53">05898</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a53">IoDeleteController</a>(
05899     IN <a class="code" href="../../d1/d8/struct__CONTROLLER__OBJECT.html">PCONTROLLER_OBJECT</a> ControllerObject
05900     )
05901 
05902 <span class="comment">/*++</span>
05903 <span class="comment"></span>
05904 <span class="comment">Routine Description:</span>
05905 <span class="comment"></span>
05906 <span class="comment">    This routine deletes the specified controller object from the system</span>
05907 <span class="comment">    so that it may no longer be referenced from a driver.  It is invoked</span>
05908 <span class="comment">    when either the driver is being unloaded from the system, or the driver's</span>
05909 <span class="comment">    initialization routine failed to properly initialize the device or a</span>
05910 <span class="comment">    fatal driver initialization error was encountered.</span>
05911 <span class="comment"></span>
05912 <span class="comment">Arguments:</span>
05913 <span class="comment"></span>
05914 <span class="comment">    ControllerObject - Pointer to the controller object that is to be</span>
05915 <span class="comment">        deleted.</span>
05916 <span class="comment"></span>
05917 <span class="comment">Return Value:</span>
05918 <span class="comment"></span>
05919 <span class="comment">    None.</span>
05920 <span class="comment"></span>
05921 <span class="comment">--*/</span>
05922 
05923 {
05924     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
05925 
05926     <span class="comment">//</span>
05927     <span class="comment">// The controller was created as a temporary object, and all of the</span>
05928     <span class="comment">// handles for the object have already been closed.  At this point,</span>
05929     <span class="comment">// simply dereferencing the object will cause it to be deleted.</span>
05930     <span class="comment">//</span>
05931 
05932     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( ControllerObject );
05933 }
05934 
05935 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l05936"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a54">05936</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a54">IopRemoveTimerFromTimerList</a>(
05937     IN <a class="code" href="../../d4/d9/struct__IO__TIMER.html">PIO_TIMER</a> timer
05938     )
05939 {
05940     KIRQL irql;
05941 
05942     ExAcquireFastLock( &amp;<a class="code" href="../../d4/d4/alpha_2splocks_8c.html#a8">IopTimerLock</a>, &amp;irql );
05943     RemoveEntryList( &amp;timer-&gt;TimerList );
05944     <span class="keywordflow">if</span> (timer-&gt;TimerFlag) {
05945         <a class="code" href="../../d3/d5/iodata_8c.html#a31">IopTimerCount</a>--;
05946     }
05947     ExReleaseFastLock( &amp;<a class="code" href="../../d4/d4/alpha_2splocks_8c.html#a8">IopTimerLock</a>, irql );
05948 }
05949 
05950 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l05951"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a55">05951</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a55">IoDeleteDevice</a>(
05952     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject
05953     )
05954 
05955 <span class="comment">/*++</span>
05956 <span class="comment"></span>
05957 <span class="comment">Routine Description:</span>
05958 <span class="comment"></span>
05959 <span class="comment">    This routine deletes the specified device object from the system so that</span>
05960 <span class="comment">    it may no longer be referenced.  It is invoked when either the device</span>
05961 <span class="comment">    driver is being unloaded from the system, or the driver's initialization</span>
05962 <span class="comment">    routine failed to properly initialize the device or a fatal driver</span>
05963 <span class="comment">    initialization error was encountered, or when the device is being removed</span>
05964 <span class="comment">    from the system.</span>
05965 <span class="comment"></span>
05966 <span class="comment">Arguments:</span>
05967 <span class="comment"></span>
05968 <span class="comment">    DeviceObject - Pointer to the device object that is to be deleted.</span>
05969 <span class="comment"></span>
05970 <span class="comment">Return Value:</span>
05971 <span class="comment"></span>
05972 <span class="comment">    None.</span>
05973 <span class="comment"></span>
05974 <span class="comment">--*/</span>
05975 
05976 {
05977     KIRQL irql;
05978 
05979     <a class="code" href="../../d7/d6/ioverifier_8h.html#a2">IOV_DELETE_DEVICE</a>(DeviceObject);
05980 
05981     <span class="comment">//</span>
05982     <span class="comment">// Check to see whether or not the device has registered a shutdown</span>
05983     <span class="comment">// handler if necessary, and if so, unregister it.</span>
05984     <span class="comment">//</span>
05985 
05986     <span class="keywordflow">if</span> (DeviceObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a132">DO_SHUTDOWN_REGISTERED</a>) {
05987         <a class="code" href="../../d4/d6/iosubs_8c.html#a120">IoUnregisterShutdownNotification</a>( DeviceObject );
05988     }
05989 
05990     <span class="comment">//</span>
05991     <span class="comment">// Release the pool that was allocated to contain the timer dispatch</span>
05992     <span class="comment">// routine and its associated context if there was one.</span>
05993     <span class="comment">//</span>
05994 
05995     <span class="keywordflow">if</span> (DeviceObject-&gt;Timer) {
05996         <a class="code" href="../../d4/d9/struct__IO__TIMER.html">PIO_TIMER</a> timer;
05997 
05998         timer = DeviceObject-&gt;Timer;
05999         <a class="code" href="../../d4/d6/iosubs_8c.html#a54">IopRemoveTimerFromTimerList</a>(timer);
06000         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( timer );
06001     }
06002 
06003     <span class="comment">//</span>
06004     <span class="comment">// If this device has a name, then mark the</span>
06005     <span class="comment">// object as temporary so that when it is dereferenced it will be</span>
06006     <span class="comment">// deleted.</span>
06007     <span class="comment">//</span>
06008 
06009     <span class="keywordflow">if</span> (DeviceObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a127">DO_DEVICE_HAS_NAME</a>) {
06010         <a class="code" href="../../d5/d0/obclose_8c.html#a3">ObMakeTemporaryObject</a>( DeviceObject );
06011     }
06012 
06013     <span class="comment">//</span>
06014     <span class="comment">// PoRunDownDeviceObject will clean up any power management</span>
06015     <span class="comment">// structures attached to the device object.</span>
06016     <span class="comment">//</span>
06017 
06018     <a class="code" href="../../d1/d2/po_8h.html#a62">PoRunDownDeviceObject</a>(DeviceObject);
06019 
06020     <span class="comment">//</span>
06021     <span class="comment">// Mark the device object as deleted.</span>
06022     <span class="comment">//</span>
06023 
06024     ExAcquireSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, &amp;irql );
06025 
06026     DeviceObject-&gt;DeviceObjectExtension-&gt;ExtensionFlags |= <a class="code" href="../../d0/d5/io_8h.html#a139">DOE_DELETE_PENDING</a>;
06027 
06028     <span class="keywordflow">if</span> (!DeviceObject-&gt;ReferenceCount) {
06029         <a class="code" href="../../d0/d6/iop_8h.html#a155">IopCompleteUnloadOrDelete</a>( DeviceObject, irql );
06030     } <span class="keywordflow">else</span> {
06031         ExReleaseSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, irql );
06032     }
06033 }
06034 
06035 
06036 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l06037"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a56">06037</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a56">IopDeleteSessionSymLinks</a>(
06038     IN PUNICODE_STRING LinkName
06039     )
06040 <span class="comment">/*++</span>
06041 <span class="comment"></span>
06042 <span class="comment">Routine Description:</span>
06043 <span class="comment"></span>
06044 <span class="comment">    This routine is called from IoDeleteSymbolic Link. It enumerates all the</span>
06045 <span class="comment">    Terminal Server session specific object directories and deletes the specified</span>
06046 <span class="comment">    symbolic link from the DosDevices object directory of each sesssion. This</span>
06047 <span class="comment">    routine is only called when Terminal Services is enabled.</span>
06048 <span class="comment"></span>
06049 <span class="comment">Arguments:</span>
06050 <span class="comment"></span>
06051 <span class="comment">    SymbolicLinkName - Provides the Unicode name string to be deassigned.</span>
06052 <span class="comment"></span>
06053 <span class="comment">Return Values:</span>
06054 <span class="comment"></span>
06055 <span class="comment">    None.</span>
06056 <span class="comment"></span>
06057 <span class="comment">--*/</span>
06058 
06059 {
06060 
06061     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
06062     UNICODE_STRING UnicodeString;
06063     UNICODE_STRING SymbolicLinkName;
06064     OBJECT_ATTRIBUTES Attributes;
06065     HANDLE <a class="code" href="../../d3/d3/tob_8c.html#a23">DirectoryHandle</a>;
06066     HANDLE linkHandle;
06067     POBJECT_DIRECTORY_INFORMATION DirInfo;
06068     BOOLEAN RestartScan;
06069     ULONG Context = 0;
06070     ULONG ReturnedLength;
06071     PWCHAR NameBuf;
06072     PUCHAR DirInfoBuffer;
06073     ULONG <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
06074     WCHAR Prefix[13]; <span class="comment">// sizeof L"\\DosDevices\\"</span>
06075 
06076 
06077 
06078     <span class="comment">//</span>
06079     <span class="comment">// Only delete links that start with \DosDevices\</span>
06080     <span class="comment">//</span>
06081 
06082     <span class="keywordflow">if</span> (LinkName-&gt;Length &lt; (<span class="keyword">sizeof</span>(<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"\\DosDevices\\"</span>))) {
06083         <span class="keywordflow">return</span> STATUS_SUCCESS;
06084     }
06085     <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>( &amp;UnicodeString, <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"\\DosDevices\\"</span> );
06086 
06087     wcsncpy(Prefix,LinkName-&gt;Buffer,(<span class="keyword">sizeof</span>(<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"\\DosDevices\\"</span>)/<span class="keyword">sizeof</span>(WCHAR)) - 1);
06088     <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>( &amp;SymbolicLinkName, Prefix);
06089 
06090     <span class="keywordflow">if</span> (<a class="code" href="../../d6/d6/nls_8c.html#a41">RtlCompareUnicodeString</a>(&amp;UnicodeString, &amp;SymbolicLinkName,<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>)) {
06091 
06092         <span class="keywordflow">return</span> STATUS_SUCCESS;
06093 
06094     }
06095 
06096 
06097     <span class="comment">//</span>
06098     <span class="comment">// Open the root Sessions Directory.</span>
06099     <span class="comment">//</span>
06100     <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>( &amp;UnicodeString, <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"\\Sessions"</span> );
06101 
06102     InitializeObjectAttributes( &amp;Attributes,
06103                                 &amp;UnicodeString,
06104                                 OBJ_CASE_INSENSITIVE,
06105                                 <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
06106                                 <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>
06107                               );
06108 
06109     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwOpenDirectoryObject( &amp;<a class="code" href="../../d3/d3/tob_8c.html#a23">DirectoryHandle</a>,
06110                                     DIRECTORY_QUERY,
06111                                     &amp;Attributes
06112                                   );
06113     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
06114 
06115 
06116         <span class="comment">//</span>
06117         <span class="comment">// Since SessionId is a ULONG , the prefix (\\Sessions\&lt;SessionId&gt;\\DosDevices)</span>
06118         <span class="comment">// cannot be more that 128 characters in length</span>
06119         <span class="comment">//</span>
06120         <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> = (LinkName-&gt;Length + 128) * <span class="keyword">sizeof</span>(WCHAR);
06121         NameBuf = (PWCHAR)<a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(<a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>, <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>, ' oI');
06122 
06123         <span class="keywordflow">if</span> (NameBuf == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
06124             <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
06125         }
06126 
06127         SymbolicLinkName.Buffer = (PWSTR)NameBuf;
06128         SymbolicLinkName.Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
06129         SymbolicLinkName.MaximumLength = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
06130 
06131 
06132         <span class="comment">//</span>
06133         <span class="comment">// 4k should be more than enough to query a directory object entry</span>
06134         <span class="comment">//</span>
06135         <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> = 4096;
06136         DirInfoBuffer = (PUCHAR)<a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(<a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>, <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>, ' oI');
06137 
06138         <span class="keywordflow">if</span> (DirInfoBuffer == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
06139             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(NameBuf);
06140             <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
06141         }
06142 
06143         RestartScan = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
06144         DirInfo = (POBJECT_DIRECTORY_INFORMATION)DirInfoBuffer;
06145 
06146 
06147         <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
06148 
06149             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwQueryDirectoryObject( <a class="code" href="../../d3/d3/tob_8c.html#a23">DirectoryHandle</a>,
06150                                              (PVOID)DirInfo,
06151                                              <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>,
06152                                              <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
06153                                              RestartScan,
06154                                              &amp;Context,
06155                                              &amp;ReturnedLength
06156                                            );
06157 
06158             RestartScan = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
06159 
06160             <span class="comment">//</span>
06161             <span class="comment">//  Check the status of the operation.</span>
06162             <span class="comment">//</span>
06163 
06164             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
06165                 <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> == STATUS_NO_MORE_ENTRIES) {
06166                     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = STATUS_SUCCESS;
06167                     }
06168 
06169                 <span class="keywordflow">break</span>;
06170                 }
06171 
06172 
06173             <span class="comment">//</span>
06174             <span class="comment">// This generates session specific symbolic link path</span>
06175             <span class="comment">// \Sessions&lt;id&gt;\DosDevices&lt;LinkName&gt;</span>
06176             <span class="comment">//</span>
06177             <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>( &amp;UnicodeString, <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"\\Sessions\\"</span> );
06178             <a class="code" href="../../d6/d6/nls_8c.html#a44">RtlCopyUnicodeString</a>( &amp;SymbolicLinkName, &amp;UnicodeString );
06179             <a class="code" href="../../d6/d6/nls_8c.html#a46">RtlAppendUnicodeStringToString</a>( &amp;SymbolicLinkName, &amp;(DirInfo-&gt;Name) );
06180             <a class="code" href="../../d6/d6/nls_8c.html#a46">RtlAppendUnicodeStringToString</a>( &amp;SymbolicLinkName, LinkName );
06181             <span class="comment">//</span>
06182             <span class="comment">// Begin by initializing the object attributes for the symbolic link.</span>
06183             <span class="comment">//</span>
06184 
06185             InitializeObjectAttributes( &amp;Attributes,
06186                                         &amp;SymbolicLinkName,
06187                                         OBJ_CASE_INSENSITIVE,
06188                                         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
06189                                         <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
06190 
06191             <span class="comment">//</span>
06192             <span class="comment">// Open the symbolic link itself so that it can be marked temporary and</span>
06193             <span class="comment">// closed.</span>
06194             <span class="comment">//</span>
06195 
06196             <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwOpenSymbolicLinkObject( &amp;linkHandle,
06197                                                DELETE,
06198                                                &amp;Attributes );
06199             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
06200 
06201                 <span class="comment">//</span>
06202                 <span class="comment">// The symbolic link was successfully opened.  Attempt to make it a</span>
06203                 <span class="comment">// temporary object, and then close the handle.  This will cause the</span>
06204                 <span class="comment">// object to go away.</span>
06205                 <span class="comment">//</span>
06206 
06207                 <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = ZwMakeTemporaryObject( linkHandle );
06208                 <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> )) {
06209                     ZwClose( linkHandle );
06210                 }
06211             }
06212 
06213 
06214 
06215          }
06216 
06217          ZwClose(<a class="code" href="../../d3/d3/tob_8c.html#a23">DirectoryHandle</a>);
06218          <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(NameBuf);
06219          <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(DirInfoBuffer);
06220     }
06221 
06222      <span class="keywordflow">return</span> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
06223 }
06224 
06225 
06226 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l06227"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a57">06227</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a57">IoDeleteSymbolicLink</a>(
06228     IN PUNICODE_STRING SymbolicLinkName
06229     )
06230 
06231 <span class="comment">/*++</span>
06232 <span class="comment"></span>
06233 <span class="comment">Routine Description:</span>
06234 <span class="comment"></span>
06235 <span class="comment">    This routine is invoked to remove a symbolic link from the system.  This</span>
06236 <span class="comment">    generally occurs whenever a driver that has assigned a symbolic link needs</span>
06237 <span class="comment">    to exit.  It can also be used when a driver no longer needs to redirect</span>
06238 <span class="comment">    a name.</span>
06239 <span class="comment"></span>
06240 <span class="comment">Arguments:</span>
06241 <span class="comment"></span>
06242 <span class="comment">    SymbolicLinkName - Provides the Unicode name string to be deassigned.</span>
06243 <span class="comment"></span>
06244 <span class="comment">Return Values:</span>
06245 <span class="comment"></span>
06246 <span class="comment">    None.</span>
06247 <span class="comment"></span>
06248 <span class="comment">--*/</span>
06249 
06250 {
06251     OBJECT_ATTRIBUTES objectAttributes;
06252     HANDLE linkHandle;
06253     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
06254 
06255     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
06256 
06257     <span class="comment">//</span>
06258     <span class="comment">// Begin by initializing the object attributes for the symbolic link.</span>
06259     <span class="comment">//</span>
06260 
06261     InitializeObjectAttributes( &amp;objectAttributes,
06262                                 SymbolicLinkName,
06263                                 OBJ_CASE_INSENSITIVE,
06264                                 (HANDLE) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
06265                                 (PSECURITY_DESCRIPTOR) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
06266 
06267     <span class="comment">//</span>
06268     <span class="comment">// Open the symbolic link itself so that it can be marked temporary and</span>
06269     <span class="comment">// closed.</span>
06270     <span class="comment">//</span>
06271 
06272     status = ZwOpenSymbolicLinkObject( &amp;linkHandle,
06273                                        DELETE,
06274                                        &amp;objectAttributes );
06275     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
06276 
06277         <span class="comment">//</span>
06278         <span class="comment">// The symbolic link was successfully opened.  Attempt to make it a</span>
06279         <span class="comment">// temporary object, and then close the handle.  This will cause the</span>
06280         <span class="comment">// object to go away.</span>
06281         <span class="comment">//</span>
06282 
06283         status = ZwMakeTemporaryObject( linkHandle );
06284         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
06285             ZwClose( linkHandle );
06286         }
06287 
06288         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d8/ex_8h.html#a325">ExVerifySuite</a>(TerminalServer) == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
06289             <a class="code" href="../../d4/d6/iosubs_8c.html#a56">IopDeleteSessionSymLinks</a>( SymbolicLinkName );
06290         }
06291     }
06292 
06293 
06294     <span class="keywordflow">return</span> status;
06295 }
06296 
06297 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l06298"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a58">06298</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a58">IoDetachDevice</a>(
06299     IN OUT <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> TargetDevice
06300     )
06301 
06302 <span class="comment">/*++</span>
06303 <span class="comment"></span>
06304 <span class="comment">Routine Description:</span>
06305 <span class="comment"></span>
06306 <span class="comment">    This routine detaches the device object which is currently attached to the</span>
06307 <span class="comment">    target device.</span>
06308 <span class="comment"></span>
06309 <span class="comment">Arguments:</span>
06310 <span class="comment"></span>
06311 <span class="comment">    TargetDevice - Pointer to device object to be detached from.</span>
06312 <span class="comment"></span>
06313 <span class="comment">Return Value:</span>
06314 <span class="comment"></span>
06315 <span class="comment">    None.</span>
06316 <span class="comment"></span>
06317 <span class="comment"></span>
06318 <span class="comment">--*/</span>
06319 
06320 {
06321     KIRQL irql;
06322     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> detachingDevice;
06323     <a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html">PDEVOBJ_EXTENSION</a> detachingExtension;
06324 
06325     <span class="comment">//</span>
06326     <span class="comment">// Detach the device object attached to the target device.  This also</span>
06327     <span class="comment">// includes decrementing the reference count for the device.  Note that</span>
06328     <span class="comment">// if the driver has been marked for an unload operation, and the</span>
06329     <span class="comment">// reference count goes to zero, then the driver may need to be unloaded</span>
06330     <span class="comment">// at this point.</span>
06331     <span class="comment">//</span>
06332 
06333     ExAcquireSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, &amp;irql );
06334 
06335     <span class="comment">//</span>
06336     <span class="comment">// Tell the Special IRP code the stack has changed. Code that will reexamine</span>
06337     <span class="comment">// the stack takes the database lock, so we can place the call here. This</span>
06338     <span class="comment">// also allows us to assert correct behavoir *before* the stack is torn</span>
06339     <span class="comment">// down.</span>
06340     <span class="comment">//</span>
06341     <a class="code" href="../../d7/d6/ioverifier_8h.html#a3">IOV_DETACH_DEVICE</a>(TargetDevice);
06342 
06343     detachingDevice = TargetDevice-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o5">AttachedDevice</a>;
06344     detachingExtension = detachingDevice-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o25">DeviceObjectExtension</a>;
06345     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( detachingExtension-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o7">AttachedTo</a> == TargetDevice );
06346 
06347     <span class="comment">//</span>
06348     <span class="comment">// Unlink the device from the doubly-linked attachment chain.</span>
06349     <span class="comment">//</span>
06350 
06351     detachingExtension-&gt;<a class="code" href="../../d3/d5/struct__DEVOBJ__EXTENSION.html#o7">AttachedTo</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
06352     TargetDevice-&gt;AttachedDevice = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
06353 
06354     <span class="keywordflow">if</span> (TargetDevice-&gt;DeviceObjectExtension-&gt;ExtensionFlags &amp;
06355         (<a class="code" href="../../d0/d5/io_8h.html#a138">DOE_UNLOAD_PENDING</a> | <a class="code" href="../../d0/d5/io_8h.html#a139">DOE_DELETE_PENDING</a> | <a class="code" href="../../d0/d5/io_8h.html#a140">DOE_REMOVE_PENDING</a>) &amp;&amp;
06356         !TargetDevice-&gt;ReferenceCount) {
06357         <a class="code" href="../../d0/d6/iop_8h.html#a155">IopCompleteUnloadOrDelete</a>( TargetDevice, irql );
06358     } <span class="keywordflow">else</span> {
06359         ExReleaseSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, irql );
06360     }
06361 }
06362 
06363 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l06364"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a59">06364</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a59">IoDisconnectInterrupt</a>(
06365     IN <a class="code" href="../../d0/d7/struct__KINTERRUPT.html">PKINTERRUPT</a> InterruptObject
06366     )
06367 
06368 <span class="comment">/*++</span>
06369 <span class="comment"></span>
06370 <span class="comment">Routine Description:</span>
06371 <span class="comment"></span>
06372 <span class="comment">    This routine disconnects all of the interrupt objects that were</span>
06373 <span class="comment">    initialized and connected by the IoConnectInterrupt routine.  Note</span>
06374 <span class="comment">    that no interrupt objects directly connected using the kernel</span>
06375 <span class="comment">    services may be input to this routine.</span>
06376 <span class="comment"></span>
06377 <span class="comment">Arguments:</span>
06378 <span class="comment"></span>
06379 <span class="comment">    InterruptObject - Supplies a pointer to the interrupt object allocated</span>
06380 <span class="comment">        by the IoConnectInterrupt routine.</span>
06381 <span class="comment"></span>
06382 <span class="comment">Return Value:</span>
06383 <span class="comment"></span>
06384 <span class="comment">    None.</span>
06385 <span class="comment"></span>
06386 <span class="comment">--*/</span>
06387 
06388 {
06389     <a class="code" href="../../d3/d4/struct__IO__INTERRUPT__STRUCTURE.html">PIO_INTERRUPT_STRUCTURE</a> interruptStructure;
06390     ULONG i;
06391 
06392     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
06393 
06394     <span class="comment">//</span>
06395     <span class="comment">// Obtain a pointer to the builtin interrupt object in the I/O interrupt</span>
06396     <span class="comment">// structure.</span>
06397     <span class="comment">//</span>
06398 
06399     interruptStructure = CONTAINING_RECORD( <a class="code" href="../../d4/d9/ke_8h.html#a402a179">InterruptObject</a>,
06400                                             <a class="code" href="../../d3/d4/struct__IO__INTERRUPT__STRUCTURE.html">IO_INTERRUPT_STRUCTURE</a>,
06401                                             <a class="code" href="../../d4/d9/ke_8h.html#a402a179">InterruptObject</a> );
06402 
06403     <span class="comment">//</span>
06404     <span class="comment">// The builtin interrupt object is always used, so simply disconnect</span>
06405     <span class="comment">// it.</span>
06406     <span class="comment">//</span>
06407 
06408     <a class="code" href="../../d7/d4/ppc_2intobj_8c.html#a2">KeDisconnectInterrupt</a>( &amp;interruptStructure-&gt;<a class="code" href="../../d3/d4/struct__IO__INTERRUPT__STRUCTURE.html#o0">InterruptObject</a> );
06409 
06410     <span class="comment">//</span>
06411     <span class="comment">// Now loop through each of the interrupt objects pointed to by the</span>
06412     <span class="comment">// structure and disconnect each.</span>
06413     <span class="comment">//</span>
06414 
06415     <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="../../d9/d5/ndismain_8h.html#a183">MAXIMUM_PROCESSORS</a>; i++) {
06416         <span class="keywordflow">if</span> (interruptStructure-&gt;<a class="code" href="../../d3/d4/struct__IO__INTERRUPT__STRUCTURE.html#o1">InterruptArray</a>[i] != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
06417             <a class="code" href="../../d7/d4/ppc_2intobj_8c.html#a2">KeDisconnectInterrupt</a>( interruptStructure-&gt;<a class="code" href="../../d3/d4/struct__IO__INTERRUPT__STRUCTURE.html#o1">InterruptArray</a>[i] );
06418         }
06419     }
06420 
06421     <span class="comment">//</span>
06422     <span class="comment">// Finally, deallocate the memory associated with the entire structure.</span>
06423     <span class="comment">//</span>
06424 
06425     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( interruptStructure );
06426 }
06427 
06428 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l06429"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a60">06429</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a60">IoEnqueueIrp</a>(
06430     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
06431     )
06432 
06433 <span class="comment">/*++</span>
06434 <span class="comment"></span>
06435 <span class="comment">Routine Description:</span>
06436 <span class="comment"></span>
06437 <span class="comment">    This routine enqueues the specified I/O Request Packet (IRP) to the thread's</span>
06438 <span class="comment">    IRP pending queue.  The thread that the IRP is queued to is specified by</span>
06439 <span class="comment">    the IRP's Thread field.</span>
06440 <span class="comment"></span>
06441 <span class="comment">Arguments:</span>
06442 <span class="comment"></span>
06443 <span class="comment">    Irp - Supplies a pointer to the IRP to be enqueued.</span>
06444 <span class="comment"></span>
06445 <span class="comment">Return Value:</span>
06446 <span class="comment"></span>
06447 <span class="comment">    None.</span>
06448 <span class="comment"></span>
06449 <span class="comment">--*/</span>
06450 
06451 {
06452     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
06453 
06454     <span class="comment">//</span>
06455     <span class="comment">// Simply enqueue the IRP to the thread's IRP queue.</span>
06456     <span class="comment">//</span>
06457 
06458     <a class="code" href="../../d0/d6/iop_8h.html#a21">IopQueueThreadIrp</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
06459     <span class="keywordflow">return</span>;
06460 }
06461 
06462 BOOLEAN
<a name="l06463"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a61">06463</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a61">IoFastQueryNetworkAttributes</a>(
06464     IN POBJECT_ATTRIBUTES ObjectAttributes,
06465     IN ACCESS_MASK DesiredAccess,
06466     IN ULONG OpenOptions,
06467     OUT PIO_STATUS_BLOCK IoStatus,
06468     OUT PFILE_NETWORK_OPEN_INFORMATION Buffer
06469     )
06470 
06471 <span class="comment">/*++</span>
06472 <span class="comment"></span>
06473 <span class="comment">Routine Description:</span>
06474 <span class="comment"></span>
06475 <span class="comment">    This routine attempts to perform a fast I/O call to obtain the network</span>
06476 <span class="comment">    attributes for a file.  This involves a specialized interface between</span>
06477 <span class="comment">    this function and the I/O system's device parse method.  This allows the</span>
06478 <span class="comment">    parse method to have the file system pseudo-open the file, obtain the</span>
06479 <span class="comment">    appropriate attributes for the file, and return them to the caller w/as</span>
06480 <span class="comment">    little overhead as possbile from either the Object Manager or the I/O</span>
06481 <span class="comment">    system itself.</span>
06482 <span class="comment"></span>
06483 <span class="comment">Arguments:</span>
06484 <span class="comment"></span>
06485 <span class="comment">    ObjectAttributes - Supplies the attributes to be used for opening the</span>
06486 <span class="comment">        file (e.g., the file's name, etc).</span>
06487 <span class="comment"></span>
06488 <span class="comment">    DesiredAccess - Supplies the type(s) of access that the caller would like</span>
06489 <span class="comment">        to the file.</span>
06490 <span class="comment"></span>
06491 <span class="comment">    OpenOptions - Supplies standard NtOpenFile open options.</span>
06492 <span class="comment"></span>
06493 <span class="comment">    IoStatus - Supplies a pointer to a variable to receive the final status</span>
06494 <span class="comment">        of the operation.</span>
06495 <span class="comment"></span>
06496 <span class="comment">    Buffer - Supplies an output buffer to receive the network attributes for</span>
06497 <span class="comment">        the specified file.</span>
06498 <span class="comment"></span>
06499 <span class="comment">Return Value:</span>
06500 <span class="comment"></span>
06501 <span class="comment">    The final function value indicates whether or not the fast path could</span>
06502 <span class="comment">    be taken successfully.</span>
06503 <span class="comment"></span>
06504 <span class="comment">--*/</span>
06505 
06506 {
06507     HANDLE handle;
06508     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
06509     <a class="code" href="../../d3/d7/struct__OPEN__PACKET.html">OPEN_PACKET</a> openPacket;
06510     <a class="code" href="../../d0/d1/struct__DUMMY__FILE__OBJECT.html">DUMMY_FILE_OBJECT</a> localFileObject;
06511 
06512     <span class="comment">//</span>
06513     <span class="comment">// Build a parse open packet that tells the parse method to open the</span>
06514     <span class="comment">// file and query its network attributes using the fast path, if it</span>
06515     <span class="comment">// exists for this file.</span>
06516     <span class="comment">//</span>
06517 
06518     RtlZeroMemory( &amp;openPacket, <span class="keyword">sizeof</span>( <a class="code" href="../../d3/d7/struct__OPEN__PACKET.html">OPEN_PACKET</a> ) );
06519 
06520     openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o0">Type</a> = <a class="code" href="../../d0/d5/io_8h.html#a7">IO_TYPE_OPEN_PACKET</a>;
06521     openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o1">Size</a> = <span class="keyword">sizeof</span>( <a class="code" href="../../d0/d6/iop_8h.html#a55">OPEN_PACKET</a> );
06522     openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o10">ShareAccess</a> = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;
06523     openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o14">Disposition</a> = FILE_OPEN;
06524     openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o8">CreateOptions</a> = OpenOptions | FILE_OPEN_REPARSE_POINT;
06525     openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o13">Options</a> = <a class="code" href="../../d0/d5/io_8h.html#a104">IO_FORCE_ACCESS_CHECK</a>;
06526     openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o16">NetworkInformation</a> = <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>;
06527     openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o20">QueryOnly</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
06528     openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o22">FullAttributes</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
06529     openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o23">LocalFileObject</a> = &amp;localFileObject;
06530 
06531     <span class="comment">//</span>
06532     <span class="comment">// Open the object by its name.  Because of the special QueryOnly flag set</span>
06533     <span class="comment">// in the open packet, the parse routine will open the file using the fast</span>
06534     <span class="comment">// path open and perform the query, effectively closing it as well.</span>
06535     <span class="comment">//</span>
06536 
06537     status = <a class="code" href="../../d7/d1/obref_8c.html#a2">ObOpenObjectByName</a>( <a class="code" href="../../d7/d0/ctlnpqos_8c.html#a4">ObjectAttributes</a>,
06538                                  (<a class="code" href="../../d3/d6/struct__OBJECT__TYPE.html">POBJECT_TYPE</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
06539                                  <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
06540                                  <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
06541                                  DesiredAccess,
06542                                  &amp;openPacket,
06543                                  &amp;handle );
06544 
06545     <span class="comment">//</span>
06546     <span class="comment">// The opeation is successful if the parse check field of the open packet</span>
06547     <span class="comment">// indicates that the parse routine was actually invoked, and the final</span>
06548     <span class="comment">// status field of the packet is set to success.  The QueryOnly field is</span>
06549     <span class="comment">// set to whether or not the fast path was invoked.</span>
06550     <span class="comment">//</span>
06551 
06552     <span class="keywordflow">if</span> (openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o5">ParseCheck</a> != <a class="code" href="../../d0/d6/iop_8h.html#a3">OPEN_PACKET_PATTERN</a>) {
06553 
06554         <span class="comment">//</span>
06555         <span class="comment">// The parse routine was not invoked properly so the operation did</span>
06556         <span class="comment">// not work at all.</span>
06557         <span class="comment">//</span>
06558 
06559         IoStatus-&gt;Status = status;
06560     } <span class="keywordflow">else</span> {
06561 
06562         <span class="comment">//</span>
06563         <span class="comment">// The fast path routine was successfully invoked so return the</span>
06564         <span class="comment">// final status of the operation.</span>
06565         <span class="comment">//</span>
06566 
06567         IoStatus-&gt;Status = openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o3">FinalStatus</a>;
06568         IoStatus-&gt;Information = openPacket.<a class="code" href="../../d3/d7/struct__OPEN__PACKET.html#o4">Information</a>;
06569     }
06570     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
06571 }
06572 
06573 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l06574"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a62">06574</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a62">IoFreeController</a>(
06575     IN <a class="code" href="../../d1/d8/struct__CONTROLLER__OBJECT.html">PCONTROLLER_OBJECT</a> ControllerObject
06576     )
06577 
06578 <span class="comment">/*++</span>
06579 <span class="comment"></span>
06580 <span class="comment">Routine Description:</span>
06581 <span class="comment"></span>
06582 <span class="comment">    This routine is invoked to deallocate the specified controller object.</span>
06583 <span class="comment">    No checks are made to ensure that the controller is really allocated</span>
06584 <span class="comment">    to a device object.  However, if it is not, then kernel will bugcheck.</span>
06585 <span class="comment"></span>
06586 <span class="comment">    If another device is waiting in the queue to allocate the controller</span>
06587 <span class="comment">    object it will be pulled from the queue and its execution routine will</span>
06588 <span class="comment">    be invoked.</span>
06589 <span class="comment"></span>
06590 <span class="comment">Arguments:</span>
06591 <span class="comment"></span>
06592 <span class="comment">    ControllerObject - Pointer to the controller object to be deallocated.</span>
06593 <span class="comment"></span>
06594 <span class="comment">Return Value:</span>
06595 <span class="comment"></span>
06596 <span class="comment">    None.</span>
06597 <span class="comment"></span>
06598 <span class="comment">--*/</span>
06599 
06600 {
06601     <a class="code" href="../../d0/d6/struct__KDEVICE__QUEUE__ENTRY.html">PKDEVICE_QUEUE_ENTRY</a> packet;
06602     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
06603     <a class="code" href="../../d0/d5/io_8h.html#a321">IO_ALLOCATION_ACTION</a> action;
06604 
06605     <span class="comment">//</span>
06606     <span class="comment">// Simply remove the next entry from the controller's device wait queue.</span>
06607     <span class="comment">// If one was successfully removed, invoke its execution routine.</span>
06608     <span class="comment">//</span>
06609 
06610     packet = <a class="code" href="../../d7/d7/devquobj_8c.html#a4">KeRemoveDeviceQueue</a>( &amp;ControllerObject-&gt;DeviceWaitQueue );
06611     <span class="keywordflow">if</span> (packet != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
06612         deviceObject = CONTAINING_RECORD( packet,
06613                                           <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">DEVICE_OBJECT</a>,
06614                                           Queue.Wcb.WaitQueueEntry );
06615         action = deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o16">Queue</a>.Wcb.DeviceRoutine( deviceObject,
06616                                                         deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o6">CurrentIrp</a>,
06617                                                         0,
06618                                                         deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o16">Queue</a>.Wcb.DeviceContext );
06619 
06620         <span class="comment">//</span>
06621         <span class="comment">// If the execution routine wants the controller to be deallocate</span>
06622         <span class="comment">// now, deallocate it.</span>
06623         <span class="comment">//</span>
06624 
06625         <span class="keywordflow">if</span> (action == <a class="code" href="../../d0/d5/io_8h.html#a601a410">DeallocateObject</a>) {
06626             <a class="code" href="../../d4/d6/iosubs_8c.html#a62">IoFreeController</a>( ControllerObject );
06627         }
06628     }
06629 }
06630 
06631 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l06632"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a63">06632</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a63">IoFreeIrp</a>(
06633     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
06634     )
06635 {
06636     <a class="code" href="../../d0/d6/iop_8h.html#a135">pIoFreeIrp</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>);
06637 }
06638 
06639 
06640 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l06641"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a64">06641</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a64">IopFreeIrp</a>(
06642     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
06643     )
06644 
06645 <span class="comment">/*++</span>
06646 <span class="comment"></span>
06647 <span class="comment">Routine Description:</span>
06648 <span class="comment"></span>
06649 <span class="comment">    This routine deallocates the specified I/O Request Packet.</span>
06650 <span class="comment"></span>
06651 <span class="comment">Arguments:</span>
06652 <span class="comment"></span>
06653 <span class="comment">    Irp - I/O Request Packet to deallocate.</span>
06654 <span class="comment"></span>
06655 <span class="comment">Return Value:</span>
06656 <span class="comment"></span>
06657 <span class="comment">    None.</span>
06658 <span class="comment"></span>
06659 <span class="comment">--*/</span>
06660 
06661 {
06662     <a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html">PNPAGED_LOOKASIDE_LIST</a> lookasideList;
06663     <a class="code" href="../../d5/d8/ex_8h.html#a108">PP_NPAGED_LOOKASIDE_NUMBER</a> number;
06664     PKPRCB prcb;
06665 
06666     <span class="comment">//</span>
06667     <span class="comment">// Ensure that the data structure being freed is really an IRP.</span>
06668     <span class="comment">//</span>
06669 
06670     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o0">Type</a> == <a class="code" href="../../d0/d5/io_8h.html#a5">IO_TYPE_IRP</a> );
06671 
06672     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o0">Type</a> != <a class="code" href="../../d0/d5/io_8h.html#a5">IO_TYPE_IRP</a>) {
06673         <a class="code" href="../../d9/d1/bugcheck_8c.html#a19">KeBugCheckEx</a>( MULTIPLE_IRP_COMPLETE_REQUESTS, (ULONG_PTR) <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, __LINE__, 0, 0 );
06674     }
06675 
06676 
06677     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(IsListEmpty(&amp;(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>)-&gt;ThreadListEntry));
06678     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o0">Type</a> = 0;
06679 
06680     <span class="comment">//</span>
06681     <span class="comment">// Ensure that all of the owners of the IRP have at least been notified</span>
06682     <span class="comment">// that the request is going away.</span>
06683     <span class="comment">//</span>
06684 
06685     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a> &gt;= <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o12">StackCount</a> );
06686 
06687     <span class="comment">//</span>
06688     <span class="comment">// Deallocate the IRP.</span>
06689     <span class="comment">//</span>
06690 
06691     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o17">AllocationFlags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a193">IRP_LOOKASIDE_ALLOCATION</a>) {
06692         <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o17">AllocationFlags</a> ^= <a class="code" href="../../d0/d5/io_8h.html#a193">IRP_LOOKASIDE_ALLOCATION</a>;
06693         InterlockedDecrement( &amp;<a class="code" href="../../d0/d6/iop_8h.html#a130">IopLookasideIrpFloat</a> );
06694     }
06695     <span class="keywordflow">if</span> (!(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o17">AllocationFlags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a192">IRP_ALLOCATED_FIXED_SIZE</a>) ||
06696         (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o17">AllocationFlags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a191">IRP_ALLOCATED_MUST_SUCCEED</a>) ||
06697         (<a class="code" href="../../d0/d6/iop_8h.html#a130">IopLookasideIrpFloat</a> &gt;= <a class="code" href="../../d0/d6/iop_8h.html#a131">IopLookasideIrpLimit</a>)) {
06698         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
06699 
06700     } <span class="keywordflow">else</span> {
06701         number = <a class="code" href="../../d5/d8/ex_8h.html#a331a197">LookasideSmallIrpList</a>;
06702         <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o12">StackCount</a> != 1) {
06703             number = <a class="code" href="../../d5/d8/ex_8h.html#a331a198">LookasideLargeIrpList</a>;
06704         }
06705 
06706         prcb = <a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a2">KeGetCurrentPrcb</a>();
06707         lookasideList = prcb-&gt;PPLookasideList[number].P;
06708         lookasideList-&gt;<a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html#o0">L</a>.<a class="code" href="../../d6/d1/struct__GENERAL__LOOKASIDE.html#o6">TotalFrees</a> += 1;
06709         <span class="keywordflow">if</span> ( <a class="code" href="../../d5/d8/ex_8h.html#a10">ExQueryDepthSList</a>( &amp;lookasideList-&gt;<a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html#o0">L</a>.<a class="code" href="../../d6/d1/struct__GENERAL__LOOKASIDE.html#o0">ListHead</a> ) &gt;= lookasideList-&gt;<a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html#o0">L</a>.<a class="code" href="../../d6/d1/struct__GENERAL__LOOKASIDE.html#o1">Depth</a> ) {
06710             lookasideList-&gt;<a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html#o0">L</a>.<a class="code" href="../../d6/d1/struct__GENERAL__LOOKASIDE.html#o7">FreeMisses</a> += 1;
06711             lookasideList = prcb-&gt;PPLookasideList[number].<a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html#o0">L</a>;
06712             lookasideList-&gt;<a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html#o0">L</a>.<a class="code" href="../../d6/d1/struct__GENERAL__LOOKASIDE.html#o6">TotalFrees</a> += 1;
06713             <span class="keywordflow">if</span> (<a class="code" href="../../d5/d8/ex_8h.html#a10">ExQueryDepthSList</a>( &amp;lookasideList-&gt;<a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html#o0">L</a>.<a class="code" href="../../d6/d1/struct__GENERAL__LOOKASIDE.html#o0">ListHead</a> ) &gt;= lookasideList-&gt;<a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html#o0">L</a>.<a class="code" href="../../d6/d1/struct__GENERAL__LOOKASIDE.html#o1">Depth</a>) {
06714                 lookasideList-&gt;<a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html#o0">L</a>.<a class="code" href="../../d6/d1/struct__GENERAL__LOOKASIDE.html#o7">FreeMisses</a> += 1;
06715                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
06716 
06717             } <span class="keywordflow">else</span> {
06718                 <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o17">AllocationFlags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a190">IRP_QUOTA_CHARGED</a>) {
06719                     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o17">AllocationFlags</a> ^= <a class="code" href="../../d0/d5/io_8h.html#a190">IRP_QUOTA_CHARGED</a>;
06720                     <a class="code" href="../../d5/d8/ex_8h.html#a230">ExReturnPoolQuota</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
06721                 }
06722 
06723                 <a class="code" href="../../d5/d8/ex_8h.html#a243">ExInterlockedPushEntrySList</a>( &amp;lookasideList-&gt;<a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html#o0">L</a>.<a class="code" href="../../d6/d1/struct__GENERAL__LOOKASIDE.html#o0">ListHead</a>,
06724                                              (PSINGLE_LIST_ENTRY) <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>,
06725                                              &amp;lookasideList-&gt;<a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html#o1">Lock</a> );
06726             }
06727 
06728         } <span class="keywordflow">else</span> {
06729             <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o17">AllocationFlags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a190">IRP_QUOTA_CHARGED</a>) {
06730                 <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o17">AllocationFlags</a> ^= <a class="code" href="../../d0/d5/io_8h.html#a190">IRP_QUOTA_CHARGED</a>;
06731                 <a class="code" href="../../d5/d8/ex_8h.html#a230">ExReturnPoolQuota</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
06732             }
06733 
06734             <a class="code" href="../../d5/d8/ex_8h.html#a243">ExInterlockedPushEntrySList</a>( &amp;lookasideList-&gt;<a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html#o0">L</a>.<a class="code" href="../../d6/d1/struct__GENERAL__LOOKASIDE.html#o0">ListHead</a>,
06735                                          (PSINGLE_LIST_ENTRY) <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>,
06736                                          &amp;lookasideList-&gt;<a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html#o1">Lock</a> );
06737         }
06738     }
06739 
06740     <span class="keywordflow">return</span>;
06741 }
06742 
06743 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l06744"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a65">06744</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a65">IoFreeMdl</a>(
06745     IN <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> Mdl
06746     )
06747 
06748 <span class="comment">/*++</span>
06749 <span class="comment"></span>
06750 <span class="comment">Routine Description:</span>
06751 <span class="comment"></span>
06752 <span class="comment">    This routine frees a Memory Descriptor List (MDL).  It only frees the</span>
06753 <span class="comment">    specified MDL; any chained MDLs must be freed explicitly through another</span>
06754 <span class="comment">    call to this routine.</span>
06755 <span class="comment"></span>
06756 <span class="comment">Arguments:</span>
06757 <span class="comment"></span>
06758 <span class="comment">    Mdl - Pointer to the Memory Descriptor List to be freed.</span>
06759 <span class="comment"></span>
06760 <span class="comment">Return Value:</span>
06761 <span class="comment"></span>
06762 <span class="comment">    None.</span>
06763 <span class="comment"></span>
06764 <span class="comment">--*/</span>
06765 
06766 {
06767     <a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html">PNPAGED_LOOKASIDE_LIST</a> lookasideList;
06768 
06769     <span class="comment">//</span>
06770     <span class="comment">// Tell memory management that this MDL will be re-used.  This will</span>
06771     <span class="comment">// cause MM to unmap any pages that have been mapped for this MDL if</span>
06772     <span class="comment">// it is a partial MDL.</span>
06773     <span class="comment">//</span>
06774 
06775     <a class="code" href="../../d2/d1/mm_8h.html#a27">MmPrepareMdlForReuse</a>(Mdl);
06776     <span class="keywordflow">if</span> (((Mdl-&gt;MdlFlags &amp; <a class="code" href="../../d0/d9/ntosdef_8h.html#a15">MDL_ALLOCATED_FIXED_SIZE</a>) == 0) ||
06777         ((Mdl-&gt;MdlFlags &amp; <a class="code" href="../../d0/d9/ntosdef_8h.html#a26">MDL_ALLOCATED_MUST_SUCCEED</a>) != 0)) {
06778         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>(Mdl);
06779 
06780     } <span class="keywordflow">else</span> {
06781         <a class="code" href="../../d5/d8/ex_8h.html#a255">ExFreeToPPNPagedLookasideList</a>(<a class="code" href="../../d5/d8/ex_8h.html#a331a199">LookasideMdlList</a>, Mdl);
06782     }
06783 }
06784 
06785 <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>
<a name="l06786"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a66">06786</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a66">IoGetAttachedDevice</a>(
06787     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject
06788     )
06789 
06790 <span class="comment">/*++</span>
06791 <span class="comment"></span>
06792 <span class="comment">Routine Description:</span>
06793 <span class="comment"></span>
06794 <span class="comment">    This routine returns the highest level device object associated with</span>
06795 <span class="comment">    the specified device.</span>
06796 <span class="comment"></span>
06797 <span class="comment">    N.B. Caller must own the IopDatabaseLock. External callers of this</span>
06798 <span class="comment">    function must ensure nobody is attaching or detaching from the stack.</span>
06799 <span class="comment">    If they cannot, they *must* use IoGetAttachedDeviceReference.</span>
06800 <span class="comment"></span>
06801 <span class="comment">Arguments:</span>
06802 <span class="comment"></span>
06803 <span class="comment">    DeviceObject - Supplies a pointer to the device for which the attached</span>
06804 <span class="comment">        device is to be returned.</span>
06805 <span class="comment"></span>
06806 <span class="comment">Return Value:</span>
06807 <span class="comment"></span>
06808 <span class="comment">    The function value is the highest level device attached to the specified</span>
06809 <span class="comment">    device.  If no devices are attached, then the pointer to the device</span>
06810 <span class="comment">    object itself is returned.</span>
06811 <span class="comment"></span>
06812 <span class="comment">--*/</span>
06813 
06814 {
06815     <span class="comment">//</span>
06816     <span class="comment">// Loop through all of the device object's attached to the specified</span>
06817     <span class="comment">// device.  When the last device object is found that is not attached</span>
06818     <span class="comment">// to, return it.</span>
06819     <span class="comment">//</span>
06820 
06821     <span class="keywordflow">while</span> (DeviceObject-&gt;AttachedDevice) {
06822         DeviceObject = DeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o5">AttachedDevice</a>;
06823     }
06824 
06825     <span class="keywordflow">return</span> DeviceObject;
06826 }
06827 
06828 <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>
<a name="l06829"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a67">06829</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a67">IoGetAttachedDeviceReference</a>(
06830     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject
06831     )
06832 <span class="comment">/*++</span>
06833 <span class="comment"></span>
06834 <span class="comment">Routine Description:</span>
06835 <span class="comment"></span>
06836 <span class="comment">    This routine synchronizes with the Io database and returns a refernce</span>
06837 <span class="comment">    to the highest level device object associated withthe specified device.</span>
06838 <span class="comment"></span>
06839 <span class="comment">Arguments:</span>
06840 <span class="comment"></span>
06841 <span class="comment">    DeviceObject - Supplies a pointer to the device for which the attached</span>
06842 <span class="comment">        device is to be returned.</span>
06843 <span class="comment"></span>
06844 <span class="comment">Return Value:</span>
06845 <span class="comment"></span>
06846 <span class="comment">    The function value is a reference to the highest level device attached</span>
06847 <span class="comment">    to the specified device.  If no devices are attached, then the pointer</span>
06848 <span class="comment">    to the device object itself is returned.</span>
06849 <span class="comment"></span>
06850 <span class="comment">--*/</span>
06851 {
06852     KIRQL               irql;
06853 
06854     ExAcquireFastLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, &amp;irql );
06855     DeviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a66">IoGetAttachedDevice</a> (DeviceObject);
06856     <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a> (DeviceObject);
06857     ExReleaseFastLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, irql );
06858     <span class="keywordflow">return</span> DeviceObject;
06859 }
06860 
06861 <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>
<a name="l06862"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a68">06862</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a68">IoGetBaseFileSystemDeviceObject</a>(
06863     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject
06864     )
06865 
06866 <span class="comment">/*++</span>
06867 <span class="comment"></span>
06868 <span class="comment">Routine Description:</span>
06869 <span class="comment"></span>
06870 <span class="comment">    This routine returns the base (lowest-level) file system volume device</span>
06871 <span class="comment">    object associated with a file.  I.e., it locates the file system w/o</span>
06872 <span class="comment">    walking the attached device object list.</span>
06873 <span class="comment"></span>
06874 <span class="comment">Arguments:</span>
06875 <span class="comment"></span>
06876 <span class="comment">    FileObject - Supplies a pointer to the file object for which the base</span>
06877 <span class="comment">        file system device object is to be returned.</span>
06878 <span class="comment"></span>
06879 <span class="comment">Return Value:</span>
06880 <span class="comment"></span>
06881 <span class="comment">    The function value is the lowest level volume device object associated</span>
06882 <span class="comment">    w/the file.</span>
06883 <span class="comment"></span>
06884 <span class="comment">--*/</span>
06885 
06886 {
06887     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
06888 
06889     <span class="comment">//</span>
06890     <span class="comment">// If the file object has a mounted Vpb, use its DeviceObject.</span>
06891     <span class="comment">//</span>
06892 
06893     <span class="keywordflow">if</span> (FileObject-&gt;Vpb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> &amp;&amp; FileObject-&gt;Vpb-&gt;DeviceObject != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
06894         deviceObject = FileObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o10">Vpb</a>-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o4">DeviceObject</a>;
06895 
06896     <span class="comment">//</span>
06897     <span class="comment">// Otherwise, if the real device has a VPB that indicates that it is</span>
06898     <span class="comment">// mounted, then use the file system device object associated with the</span>
06899     <span class="comment">// VPB.</span>
06900     <span class="comment">//</span>
06901 
06902     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!(FileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a161">FO_DIRECT_DEVICE_OPEN</a>) &amp;&amp;
06903                FileObject-&gt;DeviceObject-&gt;Vpb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> &amp;&amp;
06904                FileObject-&gt;DeviceObject-&gt;Vpb-&gt;DeviceObject != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
06905 
06906             deviceObject = FileObject-&gt;DeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o10">Vpb</a>-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o4">DeviceObject</a>;
06907 
06908     <span class="comment">//</span>
06909     <span class="comment">// Otherwise, just return the real device object.</span>
06910     <span class="comment">//</span>
06911 
06912     } <span class="keywordflow">else</span> {
06913 
06914         deviceObject = FileObject-&gt;DeviceObject;
06915     }
06916 
06917     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( deviceObject != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
06918 
06919     <span class="comment">//</span>
06920     <span class="comment">// Simply return the resultant file object.</span>
06921     <span class="comment">//</span>
06922 
06923     <span class="keywordflow">return</span> deviceObject;
06924 }
06925 
06926 <a class="code" href="../../d6/d8/struct__CONFIGURATION__INFORMATION.html">PCONFIGURATION_INFORMATION</a>
<a name="l06927"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a69">06927</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a69">IoGetConfigurationInformation</a>( VOID )
06928 
06929 <span class="comment">/*++</span>
06930 <span class="comment"></span>
06931 <span class="comment">Routine Description:</span>
06932 <span class="comment"></span>
06933 <span class="comment">    This routine returns a pointer to the system's device configuration</span>
06934 <span class="comment">    information structure so that drivers and the system can determine how</span>
06935 <span class="comment">    many different types of devices exist in the system.</span>
06936 <span class="comment"></span>
06937 <span class="comment">Arguments:</span>
06938 <span class="comment"></span>
06939 <span class="comment">    None.</span>
06940 <span class="comment"></span>
06941 <span class="comment">Return Value:</span>
06942 <span class="comment"></span>
06943 <span class="comment">    The function value is a pointer to the configuration information</span>
06944 <span class="comment">    structure.</span>
06945 <span class="comment"></span>
06946 <span class="comment">--*/</span>
06947 
06948 {
06949     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
06950 
06951     <span class="comment">//</span>
06952     <span class="comment">// Simply return a pointer to the built-in configuration information</span>
06953     <span class="comment">// structure.</span>
06954     <span class="comment">//</span>
06955 
06956     <span class="keywordflow">return</span> (&amp;<a class="code" href="../../d4/d6/iosubs_8c.html#a7">ConfigurationInformation</a>);
06957 }
06958 
06959 <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a>
<a name="l06960"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a70">06960</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a70">IoGetCurrentProcess</a>( VOID )
06961 
06962 <span class="comment">/*++</span>
06963 <span class="comment"></span>
06964 <span class="comment">Routine Description:</span>
06965 <span class="comment"></span>
06966 <span class="comment">    This routine returns a pointer to the current process.  It is actually</span>
06967 <span class="comment">    a jacket routine for the PS version of the same function since device</span>
06968 <span class="comment">    drivers using the ntddk header file cannot see into a thread object.</span>
06969 <span class="comment"></span>
06970 <span class="comment">Arguments:</span>
06971 <span class="comment"></span>
06972 <span class="comment">    None.</span>
06973 <span class="comment"></span>
06974 <span class="comment">Return Value:</span>
06975 <span class="comment"></span>
06976 <span class="comment">    The function value is a pointer to the current process.</span>
06977 <span class="comment"></span>
06978 <span class="comment">Note:</span>
06979 <span class="comment"></span>
06980 <span class="comment">    Note that this function cannot be paged because it is invoked at raised</span>
06981 <span class="comment">    IRQL in debug builds, which is the only time that the PAGED_CODE macro</span>
06982 <span class="comment">    actually does anything.  Therefore, it is impossible to find code that</span>
06983 <span class="comment">    invokes this function at raised IRQL in a normal system w/o simply running</span>
06984 <span class="comment">    into the "proper conditions".  This is too risky to actually page this</span>
06985 <span class="comment">    routine, so it is left nonpaged.</span>
06986 <span class="comment"></span>
06987 <span class="comment">--*/</span>
06988 
06989 {
06990     <span class="comment">//</span>
06991     <span class="comment">// Simply return a pointer to the current process.</span>
06992     <span class="comment">//</span>
06993 
06994     <span class="keywordflow">return</span> <a class="code" href="../../d1/d9/ps_8h.html#a19">PsGetCurrentProcess</a>();
06995 }
06996 
06997 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l06998"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a71">06998</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a71">IoGetDeviceObjectPointer</a>(
06999     IN PUNICODE_STRING ObjectName,
07000     IN ACCESS_MASK DesiredAccess,
07001     OUT <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> *FileObject,
07002     OUT <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> *DeviceObject
07003     )
07004 
07005 <span class="comment">/*++</span>
07006 <span class="comment"></span>
07007 <span class="comment">Routine Description:</span>
07008 <span class="comment"></span>
07009 <span class="comment">    This routine returns a pointer to the device object specified by the</span>
07010 <span class="comment">    object name.  It also returns a pointer to the referenced file object</span>
07011 <span class="comment">    that has been opened to the device that ensures that the device cannot</span>
07012 <span class="comment">    go away.</span>
07013 <span class="comment"></span>
07014 <span class="comment">    To close access to the device, the caller should dereference the file</span>
07015 <span class="comment">    object pointer.</span>
07016 <span class="comment"></span>
07017 <span class="comment">Arguments:</span>
07018 <span class="comment"></span>
07019 <span class="comment">    ObjectName - Name of the device object for which a pointer is to be</span>
07020 <span class="comment">        returned.</span>
07021 <span class="comment"></span>
07022 <span class="comment">    DesiredAccess - Access desired to the target device object.</span>
07023 <span class="comment"></span>
07024 <span class="comment">    FileObject - Supplies the address of a variable to receive a pointer</span>
07025 <span class="comment">        to the file object for the device.</span>
07026 <span class="comment"></span>
07027 <span class="comment">    DeviceObject - Supplies the address of a variable to receive a pointer</span>
07028 <span class="comment">        to the device object for the specified device.</span>
07029 <span class="comment"></span>
07030 <span class="comment">Return Value:</span>
07031 <span class="comment"></span>
07032 <span class="comment">    The function value is a referenced pointer to the specified device</span>
07033 <span class="comment">    object, if the device exists.  Otherwise, NULL is returned.</span>
07034 <span class="comment"></span>
07035 <span class="comment">--*/</span>
07036 
07037 {
07038     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> fileObject;
07039     OBJECT_ATTRIBUTES objectAttributes;
07040     HANDLE fileHandle;
07041     IO_STATUS_BLOCK ioStatus;
07042     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
07043 
07044     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
07045 
07046     <span class="comment">//</span>
07047     <span class="comment">// Initialize the object attributes to open the device.</span>
07048     <span class="comment">//</span>
07049 
07050     InitializeObjectAttributes( &amp;objectAttributes,
07051                                 ObjectName,
07052                                 0,
07053                                 (HANDLE) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
07054                                 (PSECURITY_DESCRIPTOR) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
07055 
07056     status = <a class="code" href="../../d6/d9/restrfil_8c.html#a33">ZwOpenFile</a>( &amp;fileHandle,
07057                          DesiredAccess,
07058                          &amp;objectAttributes,
07059                          &amp;ioStatus,
07060                          0,
07061                          FILE_NON_DIRECTORY_FILE );
07062 
07063     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
07064 
07065         <span class="comment">//</span>
07066         <span class="comment">// The open operation was successful.  Dereference the file handle</span>
07067         <span class="comment">// and obtain a pointer to the device object for the handle.</span>
07068         <span class="comment">//</span>
07069 
07070         status = <a class="code" href="../../d7/d1/obref_8c.html#a4">ObReferenceObjectByHandle</a>( fileHandle,
07071                                             0,
07072                                             <a class="code" href="../../d5/d8/fssup_8c.html#a3">IoFileObjectType</a>,
07073                                             <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
07074                                             (PVOID *) &amp;fileObject,
07075                                             <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
07076         <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
07077 
07078             *FileObject = fileObject;
07079 
07080             <span class="comment">//</span>
07081             <span class="comment">// Get a pointer to the device object for this file.</span>
07082             <span class="comment">//</span>
07083             *DeviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( fileObject );
07084         }
07085 
07086         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) ZwClose( fileHandle );
07087     }
07088 
07089     <span class="keywordflow">return</span> status;
07090 }
07091 
07092 <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>
<a name="l07093"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a72">07093</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a72">IoGetDeviceToVerify</a>(
07094     IN <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a> Thread
07095     )
07096 
07097 <span class="comment">/*++</span>
07098 <span class="comment"></span>
07099 <span class="comment">Routine Description:</span>
07100 <span class="comment"></span>
07101 <span class="comment">    This routine returns a pointer to the device object that is to be verified.</span>
07102 <span class="comment">    The pointer is set in the thread object by a device driver when the disk</span>
07103 <span class="comment">    or CD-ROM media appears to have changed since the last access to the device.</span>
07104 <span class="comment"></span>
07105 <span class="comment">Arguments:</span>
07106 <span class="comment"></span>
07107 <span class="comment">    Thread - Pointer to the thread whose field is to be queried.</span>
07108 <span class="comment"></span>
07109 <span class="comment">Return Value:</span>
07110 <span class="comment"></span>
07111 <span class="comment">    The function value is a pointer to the device to be verified, or NULL.</span>
07112 <span class="comment"></span>
07113 <span class="comment">Note:</span>
07114 <span class="comment"></span>
07115 <span class="comment">    This function cannot be made a macro, since fields in the thread object</span>
07116 <span class="comment">    move from release to release, so this must remain a full function.</span>
07117 <span class="comment"></span>
07118 <span class="comment"></span>
07119 <span class="comment">--*/</span>
07120 
07121 {
07122     <span class="comment">//</span>
07123     <span class="comment">// Simply return the device to be verified.</span>
07124     <span class="comment">//</span>
07125 
07126     <span class="keywordflow">return</span> Thread-&gt;DeviceToVerify;
07127 }
07128 
07129 <a class="code" href="../../d0/d9/ntosdef_8h.html#a29">NTKERNELAPI</a>
07130 PVOID
<a name="l07131"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a73">07131</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a73">IoGetDriverObjectExtension</a>(
07132     IN <a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html">PDRIVER_OBJECT</a> DriverObject,
07133     IN PVOID ClientIdentificationAddress
07134     )
07135 <span class="comment">/*++</span>
07136 <span class="comment"></span>
07137 <span class="comment">Routine Description:</span>
07138 <span class="comment"></span>
07139 <span class="comment">    This routine returns a pointer to the client driver object extension.</span>
07140 <span class="comment">    This extension was allocated using IoAllocateDriverObjectExtension. If</span>
07141 <span class="comment">    an extension with the create Id does not exist for the specified driver</span>
07142 <span class="comment">    object then NULL is returned.</span>
07143 <span class="comment"></span>
07144 <span class="comment">Arguments:</span>
07145 <span class="comment"></span>
07146 <span class="comment">    DriverObject - Pointer to driver object owning the extension.</span>
07147 <span class="comment"></span>
07148 <span class="comment">    ClientIdentificationAddress - Supplies the unique identifier which was</span>
07149 <span class="comment">        used to create the extension.</span>
07150 <span class="comment"></span>
07151 <span class="comment">Return Value:</span>
07152 <span class="comment"></span>
07153 <span class="comment">    The function value is a pointer to the client driver object extension,</span>
07154 <span class="comment">    or NULL.</span>
07155 <span class="comment"></span>
07156 <span class="comment">--*/</span>
07157 
07158 {
07159     KIRQL irql;
07160     <a class="code" href="../../d1/d4/struct__IO__CLIENT__EXTENSION.html">PIO_CLIENT_EXTENSION</a> <a class="code" href="../../d7/d1/genuedef_8c.html#a6">extension</a>;
07161 
07162     ExAcquireFastLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, &amp;irql );
07163     <a class="code" href="../../d7/d1/genuedef_8c.html#a6">extension</a> = DriverObject-&gt;DriverExtension-&gt;ClientDriverExtension;
07164     <span class="keywordflow">while</span> (<a class="code" href="../../d7/d1/genuedef_8c.html#a6">extension</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
07165 
07166         <span class="keywordflow">if</span> (<a class="code" href="../../d7/d1/genuedef_8c.html#a6">extension</a>-&gt;ClientIdentificationAddress == ClientIdentificationAddress) {
07167             <span class="keywordflow">break</span>;
07168         }
07169 
07170         <a class="code" href="../../d7/d1/genuedef_8c.html#a6">extension</a> = <a class="code" href="../../d7/d1/genuedef_8c.html#a6">extension</a>-&gt;NextExtension;
07171     }
07172 
07173     ExReleaseFastLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, irql );
07174 
07175     <span class="keywordflow">if</span> (<a class="code" href="../../d7/d1/genuedef_8c.html#a6">extension</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
07176         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
07177     }
07178 
07179     <span class="keywordflow">return</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a6">extension</a> + 1;
07180 }
07181 
07182 PGENERIC_MAPPING
<a name="l07183"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a74">07183</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a74">IoGetFileObjectGenericMapping</a>(
07184     VOID
07185     )
07186 
07187 <span class="comment">/*++</span>
07188 <span class="comment"></span>
07189 <span class="comment">Routine Description:</span>
07190 <span class="comment"></span>
07191 <span class="comment">    This routine returns a pointer to the generic mapping for a file object.</span>
07192 <span class="comment"></span>
07193 <span class="comment">Arguments:</span>
07194 <span class="comment"></span>
07195 <span class="comment">    None.</span>
07196 <span class="comment"></span>
07197 <span class="comment">Return Value:</span>
07198 <span class="comment"></span>
07199 <span class="comment">    A pointer to the generic mapping for a file object.</span>
07200 <span class="comment"></span>
07201 <span class="comment">--*/</span>
07202 
07203 {
07204     <span class="comment">//</span>
07205     <span class="comment">// Simply return a pointer to the generic mapping for a file object.</span>
07206     <span class="comment">//</span>
07207 
07208     <span class="keywordflow">return</span> &amp;<a class="code" href="../../d9/d5/ioinit_8c.html#a11">IopFileMapping</a>;
07209 }
07210 
07211 PVOID
<a name="l07212"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a75">07212</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a75">IoGetInitialStack</a>(
07213     VOID
07214     )
07215 
07216 <span class="comment">/*++</span>
07217 <span class="comment"></span>
07218 <span class="comment">Routine Description:</span>
07219 <span class="comment"></span>
07220 <span class="comment">    This routine returns the base initial address of the current thread's</span>
07221 <span class="comment">    stack.</span>
07222 <span class="comment"></span>
07223 <span class="comment">Arguments:</span>
07224 <span class="comment"></span>
07225 <span class="comment">    None.</span>
07226 <span class="comment"></span>
07227 <span class="comment">Return Value:</span>
07228 <span class="comment"></span>
07229 <span class="comment">    The base initial address of the current thread's stack.</span>
07230 <span class="comment"></span>
07231 <span class="comment">Note:</span>
07232 <span class="comment"></span>
07233 <span class="comment">    This function cannot be made a macro, since fields in the thread object</span>
07234 <span class="comment">    move from release to release, so this must remain a full function.</span>
07235 <span class="comment"></span>
07236 <span class="comment">--*/</span>
07237 
07238 {
07239     <span class="comment">//</span>
07240     <span class="comment">// Simply return the initial stack for this thread.</span>
07241     <span class="comment">//</span>
07242 
07243     <span class="keywordflow">return</span> <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>()-&gt;Tcb.InitialStack;
07244 }
07245 
07246 <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a>
<a name="l07247"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a76">07247</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>(
07248     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject
07249     )
07250 
07251 <span class="comment">/*++</span>
07252 <span class="comment"></span>
07253 <span class="comment">Routine Description:</span>
07254 <span class="comment"></span>
07255 <span class="comment">    This routine returns a pointer to the actual device object than an I/O</span>
07256 <span class="comment">    Request Packet (IRP) should be given to based on the specified file</span>
07257 <span class="comment">    object.</span>
07258 <span class="comment"></span>
07259 <span class="comment">    N.B. - Callers of this function must ensure no device object is</span>
07260 <span class="comment">    attaching or detaching from this stack for the duration of this call.</span>
07261 <span class="comment">    This is because the database lock is *not* held!</span>
07262 <span class="comment"></span>
07263 <span class="comment">Arguments:</span>
07264 <span class="comment"></span>
07265 <span class="comment">    FileObject - Pointer to the file object representing the open file.</span>
07266 <span class="comment"></span>
07267 <span class="comment">Return Value:</span>
07268 <span class="comment"></span>
07269 <span class="comment">    The return value is a pointer to the device object for the driver to</span>
07270 <span class="comment">    whom the request is to be given.</span>
07271 <span class="comment"></span>
07272 <span class="comment">--*/</span>
07273 
07274 {
07275     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
07276 
07277     <span class="comment">//</span>
07278     <span class="comment">// If the file object was taken out against the mounted file system, it</span>
07279     <span class="comment">// will have a Vpb. Traverse it to get to the DeviceObject. Note that in</span>
07280     <span class="comment">// this case we should never follow FileObject-&gt;DeviceObject, as that</span>
07281     <span class="comment">// mapping may be invalid after a forced dismount.</span>
07282     <span class="comment">//</span>
07283 
07284     <span class="keywordflow">if</span> (FileObject-&gt;Vpb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> &amp;&amp; FileObject-&gt;Vpb-&gt;DeviceObject != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
07285 
07286         <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(!(FileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a161">FO_DIRECT_DEVICE_OPEN</a>));
07287         deviceObject = FileObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o10">Vpb</a>-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o4">DeviceObject</a>;
07288 
07289 
07290         <span class="comment">//</span>
07291         <span class="comment">// If a driver opened a disk device using direct device open and </span>
07292         <span class="comment">// later on it uses IoGetRelatedTargetDeviceObject to find the</span>
07293         <span class="comment">// device object it wants to send an IRP then it should not get the</span>
07294         <span class="comment">// filesystem device object. This is so that if the device object is in the</span>
07295         <span class="comment">// process of being mounted then vpb is not stable.</span>
07296         <span class="comment">//</span>
07297 
07298     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!(FileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a161">FO_DIRECT_DEVICE_OPEN</a>) &amp;&amp;
07299                FileObject-&gt;DeviceObject-&gt;Vpb != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> &amp;&amp;
07300                FileObject-&gt;DeviceObject-&gt;Vpb-&gt;DeviceObject != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
07301 
07302             deviceObject = FileObject-&gt;DeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o10">Vpb</a>-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o4">DeviceObject</a>;
07303 
07304     <span class="comment">//</span>
07305     <span class="comment">// This is a direct open against the device stack (and there is no mounted</span>
07306     <span class="comment">// file system to strain the IRPs through).</span>
07307     <span class="comment">//</span>
07308 
07309     } <span class="keywordflow">else</span> {
07310 
07311         deviceObject = FileObject-&gt;DeviceObject;
07312     }
07313 
07314     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( deviceObject != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
07315 
07316     <span class="comment">//</span>
07317     <span class="comment">// Check to see whether or not the device has any associated devices.</span>
07318     <span class="comment">// If so, return the highest level device; otherwise, return a pointer</span>
07319     <span class="comment">// to the device object itself.</span>
07320     <span class="comment">//</span>
07321 
07322     <span class="keywordflow">if</span> (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o5">AttachedDevice</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
07323         deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a66">IoGetAttachedDevice</a>( deviceObject );
07324     }
07325 
07326     <span class="keywordflow">return</span> deviceObject;
07327 }
07328 
07329 ULONG
<a name="l07330"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a77">07330</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a77">IoGetRequestorProcessId</a>(
07331     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
07332     )
07333 
07334 <span class="comment">/*++</span>
07335 <span class="comment"></span>
07336 <span class="comment">Routine Description:</span>
07337 <span class="comment"></span>
07338 <span class="comment">    This routine returns a 32-bit value that is unique to the process that</span>
07339 <span class="comment">    originally requested the specified I/O operation.</span>
07340 <span class="comment"></span>
07341 <span class="comment">Arguments:</span>
07342 <span class="comment"></span>
07343 <span class="comment">    Irp - Pointer to the I/O Request Packet.</span>
07344 <span class="comment"></span>
07345 <span class="comment">Return Value:</span>
07346 <span class="comment"></span>
07347 <span class="comment">    The function value is the 32-bit process ID.</span>
07348 <span class="comment"></span>
07349 <span class="comment"></span>
07350 <span class="comment">--*/</span>
07351 
07352 {
07353     <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> process;
07354 
07355     process = <a class="code" href="../../d4/d6/iosubs_8c.html#a78">IoGetRequestorProcess</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
07356     <span class="keywordflow">if</span> (process != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
07357 
07358         <span class="comment">//</span>
07359         <span class="comment">// UniqueProcessId is a kernel-mode handle, safe to truncate to ULONG.</span>
07360         <span class="comment">//</span>
07361 
07362         <span class="keywordflow">return</span> HandleToUlong( process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o7">UniqueProcessId</a> );
07363     } <span class="keywordflow">else</span> {
07364 
07365         <span class="comment">//</span>
07366         <span class="comment">// Return a PID of zero if there is no process associated with the IRP.</span>
07367         <span class="comment">//</span>
07368 
07369         <span class="keywordflow">return</span> 0;
07370     }
07371 }
07372 
07373 <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a>
<a name="l07374"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a78">07374</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a78">IoGetRequestorProcess</a>(
07375     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
07376     )
07377 
07378 <span class="comment">/*++</span>
07379 <span class="comment"></span>
07380 <span class="comment">Routine Description:</span>
07381 <span class="comment"></span>
07382 <span class="comment">    This routine returns a pointer to the process that originally</span>
07383 <span class="comment">    requested the specified I/O operation.</span>
07384 <span class="comment"></span>
07385 <span class="comment">Arguments:</span>
07386 <span class="comment"></span>
07387 <span class="comment">    Irp - Pointer to the I/O Request Packet.</span>
07388 <span class="comment"></span>
07389 <span class="comment">Return Value:</span>
07390 <span class="comment"></span>
07391 <span class="comment">    The function value is a pointer to the original requesting process.</span>
07392 <span class="comment"></span>
07393 <span class="comment"></span>
07394 <span class="comment">--*/</span>
07395 
07396 {
07397     <span class="comment">//</span>
07398     <span class="comment">// Return the address of the process that requested the I/O operation.</span>
07399     <span class="comment">//</span>
07400 
07401     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread) {
07402         <span class="keywordflow">return</span> <a class="code" href="../../d1/d9/ps_8h.html#a17">THREAD_TO_PROCESS</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread );
07403     } <span class="keywordflow">else</span> {
07404         <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
07405     }
07406 }
07407 
07408 <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>
<a name="l07409"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a79">07409</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a79">IoGetTopLevelIrp</a>(
07410     VOID
07411     )
07412 
07413 <span class="comment">/*++</span>
07414 <span class="comment"></span>
07415 <span class="comment">Routine Description:</span>
07416 <span class="comment"></span>
07417 <span class="comment">    This routine returns the contents of the TopLevelIrp field of the current</span>
07418 <span class="comment">    thread.</span>
07419 <span class="comment"></span>
07420 <span class="comment">Arguments:</span>
07421 <span class="comment"></span>
07422 <span class="comment">    None.</span>
07423 <span class="comment"></span>
07424 <span class="comment">Return Value:</span>
07425 <span class="comment"></span>
07426 <span class="comment">    The final function value is the contents of the TopLevelIrp field.</span>
07427 <span class="comment"></span>
07428 <span class="comment">Note:</span>
07429 <span class="comment"></span>
07430 <span class="comment">    This function cannot be made a macro, since fields in the thread object</span>
07431 <span class="comment">    move from release to release, so this must remain a full function.</span>
07432 <span class="comment"></span>
07433 <span class="comment">--*/</span>
07434 
07435 {
07436     <span class="comment">//</span>
07437     <span class="comment">// Simply return the TopLevelIrp field of the thread.</span>
07438     <span class="comment">//</span>
07439 
07440     <span class="keywordflow">return</span> (<a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>) (<a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>()-&gt;TopLevelIrp);
07441 }
07442 
07443 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l07444"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a80">07444</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a80">IoInitializeIrp</a>(
07445     IN OUT <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
07446     IN USHORT PacketSize,
07447     IN CCHAR StackSize
07448     )
07449 
07450 <span class="comment">/*++</span>
07451 <span class="comment"></span>
07452 <span class="comment">Routine Description:</span>
07453 <span class="comment"></span>
07454 <span class="comment">    Initializes an IRP.</span>
07455 <span class="comment"></span>
07456 <span class="comment">Arguments:</span>
07457 <span class="comment"></span>
07458 <span class="comment">    Irp - a pointer to the IRP to initialize.</span>
07459 <span class="comment"></span>
07460 <span class="comment">    PacketSize - length, in bytes, of the IRP.</span>
07461 <span class="comment"></span>
07462 <span class="comment">    StackSize - Number of stack locations in the IRP.</span>
07463 <span class="comment"></span>
07464 <span class="comment">Return Value:</span>
07465 <span class="comment"></span>
07466 <span class="comment">    None.</span>
07467 <span class="comment"></span>
07468 <span class="comment">--*/</span>
07469 
07470 {
07471     <a class="code" href="../../d7/d6/ioverifier_8h.html#a1">IOV_INITIALIZE_IRP</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, PacketSize, StackSize);
07472 
07473     <span class="comment">//</span>
07474     <span class="comment">// Begin by zeroing the entire packet.</span>
07475     <span class="comment">//</span>
07476 
07477     RtlZeroMemory( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, PacketSize );
07478 
07479     <span class="comment">//</span>
07480     <span class="comment">// Initialize the remainder of the packet by setting the appropriate fields</span>
07481     <span class="comment">// and setting up the I/O stack locations in the packet.</span>
07482     <span class="comment">//</span>
07483 
07484     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o0">Type</a> = (CSHORT) <a class="code" href="../../d0/d5/io_8h.html#a5">IO_TYPE_IRP</a>;
07485     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o1">Size</a> = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) PacketSize;
07486     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o12">StackCount</a> = (CCHAR) StackSize;
07487     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o13">CurrentLocation</a> = (CCHAR) (StackSize + 1);
07488     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o16">ApcEnvironment</a> = <a class="code" href="../../d4/d9/ke_8h.html#a11">KeGetCurrentApcEnvironment</a>();
07489     InitializeListHead (&amp;(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>)-&gt;ThreadListEntry);
07490     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.CurrentStackLocation =
07491         ((<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a>) ((UCHAR *) (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>) +
07492             <span class="keyword">sizeof</span>( <a class="code" href="../../d0/d2/struct__IRP.html">IRP</a> ) +
07493             ( (StackSize) * <span class="keyword">sizeof</span>( <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">IO_STACK_LOCATION</a> ))));
07494 }
07495 
07496 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l07497"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a81">07497</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a81">IoReuseIrp</a>(
07498     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
07499     NTSTATUS Status)
07500 <span class="comment">/*++</span>
07501 <span class="comment"></span>
07502 <span class="comment">Routine Description:</span>
07503 <span class="comment"></span>
07504 <span class="comment">    This routine is used by drivers to initialize an already allocated IRP for reuse.</span>
07505 <span class="comment">    It does what IoInitializeIrp does but it saves the allocation flags so that we know</span>
07506 <span class="comment">    how to free the Irp and take care of quote requirements. Drivers should call IoReuseIrp</span>
07507 <span class="comment">    instead of calling IoInitializeIrp to reinitialize an IRP.</span>
07508 <span class="comment"></span>
07509 <span class="comment">Arguments:</span>
07510 <span class="comment"></span>
07511 <span class="comment">    Irp - Pointer to Irp to be reused</span>
07512 <span class="comment"></span>
07513 <span class="comment">    Status - Status to preinitialize the Iostatus field.</span>
07514 <span class="comment"></span>
07515 <span class="comment">--*/</span>
07516 {
07517 
07518     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>  PacketSize;
07519     CCHAR   StackSize;
07520     UCHAR   AllocationFlags;
07521 
07522     <span class="comment">// Did anyone forget to pull their cancel routine?</span>
07523     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o25">CancelRoutine</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) ;
07524 
07525     <span class="comment">// We probably don't want thread enqueue'd IRPs to be used</span>
07526     <span class="comment">// ping-pong style as they cannot be dequeue unless they</span>
07527     <span class="comment">// complete entirely. Not really an issue for worker threads,</span>
07528     <span class="comment">// but definitely for operations on application threads.</span>
07529     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(IsListEmpty(&amp;<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o8">ThreadListEntry</a>)) ;
07530 
07531     AllocationFlags = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o17">AllocationFlags</a>;
07532     StackSize = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o12">StackCount</a>;
07533     PacketSize =  <a class="code" href="../../d0/d5/io_8h.html#a245">IoSizeOfIrp</a>(StackSize);
07534     <a class="code" href="../../d0/d6/iop_8h.html#a20">IopInitializeIrp</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, PacketSize, StackSize);
07535     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o17">AllocationFlags</a> = AllocationFlags;
07536     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status = <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
07537 
07538 }
07539 
07540 
07541 
07542 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l07543"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a82">07543</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a82">IoInitializeTimer</a>(
07544     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
07545     IN PIO_TIMER_ROUTINE TimerRoutine,
07546     IN PVOID Context
07547     )
07548 
07549 <span class="comment">/*++</span>
07550 <span class="comment"></span>
07551 <span class="comment">Routine Description:</span>
07552 <span class="comment"></span>
07553 <span class="comment">    This routine is used by drivers to initialize a timer entry for a device</span>
07554 <span class="comment">    object.</span>
07555 <span class="comment"></span>
07556 <span class="comment">Arguments:</span>
07557 <span class="comment"></span>
07558 <span class="comment">    DeviceObject - Pointer to device object to be used.</span>
07559 <span class="comment"></span>
07560 <span class="comment">    TimerRoutine - Driver routine to be executed when timer expires.</span>
07561 <span class="comment"></span>
07562 <span class="comment">    Context - Context parameter that is passed to the driver routine.</span>
07563 <span class="comment"></span>
07564 <span class="comment">Return Value:</span>
07565 <span class="comment"></span>
07566 <span class="comment">    The function value indicates whether or not the timer was initialized.</span>
07567 <span class="comment"></span>
07568 <span class="comment">--*/</span>
07569 
07570 {
07571     <a class="code" href="../../d4/d9/struct__IO__TIMER.html">PIO_TIMER</a> timer;
07572 
07573     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
07574 
07575     <span class="comment">//</span>
07576     <span class="comment">// Begin by getting the address of the timer to be used.  If no timer has</span>
07577     <span class="comment">// been allocated, allocate one and initialize it.</span>
07578     <span class="comment">//</span>
07579 
07580     timer = DeviceObject-&gt;Timer;
07581     <span class="keywordflow">if</span> (!timer) {
07582         timer = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, <span class="keyword">sizeof</span>( <a class="code" href="../../d4/d9/struct__IO__TIMER.html">IO_TIMER</a> ), 'iToI' );
07583         <span class="keywordflow">if</span> (!timer) {
07584             <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
07585         }
07586 
07587         <span class="comment">//</span>
07588         <span class="comment">// Initialize the timer entry so that it is suitable for being placed</span>
07589         <span class="comment">// into the I/O system's timer queue.</span>
07590         <span class="comment">//</span>
07591 
07592         RtlZeroMemory( timer, <span class="keyword">sizeof</span>( <a class="code" href="../../d0/d5/io_8h.html#a328">IO_TIMER</a> ) );
07593         timer-&gt;<a class="code" href="../../d4/d9/struct__IO__TIMER.html#o0">Type</a> = <a class="code" href="../../d0/d5/io_8h.html#a8">IO_TYPE_TIMER</a>;
07594         timer-&gt;<a class="code" href="../../d4/d9/struct__IO__TIMER.html#o5">DeviceObject</a> = DeviceObject;
07595         DeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o7">Timer</a> = timer;
07596     }
07597 
07598     <span class="comment">//</span>
07599     <span class="comment">// Set the address of the driver's timer routine and the context parameter</span>
07600     <span class="comment">// passed to it and insert it onto the timer queue.  Note that the timer</span>
07601     <span class="comment">// enable flag is not set, so this routine will not actually be invoked</span>
07602     <span class="comment">// yet.</span>
07603     <span class="comment">//</span>
07604 
07605     timer-&gt;<a class="code" href="../../d4/d9/struct__IO__TIMER.html#o3">TimerRoutine</a> = TimerRoutine;
07606     timer-&gt;<a class="code" href="../../d4/d9/struct__IO__TIMER.html#o4">Context</a> = Context;
07607 
07608     <a class="code" href="../../d5/d8/ex_8h.html#a238">ExInterlockedInsertTailList</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a28">IopTimerQueueHead</a>,
07609                                  &amp;timer-&gt;<a class="code" href="../../d4/d9/struct__IO__TIMER.html#o2">TimerList</a>,
07610                                  &amp;<a class="code" href="../../d4/d4/alpha_2splocks_8c.html#a8">IopTimerLock</a> );
07611     <span class="keywordflow">return</span> STATUS_SUCCESS;
07612 }
07613 
07614 BOOLEAN
<a name="l07615"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a83">07615</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a83">IoIsOperationSynchronous</a>(
07616     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
07617     )
07618 
07619 <span class="comment">/*++</span>
07620 <span class="comment"></span>
07621 <span class="comment">Routine Description:</span>
07622 <span class="comment"></span>
07623 <span class="comment">    This routine determines whether an I/O operation is to be considered</span>
07624 <span class="comment">    synchronous or an asynchronous, from the implementors point-of-view.</span>
07625 <span class="comment">    Synchronous I/O is defined by how the file was opened, or the API being</span>
07626 <span class="comment">    used to perform the operation, or by the type of paging I/O being</span>
07627 <span class="comment">    performed, if the operation is paging I/O.</span>
07628 <span class="comment"></span>
07629 <span class="comment">    It is possible for asynchronous paging I/O to occur to a file that was</span>
07630 <span class="comment">    opened for synchronous I/O.  This occurs when the Modified Page Writer</span>
07631 <span class="comment">    is doing I/O to a file that is mapped, when too many modified pages exist</span>
07632 <span class="comment">    in the system.</span>
07633 <span class="comment"></span>
07634 <span class="comment">Arguments:</span>
07635 <span class="comment"></span>
07636 <span class="comment">    Irp - Pointer to the I/O Request Packet (IRP) representing the operation</span>
07637 <span class="comment">        to be performed.</span>
07638 <span class="comment"></span>
07639 <span class="comment">Return Value:</span>
07640 <span class="comment"></span>
07641 <span class="comment">    A value of TRUE is returned if the operation is synchronous, otherwise</span>
07642 <span class="comment">    FALSE is returned.</span>
07643 <span class="comment"></span>
07644 <span class="comment">--*/</span>
07645 
07646 {
07647     <span class="comment">//</span>
07648     <span class="comment">// Determine whether this is a synchronous I/O operation.  Synchronous I/O</span>
07649     <span class="comment">// is defined as an operation that is:</span>
07650     <span class="comment">//</span>
07651     <span class="comment">//     A file opened for synchronous I/O</span>
07652     <span class="comment">//         OR</span>
07653     <span class="comment">//     A synchronous API operation</span>
07654     <span class="comment">//         OR</span>
07655     <span class="comment">//     A synchronous paging I/O operation</span>
07656     <span class="comment">//</span>
07657     <span class="comment">//  AND this is NOT an asynchronous paging I/O operation occurring to some</span>
07658     <span class="comment">//  file that was opened for either synchronous or asynchronous I/O.</span>
07659     <span class="comment">//</span>
07660 
07661     <span class="keywordflow">if</span> ((<a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> )-&gt;FileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a> ||
07662         <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a176">IRP_SYNCHRONOUS_API</a> ||
07663         <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a181">IRP_SYNCHRONOUS_PAGING_IO</a>) &amp;&amp;
07664         !(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a174">IRP_PAGING_IO</a> &amp;&amp;
07665         !(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a181">IRP_SYNCHRONOUS_PAGING_IO</a>))) {
07666         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
07667     } <span class="keywordflow">else</span> {
07668         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
07669     }
07670 }
07671 
07672 BOOLEAN
<a name="l07673"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a84">07673</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a84">IoIsSystemThread</a>(
07674     IN <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a> Thread
07675     )
07676 
07677 <span class="comment">/*++</span>
07678 <span class="comment"></span>
07679 <span class="comment">Routine Description:</span>
07680 <span class="comment"></span>
07681 <span class="comment">    This routine returns a BOOLEAN indicating whether or not the specified</span>
07682 <span class="comment">    thread is a system thread.</span>
07683 <span class="comment"></span>
07684 <span class="comment">Arguments:</span>
07685 <span class="comment"></span>
07686 <span class="comment">    Thread - Pointer to the thread to be checked.</span>
07687 <span class="comment"></span>
07688 <span class="comment">Return Value:</span>
07689 <span class="comment"></span>
07690 <span class="comment">    A value of TRUE is returned if the indicated thread is a system thread,</span>
07691 <span class="comment">    else FALSE.</span>
07692 <span class="comment"></span>
07693 <span class="comment">Note:</span>
07694 <span class="comment"></span>
07695 <span class="comment">    This function cannot be made a macro, since fields in the thread object</span>
07696 <span class="comment">    move from release to release, so this must remain a full function.</span>
07697 <span class="comment"></span>
07698 <span class="comment">--*/</span>
07699 
07700 {
07701     <span class="keywordflow">return</span> (BOOLEAN) <a class="code" href="../../d1/d9/ps_8h.html#a18">IS_SYSTEM_THREAD</a>(Thread);
07702 }
07703 
07704 BOOLEAN
<a name="l07705"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a85">07705</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a85">IoIsValidNameGraftingBuffer</a>(
07706     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
07707     IN PREPARSE_DATA_BUFFER ReparseBuffer
07708     )
07709 
07710 <span class="comment">/*++</span>
07711 <span class="comment"></span>
07712 <span class="comment">Routine Description:</span>
07713 <span class="comment"></span>
07714 <span class="comment">    This routine returns a BOOLEAN indicating whether or not the specified</span>
07715 <span class="comment">    buffer is a valid name grafting buffer. All internal validity checks are</span>
07716 <span class="comment">    encapsulated in this routine.</span>
07717 <span class="comment"></span>
07718 <span class="comment">    Among the checks performed is whether the name lengths stored within the</span>
07719 <span class="comment">    buffer in the private data section are compatible with the total size of</span>
07720 <span class="comment">    the buffer that has been passed in.</span>
07721 <span class="comment"></span>
07722 <span class="comment">Arguments:</span>
07723 <span class="comment"></span>
07724 <span class="comment">    Irp - Pointer to the I/O Request Packet (IRP) representing the operation</span>
07725 <span class="comment">        to be performed.</span>
07726 <span class="comment"></span>
07727 <span class="comment">    Buffer - Pointer to a reparse data buffer that is supposed to contain</span>
07728 <span class="comment">        a self-consistent set of names to perform name grafting.</span>
07729 <span class="comment"></span>
07730 <span class="comment">Return Value:</span>
07731 <span class="comment"></span>
07732 <span class="comment">    A value of TRUE is returned if the buffer is correct for name grafting,</span>
07733 <span class="comment">    else FALSE.</span>
07734 <span class="comment"></span>
07735 <span class="comment">Note:</span>
07736 <span class="comment"></span>
07737 <span class="comment">    This function needs to be kept synchronized with the definition of</span>
07738 <span class="comment">    REPARSE_DATA_BUFFER.</span>
07739 <span class="comment"></span>
07740 <span class="comment">--*/</span>
07741 
07742 {
07743     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> thisStackPointer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
07744     UNICODE_STRING     drivePath;
07745 
07746     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( FIELD_OFFSET( REPARSE_DATA_BUFFER, SymbolicLinkReparseBuffer.PathBuffer[0] ) ==
07747             FIELD_OFFSET( REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer[0] ) );
07748     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( ReparseBuffer-&gt;ReparseDataLength &lt; MAXIMUM_REPARSE_DATA_BUFFER_SIZE );
07749 
07750     <span class="comment">//</span>
07751     <span class="comment">// Determine whether we have the correct kind of reparse tag in the buffer.</span>
07752     <span class="comment">//</span>
07753 
07754     <span class="keywordflow">if</span> (ReparseBuffer-&gt;ReparseTag != IO_REPARSE_TAG_MOUNT_POINT) {
07755 
07756         <span class="comment">//</span>
07757         <span class="comment">// The reparse tag is not an NT name grafting tag.</span>
07758         <span class="comment">//</span>
07759 
07760         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
07761     }
07762 
07763     <span class="comment">//</span>
07764     <span class="comment">// Determine whether we have enough data for all the length fields.</span>
07765     <span class="comment">//</span>
07766 
07767     <span class="keywordflow">if</span> (ReparseBuffer-&gt;ReparseDataLength &lt;
07768         (FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer[0]) - REPARSE_DATA_BUFFER_HEADER_SIZE)) {
07769 
07770         <span class="comment">//</span>
07771         <span class="comment">// The buffer is shorter than the minimum needed to express a pair of valid</span>
07772         <span class="comment">// names.</span>
07773         <span class="comment">//</span>
07774 
07775         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
07776     }
07777 
07778     <span class="comment">//</span>
07779     <span class="comment">// Get the address of the current stack location.</span>
07780     <span class="comment">//</span>
07781 
07782     thisStackPointer = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
07783 
07784     <span class="comment">//</span>
07785     <span class="comment">// Determine whether the data lengths returned are consistent with the buffer in</span>
07786     <span class="comment">// which they are retrieved.</span>
07787     <span class="comment">//</span>
07788     <span class="comment">// This check is meaningful only when the buffer has been allocated. When this routine</span>
07789     <span class="comment">// is used when a name grafting is being set there is no allocated output buffer.</span>
07790     <span class="comment">//</span>
07791 
07792     <span class="keywordflow">if</span> ((thisStackPointer-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.FileSystemControl.OutputBufferLength &gt; 0) &amp;&amp;
07793         (thisStackPointer-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.FileSystemControl.OutputBufferLength &lt;
07794         (ULONG)(FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer[0]) +
07795                 ReparseBuffer-&gt;MountPointReparseBuffer.SubstituteNameLength +
07796                 ReparseBuffer-&gt;MountPointReparseBuffer.PrintNameLength +
07797                 2 * <span class="keyword">sizeof</span>( UNICODE_NULL )))) {
07798 
07799         <span class="comment">//</span>
07800         <span class="comment">// The length of the appropriate buffer header, plus the lengths of the substitute</span>
07801         <span class="comment">// and print names are longer than the length of the buffer passed in.</span>
07802         <span class="comment">// Thus, this data is not self-consistent.</span>
07803         <span class="comment">//</span>
07804         <span class="comment">// Note that it is only the I/O subsystem that needs to check for this internal</span>
07805         <span class="comment">// consistency in the buffer as it will do a blind data copy using these lengths</span>
07806         <span class="comment">// when transmogrifying the names. The file system returning the buffer only needs</span>
07807         <span class="comment">// to ascertain that the total syze of the data retrieved does not exceed the size</span>
07808         <span class="comment">// of the output buffer.</span>
07809         <span class="comment">//</span>
07810 
07811         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
07812     }
07813 
07814     <span class="comment">//</span>
07815     <span class="comment">// Now we determine whether the names were placed according to the reparse point</span>
07816     <span class="comment">// specification.</span>
07817     <span class="comment">//</span>
07818 
07819     <span class="comment">//</span>
07820     <span class="comment">// Determine whether the SubstituteNameOffset is zero.</span>
07821     <span class="comment">//</span>
07822 
07823     <span class="keywordflow">if</span> (ReparseBuffer-&gt;MountPointReparseBuffer.SubstituteNameOffset != 0) {
07824 
07825         <span class="comment">//</span>
07826         <span class="comment">// Incorrect offset for the substitute name.</span>
07827         <span class="comment">//</span>
07828 
07829         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
07830     }
07831 
07832     <span class="comment">//</span>
07833     <span class="comment">// Determine whether PrintNameOffset is correct.</span>
07834     <span class="comment">//</span>
07835 
07836     <span class="keywordflow">if</span> (ReparseBuffer-&gt;MountPointReparseBuffer.PrintNameOffset !=
07837         (ReparseBuffer-&gt;MountPointReparseBuffer.SubstituteNameLength + <span class="keyword">sizeof</span>( UNICODE_NULL )) ) {
07838 
07839         <span class="comment">//</span>
07840         <span class="comment">// Incorrect offset for the print name.</span>
07841         <span class="comment">//</span>
07842 
07843         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
07844     }
07845 
07846     <span class="comment">//</span>
07847     <span class="comment">// Determine whether ReparseDataLength is correct for name grafting operations.</span>
07848     <span class="comment">// We require a buffer of type REPARSE_DATA_BUFFER.</span>
07849     <span class="comment">//</span>
07850 
07851     <span class="keywordflow">if</span> (ReparseBuffer-&gt;ReparseDataLength !=
07852         (FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer[0]) - REPARSE_DATA_BUFFER_HEADER_SIZE) +
07853         ReparseBuffer-&gt;MountPointReparseBuffer.SubstituteNameLength +
07854         ReparseBuffer-&gt;MountPointReparseBuffer.PrintNameLength +
07855         2 * <span class="keyword">sizeof</span>( UNICODE_NULL )) {
07856 
07857         <span class="comment">//</span>
07858         <span class="comment">// Incorrect length of the reparse data.</span>
07859         <span class="comment">//</span>
07860 
07861         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
07862     }
07863 
07864     <span class="comment">//</span>
07865     <span class="comment">// Determine that the substitute name is not a UNC name.</span>
07866     <span class="comment">// This assumes that ReparseBuffer-&gt;MountPointReparseBuffer.SubstituteNameOffset is zero (0).</span>
07867     <span class="comment">//</span>
07868 
07869     {
07870         <span class="comment">//</span>
07871         <span class="comment">// This conditional is a transcription of part of the code of RtlDetermineDosPathNameType_U</span>
07872         <span class="comment">// present in ntos\dll\curdir.c</span>
07873         <span class="comment">//</span>
07874         <span class="comment">// The only two legal names that can begin with \\ are:  \\.  and  \\?</span>
07875         <span class="comment">// All other names that begin with  \\  are disallowed.</span>
07876         <span class="comment">//</span>
07877 
07878         <span class="keywordflow">if</span> ((ReparseBuffer-&gt;MountPointReparseBuffer.SubstituteNameLength &gt; 6) &amp;&amp;
07879             (ReparseBuffer-&gt;MountPointReparseBuffer.PathBuffer[0] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>) &amp;&amp;
07880             (ReparseBuffer-&gt;MountPointReparseBuffer.PathBuffer[1] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>) &amp;&amp;
07881             !((ReparseBuffer-&gt;MountPointReparseBuffer.PathBuffer[2] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'.'</span>) ||
07882               (ReparseBuffer-&gt;MountPointReparseBuffer.PathBuffer[2] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'?'</span>))) {
07883 
07884             <span class="comment">//</span>
07885             <span class="comment">// The name is not one we want to deal with.</span>
07886             <span class="comment">//</span>
07887 
07888             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
07889         }
07890 
07891         <span class="comment">//</span>
07892         <span class="comment">// When  RtlDosPathNameToNtPathName_U  is used, the UNC names are returned with a prefix</span>
07893         <span class="comment">// of the form  \??\UNC\</span>
07894         <span class="comment">//</span>
07895 
07896         <span class="keywordflow">if</span> ((ReparseBuffer-&gt;MountPointReparseBuffer.SubstituteNameLength &gt; 16) &amp;&amp;
07897             (ReparseBuffer-&gt;MountPointReparseBuffer.PathBuffer[0] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>) &amp;&amp;
07898             (ReparseBuffer-&gt;MountPointReparseBuffer.PathBuffer[1] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'?'</span>) &amp;&amp;
07899             (ReparseBuffer-&gt;MountPointReparseBuffer.PathBuffer[2] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'?'</span>) &amp;&amp;
07900             (ReparseBuffer-&gt;MountPointReparseBuffer.PathBuffer[3] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>) &amp;&amp;
07901             (ReparseBuffer-&gt;MountPointReparseBuffer.PathBuffer[4] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'U'</span>) &amp;&amp;
07902             (ReparseBuffer-&gt;MountPointReparseBuffer.PathBuffer[5] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'N'</span>) &amp;&amp;
07903             (ReparseBuffer-&gt;MountPointReparseBuffer.PathBuffer[6] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'C'</span>) &amp;&amp;
07904             (ReparseBuffer-&gt;MountPointReparseBuffer.PathBuffer[7] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>)) {
07905 
07906             <span class="comment">//</span>
07907             <span class="comment">// The name is not one we want to deal with.</span>
07908             <span class="comment">//</span>
07909 
07910             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
07911         }
07912 
07913         <span class="comment">//</span>
07914         <span class="comment">// See whether there is a drive letter that is mapped at the beginning of the name.</span>
07915         <span class="comment">// If the drive letter is C, then the prefix has the form  \??\C:</span>
07916         <span class="comment">// Note that we skip the offset 4 on purpose.</span>
07917         <span class="comment">//</span>
07918 
07919         <span class="keywordflow">if</span> ((ReparseBuffer-&gt;MountPointReparseBuffer.SubstituteNameLength &gt; 12) &amp;&amp;
07920             (ReparseBuffer-&gt;MountPointReparseBuffer.PathBuffer[0] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>) &amp;&amp;
07921             (ReparseBuffer-&gt;MountPointReparseBuffer.PathBuffer[1] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'?'</span>) &amp;&amp;
07922             (ReparseBuffer-&gt;MountPointReparseBuffer.PathBuffer[2] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'?'</span>) &amp;&amp;
07923             (ReparseBuffer-&gt;MountPointReparseBuffer.PathBuffer[3] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>) &amp;&amp;
07924             (ReparseBuffer-&gt;MountPointReparseBuffer.PathBuffer[5] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">':'</span>)) {
07925 
07926             <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>           status;
07927             UNICODE_STRING     linkValue;
07928             OBJECT_ATTRIBUTES  objectAttributes;
07929             HANDLE             linkHandle;
07930             PWCHAR             linkValueBuffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;   <span class="comment">//  MAX_PATH is 260</span>
07931             WCHAR              pathNameValue[<span class="keyword">sizeof</span>(<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"\\??\\C:\0"</span>)];
07932 
07933             RtlCopyMemory( &amp;pathNameValue, <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"\\??\\C:\0"</span>, <span class="keyword">sizeof</span>(<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="stringliteral">"\\??\\C:\0"</span>) );
07934 
07935             <a class="code" href="../../d2/d7/string_8c.html#a7">RtlInitUnicodeString</a>( &amp;drivePath, pathNameValue );
07936 
07937             <span class="comment">//</span>
07938             <span class="comment">// Place the appropriate drive letter in the buffer overwriting offset 4.</span>
07939             <span class="comment">//</span>
07940 
07941             drivePath.Buffer[4] = ReparseBuffer-&gt;MountPointReparseBuffer.PathBuffer[4];
07942 
07943             InitializeObjectAttributes( &amp;objectAttributes,
07944                                         &amp;drivePath,
07945                                         OBJ_CASE_INSENSITIVE,
07946                                         (HANDLE) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
07947                                         (PSECURITY_DESCRIPTOR) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
07948 
07949             status = ZwOpenSymbolicLinkObject( &amp;linkHandle,
07950                                                SYMBOLIC_LINK_QUERY,
07951                                                &amp;objectAttributes );
07952 
07953 <span class="preprocessor">#if DBG</span>
07954 <span class="preprocessor"></span><span class="comment">//     DbgPrint( "IO Name grafting drivePath: %Z ZwOpenSymbolicLinkObject status %x\n", &amp;drivePath, status );</span>
07955 <span class="preprocessor">#endif // DBG</span>
07956 <span class="preprocessor"></span>
07957             <span class="keywordflow">if</span> ( <a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status ) ) {
07958 
07959                 <span class="comment">//</span>
07960                 <span class="comment">// Now query the link and see if there is a redirection</span>
07961                 <span class="comment">//</span>
07962 
07963                 linkValueBuffer = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
07964                                                          2 * 260,
07965                                                          '  oI' );
07966                 <span class="keywordflow">if</span> ( !linkValueBuffer ) {
07967 
07968                     <span class="comment">//</span>
07969                     <span class="comment">// Insufficient resources. Return FALSE.</span>
07970                     <span class="comment">//</span>
07971 
07972                     <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>( linkHandle );
07973                     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
07974                 }
07975 
07976                 linkValue.Buffer = linkValueBuffer;
07977                 linkValue.Length = 0;
07978                 linkValue.MaximumLength = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)(2 * 260);
07979 
07980                 status = ZwQuerySymbolicLinkObject( linkHandle,
07981                                                     &amp;linkValue,
07982                                                     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
07983                 <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>( linkHandle );
07984 
07985 <span class="preprocessor">#if DBG</span>
07986 <span class="preprocessor"></span><span class="comment">//     DbgPrint( "IO Name grafting linkValue: %Z ZwQuerySymbolicLinkObject status %x\n", &amp;linkValue, status );</span>
07987 <span class="preprocessor">#endif // DBG</span>
07988 <span class="preprocessor"></span>
07989                 <span class="keywordflow">if</span> ( <a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status ) ) {
07990 
07991                     <span class="comment">//</span>
07992                     <span class="comment">// The link is a re-directed drive when it has the prefix</span>
07993                     <span class="comment">// \Device\LanmanRedirector\</span>
07994                     <span class="comment">//</span>
07995 
07996                     <span class="keywordflow">if</span> ((linkValue.Buffer[ 0] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>) &amp;&amp;
07997                         (linkValue.Buffer[ 1] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'D'</span>) &amp;&amp;
07998                         (linkValue.Buffer[ 2] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'e'</span>) &amp;&amp;
07999                         (linkValue.Buffer[ 3] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'v'</span>) &amp;&amp;
08000                         (linkValue.Buffer[ 4] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'i'</span>) &amp;&amp;
08001                         (linkValue.Buffer[ 5] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'c'</span>) &amp;&amp;
08002                         (linkValue.Buffer[ 6] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'e'</span>) &amp;&amp;
08003                         (linkValue.Buffer[ 7] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>) &amp;&amp;
08004                         (linkValue.Buffer[ 8] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'L'</span>) &amp;&amp;
08005                         (linkValue.Buffer[ 9] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'a'</span>) &amp;&amp;
08006                         (linkValue.Buffer[10] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'n'</span>) &amp;&amp;
08007                         (linkValue.Buffer[14] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'R'</span>) &amp;&amp;
08008                         (linkValue.Buffer[15] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'e'</span>) &amp;&amp;
08009                         (linkValue.Buffer[16] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'d'</span>) &amp;&amp;
08010                         (linkValue.Buffer[17] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'i'</span>) &amp;&amp;
08011                         (linkValue.Buffer[18] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'r'</span>) &amp;&amp;
08012                         (linkValue.Buffer[23] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'r'</span>) &amp;
08013                         (linkValue.Buffer[24] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>)) {
08014 
08015                         <span class="comment">//</span>
08016                         <span class="comment">// Free the buffer.</span>
08017                         <span class="comment">//</span>
08018 
08019                         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( linkValueBuffer );
08020 
08021                         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
08022                     }
08023 
08024                     <span class="comment">//</span>
08025                     <span class="comment">// Fix for penetration bug. May be relaxed in the future 03/99.</span>
08026                     <span class="comment">// Exploit the fact that we have queried the symbolic link.</span>
08027                     <span class="comment">// Want only to allow links to volumes that have the prefix</span>
08028                     <span class="comment">//   \Device\Harddisk</span>
08029                     <span class="comment">//</span>
08030 
08031                     <span class="keywordflow">if</span> (!((linkValue.Buffer[ 0] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>) &amp;&amp;
08032                           (linkValue.Buffer[ 1] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'D'</span>) &amp;&amp;
08033                           (linkValue.Buffer[ 2] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'e'</span>) &amp;&amp;
08034                           (linkValue.Buffer[ 3] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'v'</span>) &amp;&amp;
08035                           (linkValue.Buffer[ 4] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'i'</span>) &amp;&amp;
08036                           (linkValue.Buffer[ 5] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'c'</span>) &amp;&amp;
08037                           (linkValue.Buffer[ 6] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'e'</span>) &amp;&amp;
08038                           (linkValue.Buffer[ 7] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>) &amp;&amp;
08039                           (linkValue.Buffer[ 8] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'H'</span>) &amp;&amp;
08040                           (linkValue.Buffer[ 9] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'a'</span>) &amp;&amp;
08041                           (linkValue.Buffer[10] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'r'</span>) &amp;&amp;
08042                           (linkValue.Buffer[11] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'d'</span>) &amp;&amp;
08043                           (linkValue.Buffer[12] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'d'</span>) &amp;&amp;
08044                           (linkValue.Buffer[13] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'i'</span>) &amp;&amp;
08045                           (linkValue.Buffer[14] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'s'</span>) &amp;&amp;
08046                           (linkValue.Buffer[15] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'k'</span>))) {
08047 
08048                         <span class="comment">//</span>
08049                         <span class="comment">// Free the buffer.</span>
08050                         <span class="comment">//</span>
08051 
08052                         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( linkValueBuffer );
08053 
08054                         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
08055                     }
08056                 }
08057 
08058                 <span class="comment">//</span>
08059                 <span class="comment">// Free the buffer.</span>
08060                 <span class="comment">//</span>
08061 
08062                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( linkValueBuffer );
08063             }
08064         }
08065     }
08066 
08067     <span class="comment">//</span>
08068     <span class="comment">// Fix for penetration bug. May be relaxed in the future 03/99.</span>
08069     <span class="comment">// Determine that we either have an NT file name or a volume mount point target name.</span>
08070     <span class="comment">//</span>
08071     <span class="comment">// This closes the door of having an arbitrary device name that, with the help of the</span>
08072     <span class="comment">// server, can be used to bypass access checks to the underlying device.</span>
08073     <span class="comment">//</span>
08074 
08075     {
08076         UNICODE_STRING volumeName;
08077 
08078         <span class="keywordflow">if</span> (
08079             <span class="comment">//</span>
08080             <span class="comment">// The shortest valid name is one of the kind \??\C: whose length is 12 when</span>
08081             <span class="comment">// in Unicode. All names used by volume mount points are longer.</span>
08082             <span class="comment">//</span>
08083 
08084             ReparseBuffer-&gt;MountPointReparseBuffer.SubstituteNameLength &lt; 12 ) {
08085 
08086             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
08087         }
08088 
08089         <span class="comment">//</span>
08090         <span class="comment">// The name has at least 6 Unicode characters.</span>
08091         <span class="comment">//</span>
08092         <span class="comment">// We have verified above that MountPointReparseBuffer.SubstituteNameOffset</span>
08093         <span class="comment">// is zero.</span>
08094         <span class="comment">//</span>
08095 
08096         volumeName.Length =
08097         volumeName.MaximumLength = ReparseBuffer-&gt;MountPointReparseBuffer.SubstituteNameLength;
08098         volumeName.Buffer = (PWSTR) ReparseBuffer-&gt;MountPointReparseBuffer.PathBuffer;
08099 
08100         <span class="comment">//</span>
08101         <span class="comment">// When we do not have a name that begins with a drive letter and it is not</span>
08102         <span class="comment">// a valid volume mount point name then we return false.</span>
08103         <span class="comment">//</span>
08104 
08105         <span class="keywordflow">if</span> ( !((ReparseBuffer-&gt;MountPointReparseBuffer.PathBuffer[0] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>) &amp;&amp;
08106                (ReparseBuffer-&gt;MountPointReparseBuffer.PathBuffer[1] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'?'</span>) &amp;&amp;
08107                (ReparseBuffer-&gt;MountPointReparseBuffer.PathBuffer[2] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'?'</span>) &amp;&amp;
08108                (ReparseBuffer-&gt;MountPointReparseBuffer.PathBuffer[3] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>) &amp;&amp;
08109                <span class="comment">//</span>
08110                <span class="comment">// Notice that we skip index 4, where the drive letter is to be.</span>
08111                <span class="comment">//</span>
08112                (ReparseBuffer-&gt;MountPointReparseBuffer.PathBuffer[5] == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">':'</span>))
08113 
08114              &amp;&amp;
08115 
08116              !MOUNTMGR_IS_VOLUME_NAME( &amp;volumeName ) ) {
08117 
08118             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
08119         }
08120     }
08121 
08122     <span class="comment">//</span>
08123     <span class="comment">// Otherwise return TRUE.</span>
08124     <span class="comment">//</span>
08125 
08126     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
08127 }
08128 
08129 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l08130"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a86">08130</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a86">IopDoNameTransmogrify</a>(
08131     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
08132     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
08133     IN PREPARSE_DATA_BUFFER ReparseBuffer
08134     )
08135 
08136 <span class="comment">/*++</span>
08137 <span class="comment"></span>
08138 <span class="comment">Routine Description:</span>
08139 <span class="comment"></span>
08140 <span class="comment">    This routine is called to do the name grafting needed for junctions.</span>
08141 <span class="comment"></span>
08142 <span class="comment">Arguments:</span>
08143 <span class="comment"></span>
08144 <span class="comment">    Irp - Pointer to the I/O Request Packet (IRP) representing the operation</span>
08145 <span class="comment">        to be performed.</span>
08146 <span class="comment"></span>
08147 <span class="comment">    FileObject - Pointer to the file object whose name is being affected.</span>
08148 <span class="comment"></span>
08149 <span class="comment">    ReparseBuffer - Pointer to a reparse data buffer that is supposed to contain</span>
08150 <span class="comment">        a self-consistent set of names to perform name grafting.</span>
08151 <span class="comment"></span>
08152 <span class="comment">Return Value:</span>
08153 <span class="comment"></span>
08154 <span class="comment">    No explicit return value. The appropriate fields off the IRP are set.</span>
08155 <span class="comment"></span>
08156 <span class="comment">Note:</span>
08157 <span class="comment"></span>
08158 <span class="comment">    This function needs to be kept synchronized with the definition of</span>
08159 <span class="comment">    REPARSE_DATA_BUFFER.</span>
08160 <span class="comment"></span>
08161 <span class="comment">--*/</span>
08162 
08163 {
08164     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> pathLength = 0;
08165     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> neededBufferLength = 0;
08166     PVOID outBuffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
08167     PWSTR pathBuffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
08168 
08169     <span class="comment">//</span>
08170     <span class="comment">// We do the appropriate paste of the new name in the FileName buffer</span>
08171     <span class="comment">// and deallocate the buffer that brought the data from the file system.</span>
08172     <span class="comment">//</span>
08173 
08174     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status == STATUS_REPARSE );
08175     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information == IO_REPARSE_TAG_MOUNT_POINT );
08176 
08177     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.AuxiliaryBuffer != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
08178 
08179     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( ReparseBuffer != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
08180     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( ReparseBuffer-&gt;ReparseTag == IO_REPARSE_TAG_MOUNT_POINT );
08181     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( ReparseBuffer-&gt;ReparseDataLength &lt; MAXIMUM_REPARSE_DATA_BUFFER_SIZE );
08182     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( ReparseBuffer-&gt;Reserved &lt; MAXIMUM_REPARSE_DATA_BUFFER_SIZE );
08183 
08184 <span class="preprocessor">#if DBG</span>
08185 <span class="preprocessor"></span><span class="comment">//    DbgPrint( "iosubs.c DoNameTransmogrify: Tag %x Reserved %x MaximumLength %x FileName %Z\n",</span>
08186 <span class="comment">//              ReparseBuffer-&gt;ReparseTag, ReparseBuffer-&gt;Reserved, FileObject-&gt;FileName.MaximumLength, &amp;(FileObject-&gt;FileName) );</span>
08187 <span class="preprocessor">#endif // DBG</span>
08188 <span class="preprocessor"></span>
08189     <span class="comment">//</span>
08190     <span class="comment">// Determine whether we have enough data for all the length fields.</span>
08191     <span class="comment">//</span>
08192     <span class="comment">// Determine whether the lengths returned are consistent with the maximum</span>
08193     <span class="comment">// buffer. This is the best self-defense check we can do at this time as</span>
08194     <span class="comment">// the stack pointer is already invalid.</span>
08195     <span class="comment">//</span>
08196 
08197     <span class="keywordflow">if</span> (ReparseBuffer-&gt;ReparseDataLength &gt;=
08198         (FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer[0]) - REPARSE_DATA_BUFFER_HEADER_SIZE)) {
08199 
08200         <span class="keywordflow">if</span> (MAXIMUM_REPARSE_DATA_BUFFER_SIZE &lt;
08201             (FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer[0]) +
08202                 ReparseBuffer-&gt;MountPointReparseBuffer.SubstituteNameLength +
08203                 ReparseBuffer-&gt;MountPointReparseBuffer.PrintNameLength)) {
08204 
08205             <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status = STATUS_IO_REPARSE_DATA_INVALID;
08206         }
08207     } <span class="keywordflow">else</span> {
08208         <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status = STATUS_IO_REPARSE_DATA_INVALID;
08209     }
08210 
08211     <span class="comment">//</span>
08212     <span class="comment">// The value in  ReparseBuffer-&gt;Reserved  is the length of the file</span>
08213     <span class="comment">// name that has still to be parsed.</span>
08214     <span class="comment">//</span>
08215 
08216     <span class="comment">//</span>
08217     <span class="comment">// Copy the buffer when it has the appropriate length, else return a null UNICODE name:</span>
08218     <span class="comment">//   (1) Do defensive sanity checks on the name lengths returned.</span>
08219     <span class="comment">//</span>
08220     <span class="comment">// We only care to do this if we have no error conditions.</span>
08221     <span class="comment">//</span>
08222 
08223     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status )) {
08224 
08225         pathBuffer = (PWSTR)((PCHAR)ReparseBuffer-&gt;MountPointReparseBuffer.PathBuffer +
08226                              ReparseBuffer-&gt;MountPointReparseBuffer.SubstituteNameOffset);
08227         pathLength = ReparseBuffer-&gt;MountPointReparseBuffer.SubstituteNameLength;
08228     }
08229 
08230     <span class="comment">//</span>
08231     <span class="comment">// Notice that if the data returned in AuxiliaryBuffer is not long enough then</span>
08232     <span class="comment">// pathLength has value 0 and pathBuffer has value NULL.</span>
08233     <span class="comment">//</span>
08234     <span class="comment">// The value in  ReparseBuffer-&gt;Reserved  is the length of the file name that</span>
08235     <span class="comment">// has still to be parsed.</span>
08236     <span class="comment">//</span>
08237     <span class="comment">// We only care to do this if we have no error conditions.</span>
08238     <span class="comment">//</span>
08239 
08240     <span class="keywordflow">if</span> (ReparseBuffer-&gt;Reserved &lt; 0) {
08241 
08242         <span class="comment">//</span>
08243         <span class="comment">// This is an invalid offset.</span>
08244         <span class="comment">//</span>
08245 
08246         <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status = STATUS_IO_REPARSE_DATA_INVALID;
08247     }
08248 
08249     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status )) {
08250 
08251         <span class="comment">//</span>
08252         <span class="comment">// Check for overflow. (pathLength &lt;= MAXIMUM_REPARSE_DATA_BUFFER_SIZE)</span>
08253         <span class="comment">// so pathLength + sizeof(UNICODE_NULL) cannot overflow.</span>
08254         <span class="comment">//</span>
08255 
08256         <span class="keywordflow">if</span> (((<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)MAXUSHORT - ReparseBuffer-&gt;Reserved ) &gt; (pathLength +(<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>)<span class="keyword">sizeof</span>(UNICODE_NULL))) {
08257             neededBufferLength = pathLength + ReparseBuffer-&gt;Reserved + <span class="keyword">sizeof</span>( UNICODE_NULL );
08258             <span class="comment">//</span>
08259             <span class="comment">// If the out name buffer isn't large enough, allocate a new one.</span>
08260             <span class="comment">//</span>
08261 
08262             <span class="keywordflow">if</span> (FileObject-&gt;FileName.MaximumLength &lt; neededBufferLength) {
08263                 outBuffer = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>,
08264                                                    neededBufferLength,
08265                                                    'cFoI' );
08266                 <span class="keywordflow">if</span> (!outBuffer) {
08267                     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status = STATUS_INSUFFICIENT_RESOURCES;
08268                 }
08269             } <span class="keywordflow">else</span> {
08270                 outBuffer = FileObject-&gt;FileName.Buffer;
08271             }
08272         } <span class="keywordflow">else</span> {
08273             <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status = STATUS_NAME_TOO_LONG;
08274         }
08275     }
08276 
08277     <span class="comment">//</span>
08278     <span class="comment">// Place in the out name buffer the remaining part of the name.</span>
08279     <span class="comment">//</span>
08280     <span class="comment">// We only care to do this if we have no error conditions.</span>
08281     <span class="comment">//</span>
08282 
08283     <span class="keywordflow">if</span> (<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status )) {
08284 
08285         <span class="keywordflow">if</span> (ReparseBuffer-&gt;Reserved) {
08286 
08287             RtlMoveMemory ( (PCHAR)outBuffer + pathLength,
08288                             (PCHAR)FileObject-&gt;FileName.Buffer +
08289                                   (FileObject-&gt;FileName.Length - ReparseBuffer-&gt;Reserved),
08290                             ReparseBuffer-&gt;Reserved );
08291         }
08292 
08293         <span class="comment">//</span>
08294         <span class="comment">// Copy into the front of the out name buffer the value of the</span>
08295         <span class="comment">// reparse point.</span>
08296         <span class="comment">//</span>
08297 
08298         <span class="keywordflow">if</span> (pathLength) {
08299 
08300             RtlCopyMemory( (PCHAR)outBuffer,
08301                            (PCHAR)pathBuffer,
08302                            pathLength );
08303         }
08304 
08305         FileObject-&gt;FileName.Length = neededBufferLength - <span class="keyword">sizeof</span>( UNICODE_NULL );
08306 
08307         <span class="comment">//</span>
08308         <span class="comment">// Free the old name buffer when needed and update the appropriate values.</span>
08309         <span class="comment">//</span>
08310 
08311         <span class="keywordflow">if</span> (outBuffer != FileObject-&gt;FileName.Buffer) {
08312 
08313             <span class="keywordflow">if</span> (FileObject-&gt;FileName.Buffer != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
08314                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( FileObject-&gt;FileName.Buffer );
08315             }
08316             FileObject-&gt;FileName.Buffer = outBuffer;
08317             FileObject-&gt;FileName.MaximumLength = neededBufferLength;
08318             ((PWSTR)outBuffer)[ (neededBufferLength / <span class="keyword">sizeof</span>( WCHAR ))-1 ] = UNICODE_NULL;
08319         }
08320     }
08321 
08322     <span class="comment">//</span>
08323     <span class="comment">// Free the buffer that came from the file system.</span>
08324     <span class="comment">// NULL the pointer.</span>
08325     <span class="comment">//</span>
08326 
08327     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( ReparseBuffer );
08328     ReparseBuffer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
08329 
08330     <span class="comment">//</span>
08331     <span class="comment">// Clear the tag from then Information field.</span>
08332     <span class="comment">//</span>
08333 
08334     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information = IO_REPARSE_TAG_RESERVED_ZERO;
08335 }
08336 
08337 <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>
<a name="l08338"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a87">08338</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a87">IoMakeAssociatedIrp</a>(
08339     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
08340     IN CCHAR StackSize
08341     )
08342 
08343 <span class="comment">/*++</span>
08344 <span class="comment"></span>
08345 <span class="comment">Routine Description:</span>
08346 <span class="comment"></span>
08347 <span class="comment">    This routine allocates an I/O Request Packet from the system nonpaged pool</span>
08348 <span class="comment">    and makes it an associated IRP to the specified IRP.  The packet will be</span>
08349 <span class="comment">    allocated to contain StackSize stack locations.  The IRP iwll also be</span>
08350 <span class="comment">    initialized.</span>
08351 <span class="comment"></span>
08352 <span class="comment">    Note that it is up to the caller to have set the number of associated IRPs</span>
08353 <span class="comment">    in the master packet before calling this routine for the first time.  The</span>
08354 <span class="comment">    count should be set in the master packet in:  AssociatedIrp.IrpCount.</span>
08355 <span class="comment"></span>
08356 <span class="comment">Arguments:</span>
08357 <span class="comment"></span>
08358 <span class="comment">    Irp - Pointer to master IRP to be associated with.</span>
08359 <span class="comment"></span>
08360 <span class="comment">    StackSize - Specifies the maximum number of stack locations required.</span>
08361 <span class="comment"></span>
08362 <span class="comment">Return Value:</span>
08363 <span class="comment"></span>
08364 <span class="comment">    The function value is the address of the associated IRP or NULL, if the</span>
08365 <span class="comment">    IRP could be allocated.</span>
08366 <span class="comment"></span>
08367 <span class="comment">--*/</span>
08368 
08369 {
08370     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> allocateSize;
08371     UCHAR fixedSize;
08372     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> associatedIrp;
08373     <a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html">PNPAGED_LOOKASIDE_LIST</a> lookasideList;
08374     UCHAR mustSucceed;
08375     <a class="code" href="../../d5/d8/ex_8h.html#a108">PP_NPAGED_LOOKASIDE_NUMBER</a> number;
08376     <a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a> packetSize;
08377     PKPRCB prcb;
08378 
08379     <span class="comment">//</span>
08380     <span class="comment">// If the size of the packet required is less than or equal to those on</span>
08381     <span class="comment">// the lookaside lists, then attempt to allocate the packet from the</span>
08382     <span class="comment">// lookaside lists.</span>
08383     <span class="comment">//</span>
08384 
08385     associatedIrp = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
08386     fixedSize = 0;
08387     mustSucceed = 0;
08388     packetSize = <a class="code" href="../../d0/d5/io_8h.html#a245">IoSizeOfIrp</a>(StackSize);
08389     allocateSize = packetSize;
08390     <span class="keywordflow">if</span> (StackSize &lt;= (CCHAR)<a class="code" href="../../d8/d0/cmdat3_8c.html#a56">IopLargeIrpStackLocations</a>) {
08391         fixedSize = <a class="code" href="../../d0/d5/io_8h.html#a192">IRP_ALLOCATED_FIXED_SIZE</a>;
08392         number = <a class="code" href="../../d5/d8/ex_8h.html#a331a197">LookasideSmallIrpList</a>;
08393         <span class="keywordflow">if</span> (StackSize != 1) {
08394             allocateSize = <a class="code" href="../../d0/d5/io_8h.html#a245">IoSizeOfIrp</a>((CCHAR)<a class="code" href="../../d8/d0/cmdat3_8c.html#a56">IopLargeIrpStackLocations</a>);
08395             number = <a class="code" href="../../d5/d8/ex_8h.html#a331a198">LookasideLargeIrpList</a>;
08396         }
08397 
08398         prcb = <a class="code" href="../../d2/d7/alpha_2kdpcpu_8h.html#a2">KeGetCurrentPrcb</a>();
08399         lookasideList = prcb-&gt;PPLookasideList[number].P;
08400         lookasideList-&gt;<a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html#o0">L</a>.<a class="code" href="../../d6/d1/struct__GENERAL__LOOKASIDE.html#o3">TotalAllocates</a> += 1;
08401         associatedIrp = (<a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>)<a class="code" href="../../d5/d8/ex_8h.html#a242">ExInterlockedPopEntrySList</a>(&amp;lookasideList-&gt;<a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html#o0">L</a>.<a class="code" href="../../d6/d1/struct__GENERAL__LOOKASIDE.html#o0">ListHead</a>,
08402                                                          &amp;lookasideList-&gt;<a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html#o1">Lock</a>);
08403 
08404         <span class="keywordflow">if</span> (associatedIrp == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
08405             lookasideList-&gt;<a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html#o0">L</a>.<a class="code" href="../../d6/d1/struct__GENERAL__LOOKASIDE.html#o4">AllocateMisses</a> += 1;
08406             lookasideList = prcb-&gt;PPLookasideList[number].<a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html#o0">L</a>;
08407             lookasideList-&gt;<a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html#o0">L</a>.<a class="code" href="../../d6/d1/struct__GENERAL__LOOKASIDE.html#o3">TotalAllocates</a> += 1;
08408             associatedIrp = (<a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>)<a class="code" href="../../d5/d8/ex_8h.html#a242">ExInterlockedPopEntrySList</a>(&amp;lookasideList-&gt;<a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html#o0">L</a>.<a class="code" href="../../d6/d1/struct__GENERAL__LOOKASIDE.html#o0">ListHead</a>,
08409                                                              &amp;lookasideList-&gt;<a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html#o1">Lock</a>);
08410         }
08411     }
08412 
08413     <span class="comment">//</span>
08414     <span class="comment">// If an IRP was not allocated from the lookaside list, then allocate</span>
08415     <span class="comment">// the packet from nonpaged pool.</span>
08416     <span class="comment">//</span>
08417 
08418     <span class="keywordflow">if</span> (!associatedIrp) {
08419         <span class="keywordflow">if</span> (fixedSize != 0) {
08420             lookasideList-&gt;<a class="code" href="../../d1/d4/struct__NPAGED__LOOKASIDE__LIST.html#o0">L</a>.<a class="code" href="../../d6/d1/struct__GENERAL__LOOKASIDE.html#o4">AllocateMisses</a> += 1;
08421         }
08422 
08423         <span class="comment">//</span>
08424         <span class="comment">// There are no free packets on the lookaside list, or the packet is</span>
08425         <span class="comment">// too large to be allocated from one of the lists, so it must be</span>
08426         <span class="comment">// allocated from general non-paged pool.</span>
08427         <span class="comment">//</span>
08428 
08429         associatedIrp = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(<a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, allocateSize, ' prI');
08430         <span class="keywordflow">if</span> (!associatedIrp) {
08431             <span class="keywordflow">if</span> (KeGetPreviousMode() == <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>) {
08432                 mustSucceed = <a class="code" href="../../d0/d5/io_8h.html#a191">IRP_ALLOCATED_MUST_SUCCEED</a>;
08433                 associatedIrp = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(<a class="code" href="../../d5/d8/ex_8h.html#a329a175">NonPagedPoolMustSucceed</a>,
08434                                                       allocateSize,
08435                                                       ' prI' );
08436             }
08437 
08438             <span class="keywordflow">if</span> (!associatedIrp) {
08439                 <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
08440             }
08441         }
08442 
08443     }
08444 
08445     <span class="comment">//</span>
08446     <span class="comment">// Initialize the packet.</span>
08447     <span class="comment">//</span>
08448 
08449     <a class="code" href="../../d0/d6/iop_8h.html#a20">IopInitializeIrp</a>(associatedIrp, packetSize, StackSize);
08450     associatedIrp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a177">IRP_ASSOCIATED_IRP</a>;
08451     associatedIrp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o17">AllocationFlags</a> |= (fixedSize | mustSucceed);
08452 
08453     <span class="comment">//</span>
08454     <span class="comment">// Set the thread ID to be that of the master.</span>
08455     <span class="comment">//</span>
08456 
08457     associatedIrp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread;
08458 
08459     <span class="comment">//</span>
08460     <span class="comment">// Now make the association between this packet and the master.</span>
08461     <span class="comment">//</span>
08462 
08463     associatedIrp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.MasterIrp = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>;
08464     <span class="keywordflow">return</span> associatedIrp;
08465 }
08466 
08467 BOOLEAN
<a name="l08468"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a88">08468</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a88">IoPageFileCreated</a>(
08469     IN HANDLE FileHandle
08470     )
08471 
08472 <span class="comment">/*++</span>
08473 <span class="comment"></span>
08474 <span class="comment">Routine Description:</span>
08475 <span class="comment"></span>
08476 <span class="comment">    This routine is invoked by the Memory Manager when a new page file is</span>
08477 <span class="comment">    created.  The purpose is to lookup the paging file to determine whether</span>
08478 <span class="comment">    or not it was created on the boot device.  If so, and taking crash dumps</span>
08479 <span class="comment">    is enabled, then the retrieval pointers are queried from the file system</span>
08480 <span class="comment">    for the file so that they can then be used later in writing the crash</span>
08481 <span class="comment">    dump to the paging file.</span>
08482 <span class="comment"></span>
08483 <span class="comment">    The Memory Manager will continue to invoke this function for each paging</span>
08484 <span class="comment">    file created in the system until the one for the boot device is encountered.</span>
08485 <span class="comment"></span>
08486 <span class="comment">Arguments:</span>
08487 <span class="comment"></span>
08488 <span class="comment">    FileHandle - Handle to the paging file just created.</span>
08489 <span class="comment"></span>
08490 <span class="comment">Return Value:</span>
08491 <span class="comment"></span>
08492 <span class="comment">    A value of TRUE is returned if this paging file resides on the system's</span>
08493 <span class="comment">    boot device, otherwise FALSE.</span>
08494 <span class="comment"></span>
08495 <span class="comment">--*/</span>
08496 
08497 {
08498     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> fileObject;
08499     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
08500     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
08501     BOOLEAN result;
08502 
08503     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
08504 
08505      <span class="keywordflow">return</span> <a class="code" href="../../d0/d6/iop_8h.html#a228">IopConfigureCrashDump</a>( FileHandle );
08506 }
08507 
08508 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l08509"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a89">08509</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a89">IoPageRead</a>(
08510     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
08511     IN <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MemoryDescriptorList,
08512     IN PLARGE_INTEGER StartingOffset,
08513     IN <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> Event,
08514     OUT PIO_STATUS_BLOCK IoStatusBlock
08515     )
08516 
08517 <span class="comment">/*++</span>
08518 <span class="comment"></span>
08519 <span class="comment">Routine Description:</span>
08520 <span class="comment"></span>
08521 <span class="comment">    This routine provides a special, fast interface for the Pager to read pages</span>
08522 <span class="comment">    in from the disk quickly and with very little overhead.  All of the special</span>
08523 <span class="comment">    handling for this request is recognized by setting the IRP_PAGING_IO flag</span>
08524 <span class="comment">    in the IRP flags word.  In-page operations are detected by using the IRP</span>
08525 <span class="comment">    flag IRP_INPUT_OPERATION.</span>
08526 <span class="comment"></span>
08527 <span class="comment">Arguments:</span>
08528 <span class="comment"></span>
08529 <span class="comment">    FileObject - A pointer to a referenced file object describing which file</span>
08530 <span class="comment">        the read should be performed from.</span>
08531 <span class="comment"></span>
08532 <span class="comment">    MemoryDescriptorList - An MDL which describes the physical pages that the</span>
08533 <span class="comment">        pages should be read into from the disk.  All of the pages have been</span>
08534 <span class="comment">        locked in memory.  The MDL also describes the length of the read</span>
08535 <span class="comment">        operation.</span>
08536 <span class="comment"></span>
08537 <span class="comment">    StartingOffset - Pointer to the offset in the file from which the read</span>
08538 <span class="comment">        should take place.</span>
08539 <span class="comment"></span>
08540 <span class="comment">    Event - A pointer to a kernel event structure to be used for synchronization</span>
08541 <span class="comment">        purposes.  The event will be set to the Signaled state once the in-page</span>
08542 <span class="comment">        operation completes.</span>
08543 <span class="comment"></span>
08544 <span class="comment">    IoStatusBlock - A pointer to the I/O status block in which the final status</span>
08545 <span class="comment">        and information should be stored.</span>
08546 <span class="comment"></span>
08547 <span class="comment">Return Value:</span>
08548 <span class="comment"></span>
08549 <span class="comment">    The function value is the final status of the queue request to the I/O</span>
08550 <span class="comment">    system subcomponents.</span>
08551 <span class="comment"></span>
08552 <span class="comment">Notes:</span>
08553 <span class="comment"></span>
08554 <span class="comment">    This routine is invoked at APC_LEVEL; this level is honored throughout the</span>
08555 <span class="comment">    execution of the entire I/O request, including completion.</span>
08556 <span class="comment"></span>
08557 <span class="comment">--*/</span>
08558 
08559 {
08560     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
08561     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
08562     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
08563 
08564     <span class="comment">//</span>
08565     <span class="comment">// Increment performance counter.  The Cache Manager I/Os always are</span>
08566     <span class="comment">// "recursive".</span>
08567     <span class="comment">//</span>
08568 
08569     <span class="keywordflow">if</span> (<a class="code" href="../../d2/d1/mm_8h.html#a16">MmIsRecursiveIoFault</a>()) {
08570         *<a class="code" href="../../d5/d2/cachedat_8c.html#a75">CcMissCounter</a> += (MemoryDescriptorList-&gt;ByteCount + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1) &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
08571     }
08572 
08573     <span class="comment">//</span>
08574     <span class="comment">// Begin by getting a pointer to the device object that the file resides</span>
08575     <span class="comment">// on.</span>
08576     <span class="comment">//</span>
08577 
08578     deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( FileObject );
08579 
08580     <span class="comment">//</span>
08581     <span class="comment">// Allocate an I/O Request Packet (IRP) for this in-page operation.</span>
08582     <span class="comment">//</span>
08583 
08584     irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a17">IoAllocateIrp</a>( deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o13">StackSize</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
08585     <span class="keywordflow">if</span> (!irp) {
08586         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
08587     }
08588 
08589     <span class="comment">//</span>
08590     <span class="comment">// Get a pointer to the first stack location in the packet.  This location</span>
08591     <span class="comment">// will be used to pass the function codes and parameters to the first</span>
08592     <span class="comment">// driver.</span>
08593     <span class="comment">//</span>
08594 
08595     irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
08596 
08597     <span class="comment">//</span>
08598     <span class="comment">// Fill in the IRP according to this request.</span>
08599     <span class="comment">//</span>
08600 
08601     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a> = MemoryDescriptorList;
08602     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a174">IRP_PAGING_IO</a> | <a class="code" href="../../d0/d5/io_8h.html#a173">IRP_NOCACHE</a> | <a class="code" href="../../d0/d5/io_8h.html#a181">IRP_SYNCHRONOUS_PAGING_IO</a> | <a class="code" href="../../d0/d5/io_8h.html#a180">IRP_INPUT_OPERATION</a>;
08603     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o10">RequestorMode</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>;
08604     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = IoStatusBlock;
08605     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>;
08606     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o26">UserBuffer</a> = (PVOID) ((PCHAR) MemoryDescriptorList-&gt;StartVa + MemoryDescriptorList-&gt;ByteOffset);
08607     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.OriginalFileObject = FileObject;
08608     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
08609 
08610     <span class="comment">//</span>
08611     <span class="comment">// Fill in the normal read parameters.</span>
08612     <span class="comment">//</span>
08613 
08614     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a16">IRP_MJ_READ</a>;
08615     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> = FileObject;
08616     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Read.Length = MemoryDescriptorList-&gt;ByteCount;
08617     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Read.ByteOffset = *StartingOffset;
08618 
08619     <span class="comment">//</span>
08620     <span class="comment">// Queue the packet to the appropriate driver based on whether or not there</span>
08621     <span class="comment">// is a VPB associated with the device.</span>
08622     <span class="comment">//</span>
08623 
08624     <span class="keywordflow">return</span> <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( deviceObject, irp );
08625 }
08626 
08627 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l08628"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a90">08628</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a90">IoQueryFileInformation</a>(
08629     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
08630     IN FILE_INFORMATION_CLASS FileInformationClass,
08631     IN ULONG Length,
08632     OUT PVOID FileInformation,
08633     OUT PULONG ReturnedLength
08634     )
08635 
08636 <span class="comment">/*++</span>
08637 <span class="comment"></span>
08638 <span class="comment">Routine Description:</span>
08639 <span class="comment"></span>
08640 <span class="comment">    This routine returns the requested information about a specified file.</span>
08641 <span class="comment">    The information returned is determined by the FileInformationClass that</span>
08642 <span class="comment">    is specified, and it is placed into the caller's FileInformation buffer.</span>
08643 <span class="comment"></span>
08644 <span class="comment">Arguments:</span>
08645 <span class="comment"></span>
08646 <span class="comment">    FileObject - Supplies a pointer to the file object about which the requested</span>
08647 <span class="comment">        information is returned.</span>
08648 <span class="comment"></span>
08649 <span class="comment">    FileInformationClass - Specifies the type of information which should be</span>
08650 <span class="comment">        returned about the file.</span>
08651 <span class="comment"></span>
08652 <span class="comment">    Length - Supplies the length, in bytes, of the FileInformation buffer.</span>
08653 <span class="comment"></span>
08654 <span class="comment">    FileInformation - Supplies a buffer to receive the requested information</span>
08655 <span class="comment">        returned about the file.  This buffer must not be pageable and must</span>
08656 <span class="comment">        reside in system space.</span>
08657 <span class="comment"></span>
08658 <span class="comment">    ReturnedLength - Supplies a variable that is to receive the length of the</span>
08659 <span class="comment">        information written to the FileInformation buffer.</span>
08660 <span class="comment"></span>
08661 <span class="comment">Return Value:</span>
08662 <span class="comment"></span>
08663 <span class="comment">    The status returned is the final completion status of the operation.</span>
08664 <span class="comment"></span>
08665 <span class="comment">--*/</span>
08666 
08667 {
08668     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
08669 
08670     <span class="comment">//</span>
08671     <span class="comment">// Simply invoke the common routine to perform the query operation.</span>
08672     <span class="comment">//</span>
08673 
08674     <span class="keywordflow">return</span> <a class="code" href="../../d0/d6/iop_8h.html#a203">IopQueryXxxInformation</a>( FileObject,
08675                                    FileInformationClass,
08676                                    Length,
08677                                    FileInformation,
08678                                    ReturnedLength,
08679                                    <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
08680 }
08681 
08682 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l08683"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a91">08683</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a91">IoQueryVolumeInformation</a>(
08684     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
08685     IN FS_INFORMATION_CLASS FsInformationClass,
08686     IN ULONG Length,
08687     OUT PVOID FsInformation,
08688     OUT PULONG ReturnedLength
08689     )
08690 
08691 <span class="comment">/*++</span>
08692 <span class="comment"></span>
08693 <span class="comment">Routine Description:</span>
08694 <span class="comment"></span>
08695 <span class="comment">    This routine returns the requested information about a specified volume.</span>
08696 <span class="comment">    The information returned is determined by the FsInformationClass that</span>
08697 <span class="comment">    is specified, and it is placed into the caller's FsInformation buffer.</span>
08698 <span class="comment"></span>
08699 <span class="comment">Arguments:</span>
08700 <span class="comment"></span>
08701 <span class="comment">    FileObject - Supplies a pointer to the file object about which the requested</span>
08702 <span class="comment">        information is returned.</span>
08703 <span class="comment"></span>
08704 <span class="comment">    FsInformationClass - Specifies the type of information which should be</span>
08705 <span class="comment">        returned about the volume.</span>
08706 <span class="comment"></span>
08707 <span class="comment">    Length - Supplies the length of the FsInformation buffer in bytes.</span>
08708 <span class="comment"></span>
08709 <span class="comment">    FsInformation - Supplies a buffer to receive the requested information</span>
08710 <span class="comment">        returned about the file.  This buffer must not be pageable and must</span>
08711 <span class="comment">        reside in system space.</span>
08712 <span class="comment"></span>
08713 <span class="comment">    ReturnedLength - Supplies a variable that is to receive the length of the</span>
08714 <span class="comment">        information written to the FsInformation buffer.</span>
08715 <span class="comment"></span>
08716 <span class="comment">Return Value:</span>
08717 <span class="comment"></span>
08718 <span class="comment">    The status returned is the final completion status of the operation.</span>
08719 <span class="comment"></span>
08720 <span class="comment">--*/</span>
08721 
08722 {
08723     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
08724 
08725     <span class="comment">//</span>
08726     <span class="comment">// Simply invoke the common routine to perform the query operation.</span>
08727     <span class="comment">//</span>
08728 
08729     <span class="keywordflow">return</span> <a class="code" href="../../d0/d6/iop_8h.html#a203">IopQueryXxxInformation</a>( FileObject,
08730                                    FsInformationClass,
08731                                    Length,
08732                                    FsInformation,
08733                                    ReturnedLength,
08734                                    <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
08735 }
08736 
08737 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l08738"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a92">08738</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a92">IoQueueThreadIrp</a>(
08739     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
08740     )
08741 
08742 <span class="comment">/*++</span>
08743 <span class="comment"></span>
08744 <span class="comment">Routine Description:</span>
08745 <span class="comment"></span>
08746 <span class="comment">    This routine queues the specified I/O Request Packet (IRP) to the current</span>
08747 <span class="comment">    thread's IRP pending queue.  This queue locates all of the outstanding</span>
08748 <span class="comment">    I/O requests for the thread.</span>
08749 <span class="comment"></span>
08750 <span class="comment">Arguments:</span>
08751 <span class="comment"></span>
08752 <span class="comment">    Irp - Pointer to the I/O Request Packet (IRP) to be queued.</span>
08753 <span class="comment"></span>
08754 <span class="comment">Return Value:</span>
08755 <span class="comment"></span>
08756 <span class="comment">    None.</span>
08757 <span class="comment"></span>
08758 <span class="comment">--*/</span>
08759 
08760 {
08761     <span class="comment">//</span>
08762     <span class="comment">// Simply queue the packet using the internal queueing routine.</span>
08763     <span class="comment">//</span>
08764 
08765     <a class="code" href="../../d0/d6/iop_8h.html#a21">IopQueueThreadIrp</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
08766 }
08767 
08768 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l08769"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a93">08769</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a93">IoRaiseHardError</a>(
08770     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
08771     IN <a class="code" href="../../d7/d7/struct__VPB.html">PVPB</a> Vpb OPTIONAL,
08772     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> RealDeviceObject
08773     )
08774 
08775 <span class="comment">/*++</span>
08776 <span class="comment"></span>
08777 <span class="comment">Routine Description:</span>
08778 <span class="comment"></span>
08779 <span class="comment">    This routine pops up a hard error in the context of the thread that</span>
08780 <span class="comment">    originally requested the I/O operation specified by the input IRP.  This</span>
08781 <span class="comment">    is done by queueing a kernel APC to the original thread, passing it a</span>
08782 <span class="comment">    pointer to the device objects and the IRP.  Once the pop up is performed,</span>
08783 <span class="comment">    the routine either completes the I/O request then, or it calls the driver</span>
08784 <span class="comment">    back with the same IRP.</span>
08785 <span class="comment"></span>
08786 <span class="comment">    If the original request was an IoPageRead, then it was at APC level and</span>
08787 <span class="comment">    we have to create a thread to "hold" this pop-up.  Note that we have to</span>
08788 <span class="comment">    queue to an ExWorker thread to create the thread since this can only be</span>
08789 <span class="comment">    done from the system process.</span>
08790 <span class="comment"></span>
08791 <span class="comment">Arguments:</span>
08792 <span class="comment"></span>
08793 <span class="comment">    Irp - A pointer to the I/O Request Packet (IRP) for the request that</span>
08794 <span class="comment">        failed.</span>
08795 <span class="comment"></span>
08796 <span class="comment">    Vpb - This is the volume parameter block of the offending media.  If the</span>
08797 <span class="comment">        media not yet mounted, this parameter should be absent.</span>
08798 <span class="comment"></span>
08799 <span class="comment">    RealDeviceObject - A pointer to the device object that represents the</span>
08800 <span class="comment">        device that the file system believes it has mounted.  This is</span>
08801 <span class="comment">        generally the "real" device object in the VPB, but may, in fact,</span>
08802 <span class="comment">        be a device object attached to the physical device.</span>
08803 <span class="comment"></span>
08804 <span class="comment">Return Value:</span>
08805 <span class="comment"></span>
08806 <span class="comment">    None.</span>
08807 <span class="comment"></span>
08808 <span class="comment">--*/</span>
08809 
08810 {
08811     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> IrpSp;
08812 
08813     <span class="comment">//</span>
08814     <span class="comment">// If pop-ups are disabled for the requesting thread, just complete the</span>
08815     <span class="comment">// request.</span>
08816     <span class="comment">//</span>
08817 
08818     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread-&gt;HardErrorsAreDisabled) {
08819 
08820         <span class="comment">//</span>
08821         <span class="comment">// An error was incurred, so zero out the information field before</span>
08822         <span class="comment">// completing the request if this was an input operation.  Otherwise,</span>
08823         <span class="comment">// IopCompleteRequest will try to copy to the user's buffer.</span>
08824         <span class="comment">//</span>
08825 
08826         <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a180">IRP_INPUT_OPERATION</a>) {
08827             <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information = 0;
08828         }
08829 
08830         <a class="code" href="../../d0/d5/io_8h.html#a224">IoCompleteRequest</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, <a class="code" href="../../d7/d8/exboosts_8h.html#a5">IO_DISK_INCREMENT</a> );
08831 
08832         <span class="keywordflow">return</span>;
08833     }
08834 
08835     <span class="comment">//</span>
08836     <span class="comment">//  If this Irp resulted from a call to IoPageRead(), the caller must</span>
08837     <span class="comment">//  have been at APC level, so don't try enqueing an APC.</span>
08838     <span class="comment">//</span>
08839     <span class="comment">//  Also if this is a cleanup Irp, force this pop-up to go to the new</span>
08840     <span class="comment">//  thread so that it cannot be disabled.</span>
08841     <span class="comment">//</span>
08842 
08843     IrpSp = <a class="code" href="../../d0/d5/io_8h.html#a228">IoGetCurrentIrpStackLocation</a>(<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>);
08844 
08845     <span class="keywordflow">if</span> ((<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> == (<a class="code" href="../../d0/d5/io_8h.html#a174">IRP_PAGING_IO</a> |
08846                         <a class="code" href="../../d0/d5/io_8h.html#a173">IRP_NOCACHE</a> |
08847                         <a class="code" href="../../d0/d5/io_8h.html#a181">IRP_SYNCHRONOUS_PAGING_IO</a> |
08848                         <a class="code" href="../../d0/d5/io_8h.html#a180">IRP_INPUT_OPERATION</a>)) ||
08849         (IrpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> == <a class="code" href="../../d0/d5/io_8h.html#a31">IRP_MJ_CLEANUP</a>)) {
08850 
08851         <a class="code" href="../../d5/d0/struct__IOP__APC__HARD__ERROR__PACKET.html">PIOP_APC_HARD_ERROR_PACKET</a> packet;
08852 
08853         packet = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
08854                                         <span class="keyword">sizeof</span>( <a class="code" href="../../d5/d0/struct__IOP__APC__HARD__ERROR__PACKET.html">IOP_APC_HARD_ERROR_PACKET</a> ),
08855                                         'rEoI' );
08856 
08857         <span class="keywordflow">if</span> ( packet == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
08858 
08859             <a class="code" href="../../d0/d5/io_8h.html#a224">IoCompleteRequest</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, <a class="code" href="../../d7/d8/exboosts_8h.html#a5">IO_DISK_INCREMENT</a> );
08860             <span class="keywordflow">return</span>;
08861         }
08862 
08863         <a class="code" href="../../d5/d8/ex_8h.html#a55">ExInitializeWorkItem</a>( &amp;packet-&gt;<a class="code" href="../../d5/d0/struct__IOP__APC__HARD__ERROR__PACKET.html#o0">Item</a>, <a class="code" href="../../d2/d4/internal_8c.html#a65">IopStartApcHardError</a>, packet );
08864         packet-&gt;<a class="code" href="../../d5/d0/struct__IOP__APC__HARD__ERROR__PACKET.html#o1">Irp</a> = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>;
08865         packet-&gt;<a class="code" href="../../d5/d0/struct__IOP__APC__HARD__ERROR__PACKET.html#o2">Vpb</a> = Vpb;
08866         packet-&gt;<a class="code" href="../../d5/d0/struct__IOP__APC__HARD__ERROR__PACKET.html#o3">RealDeviceObject</a> = RealDeviceObject;
08867 
08868         <a class="code" href="../../d5/d8/ex_8h.html#a261">ExQueueWorkItem</a>( &amp;packet-&gt;<a class="code" href="../../d5/d0/struct__IOP__APC__HARD__ERROR__PACKET.html#o0">Item</a>, <a class="code" href="../../d5/d8/ex_8h.html#a332a205">CriticalWorkQueue</a> );
08869 
08870     } <span class="keywordflow">else</span> {
08871 
08872         <a class="code" href="../../d1/d5/struct__KAPC.html">PKAPC</a> apc;
08873 
08874         <span class="comment">//</span>
08875         <span class="comment">// Begin by allocating and initializing an APC that can be sent to the</span>
08876         <span class="comment">// target thread.</span>
08877         <span class="comment">//</span>
08878 
08879         apc = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, <span class="keyword">sizeof</span>( <a class="code" href="../../d1/d5/struct__KAPC.html">KAPC</a> ), 'CPAK' );
08880 
08881         <span class="comment">//</span>
08882         <span class="comment">// If we could not get the pool, we have no choice but to just complete</span>
08883         <span class="comment">// the Irp, thereby passing the error onto the caller.</span>
08884         <span class="comment">//</span>
08885 
08886         <span class="keywordflow">if</span> ( apc == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
08887 
08888             <a class="code" href="../../d0/d5/io_8h.html#a224">IoCompleteRequest</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, <a class="code" href="../../d7/d8/exboosts_8h.html#a5">IO_DISK_INCREMENT</a> );
08889             <span class="keywordflow">return</span>;
08890         }
08891 
08892         <a class="code" href="../../d5/d7/apcobj_8c.html#a1">KeInitializeApc</a>( apc,
08893                          &amp;<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread-&gt;Tcb,
08894                          <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o16">ApcEnvironment</a>,
08895                          <a class="code" href="../../d2/d4/internal_8c.html#a31">IopDeallocateApc</a>,
08896                          <a class="code" href="../../d2/d4/internal_8c.html#a19">IopAbortRequest</a>,
08897                          <a class="code" href="../../d2/d4/internal_8c.html#a59">IopRaiseHardError</a>,
08898                          <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
08899                          <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
08900 
08901         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d5/d7/apcobj_8c.html#a3">KeInsertQueueApc</a>( apc,
08902                                  Vpb,
08903                                  RealDeviceObject,
08904                                  0 );
08905     }
08906 }
08907 
08908 BOOLEAN
<a name="l08909"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a94">08909</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a94">IoRaiseInformationalHardError</a>(
08910     IN NTSTATUS ErrorStatus,
08911     IN PUNICODE_STRING String OPTIONAL,
08912     IN <a class="code" href="../../d1/d8/struct__KTHREAD.html">PKTHREAD</a> Thread OPTIONAL
08913     )
08914 <span class="comment">/*++</span>
08915 <span class="comment"></span>
08916 <span class="comment">Routine Description:</span>
08917 <span class="comment"></span>
08918 <span class="comment">    This routine pops up a hard error in the hard error popup thread.  The</span>
08919 <span class="comment">    routine returns immediately, enqueuing the actual pop-up to a worker</span>
08920 <span class="comment">    thread.  The hard error that is raised is informational in the sense that</span>
08921 <span class="comment">    only the OK button is displayed.</span>
08922 <span class="comment"></span>
08923 <span class="comment">Arguments:</span>
08924 <span class="comment"></span>
08925 <span class="comment">    ErrorStatus - The error condition.</span>
08926 <span class="comment"></span>
08927 <span class="comment">    String - Depending on the error, a string may have to be enqueued.</span>
08928 <span class="comment"></span>
08929 <span class="comment">    Thread - If present, enqueue an APC to this thread rather than using</span>
08930 <span class="comment">        the hard error thread.</span>
08931 <span class="comment"></span>
08932 <span class="comment">Return Value:</span>
08933 <span class="comment"></span>
08934 <span class="comment">    BOOLEAN - TRUE if we decided to dispatch a pop-up.  FALSE if we decided</span>
08935 <span class="comment">        not to because:</span>
08936 <span class="comment"></span>
08937 <span class="comment">        - pop-ups are disabled in the requested thread, or</span>
08938 <span class="comment"></span>
08939 <span class="comment">        - a pool allocation failed, or</span>
08940 <span class="comment"></span>
08941 <span class="comment">        - an equivalent pop-up is currently pending a user response (i.e.</span>
08942 <span class="comment">          waiting for the user to press &lt;OK&gt;) or in the queue, or</span>
08943 <span class="comment"></span>
08944 <span class="comment">        - too many pop-ups have already been queued.</span>
08945 <span class="comment"></span>
08946 <span class="comment">--*/</span>
08947 
08948 <span class="comment">//</span>
08949 <span class="comment">//  This macro compares two pop-ups to see if they are content equivalent.</span>
08950 <span class="comment">//</span>
08951 
08952 #define <a class="code" href="../../d4/d6/iosubs_8c.html#a6">ArePacketsEquivalent</a>(P1,P2) (                              \
08953     (P1-&gt;ErrorStatus == P2-&gt;ErrorStatus) &amp;&amp;                        \
08954     ((!P1-&gt;String.Buffer &amp;&amp; !P2-&gt;String.Buffer) ||                 \
08955      ((P1-&gt;String.Length == P2-&gt;String.Length) &amp;&amp;                  \
08956       (RtlEqualMemory(P1-&gt;String.Buffer,                           \
08957                         P2-&gt;String.Buffer,                         \
08958                         P1-&gt;String.Length))))                      \
08959 )
08960 
08961 {
08962     KIRQL oldIrql;
08963     PVOID stringBuffer;
08964     PLIST_ENTRY links;
08965 
08966     <a class="code" href="../../d7/d0/struct__IOP__HARD__ERROR__PACKET.html">PIOP_HARD_ERROR_PACKET</a> hardErrorPacket;
08967 
08968     <span class="comment">//</span>
08969     <span class="comment">// If pop-ups are disabled for the requesting thread, just return.</span>
08970     <span class="comment">//</span>
08971 
08972     <span class="keywordflow">if</span> (ARGUMENT_PRESENT(Thread) ?
08973         CONTAINING_RECORD(Thread, <a class="code" href="../../d5/d6/struct__ETHREAD.html">ETHREAD</a>, Tcb)-&gt;HardErrorsAreDisabled :
08974         <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>()-&gt;HardErrorsAreDisabled) {
08975 
08976         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
08977     }
08978 
08979     <span class="comment">//</span>
08980     <span class="comment">// If this is one of those special error popup codes that CSRSS expects</span>
08981     <span class="comment">// to be called with a correct set of arguments, disallow from a driver</span>
08982     <span class="comment">//</span>
08983     <span class="keywordflow">if</span> ( ErrorStatus == STATUS_VDM_HARD_ERROR ||
08984          ErrorStatus == STATUS_UNHANDLED_EXCEPTION ||
08985          ErrorStatus == STATUS_SERVICE_NOTIFICATION ) {
08986         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
08987     }
08988 
08989     <span class="comment">//</span>
08990     <span class="comment">//  If this request is going to be sent to the hard error thread, and</span>
08991     <span class="comment">//  there are more than 25 entries already in the queue, don't</span>
08992     <span class="comment">//  add any more.  We'll do another safe check later on.</span>
08993     <span class="comment">//</span>
08994 
08995     <span class="keywordflow">if</span> ( !ARGUMENT_PRESENT( Thread ) &amp;&amp;
08996          (<a class="code" href="../../d1/d6/semphobj_8c.html#a2">KeReadStateSemaphore</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a25">IopHardError</a>.<a class="code" href="../../d8/d0/struct__IOP__HARD__ERROR__QUEUE.html#o3">WorkQueueSemaphore</a> ) &gt;=
08997           <a class="code" href="../../d0/d6/iop_8h.html#a2">IOP_MAXIMUM_OUTSTANDING_HARD_ERRORS</a>) ) {
08998 
08999         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
09000     } <span class="keywordflow">else</span> {
09001         <span class="keywordflow">if</span> (<a class="code" href="../../d3/d5/iodata_8c.html#a25">IopHardError</a>.<a class="code" href="../../d8/d0/struct__IOP__HARD__ERROR__QUEUE.html#o5">NumPendingApcPopups</a> &gt; <a class="code" href="../../d0/d6/iop_8h.html#a2">IOP_MAXIMUM_OUTSTANDING_HARD_ERRORS</a>) {
09002             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
09003         }
09004     }
09005 
09006     <span class="comment">//</span>
09007     <span class="comment">//  Allocate the packet, and a buffer for the string if present.</span>
09008     <span class="comment">//</span>
09009 
09010     hardErrorPacket = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
09011                                              <span class="keyword">sizeof</span>(<a class="code" href="../../d7/d0/struct__IOP__HARD__ERROR__PACKET.html">IOP_HARD_ERROR_PACKET</a>),
09012                                              'rEoI');
09013 
09014     <span class="keywordflow">if</span> (!hardErrorPacket) { <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>; }
09015 
09016     <span class="comment">//</span>
09017     <span class="comment">//  Zero out the packet and fill the NT_STATUS we will pop up.</span>
09018     <span class="comment">//</span>
09019 
09020     RtlZeroMemory( hardErrorPacket, <span class="keyword">sizeof</span>(<a class="code" href="../../d0/d6/iop_8h.html#a31">IOP_HARD_ERROR_PACKET</a>) );
09021 
09022     hardErrorPacket-&gt;<a class="code" href="../../d7/d0/struct__IOP__HARD__ERROR__PACKET.html#o1">ErrorStatus</a> = ErrorStatus;
09023 
09024     <span class="comment">//</span>
09025     <span class="comment">//  If there is a string, copy it.</span>
09026     <span class="comment">//</span>
09027 
09028     <span class="keywordflow">if</span> ( ARGUMENT_PRESENT( <a class="code" href="../../d4/d9/talloc_8c.html#a0">String</a> ) &amp;&amp; <a class="code" href="../../d4/d9/talloc_8c.html#a0">String</a>-&gt;Length ) {
09029 
09030         stringBuffer = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
09031                                               <a class="code" href="../../d4/d9/talloc_8c.html#a0">String</a>-&gt;Length,
09032                                               'rEoI' );
09033 
09034         <span class="keywordflow">if</span> (!stringBuffer) {
09035             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( hardErrorPacket );
09036             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
09037         }
09038 
09039         hardErrorPacket-&gt;<a class="code" href="../../d7/d0/struct__IOP__HARD__ERROR__PACKET.html#o2">String</a>.Length = <a class="code" href="../../d4/d9/talloc_8c.html#a0">String</a>-&gt;Length;
09040         hardErrorPacket-&gt;<a class="code" href="../../d7/d0/struct__IOP__HARD__ERROR__PACKET.html#o2">String</a>.MaximumLength = <a class="code" href="../../d4/d9/talloc_8c.html#a0">String</a>-&gt;Length;
09041 
09042         hardErrorPacket-&gt;<a class="code" href="../../d7/d0/struct__IOP__HARD__ERROR__PACKET.html#o2">String</a>.Buffer = stringBuffer;
09043 
09044         RtlCopyMemory( stringBuffer, <a class="code" href="../../d4/d9/talloc_8c.html#a0">String</a>-&gt;Buffer, <a class="code" href="../../d4/d9/talloc_8c.html#a0">String</a>-&gt;Length );
09045     }
09046 
09047     <span class="comment">//</span>
09048     <span class="comment">//  If there is an Thread, enqueue an APC for ourself, otherwise send</span>
09049     <span class="comment">//  it off to the to the hard error thread.</span>
09050     <span class="comment">//</span>
09051 
09052     <span class="keywordflow">if</span> ( ARGUMENT_PRESENT( Thread ) ) {
09053 
09054         <a class="code" href="../../d1/d5/struct__KAPC.html">PKAPC</a> apc;
09055 
09056         <span class="comment">//</span>
09057         <span class="comment">// Begin by allocating and initializing an APC that can be sent to the</span>
09058         <span class="comment">// target thread.</span>
09059         <span class="comment">//</span>
09060 
09061         apc = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>, <span class="keyword">sizeof</span>( <a class="code" href="../../d1/d5/struct__KAPC.html">KAPC</a> ), 'CPAK' );
09062 
09063         <span class="comment">//</span>
09064         <span class="comment">// If we could not get the pool, we have no choice but to just</span>
09065         <span class="comment">// free the packet and return.</span>
09066         <span class="comment">//</span>
09067 
09068         <span class="keywordflow">if</span> ( apc == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> ) {
09069 
09070             <span class="keywordflow">if</span> ( hardErrorPacket-&gt;<a class="code" href="../../d7/d0/struct__IOP__HARD__ERROR__PACKET.html#o2">String</a>.Buffer ) {
09071                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( hardErrorPacket-&gt;<a class="code" href="../../d7/d0/struct__IOP__HARD__ERROR__PACKET.html#o2">String</a>.Buffer );
09072             }
09073 
09074             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( hardErrorPacket );
09075 
09076             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
09077         }
09078 
09079         InterlockedIncrement(&amp;<a class="code" href="../../d3/d5/iodata_8c.html#a25">IopHardError</a>.<a class="code" href="../../d8/d0/struct__IOP__HARD__ERROR__QUEUE.html#o5">NumPendingApcPopups</a>);
09080         <a class="code" href="../../d5/d7/apcobj_8c.html#a1">KeInitializeApc</a>( apc,
09081                          Thread,
09082                          <a class="code" href="../../d4/d9/ke_8h.html#a403a183">CurrentApcEnvironment</a>,
09083                          <a class="code" href="../../d2/d4/internal_8c.html#a31">IopDeallocateApc</a>,
09084                          <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
09085                          <a class="code" href="../../d2/d4/internal_8c.html#a60">IopRaiseInformationalHardError</a>,
09086                          <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
09087                          hardErrorPacket );
09088 
09089         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d5/d7/apcobj_8c.html#a3">KeInsertQueueApc</a>( apc, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, 0 );
09090 
09091     } <span class="keywordflow">else</span> {
09092 
09093         <span class="comment">//</span>
09094         <span class="comment">//  Get exclusive access to the work queue.</span>
09095         <span class="comment">//</span>
09096 
09097         ExAcquireSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a25">IopHardError</a>.<a class="code" href="../../d8/d0/struct__IOP__HARD__ERROR__QUEUE.html#o2">WorkQueueSpinLock</a>, &amp;oldIrql );
09098 
09099         <span class="comment">//</span>
09100         <span class="comment">//  Check the Signal state again, if OK, go ahead and enqueue.</span>
09101         <span class="comment">//</span>
09102 
09103         <span class="keywordflow">if</span> ( <a class="code" href="../../d1/d6/semphobj_8c.html#a2">KeReadStateSemaphore</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a25">IopHardError</a>.<a class="code" href="../../d8/d0/struct__IOP__HARD__ERROR__QUEUE.html#o3">WorkQueueSemaphore</a> ) &gt;=
09104              <a class="code" href="../../d0/d6/iop_8h.html#a2">IOP_MAXIMUM_OUTSTANDING_HARD_ERRORS</a> ) {
09105 
09106             ExReleaseSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a25">IopHardError</a>.<a class="code" href="../../d8/d0/struct__IOP__HARD__ERROR__QUEUE.html#o2">WorkQueueSpinLock</a>, oldIrql );
09107 
09108             <span class="keywordflow">if</span> ( hardErrorPacket-&gt;<a class="code" href="../../d7/d0/struct__IOP__HARD__ERROR__PACKET.html#o2">String</a>.Buffer ) {
09109                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( hardErrorPacket-&gt;<a class="code" href="../../d7/d0/struct__IOP__HARD__ERROR__PACKET.html#o2">String</a>.Buffer );
09110             }
09111             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( hardErrorPacket );
09112             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
09113         }
09114 
09115         <span class="comment">//</span>
09116         <span class="comment">//  If there is a pop-up currently up, check for a match</span>
09117         <span class="comment">//</span>
09118 
09119         <span class="keywordflow">if</span> (<a class="code" href="../../d3/d5/iodata_8c.html#a26">IopCurrentHardError</a> &amp;&amp;
09120             <a class="code" href="../../d4/d6/iosubs_8c.html#a6">ArePacketsEquivalent</a>( hardErrorPacket, <a class="code" href="../../d3/d5/iodata_8c.html#a26">IopCurrentHardError</a> )) {
09121 
09122             ExReleaseSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a25">IopHardError</a>.<a class="code" href="../../d8/d0/struct__IOP__HARD__ERROR__QUEUE.html#o2">WorkQueueSpinLock</a>, oldIrql );
09123 
09124             <span class="keywordflow">if</span> ( hardErrorPacket-&gt;<a class="code" href="../../d7/d0/struct__IOP__HARD__ERROR__PACKET.html#o2">String</a>.Buffer ) {
09125                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( hardErrorPacket-&gt;<a class="code" href="../../d7/d0/struct__IOP__HARD__ERROR__PACKET.html#o2">String</a>.Buffer );
09126             }
09127             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( hardErrorPacket );
09128             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
09129         }
09130 
09131         <span class="comment">//</span>
09132         <span class="comment">//  Run down the list of queued pop-ups looking for a match.</span>
09133         <span class="comment">//</span>
09134 
09135         links = <a class="code" href="../../d3/d5/iodata_8c.html#a25">IopHardError</a>.<a class="code" href="../../d8/d0/struct__IOP__HARD__ERROR__QUEUE.html#o1">WorkQueue</a>.Flink;
09136 
09137         <span class="keywordflow">while</span> (links != &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a25">IopHardError</a>.<a class="code" href="../../d8/d0/struct__IOP__HARD__ERROR__QUEUE.html#o1">WorkQueue</a>) {
09138 
09139             <a class="code" href="../../d7/d0/struct__IOP__HARD__ERROR__PACKET.html">PIOP_HARD_ERROR_PACKET</a> queueHardErrorPacket;
09140 
09141             queueHardErrorPacket = CONTAINING_RECORD( links,
09142                                                       <a class="code" href="../../d0/d6/iop_8h.html#a31">IOP_HARD_ERROR_PACKET</a>,
09143                                                       WorkQueueLinks );
09144 
09145             <span class="keywordflow">if</span> (<a class="code" href="../../d4/d6/iosubs_8c.html#a6">ArePacketsEquivalent</a>( hardErrorPacket,
09146                                       queueHardErrorPacket )) {
09147 
09148                 ExReleaseSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a25">IopHardError</a>.<a class="code" href="../../d8/d0/struct__IOP__HARD__ERROR__QUEUE.html#o2">WorkQueueSpinLock</a>, oldIrql );
09149 
09150                 <span class="keywordflow">if</span> ( hardErrorPacket-&gt;<a class="code" href="../../d7/d0/struct__IOP__HARD__ERROR__PACKET.html#o2">String</a>.Buffer ) {
09151                     <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( hardErrorPacket-&gt;<a class="code" href="../../d7/d0/struct__IOP__HARD__ERROR__PACKET.html#o2">String</a>.Buffer );
09152                 }
09153                 <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( hardErrorPacket );
09154                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
09155             }
09156 
09157             links = links-&gt;Flink;
09158         }
09159 
09160         <span class="comment">//</span>
09161         <span class="comment">//  Enqueue this packet.</span>
09162         <span class="comment">//</span>
09163 
09164         InsertTailList( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a25">IopHardError</a>.<a class="code" href="../../d8/d0/struct__IOP__HARD__ERROR__QUEUE.html#o1">WorkQueue</a>,
09165                         &amp;hardErrorPacket-&gt;<a class="code" href="../../d7/d0/struct__IOP__HARD__ERROR__PACKET.html#o0">WorkQueueLinks</a> );
09166 
09167         <span class="comment">//</span>
09168         <span class="comment">//  Bump the count on the semaphore so that the hard error thread</span>
09169         <span class="comment">//  will know that an entry has been placed in the queue.</span>
09170         <span class="comment">//</span>
09171 
09172         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d6/semphobj_8c.html#a3">KeReleaseSemaphore</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a25">IopHardError</a>.<a class="code" href="../../d8/d0/struct__IOP__HARD__ERROR__QUEUE.html#o3">WorkQueueSemaphore</a>,
09173                                    0,
09174                                    1<a class="code" href="../../d2/d0/aw_8h.html#a3">L</a>,
09175                                    <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
09176 
09177         <span class="comment">//</span>
09178         <span class="comment">//  If we are not currently running in an ExWorkerThread, queue</span>
09179         <span class="comment">//  a work item.</span>
09180         <span class="comment">//</span>
09181 
09182         <span class="keywordflow">if</span> ( !<a class="code" href="../../d3/d5/iodata_8c.html#a25">IopHardError</a>.<a class="code" href="../../d8/d0/struct__IOP__HARD__ERROR__QUEUE.html#o4">ThreadStarted</a> ) {
09183             <a class="code" href="../../d3/d5/iodata_8c.html#a25">IopHardError</a>.<a class="code" href="../../d8/d0/struct__IOP__HARD__ERROR__QUEUE.html#o4">ThreadStarted</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
09184             <a class="code" href="../../d5/d8/ex_8h.html#a261">ExQueueWorkItem</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a25">IopHardError</a>.<a class="code" href="../../d8/d0/struct__IOP__HARD__ERROR__QUEUE.html#o0">ExWorkItem</a>, <a class="code" href="../../d5/d8/ex_8h.html#a332a206">DelayedWorkQueue</a> );
09185         }
09186 
09187         <span class="comment">//</span>
09188         <span class="comment">//  Finally, release the spinlockevent, allowing access to the work queue again.</span>
09189         <span class="comment">//  The combination of releasing both the event and the semaphore will</span>
09190         <span class="comment">//  enable the thread to wake up and obtain the entry.</span>
09191         <span class="comment">//</span>
09192 
09193         ExReleaseSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a25">IopHardError</a>.<a class="code" href="../../d8/d0/struct__IOP__HARD__ERROR__QUEUE.html#o2">WorkQueueSpinLock</a>, oldIrql );
09194     }
09195 
09196     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
09197 }
09198 
09199 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l09200"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a95">09200</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a95">IoRegisterBootDriverReinitialization</a>(
09201     IN <a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html">PDRIVER_OBJECT</a> DriverObject,
09202     IN PDRIVER_REINITIALIZE DriverReinitializationRoutine,
09203     IN PVOID Context
09204     )
09205 
09206 <span class="comment">/*++</span>
09207 <span class="comment"></span>
09208 <span class="comment">Routine Description:</span>
09209 <span class="comment"></span>
09210 <span class="comment">    This routine is invoked by boot drivers during their initialization or</span>
09211 <span class="comment">    during their reinitialization to register with the I/O system to be</span>
09212 <span class="comment">    called again once all devices have been enumerated and started.</span>
09213 <span class="comment">    Note that it  is possible for this to occur during a normally running</span>
09214 <span class="comment">    system, if the  driver is loaded dynamically, so all references to the</span>
09215 <span class="comment">    reinitialization queue must be synchronized.</span>
09216 <span class="comment"></span>
09217 <span class="comment">Arguments:</span>
09218 <span class="comment"></span>
09219 <span class="comment">    DriverObject - Pointer to the driver's driver object.</span>
09220 <span class="comment"></span>
09221 <span class="comment">    DriverReinitializationRoutine - The address of the reinitialization</span>
09222 <span class="comment">        routine that is to be invoked.</span>
09223 <span class="comment"></span>
09224 <span class="comment">    Context - Pointer to the context that is passed to the driver's</span>
09225 <span class="comment">        reinitialization routine.</span>
09226 <span class="comment"></span>
09227 <span class="comment">Return Value:</span>
09228 <span class="comment"></span>
09229 <span class="comment">    None.</span>
09230 <span class="comment"></span>
09231 <span class="comment">--*/</span>
09232 
09233 {
09234     <a class="code" href="../../d5/d3/struct__REINIT__PACKET.html">PREINIT_PACKET</a> reinitEntry;
09235 
09236     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
09237 
09238     <span class="comment">//</span>
09239     <span class="comment">// Allocate a reinitialization entry to be inserted onto the list.  Note</span>
09240     <span class="comment">// that if the entry cannot be allocated, then the request is simply</span>
09241     <span class="comment">// dropped on the floor.</span>
09242     <span class="comment">//</span>
09243 
09244     reinitEntry = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
09245                                          <span class="keyword">sizeof</span>( <a class="code" href="../../d5/d3/struct__REINIT__PACKET.html">REINIT_PACKET</a> ),
09246                                          'iRoI' );
09247     <span class="keywordflow">if</span> (!reinitEntry) {
09248         <span class="keywordflow">return</span>;
09249     }
09250 
09251     DriverObject-&gt;Flags |= <a class="code" href="../../d0/d5/io_8h.html#a148">DRVO_BOOTREINIT_REGISTERED</a>;
09252     reinitEntry-&gt;<a class="code" href="../../d5/d3/struct__REINIT__PACKET.html#o1">DriverObject</a> = DriverObject;
09253     reinitEntry-&gt;<a class="code" href="../../d5/d3/struct__REINIT__PACKET.html#o2">DriverReinitializationRoutine</a> = DriverReinitializationRoutine;
09254     reinitEntry-&gt;<a class="code" href="../../d5/d3/struct__REINIT__PACKET.html#o3">Context</a> = Context;
09255 
09256     <a class="code" href="../../d5/d8/ex_8h.html#a238">ExInterlockedInsertTailList</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a10">IopBootDriverReinitializeQueueHead</a>,
09257                                  &amp;reinitEntry-&gt;<a class="code" href="../../d5/d3/struct__REINIT__PACKET.html#o0">ListEntry</a>,
09258                                  &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a> );
09259 }
09260 
09261 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l09262"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a96">09262</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a96">IoRegisterDriverReinitialization</a>(
09263     IN <a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html">PDRIVER_OBJECT</a> DriverObject,
09264     IN PDRIVER_REINITIALIZE DriverReinitializationRoutine,
09265     IN PVOID Context
09266     )
09267 
09268 <span class="comment">/*++</span>
09269 <span class="comment"></span>
09270 <span class="comment">Routine Description:</span>
09271 <span class="comment"></span>
09272 <span class="comment">    This routine is invoked by drivers during their initialization or during</span>
09273 <span class="comment">    their reinitialization to register with the I/O system to be called again</span>
09274 <span class="comment">    before I/O system initialization is complete.  Note that it is possible</span>
09275 <span class="comment">    for this to occur during a normally running system, if the driver is</span>
09276 <span class="comment">    loaded dynamically, so all references to the reinitialization queue must</span>
09277 <span class="comment">    be synchronized.</span>
09278 <span class="comment"></span>
09279 <span class="comment">Arguments:</span>
09280 <span class="comment"></span>
09281 <span class="comment">    DriverObject - Pointer to the driver's driver object.</span>
09282 <span class="comment"></span>
09283 <span class="comment">    DriverReinitializationRoutine - The address of the reinitialization</span>
09284 <span class="comment">        routine that is to be invoked.</span>
09285 <span class="comment"></span>
09286 <span class="comment">    Context - Pointer to the context that is passed to the driver's</span>
09287 <span class="comment">        reinitialization routine.</span>
09288 <span class="comment"></span>
09289 <span class="comment">Return Value:</span>
09290 <span class="comment"></span>
09291 <span class="comment">    None.</span>
09292 <span class="comment"></span>
09293 <span class="comment">--*/</span>
09294 
09295 {
09296     <a class="code" href="../../d5/d3/struct__REINIT__PACKET.html">PREINIT_PACKET</a> reinitEntry;
09297 
09298     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
09299 
09300     <span class="comment">//</span>
09301     <span class="comment">// Allocate a reinitialization entry to be inserted onto the list.  Note</span>
09302     <span class="comment">// that if the entry cannot be allocated, then the request is simply</span>
09303     <span class="comment">// dropped on the floor.</span>
09304     <span class="comment">//</span>
09305 
09306     reinitEntry = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
09307                                          <span class="keyword">sizeof</span>( <a class="code" href="../../d5/d3/struct__REINIT__PACKET.html">REINIT_PACKET</a> ),
09308                                          'iRoI' );
09309     <span class="keywordflow">if</span> (!reinitEntry) {
09310         <span class="keywordflow">return</span>;
09311     }
09312 
09313     DriverObject-&gt;Flags |= <a class="code" href="../../d0/d5/io_8h.html#a146">DRVO_REINIT_REGISTERED</a>;
09314     reinitEntry-&gt;<a class="code" href="../../d5/d3/struct__REINIT__PACKET.html#o1">DriverObject</a> = DriverObject;
09315     reinitEntry-&gt;<a class="code" href="../../d5/d3/struct__REINIT__PACKET.html#o2">DriverReinitializationRoutine</a> = DriverReinitializationRoutine;
09316     reinitEntry-&gt;<a class="code" href="../../d5/d3/struct__REINIT__PACKET.html#o3">Context</a> = Context;
09317 
09318     <a class="code" href="../../d5/d8/ex_8h.html#a238">ExInterlockedInsertTailList</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a11">IopDriverReinitializeQueueHead</a>,
09319                                  &amp;reinitEntry-&gt;<a class="code" href="../../d5/d3/struct__REINIT__PACKET.html#o0">ListEntry</a>,
09320                                  &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a> );
09321 }
09322 
09323 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l09324"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a97">09324</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a97">IoRegisterFileSystem</a>(
09325     IN OUT <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject
09326     )
09327 
09328 <span class="comment">/*++</span>
09329 <span class="comment"></span>
09330 <span class="comment">Routine Description:</span>
09331 <span class="comment"></span>
09332 <span class="comment">    This routine inserts the device object for the file system which the device</span>
09333 <span class="comment">    object represents into the list of file systems in the system.</span>
09334 <span class="comment"></span>
09335 <span class="comment">Arguments:</span>
09336 <span class="comment"></span>
09337 <span class="comment">    DeviceObject - Pointer to device object for the file system.</span>
09338 <span class="comment"></span>
09339 <span class="comment">Return Value:</span>
09340 <span class="comment"></span>
09341 <span class="comment">    None.</span>
09342 <span class="comment"></span>
09343 <span class="comment"></span>
09344 <span class="comment">--*/</span>
09345 
09346 {
09347     <a class="code" href="../../d8/d3/struct__NOTIFICATION__PACKET.html">PNOTIFICATION_PACKET</a> nPacket;
09348     PLIST_ENTRY listHead = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
09349     PLIST_ENTRY entry;
09350 
09351     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
09352 
09353     <span class="comment">//</span>
09354     <span class="comment">// Allocate the I/O database resource for a write operation.</span>
09355     <span class="comment">//</span>
09356 
09357     (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d5/d8/ex_8h.html#a70">ExAcquireResourceExclusive</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a4">IopDatabaseResource</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
09358 
09359     <span class="comment">//</span>
09360     <span class="comment">// Insert the device object into the appropriate file system queue based on</span>
09361     <span class="comment">// the driver type in the device object.  Notice that if the device type is</span>
09362     <span class="comment">// unrecognized, the file system is simply not registered.</span>
09363     <span class="comment">//</span>
09364 
09365     <span class="keywordflow">if</span> (DeviceObject-&gt;DeviceType == FILE_DEVICE_NETWORK_FILE_SYSTEM) {
09366         listHead = &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a8">IopNetworkFileSystemQueueHead</a>;
09367     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (DeviceObject-&gt;DeviceType == FILE_DEVICE_CD_ROM_FILE_SYSTEM) {
09368         listHead = &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a7">IopCdRomFileSystemQueueHead</a>;
09369     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (DeviceObject-&gt;DeviceType == FILE_DEVICE_DISK_FILE_SYSTEM) {
09370         listHead = &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a6">IopDiskFileSystemQueueHead</a>;
09371     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (DeviceObject-&gt;DeviceType == FILE_DEVICE_TAPE_FILE_SYSTEM) {
09372         listHead = &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a9">IopTapeFileSystemQueueHead</a>;
09373     }
09374 
09375     <span class="comment">//</span>
09376     <span class="comment">//  Low priority filesystems are inserted one-from-back on the queue (ahead of</span>
09377     <span class="comment">//  raw, behind everything else), as opposed to on the front.</span>
09378     <span class="comment">//</span>
09379 
09380     <span class="keywordflow">if</span> (listHead != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
09381         <span class="keywordflow">if</span> (DeviceObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a137">DO_LOW_PRIORITY_FILESYSTEM</a> ) {
09382             InsertTailList( listHead-&gt;Blink,
09383                             &amp;DeviceObject-&gt;Queue.ListEntry );
09384         } <span class="keywordflow">else</span> {
09385             InsertHeadList( listHead,
09386                             &amp;DeviceObject-&gt;Queue.ListEntry );
09387         }
09388     }
09389 
09390     <span class="comment">//</span>
09391     <span class="comment">// Ensure that this file system's device is operable.</span>
09392     <span class="comment">//</span>
09393 
09394     DeviceObject-&gt;Flags &amp;= ~<a class="code" href="../../d0/d5/io_8h.html#a128">DO_DEVICE_INITIALIZING</a>;
09395 
09396     <span class="comment">//</span>
09397     <span class="comment">// Notify all of the registered drivers that this file system has been</span>
09398     <span class="comment">// registered as an active file system of some type.</span>
09399     <span class="comment">//</span>
09400 
09401     entry = <a class="code" href="../../d3/d5/iodata_8c.html#a14">IopFsNotifyChangeQueueHead</a>.Flink;
09402     <span class="keywordflow">while</span> (entry != &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a14">IopFsNotifyChangeQueueHead</a>) {
09403         nPacket = CONTAINING_RECORD( entry, <a class="code" href="../../d8/d3/struct__NOTIFICATION__PACKET.html">NOTIFICATION_PACKET</a>, ListEntry );
09404         entry = entry-&gt;Flink;
09405         nPacket-&gt;<a class="code" href="../../d8/d3/struct__NOTIFICATION__PACKET.html#o2">NotificationRoutine</a>( DeviceObject, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
09406     }
09407 
09408     <span class="comment">//</span>
09409     <span class="comment">// Release the I/O database resource.</span>
09410     <span class="comment">//</span>
09411 
09412     <a class="code" href="../../d5/d8/ex_8h.html#a66">ExReleaseResource</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a4">IopDatabaseResource</a> );
09413 
09414     <span class="comment">//</span>
09415     <span class="comment">// Increment the number of reasons that this driver cannot be unloaded.</span>
09416     <span class="comment">//</span>
09417 
09418     <a class="code" href="../../d5/d8/ex_8h.html#a235">ExInterlockedAddUlong</a>( &amp;DeviceObject-&gt;ReferenceCount, 1, &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a> );
09419 }
09420 
09421 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l09422"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a98">09422</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a98">IoRegisterFsRegistrationChange</a>(
09423     IN <a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html">PDRIVER_OBJECT</a> DriverObject,
09424     IN PDRIVER_FS_NOTIFICATION DriverNotificationRoutine
09425     )
09426 
09427 <span class="comment">/*++</span>
09428 <span class="comment"></span>
09429 <span class="comment">Routine Description:</span>
09430 <span class="comment"></span>
09431 <span class="comment">    This routine registers the specified driver's notification routine to be</span>
09432 <span class="comment">    invoked whenever a file system registers or unregisters itself as an active</span>
09433 <span class="comment">    file system in the system.</span>
09434 <span class="comment"></span>
09435 <span class="comment">Arguments:</span>
09436 <span class="comment"></span>
09437 <span class="comment">    DriverObject - Pointer to the driver object for the driver.</span>
09438 <span class="comment"></span>
09439 <span class="comment">    DriverNotificationRoutine - Address of routine to invoke when a file system</span>
09440 <span class="comment">        registers or unregisters itself.</span>
09441 <span class="comment"></span>
09442 <span class="comment">Return Value:</span>
09443 <span class="comment"></span>
09444 <span class="comment">    The return status is the final value of the function.</span>
09445 <span class="comment"></span>
09446 <span class="comment">--*/</span>
09447 
09448 {
09449     <a class="code" href="../../d8/d3/struct__NOTIFICATION__PACKET.html">PNOTIFICATION_PACKET</a> nPacket;
09450 
09451     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
09452 
09453     <span class="comment">//</span>
09454     <span class="comment">// Begin by attempting to allocate storage for the shutdown packet.  If</span>
09455     <span class="comment">// one cannot be allocated, simply return an appropriate error.</span>
09456     <span class="comment">//</span>
09457 
09458     nPacket = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>,
09459                                      <span class="keyword">sizeof</span>( <a class="code" href="../../d8/d3/struct__NOTIFICATION__PACKET.html">NOTIFICATION_PACKET</a> ),
09460                                      'sFoI' );
09461     <span class="keywordflow">if</span> (!nPacket) {
09462         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
09463     }
09464 
09465     <span class="comment">//</span>
09466     <span class="comment">// Initialize the notification packet and insert it onto the tail of the</span>
09467     <span class="comment">// list.</span>
09468     <span class="comment">//</span>
09469 
09470     nPacket-&gt;<a class="code" href="../../d8/d3/struct__NOTIFICATION__PACKET.html#o1">DriverObject</a> = DriverObject;
09471     nPacket-&gt;<a class="code" href="../../d8/d3/struct__NOTIFICATION__PACKET.html#o2">NotificationRoutine</a> = DriverNotificationRoutine;
09472 
09473     <a class="code" href="../../d5/d8/ex_8h.html#a70">ExAcquireResourceExclusive</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a4">IopDatabaseResource</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
09474     InsertTailList( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a14">IopFsNotifyChangeQueueHead</a>, &amp;nPacket-&gt;<a class="code" href="../../d8/d3/struct__NOTIFICATION__PACKET.html#o0">ListEntry</a> );
09475     <a class="code" href="../../d5/d8/ex_8h.html#a66">ExReleaseResource</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a4">IopDatabaseResource</a> );
09476 
09477     <span class="comment">//</span>
09478     <span class="comment">// Increment the number of reasons that this driver cannot be unloaded.</span>
09479     <span class="comment">//</span>
09480 
09481     <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a>( DriverObject );
09482 
09483     <span class="keywordflow">return</span> STATUS_SUCCESS;
09484 }
09485 
09486 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l09487"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a99">09487</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a99">IoRegisterLastChanceShutdownNotification</a>(
09488     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject
09489     )
09490 
09491 <span class="comment">/*++</span>
09492 <span class="comment"></span>
09493 <span class="comment">Routine Description:</span>
09494 <span class="comment"></span>
09495 <span class="comment">    This routine allows a driver to register that it would like to have its</span>
09496 <span class="comment">    shutdown routine invoked at very late in system shutdown.  This gives</span>
09497 <span class="comment">    the driver an opportunity to get control just before the system is fully</span>
09498 <span class="comment">    shutdown.</span>
09499 <span class="comment"></span>
09500 <span class="comment">Arguments:</span>
09501 <span class="comment"></span>
09502 <span class="comment">    DeviceObject - Pointer to the driver's device object.</span>
09503 <span class="comment"></span>
09504 <span class="comment">Return Value:</span>
09505 <span class="comment"></span>
09506 <span class="comment">    None.</span>
09507 <span class="comment"></span>
09508 <span class="comment">--*/</span>
09509 
09510 {
09511     <a class="code" href="../../d2/d3/struct__SHUTDOWN__PACKET.html">PSHUTDOWN_PACKET</a> shutdown;
09512 
09513     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
09514 
09515     <span class="comment">//</span>
09516     <span class="comment">// Begin by attempting to allocate storage for the shutdown packet.  If</span>
09517     <span class="comment">// one cannot be allocated, simply return an appropriate error.</span>
09518     <span class="comment">//</span>
09519 
09520     shutdown = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
09521                                       <span class="keyword">sizeof</span>( <a class="code" href="../../d2/d3/struct__SHUTDOWN__PACKET.html">SHUTDOWN_PACKET</a> ),
09522                                       'hSoI' );
09523     <span class="keywordflow">if</span> (!shutdown) {
09524         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
09525     }
09526 
09527     <span class="comment">//</span>
09528     <span class="comment">// Initialize the shutdown packet and insert it onto the head of the list.</span>
09529     <span class="comment">// Note that this is done because some drivers have dependencies on LIFO</span>
09530     <span class="comment">// notification ordering.</span>
09531     <span class="comment">//</span>
09532 
09533     shutdown-&gt;<a class="code" href="../../d2/d3/struct__SHUTDOWN__PACKET.html#o1">DeviceObject</a> = DeviceObject;
09534 
09535     <a class="code" href="../../d5/d8/ex_8h.html#a237">ExInterlockedInsertHeadList</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a13">IopNotifyLastChanceShutdownQueueHead</a>,
09536                                  &amp;shutdown-&gt;<a class="code" href="../../d2/d3/struct__SHUTDOWN__PACKET.html#o0">ListEntry</a>,
09537                                  &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a> );
09538 
09539     <span class="comment">//</span>
09540     <span class="comment">// Do the bookkeeping to indicate that this driver has successfully</span>
09541     <span class="comment">// registered a shutdown notification routine.</span>
09542     <span class="comment">//</span>
09543 
09544     DeviceObject-&gt;Flags |= <a class="code" href="../../d0/d5/io_8h.html#a132">DO_SHUTDOWN_REGISTERED</a>;
09545 
09546     <span class="keywordflow">return</span> STATUS_SUCCESS;
09547 }
09548 
09549 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l09550"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a100">09550</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a100">IoRegisterShutdownNotification</a>(
09551     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject
09552     )
09553 
09554 <span class="comment">/*++</span>
09555 <span class="comment"></span>
09556 <span class="comment">Routine Description:</span>
09557 <span class="comment"></span>
09558 <span class="comment">    This routine allows a driver to register that it would like to have its</span>
09559 <span class="comment">    shutdown routine invoked when the system is being shutdown.  This gives</span>
09560 <span class="comment">    the driver an opportunity to get control just before the system is fully</span>
09561 <span class="comment">    shutdown.</span>
09562 <span class="comment"></span>
09563 <span class="comment">Arguments:</span>
09564 <span class="comment"></span>
09565 <span class="comment">    DeviceObject - Pointer to the driver's device object.</span>
09566 <span class="comment"></span>
09567 <span class="comment">Return Value:</span>
09568 <span class="comment"></span>
09569 <span class="comment">    None.</span>
09570 <span class="comment"></span>
09571 <span class="comment">--*/</span>
09572 
09573 {
09574     <a class="code" href="../../d2/d3/struct__SHUTDOWN__PACKET.html">PSHUTDOWN_PACKET</a> shutdown;
09575 
09576     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
09577 
09578     <span class="comment">//</span>
09579     <span class="comment">// Begin by attempting to allocate storage for the shutdown packet.  If</span>
09580     <span class="comment">// one cannot be allocated, simply return an appropriate error.</span>
09581     <span class="comment">//</span>
09582 
09583     shutdown = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>( <a class="code" href="../../d5/d8/ex_8h.html#a329a173">NonPagedPool</a>,
09584                                       <span class="keyword">sizeof</span>( <a class="code" href="../../d2/d3/struct__SHUTDOWN__PACKET.html">SHUTDOWN_PACKET</a> ),
09585                                       'hSoI' );
09586     <span class="keywordflow">if</span> (!shutdown) {
09587         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
09588     }
09589 
09590     <span class="comment">//</span>
09591     <span class="comment">// Initialize the shutdown packet and insert it onto the head of the list.</span>
09592     <span class="comment">// Note that this is done because some drivers have dependencies on LIFO</span>
09593     <span class="comment">// notification ordering.</span>
09594     <span class="comment">//</span>
09595 
09596     shutdown-&gt;<a class="code" href="../../d2/d3/struct__SHUTDOWN__PACKET.html#o1">DeviceObject</a> = DeviceObject;
09597 
09598     <a class="code" href="../../d5/d8/ex_8h.html#a237">ExInterlockedInsertHeadList</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a12">IopNotifyShutdownQueueHead</a>,
09599                                  &amp;shutdown-&gt;<a class="code" href="../../d2/d3/struct__SHUTDOWN__PACKET.html#o0">ListEntry</a>,
09600                                  &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a> );
09601 
09602     <span class="comment">//</span>
09603     <span class="comment">// Do the bookkeeping to indicate that this driver has successfully</span>
09604     <span class="comment">// registered a shutdown notification routine.</span>
09605     <span class="comment">//</span>
09606 
09607     DeviceObject-&gt;Flags |= <a class="code" href="../../d0/d5/io_8h.html#a132">DO_SHUTDOWN_REGISTERED</a>;
09608 
09609     <span class="keywordflow">return</span> STATUS_SUCCESS;
09610 }
09611 
09612 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l09613"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a101">09613</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a101">IoReleaseCancelSpinLock</a>(
09614     IN KIRQL Irql
09615     )
09616 
09617 <span class="comment">/*++</span>
09618 <span class="comment"></span>
09619 <span class="comment">Routine Description:</span>
09620 <span class="comment"></span>
09621 <span class="comment">    This routine is invoked to release the cancel spin lock.  This spin lock</span>
09622 <span class="comment">    must be acquired before setting the address of a cancel routine in an</span>
09623 <span class="comment">    IRP and released after the cancel routine has been set.</span>
09624 <span class="comment"></span>
09625 <span class="comment">Arguments:</span>
09626 <span class="comment"></span>
09627 <span class="comment">    Irql - Supplies the IRQL value returned from acquiring the spin lock.</span>
09628 <span class="comment"></span>
09629 <span class="comment">Return Value:</span>
09630 <span class="comment"></span>
09631 <span class="comment">    None.</span>
09632 <span class="comment"></span>
09633 <span class="comment">--*/</span>
09634 
09635 {
09636     <span class="comment">//</span>
09637     <span class="comment">// Simply release the cancel spin lock.</span>
09638     <span class="comment">//</span>
09639 
09640     ExReleaseSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a1">IopCancelSpinLock</a>, Irql );
09641 }
09642 
09643 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l09644"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a102">09644</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a102">IoReleaseVpbSpinLock</a>(
09645     IN KIRQL Irql
09646     )
09647 
09648 <span class="comment">/*++</span>
09649 <span class="comment"></span>
09650 <span class="comment">Routine Description:</span>
09651 <span class="comment"></span>
09652 <span class="comment">    This routine is invoked to release the Volume Parameter Block (VPB) spin</span>
09653 <span class="comment">    lock.  This spin lock must be acquired before accessing the mount flag,</span>
09654 <span class="comment">    reference count, and device object fields of a VPB.</span>
09655 <span class="comment"></span>
09656 <span class="comment">Arguments:</span>
09657 <span class="comment"></span>
09658 <span class="comment">    Irql - Supplies the IRQL value returned from acquiring the spin lock.</span>
09659 <span class="comment"></span>
09660 <span class="comment">Return Value:</span>
09661 <span class="comment"></span>
09662 <span class="comment">    None.</span>
09663 <span class="comment"></span>
09664 <span class="comment">--*/</span>
09665 
09666 {
09667     <span class="comment">//</span>
09668     <span class="comment">// Simply release the VPB spin lock.</span>
09669     <span class="comment">//</span>
09670 
09671     ExReleaseSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a2">IopVpbSpinLock</a>, Irql );
09672 }
09673 
09674 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l09675"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a103">09675</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a103">IoRemoveShareAccess</a>(
09676     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
09677     IN OUT <a class="code" href="../../d9/d2/struct__SHARE__ACCESS.html">PSHARE_ACCESS</a> ShareAccess
09678     )
09679 
09680 <span class="comment">/*++</span>
09681 <span class="comment"></span>
09682 <span class="comment">Routine Description:</span>
09683 <span class="comment"></span>
09684 <span class="comment">    This routine is invoked to remove the access and share access information</span>
09685 <span class="comment">    in a file system Share Access structure for a given open instance.</span>
09686 <span class="comment"></span>
09687 <span class="comment">Arguments:</span>
09688 <span class="comment"></span>
09689 <span class="comment">    FileObject - Pointer to the file object of the current access being closed.</span>
09690 <span class="comment"></span>
09691 <span class="comment">    ShareAccess - Pointer to the share access structure that describes</span>
09692 <span class="comment">         how the file is currently being accessed.</span>
09693 <span class="comment"></span>
09694 <span class="comment">Return Value:</span>
09695 <span class="comment"></span>
09696 <span class="comment">    None.</span>
09697 <span class="comment"></span>
09698 <span class="comment">--*/</span>
09699 
09700 {
09701     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
09702 
09703     <span class="comment">//</span>
09704     <span class="comment">// If this accessor wanted some type of access other than READ_ or</span>
09705     <span class="comment">// WRITE_ATTRIBUTES, then account for the fact that he has closed the</span>
09706     <span class="comment">// file.  Otherwise, he hasn't been accounted for in the first place</span>
09707     <span class="comment">// so don't do anything.</span>
09708     <span class="comment">//</span>
09709 
09710     <span class="keywordflow">if</span> (FileObject-&gt;ReadAccess ||
09711         FileObject-&gt;WriteAccess ||
09712         FileObject-&gt;DeleteAccess) {
09713 
09714         <span class="comment">//</span>
09715         <span class="comment">// Decrement the number of opens in the Share Access structure.</span>
09716         <span class="comment">//</span>
09717 
09718         ShareAccess-&gt;OpenCount--;
09719 
09720         <span class="comment">//</span>
09721         <span class="comment">// For each access type, decrement the appropriate count in the Share</span>
09722         <span class="comment">// Access structure.</span>
09723         <span class="comment">//</span>
09724 
09725         <span class="keywordflow">if</span> (FileObject-&gt;ReadAccess) {
09726             ShareAccess-&gt;Readers--;
09727         }
09728 
09729         <span class="keywordflow">if</span> (FileObject-&gt;WriteAccess) {
09730             ShareAccess-&gt;Writers--;
09731         }
09732 
09733         <span class="keywordflow">if</span> (FileObject-&gt;DeleteAccess) {
09734             ShareAccess-&gt;Deleters--;
09735         }
09736 
09737         <span class="comment">//</span>
09738         <span class="comment">// For each shared access type, decrement the appropriate count in the</span>
09739         <span class="comment">// Share Access structure.</span>
09740         <span class="comment">//</span>
09741 
09742         <span class="keywordflow">if</span> (FileObject-&gt;SharedRead) {
09743             ShareAccess-&gt;SharedRead--;
09744         }
09745 
09746         <span class="keywordflow">if</span> (FileObject-&gt;SharedWrite) {
09747             ShareAccess-&gt;SharedWrite--;
09748         }
09749 
09750         <span class="keywordflow">if</span> (FileObject-&gt;SharedDelete) {
09751             ShareAccess-&gt;SharedDelete--;
09752         }
09753     }
09754 }
09755 
09756 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l09757"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a104">09757</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a104">IoSetDeviceToVerify</a>(
09758     IN <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a> Thread,
09759     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject
09760     )
09761 
09762 <span class="comment">/*++</span>
09763 <span class="comment"></span>
09764 <span class="comment">Routine Description:</span>
09765 <span class="comment"></span>
09766 <span class="comment">    This routine sets the device to verify field in the thread object.  This</span>
09767 <span class="comment">    function is invoked by file systems to NULL this field, or to set it to</span>
09768 <span class="comment">    predefined values.</span>
09769 <span class="comment"></span>
09770 <span class="comment">Arguments:</span>
09771 <span class="comment"></span>
09772 <span class="comment">    Thread - Pointer to the thread whose field is to be set.</span>
09773 <span class="comment"></span>
09774 <span class="comment">    DeviceObject - Pointer to the device to be verified, or NULL, or ...</span>
09775 <span class="comment"></span>
09776 <span class="comment">Return Value:</span>
09777 <span class="comment"></span>
09778 <span class="comment">    None.</span>
09779 <span class="comment"></span>
09780 <span class="comment">Note:</span>
09781 <span class="comment"></span>
09782 <span class="comment">    This function cannot be made a macro, since fields in the thread object</span>
09783 <span class="comment">    move from release to release, so this must remain a full function.</span>
09784 <span class="comment"></span>
09785 <span class="comment">--*/</span>
09786 
09787 {
09788     <span class="comment">//</span>
09789     <span class="comment">// Simply set the device to be verified in the specified thread.</span>
09790     <span class="comment">//</span>
09791 
09792     Thread-&gt;DeviceToVerify = DeviceObject;
09793 }
09794 
09795 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l09796"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a105">09796</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a105">IoSetHardErrorOrVerifyDevice</a>(
09797     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
09798     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject
09799     )
09800 
09801 <span class="comment">/*++</span>
09802 <span class="comment"></span>
09803 <span class="comment">Routine Description:</span>
09804 <span class="comment"></span>
09805 <span class="comment">    This routine is invoked when a driver realizes that the media</span>
09806 <span class="comment">    has possibly changed on a device, and it must be verified before</span>
09807 <span class="comment">    continuing, or a hard error has occured.  The device is stored</span>
09808 <span class="comment">    in the thread local storage of the Irp's originating thread.</span>
09809 <span class="comment"></span>
09810 <span class="comment">Arguments:</span>
09811 <span class="comment"></span>
09812 <span class="comment">    Irp - Pointer to an I/O Request Packet to get the thread.</span>
09813 <span class="comment"></span>
09814 <span class="comment">    DeviceObject - This is the device that needs to be verified.</span>
09815 <span class="comment"></span>
09816 <span class="comment">Return Value:</span>
09817 <span class="comment"></span>
09818 <span class="comment">    None.</span>
09819 <span class="comment"></span>
09820 <span class="comment">--*/</span>
09821 
09822 {
09823     <span class="comment">//</span>
09824     <span class="comment">// Store the address of the device object that needs verification in</span>
09825     <span class="comment">// the appropriate field of the thread pointed to by the specified I/O</span>
09826     <span class="comment">// Request Packet.</span>
09827     <span class="comment">//</span>
09828 
09829     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
09830 
09831     <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread-&gt;DeviceToVerify = DeviceObject;
09832 }
09833 
09834 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l09835"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a106">09835</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a106">IoSetInformation</a>(
09836     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
09837     IN FILE_INFORMATION_CLASS FileInformationClass,
09838     IN ULONG Length,
09839     IN PVOID FileInformation
09840     )
09841 
09842 <span class="comment">/*++</span>
09843 <span class="comment"></span>
09844 <span class="comment">Routine Description:</span>
09845 <span class="comment"></span>
09846 <span class="comment">    This routine sets the requested information for the specified file.</span>
09847 <span class="comment">    The information that is set is determined by the FileInformationClass</span>
09848 <span class="comment">    paramter, and the information itself is passed in the FileInformation</span>
09849 <span class="comment">    buffer.</span>
09850 <span class="comment"></span>
09851 <span class="comment">Arguments:</span>
09852 <span class="comment"></span>
09853 <span class="comment">    FileObject - Supplies a pointer to the file object for the file that</span>
09854 <span class="comment">        is to be changed.</span>
09855 <span class="comment"></span>
09856 <span class="comment">    FileInformationClass - Specifies the type of information that should</span>
09857 <span class="comment">        be set on the file.</span>
09858 <span class="comment"></span>
09859 <span class="comment">    Length - Supplies the length of the FileInformation buffer in bytes.</span>
09860 <span class="comment"></span>
09861 <span class="comment">    FileInformation - A buffer containing the file information to set.  This</span>
09862 <span class="comment">        buffer must not be pageable and must reside in system space.</span>
09863 <span class="comment"></span>
09864 <span class="comment">Return Value:</span>
09865 <span class="comment"></span>
09866 <span class="comment">    The status returned is the final completion status of the operation.</span>
09867 <span class="comment"></span>
09868 <span class="comment"></span>
09869 <span class="comment">--*/</span>
09870 
09871 {
09872     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
09873     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
09874     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
09875     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> event;
09876     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
09877     IO_STATUS_BLOCK localIoStatus;
09878     HANDLE targetHandle = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
09879     BOOLEAN synchronousIo;
09880 
09881     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
09882 
09883     <span class="comment">//</span>
09884     <span class="comment">// Reference the file object here so that no special checks need be made</span>
09885     <span class="comment">// in I/O completion to determine whether or not to dereference the file</span>
09886     <span class="comment">// object.</span>
09887     <span class="comment">//</span>
09888 
09889     <a class="code" href="../../d4/d0/ob_8h.html#a15">ObReferenceObject</a>( FileObject );
09890 
09891     <span class="comment">//</span>
09892     <span class="comment">// Make a special check here to determine whether this is a synchronous</span>
09893     <span class="comment">// I/O operation.  If it is, then wait here until the file is owned by</span>
09894     <span class="comment">// the current thread.  If this is not a (serialized) synchronous I/O</span>
09895     <span class="comment">// operation, then initialize the local event.</span>
09896     <span class="comment">//</span>
09897 
09898     <span class="keywordflow">if</span> (FileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>) {
09899 
09900         BOOLEAN interrupted;
09901 
09902         <span class="keywordflow">if</span> (!<a class="code" href="../../d0/d6/iop_8h.html#a13">IopAcquireFastLock</a>( FileObject )) {
09903             status = <a class="code" href="../../d0/d6/iop_8h.html#a147">IopAcquireFileObjectLock</a>( FileObject,
09904                                                <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
09905                                                (BOOLEAN) ((FileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a152">FO_ALERTABLE_IO</a>) != 0),
09906                                                &amp;interrupted );
09907             <span class="keywordflow">if</span> (interrupted) {
09908                 <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( FileObject );
09909                 <span class="keywordflow">return</span> status;
09910             }
09911         }
09912         <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a>( &amp;FileObject-&gt;Event );
09913         synchronousIo = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
09914     } <span class="keywordflow">else</span> {
09915         <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;event, SynchronizationEvent, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
09916         synchronousIo = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
09917     }
09918 
09919     <span class="comment">//</span>
09920     <span class="comment">// Get the address of the target device object.</span>
09921     <span class="comment">//</span>
09922 
09923     deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( FileObject );
09924 
09925     <span class="comment">//</span>
09926     <span class="comment">// Allocate and initialize the I/O Request Packet (IRP) for this operation.</span>
09927     <span class="comment">// The allocation is performed with an exception handler in case there is</span>
09928     <span class="comment">// not enough memory to satisfy the request.</span>
09929     <span class="comment">//</span>
09930 
09931     irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a17">IoAllocateIrp</a>( deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o13">StackSize</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
09932     <span class="keywordflow">if</span> (!irp) {
09933 
09934         <span class="comment">//</span>
09935         <span class="comment">// An IRP could not be allocated.  Cleanup and return an appropriate</span>
09936         <span class="comment">// error status code.</span>
09937         <span class="comment">//</span>
09938 
09939         <a class="code" href="../../d0/d6/iop_8h.html#a148">IopAllocateIrpCleanup</a>( FileObject, (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
09940 
09941         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
09942     }
09943     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.OriginalFileObject = FileObject;
09944     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
09945     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o10">RequestorMode</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>;
09946 
09947     <span class="comment">//</span>
09948     <span class="comment">// Fill in the service independent parameters in the IRP.</span>
09949     <span class="comment">//</span>
09950 
09951     <span class="keywordflow">if</span> (synchronousIo) {
09952         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = (<a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
09953     } <span class="keywordflow">else</span> {
09954         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = &amp;event;
09955         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a176">IRP_SYNCHRONOUS_API</a>;
09956     }
09957     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = &amp;localIoStatus;
09958 
09959     <span class="comment">//</span>
09960     <span class="comment">// Get a pointer to the stack location for the first driver.  This will be</span>
09961     <span class="comment">// used to pass the original function codes and parameters.</span>
09962     <span class="comment">//</span>
09963 
09964     irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
09965     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a19">IRP_MJ_SET_INFORMATION</a>;
09966     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> = FileObject;
09967 
09968     <span class="comment">//</span>
09969     <span class="comment">// Set the system buffer address to the address of the caller's buffer and</span>
09970     <span class="comment">// set the flags so that the buffer is not deallocated.</span>
09971     <span class="comment">//</span>
09972 
09973     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer = FileInformation;
09974     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> |= <a class="code" href="../../d0/d5/io_8h.html#a178">IRP_BUFFERED_IO</a>;
09975 
09976     <span class="comment">//</span>
09977     <span class="comment">// Copy the caller's parameters to the service-specific portion of the IRP.</span>
09978     <span class="comment">//</span>
09979 
09980     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.SetFile.Length = Length;
09981     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.SetFile.FileInformationClass = FileInformationClass;
09982 
09983     <span class="comment">//</span>
09984     <span class="comment">// Insert the packet at the head of the IRP list for the thread.</span>
09985     <span class="comment">//</span>
09986 
09987     <a class="code" href="../../d0/d6/iop_8h.html#a21">IopQueueThreadIrp</a>( irp );
09988 
09989     <span class="comment">//</span>
09990     <span class="comment">// Everything is now set to invoke the device driver with this request.</span>
09991     <span class="comment">// However, it is possible that the information that the caller wants to</span>
09992     <span class="comment">// set is device independent (I/O system dependent).  If this is the case,</span>
09993     <span class="comment">// then the request can be satisfied here without having to have all of</span>
09994     <span class="comment">// the drivers implement the same code.  Note that having the IRP is still</span>
09995     <span class="comment">// necessary since the I/O completion code requires it.</span>
09996     <span class="comment">//</span>
09997 
09998     <span class="keywordflow">if</span> (FileInformationClass == FileModeInformation) {
09999 
10000         PFILE_MODE_INFORMATION modeBuffer = FileInformation;
10001 
10002         <span class="comment">//</span>
10003         <span class="comment">// Set or clear the appropriate flags in the file object.</span>
10004         <span class="comment">//</span>
10005 
10006         <span class="keywordflow">if</span> (!(FileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a153">FO_NO_INTERMEDIATE_BUFFERING</a>)) {
10007             <span class="keywordflow">if</span> (modeBuffer-&gt;Mode &amp; FILE_WRITE_THROUGH) {
10008                 FileObject-&gt;Flags |= <a class="code" href="../../d0/d5/io_8h.html#a154">FO_WRITE_THROUGH</a>;
10009             } <span class="keywordflow">else</span> {
10010                 FileObject-&gt;Flags &amp;= ~<a class="code" href="../../d0/d5/io_8h.html#a154">FO_WRITE_THROUGH</a>;
10011             }
10012         }
10013 
10014         <span class="keywordflow">if</span> (modeBuffer-&gt;Mode &amp; FILE_SEQUENTIAL_ONLY) {
10015             FileObject-&gt;Flags |= <a class="code" href="../../d0/d5/io_8h.html#a155">FO_SEQUENTIAL_ONLY</a>;
10016         } <span class="keywordflow">else</span> {
10017             FileObject-&gt;Flags &amp;= ~<a class="code" href="../../d0/d5/io_8h.html#a155">FO_SEQUENTIAL_ONLY</a>;
10018         }
10019 
10020         <span class="keywordflow">if</span> (modeBuffer-&gt;Mode &amp; <a class="code" href="../../d0/d5/io_8h.html#a151">FO_SYNCHRONOUS_IO</a>) {
10021             <span class="keywordflow">if</span> (modeBuffer-&gt;Mode &amp; FILE_SYNCHRONOUS_IO_ALERT) {
10022                 FileObject-&gt;Flags |= <a class="code" href="../../d0/d5/io_8h.html#a152">FO_ALERTABLE_IO</a>;
10023             } <span class="keywordflow">else</span> {
10024                 FileObject-&gt;Flags &amp;= ~<a class="code" href="../../d0/d5/io_8h.html#a152">FO_ALERTABLE_IO</a>;
10025             }
10026         }
10027 
10028         status = STATUS_SUCCESS;
10029 
10030         <span class="comment">//</span>
10031         <span class="comment">// Complete the I/O operation.</span>
10032         <span class="comment">//</span>
10033 
10034         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Status = status;
10035         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>.Information = 0;
10036 
10037         <a class="code" href="../../d0/d5/io_8h.html#a238">IoSetNextIrpStackLocation</a>( irp );
10038         <a class="code" href="../../d0/d5/io_8h.html#a224">IoCompleteRequest</a>( irp, 0 );
10039 
10040     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (FileInformationClass == FileRenameInformation ||
10041                FileInformationClass == FileLinkInformation ||
10042                FileInformationClass == FileMoveClusterInformation) {
10043 
10044         <span class="comment">//</span>
10045         <span class="comment">// Note that the following code assumes that a rename information</span>
10046         <span class="comment">// and a set link information structure look exactly the same.</span>
10047         <span class="comment">//</span>
10048 
10049         PFILE_RENAME_INFORMATION renameBuffer = FileInformation;
10050 
10051         <span class="comment">//</span>
10052         <span class="comment">// Copy the value of the replace BOOLEAN (or the ClusterCount field)</span>
10053         <span class="comment">// from the caller's buffer to the I/O stack location parameter</span>
10054         <span class="comment">// field where it is expected by file systems.</span>
10055         <span class="comment">//</span>
10056 
10057         <span class="keywordflow">if</span> (FileInformationClass == FileMoveClusterInformation) {
10058             irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.SetFile.ClusterCount =
10059                 ((FILE_MOVE_CLUSTER_INFORMATION *) renameBuffer)-&gt;ClusterCount;
10060         } <span class="keywordflow">else</span> {
10061             irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.SetFile.ReplaceIfExists = renameBuffer-&gt;ReplaceIfExists;
10062         }
10063 
10064         <span class="comment">//</span>
10065         <span class="comment">// Check to see whether or not a fully qualified pathname was supplied.</span>
10066         <span class="comment">// If so, then more processing is required.</span>
10067         <span class="comment">//</span>
10068 
10069         <span class="keywordflow">if</span> (renameBuffer-&gt;FileName[0] == (UCHAR) OBJ_NAME_PATH_SEPARATOR ||
10070             renameBuffer-&gt;RootDirectory != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
10071 
10072             <span class="comment">//</span>
10073             <span class="comment">// A fully qualified file name was specified as the target of the</span>
10074             <span class="comment">// rename operation.  Attempt to open the target file and ensure</span>
10075             <span class="comment">// that the replacement policy for the file is consistent with the</span>
10076             <span class="comment">// caller's request, and ensure that the file is on the same volume.</span>
10077             <span class="comment">//</span>
10078 
10079             status = <a class="code" href="../../d0/d6/iop_8h.html#a197">IopOpenLinkOrRenameTarget</a>( &amp;targetHandle,
10080                                                 irp,
10081                                                 renameBuffer,
10082                                                 FileObject );
10083             <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
10084                 <a class="code" href="../../d0/d5/io_8h.html#a238">IoSetNextIrpStackLocation</a>( irp );
10085                 <a class="code" href="../../d0/d5/io_8h.html#a224">IoCompleteRequest</a>( irp, 2 );
10086 
10087             } <span class="keywordflow">else</span> {
10088 
10089                 <span class="comment">//</span>
10090                 <span class="comment">// The fully qualified file name specifies a file on the same</span>
10091                 <span class="comment">// volume and if it exists, then the caller specified that it</span>
10092                 <span class="comment">// should be replaced.</span>
10093                 <span class="comment">//</span>
10094 
10095                 status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( deviceObject, irp );
10096 
10097             }
10098 
10099         } <span class="keywordflow">else</span> {
10100 
10101             <span class="comment">//</span>
10102             <span class="comment">// This is a simple rename operation, so call the driver and let</span>
10103             <span class="comment">// it perform the rename operation within the same directory as</span>
10104             <span class="comment">// the source file.</span>
10105             <span class="comment">//</span>
10106 
10107             status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( deviceObject, irp );
10108 
10109         }
10110 
10111     } <span class="keywordflow">else</span> {
10112 
10113         <span class="comment">//</span>
10114         <span class="comment">// This is not a request that can be performed here, so invoke the</span>
10115         <span class="comment">// driver at its appropriate dispatch entry with the IRP.</span>
10116         <span class="comment">//</span>
10117 
10118         status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( deviceObject, irp );
10119 
10120     }
10121 
10122     <span class="comment">//</span>
10123     <span class="comment">// If this operation was a synchronous I/O operation, check the return</span>
10124     <span class="comment">// status to determine whether or not to wait on the file object.  If</span>
10125     <span class="comment">// the file object is to be waited on, wait for the operation to complete</span>
10126     <span class="comment">// and obtain the final status from the file object itself.</span>
10127     <span class="comment">//</span>
10128 
10129     <span class="keywordflow">if</span> (synchronousIo) {
10130         <span class="keywordflow">if</span> (status == STATUS_PENDING) {
10131             status = <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;FileObject-&gt;Event,
10132                                             <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
10133                                             <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
10134                                             (BOOLEAN) ((FileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a152">FO_ALERTABLE_IO</a>) != 0),
10135                                             (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
10136             <span class="keywordflow">if</span> (status == STATUS_ALERTED) {
10137                 <a class="code" href="../../d0/d6/iop_8h.html#a151">IopCancelAlertedRequest</a>( &amp;FileObject-&gt;Event, irp );
10138             }
10139             status = localIoStatus.Status;
10140         }
10141         <a class="code" href="../../d0/d6/iop_8h.html#a22">IopReleaseFileObjectLock</a>( FileObject );
10142 
10143     } <span class="keywordflow">else</span> {
10144 
10145         <span class="comment">//</span>
10146         <span class="comment">// This is a normal synchronous I/O operation, as opposed to a</span>
10147         <span class="comment">// serialized synchronous I/O operation.  For this case, wait for</span>
10148         <span class="comment">// the local event and copy the final status information back to</span>
10149         <span class="comment">// the caller.</span>
10150         <span class="comment">//</span>
10151 
10152         <span class="keywordflow">if</span> (status == STATUS_PENDING) {
10153             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
10154                                           <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
10155                                           <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
10156                                           <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
10157                                           (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
10158             status = localIoStatus.Status;
10159         }
10160     }
10161 
10162     <span class="comment">//</span>
10163     <span class="comment">// If a target handle was created because of a rename operation, close</span>
10164     <span class="comment">// the handle now.</span>
10165     <span class="comment">//</span>
10166 
10167     <span class="keywordflow">if</span> (targetHandle != (HANDLE) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
10168         <a class="code" href="../../d5/d0/obclose_8c.html#a1">NtClose</a>( targetHandle );
10169     }
10170 
10171     <span class="keywordflow">return</span> status;
10172 }
10173 
10174 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l10175"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a107">10175</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a107">IoSetShareAccess</a>(
10176     IN ACCESS_MASK DesiredAccess,
10177     IN ULONG DesiredShareAccess,
10178     IN OUT <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
10179     OUT <a class="code" href="../../d9/d2/struct__SHARE__ACCESS.html">PSHARE_ACCESS</a> ShareAccess
10180     )
10181 
10182 <span class="comment">/*++</span>
10183 <span class="comment"></span>
10184 <span class="comment">Routine Description:</span>
10185 <span class="comment"></span>
10186 <span class="comment">    This routine is invoked to set the access and share access information</span>
10187 <span class="comment">    in a file system Share Access structure for the first open.</span>
10188 <span class="comment"></span>
10189 <span class="comment">Arguments:</span>
10190 <span class="comment"></span>
10191 <span class="comment">    DesiredAccess - Desired access of current open request.</span>
10192 <span class="comment"></span>
10193 <span class="comment">    DesiredShareAccess - Shared access requested by current open request.</span>
10194 <span class="comment"></span>
10195 <span class="comment">    FileObject - Pointer to the file object of the current open request.</span>
10196 <span class="comment"></span>
10197 <span class="comment">    ShareAccess - Pointer to the share access structure that describes</span>
10198 <span class="comment">         how the file is currently being accessed.</span>
10199 <span class="comment"></span>
10200 <span class="comment">Return Value:</span>
10201 <span class="comment"></span>
10202 <span class="comment">    None.</span>
10203 <span class="comment"></span>
10204 <span class="comment">--*/</span>
10205 
10206 {
10207     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
10208 
10209     <span class="comment">//</span>
10210     <span class="comment">// Set the access type in the file object for the current accessor.</span>
10211     <span class="comment">//</span>
10212 
10213     FileObject-&gt;ReadAccess = (BOOLEAN) ((DesiredAccess &amp; (FILE_EXECUTE
10214         | FILE_READ_DATA)) != 0);
10215     FileObject-&gt;WriteAccess = (BOOLEAN) ((DesiredAccess &amp; (FILE_WRITE_DATA
10216         | FILE_APPEND_DATA)) != 0);
10217     FileObject-&gt;DeleteAccess = (BOOLEAN) ((DesiredAccess &amp; DELETE) != 0);
10218 
10219     <span class="comment">//</span>
10220     <span class="comment">// Check to see whether the current file opener would like to read,</span>
10221     <span class="comment">// write, or delete the file.  If so, account for it in the share access</span>
10222     <span class="comment">// structure; otherwise, skip it.</span>
10223     <span class="comment">//</span>
10224 
10225     <span class="keywordflow">if</span> (FileObject-&gt;ReadAccess ||
10226         FileObject-&gt;WriteAccess ||
10227         FileObject-&gt;DeleteAccess) {
10228 
10229         <span class="comment">//</span>
10230         <span class="comment">// Only update the share modes if the user wants to read, write or</span>
10231         <span class="comment">// delete the file.</span>
10232         <span class="comment">//</span>
10233 
10234         FileObject-&gt;SharedRead = (BOOLEAN) ((DesiredShareAccess &amp; FILE_SHARE_READ) != 0);
10235         FileObject-&gt;SharedWrite = (BOOLEAN) ((DesiredShareAccess &amp; FILE_SHARE_WRITE) != 0);
10236         FileObject-&gt;SharedDelete = (BOOLEAN) ((DesiredShareAccess &amp; FILE_SHARE_DELETE) != 0);
10237 
10238         <span class="comment">//</span>
10239         <span class="comment">// Set the Share Access structure open count.</span>
10240         <span class="comment">//</span>
10241 
10242         ShareAccess-&gt;OpenCount = 1;
10243 
10244         <span class="comment">//</span>
10245         <span class="comment">// Set the number of readers, writers, and deleters in the Share Access</span>
10246         <span class="comment">// structure.</span>
10247         <span class="comment">//</span>
10248 
10249         ShareAccess-&gt;Readers = FileObject-&gt;ReadAccess;
10250         ShareAccess-&gt;Writers = FileObject-&gt;WriteAccess;
10251         ShareAccess-&gt;Deleters = FileObject-&gt;DeleteAccess;
10252 
10253         <span class="comment">//</span>
10254         <span class="comment">// Set the number of shared readers, writers, and deleters in the Share</span>
10255         <span class="comment">// Access structure.</span>
10256         <span class="comment">//</span>
10257 
10258         ShareAccess-&gt;SharedRead = FileObject-&gt;SharedRead;
10259         ShareAccess-&gt;SharedWrite = FileObject-&gt;SharedWrite;
10260         ShareAccess-&gt;SharedDelete = FileObject-&gt;SharedDelete;
10261 
10262     } <span class="keywordflow">else</span> {
10263 
10264         <span class="comment">//</span>
10265         <span class="comment">// No read, write, or delete access has been requested.  Simply zero</span>
10266         <span class="comment">// the appropriate fields in the structure so that the next accessor</span>
10267         <span class="comment">// sees a consistent state.</span>
10268         <span class="comment">//</span>
10269 
10270         ShareAccess-&gt;OpenCount = 0;
10271         ShareAccess-&gt;Readers = 0;
10272         ShareAccess-&gt;Writers = 0;
10273         ShareAccess-&gt;Deleters = 0;
10274         ShareAccess-&gt;SharedRead = 0;
10275         ShareAccess-&gt;SharedWrite = 0;
10276         ShareAccess-&gt;SharedDelete = 0;
10277     }
10278 }
10279 
10280 BOOLEAN
<a name="l10281"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a108">10281</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a108">IoSetThreadHardErrorMode</a>(
10282     IN BOOLEAN EnableHardErrors
10283     )
10284 
10285 <span class="comment">/*++</span>
10286 <span class="comment"></span>
10287 <span class="comment">Routine Description:</span>
10288 <span class="comment"></span>
10289 <span class="comment">    This routine either enables or disables hard errors for the current</span>
10290 <span class="comment">    thread and returns the old state of the flag.</span>
10291 <span class="comment"></span>
10292 <span class="comment">Arguments:</span>
10293 <span class="comment"></span>
10294 <span class="comment">    EnableHardErrors - Supplies a BOOLEAN value indicating whether or not</span>
10295 <span class="comment">        hard errors are to be enabled for the current thread.</span>
10296 <span class="comment"></span>
10297 <span class="comment">Return Value:</span>
10298 <span class="comment"></span>
10299 <span class="comment">    The final function value is the previous state of whether or not hard</span>
10300 <span class="comment">    errors were enabled.</span>
10301 <span class="comment"></span>
10302 <span class="comment">--*/</span>
10303 
10304 {
10305     <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a> thread;
10306     BOOLEAN oldFlag;
10307 
10308     <span class="comment">//</span>
10309     <span class="comment">// Get a pointer to the current thread, capture the current state of</span>
10310     <span class="comment">// hard errors, and set the new state.</span>
10311     <span class="comment">//</span>
10312 
10313     thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
10314     oldFlag = !thread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o33">HardErrorsAreDisabled</a>;
10315     thread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o33">HardErrorsAreDisabled</a> = !EnableHardErrors;
10316 
10317     <span class="keywordflow">return</span> oldFlag;
10318 }
10319 
10320 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l10321"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a109">10321</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a109">IoSetTopLevelIrp</a>(
10322     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
10323     )
10324 
10325 <span class="comment">/*++</span>
10326 <span class="comment"></span>
10327 <span class="comment">Routine Description:</span>
10328 <span class="comment"></span>
10329 <span class="comment">    This routine sets the top level IRP field in the current thread's thread</span>
10330 <span class="comment">    object.  This function is invoked by file systems to either set this field</span>
10331 <span class="comment">    to the address of an I/O Request Packet (IRP) or to null it.</span>
10332 <span class="comment"></span>
10333 <span class="comment">Arguments:</span>
10334 <span class="comment"></span>
10335 <span class="comment">    Irp - Pointer to the IRP to be stored in the top level IRP field.</span>
10336 <span class="comment"></span>
10337 <span class="comment">Return Value:</span>
10338 <span class="comment"></span>
10339 <span class="comment">    None.</span>
10340 <span class="comment"></span>
10341 <span class="comment">Note:</span>
10342 <span class="comment"></span>
10343 <span class="comment">    This function cannot be made a macro, since fields in the thread object</span>
10344 <span class="comment">    move from release to release, so this must remain a full function.</span>
10345 <span class="comment"></span>
10346 <span class="comment">--*/</span>
10347 
10348 {
10349     <span class="comment">//</span>
10350     <span class="comment">// Simply set the top level IRP field in the current thread's thread</span>
10351     <span class="comment">// object.</span>
10352     <span class="comment">//</span>
10353 
10354     (<a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>) (<a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>())-&gt;TopLevelIrp = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>;
10355     <span class="keywordflow">return</span>;
10356 }
10357 
10358 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l10359"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a110">10359</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a110">IoShutdownSystem</a> (
10360     IN ULONG Phase
10361     )
10362 
10363 <span class="comment">/*++</span>
10364 <span class="comment"></span>
10365 <span class="comment">Routine Description:</span>
10366 <span class="comment"></span>
10367 <span class="comment">    This routine shuts down the I/O portion of the system in preparation</span>
10368 <span class="comment">    for a power-off or reboot.</span>
10369 <span class="comment"></span>
10370 <span class="comment">Arguments:</span>
10371 <span class="comment"></span>
10372 <span class="comment">    RebootPending - Indicates whether a reboot is imminently pending.</span>
10373 <span class="comment"></span>
10374 <span class="comment">    Phase - Indicates which phase of shutdown is being performed.</span>
10375 <span class="comment"></span>
10376 <span class="comment">Return Value:</span>
10377 <span class="comment"></span>
10378 <span class="comment">    None</span>
10379 <span class="comment"></span>
10380 <span class="comment">--*/</span>
10381 
10382 {
10383     PLIST_ENTRY entry;
10384     <a class="code" href="../../d2/d3/struct__SHUTDOWN__PACKET.html">PSHUTDOWN_PACKET</a> shutdown;
10385     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
10386     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
10387     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> event;
10388     IO_STATUS_BLOCK ioStatus;
10389     PVOID unlockHandle;
10390 
10391     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
10392 
10393     <span class="comment">//</span>
10394     <span class="comment">// Initialize the event used to synchronize the complete of all of the</span>
10395     <span class="comment">// shutdown routines.</span>
10396     <span class="comment">//</span>
10397 
10398     <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;event, NotificationEvent, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
10399 
10400     <span class="keywordflow">if</span> (Phase == 0) {
10401 
10402         <span class="comment">//</span>
10403         <span class="comment">// Walk the list of the drivers in the system that have registered</span>
10404         <span class="comment">// themselves as wanting to know when the system is about to be</span>
10405         <span class="comment">// shutdown and invoke each.</span>
10406         <span class="comment">//</span>
10407 
10408         <span class="keywordflow">while</span> ((entry = <a class="code" href="../../d5/d8/ex_8h.html#a239">ExInterlockedRemoveHeadList</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a12">IopNotifyShutdownQueueHead</a>, &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a> )) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
10409             shutdown = CONTAINING_RECORD( entry, <a class="code" href="../../d2/d3/struct__SHUTDOWN__PACKET.html">SHUTDOWN_PACKET</a>, ListEntry );
10410 
10411             <span class="comment">//</span>
10412             <span class="comment">// Another driver has been found that has indicated that it requires</span>
10413             <span class="comment">// shutdown notification.  Invoke the driver's shutdown entry point.</span>
10414             <span class="comment">//</span>
10415 
10416             deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a66">IoGetAttachedDevice</a>( shutdown-&gt;<a class="code" href="../../d2/d3/struct__SHUTDOWN__PACKET.html#o1">DeviceObject</a> );
10417 
10418             irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a27">IoBuildSynchronousFsdRequest</a>( <a class="code" href="../../d0/d5/io_8h.html#a29">IRP_MJ_SHUTDOWN</a>,
10419                                                 deviceObject,
10420                                                 (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
10421                                                 0,
10422                                                 (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
10423                                                 &amp;event,
10424                                                 &amp;ioStatus );
10425 
10426             <span class="keywordflow">if</span> (<a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( deviceObject, irp ) == STATUS_PENDING) {
10427 <span class="preprocessor">#if DBG</span>
10428 <span class="preprocessor"></span>                PUNICODE_STRING DeviceName = ObGetObjectName( shutdown-&gt;<a class="code" href="../../d2/d3/struct__SHUTDOWN__PACKET.html#o1">DeviceObject</a> );
10429 
10430                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( <span class="stringliteral">"IO: Waiting for shutdown of device object (%x) - %wZ\n"</span>,
10431                           shutdown-&gt;<a class="code" href="../../d2/d3/struct__SHUTDOWN__PACKET.html#o1">DeviceObject</a>,
10432                           DeviceName
10433                         );
10434 <span class="preprocessor">#endif // DBG</span>
10435 <span class="preprocessor"></span>                (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
10436                                               <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
10437                                               <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
10438                                               <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
10439                                               (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
10440             }
10441 
10442             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( shutdown );
10443             <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a>( &amp;event );
10444         }
10445 
10446     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Phase == 1) {
10447 
10448 <span class="preprocessor">#if defined(REMOTE_BOOT)</span>
10449 <span class="preprocessor"></span>        <span class="comment">//</span>
10450         <span class="comment">// If this is a remote boot client then allow the cache to close the database and</span>
10451         <span class="comment">// mark it clean.</span>
10452         <span class="comment">//</span>
10453 
10454         IopShutdownCsc();
10455 <span class="preprocessor">#endif // defined(REMOTE_BOOT)</span>
10456 <span class="preprocessor"></span>
10457         <span class="comment">// Gain access to the file system header queues by acquiring the</span>
10458         <span class="comment">// database resource for shared access.</span>
10459         <span class="comment">//</span>
10460 
10461         <a class="code" href="../../d5/d8/ex_8h.html#a69">ExAcquireResourceShared</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a4">IopDatabaseResource</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
10462 
10463         <span class="comment">//</span>
10464         <span class="comment">// Loop through each of the disk file systems, invoking each to shutdown</span>
10465         <span class="comment">// each of their mounted volumes.</span>
10466         <span class="comment">//</span>
10467 
10468         <span class="keywordflow">for</span> (entry = <a class="code" href="../../d3/d5/iodata_8c.html#a6">IopDiskFileSystemQueueHead</a>.Flink;
10469              entry != &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a6">IopDiskFileSystemQueueHead</a>;
10470              entry = entry-&gt;Flink) {
10471 
10472             deviceObject = CONTAINING_RECORD( entry, <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">DEVICE_OBJECT</a>, Queue.ListEntry );
10473             <span class="keywordflow">if</span> (deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o5">AttachedDevice</a>) {
10474                 deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a66">IoGetAttachedDevice</a>( deviceObject );
10475             }
10476 
10477             <span class="comment">//</span>
10478             <span class="comment">// Another file system has been found.  Invoke this file system at</span>
10479             <span class="comment">// its shutdown entry point.</span>
10480             <span class="comment">//</span>
10481 
10482             irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a27">IoBuildSynchronousFsdRequest</a>( <a class="code" href="../../d0/d5/io_8h.html#a29">IRP_MJ_SHUTDOWN</a>,
10483                                                 deviceObject,
10484                                                 (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
10485                                                 0,
10486                                                 (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
10487                                                 &amp;event,
10488                                                 &amp;ioStatus );
10489             <span class="keywordflow">if</span> (<a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( deviceObject, irp ) == STATUS_PENDING) {
10490 <span class="preprocessor">#if DBG</span>
10491 <span class="preprocessor"></span>                PUNICODE_STRING DeviceName = ObGetObjectName( deviceObject );
10492 
10493                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( <span class="stringliteral">"IO: Waiting for shutdown of device object (%x) - %wZ\n"</span>,
10494                           deviceObject,
10495                           DeviceName
10496                         );
10497 <span class="preprocessor">#endif // DBG</span>
10498 <span class="preprocessor"></span>                (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
10499                                               <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
10500                                               <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
10501                                               <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
10502                                               (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
10503             }
10504 
10505             <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a>( &amp;event );
10506         }
10507 
10508         <span class="comment">//</span>
10509         <span class="comment">// Walk the list of the drivers in the system that have registered</span>
10510         <span class="comment">// themselves as wanting to know at the last chance when the system</span>
10511         <span class="comment">// is about to be shutdown and invoke each.</span>
10512         <span class="comment">//</span>
10513 
10514         <span class="keywordflow">while</span> ((entry = <a class="code" href="../../d5/d8/ex_8h.html#a239">ExInterlockedRemoveHeadList</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a13">IopNotifyLastChanceShutdownQueueHead</a>, &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a> )) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
10515             shutdown = CONTAINING_RECORD( entry, <a class="code" href="../../d2/d3/struct__SHUTDOWN__PACKET.html">SHUTDOWN_PACKET</a>, ListEntry );
10516 
10517             <span class="comment">//</span>
10518             <span class="comment">// Another driver has been found that has indicated that it requires</span>
10519             <span class="comment">// shutdown notification.  Invoke the driver's shutdown entry point.</span>
10520             <span class="comment">//</span>
10521 
10522             deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a66">IoGetAttachedDevice</a>( shutdown-&gt;<a class="code" href="../../d2/d3/struct__SHUTDOWN__PACKET.html#o1">DeviceObject</a> );
10523 
10524             irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a27">IoBuildSynchronousFsdRequest</a>( <a class="code" href="../../d0/d5/io_8h.html#a29">IRP_MJ_SHUTDOWN</a>,
10525                                                 deviceObject,
10526                                                 (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
10527                                                 0,
10528                                                 (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
10529                                                 &amp;event,
10530                                                 &amp;ioStatus );
10531 
10532             <span class="keywordflow">if</span> (<a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( deviceObject, irp ) == STATUS_PENDING) {
10533 <span class="preprocessor">#if DBG</span>
10534 <span class="preprocessor"></span>                PUNICODE_STRING DeviceName = ObGetObjectName( shutdown-&gt;<a class="code" href="../../d2/d3/struct__SHUTDOWN__PACKET.html#o1">DeviceObject</a> );
10535 
10536                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>( <span class="stringliteral">"IO: Waiting for last chance shutdown of device object (%x) - %wZ\n"</span>,
10537                           shutdown-&gt;<a class="code" href="../../d2/d3/struct__SHUTDOWN__PACKET.html#o1">DeviceObject</a>,
10538                           DeviceName
10539                         );
10540 <span class="preprocessor">#endif // DBG</span>
10541 <span class="preprocessor"></span>                (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
10542                                               <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
10543                                               <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
10544                                               <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
10545                                               (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
10546             }
10547 
10548             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( shutdown );
10549             <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a>( &amp;event );
10550         }
10551 
10552         <span class="comment">//</span>
10553         <span class="comment">// N.B. The system has stopped.  The IopDatabaseResource lock is</span>
10554         <span class="comment">// not released so that no other mount operations can take place.</span>
10555         <span class="comment">//</span>
10556         <span class="comment">// ExReleaseResource( &amp;IopDatabaseResource );</span>
10557         <span class="comment">//</span>
10558     }
10559 
10560     <span class="keywordflow">return</span> ;
10561 }
10562 
10563 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l10564"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a111">10564</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a111">IoStartNextPacket</a>(
10565     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
10566     IN BOOLEAN Cancelable
10567     )
10568 
10569 <span class="comment">/*++</span>
10570 <span class="comment"></span>
10571 <span class="comment">Routine Description:</span>
10572 <span class="comment"></span>
10573 <span class="comment">    This routine is invoked to dequeue the next packet (IRP) from the</span>
10574 <span class="comment">    specified device work queue and invoke the device driver's start I/O</span>
10575 <span class="comment">    routine for it.  If the Cancelable paramter is TRUE, then the update of</span>
10576 <span class="comment">    current IRP is synchronized using the cancel spinlock.</span>
10577 <span class="comment"></span>
10578 <span class="comment">Arguments:</span>
10579 <span class="comment"></span>
10580 <span class="comment">    DeviceObject - Pointer to device object itself.</span>
10581 <span class="comment"></span>
10582 <span class="comment">    Cancelable - Indicates that IRPs in the device queue may be cancelable.</span>
10583 <span class="comment"></span>
10584 <span class="comment">Return Value:</span>
10585 <span class="comment"></span>
10586 <span class="comment">    None.</span>
10587 <span class="comment"></span>
10588 <span class="comment">--*/</span>
10589 
10590 {
10591     KIRQL cancelIrql;
10592     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
10593     <a class="code" href="../../d0/d6/struct__KDEVICE__QUEUE__ENTRY.html">PKDEVICE_QUEUE_ENTRY</a> packet;
10594 
10595     <span class="comment">//</span>
10596     <span class="comment">// Begin by checking to see whether or not this driver's requests are</span>
10597     <span class="comment">// to be considered cancelable.  If so, then acquire the cancel spinlock.</span>
10598     <span class="comment">//</span>
10599 
10600     <span class="keywordflow">if</span> (Cancelable) {
10601         <a class="code" href="../../d4/d6/iosubs_8c.html#a9">IoAcquireCancelSpinLock</a>( &amp;cancelIrql );
10602     }
10603 
10604     <span class="comment">//</span>
10605     <span class="comment">// Clear the current IRP field before starting another request.</span>
10606     <span class="comment">//</span>
10607 
10608     DeviceObject-&gt;CurrentIrp = (<a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
10609 
10610     <span class="comment">//</span>
10611     <span class="comment">// Remove the next packet from the head of the queue.  If a packet was</span>
10612     <span class="comment">// found, then process it.</span>
10613     <span class="comment">//</span>
10614 
10615     packet = <a class="code" href="../../d7/d7/devquobj_8c.html#a4">KeRemoveDeviceQueue</a>( &amp;DeviceObject-&gt;DeviceQueue );
10616 
10617     <span class="keywordflow">if</span> (packet) {
10618         irp = CONTAINING_RECORD( packet, <a class="code" href="../../d0/d2/struct__IRP.html">IRP</a>, Tail.Overlay.DeviceQueueEntry );
10619 
10620         <span class="comment">//</span>
10621         <span class="comment">// A packet was located so make it the current packet for this</span>
10622         <span class="comment">// device.</span>
10623         <span class="comment">//</span>
10624 
10625         DeviceObject-&gt;CurrentIrp = irp;
10626         <span class="keywordflow">if</span> (Cancelable) {
10627            <a class="code" href="../../d4/d6/iosubs_8c.html#a101">IoReleaseCancelSpinLock</a>( cancelIrql );
10628         }
10629 
10630         <span class="comment">//</span>
10631         <span class="comment">// Invoke the driver's start I/O routine for this packet.</span>
10632         <span class="comment">//</span>
10633 
10634         DeviceObject-&gt;DriverObject-&gt;DriverStartIo( DeviceObject, irp );
10635     } <span class="keywordflow">else</span> {
10636 
10637         <span class="comment">//</span>
10638         <span class="comment">// No packet was found, so simply release the cancel spinlock if</span>
10639         <span class="comment">// it was acquired.</span>
10640         <span class="comment">//</span>
10641 
10642         <span class="keywordflow">if</span> (Cancelable) {
10643            <a class="code" href="../../d4/d6/iosubs_8c.html#a101">IoReleaseCancelSpinLock</a>( cancelIrql );
10644         }
10645     }
10646 }
10647 
10648 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l10649"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a112">10649</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a112">IoStartNextPacketByKey</a>(
10650     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
10651     IN BOOLEAN Cancelable,
10652     IN ULONG Key
10653     )
10654 
10655 <span class="comment">/*++</span>
10656 <span class="comment"></span>
10657 <span class="comment">Routine Description:</span>
10658 <span class="comment"></span>
10659 <span class="comment">    This routine is invoked to dequeue the next packet (IRP) from the</span>
10660 <span class="comment">    specified device work queue by key and invoke the device driver's start</span>
10661 <span class="comment">    I/O routine for it.  If the Cancelable paramter is TRUE, then the</span>
10662 <span class="comment">    update of current IRP is synchronized using the cancel spinlock.</span>
10663 <span class="comment"></span>
10664 <span class="comment">Arguments:</span>
10665 <span class="comment"></span>
10666 <span class="comment">    DeviceObject - Pointer to device object itself.</span>
10667 <span class="comment"></span>
10668 <span class="comment">    Cancelable - Indicates that IRPs in the device queue may be cancelable.</span>
10669 <span class="comment"></span>
10670 <span class="comment">    Key - Specifics the Key used to remove the entry from the queue.</span>
10671 <span class="comment"></span>
10672 <span class="comment">Return Value:</span>
10673 <span class="comment"></span>
10674 <span class="comment">    None.</span>
10675 <span class="comment"></span>
10676 <span class="comment">--*/</span>
10677 
10678 {
10679     KIRQL                cancelIrql;
10680     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>                 irp;
10681     <a class="code" href="../../d0/d6/struct__KDEVICE__QUEUE__ENTRY.html">PKDEVICE_QUEUE_ENTRY</a> packet;
10682 
10683     <span class="comment">//</span>
10684     <span class="comment">// Begin by determining whether or not requests for this device are to</span>
10685     <span class="comment">// be considered cancelable.  If so, then acquire the cancel spinlock.</span>
10686     <span class="comment">//</span>
10687 
10688     <span class="keywordflow">if</span> (Cancelable) {
10689         <a class="code" href="../../d4/d6/iosubs_8c.html#a9">IoAcquireCancelSpinLock</a>( &amp;cancelIrql );
10690     }
10691 
10692     <span class="comment">//</span>
10693     <span class="comment">// Clear the current IRP field before starting another request.</span>
10694     <span class="comment">//</span>
10695 
10696     DeviceObject-&gt;CurrentIrp = (<a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
10697 
10698     <span class="comment">//</span>
10699     <span class="comment">// Attempt to remove the indicated packet according to the key from the</span>
10700     <span class="comment">// device queue.  If one is found, then process it.</span>
10701     <span class="comment">//</span>
10702 
10703     packet = <a class="code" href="../../d7/d7/devquobj_8c.html#a5">KeRemoveByKeyDeviceQueue</a>( &amp;DeviceObject-&gt;DeviceQueue, <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a> );
10704 
10705     <span class="keywordflow">if</span> (packet) {
10706         irp = CONTAINING_RECORD( packet, <a class="code" href="../../d0/d2/struct__IRP.html">IRP</a>, Tail.Overlay.DeviceQueueEntry );
10707 
10708         <span class="comment">//</span>
10709         <span class="comment">// A packet was successfully located.  Make it the current packet</span>
10710         <span class="comment">// and invoke the driver's start I/O routine for it.</span>
10711         <span class="comment">//</span>
10712 
10713         DeviceObject-&gt;CurrentIrp = irp;
10714 
10715         <span class="keywordflow">if</span> (Cancelable) {
10716            <a class="code" href="../../d4/d6/iosubs_8c.html#a101">IoReleaseCancelSpinLock</a>( cancelIrql );
10717         }
10718 
10719         DeviceObject-&gt;DriverObject-&gt;DriverStartIo( DeviceObject, irp );
10720 
10721     } <span class="keywordflow">else</span> {
10722 
10723         <span class="comment">//</span>
10724         <span class="comment">// No packet was found, so release the cancel spinlock if it was</span>
10725         <span class="comment">// acquired.</span>
10726         <span class="comment">//</span>
10727 
10728         <span class="keywordflow">if</span> (Cancelable) {
10729            <a class="code" href="../../d4/d6/iosubs_8c.html#a101">IoReleaseCancelSpinLock</a>( cancelIrql );
10730         }
10731     }
10732 }
10733 
10734 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l10735"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a113">10735</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a113">IoStartPacket</a>(
10736     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
10737     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
10738     IN PULONG Key OPTIONAL,
10739     IN PDRIVER_CANCEL CancelFunction OPTIONAL
10740     )
10741 
10742 <span class="comment">/*++</span>
10743 <span class="comment"></span>
10744 <span class="comment">Routine Description:</span>
10745 <span class="comment"></span>
10746 <span class="comment">    This routine attempts to start the specified packet request (IRP) on the</span>
10747 <span class="comment">    specified device.  If the device is already busy, then the packet is</span>
10748 <span class="comment">    simply queued to the device queue. If a non-NULL CancelFunction is</span>
10749 <span class="comment">    supplied, it will be put in the IRP.  If the IRP has been canceled, the</span>
10750 <span class="comment">    CancelFunction will be called after the IRP has been inserted into the</span>
10751 <span class="comment">    queue or made the current packet.</span>
10752 <span class="comment"></span>
10753 <span class="comment">Arguments:</span>
10754 <span class="comment"></span>
10755 <span class="comment">    DeviceObject - Pointer to device object itself.</span>
10756 <span class="comment"></span>
10757 <span class="comment">    Irp - I/O Request Packet which should be started on the device.</span>
10758 <span class="comment"></span>
10759 <span class="comment">    Key - Key to be used in inserting packet into device queue;  optional</span>
10760 <span class="comment">        (if not specified, then packet is inserted at the tail).</span>
10761 <span class="comment"></span>
10762 <span class="comment">    CancelFunction - Pointer to an optional cancel routine.</span>
10763 <span class="comment"></span>
10764 <span class="comment">Return Value:</span>
10765 <span class="comment"></span>
10766 <span class="comment">    None.</span>
10767 <span class="comment"></span>
10768 <span class="comment">--*/</span>
10769 
10770 {
10771     KIRQL oldIrql;
10772     KIRQL cancelIrql;
10773     BOOLEAN i;
10774 
10775     <span class="comment">//</span>
10776     <span class="comment">// Raise the IRQL of the processor to dispatch level for synchronization.</span>
10777     <span class="comment">//</span>
10778 
10779     <a class="code" href="../../d9/d5/verifier_8c.html#a116">KeRaiseIrql</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a53">DISPATCH_LEVEL</a>, &amp;oldIrql );
10780 
10781     <span class="comment">//</span>
10782     <span class="comment">// If the driver has indicated that packets are cancelable, then acquire</span>
10783     <span class="comment">// the cancel spinlock and set the address of the cancel function to</span>
10784     <span class="comment">// indicate that the packet is not only cancelable, but indicates what</span>
10785     <span class="comment">// routine to invoke should it be cancelled.</span>
10786     <span class="comment">//</span>
10787 
10788     <span class="keywordflow">if</span> (CancelFunction) {
10789         <a class="code" href="../../d4/d6/iosubs_8c.html#a9">IoAcquireCancelSpinLock</a>( &amp;cancelIrql );
10790         <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o25">CancelRoutine</a> = CancelFunction;
10791     }
10792 
10793     <span class="comment">//</span>
10794     <span class="comment">// If a key parameter was specified, then insert the request into the</span>
10795     <span class="comment">// work queue according to the key;  otherwise, simply insert it at the</span>
10796     <span class="comment">// tail.</span>
10797     <span class="comment">//</span>
10798 
10799     <span class="keywordflow">if</span> (<a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a>) {
10800         i = <a class="code" href="../../d7/d7/devquobj_8c.html#a3">KeInsertByKeyDeviceQueue</a>( &amp;DeviceObject-&gt;DeviceQueue,
10801                                       &amp;<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.DeviceQueueEntry,
10802                                       *<a class="code" href="../../d2/d0/nt6_2user32_8def.html#a51">Key</a> );
10803     } <span class="keywordflow">else</span> {
10804         i = <a class="code" href="../../d7/d7/devquobj_8c.html#a2">KeInsertDeviceQueue</a>( &amp;DeviceObject-&gt;DeviceQueue,
10805                                  &amp;<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.DeviceQueueEntry );
10806     }
10807 
10808     <span class="comment">//</span>
10809     <span class="comment">// If the packet was not inserted into the queue, then this request is</span>
10810     <span class="comment">// now the current packet for this device.  Indicate so by storing its</span>
10811     <span class="comment">// address in the current IRP field, and begin processing the request.</span>
10812     <span class="comment">//</span>
10813 
10814     <span class="keywordflow">if</span> (!i) {
10815 
10816         DeviceObject-&gt;CurrentIrp = <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>;
10817 
10818         <span class="keywordflow">if</span> (CancelFunction) {
10819 
10820             <a class="code" href="../../d4/d6/iosubs_8c.html#a101">IoReleaseCancelSpinLock</a>( cancelIrql );
10821         }
10822 
10823         <span class="comment">//</span>
10824         <span class="comment">// Invoke the driver's start I/O routine to get the request going on the device.</span>
10825         <span class="comment">// The StartIo routine should handle the cancellation.</span>
10826         <span class="comment">//</span>
10827 
10828         DeviceObject-&gt;DriverObject-&gt;DriverStartIo( DeviceObject, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
10829 
10830     } <span class="keywordflow">else</span> {
10831 
10832         <span class="comment">//</span>
10833         <span class="comment">// The packet was successfully inserted into the device's work queue.</span>
10834         <span class="comment">// Make one last check to determine whether or not the packet has</span>
10835         <span class="comment">// already been marked cancelled.  If it has, then invoke the</span>
10836         <span class="comment">// driver's cancel routine now.  Note that because the cancel</span>
10837         <span class="comment">// spinlock is currently being held, an attempt to cancel the request</span>
10838         <span class="comment">// from another processor at this point will simply wait until this</span>
10839         <span class="comment">// routine is finished, and then get it cancelled.</span>
10840         <span class="comment">//</span>
10841 
10842         <span class="keywordflow">if</span> (CancelFunction) {
10843             <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o14">Cancel</a>) {
10844                 <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o15">CancelIrql</a> = cancelIrql;
10845                 <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o25">CancelRoutine</a> = (<a class="code" href="../../d0/d5/io_8h.html#a286">PDRIVER_CANCEL</a>) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
10846                 CancelFunction( DeviceObject, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a> );
10847             } <span class="keywordflow">else</span> {
10848                 <a class="code" href="../../d4/d6/iosubs_8c.html#a101">IoReleaseCancelSpinLock</a>( cancelIrql );
10849             }
10850         }
10851     }
10852 
10853     <span class="comment">//</span>
10854     <span class="comment">// Restore the IRQL back to its value upon entry to this function before</span>
10855     <span class="comment">// returning to the caller.</span>
10856     <span class="comment">//</span>
10857 
10858     <a class="code" href="../../d9/d5/verifier_8c.html#a117">KeLowerIrql</a>( oldIrql );
10859 }
10860 
10861 
10862 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l10863"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a114">10863</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a114">IoStartTimer</a>(
10864     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject
10865     )
10866 
10867 <span class="comment">/*++</span>
10868 <span class="comment"></span>
10869 <span class="comment">Routine Description:</span>
10870 <span class="comment"></span>
10871 <span class="comment">    This routine starts the timer associated with the specified device object.</span>
10872 <span class="comment"></span>
10873 <span class="comment">Arguments:</span>
10874 <span class="comment"></span>
10875 <span class="comment">    DeviceObject - Device object associated with the timer to be started.</span>
10876 <span class="comment"></span>
10877 <span class="comment">Return Value:</span>
10878 <span class="comment"></span>
10879 <span class="comment">    None.</span>
10880 <span class="comment"></span>
10881 <span class="comment">--*/</span>
10882 
10883 {
10884     <a class="code" href="../../d4/d9/struct__IO__TIMER.html">PIO_TIMER</a> timer;
10885     KIRQL irql;
10886 
10887     <span class="comment">//</span>
10888     <span class="comment">// Get the address of the timer.</span>
10889     <span class="comment">//</span>
10890 
10891     timer = DeviceObject-&gt;Timer;
10892 
10893     <span class="comment">//</span>
10894     <span class="comment">// If the driver is not being unloaded, then it is okay to start timers.</span>
10895     <span class="comment">//</span>
10896 
10897     <span class="keywordflow">if</span> (!(DeviceObject-&gt;DeviceObjectExtension-&gt;ExtensionFlags &amp;
10898         (<a class="code" href="../../d0/d5/io_8h.html#a138">DOE_UNLOAD_PENDING</a> | <a class="code" href="../../d0/d5/io_8h.html#a139">DOE_DELETE_PENDING</a> | <a class="code" href="../../d0/d5/io_8h.html#a140">DOE_REMOVE_PENDING</a> | <a class="code" href="../../d0/d5/io_8h.html#a141">DOE_REMOVE_PROCESSED</a>))) {
10899 
10900         <span class="comment">//</span>
10901         <span class="comment">// Likewise, check to see whether or not the timer is already</span>
10902         <span class="comment">// enabled.  If so, then simply exit.  Otherwise, enable the timer</span>
10903         <span class="comment">// by placing it into the I/O system timer queue.</span>
10904         <span class="comment">//</span>
10905 
10906         ExAcquireFastLock( &amp;<a class="code" href="../../d4/d4/alpha_2splocks_8c.html#a8">IopTimerLock</a>, &amp;irql );
10907         <span class="keywordflow">if</span> (!timer-&gt;<a class="code" href="../../d4/d9/struct__IO__TIMER.html#o1">TimerFlag</a>) {
10908             timer-&gt;<a class="code" href="../../d4/d9/struct__IO__TIMER.html#o1">TimerFlag</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
10909             <a class="code" href="../../d3/d5/iodata_8c.html#a31">IopTimerCount</a>++;
10910         }
10911         ExReleaseFastLock( &amp;<a class="code" href="../../d4/d4/alpha_2splocks_8c.html#a8">IopTimerLock</a>, irql );
10912     }
10913 }
10914 
10915 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l10916"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a115">10916</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a115">IoStopTimer</a>(
10917     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject
10918     )
10919 
10920 <span class="comment">/*++</span>
10921 <span class="comment"></span>
10922 <span class="comment">Routine Description:</span>
10923 <span class="comment"></span>
10924 <span class="comment">    This routines stops the timer associated with the specified device object</span>
10925 <span class="comment">    from invoking being invoked.</span>
10926 <span class="comment"></span>
10927 <span class="comment">Arguments:</span>
10928 <span class="comment"></span>
10929 <span class="comment">    DeviceObject - Device object associated with the timer to be stopped.</span>
10930 <span class="comment"></span>
10931 <span class="comment">Return Value:</span>
10932 <span class="comment"></span>
10933 <span class="comment">    None.</span>
10934 <span class="comment"></span>
10935 <span class="comment">--*/</span>
10936 
10937 {
10938     KIRQL irql;
10939     <a class="code" href="../../d4/d9/struct__IO__TIMER.html">PIO_TIMER</a> timer;
10940 
10941     <span class="comment">//</span>
10942     <span class="comment">// Obtain the I/O system timer queue lock, and disable the specified</span>
10943     <span class="comment">// timer.</span>
10944     <span class="comment">//</span>
10945 
10946     timer = DeviceObject-&gt;Timer;
10947 
10948     ExAcquireFastLock( &amp;<a class="code" href="../../d4/d4/alpha_2splocks_8c.html#a8">IopTimerLock</a>, &amp;irql );
10949     <span class="keywordflow">if</span> (timer-&gt;<a class="code" href="../../d4/d9/struct__IO__TIMER.html#o1">TimerFlag</a>) {
10950         timer-&gt;<a class="code" href="../../d4/d9/struct__IO__TIMER.html#o1">TimerFlag</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
10951         <a class="code" href="../../d3/d5/iodata_8c.html#a31">IopTimerCount</a>--;
10952     }
10953     ExReleaseFastLock( &amp;<a class="code" href="../../d4/d4/alpha_2splocks_8c.html#a8">IopTimerLock</a>, irql );
10954 }
10955 
10956 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l10957"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a116">10957</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a116">IoSynchronousPageWrite</a>(
10958     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
10959     IN <a class="code" href="../../d6/d7/struct__MDL.html">PMDL</a> MemoryDescriptorList,
10960     IN PLARGE_INTEGER StartingOffset,
10961     IN <a class="code" href="../../d2/d6/struct__KEVENT.html">PKEVENT</a> Event,
10962     OUT PIO_STATUS_BLOCK IoStatusBlock
10963     )
10964 
10965 <span class="comment">/*++</span>
10966 <span class="comment"></span>
10967 <span class="comment">Routine Description:</span>
10968 <span class="comment"></span>
10969 <span class="comment">    This routine provides a special, fast interface for the Modified Page Writer</span>
10970 <span class="comment">    (MPW) to write pages to the disk quickly and with very little overhead.  All</span>
10971 <span class="comment">    of the special handling for this request is recognized by setting the</span>
10972 <span class="comment">    IRP_PAGING_IO flag in the IRP flags word.</span>
10973 <span class="comment"></span>
10974 <span class="comment">Arguments:</span>
10975 <span class="comment"></span>
10976 <span class="comment">    FileObject - A pointer to a referenced file object describing which file</span>
10977 <span class="comment">        the write should be performed on.</span>
10978 <span class="comment"></span>
10979 <span class="comment">    MemoryDescriptorList - An MDL which describes the physical pages that the</span>
10980 <span class="comment">        pages should be written to the disk.  All of the pages have been locked</span>
10981 <span class="comment">        in memory.  The MDL also describes the length of the write operation.</span>
10982 <span class="comment"></span>
10983 <span class="comment">    StartingOffset - Pointer to the offset in the file from which the write</span>
10984 <span class="comment">        should take place.</span>
10985 <span class="comment"></span>
10986 <span class="comment">    Event - A pointer to a kernel event structure to be used for synchronization</span>
10987 <span class="comment">        purposes.  The event will be set to the Signlaged state once the pages</span>
10988 <span class="comment">        have been written.</span>
10989 <span class="comment"></span>
10990 <span class="comment">    IoStatusBlock - A pointer to the I/O status block in which the final status</span>
10991 <span class="comment">        and information should be stored.</span>
10992 <span class="comment"></span>
10993 <span class="comment">Return Value:</span>
10994 <span class="comment"></span>
10995 <span class="comment">    The function value is the final status of the queue request to the I/O</span>
10996 <span class="comment">    system subcomponents.</span>
10997 <span class="comment"></span>
10998 <span class="comment"></span>
10999 <span class="comment">--*/</span>
11000 
11001 {
11002     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
11003     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
11004     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
11005 
11006     <span class="comment">//</span>
11007     <span class="comment">// Increment performance counters</span>
11008     <span class="comment">//</span>
11009 
11010     <span class="keywordflow">if</span> (<a class="code" href="../../d4/d2/cache_8h.html#a2">CcIsFileCached</a>(FileObject)) {
11011         <a class="code" href="../../d5/d2/cachedat_8c.html#a73">CcDataFlushes</a> += 1;
11012         <a class="code" href="../../d5/d2/cachedat_8c.html#a74">CcDataPages</a> += (MemoryDescriptorList-&gt;ByteCount + <a class="code" href="../../d6/d7/halmips_8h.html#a446">PAGE_SIZE</a> - 1) &gt;&gt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>;
11013     }
11014 
11015     <span class="comment">//</span>
11016     <span class="comment">// Begin by getting a pointer to the device object that the file resides</span>
11017     <span class="comment">// on.</span>
11018     <span class="comment">//</span>
11019 
11020     deviceObject = <a class="code" href="../../d4/d6/iosubs_8c.html#a76">IoGetRelatedDeviceObject</a>( FileObject );
11021 
11022     <span class="comment">//</span>
11023     <span class="comment">// Allocate an I/O Request Packet (IRP) for this out-page operation.</span>
11024     <span class="comment">//</span>
11025 
11026     irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a17">IoAllocateIrp</a>( deviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o13">StackSize</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
11027     <span class="keywordflow">if</span> (!irp) {
11028         <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
11029     }
11030 
11031     <span class="comment">//</span>
11032     <span class="comment">// Get a pointer to the first stack location in the packet.  This location</span>
11033     <span class="comment">// will be used to pass the function codes and parameters to the first</span>
11034     <span class="comment">// driver.</span>
11035     <span class="comment">//</span>
11036 
11037     irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
11038 
11039     <span class="comment">//</span>
11040     <span class="comment">// Fill in the IRP according to this request.</span>
11041     <span class="comment">//</span>
11042 
11043     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o2">MdlAddress</a> = MemoryDescriptorList;
11044     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a174">IRP_PAGING_IO</a> | <a class="code" href="../../d0/d5/io_8h.html#a173">IRP_NOCACHE</a> | <a class="code" href="../../d0/d5/io_8h.html#a181">IRP_SYNCHRONOUS_PAGING_IO</a>;
11045 
11046     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o10">RequestorMode</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>;
11047     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = IoStatusBlock;
11048     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = <a class="code" href="../../d8/d9/client_2ntstubs_8c.html#a5">Event</a>;
11049     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o26">UserBuffer</a> = (PVOID) ((PCHAR) MemoryDescriptorList-&gt;StartVa + MemoryDescriptorList-&gt;ByteOffset);
11050     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.OriginalFileObject = FileObject;
11051     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
11052 
11053     <span class="comment">//</span>
11054     <span class="comment">// Fill in the normal write parameters.</span>
11055     <span class="comment">//</span>
11056 
11057     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a17">IRP_MJ_WRITE</a>;
11058     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Write.Length = MemoryDescriptorList-&gt;ByteCount;
11059     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.Write.ByteOffset = *StartingOffset;
11060     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> = FileObject;
11061 
11062     <span class="comment">//</span>
11063     <span class="comment">// Queue the packet to the appropriate driver based on whether or not there</span>
11064     <span class="comment">// is a VPB associated with the device.</span>
11065     <span class="comment">//</span>
11066 
11067     <span class="keywordflow">return</span> <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( deviceObject, irp );
11068 }
11069 
11070 <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a>
<a name="l11071"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a117">11071</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a117">IoThreadToProcess</a>(
11072     IN <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a> Thread
11073     )
11074 
11075 <span class="comment">/*++</span>
11076 <span class="comment"></span>
11077 <span class="comment">Routine Description:</span>
11078 <span class="comment"></span>
11079 <span class="comment">    This routine returns a pointer to the process for the specified thread.</span>
11080 <span class="comment"></span>
11081 <span class="comment">Arguments:</span>
11082 <span class="comment"></span>
11083 <span class="comment">    Thread - Thread whose process is to be returned.</span>
11084 <span class="comment"></span>
11085 <span class="comment">Return Value:</span>
11086 <span class="comment"></span>
11087 <span class="comment">    A pointer to the thread's process.</span>
11088 <span class="comment"></span>
11089 <span class="comment">Note:</span>
11090 <span class="comment"></span>
11091 <span class="comment">    This function cannot be made a macro, since fields in the thread object</span>
11092 <span class="comment">    move from release to release, so this must remain a full function.</span>
11093 <span class="comment"></span>
11094 <span class="comment"></span>
11095 <span class="comment">--*/</span>
11096 
11097 {
11098     <span class="comment">//</span>
11099     <span class="comment">// Simply return the thread's process.</span>
11100     <span class="comment">//</span>
11101 
11102     <span class="keywordflow">return</span> <a class="code" href="../../d1/d9/ps_8h.html#a17">THREAD_TO_PROCESS</a>( Thread );
11103 }
11104 
11105 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l11106"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a118">11106</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a118">IoUnregisterFileSystem</a>(
11107     IN OUT <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject
11108     )
11109 
11110 <span class="comment">/*++</span>
11111 <span class="comment"></span>
11112 <span class="comment">Routine Description:</span>
11113 <span class="comment"></span>
11114 <span class="comment">    This routine removes the device object for the file system from the active</span>
11115 <span class="comment">    list of file systems in the system.</span>
11116 <span class="comment"></span>
11117 <span class="comment">Arguments:</span>
11118 <span class="comment"></span>
11119 <span class="comment">    DeviceObject - Pointer to device object for the file system.</span>
11120 <span class="comment"></span>
11121 <span class="comment">Return Value:</span>
11122 <span class="comment"></span>
11123 <span class="comment">    None.</span>
11124 <span class="comment"></span>
11125 <span class="comment"></span>
11126 <span class="comment">--*/</span>
11127 
11128 {
11129     <a class="code" href="../../d8/d3/struct__NOTIFICATION__PACKET.html">PNOTIFICATION_PACKET</a> nPacket;
11130     PLIST_ENTRY entry;
11131 
11132     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
11133 
11134     <span class="comment">//</span>
11135     <span class="comment">// Acquire the I/O database resource for a write operation.</span>
11136     <span class="comment">//</span>
11137 
11138     (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>)<a class="code" href="../../d5/d8/ex_8h.html#a70">ExAcquireResourceExclusive</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a4">IopDatabaseResource</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
11139 
11140     <span class="comment">//</span>
11141     <span class="comment">// Remove the device object from whatever queue it happens to be in at the</span>
11142     <span class="comment">// moment.  There is no need to check here to determine if the device queue</span>
11143     <span class="comment">// is in a queue since it is assumed that the caller registered it as a</span>
11144     <span class="comment">// valid file system.</span>
11145     <span class="comment">//</span>
11146 
11147     RemoveEntryList( &amp;DeviceObject-&gt;Queue.ListEntry );
11148 
11149     <span class="comment">//</span>
11150     <span class="comment">// Notify all of the registered drivers that this file system has been</span>
11151     <span class="comment">// unregistered as an active file system of some type.</span>
11152     <span class="comment">//</span>
11153 
11154     entry = <a class="code" href="../../d3/d5/iodata_8c.html#a14">IopFsNotifyChangeQueueHead</a>.Flink;
11155     <span class="keywordflow">while</span> (entry != &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a14">IopFsNotifyChangeQueueHead</a>) {
11156         nPacket = CONTAINING_RECORD( entry, <a class="code" href="../../d8/d3/struct__NOTIFICATION__PACKET.html">NOTIFICATION_PACKET</a>, ListEntry );
11157         entry = entry-&gt;Flink;
11158         nPacket-&gt;<a class="code" href="../../d8/d3/struct__NOTIFICATION__PACKET.html#o2">NotificationRoutine</a>( DeviceObject, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
11159     }
11160 
11161     <span class="comment">//</span>
11162     <span class="comment">// Release the I/O database resource.</span>
11163     <span class="comment">//</span>
11164 
11165     <a class="code" href="../../d5/d8/ex_8h.html#a66">ExReleaseResource</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a4">IopDatabaseResource</a> );
11166 
11167     <span class="comment">//</span>
11168     <span class="comment">// Decrement the number of reasons that this driver cannot be unloaded.</span>
11169     <span class="comment">//</span>
11170 
11171     <a class="code" href="../../d5/d8/ex_8h.html#a235">ExInterlockedAddUlong</a>( &amp;DeviceObject-&gt;ReferenceCount,
11172                            0xffffffff,
11173                            &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a> );
11174 
11175 }
11176 
11177 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l11178"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a119">11178</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a119">IoUnregisterFsRegistrationChange</a>(
11179     IN <a class="code" href="../../d4/d9/struct__DRIVER__OBJECT.html">PDRIVER_OBJECT</a> DriverObject,
11180     IN PDRIVER_FS_NOTIFICATION DriverNotificationRoutine
11181     )
11182 
11183 <span class="comment">/*++</span>
11184 <span class="comment"></span>
11185 <span class="comment">Routine Description:</span>
11186 <span class="comment"></span>
11187 <span class="comment">    This routine unregisters the specified driver's notification routine from</span>
11188 <span class="comment">    begin invoked whenever a file system registers or unregisters itself as an</span>
11189 <span class="comment">    active file system in the system.</span>
11190 <span class="comment"></span>
11191 <span class="comment">Arguments:</span>
11192 <span class="comment"></span>
11193 <span class="comment">    DriverObject - Pointer to the driver object for the driver.</span>
11194 <span class="comment"></span>
11195 <span class="comment">    DriverNotificationRoutine - Address of routine to unregister.</span>
11196 <span class="comment"></span>
11197 <span class="comment">Return Value:</span>
11198 <span class="comment"></span>
11199 <span class="comment">    None.</span>
11200 <span class="comment"></span>
11201 <span class="comment">--*/</span>
11202 
11203 {
11204     <a class="code" href="../../d8/d3/struct__NOTIFICATION__PACKET.html">PNOTIFICATION_PACKET</a> nPacket;
11205     PLIST_ENTRY entry;
11206 
11207     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
11208 
11209     <span class="comment">//</span>
11210     <span class="comment">// Begin by acquiring the database resource exclusively.</span>
11211     <span class="comment">//</span>
11212 
11213     <a class="code" href="../../d5/d8/ex_8h.html#a70">ExAcquireResourceExclusive</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a4">IopDatabaseResource</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
11214 
11215     <span class="comment">//</span>
11216     <span class="comment">// Walk the list of registered notification routines and unregister the</span>
11217     <span class="comment">// specified routine.</span>
11218     <span class="comment">//</span>
11219 
11220     <span class="keywordflow">for</span> (entry = <a class="code" href="../../d3/d5/iodata_8c.html#a14">IopFsNotifyChangeQueueHead</a>.Flink;
11221         entry != &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a14">IopFsNotifyChangeQueueHead</a>;
11222         entry = entry-&gt;Flink) {
11223         nPacket = CONTAINING_RECORD( entry, <a class="code" href="../../d8/d3/struct__NOTIFICATION__PACKET.html">NOTIFICATION_PACKET</a>, ListEntry );
11224         <span class="keywordflow">if</span> (nPacket-&gt;<a class="code" href="../../d8/d3/struct__NOTIFICATION__PACKET.html#o1">DriverObject</a> == DriverObject &amp;&amp;
11225             nPacket-&gt;<a class="code" href="../../d8/d3/struct__NOTIFICATION__PACKET.html#o2">NotificationRoutine</a> == DriverNotificationRoutine) {
11226             RemoveEntryList( entry );
11227             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( nPacket );
11228             <span class="keywordflow">break</span>;
11229         }
11230     }
11231 
11232     <a class="code" href="../../d5/d8/ex_8h.html#a66">ExReleaseResource</a>( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a4">IopDatabaseResource</a> );
11233 
11234     <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( DriverObject );
11235 
11236 }
11237 
11238 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l11239"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a120">11239</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a120">IoUnregisterShutdownNotification</a>(
11240     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject
11241     )
11242 
11243 <span class="comment">/*++</span>
11244 <span class="comment"></span>
11245 <span class="comment">Routine Description:</span>
11246 <span class="comment"></span>
11247 <span class="comment">    This routine removes a registered driver from the shutdown notification</span>
11248 <span class="comment">    queue.  Henceforth, the driver will not be notified when the system is</span>
11249 <span class="comment">    being shutdown.</span>
11250 <span class="comment"></span>
11251 <span class="comment">Arguments:</span>
11252 <span class="comment"></span>
11253 <span class="comment">    DeviceObject - Pointer to the driver's device object.</span>
11254 <span class="comment"></span>
11255 <span class="comment">Return Value:</span>
11256 <span class="comment"></span>
11257 <span class="comment">    None.</span>
11258 <span class="comment"></span>
11259 <span class="comment">--*/</span>
11260 
11261 {
11262     PLIST_ENTRY entry;
11263     <a class="code" href="../../d2/d3/struct__SHUTDOWN__PACKET.html">PSHUTDOWN_PACKET</a> shutdown;
11264     KIRQL irql;
11265     PVOID unlockHandle;
11266 
11267     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
11268 
11269     <span class="comment">//</span>
11270     <span class="comment">// Lock this code into memory for the duration of this function's execution.</span>
11271     <span class="comment">//</span>
11272 
11273     unlockHandle = MmLockPagableCodeSection( <a class="code" href="../../d0/d5/io_8h.html#a562">IoUnregisterShutdownNotification</a> );
11274 
11275     <span class="comment">//</span>
11276     <span class="comment">// Acquire the spinlock that protects the shutdown notification queue, and</span>
11277     <span class="comment">// walk the queue looking for the caller's entry.  Once found, remove it</span>
11278     <span class="comment">// from the queue.  It is an error to not find it, but it is ignored here.</span>
11279     <span class="comment">//</span>
11280 
11281     ExAcquireSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, &amp;irql );
11282 
11283     <span class="keywordflow">for</span> (entry = <a class="code" href="../../d3/d5/iodata_8c.html#a12">IopNotifyShutdownQueueHead</a>.Flink;
11284          entry != &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a12">IopNotifyShutdownQueueHead</a>;
11285          entry = entry-&gt;Flink) {
11286 
11287         <span class="comment">//</span>
11288         <span class="comment">// An entry has been located.  If it is the one that is being searched</span>
11289         <span class="comment">// for, simply remove it from the list and deallocate it.</span>
11290         <span class="comment">//</span>
11291 
11292         shutdown = CONTAINING_RECORD( entry, <a class="code" href="../../d2/d3/struct__SHUTDOWN__PACKET.html">SHUTDOWN_PACKET</a>, ListEntry );
11293         <span class="keywordflow">if</span> (shutdown-&gt;<a class="code" href="../../d2/d3/struct__SHUTDOWN__PACKET.html#o1">DeviceObject</a> == DeviceObject) {
11294             RemoveEntryList( entry );
11295             entry = entry-&gt;Blink;
11296             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( shutdown );
11297         }
11298     }
11299 
11300     <span class="keywordflow">for</span> (entry = <a class="code" href="../../d3/d5/iodata_8c.html#a13">IopNotifyLastChanceShutdownQueueHead</a>.Flink;
11301          entry != &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a13">IopNotifyLastChanceShutdownQueueHead</a>;
11302          entry = entry-&gt;Flink) {
11303 
11304         <span class="comment">//</span>
11305         <span class="comment">// An entry has been located.  If it is the one that is being searched</span>
11306         <span class="comment">// for, simply remove it from the list and deallocate it.</span>
11307         <span class="comment">//</span>
11308 
11309         shutdown = CONTAINING_RECORD( entry, <a class="code" href="../../d2/d3/struct__SHUTDOWN__PACKET.html">SHUTDOWN_PACKET</a>, ListEntry );
11310         <span class="keywordflow">if</span> (shutdown-&gt;<a class="code" href="../../d2/d3/struct__SHUTDOWN__PACKET.html#o1">DeviceObject</a> == DeviceObject) {
11311             RemoveEntryList( entry );
11312             entry = entry-&gt;Blink;
11313             <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( shutdown );
11314         }
11315     }
11316 
11317     <span class="comment">//</span>
11318     <span class="comment">// Release the spinlock.</span>
11319     <span class="comment">//</span>
11320 
11321     ExReleaseSpinLock( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a3">IopDatabaseLock</a>, irql );
11322 
11323     <a class="code" href="../../d5/d6/iosup_8c.html#a81">MmUnlockPagableImageSection</a>( unlockHandle );
11324 
11325     DeviceObject-&gt;Flags &amp;= ~<a class="code" href="../../d0/d5/io_8h.html#a132">DO_SHUTDOWN_REGISTERED</a>;
11326 
11327 }
11328 
11329 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l11330"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a121">11330</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a121">IoUpdateShareAccess</a>(
11331     IN OUT <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject,
11332     IN OUT <a class="code" href="../../d9/d2/struct__SHARE__ACCESS.html">PSHARE_ACCESS</a> ShareAccess
11333     )
11334 
11335 <span class="comment">/*++</span>
11336 <span class="comment"></span>
11337 <span class="comment">Routine Description:</span>
11338 <span class="comment"></span>
11339 <span class="comment">    This routine updates the share access context for a file according to</span>
11340 <span class="comment">    the desired access and share access by the current open requestor.  The</span>
11341 <span class="comment">    IoCheckShareAccess routine must already have been invoked and succeeded</span>
11342 <span class="comment">    in order to invoke this routine.  Note that when the former routine was</span>
11343 <span class="comment">    invoked the Update parameter must have been FALSE.</span>
11344 <span class="comment"></span>
11345 <span class="comment">Arguments:</span>
11346 <span class="comment"></span>
11347 <span class="comment">    FileObject - Pointer to the file object of the current open request.</span>
11348 <span class="comment"></span>
11349 <span class="comment">    ShareAccess - Pointer to the share access structure that describes how</span>
11350 <span class="comment">        the file is currently being accessed.</span>
11351 <span class="comment"></span>
11352 <span class="comment">Return Value:</span>
11353 <span class="comment"></span>
11354 <span class="comment">    None.</span>
11355 <span class="comment"></span>
11356 <span class="comment">--*/</span>
11357 
11358 {
11359     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
11360 
11361     <span class="comment">//</span>
11362     <span class="comment">// Check to see whether or not the desired accesses need read, write,</span>
11363     <span class="comment">// or delete access to the file.</span>
11364     <span class="comment">//</span>
11365 
11366     <span class="keywordflow">if</span> (FileObject-&gt;ReadAccess ||
11367         FileObject-&gt;WriteAccess ||
11368         FileObject-&gt;DeleteAccess) {
11369 
11370         <span class="comment">//</span>
11371         <span class="comment">// The open request requires read, write, or delete access so update</span>
11372         <span class="comment">// the share access context for the file.</span>
11373         <span class="comment">//</span>
11374 
11375         ShareAccess-&gt;OpenCount++;
11376 
11377         ShareAccess-&gt;Readers += FileObject-&gt;ReadAccess;
11378         ShareAccess-&gt;Writers += FileObject-&gt;WriteAccess;
11379         ShareAccess-&gt;Deleters += FileObject-&gt;DeleteAccess;
11380 
11381         ShareAccess-&gt;SharedRead += FileObject-&gt;SharedRead;
11382         ShareAccess-&gt;SharedWrite += FileObject-&gt;SharedWrite;
11383         ShareAccess-&gt;SharedDelete += FileObject-&gt;SharedDelete;
11384     }
11385 }
11386 
11387 
11388 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l11389"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a122">11389</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a122">IoVerifyVolume</a>(
11390     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
11391     IN BOOLEAN AllowRawMount
11392     )
11393 
11394 <span class="comment">/*++</span>
11395 <span class="comment"></span>
11396 <span class="comment">Routine Description:</span>
11397 <span class="comment"></span>
11398 <span class="comment">    This routine is invoked to check a mounted volume on the specified device</span>
11399 <span class="comment">    when it appears as if the media may have changed since it was last</span>
11400 <span class="comment">    accessed.  If the volume is not the same volume, and a new mount is not</span>
11401 <span class="comment">    to be attempted, return the error.</span>
11402 <span class="comment"></span>
11403 <span class="comment">    If the verify fails, this routine is used to perform a new mount operation</span>
11404 <span class="comment">    on the device.  In this case, a "clean" VPB is allocated and a new mount</span>
11405 <span class="comment">    operation is attempted.  If no mount operation succeeds, then again the</span>
11406 <span class="comment">    error handling described above occurs.</span>
11407 <span class="comment"></span>
11408 <span class="comment">Arguments:</span>
11409 <span class="comment"></span>
11410 <span class="comment">    DeviceObject - Pointer to device object on which the volume is to be</span>
11411 <span class="comment">        mounted.</span>
11412 <span class="comment"></span>
11413 <span class="comment">    AllowRawMount - Indicates that this verify is on behalf of a DASD open</span>
11414 <span class="comment">        request, thus we want to allow a raw mount if the verify fails.</span>
11415 <span class="comment"></span>
11416 <span class="comment">Return Value:</span>
11417 <span class="comment"></span>
11418 <span class="comment">    The function value is a successful status code if a volume was successfully</span>
11419 <span class="comment">    mounted on the device.  Otherwise, an error code is returned.</span>
11420 <span class="comment"></span>
11421 <span class="comment"></span>
11422 <span class="comment">--*/</span>
11423 
11424 {
11425     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
11426     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> event;
11427     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
11428     IO_STATUS_BLOCK ioStatus;
11429     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
11430     BOOLEAN verifySkipped = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
11431     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> fsDeviceObject;
11432 
11433     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
11434 
11435     <span class="comment">//</span>
11436     <span class="comment">//  Acquire the DeviceObject lock.  Nothing in this routine can raise</span>
11437     <span class="comment">//  so no try {} finally {} is required.</span>
11438     <span class="comment">//</span>
11439 
11440     status = <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;DeviceObject-&gt;DeviceLock,
11441                                     <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
11442                                     <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
11443                                     <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
11444                                     (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
11445 
11446     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( status == STATUS_SUCCESS );
11447 
11448     <span class="comment">//</span>
11449     <span class="comment">// If this volume is not mounted by anyone, skip the verify operation,</span>
11450     <span class="comment">// but do the mount.</span>
11451     <span class="comment">//</span>
11452 
11453     <span class="keywordflow">if</span> (!(DeviceObject-&gt;Vpb-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a116">VPB_MOUNTED</a>)) {
11454 
11455         verifySkipped = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
11456 
11457         status = STATUS_SUCCESS;
11458 
11459     } <span class="keywordflow">else</span> {
11460 
11461         <span class="comment">//</span>
11462         <span class="comment">// This volume needs to be verified.  Initialize the event to be</span>
11463         <span class="comment">// used while waiting for the operation to complete.</span>
11464         <span class="comment">//</span>
11465 
11466         <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;event, NotificationEvent, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
11467         status = STATUS_UNSUCCESSFUL;
11468 
11469         <span class="comment">//</span>
11470         <span class="comment">// Allocate and initialize an IRP for this verify operation.  Notice</span>
11471         <span class="comment">// that the flags for this operation appear the same as a page read</span>
11472         <span class="comment">// operation.  This is because the completion code for both of the</span>
11473         <span class="comment">// operations is exactly the same logic.</span>
11474         <span class="comment">//</span>
11475 
11476         fsDeviceObject = DeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o10">Vpb</a>-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o4">DeviceObject</a>;
11477         <span class="keywordflow">while</span> (fsDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o5">AttachedDevice</a>) {
11478             fsDeviceObject = fsDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o5">AttachedDevice</a>;
11479         }
11480         irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a17">IoAllocateIrp</a>( fsDeviceObject-&gt;<a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html#o13">StackSize</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
11481         <span class="keywordflow">if</span> (!irp) {
11482 
11483             <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>( &amp;DeviceObject-&gt;DeviceLock, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
11484             <span class="keywordflow">return</span> STATUS_INSUFFICIENT_RESOURCES;
11485         }
11486         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a175">IRP_MOUNT_COMPLETION</a> | <a class="code" href="../../d0/d5/io_8h.html#a181">IRP_SYNCHRONOUS_PAGING_IO</a>;
11487         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o10">RequestorMode</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>;
11488         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = &amp;event;
11489         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = &amp;ioStatus;
11490         irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
11491         irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
11492         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a26">IRP_MJ_FILE_SYSTEM_CONTROL</a>;
11493         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o1">MinorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a48">IRP_MN_VERIFY_VOLUME</a>;
11494         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o2">Flags</a> = AllowRawMount ? <a class="code" href="../../d0/d5/io_8h.html#a212">SL_ALLOW_RAW_MOUNT</a> : 0;
11495         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.VerifyVolume.Vpb = DeviceObject-&gt;Vpb;
11496         irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o11">Parameters</a>.VerifyVolume.DeviceObject = DeviceObject-&gt;Vpb-&gt;DeviceObject;
11497 
11498         status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( fsDeviceObject, irp );
11499 
11500         <span class="comment">//          IopLoadFileSystemDriver</span>
11501         <span class="comment">// Wait for the I/O operation to complete.</span>
11502         <span class="comment">//</span>
11503 
11504         <span class="keywordflow">if</span> (status == STATUS_PENDING) {
11505             (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
11506                                           <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
11507                                           <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
11508                                           <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
11509                                           (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
11510             status = ioStatus.Status;
11511         }
11512     }
11513 
11514     <span class="comment">//</span>
11515     <span class="comment">// If the verify operation was skipped or unsuccessful perform a mount</span>
11516     <span class="comment">// operation.</span>
11517     <span class="comment">//</span>
11518 
11519     <span class="keywordflow">if</span> ((status == STATUS_WRONG_VOLUME) || verifySkipped) {
11520 
11521         <span class="comment">//</span>
11522         <span class="comment">// A mount operation is to be attempted.  Allocate a new VPB</span>
11523         <span class="comment">// for this device and attempt to mount it.  Note that at this</span>
11524         <span class="comment">// point, allowing allocation of the VPB to fail is simply too</span>
11525         <span class="comment">// difficult to deal with, so if one cannot be allocated normally,</span>
11526         <span class="comment">// allocate one specifying that it must succeed.</span>
11527         <span class="comment">//</span>
11528 
11529         <a class="code" href="../../d4/d6/iosubs_8c.html#a44">IopCreateVpb</a> (DeviceObject);
11530         <a class="code" href="../../d1/d2/po_8h.html#a70">PoVolumeDevice</a> (DeviceObject);
11531 
11532         <span class="comment">//</span>
11533         <span class="comment">// Now mount the volume.</span>
11534         <span class="comment">//</span>
11535 
11536         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d0/d6/iop_8h.html#a195">IopMountVolume</a>( DeviceObject, AllowRawMount, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> ) )) {
11537             DeviceObject-&gt;Flags &amp;= ~<a class="code" href="../../d0/d5/io_8h.html#a122">DO_VERIFY_VOLUME</a>;
11538         }
11539     }
11540 
11541     <span class="comment">//</span>
11542     <span class="comment">//  Release the device lock.</span>
11543     <span class="comment">//</span>
11544 
11545     <a class="code" href="../../d2/d8/eventobj_8c.html#a8">KeSetEvent</a>( &amp;DeviceObject-&gt;DeviceLock, 0, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
11546 
11547     <span class="comment">//</span>
11548     <span class="comment">// Return the status from the verify operation as the final status of</span>
11549     <span class="comment">// this function.</span>
11550     <span class="comment">//</span>
11551 
11552     <span class="keywordflow">return</span> status;
11553 }
11554 
11555 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l11556"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a123">11556</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a123">IoWriteErrorLogEntry</a>(
11557     IN OUT PVOID ElEntry
11558     )
11559 
11560 <span class="comment">/*++</span>
11561 <span class="comment"></span>
11562 <span class="comment">Routine Description:</span>
11563 <span class="comment"></span>
11564 <span class="comment">    This routine places the error log entry specified by the input argument</span>
11565 <span class="comment">    onto the queue of buffers to be written to the error log process's port.</span>
11566 <span class="comment">    The error log thread will then actually send it.</span>
11567 <span class="comment"></span>
11568 <span class="comment">Arguments:</span>
11569 <span class="comment"></span>
11570 <span class="comment">    ElEntry Pointer to the error log entry.</span>
11571 <span class="comment"></span>
11572 <span class="comment">Return Value:</span>
11573 <span class="comment"></span>
11574 <span class="comment">    None.</span>
11575 <span class="comment"></span>
11576 <span class="comment">--*/</span>
11577 
11578 {
11579     <a class="code" href="../../d8/d5/struct__ERROR__LOG__ENTRY.html">PERROR_LOG_ENTRY</a> entry;
11580     KIRQL oldIrql;
11581 
11582     <span class="comment">//</span>
11583     <span class="comment">// Get the address of the error log entry header, acquire the spin lock,</span>
11584     <span class="comment">// insert the entry onto the queue, if there are no pending requests</span>
11585     <span class="comment">// then queue a worker thread request and release the spin lock.</span>
11586     <span class="comment">//</span>
11587 
11588     entry = ((<a class="code" href="../../d8/d5/struct__ERROR__LOG__ENTRY.html">PERROR_LOG_ENTRY</a>) ElEntry) - 1;
11589 
11590     <span class="keywordflow">if</span> (<a class="code" href="../../d7/d7/errorlog_8c.html#a7">IopErrorLogDisabledThisBoot</a>) {
11591         <span class="comment">//</span>
11592         <span class="comment">// Do nothing, drop the reference.</span>
11593         <span class="comment">//</span>
11594 
11595         <span class="keywordflow">if</span> (entry-&gt;<a class="code" href="../../d8/d5/struct__ERROR__LOG__ENTRY.html#o3">DeviceObject</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
11596             <span class="comment">//</span>
11597             <span class="comment">// IopErrorLogThread tests for NULL before derefing.</span>
11598             <span class="comment">// So do the same here.</span>
11599             <span class="comment">//</span>
11600             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a> (entry-&gt;<a class="code" href="../../d8/d5/struct__ERROR__LOG__ENTRY.html#o3">DeviceObject</a>);
11601         }
11602         <span class="keywordflow">if</span> (entry-&gt;<a class="code" href="../../d8/d5/struct__ERROR__LOG__ENTRY.html#o4">DriverObject</a> != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
11603             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a> (entry-&gt;<a class="code" href="../../d8/d5/struct__ERROR__LOG__ENTRY.html#o4">DriverObject</a>);
11604         }
11605         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a> (entry);
11606         <span class="keywordflow">return</span>;
11607 
11608     }
11609 
11610     <span class="comment">//</span>
11611     <span class="comment">// Set the time that the entry was logged.</span>
11612     <span class="comment">//</span>
11613 
11614     <a class="code" href="../../d7/d0/ke_2miscc_8c.html#a3">KeQuerySystemTime</a>( (PVOID) &amp;entry-&gt;<a class="code" href="../../d8/d5/struct__ERROR__LOG__ENTRY.html#o5">TimeStamp</a> );
11615 
11616     ExAcquireSpinLock( &amp;<a class="code" href="../../d4/d4/alpha_2splocks_8c.html#a6">IopErrorLogLock</a>, &amp;oldIrql );
11617 
11618     <span class="comment">//</span>
11619     <span class="comment">// Queue the request to the error log queue.</span>
11620     <span class="comment">//</span>
11621 
11622     InsertTailList( &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a21">IopErrorLogListHead</a>, &amp;entry-&gt;<a class="code" href="../../d8/d5/struct__ERROR__LOG__ENTRY.html#o2">ListEntry</a> );
11623 
11624     <span class="comment">//</span>
11625     <span class="comment">// If there is no pending work, then queue a request to a worker thread.</span>
11626     <span class="comment">//</span>
11627 
11628     <span class="keywordflow">if</span> (!<a class="code" href="../../d7/d7/errorlog_8c.html#a6">IopErrorLogPortPending</a>) {
11629 
11630         <a class="code" href="../../d7/d7/errorlog_8c.html#a6">IopErrorLogPortPending</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
11631 
11632         <a class="code" href="../../d5/d8/ex_8h.html#a55">ExInitializeWorkItem</a>( &amp;<a class="code" href="../../d7/d7/errorlog_8c.html#a3">IopErrorLogWorkItem</a>, <a class="code" href="../../d7/d7/errorlog_8c.html#a13">IopErrorLogThread</a>, <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
11633         <a class="code" href="../../d5/d8/ex_8h.html#a261">ExQueueWorkItem</a>( &amp;<a class="code" href="../../d7/d7/errorlog_8c.html#a3">IopErrorLogWorkItem</a>, <a class="code" href="../../d5/d8/ex_8h.html#a332a206">DelayedWorkQueue</a> );
11634 
11635     }
11636 
11637     ExReleaseSpinLock(&amp;<a class="code" href="../../d4/d4/alpha_2splocks_8c.html#a6">IopErrorLogLock</a>, oldIrql);
11638 }
11639 
11640 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l11641"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a124">11641</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a124">IoGetBootDiskInformation</a>(
11642     IN OUT <a class="code" href="../../d9/d4/struct__BOOTDISK__INFORMATION.html">PBOOTDISK_INFORMATION</a> BootDiskInformation,
11643     IN ULONG Size
11644     )
11645 
11646 <span class="comment">/*++</span>
11647 <span class="comment"></span>
11648 <span class="comment">Routine Description:</span>
11649 <span class="comment"></span>
11650 <span class="comment">    This routine provides the caller with the signature and offset of</span>
11651 <span class="comment">    the boot disk and system disk. This information is obtained from the</span>
11652 <span class="comment">    loader block. The callers have to be boot drivers which have registered</span>
11653 <span class="comment">    for a callback once all disk devices have been started</span>
11654 <span class="comment">Arguments:</span>
11655 <span class="comment"></span>
11656 <span class="comment">    BootDiskInformation - Supplies a pointer to the structure allocated by the</span>
11657 <span class="comment">    caller for requested information.</span>
11658 <span class="comment">    Size - Size of the BootDiskInformation structure.</span>
11659 <span class="comment"></span>
11660 <span class="comment">Return Value:</span>
11661 <span class="comment"></span>
11662 <span class="comment">    STATUS_SUCCESS - successful.</span>
11663 <span class="comment">    STATUS_TOO_LATE - indicates that the Loader Block has already been freed</span>
11664 <span class="comment">    STATUS_INVALID_PARAMETER - size allocated for boot disk information</span>
11665 <span class="comment">    is insufficient.</span>
11666 <span class="comment"></span>
11667 <span class="comment">--*/</span>
11668 
11669 {
11670     <a class="code" href="../../d1/d2/struct__LOADER__PARAMETER__BLOCK.html">PLOADER_PARAMETER_BLOCK</a> LoaderBlock = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
11671     STRING arcBootDeviceString;
11672     UCHAR deviceNameBuffer[128];
11673     STRING deviceNameString;
11674     UNICODE_STRING deviceNameUnicodeString;
11675     <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> deviceObject;
11676     UCHAR arcNameBuffer[128];
11677     STRING arcNameString;
11678     UNICODE_STRING arcNameUnicodeString;
11679     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> fileObject;
11680     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
11681     IO_STATUS_BLOCK ioStatusBlock;
11682     DISK_GEOMETRY diskGeometry;
11683     PDRIVE_LAYOUT_INFORMATION driveLayout;
11684     PLIST_ENTRY listEntry;
11685     <a class="code" href="../../d3/d9/struct__ARC__DISK__SIGNATURE.html">PARC_DISK_SIGNATURE</a> diskBlock;
11686     ULONG diskNumber;
11687     ULONG partitionNumber;
11688     PCHAR arcName;
11689     PULONG buffer;
11690     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
11691     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> event;
11692     LARGE_INTEGER offset;
11693     ULONG checkSum;
11694     ULONG i;
11695     BOOLEAN singleBiosDiskFound;
11696     BOOLEAN bootDiskFound = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
11697     BOOLEAN systemDiskFound = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
11698     <a class="code" href="../../d2/d9/struct__ARC__DISK__INFORMATION.html">PARC_DISK_INFORMATION</a> arcInformation;
11699     ULONG totalDriverDisksFound = <a class="code" href="../../d4/d6/iosubs_8c.html#a69">IoGetConfigurationInformation</a>()-&gt;<a class="code" href="../../d6/d8/struct__CONFIGURATION__INFORMATION.html#o0">DiskCount</a>;
11700     STRING arcSystemDeviceString;
11701     STRING osLoaderPathString;
11702     UNICODE_STRING osLoaderPathUnicodeString;
11703     PARTITION_INFORMATION PartitionInfo;
11704 
11705     <span class="keywordflow">if</span> (<a class="code" href="../../d3/d5/iodata_8c.html#a73">IopLoaderBlock</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
11706         <span class="keywordflow">return</span> STATUS_TOO_LATE;
11707     }
11708 
11709     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> &lt; <span class="keyword">sizeof</span>(<a class="code" href="../../d9/d4/struct__BOOTDISK__INFORMATION.html">BOOTDISK_INFORMATION</a>)) {
11710         <span class="keywordflow">return</span> STATUS_INVALID_PARAMETER;
11711     }
11712 
11713     LoaderBlock = (<a class="code" href="../../d1/d2/struct__LOADER__PARAMETER__BLOCK.html">PLOADER_PARAMETER_BLOCK</a>)<a class="code" href="../../d3/d5/iodata_8c.html#a73">IopLoaderBlock</a>;
11714     arcInformation = LoaderBlock-&gt;<a class="code" href="../../d1/d2/struct__LOADER__PARAMETER__BLOCK.html#o16">ArcDiskInformation</a>;
11715 
11716     <span class="comment">//</span>
11717     <span class="comment">// If a single bios disk was found if there is only a</span>
11718     <span class="comment">// single entry on the disk signature list.</span>
11719     <span class="comment">//</span>
11720     singleBiosDiskFound = (arcInformation-&gt;<a class="code" href="../../d2/d9/struct__ARC__DISK__INFORMATION.html#o0">DiskSignatures</a>.Flink-&gt;Flink ==
11721                            &amp;arcInformation-&gt;<a class="code" href="../../d2/d9/struct__ARC__DISK__INFORMATION.html#o0">DiskSignatures</a>) ? (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) : (<a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
11722 
11723     <span class="comment">//</span>
11724     <span class="comment">// Get ARC boot device name from loader block.</span>
11725     <span class="comment">//</span>
11726 
11727     <a class="code" href="../../d2/d7/string_8c.html#a6">RtlInitAnsiString</a>( &amp;arcBootDeviceString,
11728                        LoaderBlock-&gt;<a class="code" href="../../d1/d2/struct__LOADER__PARAMETER__BLOCK.html#o10">ArcBootDeviceName</a> );
11729     <span class="comment">//</span>
11730     <span class="comment">// Get ARC system device name from loader block.</span>
11731     <span class="comment">//</span>
11732 
11733     <a class="code" href="../../d2/d7/string_8c.html#a6">RtlInitAnsiString</a>( &amp;arcSystemDeviceString,
11734                        LoaderBlock-&gt;<a class="code" href="../../d1/d2/struct__LOADER__PARAMETER__BLOCK.html#o11">ArcHalDeviceName</a> );
11735     <span class="comment">//</span>
11736     <span class="comment">// For each disk, get its drive layout and check to see if the</span>
11737     <span class="comment">// signature is among the list of signatures in the loader block.</span>
11738     <span class="comment">// If yes, check to see if the disk contains the boot or system</span>
11739     <span class="comment">// partitions. If yes, fill up the requested structure.</span>
11740     <span class="comment">//</span>
11741 
11742     <span class="keywordflow">for</span> (diskNumber = 0;
11743          diskNumber &lt; totalDriverDisksFound;
11744          diskNumber++) {
11745 
11746         <span class="comment">//</span>
11747         <span class="comment">// Construct the NT name for a disk and obtain a reference.</span>
11748         <span class="comment">//</span>
11749 
11750         <a class="code" href="../../d6/d9/heappage_8c.html#a68">sprintf</a>( deviceNameBuffer,
11751                  <span class="stringliteral">"\\Device\\Harddisk%d\\Partition0"</span>,
11752                  diskNumber );
11753         <a class="code" href="../../d2/d7/string_8c.html#a6">RtlInitAnsiString</a>( &amp;deviceNameString, deviceNameBuffer );
11754         status = <a class="code" href="../../d6/d6/nls_8c.html#a21">RtlAnsiStringToUnicodeString</a>( &amp;deviceNameUnicodeString,
11755                                                &amp;deviceNameString,
11756                                                <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
11757         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
11758             <span class="keywordflow">continue</span>;
11759         }
11760 
11761         status = <a class="code" href="../../d4/d6/iosubs_8c.html#a71">IoGetDeviceObjectPointer</a>( &amp;deviceNameUnicodeString,
11762                                            FILE_READ_ATTRIBUTES,
11763                                            &amp;fileObject,
11764                                            &amp;deviceObject );
11765         <a class="code" href="../../d6/d6/nls_8c.html#a34">RtlFreeUnicodeString</a>( &amp;deviceNameUnicodeString );
11766 
11767         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
11768             <span class="keywordflow">continue</span>;
11769         }
11770 
11771         <span class="comment">//</span>
11772         <span class="comment">// Create IRP for get drive geometry device control.</span>
11773         <span class="comment">//</span>
11774 
11775         irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a25">IoBuildDeviceIoControlRequest</a>( IOCTL_DISK_GET_DRIVE_GEOMETRY,
11776                                              deviceObject,
11777                                              <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
11778                                              0,
11779                                              &amp;diskGeometry,
11780                                              <span class="keyword">sizeof</span>(DISK_GEOMETRY),
11781                                              <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
11782                                              &amp;event,
11783                                              &amp;ioStatusBlock );
11784         <span class="keywordflow">if</span> (!irp) {
11785             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
11786             <span class="keywordflow">continue</span>;
11787         }
11788 
11789         <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;event,
11790                            NotificationEvent,
11791                            <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
11792         status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( deviceObject,
11793                                irp );
11794 
11795         <span class="keywordflow">if</span> (status == STATUS_PENDING) {
11796             <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
11797                                    <a class="code" href="../../d4/d9/ke_8h.html#a407a203">Suspended</a>,
11798                                    <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
11799                                    <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
11800                                    <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
11801             status = ioStatusBlock.Status;
11802         }
11803 
11804         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
11805             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
11806             <span class="keywordflow">continue</span>;
11807         }
11808 
11809         <span class="comment">//</span>
11810         <span class="comment">// Get partition information for this disk.</span>
11811         <span class="comment">//</span>
11812 
11813         status = <a class="code" href="../../d2/d7/hal_8h.html#a192">IoReadPartitionTable</a>( deviceObject,
11814                                        diskGeometry.BytesPerSector,
11815                                        <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
11816                                        &amp;driveLayout );
11817 
11818         <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
11819 
11820         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
11821             <span class="keywordflow">continue</span>;
11822         }
11823 
11824         <span class="comment">//</span>
11825         <span class="comment">// Make sure sector size is at least 512 bytes.</span>
11826         <span class="comment">//</span>
11827 
11828         <span class="keywordflow">if</span> (diskGeometry.BytesPerSector &lt; 512) {
11829             diskGeometry.BytesPerSector = 512;
11830         }
11831 
11832         <span class="comment">//</span>
11833         <span class="comment">// For each ARC disk information record in the loader block</span>
11834         <span class="comment">// match the disk signature and checksum to determine its ARC</span>
11835         <span class="comment">// name and construct the NT ARC names symbolic links.</span>
11836         <span class="comment">//</span>
11837 
11838         <span class="keywordflow">for</span> (listEntry = arcInformation-&gt;<a class="code" href="../../d2/d9/struct__ARC__DISK__INFORMATION.html#o0">DiskSignatures</a>.Flink;
11839              listEntry != &amp;arcInformation-&gt;<a class="code" href="../../d2/d9/struct__ARC__DISK__INFORMATION.html#o0">DiskSignatures</a>;
11840              listEntry = listEntry-&gt;Flink) {
11841 
11842             <span class="comment">//</span>
11843             <span class="comment">// Get next record and compare disk signatures.</span>
11844             <span class="comment">//</span>
11845 
11846             diskBlock = CONTAINING_RECORD( listEntry,
11847                                            <a class="code" href="../../d3/d9/struct__ARC__DISK__SIGNATURE.html">ARC_DISK_SIGNATURE</a>,
11848                                            ListEntry );
11849 
11850             <span class="comment">//</span>
11851             <span class="comment">// Compare disk signatures.</span>
11852             <span class="comment">//</span>
11853             <span class="comment">// Or if there is only a single disk drive from</span>
11854             <span class="comment">// both the bios and driver viewpoints then</span>
11855             <span class="comment">// assign an arc name to that drive.</span>
11856             <span class="comment">//</span>
11857 
11858             <span class="keywordflow">if</span> ((singleBiosDiskFound &amp;&amp; (totalDriverDisksFound == 1)) ||
11859                 (diskBlock-&gt;<a class="code" href="../../d3/d9/struct__ARC__DISK__SIGNATURE.html#o1">Signature</a> == driveLayout-&gt;Signature &amp;&amp;
11860                  diskBlock-&gt;<a class="code" href="../../d3/d9/struct__ARC__DISK__SIGNATURE.html#o4">ValidPartitionTable</a>)) {
11861 
11862                 <span class="comment">//</span>
11863                 <span class="comment">// Create unicode device name for physical disk.</span>
11864                 <span class="comment">//</span>
11865 
11866                 <a class="code" href="../../d6/d9/heappage_8c.html#a68">sprintf</a>( deviceNameBuffer,
11867                          <span class="stringliteral">"\\Device\\Harddisk%d\\Partition0"</span>,
11868                          diskNumber );
11869                 <a class="code" href="../../d2/d7/string_8c.html#a6">RtlInitAnsiString</a>( &amp;deviceNameString, deviceNameBuffer );
11870                 status = <a class="code" href="../../d6/d6/nls_8c.html#a21">RtlAnsiStringToUnicodeString</a>( &amp;deviceNameUnicodeString,
11871                                                        &amp;deviceNameString,
11872                                                        <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
11873                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
11874                     <span class="keywordflow">continue</span>;
11875                 }
11876 
11877                 <span class="comment">//</span>
11878                 <span class="comment">// Create unicode ARC name for this partition.</span>
11879                 <span class="comment">//</span>
11880 
11881                 arcName = diskBlock-&gt;<a class="code" href="../../d3/d9/struct__ARC__DISK__SIGNATURE.html#o2">ArcName</a>;
11882                 <a class="code" href="../../d6/d9/heappage_8c.html#a68">sprintf</a>( arcNameBuffer,
11883                          <span class="stringliteral">"\\ArcName\\%s"</span>,
11884                          arcName );
11885                 <a class="code" href="../../d2/d7/string_8c.html#a6">RtlInitAnsiString</a>( &amp;arcNameString, arcNameBuffer );
11886                 status = <a class="code" href="../../d6/d6/nls_8c.html#a21">RtlAnsiStringToUnicodeString</a>( &amp;arcNameUnicodeString,
11887                                                        &amp;arcNameString,
11888                                                        <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
11889                 <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
11890                     <span class="keywordflow">continue</span>;
11891                 }
11892 
11893                 <span class="comment">//</span>
11894                 <span class="comment">// Create an ARC name for every partition on this disk.</span>
11895                 <span class="comment">//</span>
11896 
11897                 <span class="keywordflow">for</span> (partitionNumber = 0;
11898                      partitionNumber &lt; driveLayout-&gt;PartitionCount;
11899                      partitionNumber++) {
11900 
11901                     <span class="comment">//</span>
11902                     <span class="comment">// Create unicode NT device name.</span>
11903                     <span class="comment">//</span>
11904 
11905                     <a class="code" href="../../d6/d9/heappage_8c.html#a68">sprintf</a>( deviceNameBuffer,
11906                              <span class="stringliteral">"\\Device\\Harddisk%d\\Partition%d"</span>,
11907                              diskNumber,
11908                              partitionNumber+1 );
11909                     <a class="code" href="../../d2/d7/string_8c.html#a6">RtlInitAnsiString</a>( &amp;deviceNameString, deviceNameBuffer );
11910                     status = <a class="code" href="../../d6/d6/nls_8c.html#a21">RtlAnsiStringToUnicodeString</a>(
11911                                                            &amp;deviceNameUnicodeString,
11912                                                            &amp;deviceNameString,
11913                                                            <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
11914                     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
11915                         <span class="keywordflow">continue</span>;
11916                     }
11917 
11918                     <span class="comment">//</span>
11919                     <span class="comment">// Create unicode ARC name for this partition and</span>
11920                     <span class="comment">// check to see if this is the boot disk.</span>
11921                     <span class="comment">//</span>
11922 
11923                     <a class="code" href="../../d6/d9/heappage_8c.html#a68">sprintf</a>( arcNameBuffer,
11924                              <span class="stringliteral">"%spartition(%d)"</span>,
11925                              arcName,
11926                              partitionNumber+1 );
11927                     <a class="code" href="../../d2/d7/string_8c.html#a6">RtlInitAnsiString</a>( &amp;arcNameString, arcNameBuffer );
11928                     <span class="keywordflow">if</span> (<a class="code" href="../../d2/d7/string_8c.html#a11">RtlEqualString</a>( &amp;arcNameString,
11929                                         &amp;arcBootDeviceString,
11930                                         <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> )) {
11931                         BootDiskInformation-&gt;BootDeviceSignature =
11932                                                       driveLayout-&gt;Signature;
11933                         <span class="comment">//</span>
11934                         <span class="comment">// Get Partition Information for the offset of the</span>
11935                         <span class="comment">// partition within the disk</span>
11936                         <span class="comment">//</span>
11937                         status = <a class="code" href="../../d4/d6/iosubs_8c.html#a71">IoGetDeviceObjectPointer</a>(
11938                                            &amp;deviceNameUnicodeString,
11939                                            FILE_READ_ATTRIBUTES,
11940                                            &amp;fileObject,
11941                                            &amp;deviceObject );
11942                         <a class="code" href="../../d6/d6/nls_8c.html#a34">RtlFreeUnicodeString</a>( &amp;deviceNameUnicodeString );
11943 
11944                         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
11945                             <span class="keywordflow">continue</span>;
11946                         }
11947 
11948                         <span class="comment">//</span>
11949                         <span class="comment">// Create IRP for get drive geometry device control.</span>
11950                         <span class="comment">//</span>
11951 
11952                         irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a25">IoBuildDeviceIoControlRequest</a>(
11953                                              IOCTL_DISK_GET_PARTITION_INFO,
11954                                              deviceObject,
11955                                              <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
11956                                              0,
11957                                              &amp;PartitionInfo,
11958                                              <span class="keyword">sizeof</span>(PARTITION_INFORMATION),
11959                                              <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
11960                                              &amp;event,
11961                                              &amp;ioStatusBlock );
11962                         <span class="keywordflow">if</span> (!irp) {
11963                             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
11964                             <span class="keywordflow">continue</span>;
11965                         }
11966 
11967                         <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;event,
11968                                            NotificationEvent,
11969                                            <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
11970                         status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( deviceObject,
11971                                                irp );
11972 
11973                         <span class="keywordflow">if</span> (status == STATUS_PENDING) {
11974                             <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
11975                                                    <a class="code" href="../../d4/d9/ke_8h.html#a407a203">Suspended</a>,
11976                                                    <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
11977                                                    <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
11978                                                    <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
11979                             status = ioStatusBlock.Status;
11980                         }
11981 
11982                         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
11983                             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
11984                             <span class="keywordflow">continue</span>;
11985                         }
11986                         BootDiskInformation-&gt;BootPartitionOffset =
11987                                         PartitionInfo.StartingOffset.QuadPart;
11988                         bootDiskFound = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
11989                     }
11990 
11991                     <span class="comment">//</span>
11992                     <span class="comment">// See if this is the system partition.</span>
11993                     <span class="comment">//</span>
11994                     <span class="keywordflow">if</span> (<a class="code" href="../../d2/d7/string_8c.html#a11">RtlEqualString</a>( &amp;arcNameString,
11995                                         &amp;arcSystemDeviceString,
11996                                         <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> )) {
11997                         BootDiskInformation-&gt;SystemDeviceSignature =
11998                                                       driveLayout-&gt;Signature;
11999                         <span class="comment">//</span>
12000                         <span class="comment">// Get Partition Information for the offset of the</span>
12001                         <span class="comment">// partition within the disk</span>
12002                         <span class="comment">//</span>
12003                         status = <a class="code" href="../../d4/d6/iosubs_8c.html#a71">IoGetDeviceObjectPointer</a>(
12004                                            &amp;deviceNameUnicodeString,
12005                                            FILE_READ_ATTRIBUTES,
12006                                            &amp;fileObject,
12007                                            &amp;deviceObject );
12008                         <a class="code" href="../../d6/d6/nls_8c.html#a34">RtlFreeUnicodeString</a>( &amp;deviceNameUnicodeString );
12009 
12010                         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
12011                             <span class="keywordflow">continue</span>;
12012                         }
12013 
12014                         <span class="comment">//</span>
12015                         <span class="comment">// Create IRP for get drive geometry device control.</span>
12016                         <span class="comment">//</span>
12017 
12018                         irp = <a class="code" href="../../d4/d6/iosubs_8c.html#a25">IoBuildDeviceIoControlRequest</a>(
12019                                              IOCTL_DISK_GET_PARTITION_INFO,
12020                                              deviceObject,
12021                                              <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>,
12022                                              0,
12023                                              &amp;PartitionInfo,
12024                                              <span class="keyword">sizeof</span>(PARTITION_INFORMATION),
12025                                              <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
12026                                              &amp;event,
12027                                              &amp;ioStatusBlock );
12028                         <span class="keywordflow">if</span> (!irp) {
12029                             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
12030                             <span class="keywordflow">continue</span>;
12031                         }
12032 
12033                         <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;event,
12034                                            NotificationEvent,
12035                                            <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
12036                         status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( deviceObject,
12037                                                irp );
12038 
12039                         <span class="keywordflow">if</span> (status == STATUS_PENDING) {
12040                             <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
12041                                                    <a class="code" href="../../d4/d9/ke_8h.html#a407a203">Suspended</a>,
12042                                                    <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
12043                                                    <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
12044                                                    <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
12045                             status = ioStatusBlock.Status;
12046                         }
12047 
12048                         <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status )) {
12049                             <a class="code" href="../../d4/d0/ob_8h.html#a14">ObDereferenceObject</a>( fileObject );
12050                             <span class="keywordflow">continue</span>;
12051                         }
12052                         BootDiskInformation-&gt;SystemPartitionOffset =
12053                                         PartitionInfo.StartingOffset.QuadPart;
12054                         systemDiskFound = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
12055                     }
12056                 }
12057             }
12058         }
12059         <a class="code" href="../../d5/d8/ex_8h.html#a224">ExFreePool</a>( driveLayout );
12060     }
12061     <span class="keywordflow">return</span> STATUS_SUCCESS;
12062 }
12063 
12064 <span class="comment">//</span>
12065 <span class="comment">// Thunks to support standard call callers</span>
12066 <span class="comment">//</span>
12067 
12068 <span class="preprocessor">#ifdef IoCallDriver</span>
12069 <span class="preprocessor"></span><span class="preprocessor">#undef IoCallDriver</span>
12070 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
12071 <span class="preprocessor"></span>
12072 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l12073"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a125">12073</a> <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>(
12074     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
12075     IN OUT <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp
12076     )
12077 {
12078     <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/iosubs_8c.html#a29">IofCallDriver</a> (DeviceObject, <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>);
12079 }
12080 
12081 
12082 
12083 <span class="preprocessor">#ifdef IoCompleteRequest</span>
12084 <span class="preprocessor"></span><span class="preprocessor">#undef IoCompleteRequest</span>
12085 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
12086 <span class="preprocessor"></span>
12087 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l12088"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a126">12088</a> <a class="code" href="../../d0/d5/io_8h.html#a224">IoCompleteRequest</a>(
12089     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
12090     IN CCHAR PriorityBoost
12091     )
12092 {
12093     <a class="code" href="../../d4/d6/iosubs_8c.html#a39">IofCompleteRequest</a> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>, <a class="code" href="../../d0/d6/iop_8h.html#a36">PriorityBoost</a>);
12094 }
12095 
12096 
12097 PSECURITY_DESCRIPTOR
<a name="l12098"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a127">12098</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a127">IopCreateDefaultDeviceSecurityDescriptor</a>(
12099     IN DEVICE_TYPE DeviceType,
12100     IN ULONG DeviceCharacteristics,
12101     IN BOOLEAN DeviceHasName,
12102     IN PUCHAR Buffer,
12103     OUT PACL *AllocatedAcl,
12104     OUT PSECURITY_INFORMATION SecurityInformation OPTIONAL
12105     )
12106 {
12107     PSECURITY_DESCRIPTOR descriptor = (PSECURITY_DESCRIPTOR) <a class="code" href="../../d6/d2/rtqkey_8c.html#a3">Buffer</a>;
12108 
12109     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
12110 
12111     <span class="keywordflow">if</span>(ARGUMENT_PRESENT(SecurityInformation)) {
12112         (*SecurityInformation) = 0;
12113     }
12114 
12115     *AllocatedAcl = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
12116 
12117     <span class="keywordflow">switch</span> ( DeviceType ) {
12118 
12119         <span class="keywordflow">case</span> FILE_DEVICE_DISK_FILE_SYSTEM:
12120         <span class="keywordflow">case</span> FILE_DEVICE_CD_ROM_FILE_SYSTEM:
12121         <span class="keywordflow">case</span> FILE_DEVICE_FILE_SYSTEM:
12122         <span class="keywordflow">case</span> FILE_DEVICE_TAPE_FILE_SYSTEM: {
12123 
12124             <span class="comment">//</span>
12125             <span class="comment">// Use the standard public default protection for these types of devices.</span>
12126             <span class="comment">//</span>
12127 
12128             <a class="code" href="../../d8/d6/sertl_8c.html#a53">RtlCreateSecurityDescriptor</a>(descriptor,
12129                                         SECURITY_DESCRIPTOR_REVISION );
12130 
12131             <a class="code" href="../../d8/d6/sertl_8c.html#a60">RtlSetDaclSecurityDescriptor</a>(descriptor,
12132                                          <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
12133                                          <a class="code" href="../../d0/d5/se_8h.html#a74">SePublicDefaultUnrestrictedDacl</a>,
12134                                          <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
12135 
12136             <span class="keywordflow">if</span>(ARGUMENT_PRESENT(SecurityInformation)) {
12137                 (*SecurityInformation) |= DACL_SECURITY_INFORMATION;
12138             }
12139 
12140             <span class="keywordflow">break</span>;
12141         }
12142 
12143         <span class="keywordflow">case</span> FILE_DEVICE_CD_ROM:
12144         <span class="keywordflow">case</span> FILE_DEVICE_MASS_STORAGE:
12145         <span class="keywordflow">case</span> FILE_DEVICE_DISK:
12146         <span class="keywordflow">case</span> FILE_DEVICE_VIRTUAL_DISK:
12147         <span class="keywordflow">case</span> FILE_DEVICE_NETWORK_FILE_SYSTEM:
12148         <span class="keywordflow">case</span> FILE_DEVICE_DFS_FILE_SYSTEM:
12149         <span class="keywordflow">case</span> FILE_DEVICE_NETWORK: {
12150 
12151             <span class="keywordflow">if</span> ((DeviceHasName) &amp;&amp;
12152                 ((DeviceCharacteristics &amp; FILE_FLOPPY_DISKETTE) != 0)) {
12153 
12154                 status = <a class="code" href="../../d8/d6/sertl_8c.html#a53">RtlCreateSecurityDescriptor</a>(
12155                             descriptor,
12156                             SECURITY_DESCRIPTOR_REVISION );
12157 
12158                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status ) );
12159 
12160                 status = <a class="code" href="../../d8/d6/sertl_8c.html#a60">RtlSetDaclSecurityDescriptor</a>(
12161                             descriptor,
12162                             <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
12163                             <a class="code" href="../../d0/d5/se_8h.html#a76">SePublicOpenUnrestrictedDacl</a>,
12164                             <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
12165 
12166                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status ) );
12167 
12168                 <span class="keywordflow">if</span>(ARGUMENT_PRESENT(SecurityInformation)) {
12169                     (*SecurityInformation) |= DACL_SECURITY_INFORMATION;
12170                 }
12171 
12172             } <span class="keywordflow">else</span> {
12173 
12174                 UCHAR i;
12175                 PACL acl;
12176                 BOOLEAN aceFound;
12177                 BOOLEAN aceFoundForCDROM;
12178                 PACCESS_ALLOWED_ACE ace;
12179 
12180                 <span class="comment">//</span>
12181                 <span class="comment">// Protect the device so that an administrator can run chkdsk</span>
12182                 <span class="comment">// on it. This is done by making a copy of the default public</span>
12183                 <span class="comment">// ACL and changing the accesses granted to the administrators</span>
12184                 <span class="comment">// alias.</span>
12185                 <span class="comment">//</span>
12186                 <span class="comment">// The logic here is:</span>
12187                 <span class="comment">//</span>
12188                 <span class="comment">//      - Copy the public default dacl into another buffer</span>
12189                 <span class="comment">//</span>
12190                 <span class="comment">//      - Find the ACE granting ADMINISTRATORS access</span>
12191                 <span class="comment">//</span>
12192                 <span class="comment">//      - Change the granted access mask of that ACE to give</span>
12193                 <span class="comment">//        administrators write access.</span>
12194                 <span class="comment">//</span>
12195                 <span class="comment">//</span>
12196 
12197                 acl = <a class="code" href="../../d5/d8/ex_8h.html#a4">ExAllocatePoolWithTag</a>(
12198                         <a class="code" href="../../d5/d8/ex_8h.html#a329a174">PagedPool</a>,
12199                         <a class="code" href="../../d0/d5/se_8h.html#a74">SePublicDefaultUnrestrictedDacl</a>-&gt;AclSize,
12200                         'eSoI' );
12201 
12202                 <span class="keywordflow">if</span> (!acl) {
12203                     <span class="keywordflow">return</span> <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
12204                 }
12205 
12206                 RtlCopyMemory( acl,
12207                                <a class="code" href="../../d0/d5/se_8h.html#a74">SePublicDefaultUnrestrictedDacl</a>,
12208                                <a class="code" href="../../d0/d5/se_8h.html#a74">SePublicDefaultUnrestrictedDacl</a>-&gt;AclSize );
12209 
12210                 <span class="comment">//</span>
12211                 <span class="comment">// Find the Administrators ACE</span>
12212                 <span class="comment">//</span>
12213 
12214                 aceFound = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
12215                 aceFoundForCDROM = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
12216 
12217                 <span class="keywordflow">for</span> ( i = 0, status = <a class="code" href="../../d2/d4/acledit_8c.html#a12">RtlGetAce</a>(acl, 0, &amp;ace);
12218                       <a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>(status);
12219                       i++, status = <a class="code" href="../../d2/d4/acledit_8c.html#a12">RtlGetAce</a>(acl, i, &amp;ace)) {
12220 
12221                     PSID sid;
12222 
12223                     sid = &amp;(ace-&gt;SidStart);
12224                     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d6/sertl_8c.html#a36">RtlEqualSid</a>( <a class="code" href="../../d0/d5/se_8h.html#a56">SeAliasAdminsSid</a>, sid )) {
12225                         PACCESS_MASK mask;
12226 
12227                         ace-&gt;Mask |= ( GENERIC_READ |
12228                                        GENERIC_WRITE |
12229                                        GENERIC_EXECUTE );
12230 
12231                         aceFound = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
12232                     }
12233 
12234                     <span class="keywordflow">if</span> (DeviceType == FILE_DEVICE_CD_ROM) {
12235 
12236                          <span class="keywordflow">if</span> (<a class="code" href="../../d8/d6/sertl_8c.html#a36">RtlEqualSid</a>( <a class="code" href="../../d0/d5/se_8h.html#a42">SeWorldSid</a>, sid )) {
12237                              ace-&gt;Mask |= GENERIC_READ;
12238                              aceFoundForCDROM = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
12239                          }
12240                      }
12241                 }
12242 
12243                 <span class="comment">//</span>
12244                 <span class="comment">// If the ACE wasn't found, then the public default ACL has been</span>
12245                 <span class="comment">// changed.  For this case, this code needs to be updated to match</span>
12246                 <span class="comment">// the new public default DACL.</span>
12247                 <span class="comment">//</span>
12248 
12249                 <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(aceFound == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
12250 
12251                 <span class="keywordflow">if</span> (DeviceType == FILE_DEVICE_CD_ROM) {
12252                     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(aceFoundForCDROM == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>);
12253                 }
12254 
12255                 <span class="comment">//</span>
12256                 <span class="comment">// Finally, build a full security descriptor from the above DACL.</span>
12257                 <span class="comment">//</span>
12258 
12259                 <a class="code" href="../../d8/d6/sertl_8c.html#a53">RtlCreateSecurityDescriptor</a>( descriptor,
12260                                              SECURITY_DESCRIPTOR_REVISION );
12261 
12262                 <a class="code" href="../../d8/d6/sertl_8c.html#a60">RtlSetDaclSecurityDescriptor</a>( descriptor,
12263                                               <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
12264                                               acl,
12265                                               <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
12266 
12267                 <span class="keywordflow">if</span>(ARGUMENT_PRESENT(SecurityInformation)) {
12268                     (*SecurityInformation) |= DACL_SECURITY_INFORMATION;
12269                 }
12270 
12271                 *AllocatedAcl = acl;
12272             }
12273 
12274             <span class="keywordflow">break</span>;
12275         }
12276 
12277         <span class="keywordflow">default</span>: {
12278 
12279             status = <a class="code" href="../../d8/d6/sertl_8c.html#a53">RtlCreateSecurityDescriptor</a>( descriptor,
12280                                                   SECURITY_DESCRIPTOR_REVISION );
12281             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( status ) );
12282 
12283             status = <a class="code" href="../../d8/d6/sertl_8c.html#a60">RtlSetDaclSecurityDescriptor</a>( descriptor,
12284                                                    <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>,
12285                                                    <a class="code" href="../../d0/d5/se_8h.html#a76">SePublicOpenUnrestrictedDacl</a>,
12286                                                    <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
12287 
12288             <span class="keywordflow">if</span>(ARGUMENT_PRESENT(SecurityInformation)) {
12289                 (*SecurityInformation) |= DACL_SECURITY_INFORMATION;
12290             }
12291 
12292             <span class="keywordflow">break</span>;
12293         }
12294     }
12295 
12296     <span class="keywordflow">return</span> descriptor;
12297 }
12298 
12299 
12300 <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a>
<a name="l12301"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a128">12301</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a128">IoGetRequestorSessionId</a>(
12302     IN <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> Irp,
12303     OUT PULONG pSessionId
12304     )
12305 
12306 <span class="comment">/*++</span>
12307 <span class="comment"></span>
12308 <span class="comment">Routine Description:</span>
12309 <span class="comment"></span>
12310 <span class="comment">    This routine returns the session ID for process that originally</span>
12311 <span class="comment">    requested the specified I/O operation.</span>
12312 <span class="comment"></span>
12313 <span class="comment">Arguments:</span>
12314 <span class="comment"></span>
12315 <span class="comment">    Irp - Pointer to the I/O Request Packet.</span>
12316 <span class="comment"></span>
12317 <span class="comment">    pSessionId - Pointer to the session Id which is set upon successful return.</span>
12318 <span class="comment"></span>
12319 <span class="comment">Return Value:</span>
12320 <span class="comment"></span>
12321 <span class="comment">    Returns STATUS_SUCCESS if the session ID was available, otherwise</span>
12322 <span class="comment">    STATUS_UNSUCCESSFUL.</span>
12323 <span class="comment"></span>
12324 <span class="comment">--*/</span>
12325 
12326 {
12327     <a class="code" href="../../d0/d4/struct__EPROCESS.html">PEPROCESS</a> Process;
12328 
12329     <span class="comment">//</span>
12330     <span class="comment">// Get the address of the process that requested the I/O operation.</span>
12331     <span class="comment">//</span>
12332 
12333     <span class="keywordflow">if</span> (<a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread) {
12334         Process = <a class="code" href="../../d1/d9/ps_8h.html#a17">THREAD_TO_PROCESS</a>( <a class="code" href="../../d0/d6/iop_8h.html#a35">Irp</a>-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread );
12335         *pSessionId = Process-&gt;<a class="code" href="../../d0/d4/struct__EPROCESS.html#o60">SessionId</a>;
12336         <span class="keywordflow">return</span>(STATUS_SUCCESS);
12337     }
12338 
12339     *pSessionId = (ULONG) -1;
12340     <span class="keywordflow">return</span>(STATUS_UNSUCCESSFUL);
12341 }
12342 
12343 
12344 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l12345"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a129">12345</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a129">IopUpdateOtherOperationCount</a>(
12346     VOID
12347     )
12348 <span class="comment">/*++</span>
12349 <span class="comment"></span>
12350 <span class="comment">Routine Description:</span>
12351 <span class="comment"></span>
12352 <span class="comment">    This routine is invoked to update the operation count for the current</span>
12353 <span class="comment">    process to indicate that an I/O service other than a read or write</span>
12354 <span class="comment">    has been invoked.</span>
12355 <span class="comment"></span>
12356 <span class="comment">    There is an implicit assumption that this call is always made in the context</span>
12357 <span class="comment">    of the issuing thread.</span>
12358 <span class="comment"></span>
12359 <span class="comment">Arguments:</span>
12360 <span class="comment"></span>
12361 <span class="comment">    None.</span>
12362 <span class="comment"></span>
12363 <span class="comment">Return Value:</span>
12364 <span class="comment"></span>
12365 <span class="comment">    None.</span>
12366 <span class="comment"></span>
12367 <span class="comment">--*/</span>
12368 {
12369     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a55">IoCountOperations</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
12370         <a class="code" href="../../d0/d5/io_8h.html#a382">IoOtherOperationCount</a> += 1;
12371         <a class="code" href="../../d5/d8/ex_8h.html#a233">ExInterlockedAddLargeStatistic</a>( &amp;<a class="code" href="../../d1/d9/ps_8h.html#a17">THREAD_TO_PROCESS</a>(<a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>())-&gt;OtherOperationCount, 1);
12372     }
12373 }
12374 
12375 
12376 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l12377"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a130">12377</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a130">IopUpdateReadOperationCount</a>(
12378     VOID
12379     )
12380 
12381 <span class="comment">/*++</span>
12382 <span class="comment"></span>
12383 <span class="comment">Routine Description:</span>
12384 <span class="comment"></span>
12385 <span class="comment">    This routine is invoked to update the read operation count for the</span>
12386 <span class="comment">    current process to indicate that the NtReadFile system service has</span>
12387 <span class="comment">    been invoked.</span>
12388 <span class="comment"></span>
12389 <span class="comment">    There is an implicit assumption that this call is always made in the context</span>
12390 <span class="comment">    of the issuing thread.</span>
12391 <span class="comment"></span>
12392 <span class="comment">Arguments:</span>
12393 <span class="comment"></span>
12394 <span class="comment">    None.</span>
12395 <span class="comment"></span>
12396 <span class="comment">Return Value:</span>
12397 <span class="comment"></span>
12398 <span class="comment">    None.</span>
12399 <span class="comment"></span>
12400 <span class="comment">--*/</span>
12401 {
12402     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a55">IoCountOperations</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
12403         <a class="code" href="../../d0/d5/io_8h.html#a380">IoReadOperationCount</a> += 1;
12404         <a class="code" href="../../d5/d8/ex_8h.html#a233">ExInterlockedAddLargeStatistic</a>( &amp;<a class="code" href="../../d1/d9/ps_8h.html#a17">THREAD_TO_PROCESS</a>(<a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>())-&gt;ReadOperationCount, 1);
12405     }
12406 }
12407 
12408 
12409 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l12410"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a131">12410</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a131">IopUpdateWriteOperationCount</a>(
12411     VOID
12412     )
12413 <span class="comment">/*++</span>
12414 <span class="comment"></span>
12415 <span class="comment">Routine Description:</span>
12416 <span class="comment"></span>
12417 <span class="comment">    This routine is invoked to update the write operation count for the</span>
12418 <span class="comment">    current process to indicate that the NtWriteFile service other has</span>
12419 <span class="comment">    been invoked.</span>
12420 <span class="comment"></span>
12421 <span class="comment">    There is an implicit assumption that this call is always made in the context</span>
12422 <span class="comment">    of the issuing thread.</span>
12423 <span class="comment"></span>
12424 <span class="comment">Arguments:</span>
12425 <span class="comment"></span>
12426 <span class="comment">    None.</span>
12427 <span class="comment"></span>
12428 <span class="comment">Return Value:</span>
12429 <span class="comment"></span>
12430 <span class="comment">    None.</span>
12431 <span class="comment"></span>
12432 <span class="comment">--*/</span>
12433 {
12434     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a55">IoCountOperations</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
12435         <a class="code" href="../../d0/d5/io_8h.html#a381">IoWriteOperationCount</a> += 1;
12436         <a class="code" href="../../d5/d8/ex_8h.html#a233">ExInterlockedAddLargeStatistic</a>( &amp;<a class="code" href="../../d1/d9/ps_8h.html#a17">THREAD_TO_PROCESS</a>(<a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>())-&gt;WriteOperationCount, 1);
12437     }
12438 }
12439 
12440 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l12441"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a132">12441</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a132">IopUpdateOtherTransferCount</a>(
12442     IN ULONG TransferCount
12443     )
12444 <span class="comment">/*++</span>
12445 <span class="comment"></span>
12446 <span class="comment">Routine Description:</span>
12447 <span class="comment"></span>
12448 <span class="comment">    This routine is invoked to update the transfer count for the current</span>
12449 <span class="comment">    process for an operation other than a read or write system service.</span>
12450 <span class="comment"></span>
12451 <span class="comment">    There is an implicit assumption that this call is always made in the context</span>
12452 <span class="comment">    of the issuing thread. Also note that overflow is folded into the thread's</span>
12453 <span class="comment">    process.</span>
12454 <span class="comment"></span>
12455 <span class="comment">Arguments:</span>
12456 <span class="comment"></span>
12457 <span class="comment">    TransferCount - The count of the number of bytes transferred.</span>
12458 <span class="comment"></span>
12459 <span class="comment">Return Value:</span>
12460 <span class="comment"></span>
12461 <span class="comment">    None.</span>
12462 <span class="comment"></span>
12463 <span class="comment">--*/</span>
12464 {
12465     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a55">IoCountOperations</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
12466         <a class="code" href="../../d5/d8/ex_8h.html#a233">ExInterlockedAddLargeStatistic</a>( &amp;<a class="code" href="../../d0/d5/io_8h.html#a385">IoOtherTransferCount</a>, TransferCount );
12467         <a class="code" href="../../d5/d8/ex_8h.html#a233">ExInterlockedAddLargeStatistic</a>( &amp;<a class="code" href="../../d1/d9/ps_8h.html#a17">THREAD_TO_PROCESS</a>(<a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>())-&gt;OtherTransferCount, TransferCount);
12468     }
12469 }
12470 
12471 
12472 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l12473"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a133">12473</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a133">IopUpdateReadTransferCount</a>(
12474     IN ULONG TransferCount
12475     )
12476 <span class="comment">/*++</span>
12477 <span class="comment"></span>
12478 <span class="comment">Routine Description:</span>
12479 <span class="comment"></span>
12480 <span class="comment">    This routine is invoked to update the read transfer count for the</span>
12481 <span class="comment">    current process.</span>
12482 <span class="comment"></span>
12483 <span class="comment">    There is an implicit assumption that this call is always made in the context</span>
12484 <span class="comment">    of the issuing thread. Also note that overflow is folded into the thread's</span>
12485 <span class="comment">    process.</span>
12486 <span class="comment"></span>
12487 <span class="comment">Arguments:</span>
12488 <span class="comment"></span>
12489 <span class="comment">    TransferCount - The count of the number of bytes transferred.</span>
12490 <span class="comment"></span>
12491 <span class="comment">Return Value:</span>
12492 <span class="comment"></span>
12493 <span class="comment">    None.</span>
12494 <span class="comment"></span>
12495 <span class="comment">--*/</span>
12496 {
12497     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a55">IoCountOperations</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
12498         <a class="code" href="../../d5/d8/ex_8h.html#a233">ExInterlockedAddLargeStatistic</a>( &amp;<a class="code" href="../../d0/d5/io_8h.html#a383">IoReadTransferCount</a>, TransferCount );
12499         <a class="code" href="../../d5/d8/ex_8h.html#a233">ExInterlockedAddLargeStatistic</a>( &amp;<a class="code" href="../../d1/d9/ps_8h.html#a17">THREAD_TO_PROCESS</a>(<a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>())-&gt;ReadTransferCount, TransferCount);
12500     }
12501 }
12502 
12503 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l12504"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a134">12504</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a134">IopUpdateWriteTransferCount</a>(
12505     IN ULONG TransferCount
12506     )
12507 <span class="comment">/*++</span>
12508 <span class="comment"></span>
12509 <span class="comment">Routine Description:</span>
12510 <span class="comment"></span>
12511 <span class="comment">    This routine is invoked to update the write transfer count for the</span>
12512 <span class="comment">    current process.</span>
12513 <span class="comment"></span>
12514 <span class="comment">    There is an implicit assumption that this call is always made in the context</span>
12515 <span class="comment">    of the issuing thread. Also note that overflow is folded into the thread's</span>
12516 <span class="comment">    process.</span>
12517 <span class="comment"></span>
12518 <span class="comment">Arguments:</span>
12519 <span class="comment"></span>
12520 <span class="comment">    TransferCount - The count of the number of bytes transferred.</span>
12521 <span class="comment"></span>
12522 <span class="comment">Return Value:</span>
12523 <span class="comment"></span>
12524 <span class="comment">    None.</span>
12525 <span class="comment"></span>
12526 <span class="comment">--*/</span>
12527 {
12528     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/cmdat3_8c.html#a55">IoCountOperations</a> == <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
12529         <a class="code" href="../../d5/d8/ex_8h.html#a233">ExInterlockedAddLargeStatistic</a>( &amp;<a class="code" href="../../d0/d5/io_8h.html#a384">IoWriteTransferCount</a>, TransferCount );
12530         <a class="code" href="../../d5/d8/ex_8h.html#a233">ExInterlockedAddLargeStatistic</a>( &amp;<a class="code" href="../../d1/d9/ps_8h.html#a17">THREAD_TO_PROCESS</a>(<a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>())-&gt;WriteTransferCount, TransferCount);
12531     }
12532 }
12533 
12534 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l12535"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a135">12535</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a135">IoCancelFileOpen</a>(
12536     IN <a class="code" href="../../d8/d4/struct__DEVICE__OBJECT.html">PDEVICE_OBJECT</a> DeviceObject,
12537     IN <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> FileObject
12538     )
12539 <span class="comment">/*++</span>
12540 <span class="comment"></span>
12541 <span class="comment">Routine Description:</span>
12542 <span class="comment"></span>
12543 <span class="comment">    This routine is invoked by a filter driver to send a close to the</span>
12544 <span class="comment">    next filesystem driver below. It's needed as part of the file open</span>
12545 <span class="comment">    process. The filter driver forwards the open to the FSD and the FSD</span>
12546 <span class="comment">    returns success. The filter driver then examines some stuff and</span>
12547 <span class="comment">    decides that the open has to be failed. In this case it has to send</span>
12548 <span class="comment">    a close to the FSD.</span>
12549 <span class="comment"></span>
12550 <span class="comment">    We can safely assume a thread context because it has to be called only</span>
12551 <span class="comment">    in the context of file open. If the file object already has a handle</span>
12552 <span class="comment">    then the owner of the handle can then simply close the handle to the</span>
12553 <span class="comment">    file object and we will close the file.</span>
12554 <span class="comment"></span>
12555 <span class="comment">    This code is extracted from IopCloseFile and IopDeleteFile. So it is</span>
12556 <span class="comment">    duplication of code but it prevents duplication elsewhere in other FSDs.</span>
12557 <span class="comment"></span>
12558 <span class="comment">Arguments:</span>
12559 <span class="comment"></span>
12560 <span class="comment">    FileObject - Points to the file that needs to be closed.</span>
12561 <span class="comment"></span>
12562 <span class="comment">    DeviceObject - Points to the device object of the filesystem driver below</span>
12563 <span class="comment">        the filter driver.</span>
12564 <span class="comment"></span>
12565 <span class="comment">Return Value:</span>
12566 <span class="comment"></span>
12567 <span class="comment">    None</span>
12568 <span class="comment"></span>
12569 <span class="comment">--*/</span>
12570 
12571 {
12572     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
12573     <a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html">PIO_STACK_LOCATION</a> irpSp;
12574     <a class="code" href="../../d5/d9/struct__FAST__IO__DISPATCH.html">PFAST_IO_DISPATCH</a> fastIoDispatch;
12575     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> status;
12576     <a class="code" href="../../d2/d6/struct__KEVENT.html">KEVENT</a> event;
12577     KIRQL irql;
12578     IO_STATUS_BLOCK ioStatusBlock;
12579     <a class="code" href="../../d7/d7/struct__VPB.html">PVPB</a> vpb;
12580     BOOLEAN referenceCountDecremented;
12581 
12582 
12583     <span class="comment">//</span>
12584     <span class="comment">// Cannot call this function if a handle has already been created</span>
12585     <span class="comment">// for this file.</span>
12586     <span class="comment">//</span>
12587     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(!(FileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a168">FO_HANDLE_CREATED</a>));
12588 
12589     <span class="comment">//</span>
12590     <span class="comment">// Initialize the local event that will be used to synchronize access</span>
12591     <span class="comment">// to the driver completing this I/O operation.</span>
12592     <span class="comment">//</span>
12593 
12594     <a class="code" href="../../d4/d9/ke_8h.html#a20">KeInitializeEvent</a>( &amp;event, SynchronizationEvent, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
12595 
12596     <span class="comment">//</span>
12597     <span class="comment">// Reset the event in the file object.</span>
12598     <span class="comment">//</span>
12599 
12600     <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a>( &amp;FileObject-&gt;Event );
12601 
12602     <span class="comment">//</span>
12603     <span class="comment">// Allocate and initialize the I/O Request Packet (IRP) for this</span>
12604     <span class="comment">// operation.</span>
12605     <span class="comment">//</span>
12606 
12607     irp = <a class="code" href="../../d0/d6/iop_8h.html#a149">IopAllocateIrpMustSucceed</a>( DeviceObject-&gt;StackSize );
12608     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.OriginalFileObject = FileObject;
12609     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
12610     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o10">RequestorMode</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>;
12611 
12612     <span class="comment">//</span>
12613     <span class="comment">// Fill in the service independent parameters in the IRP.</span>
12614     <span class="comment">//</span>
12615 
12616     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = &amp;event;
12617     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = &amp;irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o9">IoStatus</a>;
12618     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o24">Overlay</a>.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
12619     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a176">IRP_SYNCHRONOUS_API</a> | <a class="code" href="../../d0/d5/io_8h.html#a185">IRP_CLOSE_OPERATION</a>;
12620 
12621     <span class="comment">//</span>
12622     <span class="comment">// Get a pointer to the stack location for the first driver.  This will</span>
12623     <span class="comment">// be used to pass the original function codes and parameters.  No</span>
12624     <span class="comment">// function-specific parameters are required for this operation.</span>
12625     <span class="comment">//</span>
12626 
12627     irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
12628     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a31">IRP_MJ_CLEANUP</a>;
12629     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> = FileObject;
12630 
12631     <span class="comment">//</span>
12632     <span class="comment">// Insert the packet at the head of the IRP list for the thread.</span>
12633     <span class="comment">//</span>
12634 
12635     <a class="code" href="../../d0/d6/iop_8h.html#a21">IopQueueThreadIrp</a>( irp );
12636 
12637     <span class="comment">//</span>
12638     <span class="comment">// Invoke the driver at its appropriate dispatch entry with the IRP.</span>
12639     <span class="comment">//</span>
12640 
12641     status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( DeviceObject, irp );
12642 
12643     <span class="comment">//</span>
12644     <span class="comment">// If no error was incurred, wait for the I/O operation to complete.</span>
12645     <span class="comment">//</span>
12646 
12647     <span class="keywordflow">if</span> (status == STATUS_PENDING) {
12648         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
12649                                       <a class="code" href="../../d4/d9/ke_8h.html#a407a204">UserRequest</a>,
12650                                       <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
12651                                       <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
12652                                       (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
12653     }
12654 
12655     <span class="comment">//</span>
12656     <span class="comment">// The following code tears down the IRP by hand since it may not</span>
12657     <span class="comment">// be possible for it to be completed (either because this code was</span>
12658     <span class="comment">// invoked as APC_LEVEL in the first place - or because the reference</span>
12659     <span class="comment">// count on the object cannot be incremented due to this routine</span>
12660     <span class="comment">// being invoked by the delete file procedure below).  Cleanup IRPs</span>
12661     <span class="comment">// therefore use close semantics (the close operation flag is set</span>
12662     <span class="comment">// in the IRP) so that the I/O complete request routine itself sets</span>
12663     <span class="comment">// the event to the Signaled state.</span>
12664     <span class="comment">//</span>
12665 
12666     <a class="code" href="../../d9/d5/verifier_8c.html#a116">KeRaiseIrql</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a52">APC_LEVEL</a>, &amp;irql );
12667     <a class="code" href="../../d0/d6/iop_8h.html#a18">IopDequeueThreadIrp</a>( irp );
12668     <a class="code" href="../../d9/d5/verifier_8c.html#a117">KeLowerIrql</a>( irql );
12669 
12670     <span class="comment">//</span>
12671     <span class="comment">// Reuse the IRP for the next operation.</span>
12672     <span class="comment">//</span>
12673 
12674     <a class="code" href="../../d4/d6/iosubs_8c.html#a81">IoReuseIrp</a>( irp , STATUS_SUCCESS);
12675 
12676     <span class="comment">//</span>
12677     <span class="comment">// Reset the event in the file object.</span>
12678     <span class="comment">//</span>
12679 
12680     <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a>( &amp;FileObject-&gt;Event );
12681     <a class="code" href="../../d4/d9/ke_8h.html#a21">KeClearEvent</a>(&amp;event);
12682 
12683     <span class="comment">//</span>
12684     <span class="comment">// Get a pointer to the stack location for the first driver.  This is</span>
12685     <span class="comment">// where the function codes and parameters are placed.</span>
12686     <span class="comment">//</span>
12687 
12688     irpSp = <a class="code" href="../../d0/d5/io_8h.html#a230">IoGetNextIrpStackLocation</a>( irp );
12689 
12690     <span class="comment">//</span>
12691     <span class="comment">// Fill in the IRP, indicating that this file object is being deleted.</span>
12692     <span class="comment">//</span>
12693 
12694     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o0">MajorFunction</a> = <a class="code" href="../../d0/d5/io_8h.html#a15">IRP_MJ_CLOSE</a>;
12695     irpSp-&gt;<a class="code" href="../../d2/d5/struct__IO__STACK__LOCATION.html#o28">FileObject</a> = FileObject;
12696     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o18">UserIosb</a> = &amp;ioStatusBlock;
12697     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o19">UserEvent</a> = &amp;event;
12698     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.OriginalFileObject = FileObject;
12699     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.Thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
12700     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o7">AssociatedIrp</a>.SystemBuffer = (PVOID) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
12701     irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> = <a class="code" href="../../d0/d5/io_8h.html#a185">IRP_CLOSE_OPERATION</a> | <a class="code" href="../../d0/d5/io_8h.html#a176">IRP_SYNCHRONOUS_API</a>;
12702 
12703     <span class="comment">//</span>
12704     <span class="comment">// Place this packet in the thread's I/O pending queue.</span>
12705     <span class="comment">//</span>
12706 
12707     <a class="code" href="../../d0/d6/iop_8h.html#a21">IopQueueThreadIrp</a>( irp );
12708 
12709     <span class="comment">//</span>
12710     <span class="comment">// Decrement the reference count on the VPB, if necessary.  We</span>
12711     <span class="comment">// have to do this BEFORE handing the Irp to the file system</span>
12712     <span class="comment">// because of a trick the file systems play with close, and</span>
12713     <span class="comment">// believe me, you really don't want to know what it is.</span>
12714     <span class="comment">//</span>
12715     <span class="comment">// Since there is not a error path here (close cannot fail),</span>
12716     <span class="comment">// and the file system is the only ome who can actually synchronize</span>
12717     <span class="comment">// with the actual completion of close processing, the file system</span>
12718     <span class="comment">// is the one responsible for Vpb deletion.</span>
12719     <span class="comment">//</span>
12720 
12721     vpb = FileObject-&gt;Vpb;
12722 
12723     <span class="keywordflow">if</span> (vpb &amp;&amp; !(FileObject-&gt;Flags &amp; <a class="code" href="../../d0/d5/io_8h.html#a161">FO_DIRECT_DEVICE_OPEN</a>)) {
12724         <a class="code" href="../../d5/d8/ex_8h.html#a235">ExInterlockedAddUlong</a>( &amp;vpb-&gt;<a class="code" href="../../d7/d7/struct__VPB.html#o7">ReferenceCount</a>,
12725                                0xffffffff,
12726                                &amp;<a class="code" href="../../d3/d5/iodata_8c.html#a2">IopVpbSpinLock</a> );
12727         FileObject-&gt;Flags |= <a class="code" href="../../d0/d5/io_8h.html#a171">FO_FILE_OPEN_CANCELLED</a>;
12728     }
12729 
12730     <span class="comment">//</span>
12731     <span class="comment">// Give the device driver the packet.  If this request does not work,</span>
12732     <span class="comment">// there is nothing that can be done about it.  This is unfortunate</span>
12733     <span class="comment">// because the driver may have had problems that it was about to</span>
12734     <span class="comment">// report about other operations (e.g., write behind failures, etc.)</span>
12735     <span class="comment">// that it can no longer report.  The reason is that this routine</span>
12736     <span class="comment">// is really initially invoked by NtClose, which has already closed</span>
12737     <span class="comment">// the caller's handle, and that's what the return status from close</span>
12738     <span class="comment">// indicates:  the handle has successfully been closed.</span>
12739     <span class="comment">//</span>
12740 
12741     status = <a class="code" href="../../d0/d5/io_8h.html#a223">IoCallDriver</a>( DeviceObject, irp );
12742 
12743     <span class="keywordflow">if</span> (status == STATUS_PENDING) {
12744         (<a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>) <a class="code" href="../../d1/d7/wait_8c.html#a4">KeWaitForSingleObject</a>( &amp;event,
12745                                       <a class="code" href="../../d6/d7/halmips_8h.html#a455">Executive</a>,
12746                                       <a class="code" href="../../d6/d7/halmips_8h.html#a456">KernelMode</a>,
12747                                       <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>,
12748                                       (PLARGE_INTEGER) <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
12749     }
12750 
12751     <span class="comment">//</span>
12752     <span class="comment">// Perform any completion operations that need to be performed on</span>
12753     <span class="comment">// the IRP that was used for this request.  This is done here as</span>
12754     <span class="comment">// as opposed to in normal completion code because there is a race</span>
12755     <span class="comment">// condition between when this routine executes if it was invoked</span>
12756     <span class="comment">// from a special kernel APC (e.g., some IRP was just completed and</span>
12757     <span class="comment">// dereferenced this file object for the last time), and when the</span>
12758     <span class="comment">// special kernel APC because of this packet's completion executing.</span>
12759     <span class="comment">//</span>
12760     <span class="comment">// This problem is solved by not having to queue a special kernel</span>
12761     <span class="comment">// APC routine for completion of this packet.  Rather, it is treated</span>
12762     <span class="comment">// much like a synchronous paging I/O operation, except that the</span>
12763     <span class="comment">// packet is not even freed during I/O completion.  This is because</span>
12764     <span class="comment">// the packet is still in this thread's queue, and there is no way</span>
12765     <span class="comment">// to get it out except at APC_LEVEL.  Unfortunately, the part of</span>
12766     <span class="comment">// I/O completion that needs to dequeue the packet is running at</span>
12767     <span class="comment">// DISPATCH_LEVEL.</span>
12768     <span class="comment">//</span>
12769     <span class="comment">// Hence, the packet must be removed from the queue (synchronized,</span>
12770     <span class="comment">// of course), and then it must be freed.</span>
12771     <span class="comment">//</span>
12772 
12773     <a class="code" href="../../d9/d5/verifier_8c.html#a116">KeRaiseIrql</a>( <a class="code" href="../../d6/d7/halmips_8h.html#a52">APC_LEVEL</a>, &amp;irql );
12774     <a class="code" href="../../d0/d6/iop_8h.html#a18">IopDequeueThreadIrp</a>( irp );
12775     <a class="code" href="../../d9/d5/verifier_8c.html#a117">KeLowerIrql</a>( irql );
12776 
12777     <a class="code" href="../../d4/d6/iosubs_8c.html#a63">IoFreeIrp</a>( irp );
12778 
12779 }
12780 
12781 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l12782"></a><a class="code" href="../../d4/d6/iosubs_8c.html#a136">12782</a> <a class="code" href="../../d4/d6/iosubs_8c.html#a136">IoRetryIrpCompletions</a>(
12783     VOID
12784     )
12785 <span class="comment">/*++</span>
12786 <span class="comment"></span>
12787 <span class="comment">Routine Description:</span>
12788 <span class="comment"></span>
12789 <span class="comment">    This routine is called from Mm when a page fault has completed. It's</span>
12790 <span class="comment">    called on the special occasion when a thread faults a page and then when</span>
12791 <span class="comment">    it's waiting for the inpage to complete, an IopCompleteRequest APC fires</span>
12792 <span class="comment">    and we fault the same page again (say if the user buffer falls on the</span>
12793 <span class="comment">    same page).  Note the fault during the APC may be referencing the same or</span>
12794 <span class="comment">    a different user virtual address but this is irrelevant - the problem lies</span>
12795 <span class="comment">    in the fact that both virtual address references are to the same physical</span>
12796 <span class="comment">    page and thus result in a collided fault in the Mm.</span>
12797 <span class="comment"></span>
12798 <span class="comment">    Mm detects this case (to avoid deadlock) and returns STATUS_FAULT_COLLISION</span>
12799 <span class="comment">    and the I/O manager bails out the APC after marking the Irp with the flag</span>
12800 <span class="comment">    IRP_RETRY_IO_COMPLETION. Later on when Mm has decided the fault has</span>
12801 <span class="comment">    progressed far enough to avoid deadlock, it calls back into this routine </span>
12802 <span class="comment">    which calls IopCompleteRequest again.  The code in IopCompleteRequest is</span>
12803 <span class="comment">    written in a reentrant way so that the retry knows the completion is only</span>
12804 <span class="comment">    partially processed so far. We can fault in two places in IopCompleteRequest</span>
12805 <span class="comment">    and in both cases if we call IopCompleteRequest again they will now work.</span>
12806 <span class="comment"></span>
12807 <span class="comment">    This call must be called in the context of the thread that is faulting.</span>
12808 <span class="comment">    This function should be called at APC_LEVEL.</span>
12809 <span class="comment"></span>
12810 <span class="comment">Arguments:</span>
12811 <span class="comment"></span>
12812 <span class="comment">    None.</span>
12813 <span class="comment"></span>
12814 <span class="comment">Return Value:</span>
12815 <span class="comment"></span>
12816 <span class="comment">    None.</span>
12817 <span class="comment"></span>
12818 <span class="comment">--*/</span>
12819 {
12820     PLIST_ENTRY header;
12821     PLIST_ENTRY entry;
12822     KIRQL irql;
12823     <a class="code" href="../../d5/d6/struct__ETHREAD.html">PETHREAD</a> thread;
12824     <a class="code" href="../../d0/d2/struct__IRP.html">PIRP</a> irp;
12825     PVOID saveAuxiliaryPointer = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
12826     <a class="code" href="../../d9/d1/struct__FILE__OBJECT.html">PFILE_OBJECT</a> fileObject;
12827 
12828 
12829     thread = <a class="code" href="../../d1/d9/ps_8h.html#a20">PsGetCurrentThread</a>();
12830 
12831     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(KeGetCurrentIrql() == <a class="code" href="../../d6/d7/halmips_8h.html#a52">APC_LEVEL</a>);
12832 
12833     <span class="comment">//</span>
12834     <span class="comment">// Raise the IRQL so that the IrpList cannot be modified by a completion</span>
12835     <span class="comment">// APC.</span>
12836     <span class="comment">//</span>
12837 
12838     header = &amp;thread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o18">IrpList</a>;
12839     entry = thread-&gt;<a class="code" href="../../d5/d6/struct__ETHREAD.html#o18">IrpList</a>.Flink;
12840 
12841     <span class="comment">//</span>
12842     <span class="comment">// Walk the list of pending IRPs, completing each of them.</span>
12843     <span class="comment">//</span>
12844 
12845     <span class="keywordflow">while</span> (header != entry) {
12846 
12847         irp = CONTAINING_RECORD( entry, <a class="code" href="../../d0/d2/struct__IRP.html">IRP</a>, ThreadListEntry );
12848         entry = entry-&gt;Flink;
12849 
12850         <span class="keywordflow">if</span> (irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a189">IRP_RETRY_IO_COMPLETION</a>) {
12851 
12852             <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>(!(irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp; <a class="code" href="../../d0/d5/io_8h.html#a182">IRP_CREATE_OPERATION</a>));
12853 
12854             irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o3">Flags</a> &amp;= ~<a class="code" href="../../d0/d5/io_8h.html#a189">IRP_RETRY_IO_COMPLETION</a>;
12855             fileObject = irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Overlay.OriginalFileObject;
12856             <a class="code" href="../../d0/d6/iop_8h.html#a157">IopCompleteRequest</a>(
12857                     &amp;irp-&gt;<a class="code" href="../../d0/d2/struct__IRP.html#o38">Tail</a>.Apc, 
12858                     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, 
12859                     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>, 
12860                     &amp;fileObject,
12861                     &amp;saveAuxiliaryPointer);
12862         }
12863     }
12864 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:31 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
