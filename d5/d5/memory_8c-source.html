<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: memory.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>memory.c</h1><a href="../../d4/d6/memory_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="preprocessor">#include "<a class="code" href="../../d3/d3/arcinst_2precomp_8h.html">precomp.h</a>"</span>
00002 <span class="preprocessor">#pragma hdrstop</span>
00003 <span class="preprocessor"></span>
00004 <span class="comment">//</span>
00005 <span class="comment">// SEGMENT_HEADER is the header that resides at the beginning of every</span>
00006 <span class="comment">// segment of memory managed by this package.  For non-growable heaps,</span>
00007 <span class="comment">// there is only one segment for the entire heap.  For growable heaps,</span>
00008 <span class="comment">// segments are created as needed whenever there is not enough free space</span>
00009 <span class="comment">// to satisfy an allocation request.</span>
00010 <span class="comment">//</span>
<a name="l00011"></a><a class="code" href="../../d2/d1/struct__SEGMENT__HEADER.html">00011</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d2/d1/struct__SEGMENT__HEADER.html">_SEGMENT_HEADER</a> {
<a name="l00012"></a><a class="code" href="../../d2/d1/struct__SEGMENT__HEADER.html#o0">00012</a>     <span class="keyword">struct </span><a class="code" href="../../d2/d1/struct__SEGMENT__HEADER.html">_SEGMENT_HEADER</a> *<a class="code" href="../../d2/d1/struct__SEGMENT__HEADER.html#o0">Next</a>;
<a name="l00013"></a><a class="code" href="../../d2/d1/struct__SEGMENT__HEADER.html#o1">00013</a>     ULONG <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
<a name="l00014"></a><a class="code" href="../../d2/d1/struct__SEGMENT__HEADER.html#o2">00014</a>     ULONG <a class="code" href="../../d2/d1/struct__SEGMENT__HEADER.html#o2">Spare</a>[ 2 ];                   <span class="comment">// Make sizeof match granularity</span>
00015 } <a class="code" href="../../d2/d1/struct__SEGMENT__HEADER.html">SEGMENT_HEADER</a>, *<a class="code" href="../../d2/d1/struct__SEGMENT__HEADER.html">PSEGMENT_HEADER</a>;
00016 
00017 <span class="comment">//</span>
00018 <span class="comment">// FREE_HEADER is the header that resides at the beginning of every</span>
00019 <span class="comment">// free block of memory managed by this package.  All free blocks are</span>
00020 <span class="comment">// linked together on a free list rooted in the heap header.  The segment</span>
00021 <span class="comment">// field of a free header prevents free blocks in different segments from</span>
00022 <span class="comment">// being coalesced.</span>
00023 <span class="comment">//</span>
<a name="l00024"></a><a class="code" href="../../d7/d0/struct__FREE__HEADER.html">00024</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d7/d0/struct__FREE__HEADER.html">_FREE_HEADER</a> {
<a name="l00025"></a><a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o0">00025</a>     <span class="keyword">struct </span><a class="code" href="../../d7/d0/struct__FREE__HEADER.html">_FREE_HEADER</a> *<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o0">Next</a>;
<a name="l00026"></a><a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o1">00026</a>     ULONG <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
<a name="l00027"></a><a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o2">00027</a>     <span class="keyword">struct </span><a class="code" href="../../d2/d1/struct__SEGMENT__HEADER.html">_SEGMENT_HEADER</a> *<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o2">Segment</a>;
<a name="l00028"></a><a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o3">00028</a>     ULONG <a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o3">Spare</a>;
00029 } <a class="code" href="../../d7/d0/struct__FREE__HEADER.html">FREE_HEADER</a>, *<a class="code" href="../../d7/d0/struct__FREE__HEADER.html">PFREE_HEADER</a>;
00030 
00031 <span class="comment">//</span>
00032 <span class="comment">// BUSY_HEADER is the header that resides at the beginning of allocated</span>
00033 <span class="comment">// block of memory managed by this package.  When the block is</span>
00034 <span class="comment">// allocated, the Busy structure is valid.  The address that the user</span>
00035 <span class="comment">// sees actually points to the byte following the header.  When the</span>
00036 <span class="comment">// block is on the free list, the Free structure is valid.</span>
00037 <span class="comment">//</span>
<a name="l00038"></a><a class="code" href="../../d9/d5/struct__BUSY__HEADER.html">00038</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d9/d5/struct__BUSY__HEADER.html">_BUSY_HEADER</a> {
<a name="l00039"></a><a class="code" href="../../d9/d5/struct__BUSY__HEADER.html#o0">00039</a>     <span class="keyword">struct </span><a class="code" href="../../d2/d1/struct__SEGMENT__HEADER.html">_SEGMENT_HEADER</a> *<a class="code" href="../../d9/d5/struct__BUSY__HEADER.html#o0">Segment</a>;
<a name="l00040"></a><a class="code" href="../../d9/d5/struct__BUSY__HEADER.html#o1">00040</a>     ULONG <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
<a name="l00041"></a><a class="code" href="../../d9/d5/struct__BUSY__HEADER.html#o2">00041</a>     HANDLE <a class="code" href="../../d9/d5/struct__BUSY__HEADER.html#o2">HandleValue</a>;
<a name="l00042"></a><a class="code" href="../../d9/d5/struct__BUSY__HEADER.html#o3">00042</a>     ULONG <a class="code" href="../../d9/d5/struct__BUSY__HEADER.html#o3">Spare</a>;
00043 } <a class="code" href="../../d9/d5/struct__BUSY__HEADER.html">BUSY_HEADER</a>, *<a class="code" href="../../d9/d5/struct__BUSY__HEADER.html">PBUSY_HEADER</a>;
00044 
00045 <span class="comment">//</span>
00046 <span class="comment">// Flags are stored in the low order two bits of the first word of the</span>
00047 <span class="comment">// header.  This is possible, since all blocks are aligned on 16 byte</span>
00048 <span class="comment">// boundaries.  To make walking the free list fast, the flag value for</span>
00049 <span class="comment">// a free block is zero, so we can use the Next pointer without modification.</span>
00050 <span class="comment">//</span>
<a name="l00051"></a><a class="code" href="../../d4/d6/memory_8c.html#a0">00051</a> <span class="preprocessor">#define FLAGS_FREE        0x00000000</span>
<a name="l00052"></a><a class="code" href="../../d4/d6/memory_8c.html#a1">00052</a> <span class="preprocessor"></span><span class="preprocessor">#define FLAGS_BUSY        0x00000001</span>
<a name="l00053"></a><a class="code" href="../../d4/d6/memory_8c.html#a2">00053</a> <span class="preprocessor"></span><span class="preprocessor">#define FLAGS_MASK        0x00000003</span>
00054 <span class="preprocessor"></span>
00055 <span class="comment">//</span>
00056 <span class="comment">// All allocations are made as a multiple of ALLOCATION_GRANULARITY.</span>
00057 <span class="comment">// The size requested is rounded up to a multiple of the allocation</span>
00058 <span class="comment">// granularity.  The size of an allocation header is then added and</span>
00059 <span class="comment">// that is the amount of memory that is actually allocated.</span>
00060 <span class="comment">//</span>
<a name="l00061"></a><a class="code" href="../../d4/d6/memory_8c.html#a3">00061</a> <span class="preprocessor">#define ALLOCATION_GRANULARITY 16 // bytes</span>
00062 <span class="preprocessor"></span>
00063 <span class="comment">//</span>
00064 <span class="comment">// HEAP_HEADER is the header for a heap.  All access to the heap is</span>
00065 <span class="comment">// synchronized by the Lock field.</span>
00066 <span class="comment">//</span>
<a name="l00067"></a><a class="code" href="../../d3/d6/struct__HEAP__HEADER.html">00067</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d3/d6/struct__HEAP__HEADER.html">_HEAP_HEADER</a> {
00068     <span class="comment">//</span>
00069     <span class="comment">// Heap routines use Length to determine if the heap is valid.</span>
00070     <span class="comment">//</span>
<a name="l00071"></a><a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o0">00071</a>     ULONG <a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o0">Length</a>;
00072 
00073     <span class="comment">//</span>
00074     <span class="comment">// If the ZeroExtraMemory field is true, then the heap allocation</span>
00075     <span class="comment">// logic will zero initialize any extra space at the end of an allocated</span>
00076     <span class="comment">// block, due to rounding up to the ALIGNMENT_GRANULARITY amount.</span>
00077     <span class="comment">//</span>
<a name="l00078"></a><a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o1">00078</a>     BOOLEAN <a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o1">ZeroExtraMemory</a>;
00079 
00080     <span class="comment">//</span>
00081     <span class="comment">// The address of the first valid address at the begining of the</span>
00082     <span class="comment">// heap.  Used for validating pointers passed to AlFreeHeap</span>
00083     <span class="comment">//</span>
<a name="l00084"></a><a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o2">00084</a>     PVOID <a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o2">ValidAddress</a>;
00085 
00086     <span class="comment">//</span>
00087     <span class="comment">// The address of the first address of memory beyond the end of the heap</span>
00088     <span class="comment">//</span>
<a name="l00089"></a><a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o3">00089</a>     PVOID <a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o3">EndAddress</a>;
00090 
00091     <span class="comment">//</span>
00092     <span class="comment">// FreeList is the header for the heap free list.</span>
00093     <span class="comment">//</span>
<a name="l00094"></a><a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o4">00094</a>     ULONG <a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o4">Spare</a>;         <span class="comment">// Make free list align on granularity</span>
<a name="l00095"></a><a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o5">00095</a>     <a class="code" href="../../d7/d0/struct__FREE__HEADER.html">FREE_HEADER</a> <a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o5">FreeList</a>;
00096 } <a class="code" href="../../d3/d6/struct__HEAP__HEADER.html">HEAP_HEADER</a>, *<a class="code" href="../../d3/d6/struct__HEAP__HEADER.html">PHEAP_HEADER</a>;
00097 
00098 
00099 <span class="comment">//</span>
00100 <span class="comment">// The heap is constructed out of a memory descriptor</span>
00101 <span class="comment">// block that is below the descriptor for the loaded program.  This block</span>
00102 <span class="comment">// also accomodates the loaded program stack.  It is essential therefore</span>
00103 <span class="comment">// to estimate the stack space requirement for your arc program.  (16 pages</span>
00104 <span class="comment">// should be enough.)  The StackPages and HeapPages are 4K each.</span>
00105 <span class="comment">//</span>
00106 
<a name="l00107"></a><a class="code" href="../../d4/d6/memory_8c.html#a4">00107</a> <span class="preprocessor">#define HEAP_ZERO_EXTRA_MEMORY   0x00000008</span>
00108 <span class="preprocessor"></span><span class="comment">//</span>
00109 <span class="comment">// Define memory allocation descriptor listhead and heap storage variables.</span>
00110 <span class="comment">//</span>
00111 
<a name="l00112"></a><a class="code" href="../../d4/d6/memory_8c.html#a13">00112</a> ULONG <a class="code" href="../../d4/d6/memory_8c.html#a13">AlHeapFree</a>;
<a name="l00113"></a><a class="code" href="../../d4/d6/memory_8c.html#a14">00113</a> ULONG <a class="code" href="../../d4/d6/memory_8c.html#a14">AlHeapLimit</a>;
00114 
<a name="l00115"></a><a class="code" href="../../d4/d6/memory_8c.html#a15">00115</a> PVOID  <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
00116 
00117 
00118 PVOID
<a name="l00119"></a><a class="code" href="../../d4/d6/memory_8c.html#a16">00119</a> <a class="code" href="../../d4/d6/memory_8c.html#a16">AlRtCreateHeap</a>(
00120     IN ULONG Flags,
00121     IN PVOID HeapBase,
00122     IN ULONG Size
00123     )
00124 
00125 <span class="comment">/*++</span>
00126 <span class="comment"></span>
00127 <span class="comment">Routine Description:</span>
00128 <span class="comment"></span>
00129 <span class="comment">    This routine initializes a heap.</span>
00130 <span class="comment"></span>
00131 <span class="comment">Arguments:</span>
00132 <span class="comment"></span>
00133 <span class="comment">    Flags - Specifies optional attributes of the heap.</span>
00134 <span class="comment"></span>
00135 <span class="comment">        Valid Flags Values:</span>
00136 <span class="comment">        HEAP_ZERO_EXTRA_MEMORY. to make sure that extra memory passed</span>
00137 <span class="comment">                    in is zeroed out.</span>
00138 <span class="comment"></span>
00139 <span class="comment">    HeapBase - if not NULL, this specifies the base address for memory</span>
00140 <span class="comment">    to use as the heap.  If NULL, memory is allocated by these routines.</span>
00141 <span class="comment"></span>
00142 <span class="comment">    Size - Size of the block of memory passed in to be used as a heap</span>
00143 <span class="comment"></span>
00144 <span class="comment">Return Value:</span>
00145 <span class="comment"></span>
00146 <span class="comment">    PVOID - a pointer to be used in accessing the created heap.</span>
00147 <span class="comment"></span>
00148 <span class="comment">--*/</span>
00149 
00150 {
00151     <a class="code" href="../../d4/d6/memory_8c.html#a12">PHEAP_HEADER</a> Heap = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00152     <a class="code" href="../../d4/d6/memory_8c.html#a8">PFREE_HEADER</a> FreeBlock;
00153 
00154 
00155     Heap          = (<a class="code" href="../../d4/d6/memory_8c.html#a12">PHEAP_HEADER</a>)HeapBase;
00156     Heap-&gt;<a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o0">Length</a>      = <span class="keyword">sizeof</span>( <a class="code" href="../../d3/d6/struct__HEAP__HEADER.html">HEAP_HEADER</a> );
00157     Heap-&gt;<a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o1">ZeroExtraMemory</a> = (BOOLEAN)((Flags &amp; <a class="code" href="../../d4/d6/memory_8c.html#a4">HEAP_ZERO_EXTRA_MEMORY</a>) ? <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> : <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>);
00158     Heap-&gt;<a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o2">ValidAddress</a>    = (PCH)Heap + ((<span class="keyword">sizeof</span>(*Heap) + (<a class="code" href="../../d4/d6/memory_8c.html#a3">ALLOCATION_GRANULARITY</a>-1)) &amp; ~(<a class="code" href="../../d4/d6/memory_8c.html#a3">ALLOCATION_GRANULARITY</a>-1));
00159     Heap-&gt;<a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o3">EndAddress</a>      = (PCH)Heap + <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>;
00160 
00161     <span class="comment">//</span>
00162     <span class="comment">// Initialize the free list to be a single block that starts immediately</span>
00163     <span class="comment">// after the heap header.</span>
00164     <span class="comment">//</span>
00165 
00166     FreeBlock = (<a class="code" href="../../d4/d6/memory_8c.html#a8">PFREE_HEADER</a>)Heap-&gt;<a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o2">ValidAddress</a>;
00167     FreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o0">Next</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00168     FreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o1">Size</a> = (ULONG)Heap-&gt;<a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o3">EndAddress</a> -
00169                       (ULONG)FreeBlock;
00170     FreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o2">Segment</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00171 
00172     Heap-&gt;<a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o5">FreeList</a>.<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o0">Next</a> = FreeBlock;
00173     Heap-&gt;<a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o5">FreeList</a>.<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o1">Size</a> = 0;
00174     Heap-&gt;<a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o5">FreeList</a>.<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o2">Segment</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00175 
00176     <span class="keywordflow">return</span>( (PVOID)Heap );
00177 } <span class="comment">// AlRtCreateHeap</span>
00178 
00179 
00180 
00181 <span class="preprocessor">#if DBG</span>
00182 <span class="preprocessor"></span>
00183 BOOLEAN
00184 DumpHeapSegment(
00185     BOOLEAN DumpHeap,
00186     PHEAP_HEADER Heap,
00187     PVOID FirstValidBlock,
00188     PVOID FirstInvalidBlock,
00189     PULONG CountOfFreeBlocks
00190     )
00191 {
00192     PVOID CurrentBlock = FirstValidBlock;
00193     <a class="code" href="../../d4/d6/memory_8c.html#a8">PFREE_HEADER</a> FreeBlock;
00194     <a class="code" href="../../d4/d6/memory_8c.html#a10">PBUSY_HEADER</a> BusyBlock;
00195 
00196     <span class="keywordflow">while</span> (CurrentBlock &lt; FirstInvalidBlock) {
00197         BusyBlock = CurrentBlock;
00198         FreeBlock = CurrentBlock;
00199         <span class="keywordflow">if</span> (((ULONG)BusyBlock-&gt;<a class="code" href="../../d9/d5/struct__BUSY__HEADER.html#o0">Segment</a> &amp; <a class="code" href="../../d4/d6/memory_8c.html#a2">FLAGS_MASK</a>) == <a class="code" href="../../d4/d6/memory_8c.html#a1">FLAGS_BUSY</a>) {
00200             <span class="keywordflow">if</span> (DumpHeap) {
00201                 <a class="code" href="../../d4/d9/arcinst_8h.html#a114">AlPrint</a>( <span class="stringliteral">"    %08lx: BUSY Flags=%lx  Size: %lx  Segment: %lx\n"</span>,
00202                           BusyBlock,
00203                           (ULONG)BusyBlock-&gt;<a class="code" href="../../d9/d5/struct__BUSY__HEADER.html#o0">Segment</a> &amp; FLAGS_MASK,
00204                           BusyBlock-&gt;<a class="code" href="../../d9/d5/struct__BUSY__HEADER.html#o1">Size</a>,
00205                           (ULONG)BusyBlock-&gt;<a class="code" href="../../d9/d5/struct__BUSY__HEADER.html#o0">Segment</a> &amp; ~FLAGS_MASK
00206                         );
00207                 }
00208 
00209             CurrentBlock = (PCH)CurrentBlock + BusyBlock-&gt;<a class="code" href="../../d9/d5/struct__BUSY__HEADER.html#o1">Size</a>;
00210             }
00211         <span class="keywordflow">else</span>
00212         <span class="keywordflow">if</span> (((ULONG)FreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o0">Next</a> &amp; <a class="code" href="../../d4/d6/memory_8c.html#a2">FLAGS_MASK</a>) == <a class="code" href="../../d4/d6/memory_8c.html#a0">FLAGS_FREE</a>) {
00213             *CountOfFreeBlocks += 1;
00214             <span class="keywordflow">if</span> (DumpHeap) {
00215                 <a class="code" href="../../d4/d9/arcinst_8h.html#a114">AlPrint</a>( <span class="stringliteral">"    %08lx: FREE Next=%lx  Size: %lx  Segment: %lx\n"</span>,
00216                           FreeBlock,
00217                           FreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o0">Next</a>,
00218                           FreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o1">Size</a>,
00219                           FreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o2">Segment</a>
00220                         );
00221                 }
00222 
00223             CurrentBlock = (PCH)CurrentBlock + FreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o1">Size</a>;
00224             }
00225         <span class="keywordflow">else</span> {
00226             <span class="keywordflow">if</span> (DumpHeap) {
00227                 <a class="code" href="../../d4/d9/arcinst_8h.html#a114">AlPrint</a>( <span class="stringliteral">"*** Invalid heap block at %lx\n"</span>, CurrentBlock );
00228                 }
00229 
00230             <span class="keywordflow">return</span>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00231             }
00232 
00233         }
00234 
00235     <span class="keywordflow">if</span> (CurrentBlock != FirstInvalidBlock) {
00236         <span class="keywordflow">if</span> (DumpHeap) {
00237             <a class="code" href="../../d4/d9/arcinst_8h.html#a114">AlPrint</a>( <span class="stringliteral">"*** Heap segment ends at %lx instead of %lx\n"</span>,
00238                       CurrentBlock, FirstInvalidBlock
00239                     );
00240             }
00241 
00242         <span class="keywordflow">return</span>( <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> );
00243         }
00244 
00245     <span class="keywordflow">return</span>( <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00246 }
00247 
00248 
00249 BOOLEAN
00250 <a class="code" href="../../d4/d6/memory_8c.html#a17">AlRtValidateHeap</a>(
00251     IN PVOID HeapHandle,
00252     IN BOOLEAN DumpHeap
00253     )
00254 {
00255     <a class="code" href="../../d4/d6/memory_8c.html#a12">PHEAP_HEADER</a> Heap = (<a class="code" href="../../d4/d6/memory_8c.html#a12">PHEAP_HEADER</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
00256     <a class="code" href="../../d4/d6/memory_8c.html#a8">PFREE_HEADER</a> FreeBlock;
00257     BOOLEAN HeapValid = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00258     ULONG LengthOfFreeList;
00259     ULONG CountOfFreeBlocks;
00260 
00261     <span class="comment">//</span>
00262     <span class="comment">// Validate that HeapAddress points to a HEAP_HEADER structure.</span>
00263     <span class="comment">//</span>
00264 
00265     <span class="keywordflow">if</span> (Heap-&gt;<a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o0">Length</a> != <span class="keyword">sizeof</span>( <a class="code" href="../../d3/d6/struct__HEAP__HEADER.html">HEAP_HEADER</a> )) {
00266         <span class="keywordflow">if</span> (DumpHeap) {
00267             <a class="code" href="../../d4/d9/arcinst_8h.html#a114">AlPrint</a>( <span class="stringliteral">"AlRtHEAP: Invalid heap header- %lx\n"</span>, Heap );
00268             }
00269 
00270         HeapValid = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00271         <span class="keywordflow">goto</span> <a class="code" href="../../d9/d1/fedefs_8h.html#a16">exit</a>;
00272         }
00273 
00274 
00275     <span class="keywordflow">if</span> (DumpHeap) {
00276         <a class="code" href="../../d4/d9/arcinst_8h.html#a114">AlPrint</a>( <span class="stringliteral">"Heap at %lx,  Length=%lx\n"</span>, Heap, Heap-&gt;<a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o0">Length</a> );
00277         <a class="code" href="../../d4/d9/arcinst_8h.html#a114">AlPrint</a>( <span class="stringliteral">"  FreeList: Head=%lx\n"</span>, Heap-&gt;<a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o5">FreeList</a>.<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o0">Next</a> );
00278         <a class="code" href="../../d4/d9/arcinst_8h.html#a114">AlPrint</a>( <span class="stringliteral">"  Heap: End Address = %lx\n"</span>,Heap-&gt;<a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o3">EndAddress</a>);
00279         }
00280 
00281 
00282     <span class="keywordflow">if</span> (Heap-&gt;<a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o5">FreeList</a>.<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o1">Size</a> != 0) {
00283         <span class="keywordflow">if</span> (DumpHeap) {
00284             <a class="code" href="../../d4/d9/arcinst_8h.html#a114">AlPrint</a>( <span class="stringliteral">"*** head of free list is invalid (size)\n"</span> );
00285             }
00286 
00287         HeapValid = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00288         <span class="keywordflow">goto</span> <a class="code" href="../../d9/d1/fedefs_8h.html#a16">exit</a>;
00289         }
00290 
00291     LengthOfFreeList = 0;
00292     FreeBlock = Heap-&gt;<a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o5">FreeList</a>.<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o0">Next</a>;
00293     <span class="keywordflow">while</span> (FreeBlock) {
00294         <span class="keywordflow">if</span> (DumpHeap) {
00295             <a class="code" href="../../d4/d9/arcinst_8h.html#a114">AlPrint</a>( <span class="stringliteral">"    %08lx: Next=%lx  Size: %lx  Segment: %lx\n"</span>,
00296                       FreeBlock,
00297                       FreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o0">Next</a>,
00298                       FreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o1">Size</a>,
00299                       FreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o2">Segment</a>
00300                     );
00301             }
00302 
00303         <span class="keywordflow">if</span> (((ULONG)FreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o0">Next</a> &amp; <a class="code" href="../../d4/d6/memory_8c.html#a2">FLAGS_MASK</a>) != <a class="code" href="../../d4/d6/memory_8c.html#a0">FLAGS_FREE</a>) {
00304             <span class="keywordflow">if</span> (DumpHeap) {
00305                 <a class="code" href="../../d4/d9/arcinst_8h.html#a114">AlPrint</a>( <span class="stringliteral">"*** free list element is not a valid free block\n"</span> );
00306                 }
00307 
00308             HeapValid = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00309             <span class="keywordflow">goto</span> <a class="code" href="../../d9/d1/fedefs_8h.html#a16">exit</a>;
00310             }
00311 
00312         LengthOfFreeList += 1;
00313         FreeBlock = FreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o0">Next</a>;
00314         }
00315 
00316     CountOfFreeBlocks = 0;
00317     <span class="keywordflow">if</span> (DumpHeap) {
00318         <a class="code" href="../../d4/d9/arcinst_8h.html#a114">AlPrint</a>( <span class="stringliteral">"  Heap Blocks starting at %lx:\n"</span>, Heap-&gt;<a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o2">ValidAddress</a> );
00319         }
00320 
00321     HeapValid = DumpHeapSegment( DumpHeap,
00322                                  Heap,
00323                                  Heap-&gt;<a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o2">ValidAddress</a>,
00324                                  Heap-&gt;<a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o3">EndAddress</a>,
00325                                  &amp;CountOfFreeBlocks
00326                                );
00327     <span class="keywordflow">if</span> (!HeapValid) {
00328         <span class="keywordflow">goto</span> <a class="code" href="../../d9/d1/fedefs_8h.html#a16">exit</a>;
00329         }
00330 
00331     <span class="keywordflow">if</span> (LengthOfFreeList != CountOfFreeBlocks) {
00332         <span class="keywordflow">if</span> (DumpHeap) {
00333             <a class="code" href="../../d4/d9/arcinst_8h.html#a114">AlPrint</a>( <span class="stringliteral">"*** Number of free blocks in arena (%ld) does not match number in the free list (%ld)\n"</span>,
00334                       CountOfFreeBlocks,
00335                       LengthOfFreeList
00336                     );
00337             }
00338 
00339         HeapValid = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00340         <span class="keywordflow">goto</span> <a class="code" href="../../d9/d1/fedefs_8h.html#a16">exit</a>;
00341         }
00342 
00343 <a class="code" href="../../d9/d1/fedefs_8h.html#a16">exit</a>:
00344     <span class="keywordflow">return</span>( HeapValid );
00345 
00346 } <span class="comment">// AlRtValidateHeap</span>
00347 
00348 
00349 <span class="preprocessor">#else</span>
00350 <span class="preprocessor"></span>
00351 BOOLEAN
<a name="l00352"></a><a class="code" href="../../d4/d6/memory_8c.html#a17">00352</a> <a class="code" href="../../d4/d6/memory_8c.html#a17">AlRtValidateHeap</a>(
00353     IN PVOID HeapHandle,
00354     IN BOOLEAN DumpHeap
00355     )
00356 {
00357     <span class="keywordflow">return</span>( <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> );
00358 }
00359 
00360 <span class="preprocessor">#endif</span>
00361 <span class="preprocessor"></span>
00362 
00363 
00364 PVOID
<a name="l00365"></a><a class="code" href="../../d4/d6/memory_8c.html#a18">00365</a> <a class="code" href="../../d4/d6/memory_8c.html#a18">AlRtAllocateHeap</a>(
00366     IN PVOID HeapHandle,
00367     IN ULONG Size
00368     )
00369 {
00370     <a class="code" href="../../d4/d6/memory_8c.html#a12">PHEAP_HEADER</a> Heap = (<a class="code" href="../../d4/d6/memory_8c.html#a12">PHEAP_HEADER</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
00371     ULONG allocationSize;
00372 <span class="comment">//    PSEGMENT_HEADER Segment;</span>
00373     <a class="code" href="../../d4/d6/memory_8c.html#a8">PFREE_HEADER</a> FreeBlock;
00374     <a class="code" href="../../d4/d6/memory_8c.html#a8">PFREE_HEADER</a> PreviousFreeBlock;
00375     <a class="code" href="../../d4/d6/memory_8c.html#a8">PFREE_HEADER</a> NewFreeBlock;
00376     <a class="code" href="../../d4/d6/memory_8c.html#a10">PBUSY_HEADER</a> BusyBlock;
00377 
00378 
00379     <span class="comment">//</span>
00380     <span class="comment">// Validate that HeapAddress points to a HEAP_HEADER structure.</span>
00381     <span class="comment">//</span>
00382 
00383     <span class="keywordflow">if</span> (Heap-&gt;<a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o0">Length</a> != <span class="keyword">sizeof</span>( <a class="code" href="../../d3/d6/struct__HEAP__HEADER.html">HEAP_HEADER</a> )) {
00384 <span class="preprocessor">#if DBG</span>
00385 <span class="preprocessor"></span>    <a class="code" href="../../d4/d9/arcinst_8h.html#a114">AlPrint</a>( <span class="stringliteral">"ALHEAP: Invalid heap header- %lx\n"</span>, Heap );
00386 <span class="preprocessor">#endif // DBG</span>
00387 <span class="preprocessor"></span>        <span class="keywordflow">return</span>( <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00388         }
00389 
00390     <span class="comment">//</span>
00391     <span class="comment">// Additional check, see if the heap is valid, call the heap validation</span>
00392     <span class="comment">// code, requesting it to not dump stuff.</span>
00393     <span class="comment">//</span>
00394     <span class="keywordflow">if</span>(!<a class="code" href="../../d4/d6/memory_8c.html#a17">AlRtValidateHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
00395 
00396 <span class="preprocessor">#if DBG</span>
00397 <span class="preprocessor"></span>        <a class="code" href="../../d4/d9/arcinst_8h.html#a114">AlPrint</a>(<span class="stringliteral">"Heap validation failed\n"</span>);
00398 <span class="preprocessor">#endif</span>
00399 <span class="preprocessor"></span>        <span class="keywordflow">return</span> ( <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00400     }
00401 
00402 
00403     <span class="comment">//</span>
00404     <span class="comment">// Round the requested size up to the allocation granularity.  Note</span>
00405     <span class="comment">// that if the request is for 0 bytes, we still allocate memory.</span>
00406     <span class="comment">//</span>
00407 
00408     allocationSize = ((<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> ? <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> : <a class="code" href="../../d4/d6/memory_8c.html#a3">ALLOCATION_GRANULARITY</a>) +
00409                       <span class="keyword">sizeof</span>( <a class="code" href="../../d9/d5/struct__BUSY__HEADER.html">BUSY_HEADER</a> ) +
00410                       <a class="code" href="../../d4/d6/memory_8c.html#a3">ALLOCATION_GRANULARITY</a> -
00411                       1
00412                      ) &amp; ~(<a class="code" href="../../d4/d6/memory_8c.html#a3">ALLOCATION_GRANULARITY</a> - 1);
00413     <span class="keywordflow">if</span> (allocationSize &lt; <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>) {
00414 <span class="preprocessor">#if DBG</span>
00415 <span class="preprocessor"></span>    <a class="code" href="../../d4/d9/arcinst_8h.html#a114">AlPrint</a>( <span class="stringliteral">"ALHEAP: Invalid heap size - %lx\n"</span>, <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> );
00416 <span class="comment">//   RtlpBreakPointHeap();</span>
00417 <span class="preprocessor">#endif // DBG</span>
00418 <span class="preprocessor"></span>        <span class="keywordflow">return</span>( <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00419     }
00420 
00421     <span class="comment">//</span>
00422     <span class="comment">// Point to the free list header.</span>
00423     <span class="comment">//</span>
00424 
00425     FreeBlock = &amp;Heap-&gt;<a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o5">FreeList</a>;
00426 <span class="preprocessor">#if DBG</span>
00427 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (FreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o1">Size</a> != 0) {
00428     <a class="code" href="../../d4/d9/arcinst_8h.html#a114">AlPrint</a>( <span class="stringliteral">"ALHEAP: Heap free list HEAD hosed at %lx\n"</span>, FreeBlock );
00429 <span class="comment">//   RtlpBreakPointHeap();</span>
00430 
00431     <span class="keywordflow">return</span>( <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00432         }
00433 <span class="preprocessor">#endif // DBG</span>
00434 <span class="preprocessor"></span>
00435     <span class="comment">//</span>
00436     <span class="comment">// Continuous loop.  We'll break out of the loop when we've found</span>
00437     <span class="comment">// (or created) some free memory.</span>
00438     <span class="comment">//</span>
00439 
00440     <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00441         <span class="comment">//</span>
00442         <span class="comment">// Have we reached the end of the free list?</span>
00443         <span class="comment">//</span>
00444 
00445     <span class="keywordflow">if</span> (FreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o0">Next</a> == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)
00446         <span class="keywordflow">return</span>( <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00447         <span class="keywordflow">else</span> {
00448             <span class="comment">//</span>
00449             <span class="comment">// Point to the next free block, saving a pointer to the</span>
00450             <span class="comment">// previous one.</span>
00451             <span class="comment">//</span>
00452 
00453             PreviousFreeBlock = FreeBlock;
00454             FreeBlock = PreviousFreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o0">Next</a>;
00455             }
00456 
00457 <span class="preprocessor">#if DBG</span>
00458 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (FreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o1">Size</a> == 0) {
00459         <a class="code" href="../../d4/d9/arcinst_8h.html#a114">AlPrint</a>( <span class="stringliteral">"ALHEAP: Heap free list ENTRY hosed at %lx\n"</span>,
00460                       FreeBlock
00461                     );
00462 <span class="comment">//       RtlpBreakPointHeap();</span>
00463         <span class="keywordflow">return</span>( <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00464             }
00465 <span class="preprocessor">#endif // DBG</span>
00466 <span class="preprocessor"></span>
00467         <span class="comment">//</span>
00468         <span class="comment">// We haven't exhausted the free list yet.  If this block is</span>
00469         <span class="comment">// large enough for what we need, break out of the while loop.</span>
00470         <span class="comment">//</span>
00471 
00472         <span class="keywordflow">if</span> (FreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o1">Size</a> &gt;= allocationSize) {
00473             <span class="keywordflow">break</span>;
00474             }
00475 
00476         } <span class="comment">// while ( TRUE )</span>
00477 
00478     <span class="comment">//</span>
00479     <span class="comment">// We have found a free block that is large enough to hold what the</span>
00480     <span class="comment">// user requested.  If it's exactly the right size, simply point the</span>
00481     <span class="comment">// previous free block to the successor of this free block.  If it's</span>
00482     <span class="comment">// larger than what we want, we allocate from the front of the block,</span>
00483     <span class="comment">// leaving the trailing part free.  Exactly the right size is fuzzy,</span>
00484     <span class="comment">// as if we decide to split we need at least enough extra space for</span>
00485     <span class="comment">// a free header plus some space to statisfy an allocation.</span>
00486     <span class="comment">//</span>
00487 
00488     <span class="keywordflow">if</span> ((FreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o1">Size</a> - allocationSize) &lt; (2 * <span class="keyword">sizeof</span>( <a class="code" href="../../d7/d0/struct__FREE__HEADER.html">FREE_HEADER</a> ))) {
00489         <span class="comment">//</span>
00490         <span class="comment">// If the amount of extra space is less than twice the size of</span>
00491         <span class="comment">// a free header, just give the caller all the space, as the</span>
00492         <span class="comment">// extra amount is too small to waste a free block on.</span>
00493         <span class="comment">//</span>
00494 
00495         allocationSize = FreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o1">Size</a>;
00496 
00497         <span class="comment">//</span>
00498         <span class="comment">// Exactly the right size.  Point previous free block to the</span>
00499         <span class="comment">// next free block.</span>
00500         <span class="comment">//</span>
00501 
00502         PreviousFreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o0">Next</a> = FreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o0">Next</a>;
00503 
00504         }
00505     <span class="keywordflow">else</span> {
00506 
00507         <span class="comment">//</span>
00508         <span class="comment">// More memory than we need.  Make the trailing part of the block</span>
00509         <span class="comment">// into a free block.  Point the previous block to the new block</span>
00510         <span class="comment">// and the new block to the next block.</span>
00511         <span class="comment">//</span>
00512 
00513         NewFreeBlock = (<a class="code" href="../../d4/d6/memory_8c.html#a8">PFREE_HEADER</a>)((PCH)FreeBlock + allocationSize);
00514         PreviousFreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o0">Next</a> = NewFreeBlock;
00515         NewFreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o0">Next</a> = FreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o0">Next</a>;
00516         NewFreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o1">Size</a> = FreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o1">Size</a> - allocationSize;
00517         NewFreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o2">Segment</a> = FreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o2">Segment</a>;
00518         }
00519 
00520     <span class="comment">//</span>
00521     <span class="comment">// Set up the header for the allocated block.</span>
00522     <span class="comment">//</span>
00523 
00524     BusyBlock = (<a class="code" href="../../d4/d6/memory_8c.html#a10">PBUSY_HEADER</a>)FreeBlock;
00525     BusyBlock-&gt;<a class="code" href="../../d9/d5/struct__BUSY__HEADER.html#o0">Segment</a> = (<a class="code" href="../../d4/d6/memory_8c.html#a6">PSEGMENT_HEADER</a>)((ULONG)FreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o2">Segment</a> |
00526                                            <a class="code" href="../../d4/d6/memory_8c.html#a1">FLAGS_BUSY</a>
00527                                           );
00528     BusyBlock-&gt;<a class="code" href="../../d9/d5/struct__BUSY__HEADER.html#o1">Size</a> = allocationSize;
00529     BusyBlock-&gt;<a class="code" href="../../d9/d5/struct__BUSY__HEADER.html#o2">HandleValue</a> = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00530 
00531     <span class="keywordflow">if</span> (Heap-&gt;<a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o1">ZeroExtraMemory</a>) {
00532      ULONG extraSize;
00533 
00534      extraSize = allocationSize - <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> - <span class="keyword">sizeof</span>( <a class="code" href="../../d9/d5/struct__BUSY__HEADER.html">BUSY_HEADER</a> );
00535      memset( (PCHAR)BusyBlock + (allocationSize - extraSize),
00536             0,
00537             extraSize
00538               );
00539      }
00540 
00541 <span class="preprocessor">#if DBG</span>
00542 <span class="preprocessor"></span>    BusyBlock-&gt;<a class="code" href="../../d9/d5/struct__BUSY__HEADER.html#o3">Spare</a> = 0;
00543 <span class="preprocessor">#endif</span>
00544 <span class="preprocessor"></span>
00545     <span class="comment">//</span>
00546     <span class="comment">// Return the address of the user portion of the allocated block.</span>
00547     <span class="comment">// This is the byte following the header.</span>
00548     <span class="comment">//</span>
00549 
00550     <span class="keywordflow">return</span>( (PVOID)(BusyBlock + 1) );
00551 } <span class="comment">// AlRtAllocateHeap</span>
00552 
00553 
00554 PVOID
<a name="l00555"></a><a class="code" href="../../d4/d6/memory_8c.html#a19">00555</a> <a class="code" href="../../d4/d6/memory_8c.html#a19">AlRtFreeHeap</a>(
00556     IN PVOID HeapHandle,
00557     IN PVOID BaseAddress
00558     )
00559 {
00560     <a class="code" href="../../d4/d6/memory_8c.html#a12">PHEAP_HEADER</a> Heap = (<a class="code" href="../../d4/d6/memory_8c.html#a12">PHEAP_HEADER</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
00561     <a class="code" href="../../d4/d6/memory_8c.html#a8">PFREE_HEADER</a> FreeBlock;
00562     <a class="code" href="../../d4/d6/memory_8c.html#a8">PFREE_HEADER</a> PreviousFreeBlock;
00563     <a class="code" href="../../d4/d6/memory_8c.html#a8">PFREE_HEADER</a> SecondPrevFreeBlock;
00564     <a class="code" href="../../d4/d6/memory_8c.html#a10">PBUSY_HEADER</a> BusyBlock;
00565     <a class="code" href="../../d4/d6/memory_8c.html#a6">PSEGMENT_HEADER</a> BusySegment;
00566     ULONG BusyFlags;
00567     ULONG BusySize;
00568 
00569     <span class="keywordflow">if</span> (BaseAddress == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00570         <span class="keywordflow">return</span>( <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00571         }
00572 
00573     <span class="comment">//</span>
00574     <span class="comment">// Validate that HeapAddress points to a HEAP_HEADER structure.</span>
00575     <span class="comment">//</span>
00576 
00577     <span class="keywordflow">if</span> (Heap-&gt;<a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o0">Length</a> != <span class="keyword">sizeof</span>( <a class="code" href="../../d3/d6/struct__HEAP__HEADER.html">HEAP_HEADER</a> )) {
00578 <span class="preprocessor">#if DBG</span>
00579 <span class="preprocessor"></span>    <a class="code" href="../../d4/d9/arcinst_8h.html#a114">AlPrint</a>( <span class="stringliteral">"ALHEAP: Invalid heap header- %lx\n"</span>, Heap );
00580 <span class="comment">//   RtlpBreakPointHeap();</span>
00581 <span class="preprocessor">#endif // DBG</span>
00582 <span class="preprocessor"></span>        <span class="keywordflow">return</span>( BaseAddress );
00583         }
00584 
00585     <span class="comment">//</span>
00586     <span class="comment">// Additional check, see if the heap is valid, call the heap validation</span>
00587     <span class="comment">// code, requesting it to not dump stuff.</span>
00588     <span class="comment">//</span>
00589     <span class="keywordflow">if</span>(!<a class="code" href="../../d4/d6/memory_8c.html#a17">AlRtValidateHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
00590 
00591 <span class="preprocessor">#if DBG</span>
00592 <span class="preprocessor"></span>        <a class="code" href="../../d4/d9/arcinst_8h.html#a114">AlPrint</a>(<span class="stringliteral">"Heap validation failed\n"</span>);
00593 <span class="preprocessor">#endif</span>
00594 <span class="preprocessor"></span>        <span class="keywordflow">return</span> ( BaseAddress );
00595     }
00596 
00597 
00598     <span class="comment">//</span>
00599     <span class="comment">// Get the 'real' address of the allocation unit.  (That is, the</span>
00600     <span class="comment">// address of the allocation header.)  Make sure the address lies</span>
00601     <span class="comment">// within the bounds of the valid portion of the heap.</span>
00602     <span class="comment">//</span>
00603 
00604     BusyBlock = (<a class="code" href="../../d4/d6/memory_8c.html#a10">PBUSY_HEADER</a>)BaseAddress - 1;
00605     BusyFlags = (ULONG)BusyBlock-&gt;<a class="code" href="../../d9/d5/struct__BUSY__HEADER.html#o0">Segment</a> &amp; <a class="code" href="../../d4/d6/memory_8c.html#a2">FLAGS_MASK</a>;
00606     BusySegment = (<a class="code" href="../../d4/d6/memory_8c.html#a6">PSEGMENT_HEADER</a>)((ULONG)BusyBlock-&gt;<a class="code" href="../../d9/d5/struct__BUSY__HEADER.html#o0">Segment</a> &amp; ~<a class="code" href="../../d4/d6/memory_8c.html#a2">FLAGS_MASK</a>);
00607     BusySize = BusyBlock-&gt;<a class="code" href="../../d9/d5/struct__BUSY__HEADER.html#o1">Size</a>;
00608 
00609     <span class="keywordflow">if</span> (BusyFlags != <a class="code" href="../../d4/d6/memory_8c.html#a1">FLAGS_BUSY</a>
00610 <span class="preprocessor">#if DBG</span>
00611 <span class="preprocessor"></span>        || (BusySegment == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> &amp;&amp;
00612             ((PCHAR)BusyBlock &lt; (PCHAR)Heap-&gt;<a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o2">ValidAddress</a> ||
00613          (PCHAR)BusyBlock &gt;= (PCHAR)Heap-&gt;<a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o3">EndAddress</a>
00614             )
00615         ) ||
00616         (BusySegment != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> &amp;&amp;
00617             (BusyBlock &lt; (<a class="code" href="../../d4/d6/memory_8c.html#a10">PBUSY_HEADER</a>)(BusySegment+1) ||
00618              BusyBlock &gt;= (<a class="code" href="../../d4/d6/memory_8c.html#a10">PBUSY_HEADER</a>)((ULONG)BusySegment + BusySegment-&gt;<a class="code" href="../../d2/d1/struct__SEGMENT__HEADER.html#o1">Size</a>)
00619             )
00620         ) ||
00621         (BusySize &lt; <a class="code" href="../../d4/d6/memory_8c.html#a3">ALLOCATION_GRANULARITY</a>
00622         ) ||
00623         (BusySize &amp; (<a class="code" href="../../d4/d6/memory_8c.html#a3">ALLOCATION_GRANULARITY</a>-1) != 0
00624         )
00625 <span class="preprocessor">#endif // DBG</span>
00626 <span class="preprocessor"></span>       ) {
00627 <span class="preprocessor">#if DBG</span>
00628 <span class="preprocessor"></span>    <a class="code" href="../../d4/d9/arcinst_8h.html#a114">AlPrint</a>( <span class="stringliteral">"ALHEAP: Invalid Address specified to AlRtFreeHeap( %lx, %lx )\n"</span>,
00629                   Heap,
00630                   BaseAddress
00631                 );
00632 <span class="comment">//   RtlpBreakPointHeap();</span>
00633 <span class="preprocessor">#endif // DBG</span>
00634 <span class="preprocessor"></span>        <span class="keywordflow">return</span>( BaseAddress );
00635         }
00636 
00637 
00638     <span class="comment">//</span>
00639     <span class="comment">// Free blocks are stored in the free list in ascending order by</span>
00640     <span class="comment">// base address.  As we search the free list to find the place for</span>
00641     <span class="comment">// this block, we remember the previous two free blocks that we</span>
00642     <span class="comment">// passed through.  These are used during combining of adjacent</span>
00643     <span class="comment">// free blocks.</span>
00644     <span class="comment">//</span>
00645 
00646     SecondPrevFreeBlock = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
00647     PreviousFreeBlock = &amp;Heap-&gt;<a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o5">FreeList</a>;
00648 <span class="preprocessor">#if DBG</span>
00649 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (PreviousFreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o1">Size</a> != 0) {
00650     <a class="code" href="../../d4/d9/arcinst_8h.html#a114">AlPrint</a>( <span class="stringliteral">"ALHEAP: Heap free list HEAD hosed at %lx\n"</span>,
00651                   PreviousFreeBlock
00652                 );
00653 <span class="comment">//   RtlpBreakPointHeap();</span>
00654 
00655         <span class="keywordflow">return</span>( BaseAddress );
00656         }
00657 <span class="preprocessor">#endif // DBG</span>
00658 <span class="preprocessor"></span>
00659     <span class="comment">//</span>
00660     <span class="comment">// Continuous loop.  We'll break out of the loop when we've found</span>
00661     <span class="comment">// the first block of free memory whose address is larger than the</span>
00662     <span class="comment">// address of the block being freed.  (Or the end of the free list.)</span>
00663     <span class="comment">//</span>
00664 
00665     <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00666 
00667         <span class="comment">//</span>
00668         <span class="comment">// Get the address of the next free block.  If we've exhausted</span>
00669         <span class="comment">// the free list, break out of the loop -- the block we're</span>
00670         <span class="comment">// freeing goes at the end of the list.</span>
00671         <span class="comment">//</span>
00672 
00673         FreeBlock = PreviousFreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o0">Next</a>;
00674 
00675         <span class="keywordflow">if</span> (FreeBlock == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00676             <span class="keywordflow">break</span>;
00677             }
00678 
00679 <span class="preprocessor">#if DBG</span>
00680 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (FreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o1">Size</a> == 0) {
00681         <a class="code" href="../../d4/d9/arcinst_8h.html#a114">AlPrint</a>( <span class="stringliteral">"ALHEAP: Heap free list ENTRY hosed at %lx\n"</span>,
00682                       FreeBlock
00683                     );
00684 <span class="comment">//       RtlpBreakPointHeap();</span>
00685 
00686             <span class="keywordflow">return</span>( BaseAddress );
00687             }
00688 <span class="preprocessor">#endif // DBG</span>
00689 <span class="preprocessor"></span>
00690         <span class="comment">//</span>
00691         <span class="comment">// If the address of the current block is higher than the</span>
00692         <span class="comment">// address of the block we're freeing, break out of the loop.</span>
00693         <span class="comment">// The freed block goes immediately before the current block.</span>
00694         <span class="comment">//</span>
00695 
00696         <span class="keywordflow">if</span> (FreeBlock &gt; (<a class="code" href="../../d4/d6/memory_8c.html#a8">PFREE_HEADER</a>)BusyBlock) {
00697             <span class="keywordflow">break</span>;
00698             }
00699 
00700         <span class="comment">//</span>
00701         <span class="comment">// We haven't found the spot yet.  Remember the last two blocks.</span>
00702         <span class="comment">//</span>
00703 
00704         SecondPrevFreeBlock = PreviousFreeBlock;
00705         PreviousFreeBlock = FreeBlock;
00706 
00707         } <span class="comment">// while ( TRUE )</span>
00708 
00709 
00710     <span class="comment">//</span>
00711     <span class="comment">// We've found the place for the block we're freeing.  If the previous</span>
00712     <span class="comment">// block is adjacent to this one, merge the two by summing their sizes,</span>
00713     <span class="comment">// adjusting the address of the block being freed, and making the second</span>
00714     <span class="comment">// previous block the first previous block.  (Note that the previous</span>
00715     <span class="comment">// block may actually be the listhead.  In this case, the if condition</span>
00716     <span class="comment">// will never be true, because the Size of the listhead is 0.)</span>
00717     <span class="comment">//</span>
00718 
00719     <span class="keywordflow">if</span> (((PCH)PreviousFreeBlock + PreviousFreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o1">Size</a>) == (PCH)BusyBlock &amp;&amp;
00720         PreviousFreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o2">Segment</a> == BusySegment
00721        ) {
00722         BusySize += PreviousFreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o1">Size</a>;
00723         BusyBlock = (<a class="code" href="../../d4/d6/memory_8c.html#a10">PBUSY_HEADER</a>)PreviousFreeBlock;
00724         PreviousFreeBlock = SecondPrevFreeBlock;
00725 <span class="preprocessor">#if DBG</span>
00726 <span class="preprocessor"></span>        }
00727     <span class="keywordflow">else</span>
00728     <span class="keywordflow">if</span> ((PreviousFreeBlock != &amp;Heap-&gt;<a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o5">FreeList</a>) &amp;&amp;
00729         ((PCH)PreviousFreeBlock + PreviousFreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o1">Size</a>) &gt; (PCH)BusyBlock
00730        ) {
00731     <a class="code" href="../../d4/d9/arcinst_8h.html#a114">AlPrint</a>( <span class="stringliteral">"ALHEAP: Heap free list overlaps freed block at %lx\n"</span>,
00732                   BusyBlock
00733                 );
00734 <span class="comment">//   RtlpBreakPointHeap();</span>
00735 
00736     <span class="keywordflow">return</span>( BaseAddress );
00737 <span class="preprocessor">#endif // DBG</span>
00738 <span class="preprocessor"></span>        }
00739 
00740     <span class="comment">//</span>
00741     <span class="comment">// If the block being freed is adjacent to the current block, merge</span>
00742     <span class="comment">// the two by summing their sizes and making the next block the</span>
00743     <span class="comment">// current block.  (Note that the current block may not exist, in</span>
00744     <span class="comment">// which case FreeBlock == NULL, and the if condition will not be</span>
00745     <span class="comment">// true.)</span>
00746     <span class="comment">//*** There is an assumption here that we'll never EVER use the</span>
00747     <span class="comment">//*** very highest part of the address space for user mode allocatable</span>
00748     <span class="comment">//*** memory!</span>
00749     <span class="comment">//</span>
00750 
00751     <span class="keywordflow">if</span> (((PCH)BusyBlock + BusySize) == (PCH)FreeBlock &amp;&amp;
00752         FreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o2">Segment</a> == BusySegment
00753        ) {
00754         BusySize += FreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o1">Size</a>;
00755         FreeBlock = FreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o0">Next</a>;
00756 <span class="preprocessor">#if DBG</span>
00757 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (FreeBlock != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00758             <span class="keywordflow">if</span> (FreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o1">Size</a> == 0) {
00759         <a class="code" href="../../d4/d9/arcinst_8h.html#a114">AlPrint</a>( <span class="stringliteral">"ALHEAP: Heap free list ENTRY hosed at %lx\n"</span>,
00760                           FreeBlock
00761                         );
00762 <span class="comment">//       RtlpBreakPointHeap();</span>
00763 
00764         <span class="keywordflow">return</span>( BaseAddress );
00765                 }
00766             }
00767         }
00768     <span class="keywordflow">else</span>
00769     <span class="keywordflow">if</span> ((FreeBlock != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) &amp;&amp;
00770         ((PCH)BusyBlock + BusySize) &gt; (PCH)FreeBlock
00771        ) {
00772     <a class="code" href="../../d4/d9/arcinst_8h.html#a114">AlPrint</a>( <span class="stringliteral">"ALHEAP: Freed block overlaps heap free list at %lx\n"</span>,
00773                   BusyBlock
00774                 );
00775 <span class="comment">//   RtlpBreakPointHeap();</span>
00776 
00777     <span class="keywordflow">return</span>( BaseAddress );
00778 <span class="preprocessor">#endif // DBG</span>
00779 <span class="preprocessor"></span>        }
00780 
00781     <span class="comment">//</span>
00782     <span class="comment">// Done merging.  Update the free list and the free block header.</span>
00783     <span class="comment">//*** May want to reclaim (i.e., release) pages sometime.  That is,</span>
00784     <span class="comment">//*** if we find ourselves with oodles of contiguous pages on the</span>
00785     <span class="comment">//*** free list, we could delete them from our address space.  On</span>
00786     <span class="comment">//*** the other hand, it probably doesn't cost very much to keep</span>
00787     <span class="comment">//*** them around, and if the process needed that much memory once,</span>
00788     <span class="comment">//*** it's likely to need it again.</span>
00789     <span class="comment">//</span>
00790 
00791     PreviousFreeBlock-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o0">Next</a> = (<a class="code" href="../../d4/d6/memory_8c.html#a8">PFREE_HEADER</a>)BusyBlock;
00792     ((<a class="code" href="../../d4/d6/memory_8c.html#a8">PFREE_HEADER</a>)BusyBlock)-&gt;Next = FreeBlock;
00793     ((<a class="code" href="../../d4/d6/memory_8c.html#a8">PFREE_HEADER</a>)BusyBlock)-&gt;<a class="code" href="../../d7/d0/struct__FREE__HEADER.html#o1">Size</a> = BusySize;
00794     ((<a class="code" href="../../d4/d6/memory_8c.html#a8">PFREE_HEADER</a>)BusyBlock)-&gt;Segment = BusySegment;
00795 
00796     <span class="comment">//</span>
00797     <span class="comment">// Release the free list lock and return to the caller.</span>
00798     <span class="comment">//</span>
00799 
00800 
00801     <span class="keywordflow">return</span>( <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00802 } <span class="comment">// AlRtFreeHeap</span>
00803 
00804 
00805 
00806 PVOID
<a name="l00807"></a><a class="code" href="../../d4/d6/memory_8c.html#a20">00807</a> <a class="code" href="../../d4/d6/memory_8c.html#a20">AlRtReAllocateHeap</a>(
00808     IN PVOID HeapHandle,
00809     IN PVOID BaseAddress,
00810     IN ULONG Size
00811     )
00812 {
00813     <a class="code" href="../../d4/d6/memory_8c.html#a12">PHEAP_HEADER</a> Heap = (<a class="code" href="../../d4/d6/memory_8c.html#a12">PHEAP_HEADER</a>)<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>;
00814     PVOID NewBaseAddress;
00815     ULONG allocationSize;
00816     <a class="code" href="../../d4/d6/memory_8c.html#a10">PBUSY_HEADER</a> BusyBlock;
00817     <a class="code" href="../../d4/d6/memory_8c.html#a10">PBUSY_HEADER</a> ExtraBusyBlock;
00818     <a class="code" href="../../d4/d6/memory_8c.html#a6">PSEGMENT_HEADER</a> BusySegment;
00819     ULONG BusyFlags;
00820     ULONG BusySize;
00821     LONG DeltaSize;
00822 
00823     <span class="comment">//</span>
00824     <span class="comment">// Validate that HeapAddress points to a HEAP_HEADER structure.</span>
00825     <span class="comment">//</span>
00826 
00827     <span class="keywordflow">if</span> (Heap-&gt;<a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o0">Length</a> != <span class="keyword">sizeof</span>( <a class="code" href="../../d3/d6/struct__HEAP__HEADER.html">HEAP_HEADER</a> )) {
00828 <span class="preprocessor">#if DBG</span>
00829 <span class="preprocessor"></span>    <a class="code" href="../../d4/d9/arcinst_8h.html#a114">AlPrint</a>( <span class="stringliteral">"ALHEAP: Invalid heap header- %lx\n"</span>, Heap );
00830 <span class="comment">//   RtlpBreakPointHeap();</span>
00831 <span class="preprocessor">#endif // DBG</span>
00832 <span class="preprocessor"></span>        <span class="keywordflow">return</span>( <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00833         }
00834 
00835     <span class="comment">//</span>
00836     <span class="comment">// Additional check, see if the heap is valid, call the heap validation</span>
00837     <span class="comment">// code, requesting it to not dump stuff.</span>
00838     <span class="comment">//</span>
00839     <span class="keywordflow">if</span>(!<a class="code" href="../../d4/d6/memory_8c.html#a17">AlRtValidateHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>)) {
00840 
00841 <span class="preprocessor">#if DBG</span>
00842 <span class="preprocessor"></span>        <a class="code" href="../../d4/d9/arcinst_8h.html#a114">AlPrint</a>(<span class="stringliteral">"Heap validation failed\n"</span>);
00843 <span class="preprocessor">#endif</span>
00844 <span class="preprocessor"></span>        <span class="keywordflow">return</span> ( <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00845     }
00846 
00847 
00848     <span class="comment">//</span>
00849     <span class="comment">// Round the requested size up to the allocation granularity.  Note</span>
00850     <span class="comment">// that if the request is for 0 bytes, we still allocate memory.</span>
00851     <span class="comment">//</span>
00852 
00853     allocationSize = ((<a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> ? <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> : <a class="code" href="../../d4/d6/memory_8c.html#a3">ALLOCATION_GRANULARITY</a>) +
00854                       <span class="keyword">sizeof</span>( <a class="code" href="../../d9/d5/struct__BUSY__HEADER.html">BUSY_HEADER</a> ) +
00855                       <a class="code" href="../../d4/d6/memory_8c.html#a3">ALLOCATION_GRANULARITY</a> -
00856                       1
00857                      ) &amp; ~(<a class="code" href="../../d4/d6/memory_8c.html#a3">ALLOCATION_GRANULARITY</a> - 1);
00858 
00859     <span class="keywordflow">if</span> (allocationSize &lt; <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>) {
00860 <span class="preprocessor">#if DBG</span>
00861 <span class="preprocessor"></span>    <a class="code" href="../../d4/d9/arcinst_8h.html#a114">AlPrint</a>( <span class="stringliteral">"ALHEAP: Invalid heap size - %lx\n"</span>, <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> );
00862 <span class="comment">//   RtlpBreakPointHeap();</span>
00863 <span class="preprocessor">#endif // DBG</span>
00864 <span class="preprocessor"></span>        <span class="keywordflow">return</span>( <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00865         }
00866 
00867     <span class="keywordflow">if</span> (BaseAddress == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00868 <span class="preprocessor">#if DBG</span>
00869 <span class="preprocessor"></span>    <a class="code" href="../../d4/d9/arcinst_8h.html#a114">AlPrint</a>( <span class="stringliteral">"ALHEAP: Invalid heap address - %lx\n"</span>, BaseAddress );
00870 <span class="comment">//   RtlpBreakPointHeap();</span>
00871 <span class="preprocessor">#endif // DBG</span>
00872 <span class="preprocessor"></span>        <span class="keywordflow">return</span>( <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00873         }
00874 
00875     <span class="comment">//</span>
00876     <span class="comment">// Get the 'real' address of the allocation unit.  (That is, the</span>
00877     <span class="comment">// address of the allocation header.)  Make sure the address lies</span>
00878     <span class="comment">// within the bounds of the valid portion of the heap.</span>
00879     <span class="comment">//</span>
00880 
00881     BusyBlock = (<a class="code" href="../../d4/d6/memory_8c.html#a10">PBUSY_HEADER</a>)BaseAddress - 1;
00882     BusySize = BusyBlock-&gt;<a class="code" href="../../d9/d5/struct__BUSY__HEADER.html#o1">Size</a>;
00883     BusySegment = (<a class="code" href="../../d4/d6/memory_8c.html#a6">PSEGMENT_HEADER</a>)((ULONG)BusyBlock-&gt;<a class="code" href="../../d9/d5/struct__BUSY__HEADER.html#o0">Segment</a> &amp; ~<a class="code" href="../../d4/d6/memory_8c.html#a2">FLAGS_MASK</a>);
00884     BusyFlags = (ULONG)BusyBlock-&gt;<a class="code" href="../../d9/d5/struct__BUSY__HEADER.html#o0">Segment</a> &amp; <a class="code" href="../../d4/d6/memory_8c.html#a2">FLAGS_MASK</a>;
00885 
00886     <span class="keywordflow">if</span> (BusyFlags != <a class="code" href="../../d4/d6/memory_8c.html#a1">FLAGS_BUSY</a>
00887 <span class="preprocessor">#if DBG</span>
00888 <span class="preprocessor"></span>        || (BusySegment == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> &amp;&amp;
00889             ((PCHAR)BusyBlock &lt; (PCHAR)Heap-&gt;<a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o2">ValidAddress</a> ||
00890          (PCHAR)BusyBlock &gt;= (PCHAR)Heap-&gt;<a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o3">EndAddress</a>
00891             )
00892         ) ||
00893         (BusySegment != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> &amp;&amp;
00894             (BusyBlock &lt; (<a class="code" href="../../d4/d6/memory_8c.html#a10">PBUSY_HEADER</a>)(BusySegment+1) ||
00895              BusyBlock &gt;= (<a class="code" href="../../d4/d6/memory_8c.html#a10">PBUSY_HEADER</a>)((ULONG)BusySegment + BusySegment-&gt;<a class="code" href="../../d2/d1/struct__SEGMENT__HEADER.html#o1">Size</a>)
00896             )
00897         ) ||
00898         (BusySize &lt; <a class="code" href="../../d4/d6/memory_8c.html#a3">ALLOCATION_GRANULARITY</a>
00899         ) ||
00900         (BusySize &amp; (<a class="code" href="../../d4/d6/memory_8c.html#a3">ALLOCATION_GRANULARITY</a>-1) != 0
00901         )
00902 <span class="preprocessor">#endif // DBG</span>
00903 <span class="preprocessor"></span>       ) {
00904 <span class="preprocessor">#if DBG</span>
00905 <span class="preprocessor"></span>    <a class="code" href="../../d4/d9/arcinst_8h.html#a114">AlPrint</a>( <span class="stringliteral">"ALHEAP: Invalid Address specified to AlRtFreeHeap( %lx, %lx )\n"</span>,
00906                   Heap,
00907                   BaseAddress
00908                 );
00909 <span class="comment">//   RtlpBreakPointHeap();</span>
00910 <span class="preprocessor">#endif // DBG</span>
00911 <span class="preprocessor"></span>        <span class="keywordflow">return</span>( <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a> );
00912         }
00913 
00914 
00915     <span class="comment">//</span>
00916     <span class="comment">// See if new size less than or equal to the current size.</span>
00917     <span class="comment">//</span>
00918 
00919     DeltaSize = (LONG)(BusySize - allocationSize);
00920     <span class="keywordflow">if</span> (DeltaSize &gt;= 0) {
00921         <span class="comment">//</span>
00922         <span class="comment">// Then shrinking block.  If amount of shrinkage is less than</span>
00923         <span class="comment">// the size of a free block, then nothing to do.</span>
00924         <span class="comment">//</span>
00925 
00926         <span class="keywordflow">if</span> (DeltaSize &lt; <span class="keyword">sizeof</span>( <a class="code" href="../../d7/d0/struct__FREE__HEADER.html">FREE_HEADER</a> )) {
00927             <span class="keywordflow">if</span> (Heap-&gt;<a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o1">ZeroExtraMemory</a>) {
00928         memset( (PCHAR)BusyBlock + (allocationSize - DeltaSize),0,
00929                                DeltaSize
00930                              );
00931                 }
00932 
00933             <span class="keywordflow">return</span>( BaseAddress );
00934             }
00935 
00936         <span class="comment">//</span>
00937         <span class="comment">// Otherwise, shrink size of this block to new size, and make extra</span>
00938     <span class="comment">// space at end look like another busy block and call AlRtFreeHeap</span>
00939         <span class="comment">// to free it.</span>
00940         <span class="comment">//</span>
00941 
00942         BusyBlock-&gt;<a class="code" href="../../d9/d5/struct__BUSY__HEADER.html#o1">Size</a> = allocationSize;
00943         ExtraBusyBlock = (<a class="code" href="../../d4/d6/memory_8c.html#a10">PBUSY_HEADER</a>)((PCH)BusyBlock + allocationSize);
00944         ExtraBusyBlock-&gt;<a class="code" href="../../d9/d5/struct__BUSY__HEADER.html#o0">Segment</a> = BusyBlock-&gt;<a class="code" href="../../d9/d5/struct__BUSY__HEADER.html#o0">Segment</a>;
00945         ExtraBusyBlock-&gt;<a class="code" href="../../d9/d5/struct__BUSY__HEADER.html#o1">Size</a> = (ULONG)(DeltaSize);
00946 <span class="preprocessor">#if DBG</span>
00947 <span class="preprocessor"></span>    ExtraBusyBlock-&gt;<a class="code" href="../../d9/d5/struct__BUSY__HEADER.html#o3">Spare</a> = 0;
00948 <span class="preprocessor">#endif</span>
00949 <span class="preprocessor"></span>
00950     <a class="code" href="../../d4/d6/memory_8c.html#a19">AlRtFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, (PVOID)(ExtraBusyBlock+1) );
00951 
00952         <span class="keywordflow">if</span> (Heap-&gt;<a class="code" href="../../d3/d6/struct__HEAP__HEADER.html#o1">ZeroExtraMemory</a>) {
00953             ULONG extraSize;
00954 
00955             extraSize = allocationSize - <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> - <span class="keyword">sizeof</span>( <a class="code" href="../../d9/d5/struct__BUSY__HEADER.html">BUSY_HEADER</a> );
00956         memset( (PCHAR)BusyBlock + (allocationSize - extraSize),0,
00957                            extraSize
00958                          );
00959             }
00960 
00961         <span class="keywordflow">return</span>( BaseAddress );
00962         }
00963 
00964     <span class="comment">//</span>
00965     <span class="comment">// Otherwise growing block, so allocate a new block with the bigger</span>
00966     <span class="comment">// size, copy the contents of the old block to the new block and then</span>
00967     <span class="comment">// free the old block.  Return the address of the new block.</span>
00968     <span class="comment">//</span>
00969 
00970     NewBaseAddress = <a class="code" href="../../d4/d6/memory_8c.html#a18">AlRtAllocateHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> );
00971     <span class="keywordflow">if</span> (NewBaseAddress != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
00972 <span class="preprocessor">#if DBG</span>
00973 <span class="preprocessor"></span>        ExtraBusyBlock = (<a class="code" href="../../d4/d6/memory_8c.html#a10">PBUSY_HEADER</a>)NewBaseAddress - 1;
00974     ExtraBusyBlock-&gt;<a class="code" href="../../d9/d5/struct__BUSY__HEADER.html#o3">Spare</a> = 0;
00975 <span class="preprocessor">#endif</span>
00976 <span class="preprocessor"></span>    memmove( NewBaseAddress,
00977                        BaseAddress,
00978                        BusySize - <span class="keyword">sizeof</span>( <a class="code" href="../../d9/d5/struct__BUSY__HEADER.html">BUSY_HEADER</a> )
00979                      );
00980 
00981     <a class="code" href="../../d4/d6/memory_8c.html#a19">AlRtFreeHeap</a>( <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>, BaseAddress );
00982         }
00983 
00984     <span class="keywordflow">return</span>( NewBaseAddress );
00985 }
00986 
00987 
00988 
00989 
00990 <a class="code" href="../../d1/d9/arc_8h.html#a44">ARC_STATUS</a>
<a name="l00991"></a><a class="code" href="../../d4/d6/memory_8c.html#a21">00991</a> <a class="code" href="../../d4/d6/memory_8c.html#a21">AlMemoryInitialize</a> (
00992     ULONG StackPages,
00993     ULONG HeapPages
00994     )
00995 
00996 <span class="comment">/*++</span>
00997 <span class="comment"></span>
00998 <span class="comment">Routine Description:</span>
00999 <span class="comment"></span>
01000 <span class="comment">    This routine allocates stack space for the OS loader, initializes</span>
01001 <span class="comment">    heap storage, and initializes the memory allocation list.</span>
01002 <span class="comment"></span>
01003 <span class="comment">Arguments:</span>
01004 <span class="comment"></span>
01005 <span class="comment">    None.</span>
01006 <span class="comment"></span>
01007 <span class="comment">Return Value:</span>
01008 <span class="comment"></span>
01009 <span class="comment">    ESUCCESS is returned if the initialization is successful. Otherwise,</span>
01010 <span class="comment">    ENOMEM is returned.</span>
01011 <span class="comment"></span>
01012 <span class="comment">--*/</span>
01013 
01014 {
01015 
01016     <a class="code" href="../../d3/d8/struct__MEMORY__DESCRIPTOR.html">PMEMORY_DESCRIPTOR</a> FreeDescriptor;
01017     <a class="code" href="../../d3/d8/struct__MEMORY__DESCRIPTOR.html">PMEMORY_DESCRIPTOR</a> ProgramDescriptor;
01018 
01019     <span class="comment">//</span>
01020     <span class="comment">// Find the memory descriptor that describes the allocation for the OS</span>
01021     <span class="comment">// loader itself.</span>
01022     <span class="comment">//</span>
01023 
01024     ProgramDescriptor = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01025     <span class="keywordflow">while</span> ((ProgramDescriptor = <a class="code" href="../../d1/d9/arc_8h.html#a26">ArcGetMemoryDescriptor</a>(ProgramDescriptor)) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01026         <span class="keywordflow">if</span> (ProgramDescriptor-&gt;<a class="code" href="../../d3/d8/struct__MEMORY__DESCRIPTOR.html#o0">MemoryType</a> == <a class="code" href="../../d1/d9/arc_8h.html#a316a232">MemoryLoadedProgram</a>) {
01027             <span class="keywordflow">break</span>;
01028         }
01029     }
01030 
01031     <span class="comment">//</span>
01032     <span class="comment">// If a loaded program memory descriptor was found, then it must be</span>
01033     <span class="comment">// for the OS loader since that is the only program that can be loaded.</span>
01034     <span class="comment">// If a loaded program memory descriptor was not found, then firmware</span>
01035     <span class="comment">// is not functioning properly and an unsuccessful status is returned.</span>
01036     <span class="comment">//</span>
01037 
01038     <span class="keywordflow">if</span> (ProgramDescriptor == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01039         <span class="keywordflow">return</span> <a class="code" href="../../d2/d9/arccodes_8h.html#a24a17">ENOMEM</a>;
01040     }
01041 
01042     <span class="comment">//</span>
01043     <span class="comment">// Find the free memory descriptor that is just below the loaded</span>
01044     <span class="comment">// program in memory. There should be several megabytes of free</span>
01045     <span class="comment">// memory just preceeding the OS loader.</span>
01046     <span class="comment">//</span>
01047 
01048     FreeDescriptor = <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>;
01049     <span class="keywordflow">while</span> ((FreeDescriptor = <a class="code" href="../../d1/d9/arc_8h.html#a26">ArcGetMemoryDescriptor</a>(FreeDescriptor)) != <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01050         <span class="keywordflow">if</span> ((FreeDescriptor-&gt;<a class="code" href="../../d3/d8/struct__MEMORY__DESCRIPTOR.html#o0">MemoryType</a> == <a class="code" href="../../d1/d9/arc_8h.html#a316a230">MemoryFree</a>) &amp;&amp;
01051             (FreeDescriptor-&gt;<a class="code" href="../../d3/d8/struct__MEMORY__DESCRIPTOR.html#o2">PageCount</a> &gt;= (StackPages+HeapPages))) {
01052             <span class="keywordflow">break</span>;
01053         }
01054     }
01055 
01056     <span class="comment">//</span>
01057     <span class="comment">// If a free memory descriptor was not found that describes the free</span>
01058     <span class="comment">// memory just below the OS loader, then firmware is not functioning</span>
01059     <span class="comment">// properly and an unsuccessful status is returned.</span>
01060     <span class="comment">//</span>
01061 
01062     <span class="keywordflow">if</span> (FreeDescriptor == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>) {
01063         <span class="keywordflow">return</span> <a class="code" href="../../d2/d9/arccodes_8h.html#a24a17">ENOMEM</a>;
01064     }
01065 
01066     <span class="comment">//</span>
01067     <span class="comment">// Check to determine if enough free memory is available for the OS</span>
01068     <span class="comment">// loader stack and the heap area. If enough memory is not available,</span>
01069     <span class="comment">// then return an unsuccessful status.</span>
01070     <span class="comment">//</span>
01071 
01072     <span class="keywordflow">if</span> (FreeDescriptor-&gt;<a class="code" href="../../d3/d8/struct__MEMORY__DESCRIPTOR.html#o2">PageCount</a> &lt; (StackPages + HeapPages)) {
01073         <span class="keywordflow">return</span> <a class="code" href="../../d2/d9/arccodes_8h.html#a24a17">ENOMEM</a>;
01074     }
01075 
01076     <span class="comment">//</span>
01077     <span class="comment">// Compute the address of the loader heap, initialize the heap</span>
01078     <span class="comment">// allocation variables, and zero the heap memory.</span>
01079     <span class="comment">//</span>
01080 
01081     <a class="code" href="../../d4/d6/memory_8c.html#a13">AlHeapFree</a> = <a class="code" href="../../d6/d7/halmips_8h.html#a443">KSEG0_BASE</a> | ((ProgramDescriptor-&gt;<a class="code" href="../../d3/d8/struct__MEMORY__DESCRIPTOR.html#o1">BasePage</a> -
01082                 (StackPages + HeapPages)) &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
01083 
01084     <a class="code" href="../../d4/d6/memory_8c.html#a14">AlHeapLimit</a> = <a class="code" href="../../d4/d6/memory_8c.html#a13">AlHeapFree</a> + (HeapPages &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
01085 
01086     memset((PVOID)<a class="code" href="../../d4/d6/memory_8c.html#a13">AlHeapFree</a>, 0,HeapPages &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>);
01087 
01088 
01089     <span class="comment">//</span>
01090     <span class="comment">// Changed to new heap allocater</span>
01091     <span class="comment">//</span>
01092 
01093     <span class="keywordflow">if</span> ((<a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a> = <a class="code" href="../../d4/d6/memory_8c.html#a16">AlRtCreateHeap</a>
01094             (
01095             <a class="code" href="../../d4/d6/memory_8c.html#a4">HEAP_ZERO_EXTRA_MEMORY</a>,
01096             (PVOID)<a class="code" href="../../d4/d6/memory_8c.html#a13">AlHeapFree</a>,
01097             HeapPages &lt;&lt; <a class="code" href="../../d6/d7/halmips_8h.html#a447">PAGE_SHIFT</a>
01098             ))
01099             == <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a3">NULL</a>)
01100        <span class="keywordflow">return</span> <a class="code" href="../../d2/d9/arccodes_8h.html#a24a17">ENOMEM</a>;
01101     <span class="keywordflow">else</span>
01102        <span class="keywordflow">return</span> <a class="code" href="../../d2/d9/arccodes_8h.html#a24a1">ESUCCESS</a>;
01103 
01104 }
01105 
01106 
01107 <span class="comment">//</span>
01108 <span class="comment">// AlAllocateHeap.</span>
01109 <span class="comment">//</span>
01110 <span class="comment">//    Heap space allocator.  Size is in bytes required.</span>
01111 
01112 PVOID
<a name="l01113"></a><a class="code" href="../../d4/d6/memory_8c.html#a22">01113</a> <a class="code" href="../../d4/d6/memory_8c.html#a22">AlAllocateHeap</a> (
01114     IN ULONG Size
01115     )
01116 {
01117     <span class="keywordflow">return</span> (<a class="code" href="../../d4/d6/memory_8c.html#a18">AlRtAllocateHeap</a>
01118          (
01119          <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>,
01120          <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a>
01121          ));
01122 
01123 }
01124 
01125 
01126 
01127 <span class="comment">// 3. AlDeallocateHeap</span>
01128 <span class="comment">//</span>
01129 <span class="comment">//    Heap Deallocation needs to be defined and implemented.</span>
01130 <span class="comment">//</span>
01131 <span class="comment">//</span>
01132 
01133 PVOID
<a name="l01134"></a><a class="code" href="../../d4/d6/memory_8c.html#a23">01134</a> <a class="code" href="../../d4/d6/memory_8c.html#a23">AlDeallocateHeap</a> (
01135     IN PVOID HeapAddress
01136     )
01137 {
01138     <span class="keywordflow">return</span> (<a class="code" href="../../d4/d6/memory_8c.html#a19">AlRtFreeHeap</a>
01139         (
01140         <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>,
01141         HeapAddress
01142         ));
01143 }
01144 
01145 
01146 <span class="comment">//</span>
01147 <span class="comment">// 4. AlReallocateHeap</span>
01148 <span class="comment">//</span>
01149 <span class="comment">//</span>
01150 <span class="comment">//</span>
01151 
01152 PVOID
<a name="l01153"></a><a class="code" href="../../d4/d6/memory_8c.html#a24">01153</a> <a class="code" href="../../d4/d6/memory_8c.html#a24">AlReallocateHeap</a> (
01154     IN PVOID HeapAddress,
01155     IN ULONG NewSize
01156     )
01157 {
01158     <span class="keywordflow">return</span> (<a class="code" href="../../d4/d6/memory_8c.html#a20">AlRtReAllocateHeap</a>
01159         (
01160         <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>,
01161         HeapAddress,
01162         NewSize
01163         ));
01164 }
01165 
01166 <span class="comment">//</span>
01167 <span class="comment">// 5. AlValidateHeap</span>
01168 <span class="comment">//</span>
01169 <span class="comment">//    Heap validation</span>
01170 <span class="comment">//</span>
01171 <span class="comment">//</span>
01172 
01173 BOOLEAN
<a name="l01174"></a><a class="code" href="../../d4/d6/memory_8c.html#a25">01174</a> <a class="code" href="../../d4/d6/memory_8c.html#a25">AlValidateHeap</a>(
01175     IN BOOLEAN DumpHeap
01176     )
01177 {
01178     <span class="keywordflow">return</span> (<a class="code" href="../../d4/d6/memory_8c.html#a17">AlRtValidateHeap</a>
01179                 (
01180                 <a class="code" href="../../d4/d6/memory_8c.html#a15">HeapHandle</a>,
01181                 DumpHeap
01182                 ));
01183 }
01184 
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:40:43 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
