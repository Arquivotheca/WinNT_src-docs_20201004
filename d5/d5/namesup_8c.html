<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: namesup.c File Reference</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>namesup.c File Reference</h1><code>#include "UdfProcs.h"</code><br>

<p>
<a href="../../d6/d4/namesup_8c-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d5/namesup_8c.html#a0">BugCheckFileId</a>&nbsp;&nbsp;&nbsp;(UDFS_BUG_CHECK_NAMESUP)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d5/namesup_8c.html#a1">Dbg</a>&nbsp;&nbsp;&nbsp;(UDFS_DEBUG_LEVEL_NAMESUP)</td></tr>

<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>INLINE ULONG&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d5/namesup_8c.html#a3">NativeDosCharLength</a> (IN WCHAR Wchar)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d5/namesup_8c.html#a4">UdfDissectName</a> (IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext, IN OUT PUNICODE_STRING RemainingName, OUT PUNICODE_STRING FinalName)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d5/namesup_8c.html#a5">UdfIs8dot3Name</a> (IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext, IN UNICODE_STRING <a class="el" href="../../d8/d1/hivestat_8c.html#a9">FileName</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d5/namesup_8c.html#a6">UdfCandidateShortName</a> (IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext, IN PUNICODE_STRING <a class="el" href="../../d9/d3/rules_8c.html#a6">Name</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d5/namesup_8c.html#a7">UdfGenerate8dot3Name</a> (IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext, IN PUNICODE_STRING <a class="el" href="../../d8/d1/hivestat_8c.html#a9">FileName</a>, OUT PUNICODE_STRING ShortFileName)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d5/namesup_8c.html#a8">UdfConvertCS0DstringToUnicode</a> (IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext, IN PUCHAR Dstring, IN UCHAR Length OPTIONAL, IN UCHAR FieldLength OPTIONAL, IN OUT PUNICODE_STRING <a class="el" href="../../d9/d3/rules_8c.html#a6">Name</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d5/namesup_8c.html#a9">UdfCheckLegalCS0Dstring</a> (<a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext, PUCHAR Dstring, UCHAR Length OPTIONAL, UCHAR FieldLength OPTIONAL, BOOLEAN ReturnOnError)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>VOID&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d5/namesup_8c.html#a10">UdfRenderNameToLegalUnicode</a> (IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext, IN PUNICODE_STRING <a class="el" href="../../d9/d3/rules_8c.html#a6">Name</a>, IN PUNICODE_STRING RenderedName)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>BOOLEAN&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d5/namesup_8c.html#a11">UdfIsNameInExpression</a> (IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext, IN PUNICODE_STRING CurrentName, IN PUNICODE_STRING SearchExpression, IN BOOLEAN Wild)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="../../d1/d8/fsrtl_8h.html#a70">FSRTL_COMPARISON_RESULT</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d5/namesup_8c.html#a12">UdfFullCompareNames</a> (IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a> IrpContext, IN PUNICODE_STRING NameA, IN PUNICODE_STRING NameB)</td></tr>

<tr><td colspan=2><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>CONST <a class="el" href="../../d2/d1/bench_8h.html#a8">CHAR</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="../../d5/d5/namesup_8c.html#a2">UdfCrcChar</a> [] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ#_~-@"</td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="a0" doxytag="namesup.c::BugCheckFileId" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define BugCheckFileId&nbsp;&nbsp;&nbsp;(UDFS_BUG_CHECK_NAMESUP)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d4/namesup_8c-source.html#l00027">27</a> of file <a class="el" href="../../d6/d4/namesup_8c-source.html">namesup.c</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="namesup.c::Dbg" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define Dbg&nbsp;&nbsp;&nbsp;(UDFS_DEBUG_LEVEL_NAMESUP)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d4/namesup_8c-source.html#l00033">33</a> of file <a class="el" href="../../d6/d4/namesup_8c-source.html">namesup.c</a>.    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a3" doxytag="namesup.c::NativeDosCharLength" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> INLINE ULONG NativeDosCharLength           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN WCHAR&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>Wchar</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d4/namesup_8c-source.html#l00056">56</a> of file <a class="el" href="../../d6/d4/namesup_8c-source.html">namesup.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d2/d0/bench_8c-source.html#l00050">CHAR</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d0/d6/iop_8h.html#a144">NTSTATUS()</a>, <a class="el" href="../../d0/d6/nlsxlat_8c-source.html#l01433">RtlUpcaseUnicodeToOemN()</a>, and <a class="el" href="../../d3/d0/cttoken_8c-source.html#l00135">Status</a>.
<p>
Referenced by <a class="el" href="../../d6/d4/namesup_8c-source.html#l00389">UdfGenerate8dot3Name()</a>.
<p>
<pre class="fragment"><div>00062                    :
00063 
00064     This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a46">translation</a> layer <span class="keywordflow">for</span> asking how big a given UNICODE
00065     character will be when converted to OEM.  Aside from adding more material
00066     to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> kernel export table, <span class="keyword">this</span> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> how ya <span class="keywordflow">do</span> <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a>.
00067 
00068 Arguments:
00069 
00070     Wchar - pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> character
00071 
00072 Return Value:
00073 
00074     <a class="code" href="../../d8/d7/lh__open_2pi__mem_8h.html#a0">Size</a> in bytes.
00075 
00076 --*/
00077 
00078 {
00079     <a class="code" href="../../d0/d6/iop_8h.html#a144">NTSTATUS</a> <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a>;
00080     <a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a> OemBuf[2];
00081     ULONG Length;
00082 
00083     <a class="code" href="../../d1/d0/cmchek_8c.html#a4">Status</a> = <a class="code" href="../../d9/d6/nlsxlat_8c.html#a40">RtlUpcaseUnicodeToOemN</a>( OemBuf,
00084                                      <span class="keyword">sizeof</span>(OemBuf),
00085                                      &amp;Length,
00086                                      &amp;Wchar,
00087                                      <span class="keyword">sizeof</span>(WCHAR));
00088     
00089     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( Status ));
00090 
00091     <span class="keywordflow">return</span> Length;
00092 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="namesup.c::UdfCandidateShortName" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN UdfCandidateShortName           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>IrpContext</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PUNICODE_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>Name</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d4/namesup_8c-source.html#l00301">301</a> of file <a class="el" href="../../d6/d4/namesup_8c-source.html">namesup.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d2/d7/udfdata_8h-source.html#l00352">ASSERT_IRP_CONTEXT</a>, <a class="el" href="../../d0/d7/udf_8h-source.html#l00205">BYTE_COUNT_8_DOT_3</a>, <a class="el" href="../../d0/d7/udf_8h-source.html#l00240">CRC_MARK</a>, <a class="el" href="../../d0/d7/udf_8h-source.html#l00227">DOS_CRC_LEN</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d2/d9/cmchek_8c-source.html#l00095">Index</a>, <a class="el" href="../../d9/d9/geninst_8c-source.html#l00154">Name</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d0/d7/udf_8h-source.html#l00238">PERIOD</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
Referenced by <a class="el" href="../../d4/d7/udfs_2create_8c-source.html#l00108">UdfCommonCreate()</a>.
<p>
<pre class="fragment"><div>00308                    :
00309 
00310     This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> called to determine <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> input name could be a generated
00311     <span class="keywordtype">short</span> name.
00312 
00313 Arguments:
00314 
00315     <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a> - Pointer to <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> name to stare at.
00316 
00317 Return Value:
00318 
00319     BOOLEAN True <span class="keywordflow">if</span> <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> possible that <span class="keyword">this</span> <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a shortname, False otherwise.
00320 
00321 --*/
00322 
00323 {
00324     ULONG <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>, SubIndex;
00325     BOOLEAN LooksShort = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00326     
00327     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00328 
00329     <span class="comment">//</span>
00330     <span class="comment">//  Check inputs.</span>
00331     <span class="comment">//</span>
00332 
00333     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
00334 
00335     <span class="comment">//</span>
00336     <span class="comment">//  The length can't be larger than an 8.3 name and must be</span>
00337     <span class="comment">//  at least as big as the uniqifier stamp.</span>
00338     <span class="comment">//</span>
00339 
00340     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length != 0 );
00341     
00342     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length &gt; <a class="code" href="../../d9/d7/udf_8h.html#a11">BYTE_COUNT_8_DOT_3</a> ||
00343         <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length &lt; <a class="code" href="../../d9/d7/udf_8h.html#a18">DOS_CRC_LEN</a> * <span class="keyword">sizeof</span>(WCHAR)) {
00344 
00345         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00346     }
00347     
00348     <span class="comment">//</span>
00349     <span class="comment">//  Walk across the name looking for the uniquifier stamp.  The stamp</span>
00350     <span class="comment">//  is of the form #&lt;hex&gt;&lt;hex&gt;&lt;hex&gt; so if we can stop before the end</span>
00351     <span class="comment">//  of the full name.</span>
00352     <span class="comment">//</span>
00353     
00354     <span class="keywordflow">for</span> ( <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> = 0;
00355           <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> &lt;= (<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length / <span class="keyword">sizeof</span>(WCHAR)) - <a class="code" href="../../d9/d7/udf_8h.html#a18">DOS_CRC_LEN</a>;
00356           <a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>++ ) {
00357 
00358         <span class="comment">//</span>
00359         <span class="comment">//  Is the current character the stamp UDF uses to offset the stamp?</span>
00360         <span class="comment">//</span>
00361         
00362         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a>] == <a class="code" href="../../d9/d7/udf_8h.html#a28">CRC_MARK</a>) {
00363         
00364             <span class="comment">//</span>
00365             <span class="comment">//  We may potentially have just a CRC at the end</span>
00366             <span class="comment">//  of the name OR have a period following.  If we</span>
00367             <span class="comment">//  do, it is reasonable to think the name may be</span>
00368             <span class="comment">//  a generated shorty.</span>
00369             <span class="comment">//</span>
00370             <span class="comment">//  #123 (a very special case - orignal name was ".")</span>
00371             <span class="comment">//  FOO#123</span>
00372             <span class="comment">//  FOO#123.TXT</span>
00373             <span class="comment">//</span>
00374             
00375             <span class="keywordflow">if</span> (<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> == (<a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length / <span class="keyword">sizeof</span>(WCHAR)) - <a class="code" href="../../d9/d7/udf_8h.html#a18">DOS_CRC_LEN</a> ||
00376                 <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer[<a class="code" href="../../d1/d0/cmchek_8c.html#a10">Index</a> + <a class="code" href="../../d9/d7/udf_8h.html#a18">DOS_CRC_LEN</a>] == <a class="code" href="../../d9/d7/udf_8h.html#a26">PERIOD</a>) {
00377 
00378                 LooksShort = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00379                 <span class="keywordflow">break</span>;
00380             }
00381         }
00382     }
00383 
00384     <span class="keywordflow">return</span> LooksShort;
00385 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="namesup.c::UdfCheckLegalCS0Dstring" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN UdfCheckLegalCS0Dstring           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>IrpContext</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>PUCHAR&nbsp;</td>
          <td class="mdname" nowrap> <em>Dstring</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>UCHAR Length&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>UCHAR FieldLength&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>ReturnOnError</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d4/namesup_8c-source.html#l00819">819</a> of file <a class="el" href="../../d6/d4/namesup_8c-source.html">namesup.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d2/d7/udfdata_8h-source.html#l00352">ASSERT_IRP_CONTEXT</a>, <a class="el" href="../../d0/d5/cdfs__rec_8c-source.html#l00032">Dbg</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l02290">DebugTrace</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d6/d4/cc_8h-source.html#l00497">FlagOn</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, and <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00406">UdfRaiseStatus()</a>.
<p>
Referenced by <a class="el" href="../../d5/d7/dirsup_8c-source.html#l00360">UdfUpdateDirNames()</a>, and <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l04056">UdfUpdateVolumeLabel()</a>.
<p>
<pre class="fragment"><div>00829                    :
00830 
00831     This routine inspects a CS0 Dstring <span class="keywordflow">for</span> conformance.
00832     
00833 Arguments:
00834 
00835     Dstring - a dstring to check
00836     
00837     Length - length of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> dstring.  If unspecified, we assume that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> characters come
00838         from a proper 1/7.2.12 dstring that specifies length in <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> last character of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a>
00839         field.
00840     
00841     FieldLength - length of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> dstring field.  If unspecified, we assume that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> characters
00842         come from an uncounted length of CS0 characters and that <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> Length parameter <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
00843         specified.
00844     
00845     ReturnOnError - whether to <span class="keywordflow">return</span> or raise on a discovered error
00846     
00847 Return Value:
00848 
00849     None. Raised status <span class="keywordflow">if</span> corruption <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> found.
00850     
00851 --*/
00852 
00853 {
00854     UCHAR NameLength;
00855 
00856     <span class="comment">//</span>
00857     <span class="comment">//  Check input.</span>
00858     <span class="comment">//</span>
00859 
00860     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
00861 
00862     <span class="comment">//</span>
00863     <span class="comment">//  If the length is unspecified, this is a real 1/7.2.12 dstring and the length is in</span>
00864     <span class="comment">//  the last character of the field.</span>
00865     <span class="comment">//</span>
00866     
00867     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( Length || FieldLength );
00868 
00869     <span class="keywordflow">if</span> (Length) {
00870 
00871         NameLength = FieldLength = Length;
00872     
00873     } <span class="keywordflow">else</span> {
00874 
00875         NameLength = *(Dstring + FieldLength - 1);
00876     }
00877 
00878     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( +1, Dbg,
00879                  <span class="stringliteral">"UdfCheckLegalCS0Dstring, Dstring %08x Length %02x FieldLength %02x (NameLength %02x)\n"</span>,
00880                  Dstring,
00881                  Length,
00882                  FieldLength,
00883                  NameLength ));
00884 
00885     <span class="comment">//</span>
00886     <span class="comment">//  The string must be "compressed" in 8bit or 16bit chunks.  If it</span>
00887     <span class="comment">//  is in 16bit chunks, we better have an integral number of them -</span>
00888     <span class="comment">//  remember we have the compression ID, so the length will be odd.</span>
00889     <span class="comment">//</span>
00890     
00891     <span class="keywordflow">if</span> ((NameLength &lt;= 1 &amp;&amp;
00892          <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg,
00893                       <span class="stringliteral">"UdfCheckLegalCS0Dstring, NameLength is too small!\n"</span> ))) ||
00894 
00895         (NameLength &gt; FieldLength &amp;&amp;
00896          <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg,
00897                       <span class="stringliteral">"UdfCheckLegalCS0Dstring, NameLength is bigger than the field itself!\n"</span> ))) ||
00898 
00899         ((*Dstring != 8 &amp;&amp; *Dstring != 16) &amp;&amp;
00900          <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg,
00901                       <span class="stringliteral">"UdfCheckLegalCS0Dstring, claims encoding %02x, unknown! (not 0x8 or 0x10)\n"</span>,
00902                       *Dstring ))) ||
00903 
00904         ((*Dstring == 16 &amp;&amp; !<a class="code" href="../../d5/d5/cc_8h.html#a58">FlagOn</a>( NameLength, 1)) &amp;&amp;
00905          <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( 0, Dbg,
00906                      <span class="stringliteral">"UdfCheckLegalCS0Dstring, NameLength not odd, encoding 0x10!\n"</span> )))) {
00907 
00908         <span class="keywordflow">if</span> (ReturnOnError) {
00909 
00910             <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, Dbg, <span class="stringliteral">"UdfCheckLegalCS0Dstring -&gt; FALSE\n"</span> ));
00911 
00912             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00913         }
00914 
00915         <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, Dbg, <span class="stringliteral">"UdfCheckLegalCS0Dstring -&gt; raised status\n"</span> ));
00916 
00917         <a class="code" href="../../d3/d8/udfprocs_8h.html#a122">UdfRaiseStatus</a>( IrpContext, STATUS_FILE_CORRUPT_ERROR );
00918     }
00919 
00920     <a class="code" href="../../d5/d5/cc_8h.html#a91">DebugTrace</a>(( -1, Dbg, <span class="stringliteral">"UdfCheckLegalCS0Dstring -&gt; TRUE\n"</span> ));
00921 
00922     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00923 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="namesup.c::UdfConvertCS0DstringToUnicode" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID UdfConvertCS0DstringToUnicode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>IrpContext</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PUCHAR&nbsp;</td>
          <td class="mdname" nowrap> <em>Dstring</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN UCHAR Length&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN UCHAR FieldLength&nbsp;</td>
          <td class="mdname" nowrap> <em>OPTIONAL</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT PUNICODE_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>Name</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d4/namesup_8c-source.html#l00689">689</a> of file <a class="el" href="../../d6/d4/namesup_8c-source.html">namesup.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d2/d7/udfdata_8h-source.html#l00352">ASSERT_IRP_CONTEXT</a>, <a class="el" href="../../d2/d0/bench_8c-source.html#l00050">CHAR</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00061">Min</a>, <a class="el" href="../../d9/d9/geninst_8c-source.html#l00154">Name</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l00330">SwapCopyUchar2</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l01177">UdfCS0DstringUnicodeSize()</a>, and <a class="el" href="../../d3/d9/nt6_2user32_8def-source.html#l00844">Unicode</a>.
<p>
Referenced by <a class="el" href="../../d5/d7/dirsup_8c-source.html#l00360">UdfUpdateDirNames()</a>, and <a class="el" href="../../d0/d7/udfs_2fsctrl_8c-source.html#l04056">UdfUpdateVolumeLabel()</a>.
<p>
<pre class="fragment"><div>00699                    :
00700 
00701     This routine will convert <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> CS0 input dstring (1/7.2.12) to Unicode.  We assume that
00702     the length is sane.
00703     
00704     This "compression" in CS0 is really just a special case hack for ASCII.
00705 
00706 Arguments:
00707 
00708     Dstring - the input dstring field
00709     
00710     Length - length of the dstring.  If unspecified, we assume that the characters come
00711         from a proper 1/7.2.12 dstring that specifies length in the last character of the
00712         field.
00713     
00714     FieldLength - length of the dstring field.  If unspecified, we assume that the characters
00715         come from an uncounted length of CS0 characters and that the Length parameter is
00716         specified.
00717     
00718     Name - the output Unicode string
00719 
00720 Return Value:
00721 
00722     None.
00723 
00724 --*/
00725 
00726 {
00727     ULONG CompressID;
00728     ULONG UnicodeIndex, ByteIndex;
00729     PWCHAR <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a96">Unicode</a> = <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer;
00730 
00731     UCHAR NameLength;
00732     ULONG CopyNameLength;
00733 
00734     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00735    
00736     <span class="comment">//</span>
00737     <span class="comment">//  Check input.</span>
00738     <span class="comment">//</span>
00739 
00740     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
00741 
00742     CompressID = *Dstring;
00743 
00744     <span class="comment">//</span>
00745     <span class="comment">//  If the length is unspecified, this is a real 1/7.2.12 dstring and the length is in</span>
00746     <span class="comment">//  the last character of the field.</span>
00747     <span class="comment">//</span>
00748     
00749     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( Length || FieldLength );
00750 
00751     <span class="keywordflow">if</span> (Length) {
00752 
00753         NameLength = FieldLength = Length;
00754     
00755     } <span class="keywordflow">else</span> {
00756 
00757         NameLength = *(Dstring + FieldLength - 1);
00758     }
00759     
00760     <span class="comment">//</span>
00761     <span class="comment">//  If the caller specified a size, they should have made sure the buffer is big enough.</span>
00762     <span class="comment">//  Otherwise, we will trim to fit.</span>
00763     <span class="comment">//</span>
00764     
00765     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( Length == 0 || <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;MaximumLength &gt;= <a class="code" href="../../d3/d8/udfprocs_8h.html#a187">UdfCS0DstringUnicodeSize</a>( IrpContext, Dstring, NameLength ) );
00766  
00767     <span class="comment">//</span>
00768     <span class="comment">//  Decide how many UNICODE bytes to "copy".</span>
00769     <span class="comment">//</span>
00770     
00771     CopyNameLength = <a class="code" href="../../d3/d8/udfprocs_8h.html#a3">Min</a>( <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;MaximumLength, <a class="code" href="../../d3/d8/udfprocs_8h.html#a187">UdfCS0DstringUnicodeSize</a>( IrpContext, Dstring, NameLength ));
00772     
00773     <span class="comment">//</span>
00774     <span class="comment">//  Reset the name length and advance over the compression ID in the dstring.</span>
00775     <span class="comment">//</span>
00776     
00777     <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length = 0;
00778     Dstring++;
00779  
00780     <span class="comment">//</span>
00781     <span class="comment">//  Loop through all the bytes.</span>
00782     <span class="comment">//</span>
00783 
00784     <span class="keywordflow">while</span> (CopyNameLength &gt; <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length) {
00785       
00786         <span class="keywordflow">if</span> (CompressID == 16) {
00787        
00788             <span class="comment">//</span>
00789             <span class="comment">//  We're little endian, and this is the single place in the entire UDF/ISO standard</span>
00790             <span class="comment">//  where they use big endian.</span>
00791             <span class="comment">//</span>
00792             <span class="comment">//  Thank you.  Thank you very much.</span>
00793             <span class="comment">//</span>
00794             <span class="comment">//  Do an unaligned swapcopy of this 16bit value.</span>
00795             <span class="comment">//</span>
00796 
00797             <a class="code" href="../../d3/d8/udfprocs_8h.html#a58">SwapCopyUchar2</a>( Unicode, Dstring );
00798             Dstring += <span class="keyword">sizeof</span>(WCHAR);
00799        
00800         } <span class="keywordflow">else</span> {
00801 
00802             <span class="comment">//</span>
00803             <span class="comment">//  Drop the byte into the low bits.</span>
00804             <span class="comment">//</span>
00805                 
00806             *<a class="code" href="../../d2/d0/nt6_2user32_8def.html#a96">Unicode</a> = *Dstring;
00807             Dstring += <span class="keyword">sizeof</span>(<a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a>);
00808         }
00809 
00810         <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length += <span class="keyword">sizeof</span>(WCHAR);
00811         <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a96">Unicode</a>++;
00812     }
00813 
00814     <span class="keywordflow">return</span>;
00815 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="namesup.c::UdfDissectName" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID UdfDissectName           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>IrpContext</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN OUT PUNICODE_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>RemainingName</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PUNICODE_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>FinalName</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d4/namesup_8c-source.html#l00096">96</a> of file <a class="el" href="../../d6/d4/namesup_8c-source.html">namesup.c</a>.
<p>
References <a class="el" href="../../d3/d6/notify_8c-source.html#l00236">Add2Ptr</a>, <a class="el" href="../../d2/d7/udfdata_8h-source.html#l00352">ASSERT_IRP_CONTEXT</a>, <a class="el" href="../../d3/d9/aw_8h-source.html#l00031">L</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, and <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00064">USHORT</a>.
<p>
Referenced by <a class="el" href="../../d4/d7/udfs_2create_8c-source.html#l00108">UdfCommonCreate()</a>, and <a class="el" href="../../d6/d3/prefxsup_8c-source.html#l00324">UdfFindPrefix()</a>.
<p>
<pre class="fragment"><div>00104                    :
00105 
00106     This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> called to strip off leading components of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> name strings.  We search
00107     <span class="keywordflow">for</span> either <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> end of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> string or separating characters.  The input remaining
00108     name strings should have neither a trailing or leading backslash.
00109 
00110 Arguments:
00111 
00112     RemainingName - Remaining name.
00113 
00114     FinalName - Location to store next component of name.
00115 
00116 Return Value:
00117 
00118     None.
00119 
00120 --*/
00121 
00122 {
00123     ULONG NameLength;
00124     PWCHAR NextWchar;
00125 
00126     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00127 
00128     <span class="comment">//</span>
00129     <span class="comment">//  Check inputs.</span>
00130     <span class="comment">//</span>
00131 
00132     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
00133 
00134     <span class="comment">//</span>
00135     <span class="comment">//  Find the offset of the next component separators.</span>
00136     <span class="comment">//</span>
00137 
00138     <span class="keywordflow">for</span> (NameLength = 0, NextWchar = RemainingName-&gt;Buffer;
00139          (NameLength &lt; RemainingName-&gt;Length) &amp;&amp; (*NextWchar != <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'\\'</span>);
00140          NameLength += <span class="keyword">sizeof</span>( WCHAR) , NextWchar += 1);
00141 
00142     <span class="comment">//</span>
00143     <span class="comment">//  Adjust all the strings by this amount.</span>
00144     <span class="comment">//</span>
00145 
00146     FinalName-&gt;Buffer = RemainingName-&gt;Buffer;
00147 
00148     FinalName-&gt;MaximumLength = FinalName-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) NameLength;
00149 
00150     <span class="comment">//</span>
00151     <span class="comment">//  If this is the last component then set the RemainingName lengths to zero.</span>
00152     <span class="comment">//</span>
00153 
00154     <span class="keywordflow">if</span> (NameLength == RemainingName-&gt;Length) {
00155 
00156         RemainingName-&gt;Length = 0;
00157 
00158     <span class="comment">//</span>
00159     <span class="comment">//  Otherwise we adjust the string by this amount plus the separating character.</span>
00160     <span class="comment">//</span>
00161 
00162     } <span class="keywordflow">else</span> {
00163 
00164         RemainingName-&gt;MaximumLength -= (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) (NameLength + <span class="keyword">sizeof</span>( WCHAR ));
00165         RemainingName-&gt;Length -= (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) (NameLength + <span class="keyword">sizeof</span>( WCHAR ));
00166         RemainingName-&gt;Buffer = <a class="code" href="../../d2/d7/notify_8c.html#a7">Add2Ptr</a>( RemainingName-&gt;Buffer,
00167                                          NameLength + <span class="keyword">sizeof</span>( WCHAR ),
00168                                          PWCHAR );
00169     }
00170 
00171     <span class="keywordflow">return</span>;
00172 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="namesup.c::UdfFullCompareNames" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="../../d1/d8/fsrtl_8h.html#a70">FSRTL_COMPARISON_RESULT</a> UdfFullCompareNames           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>IrpContext</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PUNICODE_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>NameA</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PUNICODE_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>NameB</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d4/namesup_8c-source.html#l01274">1274</a> of file <a class="el" href="../../d6/d4/namesup_8c-source.html">namesup.c</a>.
<p>
References <a class="el" href="../../d2/d7/udfdata_8h-source.html#l00352">ASSERT_IRP_CONTEXT</a>, <a class="el" href="../../d1/d8/fsrtl_8h.html#a189a90">EqualTo</a>, <a class="el" href="../../d1/d8/fsrtl_8h.html#a70">FSRTL_COMPARISON_RESULT</a>, <a class="el" href="../../d1/d8/fsrtl_8h.html#a189a91">GreaterThan</a>, <a class="el" href="../../d1/d8/fsrtl_8h.html#a189a89">LessThan</a>, and <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>.
<p>
Referenced by <a class="el" href="../../d5/d7/dirsup_8c-source.html#l00726">UdfFindDirEntry()</a>, <a class="el" href="../../d6/d3/prefxsup_8c-source.html#l00557">UdfFindNameLink()</a>, <a class="el" href="../../d2/d7/dirctrl_8c-source.html#l01003">UdfInitializeEnumeration()</a>, and <a class="el" href="../../d6/d3/prefxsup_8c-source.html#l00660">UdfInsertNameLink()</a>.
<p>
<pre class="fragment"><div>01282                    :
01283 
01284     This function compares two names as fast as possible.  Note that since
01285     <span class="keyword">this</span> comparison <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> <span class="keywordflow">case</span> sensitive we can <span class="keywordflow">do</span> a direct memory comparison.
01286 
01287 Arguments:
01288 
01289     NameA &amp; NameB - The names to compare.
01290 
01291 Return Value:
01292 
01293     <a class="code" href="../../d4/d4/prefix_8c.html#a7">COMPARISON</a> - returns
01294 
01295         <a class="code" href="../../d1/d8/fsrtl_8h.html#a189a89">LessThan</a>    <span class="keywordflow">if</span> NameA &lt; NameB lexicalgraphically,
01296         <a class="code" href="../../d1/d8/fsrtl_8h.html#a189a91">GreaterThan</a> <span class="keywordflow">if</span> NameA &gt; NameB lexicalgraphically,
01297         <a class="code" href="../../d1/d8/fsrtl_8h.html#a189a90">EqualTo</a>     <span class="keywordflow">if</span> NameA <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> equal to NameB
01298 
01299 --*/
01300 
01301 {
01302     ULONG i;
01303     ULONG MinLength = NameA-&gt;Length;
01304     <a class="code" href="../../d1/d8/fsrtl_8h.html#a70">FSRTL_COMPARISON_RESULT</a> Result = <a class="code" href="../../d1/d8/fsrtl_8h.html#a189a89">LessThan</a>;
01305 
01306     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01307 
01308     <span class="comment">//</span>
01309     <span class="comment">//  Check inputs.</span>
01310     <span class="comment">//</span>
01311 
01312     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
01313 
01314     <span class="comment">//</span>
01315     <span class="comment">//  Figure out the minimum of the two lengths</span>
01316     <span class="comment">//</span>
01317 
01318     <span class="keywordflow">if</span> (NameA-&gt;Length &gt; NameB-&gt;Length) {
01319 
01320         MinLength = NameB-&gt;Length;
01321         Result = <a class="code" href="../../d1/d8/fsrtl_8h.html#a189a91">GreaterThan</a>;
01322 
01323     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (NameA-&gt;Length == NameB-&gt;Length) {
01324 
01325         Result = <a class="code" href="../../d1/d8/fsrtl_8h.html#a189a90">EqualTo</a>;
01326     }
01327 
01328     <span class="comment">//</span>
01329     <span class="comment">//  Loop through looking at all of the characters in both strings</span>
01330     <span class="comment">//  testing for equalilty, less than, and greater than</span>
01331     <span class="comment">//</span>
01332 
01333     i = (ULONG) RtlCompareMemory( NameA-&gt;Buffer, NameB-&gt;Buffer, MinLength );
01334 
01335     <span class="keywordflow">if</span> (i &lt; MinLength) {
01336 
01337         <span class="comment">//</span>
01338         <span class="comment">//  We know the offset of the first character which is different.</span>
01339         <span class="comment">//</span>
01340 
01341         <span class="keywordflow">return</span> ((NameA-&gt;Buffer[ i / 2 ] &lt; NameB-&gt;Buffer[ i / 2 ]) ?
01342                  <a class="code" href="../../d1/d8/fsrtl_8h.html#a189a89">LessThan</a> :
01343                  <a class="code" href="../../d1/d8/fsrtl_8h.html#a189a91">GreaterThan</a>);
01344     }
01345 
01346     <span class="comment">//</span>
01347     <span class="comment">//  The names match up to the length of the shorter string.</span>
01348     <span class="comment">//  The shorter string lexically appears first.</span>
01349     <span class="comment">//</span>
01350 
01351     <span class="keywordflow">return</span> Result;
01352 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="namesup.c::UdfGenerate8dot3Name" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID UdfGenerate8dot3Name           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>IrpContext</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PUNICODE_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>FileName</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>OUT PUNICODE_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>ShortFileName</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d4/namesup_8c-source.html#l00389">389</a> of file <a class="el" href="../../d6/d4/namesup_8c-source.html">namesup.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d0/d7/udf_8h-source.html#l00240">CRC_MARK</a>, <a class="el" href="../../d0/d7/udf_8h-source.html#l00227">DOS_CRC_LEN</a>, <a class="el" href="../../d0/d7/udf_8h-source.html#l00226">DOS_EXT_LEN</a>, <a class="el" href="../../d0/d7/udf_8h-source.html#l00225">DOS_NAME_LEN</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d3/d1/rtload_8c-source.html#l00047">FileName</a>, <a class="el" href="../../d0/d7/udf_8h-source.html#l00241">ILLEGAL_CHAR_MARK</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00035">INT16</a>, <a class="el" href="../../d0/d7/udf_8h-source.html#l00230">IsDeviceName</a>, <a class="el" href="../../d0/d7/udf_8h-source.html#l00229">IsFileNameCharLegal</a>, <a class="el" href="../../d6/d4/namesup_8c-source.html#l00056">NativeDosCharLength()</a>, <a class="el" href="../../d0/d7/udf_8h-source.html#l00238">PERIOD</a>, <a class="el" href="../../d0/d7/udf_8h-source.html#l00239">SPACE</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d1/d7/udfdata_8c-source.html#l01194">UdfComputeCrc16Uni()</a>, <a class="el" href="../../d6/d4/namesup_8c-source.html#l00039">UdfCrcChar</a>, <a class="el" href="../../d4/d7/udfprocs_8h-source.html#l01131">UdfUpcaseName()</a>, <a class="el" href="../../d0/d7/udf_8h-source.html#l00235">UINT16</a>, <a class="el" href="../../d0/d7/udf_8h-source.html#l00236">UNICODE_CHAR</a>, <a class="el" href="../../d0/d7/udf_8h-source.html#l00232">UnicodeToUpper</a>, and <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00064">USHORT</a>.
<p>
Referenced by <a class="el" href="../../d2/d7/dirctrl_8c-source.html#l01500">UdfEnumerateIndex()</a>, <a class="el" href="../../d5/d7/dirsup_8c-source.html#l00726">UdfFindDirEntry()</a>, <a class="el" href="../../d5/d2/fileinfo_8c-source.html#l01232">UdfQueryAlternateNameInfo()</a>, and <a class="el" href="../../d2/d7/dirctrl_8c-source.html#l00334">UdfQueryDirectory()</a>.
<p>
<pre class="fragment"><div>00397                    :
00398 
00399     This routine <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> called to generate a <span class="keywordtype">short</span> name from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> given <span class="keywordtype">long</span> name.  We will
00400     generate a <span class="keywordtype">short</span> name from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> given <span class="keywordtype">long</span> name.
00401 
00402     The <span class="keywordtype">short</span> form <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> to convert all runs of illegal characters to <span class="stringliteral">"_"</span> and tack
00403     on a base41 representation of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> CRC of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> original name.  The algorithm <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
00404     nearly directly lifted from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> UDF (2.01 proposed!) standard, so apologies for the
00405     style clash.
00406     
00407 Arguments:
00408 
00409     FileName - String of bytes containing the name.
00410 
00411     ShortFileName - Pointer to the string to store the <span class="keywordtype">short</span> name into.
00412         
00413 Return Value:
00414 
00415     None.
00416 
00417 --*/
00418 
00419 {
00420     <a class="code" href="../../d4/d6/lh__open_2pi__basic_8h.html#a10">INT16</a> index;
00421     <a class="code" href="../../d9/d7/udf_8h.html#a23">INT16</a> targetIndex;
00422     <a class="code" href="../../d9/d7/udf_8h.html#a23">INT16</a> crcIndex;
00423     <a class="code" href="../../d9/d7/udf_8h.html#a23">INT16</a> extLen;
00424     <a class="code" href="../../d9/d7/udf_8h.html#a23">INT16</a> nameLen;
00425     <a class="code" href="../../d9/d7/udf_8h.html#a23">INT16</a> charLen;
00426     <a class="code" href="../../d9/d7/udf_8h.html#a23">INT16</a> overlayBytes;
00427     <a class="code" href="../../d9/d7/udf_8h.html#a23">INT16</a> bytesLeft;
00428     <a class="code" href="../../d9/d7/udf_8h.html#a25">UNICODE_CHAR</a> current;
00429     BOOLEAN needsCRC;
00430     <a class="code" href="../../d9/d7/udf_8h.html#a25">UNICODE_CHAR</a> ext[<a class="code" href="../../d9/d7/udf_8h.html#a17">DOS_EXT_LEN</a>];
00431 
00432     <span class="comment">//</span>
00433     <span class="comment">//  So as to lift as directly as possible from the standard, chunk things around.</span>
00434     <span class="comment">//</span>
00435  
00436     PWCHAR dosName = ShortFileName-&gt;Buffer;
00437     PWCHAR udfName = <a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a>-&gt;Buffer;
00438     LONG udfNameLen = <a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a>-&gt;Length / <span class="keyword">sizeof</span>(WCHAR);
00439     
00440     needsCRC = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00441 
00442     <span class="comment">/* Start at the end of the UDF file name and scan for a period */</span>
00443     <span class="comment">/* ('.').  This will be where the DOS extension starts (if     */</span>
00444     <span class="comment">/* any).                                                       */</span>
00445     index = udfNameLen;
00446     <span class="keywordflow">while</span> (index-- &gt; 0) {
00447         <span class="keywordflow">if</span> (udfName[index] == <a class="code" href="../../d9/d7/udf_8h.html#a26">PERIOD</a>)
00448             <span class="keywordflow">break</span>;
00449     }
00450 
00451     <span class="keywordflow">if</span> (index &lt; 0) {
00452         <span class="comment">/* There name was scanned to the beginning of the buffer   */</span>
00453         <span class="comment">/* and no extension was found.                             */</span>
00454         extLen = 0;
00455         nameLen = udfNameLen;
00456     }
00457     <span class="keywordflow">else</span> {
00458         <span class="comment">/* A DOS extension was found, process it first.            */</span>
00459         extLen = udfNameLen - index - 1;
00460         nameLen = index;
00461         targetIndex = 0;
00462         bytesLeft = <a class="code" href="../../d9/d7/udf_8h.html#a17">DOS_EXT_LEN</a>;
00463 
00464         <span class="keywordflow">while</span> (++index &lt; udfNameLen &amp;&amp; bytesLeft &gt; 0) {
00465             <span class="comment">/* Get the current character and convert it to upper   */</span>
00466             <span class="comment">/* case.                                               */</span>
00467             current = <a class="code" href="../../d9/d7/udf_8h.html#a22">UnicodeToUpper</a>(udfName[index]);
00468             <span class="keywordflow">if</span> (current == <a class="code" href="../../d9/d7/udf_8h.html#a27">SPACE</a>) {
00469                 <span class="comment">/* If a space is found, a CRC must be appended to  */</span>
00470                 <span class="comment">/* the mangled file name.                          */</span>
00471                 needsCRC = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00472             }
00473             <span class="keywordflow">else</span> {
00474                 <span class="comment">/* Determine if this is a valid file name char and */</span>
00475                 <span class="comment">/* calculate its corresponding BCS character byte  */</span>
00476                 <span class="comment">/* length (zero if the char is not legal or        */</span>
00477                 <span class="comment">/* undisplayable on this system).                  */</span>
00478                 charLen = (<a class="code" href="../../d9/d7/udf_8h.html#a19">IsFileNameCharLegal</a>(current)) ?
00479                     <a class="code" href="../../d5/d5/namesup_8c.html#a3">NativeDosCharLength</a>(current) : 0;
00480 
00481                 <span class="comment">/* If the char is larger than the available space  */</span>
00482                 <span class="comment">/* in the buffer, pretend it is undisplayable.     */</span>
00483                 <span class="keywordflow">if</span> (charLen &gt; bytesLeft)
00484                     charLen = 0;
00485 
00486                 <span class="keywordflow">if</span> (charLen == 0) {
00487                     <span class="comment">/* Undisplayable or illegal characters are     */</span>
00488                     <span class="comment">/* substituted with an underscore ("_"), and   */</span>
00489                     <span class="comment">/* required a CRC code appended to the mangled */</span>
00490                     <span class="comment">/* file name.                                  */</span>
00491                     needsCRC = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00492                     charLen = 1;
00493                     current = <a class="code" href="../../d9/d7/udf_8h.html#a29">ILLEGAL_CHAR_MARK</a>;
00494 
00495                     <span class="comment">/* Skip over any following undiplayable or     */</span>
00496                     <span class="comment">/* illegal chars.                              */</span>
00497                     <span class="keywordflow">while</span> (index + 1 &lt; udfNameLen &amp;&amp;
00498                         (!<a class="code" href="../../d9/d7/udf_8h.html#a19">IsFileNameCharLegal</a>(udfName[index + 1]) ||
00499                         <a class="code" href="../../d5/d5/namesup_8c.html#a3">NativeDosCharLength</a>(udfName[index + 1]) == 0))
00500                         index++;
00501                 }
00502 
00503                 <span class="comment">/* Assign the resulting char to the next index in  */</span>
00504                 <span class="comment">/* the extension buffer and determine how many BCS */</span>
00505                 <span class="comment">/* bytes are left.                                 */</span>
00506                 ext[targetIndex++] = current;
00507                 bytesLeft -= charLen;
00508             }
00509         }
00510 
00511         <span class="comment">/* Save the number of Unicode characters in the extension  */</span>
00512         extLen = targetIndex;
00513 
00514         <span class="comment">/* If the extension was too large, or it was zero length   */</span>
00515         <span class="comment">/* (i.e. the name ended in a period), a CRC code must be   */</span>
00516         <span class="comment">/* appended to the mangled name.                           */</span>
00517         <span class="keywordflow">if</span> (index &lt; udfNameLen || extLen == 0)
00518             needsCRC = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00519     }
00520 
00521     <span class="comment">/* Now process the actual file name.                           */</span>
00522     index = 0;
00523     targetIndex = 0;
00524     crcIndex = 0;
00525     overlayBytes = -1;
00526     bytesLeft = <a class="code" href="../../d9/d7/udf_8h.html#a16">DOS_NAME_LEN</a>;
00527     <span class="keywordflow">while</span> (index &lt; nameLen &amp;&amp; bytesLeft &gt; 0) {
00528         <span class="comment">/* Get the current character and convert it to upper case. */</span>
00529         current = <a class="code" href="../../d9/d7/udf_8h.html#a22">UnicodeToUpper</a>(udfName[index]);
00530         <span class="keywordflow">if</span> (current == <a class="code" href="../../d9/d7/udf_8h.html#a27">SPACE</a> || current == <a class="code" href="../../d9/d7/udf_8h.html#a26">PERIOD</a>) {
00531             <span class="comment">/* Spaces and periods are just skipped, a CRC code     */</span>
00532             <span class="comment">/* must be added to the mangled file name.             */</span>
00533             needsCRC = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00534         }
00535         <span class="keywordflow">else</span> {
00536             <span class="comment">/* Determine if this is a valid file name char and     */</span>
00537             <span class="comment">/* calculate its corresponding BCS character byte      */</span>
00538             <span class="comment">/* length (zero if the char is not legal or            */</span>
00539             <span class="comment">/* undisplayable on this system).                      */</span>
00540             charLen = (<a class="code" href="../../d9/d7/udf_8h.html#a19">IsFileNameCharLegal</a>(current)) ?
00541                 <a class="code" href="../../d5/d5/namesup_8c.html#a3">NativeDosCharLength</a>(current) : 0;
00542 
00543             <span class="comment">/* If the char is larger than the available space in   */</span>
00544             <span class="comment">/* the buffer, pretend it is undisplayable.            */</span>
00545             <span class="keywordflow">if</span> (charLen &gt; bytesLeft)
00546                 charLen = 0;
00547 
00548             <span class="keywordflow">if</span> (charLen == 0) {
00549                 <span class="comment">/* Undisplayable or illegal characters are         */</span>
00550                 <span class="comment">/* substituted with an underscore ("_"), and       */</span>
00551                 <span class="comment">/* required a CRC code appended to the mangled     */</span>
00552                 <span class="comment">/* file name.                                      */</span>
00553                 needsCRC = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00554                 charLen = 1;
00555                 current = <a class="code" href="../../d9/d7/udf_8h.html#a29">ILLEGAL_CHAR_MARK</a>;
00556 
00557                 <span class="comment">/* Skip over any following undiplayable or illegal */</span>
00558                 <span class="comment">/* chars.                                          */</span>
00559                 <span class="keywordflow">while</span> (index + 1 &lt; nameLen &amp;&amp;
00560                     (!<a class="code" href="../../d9/d7/udf_8h.html#a19">IsFileNameCharLegal</a>(udfName[index + 1]) ||
00561                     <a class="code" href="../../d5/d5/namesup_8c.html#a3">NativeDosCharLength</a>(udfName[index + 1]) == 0))
00562                     index++;
00563 
00564                 <span class="comment">/* Terminate loop if at the end of the file name.  */</span>
00565                 <span class="keywordflow">if</span> (index &gt;= nameLen)
00566                     <span class="keywordflow">break</span>;
00567             }
00568 
00569             <span class="comment">/* Assign the resulting char to the next index in the  */</span>
00570             <span class="comment">/* file name buffer and determine how many BCS bytes   */</span>
00571             <span class="comment">/* are left.                                           */</span>
00572             dosName[targetIndex++] = current;
00573             bytesLeft -= charLen;
00574 
00575             <span class="comment">/* This figures out where the CRC code needs to start  */</span>
00576             <span class="comment">/* in the file name buffer.                            */</span>
00577             <span class="keywordflow">if</span> (bytesLeft &gt;= <a class="code" href="../../d9/d7/udf_8h.html#a18">DOS_CRC_LEN</a>) {
00578                 <span class="comment">/* If there is enough space left, just tack it     */</span>
00579                 <span class="comment">/* onto the end.                                   */</span>
00580                 crcIndex = targetIndex;
00581             }
00582             <span class="keywordflow">else</span> {
00583                 <span class="comment">/* If there is not enough space left, the CRC      */</span>
00584                 <span class="comment">/* must overlay a character already in the file    */</span>
00585                 <span class="comment">/* name buffer.  Once this condition has been      */</span>
00586                 <span class="comment">/* met, the value will not change.                 */</span>
00587                 <span class="keywordflow">if</span> (overlayBytes &lt; 0) {
00588                     <span class="comment">/* Determine the index and save the length of  */</span>
00589                     <span class="comment">/* the BCS character that is overlayed.  It    */</span>
00590                     <span class="comment">/* is possible that the CRC might overlay      */</span>
00591                     <span class="comment">/* half of a two-byte BCS character depending  */</span>
00592                     <span class="comment">/* upon how the character boundaries line up.  */</span>
00593                     overlayBytes = (bytesLeft + charLen &gt; <a class="code" href="../../d9/d7/udf_8h.html#a18">DOS_CRC_LEN</a>)
00594                         ? 1 : 0;
00595                     crcIndex = targetIndex - 1;
00596                 }
00597             }
00598         }
00599 
00600         <span class="comment">/* Advance to the next character.                          */</span>
00601         index++;
00602     }
00603 
00604     <span class="comment">/* If the scan did not reach the end of the file name, or the  */</span>
00605     <span class="comment">/* length of the file name is zero, a CRC code is needed.      */</span>
00606     <span class="keywordflow">if</span> (index &lt; nameLen || index == 0)
00607         needsCRC = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00608 
00609     <span class="comment">/* If the name has illegal characters or and extension, it     */</span>
00610     <span class="comment">/* is not a DOS device name.                                   */</span>
00611     <span class="keywordflow">if</span> (needsCRC == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> &amp;&amp; extLen == 0) {
00612         <span class="comment">/* If this is the name of a DOS device, a CRC code should  */</span>
00613         <span class="comment">/* be appended to the file name.                           */</span>
00614         <span class="keywordflow">if</span> (<a class="code" href="../../d9/d7/udf_8h.html#a20">IsDeviceName</a>(udfName, udfNameLen))
00615             needsCRC = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00616     }
00617 
00618     <span class="comment">/* Append the CRC code to the file name, if needed.            */</span>
00619     <span class="keywordflow">if</span> (needsCRC) {
00620         <span class="comment">/* Get the CRC value for the original Unicode string       */</span>
00621         <a class="code" href="../../d9/d7/udf_8h.html#a24">UINT16</a> udfCRCValue;
00622         <a class="code" href="../../d9/d7/udf_8h.html#a24">UINT16</a> modulus;
00623 
00624         <span class="comment">//</span>
00625         <span class="comment">//  In UDF 2.00, the sample code changed to take the CRC</span>
00626         <span class="comment">//  from the UNICODE expansion of the CS0 as opposed to</span>
00627         <span class="comment">//  the CS0 itself.  In UDF 2.01, the wording of the spec</span>
00628         <span class="comment">//  will actually match this.</span>
00629         <span class="comment">//</span>
00630         <span class="comment">//  Additionally, the checksum changes to be byte-order</span>
00631         <span class="comment">//  independent.</span>
00632         <span class="comment">//</span>
00633         
00634         udfCRCValue = <a class="code" href="../../d3/d8/udfprocs_8h.html#a135">UdfComputeCrc16Uni</a>(udfName, udfNameLen);
00635 
00636         <span class="comment">/* Determine the character index where the CRC should      */</span>
00637         <span class="comment">/* begin.                                                  */</span>
00638         targetIndex = crcIndex;
00639 
00640         <span class="comment">/* If the character being overlayed is a two-byte BCS      */</span>
00641         <span class="comment">/* character, replace the first byte with an underscore.   */</span>
00642         <span class="keywordflow">if</span> (overlayBytes &gt; 0)
00643             dosName[targetIndex++] = <a class="code" href="../../d9/d7/udf_8h.html#a29">ILLEGAL_CHAR_MARK</a>;
00644 
00645         <span class="comment">//</span>
00646         <span class="comment">//  UDF 2.01 changes to a base 41 encoding.  UDF 1.50 and</span>
00647         <span class="comment">//  UDF 2.00 exchanged the # delimeter with the high 4bits</span>
00648         <span class="comment">//  of the CRC.</span>
00649         <span class="comment">//</span>
00650 
00651         dosName[targetIndex++] = <a class="code" href="../../d9/d7/udf_8h.html#a28">CRC_MARK</a>;
00652         
00653         dosName[targetIndex++] =
00654             <a class="code" href="../../d5/d5/namesup_8c.html#a2">UdfCrcChar</a>[udfCRCValue / (41 * 41)];
00655         udfCRCValue %= (41 * 41);
00656         
00657         dosName[targetIndex++] =
00658             <a class="code" href="../../d5/d5/namesup_8c.html#a2">UdfCrcChar</a>[udfCRCValue / 41];
00659         udfCRCValue %= 41;
00660         
00661         dosName[targetIndex++] =
00662             <a class="code" href="../../d5/d5/namesup_8c.html#a2">UdfCrcChar</a>[udfCRCValue];
00663     }
00664 
00665     <span class="comment">/* Append the extension, if any.                               */</span>
00666     <span class="keywordflow">if</span> (extLen &gt; 0) {
00667         <span class="comment">/* Tack on a period and each successive byte in the        */</span>
00668         <span class="comment">/* extension buffer.                                       */</span>
00669         dosName[targetIndex++] = <a class="code" href="../../d9/d7/udf_8h.html#a26">PERIOD</a>;
00670         <span class="keywordflow">for</span> (index = 0; index &lt; extLen; index++)
00671             dosName[targetIndex++] = ext[index];
00672     }
00673 
00674     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( (targetIndex * <span class="keyword">sizeof</span>(WCHAR)) &lt;= ShortFileName-&gt;MaximumLength );
00675  
00676     ShortFileName-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) (targetIndex * <span class="keyword">sizeof</span>(WCHAR));
00677 
00678     <span class="comment">//</span>
00679     <span class="comment">//  Now we upcase the whole name at once.</span>
00680     <span class="comment">//</span>
00681 
00682     <a class="code" href="../../d3/d8/udfprocs_8h.html#a186">UdfUpcaseName</a>( IrpContext,
00683                    ShortFileName,
00684                    ShortFileName );
00685 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="namesup.c::UdfIs8dot3Name" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN UdfIs8dot3Name           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>IrpContext</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN UNICODE_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>FileName</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d4/namesup_8c-source.html#l00176">176</a> of file <a class="el" href="../../d6/d4/namesup_8c-source.html">namesup.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d2/d7/udfdata_8h-source.html#l00352">ASSERT_IRP_CONTEXT</a>, <a class="el" href="../../d0/d7/udf_8h-source.html#l00205">BYTE_COUNT_8_DOT_3</a>, <a class="el" href="../../d2/d0/bench_8c-source.html#l00050">CHAR</a>, <a class="el" href="../../d5/d9/cmconfig_8c-source.html#l00051">Count</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d3/d1/rtload_8c-source.html#l00047">FileName</a>, <a class="el" href="../../d2/d2/dbcsname_8c-source.html#l00081">FsRtlIsFatDbcsLegal()</a>, <a class="el" href="../../d3/d9/aw_8h-source.html#l00031">L</a>, <a class="el" href="../../d6/d5/stierr_8h-source.html#l00030">NT_SUCCESS</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, <a class="el" href="../../d7/d5/nls_8c-source.html#l00816">RtlUnicodeStringToCountedOemString()</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
Referenced by <a class="el" href="../../d2/d7/dirctrl_8c-source.html#l01500">UdfEnumerateIndex()</a>, <a class="el" href="../../d5/d7/dirsup_8c-source.html#l00726">UdfFindDirEntry()</a>, <a class="el" href="../../d5/d2/fileinfo_8c-source.html#l01232">UdfQueryAlternateNameInfo()</a>, and <a class="el" href="../../d2/d7/dirctrl_8c-source.html#l00334">UdfQueryDirectory()</a>.
<p>
<pre class="fragment"><div>00183                    :
00184 
00185     This routine checks <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> name follows <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> 8.3 name conventions.  We check <span class="keywordflow">for</span>
00186     <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> name length and whether <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> characters are valid.
00187 
00188 Arguments:
00189 
00190     <a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a> - <a class="code" href="../../d4/d9/talloc_8c.html#a0">String</a> of bytes containing <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> name.
00191 
00192 Return Value:
00193 
00194     BOOLEAN - <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> <span class="keyword">this</span> name <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> a legal 8.3 name, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> otherwise.
00195 
00196 --*/
00197 
00198 {
00199     <a class="code" href="../../d1/d1/bench_8c.html#a16">CHAR</a> DbcsNameBuffer[ <a class="code" href="../../d9/d7/udf_8h.html#a11">BYTE_COUNT_8_DOT_3</a> ];
00200     STRING DbcsName;
00201 
00202     PWCHAR NextWchar;
00203     ULONG <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a>;
00204 
00205     ULONG DotCount = 0;
00206     BOOLEAN LastCharDot = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00207 
00208     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
00209 
00210     <span class="comment">//</span>
00211     <span class="comment">//  Check inputs.</span>
00212     <span class="comment">//</span>
00213 
00214     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
00215 
00216     <span class="comment">//</span>
00217     <span class="comment">//  The length must be less than 24 bytes.</span>
00218     <span class="comment">//</span>
00219 
00220     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( <a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a>.Length != 0 );
00221     <span class="keywordflow">if</span> (<a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a>.Length &gt; <a class="code" href="../../d9/d7/udf_8h.html#a11">BYTE_COUNT_8_DOT_3</a>) {
00222 
00223         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00224     }
00225 
00226     <span class="comment">//</span>
00227     <span class="comment">//  Walk though and check for a space character.</span>
00228     <span class="comment">//</span>
00229 
00230     NextWchar = <a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a>.Buffer;
00231     <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> = 0;
00232 
00233     <span class="keywordflow">do</span> {
00234 
00235         <span class="comment">//</span>
00236         <span class="comment">//  No spaces allowed.</span>
00237         <span class="comment">//</span>
00238 
00239         <span class="keywordflow">if</span> (*NextWchar == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">' '</span>) { <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>; }
00240 
00241         <span class="keywordflow">if</span> (*NextWchar == <a class="code" href="../../d2/d0/aw_8h.html#a3">L</a><span class="charliteral">'.'</span>) {
00242 
00243             <span class="comment">//</span>
00244             <span class="comment">//  Not an 8.3 name if more than 1 dot or more than 8 characters</span>
00245             <span class="comment">//  remaining.  (It is legal for the dot to be in the ninth</span>
00246             <span class="comment">//  position)</span>
00247             <span class="comment">//</span>
00248 
00249             <span class="keywordflow">if</span> ((DotCount &gt; 0) ||
00250                 (<a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> &gt; 8 * <span class="keyword">sizeof</span>( WCHAR ))) {
00251 
00252                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00253             }
00254 
00255             DotCount += 1;
00256             LastCharDot = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00257 
00258         } <span class="keywordflow">else</span> {
00259 
00260             LastCharDot = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00261         }
00262 
00263         <a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> += 2;
00264         NextWchar += 1;
00265 
00266     } <span class="keywordflow">while</span> (<a class="code" href="../../d4/d0/cmconfig_8c.html#a6">Count</a> &lt; <a class="code" href="../../d2/d2/rtload_8c.html#a3">FileName</a>.Length);
00267 
00268     <span class="comment">//</span>
00269     <span class="comment">//  We can't have a period at the end of the name.</span>
00270     <span class="comment">//</span>
00271 
00272     <span class="keywordflow">if</span> (LastCharDot) {
00273 
00274         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00275     }
00276 
00277     <span class="comment">//</span>
00278     <span class="comment">//  Create an Oem name to use to check for a valid short name.</span>
00279     <span class="comment">//</span>
00280 
00281     DbcsName.MaximumLength = <a class="code" href="../../d9/d7/udf_8h.html#a11">BYTE_COUNT_8_DOT_3</a>;
00282     DbcsName.Buffer = DbcsNameBuffer;
00283 
00284     <span class="keywordflow">if</span> (!<a class="code" href="../../d5/d6/stierr_8h.html#a0">NT_SUCCESS</a>( <a class="code" href="../../d6/d6/nls_8c.html#a29">RtlUnicodeStringToCountedOemString</a>( &amp;DbcsName,
00285                                                          &amp;FileName,
00286                                                          FALSE ))) {
00287 
00288         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00289     }
00290 
00291     <span class="comment">//</span>
00292     <span class="comment">//  We have now initialized the Oem string.  Call the FsRtl package to check for a</span>
00293     <span class="comment">//  valid FAT name.</span>
00294     <span class="comment">//</span>
00295 
00296     <span class="keywordflow">return</span> <a class="code" href="../../d1/d8/fsrtl_8h.html#a134">FsRtlIsFatDbcsLegal</a>( DbcsName, FALSE, FALSE, FALSE );
00297 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="namesup.c::UdfIsNameInExpression" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> BOOLEAN UdfIsNameInExpression           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>IrpContext</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PUNICODE_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>CurrentName</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PUNICODE_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>SearchExpression</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN BOOLEAN&nbsp;</td>
          <td class="mdname" nowrap> <em>Wild</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d4/namesup_8c-source.html#l01203">1203</a> of file <a class="el" href="../../d6/d4/namesup_8c-source.html">namesup.c</a>.
<p>
References <a class="el" href="../../d2/d7/udfdata_8h-source.html#l00352">ASSERT_IRP_CONTEXT</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d5/d4/name_8c-source.html#l00415">FsRtlIsNameInExpression()</a>, <a class="el" href="../../d5/d5/lh__open_2pi__basic_8h-source.html#l00023">NULL</a>, <a class="el" href="../../d1/d8/ntosdef_8h-source.html#l00462">PAGED_CODE</a>, and <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>.
<p>
Referenced by <a class="el" href="../../d2/d7/dirctrl_8c-source.html#l01500">UdfEnumerateIndex()</a>.
<p>
<pre class="fragment"><div>01212                    :
01213 
01214     This routine will compare two <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a96">Unicode</a> strings.  We assume that <span class="keywordflow">if</span> <span class="keyword">this</span>
01215     <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> to be a <span class="keywordflow">case</span>-insensitive search then they are already upcased.
01216 
01217 Arguments:
01218 
01219     CurrentName - Filename from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> disk.
01220 
01221     SearchExpression - Filename expression to use <span class="keywordflow">for</span> match.
01222     
01223     Wild - True <span class="keywordflow">if</span> wildcards are present in SearchExpression.
01224 
01225 Return Value:
01226 
01227     BOOLEAN - <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> <span class="keywordflow">if</span> <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> expressions match, <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> otherwise.
01228 
01229 --*/
01230 
01231 {
01232     BOOLEAN Match = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01233     
01234     <a class="code" href="../../d0/d9/ntosdef_8h.html#a28">PAGED_CODE</a>();
01235 
01236     <span class="comment">//</span>
01237     <span class="comment">//  Check inputs.</span>
01238     <span class="comment">//</span>
01239 
01240     <a class="code" href="../../d1/d8/udfdata_8h.html#a28">ASSERT_IRP_CONTEXT</a>( IrpContext );
01241 
01242     <span class="comment">//</span>
01243     <span class="comment">//  If there are wildcards in the expression then we call the</span>
01244     <span class="comment">//  appropriate FsRtlRoutine.</span>
01245     <span class="comment">//</span>
01246 
01247     <span class="keywordflow">if</span> (Wild) {
01248 
01249         Match = <a class="code" href="../../d1/d8/fsrtl_8h.html#a179">FsRtlIsNameInExpression</a>( SearchExpression,
01250                                          CurrentName,
01251                                          FALSE,
01252                                          NULL );
01253 
01254     <span class="comment">//</span>
01255     <span class="comment">//  Otherwise do a direct memory comparison for the name string.</span>
01256     <span class="comment">//</span>
01257 
01258     } <span class="keywordflow">else</span> {
01259 
01260         <span class="keywordflow">if</span> ((CurrentName-&gt;Length != SearchExpression-&gt;Length) ||
01261             (!RtlEqualMemory( CurrentName-&gt;Buffer,
01262                               SearchExpression-&gt;Buffer,
01263                               CurrentName-&gt;Length ))) {
01264 
01265             Match = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01266         }
01267     }
01268 
01269     <span class="keywordflow">return</span> Match;
01270 }

</div></pre>    </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="namesup.c::UdfRenderNameToLegalUnicode" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> VOID UdfRenderNameToLegalUnicode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">IN <a class="el" href="../../d0/d3/struct__IRP__CONTEXT.html">PIRP_CONTEXT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>IrpContext</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PUNICODE_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>Name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>IN PUNICODE_STRING&nbsp;</td>
          <td class="mdname" nowrap> <em>RenderedName</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d4/namesup_8c-source.html#l00927">927</a> of file <a class="el" href="../../d6/d4/namesup_8c-source.html">namesup.c</a>.
<p>
References <a class="el" href="../../d7/d4/ntgdi_2icm_2inc_2debug_8h-source.html#l00146">ASSERT</a>, <a class="el" href="../../d0/d7/udf_8h-source.html#l00223">CRC_LEN</a>, <a class="el" href="../../d0/d7/udf_8h-source.html#l00240">CRC_MARK</a>, <a class="el" href="../../d0/d7/udf_8h-source.html#l00222">EXT_LEN</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00625">FALSE</a>, <a class="el" href="../../d0/d7/udf_8h-source.html#l00241">ILLEGAL_CHAR_MARK</a>, <a class="el" href="../../d0/d7/udf_8h-source.html#l00234">INT16</a>, <a class="el" href="../../d0/d7/udf_8h-source.html#l00230">IsDeviceName</a>, <a class="el" href="../../d0/d7/udf_8h-source.html#l00229">IsFileNameCharLegal</a>, <a class="el" href="../../d0/d7/udf_8h-source.html#l00221">MAX_LEN</a>, <a class="el" href="../../d9/d9/geninst_8c-source.html#l00154">Name</a>, <a class="el" href="../../d0/d7/udf_8h-source.html#l00231">NativeCharLength</a>, <a class="el" href="../../d0/d7/udf_8h-source.html#l00238">PERIOD</a>, <a class="el" href="../../d0/d7/udf_8h-source.html#l00239">SPACE</a>, <a class="el" href="../../d7/d6/halmips_8h-source.html#l00626">TRUE</a>, <a class="el" href="../../d1/d7/udfdata_8c-source.html#l01194">UdfComputeCrc16Uni()</a>, <a class="el" href="../../d6/d4/namesup_8c-source.html#l00039">UdfCrcChar</a>, <a class="el" href="../../d0/d7/udf_8h-source.html#l00235">UINT16</a>, <a class="el" href="../../d0/d7/udf_8h-source.html#l00236">UNICODE_CHAR</a>, and <a class="el" href="../../d5/d4/aug98_2dll32_2icc__i386_8h-source.html#l00064">USHORT</a>.
<p>
Referenced by <a class="el" href="../../d5/d7/dirsup_8c-source.html#l00360">UdfUpdateDirNames()</a>.
<p>
<pre class="fragment"><div>00935                    :
00936 
00937     This routine will take a <a class="code" href="../../d2/d0/nt6_2user32_8def.html#a96">Unicode</a> string containing illegal characters and
00938     run <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> through <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> UDF standard algorithim to render <a class="code" href="../../d1/d9/icmui_8def.html#a4">it</a> into a <span class="stringliteral">"legal"</span>
00939     name.
00940     
00941     The <span class="keywordtype">short</span> form <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a> to convert all runs of illegal characters to <span class="stringliteral">"_"</span> and tack
00942     on a hex representation of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> CRC of <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> original name.  The algorithm <a class="code" href="../../d3/d0/user32_8def.html#a108">is</a>
00943     nearly directly lifted from <a class="code" href="../../d7/d1/genuedef_8c.html#a2">the</a> UDF (2.01 proposed!) standard, so apologies
00944     for the style clash.
00945     
00946 Arguments:
00947 
00948     Name - the actual name
00949     
00950     RenderedName - the name rendered into legal characters
00951     
00952 Return Value:
00953 
00954     BOOLEAN - TRUE if the expressions match, FALSE otherwise.
00955 
00956 --*/
00957 
00958 {
00959     <a class="code" href="../../d9/d7/udf_8h.html#a23">INT16</a> index;
00960     <a class="code" href="../../d9/d7/udf_8h.html#a23">INT16</a> targetIndex;
00961     <a class="code" href="../../d9/d7/udf_8h.html#a23">INT16</a> crcIndex;
00962     <a class="code" href="../../d9/d7/udf_8h.html#a23">INT16</a> extLen;
00963     <a class="code" href="../../d9/d7/udf_8h.html#a23">INT16</a> nameLen;
00964     <a class="code" href="../../d9/d7/udf_8h.html#a23">INT16</a> charLen;
00965     <a class="code" href="../../d9/d7/udf_8h.html#a23">INT16</a> overlayBytes;
00966     <a class="code" href="../../d9/d7/udf_8h.html#a23">INT16</a> bytesLeft;
00967     <a class="code" href="../../d9/d7/udf_8h.html#a25">UNICODE_CHAR</a> current;
00968     BOOLEAN needsCRC;
00969     BOOLEAN foundDot;
00970     <a class="code" href="../../d9/d7/udf_8h.html#a25">UNICODE_CHAR</a> ext[<a class="code" href="../../d9/d7/udf_8h.html#a14">EXT_LEN</a>];
00971 
00972     <span class="comment">//</span>
00973     <span class="comment">//  So as to lift as directly as possible from the standard, chunk things around.</span>
00974     <span class="comment">//</span>
00975  
00976     PWCHAR newName = RenderedName-&gt;Buffer;
00977     PWCHAR udfName = <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Buffer;
00978     LONG udfNameLen = <a class="code" href="../../d8/d0/geninst_8c.html#a20">Name</a>-&gt;Length / <span class="keyword">sizeof</span>(WCHAR);
00979 
00980     <span class="comment">/* Remove trailing periods ('.') and spaces (' '), Windows     */</span>
00981     <span class="comment">/* does not like them.                                         */</span>
00982     foundDot = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00983     index = udfNameLen;
00984     <span class="keywordflow">while</span> (index-- &gt; 0) {
00985         <span class="keywordflow">if</span> (udfName[index] == <a class="code" href="../../d9/d7/udf_8h.html#a26">PERIOD</a>)
00986             foundDot = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00987         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (udfName[index] != <a class="code" href="../../d9/d7/udf_8h.html#a27">SPACE</a>)
00988             <span class="keywordflow">break</span>;
00989     }
00990 
00991     <span class="comment">/* If any trailing periods or spaces were found, a CRC code    */</span>
00992     <span class="comment">/* needs to be added to the resulting file name.               */</span>
00993     nameLen = index + 1;
00994     <span class="keywordflow">if</span> (nameLen &lt; udfNameLen)
00995         needsCRC = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00996 
00997     needsCRC = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00998     bytesLeft = <a class="code" href="../../d9/d7/udf_8h.html#a13">MAX_LEN</a>;
00999     extLen = 0;
01000 
01001     <span class="keywordflow">if</span> (needsCRC == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> || foundDot == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>) {
01002         <span class="comment">/* Look for an extension in the file name.  We do not      */</span>
01003         <span class="comment">/* need to look for one if there were any trailing periods */</span>
01004         <span class="comment">/* removed.                                                */</span>
01005         <a class="code" href="../../d9/d7/udf_8h.html#a23">INT16</a> endIndex;
01006         <a class="code" href="../../d9/d7/udf_8h.html#a23">INT16</a> prevCharLen = 1;
01007         <a class="code" href="../../d9/d7/udf_8h.html#a23">INT16</a> extBytes = 0;
01008 
01009         targetIndex = 0;
01010         index = nameLen;
01011 
01012         <span class="comment">/* Determine how many bytes we need to scan to find the    */</span>
01013         <span class="comment">/* extension delimiter.  The extension has a maximum of    */</span>
01014         <span class="comment">/* five characters, but we do not want to scan past the    */</span>
01015         <span class="comment">/* beginning of the buffer.                                */</span>
01016         endIndex = (udfNameLen &gt; <a class="code" href="../../d9/d7/udf_8h.html#a14">EXT_LEN</a> + 1) ?
01017             udfNameLen - <a class="code" href="../../d9/d7/udf_8h.html#a14">EXT_LEN</a> - 1 : 1;
01018 
01019         <span class="comment">/* Start at the end of the name and scan backward, looking */</span>
01020         <span class="comment">/* for the extension delimiter (".").                      */</span>
01021         <span class="keywordflow">while</span> (index-- &gt; endIndex) {
01022             <span class="comment">/* Get the character to test.                          */</span>
01023             current = udfName[index];
01024 
01025             <span class="keywordflow">if</span> (current == <span class="charliteral">'.'</span>) {
01026                 <span class="comment">/* The extension delimiter was found, figure out   */</span>
01027                 <span class="comment">/* how many characters the extension contains and  */</span>
01028                 <span class="comment">/* the length of the resulting file name without   */</span>
01029                 <span class="comment">/* the extension.                                  */</span>
01030                 extLen = nameLen - index - 1;
01031                 nameLen = index;
01032                 <span class="keywordflow">break</span>;
01033             }
01034 
01035             <span class="comment">/* Determine the byte length of the current character  */</span>
01036             <span class="comment">/* when converted to native format.                    */</span>
01037             charLen = (<a class="code" href="../../d9/d7/udf_8h.html#a19">IsFileNameCharLegal</a>(current)) ?
01038                 <a class="code" href="../../d9/d7/udf_8h.html#a21">NativeCharLength</a>(current) : 0;
01039 
01040             <span class="keywordflow">if</span> (charLen == 0) {
01041                 <span class="comment">/* If the character byte length is zero, it is     */</span>
01042                 <span class="comment">/* illegal or unprintable, place an underscore     */</span>
01043                 <span class="comment">/* ("_") in the extension buffer if the previous   */</span>
01044                 <span class="comment">/* character tested was legal.  Not that the       */</span>
01045                 <span class="comment">/* characters placed in the extension buffer are   */</span>
01046                 <span class="comment">/* in reverse order.                               */</span>
01047                 <span class="keywordflow">if</span> (prevCharLen != 0) {
01048                     ext[targetIndex++] = <a class="code" href="../../d9/d7/udf_8h.html#a29">ILLEGAL_CHAR_MARK</a>;
01049                     extBytes++;
01050                 }
01051             }
01052             <span class="keywordflow">else</span> {
01053                 <span class="comment">/* The current character is legal and printable,   */</span>
01054                 <span class="comment">/* put it in the extension buffer.  Note that the  */</span>
01055                 <span class="comment">/* characters placed in the extension buffer are   */</span>
01056                 <span class="comment">/* in reverse order.                               */</span>
01057                 ext[targetIndex++] = current;
01058                 extBytes += charLen;
01059             }
01060 
01061             <span class="comment">/* Save the byte length of the current character, so   */</span>
01062             <span class="comment">/* we can determine if it was a legal character during */</span>
01063             <span class="comment">/* the next test.                                      */</span>
01064             prevCharLen = charLen;
01065         }
01066 
01067         <span class="comment">/* If an extension was found, determine how many bytes     */</span>
01068         <span class="comment">/* remain in the file name buffer once we account for it.  */</span>
01069         <span class="keywordflow">if</span> (extLen &gt; 0)
01070             bytesLeft -= extBytes + 1;
01071     }
01072 
01073     index = 0;
01074     targetIndex = 0;
01075     crcIndex = 0;
01076     overlayBytes = -1;
01077     <span class="keywordflow">while</span> (index &lt; nameLen &amp;&amp; bytesLeft &gt; 0) {
01078         <span class="comment">/* Get the current character and convert it to upper case. */</span>
01079         current = udfName[index];
01080 
01081         <span class="comment">/* Determine if this is a valid file name char and         */</span>
01082         <span class="comment">/* calculate its corresponding native character byte       */</span>
01083         <span class="comment">/* length (zero if the char is not legal or undiplayable   */</span>
01084         <span class="comment">/* on this system).                                        */</span>
01085         charLen = (<a class="code" href="../../d9/d7/udf_8h.html#a19">IsFileNameCharLegal</a>(current)) ?
01086             <a class="code" href="../../d9/d7/udf_8h.html#a21">NativeCharLength</a>(current) : 0;
01087 
01088         <span class="comment">/* If the char is larger than the available space in the   */</span>
01089         <span class="comment">/* buffer, pretend it is undisplayable.                    */</span>
01090         <span class="keywordflow">if</span> (charLen &gt; bytesLeft)
01091             charLen = 0;
01092 
01093         <span class="keywordflow">if</span> (charLen == 0) {
01094             <span class="comment">/* Undisplayable or illegal characters are substituted */</span>
01095             <span class="comment">/* with an underscore ("_"), and requires a CRC code   */</span>
01096             <span class="comment">/* appended to the mangled file name.                  */</span>
01097             needsCRC = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01098             charLen = 1;
01099             current = <span class="charliteral">'_'</span>;
01100 
01101             <span class="comment">/* Skip over any following undiplayable or illegal     */</span>
01102             <span class="comment">/* chars.                                              */</span>
01103             <span class="keywordflow">while</span> (index + 1 &lt; udfNameLen &amp;&amp;
01104                 (!<a class="code" href="../../d9/d7/udf_8h.html#a19">IsFileNameCharLegal</a>(udfName[index + 1]) ||
01105                 <a class="code" href="../../d9/d7/udf_8h.html#a21">NativeCharLength</a>(udfName[index + 1]) == 0))
01106                 index++;
01107 
01108             <span class="comment">/* Terminate loop if at the end of the file name.      */</span>
01109             <span class="keywordflow">if</span> (index &gt;= udfNameLen)
01110                 <span class="keywordflow">break</span>;
01111         }
01112 
01113         <span class="comment">/* Assign the resulting char to the next index in the file */</span>
01114         <span class="comment">/* name buffer and determine how many native bytes are     */</span>
01115         <span class="comment">/* left.                                                   */</span>
01116         newName[targetIndex++] = current;
01117         bytesLeft -= charLen;
01118 
01119         <span class="comment">/* This figures out where the CRC code needs to start in   */</span>
01120         <span class="comment">/* the file name buffer.                                   */</span>
01121         <span class="keywordflow">if</span> (bytesLeft &gt;= <a class="code" href="../../d9/d7/udf_8h.html#a15">CRC_LEN</a>) {
01122             <span class="comment">/* If there is enough space left, just tack it onto    */</span>
01123             <span class="comment">/* the end.                                            */</span>
01124             crcIndex = targetIndex;
01125         }
01126         <span class="keywordflow">else</span> {
01127             <span class="comment">/* If there is not enough space left, the CRC must     */</span>
01128             <span class="comment">/* overlay a character already in the file name        */</span>
01129             <span class="comment">/* buffer.  Once this condition has been met, the      */</span>
01130             <span class="comment">/* value will not change.                              */</span>
01131             <span class="keywordflow">if</span> (overlayBytes &lt; 0) {
01132                 <span class="comment">/* Determine the index and save the length of the  */</span>
01133                 <span class="comment">/* native character that is overlayed.  It is      */</span>
01134                 <span class="comment">/* possible that the CRC might overlay half of a   */</span>
01135                 <span class="comment">/* two-byte native character depending upon how    */</span>
01136                 <span class="comment">/* the character boundaries line up.               */</span>
01137                 overlayBytes = (bytesLeft + charLen &gt; <a class="code" href="../../d9/d7/udf_8h.html#a15">CRC_LEN</a>)
01138                     ? 1 : 0;
01139                 crcIndex = targetIndex - 1;
01140             }
01141         }
01142 
01143         <span class="comment">/* Advance to the next character.                          */</span>
01144         index++;
01145     }
01146 
01147     <span class="comment">/* If the scan did not reach the end of the file name, or the  */</span>
01148     <span class="comment">/* length of the file name is zero, a CRC code is needed.      */</span>
01149     <span class="keywordflow">if</span> (index &lt; nameLen || index == 0)
01150         needsCRC = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01151 
01152     <span class="comment">/* If the name has illegal characters or and extension, it     */</span>
01153     <span class="comment">/* is not a DOS device name.                                   */</span>
01154     <span class="keywordflow">if</span> (needsCRC == <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a> &amp;&amp; extLen == 0) {
01155         <span class="comment">/* If this is the name of a DOS device, a CRC code should  */</span>
01156         <span class="comment">/* be appended to the file name.                           */</span>
01157         <span class="keywordflow">if</span> (<a class="code" href="../../d9/d7/udf_8h.html#a20">IsDeviceName</a>(udfName, udfNameLen))
01158             needsCRC = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
01159     }
01160 
01161     <span class="comment">/* Append the CRC code to the file name, if needed.            */</span>
01162     <span class="keywordflow">if</span> (needsCRC) {
01163         <span class="comment">/* Get the CRC value for the original Unicode string       */</span>
01164         <a class="code" href="../../d9/d7/udf_8h.html#a24">UINT16</a> udfCRCValue = <a class="code" href="../../d3/d8/udfprocs_8h.html#a135">UdfComputeCrc16Uni</a>(udfName, udfNameLen);
01165 
01166         <span class="comment">/* Determine the character index where the CRC should      */</span>
01167         <span class="comment">/* begin.                                                  */</span>
01168         targetIndex = crcIndex;
01169 
01170         <span class="comment">/* If the character being overlayed is a two-byte native   */</span>
01171         <span class="comment">/* character, replace the first byte with an underscore.   */</span>
01172         <span class="keywordflow">if</span> (overlayBytes &gt; 0)
01173             newName[targetIndex++] = <a class="code" href="../../d9/d7/udf_8h.html#a29">ILLEGAL_CHAR_MARK</a>;
01174 
01175         <span class="comment">/* Append the encoded CRC value with delimiter.            */</span>
01176         newName[targetIndex++] = <a class="code" href="../../d9/d7/udf_8h.html#a28">CRC_MARK</a>;
01177         newName[targetIndex++] = <a class="code" href="../../d5/d5/namesup_8c.html#a2">UdfCrcChar</a>[(udfCRCValue &amp; 0xf000) &gt;&gt; 12];
01178         newName[targetIndex++] = <a class="code" href="../../d5/d5/namesup_8c.html#a2">UdfCrcChar</a>[(udfCRCValue &amp; 0x0f00) &gt;&gt; 8];
01179         newName[targetIndex++] = <a class="code" href="../../d5/d5/namesup_8c.html#a2">UdfCrcChar</a>[(udfCRCValue &amp; 0x00f0) &gt;&gt; 4];
01180         newName[targetIndex++] = <a class="code" href="../../d5/d5/namesup_8c.html#a2">UdfCrcChar</a>[(udfCRCValue &amp; 0x000f)];
01181     }
01182 
01183 
01184     <span class="comment">/* If an extension was found, append it here.                  */</span>
01185     <span class="keywordflow">if</span> (extLen &gt; 0) {
01186         <span class="comment">/* Add the period ('.') for the extension delimiter.       */</span>
01187         newName[targetIndex++] = <a class="code" href="../../d9/d7/udf_8h.html#a26">PERIOD</a>;
01188 
01189         <span class="comment">/* Append the characters in the extension buffer.  They    */</span>
01190         <span class="comment">/* were stored in reverse order, so we need to begin with  */</span>
01191         <span class="comment">/* the last character and work forward.                    */</span>
01192         <span class="keywordflow">while</span> (extLen-- &gt; 0)
01193             newName[targetIndex++] = ext[extLen];
01194     }
01195 
01196     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( (targetIndex * <span class="keyword">sizeof</span>(WCHAR)) &lt;= RenderedName-&gt;MaximumLength );
01197  
01198     RenderedName-&gt;Length = (<a class="code" href="../../d4/d5/aug98_2dll32_2icc__i386_8h.html#a14">USHORT</a>) (targetIndex * <span class="keyword">sizeof</span>(WCHAR));
01199 }

</div></pre>    </td>
  </tr>
</table>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="a2" doxytag="namesup.c::UdfCrcChar" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> CONST <a class="el" href="../../d2/d1/bench_8h.html#a8">CHAR</a> <a class="el" href="../../d5/d5/namesup_8c.html#a2">UdfCrcChar</a>[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ#_~-@"<code> [static]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="../../d6/d4/namesup_8c-source.html#l00039">39</a> of file <a class="el" href="../../d6/d4/namesup_8c-source.html">namesup.c</a>.
<p>
Referenced by <a class="el" href="../../d6/d4/namesup_8c-source.html#l00389">UdfGenerate8dot3Name()</a>, and <a class="el" href="../../d6/d4/namesup_8c-source.html#l00927">UdfRenderNameToLegalUnicode()</a>.    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:44:49 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
