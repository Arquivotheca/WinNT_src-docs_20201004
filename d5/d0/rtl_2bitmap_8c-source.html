<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test: bitmap.c Source File</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindex" href="../../main.html">Main&nbsp;Page</a> | <a class="qindex" href="../../hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="../../annotated.html">Class&nbsp;List</a> | <a class="qindex" href="../../files.html">File&nbsp;List</a> | <a class="qindex" href="../../functions.html">Class&nbsp;Members</a> | <a class="qindex" href="../../globals.html">File&nbsp;Members</a></div>
<h1>bitmap.c</h1><a href="../../d4/d1/rtl_2bitmap_8c.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 <span class="comment">/*++</span>
00002 <span class="comment"></span>
00003 <span class="comment">Copyright (c) 1989  Microsoft Corporation</span>
00004 <span class="comment"></span>
00005 <span class="comment">Module Name:</span>
00006 <span class="comment"></span>
00007 <span class="comment">    BitMap.c</span>
00008 <span class="comment"></span>
00009 <span class="comment">Abstract:</span>
00010 <span class="comment"></span>
00011 <span class="comment">    Implementation of the bit map routines for the NT rtl.</span>
00012 <span class="comment"></span>
00013 <span class="comment">    Bit numbers within the bit map are zero based.  The first is numbered</span>
00014 <span class="comment">    zero.</span>
00015 <span class="comment"></span>
00016 <span class="comment">    The bit map routines keep track of the number of bits clear or set by</span>
00017 <span class="comment">    subtracting or adding the number of bits operated on as bit ranges</span>
00018 <span class="comment">    are cleared or set; individual bit states are not tested.</span>
00019 <span class="comment">    This means that if a range of bits is set,</span>
00020 <span class="comment">    it is assumed that the total range is currently clear.</span>
00021 <span class="comment"></span>
00022 <span class="comment">Author:</span>
00023 <span class="comment"></span>
00024 <span class="comment">    Gary Kimura (GaryKi) &amp; Lou Perazzoli (LouP)     29-Jan-1990</span>
00025 <span class="comment"></span>
00026 <span class="comment">Revision History:</span>
00027 <span class="comment"></span>
00028 <span class="comment">--*/</span>
00029 
00030 <span class="preprocessor">#include "<a class="code" href="../../d5/d9/ntrtlp_8h.html">ntrtlp.h</a>"</span>
00031 
00032 <span class="preprocessor">#if defined(ALLOC_PRAGMA) &amp;&amp; defined(NTOS_KERNEL_RUNTIME)</span>
00033 <span class="preprocessor"></span><span class="preprocessor">#pragma alloc_text(PAGE,RtlInitializeBitMap)</span>
00034 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00035 <span class="preprocessor"></span>
<a name="l00036"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a0">00036</a> <span class="preprocessor">#define RightShiftUlong(E1,E2) ((E2) &lt; 32 ? (E1) &gt;&gt; (E2) : 0)</span>
<a name="l00037"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a1">00037</a> <span class="preprocessor"></span><span class="preprocessor">#define LeftShiftUlong(E1,E2)  ((E2) &lt; 32 ? (E1) &lt;&lt; (E2) : 0)</span>
00038 <span class="preprocessor"></span>
00039 <span class="preprocessor">#if DBG</span>
00040 <span class="preprocessor"></span><a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
00041 DumpBitMap (
00042     PRTL_BITMAP <a class="code" href="../../d2/d1/structBitMap.html">BitMap</a>
00043     )
00044 {
00045     ULONG i;
00046     BOOLEAN AllZeros, AllOnes;
00047 
00048     <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">" BitMap:%08lx"</span>, <a class="code" href="../../d8/d9/tbitmap_8c.html#a2">BitMap</a>);
00049 
00050     KdPrint((<span class="stringliteral">" (%08x)"</span>, <a class="code" href="../../d8/d9/tbitmap_8c.html#a2">BitMap</a>-&gt;SizeOfBitMap));
00051     KdPrint((<span class="stringliteral">" %08lx\n"</span>, <a class="code" href="../../d8/d9/tbitmap_8c.html#a2">BitMap</a>-&gt;Buffer));
00052 
00053     AllZeros = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00054     AllOnes = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00055 
00056     <span class="keywordflow">for</span> (i = 0; i &lt; ((<a class="code" href="../../d8/d9/tbitmap_8c.html#a2">BitMap</a>-&gt;SizeOfBitMap + 31) / 32); i += 1) {
00057 
00058         <span class="keywordflow">if</span> (<a class="code" href="../../d8/d9/tbitmap_8c.html#a2">BitMap</a>-&gt;Buffer[i] == 0) {
00059 
00060             <span class="keywordflow">if</span> (AllZeros) {
00061 
00062                 NOTHING;
00063 
00064             } <span class="keywordflow">else</span> {
00065 
00066                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"%4d:"</span>, i);
00067                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">" %08lx\n"</span>, <a class="code" href="../../d8/d9/tbitmap_8c.html#a2">BitMap</a>-&gt;Buffer[i]);
00068             }
00069 
00070             AllZeros = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00071             AllOnes = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00072 
00073         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="../../d8/d9/tbitmap_8c.html#a2">BitMap</a>-&gt;Buffer[i] == 0xFFFFFFFF) {
00074 
00075             <span class="keywordflow">if</span> (AllOnes) {
00076 
00077                 NOTHING;
00078 
00079             } <span class="keywordflow">else</span> {
00080 
00081                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"%4d:"</span>, i);
00082                 <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">" %08lx\n"</span>, <a class="code" href="../../d8/d9/tbitmap_8c.html#a2">BitMap</a>-&gt;Buffer[i]);
00083             }
00084 
00085             AllZeros = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00086             AllOnes = <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
00087 
00088         } <span class="keywordflow">else</span> {
00089 
00090             AllZeros = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00091             AllOnes = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
00092 
00093             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"%4d:"</span>, i);
00094             <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">" %08lx\n"</span>, <a class="code" href="../../d8/d9/tbitmap_8c.html#a2">BitMap</a>-&gt;Buffer[i]);
00095         }
00096     }
00097 }
00098 <span class="preprocessor">#endif</span>
00099 <span class="preprocessor"></span>
00100 
00101 <span class="comment">//</span>
00102 <span class="comment">//  There are three macros to make reading the bytes in a bitmap easier.</span>
00103 <span class="comment">//</span>
00104 
<a name="l00105"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a2">00105</a> <span class="preprocessor">#define GET_BYTE_DECLARATIONS() \</span>
00106 <span class="preprocessor">    PUCHAR _CURRENT_POSITION;</span>
00107 <span class="preprocessor"></span>
<a name="l00108"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a3">00108</a> <span class="preprocessor">#define GET_BYTE_INITIALIZATION(RTL_BITMAP,BYTE_INDEX) {               \</span>
00109 <span class="preprocessor">    _CURRENT_POSITION = &amp;((PUCHAR)((RTL_BITMAP)-&gt;Buffer))[BYTE_INDEX]; \</span>
00110 <span class="preprocessor">}</span>
00111 <span class="preprocessor"></span>
<a name="l00112"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a4">00112</a> <span class="preprocessor">#define GET_BYTE(THIS_BYTE)  (         \</span>
00113 <span class="preprocessor">    THIS_BYTE = *(_CURRENT_POSITION++) \</span>
00114 <span class="preprocessor">)</span>
00115 <span class="preprocessor"></span>
00116 
00117 <span class="comment">//</span>
00118 <span class="comment">//  Lookup table that tells how many contiguous bits are clear (i.e., 0) in</span>
00119 <span class="comment">//  a byte</span>
00120 <span class="comment">//</span>
00121 
<a name="l00122"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a19">00122</a> CONST CCHAR <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a19">RtlpBitsClearAnywhere</a>[] =
00123          { 8,7,6,6,5,5,5,5,4,4,4,4,4,4,4,4,
00124            4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
00125            5,4,3,3,2,2,2,2,3,2,2,2,2,2,2,2,
00126            4,3,2,2,2,2,2,2,3,2,2,2,2,2,2,2,
00127            6,5,4,4,3,3,3,3,3,2,2,2,2,2,2,2,
00128            4,3,2,2,2,1,1,1,3,2,1,1,2,1,1,1,
00129            5,4,3,3,2,2,2,2,3,2,1,1,2,1,1,1,
00130            4,3,2,2,2,1,1,1,3,2,1,1,2,1,1,1,
00131            7,6,5,5,4,4,4,4,3,3,3,3,3,3,3,3,
00132            4,3,2,2,2,2,2,2,3,2,2,2,2,2,2,2,
00133            5,4,3,3,2,2,2,2,3,2,1,1,2,1,1,1,
00134            4,3,2,2,2,1,1,1,3,2,1,1,2,1,1,1,
00135            6,5,4,4,3,3,3,3,3,2,2,2,2,2,2,2,
00136            4,3,2,2,2,1,1,1,3,2,1,1,2,1,1,1,
00137            5,4,3,3,2,2,2,2,3,2,1,1,2,1,1,1,
00138            4,3,2,2,2,1,1,1,3,2,1,1,2,1,1,0 };
00139 
00140 <span class="comment">//</span>
00141 <span class="comment">//  Lookup table that tells how many contiguous LOW order bits are clear</span>
00142 <span class="comment">//  (i.e., 0) in a byte</span>
00143 <span class="comment">//</span>
00144 
<a name="l00145"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a20">00145</a> CONST CCHAR <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a20">RtlpBitsClearLow</a>[] =
00146           { 8,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
00147             4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
00148             5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
00149             4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
00150             6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
00151             4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
00152             5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
00153             4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
00154             7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
00155             4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
00156             5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
00157             4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
00158             6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
00159             4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
00160             5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
00161             4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0 };
00162 
00163 <span class="comment">//</span>
00164 <span class="comment">//  Lookup table that tells how many contiguous HIGH order bits are clear</span>
00165 <span class="comment">//  (i.e., 0) in a byte</span>
00166 <span class="comment">//</span>
00167 
<a name="l00168"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a21">00168</a> CONST CCHAR <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a21">RtlpBitsClearHigh</a>[] =
00169           { 8,7,6,6,5,5,5,5,4,4,4,4,4,4,4,4,
00170             3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
00171             2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
00172             2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
00173             1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
00174             1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
00175             1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
00176             1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
00177             0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
00178             0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
00179             0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
00180             0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
00181             0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
00182             0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
00183             0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
00184             0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
00185 
00186 <span class="comment">//</span>
00187 <span class="comment">//  Lookup table that tells how many clear bits (i.e., 0) there are in a byte</span>
00188 <span class="comment">//</span>
00189 
<a name="l00190"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a22">00190</a> CONST CCHAR <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a22">RtlpBitsClearTotal</a>[] =
00191           { 8,7,7,6,7,6,6,5,7,6,6,5,6,5,5,4,
00192             7,6,6,5,6,5,5,4,6,5,5,4,5,4,4,3,
00193             7,6,6,5,6,5,5,4,6,5,5,4,5,4,4,3,
00194             6,5,5,4,5,4,4,3,5,4,4,3,4,3,3,2,
00195             7,6,6,5,6,5,5,4,6,5,5,4,5,4,4,3,
00196             6,5,5,4,5,4,4,3,5,4,4,3,4,3,3,2,
00197             6,5,5,4,5,4,4,3,5,4,4,3,4,3,3,2,
00198             5,4,4,3,4,3,3,2,4,3,3,2,3,2,2,1,
00199             7,6,6,5,6,5,5,4,6,5,5,4,5,4,4,3,
00200             6,5,5,4,5,4,4,3,5,4,4,3,4,3,3,2,
00201             6,5,5,4,5,4,4,3,5,4,4,3,4,3,3,2,
00202             5,4,4,3,4,3,3,2,4,3,3,2,3,2,2,1,
00203             6,5,5,4,5,4,4,3,5,4,4,3,4,3,3,2,
00204             5,4,4,3,4,3,3,2,4,3,3,2,3,2,2,1,
00205             5,4,4,3,4,3,3,2,4,3,3,2,3,2,2,1,
00206             4,3,3,2,3,2,2,1,3,2,2,1,2,1,1,0 };
00207 
00208 <span class="comment">//</span>
00209 <span class="comment">//  Bit Mask for clearing and setting bits within bytes.  FillMask[i] has the first</span>
00210 <span class="comment">//  i bits set to 1.  ZeroMask[i] has the first i bits set to zero.</span>
00211 <span class="comment">//</span>
00212 
<a name="l00213"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a23">00213</a> <span class="keyword">static</span> CONST UCHAR <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a23">FillMask</a>[] = { 0x00, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF };
00214 
<a name="l00215"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a24">00215</a> <span class="keyword">static</span> CONST UCHAR <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a24">ZeroMask</a>[] = { 0xFF, 0xFE, 0xFC, 0xF8, 0xf0, 0xe0, 0xc0, 0x80, 0x00 };
00216 
00217 
00218 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00219"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a26">00219</a> <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a26">RtlInitializeBitMap</a> (
00220     IN PRTL_BITMAP BitMapHeader,
00221     IN PULONG BitMapBuffer,
00222     IN ULONG SizeOfBitMap
00223     )
00224 
00225 <span class="comment">/*++</span>
00226 <span class="comment"></span>
00227 <span class="comment">Routine Description:</span>
00228 <span class="comment"></span>
00229 <span class="comment">    This procedure initializes a bit map.</span>
00230 <span class="comment"></span>
00231 <span class="comment">Arguments:</span>
00232 <span class="comment"></span>
00233 <span class="comment">    BitMapHeader - Supplies a pointer to the BitMap Header to initialize</span>
00234 <span class="comment"></span>
00235 <span class="comment">    BitMapBuffer - Supplies a pointer to the buffer that is to serve as the</span>
00236 <span class="comment">        BitMap.  This must be an a multiple number of longwords in size.</span>
00237 <span class="comment"></span>
00238 <span class="comment">    SizeOfBitMap - Supplies the number of bits required in the Bit Map.</span>
00239 <span class="comment"></span>
00240 <span class="comment">Return Value:</span>
00241 <span class="comment"></span>
00242 <span class="comment">    None.</span>
00243 <span class="comment"></span>
00244 <span class="comment">--*/</span>
00245 
00246 {
00247     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
00248 
00249     <span class="comment">//</span>
00250     <span class="comment">//  Initialize the BitMap header.</span>
00251     <span class="comment">//</span>
00252 
00253     <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;SizeOfBitMap = SizeOfBitMap;
00254     <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;Buffer = BitMapBuffer;
00255 
00256     <span class="comment">//</span>
00257     <span class="comment">//  And return to our caller</span>
00258     <span class="comment">//</span>
00259 
00260     <span class="comment">//DbgPrint("InitializeBitMap"); DumpBitMap(BitMapHeader);</span>
00261     <span class="keywordflow">return</span>;
00262 }
00263 
00264 
00265 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00266"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a27">00266</a> <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a27">RtlClearAllBits</a> (
00267     IN PRTL_BITMAP BitMapHeader
00268     )
00269 
00270 <span class="comment">/*++</span>
00271 <span class="comment"></span>
00272 <span class="comment">Routine Description:</span>
00273 <span class="comment"></span>
00274 <span class="comment">    This procedure clears all bits in the specified Bit Map.</span>
00275 <span class="comment"></span>
00276 <span class="comment">Arguments:</span>
00277 <span class="comment"></span>
00278 <span class="comment">    BitMapHeader - Supplies a pointer to the previously initialized BitMap</span>
00279 <span class="comment"></span>
00280 <span class="comment">Return Value:</span>
00281 <span class="comment"></span>
00282 <span class="comment">    None.</span>
00283 <span class="comment"></span>
00284 <span class="comment">--*/</span>
00285 
00286 {
00287     <span class="comment">//</span>
00288     <span class="comment">//  Clear all the bits</span>
00289     <span class="comment">//</span>
00290 
00291     RtlZeroMemory( <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;Buffer,
00292                    ((<a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;SizeOfBitMap + 31) / 32) * 4
00293                  );
00294 
00295     <span class="comment">//</span>
00296     <span class="comment">//  And return to our caller</span>
00297     <span class="comment">//</span>
00298 
00299     <span class="comment">//DbgPrint("ClearAllBits"); DumpBitMap(BitMapHeader);</span>
00300     <span class="keywordflow">return</span>;
00301 }
00302 
00303 
00304 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l00305"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a28">00305</a> <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a28">RtlSetAllBits</a> (
00306     IN PRTL_BITMAP BitMapHeader
00307     )
00308 
00309 <span class="comment">/*++</span>
00310 <span class="comment"></span>
00311 <span class="comment">Routine Description:</span>
00312 <span class="comment"></span>
00313 <span class="comment">    This procedure sets all bits in the specified Bit Map.</span>
00314 <span class="comment"></span>
00315 <span class="comment">Arguments:</span>
00316 <span class="comment"></span>
00317 <span class="comment">    BitMapHeader - Supplies a pointer to the previously initialized BitMap</span>
00318 <span class="comment"></span>
00319 <span class="comment">Return Value:</span>
00320 <span class="comment"></span>
00321 <span class="comment">    None.</span>
00322 <span class="comment"></span>
00323 <span class="comment">--*/</span>
00324 
00325 {
00326     <span class="comment">//</span>
00327     <span class="comment">//  Set all the bits</span>
00328     <span class="comment">//</span>
00329 
00330     RtlFillMemoryUlong( <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;Buffer,
00331                         ((<a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;SizeOfBitMap + 31) / 32) * 4,
00332                         0xffffffff
00333                       );
00334 
00335     <span class="comment">//</span>
00336     <span class="comment">//  And return to our caller</span>
00337     <span class="comment">//</span>
00338 
00339     <span class="comment">//DbgPrint("SetAllBits"); DumpBitMap(BitMapHeader);</span>
00340     <span class="keywordflow">return</span>;
00341 }
00342 
00343 
00344 ULONG
<a name="l00345"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a29">00345</a> <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a29">RtlFindClearBits</a> (
00346     IN PRTL_BITMAP BitMapHeader,
00347     IN ULONG NumberToFind,
00348     IN ULONG HintIndex
00349     )
00350 
00351 <span class="comment">/*++</span>
00352 <span class="comment"></span>
00353 <span class="comment">Routine Description:</span>
00354 <span class="comment"></span>
00355 <span class="comment">    This procedure searches the specified bit map for the specified</span>
00356 <span class="comment">    contiguous region of clear bits.  If a run is not found from the</span>
00357 <span class="comment">    hint to the end of the bitmap, we will search again from the</span>
00358 <span class="comment">    beginning of the bitmap.</span>
00359 <span class="comment"></span>
00360 <span class="comment">Arguments:</span>
00361 <span class="comment"></span>
00362 <span class="comment">    BitMapHeader - Supplies a pointer to the previously initialized BitMap.</span>
00363 <span class="comment"></span>
00364 <span class="comment">    NumberToFind - Supplies the size of the contiguous region to find.</span>
00365 <span class="comment"></span>
00366 <span class="comment">    HintIndex - Supplies the index (zero based) of where we should start</span>
00367 <span class="comment">        the search from within the bitmap.</span>
00368 <span class="comment"></span>
00369 <span class="comment">Return Value:</span>
00370 <span class="comment"></span>
00371 <span class="comment">    ULONG - Receives the starting index (zero based) of the contiguous</span>
00372 <span class="comment">        region of clear bits found.  If not such a region cannot be found</span>
00373 <span class="comment">        a -1 (i.e. 0xffffffff) is returned.</span>
00374 <span class="comment"></span>
00375 <span class="comment">--*/</span>
00376 
00377 {
00378     ULONG SizeOfBitMap;
00379     ULONG SizeInBytes;
00380 
00381     ULONG HintBit;
00382     ULONG MainLoopIndex;
00383 
00384     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a2">GET_BYTE_DECLARATIONS</a>();
00385 
00386     <span class="comment">//</span>
00387     <span class="comment">//  To make the loops in our test run faster we'll extract the</span>
00388     <span class="comment">//  fields from the bitmap header</span>
00389     <span class="comment">//</span>
00390 
00391     SizeOfBitMap = <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;SizeOfBitMap;
00392     SizeInBytes = (SizeOfBitMap + 7) / 8;
00393 
00394     <span class="comment">//</span>
00395     <span class="comment">//  Set any unused bits in the last byte so we won't count them.  We do</span>
00396     <span class="comment">//  this by first checking if there is any odd bits in the last byte.</span>
00397     <span class="comment">//</span>
00398 
00399     <span class="keywordflow">if</span> ((SizeOfBitMap % 8) != 0) {
00400 
00401         <span class="comment">//</span>
00402         <span class="comment">//  The last byte has some odd bits so we'll set the high unused</span>
00403         <span class="comment">//  bits in the last byte to 1's</span>
00404         <span class="comment">//</span>
00405 
00406         ((PUCHAR)<a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;Buffer)[SizeInBytes - 1] |=
00407                                                     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a24">ZeroMask</a>[SizeOfBitMap % 8];
00408     }
00409 
00410     <span class="comment">//</span>
00411     <span class="comment">//  Calculate from the hint index where the hint byte is and set ourselves</span>
00412     <span class="comment">//  up to read the hint on the next call to GET_BYTE.  To make the</span>
00413     <span class="comment">//  algorithm run fast we'll only honor hints down to the byte level of</span>
00414     <span class="comment">//  granularity.  There is a possibility that we'll need to execute</span>
00415     <span class="comment">//  our main logic twice.  Once to test from the hint byte to the end of</span>
00416     <span class="comment">//  the bitmap and the other to test from the start of the bitmap.  First</span>
00417     <span class="comment">//  we need to make sure the Hint Index is within range.</span>
00418     <span class="comment">//</span>
00419 
00420     <span class="keywordflow">if</span> (HintIndex &gt;= SizeOfBitMap) {
00421 
00422         HintIndex = 0;
00423     }
00424 
00425     HintBit = HintIndex % 8;
00426 
00427     <span class="keywordflow">for</span> (MainLoopIndex = 0; MainLoopIndex &lt; 2; MainLoopIndex += 1) {
00428 
00429         ULONG StartByteIndex;
00430         ULONG EndByteIndex;
00431 
00432         UCHAR CurrentByte;
00433 
00434         <span class="comment">//</span>
00435         <span class="comment">//  Check for the first time through the main loop, which indicates</span>
00436         <span class="comment">//  that we are going to start our search at our hint byte</span>
00437         <span class="comment">//</span>
00438 
00439         <span class="keywordflow">if</span> (MainLoopIndex == 0) {
00440 
00441             StartByteIndex = HintIndex / 8;
00442             EndByteIndex = SizeInBytes;
00443 
00444         <span class="comment">//</span>
00445         <span class="comment">//  This is the second time through the loop, make sure there is</span>
00446         <span class="comment">//  actually something to check before the hint byte</span>
00447         <span class="comment">//</span>
00448 
00449         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (HintIndex != 0) {
00450 
00451             <span class="comment">//</span>
00452             <span class="comment">//  The end index for the second time around is based on the</span>
00453             <span class="comment">//  number of bits we need to find.  We need to use this inorder</span>
00454             <span class="comment">//  to take the case where the preceding byte to the hint byte</span>
00455             <span class="comment">//  is the start of our run, and the run includes the hint byte</span>
00456             <span class="comment">//  and some following bytes, based on the number of bits needed</span>
00457             <span class="comment">//  The computation is to take the number of bits needed minus</span>
00458             <span class="comment">//  2 divided by 8 and then add 2.  This will take in to account</span>
00459             <span class="comment">//  the worst possible case where we have one bit hanging off</span>
00460             <span class="comment">//  of each end byte, and all intervening bytes are all zero.</span>
00461             <span class="comment">//</span>
00462 
00463             <span class="keywordflow">if</span> (NumberToFind &lt; 2) {
00464 
00465                 EndByteIndex = HintIndex / 8;
00466 
00467             } <span class="keywordflow">else</span> {
00468 
00469                 EndByteIndex = (HintIndex / 8) + ((NumberToFind - 2) / 8) + 2;
00470 
00471                 <span class="comment">//</span>
00472                 <span class="comment">//  Make sure we don't overrun the end of the bitmap</span>
00473                 <span class="comment">//</span>
00474 
00475                 <span class="keywordflow">if</span> (EndByteIndex &gt; SizeInBytes) {
00476 
00477                     EndByteIndex = SizeInBytes;
00478                 }
00479             }
00480 
00481             HintIndex = 0;
00482             HintBit = 0;
00483             StartByteIndex = 0;
00484 
00485         <span class="comment">//</span>
00486         <span class="comment">//  Otherwise we already did a complete loop through the bitmap</span>
00487         <span class="comment">//  so we should simply return -1 to say nothing was found</span>
00488         <span class="comment">//</span>
00489 
00490         } <span class="keywordflow">else</span> {
00491 
00492             <span class="keywordflow">return</span> 0xffffffff;
00493         }
00494 
00495         <span class="comment">//</span>
00496         <span class="comment">//  Set ourselves up to get the next byte</span>
00497         <span class="comment">//</span>
00498 
00499         <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a3">GET_BYTE_INITIALIZATION</a>(<a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>, StartByteIndex);
00500 
00501         <span class="comment">//</span>
00502         <span class="comment">//  Get the first byte, and set any bits before the hint bit.</span>
00503         <span class="comment">//</span>
00504 
00505         <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a4">GET_BYTE</a>( CurrentByte );
00506 
00507         CurrentByte |= <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a23">FillMask</a>[HintBit];
00508 
00509         <span class="comment">//</span>
00510         <span class="comment">//  If the number of bits can only fit in 1 or 2 bytes (i.e., 9 bits or</span>
00511         <span class="comment">//  less) we do the following test case.</span>
00512         <span class="comment">//</span>
00513 
00514         <span class="keywordflow">if</span> (NumberToFind &lt;= 9) {
00515 
00516             ULONG CurrentBitIndex;
00517             UCHAR PreviousByte;
00518 
00519             PreviousByte = 0xff;
00520 
00521             <span class="comment">//</span>
00522             <span class="comment">//  Examine all the bytes within our test range searching</span>
00523             <span class="comment">//  for a fit</span>
00524             <span class="comment">//</span>
00525 
00526             CurrentBitIndex = StartByteIndex * 8;
00527 
00528             <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00529 
00530                 <span class="comment">//</span>
00531                 <span class="comment">//  If this is the first itteration of the loop, mask Current</span>
00532                 <span class="comment">//  byte with the real hint.</span>
00533                 <span class="comment">//</span>
00534 
00535                 <span class="comment">//</span>
00536                 <span class="comment">//  Check to see if the current byte coupled with the previous</span>
00537                 <span class="comment">//  byte will satisfy the requirement. The check uses the high</span>
00538                 <span class="comment">//  part of the previous byte and low part of the current byte.</span>
00539                 <span class="comment">//</span>
00540 
00541                 <span class="keywordflow">if</span> (((ULONG)<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a21">RtlpBitsClearHigh</a>[PreviousByte] +
00542                            (ULONG)<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a20">RtlpBitsClearLow</a>[CurrentByte]) &gt;= NumberToFind) {
00543 
00544                     ULONG StartingIndex;
00545 
00546                     <span class="comment">//</span>
00547                     <span class="comment">//  It all fits in these two bytes, so we can compute</span>
00548                     <span class="comment">//  the starting index.  This is done by taking the</span>
00549                     <span class="comment">//  index of the current byte (bit 0) and subtracting the</span>
00550                     <span class="comment">//  number of bits its takes to get to the first cleared</span>
00551                     <span class="comment">//  high bit.</span>
00552                     <span class="comment">//</span>
00553 
00554                     StartingIndex = CurrentBitIndex -
00555                                              (LONG)<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a21">RtlpBitsClearHigh</a>[PreviousByte];
00556 
00557                     <span class="comment">//</span>
00558                     <span class="comment">//  Now make sure the total size isn't beyond the bitmap</span>
00559                     <span class="comment">//</span>
00560 
00561                     <span class="keywordflow">if</span> ((StartingIndex + NumberToFind) &lt;= SizeOfBitMap) {
00562 
00563                         <span class="keywordflow">return</span> StartingIndex;
00564                     }
00565                 }
00566 
00567                 <span class="comment">//</span>
00568                 <span class="comment">//  The previous byte does not help, so check the current byte.</span>
00569                 <span class="comment">//</span>
00570 
00571                 <span class="keywordflow">if</span> ((ULONG)<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a19">RtlpBitsClearAnywhere</a>[CurrentByte] &gt;= NumberToFind) {
00572 
00573                     UCHAR BitMask;
00574                     ULONG i;
00575 
00576                     <span class="comment">//</span>
00577                     <span class="comment">//  It all fits in a single byte, so calculate the bit</span>
00578                     <span class="comment">//  number.  We do this by taking a mask of the appropriate</span>
00579                     <span class="comment">//  size and shifting it over until it fits.  It fits when</span>
00580                     <span class="comment">//  we can bitwise-and the current byte with the bitmask</span>
00581                     <span class="comment">//  and get a zero back.</span>
00582                     <span class="comment">//</span>
00583 
00584                     BitMask = <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a23">FillMask</a>[ NumberToFind ];
00585                     <span class="keywordflow">for</span> (i = 0; (BitMask &amp; CurrentByte) != 0; i += 1) {
00586 
00587                         BitMask &lt;&lt;= 1;
00588                     }
00589 
00590                     <span class="comment">//</span>
00591                     <span class="comment">//  return to our caller the located bit index, and the</span>
00592                     <span class="comment">//  number that we found.</span>
00593                     <span class="comment">//</span>
00594 
00595                     <span class="keywordflow">return</span> CurrentBitIndex + i;
00596                 }
00597 
00598                 <span class="comment">//</span>
00599                 <span class="comment">//  For the next iteration through our loop we need to make</span>
00600                 <span class="comment">//  the current byte into the previous byte, and go to the</span>
00601                 <span class="comment">//  top of the loop again.</span>
00602                 <span class="comment">//</span>
00603 
00604                 PreviousByte = CurrentByte;
00605 
00606                 <span class="comment">//</span>
00607                 <span class="comment">//  Increment our Bit Index, and either exit, or get the</span>
00608                 <span class="comment">//  next byte.</span>
00609                 <span class="comment">//</span>
00610 
00611                 CurrentBitIndex += 8;
00612 
00613                 <span class="keywordflow">if</span> ( CurrentBitIndex &lt; EndByteIndex * 8 ) {
00614 
00615                     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a4">GET_BYTE</a>( CurrentByte );
00616 
00617                 } <span class="keywordflow">else</span> {
00618 
00619                     <span class="keywordflow">break</span>;
00620                 }
00621 
00622             } <span class="comment">// end loop CurrentBitIndex</span>
00623 
00624         <span class="comment">//</span>
00625         <span class="comment">//  The number to find is greater than 9 but if it is less than 15</span>
00626         <span class="comment">//  then we know it can be satisfied with at most 2 bytes, or 3 bytes</span>
00627         <span class="comment">//  if the middle byte (of the 3) is all zeros.</span>
00628         <span class="comment">//</span>
00629 
00630         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (NumberToFind &lt; 15) {
00631 
00632             ULONG CurrentBitIndex;
00633 
00634             UCHAR PreviousPreviousByte;
00635             UCHAR PreviousByte;
00636 
00637             PreviousByte = 0xff;
00638 
00639             <span class="comment">//</span>
00640             <span class="comment">//  Examine all the bytes within our test range searching</span>
00641             <span class="comment">//  for a fit</span>
00642             <span class="comment">//</span>
00643 
00644             CurrentBitIndex = StartByteIndex * 8;
00645 
00646             <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00647 
00648                 <span class="comment">//</span>
00649                 <span class="comment">//  For the next iteration through our loop we need to make</span>
00650                 <span class="comment">//  the current byte into the previous byte, the previous</span>
00651                 <span class="comment">//  byte into the previous previous byte, and go forward.</span>
00652                 <span class="comment">//</span>
00653 
00654                 PreviousPreviousByte = PreviousByte;
00655                 PreviousByte = CurrentByte;
00656 
00657                 <span class="comment">//</span>
00658                 <span class="comment">//  Increment our Bit Index, and either exit, or get the</span>
00659                 <span class="comment">//  next byte.</span>
00660                 <span class="comment">//</span>
00661 
00662                 CurrentBitIndex += 8;
00663 
00664                 <span class="keywordflow">if</span> ( CurrentBitIndex &lt; EndByteIndex * 8 ) {
00665 
00666                     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a4">GET_BYTE</a>( CurrentByte );
00667 
00668                 } <span class="keywordflow">else</span> {
00669 
00670                     <span class="keywordflow">break</span>;
00671                 }
00672 
00673                 <span class="comment">//</span>
00674                 <span class="comment">//  if the previous byte is all zeros then maybe the</span>
00675                 <span class="comment">//  request can be satisfied using the Previous Previous Byte</span>
00676                 <span class="comment">//  Previous Byte, and the Current Byte.</span>
00677                 <span class="comment">//</span>
00678 
00679                 <span class="keywordflow">if</span> ((PreviousByte == 0)
00680                     
00681                     &amp;&amp;
00682 
00683                     (((ULONG)<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a21">RtlpBitsClearHigh</a>[PreviousPreviousByte] + 8 +
00684                           (ULONG)<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a20">RtlpBitsClearLow</a>[CurrentByte]) &gt;= NumberToFind)) {
00685 
00686                     ULONG StartingIndex;
00687 
00688                     <span class="comment">//</span>
00689                     <span class="comment">//  It all fits in these three bytes, so we can compute</span>
00690                     <span class="comment">//  the starting index.  This is done by taking the</span>
00691                     <span class="comment">//  index of the previous byte (bit 0) and subtracting</span>
00692                     <span class="comment">//  the number of bits its takes to get to the first</span>
00693                     <span class="comment">//  cleared high bit.</span>
00694                     <span class="comment">//</span>
00695 
00696                     StartingIndex = (CurrentBitIndex - 8) -
00697                                      (LONG)<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a21">RtlpBitsClearHigh</a>[PreviousPreviousByte];
00698 
00699                     <span class="comment">//</span>
00700                     <span class="comment">//  Now make sure the total size isn't beyond the bitmap</span>
00701                     <span class="comment">//</span>
00702 
00703                     <span class="keywordflow">if</span> ((StartingIndex + NumberToFind) &lt;= SizeOfBitMap) {
00704 
00705                         <span class="keywordflow">return</span> StartingIndex;
00706                     }
00707                 }
00708 
00709                 <span class="comment">//</span>
00710                 <span class="comment">//  Check to see if the Previous byte and current byte</span>
00711                 <span class="comment">//  together satisfy the request.</span>
00712                 <span class="comment">//</span>
00713 
00714                 <span class="keywordflow">if</span> (((ULONG)<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a21">RtlpBitsClearHigh</a>[PreviousByte] +
00715                            (ULONG)<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a20">RtlpBitsClearLow</a>[CurrentByte]) &gt;= NumberToFind) {
00716 
00717                     ULONG StartingIndex;
00718 
00719                     <span class="comment">//</span>
00720                     <span class="comment">//  It all fits in these two bytes, so we can compute</span>
00721                     <span class="comment">//  the starting index.  This is done by taking the</span>
00722                     <span class="comment">//  index of the current byte (bit 0) and subtracting the</span>
00723                     <span class="comment">//  number of bits its takes to get to the first cleared</span>
00724                     <span class="comment">//  high bit.</span>
00725                     <span class="comment">//</span>
00726 
00727                     StartingIndex = CurrentBitIndex -
00728                                              (LONG)<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a21">RtlpBitsClearHigh</a>[PreviousByte];
00729 
00730                     <span class="comment">//</span>
00731                     <span class="comment">//  Now make sure the total size isn't beyond the bitmap</span>
00732                     <span class="comment">//</span>
00733 
00734                     <span class="keywordflow">if</span> ((StartingIndex + NumberToFind) &lt;= SizeOfBitMap) {
00735 
00736                         <span class="keywordflow">return</span> StartingIndex;
00737                     }
00738                 }
00739 
00740             } <span class="comment">// end loop CurrentBitIndex</span>
00741 
00742         <span class="comment">//</span>
00743         <span class="comment">//  The number to find is greater than or equal to 15.  This request</span>
00744         <span class="comment">//  has to have at least one byte of all zeros to be satisfied</span>
00745         <span class="comment">//</span>
00746 
00747         } <span class="keywordflow">else</span> {
00748 
00749             ULONG CurrentByteIndex;
00750 
00751             ULONG ZeroBytesNeeded;
00752             ULONG ZeroBytesFound;
00753 
00754             UCHAR StartOfRunByte;
00755             LONG StartOfRunIndex;
00756 
00757             <span class="comment">//</span>
00758             <span class="comment">//  First precalculate how many zero bytes we're going to need</span>
00759             <span class="comment">//</span>
00760 
00761             ZeroBytesNeeded = (NumberToFind - 7) / 8;
00762 
00763             <span class="comment">//</span>
00764             <span class="comment">//  Indicate for the first time through our loop that we haven't</span>
00765             <span class="comment">//  found a zero byte yet, and indicate that the start of the</span>
00766             <span class="comment">//  run is the byte just before the start byte index</span>
00767             <span class="comment">//</span>
00768 
00769             ZeroBytesFound = 0;
00770             StartOfRunByte = 0xff;
00771             StartOfRunIndex = StartByteIndex - 1;
00772 
00773             <span class="comment">//</span>
00774             <span class="comment">//  Examine all the bytes in our test range searching for a fit</span>
00775             <span class="comment">//</span>
00776 
00777             CurrentByteIndex = StartByteIndex;
00778 
00779             <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
00780 
00781                 <span class="comment">//</span>
00782                 <span class="comment">//  If the number of zero bytes fits our minimum requirements</span>
00783                 <span class="comment">//  then we can do the additional test to see if we</span>
00784                 <span class="comment">//  actually found a fit</span>
00785                 <span class="comment">//</span>
00786 
00787                 <span class="keywordflow">if</span> ((ZeroBytesFound &gt;= ZeroBytesNeeded)
00788 
00789                         &amp;&amp;
00790 
00791                     ((ULONG)<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a21">RtlpBitsClearHigh</a>[StartOfRunByte] + ZeroBytesFound*8 +
00792                      (ULONG)<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a20">RtlpBitsClearLow</a>[CurrentByte]) &gt;= NumberToFind) {
00793 
00794                     ULONG StartingIndex;
00795 
00796                     <span class="comment">//</span>
00797                     <span class="comment">//  It all fits in these bytes, so we can compute</span>
00798                     <span class="comment">//  the starting index.  This is done by taking the</span>
00799                     <span class="comment">//  StartOfRunIndex times 8 and adding the number of bits</span>
00800                     <span class="comment">//  it takes to get to the first cleared high bit.</span>
00801                     <span class="comment">//</span>
00802 
00803                     StartingIndex = (StartOfRunIndex * 8) +
00804                                      (8 - (LONG)<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a21">RtlpBitsClearHigh</a>[StartOfRunByte]);
00805 
00806                     <span class="comment">//</span>
00807                     <span class="comment">//  Now make sure the total size isn't beyond the bitmap</span>
00808                     <span class="comment">//</span>
00809 
00810                     <span class="keywordflow">if</span> ((StartingIndex + NumberToFind) &lt;= SizeOfBitMap) {
00811 
00812                         <span class="keywordflow">return</span> StartingIndex;
00813                     }
00814                 }
00815 
00816                 <span class="comment">//</span>
00817                 <span class="comment">//  Check to see if the byte is zero and increment</span>
00818                 <span class="comment">//  the number of zero bytes found</span>
00819                 <span class="comment">//</span>
00820 
00821                 <span class="keywordflow">if</span> (CurrentByte == 0) {
00822 
00823                     ZeroBytesFound += 1;
00824 
00825                 <span class="comment">//</span>
00826                 <span class="comment">//  The byte isn't a zero so we need to start over again</span>
00827                 <span class="comment">//  looking for zero bytes.</span>
00828                 <span class="comment">//</span>
00829 
00830                 } <span class="keywordflow">else</span> {
00831 
00832                     ZeroBytesFound = 0;
00833                     StartOfRunByte = CurrentByte;
00834                     StartOfRunIndex = CurrentByteIndex;
00835                 }
00836 
00837                 <span class="comment">//</span>
00838                 <span class="comment">//  Increment our Byte Index, and either exit, or get the</span>
00839                 <span class="comment">//  next byte.</span>
00840                 <span class="comment">//</span>
00841 
00842                 CurrentByteIndex += 1;
00843 
00844                 <span class="keywordflow">if</span> ( CurrentByteIndex &lt; EndByteIndex ) {
00845 
00846                     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a4">GET_BYTE</a>( CurrentByte );
00847 
00848                 } <span class="keywordflow">else</span> {
00849 
00850                     <span class="keywordflow">break</span>;
00851                 }
00852 
00853             } <span class="comment">// end loop CurrentByteIndex</span>
00854         }
00855     }
00856 
00857     <span class="comment">//</span>
00858     <span class="comment">//  We never found a fit so we'll return -1</span>
00859     <span class="comment">//</span>
00860 
00861     <span class="keywordflow">return</span> 0xffffffff;
00862 }
00863 
00864 
00865 ULONG
<a name="l00866"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a30">00866</a> <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a30">RtlFindSetBits</a> (
00867     IN PRTL_BITMAP BitMapHeader,
00868     IN ULONG NumberToFind,
00869     IN ULONG HintIndex
00870     )
00871 
00872 <span class="comment">/*++</span>
00873 <span class="comment"></span>
00874 <span class="comment">Routine Description:</span>
00875 <span class="comment"></span>
00876 <span class="comment">    This procedure searches the specified bit map for the specified</span>
00877 <span class="comment">    contiguous region of set bits.</span>
00878 <span class="comment"></span>
00879 <span class="comment">Arguments:</span>
00880 <span class="comment"></span>
00881 <span class="comment">    BitMapHeader - Supplies a pointer to the previously initialized BitMap.</span>
00882 <span class="comment"></span>
00883 <span class="comment">    NumberToFind - Supplies the size of the contiguous region to find.</span>
00884 <span class="comment"></span>
00885 <span class="comment">    HintIndex - Supplies the index (zero based) of where we should start</span>
00886 <span class="comment">        the search from within the bitmap.</span>
00887 <span class="comment"></span>
00888 <span class="comment">Return Value:</span>
00889 <span class="comment"></span>
00890 <span class="comment">    ULONG - Receives the starting index (zero based) of the contiguous</span>
00891 <span class="comment">        region of set bits found.  If such a region cannot be found then</span>
00892 <span class="comment">        a -1 (i.e., 0xffffffff) is returned.</span>
00893 <span class="comment"></span>
00894 <span class="comment">--*/</span>
00895 
00896 {
00897     ULONG SizeOfBitMap;
00898     ULONG SizeInBytes;
00899 
00900     ULONG HintBit;
00901     ULONG MainLoopIndex;
00902 
00903     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a2">GET_BYTE_DECLARATIONS</a>();
00904 
00905     <span class="comment">//</span>
00906     <span class="comment">//  To make the loops in our test run faster we'll extract the</span>
00907     <span class="comment">//  fields from the bitmap header</span>
00908     <span class="comment">//</span>
00909 
00910     SizeOfBitMap = <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;SizeOfBitMap;
00911     SizeInBytes = (SizeOfBitMap + 7) / 8;
00912 
00913     <span class="comment">//</span>
00914     <span class="comment">//  Set any unused bits in the last byte so we won't count them.  We do</span>
00915     <span class="comment">//  this by first checking if there is any odd bits in the last byte.</span>
00916     <span class="comment">//</span>
00917 
00918     <span class="keywordflow">if</span> ((SizeOfBitMap % 8) != 0) {
00919 
00920         <span class="comment">//</span>
00921         <span class="comment">//  The last byte has some odd bits so we'll set the high unused</span>
00922         <span class="comment">//  bits in the last byte to 0's</span>
00923         <span class="comment">//</span>
00924 
00925         ((PUCHAR)<a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;Buffer)[SizeInBytes - 1] &amp;=
00926                                                     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a23">FillMask</a>[SizeOfBitMap % 8];
00927     }
00928 
00929     <span class="comment">//</span>
00930     <span class="comment">//  Calculate from the hint index where the hint byte is and set ourselves</span>
00931     <span class="comment">//  up to read the hint on the next call to GET_BYTE.  To make the</span>
00932     <span class="comment">//  algorithm run fast we'll only honor hints down to the byte level of</span>
00933     <span class="comment">//  granularity.  There is a possibility that we'll need to execute</span>
00934     <span class="comment">//  our main logic twice.  Once to test from the hint byte to the end of</span>
00935     <span class="comment">//  the bitmap and the other to test from the start of the bitmap.  First</span>
00936     <span class="comment">//  we need to make sure the Hint Index is within range.</span>
00937     <span class="comment">//</span>
00938 
00939     <span class="keywordflow">if</span> (HintIndex &gt;= SizeOfBitMap) {
00940 
00941         HintIndex = 0;
00942     }
00943 
00944     HintBit = HintIndex % 8;
00945 
00946     <span class="keywordflow">for</span> (MainLoopIndex = 0; MainLoopIndex &lt; 2; MainLoopIndex += 1) {
00947 
00948         ULONG StartByteIndex;
00949         ULONG EndByteIndex;
00950 
00951         UCHAR CurrentByte;
00952 
00953         <span class="comment">//</span>
00954         <span class="comment">//  Check for the first time through the main loop, which indicates</span>
00955         <span class="comment">//  that we are going to start our search at our hint byte</span>
00956         <span class="comment">//</span>
00957 
00958         <span class="keywordflow">if</span> (MainLoopIndex == 0) {
00959 
00960             StartByteIndex = HintIndex / 8;
00961             EndByteIndex = SizeInBytes;
00962 
00963         <span class="comment">//</span>
00964         <span class="comment">//  This is the second time through the loop, make sure there is</span>
00965         <span class="comment">//  actually something to check before the hint byte</span>
00966         <span class="comment">//</span>
00967 
00968         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (HintIndex != 0) {
00969 
00970             <span class="comment">//</span>
00971             <span class="comment">//  The end index for the second time around is based on the</span>
00972             <span class="comment">//  number of bits we need to find.  We need to use this inorder</span>
00973             <span class="comment">//  to take the case where the preceding byte to the hint byte</span>
00974             <span class="comment">//  is the start of our run, and the run includes the hint byte</span>
00975             <span class="comment">//  and some following bytes, based on the number of bits needed</span>
00976             <span class="comment">//  The computation is to take the number of bits needed minus</span>
00977             <span class="comment">//  2 divided by 8 and then add 2.  This will take in to account</span>
00978             <span class="comment">//  the worst possible case where we have one bit hanging off</span>
00979             <span class="comment">//  of each end byte, and all intervening bytes are all zero.</span>
00980             <span class="comment">//  We only need to add one in the following equation because</span>
00981             <span class="comment">//  HintByte is already counted.</span>
00982             <span class="comment">//</span>
00983 
00984             <span class="keywordflow">if</span> (NumberToFind &lt; 2) {
00985 
00986                 EndByteIndex = HintIndex / 8;
00987 
00988             } <span class="keywordflow">else</span> {
00989 
00990                 EndByteIndex = HintIndex / 8 + ((NumberToFind - 2) / 8) + 1;
00991 
00992                 <span class="comment">//</span>
00993                 <span class="comment">//  Make sure we don't overrun the end of the bitmap</span>
00994                 <span class="comment">//</span>
00995 
00996                 <span class="keywordflow">if</span> (EndByteIndex &gt; SizeInBytes) {
00997 
00998                     EndByteIndex = SizeInBytes;
00999                 }
01000             }
01001 
01002             StartByteIndex = 0;
01003             HintIndex = 0;
01004             HintBit = 0;
01005 
01006         <span class="comment">//</span>
01007         <span class="comment">//  Otherwise we already did a complete loop through the bitmap</span>
01008         <span class="comment">//  so we should simply return -1 to say nothing was found</span>
01009         <span class="comment">//</span>
01010 
01011         } <span class="keywordflow">else</span> {
01012 
01013             <span class="keywordflow">return</span> 0xffffffff;
01014         }
01015 
01016         <span class="comment">//</span>
01017         <span class="comment">//  Set ourselves up to get the next byte</span>
01018         <span class="comment">//</span>
01019 
01020         <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a3">GET_BYTE_INITIALIZATION</a>(<a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>, StartByteIndex);
01021 
01022         <span class="comment">//</span>
01023         <span class="comment">//  Get the first byte, and clear any bits before the hint bit.</span>
01024         <span class="comment">//</span>
01025 
01026         <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a4">GET_BYTE</a>( CurrentByte );
01027 
01028         CurrentByte &amp;= <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a24">ZeroMask</a>[HintBit];
01029 
01030         <span class="comment">//</span>
01031         <span class="comment">//  If the number of bits can only fit in 1 or 2 bytes (i.e., 9 bits or</span>
01032         <span class="comment">//  less) we do the following test case.</span>
01033         <span class="comment">//</span>
01034 
01035         <span class="keywordflow">if</span> (NumberToFind &lt;= 9) {
01036 
01037             ULONG CurrentBitIndex;
01038 
01039             UCHAR PreviousByte;
01040 
01041             PreviousByte = 0x00;
01042 
01043             <span class="comment">//</span>
01044             <span class="comment">//  Examine all the bytes within our test range searching</span>
01045             <span class="comment">//  for a fit</span>
01046             <span class="comment">//</span>
01047 
01048             CurrentBitIndex = StartByteIndex * 8;
01049 
01050             <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01051 
01052                 <span class="comment">//</span>
01053                 <span class="comment">//  Check to see if the current byte coupled with the previous</span>
01054                 <span class="comment">//  byte will satisfy the requirement. The check uses the high</span>
01055                 <span class="comment">//  part of the previous byte and low part of the current byte.</span>
01056                 <span class="comment">//</span>
01057 
01058                 <span class="keywordflow">if</span> (((ULONG)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a2">RtlpBitsSetHigh</a>(PreviousByte) +
01059                              (ULONG)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a1">RtlpBitsSetLow</a>(CurrentByte)) &gt;= NumberToFind) {
01060 
01061                     ULONG StartingIndex;
01062 
01063                     <span class="comment">//</span>
01064                     <span class="comment">//  It all fits in these two bytes, so we can compute</span>
01065                     <span class="comment">//  the starting index.  This is done by taking the</span>
01066                     <span class="comment">//  index of the current byte (bit 0) and subtracting the</span>
01067                     <span class="comment">//  number of bits its takes to get to the first set</span>
01068                     <span class="comment">//  high bit.</span>
01069                     <span class="comment">//</span>
01070 
01071                     StartingIndex = CurrentBitIndex -
01072                                                (LONG)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a2">RtlpBitsSetHigh</a>(PreviousByte);
01073 
01074                     <span class="comment">//</span>
01075                     <span class="comment">//  Now make sure the total size isn't beyond the bitmap</span>
01076                     <span class="comment">//</span>
01077 
01078                     <span class="keywordflow">if</span> ((StartingIndex + NumberToFind) &lt;= SizeOfBitMap) {
01079 
01080                         <span class="keywordflow">return</span> StartingIndex;
01081                     }
01082                 }
01083 
01084                 <span class="comment">//</span>
01085                 <span class="comment">//  The previous byte does not help, so check the current byte.</span>
01086                 <span class="comment">//</span>
01087 
01088                 <span class="keywordflow">if</span> ((ULONG)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a0">RtlpBitSetAnywhere</a>(CurrentByte) &gt;= NumberToFind) {
01089 
01090                     UCHAR BitMask;
01091                     ULONG i;
01092 
01093                     <span class="comment">//</span>
01094                     <span class="comment">//  It all fits in a single byte, so calculate the bit</span>
01095                     <span class="comment">//  number.  We do this by taking a mask of the appropriate</span>
01096                     <span class="comment">//  size and shifting it over until it fits.  It fits when</span>
01097                     <span class="comment">//  we can bitwise-and the current byte with the bit mask</span>
01098                     <span class="comment">//  and get back the bit mask.</span>
01099                     <span class="comment">//</span>
01100 
01101                     BitMask = <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a23">FillMask</a>[ NumberToFind ];
01102                     <span class="keywordflow">for</span> (i = 0; (BitMask &amp; CurrentByte) != BitMask; i += 1) {
01103 
01104                         BitMask &lt;&lt;= 1;
01105                     }
01106 
01107                     <span class="comment">//</span>
01108                     <span class="comment">//  return to our caller the located bit index, and the</span>
01109                     <span class="comment">//  number that we found.</span>
01110                     <span class="comment">//</span>
01111 
01112                     <span class="keywordflow">return</span> CurrentBitIndex + i;
01113                 }
01114 
01115                 <span class="comment">//</span>
01116                 <span class="comment">//  For the next iteration through our loop we need to make</span>
01117                 <span class="comment">//  the current byte into the previous byte, and go to the</span>
01118                 <span class="comment">//  top of the loop again.</span>
01119                 <span class="comment">//</span>
01120 
01121                 PreviousByte = CurrentByte;
01122 
01123                 <span class="comment">//</span>
01124                 <span class="comment">//  Increment our Bit Index, and either exit, or get the</span>
01125                 <span class="comment">//  next byte.</span>
01126                 <span class="comment">//</span>
01127 
01128                 CurrentBitIndex += 8;
01129 
01130                 <span class="keywordflow">if</span> ( CurrentBitIndex &lt; EndByteIndex * 8 ) {
01131 
01132                     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a4">GET_BYTE</a>( CurrentByte );
01133 
01134                 } <span class="keywordflow">else</span> {
01135 
01136                     <span class="keywordflow">break</span>;
01137                 }
01138 
01139             } <span class="comment">// end loop CurrentBitIndex</span>
01140 
01141         <span class="comment">//</span>
01142         <span class="comment">//  The number to find is greater than 9 but if it is less than 15</span>
01143         <span class="comment">//  then we know it can be satisfied with at most 2 bytes, or 3 bytes</span>
01144         <span class="comment">//  if the middle byte (of the 3) is all ones.</span>
01145         <span class="comment">//</span>
01146 
01147         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (NumberToFind &lt; 15) {
01148 
01149             ULONG CurrentBitIndex;
01150 
01151             UCHAR PreviousPreviousByte;
01152             UCHAR PreviousByte;
01153 
01154             PreviousByte = 0x00;
01155 
01156             <span class="comment">//</span>
01157             <span class="comment">//  Examine all the bytes within our test range searching</span>
01158             <span class="comment">//  for a fit</span>
01159             <span class="comment">//</span>
01160 
01161             CurrentBitIndex = StartByteIndex * 8;
01162 
01163             <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01164 
01165                 <span class="comment">//</span>
01166                 <span class="comment">//  For the next iteration through our loop we need to make</span>
01167                 <span class="comment">//  the current byte into the previous byte, the previous</span>
01168                 <span class="comment">//  byte into the previous previous byte, and go to the</span>
01169                 <span class="comment">//  top of the loop again.</span>
01170                 <span class="comment">//</span>
01171 
01172                 PreviousPreviousByte = PreviousByte;
01173                 PreviousByte = CurrentByte;
01174 
01175                 <span class="comment">//</span>
01176                 <span class="comment">//  Increment our Bit Index, and either exit, or get the</span>
01177                 <span class="comment">//  next byte.</span>
01178                 <span class="comment">//</span>
01179 
01180                 CurrentBitIndex += 8;
01181 
01182                 <span class="keywordflow">if</span> ( CurrentBitIndex &lt; EndByteIndex * 8 ) {
01183 
01184                     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a4">GET_BYTE</a>( CurrentByte );
01185 
01186                 } <span class="keywordflow">else</span> {
01187 
01188                     <span class="keywordflow">break</span>;
01189                 }
01190 
01191                 <span class="comment">//</span>
01192                 <span class="comment">//  if the previous byte is all ones then maybe the</span>
01193                 <span class="comment">//  request can be satisfied using the Previous Previous Byte</span>
01194                 <span class="comment">//  Previous Byte, and the Current Byte.</span>
01195                 <span class="comment">//</span>
01196 
01197                 <span class="keywordflow">if</span> ((PreviousByte == 0xff)
01198 
01199                         &amp;&amp;
01200 
01201                     (((ULONG)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a2">RtlpBitsSetHigh</a>(PreviousPreviousByte) + 8 +
01202                             (ULONG)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a1">RtlpBitsSetLow</a>(CurrentByte)) &gt;= NumberToFind)) {
01203 
01204                     ULONG StartingIndex;
01205 
01206                     <span class="comment">//</span>
01207                     <span class="comment">//  It all fits in these three bytes, so we can compute</span>
01208                     <span class="comment">//  the starting index.  This is done by taking the</span>
01209                     <span class="comment">//  index of the previous byte (bit 0) and subtracting</span>
01210                     <span class="comment">//  the number of bits its takes to get to the first</span>
01211                     <span class="comment">//  set high bit.</span>
01212                     <span class="comment">//</span>
01213 
01214                     StartingIndex = (CurrentBitIndex - 8) -
01215                                        (LONG)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a2">RtlpBitsSetHigh</a>(PreviousPreviousByte);
01216 
01217                     <span class="comment">//</span>
01218                     <span class="comment">//  Now make sure the total size isn't beyond the bitmap</span>
01219                     <span class="comment">//</span>
01220 
01221                     <span class="keywordflow">if</span> ((StartingIndex + NumberToFind) &lt;= SizeOfBitMap) {
01222 
01223                         <span class="keywordflow">return</span> StartingIndex;
01224                     }
01225                 }
01226 
01227                 <span class="comment">//</span>
01228                 <span class="comment">//  Check to see if the Previous byte and current byte</span>
01229                 <span class="comment">//  together satisfy the request.</span>
01230                 <span class="comment">//</span>
01231 
01232                 <span class="keywordflow">if</span> (((ULONG)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a2">RtlpBitsSetHigh</a>(PreviousByte) +
01233                              (ULONG)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a1">RtlpBitsSetLow</a>(CurrentByte)) &gt;= NumberToFind) {
01234 
01235                     ULONG StartingIndex;
01236 
01237                     <span class="comment">//</span>
01238                     <span class="comment">//  It all fits in these two bytes, so we can compute</span>
01239                     <span class="comment">//  the starting index.  This is done by taking the</span>
01240                     <span class="comment">//  index of the current byte (bit 0) and subtracting the</span>
01241                     <span class="comment">//  number of bits its takes to get to the first set</span>
01242                     <span class="comment">//  high bit.</span>
01243                     <span class="comment">//</span>
01244 
01245                     StartingIndex = CurrentBitIndex -
01246                                                (LONG)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a2">RtlpBitsSetHigh</a>(PreviousByte);
01247 
01248                     <span class="comment">//</span>
01249                     <span class="comment">//  Now make sure the total size isn't beyond the bitmap</span>
01250                     <span class="comment">//</span>
01251 
01252                     <span class="keywordflow">if</span> ((StartingIndex + NumberToFind) &lt;= SizeOfBitMap) {
01253 
01254                         <span class="keywordflow">return</span> StartingIndex;
01255                     }
01256                 }
01257             } <span class="comment">// end loop CurrentBitIndex</span>
01258 
01259         <span class="comment">//</span>
01260         <span class="comment">//  The number to find is greater than or equal to 15.  This request</span>
01261         <span class="comment">//  has to have at least one byte of all ones to be satisfied</span>
01262         <span class="comment">//</span>
01263 
01264         } <span class="keywordflow">else</span> {
01265 
01266             ULONG CurrentByteIndex;
01267 
01268             ULONG OneBytesNeeded;
01269             ULONG OneBytesFound;
01270 
01271             UCHAR StartOfRunByte;
01272             LONG StartOfRunIndex;
01273 
01274             <span class="comment">//</span>
01275             <span class="comment">//  First precalculate how many one bytes we're going to need</span>
01276             <span class="comment">//</span>
01277 
01278             OneBytesNeeded = (NumberToFind - 7) / 8;
01279 
01280             <span class="comment">//</span>
01281             <span class="comment">//  Indicate for the first time through our loop that we haven't</span>
01282             <span class="comment">//  found a one byte yet, and indicate that the start of the</span>
01283             <span class="comment">//  run is the byte just before the start byte index</span>
01284             <span class="comment">//</span>
01285 
01286             OneBytesFound = 0;
01287             StartOfRunByte = 0x00;
01288             StartOfRunIndex = StartByteIndex - 1;
01289 
01290             <span class="comment">//</span>
01291             <span class="comment">//  Examine all the bytes in our test range searching for a fit</span>
01292             <span class="comment">//</span>
01293 
01294             CurrentByteIndex = StartByteIndex;
01295 
01296             <span class="keywordflow">while</span> (<a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>) {
01297 
01298                 <span class="comment">//</span>
01299                 <span class="comment">//  If the number of zero bytes fits our minimum requirements</span>
01300                 <span class="comment">//  then we can do the additional test to see if we</span>
01301                 <span class="comment">//  actually found a fit</span>
01302                 <span class="comment">//</span>
01303 
01304                 <span class="keywordflow">if</span> ((OneBytesFound &gt;= OneBytesNeeded)
01305 
01306                         &amp;&amp;
01307 
01308                     ((ULONG)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a2">RtlpBitsSetHigh</a>(StartOfRunByte) + OneBytesFound*8 +
01309                      (ULONG)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a1">RtlpBitsSetLow</a>(CurrentByte)) &gt;= NumberToFind) {
01310 
01311                     ULONG StartingIndex;
01312 
01313                     <span class="comment">//</span>
01314                     <span class="comment">//  It all fits in these bytes, so we can compute</span>
01315                     <span class="comment">//  the starting index.  This is done by taking the</span>
01316                     <span class="comment">//  StartOfRunIndex times 8 and adding the number of bits</span>
01317                     <span class="comment">//  it takes to get to the first set high bit.</span>
01318                     <span class="comment">//</span>
01319 
01320                     StartingIndex = (StartOfRunIndex * 8) +
01321                                        (8 - (LONG)<a class="code" href="../../d5/d9/ntrtlp_8h.html#a2">RtlpBitsSetHigh</a>(StartOfRunByte));
01322 
01323                     <span class="comment">//</span>
01324                     <span class="comment">//  Now make sure the total size isn't beyond the bitmap</span>
01325                     <span class="comment">//</span>
01326 
01327                     <span class="keywordflow">if</span> ((StartingIndex + NumberToFind) &lt;= SizeOfBitMap) {
01328 
01329                         <span class="keywordflow">return</span> StartingIndex;
01330                     }
01331                 }
01332 
01333                 <span class="comment">//</span>
01334                 <span class="comment">//  Check to see if the byte is all ones and increment</span>
01335                 <span class="comment">//  the number of one bytes found</span>
01336                 <span class="comment">//</span>
01337 
01338                 <span class="keywordflow">if</span> (CurrentByte == 0xff) {
01339 
01340                     OneBytesFound += 1;
01341 
01342                 <span class="comment">//</span>
01343                 <span class="comment">//  The byte isn't all ones so we need to start over again</span>
01344                 <span class="comment">//  looking for one bytes.</span>
01345                 <span class="comment">//</span>
01346 
01347                 } <span class="keywordflow">else</span> {
01348 
01349                     OneBytesFound = 0;
01350                     StartOfRunByte = CurrentByte;
01351                     StartOfRunIndex = CurrentByteIndex;
01352                 }
01353 
01354                 <span class="comment">//</span>
01355                 <span class="comment">//  Increment our Byte Index, and either exit, or get the</span>
01356                 <span class="comment">//  next byte.</span>
01357                 <span class="comment">//</span>
01358 
01359                 CurrentByteIndex += 1;
01360 
01361                 <span class="keywordflow">if</span> ( CurrentByteIndex &lt; EndByteIndex ) {
01362 
01363                     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a4">GET_BYTE</a>( CurrentByte );
01364 
01365                 } <span class="keywordflow">else</span> {
01366 
01367                     <span class="keywordflow">break</span>;
01368                 }
01369             } <span class="comment">// end loop CurrentByteIndex</span>
01370         }
01371     }
01372 
01373     <span class="comment">//</span>
01374     <span class="comment">//  We never found a fit so we'll return -1</span>
01375     <span class="comment">//</span>
01376 
01377     <span class="keywordflow">return</span> 0xffffffff;
01378 }
01379 
01380 
01381 ULONG
<a name="l01382"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a31">01382</a> <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a31">RtlFindClearBitsAndSet</a> (
01383     IN PRTL_BITMAP BitMapHeader,
01384     IN ULONG NumberToFind,
01385     IN ULONG HintIndex
01386     )
01387 
01388 <span class="comment">/*++</span>
01389 <span class="comment"></span>
01390 <span class="comment">Routine Description:</span>
01391 <span class="comment"></span>
01392 <span class="comment">    This procedure searches the specified bit map for the specified</span>
01393 <span class="comment">    contiguous region of clear bits, sets the bits and returns the</span>
01394 <span class="comment">    number of bits found, and the starting bit number which was clear</span>
01395 <span class="comment">    then set.</span>
01396 <span class="comment"></span>
01397 <span class="comment">Arguments:</span>
01398 <span class="comment"></span>
01399 <span class="comment">    BitMapHeader - Supplies a pointer to the previously initialized BitMap.</span>
01400 <span class="comment"></span>
01401 <span class="comment">    NumberToFind - Supplies the size of the contiguous region to find.</span>
01402 <span class="comment"></span>
01403 <span class="comment">    HintIndex - Supplies the index (zero based) of where we should start</span>
01404 <span class="comment">        the search from within the bitmap.</span>
01405 <span class="comment"></span>
01406 <span class="comment">Return Value:</span>
01407 <span class="comment"></span>
01408 <span class="comment">    ULONG - Receives the starting index (zero based) of the contiguous</span>
01409 <span class="comment">        region found.  If such a region cannot be located a -1 (i.e.,</span>
01410 <span class="comment">        0xffffffff) is returned.</span>
01411 <span class="comment"></span>
01412 <span class="comment">--*/</span>
01413 
01414 {
01415     ULONG StartingIndex;
01416 
01417     <span class="comment">//</span>
01418     <span class="comment">//  First look for a run of clear bits that equals the size requested</span>
01419     <span class="comment">//</span>
01420 
01421     StartingIndex = <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a29">RtlFindClearBits</a>( <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>,
01422                                       NumberToFind,
01423                                       HintIndex );
01424 
01425     <span class="comment">//DbgPrint("FindClearBits %08lx, ", NumberToFind);</span>
01426     <span class="comment">//DbgPrint("%08lx", StartingIndex);</span>
01427     <span class="comment">//DumpBitMap(BitMapHeader);</span>
01428 
01429     <span class="keywordflow">if</span> (StartingIndex != 0xffffffff) {
01430 
01431         <span class="comment">//</span>
01432         <span class="comment">//  We found a large enough run of clear bits so now set them</span>
01433         <span class="comment">//</span>
01434 
01435         <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a34">RtlSetBits</a>( <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>, StartingIndex, NumberToFind );
01436     }
01437 
01438     <span class="comment">//</span>
01439     <span class="comment">//  And return to our caller</span>
01440     <span class="comment">//</span>
01441 
01442     <span class="keywordflow">return</span> StartingIndex;
01443 
01444 }
01445 
01446 
01447 ULONG
<a name="l01448"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a32">01448</a> <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a32">RtlFindSetBitsAndClear</a> (
01449     IN PRTL_BITMAP BitMapHeader,
01450     IN ULONG NumberToFind,
01451     IN ULONG HintIndex
01452     )
01453 
01454 <span class="comment">/*++</span>
01455 <span class="comment"></span>
01456 <span class="comment">Routine Description:</span>
01457 <span class="comment"></span>
01458 <span class="comment">    This procedure searches the specified bit map for the specified</span>
01459 <span class="comment">    contiguous region of set bits, clears the bits and returns the</span>
01460 <span class="comment">    number of bits found and the starting bit number which was set then</span>
01461 <span class="comment">    clear.</span>
01462 <span class="comment"></span>
01463 <span class="comment">Arguments:</span>
01464 <span class="comment"></span>
01465 <span class="comment">    BitMapHeader - Supplies a pointer to the previously initialized BitMap.</span>
01466 <span class="comment"></span>
01467 <span class="comment">    NumberToFind - Supplies the size of the contiguous region to find.</span>
01468 <span class="comment"></span>
01469 <span class="comment">    HintIndex - Supplies the index (zero based) of where we should start</span>
01470 <span class="comment">        the search from within the bitmap.</span>
01471 <span class="comment"></span>
01472 <span class="comment">Return Value:</span>
01473 <span class="comment"></span>
01474 <span class="comment">    ULONG - Receives the starting index (zero based) of the contiguous</span>
01475 <span class="comment">        region found.  If such a region cannot be located a -1 (i.e.,</span>
01476 <span class="comment">        0xffffffff) is returned.</span>
01477 <span class="comment"></span>
01478 <span class="comment"></span>
01479 <span class="comment">--*/</span>
01480 
01481 {
01482     ULONG StartingIndex;
01483 
01484     <span class="comment">//</span>
01485     <span class="comment">//  First look for a run of set bits that equals the size requested</span>
01486     <span class="comment">//</span>
01487 
01488     <span class="keywordflow">if</span> ((StartingIndex = <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a30">RtlFindSetBits</a>( <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>,
01489                                          NumberToFind,
01490                                          HintIndex )) != 0xffffffff) {
01491 
01492         <span class="comment">//</span>
01493         <span class="comment">//  We found a large enough run of set bits so now clear them</span>
01494         <span class="comment">//</span>
01495 
01496         <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a33">RtlClearBits</a>( <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>, StartingIndex, NumberToFind );
01497     }
01498 
01499     <span class="comment">//</span>
01500     <span class="comment">//  And return to our caller</span>
01501     <span class="comment">//</span>
01502 
01503     <span class="keywordflow">return</span> StartingIndex;
01504 }
01505 
01506 
01507 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01508"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a33">01508</a> <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a33">RtlClearBits</a> (
01509     IN PRTL_BITMAP BitMapHeader,
01510     IN ULONG StartingIndex,
01511     IN ULONG NumberToClear
01512     )
01513 
01514 <span class="comment">/*++</span>
01515 <span class="comment"></span>
01516 <span class="comment">Routine Description:</span>
01517 <span class="comment"></span>
01518 <span class="comment">    This procedure clears the specified range of bits within the</span>
01519 <span class="comment">    specified bit map.</span>
01520 <span class="comment"></span>
01521 <span class="comment">Arguments:</span>
01522 <span class="comment"></span>
01523 <span class="comment">    BitMapHeader - Supplies a pointer to the previously initialized Bit Map.</span>
01524 <span class="comment"></span>
01525 <span class="comment">    StartingIndex - Supplies the index (zero based) of the first bit to clear.</span>
01526 <span class="comment"></span>
01527 <span class="comment">    NumberToClear - Supplies the number of bits to clear.</span>
01528 <span class="comment"></span>
01529 <span class="comment">Return Value:</span>
01530 <span class="comment"></span>
01531 <span class="comment">    None.</span>
01532 <span class="comment"></span>
01533 <span class="comment">--*/</span>
01534 
01535 {
01536     ULONG BitOffset;
01537     PULONG CurrentLong;
01538 
01539     <span class="comment">//DbgPrint("ClearBits %08lx, ", NumberToClear);</span>
01540     <span class="comment">//DbgPrint("%08lx", StartingIndex);</span>
01541 
01542     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( StartingIndex + NumberToClear &lt;= BitMapHeader-&gt;SizeOfBitMap );
01543 
01544     <span class="comment">//</span>
01545     <span class="comment">//  Special case the situation where the number of bits to clear is</span>
01546     <span class="comment">//  zero.  Turn this into a noop.</span>
01547     <span class="comment">//</span>
01548 
01549     <span class="keywordflow">if</span> (NumberToClear == 0) {
01550 
01551         <span class="keywordflow">return</span>;
01552     }
01553 
01554     BitOffset = StartingIndex % 32;
01555 
01556     <span class="comment">//</span>
01557     <span class="comment">//  Get a pointer to the first longword that needs to be zeroed out</span>
01558     <span class="comment">//</span>
01559 
01560     CurrentLong = &amp;<a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;Buffer[ StartingIndex / 32 ];
01561 
01562     <span class="comment">//</span>
01563     <span class="comment">//  Check if we can only need to clear out one longword.</span>
01564     <span class="comment">//</span>
01565 
01566     <span class="keywordflow">if</span> ((BitOffset + NumberToClear) &lt;= 32) {
01567 
01568         <span class="comment">//</span>
01569         <span class="comment">//  To build a mask of bits to clear we shift left to get the number</span>
01570         <span class="comment">//  of bits we're clearing and then shift right to put it in position.</span>
01571         <span class="comment">//  We'll typecast the right shift to ULONG to make sure it doesn't</span>
01572         <span class="comment">//  do a sign extend.</span>
01573         <span class="comment">//</span>
01574 
01575         *CurrentLong &amp;= ~<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a1">LeftShiftUlong</a>(<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a0">RightShiftUlong</a>(((ULONG)0xFFFFFFFF),(32 - NumberToClear)),
01576                                                                     BitOffset);
01577 
01578         <span class="comment">//</span>
01579         <span class="comment">//  And return to our caller</span>
01580         <span class="comment">//</span>
01581 
01582         <span class="comment">//DumpBitMap(BitMapHeader);</span>
01583 
01584         <span class="keywordflow">return</span>;
01585     }
01586 
01587     <span class="comment">//</span>
01588     <span class="comment">//  We can clear out to the end of the first longword so we'll</span>
01589     <span class="comment">//  do that right now.</span>
01590     <span class="comment">//</span>
01591 
01592     *CurrentLong &amp;= ~<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a1">LeftShiftUlong</a>(0xFFFFFFFF, BitOffset);
01593 
01594     <span class="comment">//</span>
01595     <span class="comment">//  And indicate what the next longword to clear is and how many</span>
01596     <span class="comment">//  bits are left to clear</span>
01597     <span class="comment">//</span>
01598 
01599     CurrentLong += 1;
01600     NumberToClear -= 32 - BitOffset;
01601 
01602     <span class="comment">//</span>
01603     <span class="comment">//  The bit position is now long aligned, so we can continue</span>
01604     <span class="comment">//  clearing longwords until the number to clear is less than 32</span>
01605     <span class="comment">//</span>
01606 
01607     <span class="keywordflow">while</span> (NumberToClear &gt;= 32) {
01608 
01609         *CurrentLong = 0;
01610         CurrentLong += 1;
01611         NumberToClear -= 32;
01612     }
01613 
01614     <span class="comment">//</span>
01615     <span class="comment">//  And now we can clear the remaining bits, if there are any, in the</span>
01616     <span class="comment">//  last longword</span>
01617     <span class="comment">//</span>
01618 
01619     <span class="keywordflow">if</span> (NumberToClear &gt; 0) {
01620 
01621         *CurrentLong &amp;= <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a1">LeftShiftUlong</a>(0xFFFFFFFF, NumberToClear);
01622     }
01623 
01624     <span class="comment">//</span>
01625     <span class="comment">//  And return to our caller</span>
01626     <span class="comment">//</span>
01627 
01628     <span class="comment">//DumpBitMap(BitMapHeader);</span>
01629 
01630     <span class="keywordflow">return</span>;
01631 }
01632 
01633 <a class="code" href="../../d2/d7/hal_8h.html#a212">VOID</a>
<a name="l01634"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a34">01634</a> <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a34">RtlSetBits</a> (
01635     IN PRTL_BITMAP BitMapHeader,
01636     IN ULONG StartingIndex,
01637     IN ULONG NumberToSet
01638     )
01639 
01640 <span class="comment">/*++</span>
01641 <span class="comment"></span>
01642 <span class="comment">Routine Description:</span>
01643 <span class="comment"></span>
01644 <span class="comment">    This procedure sets the specified range of bits within the</span>
01645 <span class="comment">    specified bit map.</span>
01646 <span class="comment"></span>
01647 <span class="comment">Arguments:</span>
01648 <span class="comment"></span>
01649 <span class="comment">    BitMapHeader - Supplies a pointer to the previously initialied BitMap.</span>
01650 <span class="comment"></span>
01651 <span class="comment">    StartingIndex - Supplies the index (zero based) of the first bit to set.</span>
01652 <span class="comment"></span>
01653 <span class="comment">    NumberToSet - Supplies the number of bits to set.</span>
01654 <span class="comment"></span>
01655 <span class="comment">Return Value:</span>
01656 <span class="comment"></span>
01657 <span class="comment">    None.</span>
01658 <span class="comment"></span>
01659 <span class="comment">--*/</span>
01660 {
01661     ULONG BitOffset;
01662     PULONG CurrentLong;
01663 
01664     <span class="comment">//DbgPrint("SetBits %08lx, ", NumberToSet);</span>
01665     <span class="comment">//DbgPrint("%08lx", StartingIndex);</span>
01666 
01667     <a class="code" href="../../d6/d5/ntgdi_2icm_2inc_2debug_8h.html#a7">ASSERT</a>( StartingIndex + NumberToSet &lt;= BitMapHeader-&gt;SizeOfBitMap );
01668 
01669     <span class="comment">//</span>
01670     <span class="comment">//  Special case the situation where the number of bits to set is</span>
01671     <span class="comment">//  zero.  Turn this into a noop.</span>
01672     <span class="comment">//</span>
01673 
01674     <span class="keywordflow">if</span> (NumberToSet == 0) {
01675 
01676         <span class="keywordflow">return</span>;
01677     }
01678 
01679     BitOffset = StartingIndex % 32;
01680 
01681     <span class="comment">//</span>
01682     <span class="comment">//  Get a pointer to the first longword that needs to be set</span>
01683     <span class="comment">//</span>
01684 
01685     CurrentLong = &amp;<a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;Buffer[ StartingIndex / 32 ];
01686 
01687     <span class="comment">//</span>
01688     <span class="comment">//  Check if we can only need to set one longword.</span>
01689     <span class="comment">//</span>
01690 
01691     <span class="keywordflow">if</span> ((BitOffset + NumberToSet) &lt;= 32) {
01692 
01693         <span class="comment">//</span>
01694         <span class="comment">//  To build a mask of bits to set we shift left to get the number</span>
01695         <span class="comment">//  of bits we're setting and then shift right to put it in position.</span>
01696         <span class="comment">//  We'll typecast the right shift to ULONG to make sure it doesn't</span>
01697         <span class="comment">//  do a sign extend.</span>
01698         <span class="comment">//</span>
01699 
01700         *CurrentLong |= <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a1">LeftShiftUlong</a>(<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a0">RightShiftUlong</a>(((ULONG)0xFFFFFFFF),(32 - NumberToSet)),
01701                                                                     BitOffset);
01702 
01703         <span class="comment">//</span>
01704         <span class="comment">//  And return to our caller</span>
01705         <span class="comment">//</span>
01706 
01707         <span class="comment">//DumpBitMap(BitMapHeader);</span>
01708 
01709         <span class="keywordflow">return</span>;
01710     }
01711 
01712     <span class="comment">//</span>
01713     <span class="comment">//  We can set bits out to the end of the first longword so we'll</span>
01714     <span class="comment">//  do that right now.</span>
01715     <span class="comment">//</span>
01716 
01717     *CurrentLong |= <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a1">LeftShiftUlong</a>(0xFFFFFFFF, BitOffset);
01718 
01719     <span class="comment">//</span>
01720     <span class="comment">//  And indicate what the next longword to set is and how many</span>
01721     <span class="comment">//  bits are left to set</span>
01722     <span class="comment">//</span>
01723 
01724     CurrentLong += 1;
01725     NumberToSet -= 32 - BitOffset;
01726 
01727     <span class="comment">//</span>
01728     <span class="comment">//  The bit position is now long aligned, so we can continue</span>
01729     <span class="comment">//  setting longwords until the number to set is less than 32</span>
01730     <span class="comment">//</span>
01731 
01732     <span class="keywordflow">while</span> (NumberToSet &gt;= 32) {
01733 
01734         *CurrentLong = 0xffffffff;
01735         CurrentLong += 1;
01736         NumberToSet -= 32;
01737     }
01738 
01739     <span class="comment">//</span>
01740     <span class="comment">//  And now we can set the remaining bits, if there are any, in the</span>
01741     <span class="comment">//  last longword</span>
01742     <span class="comment">//</span>
01743 
01744     <span class="keywordflow">if</span> (NumberToSet &gt; 0) {
01745 
01746         *CurrentLong |= ~<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a1">LeftShiftUlong</a>(0xFFFFFFFF, NumberToSet);
01747     }
01748 
01749     <span class="comment">//</span>
01750     <span class="comment">//  And return to our caller</span>
01751     <span class="comment">//</span>
01752 
01753     <span class="comment">//DumpBitMap(BitMapHeader);</span>
01754 
01755     <span class="keywordflow">return</span>;
01756 }
01757 
01758 
01759 <span class="preprocessor">#if DBG</span>
01760 <span class="preprocessor"></span>BOOLEAN NtfsDebugIt = <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
01761 <span class="preprocessor">#endif</span>
01762 <span class="preprocessor"></span>
01763 ULONG
<a name="l01764"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a35">01764</a> <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a35">RtlFindClearRuns</a> (
01765     IN PRTL_BITMAP BitMapHeader,
01766     PRTL_BITMAP_RUN RunArray,
01767     ULONG SizeOfRunArray,
01768     BOOLEAN LocateLongestRuns
01769     )
01770 
01771 <span class="comment">/*++</span>
01772 <span class="comment"></span>
01773 <span class="comment">Routine Description:</span>
01774 <span class="comment"></span>
01775 <span class="comment">    This procedure finds N contiguous runs of clear bits</span>
01776 <span class="comment">    within the specified bit map.</span>
01777 <span class="comment"></span>
01778 <span class="comment">Arguments:</span>
01779 <span class="comment"></span>
01780 <span class="comment">    BitMapHeader - Supplies a pointer to the previously initialized BitMap.</span>
01781 <span class="comment"></span>
01782 <span class="comment">    RunArray - Receives the bit position, and length of each of the free runs</span>
01783 <span class="comment">        that the procedure locates.  The array will be sorted according to</span>
01784 <span class="comment">        length.</span>
01785 <span class="comment"></span>
01786 <span class="comment">    SizeOfRunArray - Supplies the maximum number of entries the caller wants</span>
01787 <span class="comment">        returned in RunArray</span>
01788 <span class="comment"></span>
01789 <span class="comment">    LocateLongestRuns - Indicates if this routine is to return the longest runs</span>
01790 <span class="comment">        it can find or just the first N runs.</span>
01791 <span class="comment"></span>
01792 <span class="comment"></span>
01793 <span class="comment">Return Value:</span>
01794 <span class="comment"></span>
01795 <span class="comment">    ULONG - Receives the number of runs that the procedure has located and</span>
01796 <span class="comment">        returned in RunArray</span>
01797 <span class="comment"></span>
01798 <span class="comment">--*/</span>
01799 
01800 {
01801     ULONG RunIndex;
01802     ULONG i;
01803     LONG j;
01804 
01805     ULONG SizeOfBitMap;
01806     ULONG SizeInBytes;
01807 
01808     ULONG CurrentRunSize;
01809     ULONG CurrentRunIndex;
01810     ULONG CurrentByteIndex;
01811     UCHAR CurrentByte;
01812 
01813     UCHAR BitMask;
01814     UCHAR TempNumber;
01815 
01816     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a2">GET_BYTE_DECLARATIONS</a>();
01817 
01818     <span class="comment">//</span>
01819     <span class="comment">//  Reference the bitmap header to make the loop run faster</span>
01820     <span class="comment">//</span>
01821 
01822     SizeOfBitMap = <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;SizeOfBitMap;
01823     SizeInBytes = (SizeOfBitMap + 7) / 8;
01824 
01825     <span class="comment">//</span>
01826     <span class="comment">//  Set any unused bits in the last byte so we won't count them.  We do</span>
01827     <span class="comment">//  this by first checking if there is any odd bits in the last byte.</span>
01828     <span class="comment">//</span>
01829 
01830     <span class="keywordflow">if</span> ((SizeOfBitMap % 8) != 0) {
01831 
01832         <span class="comment">//</span>
01833         <span class="comment">//  The last byte has some odd bits so we'll set the high unused</span>
01834         <span class="comment">//  bits in the last byte to 1's</span>
01835         <span class="comment">//</span>
01836 
01837         ((PUCHAR)<a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;Buffer)[SizeInBytes - 1] |= <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a24">ZeroMask</a>[SizeOfBitMap % 8];
01838     }
01839 
01840     <span class="comment">//</span>
01841     <span class="comment">//  Set it up so we can the use GET_BYTE macro</span>
01842     <span class="comment">//</span>
01843 
01844     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a3">GET_BYTE_INITIALIZATION</a>( <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>, 0);
01845 
01846     <span class="comment">//</span>
01847     <span class="comment">//  Set our RunIndex and current run variables.  Run Index allays is the index</span>
01848     <span class="comment">//  of the next location to fill in or it could be one beyond the end of the</span>
01849     <span class="comment">//  array.</span>
01850     <span class="comment">//</span>
01851 
01852     RunIndex = 0;
01853     <span class="keywordflow">for</span> (i = 0; i &lt; SizeOfRunArray; i += 1) { RunArray[i].NumberOfBits = 0; }
01854 
01855     CurrentRunSize = 0;
01856     CurrentRunIndex = 0;
01857 
01858     <span class="comment">//</span>
01859     <span class="comment">//  Examine every byte in the BitMap</span>
01860     <span class="comment">//</span>
01861 
01862     <span class="keywordflow">for</span> (CurrentByteIndex = 0;
01863          CurrentByteIndex &lt; SizeInBytes;
01864          CurrentByteIndex += 1) {
01865 
01866         <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a4">GET_BYTE</a>( CurrentByte );
01867 
01868 <span class="preprocessor">#if DBG</span>
01869 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (NtfsDebugIt) { <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"%d: %08lx %08lx %08lx %08lx %08lx\n"</span>,__LINE__,RunIndex,CurrentRunSize,CurrentRunIndex,CurrentByteIndex,CurrentByte); }
01870 <span class="preprocessor">#endif</span>
01871 <span class="preprocessor"></span>
01872         <span class="comment">//</span>
01873         <span class="comment">//  If the current byte is not all zeros we need to (1) check if</span>
01874         <span class="comment">//  the current run is big enough to be inserted in the output</span>
01875         <span class="comment">//  array, and (2) check if the current byte inside of itself can</span>
01876         <span class="comment">//  be inserted, and (3) start a new current run</span>
01877         <span class="comment">//</span>
01878 
01879         <span class="keywordflow">if</span> (CurrentByte != 0x00) {
01880 
01881             <span class="comment">//</span>
01882             <span class="comment">//  Compute the final size of the current run</span>
01883             <span class="comment">//</span>
01884 
01885             CurrentRunSize += <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a20">RtlpBitsClearLow</a>[CurrentByte];
01886 
01887             <span class="comment">//</span>
01888             <span class="comment">//  Check if the current run be stored in the output array by either</span>
01889             <span class="comment">//  there being room in the array or the last entry is smaller than</span>
01890             <span class="comment">//  the current entry</span>
01891             <span class="comment">//</span>
01892 
01893             <span class="keywordflow">if</span> (CurrentRunSize &gt; 0) {
01894 
01895                 <span class="keywordflow">if</span> ((RunIndex &lt; SizeOfRunArray) ||
01896                     (RunArray[RunIndex-1].NumberOfBits &lt; CurrentRunSize)) {
01897 
01898                     <span class="comment">//</span>
01899                     <span class="comment">//  If necessary increment the RunIndex and shift over the output</span>
01900                     <span class="comment">//  array until we find the slot where the new run belongs.  We only</span>
01901                     <span class="comment">//  do the shifting if we're returning longest runs.</span>
01902                     <span class="comment">//</span>
01903 
01904                     <span class="keywordflow">if</span> (RunIndex &lt; SizeOfRunArray) { RunIndex += 1; }
01905 
01906                     <span class="keywordflow">for</span> (j = RunIndex-2; LocateLongestRuns &amp;&amp; (j &gt;= 0) &amp;&amp; (RunArray[j].NumberOfBits &lt; CurrentRunSize); j -= 1) {
01907 
01908                         RunArray[j+1] = RunArray[j];
01909                     }
01910 
01911                     RunArray[j+1].NumberOfBits = CurrentRunSize;
01912                     RunArray[j+1].StartingIndex = CurrentRunIndex;
01913 
01914 <span class="preprocessor">#if DBG</span>
01915 <span class="preprocessor"></span>                    <span class="keywordflow">if</span> (NtfsDebugIt) { <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"%d: %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"</span>,
01916                         __LINE__,RunIndex,CurrentRunSize,CurrentRunIndex,CurrentByteIndex,CurrentByte,j,RunArray[j+1].NumberOfBits,RunArray[j+1].StartingIndex); }
01917 <span class="preprocessor">#endif</span>
01918 <span class="preprocessor"></span>
01919                     <span class="comment">//</span>
01920                     <span class="comment">//  Now if the array is full and we are not doing longest runs return</span>
01921                     <span class="comment">//  to our caller</span>
01922                     <span class="comment">//</span>
01923 
01924                     <span class="keywordflow">if</span> (!LocateLongestRuns &amp;&amp; (RunIndex &gt;= SizeOfRunArray)) {
01925 
01926                         <span class="keywordflow">return</span> RunIndex;
01927                     }
01928                 }
01929             }
01930 
01931             <span class="comment">//</span>
01932             <span class="comment">//  The next run starts with the remaining clear bits in the</span>
01933             <span class="comment">//  current byte.  We set this up before we check inside the</span>
01934             <span class="comment">//  current byte for a longer run, because the latter test</span>
01935             <span class="comment">//  might require extra work.</span>
01936             <span class="comment">//</span>
01937 
01938             CurrentRunSize = <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a21">RtlpBitsClearHigh</a>[ CurrentByte ];
01939             CurrentRunIndex = (CurrentByteIndex * 8) + (8 - CurrentRunSize);
01940 
01941             <span class="comment">//</span>
01942             <span class="comment">//  Set the low and high bits, otherwise we'll wind up thinking that we have a</span>
01943             <span class="comment">//  small run that needs to get added to the array, but these bits have</span>
01944             <span class="comment">//  just been accounting for</span>
01945             <span class="comment">//</span>
01946 
01947             CurrentByte |= <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a23">FillMask</a>[<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a20">RtlpBitsClearLow</a>[CurrentByte]] |
01948                            <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a24">ZeroMask</a>[8-<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a21">RtlpBitsClearHigh</a>[CurrentByte]];
01949 
01950             <span class="comment">//</span>
01951             <span class="comment">//  Check if the current byte contains a run inside of it that</span>
01952             <span class="comment">//  should go into the output array.  There may be multiple</span>
01953             <span class="comment">//  runs in the byte that we need to insert.</span>
01954             <span class="comment">//</span>
01955 
01956             <span class="keywordflow">while</span> ((CurrentByte != 0xff)
01957 
01958                         &amp;&amp;
01959 
01960                    ((RunIndex &lt; SizeOfRunArray) ||
01961                     (RunArray[RunIndex-1].NumberOfBits &lt; (ULONG)<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a19">RtlpBitsClearAnywhere</a>[CurrentByte]))) {
01962 
01963                 TempNumber = <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a19">RtlpBitsClearAnywhere</a>[CurrentByte];
01964 
01965                 <span class="comment">//</span>
01966                 <span class="comment">//  Somewhere in the current byte is a run to be inserted of</span>
01967                 <span class="comment">//  size TempNumber.  All we need to do is find the index for this run.</span>
01968                 <span class="comment">//</span>
01969 
01970                 BitMask = <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a23">FillMask</a>[ TempNumber ];
01971 
01972                 <span class="keywordflow">for</span> (i = 0; (BitMask &amp; CurrentByte) != 0; i += 1) {
01973 
01974                     BitMask &lt;&lt;= 1;
01975                 }
01976 
01977                 <span class="comment">//</span>
01978                 <span class="comment">//  If necessary increment the RunIndex and shift over the output</span>
01979                 <span class="comment">//  array until we find the slot where the new run belongs.  We only</span>
01980                 <span class="comment">//  do the shifting if we're returning longest runs.</span>
01981                 <span class="comment">//</span>
01982 
01983                 <span class="keywordflow">if</span> (RunIndex &lt; SizeOfRunArray) { RunIndex += 1; }
01984 
01985                 <span class="keywordflow">for</span> (j = RunIndex-2; LocateLongestRuns &amp;&amp; (j &gt;= 0) &amp;&amp; (RunArray[j].NumberOfBits &lt; TempNumber); j -= 1) {
01986 
01987                     RunArray[j+1] = RunArray[j];
01988                 }
01989 
01990                 RunArray[j+1].NumberOfBits = TempNumber;
01991                 RunArray[j+1].StartingIndex = (CurrentByteIndex * 8) + i;
01992 
01993 <span class="preprocessor">#if DBG</span>
01994 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (NtfsDebugIt) { <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"%d: %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"</span>,
01995                     __LINE__,RunIndex,CurrentRunSize,CurrentRunIndex,CurrentByteIndex,CurrentByte,j,RunArray[j+1].NumberOfBits,RunArray[j+1].StartingIndex); }
01996 <span class="preprocessor">#endif</span>
01997 <span class="preprocessor"></span>
01998                 <span class="comment">//</span>
01999                 <span class="comment">//  Now if the array is full and we are not doing longest runs return</span>
02000                 <span class="comment">//  to our caller</span>
02001                 <span class="comment">//</span>
02002 
02003                 <span class="keywordflow">if</span> (!LocateLongestRuns &amp;&amp; (RunIndex &gt;= SizeOfRunArray)) {
02004 
02005                     <span class="keywordflow">return</span> RunIndex;
02006                 }
02007 
02008                 <span class="comment">//</span>
02009                 <span class="comment">//  Mask out the bits and look for another run in the current byte</span>
02010                 <span class="comment">//</span>
02011 
02012                 CurrentByte |= BitMask;
02013             }
02014 
02015         <span class="comment">//</span>
02016         <span class="comment">//  Otherwise the current byte is all zeros and</span>
02017         <span class="comment">//  we simply continue with the current run</span>
02018         <span class="comment">//</span>
02019 
02020         } <span class="keywordflow">else</span> {
02021 
02022             CurrentRunSize += 8;
02023         }
02024     }
02025 
02026 <span class="preprocessor">#if DBG</span>
02027 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (NtfsDebugIt) { <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"%d: %08lx %08lx %08lx %08lx %08lx\n"</span>,__LINE__,RunIndex,CurrentRunSize,CurrentRunIndex,CurrentByteIndex,CurrentByte); }
02028 <span class="preprocessor">#endif</span>
02029 <span class="preprocessor"></span>
02030     <span class="comment">//</span>
02031     <span class="comment">//  See if we finished looking over the bitmap with an open current</span>
02032     <span class="comment">//  run that should be inserted in the output array</span>
02033     <span class="comment">//</span>
02034 
02035     <span class="keywordflow">if</span> (CurrentRunSize &gt; 0) {
02036 
02037         <span class="keywordflow">if</span> ((RunIndex &lt; SizeOfRunArray) ||
02038             (RunArray[RunIndex-1].NumberOfBits &lt; CurrentRunSize)) {
02039 
02040             <span class="comment">//</span>
02041             <span class="comment">//  If necessary increment the RunIndex and shift over the output</span>
02042             <span class="comment">//  array until we find the slot where the new run belongs.</span>
02043             <span class="comment">//</span>
02044 
02045             <span class="keywordflow">if</span> (RunIndex &lt; SizeOfRunArray) { RunIndex += 1; }
02046 
02047             <span class="keywordflow">for</span> (j = RunIndex-2; LocateLongestRuns &amp;&amp; (j &gt;= 0) &amp;&amp; (RunArray[j].NumberOfBits &lt; CurrentRunSize); j -= 1) {
02048 
02049                 RunArray[j+1] = RunArray[j];
02050             }
02051 
02052             RunArray[j+1].NumberOfBits = CurrentRunSize;
02053             RunArray[j+1].StartingIndex = CurrentRunIndex;
02054 
02055 <span class="preprocessor">#if DBG</span>
02056 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (NtfsDebugIt) { <a class="code" href="../../d6/d6/memprint_8h.html#a7">DbgPrint</a>(<span class="stringliteral">"%d: %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"</span>,
02057                 __LINE__,RunIndex,CurrentRunSize,CurrentRunIndex,CurrentByteIndex,CurrentByte,j,RunArray[j+1].NumberOfBits,RunArray[j+1].StartingIndex); }
02058 <span class="preprocessor">#endif</span>
02059 <span class="preprocessor"></span>        }
02060     }
02061 
02062     <span class="comment">//</span>
02063     <span class="comment">//  Return to our caller</span>
02064     <span class="comment">//</span>
02065 
02066     <span class="keywordflow">return</span> RunIndex;
02067 }
02068 
02069 
02070 ULONG
<a name="l02071"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a36">02071</a> <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a36">RtlFindLongestRunClear</a> (
02072     IN PRTL_BITMAP BitMapHeader,
02073     OUT PULONG StartingIndex
02074     )
02075 
02076 <span class="comment">/*++</span>
02077 <span class="comment"></span>
02078 <span class="comment">Routine Description:</span>
02079 <span class="comment"></span>
02080 <span class="comment">    This procedure finds the largest contiguous range of clear bits</span>
02081 <span class="comment">    within the specified bit map.</span>
02082 <span class="comment"></span>
02083 <span class="comment">Arguments:</span>
02084 <span class="comment"></span>
02085 <span class="comment">    BitMapHeader - Supplies a pointer to the previously initialized BitMap.</span>
02086 <span class="comment"></span>
02087 <span class="comment">    StartingIndex - Receives the index (zero based) of the first run</span>
02088 <span class="comment">        equal to the longest run of clear bits in the BitMap.</span>
02089 <span class="comment"></span>
02090 <span class="comment">Return Value:</span>
02091 <span class="comment"></span>
02092 <span class="comment">    ULONG - Receives the number of bits contained in the largest contiguous</span>
02093 <span class="comment">        run of clear bits.</span>
02094 <span class="comment"></span>
02095 <span class="comment">--*/</span>
02096 
02097 {
02098     RTL_BITMAP_RUN RunArray[1];
02099 
02100     <span class="comment">//</span>
02101     <span class="comment">//  Locate the longest run in the bitmap.  If there is one then</span>
02102     <span class="comment">//  return that run otherwise return the error condition.</span>
02103     <span class="comment">//</span>
02104 
02105     <span class="keywordflow">if</span> (<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a35">RtlFindClearRuns</a>( <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>, RunArray, 1, <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a> ) == 1) {
02106 
02107         *StartingIndex = RunArray[0].StartingIndex;
02108         <span class="keywordflow">return</span> RunArray[0].NumberOfBits;
02109     }
02110 
02111     *StartingIndex = 0;
02112     <span class="keywordflow">return</span> 0;
02113 }
02114 
02115 
02116 ULONG
<a name="l02117"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a37">02117</a> <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a37">RtlFindFirstRunClear</a> (
02118     IN PRTL_BITMAP BitMapHeader,
02119     OUT PULONG StartingIndex
02120     )
02121 
02122 <span class="comment">/*++</span>
02123 <span class="comment"></span>
02124 <span class="comment">Routine Description:</span>
02125 <span class="comment"></span>
02126 <span class="comment">    This procedure finds the first contiguous range of clear bits</span>
02127 <span class="comment">    within the specified bit map.</span>
02128 <span class="comment"></span>
02129 <span class="comment">Arguments:</span>
02130 <span class="comment"></span>
02131 <span class="comment">    BitMapHeader - Supplies a pointer to the previously initialized BitMap.</span>
02132 <span class="comment"></span>
02133 <span class="comment">    StartingIndex - Receives the index (zero based) of the first run</span>
02134 <span class="comment">        equal to the longest run of clear bits in the BitMap.</span>
02135 <span class="comment"></span>
02136 <span class="comment">Return Value:</span>
02137 <span class="comment"></span>
02138 <span class="comment">    ULONG - Receives the number of bits contained in the first contiguous</span>
02139 <span class="comment">        run of clear bits.</span>
02140 <span class="comment"></span>
02141 <span class="comment">--*/</span>
02142 
02143 {
02144     <span class="keywordflow">return</span> <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a42">RtlFindNextForwardRunClear</a>(<a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>, 0, StartingIndex);
02145 }
02146 
02147 
02148 ULONG
<a name="l02149"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a38">02149</a> <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a38">RtlNumberOfClearBits</a> (
02150     IN PRTL_BITMAP BitMapHeader
02151     )
02152 
02153 <span class="comment">/*++</span>
02154 <span class="comment"></span>
02155 <span class="comment">Routine Description:</span>
02156 <span class="comment"></span>
02157 <span class="comment">    This procedure counts and returns the number of clears bits within</span>
02158 <span class="comment">    the specified bitmap.</span>
02159 <span class="comment"></span>
02160 <span class="comment">Arguments:</span>
02161 <span class="comment"></span>
02162 <span class="comment">    BitMapHeader - Supplies a pointer to the previously initialized bitmap.</span>
02163 <span class="comment"></span>
02164 <span class="comment">Return Value:</span>
02165 <span class="comment"></span>
02166 <span class="comment">    ULONG - The total number of clear bits in the bitmap</span>
02167 <span class="comment"></span>
02168 <span class="comment">--*/</span>
02169 
02170 {
02171     ULONG SizeOfBitMap;
02172     ULONG SizeInBytes;
02173 
02174     ULONG i;
02175     UCHAR CurrentByte;
02176 
02177     ULONG TotalClear;
02178 
02179     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a2">GET_BYTE_DECLARATIONS</a>();
02180 
02181     <span class="comment">//</span>
02182     <span class="comment">//  Reference the bitmap header to make the loop run faster</span>
02183     <span class="comment">//</span>
02184 
02185     SizeOfBitMap = <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;SizeOfBitMap;
02186     SizeInBytes = (SizeOfBitMap + 7) / 8;
02187 
02188     <span class="comment">//</span>
02189     <span class="comment">//  Set any unused bits in the last byte so we don't count them.  We</span>
02190     <span class="comment">//  do this by first checking if there are any odd bits in the last byte</span>
02191     <span class="comment">//</span>
02192 
02193     <span class="keywordflow">if</span> ((SizeOfBitMap % 8) != 0) {
02194 
02195         <span class="comment">//</span>
02196         <span class="comment">//  The last byte has some odd bits so we'll set the high unused</span>
02197         <span class="comment">//  bits in the last byte to 1's</span>
02198         <span class="comment">//</span>
02199 
02200         ((PUCHAR)<a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;Buffer)[SizeInBytes - 1] |=
02201                                                     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a24">ZeroMask</a>[SizeOfBitMap % 8];
02202     }
02203 
02204     <span class="comment">//</span>
02205     <span class="comment">//  Set if up so we can use the GET_BYTE macro</span>
02206     <span class="comment">//</span>
02207 
02208     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a3">GET_BYTE_INITIALIZATION</a>( <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>, 0 );
02209 
02210     <span class="comment">//</span>
02211     <span class="comment">//  Examine every byte in the bitmap</span>
02212     <span class="comment">//</span>
02213 
02214     TotalClear = 0;
02215     <span class="keywordflow">for</span> (i = 0; i &lt; SizeInBytes; i += 1) {
02216 
02217         <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a4">GET_BYTE</a>( CurrentByte );
02218 
02219         TotalClear += <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a22">RtlpBitsClearTotal</a>[CurrentByte];
02220     }
02221 
02222     <span class="keywordflow">return</span> TotalClear;
02223 }
02224 
02225 
02226 ULONG
<a name="l02227"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a39">02227</a> <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a39">RtlNumberOfSetBits</a> (
02228     IN PRTL_BITMAP BitMapHeader
02229     )
02230 
02231 <span class="comment">/*++</span>
02232 <span class="comment"></span>
02233 <span class="comment">Routine Description:</span>
02234 <span class="comment"></span>
02235 <span class="comment">    This procedure counts and returns the number of set bits within</span>
02236 <span class="comment">    the specified bitmap.</span>
02237 <span class="comment"></span>
02238 <span class="comment">Arguments:</span>
02239 <span class="comment"></span>
02240 <span class="comment">    BitMapHeader - Supplies a pointer to the previously initialized bitmap.</span>
02241 <span class="comment"></span>
02242 <span class="comment">Return Value:</span>
02243 <span class="comment"></span>
02244 <span class="comment">    ULONG - The total number of set bits in the bitmap</span>
02245 <span class="comment"></span>
02246 <span class="comment">--*/</span>
02247 
02248 {
02249     ULONG SizeOfBitMap;
02250     ULONG SizeInBytes;
02251 
02252     ULONG i;
02253     UCHAR CurrentByte;
02254 
02255     ULONG TotalSet;
02256 
02257     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a2">GET_BYTE_DECLARATIONS</a>();
02258 
02259     <span class="comment">//</span>
02260     <span class="comment">//  Reference the bitmap header to make the loop run faster</span>
02261     <span class="comment">//</span>
02262 
02263     SizeOfBitMap = <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;SizeOfBitMap;
02264     SizeInBytes = (SizeOfBitMap + 7) / 8;
02265 
02266     <span class="comment">//</span>
02267     <span class="comment">//  Clear any unused bits in the last byte so we don't count them.  We</span>
02268     <span class="comment">//  do this by first checking if there are any odd bits in the last byte</span>
02269     <span class="comment">//</span>
02270 
02271     <span class="keywordflow">if</span> ((SizeOfBitMap % 8) != 0) {
02272 
02273         <span class="comment">//</span>
02274         <span class="comment">//  The last byte has some odd bits so we'll set the high unused</span>
02275         <span class="comment">//  bits in the last byte to 0's</span>
02276         <span class="comment">//</span>
02277 
02278         ((PUCHAR)<a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;Buffer)[SizeInBytes - 1] &amp;=
02279                                                     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a23">FillMask</a>[SizeOfBitMap % 8];
02280     }
02281 
02282     <span class="comment">//</span>
02283     <span class="comment">//  Set if up so we can use the GET_BYTE macro</span>
02284     <span class="comment">//</span>
02285 
02286     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a3">GET_BYTE_INITIALIZATION</a>( <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>, 0 );
02287 
02288     <span class="comment">//</span>
02289     <span class="comment">//  Examine every byte in the bitmap</span>
02290     <span class="comment">//</span>
02291 
02292     TotalSet = 0;
02293     <span class="keywordflow">for</span> (i = 0; i &lt; SizeInBytes; i += 1) {
02294 
02295         <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a4">GET_BYTE</a>( CurrentByte );
02296 
02297         TotalSet += <a class="code" href="../../d5/d9/ntrtlp_8h.html#a3">RtlpBitsSetTotal</a>(CurrentByte);
02298     }
02299 
02300     <span class="keywordflow">return</span> TotalSet;
02301 }
02302 
02303 
02304 BOOLEAN
<a name="l02305"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a40">02305</a> <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a40">RtlAreBitsClear</a> (
02306     IN PRTL_BITMAP BitMapHeader,
02307     IN ULONG StartingIndex,
02308     IN ULONG Length
02309     )
02310 
02311 <span class="comment">/*++</span>
02312 <span class="comment"></span>
02313 <span class="comment">Routine Description:</span>
02314 <span class="comment"></span>
02315 <span class="comment">    This procedure determines if the range of specified bits are all clear.</span>
02316 <span class="comment"></span>
02317 <span class="comment">Arguments:</span>
02318 <span class="comment"></span>
02319 <span class="comment">    BitMapHeader - Supplies a pointer to the previously initialized bitmap.</span>
02320 <span class="comment"></span>
02321 <span class="comment">    StartingIndex - Supplies the starting bit index to examine</span>
02322 <span class="comment"></span>
02323 <span class="comment">    Length - Supplies the number of bits to examine</span>
02324 <span class="comment"></span>
02325 <span class="comment">Return Value:</span>
02326 <span class="comment"></span>
02327 <span class="comment">    BOOLEAN - TRUE if the specified bits in the bitmap are all clear, and</span>
02328 <span class="comment">        FALSE if any are set or if the range is outside the bitmap or if</span>
02329 <span class="comment">        Length is zero.</span>
02330 <span class="comment"></span>
02331 <span class="comment">--*/</span>
02332 
02333 {
02334     ULONG SizeOfBitMap;
02335     ULONG SizeInBytes;
02336 
02337     ULONG EndingIndex;
02338 
02339     ULONG StartingByte;
02340     ULONG EndingByte;
02341 
02342     ULONG StartingOffset;
02343     ULONG EndingOffset;
02344 
02345     ULONG i;
02346     UCHAR Byte;
02347 
02348     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a2">GET_BYTE_DECLARATIONS</a>();
02349 
02350     <span class="comment">//</span>
02351     <span class="comment">//  To make the loops in our test run faster we'll extract the fields</span>
02352     <span class="comment">//  from the bitmap header</span>
02353     <span class="comment">//</span>
02354 
02355     SizeOfBitMap = <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;SizeOfBitMap;
02356     SizeInBytes = (SizeOfBitMap + 7) / 8;
02357 
02358     <span class="comment">//</span>
02359     <span class="comment">//  First make sure that the specified range is contained within the</span>
02360     <span class="comment">//  bitmap, and the length is not zero.</span>
02361     <span class="comment">//</span>
02362 
02363     <span class="keywordflow">if</span> ((StartingIndex + Length &gt; SizeOfBitMap) || (Length == 0)) {
02364 
02365         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02366     }
02367 
02368     <span class="comment">//</span>
02369     <span class="comment">//  Compute the ending index, starting and ending byte, and the starting</span>
02370     <span class="comment">//  and ending offset within each byte</span>
02371     <span class="comment">//</span>
02372 
02373     EndingIndex = StartingIndex + Length - 1;
02374 
02375     StartingByte = StartingIndex / 8;
02376     EndingByte = EndingIndex / 8;
02377 
02378     StartingOffset = StartingIndex % 8;
02379     EndingOffset = EndingIndex % 8;
02380 
02381     <span class="comment">//</span>
02382     <span class="comment">//  Set ourselves up to get the next byte</span>
02383     <span class="comment">//</span>
02384 
02385     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a3">GET_BYTE_INITIALIZATION</a>( <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>, StartingByte );
02386 
02387     <span class="comment">//</span>
02388     <span class="comment">//  Special case the situation where the starting byte and ending</span>
02389     <span class="comment">//  byte are one in the same</span>
02390     <span class="comment">//</span>
02391 
02392     <span class="keywordflow">if</span> (StartingByte == EndingByte) {
02393 
02394         <span class="comment">//</span>
02395         <span class="comment">//  Get the single byte we are to look at</span>
02396         <span class="comment">//</span>
02397 
02398         <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a4">GET_BYTE</a>( Byte );
02399 
02400         <span class="comment">//</span>
02401         <span class="comment">//  Now we compute the mask of bits we're after and then AND it with</span>
02402         <span class="comment">//  the byte.  If it is zero then the bits in question are all clear</span>
02403         <span class="comment">//  otherwise at least one of them is set.</span>
02404         <span class="comment">//</span>
02405 
02406         <span class="keywordflow">if</span> ((<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a24">ZeroMask</a>[StartingOffset] &amp; <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a23">FillMask</a>[EndingOffset+1] &amp; Byte) == 0) {
02407 
02408             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02409 
02410         } <span class="keywordflow">else</span> {
02411 
02412             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02413         }
02414 
02415     } <span class="keywordflow">else</span> {
02416 
02417         <span class="comment">//</span>
02418         <span class="comment">//  Get the first byte that we're after, and then</span>
02419         <span class="comment">//  compute the mask of bits we're after for the first byte then</span>
02420         <span class="comment">//  AND it with the byte itself.</span>
02421         <span class="comment">//</span>
02422 
02423         <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a4">GET_BYTE</a>( Byte );
02424 
02425         <span class="keywordflow">if</span> ((<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a24">ZeroMask</a>[StartingOffset] &amp; Byte) != 0) {
02426 
02427             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02428         }
02429 
02430         <span class="comment">//</span>
02431         <span class="comment">//  Now for every whole byte inbetween read in the byte,</span>
02432         <span class="comment">//  and make sure it is all zeros</span>
02433         <span class="comment">//</span>
02434 
02435         <span class="keywordflow">for</span> (i = StartingByte+1; i &lt; EndingByte; i += 1) {
02436 
02437             <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a4">GET_BYTE</a>( Byte );
02438 
02439             <span class="keywordflow">if</span> (Byte != 0) {
02440 
02441                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02442             }
02443         }
02444 
02445         <span class="comment">//</span>
02446         <span class="comment">//  Get the last byte we're after, and then</span>
02447         <span class="comment">//  compute the mask of bits we're after for the last byte then</span>
02448         <span class="comment">//  AND it with the byte itself.</span>
02449         <span class="comment">//</span>
02450 
02451         <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a4">GET_BYTE</a>( Byte );
02452 
02453         <span class="keywordflow">if</span> ((<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a23">FillMask</a>[EndingOffset+1] &amp; Byte) != 0) {
02454 
02455             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02456         }
02457     }
02458 
02459     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02460 }
02461 
02462 
02463 BOOLEAN
<a name="l02464"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a41">02464</a> <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a41">RtlAreBitsSet</a> (
02465     IN PRTL_BITMAP BitMapHeader,
02466     IN ULONG StartingIndex,
02467     IN ULONG Length
02468     )
02469 
02470 <span class="comment">/*++</span>
02471 <span class="comment"></span>
02472 <span class="comment">Routine Description:</span>
02473 <span class="comment"></span>
02474 <span class="comment">    This procedure determines if the range of specified bits are all set.</span>
02475 <span class="comment"></span>
02476 <span class="comment">Arguments:</span>
02477 <span class="comment"></span>
02478 <span class="comment">    BitMapHeader - Supplies a pointer to the previously initialized bitmap.</span>
02479 <span class="comment"></span>
02480 <span class="comment">    StartingIndex - Supplies the starting bit index to examine</span>
02481 <span class="comment"></span>
02482 <span class="comment">    Length - Supplies the number of bits to examine</span>
02483 <span class="comment"></span>
02484 <span class="comment">Return Value:</span>
02485 <span class="comment"></span>
02486 <span class="comment">    BOOLEAN - TRUE if the specified bits in the bitmap are all set, and</span>
02487 <span class="comment">        FALSE if any are clear or if the range is outside the bitmap or if</span>
02488 <span class="comment">        Length is zero.</span>
02489 <span class="comment"></span>
02490 <span class="comment">--*/</span>
02491 
02492 {
02493     ULONG SizeOfBitMap;
02494     ULONG SizeInBytes;
02495 
02496     ULONG EndingIndex;
02497 
02498     ULONG StartingByte;
02499     ULONG EndingByte;
02500 
02501     ULONG StartingOffset;
02502     ULONG EndingOffset;
02503 
02504     ULONG i;
02505     UCHAR Byte;
02506 
02507     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a2">GET_BYTE_DECLARATIONS</a>();
02508 
02509     <span class="comment">//</span>
02510     <span class="comment">//  To make the loops in our test run faster we'll extract the fields</span>
02511     <span class="comment">//  from the bitmap header</span>
02512     <span class="comment">//</span>
02513 
02514     SizeOfBitMap = <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;SizeOfBitMap;
02515     SizeInBytes = (SizeOfBitMap + 7) / 8;
02516 
02517     <span class="comment">//</span>
02518     <span class="comment">//  First make sure that the specified range is contained within the</span>
02519     <span class="comment">//  bitmap, and the length is not zero.</span>
02520     <span class="comment">//</span>
02521 
02522     <span class="keywordflow">if</span> ((StartingIndex + Length &gt; SizeOfBitMap) || (Length == 0)) {
02523 
02524         <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02525     }
02526 
02527     <span class="comment">//</span>
02528     <span class="comment">//  Compute the ending index, starting and ending byte, and the starting</span>
02529     <span class="comment">//  and ending offset within each byte</span>
02530     <span class="comment">//</span>
02531 
02532     EndingIndex = StartingIndex + Length - 1;
02533 
02534     StartingByte = StartingIndex / 8;
02535     EndingByte = EndingIndex / 8;
02536 
02537     StartingOffset = StartingIndex % 8;
02538     EndingOffset = EndingIndex % 8;
02539 
02540     <span class="comment">//</span>
02541     <span class="comment">//  Set ourselves up to get the next byte</span>
02542     <span class="comment">//</span>
02543 
02544     <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a3">GET_BYTE_INITIALIZATION</a>( <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>, StartingByte );
02545 
02546     <span class="comment">//</span>
02547     <span class="comment">//  Special case the situation where the starting byte and ending</span>
02548     <span class="comment">//  byte are one in the same</span>
02549     <span class="comment">//</span>
02550 
02551     <span class="keywordflow">if</span> (StartingByte == EndingByte) {
02552 
02553         <span class="comment">//</span>
02554         <span class="comment">//  Get the single byte we are to look at</span>
02555         <span class="comment">//</span>
02556 
02557         <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a4">GET_BYTE</a>( Byte );
02558 
02559         <span class="comment">//</span>
02560         <span class="comment">//  Now we compute the mask of bits we're after and then AND it with</span>
02561         <span class="comment">//  the complement of the byte If it is zero then the bits in question</span>
02562         <span class="comment">//  are all clear otherwise at least one of them is clear.</span>
02563         <span class="comment">//</span>
02564 
02565         <span class="keywordflow">if</span> ((<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a24">ZeroMask</a>[StartingOffset] &amp; <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a23">FillMask</a>[EndingOffset+1] &amp; ~Byte) == 0) {
02566 
02567             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02568 
02569         } <span class="keywordflow">else</span> {
02570 
02571             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02572         }
02573 
02574     } <span class="keywordflow">else</span> {
02575 
02576         <span class="comment">//</span>
02577         <span class="comment">//  Get the first byte that we're after, and then</span>
02578         <span class="comment">//  compute the mask of bits we're after for the first byte then</span>
02579         <span class="comment">//  AND it with the complement of the byte itself.</span>
02580         <span class="comment">//</span>
02581 
02582         <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a4">GET_BYTE</a>( Byte );
02583 
02584         <span class="keywordflow">if</span> ((<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a24">ZeroMask</a>[StartingOffset] &amp; ~Byte) != 0) {
02585 
02586             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02587         }
02588 
02589         <span class="comment">//</span>
02590         <span class="comment">//  Now for every whole byte inbetween read in the byte,</span>
02591         <span class="comment">//  and make sure it is all ones</span>
02592         <span class="comment">//</span>
02593 
02594         <span class="keywordflow">for</span> (i = StartingByte+1; i &lt; EndingByte; i += 1) {
02595 
02596             <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a4">GET_BYTE</a>( Byte );
02597 
02598             <span class="keywordflow">if</span> (Byte != 0xff) {
02599 
02600                 <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02601             }
02602         }
02603 
02604         <span class="comment">//</span>
02605         <span class="comment">//  Get the last byte we're after, and then</span>
02606         <span class="comment">//  compute the mask of bits we're after for the last byte then</span>
02607         <span class="comment">//  AND it with the complement of the byte itself.</span>
02608         <span class="comment">//</span>
02609 
02610         <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a4">GET_BYTE</a>( Byte );
02611 
02612         <span class="keywordflow">if</span> ((<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a23">FillMask</a>[EndingOffset+1] &amp; ~Byte) != 0) {
02613 
02614             <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a457">FALSE</a>;
02615         }
02616     }
02617 
02618     <span class="keywordflow">return</span> <a class="code" href="../../d6/d7/halmips_8h.html#a458">TRUE</a>;
02619 }
02620 
<a name="l02621"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a25">02621</a> <span class="keyword">static</span> CONST ULONG <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a25">FillMaskUlong</a>[] = {
02622     0x00000000, 0x00000001, 0x00000003, 0x00000007,
02623     0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f,
02624     0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff,
02625     0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff,
02626     0x0000ffff, 0x0001ffff, 0x0003ffff, 0x0007ffff,
02627     0x000fffff, 0x001fffff, 0x003fffff, 0x007fffff,
02628     0x00ffffff, 0x01ffffff, 0x03ffffff, 0x07ffffff,
02629     0x0fffffff, 0x1fffffff, 0x3fffffff, 0x7fffffff,
02630     0xffffffff
02631 };
02632 
02633 
02634 ULONG
<a name="l02635"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a42">02635</a> <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a42">RtlFindNextForwardRunClear</a> (
02636     IN PRTL_BITMAP BitMapHeader,
02637     IN ULONG FromIndex,
02638     IN PULONG StartingRunIndex
02639     )
02640 {
02641     ULONG <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a>;
02642     ULONG <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a>;
02643     PULONG PHunk, BitMapEnd;
02644     ULONG Hunk;
02645 
02646     <span class="comment">//</span>
02647     <span class="comment">// Take care of the boundary case of the null bitmap</span>
02648     <span class="comment">//</span>
02649 
02650     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;SizeOfBitMap == 0) {
02651 
02652         *StartingRunIndex = FromIndex;
02653         <span class="keywordflow">return</span> 0;
02654     }
02655 
02656     <span class="comment">//</span>
02657     <span class="comment">//  Compute the last word address in the bitmap</span>
02658     <span class="comment">//</span>
02659 
02660     BitMapEnd = <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;Buffer + ((<a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;SizeOfBitMap - 1) / 32);
02661 
02662     <span class="comment">//</span>
02663     <span class="comment">//  Scan forward for the first clear bit</span>
02664     <span class="comment">//</span>
02665 
02666     <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a> = FromIndex;
02667 
02668     <span class="comment">//</span>
02669     <span class="comment">//  Build pointer to the ULONG word in the bitmap</span>
02670     <span class="comment">//  containing the Start bit</span>
02671     <span class="comment">//</span>
02672 
02673     PHunk = <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;Buffer + (<a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a> / 32);
02674 
02675     <span class="comment">//</span>
02676     <span class="comment">//  If the first subword is set then we can proceed to</span>
02677     <span class="comment">//  take big steps in the bitmap since we are now ULONG</span>
02678     <span class="comment">//  aligned in the search. Make sure we aren't improperly</span>
02679     <span class="comment">//  looking at the last word in the bitmap.</span>
02680     <span class="comment">//</span>
02681 
02682     <span class="keywordflow">if</span> (PHunk != BitMapEnd) {
02683 
02684         <span class="comment">//</span>
02685         <span class="comment">//  Read in the bitmap hunk. Set the previous bits in this word.</span>
02686         <span class="comment">//</span>
02687 
02688         Hunk = *PHunk | <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a25">FillMaskUlong</a>[<a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a> % 32];
02689 
02690         <span class="keywordflow">if</span> (Hunk == (ULONG)~0) {
02691 
02692             <span class="comment">//</span>
02693             <span class="comment">//  Adjust the pointers forward</span>
02694             <span class="comment">//</span>
02695 
02696             <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a> += 32 - (<a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a> % 32);
02697             PHunk++;
02698 
02699             <span class="keywordflow">while</span> ( PHunk &lt; BitMapEnd ) {
02700 
02701                 <span class="comment">//</span>
02702                 <span class="comment">//  Stop at first word with unset bits</span>
02703                 <span class="comment">//</span>
02704 
02705                 <span class="keywordflow">if</span> (*PHunk != (ULONG)~0) <span class="keywordflow">break</span>;
02706 
02707                 PHunk++;
02708                 <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a> += 32;
02709             }
02710         }
02711     }
02712 
02713     <span class="comment">//</span>
02714     <span class="comment">//  Bitwise search forward for the clear bit</span>
02715     <span class="comment">//</span>
02716 
02717     <span class="keywordflow">while</span> ((<a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a> &lt; <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;SizeOfBitMap) &amp;&amp; (RtlCheckBit( <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>, <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a> ) == 1)) { <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a> += 1; }
02718 
02719     <span class="comment">//</span>
02720     <span class="comment">//  Scan forward for the first set bit</span>
02721     <span class="comment">//</span>
02722 
02723     <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a> = <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a>;
02724 
02725     <span class="comment">//</span>
02726     <span class="comment">//  If we aren't in the last word of the bitmap we may be</span>
02727     <span class="comment">//  able to keep taking big steps</span>
02728     <span class="comment">//</span>
02729 
02730     <span class="keywordflow">if</span> (PHunk != BitMapEnd) {
02731 
02732         <span class="comment">//</span>
02733         <span class="comment">//  We know that the clear bit was in the last word we looked at,</span>
02734         <span class="comment">//  so continue from there to find the next set bit, clearing the</span>
02735         <span class="comment">//  previous bits in the word</span>
02736         <span class="comment">//</span>
02737 
02738         Hunk = *PHunk &amp; ~<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a25">FillMaskUlong</a>[<a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a> % 32];
02739 
02740         <span class="keywordflow">if</span> (Hunk == (ULONG)0) {
02741 
02742             <span class="comment">//</span>
02743             <span class="comment">//  Adjust the pointers forward</span>
02744             <span class="comment">//</span>
02745 
02746             <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a> += 32 - (<a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a> % 32);
02747             PHunk++;
02748 
02749             <span class="keywordflow">while</span> ( PHunk &lt; BitMapEnd ) {
02750 
02751                 <span class="comment">//</span>
02752                 <span class="comment">//  Stop at first word with set bits</span>
02753                 <span class="comment">//</span>
02754 
02755                 <span class="keywordflow">if</span> (*PHunk != (ULONG)0) <span class="keywordflow">break</span>;
02756 
02757                 PHunk++;
02758                 <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a> += 32;
02759             }
02760         }
02761     }
02762 
02763     <span class="comment">//</span>
02764     <span class="comment">//  Bitwise search forward for the set bit</span>
02765     <span class="comment">//</span>
02766 
02767     <span class="keywordflow">while</span> ((<a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a> &lt; <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;SizeOfBitMap) &amp;&amp; (RtlCheckBit( <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>, <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a> ) == 0)) { <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a> += 1; }
02768 
02769     <span class="comment">//</span>
02770     <span class="comment">//  Compute the index and return the length</span>
02771     <span class="comment">//</span>
02772 
02773     *StartingRunIndex = <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a>;
02774     <span class="keywordflow">return</span> (<a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a> - <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a>);
02775 }
02776 
02777 
02778 ULONG
<a name="l02779"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a43">02779</a> <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a43">RtlFindLastBackwardRunClear</a> (
02780     IN PRTL_BITMAP BitMapHeader,
02781     IN ULONG FromIndex,
02782     IN PULONG StartingRunIndex
02783     )
02784 {
02785     ULONG <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a>;
02786     ULONG <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a>;
02787     PULONG PHunk;
02788     ULONG Hunk;
02789 
02790     <a class="code" href="../../d5/d9/ntrtlp_8h.html#a12">RTL_PAGED_CODE</a>();
02791 
02792     <span class="comment">//</span>
02793     <span class="comment">//  Take care of the boundary case of the null bitmap</span>
02794     <span class="comment">//</span>
02795 
02796     <span class="keywordflow">if</span> (<a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;SizeOfBitMap == 0) {
02797 
02798         *StartingRunIndex = FromIndex;
02799         <span class="keywordflow">return</span> 0;
02800     }
02801 
02802     <span class="comment">//</span>
02803     <span class="comment">//  Scan backwards for the first clear bit</span>
02804     <span class="comment">//</span>
02805 
02806     <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a> = FromIndex;
02807 
02808     <span class="comment">//</span>
02809     <span class="comment">//  Build pointer to the ULONG word in the bitmap</span>
02810     <span class="comment">//  containing the End bit, then read in the bitmap</span>
02811     <span class="comment">//  hunk. Set the rest of the bits in this word, NOT</span>
02812     <span class="comment">//  inclusive of the FromIndex bit.</span>
02813     <span class="comment">//</span>
02814 
02815     PHunk = <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;Buffer + (<a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a> / 32);
02816     Hunk = *PHunk | ~<a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a25">FillMaskUlong</a>[(<a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a> % 32) + 1];
02817 
02818     <span class="comment">//</span>
02819     <span class="comment">//  If the first subword is set then we can proceed to</span>
02820     <span class="comment">//  take big steps in the bitmap since we are now ULONG</span>
02821     <span class="comment">//  aligned in the search</span>
02822     <span class="comment">//</span>
02823 
02824     <span class="keywordflow">if</span> (Hunk == (ULONG)~0) {
02825 
02826         <span class="comment">//</span>
02827         <span class="comment">//  Adjust the pointers backwards</span>
02828         <span class="comment">//</span>
02829 
02830         <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a> -= (<a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a> % 32) + 1;
02831         PHunk--;
02832 
02833         <span class="keywordflow">while</span> ( PHunk &gt; <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;Buffer ) {
02834 
02835             <span class="comment">//</span>
02836             <span class="comment">//  Stop at first word with set bits</span>
02837             <span class="comment">//</span>
02838 
02839             <span class="keywordflow">if</span> (*PHunk != (ULONG)~0) <span class="keywordflow">break</span>;
02840 
02841             PHunk--;
02842             <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a> -= 32;
02843         }
02844     }
02845 
02846     <span class="comment">//</span>
02847     <span class="comment">//  Bitwise search backward for the clear bit</span>
02848     <span class="comment">//</span>
02849 
02850     <span class="keywordflow">while</span> ((<a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a> != MAXULONG) &amp;&amp; (RtlCheckBit( <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>, <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a> ) == 1)) { <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a> -= 1; }
02851 
02852     <span class="comment">//</span>
02853     <span class="comment">//  Scan backwards for the first set bit</span>
02854     <span class="comment">//</span>
02855 
02856     <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a> = <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a>;
02857 
02858     <span class="comment">//</span>
02859     <span class="comment">//  We know that the clear bit was in the last word we looked at,</span>
02860     <span class="comment">//  so continue from there to find the next set bit, clearing the</span>
02861     <span class="comment">//  previous bits in the word.</span>
02862     <span class="comment">//</span>
02863 
02864     Hunk = *PHunk &amp; <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a25">FillMaskUlong</a>[<a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a> % 32];
02865 
02866     <span class="comment">//</span>
02867     <span class="comment">//  If the subword is unset then we can proceed in big steps</span>
02868     <span class="comment">//</span>
02869 
02870     <span class="keywordflow">if</span> (Hunk == (ULONG)0) {
02871 
02872         <span class="comment">//</span>
02873         <span class="comment">//  Adjust the pointers backward</span>
02874         <span class="comment">//</span>
02875 
02876         <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a> -= (<a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a> % 32) + 1;
02877         PHunk--;
02878 
02879         <span class="keywordflow">while</span> ( PHunk &gt; <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>-&gt;Buffer ) {
02880 
02881             <span class="comment">//</span>
02882             <span class="comment">//  Stop at first word with set bits</span>
02883             <span class="comment">//</span>
02884 
02885             <span class="keywordflow">if</span> (*PHunk != (ULONG)0) <span class="keywordflow">break</span>;
02886 
02887             PHunk--;
02888             <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a> -= 32;
02889         }
02890     }
02891 
02892     <span class="comment">//</span>
02893     <span class="comment">//  Bitwise search backward for the set bit</span>
02894     <span class="comment">//</span>
02895 
02896     <span class="keywordflow">while</span> ((<a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a> != MAXULONG) &amp;&amp; (RtlCheckBit( <a class="code" href="../../d8/d9/tbitmap_8c.html#a1">BitMapHeader</a>, <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a> ) == 0)) { <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a> -= 1; }
02897 
02898     <span class="comment">//</span>
02899     <span class="comment">//  Compute the index and return the length</span>
02900     <span class="comment">//</span>
02901 
02902     *StartingRunIndex = <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a> + 1;
02903     <span class="keywordflow">return</span> (<a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a19">End</a> - <a class="code" href="../../d9/d1/config_2i386_2init386_8c.html#a18">Start</a>);
02904 }
02905 
<a name="l02906"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a5">02906</a> <span class="preprocessor">#define BM_4567 0xFFFFFFFF00000000UI64</span>
<a name="l02907"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a6">02907</a> <span class="preprocessor"></span><span class="preprocessor">#define BM_67   0xFFFF000000000000UI64</span>
<a name="l02908"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a7">02908</a> <span class="preprocessor"></span><span class="preprocessor">#define BM_7    0xFF00000000000000UI64</span>
<a name="l02909"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a8">02909</a> <span class="preprocessor"></span><span class="preprocessor">#define BM_5    0x0000FF0000000000UI64</span>
<a name="l02910"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a9">02910</a> <span class="preprocessor"></span><span class="preprocessor">#define BM_23   0x00000000FFFF0000UI64</span>
<a name="l02911"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a10">02911</a> <span class="preprocessor"></span><span class="preprocessor">#define BM_3    0x00000000FF000000UI64</span>
<a name="l02912"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a11">02912</a> <span class="preprocessor"></span><span class="preprocessor">#define BM_1    0x000000000000FF00UI64</span>
02913 <span class="preprocessor"></span>
<a name="l02914"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a12">02914</a> <span class="preprocessor">#define BM_0123 0x00000000FFFFFFFFUI64</span>
<a name="l02915"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a13">02915</a> <span class="preprocessor"></span><span class="preprocessor">#define BM_01   0x000000000000FFFFUI64</span>
<a name="l02916"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a14">02916</a> <span class="preprocessor"></span><span class="preprocessor">#define BM_0    0x00000000000000FFUI64</span>
<a name="l02917"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a15">02917</a> <span class="preprocessor"></span><span class="preprocessor">#define BM_2    0x0000000000FF0000UI64</span>
<a name="l02918"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a16">02918</a> <span class="preprocessor"></span><span class="preprocessor">#define BM_45   0x0000FFFF00000000UI64</span>
<a name="l02919"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a17">02919</a> <span class="preprocessor"></span><span class="preprocessor">#define BM_4    0x000000FF00000000UI64</span>
<a name="l02920"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a18">02920</a> <span class="preprocessor"></span><span class="preprocessor">#define BM_6    0x00FF000000000000UI64</span>
02921 <span class="preprocessor"></span>
02922 CCHAR
<a name="l02923"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a44">02923</a> <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a44">RtlFindMostSignificantBit</a> (
02924     IN ULONGLONG Set
02925     )
02926 <span class="comment">/*++</span>
02927 <span class="comment"></span>
02928 <span class="comment">Routine Description:</span>
02929 <span class="comment"></span>
02930 <span class="comment">    This procedure finds the most significant non-zero bit in Set and</span>
02931 <span class="comment">    returns it's zero-based position.</span>
02932 <span class="comment"></span>
02933 <span class="comment">Arguments:</span>
02934 <span class="comment"></span>
02935 <span class="comment">    Set - Supplies the 64-bit bitmap.</span>
02936 <span class="comment"></span>
02937 <span class="comment">Return Value:</span>
02938 <span class="comment"></span>
02939 <span class="comment">    Set != 0:</span>
02940 <span class="comment">        Bit position of the most significant set bit in Set.</span>
02941 <span class="comment"></span>
02942 <span class="comment">    Set == 0:</span>
02943 <span class="comment">        -1.</span>
02944 <span class="comment"></span>
02945 <span class="comment">--*/</span>
02946 {
02947     UCHAR index;
02948     UCHAR bitOffset;
02949     UCHAR lookup;
02950 
02951     <span class="keywordflow">if</span> ((Set &amp; <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a5">BM_4567</a>) != 0) {
02952         <span class="keywordflow">if</span> ((Set &amp; <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a6">BM_67</a>) != 0) {
02953             <span class="keywordflow">if</span> ((Set &amp; <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a7">BM_7</a>) != 0) {
02954                 bitOffset = 7 * 8;
02955             } <span class="keywordflow">else</span> {
02956                 bitOffset = 6 * 8;
02957             }
02958         } <span class="keywordflow">else</span> {
02959             <span class="keywordflow">if</span> ((Set &amp; <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a8">BM_5</a>) != 0) {
02960                 bitOffset = 5 * 8;
02961             } <span class="keywordflow">else</span> {
02962                 bitOffset = 4 * 8;
02963             }
02964         }
02965     } <span class="keywordflow">else</span> {
02966         <span class="keywordflow">if</span> ((Set &amp; <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a9">BM_23</a>) != 0) {
02967             <span class="keywordflow">if</span> ((Set &amp; <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a10">BM_3</a>) != 0) {
02968                 bitOffset = 3 * 8;
02969             } <span class="keywordflow">else</span> {
02970                 bitOffset = 2 * 8;
02971             }
02972         } <span class="keywordflow">else</span> {
02973             <span class="keywordflow">if</span> ((Set &amp; <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a11">BM_1</a>) != 0) {
02974                 bitOffset = 1 * 8;
02975             } <span class="keywordflow">else</span> {
02976 
02977                 <span class="comment">//</span>
02978                 <span class="comment">// The test for Set == 0 is postponed to here, it is expected</span>
02979                 <span class="comment">// to be rare.  Note that if we had our own version of</span>
02980                 <span class="comment">// RtlpBitsClearHigh[] we could eliminate this test entirely,</span>
02981                 <span class="comment">// reducing the average number of tests from 3.125 to 3.</span>
02982                 <span class="comment">//</span>
02983 
02984                 <span class="keywordflow">if</span> (Set == 0) {
02985                     <span class="keywordflow">return</span> -1;
02986                 }
02987 
02988                 bitOffset = 0 * 8;
02989             }
02990         }
02991     }
02992 
02993     lookup = (UCHAR)(Set &gt;&gt; bitOffset);
02994     index = (7 - <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a21">RtlpBitsClearHigh</a>[lookup]) + bitOffset;
02995     <span class="keywordflow">return</span> index;
02996 }
02997 
02998 CCHAR
<a name="l02999"></a><a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a45">02999</a> <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a45">RtlFindLeastSignificantBit</a> (
03000     IN ULONGLONG Set
03001     )
03002 <span class="comment">/*++</span>
03003 <span class="comment"></span>
03004 <span class="comment">Routine Description:</span>
03005 <span class="comment"></span>
03006 <span class="comment">    This procedure finds the least significant non-zero bit in Set and</span>
03007 <span class="comment">    returns it's zero-based position.</span>
03008 <span class="comment"></span>
03009 <span class="comment">Arguments:</span>
03010 <span class="comment"></span>
03011 <span class="comment">    Set - Supplies the 64-bit bitmap.</span>
03012 <span class="comment"></span>
03013 <span class="comment">Return Value:</span>
03014 <span class="comment"></span>
03015 <span class="comment">    Set != 0:</span>
03016 <span class="comment">        Bit position of the least significant non-zero bit in Set.</span>
03017 <span class="comment"></span>
03018 <span class="comment">    Set == 0:</span>
03019 <span class="comment">        -1.</span>
03020 <span class="comment"></span>
03021 <span class="comment">--*/</span>
03022 {
03023     UCHAR index;
03024     UCHAR bitOffset;
03025     UCHAR lookup;
03026 
03027     <span class="keywordflow">if</span> ((Set &amp; <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a12">BM_0123</a>) != 0) {
03028         <span class="keywordflow">if</span> ((Set &amp; <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a13">BM_01</a>) != 0) {
03029             <span class="keywordflow">if</span> ((Set &amp; <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a14">BM_0</a>) != 0) {
03030                 bitOffset = 0 * 8;
03031             } <span class="keywordflow">else</span> {
03032                 bitOffset = 1 * 8;
03033             }
03034         } <span class="keywordflow">else</span> {
03035             <span class="keywordflow">if</span> ((Set &amp; <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a15">BM_2</a>) != 0) {
03036                 bitOffset = 2 * 8;
03037             } <span class="keywordflow">else</span> {
03038                 bitOffset = 3 * 8;
03039             }
03040         }
03041     } <span class="keywordflow">else</span> {
03042         <span class="keywordflow">if</span> ((Set &amp; <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a16">BM_45</a>) != 0) {
03043             <span class="keywordflow">if</span> ((Set &amp; <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a17">BM_4</a>) != 0) {
03044                 bitOffset = 4 * 8;
03045             } <span class="keywordflow">else</span> {
03046                 bitOffset = 5 * 8;
03047             }
03048         } <span class="keywordflow">else</span> {
03049             <span class="keywordflow">if</span> ((Set &amp; <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a18">BM_6</a>) != 0) {
03050                 bitOffset = 6 * 8;
03051             } <span class="keywordflow">else</span> {
03052 
03053                 <span class="comment">//</span>
03054                 <span class="comment">// The test for Set == 0 is postponed to here, it is expected</span>
03055                 <span class="comment">// to be rare.  Note that if we had our own version of</span>
03056                 <span class="comment">// RtlpBitsClearHigh[] we could eliminate this test entirely,</span>
03057                 <span class="comment">// reducing the average number of tests from 3.125 to 3.</span>
03058                 <span class="comment">//</span>
03059 
03060                 <span class="keywordflow">if</span> (Set == 0) {
03061                     <span class="keywordflow">return</span> -1;
03062                 }
03063 
03064                 bitOffset = 7 * 8;
03065             }
03066         }
03067     }
03068 
03069     lookup = (UCHAR)(Set &gt;&gt; bitOffset);
03070     index = <a class="code" href="../../d4/d1/rtl_2bitmap_8c.html#a20">RtlpBitsClearLow</a>[lookup] + bitOffset;
03071     <span class="keywordflow">return</span> index;
03072 }
03073 
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Sat May 15 19:39:18 2004 for test by
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
